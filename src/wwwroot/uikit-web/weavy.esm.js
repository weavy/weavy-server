var v1 = Object.defineProperty;
var Hw = (n) => {
  throw TypeError(n);
};
var a = (n, t) => v1(n, "name", { value: t, configurable: !0 });
var Ou = (n, t, e) => t.has(n) || Hw("Cannot " + e);
var y = (n, t, e) => (Ou(n, t, "read from private field"), e ? e.call(n) : t.get(n)), O = (n, t, e) => t.has(n) ? Hw("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), _ = (n, t, e, i) => (Ou(n, t, "write to private field"), i ? i.call(n, e) : t.set(n, e), e), lt = (n, t, e) => (Ou(n, t, "access private method"), e);
var Rd = (n, t, e, i) => ({
  set _(r) {
    _(n, t, r, e);
  },
  get _() {
    return y(n, t, i);
  }
});
import { observeConnected as g1, throwOnDomNotAvailable as Pe, isDomAvailable as Xp, whenConnected as nm, whenParentsDefined as yr, defaultVisibilityCheckOptions as b1, isInShadowDom as Bw, isModifiedClick as vh, isPopoverPolyfilled as Gu, inOverlay as x1, autofocusRef as Jp, whenElementVisible as Zu, whenDocumentVisible as C1 } from "./es/editor-M1x0pxVu.js";
import { configureLocalization as $1, e as k1, i as j, i$1 as it, m as P1, b as _1, r as S1, S as M1, x as h, W as A1, E as b, w as gh, T as Nd, msg as x, localized as ht, str as gt } from "./es/locales/sv-SE-DNn-JJCG.js";
function Ud(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
a(Ud, "isObject");
function Dr(n) {
  if (Ud(n) === !1) return !1;
  const t = n.constructor;
  if (t === void 0) return !0;
  const e = t.prototype;
  return !(Ud(e) === !1 || Object.prototype.hasOwnProperty.call(e, "isPrototypeOf") === !1);
}
a(Dr, "isPlainObject$1");
function Yu(n) {
  return typeof n.toJSON == "function";
}
a(Yu, "hasToJSON");
function E1(n) {
  return typeof n == "boolean" || typeof n == "number" || typeof n == "string" || n === null || Dr(n) || Array.isArray(n);
}
a(E1, "isJSONSerializable");
function Pa(n, t, e = !1) {
  n = n || {}, t = t || {};
  const i = {};
  for (const r in n)
    Object.prototype.hasOwnProperty.call(n, r) && (i[r] = n[r]);
  for (const r in t)
    Object.prototype.hasOwnProperty.call(t, r) && (e && i[r] && Dr(i[r]) && Dr(t[r]) ? i[r] = Pa(i[r], t[r], e) : i[r] = t[r]);
  return i;
}
a(Pa, "assign");
function R1(n) {
  return n ? Array.isArray(n) ? n : [n] : [];
}
a(R1, "asArray");
async function T1(n, t) {
  for (const e of n)
    if (await t(e))
      return e;
}
a(T1, "findAsyncSequential");
function _a(n, t, e = !1, i = !1) {
  if (!i && (!Dr(n) || !Dr(t)) || i && (!Ud(n) || !Ud(t)))
    return !1;
  const r = Object.getOwnPropertyNames(n), s = Object.getOwnPropertyNames(t);
  if (!e && r.length !== s.length)
    return !1;
  for (let o = 0; o < r.length; o++) {
    const c = r[o], l = n[c], p = t[c];
    if (l !== p && !_a(l, p, e))
      return !1;
  }
  return !0;
}
a(_a, "eqObjects");
function am(n) {
  return Object.entries(n);
}
a(am, "objectAsIterable");
function sm(n) {
  return n.charAt(0).toUpperCase() + n.substring(1).toLowerCase();
}
a(sm, "toUpperCaseFirst");
const L1 = '\\s,.:;"', O1 = new RegExp(`^|[${L1}]|$`, "g"), z1 = ".!?", I1 = new RegExp(`^|(?<=[${z1}])|$`);
function om(n) {
  return n.length > 0 ? n.replace(/([a-z\d])([A-Z]+)/g, "$1-$2").replace(/_|\s+/g, "-").toLowerCase() : n;
}
a(om, "toKebabCase");
function F1(n, t = 2) {
  if (!n)
    return null;
  let e = "";
  const i = n.split(O1).filter((r) => r);
  return i.length == 1 ? e = i[0] : i.forEach((r) => {
    e += r.charAt(0);
  }), e.substring(0, t).toUpperCase();
}
a(F1, "getInitials");
function cm(n) {
  let t;
  const e = n.split(I1).filter((i) => i);
  return e.length ? t = e[0] : t = n, t;
}
a(cm, "getTitleFromText");
function lm(n, t = 256) {
  return n.length > t && (n = n.substring(0, t - 1) + "…"), n;
}
a(lm, "truncateText");
const D1 = /^[\p{Extended_Pictographic}\p{Emoji_Presentation}]+$/u;
function V1(n) {
  return !!n?.match(D1)?.length;
}
a(V1, "checkOnlyEmojis");
const H1 = {
  //mode: 'cors', // no-cors, *cors, same-origin
  // cache: 'default' means the server is in control of the caching which is preferred instead of using 'reload'
  //cache: 'default', // *default, no-cache, reload, force-cache, only-if-cached
  credentials: "omit",
  // include, *same-origin, omit
  headers: {
    // https://stackoverflow.com/questions/8163703/cross-domain-ajax-doesnt-send-x-requested-with-header
    "X-Requested-With": "XMLHttpRequest"
  },
  redirect: "manual"
  // manual, *follow, error
  //referrerPolicy: 'no-referrer-when-downgrade', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
};
function B1() {
  const n = /* @__PURE__ */ new WeakSet(), t = /* @__PURE__ */ a(function(e, i) {
    if (Yu(i) && (i = i.toJSON()), !(i !== null && typeof i == "object"))
      return i;
    if (n.has(i))
      return "[Circular]";
    let r;
    if (n.add(i), Dr(i)) {
      const s = {};
      Object.keys(i).forEach((o) => {
        s[o] = t(o, i[o]);
      }), r = s;
    } else Array.isArray(i) && (r = i.map((s, o) => t(o, s)));
    return n.delete(i), r;
  }, "replacer");
  return t;
}
a(B1, "getCircularReferenceReplacer");
function fl() {
  return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
}
a(fl, "S4");
function N1(n) {
  if (n && n.ok && n.body) {
    const t = n.body.getReader();
    return new ReadableStream({
      start(e) {
        const i = /* @__PURE__ */ a(() => t.read().then(({ done: r, value: s }) => {
          if (r) {
            e.close();
            return;
          }
          return e.enqueue(s), i();
        }), "pump");
        return i();
      }
    });
  } else
    throw new Error("Could not parse text stream");
}
a(N1, "getTextStreamFromResponse");
function dm(n) {
  let t;
  try {
    if (t = window[n], t) {
      const e = "__storage_test__";
      t.setItem(e, e), t.removeItem(e);
    }
  } catch (e) {
    e instanceof DOMException && e.name === "QuotaExceededError" && // acknowledge QuotaExceededError only if there's something already stored
    t && t.length !== 0 && console.error("Storage not available:", n);
  }
  return t;
}
a(dm, "getStorage");
const Wy = class Wy extends Error {
  constructor() {
    super("Instance destroyed"), this.name = "DestroyError";
  }
};
a(Wy, "DestroyError");
let Ut = Wy;
const U1 = /* @__PURE__ */ a((n) => {
  var t;
  return t = class extends n {
    // AUTHENTICATION
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...i) {
      super(...i), this._whenTokenFactory = new Promise((r) => {
        this._resolveTokenFactory = r;
      }), this._whenUrlAndTokenFactory = new Promise((r) => {
        this._resolveUrlAndTokenFactory = (s) => {
          r(s), this.configurationState = "configured";
        };
      }), this._whenTokenIsValid = new Promise((r) => {
        this._resolveTokenIsValid = r;
      }), this._tokenPromise = null, this._token = "", this._validTokenFromFactory = async (r = !1) => {
        const s = [this.whenTokenFactory()];
        this.tokenFactoryRetryDelay >= 0 && this.tokenFactoryRetryDelay < 1 / 0 && s.push(new Promise((c) => setTimeout(c, this.tokenFactoryRetryDelay))), await Promise.race(s);
        const o = await this.tokenFactory?.(r) ?? "";
        if (this._validateToken(o)) {
          if (r && o === this._token && this.tokenFactoryRetryDelay >= 0 && this.tokenFactoryRetryDelay < 1 / 0)
            return await new Promise((c) => setTimeout(c, this.tokenFactoryRetryDelay)), await this._validTokenFromFactory(!0);
        } else if (this._whenTokenFactory = new Promise((c) => {
          this._resolveTokenFactory = c;
        }), !r)
          return await this._validTokenFromFactory(!1);
        if (!o)
          throw new TypeError("Could not get a valid token from tokenFactory.");
        return this._resolveTokenFactory?.(!0), this.whenUrl().then(this._resolveUrlAndTokenFactory), o;
      }, Promise.all([this.whenUrl(), this.whenTokenFactory()]).then(() => {
        this.url && this.tokenFactory && this._resolveUrlAndTokenFactory?.(!0);
      });
    }
    async whenTokenFactory() {
      await this._whenTokenFactory;
    }
    async whenUrlAndTokenFactory() {
      await this._whenUrlAndTokenFactory;
    }
    async whenTokenIsValid() {
      await this._whenTokenIsValid;
    }
    /**
     * Async function returning an `access_token` string for _your_ authenticated user. A boolean `refresh` parameter is provided to let you now if a fresh token is needed from Weavy.
     */
    get tokenFactory() {
      return this._tokenFactory;
    }
    set tokenFactory(i) {
      if (this.isDestroyed)
        throw new Ut();
      this._tokenFactory && this._tokenFactory !== i && this.whenTokenFactory().then(() => {
        this.queryClient.refetchQueries({ stale: !0 });
      }), this._tokenFactory = i ?? void 0, this._tokenFactory && queueMicrotask(() => {
        this._resolveTokenFactory?.(!0);
      });
    }
    /**
     * An URL to an endpoint returning an JSON data containing an `access_token` string property for _your_ authenticated user. A boolean `refresh=true` query parameter is provided in the request to let you now if when a fresh token is needed from Weavy.
     */
    get tokenUrl() {
      return this._tokenUrl;
    }
    set tokenUrl(i) {
      if (this.isDestroyed)
        throw new Ut();
      try {
        if (typeof i == "string")
          i && (this._tokenUrl = new URL(i, window.location.toString()));
        else if (i instanceof URL)
          this._tokenUrl = i;
        else if (i == null)
          this._tokenUrl = void 0;
        else
          throw new Error();
      } catch (r) {
        throw new Error("Invalid url", r);
      }
      this._tokenUrl && !this.tokenFactory && (this.tokenFactory = async (r) => {
        if (!this.tokenUrl)
          throw new Error("tokenURL property is not valid");
        const s = new URL(this.tokenUrl);
        r ? s.searchParams.set("refresh", "true") : s.searchParams.delete("refresh");
        const o = await fetch(s);
        if (o.ok) {
          const c = await o.json();
          if (c.access_token === void 0)
            throw new Error("Token response does not contain required property: access_token");
          return c.access_token;
        } else
          throw new Error("Could not get access token from server!");
      });
    }
    _validateToken(i) {
      if (!i)
        return !1;
      if (typeof i != "string")
        throw new TypeError(`You have provided an invalid string access token of type ${typeof i}.`);
      if (typeof i == "string" && !i.startsWith("wyu_"))
        throw i.startsWith("wys_") ? new TypeError("You have provided an API key for authentication. Provide a user access token instead.") : new TypeError("You have provided an invalid string as access token.");
      return this._resolveTokenIsValid?.(i), !0;
    }
    async getToken(i = !1) {
      if (this.isDestroyed)
        throw new Ut();
      if (this._token && !i)
        return this._token;
      if (this._tokenPromise)
        return await this._tokenPromise;
      this._tokenPromise = new Promise((r, s) => {
        this._validTokenFromFactory(i).then(r).catch(s), this.tokenFactoryTimeout >= 0 && this.tokenFactoryTimeout < 1 / 0 && setTimeout(() => s(new Error("Token factory timeout.")), this.tokenFactoryTimeout), window.addEventListener("offline", () => s(new Error("Network changed.")), { once: !0 }), window.addEventListener("online", () => s(new Error("Network changed.")), { once: !0 });
      });
      try {
        const r = await this._tokenPromise;
        return this._tokenPromise = null, this._token = r, this._token;
      } catch (r) {
        throw this._tokenPromise = null, r;
      }
    }
  }, a(t, "WeavyAuthentication"), t;
}, "WeavyAuthenticationMixin");
var Td = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function q1(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
a(q1, "getDefaultExportFromCjs");
function zu(n) {
  throw new Error('Could not dynamically require "' + n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
a(zu, "commonjsRequire");
var Iu = { exports: {} }, Nw;
function j1() {
  return Nw || (Nw = 1, (function(n, t) {
    var e;
    e = /* @__PURE__ */ a(() => (() => {
      var i = { d: /* @__PURE__ */ a((H, d) => {
        for (var w in d) i.o(d, w) && !i.o(H, w) && Object.defineProperty(H, w, { enumerable: !0, get: d[w] });
      }, "d") };
      i.g = (function() {
        if (typeof globalThis == "object") return globalThis;
        try {
          return this || new Function("return this")();
        } catch {
          if (typeof window == "object") return window;
        }
      })(), i.o = (H, d) => Object.prototype.hasOwnProperty.call(H, d), i.r = (H) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(H, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(H, "t", { value: !0 });
      };
      var r, s = {};
      i.r(s), i.d(s, { AbortError: /* @__PURE__ */ a(() => l, "AbortError"), DefaultHttpClient: /* @__PURE__ */ a(() => Rt, "DefaultHttpClient"), HttpClient: /* @__PURE__ */ a(() => $, "HttpClient"), HttpError: /* @__PURE__ */ a(() => o, "HttpError"), HttpResponse: /* @__PURE__ */ a(() => f, "HttpResponse"), HttpTransportType: /* @__PURE__ */ a(() => Et, "HttpTransportType"), HubConnection: /* @__PURE__ */ a(() => Bi, "HubConnection"), HubConnectionBuilder: /* @__PURE__ */ a(() => eu, "HubConnectionBuilder"), HubConnectionState: /* @__PURE__ */ a(() => kt, "HubConnectionState"), JsonHubProtocol: /* @__PURE__ */ a(() => Md, "JsonHubProtocol"), LogLevel: /* @__PURE__ */ a(() => r, "LogLevel"), MessageType: /* @__PURE__ */ a(() => ct, "MessageType"), NullLogger: /* @__PURE__ */ a(() => A, "NullLogger"), Subject: /* @__PURE__ */ a(() => hi, "Subject"), TimeoutError: /* @__PURE__ */ a(() => c, "TimeoutError"), TransferFormat: /* @__PURE__ */ a(() => re, "TransferFormat"), VERSION: /* @__PURE__ */ a(() => M, "VERSION") });
      const iu = class iu extends Error {
        constructor(d, w) {
          const k = new.target.prototype;
          super(`${d}: Status code '${w}'`), this.statusCode = w, this.__proto__ = k;
        }
      };
      a(iu, "i");
      let o = iu;
      const ru = class ru extends Error {
        constructor(d = "A timeout occurred.") {
          const w = new.target.prototype;
          super(d), this.__proto__ = w;
        }
      };
      a(ru, "n");
      let c = ru;
      const nu = class nu extends Error {
        constructor(d = "An abort occurred.") {
          const w = new.target.prototype;
          super(d), this.__proto__ = w;
        }
      };
      a(nu, "r");
      let l = nu;
      const au = class au extends Error {
        constructor(d, w) {
          const k = new.target.prototype;
          super(d), this.transport = w, this.errorType = "UnsupportedTransportError", this.__proto__ = k;
        }
      };
      a(au, "o");
      let p = au;
      const su = class su extends Error {
        constructor(d, w) {
          const k = new.target.prototype;
          super(d), this.transport = w, this.errorType = "DisabledTransportError", this.__proto__ = k;
        }
      };
      a(su, "h");
      let v = su;
      const ou = class ou extends Error {
        constructor(d, w) {
          const k = new.target.prototype;
          super(d), this.transport = w, this.errorType = "FailedToStartTransportError", this.__proto__ = k;
        }
      };
      a(ou, "c");
      let C = ou;
      const cu = class cu extends Error {
        constructor(d) {
          const w = new.target.prototype;
          super(d), this.errorType = "FailedToNegotiateWithServerError", this.__proto__ = w;
        }
      };
      a(cu, "a");
      let g = cu;
      const lu = class lu extends Error {
        constructor(d, w) {
          const k = new.target.prototype;
          super(d), this.innerErrors = w, this.__proto__ = k;
        }
      };
      a(lu, "l");
      let m = lu;
      const du = class du {
        constructor(d, w, k) {
          this.statusCode = d, this.statusText = w, this.content = k;
        }
      };
      a(du, "u");
      let f = du;
      const hu = class hu {
        get(d, w) {
          return this.send({ ...w, method: "GET", url: d });
        }
        post(d, w) {
          return this.send({ ...w, method: "POST", url: d });
        }
        delete(d, w) {
          return this.send({ ...w, method: "DELETE", url: d });
        }
        getCookieString(d) {
          return "";
        }
      };
      a(hu, "d");
      let $ = hu;
      (function(H) {
        H[H.Trace = 0] = "Trace", H[H.Debug = 1] = "Debug", H[H.Information = 2] = "Information", H[H.Warning = 3] = "Warning", H[H.Error = 4] = "Error", H[H.Critical = 5] = "Critical", H[H.None = 6] = "None";
      })(r || (r = {}));
      const uu = class uu {
        constructor() {
        }
        log(d, w) {
        }
      };
      a(uu, "f");
      let A = uu;
      A.instance = new A();
      const M = "9.0.6", pu = class pu {
        static isRequired(d, w) {
          if (d == null) throw new Error(`The '${w}' argument is required.`);
        }
        static isNotEmpty(d, w) {
          if (!d || d.match(/^\s*$/)) throw new Error(`The '${w}' argument should not be empty.`);
        }
        static isIn(d, w, k) {
          if (!(d in w)) throw new Error(`Unknown ${k} value: ${d}.`);
        }
      };
      a(pu, "w");
      let R = pu;
      const sa = class sa {
        static get isBrowser() {
          return !sa.isNode && typeof window == "object" && typeof window.document == "object";
        }
        static get isWebWorker() {
          return !sa.isNode && typeof self == "object" && "importScripts" in self;
        }
        static get isReactNative() {
          return !sa.isNode && typeof window == "object" && window.document === void 0;
        }
        static get isNode() {
          return typeof process < "u" && process.release && process.release.name === "node";
        }
      };
      a(sa, "g");
      let V = sa;
      function W(H, d) {
        let w = "";
        return I(H) ? (w = `Binary data of length ${H.byteLength}`, d && (w += `. Content: '${(function(k) {
          const P = new Uint8Array(k);
          let T = "";
          return P.forEach(((z) => {
            T += `0x${z < 16 ? "0" : ""}${z.toString(16)} `;
          })), T.substr(0, T.length - 1);
        })(H)}'`)) : typeof H == "string" && (w = `String data of length ${H.length}`, d && (w += `. Content: '${H}'`)), w;
      }
      a(W, "m");
      function I(H) {
        return H && typeof ArrayBuffer < "u" && (H instanceof ArrayBuffer || H.constructor && H.constructor.name === "ArrayBuffer");
      }
      a(I, "y");
      async function U(H, d, w, k, P, T) {
        const z = {}, [Z, Y] = ot();
        z[Z] = Y, H.log(r.Trace, `(${d} transport) sending data. ${W(P, T.logMessageContent)}.`);
        const ft = I(P) ? "arraybuffer" : "text", Tt = await w.post(k, { content: P, headers: { ...z, ...T.headers }, responseType: ft, timeout: T.timeout, withCredentials: T.withCredentials });
        H.log(r.Trace, `(${d} transport) request complete. Response status: ${Tt.statusCode}.`);
      }
      a(U, "b");
      const yu = class yu {
        constructor(d, w) {
          this.i = d, this.h = w;
        }
        dispose() {
          const d = this.i.observers.indexOf(this.h);
          d > -1 && this.i.observers.splice(d, 1), this.i.observers.length === 0 && this.i.cancelCallback && this.i.cancelCallback().catch(((w) => {
          }));
        }
      };
      a(yu, "v");
      let K = yu;
      const wu = class wu {
        constructor(d) {
          this.l = d, this.out = console;
        }
        log(d, w) {
          if (d >= this.l) {
            const k = `[${(/* @__PURE__ */ new Date()).toISOString()}] ${r[d]}: ${w}`;
            switch (d) {
              case r.Critical:
              case r.Error:
                this.out.error(k);
                break;
              case r.Warning:
                this.out.warn(k);
                break;
              case r.Information:
                this.out.info(k);
                break;
              default:
                this.out.log(k);
            }
          }
        }
      };
      a(wu, "E");
      let tt = wu;
      function ot() {
        let H = "X-SignalR-User-Agent";
        return V.isNode && (H = "User-Agent"), [H, rt(M, Lt(), V.isNode ? "NodeJS" : "Browser", Ot())];
      }
      a(ot, "$");
      function rt(H, d, w, k) {
        let P = "Microsoft SignalR/";
        const T = H.split(".");
        return P += `${T[0]}.${T[1]}`, P += ` (${H}; `, P += d && d !== "" ? `${d}; ` : "Unknown OS; ", P += `${w}`, P += k ? `; ${k}` : "; Unknown Runtime Version", P += ")", P;
      }
      a(rt, "C");
      function Lt() {
        if (!V.isNode) return "";
        switch (process.platform) {
          case "win32":
            return "Windows NT";
          case "darwin":
            return "macOS";
          case "linux":
            return "Linux";
          default:
            return process.platform;
        }
      }
      a(Lt, "S");
      function Ot() {
        if (V.isNode) return process.versions.node;
      }
      a(Ot, "k");
      function At(H) {
        return H.stack ? H.stack : H.message ? H.message : `${H}`;
      }
      a(At, "P");
      const fu = class fu extends $ {
        constructor(d) {
          if (super(), this.u = d, typeof fetch > "u" || V.isNode) {
            const w = zu;
            this.p = new (w("tough-cookie")).CookieJar(), typeof fetch > "u" ? this.m = w("node-fetch") : this.m = fetch, this.m = w("fetch-cookie")(this.m, this.p);
          } else this.m = fetch.bind((function() {
            if (typeof globalThis < "u") return globalThis;
            if (typeof self < "u") return self;
            if (typeof window < "u") return window;
            if (i.g !== void 0) return i.g;
            throw new Error("could not find global");
          })());
          if (typeof AbortController > "u") {
            const w = zu;
            this.v = w("abort-controller");
          } else this.v = AbortController;
        }
        async send(d) {
          if (d.abortSignal && d.abortSignal.aborted) throw new l();
          if (!d.method) throw new Error("No method defined.");
          if (!d.url) throw new Error("No url defined.");
          const w = new this.v();
          let k;
          d.abortSignal && (d.abortSignal.onabort = () => {
            w.abort(), k = new l();
          });
          let P, T = null;
          if (d.timeout) {
            const Y = d.timeout;
            T = setTimeout((() => {
              w.abort(), this.u.log(r.Warning, "Timeout from HTTP request."), k = new c();
            }), Y);
          }
          d.content === "" && (d.content = void 0), d.content && (d.headers = d.headers || {}, I(d.content) ? d.headers["Content-Type"] = "application/octet-stream" : d.headers["Content-Type"] = "text/plain;charset=UTF-8");
          try {
            P = await this.m(d.url, { body: d.content, cache: "no-cache", credentials: d.withCredentials === !0 ? "include" : "same-origin", headers: { "X-Requested-With": "XMLHttpRequest", ...d.headers }, method: d.method, mode: "cors", redirect: "follow", signal: w.signal });
          } catch (Y) {
            throw k || (this.u.log(r.Warning, `Error from HTTP request. ${Y}.`), Y);
          } finally {
            T && clearTimeout(T), d.abortSignal && (d.abortSignal.onabort = null);
          }
          if (!P.ok) {
            const Y = await Bt(P, "text");
            throw new o(Y || P.statusText, P.status);
          }
          const z = Bt(P, d.responseType), Z = await z;
          return new f(P.status, P.statusText, Z);
        }
        getCookieString(d) {
          let w = "";
          return V.isNode && this.p && this.p.getCookies(d, ((k, P) => w = P.join("; "))), w;
        }
      };
      a(fu, "T");
      let vt = fu;
      function Bt(H, d) {
        let w;
        switch (d) {
          case "arraybuffer":
            w = H.arrayBuffer();
            break;
          case "text":
          default:
            w = H.text();
            break;
          case "blob":
          case "document":
          case "json":
            throw new Error(`${d} is not supported.`);
        }
        return w;
      }
      a(Bt, "I");
      const mu = class mu extends $ {
        constructor(d) {
          super(), this.u = d;
        }
        send(d) {
          return d.abortSignal && d.abortSignal.aborted ? Promise.reject(new l()) : d.method ? d.url ? new Promise(((w, k) => {
            const P = new XMLHttpRequest();
            P.open(d.method, d.url, !0), P.withCredentials = d.withCredentials === void 0 || d.withCredentials, P.setRequestHeader("X-Requested-With", "XMLHttpRequest"), d.content === "" && (d.content = void 0), d.content && (I(d.content) ? P.setRequestHeader("Content-Type", "application/octet-stream") : P.setRequestHeader("Content-Type", "text/plain;charset=UTF-8"));
            const T = d.headers;
            T && Object.keys(T).forEach(((z) => {
              P.setRequestHeader(z, T[z]);
            })), d.responseType && (P.responseType = d.responseType), d.abortSignal && (d.abortSignal.onabort = () => {
              P.abort(), k(new l());
            }), d.timeout && (P.timeout = d.timeout), P.onload = () => {
              d.abortSignal && (d.abortSignal.onabort = null), P.status >= 200 && P.status < 300 ? w(new f(P.status, P.statusText, P.response || P.responseText)) : k(new o(P.response || P.responseText || P.statusText, P.status));
            }, P.onerror = () => {
              this.u.log(r.Warning, `Error from HTTP request. ${P.status}: ${P.statusText}.`), k(new o(P.statusText, P.status));
            }, P.ontimeout = () => {
              this.u.log(r.Warning, "Timeout from HTTP request."), k(new c());
            }, P.send(d.content);
          })) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."));
        }
      };
      a(mu, "_");
      let xe = mu;
      const vu = class vu extends $ {
        constructor(d) {
          if (super(), typeof fetch < "u" || V.isNode) this.$ = new vt(d);
          else {
            if (typeof XMLHttpRequest > "u") throw new Error("No usable HttpClient found.");
            this.$ = new xe(d);
          }
        }
        send(d) {
          return d.abortSignal && d.abortSignal.aborted ? Promise.reject(new l()) : d.method ? d.url ? this.$.send(d) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."));
        }
        getCookieString(d) {
          return this.$.getCookieString(d);
        }
      };
      a(vu, "H");
      let Rt = vu;
      const oa = class oa {
        static write(d) {
          return `${d}${oa.RecordSeparator}`;
        }
        static parse(d) {
          if (d[d.length - 1] !== oa.RecordSeparator) throw new Error("Message is incomplete.");
          const w = d.split(oa.RecordSeparator);
          return w.pop(), w;
        }
      };
      a(oa, "D");
      let xt = oa;
      xt.RecordSeparatorCode = 30, xt.RecordSeparator = String.fromCharCode(xt.RecordSeparatorCode);
      const gu = class gu {
        writeHandshakeRequest(d) {
          return xt.write(JSON.stringify(d));
        }
        parseHandshakeResponse(d) {
          let w, k;
          if (I(d)) {
            const z = new Uint8Array(d), Z = z.indexOf(xt.RecordSeparatorCode);
            if (Z === -1) throw new Error("Message is incomplete.");
            const Y = Z + 1;
            w = String.fromCharCode.apply(null, Array.prototype.slice.call(z.slice(0, Y))), k = z.byteLength > Y ? z.slice(Y).buffer : null;
          } else {
            const z = d, Z = z.indexOf(xt.RecordSeparator);
            if (Z === -1) throw new Error("Message is incomplete.");
            const Y = Z + 1;
            w = z.substring(0, Y), k = z.length > Y ? z.substring(Y) : null;
          }
          const P = xt.parse(w), T = JSON.parse(P[0]);
          if (T.type) throw new Error("Expected a handshake response from the server.");
          return [k, T];
        }
      };
      a(gu, "R");
      let ie = gu;
      var ct, kt;
      (function(H) {
        H[H.Invocation = 1] = "Invocation", H[H.StreamItem = 2] = "StreamItem", H[H.Completion = 3] = "Completion", H[H.StreamInvocation = 4] = "StreamInvocation", H[H.CancelInvocation = 5] = "CancelInvocation", H[H.Ping = 6] = "Ping", H[H.Close = 7] = "Close", H[H.Ack = 8] = "Ack", H[H.Sequence = 9] = "Sequence";
      })(ct || (ct = {}));
      const bu = class bu {
        constructor() {
          this.observers = [];
        }
        next(d) {
          for (const w of this.observers) w.next(d);
        }
        error(d) {
          for (const w of this.observers) w.error && w.error(d);
        }
        complete() {
          for (const d of this.observers) d.complete && d.complete();
        }
        subscribe(d) {
          return this.observers.push(d), new K(this, d);
        }
      };
      a(bu, "U");
      let hi = bu;
      const xu = class xu {
        constructor(d, w, k) {
          this.C = 1e5, this.S = [], this.k = 0, this.P = !1, this.T = 1, this.I = 0, this._ = 0, this.H = !1, this.D = d, this.R = w, this.C = k;
        }
        async A(d) {
          const w = this.D.writeMessage(d);
          let k = Promise.resolve();
          if (this.U(d)) {
            this.k++;
            let P = /* @__PURE__ */ a(() => {
            }, "t"), T = /* @__PURE__ */ a(() => {
            }, "i");
            I(w) ? this._ += w.byteLength : this._ += w.length, this._ >= this.C && (k = new Promise(((z, Z) => {
              P = z, T = Z;
            }))), this.S.push(new Hi(w, this.k, P, T));
          }
          try {
            this.H || await this.R.send(w);
          } catch {
            this.L();
          }
          await k;
        }
        N(d) {
          let w = -1;
          for (let k = 0; k < this.S.length; k++) {
            const P = this.S[k];
            if (P.q <= d.sequenceId) w = k, I(P.M) ? this._ -= P.M.byteLength : this._ -= P.M.length, P.j();
            else {
              if (!(this._ < this.C)) break;
              P.j();
            }
          }
          w !== -1 && (this.S = this.S.slice(w + 1));
        }
        W(d) {
          if (this.P) return d.type === ct.Sequence && (this.P = !1, !0);
          if (!this.U(d)) return !0;
          const w = this.T;
          return this.T++, w <= this.I ? (w === this.I && this.O(), !1) : (this.I = w, this.O(), !0);
        }
        F(d) {
          d.sequenceId > this.T ? this.R.stop(new Error("Sequence ID greater than amount of messages we've received.")) : this.T = d.sequenceId;
        }
        L() {
          this.H = !0, this.P = !0;
        }
        async B() {
          const d = this.S.length !== 0 ? this.S[0].q : this.k + 1;
          await this.R.send(this.D.writeMessage({ type: ct.Sequence, sequenceId: d }));
          const w = this.S;
          for (const k of w) await this.R.send(k.M);
          this.H = !1;
        }
        X(d) {
          d != null || (d = new Error("Unable to reconnect to server."));
          for (const w of this.S) w.J(d);
        }
        U(d) {
          switch (d.type) {
            case ct.Invocation:
            case ct.StreamItem:
            case ct.Completion:
            case ct.StreamInvocation:
            case ct.CancelInvocation:
              return !0;
            case ct.Close:
            case ct.Sequence:
            case ct.Ping:
            case ct.Ack:
              return !1;
          }
        }
        O() {
          this.V === void 0 && (this.V = setTimeout((async () => {
            try {
              this.H || await this.R.send(this.D.writeMessage({ type: ct.Ack, sequenceId: this.I }));
            } catch {
            }
            clearTimeout(this.V), this.V = void 0;
          }), 1e3));
        }
      };
      a(xu, "L");
      let Ye = xu;
      const Cu = class Cu {
        constructor(d, w, k, P) {
          this.M = d, this.q = w, this.j = k, this.J = P;
        }
      };
      a(Cu, "N");
      let Hi = Cu;
      (function(H) {
        H.Disconnected = "Disconnected", H.Connecting = "Connecting", H.Connected = "Connected", H.Disconnecting = "Disconnecting", H.Reconnecting = "Reconnecting";
      })(kt || (kt = {}));
      const Ad = class Ad {
        static create(d, w, k, P, T, z, Z) {
          return new Ad(d, w, k, P, T, z, Z);
        }
        constructor(d, w, k, P, T, z, Z) {
          this.K = 0, this.G = () => {
            this.u.log(r.Warning, "The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep");
          }, R.isRequired(d, "connection"), R.isRequired(w, "logger"), R.isRequired(k, "protocol"), this.serverTimeoutInMilliseconds = T ?? 3e4, this.keepAliveIntervalInMilliseconds = z ?? 15e3, this.Y = Z ?? 1e5, this.u = w, this.D = k, this.connection = d, this.Z = P, this.tt = new ie(), this.connection.onreceive = (Y) => this.et(Y), this.connection.onclose = (Y) => this.st(Y), this.it = {}, this.nt = {}, this.rt = [], this.ot = [], this.ht = [], this.ct = 0, this.lt = !1, this.ut = kt.Disconnected, this.dt = !1, this.ft = this.D.writeMessage({ type: ct.Ping });
        }
        get state() {
          return this.ut;
        }
        get connectionId() {
          return this.connection && this.connection.connectionId || null;
        }
        get baseUrl() {
          return this.connection.baseUrl || "";
        }
        set baseUrl(d) {
          if (this.ut !== kt.Disconnected && this.ut !== kt.Reconnecting) throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");
          if (!d) throw new Error("The HubConnection url must be a valid url.");
          this.connection.baseUrl = d;
        }
        start() {
          return this.wt = this.gt(), this.wt;
        }
        async gt() {
          if (this.ut !== kt.Disconnected) return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));
          this.ut = kt.Connecting, this.u.log(r.Debug, "Starting HubConnection.");
          try {
            await this.yt(), V.isBrowser && window.document.addEventListener("freeze", this.G), this.ut = kt.Connected, this.dt = !0, this.u.log(r.Debug, "HubConnection connected successfully.");
          } catch (d) {
            return this.ut = kt.Disconnected, this.u.log(r.Debug, `HubConnection failed to start successfully because of error '${d}'.`), Promise.reject(d);
          }
        }
        async yt() {
          this.bt = void 0, this.lt = !1;
          const d = new Promise(((w, k) => {
            this.vt = w, this.Et = k;
          }));
          await this.connection.start(this.D.transferFormat);
          try {
            let w = this.D.version;
            this.connection.features.reconnect || (w = 1);
            const k = { protocol: this.D.name, version: w };
            if (this.u.log(r.Debug, "Sending handshake request."), await this.$t(this.tt.writeHandshakeRequest(k)), this.u.log(r.Information, `Using HubProtocol '${this.D.name}'.`), this.Ct(), this.St(), this.kt(), await d, this.bt) throw this.bt;
            this.connection.features.reconnect && (this.Pt = new Ye(this.D, this.connection, this.Y), this.connection.features.disconnected = this.Pt.L.bind(this.Pt), this.connection.features.resend = () => {
              if (this.Pt) return this.Pt.B();
            }), this.connection.features.inherentKeepAlive || await this.$t(this.ft);
          } catch (w) {
            throw this.u.log(r.Debug, `Hub handshake failed with error '${w}' during start(). Stopping HubConnection.`), this.Ct(), this.Tt(), await this.connection.stop(w), w;
          }
        }
        async stop() {
          const d = this.wt;
          this.connection.features.reconnect = !1, this.It = this._t(), await this.It;
          try {
            await d;
          } catch {
          }
        }
        _t(d) {
          if (this.ut === kt.Disconnected) return this.u.log(r.Debug, `Call to HubConnection.stop(${d}) ignored because it is already in the disconnected state.`), Promise.resolve();
          if (this.ut === kt.Disconnecting) return this.u.log(r.Debug, `Call to HttpConnection.stop(${d}) ignored because the connection is already in the disconnecting state.`), this.It;
          const w = this.ut;
          return this.ut = kt.Disconnecting, this.u.log(r.Debug, "Stopping HubConnection."), this.Ht ? (this.u.log(r.Debug, "Connection stopped during reconnect delay. Done reconnecting."), clearTimeout(this.Ht), this.Ht = void 0, this.Dt(), Promise.resolve()) : (w === kt.Connected && this.Rt(), this.Ct(), this.Tt(), this.bt = d || new l("The connection was stopped before the hub handshake could complete."), this.connection.stop(d));
        }
        async Rt() {
          try {
            await this.xt(this.At());
          } catch {
          }
        }
        stream(d, ...w) {
          const [k, P] = this.Ut(w), T = this.Lt(d, w, P);
          let z;
          const Z = new hi();
          return Z.cancelCallback = () => {
            const Y = this.Nt(T.invocationId);
            return delete this.it[T.invocationId], z.then((() => this.xt(Y)));
          }, this.it[T.invocationId] = (Y, ft) => {
            ft ? Z.error(ft) : Y && (Y.type === ct.Completion ? Y.error ? Z.error(new Error(Y.error)) : Z.complete() : Z.next(Y.item));
          }, z = this.xt(T).catch(((Y) => {
            Z.error(Y), delete this.it[T.invocationId];
          })), this.qt(k, z), Z;
        }
        $t(d) {
          return this.kt(), this.connection.send(d);
        }
        xt(d) {
          return this.Pt ? this.Pt.A(d) : this.$t(this.D.writeMessage(d));
        }
        send(d, ...w) {
          const [k, P] = this.Ut(w), T = this.xt(this.Mt(d, w, !0, P));
          return this.qt(k, T), T;
        }
        invoke(d, ...w) {
          const [k, P] = this.Ut(w), T = this.Mt(d, w, !1, P);
          return new Promise(((z, Z) => {
            this.it[T.invocationId] = (ft, Tt) => {
              Tt ? Z(Tt) : ft && (ft.type === ct.Completion ? ft.error ? Z(new Error(ft.error)) : z(ft.result) : Z(new Error(`Unexpected message type: ${ft.type}`)));
            };
            const Y = this.xt(T).catch(((ft) => {
              Z(ft), delete this.it[T.invocationId];
            }));
            this.qt(k, Y);
          }));
        }
        on(d, w) {
          d && w && (d = d.toLowerCase(), this.nt[d] || (this.nt[d] = []), this.nt[d].indexOf(w) === -1 && this.nt[d].push(w));
        }
        off(d, w) {
          if (!d) return;
          d = d.toLowerCase();
          const k = this.nt[d];
          if (k) if (w) {
            const P = k.indexOf(w);
            P !== -1 && (k.splice(P, 1), k.length === 0 && delete this.nt[d]);
          } else delete this.nt[d];
        }
        onclose(d) {
          d && this.rt.push(d);
        }
        onreconnecting(d) {
          d && this.ot.push(d);
        }
        onreconnected(d) {
          d && this.ht.push(d);
        }
        et(d) {
          if (this.Ct(), this.lt || (d = this.jt(d), this.lt = !0), d) {
            const w = this.D.parseMessages(d, this.u);
            for (const k of w) if (!this.Pt || this.Pt.W(k)) switch (k.type) {
              case ct.Invocation:
                this.Wt(k).catch(((P) => {
                  this.u.log(r.Error, `Invoke client method threw error: ${At(P)}`);
                }));
                break;
              case ct.StreamItem:
              case ct.Completion: {
                const P = this.it[k.invocationId];
                if (P) {
                  k.type === ct.Completion && delete this.it[k.invocationId];
                  try {
                    P(k);
                  } catch (T) {
                    this.u.log(r.Error, `Stream callback threw error: ${At(T)}`);
                  }
                }
                break;
              }
              case ct.Ping:
                break;
              case ct.Close: {
                this.u.log(r.Information, "Close message received from server.");
                const P = k.error ? new Error("Server returned an error on close: " + k.error) : void 0;
                k.allowReconnect === !0 ? this.connection.stop(P) : this.It = this._t(P);
                break;
              }
              case ct.Ack:
                this.Pt && this.Pt.N(k);
                break;
              case ct.Sequence:
                this.Pt && this.Pt.F(k);
                break;
              default:
                this.u.log(r.Warning, `Invalid message type: ${k.type}.`);
            }
          }
          this.St();
        }
        jt(d) {
          let w, k;
          try {
            [k, w] = this.tt.parseHandshakeResponse(d);
          } catch (P) {
            const T = "Error parsing handshake response: " + P;
            this.u.log(r.Error, T);
            const z = new Error(T);
            throw this.Et(z), z;
          }
          if (w.error) {
            const P = "Server returned handshake error: " + w.error;
            this.u.log(r.Error, P);
            const T = new Error(P);
            throw this.Et(T), T;
          }
          return this.u.log(r.Debug, "Server handshake complete."), this.vt(), k;
        }
        kt() {
          this.connection.features.inherentKeepAlive || (this.K = (/* @__PURE__ */ new Date()).getTime() + this.keepAliveIntervalInMilliseconds, this.Tt());
        }
        St() {
          if (!(this.connection.features && this.connection.features.inherentKeepAlive || (this.Ot = setTimeout((() => this.serverTimeout()), this.serverTimeoutInMilliseconds), this.Ft !== void 0))) {
            let d = this.K - (/* @__PURE__ */ new Date()).getTime();
            d < 0 && (d = 0), this.Ft = setTimeout((async () => {
              if (this.ut === kt.Connected) try {
                await this.$t(this.ft);
              } catch {
                this.Tt();
              }
            }), d);
          }
        }
        serverTimeout() {
          this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."));
        }
        async Wt(d) {
          const w = d.target.toLowerCase(), k = this.nt[w];
          if (!k) return this.u.log(r.Warning, `No client method with the name '${w}' found.`), void (d.invocationId && (this.u.log(r.Warning, `No result given for '${w}' method and invocation ID '${d.invocationId}'.`), await this.xt(this.Bt(d.invocationId, "Client didn't provide a result.", null))));
          const P = k.slice(), T = !!d.invocationId;
          let z, Z, Y;
          for (const ft of P) try {
            const Tt = z;
            z = await ft.apply(this, d.arguments), T && z && Tt && (this.u.log(r.Error, `Multiple results provided for '${w}'. Sending error to server.`), Y = this.Bt(d.invocationId, "Client provided multiple results.", null)), Z = void 0;
          } catch (Tt) {
            Z = Tt, this.u.log(r.Error, `A callback for the method '${w}' threw error '${Tt}'.`);
          }
          Y ? await this.xt(Y) : T ? (Z ? Y = this.Bt(d.invocationId, `${Z}`, null) : z !== void 0 ? Y = this.Bt(d.invocationId, null, z) : (this.u.log(r.Warning, `No result given for '${w}' method and invocation ID '${d.invocationId}'.`), Y = this.Bt(d.invocationId, "Client didn't provide a result.", null)), await this.xt(Y)) : z && this.u.log(r.Error, `Result given for '${w}' method but server is not expecting a result.`);
        }
        st(d) {
          this.u.log(r.Debug, `HubConnection.connectionClosed(${d}) called while in state ${this.ut}.`), this.bt = this.bt || d || new l("The underlying connection was closed before the hub handshake could complete."), this.vt && this.vt(), this.Xt(d || new Error("Invocation canceled due to the underlying connection being closed.")), this.Ct(), this.Tt(), this.ut === kt.Disconnecting ? this.Dt(d) : this.ut === kt.Connected && this.Z ? this.Jt(d) : this.ut === kt.Connected && this.Dt(d);
        }
        Dt(d) {
          if (this.dt) {
            this.ut = kt.Disconnected, this.dt = !1, this.Pt && (this.Pt.X(d ?? new Error("Connection closed.")), this.Pt = void 0), V.isBrowser && window.document.removeEventListener("freeze", this.G);
            try {
              this.rt.forEach(((w) => w.apply(this, [d])));
            } catch (w) {
              this.u.log(r.Error, `An onclose callback called with error '${d}' threw error '${w}'.`);
            }
          }
        }
        async Jt(d) {
          const w = Date.now();
          let k = 0, P = d !== void 0 ? d : new Error("Attempting to reconnect due to a unknown error."), T = this.zt(k++, 0, P);
          if (T === null) return this.u.log(r.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."), void this.Dt(d);
          if (this.ut = kt.Reconnecting, d ? this.u.log(r.Information, `Connection reconnecting because of error '${d}'.`) : this.u.log(r.Information, "Connection reconnecting."), this.ot.length !== 0) {
            try {
              this.ot.forEach(((z) => z.apply(this, [d])));
            } catch (z) {
              this.u.log(r.Error, `An onreconnecting callback called with error '${d}' threw error '${z}'.`);
            }
            if (this.ut !== kt.Reconnecting) return void this.u.log(r.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.");
          }
          for (; T !== null; ) {
            if (this.u.log(r.Information, `Reconnect attempt number ${k} will start in ${T} ms.`), await new Promise(((z) => {
              this.Ht = setTimeout(z, T);
            })), this.Ht = void 0, this.ut !== kt.Reconnecting) return void this.u.log(r.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting.");
            try {
              if (await this.yt(), this.ut = kt.Connected, this.u.log(r.Information, "HubConnection reconnected successfully."), this.ht.length !== 0) try {
                this.ht.forEach(((z) => z.apply(this, [this.connection.connectionId])));
              } catch (z) {
                this.u.log(r.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${z}'.`);
              }
              return;
            } catch (z) {
              if (this.u.log(r.Information, `Reconnect attempt failed because of error '${z}'.`), this.ut !== kt.Reconnecting) return this.u.log(r.Debug, `Connection moved to the '${this.ut}' from the reconnecting state during reconnect attempt. Done reconnecting.`), void (this.ut === kt.Disconnecting && this.Dt());
              P = z instanceof Error ? z : new Error(z.toString()), T = this.zt(k++, Date.now() - w, P);
            }
          }
          this.u.log(r.Information, `Reconnect retries have been exhausted after ${Date.now() - w} ms and ${k} failed attempts. Connection disconnecting.`), this.Dt();
        }
        zt(d, w, k) {
          try {
            return this.Z.nextRetryDelayInMilliseconds({ elapsedMilliseconds: w, previousRetryCount: d, retryReason: k });
          } catch (P) {
            return this.u.log(r.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${d}, ${w}) threw error '${P}'.`), null;
          }
        }
        Xt(d) {
          const w = this.it;
          this.it = {}, Object.keys(w).forEach(((k) => {
            const P = w[k];
            try {
              P(null, d);
            } catch (T) {
              this.u.log(r.Error, `Stream 'error' callback called with '${d}' threw error: ${At(T)}`);
            }
          }));
        }
        Tt() {
          this.Ft && (clearTimeout(this.Ft), this.Ft = void 0);
        }
        Ct() {
          this.Ot && clearTimeout(this.Ot);
        }
        Mt(d, w, k, P) {
          if (k) return P.length !== 0 ? { target: d, arguments: w, streamIds: P, type: ct.Invocation } : { target: d, arguments: w, type: ct.Invocation };
          {
            const T = this.ct;
            return this.ct++, P.length !== 0 ? { target: d, arguments: w, invocationId: T.toString(), streamIds: P, type: ct.Invocation } : { target: d, arguments: w, invocationId: T.toString(), type: ct.Invocation };
          }
        }
        qt(d, w) {
          if (d.length !== 0) {
            w || (w = Promise.resolve());
            for (const k in d) d[k].subscribe({ complete: /* @__PURE__ */ a(() => {
              w = w.then((() => this.xt(this.Bt(k))));
            }, "complete"), error: /* @__PURE__ */ a((P) => {
              let T;
              T = P instanceof Error ? P.message : P && P.toString ? P.toString() : "Unknown error", w = w.then((() => this.xt(this.Bt(k, T))));
            }, "error"), next: /* @__PURE__ */ a((P) => {
              w = w.then((() => this.xt(this.Vt(k, P))));
            }, "next") });
          }
        }
        Ut(d) {
          const w = [], k = [];
          for (let P = 0; P < d.length; P++) {
            const T = d[P];
            if (this.Kt(T)) {
              const z = this.ct;
              this.ct++, w[z] = T, k.push(z.toString()), d.splice(P, 1);
            }
          }
          return [w, k];
        }
        Kt(d) {
          return d && d.subscribe && typeof d.subscribe == "function";
        }
        Lt(d, w, k) {
          const P = this.ct;
          return this.ct++, k.length !== 0 ? { target: d, arguments: w, invocationId: P.toString(), streamIds: k, type: ct.StreamInvocation } : { target: d, arguments: w, invocationId: P.toString(), type: ct.StreamInvocation };
        }
        Nt(d) {
          return { invocationId: d, type: ct.CancelInvocation };
        }
        Vt(d, w) {
          return { invocationId: d, item: w, type: ct.StreamItem };
        }
        Bt(d, w, k) {
          return w ? { error: w, invocationId: d, type: ct.Completion } : { invocationId: d, result: k, type: ct.Completion };
        }
        At() {
          return { type: ct.Close };
        }
      };
      a(Ad, "q");
      let Bi = Ad;
      const sl = [0, 2e3, 1e4, 3e4, null], $u = class $u {
        constructor(d) {
          this.Gt = d !== void 0 ? [...d, null] : sl;
        }
        nextRetryDelayInMilliseconds(d) {
          return this.Gt[d.previousRetryCount];
        }
      };
      a($u, "j");
      let Ci = $u;
      const ku = class ku {
      };
      a(ku, "W");
      let Ct = ku;
      Ct.Authorization = "Authorization", Ct.Cookie = "Cookie";
      const Pu = class Pu extends $ {
        constructor(d, w) {
          super(), this.Qt = d, this.Yt = w;
        }
        async send(d) {
          let w = !0;
          this.Yt && (!this.Zt || d.url && d.url.indexOf("/negotiate?") > 0) && (w = !1, this.Zt = await this.Yt()), this.te(d);
          const k = await this.Qt.send(d);
          return w && k.statusCode === 401 && this.Yt ? (this.Zt = await this.Yt(), this.te(d), await this.Qt.send(d)) : k;
        }
        te(d) {
          d.headers || (d.headers = {}), this.Zt ? d.headers[Ct.Authorization] = `Bearer ${this.Zt}` : this.Yt && d.headers[Ct.Authorization] && delete d.headers[Ct.Authorization];
        }
        getCookieString(d) {
          return this.Qt.getCookieString(d);
        }
      };
      a(Pu, "O");
      let Ve = Pu;
      var Et, re;
      (function(H) {
        H[H.None = 0] = "None", H[H.WebSockets = 1] = "WebSockets", H[H.ServerSentEvents = 2] = "ServerSentEvents", H[H.LongPolling = 4] = "LongPolling";
      })(Et || (Et = {})), (function(H) {
        H[H.Text = 1] = "Text", H[H.Binary = 2] = "Binary";
      })(re || (re = {}));
      const _u = class _u {
        constructor() {
          this.ee = !1, this.onabort = null;
        }
        abort() {
          this.ee || (this.ee = !0, this.onabort && this.onabort());
        }
        get signal() {
          return this;
        }
        get aborted() {
          return this.ee;
        }
      };
      a(_u, "X");
      let Zh = _u;
      const Su = class Su {
        get pollAborted() {
          return this.se.aborted;
        }
        constructor(d, w, k) {
          this.$ = d, this.u = w, this.se = new Zh(), this.ie = k, this.ne = !1, this.onreceive = null, this.onclose = null;
        }
        async connect(d, w) {
          if (R.isRequired(d, "url"), R.isRequired(w, "transferFormat"), R.isIn(w, re, "transferFormat"), this.re = d, this.u.log(r.Trace, "(LongPolling transport) Connecting."), w === re.Binary && typeof XMLHttpRequest < "u" && typeof new XMLHttpRequest().responseType != "string") throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");
          const [k, P] = ot(), T = { [k]: P, ...this.ie.headers }, z = { abortSignal: this.se.signal, headers: T, timeout: 1e5, withCredentials: this.ie.withCredentials };
          w === re.Binary && (z.responseType = "arraybuffer");
          const Z = `${d}&_=${Date.now()}`;
          this.u.log(r.Trace, `(LongPolling transport) polling: ${Z}.`);
          const Y = await this.$.get(Z, z);
          Y.statusCode !== 200 ? (this.u.log(r.Error, `(LongPolling transport) Unexpected response code: ${Y.statusCode}.`), this.oe = new o(Y.statusText || "", Y.statusCode), this.ne = !1) : this.ne = !0, this.he = this.ce(this.re, z);
        }
        async ce(d, w) {
          try {
            for (; this.ne; ) try {
              const k = `${d}&_=${Date.now()}`;
              this.u.log(r.Trace, `(LongPolling transport) polling: ${k}.`);
              const P = await this.$.get(k, w);
              P.statusCode === 204 ? (this.u.log(r.Information, "(LongPolling transport) Poll terminated by server."), this.ne = !1) : P.statusCode !== 200 ? (this.u.log(r.Error, `(LongPolling transport) Unexpected response code: ${P.statusCode}.`), this.oe = new o(P.statusText || "", P.statusCode), this.ne = !1) : P.content ? (this.u.log(r.Trace, `(LongPolling transport) data received. ${W(P.content, this.ie.logMessageContent)}.`), this.onreceive && this.onreceive(P.content)) : this.u.log(r.Trace, "(LongPolling transport) Poll timed out, reissuing.");
            } catch (k) {
              this.ne ? k instanceof c ? this.u.log(r.Trace, "(LongPolling transport) Poll timed out, reissuing.") : (this.oe = k, this.ne = !1) : this.u.log(r.Trace, `(LongPolling transport) Poll errored after shutdown: ${k.message}`);
            }
          } finally {
            this.u.log(r.Trace, "(LongPolling transport) Polling complete."), this.pollAborted || this.ae();
          }
        }
        async send(d) {
          return this.ne ? U(this.u, "LongPolling", this.$, this.re, d, this.ie) : Promise.reject(new Error("Cannot send until the transport is connected"));
        }
        async stop() {
          this.u.log(r.Trace, "(LongPolling transport) Stopping polling."), this.ne = !1, this.se.abort();
          try {
            await this.he, this.u.log(r.Trace, `(LongPolling transport) sending DELETE request to ${this.re}.`);
            const d = {}, [w, k] = ot();
            d[w] = k;
            const P = { headers: { ...d, ...this.ie.headers }, timeout: this.ie.timeout, withCredentials: this.ie.withCredentials };
            let T;
            try {
              await this.$.delete(this.re, P);
            } catch (z) {
              T = z;
            }
            T ? T instanceof o && (T.statusCode === 404 ? this.u.log(r.Trace, "(LongPolling transport) A 404 response was returned from sending a DELETE request.") : this.u.log(r.Trace, `(LongPolling transport) Error sending a DELETE request: ${T}`)) : this.u.log(r.Trace, "(LongPolling transport) DELETE request accepted.");
          } finally {
            this.u.log(r.Trace, "(LongPolling transport) Stop finished."), this.ae();
          }
        }
        ae() {
          if (this.onclose) {
            let d = "(LongPolling transport) Firing onclose event.";
            this.oe && (d += " Error: " + this.oe), this.u.log(r.Trace, d), this.onclose(this.oe);
          }
        }
      };
      a(Su, "J");
      let Sd = Su;
      const Mu = class Mu {
        constructor(d, w, k, P) {
          this.$ = d, this.Zt = w, this.u = k, this.ie = P, this.onreceive = null, this.onclose = null;
        }
        async connect(d, w) {
          return R.isRequired(d, "url"), R.isRequired(w, "transferFormat"), R.isIn(w, re, "transferFormat"), this.u.log(r.Trace, "(SSE transport) Connecting."), this.re = d, this.Zt && (d += (d.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(this.Zt)}`), new Promise(((k, P) => {
            let T, z = !1;
            if (w === re.Text) {
              if (V.isBrowser || V.isWebWorker) T = new this.ie.EventSource(d, { withCredentials: this.ie.withCredentials });
              else {
                const Z = this.$.getCookieString(d), Y = {};
                Y.Cookie = Z;
                const [ft, Tt] = ot();
                Y[ft] = Tt, T = new this.ie.EventSource(d, { withCredentials: this.ie.withCredentials, headers: { ...Y, ...this.ie.headers } });
              }
              try {
                T.onmessage = (Z) => {
                  if (this.onreceive) try {
                    this.u.log(r.Trace, `(SSE transport) data received. ${W(Z.data, this.ie.logMessageContent)}.`), this.onreceive(Z.data);
                  } catch (Y) {
                    return void this.le(Y);
                  }
                }, T.onerror = (Z) => {
                  z ? this.le() : P(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled."));
                }, T.onopen = () => {
                  this.u.log(r.Information, `SSE connected to ${this.re}`), this.ue = T, z = !0, k();
                };
              } catch (Z) {
                return void P(Z);
              }
            } else P(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));
          }));
        }
        async send(d) {
          return this.ue ? U(this.u, "SSE", this.$, this.re, d, this.ie) : Promise.reject(new Error("Cannot send until the transport is connected"));
        }
        stop() {
          return this.le(), Promise.resolve();
        }
        le(d) {
          this.ue && (this.ue.close(), this.ue = void 0, this.onclose && this.onclose(d));
        }
      };
      a(Mu, "z");
      let Yh = Mu;
      const Au = class Au {
        constructor(d, w, k, P, T, z) {
          this.u = k, this.Yt = w, this.de = P, this.fe = T, this.$ = d, this.onreceive = null, this.onclose = null, this.pe = z;
        }
        async connect(d, w) {
          let k;
          return R.isRequired(d, "url"), R.isRequired(w, "transferFormat"), R.isIn(w, re, "transferFormat"), this.u.log(r.Trace, "(WebSockets transport) Connecting."), this.Yt && (k = await this.Yt()), new Promise(((P, T) => {
            let z;
            d = d.replace(/^http/, "ws");
            const Z = this.$.getCookieString(d);
            let Y = !1;
            if (V.isNode || V.isReactNative) {
              const ft = {}, [Tt, ca] = ot();
              ft[Tt] = ca, k && (ft[Ct.Authorization] = `Bearer ${k}`), Z && (ft[Ct.Cookie] = Z), z = new this.fe(d, void 0, { headers: { ...ft, ...this.pe } });
            } else k && (d += (d.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(k)}`);
            z || (z = new this.fe(d)), w === re.Binary && (z.binaryType = "arraybuffer"), z.onopen = (ft) => {
              this.u.log(r.Information, `WebSocket connected to ${d}.`), this.we = z, Y = !0, P();
            }, z.onerror = (ft) => {
              let Tt = null;
              Tt = typeof ErrorEvent < "u" && ft instanceof ErrorEvent ? ft.error : "There was an error with the transport", this.u.log(r.Information, `(WebSockets transport) ${Tt}.`);
            }, z.onmessage = (ft) => {
              if (this.u.log(r.Trace, `(WebSockets transport) data received. ${W(ft.data, this.de)}.`), this.onreceive) try {
                this.onreceive(ft.data);
              } catch (Tt) {
                return void this.le(Tt);
              }
            }, z.onclose = (ft) => {
              if (Y) this.le(ft);
              else {
                let Tt = null;
                Tt = typeof ErrorEvent < "u" && ft instanceof ErrorEvent ? ft.error : "WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.", T(new Error(Tt));
              }
            };
          }));
        }
        send(d) {
          return this.we && this.we.readyState === this.fe.OPEN ? (this.u.log(r.Trace, `(WebSockets transport) sending data. ${W(d, this.de)}.`), this.we.send(d), Promise.resolve()) : Promise.reject("WebSocket is not in the OPEN state");
        }
        stop() {
          return this.we && this.le(void 0), Promise.resolve();
        }
        le(d) {
          this.we && (this.we.onclose = () => {
          }, this.we.onmessage = () => {
          }, this.we.onerror = () => {
          }, this.we.close(), this.we = void 0), this.u.log(r.Trace, "(WebSockets transport) socket closed."), this.onclose && (!this.ge(d) || d.wasClean !== !1 && d.code === 1e3 ? d instanceof Error ? this.onclose(d) : this.onclose() : this.onclose(new Error(`WebSocket closed with status code: ${d.code} (${d.reason || "no reason given"}).`)));
        }
        ge(d) {
          return d && typeof d.wasClean == "boolean" && typeof d.code == "number";
        }
      };
      a(Au, "V");
      let Xh = Au;
      const Eu = class Eu {
        constructor(d, w = {}) {
          var k;
          if (this.me = () => {
          }, this.features = {}, this.ye = 1, R.isRequired(d, "url"), this.u = (k = w.logger) === void 0 ? new tt(r.Information) : k === null ? A.instance : k.log !== void 0 ? k : new tt(k), this.baseUrl = this.be(d), (w = w || {}).logMessageContent = w.logMessageContent !== void 0 && w.logMessageContent, typeof w.withCredentials != "boolean" && w.withCredentials !== void 0) throw new Error("withCredentials option was not a 'boolean' or 'undefined' value");
          w.withCredentials = w.withCredentials === void 0 || w.withCredentials, w.timeout = w.timeout === void 0 ? 1e5 : w.timeout;
          let P = null, T = null;
          if (V.isNode) {
            const z = zu;
            P = z("ws"), T = z("eventsource");
          }
          V.isNode || typeof WebSocket > "u" || w.WebSocket ? V.isNode && !w.WebSocket && P && (w.WebSocket = P) : w.WebSocket = WebSocket, V.isNode || typeof EventSource > "u" || w.EventSource ? V.isNode && !w.EventSource && T !== void 0 && (w.EventSource = T) : w.EventSource = EventSource, this.$ = new Ve(w.httpClient || new Rt(this.u), w.accessTokenFactory), this.ut = "Disconnected", this.dt = !1, this.ie = w, this.onreceive = null, this.onclose = null;
        }
        async start(d) {
          if (d = d || re.Binary, R.isIn(d, re, "transferFormat"), this.u.log(r.Debug, `Starting connection with transfer format '${re[d]}'.`), this.ut !== "Disconnected") return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."));
          if (this.ut = "Connecting", this.ve = this.yt(d), await this.ve, this.ut === "Disconnecting") {
            const w = "Failed to start the HttpConnection before stop() was called.";
            return this.u.log(r.Error, w), await this.It, Promise.reject(new l(w));
          }
          if (this.ut !== "Connected") {
            const w = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";
            return this.u.log(r.Error, w), Promise.reject(new l(w));
          }
          this.dt = !0;
        }
        send(d) {
          return this.ut !== "Connected" ? Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State.")) : (this.Ee || (this.Ee = new tu(this.transport)), this.Ee.send(d));
        }
        async stop(d) {
          return this.ut === "Disconnected" ? (this.u.log(r.Debug, `Call to HttpConnection.stop(${d}) ignored because the connection is already in the disconnected state.`), Promise.resolve()) : this.ut === "Disconnecting" ? (this.u.log(r.Debug, `Call to HttpConnection.stop(${d}) ignored because the connection is already in the disconnecting state.`), this.It) : (this.ut = "Disconnecting", this.It = new Promise(((w) => {
            this.me = w;
          })), await this._t(d), void await this.It);
        }
        async _t(d) {
          this.$e = d;
          try {
            await this.ve;
          } catch {
          }
          if (this.transport) {
            try {
              await this.transport.stop();
            } catch (w) {
              this.u.log(r.Error, `HttpConnection.transport.stop() threw error '${w}'.`), this.Ce();
            }
            this.transport = void 0;
          } else this.u.log(r.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.");
        }
        async yt(d) {
          let w = this.baseUrl;
          this.Yt = this.ie.accessTokenFactory, this.$.Yt = this.Yt;
          try {
            if (this.ie.skipNegotiation) {
              if (this.ie.transport !== Et.WebSockets) throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");
              this.transport = this.Se(Et.WebSockets), await this.ke(w, d);
            } else {
              let k = null, P = 0;
              do {
                if (k = await this.Pe(w), this.ut === "Disconnecting" || this.ut === "Disconnected") throw new l("The connection was stopped during negotiation.");
                if (k.error) throw new Error(k.error);
                if (k.ProtocolVersion) throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");
                if (k.url && (w = k.url), k.accessToken) {
                  const T = k.accessToken;
                  this.Yt = () => T, this.$.Zt = T, this.$.Yt = void 0;
                }
                P++;
              } while (k.url && P < 100);
              if (P === 100 && k.url) throw new Error("Negotiate redirection limit exceeded.");
              await this.Te(w, this.ie.transport, k, d);
            }
            this.transport instanceof Sd && (this.features.inherentKeepAlive = !0), this.ut === "Connecting" && (this.u.log(r.Debug, "The HttpConnection connected successfully."), this.ut = "Connected");
          } catch (k) {
            return this.u.log(r.Error, "Failed to start the connection: " + k), this.ut = "Disconnected", this.transport = void 0, this.me(), Promise.reject(k);
          }
        }
        async Pe(d) {
          const w = {}, [k, P] = ot();
          w[k] = P;
          const T = this.Ie(d);
          this.u.log(r.Debug, `Sending negotiation request: ${T}.`);
          try {
            const z = await this.$.post(T, { content: "", headers: { ...w, ...this.ie.headers }, timeout: this.ie.timeout, withCredentials: this.ie.withCredentials });
            if (z.statusCode !== 200) return Promise.reject(new Error(`Unexpected status code returned from negotiate '${z.statusCode}'`));
            const Z = JSON.parse(z.content);
            return (!Z.negotiateVersion || Z.negotiateVersion < 1) && (Z.connectionToken = Z.connectionId), Z.useStatefulReconnect && this.ie._e !== !0 ? Promise.reject(new g("Client didn't negotiate Stateful Reconnect but the server did.")) : Z;
          } catch (z) {
            let Z = "Failed to complete negotiation with the server: " + z;
            return z instanceof o && z.statusCode === 404 && (Z += " Either this is not a SignalR endpoint or there is a proxy blocking the connection."), this.u.log(r.Error, Z), Promise.reject(new g(Z));
          }
        }
        He(d, w) {
          return w ? d + (d.indexOf("?") === -1 ? "?" : "&") + `id=${w}` : d;
        }
        async Te(d, w, k, P) {
          let T = this.He(d, k.connectionToken);
          if (this.De(w)) return this.u.log(r.Debug, "Connection was provided an instance of ITransport, using that directly."), this.transport = w, await this.ke(T, P), void (this.connectionId = k.connectionId);
          const z = [], Z = k.availableTransports || [];
          let Y = k;
          for (const ft of Z) {
            const Tt = this.Re(ft, w, P, Y?.useStatefulReconnect === !0);
            if (Tt instanceof Error) z.push(`${ft.transport} failed:`), z.push(Tt);
            else if (this.De(Tt)) {
              if (this.transport = Tt, !Y) {
                try {
                  Y = await this.Pe(d);
                } catch (ca) {
                  return Promise.reject(ca);
                }
                T = this.He(d, Y.connectionToken);
              }
              try {
                return await this.ke(T, P), void (this.connectionId = Y.connectionId);
              } catch (ca) {
                if (this.u.log(r.Error, `Failed to start the transport '${ft.transport}': ${ca}`), Y = void 0, z.push(new C(`${ft.transport} failed: ${ca}`, Et[ft.transport])), this.ut !== "Connecting") {
                  const Vw = "Failed to select transport before stop() was called.";
                  return this.u.log(r.Debug, Vw), Promise.reject(new l(Vw));
                }
              }
            }
          }
          return z.length > 0 ? Promise.reject(new m(`Unable to connect to the server with any of the available transports. ${z.join(" ")}`, z)) : Promise.reject(new Error("None of the transports supported by the client are supported by the server."));
        }
        Se(d) {
          switch (d) {
            case Et.WebSockets:
              if (!this.ie.WebSocket) throw new Error("'WebSocket' is not supported in your environment.");
              return new Xh(this.$, this.Yt, this.u, this.ie.logMessageContent, this.ie.WebSocket, this.ie.headers || {});
            case Et.ServerSentEvents:
              if (!this.ie.EventSource) throw new Error("'EventSource' is not supported in your environment.");
              return new Yh(this.$, this.$.Zt, this.u, this.ie);
            case Et.LongPolling:
              return new Sd(this.$, this.u, this.ie);
            default:
              throw new Error(`Unknown transport: ${d}.`);
          }
        }
        ke(d, w) {
          return this.transport.onreceive = this.onreceive, this.features.reconnect ? this.transport.onclose = async (k) => {
            let P = !1;
            if (this.features.reconnect) {
              try {
                this.features.disconnected(), await this.transport.connect(d, w), await this.features.resend();
              } catch {
                P = !0;
              }
              P && this.Ce(k);
            } else this.Ce(k);
          } : this.transport.onclose = (k) => this.Ce(k), this.transport.connect(d, w);
        }
        Re(d, w, k, P) {
          const T = Et[d.transport];
          if (T == null) return this.u.log(r.Debug, `Skipping transport '${d.transport}' because it is not supported by this client.`), new Error(`Skipping transport '${d.transport}' because it is not supported by this client.`);
          if (!(function(z, Z) {
            return !z || !!(Z & z);
          })(w, T)) return this.u.log(r.Debug, `Skipping transport '${Et[T]}' because it was disabled by the client.`), new v(`'${Et[T]}' is disabled by the client.`, T);
          if (!(d.transferFormats.map(((z) => re[z])).indexOf(k) >= 0)) return this.u.log(r.Debug, `Skipping transport '${Et[T]}' because it does not support the requested transfer format '${re[k]}'.`), new Error(`'${Et[T]}' does not support ${re[k]}.`);
          if (T === Et.WebSockets && !this.ie.WebSocket || T === Et.ServerSentEvents && !this.ie.EventSource) return this.u.log(r.Debug, `Skipping transport '${Et[T]}' because it is not supported in your environment.'`), new p(`'${Et[T]}' is not supported in your environment.`, T);
          this.u.log(r.Debug, `Selecting transport '${Et[T]}'.`);
          try {
            return this.features.reconnect = T === Et.WebSockets ? P : void 0, this.Se(T);
          } catch (z) {
            return z;
          }
        }
        De(d) {
          return d && typeof d == "object" && "connect" in d;
        }
        Ce(d) {
          if (this.u.log(r.Debug, `HttpConnection.stopConnection(${d}) called while in state ${this.ut}.`), this.transport = void 0, d = this.$e || d, this.$e = void 0, this.ut !== "Disconnected") {
            if (this.ut === "Connecting") throw this.u.log(r.Warning, `Call to HttpConnection.stopConnection(${d}) was ignored because the connection is still in the connecting state.`), new Error(`HttpConnection.stopConnection(${d}) was called while the connection is still in the connecting state.`);
            if (this.ut === "Disconnecting" && this.me(), d ? this.u.log(r.Error, `Connection disconnected with error '${d}'.`) : this.u.log(r.Information, "Connection disconnected."), this.Ee && (this.Ee.stop().catch(((w) => {
              this.u.log(r.Error, `TransportSendQueue.stop() threw error '${w}'.`);
            })), this.Ee = void 0), this.connectionId = void 0, this.ut = "Disconnected", this.dt) {
              this.dt = !1;
              try {
                this.onclose && this.onclose(d);
              } catch (w) {
                this.u.log(r.Error, `HttpConnection.onclose(${d}) threw error '${w}'.`);
              }
            }
          } else this.u.log(r.Debug, `Call to HttpConnection.stopConnection(${d}) was ignored because the connection is already in the disconnected state.`);
        }
        be(d) {
          if (d.lastIndexOf("https://", 0) === 0 || d.lastIndexOf("http://", 0) === 0) return d;
          if (!V.isBrowser) throw new Error(`Cannot resolve '${d}'.`);
          const w = window.document.createElement("a");
          return w.href = d, this.u.log(r.Information, `Normalizing '${d}' to '${w.href}'.`), w.href;
        }
        Ie(d) {
          const w = new URL(d);
          w.pathname.endsWith("/") ? w.pathname += "negotiate" : w.pathname += "/negotiate";
          const k = new URLSearchParams(w.searchParams);
          return k.has("negotiateVersion") || k.append("negotiateVersion", this.ye.toString()), k.has("useStatefulReconnect") ? k.get("useStatefulReconnect") === "true" && (this.ie._e = !0) : this.ie._e === !0 && k.append("useStatefulReconnect", "true"), w.search = k.toString(), w.toString();
        }
      };
      a(Eu, "K");
      let Jh = Eu;
      const Ed = class Ed {
        constructor(d) {
          this.xe = d, this.Ae = [], this.Ue = !0, this.Le = new aa(), this.Ne = new aa(), this.qe = this.Me();
        }
        send(d) {
          return this.je(d), this.Ne || (this.Ne = new aa()), this.Ne.promise;
        }
        stop() {
          return this.Ue = !1, this.Le.resolve(), this.qe;
        }
        je(d) {
          if (this.Ae.length && typeof this.Ae[0] != typeof d) throw new Error(`Expected data to be of type ${typeof this.Ae} but was of type ${typeof d}`);
          this.Ae.push(d), this.Le.resolve();
        }
        async Me() {
          for (; ; ) {
            if (await this.Le.promise, !this.Ue) {
              this.Ne && this.Ne.reject("Connection stopped.");
              break;
            }
            this.Le = new aa();
            const d = this.Ne;
            this.Ne = void 0;
            const w = typeof this.Ae[0] == "string" ? this.Ae.join("") : Ed.We(this.Ae);
            this.Ae.length = 0;
            try {
              await this.xe.send(w), d.resolve();
            } catch (k) {
              d.reject(k);
            }
          }
        }
        static We(d) {
          const w = d.map(((T) => T.byteLength)).reduce(((T, z) => T + z)), k = new Uint8Array(w);
          let P = 0;
          for (const T of d) k.set(new Uint8Array(T), P), P += T.byteLength;
          return k.buffer;
        }
      };
      a(Ed, "G");
      let tu = Ed;
      const Ru = class Ru {
        constructor() {
          this.promise = new Promise(((d, w) => [this.j, this.Oe] = [d, w]));
        }
        resolve() {
          this.j();
        }
        reject(d) {
          this.Oe(d);
        }
      };
      a(Ru, "Q");
      let aa = Ru;
      const Tu = class Tu {
        constructor() {
          this.name = "json", this.version = 2, this.transferFormat = re.Text;
        }
        parseMessages(d, w) {
          if (typeof d != "string") throw new Error("Invalid input for JSON hub protocol. Expected a string.");
          if (!d) return [];
          w === null && (w = A.instance);
          const k = xt.parse(d), P = [];
          for (const T of k) {
            const z = JSON.parse(T);
            if (typeof z.type != "number") throw new Error("Invalid payload.");
            switch (z.type) {
              case ct.Invocation:
                this.U(z);
                break;
              case ct.StreamItem:
                this.Fe(z);
                break;
              case ct.Completion:
                this.Be(z);
                break;
              case ct.Ping:
              case ct.Close:
                break;
              case ct.Ack:
                this.Xe(z);
                break;
              case ct.Sequence:
                this.Je(z);
                break;
              default:
                w.log(r.Information, "Unknown message type '" + z.type + "' ignored.");
                continue;
            }
            P.push(z);
          }
          return P;
        }
        writeMessage(d) {
          return xt.write(JSON.stringify(d));
        }
        U(d) {
          this.ze(d.target, "Invalid payload for Invocation message."), d.invocationId !== void 0 && this.ze(d.invocationId, "Invalid payload for Invocation message.");
        }
        Fe(d) {
          if (this.ze(d.invocationId, "Invalid payload for StreamItem message."), d.item === void 0) throw new Error("Invalid payload for StreamItem message.");
        }
        Be(d) {
          if (d.result && d.error) throw new Error("Invalid payload for Completion message.");
          !d.result && d.error && this.ze(d.error, "Invalid payload for Completion message."), this.ze(d.invocationId, "Invalid payload for Completion message.");
        }
        Xe(d) {
          if (typeof d.sequenceId != "number") throw new Error("Invalid SequenceId for Ack message.");
        }
        Je(d) {
          if (typeof d.sequenceId != "number") throw new Error("Invalid SequenceId for Sequence message.");
        }
        ze(d, w) {
          if (typeof d != "string" || d === "") throw new Error(w);
        }
      };
      a(Tu, "Y");
      let Md = Tu;
      const m1 = { trace: r.Trace, debug: r.Debug, info: r.Information, information: r.Information, warn: r.Warning, warning: r.Warning, error: r.Error, critical: r.Critical, none: r.None }, Lu = class Lu {
        configureLogging(d) {
          if (R.isRequired(d, "logging"), d.log !== void 0) this.logger = d;
          else if (typeof d == "string") {
            const w = (function(k) {
              const P = m1[k.toLowerCase()];
              if (P !== void 0) return P;
              throw new Error(`Unknown log level: ${k}`);
            })(d);
            this.logger = new tt(w);
          } else this.logger = new tt(d);
          return this;
        }
        withUrl(d, w) {
          return R.isRequired(d, "url"), R.isNotEmpty(d, "url"), this.url = d, this.httpConnectionOptions = typeof w == "object" ? { ...this.httpConnectionOptions, ...w } : { ...this.httpConnectionOptions, transport: w }, this;
        }
        withHubProtocol(d) {
          return R.isRequired(d, "protocol"), this.protocol = d, this;
        }
        withAutomaticReconnect(d) {
          if (this.reconnectPolicy) throw new Error("A reconnectPolicy has already been set.");
          return d ? Array.isArray(d) ? this.reconnectPolicy = new Ci(d) : this.reconnectPolicy = d : this.reconnectPolicy = new Ci(), this;
        }
        withServerTimeout(d) {
          return R.isRequired(d, "milliseconds"), this.Ve = d, this;
        }
        withKeepAliveInterval(d) {
          return R.isRequired(d, "milliseconds"), this.Ke = d, this;
        }
        withStatefulReconnect(d) {
          return this.httpConnectionOptions === void 0 && (this.httpConnectionOptions = {}), this.httpConnectionOptions._e = !0, this.Y = d?.bufferSize, this;
        }
        build() {
          const d = this.httpConnectionOptions || {};
          if (d.logger === void 0 && (d.logger = this.logger), !this.url) throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");
          const w = new Jh(this.url, d);
          return Bi.create(w, this.logger || A.instance, this.protocol || new Md(), this.reconnectPolicy, this.Ve, this.Ke, this.Y);
        }
      };
      a(Lu, "tt");
      let eu = Lu;
      return Uint8Array.prototype.indexOf || Object.defineProperty(Uint8Array.prototype, "indexOf", { value: Array.prototype.indexOf, writable: !0 }), Uint8Array.prototype.slice || Object.defineProperty(Uint8Array.prototype, "slice", { value: /* @__PURE__ */ a(function(H, d) {
        return new Uint8Array(Array.prototype.slice.call(this, H, d));
      }, "value"), writable: !0 }), Uint8Array.prototype.forEach || Object.defineProperty(Uint8Array.prototype, "forEach", { value: Array.prototype.forEach, writable: !0 }), s;
    })(), "e"), n.exports = e();
  })(Iu)), Iu.exports;
}
a(j1, "requireSignalr_min");
var Uw = /* @__PURE__ */ j1();
const W1 = /* @__PURE__ */ a((n) => {
  var t;
  return t = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...i) {
      super(...i), this._whenConnectionRequested = new Promise((r) => {
        this._resolveConnectionRequested = r;
      }), this._whenConnectionCreated = new Promise((r) => {
        this._resolveConnectionCreated = r;
      }), this._connectionEventListeners = [], this.signalRAccessTokenRefresh = !1, this._whenConnectionStarted = new Promise((r, s) => {
        this._whenConnectionStartedResolve = r, this._whenConnectionStartedReject = s;
      }), this.whenConnectionRequested().then(() => {
        this.isDestroyed || this.createConnection();
      });
    }
    async whenConnectionRequested() {
      await this._whenConnectionRequested;
    }
    async whenConnectionCreated() {
      return await this._whenConnectionCreated;
    }
    get rtmConnection() {
      return this._connection;
    }
    async whenConnectionStarted() {
      return await this._whenConnectionStarted;
    }
    async createConnection() {
      if (this.isDestroyed)
        throw new Ut();
      if (this.networkStateIsPending = !0, await this.whenUrlAndTokenFactory(), this._connection) {
        const i = new URL("/hubs/rtm", this.url);
        this._connection.baseUrl !== i.toString() && (this.connectionState = "reconnecting", console.info(
          this.weavyId,
          "Reconnecting due to changed url.",
          this._connection.baseUrl,
          "=>",
          i.toString()
        ), await this.disconnect(), this._connection.baseUrl = i.toString(), this.connect());
      } else {
        this.connectionState = "connecting";
        const i = new URL("/hubs/rtm", this.url);
        this._connection = new Uw.HubConnectionBuilder().configureLogging(Uw.LogLevel.None).withUrl(i.toString(), {
          accessTokenFactory: /* @__PURE__ */ a(async () => {
            try {
              if (this.signalRAccessTokenRefresh) {
                const r = await this.getToken(!0);
                return this.signalRAccessTokenRefresh = !1, r;
              } else
                return await this.getToken();
            } catch (r) {
              throw console.error(r), r;
            }
          }, "accessTokenFactory")
        }).withAutomaticReconnect({
          nextRetryDelayInMilliseconds: /* @__PURE__ */ a((r) => !this.isDestroyed && window.navigator.onLine && document?.visibilityState !== "hidden" && r.elapsedMilliseconds < 6e4 ? [0, 2e3, 1e4][r.previousRetryCount] || 1e4 : null, "nextRetryDelayInMilliseconds")
        }).build(), this._connection.onclose(() => {
          console.info(this.weavyId, "SignalR closed."), this.connectionState = "disconnected", !this.isDestroyed && (this.networkStateIsPending = !0, this._whenConnectionStarted = new Promise((r, s) => {
            this._whenConnectionStartedResolve = r, this._whenConnectionStartedReject = s;
          }), this.connect());
        }), this._connection.onreconnecting(() => {
          console.info(this.weavyId, "SignalR reconnecting..."), this.connectionState = "reconnecting";
        }), this._connection.onreconnected((r) => {
          console.info(this.weavyId, `SignalR reconnected ${r}`), this.connectionState = "connected", this.networkStateIsPending = !1;
          for (let s = 0; s < this._connectionEventListeners.length; s++)
            this._connection?.invoke("Subscribe", this._connectionEventListeners[s].name);
        }), this._resolveConnectionCreated?.(this._connection), this.connect();
      }
      return this._connection;
    }
    async disconnect() {
      this._connection && (await this._connection.stop(), this.connectionState = "disconnected");
    }
    async connect() {
      if (this.isDestroyed)
        throw new Ut();
      let i;
      this._connection ? i = this._connection : i = await this.whenConnectionCreated(), console.info(this.weavyId, "Connecting SignalR...");
      try {
        if (!window.navigator.onLine)
          throw new Error();
        await Promise.race([i.start(), this.whenConnectionStarted()]), this.signalRAccessTokenRefresh = !1, this.networkStateIsPending = !1, this.connectionState = "connected", this._whenConnectionStartedResolve?.(i), console.info(this.weavyId, `SignalR connected ${i.connectionId}`);
      } catch (r) {
        if (r instanceof Ut)
          return console.warn(this.weavyId, "SignalR connection aborted."), i;
        window.navigator.onLine ? !this.signalRAccessTokenRefresh && window.document.visibilityState !== "hidden" && r.toString().includes("Unauthorized") ? (console.info(this.weavyId, "Retrying SignalR connect with fresh token."), this.signalRAccessTokenRefresh = !0) : (console.info(
          this.weavyId,
          "Server is probably down, retrying SignalR connect after a delay or when window regains focus."
        ), this.connectionState = "reconnecting", await new Promise((s) => {
          setTimeout(s, 5e3), window.addEventListener("visibilitychange", s, { once: !0 }), window.addEventListener("offline", s, { once: !0 }), window.addEventListener("online", s, { once: !0 });
        })) : (this.networkStateIsPending = !1, console.info(this.weavyId, "Offline, reconnecting SignalR when online."), await new Promise((s) => {
          window.addEventListener("online", s, { once: !0 });
        })), window.navigator.onLine && document?.visibilityState !== "hidden" && await new Promise((s) => setTimeout(s, 1e3)), this.checkVersion(), this.networkStateIsPending = !0, await this.connect();
      }
      return i;
    }
    async subscribe(i, r, s) {
      if (this.isDestroyed)
        throw new Ut();
      this._resolveConnectionRequested?.(!0);
      const o = i ? i + ":" + r : r;
      try {
        if (this._connectionEventListeners || await new Promise((l) => queueMicrotask(() => l(!0))), this._connectionEventListeners.some((l) => l.name === o && l.callback === s))
          throw new Error("Duplicate subscribe: " + o);
        if (this._connectionEventListeners.push({ name: o, callback: s }), await this.whenConnectionStarted(), !this._connection)
          throw new Error("Connection not created");
        if (this._connection.on(o, s), await this._connection.invoke("Subscribe", o) === !1)
          throw new Error("Could not subscribe to " + o);
        return !0;
      } catch (c) {
        c instanceof Ut || console.error(this.weavyId, "Error in Subscribe:", c);
        const l = this._connectionEventListeners.findIndex((p) => p.name === o && p.callback === s);
        return l !== -1 && (this._connectionEventListeners.splice(l, 1), this._connection?.off(o, s)), !1;
      }
    }
    async unsubscribe(i, r, s) {
      if (this.isDestroyed)
        throw new Ut();
      try {
        const o = i ? i + ":" + r : r, c = this._connectionEventListeners.findIndex((l) => l.name === o && l.callback === s);
        if (c !== -1) {
          if (this._connectionEventListeners.splice(c, 1), await this.whenConnectionStarted(), !this._connection)
            throw new Error("Connection not created");
          this._connection?.off(o, s), this._connectionEventListeners.some((l) => l.name === o) || await this._connection.invoke("Unsubscribe", o);
        }
      } catch (o) {
        o instanceof Ut || console.error(this.weavyId, "Error in Unsubscribe:", o);
      }
    }
    destroy() {
      super.destroy(), this.disconnect(), this._whenConnectionStartedReject && (this._whenConnectionStarted.catch(() => {
      }), this._whenConnectionStartedReject(new Ut()));
    }
  }, a(t, "WeavyConnection"), t;
}, "WeavyConnectionMixin");
var qd = /* @__PURE__ */ ((n) => (n.JSON = "application/json;charset=utf-8", n.FormData = "multipart/form-data;charset=utf-8", n.URLEncoded = "application/x-www-form-urlencoded;charset=utf-8", n.Text = "text/plain;charset=utf-8", n.Auto = "", n))(qd || {});
const K1 = /* @__PURE__ */ a((n) => {
  var t;
  return t = class extends n {
    // FETCH
    async fetchOptions(i = {}, r = !0) {
      if (this.isDestroyed)
        throw new Ut();
      const s = {
        headers: {
          "X-Weavy-Source": `${ae.sourceName}@${ae.version}`,
          "Content-Type": qd.JSON
        },
        method: "GET"
      }, o = Pa(Pa(H1, s, !0), i, !0);
      return r ? Pa(
        o,
        {
          headers: {
            Authorization: "Bearer " + await this.getToken()
          }
        },
        !0
      ) : o;
    }
    async fetch(i, r, s = !0) {
      if (this.isDestroyed)
        throw new Ut();
      const o = await this.fetchOptions(r);
      this.networkStateIsPending = !0;
      const c = await fetch(new URL(i, this.url), o);
      if (c.ok)
        this.networkStateIsPending = !1, this.serverState = "ok";
      else if (c.status === 401 || c.status === 403) {
        if (s)
          return await this.getToken(!0), await this.fetch(i, r, !1);
        this.networkStateIsPending = !1, this.serverState = "unauthorized";
      } else
        this.networkStateIsPending = !1;
      return c;
    }
    async upload(i, r, s, o = qd.JSON, c, l, p = !0) {
      if (this.isDestroyed)
        throw new Ut();
      const v = await this.getToken();
      return await new Promise((C, g) => {
        const m = new XMLHttpRequest();
        m.open(r, new URL(i, this.url), !0), m.setRequestHeader("Authorization", "Bearer " + v), m.setRequestHeader("X-Weavy-Source", `${ae.sourceName}@${ae.version}`), o && m.setRequestHeader("Content-Type", o), c && m.upload.addEventListener("progress", (f) => {
          c(f.loaded / f.total * 100 || 100);
        }), m.onload = (f) => {
          p && (m.status === 401 || m.status === 401) ? this.getToken(!0).then(() => this.upload(i, r, s, o, c, l, !1)).then(C).catch(g) : C(new Response(m.response, { status: m.status, statusText: m.statusText }));
        }, m.onerror = g, m.onabort = g, l?.addEventListener("abort", () => {
          m.abort();
        }), m.send(s);
      });
    }
    // DEPRECATED
    async get(i) {
      return console.warn(`weavy.get() is deprecated, use weavy.fetch("${i}") instead.`), this.fetch(i);
    }
    // DEPRECATED
    async post(i, r, s, o) {
      console.warn(
        `weavy.post() is deprecated, use weavy.fetch("${i}", { method: "${r}"}) instead.`
      );
      const c = o ? { "Content-Type": o } : void 0;
      return this.fetch(i, { method: r, body: s, headers: c });
    }
  }, a(t, "WeavyFetch"), t;
}, "WeavyFetchMixin"), hm = "en", Q1 = /* @__PURE__ */ a((n) => {
  var t;
  return t = class extends n {
    constructor() {
      super(...arguments), this._locales = /* @__PURE__ */ new Map([
        ["sv-SE", () => import(
          /* webpackIgnore: true */
          /* @vite-ignore */
          new URL("./es/locales/sv-SE-DNn-JJCG.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
        ).then((i) => i.svSE)]
      ]), this._locale = t.sourceLocale;
    }
    /**
     * The locale used in the Weavy source.
     */
    static get sourceLocale() {
      try {
        return hm;
      } catch {
        return "";
      }
    }
    get locales() {
      return Array.from(this._locales.entries());
    }
    set locales(i) {
      if (this.isDestroyed)
        throw new Ut();
      if (this.localization)
        throw new Error("Locales may only be configured once");
      if (i) {
        if (!Array.isArray(i))
          throw new TypeError("Provided locales have invalid format.");
        i.forEach((r) => {
          if (!Array.isArray(r) || r.length !== 2 || typeof r[0] != "string")
            throw new TypeError("Invalid locale provided: " + r[0]);
          this._locales.set(...r);
        }), this.configureLocalization();
      }
    }
    get localization() {
      return this._localization;
    }
    /**
     * Selected locale. The locale must be pre configured in `.locales`.
     */
    get locale() {
      return this._locale;
    }
    set locale(i) {
      if (this.isDestroyed)
        throw new Ut();
      !this._locale && !i || (i ||= t.sourceLocale, this._locale = i, this.localization ? this.localization.setLocale(this._locale) : queueMicrotask(() => {
        this.localization ? this.localization.setLocale(this._locale) : this._locale !== t.sourceLocale && (this._locales.has(this._locale) && this.configureLocalization(), this.localization ? this.localization.setLocale(this._locale) : console.error(
          this.weavyId,
          `You need to configure additional languages in config to use '${i}'.`
        ));
      }));
    }
    async loadLocale(i) {
      if (this.isDestroyed)
        throw new Ut();
      if (this._locales?.has(i)) {
        const r = this._locales.get(i);
        return console.info(
          this.weavyId,
          typeof r == "function" ? "loading locale" : "preloaded locale",
          i
        ), await (typeof r == "function" ? r() : r);
      } else
        throw new Error("The requested locale is not configured");
    }
    configureLocalization() {
      if (this.isDestroyed)
        throw new Ut();
      if (this._locales?.size && !this.localization) {
        const i = this._locales.keys();
        console.info(this.weavyId, "Configuring locales", i);
        const { getLocale: r, setLocale: s } = $1({
          sourceLocale: t.sourceLocale,
          targetLocales: i,
          loadLocale: /* @__PURE__ */ a((o) => this.loadLocale(o), "loadLocale")
        });
        this._localization = {
          getLocale: r,
          setLocale: s
        };
      }
    }
  }, a(t, "WeavyLocalization"), t;
}, "WeavyLocalizationMixin"), G1 = /* @__PURE__ */ a((n) => {
  var t;
  return t = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...i) {
      super(...i), this._configurationState = "pending", this._networkEvents = /* @__PURE__ */ new Set(), this._connectionState = "connecting", this._serverState = "ok", this._networkState = window.navigator.onLine ? "online" : "offline", this._networkStateIsPending = !1, window.addEventListener("online", () => {
        this.networkState = "online";
      }), window.addEventListener("offline", () => {
        this.networkState = "offline", this.networkStateIsPending = !1;
      }), queueMicrotask(() => this.requestConfigurationCheck());
    }
    get configurationState() {
      return this._configurationState;
    }
    set configurationState(i) {
      this._configurationState = i, this._configurationTimer && i === "configured" && (window.clearTimeout(this._configurationTimer), this._configurationTimer = null), this.triggerNetworkChange();
    }
    get networkState() {
      return this._networkState;
    }
    set networkState(i) {
      this._networkState = i, this.triggerNetworkChange();
    }
    get serverState() {
      return this._serverState;
    }
    set serverState(i) {
      this._serverState = i, this.triggerNetworkChange();
    }
    get connectionState() {
      return this._connectionState;
    }
    set connectionState(i) {
      this._connectionState = i, this.triggerNetworkChange();
    }
    get networkStateIsPending() {
      return this._networkStateIsPending;
    }
    set networkStateIsPending(i) {
      this._networkStateIsPending = i, this.triggerNetworkChange();
    }
    get network() {
      return {
        state: this._networkState === "online" ? (this._connectionState === "connected" || this._serverState === "ok") && this.configurationState !== "uninitialized" ? "online" : "unreachable" : "offline",
        isPending: this._networkStateIsPending
      };
    }
    requestConfigurationCheck() {
      !this._configurationTimer && this.configurationTimeout >= 0 && this.configurationTimeout < 1 / 0 && (this._configurationTimer = window.setTimeout(() => {
        this.configurationState === "pending" && (this.configurationState = "uninitialized", console.error("Weavy was not configured with required url and tokenFactory/tokenUrl within a reasonable time. Please check your configuration!")), this._configurationTimer = null;
      }, this.configurationTimeout));
    }
    triggerNetworkChange() {
      const i = this.network;
      this._networkEvents.forEach((r) => {
        r(i);
      });
    }
    addNetworkListener(i) {
      this._networkEvents.add(i);
    }
    removeNetworkListener(i) {
      this._networkEvents.delete(i);
    }
  }, a(t, "WeavyNetwork"), t;
}, "WeavyNetworkMixin");
var Ma, Wc = (Ma = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, a(Ma, "Subscribable"), Ma), Z1 = {
  // We need the wrapper function syntax below instead of direct references to
  // global setTimeout etc.
  //
  // BAD: `setTimeout: setTimeout`
  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
  //
  // If we use direct references here, then anything that wants to spy on or
  // replace the global setTimeout (like tests) won't work since we'll already
  // have a hard reference to the original implementation at the time when this
  // file was imported.
  setTimeout: /* @__PURE__ */ a((n, t) => setTimeout(n, t), "setTimeout"),
  clearTimeout: /* @__PURE__ */ a((n) => clearTimeout(n), "clearTimeout"),
  setInterval: /* @__PURE__ */ a((n, t) => setInterval(n, t), "setInterval"),
  clearInterval: /* @__PURE__ */ a((n) => clearInterval(n), "clearInterval")
}, Cr, Yp, Aa, Y1 = (Aa = class {
  constructor() {
    // We cannot have TimeoutManager<T> as we must instantiate it with a concrete
    // type at app boot; and if we leave that type, then any new timer provider
    // would need to support ReturnType<typeof setTimeout>, which is infeasible.
    //
    // We settle for type safety for the TimeoutProvider type, and accept that
    // this class is unsafe internally to allow for extension.
    O(this, Cr, Z1);
    O(this, Yp, !1);
  }
  setTimeoutProvider(t) {
    _(this, Cr, t);
  }
  setTimeout(t, e) {
    return y(this, Cr).setTimeout(t, e);
  }
  clearTimeout(t) {
    y(this, Cr).clearTimeout(t);
  }
  setInterval(t, e) {
    return y(this, Cr).setInterval(t, e);
  }
  clearInterval(t) {
    y(this, Cr).clearInterval(t);
  }
}, Cr = new WeakMap(), Yp = new WeakMap(), a(Aa, "TimeoutManager"), Aa), Lr = new Y1();
function X1(n) {
  setTimeout(n, 0);
}
a(X1, "systemSetTimeoutZero");
var $c = typeof window > "u" || "Deno" in globalThis;
function Me() {
}
a(Me, "noop$1");
function J1(n, t) {
  return typeof n == "function" ? n(t) : n;
}
a(J1, "functionalUpdate");
function Xu(n) {
  return typeof n == "number" && n >= 0 && n !== 1 / 0;
}
a(Xu, "isValidTimeout");
function um(n, t) {
  return Math.max(n + (t || 0) - Date.now(), 0);
}
a(um, "timeUntilStale");
function Ir(n, t) {
  return typeof n == "function" ? n(t) : n;
}
a(Ir, "resolveStaleTime");
function ai(n, t) {
  return typeof n == "function" ? n(t) : n;
}
a(ai, "resolveEnabled");
function qw(n, t) {
  const {
    type: e = "all",
    exact: i,
    fetchStatus: r,
    predicate: s,
    queryKey: o,
    stale: c
  } = n;
  if (o) {
    if (i) {
      if (t.queryHash !== ty(o, t.options))
        return !1;
    } else if (!ml(t.queryKey, o))
      return !1;
  }
  if (e !== "all") {
    const l = t.isActive();
    if (e === "active" && !l || e === "inactive" && l)
      return !1;
  }
  return !(typeof c == "boolean" && t.isStale() !== c || r && r !== t.state.fetchStatus || s && !s(t));
}
a(qw, "matchQuery");
function jw(n, t) {
  const { exact: e, status: i, predicate: r, mutationKey: s } = n;
  if (s) {
    if (!t.options.mutationKey)
      return !1;
    if (e) {
      if (Pn(t.options.mutationKey) !== Pn(s))
        return !1;
    } else if (!ml(t.options.mutationKey, s))
      return !1;
  }
  return !(i && t.state.status !== i || r && !r(t));
}
a(jw, "matchMutation");
function ty(n, t) {
  return (t?.queryKeyHashFn || Pn)(n);
}
a(ty, "hashQueryKeyByOptions");
function Pn(n) {
  return JSON.stringify(
    n,
    (t, e) => Ju(e) ? Object.keys(e).sort().reduce((i, r) => (i[r] = e[r], i), {}) : e
  );
}
a(Pn, "hashKey");
function ml(n, t) {
  return n === t ? !0 : typeof n != typeof t ? !1 : n && t && typeof n == "object" && typeof t == "object" ? Object.keys(t).every((e) => ml(n[e], t[e])) : !1;
}
a(ml, "partialMatchKey");
var tg = Object.prototype.hasOwnProperty;
function dd(n, t, e = 0) {
  if (n === t)
    return n;
  if (e > 500) return t;
  const i = Ww(n) && Ww(t);
  if (!i && !(Ju(n) && Ju(t))) return t;
  const s = (i ? n : Object.keys(n)).length, o = i ? t : Object.keys(t), c = o.length, l = i ? new Array(c) : {};
  let p = 0;
  for (let v = 0; v < c; v++) {
    const C = i ? v : o[v], g = n[C], m = t[C];
    if (g === m) {
      l[C] = g, (i ? v < s : tg.call(n, C)) && p++;
      continue;
    }
    if (g === null || m === null || typeof g != "object" || typeof m != "object") {
      l[C] = m;
      continue;
    }
    const f = dd(g, m, e + 1);
    l[C] = f, f === g && p++;
  }
  return s === c && p === s ? n : l;
}
a(dd, "replaceEqualDeep");
function jd(n, t) {
  if (!t || Object.keys(n).length !== Object.keys(t).length)
    return !1;
  for (const e in n)
    if (n[e] !== t[e])
      return !1;
  return !0;
}
a(jd, "shallowEqualObjects");
function Ww(n) {
  return Array.isArray(n) && n.length === Object.keys(n).length;
}
a(Ww, "isPlainArray");
function Ju(n) {
  if (!Kw(n))
    return !1;
  const t = n.constructor;
  if (t === void 0)
    return !0;
  const e = t.prototype;
  return !(!Kw(e) || !e.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(n) !== Object.prototype);
}
a(Ju, "isPlainObject");
function Kw(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
a(Kw, "hasObjectPrototype");
function eg(n) {
  return new Promise((t) => {
    Lr.setTimeout(t, n);
  });
}
a(eg, "sleep");
function tp(n, t, e) {
  return typeof e.structuralSharing == "function" ? e.structuralSharing(n, t) : e.structuralSharing !== !1 ? dd(n, t) : t;
}
a(tp, "replaceData");
function ig(n, t, e = 0) {
  const i = [...n, t];
  return e && i.length > e ? i.slice(1) : i;
}
a(ig, "addToEnd");
function rg(n, t, e = 0) {
  const i = [t, ...n];
  return e && i.length > e ? i.slice(0, -1) : i;
}
a(rg, "addToStart");
var ey = Symbol();
function pm(n, t) {
  return !n.queryFn && t?.initialPromise ? () => t.initialPromise : !n.queryFn || n.queryFn === ey ? () => Promise.reject(new Error(`Missing queryFn: '${n.queryHash}'`)) : n.queryFn;
}
a(pm, "ensureQueryFn");
function ng(n, t, e) {
  let i = !1, r;
  return Object.defineProperty(n, "signal", {
    enumerable: !0,
    get: /* @__PURE__ */ a(() => (r ??= t(), i || (i = !0, r.aborted ? e() : r.addEventListener("abort", e, { once: !0 })), r), "get")
  }), n;
}
a(ng, "addConsumeAwareSignal");
var cn, $r, Ea, Ra, ag = (Ra = class extends Wc {
  constructor() {
    super();
    O(this, cn);
    O(this, $r);
    O(this, Ea);
    _(this, Ea, (e) => {
      if (!$c && window.addEventListener) {
        const i = /* @__PURE__ */ a(() => e(), "listener");
        return window.addEventListener("visibilitychange", i, !1), () => {
          window.removeEventListener("visibilitychange", i);
        };
      }
    });
  }
  onSubscribe() {
    y(this, $r) || this.setEventListener(y(this, Ea));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = y(this, $r)) == null || e.call(this), _(this, $r, void 0));
  }
  setEventListener(e) {
    var i;
    _(this, Ea, e), (i = y(this, $r)) == null || i.call(this), _(this, $r, e((r) => {
      typeof r == "boolean" ? this.setFocused(r) : this.onFocus();
    }));
  }
  setFocused(e) {
    y(this, cn) !== e && (_(this, cn, e), this.onFocus());
  }
  onFocus() {
    const e = this.isFocused();
    this.listeners.forEach((i) => {
      i(e);
    });
  }
  isFocused() {
    return typeof y(this, cn) == "boolean" ? y(this, cn) : globalThis.document?.visibilityState !== "hidden";
  }
}, cn = new WeakMap(), $r = new WeakMap(), Ea = new WeakMap(), a(Ra, "FocusManager"), Ra), iy = new ag();
function ep() {
  let n, t;
  const e = new Promise((r, s) => {
    n = r, t = s;
  });
  e.status = "pending", e.catch(() => {
  });
  function i(r) {
    Object.assign(e, r), delete e.resolve, delete e.reject;
  }
  return a(i, "finalize"), e.resolve = (r) => {
    i({
      status: "fulfilled",
      value: r
    }), n(r);
  }, e.reject = (r) => {
    i({
      status: "rejected",
      reason: r
    }), t(r);
  }, e;
}
a(ep, "pendingThenable");
function sg(n) {
  let t;
  if (n.then((e) => (t = e, e), Me)?.catch(Me), t !== void 0)
    return { data: t };
}
a(sg, "tryResolveSync");
function ym(n) {
  return n;
}
a(ym, "defaultTransformerFn");
function og(n) {
  return {
    mutationKey: n.options.mutationKey,
    state: n.state,
    ...n.options.scope && { scope: n.options.scope },
    ...n.meta && { meta: n.meta }
  };
}
a(og, "dehydrateMutation");
function cg(n, t, e) {
  const i = /* @__PURE__ */ a(() => {
    const r = n.promise?.then(t).catch((s) => e(s) ? Promise.reject(new Error("redacted")) : Promise.reject(s));
    return r?.catch(Me), r;
  }, "dehydratePromise");
  return {
    dehydratedAt: Date.now(),
    state: {
      ...n.state,
      ...n.state.data !== void 0 && {
        data: t(n.state.data)
      }
    },
    queryKey: n.queryKey,
    queryHash: n.queryHash,
    ...n.state.status === "pending" && {
      promise: i()
    },
    ...n.meta && { meta: n.meta }
  };
}
a(cg, "dehydrateQuery");
function lg(n) {
  return n.state.isPaused;
}
a(lg, "defaultShouldDehydrateMutation");
function dg(n) {
  return n.state.status === "success";
}
a(dg, "defaultShouldDehydrateQuery");
function hg(n) {
  return !0;
}
a(hg, "defaultShouldRedactErrors");
function ug(n, t = {}) {
  const e = t.shouldDehydrateMutation ?? n.getDefaultOptions().dehydrate?.shouldDehydrateMutation ?? lg, i = n.getMutationCache().getAll().flatMap(
    (l) => e(l) ? [og(l)] : []
  ), r = t.shouldDehydrateQuery ?? n.getDefaultOptions().dehydrate?.shouldDehydrateQuery ?? dg, s = t.shouldRedactErrors ?? n.getDefaultOptions().dehydrate?.shouldRedactErrors ?? hg, o = t.serializeData ?? n.getDefaultOptions().dehydrate?.serializeData ?? ym, c = n.getQueryCache().getAll().flatMap(
    (l) => r(l) ? [cg(l, o, s)] : []
  );
  return { mutations: i, queries: c };
}
a(ug, "dehydrate");
function pg(n, t, e) {
  if (typeof t != "object" || t === null)
    return;
  const i = n.getMutationCache(), r = n.getQueryCache(), s = n.getDefaultOptions().hydrate?.deserializeData ?? ym, o = t.mutations || [], c = t.queries || [];
  o.forEach(({ state: l, ...p }) => {
    i.build(
      n,
      {
        ...n.getDefaultOptions().hydrate?.mutations,
        ...e?.defaultOptions?.mutations,
        ...p
      },
      l
    );
  }), c.forEach(
    ({ queryKey: l, state: p, queryHash: v, meta: C, promise: g, dehydratedAt: m }) => {
      const f = g ? sg(g) : void 0, $ = p.data === void 0 ? f?.data : p.data, A = $ === void 0 ? $ : s($);
      let M = r.get(v);
      const R = M?.state.status === "pending", V = M?.state.fetchStatus === "fetching";
      if (M) {
        const W = f && // We only need this undefined check to handle older dehydration
        // payloads that might not have dehydratedAt
        m !== void 0 && m > M.state.dataUpdatedAt;
        if (p.dataUpdatedAt > M.state.dataUpdatedAt || W) {
          const { fetchStatus: I, ...U } = p;
          M.setState({
            ...U,
            data: A
          });
        }
      } else
        M = r.build(
          n,
          {
            ...n.getDefaultOptions().hydrate?.queries,
            ...e?.defaultOptions?.queries,
            queryKey: l,
            queryHash: v,
            meta: C
          },
          // Reset fetch status to idle to avoid
          // query being stuck in fetching state upon hydration
          {
            ...p,
            data: A,
            fetchStatus: "idle",
            status: A !== void 0 ? "success" : p.status
          }
        );
      g && !R && !V && // Only hydrate if dehydration is newer than any existing data,
      // this is always true for new queries
      (m === void 0 || m > M.state.dataUpdatedAt) && M.fetch(void 0, {
        // RSC transformed promises are not thenable
        initialPromise: Promise.resolve(g).then(s)
      }).catch(Me);
    }
  );
}
a(pg, "hydrate");
var yg = X1;
function wg() {
  let n = [], t = 0, e = /* @__PURE__ */ a((c) => {
    c();
  }, "notifyFn"), i = /* @__PURE__ */ a((c) => {
    c();
  }, "batchNotifyFn"), r = yg;
  const s = /* @__PURE__ */ a((c) => {
    t ? n.push(c) : r(() => {
      e(c);
    });
  }, "schedule"), o = /* @__PURE__ */ a(() => {
    const c = n;
    n = [], c.length && r(() => {
      i(() => {
        c.forEach((l) => {
          e(l);
        });
      });
    });
  }, "flush");
  return {
    batch: /* @__PURE__ */ a((c) => {
      let l;
      t++;
      try {
        l = c();
      } finally {
        t--, t || o();
      }
      return l;
    }, "batch"),
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: /* @__PURE__ */ a((c) => (...l) => {
      s(() => {
        c(...l);
      });
    }, "batchCalls"),
    schedule: s,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: /* @__PURE__ */ a((c) => {
      e = c;
    }, "setNotifyFunction"),
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: /* @__PURE__ */ a((c) => {
      i = c;
    }, "setBatchNotifyFunction"),
    setScheduler: /* @__PURE__ */ a((c) => {
      r = c;
    }, "setScheduler")
  };
}
a(wg, "createNotifyManager");
var ke = wg(), Ta, kr, La, Oa, fg = (Oa = class extends Wc {
  constructor() {
    super();
    O(this, Ta, !0);
    O(this, kr);
    O(this, La);
    _(this, La, (e) => {
      if (!$c && window.addEventListener) {
        const i = /* @__PURE__ */ a(() => e(!0), "onlineListener"), r = /* @__PURE__ */ a(() => e(!1), "offlineListener");
        return window.addEventListener("online", i, !1), window.addEventListener("offline", r, !1), () => {
          window.removeEventListener("online", i), window.removeEventListener("offline", r);
        };
      }
    });
  }
  onSubscribe() {
    y(this, kr) || this.setEventListener(y(this, La));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = y(this, kr)) == null || e.call(this), _(this, kr, void 0));
  }
  setEventListener(e) {
    var i;
    _(this, La, e), (i = y(this, kr)) == null || i.call(this), _(this, kr, e(this.setOnline.bind(this)));
  }
  setOnline(e) {
    y(this, Ta) !== e && (_(this, Ta, e), this.listeners.forEach((r) => {
      r(e);
    }));
  }
  isOnline() {
    return y(this, Ta);
  }
}, Ta = new WeakMap(), kr = new WeakMap(), La = new WeakMap(), a(Oa, "OnlineManager"), Oa), Wd = new fg();
function mg(n) {
  return Math.min(1e3 * 2 ** n, 3e4);
}
a(mg, "defaultRetryDelay");
function wm(n) {
  return (n ?? "online") === "online" ? Wd.isOnline() : !0;
}
a(wm, "canFetch");
var za, ip = (za = class extends Error {
  constructor(t) {
    super("CancelledError"), this.revert = t?.revert, this.silent = t?.silent;
  }
}, a(za, "CancelledError"), za);
function fm(n) {
  let t = !1, e = 0, i;
  const r = ep(), s = /* @__PURE__ */ a(() => r.status !== "pending", "isResolved"), o = /* @__PURE__ */ a(($) => {
    if (!s()) {
      const A = new ip($);
      g(A), n.onCancel?.(A);
    }
  }, "cancel"), c = /* @__PURE__ */ a(() => {
    t = !0;
  }, "cancelRetry"), l = /* @__PURE__ */ a(() => {
    t = !1;
  }, "continueRetry"), p = /* @__PURE__ */ a(() => iy.isFocused() && (n.networkMode === "always" || Wd.isOnline()) && n.canRun(), "canContinue"), v = /* @__PURE__ */ a(() => wm(n.networkMode) && n.canRun(), "canStart"), C = /* @__PURE__ */ a(($) => {
    s() || (i?.(), r.resolve($));
  }, "resolve"), g = /* @__PURE__ */ a(($) => {
    s() || (i?.(), r.reject($));
  }, "reject"), m = /* @__PURE__ */ a(() => new Promise(($) => {
    i = /* @__PURE__ */ a((A) => {
      (s() || p()) && $(A);
    }, "continueFn"), n.onPause?.();
  }).then(() => {
    i = void 0, s() || n.onContinue?.();
  }), "pause"), f = /* @__PURE__ */ a(() => {
    if (s())
      return;
    let $;
    const A = e === 0 ? n.initialPromise : void 0;
    try {
      $ = A ?? n.fn();
    } catch (M) {
      $ = Promise.reject(M);
    }
    Promise.resolve($).then(C).catch((M) => {
      if (s())
        return;
      const R = n.retry ?? ($c ? 0 : 3), V = n.retryDelay ?? mg, W = typeof V == "function" ? V(e, M) : V, I = R === !0 || typeof R == "number" && e < R || typeof R == "function" && R(e, M);
      if (t || !I) {
        g(M);
        return;
      }
      e++, n.onFail?.(e, M), eg(W).then(() => p() ? void 0 : m()).then(() => {
        t ? g(M) : f();
      });
    });
  }, "run");
  return {
    promise: r,
    status: /* @__PURE__ */ a(() => r.status, "status"),
    cancel: o,
    continue: /* @__PURE__ */ a(() => (i?.(), r), "continue"),
    cancelRetry: c,
    continueRetry: l,
    canStart: v,
    start: /* @__PURE__ */ a(() => (v() ? f() : m().then(f), r), "start")
  };
}
a(fm, "createRetryer");
var ln, Ia, mm = (Ia = class {
  constructor() {
    O(this, ln);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), Xu(this.gcTime) && _(this, ln, Lr.setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t ?? ($c ? 1 / 0 : 300 * 1e3)
    );
  }
  clearGcTimeout() {
    y(this, ln) && (Lr.clearTimeout(y(this, ln)), _(this, ln, void 0));
  }
}, ln = new WeakMap(), a(Ia, "Removable"), Ia), dn, Fa, ni, hn, fe, Ul, un, ui, Ui, Da, vg = (Da = class extends mm {
  constructor(e) {
    super();
    O(this, ui);
    O(this, dn);
    O(this, Fa);
    O(this, ni);
    O(this, hn);
    O(this, fe);
    O(this, Ul);
    O(this, un);
    _(this, un, !1), _(this, Ul, e.defaultOptions), this.setOptions(e.options), this.observers = [], _(this, hn, e.client), _(this, ni, y(this, hn).getQueryCache()), this.queryKey = e.queryKey, this.queryHash = e.queryHash, _(this, dn, Gw(this.options)), this.state = e.state ?? y(this, dn), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return y(this, fe)?.promise;
  }
  setOptions(e) {
    if (this.options = { ...y(this, Ul), ...e }, this.updateGcTime(this.options.gcTime), this.state && this.state.data === void 0) {
      const i = Gw(this.options);
      i.data !== void 0 && (this.setState(
        Qw(i.data, i.dataUpdatedAt)
      ), _(this, dn, i));
    }
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && y(this, ni).remove(this);
  }
  setData(e, i) {
    const r = tp(this.state.data, e, this.options);
    return lt(this, ui, Ui).call(this, {
      data: r,
      type: "success",
      dataUpdatedAt: i?.updatedAt,
      manual: i?.manual
    }), r;
  }
  setState(e, i) {
    lt(this, ui, Ui).call(this, { type: "setState", state: e, setStateOptions: i });
  }
  cancel(e) {
    const i = y(this, fe)?.promise;
    return y(this, fe)?.cancel(e), i ? i.then(Me).catch(Me) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(y(this, dn));
  }
  isActive() {
    return this.observers.some(
      (e) => ai(e.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === ey || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => Ir(e.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => e.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(e = 0) {
    return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !um(this.state.dataUpdatedAt, e);
  }
  onFocus() {
    this.observers.find((i) => i.shouldFetchOnWindowFocus())?.refetch({ cancelRefetch: !1 }), y(this, fe)?.continue();
  }
  onOnline() {
    this.observers.find((i) => i.shouldFetchOnReconnect())?.refetch({ cancelRefetch: !1 }), y(this, fe)?.continue();
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), y(this, ni).notify({ type: "observerAdded", query: this, observer: e }));
  }
  removeObserver(e) {
    this.observers.includes(e) && (this.observers = this.observers.filter((i) => i !== e), this.observers.length || (y(this, fe) && (y(this, un) ? y(this, fe).cancel({ revert: !0 }) : y(this, fe).cancelRetry()), this.scheduleGc()), y(this, ni).notify({ type: "observerRemoved", query: this, observer: e }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || lt(this, ui, Ui).call(this, { type: "invalidate" });
  }
  async fetch(e, i) {
    if (this.state.fetchStatus !== "idle" && // If the promise in the retryer is already rejected, we have to definitely
    // re-start the fetch; there is a chance that the query is still in a
    // pending state when that happens
    y(this, fe)?.status() !== "rejected") {
      if (this.state.data !== void 0 && i?.cancelRefetch)
        this.cancel({ silent: !0 });
      else if (y(this, fe))
        return y(this, fe).continueRetry(), y(this, fe).promise;
    }
    if (e && this.setOptions(e), !this.options.queryFn) {
      const p = this.observers.find((v) => v.options.queryFn);
      p && this.setOptions(p.options);
    }
    const r = new AbortController(), s = /* @__PURE__ */ a((p) => {
      Object.defineProperty(p, "signal", {
        enumerable: !0,
        get: /* @__PURE__ */ a(() => (_(this, un, !0), r.signal), "get")
      });
    }, "addSignalProperty"), o = /* @__PURE__ */ a(() => {
      const p = pm(this.options, i), C = (/* @__PURE__ */ a(() => {
        const g = {
          client: y(this, hn),
          queryKey: this.queryKey,
          meta: this.meta
        };
        return s(g), g;
      }, "createQueryFnContext"))();
      return _(this, un, !1), this.options.persister ? this.options.persister(
        p,
        C,
        this
      ) : p(C);
    }, "fetchFn"), l = (/* @__PURE__ */ a(() => {
      const p = {
        fetchOptions: i,
        options: this.options,
        queryKey: this.queryKey,
        client: y(this, hn),
        state: this.state,
        fetchFn: o
      };
      return s(p), p;
    }, "createFetchContext"))();
    this.options.behavior?.onFetch(l, this), _(this, Fa, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== l.fetchOptions?.meta) && lt(this, ui, Ui).call(this, { type: "fetch", meta: l.fetchOptions?.meta }), _(this, fe, fm({
      initialPromise: i?.initialPromise,
      fn: l.fetchFn,
      onCancel: /* @__PURE__ */ a((p) => {
        p instanceof ip && p.revert && this.setState({
          ...y(this, Fa),
          fetchStatus: "idle"
        }), r.abort();
      }, "onCancel"),
      onFail: /* @__PURE__ */ a((p, v) => {
        lt(this, ui, Ui).call(this, { type: "failed", failureCount: p, error: v });
      }, "onFail"),
      onPause: /* @__PURE__ */ a(() => {
        lt(this, ui, Ui).call(this, { type: "pause" });
      }, "onPause"),
      onContinue: /* @__PURE__ */ a(() => {
        lt(this, ui, Ui).call(this, { type: "continue" });
      }, "onContinue"),
      retry: l.options.retry,
      retryDelay: l.options.retryDelay,
      networkMode: l.options.networkMode,
      canRun: /* @__PURE__ */ a(() => !0, "canRun")
    }));
    try {
      const p = await y(this, fe).start();
      if (p === void 0)
        throw new Error(`${this.queryHash} data is undefined`);
      return this.setData(p), y(this, ni).config.onSuccess?.(p, this), y(this, ni).config.onSettled?.(
        p,
        this.state.error,
        this
      ), p;
    } catch (p) {
      if (p instanceof ip) {
        if (p.silent)
          return y(this, fe).promise;
        if (p.revert) {
          if (this.state.data === void 0)
            throw p;
          return this.state.data;
        }
      }
      throw lt(this, ui, Ui).call(this, {
        type: "error",
        error: p
      }), y(this, ni).config.onError?.(
        p,
        this
      ), y(this, ni).config.onSettled?.(
        this.state.data,
        p,
        this
      ), p;
    } finally {
      this.scheduleGc();
    }
  }
}, dn = new WeakMap(), Fa = new WeakMap(), ni = new WeakMap(), hn = new WeakMap(), fe = new WeakMap(), Ul = new WeakMap(), un = new WeakMap(), ui = new WeakSet(), Ui = /* @__PURE__ */ a(function(e) {
  const i = /* @__PURE__ */ a((r) => {
    switch (e.type) {
      case "failed":
        return {
          ...r,
          fetchFailureCount: e.failureCount,
          fetchFailureReason: e.error
        };
      case "pause":
        return {
          ...r,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...r,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...r,
          ...vm(r.data, this.options),
          fetchMeta: e.meta ?? null
        };
      case "success":
        const s = {
          ...r,
          ...Qw(e.data, e.dataUpdatedAt),
          dataUpdateCount: r.dataUpdateCount + 1,
          ...!e.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
        return _(this, Fa, e.manual ? s : void 0), s;
      case "error":
        const o = e.error;
        return {
          ...r,
          error: o,
          errorUpdateCount: r.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: r.fetchFailureCount + 1,
          fetchFailureReason: o,
          fetchStatus: "idle",
          status: "error",
          // flag existing data as invalidated if we get a background error
          // note that "no data" always means stale so we can set unconditionally here
          isInvalidated: !0
        };
      case "invalidate":
        return {
          ...r,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...r,
          ...e.state
        };
    }
  }, "reducer");
  this.state = i(this.state), ke.batch(() => {
    this.observers.forEach((r) => {
      r.onQueryUpdate();
    }), y(this, ni).notify({ query: this, type: "updated", action: e });
  });
}, "#dispatch"), a(Da, "Query"), Da);
function vm(n, t) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: wm(t.networkMode) ? "fetching" : "paused",
    ...n === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
a(vm, "fetchState");
function Qw(n, t) {
  return {
    data: n,
    dataUpdatedAt: t ?? Date.now(),
    error: null,
    isInvalidated: !1,
    status: "success"
  };
}
a(Qw, "successState");
function Gw(n) {
  const t = typeof n.initialData == "function" ? n.initialData() : n.initialData, e = t !== void 0, i = e ? typeof n.initialDataUpdatedAt == "function" ? n.initialDataUpdatedAt() : n.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: e ? i ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: e ? "success" : "pending",
    fetchStatus: "idle"
  };
}
a(Gw, "getDefaultState$1");
var Be, bt, ql, Oe, pn, Va, ji, Pr, jl, Ha, Ba, yn, wn, _r, Na, St, dl, rp, np, ap, sp, op, cp, lp, bm, Ua, gm = (Ua = class extends Wc {
  constructor(e, i) {
    super();
    O(this, St);
    O(this, Be);
    O(this, bt);
    O(this, ql);
    O(this, Oe);
    O(this, pn);
    O(this, Va);
    O(this, ji);
    O(this, Pr);
    O(this, jl);
    O(this, Ha);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    O(this, Ba);
    O(this, yn);
    O(this, wn);
    O(this, _r);
    O(this, Na, /* @__PURE__ */ new Set());
    this.options = i, _(this, Be, e), _(this, Pr, null), _(this, ji, ep()), this.bindMethods(), this.setOptions(i);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (y(this, bt).addObserver(this), Zw(y(this, bt), this.options) ? lt(this, St, dl).call(this) : this.updateResult(), lt(this, St, sp).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return dp(
      y(this, bt),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return dp(
      y(this, bt),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), lt(this, St, op).call(this), lt(this, St, cp).call(this), y(this, bt).removeObserver(this);
  }
  setOptions(e) {
    const i = this.options, r = y(this, bt);
    if (this.options = y(this, Be).defaultQueryOptions(e), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof ai(this.options.enabled, y(this, bt)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    lt(this, St, lp).call(this), y(this, bt).setOptions(this.options), i._defaulted && !jd(this.options, i) && y(this, Be).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: y(this, bt),
      observer: this
    });
    const s = this.hasListeners();
    s && Yw(
      y(this, bt),
      r,
      this.options,
      i
    ) && lt(this, St, dl).call(this), this.updateResult(), s && (y(this, bt) !== r || ai(this.options.enabled, y(this, bt)) !== ai(i.enabled, y(this, bt)) || Ir(this.options.staleTime, y(this, bt)) !== Ir(i.staleTime, y(this, bt))) && lt(this, St, rp).call(this);
    const o = lt(this, St, np).call(this);
    s && (y(this, bt) !== r || ai(this.options.enabled, y(this, bt)) !== ai(i.enabled, y(this, bt)) || o !== y(this, _r)) && lt(this, St, ap).call(this, o);
  }
  getOptimisticResult(e) {
    const i = y(this, Be).getQueryCache().build(y(this, Be), e), r = this.createResult(i, e);
    return bg(this, r) && (_(this, Oe, r), _(this, Va, this.options), _(this, pn, y(this, bt).state)), r;
  }
  getCurrentResult() {
    return y(this, Oe);
  }
  trackResult(e, i) {
    return new Proxy(e, {
      get: /* @__PURE__ */ a((r, s) => (this.trackProp(s), i?.(s), s === "promise" && (this.trackProp("data"), !this.options.experimental_prefetchInRender && y(this, ji).status === "pending" && y(this, ji).reject(
        new Error(
          "experimental_prefetchInRender feature flag is not enabled"
        )
      )), Reflect.get(r, s)), "get")
    });
  }
  trackProp(e) {
    y(this, Na).add(e);
  }
  getCurrentQuery() {
    return y(this, bt);
  }
  refetch({ ...e } = {}) {
    return this.fetch({
      ...e
    });
  }
  fetchOptimistic(e) {
    const i = y(this, Be).defaultQueryOptions(e), r = y(this, Be).getQueryCache().build(y(this, Be), i);
    return r.fetch().then(() => this.createResult(r, i));
  }
  fetch(e) {
    return lt(this, St, dl).call(this, {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), y(this, Oe)));
  }
  createResult(e, i) {
    const r = y(this, bt), s = this.options, o = y(this, Oe), c = y(this, pn), l = y(this, Va), v = e !== r ? e.state : y(this, ql), { state: C } = e;
    let g = { ...C }, m = !1, f;
    if (i._optimisticResults) {
      const rt = this.hasListeners(), Lt = !rt && Zw(e, i), Ot = rt && Yw(e, r, i, s);
      (Lt || Ot) && (g = {
        ...g,
        ...vm(C.data, e.options)
      }), i._optimisticResults === "isRestoring" && (g.fetchStatus = "idle");
    }
    let { error: $, errorUpdatedAt: A, status: M } = g;
    f = g.data;
    let R = !1;
    if (i.placeholderData !== void 0 && f === void 0 && M === "pending") {
      let rt;
      o?.isPlaceholderData && i.placeholderData === l?.placeholderData ? (rt = o.data, R = !0) : rt = typeof i.placeholderData == "function" ? i.placeholderData(
        y(this, Ba)?.state.data,
        y(this, Ba)
      ) : i.placeholderData, rt !== void 0 && (M = "success", f = tp(
        o?.data,
        rt,
        i
      ), m = !0);
    }
    if (i.select && f !== void 0 && !R)
      if (o && f === c?.data && i.select === y(this, jl))
        f = y(this, Ha);
      else
        try {
          _(this, jl, i.select), f = i.select(f), f = tp(o?.data, f, i), _(this, Ha, f), _(this, Pr, null);
        } catch (rt) {
          _(this, Pr, rt);
        }
    y(this, Pr) && ($ = y(this, Pr), f = y(this, Ha), A = Date.now(), M = "error");
    const V = g.fetchStatus === "fetching", W = M === "pending", I = M === "error", U = W && V, K = f !== void 0, ot = {
      status: M,
      fetchStatus: g.fetchStatus,
      isPending: W,
      isSuccess: M === "success",
      isError: I,
      isInitialLoading: U,
      isLoading: U,
      data: f,
      dataUpdatedAt: g.dataUpdatedAt,
      error: $,
      errorUpdatedAt: A,
      failureCount: g.fetchFailureCount,
      failureReason: g.fetchFailureReason,
      errorUpdateCount: g.errorUpdateCount,
      isFetched: g.dataUpdateCount > 0 || g.errorUpdateCount > 0,
      isFetchedAfterMount: g.dataUpdateCount > v.dataUpdateCount || g.errorUpdateCount > v.errorUpdateCount,
      isFetching: V,
      isRefetching: V && !W,
      isLoadingError: I && !K,
      isPaused: g.fetchStatus === "paused",
      isPlaceholderData: m,
      isRefetchError: I && K,
      isStale: ry(e, i),
      refetch: this.refetch,
      promise: y(this, ji),
      isEnabled: ai(i.enabled, e) !== !1
    };
    if (this.options.experimental_prefetchInRender) {
      const rt = ot.data !== void 0, Lt = ot.status === "error" && !rt, Ot = /* @__PURE__ */ a((Bt) => {
        Lt ? Bt.reject(ot.error) : rt && Bt.resolve(ot.data);
      }, "finalizeThenableIfPossible"), At = /* @__PURE__ */ a(() => {
        const Bt = _(this, ji, ot.promise = ep());
        Ot(Bt);
      }, "recreateThenable"), vt = y(this, ji);
      switch (vt.status) {
        case "pending":
          e.queryHash === r.queryHash && Ot(vt);
          break;
        case "fulfilled":
          (Lt || ot.data !== vt.value) && At();
          break;
        case "rejected":
          (!Lt || ot.error !== vt.reason) && At();
          break;
      }
    }
    return ot;
  }
  updateResult() {
    const e = y(this, Oe), i = this.createResult(y(this, bt), this.options);
    if (_(this, pn, y(this, bt).state), _(this, Va, this.options), y(this, pn).data !== void 0 && _(this, Ba, y(this, bt)), jd(i, e))
      return;
    _(this, Oe, i);
    const r = /* @__PURE__ */ a(() => {
      if (!e)
        return !0;
      const { notifyOnChangeProps: s } = this.options, o = typeof s == "function" ? s() : s;
      if (o === "all" || !o && !y(this, Na).size)
        return !0;
      const c = new Set(
        o ?? y(this, Na)
      );
      return this.options.throwOnError && c.add("error"), Object.keys(y(this, Oe)).some((l) => {
        const p = l;
        return y(this, Oe)[p] !== e[p] && c.has(p);
      });
    }, "shouldNotifyListeners");
    lt(this, St, bm).call(this, { listeners: r() });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && lt(this, St, sp).call(this);
  }
}, Be = new WeakMap(), bt = new WeakMap(), ql = new WeakMap(), Oe = new WeakMap(), pn = new WeakMap(), Va = new WeakMap(), ji = new WeakMap(), Pr = new WeakMap(), jl = new WeakMap(), Ha = new WeakMap(), Ba = new WeakMap(), yn = new WeakMap(), wn = new WeakMap(), _r = new WeakMap(), Na = new WeakMap(), St = new WeakSet(), dl = /* @__PURE__ */ a(function(e) {
  lt(this, St, lp).call(this);
  let i = y(this, bt).fetch(
    this.options,
    e
  );
  return e?.throwOnError || (i = i.catch(Me)), i;
}, "#executeFetch"), rp = /* @__PURE__ */ a(function() {
  lt(this, St, op).call(this);
  const e = Ir(
    this.options.staleTime,
    y(this, bt)
  );
  if ($c || y(this, Oe).isStale || !Xu(e))
    return;
  const r = um(y(this, Oe).dataUpdatedAt, e) + 1;
  _(this, yn, Lr.setTimeout(() => {
    y(this, Oe).isStale || this.updateResult();
  }, r));
}, "#updateStaleTimeout"), np = /* @__PURE__ */ a(function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(y(this, bt)) : this.options.refetchInterval) ?? !1;
}, "#computeRefetchInterval"), ap = /* @__PURE__ */ a(function(e) {
  lt(this, St, cp).call(this), _(this, _r, e), !($c || ai(this.options.enabled, y(this, bt)) === !1 || !Xu(y(this, _r)) || y(this, _r) === 0) && _(this, wn, Lr.setInterval(() => {
    (this.options.refetchIntervalInBackground || iy.isFocused()) && lt(this, St, dl).call(this);
  }, y(this, _r)));
}, "#updateRefetchInterval"), sp = /* @__PURE__ */ a(function() {
  lt(this, St, rp).call(this), lt(this, St, ap).call(this, lt(this, St, np).call(this));
}, "#updateTimers"), op = /* @__PURE__ */ a(function() {
  y(this, yn) && (Lr.clearTimeout(y(this, yn)), _(this, yn, void 0));
}, "#clearStaleTimeout"), cp = /* @__PURE__ */ a(function() {
  y(this, wn) && (Lr.clearInterval(y(this, wn)), _(this, wn, void 0));
}, "#clearRefetchInterval"), lp = /* @__PURE__ */ a(function() {
  const e = y(this, Be).getQueryCache().build(y(this, Be), this.options);
  if (e === y(this, bt))
    return;
  const i = y(this, bt);
  _(this, bt, e), _(this, ql, e.state), this.hasListeners() && (i?.removeObserver(this), e.addObserver(this));
}, "#updateQuery"), bm = /* @__PURE__ */ a(function(e) {
  ke.batch(() => {
    e.listeners && this.listeners.forEach((i) => {
      i(y(this, Oe));
    }), y(this, Be).getQueryCache().notify({
      query: y(this, bt),
      type: "observerResultsUpdated"
    });
  });
}, "#notify"), a(Ua, "QueryObserver"), Ua);
function gg(n, t) {
  return ai(t.enabled, n) !== !1 && n.state.data === void 0 && !(n.state.status === "error" && t.retryOnMount === !1);
}
a(gg, "shouldLoadOnMount");
function Zw(n, t) {
  return gg(n, t) || n.state.data !== void 0 && dp(n, t, t.refetchOnMount);
}
a(Zw, "shouldFetchOnMount");
function dp(n, t, e) {
  if (ai(t.enabled, n) !== !1 && Ir(t.staleTime, n) !== "static") {
    const i = typeof e == "function" ? e(n) : e;
    return i === "always" || i !== !1 && ry(n, t);
  }
  return !1;
}
a(dp, "shouldFetchOn");
function Yw(n, t, e, i) {
  return (n !== t || ai(i.enabled, n) === !1) && (!e.suspense || n.state.status !== "error") && ry(n, e);
}
a(Yw, "shouldFetchOptionally");
function ry(n, t) {
  return ai(t.enabled, n) !== !1 && n.isStaleByTime(Ir(t.staleTime, n));
}
a(ry, "isStale");
function bg(n, t) {
  return !jd(n.getCurrentResult(), t);
}
a(bg, "shouldAssignObserverCurrentProperties");
function Kd(n) {
  return {
    onFetch: /* @__PURE__ */ a((t, e) => {
      const i = t.options, r = t.fetchOptions?.meta?.fetchMore?.direction, s = t.state.data?.pages || [], o = t.state.data?.pageParams || [];
      let c = { pages: [], pageParams: [] }, l = 0;
      const p = /* @__PURE__ */ a(async () => {
        let v = !1;
        const C = /* @__PURE__ */ a((f) => {
          ng(
            f,
            () => t.signal,
            () => v = !0
          );
        }, "addSignalProperty"), g = pm(t.options, t.fetchOptions), m = /* @__PURE__ */ a(async (f, $, A) => {
          if (v)
            return Promise.reject();
          if ($ == null && f.pages.length)
            return Promise.resolve(f);
          const R = (/* @__PURE__ */ a(() => {
            const U = {
              client: t.client,
              queryKey: t.queryKey,
              pageParam: $,
              direction: A ? "backward" : "forward",
              meta: t.options.meta
            };
            return C(U), U;
          }, "createQueryFnContext"))(), V = await g(R), { maxPages: W } = t.options, I = A ? rg : ig;
          return {
            pages: I(f.pages, V, W),
            pageParams: I(f.pageParams, $, W)
          };
        }, "fetchPage");
        if (r && s.length) {
          const f = r === "backward", $ = f ? xm : hp, A = {
            pages: s,
            pageParams: o
          }, M = $(i, A);
          c = await m(A, M, f);
        } else {
          const f = n ?? s.length;
          do {
            const $ = l === 0 ? o[0] ?? i.initialPageParam : hp(i, c);
            if (l > 0 && $ == null)
              break;
            c = await m(c, $), l++;
          } while (l < f);
        }
        return c;
      }, "fetchFn");
      t.options.persister ? t.fetchFn = () => t.options.persister?.(
        p,
        {
          client: t.client,
          queryKey: t.queryKey,
          meta: t.options.meta,
          signal: t.signal
        },
        e
      ) : t.fetchFn = p;
    }, "onFetch")
  };
}
a(Kd, "infiniteQueryBehavior");
function hp(n, { pages: t, pageParams: e }) {
  const i = t.length - 1;
  return t.length > 0 ? n.getNextPageParam(
    t[i],
    t,
    e[i],
    e
  ) : void 0;
}
a(hp, "getNextPageParam");
function xm(n, { pages: t, pageParams: e }) {
  return t.length > 0 ? n.getPreviousPageParam?.(t[0], t, e[0], e) : void 0;
}
a(xm, "getPreviousPageParam");
function xg(n, t) {
  return t ? hp(n, t) != null : !1;
}
a(xg, "hasNextPage");
function Cg(n, t) {
  return !t || !n.getPreviousPageParam ? !1 : xm(n, t) != null;
}
a(Cg, "hasPreviousPage");
var qa, $g = (qa = class extends gm {
  constructor(t, e) {
    super(t, e);
  }
  bindMethods() {
    super.bindMethods(), this.fetchNextPage = this.fetchNextPage.bind(this), this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
  }
  setOptions(t) {
    super.setOptions({
      ...t,
      behavior: Kd()
    });
  }
  getOptimisticResult(t) {
    return t.behavior = Kd(), super.getOptimisticResult(t);
  }
  fetchNextPage(t) {
    return this.fetch({
      ...t,
      meta: {
        fetchMore: { direction: "forward" }
      }
    });
  }
  fetchPreviousPage(t) {
    return this.fetch({
      ...t,
      meta: {
        fetchMore: { direction: "backward" }
      }
    });
  }
  createResult(t, e) {
    const { state: i } = t, r = super.createResult(t, e), { isFetching: s, isRefetching: o, isError: c, isRefetchError: l } = r, p = i.fetchMeta?.fetchMore?.direction, v = c && p === "forward", C = s && p === "forward", g = c && p === "backward", m = s && p === "backward";
    return {
      ...r,
      fetchNextPage: this.fetchNextPage,
      fetchPreviousPage: this.fetchPreviousPage,
      hasNextPage: xg(e, i.data),
      hasPreviousPage: Cg(e, i.data),
      isFetchNextPageError: v,
      isFetchingNextPage: C,
      isFetchPreviousPageError: g,
      isFetchingPreviousPage: m,
      isRefetchError: l && !v && !g,
      isRefetching: o && !C && !m
    };
  }
}, a(qa, "InfiniteQueryObserver"), qa), Wl, Pi, ze, fn, _i, gr, ja, kg = (ja = class extends mm {
  constructor(e) {
    super();
    O(this, _i);
    O(this, Wl);
    O(this, Pi);
    O(this, ze);
    O(this, fn);
    _(this, Wl, e.client), this.mutationId = e.mutationId, _(this, ze, e.mutationCache), _(this, Pi, []), this.state = e.state || Cm(), this.setOptions(e.options), this.scheduleGc();
  }
  setOptions(e) {
    this.options = e, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(e) {
    y(this, Pi).includes(e) || (y(this, Pi).push(e), this.clearGcTimeout(), y(this, ze).notify({
      type: "observerAdded",
      mutation: this,
      observer: e
    }));
  }
  removeObserver(e) {
    _(this, Pi, y(this, Pi).filter((i) => i !== e)), this.scheduleGc(), y(this, ze).notify({
      type: "observerRemoved",
      mutation: this,
      observer: e
    });
  }
  optionalRemove() {
    y(this, Pi).length || (this.state.status === "pending" ? this.scheduleGc() : y(this, ze).remove(this));
  }
  continue() {
    return y(this, fn)?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(e) {
    const i = /* @__PURE__ */ a(() => {
      lt(this, _i, gr).call(this, { type: "continue" });
    }, "onContinue"), r = {
      client: y(this, Wl),
      meta: this.options.meta,
      mutationKey: this.options.mutationKey
    };
    _(this, fn, fm({
      fn: /* @__PURE__ */ a(() => this.options.mutationFn ? this.options.mutationFn(e, r) : Promise.reject(new Error("No mutationFn found")), "fn"),
      onFail: /* @__PURE__ */ a((c, l) => {
        lt(this, _i, gr).call(this, { type: "failed", failureCount: c, error: l });
      }, "onFail"),
      onPause: /* @__PURE__ */ a(() => {
        lt(this, _i, gr).call(this, { type: "pause" });
      }, "onPause"),
      onContinue: i,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: /* @__PURE__ */ a(() => y(this, ze).canRun(this), "canRun")
    }));
    const s = this.state.status === "pending", o = !y(this, fn).canStart();
    try {
      if (s)
        i();
      else {
        lt(this, _i, gr).call(this, { type: "pending", variables: e, isPaused: o }), await y(this, ze).config.onMutate?.(
          e,
          this,
          r
        );
        const l = await this.options.onMutate?.(
          e,
          r
        );
        l !== this.state.context && lt(this, _i, gr).call(this, {
          type: "pending",
          context: l,
          variables: e,
          isPaused: o
        });
      }
      const c = await y(this, fn).start();
      return await y(this, ze).config.onSuccess?.(
        c,
        e,
        this.state.context,
        this,
        r
      ), await this.options.onSuccess?.(
        c,
        e,
        this.state.context,
        r
      ), await y(this, ze).config.onSettled?.(
        c,
        null,
        this.state.variables,
        this.state.context,
        this,
        r
      ), await this.options.onSettled?.(
        c,
        null,
        e,
        this.state.context,
        r
      ), lt(this, _i, gr).call(this, { type: "success", data: c }), c;
    } catch (c) {
      try {
        await y(this, ze).config.onError?.(
          c,
          e,
          this.state.context,
          this,
          r
        );
      } catch (l) {
        Promise.reject(l);
      }
      try {
        await this.options.onError?.(
          c,
          e,
          this.state.context,
          r
        );
      } catch (l) {
        Promise.reject(l);
      }
      try {
        await y(this, ze).config.onSettled?.(
          void 0,
          c,
          this.state.variables,
          this.state.context,
          this,
          r
        );
      } catch (l) {
        Promise.reject(l);
      }
      try {
        await this.options.onSettled?.(
          void 0,
          c,
          e,
          this.state.context,
          r
        );
      } catch (l) {
        Promise.reject(l);
      }
      throw lt(this, _i, gr).call(this, { type: "error", error: c }), c;
    } finally {
      y(this, ze).runNext(this);
    }
  }
}, Wl = new WeakMap(), Pi = new WeakMap(), ze = new WeakMap(), fn = new WeakMap(), _i = new WeakSet(), gr = /* @__PURE__ */ a(function(e) {
  const i = /* @__PURE__ */ a((r) => {
    switch (e.type) {
      case "failed":
        return {
          ...r,
          failureCount: e.failureCount,
          failureReason: e.error
        };
      case "pause":
        return {
          ...r,
          isPaused: !0
        };
      case "continue":
        return {
          ...r,
          isPaused: !1
        };
      case "pending":
        return {
          ...r,
          context: e.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: e.isPaused,
          status: "pending",
          variables: e.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...r,
          data: e.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...r,
          data: void 0,
          error: e.error,
          failureCount: r.failureCount + 1,
          failureReason: e.error,
          isPaused: !1,
          status: "error"
        };
    }
  }, "reducer");
  this.state = i(this.state), ke.batch(() => {
    y(this, Pi).forEach((r) => {
      r.onMutationUpdate(e);
    }), y(this, ze).notify({
      mutation: this,
      type: "updated",
      action: e
    });
  });
}, "#dispatch"), a(ja, "Mutation"), ja);
function Cm() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
a(Cm, "getDefaultState");
var Wi, pi, Kl, Wa, Pg = (Wa = class extends Wc {
  constructor(e = {}) {
    super();
    O(this, Wi);
    O(this, pi);
    O(this, Kl);
    this.config = e, _(this, Wi, /* @__PURE__ */ new Set()), _(this, pi, /* @__PURE__ */ new Map()), _(this, Kl, 0);
  }
  build(e, i, r) {
    const s = new kg({
      client: e,
      mutationCache: this,
      mutationId: ++Rd(this, Kl)._,
      options: e.defaultMutationOptions(i),
      state: r
    });
    return this.add(s), s;
  }
  add(e) {
    y(this, Wi).add(e);
    const i = Ld(e);
    if (typeof i == "string") {
      const r = y(this, pi).get(i);
      r ? r.push(e) : y(this, pi).set(i, [e]);
    }
    this.notify({ type: "added", mutation: e });
  }
  remove(e) {
    if (y(this, Wi).delete(e)) {
      const i = Ld(e);
      if (typeof i == "string") {
        const r = y(this, pi).get(i);
        if (r)
          if (r.length > 1) {
            const s = r.indexOf(e);
            s !== -1 && r.splice(s, 1);
          } else r[0] === e && y(this, pi).delete(i);
      }
    }
    this.notify({ type: "removed", mutation: e });
  }
  canRun(e) {
    const i = Ld(e);
    if (typeof i == "string") {
      const s = y(this, pi).get(i)?.find(
        (o) => o.state.status === "pending"
      );
      return !s || s === e;
    } else
      return !0;
  }
  runNext(e) {
    const i = Ld(e);
    return typeof i == "string" ? y(this, pi).get(i)?.find((s) => s !== e && s.state.isPaused)?.continue() ?? Promise.resolve() : Promise.resolve();
  }
  clear() {
    ke.batch(() => {
      y(this, Wi).forEach((e) => {
        this.notify({ type: "removed", mutation: e });
      }), y(this, Wi).clear(), y(this, pi).clear();
    });
  }
  getAll() {
    return Array.from(y(this, Wi));
  }
  find(e) {
    const i = { exact: !0, ...e };
    return this.getAll().find(
      (r) => jw(i, r)
    );
  }
  findAll(e = {}) {
    return this.getAll().filter((i) => jw(e, i));
  }
  notify(e) {
    ke.batch(() => {
      this.listeners.forEach((i) => {
        i(e);
      });
    });
  }
  resumePausedMutations() {
    const e = this.getAll().filter((i) => i.state.isPaused);
    return ke.batch(
      () => Promise.all(
        e.map((i) => i.continue().catch(Me))
      )
    );
  }
}, Wi = new WeakMap(), pi = new WeakMap(), Kl = new WeakMap(), a(Wa, "MutationCache"), Wa);
function Ld(n) {
  return n.options.scope?.id;
}
a(Ld, "scopeFor");
var Ki, Sr, Ne, Qi, er, Id, up, Ka, Mt = (Ka = class extends Wc {
  constructor(e, i) {
    super();
    O(this, er);
    O(this, Ki);
    O(this, Sr);
    O(this, Ne);
    O(this, Qi);
    _(this, Ki, e), this.setOptions(i), this.bindMethods(), lt(this, er, Id).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);
  }
  setOptions(e) {
    const i = this.options;
    this.options = y(this, Ki).defaultMutationOptions(e), jd(this.options, i) || y(this, Ki).getMutationCache().notify({
      type: "observerOptionsUpdated",
      mutation: y(this, Ne),
      observer: this
    }), i?.mutationKey && this.options.mutationKey && Pn(i.mutationKey) !== Pn(this.options.mutationKey) ? this.reset() : y(this, Ne)?.state.status === "pending" && y(this, Ne).setOptions(this.options);
  }
  onUnsubscribe() {
    this.hasListeners() || y(this, Ne)?.removeObserver(this);
  }
  onMutationUpdate(e) {
    lt(this, er, Id).call(this), lt(this, er, up).call(this, e);
  }
  getCurrentResult() {
    return y(this, Sr);
  }
  reset() {
    y(this, Ne)?.removeObserver(this), _(this, Ne, void 0), lt(this, er, Id).call(this), lt(this, er, up).call(this);
  }
  mutate(e, i) {
    return _(this, Qi, i), y(this, Ne)?.removeObserver(this), _(this, Ne, y(this, Ki).getMutationCache().build(y(this, Ki), this.options)), y(this, Ne).addObserver(this), y(this, Ne).execute(e);
  }
}, Ki = new WeakMap(), Sr = new WeakMap(), Ne = new WeakMap(), Qi = new WeakMap(), er = new WeakSet(), Id = /* @__PURE__ */ a(function() {
  const e = y(this, Ne)?.state ?? Cm();
  _(this, Sr, {
    ...e,
    isPending: e.status === "pending",
    isSuccess: e.status === "success",
    isError: e.status === "error",
    isIdle: e.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, "#updateResult"), up = /* @__PURE__ */ a(function(e) {
  ke.batch(() => {
    if (y(this, Qi) && this.hasListeners()) {
      const i = y(this, Sr).variables, r = y(this, Sr).context, s = {
        client: y(this, Ki),
        meta: this.options.meta,
        mutationKey: this.options.mutationKey
      };
      if (e?.type === "success") {
        try {
          y(this, Qi).onSuccess?.(
            e.data,
            i,
            r,
            s
          );
        } catch (o) {
          Promise.reject(o);
        }
        try {
          y(this, Qi).onSettled?.(
            e.data,
            null,
            i,
            r,
            s
          );
        } catch (o) {
          Promise.reject(o);
        }
      } else if (e?.type === "error") {
        try {
          y(this, Qi).onError?.(
            e.error,
            i,
            r,
            s
          );
        } catch (o) {
          Promise.reject(o);
        }
        try {
          y(this, Qi).onSettled?.(
            void 0,
            e.error,
            i,
            r,
            s
          );
        } catch (o) {
          Promise.reject(o);
        }
      }
    }
    this.listeners.forEach((i) => {
      i(y(this, Sr));
    });
  });
}, "#notify"), a(Ka, "MutationObserver"), Ka), Si, Qa, _g = (Qa = class extends Wc {
  constructor(e = {}) {
    super();
    O(this, Si);
    this.config = e, _(this, Si, /* @__PURE__ */ new Map());
  }
  build(e, i, r) {
    const s = i.queryKey, o = i.queryHash ?? ty(s, i);
    let c = this.get(o);
    return c || (c = new vg({
      client: e,
      queryKey: s,
      queryHash: o,
      options: e.defaultQueryOptions(i),
      state: r,
      defaultOptions: e.getQueryDefaults(s)
    }), this.add(c)), c;
  }
  add(e) {
    y(this, Si).has(e.queryHash) || (y(this, Si).set(e.queryHash, e), this.notify({
      type: "added",
      query: e
    }));
  }
  remove(e) {
    const i = y(this, Si).get(e.queryHash);
    i && (e.destroy(), i === e && y(this, Si).delete(e.queryHash), this.notify({ type: "removed", query: e }));
  }
  clear() {
    ke.batch(() => {
      this.getAll().forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return y(this, Si).get(e);
  }
  getAll() {
    return [...y(this, Si).values()];
  }
  find(e) {
    const i = { exact: !0, ...e };
    return this.getAll().find(
      (r) => qw(i, r)
    );
  }
  findAll(e = {}) {
    const i = this.getAll();
    return Object.keys(e).length > 0 ? i.filter((r) => qw(e, r)) : i;
  }
  notify(e) {
    ke.batch(() => {
      this.listeners.forEach((i) => {
        i(e);
      });
    });
  }
  onFocus() {
    ke.batch(() => {
      this.getAll().forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    ke.batch(() => {
      this.getAll().forEach((e) => {
        e.onOnline();
      });
    });
  }
}, Si = new WeakMap(), a(Qa, "QueryCache"), Qa), Nt, Mr, Ar, Ga, Za, Er, Ya, Xa, Ja, Sg = (Ja = class {
  constructor(t = {}) {
    O(this, Nt);
    O(this, Mr);
    O(this, Ar);
    O(this, Ga);
    O(this, Za);
    O(this, Er);
    O(this, Ya);
    O(this, Xa);
    _(this, Nt, t.queryCache || new _g()), _(this, Mr, t.mutationCache || new Pg()), _(this, Ar, t.defaultOptions || {}), _(this, Ga, /* @__PURE__ */ new Map()), _(this, Za, /* @__PURE__ */ new Map()), _(this, Er, 0);
  }
  mount() {
    Rd(this, Er)._++, y(this, Er) === 1 && (_(this, Ya, iy.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), y(this, Nt).onFocus());
    })), _(this, Xa, Wd.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), y(this, Nt).onOnline());
    })));
  }
  unmount() {
    var t, e;
    Rd(this, Er)._--, y(this, Er) === 0 && ((t = y(this, Ya)) == null || t.call(this), _(this, Ya, void 0), (e = y(this, Xa)) == null || e.call(this), _(this, Xa, void 0));
  }
  isFetching(t) {
    return y(this, Nt).findAll({ ...t, fetchStatus: "fetching" }).length;
  }
  isMutating(t) {
    return y(this, Mr).findAll({ ...t, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(t) {
    const e = this.defaultQueryOptions({ queryKey: t });
    return y(this, Nt).get(e.queryHash)?.state.data;
  }
  ensureQueryData(t) {
    const e = this.defaultQueryOptions(t), i = y(this, Nt).build(this, e), r = i.state.data;
    return r === void 0 ? this.fetchQuery(t) : (t.revalidateIfStale && i.isStaleByTime(Ir(e.staleTime, i)) && this.prefetchQuery(e), Promise.resolve(r));
  }
  getQueriesData(t) {
    return y(this, Nt).findAll(t).map(({ queryKey: e, state: i }) => {
      const r = i.data;
      return [e, r];
    });
  }
  setQueryData(t, e, i) {
    const r = this.defaultQueryOptions({ queryKey: t }), o = y(this, Nt).get(
      r.queryHash
    )?.state.data, c = J1(e, o);
    if (c !== void 0)
      return y(this, Nt).build(this, r).setData(c, { ...i, manual: !0 });
  }
  setQueriesData(t, e, i) {
    return ke.batch(
      () => y(this, Nt).findAll(t).map(({ queryKey: r }) => [
        r,
        this.setQueryData(r, e, i)
      ])
    );
  }
  getQueryState(t) {
    const e = this.defaultQueryOptions({ queryKey: t });
    return y(this, Nt).get(
      e.queryHash
    )?.state;
  }
  removeQueries(t) {
    const e = y(this, Nt);
    ke.batch(() => {
      e.findAll(t).forEach((i) => {
        e.remove(i);
      });
    });
  }
  resetQueries(t, e) {
    const i = y(this, Nt);
    return ke.batch(() => (i.findAll(t).forEach((r) => {
      r.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...t
      },
      e
    )));
  }
  cancelQueries(t, e = {}) {
    const i = { revert: !0, ...e }, r = ke.batch(
      () => y(this, Nt).findAll(t).map((s) => s.cancel(i))
    );
    return Promise.all(r).then(Me).catch(Me);
  }
  invalidateQueries(t, e = {}) {
    return ke.batch(() => (y(this, Nt).findAll(t).forEach((i) => {
      i.invalidate();
    }), t?.refetchType === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...t,
        type: t?.refetchType ?? t?.type ?? "active"
      },
      e
    )));
  }
  refetchQueries(t, e = {}) {
    const i = {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }, r = ke.batch(
      () => y(this, Nt).findAll(t).filter((s) => !s.isDisabled() && !s.isStatic()).map((s) => {
        let o = s.fetch(void 0, i);
        return i.throwOnError || (o = o.catch(Me)), s.state.fetchStatus === "paused" ? Promise.resolve() : o;
      })
    );
    return Promise.all(r).then(Me);
  }
  fetchQuery(t) {
    const e = this.defaultQueryOptions(t);
    e.retry === void 0 && (e.retry = !1);
    const i = y(this, Nt).build(this, e);
    return i.isStaleByTime(
      Ir(e.staleTime, i)
    ) ? i.fetch(e) : Promise.resolve(i.state.data);
  }
  prefetchQuery(t) {
    return this.fetchQuery(t).then(Me).catch(Me);
  }
  fetchInfiniteQuery(t) {
    return t.behavior = Kd(t.pages), this.fetchQuery(t);
  }
  prefetchInfiniteQuery(t) {
    return this.fetchInfiniteQuery(t).then(Me).catch(Me);
  }
  ensureInfiniteQueryData(t) {
    return t.behavior = Kd(t.pages), this.ensureQueryData(t);
  }
  resumePausedMutations() {
    return Wd.isOnline() ? y(this, Mr).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return y(this, Nt);
  }
  getMutationCache() {
    return y(this, Mr);
  }
  getDefaultOptions() {
    return y(this, Ar);
  }
  setDefaultOptions(t) {
    _(this, Ar, t);
  }
  setQueryDefaults(t, e) {
    y(this, Ga).set(Pn(t), {
      queryKey: t,
      defaultOptions: e
    });
  }
  getQueryDefaults(t) {
    const e = [...y(this, Ga).values()], i = {};
    return e.forEach((r) => {
      ml(t, r.queryKey) && Object.assign(i, r.defaultOptions);
    }), i;
  }
  setMutationDefaults(t, e) {
    y(this, Za).set(Pn(t), {
      mutationKey: t,
      defaultOptions: e
    });
  }
  getMutationDefaults(t) {
    const e = [...y(this, Za).values()], i = {};
    return e.forEach((r) => {
      ml(t, r.mutationKey) && Object.assign(i, r.defaultOptions);
    }), i;
  }
  defaultQueryOptions(t) {
    if (t._defaulted)
      return t;
    const e = {
      ...y(this, Ar).queries,
      ...this.getQueryDefaults(t.queryKey),
      ...t,
      _defaulted: !0
    };
    return e.queryHash || (e.queryHash = ty(
      e.queryKey,
      e
    )), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.queryFn === ey && (e.enabled = !1), e;
  }
  defaultMutationOptions(t) {
    return t?._defaulted ? t : {
      ...y(this, Ar).mutations,
      ...t?.mutationKey && this.getMutationDefaults(t.mutationKey),
      ...t,
      _defaulted: !0
    };
  }
  clear() {
    y(this, Nt).clear(), y(this, Mr).clear();
  }
}, Nt = new WeakMap(), Mr = new WeakMap(), Ar = new WeakMap(), Ga = new WeakMap(), Za = new WeakMap(), Er = new WeakMap(), Ya = new WeakMap(), Xa = new WeakMap(), a(Ja, "QueryClient"), Ja);
function Fu() {
}
a(Fu, "noop");
function Mg({
  storage: n,
  key: t = "REACT_QUERY_OFFLINE_CACHE",
  throttleTime: e = 1e3,
  serialize: i = JSON.stringify,
  deserialize: r = JSON.parse,
  retry: s
}) {
  if (n) {
    const o = /* @__PURE__ */ a((c) => {
      try {
        n.setItem(t, i(c));
        return;
      } catch (l) {
        return l;
      }
    }, "trySave");
    return {
      persistClient: Ag((c) => {
        let l = c, p = o(l), v = 0;
        for (; p && l; )
          v++, l = s?.({
            persistedClient: l,
            error: p,
            errorCount: v
          }), l && (p = o(l));
      }, e),
      restoreClient: /* @__PURE__ */ a(() => {
        const c = n.getItem(t);
        if (c)
          return r(c);
      }, "restoreClient"),
      removeClient: /* @__PURE__ */ a(() => {
        n.removeItem(t);
      }, "removeClient")
    };
  }
  return {
    persistClient: Fu,
    restoreClient: Fu,
    removeClient: Fu
  };
}
a(Mg, "createSyncStoragePersister");
function Ag(n, t = 100) {
  let e = null, i;
  return function(...r) {
    i = r, e === null && (e = Lr.setTimeout(() => {
      n(...i), e = null;
    }, t));
  };
}
a(Ag, "throttle$1");
var Eg = ["added", "removed", "updated"];
function Xw(n) {
  return Eg.includes(n);
}
a(Xw, "isCacheEventType");
async function Rg({
  queryClient: n,
  persister: t,
  maxAge: e = 1e3 * 60 * 60 * 24,
  buster: i = "",
  hydrateOptions: r
}) {
  try {
    const s = await t.restoreClient();
    if (s)
      if (s.timestamp) {
        const o = Date.now() - s.timestamp > e, c = s.buster !== i;
        if (o || c)
          return t.removeClient();
        pg(n, s.clientState, r);
      } else
        return t.removeClient();
  } catch (s) {
    throw await t.removeClient(), s;
  }
}
a(Rg, "persistQueryClientRestore");
async function Jw({
  queryClient: n,
  persister: t,
  buster: e = "",
  dehydrateOptions: i
}) {
  const r = {
    buster: e,
    timestamp: Date.now(),
    clientState: ug(n, i)
  };
  await t.persistClient(r);
}
a(Jw, "persistQueryClientSave");
function Tg(n) {
  const t = n.queryClient.getQueryCache().subscribe((i) => {
    Xw(i.type) && Jw(n);
  }), e = n.queryClient.getMutationCache().subscribe((i) => {
    Xw(i.type) && Jw(n);
  });
  return () => {
    t(), e();
  };
}
a(Tg, "persistQueryClientSubscribe");
const Lg = /* @__PURE__ */ a((n) => {
  var t;
  return t = class extends n {
    // QUERY CLIENT
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...i) {
      super(...i), this._queryClient = new Sg({
        defaultOptions: {
          queries: {
            staleTime: this.staleTime,
            gcTime: this.gcTime
          }
        }
      }), this.initQueryClient();
    }
    get queryClient() {
      return this._queryClient;
    }
    async initQueryClient() {
      if (this.isDestroyed)
        throw new Ut();
      await this.whenUrl();
      try {
        this._sessionStoragePersister = Mg({
          key: "WEAVY_QUERY_OFFLINE_CACHE",
          storage: window.sessionStorage,
          throttleTime: this.staleTime
        });
        const i = {
          queryClient: this._queryClient,
          persister: this._sessionStoragePersister,
          maxAge: this.gcTime,
          // 24h - should match gcTime
          buster: this.cachePrefix,
          // Cache busting parameter (build hash or similar)
          hydrateOptions: void 0,
          dehydrateOptions: {
            shouldDehydrateMutation: /* @__PURE__ */ a((r) => {
              const s = r.state.context?.status?.state === "pending";
              return !!(r.state.context && !s || r.state.isPaused);
            }, "shouldDehydrateMutation")
          }
        };
        await Rg(i), this._unsubscribeQueryClient = Tg(i);
      } catch {
        console.warn(this.weavyId, "Query cache persister not available.");
      }
      this.host.isConnected && this._queryClient.mount(), this._hostIsConnectedObserver = g1(this.host, (i) => {
        this.isDestroyed || (i ? (console.info(this.weavyId, "Query client mounted"), this._queryClient.mount()) : (console.info(this.weavyId, "Query client unmounted"), this._queryClient.unmount()));
      });
    }
    async reset() {
      await super.reset(), await this._queryClient.cancelQueries(), await this._sessionStoragePersister?.removeClient(), await this.queryClient.resetQueries();
    }
    async disconnectQueryClient() {
      console.info(this.weavyId, "Query client disconnected"), await this._queryClient.cancelQueries(), await this._sessionStoragePersister?.removeClient(), this._unsubscribeQueryClient?.(), this._queryClient.unmount(), this._queryClient.clear();
    }
    destroy() {
      super.destroy(), this._hostIsConnectedObserver?.disconnect(), this.disconnectQueryClient();
    }
  }, a(t, "WeavyQuery"), t;
}, "WeavyQueryMixin"), Og = /* @__PURE__ */ a((n) => {
  var t;
  return t = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...i) {
      super(...i);
    }
    set annotations(i) {
      this._annotations = i, this.updateContext();
    }
    get annotations() {
      return this._annotations ?? ae.defaults.annotations;
    }
    set enterToSend(i) {
      this._enterToSend = i, this.updateContext();
    }
    get enterToSend() {
      return this._enterToSend ?? ae.defaults.enterToSend;
    }
    set reactions(i) {
      this._reactions = i, this.updateContext();
    }
    get reactions() {
      return this._reactions ?? ae.defaults.reactions;
    }
  }, a(t, "WeavySettings"), t;
}, "WeavySettingsMixin");
function He(n) {
  return n < 0 ? -1 : n === 0 ? 0 : 1;
}
a(He, "signum");
function hl(n, t, e) {
  return (1 - e) * n + e * t;
}
a(hl, "lerp");
function zg(n, t, e) {
  return e < n ? n : e > t ? t : e;
}
a(zg, "clampInt");
function $e(n, t, e) {
  return e < n ? n : e > t ? t : e;
}
a($e, "clampDouble");
function tf(n) {
  return n = n % 360, n < 0 && (n = n + 360), n;
}
a(tf, "sanitizeDegreesInt");
function Ue(n) {
  return n = n % 360, n < 0 && (n = n + 360), n;
}
a(Ue, "sanitizeDegreesDouble");
function pp(n, t) {
  const e = n[0] * t[0][0] + n[1] * t[0][1] + n[2] * t[0][2], i = n[0] * t[1][0] + n[1] * t[1][1] + n[2] * t[1][2], r = n[0] * t[2][0] + n[1] * t[2][1] + n[2] * t[2][2];
  return [e, i, r];
}
a(pp, "matrixMultiply");
const $m = [
  [0.41233895, 0.35762064, 0.18051042],
  [0.2126, 0.7152, 0.0722],
  [0.01932141, 0.11916382, 0.95034478]
], Ig = [
  [
    3.2413774792388685,
    -1.5376652402851851,
    -0.49885366846268053
  ],
  [
    -0.9691452513005321,
    1.8758853451067872,
    0.04156585616912061
  ],
  [
    0.05562093689691305,
    -0.20395524564742123,
    1.0571799111220335
  ]
], km = [95.047, 100, 108.883];
function ny(n, t, e) {
  return (255 << 24 | (n & 255) << 16 | (t & 255) << 8 | e & 255) >>> 0;
}
a(ny, "argbFromRgb");
function ef(n) {
  const t = $n(n[0]), e = $n(n[1]), i = $n(n[2]);
  return ny(t, e, i);
}
a(ef, "argbFromLinrgb");
function Fg(n) {
  return n >> 24 & 255;
}
a(Fg, "alphaFromArgb");
function ay(n) {
  return n >> 16 & 255;
}
a(ay, "redFromArgb");
function sy(n) {
  return n >> 8 & 255;
}
a(sy, "greenFromArgb");
function oy(n) {
  return n & 255;
}
a(oy, "blueFromArgb");
function Dg(n, t, e) {
  const i = Ig, r = i[0][0] * n + i[0][1] * t + i[0][2] * e, s = i[1][0] * n + i[1][1] * t + i[1][2] * e, o = i[2][0] * n + i[2][1] * t + i[2][2] * e, c = $n(r), l = $n(s), p = $n(o);
  return ny(c, l, p);
}
a(Dg, "argbFromXyz");
function Vg(n) {
  const t = Ji(ay(n)), e = Ji(sy(n)), i = Ji(oy(n));
  return pp([t, e, i], $m);
}
a(Vg, "xyzFromArgb");
function Hg(n) {
  const t = Ji(ay(n)), e = Ji(sy(n)), i = Ji(oy(n)), r = $m, s = r[0][0] * t + r[0][1] * e + r[0][2] * i, o = r[1][0] * t + r[1][1] * e + r[1][2] * i, c = r[2][0] * t + r[2][1] * e + r[2][2] * i, l = km, p = s / l[0], v = o / l[1], C = c / l[2], g = ul(p), m = ul(v), f = ul(C), $ = 116 * m - 16, A = 500 * (g - m), M = 200 * (m - f);
  return [$, A, M];
}
a(Hg, "labFromArgb");
function Bg(n) {
  const t = Or(n), e = $n(t);
  return ny(e, e, e);
}
a(Bg, "argbFromLstar");
function rf(n) {
  const t = Vg(n)[1];
  return 116 * ul(t / 100) - 16;
}
a(rf, "lstarFromArgb");
function Or(n) {
  return 100 * Ug((n + 16) / 116);
}
a(Or, "yFromLstar");
function yp(n) {
  return ul(n / 100) * 116 - 16;
}
a(yp, "lstarFromY");
function Ji(n) {
  const t = n / 255;
  return t <= 0.040449936 ? t / 12.92 * 100 : Math.pow((t + 0.055) / 1.055, 2.4) * 100;
}
a(Ji, "linearized");
function $n(n) {
  const t = n / 100;
  let e = 0;
  return t <= 31308e-7 ? e = t * 12.92 : e = 1.055 * Math.pow(t, 1 / 2.4) - 0.055, zg(0, 255, Math.round(e * 255));
}
a($n, "delinearized");
function Ng() {
  return km;
}
a(Ng, "whitePointD65");
function ul(n) {
  const t = 0.008856451679035631, e = 24389 / 27;
  return n > t ? Math.pow(n, 1 / 3) : (e * n + 16) / 116;
}
a(ul, "labF");
function Ug(n) {
  const t = 0.008856451679035631, e = 24389 / 27, i = n * n * n;
  return i > t ? i : (116 * n - 16) / e;
}
a(Ug, "labInvf");
const wh = class wh {
  /**
   * Create ViewingConditions from a simple, physically relevant, set of
   * parameters.
   *
   * @param whitePoint White point, measured in the XYZ color space.
   *     default = D65, or sunny day afternoon
   * @param adaptingLuminance The luminance of the adapting field. Informally,
   *     how bright it is in the room where the color is viewed. Can be
   *     calculated from lux by multiplying lux by 0.0586. default = 11.72,
   *     or 200 lux.
   * @param backgroundLstar The lightness of the area surrounding the color.
   *     measured by L* in L*a*b*. default = 50.0
   * @param surround A general description of the lighting surrounding the
   *     color. 0 is pitch dark, like watching a movie in a theater. 1.0 is a
   *     dimly light room, like watching TV at home at night. 2.0 means there
   *     is no difference between the lighting on the color and around it.
   *     default = 2.0
   * @param discountingIlluminant Whether the eye accounts for the tint of the
   *     ambient lighting, such as knowing an apple is still red in green light.
   *     default = false, the eye does not perform this process on
   *       self-luminous objects like displays.
   */
  static make(t = Ng(), e = 200 / Math.PI * Or(50) / 100, i = 50, r = 2, s = !1) {
    const o = t, c = o[0] * 0.401288 + o[1] * 0.650173 + o[2] * -0.051461, l = o[0] * -0.250268 + o[1] * 1.204414 + o[2] * 0.045854, p = o[0] * -2079e-6 + o[1] * 0.048952 + o[2] * 0.953127, v = 0.8 + r / 10, C = v >= 0.9 ? hl(0.59, 0.69, (v - 0.9) * 10) : hl(0.525, 0.59, (v - 0.8) * 10);
    let g = s ? 1 : v * (1 - 1 / 3.6 * Math.exp((-e - 42) / 92));
    g = g > 1 ? 1 : g < 0 ? 0 : g;
    const m = v, f = [
      g * (100 / c) + 1 - g,
      g * (100 / l) + 1 - g,
      g * (100 / p) + 1 - g
    ], $ = 1 / (5 * e + 1), A = $ * $ * $ * $, M = 1 - A, R = A * e + 0.1 * M * M * Math.cbrt(5 * e), V = Or(i) / t[1], W = 1.48 + Math.sqrt(V), I = 0.725 / Math.pow(V, 0.2), U = I, K = [
      Math.pow(R * f[0] * c / 100, 0.42),
      Math.pow(R * f[1] * l / 100, 0.42),
      Math.pow(R * f[2] * p / 100, 0.42)
    ], tt = [
      400 * K[0] / (K[0] + 27.13),
      400 * K[1] / (K[1] + 27.13),
      400 * K[2] / (K[2] + 27.13)
    ], ot = (2 * tt[0] + tt[1] + 0.05 * tt[2]) * I;
    return new wh(V, ot, I, U, C, m, f, R, Math.pow(R, 0.25), W);
  }
  /**
   * Parameters are intermediate values of the CAM16 conversion process. Their
   * names are shorthand for technical color science terminology, this class
   * would not benefit from documenting them individually. A brief overview
   * is available in the CAM16 specification, and a complete overview requires
   * a color science textbook, such as Fairchild's Color Appearance Models.
   */
  constructor(t, e, i, r, s, o, c, l, p, v) {
    this.n = t, this.aw = e, this.nbb = i, this.ncb = r, this.c = s, this.nc = o, this.rgbD = c, this.fl = l, this.fLRoot = p, this.z = v;
  }
};
a(wh, "ViewingConditions");
let Ei = wh;
Ei.DEFAULT = Ei.make();
const ki = class ki {
  /**
   * All of the CAM16 dimensions can be calculated from 3 of the dimensions, in
   * the following combinations:
   *      -  {j or q} and {c, m, or s} and hue
   *      - jstar, astar, bstar
   * Prefer using a static method that constructs from 3 of those dimensions.
   * This constructor is intended for those methods to use to return all
   * possible dimensions.
   *
   * @param hue
   * @param chroma informally, colorfulness / color intensity. like saturation
   *     in HSL, except perceptually accurate.
   * @param j lightness
   * @param q brightness; ratio of lightness to white point's lightness
   * @param m colorfulness
   * @param s saturation; ratio of chroma to white point's chroma
   * @param jstar CAM16-UCS J coordinate
   * @param astar CAM16-UCS a coordinate
   * @param bstar CAM16-UCS b coordinate
   */
  constructor(t, e, i, r, s, o, c, l, p) {
    this.hue = t, this.chroma = e, this.j = i, this.q = r, this.m = s, this.s = o, this.jstar = c, this.astar = l, this.bstar = p;
  }
  /**
   * CAM16 instances also have coordinates in the CAM16-UCS space, called J*,
   * a*, b*, or jstar, astar, bstar in code. CAM16-UCS is included in the CAM16
   * specification, and is used to measure distances between colors.
   */
  distance(t) {
    const e = this.jstar - t.jstar, i = this.astar - t.astar, r = this.bstar - t.bstar, s = Math.sqrt(e * e + i * i + r * r);
    return 1.41 * Math.pow(s, 0.63);
  }
  /**
   * @param argb ARGB representation of a color.
   * @return CAM16 color, assuming the color was viewed in default viewing
   *     conditions.
   */
  static fromInt(t) {
    return ki.fromIntInViewingConditions(t, Ei.DEFAULT);
  }
  /**
   * @param argb ARGB representation of a color.
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   * @return CAM16 color.
   */
  static fromIntInViewingConditions(t, e) {
    const i = (t & 16711680) >> 16, r = (t & 65280) >> 8, s = t & 255, o = Ji(i), c = Ji(r), l = Ji(s), p = 0.41233895 * o + 0.35762064 * c + 0.18051042 * l, v = 0.2126 * o + 0.7152 * c + 0.0722 * l, C = 0.01932141 * o + 0.11916382 * c + 0.95034478 * l, g = 0.401288 * p + 0.650173 * v - 0.051461 * C, m = -0.250268 * p + 1.204414 * v + 0.045854 * C, f = -2079e-6 * p + 0.048952 * v + 0.953127 * C, $ = e.rgbD[0] * g, A = e.rgbD[1] * m, M = e.rgbD[2] * f, R = Math.pow(e.fl * Math.abs($) / 100, 0.42), V = Math.pow(e.fl * Math.abs(A) / 100, 0.42), W = Math.pow(e.fl * Math.abs(M) / 100, 0.42), I = He($) * 400 * R / (R + 27.13), U = He(A) * 400 * V / (V + 27.13), K = He(M) * 400 * W / (W + 27.13), tt = (11 * I + -12 * U + K) / 11, ot = (I + U - 2 * K) / 9, rt = (20 * I + 20 * U + 21 * K) / 20, Lt = (40 * I + 20 * U + K) / 20, At = Math.atan2(ot, tt) * 180 / Math.PI, vt = Ue(At), Bt = vt * Math.PI / 180, xe = Lt * e.nbb, Rt = 100 * Math.pow(xe / e.aw, e.c * e.z), xt = 4 / e.c * Math.sqrt(Rt / 100) * (e.aw + 4) * e.fLRoot, ie = vt < 20.14 ? vt + 360 : vt, ct = 0.25 * (Math.cos(ie * Math.PI / 180 + 2) + 3.8), hi = 5e4 / 13 * ct * e.nc * e.ncb * Math.sqrt(tt * tt + ot * ot) / (rt + 0.305), Ye = Math.pow(hi, 0.9) * Math.pow(1.64 - Math.pow(0.29, e.n), 0.73), Hi = Ye * Math.sqrt(Rt / 100), Bi = Hi * e.fLRoot, sl = 50 * Math.sqrt(Ye * e.c / (e.aw + 4)), Ci = (1 + 100 * 7e-3) * Rt / (1 + 7e-3 * Rt), Ct = 1 / 0.0228 * Math.log(1 + 0.0228 * Bi), Ve = Ct * Math.cos(Bt), Et = Ct * Math.sin(Bt);
    return new ki(vt, Hi, Rt, xt, Bi, sl, Ci, Ve, Et);
  }
  /**
   * @param j CAM16 lightness
   * @param c CAM16 chroma
   * @param h CAM16 hue
   */
  static fromJch(t, e, i) {
    return ki.fromJchInViewingConditions(t, e, i, Ei.DEFAULT);
  }
  /**
   * @param j CAM16 lightness
   * @param c CAM16 chroma
   * @param h CAM16 hue
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   */
  static fromJchInViewingConditions(t, e, i, r) {
    const s = 4 / r.c * Math.sqrt(t / 100) * (r.aw + 4) * r.fLRoot, o = e * r.fLRoot, c = e / Math.sqrt(t / 100), l = 50 * Math.sqrt(c * r.c / (r.aw + 4)), p = i * Math.PI / 180, v = (1 + 100 * 7e-3) * t / (1 + 7e-3 * t), C = 1 / 0.0228 * Math.log(1 + 0.0228 * o), g = C * Math.cos(p), m = C * Math.sin(p);
    return new ki(i, e, t, s, o, l, v, g, m);
  }
  /**
   * @param jstar CAM16-UCS lightness.
   * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the Y axis.
   * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the X axis.
   */
  static fromUcs(t, e, i) {
    return ki.fromUcsInViewingConditions(t, e, i, Ei.DEFAULT);
  }
  /**
   * @param jstar CAM16-UCS lightness.
   * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the Y axis.
   * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the X axis.
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   */
  static fromUcsInViewingConditions(t, e, i, r) {
    const s = e, o = i, c = Math.sqrt(s * s + o * o), p = (Math.exp(c * 0.0228) - 1) / 0.0228 / r.fLRoot;
    let v = Math.atan2(o, s) * (180 / Math.PI);
    v < 0 && (v += 360);
    const C = t / (1 - (t - 100) * 7e-3);
    return ki.fromJchInViewingConditions(C, p, v, r);
  }
  /**
   *  @return ARGB representation of color, assuming the color was viewed in
   *     default viewing conditions, which are near-identical to the default
   *     viewing conditions for sRGB.
   */
  toInt() {
    return this.viewed(Ei.DEFAULT);
  }
  /**
   * @param viewingConditions Information about the environment where the color
   *     will be viewed.
   * @return ARGB representation of color
   */
  viewed(t) {
    const e = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100), i = Math.pow(e / Math.pow(1.64 - Math.pow(0.29, t.n), 0.73), 1 / 0.9), r = this.hue * Math.PI / 180, s = 0.25 * (Math.cos(r + 2) + 3.8), o = t.aw * Math.pow(this.j / 100, 1 / t.c / t.z), c = s * (5e4 / 13) * t.nc * t.ncb, l = o / t.nbb, p = Math.sin(r), v = Math.cos(r), C = 23 * (l + 0.305) * i / (23 * c + 11 * i * v + 108 * i * p), g = C * v, m = C * p, f = (460 * l + 451 * g + 288 * m) / 1403, $ = (460 * l - 891 * g - 261 * m) / 1403, A = (460 * l - 220 * g - 6300 * m) / 1403, M = Math.max(0, 27.13 * Math.abs(f) / (400 - Math.abs(f))), R = He(f) * (100 / t.fl) * Math.pow(M, 1 / 0.42), V = Math.max(0, 27.13 * Math.abs($) / (400 - Math.abs($))), W = He($) * (100 / t.fl) * Math.pow(V, 1 / 0.42), I = Math.max(0, 27.13 * Math.abs(A) / (400 - Math.abs(A))), U = He(A) * (100 / t.fl) * Math.pow(I, 1 / 0.42), K = R / t.rgbD[0], tt = W / t.rgbD[1], ot = U / t.rgbD[2], rt = 1.86206786 * K - 1.01125463 * tt + 0.14918677 * ot, Lt = 0.38752654 * K + 0.62144744 * tt - 897398e-8 * ot, Ot = -0.0158415 * K - 0.03412294 * tt + 1.04996444 * ot;
    return Dg(rt, Lt, Ot);
  }
  /// Given color expressed in XYZ and viewed in [viewingConditions], convert to
  /// CAM16.
  static fromXyzInViewingConditions(t, e, i, r) {
    const s = 0.401288 * t + 0.650173 * e - 0.051461 * i, o = -0.250268 * t + 1.204414 * e + 0.045854 * i, c = -2079e-6 * t + 0.048952 * e + 0.953127 * i, l = r.rgbD[0] * s, p = r.rgbD[1] * o, v = r.rgbD[2] * c, C = Math.pow(r.fl * Math.abs(l) / 100, 0.42), g = Math.pow(r.fl * Math.abs(p) / 100, 0.42), m = Math.pow(r.fl * Math.abs(v) / 100, 0.42), f = He(l) * 400 * C / (C + 27.13), $ = He(p) * 400 * g / (g + 27.13), A = He(v) * 400 * m / (m + 27.13), M = (11 * f + -12 * $ + A) / 11, R = (f + $ - 2 * A) / 9, V = (20 * f + 20 * $ + 21 * A) / 20, W = (40 * f + 20 * $ + A) / 20, U = Math.atan2(R, M) * 180 / Math.PI, K = U < 0 ? U + 360 : U >= 360 ? U - 360 : U, tt = K * Math.PI / 180, ot = W * r.nbb, rt = 100 * Math.pow(ot / r.aw, r.c * r.z), Lt = 4 / r.c * Math.sqrt(rt / 100) * (r.aw + 4) * r.fLRoot, Ot = K < 20.14 ? K + 360 : K, At = 1 / 4 * (Math.cos(Ot * Math.PI / 180 + 2) + 3.8), Bt = 5e4 / 13 * At * r.nc * r.ncb * Math.sqrt(M * M + R * R) / (V + 0.305), xe = Math.pow(Bt, 0.9) * Math.pow(1.64 - Math.pow(0.29, r.n), 0.73), Rt = xe * Math.sqrt(rt / 100), xt = Rt * r.fLRoot, ie = 50 * Math.sqrt(xe * r.c / (r.aw + 4)), ct = (1 + 100 * 7e-3) * rt / (1 + 7e-3 * rt), kt = Math.log(1 + 0.0228 * xt) / 0.0228, hi = kt * Math.cos(tt), Ye = kt * Math.sin(tt);
    return new ki(K, Rt, rt, Lt, xt, ie, ct, hi, Ye);
  }
  /// XYZ representation of CAM16 seen in [viewingConditions].
  xyzInViewingConditions(t) {
    const e = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100), i = Math.pow(e / Math.pow(1.64 - Math.pow(0.29, t.n), 0.73), 1 / 0.9), r = this.hue * Math.PI / 180, s = 0.25 * (Math.cos(r + 2) + 3.8), o = t.aw * Math.pow(this.j / 100, 1 / t.c / t.z), c = s * (5e4 / 13) * t.nc * t.ncb, l = o / t.nbb, p = Math.sin(r), v = Math.cos(r), C = 23 * (l + 0.305) * i / (23 * c + 11 * i * v + 108 * i * p), g = C * v, m = C * p, f = (460 * l + 451 * g + 288 * m) / 1403, $ = (460 * l - 891 * g - 261 * m) / 1403, A = (460 * l - 220 * g - 6300 * m) / 1403, M = Math.max(0, 27.13 * Math.abs(f) / (400 - Math.abs(f))), R = He(f) * (100 / t.fl) * Math.pow(M, 1 / 0.42), V = Math.max(0, 27.13 * Math.abs($) / (400 - Math.abs($))), W = He($) * (100 / t.fl) * Math.pow(V, 1 / 0.42), I = Math.max(0, 27.13 * Math.abs(A) / (400 - Math.abs(A))), U = He(A) * (100 / t.fl) * Math.pow(I, 1 / 0.42), K = R / t.rgbD[0], tt = W / t.rgbD[1], ot = U / t.rgbD[2], rt = 1.86206786 * K - 1.01125463 * tt + 0.14918677 * ot, Lt = 0.38752654 * K + 0.62144744 * tt - 897398e-8 * ot, Ot = -0.0158415 * K - 0.03412294 * tt + 1.04996444 * ot;
    return [rt, Lt, Ot];
  }
};
a(ki, "Cam16");
let on = ki;
const wt = class wt {
  /**
   * Sanitizes a small enough angle in radians.
   *
   * @param angle An angle in radians; must not deviate too much
   * from 0.
   * @return A coterminal angle between 0 and 2pi.
   */
  static sanitizeRadians(t) {
    return (t + Math.PI * 8) % (Math.PI * 2);
  }
  /**
   * Delinearizes an RGB component, returning a floating-point
   * number.
   *
   * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents
   * linear R/G/B channel
   * @return 0.0 <= output <= 255.0, color channel converted to
   * regular RGB space
   */
  static trueDelinearized(t) {
    const e = t / 100;
    let i = 0;
    return e <= 31308e-7 ? i = e * 12.92 : i = 1.055 * Math.pow(e, 1 / 2.4) - 0.055, i * 255;
  }
  static chromaticAdaptation(t) {
    const e = Math.pow(Math.abs(t), 0.42);
    return He(t) * 400 * e / (e + 27.13);
  }
  /**
   * Returns the hue of a linear RGB color in CAM16.
   *
   * @param linrgb The linear RGB coordinates of a color.
   * @return The hue of the color in CAM16, in radians.
   */
  static hueOf(t) {
    const e = pp(t, wt.SCALED_DISCOUNT_FROM_LINRGB), i = wt.chromaticAdaptation(e[0]), r = wt.chromaticAdaptation(e[1]), s = wt.chromaticAdaptation(e[2]), o = (11 * i + -12 * r + s) / 11, c = (i + r - 2 * s) / 9;
    return Math.atan2(c, o);
  }
  static areInCyclicOrder(t, e, i) {
    const r = wt.sanitizeRadians(e - t), s = wt.sanitizeRadians(i - t);
    return r < s;
  }
  /**
   * Solves the lerp equation.
   *
   * @param source The starting number.
   * @param mid The number in the middle.
   * @param target The ending number.
   * @return A number t such that lerp(source, target, t) = mid.
   */
  static intercept(t, e, i) {
    return (e - t) / (i - t);
  }
  static lerpPoint(t, e, i) {
    return [
      t[0] + (i[0] - t[0]) * e,
      t[1] + (i[1] - t[1]) * e,
      t[2] + (i[2] - t[2]) * e
    ];
  }
  /**
   * Intersects a segment with a plane.
   *
   * @param source The coordinates of point A.
   * @param coordinate The R-, G-, or B-coordinate of the plane.
   * @param target The coordinates of point B.
   * @param axis The axis the plane is perpendicular with. (0: R, 1:
   * G, 2: B)
   * @return The intersection point of the segment AB with the plane
   * R=coordinate, G=coordinate, or B=coordinate
   */
  static setCoordinate(t, e, i, r) {
    const s = wt.intercept(t[r], e, i[r]);
    return wt.lerpPoint(t, s, i);
  }
  static isBounded(t) {
    return 0 <= t && t <= 100;
  }
  /**
   * Returns the nth possible vertex of the polygonal intersection.
   *
   * @param y The Y value of the plane.
   * @param n The zero-based index of the point. 0 <= n <= 11.
   * @return The nth possible vertex of the polygonal intersection
   * of the y plane and the RGB cube, in linear RGB coordinates, if
   * it exists. If this possible vertex lies outside of the cube,
   * [-1.0, -1.0, -1.0] is returned.
   */
  static nthVertex(t, e) {
    const i = wt.Y_FROM_LINRGB[0], r = wt.Y_FROM_LINRGB[1], s = wt.Y_FROM_LINRGB[2], o = e % 4 <= 1 ? 0 : 100, c = e % 2 === 0 ? 0 : 100;
    if (e < 4) {
      const l = o, p = c, v = (t - l * r - p * s) / i;
      return wt.isBounded(v) ? [v, l, p] : [-1, -1, -1];
    } else if (e < 8) {
      const l = o, p = c, v = (t - p * i - l * s) / r;
      return wt.isBounded(v) ? [p, v, l] : [-1, -1, -1];
    } else {
      const l = o, p = c, v = (t - l * i - p * r) / s;
      return wt.isBounded(v) ? [l, p, v] : [-1, -1, -1];
    }
  }
  /**
   * Finds the segment containing the desired color.
   *
   * @param y The Y value of the color.
   * @param targetHue The hue of the color.
   * @return A list of two sets of linear RGB coordinates, each
   * corresponding to an endpoint of the segment containing the
   * desired color.
   */
  static bisectToSegment(t, e) {
    let i = [-1, -1, -1], r = i, s = 0, o = 0, c = !1, l = !0;
    for (let p = 0; p < 12; p++) {
      const v = wt.nthVertex(t, p);
      if (v[0] < 0)
        continue;
      const C = wt.hueOf(v);
      if (!c) {
        i = v, r = v, s = C, o = C, c = !0;
        continue;
      }
      (l || wt.areInCyclicOrder(s, C, o)) && (l = !1, wt.areInCyclicOrder(s, e, C) ? (r = v, o = C) : (i = v, s = C));
    }
    return [i, r];
  }
  static midpoint(t, e) {
    return [
      (t[0] + e[0]) / 2,
      (t[1] + e[1]) / 2,
      (t[2] + e[2]) / 2
    ];
  }
  static criticalPlaneBelow(t) {
    return Math.floor(t - 0.5);
  }
  static criticalPlaneAbove(t) {
    return Math.ceil(t - 0.5);
  }
  /**
   * Finds a color with the given Y and hue on the boundary of the
   * cube.
   *
   * @param y The Y value of the color.
   * @param targetHue The hue of the color.
   * @return The desired color, in linear RGB coordinates.
   */
  static bisectToLimit(t, e) {
    const i = wt.bisectToSegment(t, e);
    let r = i[0], s = wt.hueOf(r), o = i[1];
    for (let c = 0; c < 3; c++)
      if (r[c] !== o[c]) {
        let l = -1, p = 255;
        r[c] < o[c] ? (l = wt.criticalPlaneBelow(wt.trueDelinearized(r[c])), p = wt.criticalPlaneAbove(wt.trueDelinearized(o[c]))) : (l = wt.criticalPlaneAbove(wt.trueDelinearized(r[c])), p = wt.criticalPlaneBelow(wt.trueDelinearized(o[c])));
        for (let v = 0; v < 8 && !(Math.abs(p - l) <= 1); v++) {
          const C = Math.floor((l + p) / 2), g = wt.CRITICAL_PLANES[C], m = wt.setCoordinate(r, g, o, c), f = wt.hueOf(m);
          wt.areInCyclicOrder(s, e, f) ? (o = m, p = C) : (r = m, s = f, l = C);
        }
      }
    return wt.midpoint(r, o);
  }
  static inverseChromaticAdaptation(t) {
    const e = Math.abs(t), i = Math.max(0, 27.13 * e / (400 - e));
    return He(t) * Math.pow(i, 1 / 0.42);
  }
  /**
   * Finds a color with the given hue, chroma, and Y.
   *
   * @param hueRadians The desired hue in radians.
   * @param chroma The desired chroma.
   * @param y The desired Y.
   * @return The desired color as a hexadecimal integer, if found; 0
   * otherwise.
   */
  static findResultByJ(t, e, i) {
    let r = Math.sqrt(i) * 11;
    const s = Ei.DEFAULT, o = 1 / Math.pow(1.64 - Math.pow(0.29, s.n), 0.73), l = 0.25 * (Math.cos(t + 2) + 3.8) * (5e4 / 13) * s.nc * s.ncb, p = Math.sin(t), v = Math.cos(t);
    for (let C = 0; C < 5; C++) {
      const g = r / 100, m = e === 0 || r === 0 ? 0 : e / Math.sqrt(g), f = Math.pow(m * o, 1 / 0.9), A = s.aw * Math.pow(g, 1 / s.c / s.z) / s.nbb, M = 23 * (A + 0.305) * f / (23 * l + 11 * f * v + 108 * f * p), R = M * v, V = M * p, W = (460 * A + 451 * R + 288 * V) / 1403, I = (460 * A - 891 * R - 261 * V) / 1403, U = (460 * A - 220 * R - 6300 * V) / 1403, K = wt.inverseChromaticAdaptation(W), tt = wt.inverseChromaticAdaptation(I), ot = wt.inverseChromaticAdaptation(U), rt = pp([K, tt, ot], wt.LINRGB_FROM_SCALED_DISCOUNT);
      if (rt[0] < 0 || rt[1] < 0 || rt[2] < 0)
        return 0;
      const Lt = wt.Y_FROM_LINRGB[0], Ot = wt.Y_FROM_LINRGB[1], At = wt.Y_FROM_LINRGB[2], vt = Lt * rt[0] + Ot * rt[1] + At * rt[2];
      if (vt <= 0)
        return 0;
      if (C === 4 || Math.abs(vt - i) < 2e-3)
        return rt[0] > 100.01 || rt[1] > 100.01 || rt[2] > 100.01 ? 0 : ef(rt);
      r = r - (vt - i) * r / (2 * vt);
    }
    return 0;
  }
  /**
   * Finds an sRGB color with the given hue, chroma, and L*, if
   * possible.
   *
   * @param hueDegrees The desired hue, in degrees.
   * @param chroma The desired chroma.
   * @param lstar The desired L*.
   * @return A hexadecimal representing the sRGB color. The color
   * has sufficiently close hue, chroma, and L* to the desired
   * values, if possible; otherwise, the hue and L* will be
   * sufficiently close, and chroma will be maximized.
   */
  static solveToInt(t, e, i) {
    if (e < 1e-4 || i < 1e-4 || i > 99.9999)
      return Bg(i);
    t = Ue(t);
    const r = t / 180 * Math.PI, s = Or(i), o = wt.findResultByJ(r, e, s);
    if (o !== 0)
      return o;
    const c = wt.bisectToLimit(s, r);
    return ef(c);
  }
  /**
   * Finds an sRGB color with the given hue, chroma, and L*, if
   * possible.
   *
   * @param hueDegrees The desired hue, in degrees.
   * @param chroma The desired chroma.
   * @param lstar The desired L*.
   * @return An CAM16 object representing the sRGB color. The color
   * has sufficiently close hue, chroma, and L* to the desired
   * values, if possible; otherwise, the hue and L* will be
   * sufficiently close, and chroma will be maximized.
   */
  static solveToCam(t, e, i) {
    return on.fromInt(wt.solveToInt(t, e, i));
  }
};
a(wt, "HctSolver");
let Ri = wt;
Ri.SCALED_DISCOUNT_FROM_LINRGB = [
  [
    0.001200833568784504,
    0.002389694492170889,
    2795742885861124e-19
  ],
  [
    5891086651375999e-19,
    0.0029785502573438758,
    3270666104008398e-19
  ],
  [
    10146692491640572e-20,
    5364214359186694e-19,
    0.0032979401770712076
  ]
];
Ri.LINRGB_FROM_SCALED_DISCOUNT = [
  [
    1373.2198709594231,
    -1100.4251190754821,
    -7.278681089101213
  ],
  [
    -271.815969077903,
    559.6580465940733,
    -32.46047482791194
  ],
  [
    1.9622899599665666,
    -57.173814538844006,
    308.7233197812385
  ]
];
Ri.Y_FROM_LINRGB = [0.2126, 0.7152, 0.0722];
Ri.CRITICAL_PLANES = [
  0.015176349177441876,
  0.045529047532325624,
  0.07588174588720938,
  0.10623444424209313,
  0.13658714259697685,
  0.16693984095186062,
  0.19729253930674434,
  0.2276452376616281,
  0.2579979360165119,
  0.28835063437139563,
  0.3188300904430532,
  0.350925934958123,
  0.3848314933096426,
  0.42057480301049466,
  0.458183274052838,
  0.4976837250274023,
  0.5391024159806381,
  0.5824650784040898,
  0.6277969426914107,
  0.6751227633498623,
  0.7244668422128921,
  0.775853049866786,
  0.829304845476233,
  0.8848452951698498,
  0.942497089126609,
  1.0022825574869039,
  1.0642236851973577,
  1.1283421258858297,
  1.1946592148522128,
  1.2631959812511864,
  1.3339731595349034,
  1.407011200216447,
  1.4823302800086415,
  1.5599503113873272,
  1.6398909516233677,
  1.7221716113234105,
  1.8068114625156377,
  1.8938294463134073,
  1.9832442801866852,
  2.075074464868551,
  2.1693382909216234,
  2.2660538449872063,
  2.36523901573795,
  2.4669114995532007,
  2.5710888059345764,
  2.6777882626779785,
  2.7870270208169257,
  2.898822059350997,
  3.0131901897720907,
  3.1301480604002863,
  3.2497121605402226,
  3.3718988244681087,
  3.4967242352587946,
  3.624204428461639,
  3.754355295633311,
  3.887192587735158,
  4.022731918402185,
  4.160988767090289,
  4.301978482107941,
  4.445716283538092,
  4.592217266055746,
  4.741496401646282,
  4.893568542229298,
  5.048448422192488,
  5.20615066083972,
  5.3666897647573375,
  5.5300801301023865,
  5.696336044816294,
  5.865471690767354,
  6.037501145825082,
  6.212438385869475,
  6.390297286737924,
  6.571091626112461,
  6.7548350853498045,
  6.941541251256611,
  7.131223617812143,
  7.323895587840543,
  7.5195704746346665,
  7.7182615035334345,
  7.919981813454504,
  8.124744458384042,
  8.332562408825165,
  8.543448553206703,
  8.757415699253682,
  8.974476575321063,
  9.194643831691977,
  9.417930041841839,
  9.644347703669503,
  9.873909240696694,
  10.106627003236781,
  10.342513269534024,
  10.58158024687427,
  10.8238400726681,
  11.069304815507364,
  11.317986476196008,
  11.569896988756009,
  11.825048221409341,
  12.083451977536606,
  12.345119996613247,
  12.610063955123938,
  12.878295467455942,
  13.149826086772048,
  13.42466730586372,
  13.702830557985108,
  13.984327217668513,
  14.269168601521828,
  14.55736596900856,
  14.848930523210871,
  15.143873411576273,
  15.44220572664832,
  15.743938506781891,
  16.04908273684337,
  16.35764934889634,
  16.66964922287304,
  16.985093187232053,
  17.30399201960269,
  17.62635644741625,
  17.95219714852476,
  18.281524751807332,
  18.614349837764564,
  18.95068293910138,
  19.290534541298456,
  19.633915083172692,
  19.98083495742689,
  20.331304511189067,
  20.685334046541502,
  21.042933821039977,
  21.404114048223256,
  21.76888489811322,
  22.137256497705877,
  22.50923893145328,
  22.884842241736916,
  23.264076429332462,
  23.6469514538663,
  24.033477234264016,
  24.42366364919083,
  24.817520537484558,
  25.21505769858089,
  25.61628489293138,
  26.021211842414342,
  26.429848230738664,
  26.842203703840827,
  27.258287870275353,
  27.678110301598522,
  28.10168053274597,
  28.529008062403893,
  28.96010235337422,
  29.39497283293396,
  29.83362889318845,
  30.276079891419332,
  30.722335150426627,
  31.172403958865512,
  31.62629557157785,
  32.08401920991837,
  32.54558406207592,
  33.010999283389665,
  33.4802739966603,
  33.953417292456834,
  34.430438229418264,
  34.911345834551085,
  35.39614910352207,
  35.88485700094671,
  36.37747846067349,
  36.87402238606382,
  37.37449765026789,
  37.87891309649659,
  38.38727753828926,
  38.89959975977785,
  39.41588851594697,
  39.93615253289054,
  40.460400508064545,
  40.98864111053629,
  41.520882981230194,
  42.05713473317016,
  42.597404951718396,
  43.141702194811224,
  43.6900349931913,
  44.24241185063697,
  44.798841244188324,
  45.35933162437017,
  45.92389141541209,
  46.49252901546552,
  47.065252796817916,
  47.64207110610409,
  48.22299226451468,
  48.808024568002054,
  49.3971762874833,
  49.9904556690408,
  50.587870934119984,
  51.189430279724725,
  51.79514187861014,
  52.40501387947288,
  53.0190544071392,
  53.637271562750364,
  54.259673423945976,
  54.88626804504493,
  55.517063457223934,
  56.15206766869424,
  56.79128866487574,
  57.43473440856916,
  58.08241284012621,
  58.734331877617365,
  59.39049941699807,
  60.05092333227251,
  60.715611475655585,
  61.38457167773311,
  62.057811747619894,
  62.7353394731159,
  63.417162620860914,
  64.10328893648692,
  64.79372614476921,
  65.48848194977529,
  66.18756403501224,
  66.89098006357258,
  67.59873767827808,
  68.31084450182222,
  69.02730813691093,
  69.74813616640164,
  70.47333615344107,
  71.20291564160104,
  71.93688215501312,
  72.67524319850172,
  73.41800625771542,
  74.16517879925733,
  74.9167682708136,
  75.67278210128072,
  76.43322770089146,
  77.1981124613393,
  77.96744375590167,
  78.74122893956174,
  79.51947534912904,
  80.30219030335869,
  81.08938110306934,
  81.88105503125999,
  82.67721935322541,
  83.4778813166706,
  84.28304815182372,
  85.09272707154808,
  85.90692527145302,
  86.72564993000343,
  87.54890820862819,
  88.3767072518277,
  89.2090541872801,
  90.04595612594655,
  90.88742016217518,
  91.73345337380438,
  92.58406282226491,
  93.43925555268066,
  94.29903859396902,
  95.16341895893969,
  96.03240364439274,
  96.9059996312159,
  97.78421388448044,
  98.6670533535366,
  99.55452497210776
];
const Ca = class Ca {
  static from(t, e, i) {
    return new Ca(Ri.solveToInt(t, e, i));
  }
  /**
   * @param argb ARGB representation of a color.
   * @return HCT representation of a color in default viewing conditions
   */
  static fromInt(t) {
    return new Ca(t);
  }
  toInt() {
    return this.argb;
  }
  /**
   * A number, in degrees, representing ex. red, orange, yellow, etc.
   * Ranges from 0 <= hue < 360.
   */
  get hue() {
    return this.internalHue;
  }
  /**
   * @param newHue 0 <= newHue < 360; invalid values are corrected.
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set hue(t) {
    this.setInternalState(Ri.solveToInt(t, this.internalChroma, this.internalTone));
  }
  get chroma() {
    return this.internalChroma;
  }
  /**
   * @param newChroma 0 <= newChroma < ?
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set chroma(t) {
    this.setInternalState(Ri.solveToInt(this.internalHue, t, this.internalTone));
  }
  /** Lightness. Ranges from 0 to 100. */
  get tone() {
    return this.internalTone;
  }
  /**
   * @param newTone 0 <= newTone <= 100; invalid valids are corrected.
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set tone(t) {
    this.setInternalState(Ri.solveToInt(this.internalHue, this.internalChroma, t));
  }
  /** Sets a property of the Hct object. */
  setValue(t, e) {
    this[t] = e;
  }
  toString() {
    return `HCT(${this.hue.toFixed(0)}, ${this.chroma.toFixed(0)}, ${this.tone.toFixed(0)})`;
  }
  static isBlue(t) {
    return t >= 250 && t < 270;
  }
  static isYellow(t) {
    return t >= 105 && t < 125;
  }
  static isCyan(t) {
    return t >= 170 && t < 207;
  }
  constructor(t) {
    this.argb = t;
    const e = on.fromInt(t);
    this.internalHue = e.hue, this.internalChroma = e.chroma, this.internalTone = rf(t), this.argb = t;
  }
  setInternalState(t) {
    const e = on.fromInt(t);
    this.internalHue = e.hue, this.internalChroma = e.chroma, this.internalTone = rf(t), this.argb = t;
  }
  /**
   * Translates a color into different [ViewingConditions].
   *
   * Colors change appearance. They look different with lights on versus off,
   * the same color, as in hex code, on white looks different when on black.
   * This is called color relativity, most famously explicated by Josef Albers
   * in Interaction of Color.
   *
   * In color science, color appearance models can account for this and
   * calculate the appearance of a color in different settings. HCT is based on
   * CAM16, a color appearance model, and uses it to make these calculations.
   *
   * See [ViewingConditions.make] for parameters affecting color appearance.
   */
  inViewingConditions(t) {
    const i = on.fromInt(this.toInt()).xyzInViewingConditions(t), r = on.fromXyzInViewingConditions(i[0], i[1], i[2], Ei.make());
    return Ca.from(r.hue, r.chroma, yp(i[1]));
  }
};
a(Ca, "Hct");
let pt = Ca;
const xr = class xr {
  /**
   * Returns a contrast ratio, which ranges from 1 to 21.
   *
   * @param toneA Tone between 0 and 100. Values outside will be clamped.
   * @param toneB Tone between 0 and 100. Values outside will be clamped.
   */
  static ratioOfTones(t, e) {
    return t = $e(0, 100, t), e = $e(0, 100, e), xr.ratioOfYs(Or(t), Or(e));
  }
  static ratioOfYs(t, e) {
    const i = t > e ? t : e, r = i === e ? t : e;
    return (i + 5) / (r + 5);
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns -1 if ratio cannot be achieved with tone parameter.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in -1 being returned.
   * @param ratio Contrast ratio of return value and tone.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static lighter(t, e) {
    if (t < 0 || t > 100)
      return -1;
    const i = Or(t), r = e * (i + 5) - 5, s = xr.ratioOfYs(r, i), o = Math.abs(s - e);
    if (s < e && o > 0.04)
      return -1;
    const c = yp(r) + 0.4;
    return c < 0 || c > 100 ? -1 : c;
  }
  /**
   * Returns a tone <= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns -1 if ratio cannot be achieved with tone parameter.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in -1 being returned.
   * @param ratio Contrast ratio of return value and tone.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static darker(t, e) {
    if (t < 0 || t > 100)
      return -1;
    const i = Or(t), r = (i + 5) / e - 5, s = xr.ratioOfYs(i, r), o = Math.abs(s - e);
    if (s < e && o > 0.04)
      return -1;
    const c = yp(r) - 0.4;
    return c < 0 || c > 100 ? -1 : c;
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns 100 if ratio cannot be achieved with tone parameter.
   *
   * This method is unsafe because the returned value is guaranteed to be in
   * bounds for tone, i.e. between 0 and 100. However, that value may not reach
   * the ratio with tone. For example, there is no color lighter than T100.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in 100 being returned.
   * @param ratio Desired contrast ratio of return value and tone parameter.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static lighterUnsafe(t, e) {
    const i = xr.lighter(t, e);
    return i < 0 ? 100 : i;
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns 100 if ratio cannot be achieved with tone parameter.
   *
   * This method is unsafe because the returned value is guaranteed to be in
   * bounds for tone, i.e. between 0 and 100. However, that value may not reach
   * the [ratio with [tone]. For example, there is no color darker than T0.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in 0 being returned.
   * @param ratio Desired contrast ratio of return value and tone parameter.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static darkerUnsafe(t, e) {
    const i = xr.darker(t, e);
    return i < 0 ? 0 : i;
  }
};
a(xr, "Contrast");
let ne = xr;
const fh = class fh {
  /**
   * Returns true if a color is disliked.
   *
   * @param hct A color to be judged.
   * @return Whether the color is disliked.
   *
   * Disliked is defined as a dark yellow-green that is not neutral.
   */
  static isDisliked(t) {
    const e = Math.round(t.hue) >= 90 && Math.round(t.hue) <= 111, i = Math.round(t.chroma) > 16, r = Math.round(t.tone) < 65;
    return e && i && r;
  }
  /**
   * If a color is disliked, lighten it to make it likable.
   *
   * @param hct A color to be judged.
   * @return A new color if the original color is disliked, or the original
   *   color if it is acceptable.
   */
  static fixIfDisliked(t) {
    return fh.isDisliked(t) ? pt.from(t.hue, t.chroma, 70) : t;
  }
};
a(fh, "DislikeAnalyzer");
let vl = fh;
function qg(n, t, e) {
  if (n.name !== e.name)
    throw new Error(`Attempting to extend color ${n.name} with color ${e.name} of different name for spec version ${t}.`);
  if (n.isBackground !== e.isBackground)
    throw new Error(`Attempting to extend color ${n.name} as a ${n.isBackground ? "background" : "foreground"} with color ${e.name} as a ${e.isBackground ? "background" : "foreground"} for spec version ${t}.`);
}
a(qg, "validateExtendedColor");
function ut(n, t, e) {
  return qg(n, t, e), L.fromPalette({
    name: n.name,
    palette: /* @__PURE__ */ a((i) => i.specVersion === t ? e.palette(i) : n.palette(i), "palette"),
    tone: /* @__PURE__ */ a((i) => i.specVersion === t ? e.tone(i) : n.tone(i), "tone"),
    isBackground: n.isBackground,
    chromaMultiplier: /* @__PURE__ */ a((i) => {
      const r = i.specVersion === t ? e.chromaMultiplier : n.chromaMultiplier;
      return r !== void 0 ? r(i) : 1;
    }, "chromaMultiplier"),
    background: /* @__PURE__ */ a((i) => {
      const r = i.specVersion === t ? e.background : n.background;
      return r !== void 0 ? r(i) : void 0;
    }, "background"),
    secondBackground: /* @__PURE__ */ a((i) => {
      const r = i.specVersion === t ? e.secondBackground : n.secondBackground;
      return r !== void 0 ? r(i) : void 0;
    }, "secondBackground"),
    contrastCurve: /* @__PURE__ */ a((i) => {
      const r = i.specVersion === t ? e.contrastCurve : n.contrastCurve;
      return r !== void 0 ? r(i) : void 0;
    }, "contrastCurve"),
    toneDeltaPair: /* @__PURE__ */ a((i) => {
      const r = i.specVersion === t ? e.toneDeltaPair : n.toneDeltaPair;
      return r !== void 0 ? r(i) : void 0;
    }, "toneDeltaPair")
  });
}
a(ut, "extendSpecVersion");
const qi = class qi {
  /**
   * Create a DynamicColor defined by a TonalPalette and HCT tone.
   *
   * @param args Functions with DynamicScheme as input. Must provide a palette
   *     and tone. May provide a background DynamicColor and ToneDeltaPair.
   */
  static fromPalette(t) {
    return new qi(t.name ?? "", t.palette, t.tone ?? qi.getInitialToneFromBackground(t.background), t.isBackground ?? !1, t.chromaMultiplier, t.background, t.secondBackground, t.contrastCurve, t.toneDeltaPair);
  }
  static getInitialToneFromBackground(t) {
    return t === void 0 ? (e) => 50 : (e) => t(e) ? t(e).getTone(e) : 50;
  }
  /**
   * The base constructor for DynamicColor.
   *
   * _Strongly_ prefer using one of the convenience constructors. This class is
   * arguably too flexible to ensure it can support any scenario. Functional
   * arguments allow  overriding without risks that come with subclasses.
   *
   * For example, the default behavior of adjust tone at max contrast
   * to be at a 7.0 ratio with its background is principled and
   * matches accessibility guidance. That does not mean it's the desired
   * approach for _every_ design system, and every color pairing,
   * always, in every case.
   *
   * @param name The name of the dynamic color. Defaults to empty.
   * @param palette Function that provides a TonalPalette given DynamicScheme. A
   *     TonalPalette is defined by a hue and chroma, so this replaces the need
   *     to specify hue/chroma. By providing a tonal palette, when contrast
   *     adjustments are made, intended chroma can be preserved.
   * @param tone Function that provides a tone, given a DynamicScheme.
   * @param isBackground Whether this dynamic color is a background, with some
   *     other color as the foreground. Defaults to false.
   * @param chromaMultiplier A factor that multiplies the chroma for this color.
   * @param background The background of the dynamic color (as a function of a
   *     `DynamicScheme`), if it exists.
   * @param secondBackground A second background of the dynamic color (as a
   *     function of a `DynamicScheme`), if it exists.
   * @param contrastCurve A `ContrastCurve` object specifying how its contrast
   *     against its background should behave in various contrast levels
   *     options.
   * @param toneDeltaPair A `ToneDeltaPair` object specifying a tone delta
   *     constraint between two colors. One of them must be the color being
   *     constructed.
   */
  constructor(t, e, i, r, s, o, c, l, p) {
    if (this.name = t, this.palette = e, this.tone = i, this.isBackground = r, this.chromaMultiplier = s, this.background = o, this.secondBackground = c, this.contrastCurve = l, this.toneDeltaPair = p, this.hctCache = /* @__PURE__ */ new Map(), !o && c)
      throw new Error(`Color ${t} has secondBackgrounddefined, but background is not defined.`);
    if (!o && l)
      throw new Error(`Color ${t} has contrastCurvedefined, but background is not defined.`);
    if (o && !l)
      throw new Error(`Color ${t} has backgrounddefined, but contrastCurve is not defined.`);
  }
  /**
   * Returns a deep copy of this DynamicColor.
   */
  clone() {
    return qi.fromPalette({
      name: this.name,
      palette: this.palette,
      tone: this.tone,
      isBackground: this.isBackground,
      chromaMultiplier: this.chromaMultiplier,
      background: this.background,
      secondBackground: this.secondBackground,
      contrastCurve: this.contrastCurve,
      toneDeltaPair: this.toneDeltaPair
    });
  }
  /**
   * Clears the cache of HCT values for this color. For testing or debugging
   * purposes.
   */
  clearCache() {
    this.hctCache.clear();
  }
  /**
   * Returns a ARGB integer (i.e. a hex code).
   *
   * @param scheme Defines the conditions of the user interface, for example,
   *     whether or not it is dark mode or light mode, and what the desired
   *     contrast level is.
   */
  getArgb(t) {
    return this.getHct(t).toInt();
  }
  /**
   * Returns a color, expressed in the HCT color space, that this
   * DynamicColor is under the conditions in scheme.
   *
   * @param scheme Defines the conditions of the user interface, for example,
   *     whether or not it is dark mode or light mode, and what the desired
   *     contrast level is.
   */
  getHct(t) {
    const e = this.hctCache.get(t);
    if (e != null)
      return e;
    const i = nf(t.specVersion).getHct(t, this);
    return this.hctCache.size > 4 && this.hctCache.clear(), this.hctCache.set(t, i), i;
  }
  /**
   * Returns a tone, T in the HCT color space, that this DynamicColor is under
   * the conditions in scheme.
   *
   * @param scheme Defines the conditions of the user interface, for example,
   *     whether or not it is dark mode or light mode, and what the desired
   *     contrast level is.
   */
  getTone(t) {
    return nf(t.specVersion).getTone(t, this);
  }
  /**
   * Given a background tone, finds a foreground tone, while ensuring they reach
   * a contrast ratio that is as close to [ratio] as possible.
   *
   * @param bgTone Tone in HCT. Range is 0 to 100, undefined behavior when it
   *     falls outside that range.
   * @param ratio The contrast ratio desired between bgTone and the return
   *     value.
   */
  static foregroundTone(t, e) {
    const i = ne.lighterUnsafe(t, e), r = ne.darkerUnsafe(t, e), s = ne.ratioOfTones(i, t), o = ne.ratioOfTones(r, t);
    if (qi.tonePrefersLightForeground(t)) {
      const l = Math.abs(s - o) < 0.1 && s < e && o < e;
      return s >= e || s >= o || l ? i : r;
    } else
      return o >= e || o >= s ? r : i;
  }
  /**
   * Returns whether [tone] prefers a light foreground.
   *
   * People prefer white foregrounds on ~T60-70. Observed over time, and also
   * by Andrew Somers during research for APCA.
   *
   * T60 used as to create the smallest discontinuity possible when skipping
   * down to T49 in order to ensure light foregrounds.
   * Since `tertiaryContainer` in dark monochrome scheme requires a tone of
   * 60, it should not be adjusted. Therefore, 60 is excluded here.
   */
  static tonePrefersLightForeground(t) {
    return Math.round(t) < 60;
  }
  /**
   * Returns whether [tone] can reach a contrast ratio of 4.5 with a lighter
   * color.
   */
  static toneAllowsLightForeground(t) {
    return Math.round(t) <= 49;
  }
  /**
   * Adjusts a tone such that white has 4.5 contrast, if the tone is
   * reasonably close to supporting it.
   */
  static enableLightForeground(t) {
    return qi.tonePrefersLightForeground(t) && !qi.toneAllowsLightForeground(t) ? 49 : t;
  }
};
a(qi, "DynamicColor");
let L = qi;
const Ky = class Ky {
  getHct(t, e) {
    const i = e.getTone(t);
    return e.palette(t).getHct(i);
  }
  getTone(t, e) {
    const i = t.contrastLevel < 0, r = e.toneDeltaPair ? e.toneDeltaPair(t) : void 0;
    if (r) {
      const s = r.roleA, o = r.roleB, c = r.delta, l = r.polarity, p = r.stayTogether, v = l === "nearer" || l === "lighter" && !t.isDark || l === "darker" && t.isDark, C = v ? s : o, g = v ? o : s, m = e.name === C.name, f = t.isDark ? 1 : -1;
      let $ = C.tone(t), A = g.tone(t);
      if (e.background && C.contrastCurve && g.contrastCurve) {
        const M = e.background(t), R = C.contrastCurve(t), V = g.contrastCurve(t);
        if (M && R && V) {
          const W = M.getTone(t), I = R.get(t.contrastLevel), U = V.get(t.contrastLevel);
          ne.ratioOfTones(W, $) < I && ($ = L.foregroundTone(W, I)), ne.ratioOfTones(W, A) < U && (A = L.foregroundTone(W, U)), i && ($ = L.foregroundTone(W, I), A = L.foregroundTone(W, U));
        }
      }
      return (A - $) * f < c && (A = $e(0, 100, $ + c * f), (A - $) * f >= c || ($ = $e(0, 100, A - c * f))), 50 <= $ && $ < 60 ? f > 0 ? ($ = 60, A = Math.max(A, $ + c * f)) : ($ = 49, A = Math.min(A, $ + c * f)) : 50 <= A && A < 60 && (p ? f > 0 ? ($ = 60, A = Math.max(A, $ + c * f)) : ($ = 49, A = Math.min(A, $ + c * f)) : f > 0 ? A = 60 : A = 49), m ? $ : A;
    } else {
      let s = e.tone(t);
      if (e.background == null || e.background(t) === void 0 || e.contrastCurve == null || e.contrastCurve(t) === void 0)
        return s;
      const o = e.background(t).getTone(t), c = e.contrastCurve(t).get(t.contrastLevel);
      if (ne.ratioOfTones(o, s) >= c || (s = L.foregroundTone(o, c)), i && (s = L.foregroundTone(o, c)), e.isBackground && 50 <= s && s < 60 && (ne.ratioOfTones(49, o) >= c ? s = 49 : s = 60), e.secondBackground == null || e.secondBackground(t) === void 0)
        return s;
      const [l, p] = [e.background, e.secondBackground], [v, C] = [l(t).getTone(t), p(t).getTone(t)], [g, m] = [Math.max(v, C), Math.min(v, C)];
      if (ne.ratioOfTones(g, s) >= c && ne.ratioOfTones(m, s) >= c)
        return s;
      const f = ne.lighter(g, c), $ = ne.darker(m, c), A = [];
      return f !== -1 && A.push(f), $ !== -1 && A.push($), L.tonePrefersLightForeground(v) || L.tonePrefersLightForeground(C) ? f < 0 ? 100 : f : A.length === 1 ? A[0] : $ < 0 ? 0 : $;
    }
  }
};
a(Ky, "ColorCalculationDelegateImpl2021");
let wp = Ky;
const Qy = class Qy {
  getHct(t, e) {
    const i = e.palette(t), r = e.getTone(t), s = i.hue, o = i.chroma * (e.chromaMultiplier ? e.chromaMultiplier(t) : 1);
    return pt.from(s, o, r);
  }
  getTone(t, e) {
    const i = e.toneDeltaPair ? e.toneDeltaPair(t) : void 0;
    if (i) {
      const r = i.roleA, s = i.roleB, o = i.polarity, c = i.constraint, l = o === "darker" || o === "relative_lighter" && t.isDark || o === "relative_darker" && !t.isDark ? -i.delta : i.delta, p = e.name === r.name, v = p ? r : s, C = p ? s : r;
      let g = v.tone(t), m = C.getTone(t);
      const f = l * (p ? 1 : -1);
      if (c === "exact" ? g = $e(0, 100, m + f) : c === "nearer" ? f > 0 ? g = $e(0, 100, $e(m, m + f, g)) : g = $e(0, 100, $e(m + f, m, g)) : c === "farther" && (f > 0 ? g = $e(m + f, 100, g) : g = $e(0, m + f, g)), e.background && e.contrastCurve) {
        const $ = e.background(t), A = e.contrastCurve(t);
        if ($ && A) {
          const M = $.getTone(t), R = A.get(t.contrastLevel);
          g = ne.ratioOfTones(M, g) >= R && t.contrastLevel >= 0 ? g : L.foregroundTone(M, R);
        }
      }
      return e.isBackground && !e.name.endsWith("_fixed_dim") && (g >= 57 ? g = $e(65, 100, g) : g = $e(0, 49, g)), g;
    } else {
      let r = e.tone(t);
      if (e.background == null || e.background(t) === void 0 || e.contrastCurve == null || e.contrastCurve(t) === void 0)
        return r;
      const s = e.background(t).getTone(t), o = e.contrastCurve(t).get(t.contrastLevel);
      if (r = ne.ratioOfTones(s, r) >= o && t.contrastLevel >= 0 ? r : L.foregroundTone(s, o), e.isBackground && !e.name.endsWith("_fixed_dim") && (r >= 57 ? r = $e(65, 100, r) : r = $e(0, 49, r)), e.secondBackground == null || e.secondBackground(t) === void 0)
        return r;
      const [c, l] = [e.background, e.secondBackground], [p, v] = [c(t).getTone(t), l(t).getTone(t)], [C, g] = [Math.max(p, v), Math.min(p, v)];
      if (ne.ratioOfTones(C, r) >= o && ne.ratioOfTones(g, r) >= o)
        return r;
      const m = ne.lighter(C, o), f = ne.darker(g, o), $ = [];
      return m !== -1 && $.push(m), f !== -1 && $.push(f), L.tonePrefersLightForeground(p) || L.tonePrefersLightForeground(v) ? m < 0 ? 100 : m : $.length === 1 ? $[0] : f < 0 ? 0 : f;
    }
  }
};
a(Qy, "ColorCalculationDelegateImpl2025");
let fp = Qy;
const jg = new wp(), Wg = new fp();
function nf(n) {
  return n === "2025" ? Wg : jg;
}
a(nf, "getSpec$1");
const $a = class $a {
  /**
   * @param argb ARGB representation of a color
   * @return Tones matching that color's hue and chroma.
   */
  static fromInt(t) {
    const e = pt.fromInt(t);
    return $a.fromHct(e);
  }
  /**
   * @param hct Hct
   * @return Tones matching that color's hue and chroma.
   */
  static fromHct(t) {
    return new $a(t.hue, t.chroma, t);
  }
  /**
   * @param hue HCT hue
   * @param chroma HCT chroma
   * @return Tones matching hue and chroma.
   */
  static fromHueAndChroma(t, e) {
    const i = new mp(t, e).create();
    return new $a(t, e, i);
  }
  constructor(t, e, i) {
    this.hue = t, this.chroma = e, this.keyColor = i, this.cache = /* @__PURE__ */ new Map();
  }
  /**
   * @param tone HCT tone, measured from 0 to 100.
   * @return ARGB representation of a color with that tone.
   */
  tone(t) {
    let e = this.cache.get(t);
    return e === void 0 && (t == 99 && pt.isYellow(this.hue) ? e = this.averageArgb(this.tone(98), this.tone(100)) : e = pt.from(this.hue, this.chroma, t).toInt(), this.cache.set(t, e)), e;
  }
  /**
   * @param tone HCT tone.
   * @return HCT representation of a color with that tone.
   */
  getHct(t) {
    return pt.fromInt(this.tone(t));
  }
  averageArgb(t, e) {
    const i = t >>> 16 & 255, r = t >>> 8 & 255, s = t & 255, o = e >>> 16 & 255, c = e >>> 8 & 255, l = e & 255, p = Math.round((i + o) / 2), v = Math.round((r + c) / 2), C = Math.round((s + l) / 2);
    return (255 << 24 | (p & 255) << 16 | (v & 255) << 8 | C & 255) >>> 0;
  }
};
a($a, "TonalPalette");
let N = $a;
const Gy = class Gy {
  constructor(t, e) {
    this.hue = t, this.requestedChroma = e, this.chromaCache = /* @__PURE__ */ new Map(), this.maxChromaValue = 200;
  }
  /**
   * Creates a key color from a [hue] and a [chroma].
   * The key color is the first tone, starting from T50, matching the given hue
   * and chroma.
   *
   * @return Key color [Hct]
   */
  create() {
    let r = 0, s = 100;
    for (; r < s; ) {
      const o = Math.floor((r + s) / 2), c = this.maxChroma(o) < this.maxChroma(o + 1);
      if (this.maxChroma(o) >= this.requestedChroma - 0.01)
        if (Math.abs(r - 50) < Math.abs(s - 50))
          s = o;
        else {
          if (r === o)
            return pt.from(this.hue, this.requestedChroma, r);
          r = o;
        }
      else
        c ? r = o + 1 : s = o;
    }
    return pt.from(this.hue, this.requestedChroma, r);
  }
  // Find the maximum chroma for a given tone
  maxChroma(t) {
    if (this.chromaCache.has(t))
      return this.chromaCache.get(t);
    const e = pt.from(this.hue, this.maxChromaValue, t).chroma;
    return this.chromaCache.set(t, e), e;
  }
};
a(Gy, "KeyColor");
let mp = Gy;
const ka = class ka {
  constructor(t) {
    this.input = t, this.hctsByTempCache = [], this.hctsByHueCache = [], this.tempsByHctCache = /* @__PURE__ */ new Map(), this.inputRelativeTemperatureCache = -1, this.complementCache = null;
  }
  get hctsByTemp() {
    if (this.hctsByTempCache.length > 0)
      return this.hctsByTempCache;
    const t = this.hctsByHue.concat([this.input]), e = this.tempsByHct;
    return t.sort((i, r) => e.get(i) - e.get(r)), this.hctsByTempCache = t, t;
  }
  get warmest() {
    return this.hctsByTemp[this.hctsByTemp.length - 1];
  }
  get coldest() {
    return this.hctsByTemp[0];
  }
  /**
   * A set of colors with differing hues, equidistant in temperature.
   *
   * In art, this is usually described as a set of 5 colors on a color wheel
   * divided into 12 sections. This method allows provision of either of those
   * values.
   *
   * Behavior is undefined when [count] or [divisions] is 0.
   * When divisions < count, colors repeat.
   *
   * [count] The number of colors to return, includes the input color.
   * [divisions] The number of divisions on the color wheel.
   */
  analogous(t = 5, e = 12) {
    const i = Math.round(this.input.hue), r = this.hctsByHue[i];
    let s = this.relativeTemperature(r);
    const o = [r];
    let c = 0;
    for (let f = 0; f < 360; f++) {
      const $ = tf(i + f), A = this.hctsByHue[$], M = this.relativeTemperature(A), R = Math.abs(M - s);
      s = M, c += R;
    }
    let l = 1;
    const p = c / e;
    let v = 0;
    for (s = this.relativeTemperature(r); o.length < e; ) {
      const f = tf(i + l), $ = this.hctsByHue[f], A = this.relativeTemperature($), M = Math.abs(A - s);
      v += M;
      const R = o.length * p;
      let V = v >= R, W = 1;
      for (; V && o.length < e; ) {
        o.push($);
        const I = (o.length + W) * p;
        V = v >= I, W++;
      }
      if (s = A, l++, l > 360) {
        for (; o.length < e; )
          o.push($);
        break;
      }
    }
    const C = [this.input], g = Math.floor((t - 1) / 2);
    for (let f = 1; f < g + 1; f++) {
      let $ = 0 - f;
      for (; $ < 0; )
        $ = o.length + $;
      $ >= o.length && ($ = $ % o.length), C.splice(0, 0, o[$]);
    }
    const m = t - g - 1;
    for (let f = 1; f < m + 1; f++) {
      let $ = f;
      for (; $ < 0; )
        $ = o.length + $;
      $ >= o.length && ($ = $ % o.length), C.push(o[$]);
    }
    return C;
  }
  /**
   * A color that complements the input color aesthetically.
   *
   * In art, this is usually described as being across the color wheel.
   * History of this shows intent as a color that is just as cool-warm as the
   * input color is warm-cool.
   */
  get complement() {
    if (this.complementCache != null)
      return this.complementCache;
    const t = this.coldest.hue, e = this.tempsByHct.get(this.coldest), i = this.warmest.hue, s = this.tempsByHct.get(this.warmest) - e, o = ka.isBetween(this.input.hue, t, i), c = o ? i : t, l = o ? t : i, p = 1;
    let v = 1e3, C = this.hctsByHue[Math.round(this.input.hue)];
    const g = 1 - this.inputRelativeTemperature;
    for (let m = 0; m <= 360; m += 1) {
      const f = Ue(c + p * m);
      if (!ka.isBetween(f, c, l))
        continue;
      const $ = this.hctsByHue[Math.round(f)], A = (this.tempsByHct.get($) - e) / s, M = Math.abs(g - A);
      M < v && (v = M, C = $);
    }
    return this.complementCache = C, this.complementCache;
  }
  /**
   * Temperature relative to all colors with the same chroma and tone.
   * Value on a scale from 0 to 1.
   */
  relativeTemperature(t) {
    const e = this.tempsByHct.get(this.warmest) - this.tempsByHct.get(this.coldest), i = this.tempsByHct.get(t) - this.tempsByHct.get(this.coldest);
    return e === 0 ? 0.5 : i / e;
  }
  /** Relative temperature of the input color. See [relativeTemperature]. */
  get inputRelativeTemperature() {
    return this.inputRelativeTemperatureCache >= 0 ? this.inputRelativeTemperatureCache : (this.inputRelativeTemperatureCache = this.relativeTemperature(this.input), this.inputRelativeTemperatureCache);
  }
  /** A Map with keys of HCTs in [hctsByTemp], values of raw temperature. */
  get tempsByHct() {
    if (this.tempsByHctCache.size > 0)
      return this.tempsByHctCache;
    const t = this.hctsByHue.concat([this.input]), e = /* @__PURE__ */ new Map();
    for (const i of t)
      e.set(i, ka.rawTemperature(i));
    return this.tempsByHctCache = e, e;
  }
  /**
   * HCTs for all hues, with the same chroma/tone as the input.
   * Sorted ascending, hue 0 to 360.
   */
  get hctsByHue() {
    if (this.hctsByHueCache.length > 0)
      return this.hctsByHueCache;
    const t = [];
    for (let e = 0; e <= 360; e += 1) {
      const i = pt.from(e, this.input.chroma, this.input.tone);
      t.push(i);
    }
    return this.hctsByHueCache = t, this.hctsByHueCache;
  }
  /** Determines if an angle is between two other angles, rotating clockwise. */
  static isBetween(t, e, i) {
    return e < i ? e <= t && t <= i : e <= t || t <= i;
  }
  /**
   * Value representing cool-warm factor of a color.
   * Values below 0 are considered cool, above, warm.
   *
   * Color science has researched emotion and harmony, which art uses to select
   * colors. Warm-cool is the foundation of analogous and complementary colors.
   * See:
   * - Li-Chen Ou's Chapter 19 in Handbook of Color Psychology (2015).
   * - Josef Albers' Interaction of Color chapters 19 and 21.
   *
   * Implementation of Ou, Woodcock and Wright's algorithm, which uses
   * L*a*b* / LCH color space.
   * Return value has these properties:
   * - Values below 0 are cool, above 0 are warm.
   * - Lower bound: -0.52 - (chroma ^ 1.07 / 20). L*a*b* chroma is infinite.
   *   Assuming max of 130 chroma, -9.66.
   * - Upper bound: -0.52 + (chroma ^ 1.07 / 20). L*a*b* chroma is infinite.
   *   Assuming max of 130 chroma, 8.61.
   */
  static rawTemperature(t) {
    const e = Hg(t.toInt()), i = Ue(Math.atan2(e[2], e[1]) * 180 / Math.PI), r = Math.sqrt(e[1] * e[1] + e[2] * e[2]);
    return -0.5 + 0.02 * Math.pow(r, 1.07) * Math.cos(Ue(i - 50) * Math.PI / 180);
  }
};
a(ka, "TemperatureCache");
let Qd = ka;
const Zy = class Zy {
  /**
   * Creates a `ContrastCurve` object.
   *
   * @param low Value for contrast level -1.0
   * @param normal Value for contrast level 0.0
   * @param medium Value for contrast level 0.5
   * @param high Value for contrast level 1.0
   */
  constructor(t, e, i, r) {
    this.low = t, this.normal = e, this.medium = i, this.high = r;
  }
  /**
   * Returns the value at a given contrast level.
   *
   * @param contrastLevel The contrast level. 0.0 is the default (normal); -1.0
   *     is the lowest; 1.0 is the highest.
   * @return The value. For contrast ratios, a number between 1.0 and 21.0.
   */
  get(t) {
    return t <= -1 ? this.low : t < 0 ? hl(this.low, this.normal, (t - -1) / 1) : t < 0.5 ? hl(this.normal, this.medium, (t - 0) / 0.5) : t < 1 ? hl(this.medium, this.high, (t - 0.5) / 0.5) : this.high;
  }
};
a(Zy, "ContrastCurve");
let et = Zy;
const Yy = class Yy {
  /**
   * Documents a constraint in tone distance between two DynamicColors.
   *
   * The polarity is an adjective that describes "A", compared to "B".
   *
   * For instance, ToneDeltaPair(A, B, 15, 'darker', 'exact') states that
   * A's tone should be exactly 15 darker than B's.
   *
   * 'relative_darker' and 'relative_lighter' describes the tone adjustment
   * relative to the surface color trend (white in light mode; black in dark
   * mode). For instance, ToneDeltaPair(A, B, 10, 'relative_lighter',
   * 'farther') states that A should be at least 10 lighter than B in light
   * mode, and at least 10 darker than B in dark mode.
   *
   * @param roleA The first role in a pair.
   * @param roleB The second role in a pair.
   * @param delta Required difference between tones. Absolute value, negative
   * values have undefined behavior.
   * @param polarity The relative relation between tones of roleA and roleB,
   * as described above.
   * @param constraint How to fulfill the tone delta pair constraint.
   * @param stayTogether Whether these two roles should stay on the same side
   * of the "awkward zone" (T50-59). This is necessary for certain cases where
   * one role has two backgrounds.
   */
  constructor(t, e, i, r, s, o) {
    this.roleA = t, this.roleB = e, this.delta = i, this.polarity = r, this.stayTogether = s, this.constraint = o, this.constraint = o ?? "exact";
  }
};
a(Yy, "ToneDeltaPair");
let Pt = Yy;
var E;
(function(n) {
  n[n.MONOCHROME = 0] = "MONOCHROME", n[n.NEUTRAL = 1] = "NEUTRAL", n[n.TONAL_SPOT = 2] = "TONAL_SPOT", n[n.VIBRANT = 3] = "VIBRANT", n[n.EXPRESSIVE = 4] = "EXPRESSIVE", n[n.FIDELITY = 5] = "FIDELITY", n[n.CONTENT = 6] = "CONTENT", n[n.RAINBOW = 7] = "RAINBOW", n[n.FRUIT_SALAD = 8] = "FRUIT_SALAD";
})(E || (E = {}));
function la(n) {
  return n.variant === E.FIDELITY || n.variant === E.CONTENT;
}
a(la, "isFidelity");
function Ft(n) {
  return n.variant === E.MONOCHROME;
}
a(Ft, "isMonochrome");
function Kg(n, t, e, i) {
  let r = e, s = pt.from(n, t, e);
  if (s.chroma < t) {
    let o = s.chroma;
    for (; s.chroma < t; ) {
      r += i ? -1 : 1;
      const c = pt.from(n, t, r);
      if (o > c.chroma || Math.abs(c.chroma - t) < 0.4)
        break;
      const l = Math.abs(c.chroma - t), p = Math.abs(s.chroma - t);
      l < p && (s = c), o = Math.max(o, c.chroma);
    }
  }
  return r;
}
a(Kg, "findDesiredChromaByTone");
const Xy = class Xy {
  ////////////////////////////////////////////////////////////////
  // Main Palettes                                              //
  ////////////////////////////////////////////////////////////////
  primaryPaletteKeyColor() {
    return L.fromPalette({
      name: "primary_palette_key_color",
      palette: /* @__PURE__ */ a((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.primaryPalette.keyColor.tone, "tone")
    });
  }
  secondaryPaletteKeyColor() {
    return L.fromPalette({
      name: "secondary_palette_key_color",
      palette: /* @__PURE__ */ a((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.secondaryPalette.keyColor.tone, "tone")
    });
  }
  tertiaryPaletteKeyColor() {
    return L.fromPalette({
      name: "tertiary_palette_key_color",
      palette: /* @__PURE__ */ a((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.tertiaryPalette.keyColor.tone, "tone")
    });
  }
  neutralPaletteKeyColor() {
    return L.fromPalette({
      name: "neutral_palette_key_color",
      palette: /* @__PURE__ */ a((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.neutralPalette.keyColor.tone, "tone")
    });
  }
  neutralVariantPaletteKeyColor() {
    return L.fromPalette({
      name: "neutral_variant_palette_key_color",
      palette: /* @__PURE__ */ a((t) => t.neutralVariantPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.neutralVariantPalette.keyColor.tone, "tone")
    });
  }
  errorPaletteKeyColor() {
    return L.fromPalette({
      name: "error_palette_key_color",
      palette: /* @__PURE__ */ a((t) => t.errorPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.errorPalette.keyColor.tone, "tone")
    });
  }
  ////////////////////////////////////////////////////////////////
  // Surfaces [S]                                               //
  ////////////////////////////////////////////////////////////////
  background() {
    return L.fromPalette({
      name: "background",
      palette: /* @__PURE__ */ a((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? 6 : 98, "tone"),
      isBackground: !0
    });
  }
  onBackground() {
    return L.fromPalette({
      name: "on_background",
      palette: /* @__PURE__ */ a((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? 90 : 10, "tone"),
      background: /* @__PURE__ */ a((t) => this.background(), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(3, 3, 4.5, 7), "contrastCurve")
    });
  }
  surface() {
    return L.fromPalette({
      name: "surface",
      palette: /* @__PURE__ */ a((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? 6 : 98, "tone"),
      isBackground: !0
    });
  }
  surfaceDim() {
    return L.fromPalette({
      name: "surface_dim",
      palette: /* @__PURE__ */ a((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? 6 : new et(87, 87, 80, 75).get(t.contrastLevel), "tone"),
      isBackground: !0
    });
  }
  surfaceBright() {
    return L.fromPalette({
      name: "surface_bright",
      palette: /* @__PURE__ */ a((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? new et(24, 24, 29, 34).get(t.contrastLevel) : 98, "tone"),
      isBackground: !0
    });
  }
  surfaceContainerLowest() {
    return L.fromPalette({
      name: "surface_container_lowest",
      palette: /* @__PURE__ */ a((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? new et(4, 4, 2, 0).get(t.contrastLevel) : 100, "tone"),
      isBackground: !0
    });
  }
  surfaceContainerLow() {
    return L.fromPalette({
      name: "surface_container_low",
      palette: /* @__PURE__ */ a((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? new et(10, 10, 11, 12).get(t.contrastLevel) : new et(96, 96, 96, 95).get(t.contrastLevel), "tone"),
      isBackground: !0
    });
  }
  surfaceContainer() {
    return L.fromPalette({
      name: "surface_container",
      palette: /* @__PURE__ */ a((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? new et(12, 12, 16, 20).get(t.contrastLevel) : new et(94, 94, 92, 90).get(t.contrastLevel), "tone"),
      isBackground: !0
    });
  }
  surfaceContainerHigh() {
    return L.fromPalette({
      name: "surface_container_high",
      palette: /* @__PURE__ */ a((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? new et(17, 17, 21, 25).get(t.contrastLevel) : new et(92, 92, 88, 85).get(t.contrastLevel), "tone"),
      isBackground: !0
    });
  }
  surfaceContainerHighest() {
    return L.fromPalette({
      name: "surface_container_highest",
      palette: /* @__PURE__ */ a((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? new et(22, 22, 26, 30).get(t.contrastLevel) : new et(90, 90, 84, 80).get(t.contrastLevel), "tone"),
      isBackground: !0
    });
  }
  onSurface() {
    return L.fromPalette({
      name: "on_surface",
      palette: /* @__PURE__ */ a((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? 90 : 10, "tone"),
      background: /* @__PURE__ */ a((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(4.5, 7, 11, 21), "contrastCurve")
    });
  }
  surfaceVariant() {
    return L.fromPalette({
      name: "surface_variant",
      palette: /* @__PURE__ */ a((t) => t.neutralVariantPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? 30 : 90, "tone"),
      isBackground: !0
    });
  }
  onSurfaceVariant() {
    return L.fromPalette({
      name: "on_surface_variant",
      palette: /* @__PURE__ */ a((t) => t.neutralVariantPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? 80 : 30, "tone"),
      background: /* @__PURE__ */ a((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(3, 4.5, 7, 11), "contrastCurve")
    });
  }
  inverseSurface() {
    return L.fromPalette({
      name: "inverse_surface",
      palette: /* @__PURE__ */ a((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? 90 : 20, "tone"),
      isBackground: !0
    });
  }
  inverseOnSurface() {
    return L.fromPalette({
      name: "inverse_on_surface",
      palette: /* @__PURE__ */ a((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? 20 : 95, "tone"),
      background: /* @__PURE__ */ a((t) => this.inverseSurface(), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(4.5, 7, 11, 21), "contrastCurve")
    });
  }
  outline() {
    return L.fromPalette({
      name: "outline",
      palette: /* @__PURE__ */ a((t) => t.neutralVariantPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? 60 : 50, "tone"),
      background: /* @__PURE__ */ a((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(1.5, 3, 4.5, 7), "contrastCurve")
    });
  }
  outlineVariant() {
    return L.fromPalette({
      name: "outline_variant",
      palette: /* @__PURE__ */ a((t) => t.neutralVariantPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? 30 : 80, "tone"),
      background: /* @__PURE__ */ a((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(1, 1, 3, 4.5), "contrastCurve")
    });
  }
  shadow() {
    return L.fromPalette({
      name: "shadow",
      palette: /* @__PURE__ */ a((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => 0, "tone")
    });
  }
  scrim() {
    return L.fromPalette({
      name: "scrim",
      palette: /* @__PURE__ */ a((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => 0, "tone")
    });
  }
  surfaceTint() {
    return L.fromPalette({
      name: "surface_tint",
      palette: /* @__PURE__ */ a((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? 80 : 40, "tone"),
      isBackground: !0
    });
  }
  ////////////////////////////////////////////////////////////////
  // Primary [P].                                               //
  ////////////////////////////////////////////////////////////////
  primary() {
    return L.fromPalette({
      name: "primary",
      palette: /* @__PURE__ */ a((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => Ft(t) ? t.isDark ? 100 : 0 : t.isDark ? 80 : 40, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(3, 4.5, 7, 7), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((t) => new Pt(this.primaryContainer(), this.primary(), 10, "nearer", !1), "toneDeltaPair")
    });
  }
  primaryDim() {
  }
  onPrimary() {
    return L.fromPalette({
      name: "on_primary",
      palette: /* @__PURE__ */ a((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => Ft(t) ? t.isDark ? 10 : 90 : t.isDark ? 20 : 100, "tone"),
      background: /* @__PURE__ */ a((t) => this.primary(), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(4.5, 7, 11, 21), "contrastCurve")
    });
  }
  primaryContainer() {
    return L.fromPalette({
      name: "primary_container",
      palette: /* @__PURE__ */ a((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => la(t) ? t.sourceColorHct.tone : Ft(t) ? t.isDark ? 85 : 25 : t.isDark ? 30 : 90, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((t) => new Pt(this.primaryContainer(), this.primary(), 10, "nearer", !1), "toneDeltaPair")
    });
  }
  onPrimaryContainer() {
    return L.fromPalette({
      name: "on_primary_container",
      palette: /* @__PURE__ */ a((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => la(t) ? L.foregroundTone(this.primaryContainer().tone(t), 4.5) : Ft(t) ? t.isDark ? 0 : 100 : t.isDark ? 90 : 30, "tone"),
      background: /* @__PURE__ */ a((t) => this.primaryContainer(), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(3, 4.5, 7, 11), "contrastCurve")
    });
  }
  inversePrimary() {
    return L.fromPalette({
      name: "inverse_primary",
      palette: /* @__PURE__ */ a((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? 40 : 80, "tone"),
      background: /* @__PURE__ */ a((t) => this.inverseSurface(), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(3, 4.5, 7, 7), "contrastCurve")
    });
  }
  /////////////////////////////////////////////////////////////////
  // Secondary [Q].                                              //
  /////////////////////////////////////////////////////////////////
  secondary() {
    return L.fromPalette({
      name: "secondary",
      palette: /* @__PURE__ */ a((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? 80 : 40, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(3, 4.5, 7, 7), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((t) => new Pt(this.secondaryContainer(), this.secondary(), 10, "nearer", !1), "toneDeltaPair")
    });
  }
  secondaryDim() {
  }
  onSecondary() {
    return L.fromPalette({
      name: "on_secondary",
      palette: /* @__PURE__ */ a((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => Ft(t) ? t.isDark ? 10 : 100 : t.isDark ? 20 : 100, "tone"),
      background: /* @__PURE__ */ a((t) => this.secondary(), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(4.5, 7, 11, 21), "contrastCurve")
    });
  }
  secondaryContainer() {
    return L.fromPalette({
      name: "secondary_container",
      palette: /* @__PURE__ */ a((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => {
        const e = t.isDark ? 30 : 90;
        return Ft(t) ? t.isDark ? 30 : 85 : la(t) ? Kg(t.secondaryPalette.hue, t.secondaryPalette.chroma, e, !t.isDark) : e;
      }, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((t) => new Pt(this.secondaryContainer(), this.secondary(), 10, "nearer", !1), "toneDeltaPair")
    });
  }
  onSecondaryContainer() {
    return L.fromPalette({
      name: "on_secondary_container",
      palette: /* @__PURE__ */ a((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => Ft(t) ? t.isDark ? 90 : 10 : la(t) ? L.foregroundTone(this.secondaryContainer().tone(t), 4.5) : t.isDark ? 90 : 30, "tone"),
      background: /* @__PURE__ */ a((t) => this.secondaryContainer(), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(3, 4.5, 7, 11), "contrastCurve")
    });
  }
  /////////////////////////////////////////////////////////////////
  // Tertiary [T].                                               //
  /////////////////////////////////////////////////////////////////
  tertiary() {
    return L.fromPalette({
      name: "tertiary",
      palette: /* @__PURE__ */ a((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => Ft(t) ? t.isDark ? 90 : 25 : t.isDark ? 80 : 40, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(3, 4.5, 7, 7), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((t) => new Pt(this.tertiaryContainer(), this.tertiary(), 10, "nearer", !1), "toneDeltaPair")
    });
  }
  tertiaryDim() {
  }
  onTertiary() {
    return L.fromPalette({
      name: "on_tertiary",
      palette: /* @__PURE__ */ a((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => Ft(t) ? t.isDark ? 10 : 90 : t.isDark ? 20 : 100, "tone"),
      background: /* @__PURE__ */ a((t) => this.tertiary(), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(4.5, 7, 11, 21), "contrastCurve")
    });
  }
  tertiaryContainer() {
    return L.fromPalette({
      name: "tertiary_container",
      palette: /* @__PURE__ */ a((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => {
        if (Ft(t))
          return t.isDark ? 60 : 49;
        if (!la(t))
          return t.isDark ? 30 : 90;
        const e = t.tertiaryPalette.getHct(t.sourceColorHct.tone);
        return vl.fixIfDisliked(e).tone;
      }, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((t) => new Pt(this.tertiaryContainer(), this.tertiary(), 10, "nearer", !1), "toneDeltaPair")
    });
  }
  onTertiaryContainer() {
    return L.fromPalette({
      name: "on_tertiary_container",
      palette: /* @__PURE__ */ a((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => Ft(t) ? t.isDark ? 0 : 100 : la(t) ? L.foregroundTone(this.tertiaryContainer().tone(t), 4.5) : t.isDark ? 90 : 30, "tone"),
      background: /* @__PURE__ */ a((t) => this.tertiaryContainer(), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(3, 4.5, 7, 11), "contrastCurve")
    });
  }
  //////////////////////////////////////////////////////////////////
  // Error [E].                                                   //
  //////////////////////////////////////////////////////////////////
  error() {
    return L.fromPalette({
      name: "error",
      palette: /* @__PURE__ */ a((t) => t.errorPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? 80 : 40, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(3, 4.5, 7, 7), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((t) => new Pt(this.errorContainer(), this.error(), 10, "nearer", !1), "toneDeltaPair")
    });
  }
  errorDim() {
  }
  onError() {
    return L.fromPalette({
      name: "on_error",
      palette: /* @__PURE__ */ a((t) => t.errorPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? 20 : 100, "tone"),
      background: /* @__PURE__ */ a((t) => this.error(), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(4.5, 7, 11, 21), "contrastCurve")
    });
  }
  errorContainer() {
    return L.fromPalette({
      name: "error_container",
      palette: /* @__PURE__ */ a((t) => t.errorPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.isDark ? 30 : 90, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((t) => new Pt(this.errorContainer(), this.error(), 10, "nearer", !1), "toneDeltaPair")
    });
  }
  onErrorContainer() {
    return L.fromPalette({
      name: "on_error_container",
      palette: /* @__PURE__ */ a((t) => t.errorPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => Ft(t) ? t.isDark ? 90 : 10 : t.isDark ? 90 : 30, "tone"),
      background: /* @__PURE__ */ a((t) => this.errorContainer(), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(3, 4.5, 7, 11), "contrastCurve")
    });
  }
  //////////////////////////////////////////////////////////////////
  // Primary Fixed [PF]                                           //
  //////////////////////////////////////////////////////////////////
  primaryFixed() {
    return L.fromPalette({
      name: "primary_fixed",
      palette: /* @__PURE__ */ a((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => Ft(t) ? 40 : 90, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((t) => new Pt(this.primaryFixed(), this.primaryFixedDim(), 10, "lighter", !0), "toneDeltaPair")
    });
  }
  primaryFixedDim() {
    return L.fromPalette({
      name: "primary_fixed_dim",
      palette: /* @__PURE__ */ a((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => Ft(t) ? 30 : 80, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((t) => new Pt(this.primaryFixed(), this.primaryFixedDim(), 10, "lighter", !0), "toneDeltaPair")
    });
  }
  onPrimaryFixed() {
    return L.fromPalette({
      name: "on_primary_fixed",
      palette: /* @__PURE__ */ a((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => Ft(t) ? 100 : 10, "tone"),
      background: /* @__PURE__ */ a((t) => this.primaryFixedDim(), "background"),
      secondBackground: /* @__PURE__ */ a((t) => this.primaryFixed(), "secondBackground"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(4.5, 7, 11, 21), "contrastCurve")
    });
  }
  onPrimaryFixedVariant() {
    return L.fromPalette({
      name: "on_primary_fixed_variant",
      palette: /* @__PURE__ */ a((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => Ft(t) ? 90 : 30, "tone"),
      background: /* @__PURE__ */ a((t) => this.primaryFixedDim(), "background"),
      secondBackground: /* @__PURE__ */ a((t) => this.primaryFixed(), "secondBackground"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(3, 4.5, 7, 11), "contrastCurve")
    });
  }
  ///////////////////////////////////////////////////////////////////
  // Secondary Fixed [QF]                                          //
  ///////////////////////////////////////////////////////////////////
  secondaryFixed() {
    return L.fromPalette({
      name: "secondary_fixed",
      palette: /* @__PURE__ */ a((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => Ft(t) ? 80 : 90, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((t) => new Pt(this.secondaryFixed(), this.secondaryFixedDim(), 10, "lighter", !0), "toneDeltaPair")
    });
  }
  secondaryFixedDim() {
    return L.fromPalette({
      name: "secondary_fixed_dim",
      palette: /* @__PURE__ */ a((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => Ft(t) ? 70 : 80, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((t) => new Pt(this.secondaryFixed(), this.secondaryFixedDim(), 10, "lighter", !0), "toneDeltaPair")
    });
  }
  onSecondaryFixed() {
    return L.fromPalette({
      name: "on_secondary_fixed",
      palette: /* @__PURE__ */ a((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => 10, "tone"),
      background: /* @__PURE__ */ a((t) => this.secondaryFixedDim(), "background"),
      secondBackground: /* @__PURE__ */ a((t) => this.secondaryFixed(), "secondBackground"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(4.5, 7, 11, 21), "contrastCurve")
    });
  }
  onSecondaryFixedVariant() {
    return L.fromPalette({
      name: "on_secondary_fixed_variant",
      palette: /* @__PURE__ */ a((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => Ft(t) ? 25 : 30, "tone"),
      background: /* @__PURE__ */ a((t) => this.secondaryFixedDim(), "background"),
      secondBackground: /* @__PURE__ */ a((t) => this.secondaryFixed(), "secondBackground"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(3, 4.5, 7, 11), "contrastCurve")
    });
  }
  /////////////////////////////////////////////////////////////////
  // Tertiary Fixed [TF]                                         //
  /////////////////////////////////////////////////////////////////
  tertiaryFixed() {
    return L.fromPalette({
      name: "tertiary_fixed",
      palette: /* @__PURE__ */ a((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => Ft(t) ? 40 : 90, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((t) => new Pt(this.tertiaryFixed(), this.tertiaryFixedDim(), 10, "lighter", !0), "toneDeltaPair")
    });
  }
  tertiaryFixedDim() {
    return L.fromPalette({
      name: "tertiary_fixed_dim",
      palette: /* @__PURE__ */ a((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => Ft(t) ? 30 : 80, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((t) => new Pt(this.tertiaryFixed(), this.tertiaryFixedDim(), 10, "lighter", !0), "toneDeltaPair")
    });
  }
  onTertiaryFixed() {
    return L.fromPalette({
      name: "on_tertiary_fixed",
      palette: /* @__PURE__ */ a((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => Ft(t) ? 100 : 10, "tone"),
      background: /* @__PURE__ */ a((t) => this.tertiaryFixedDim(), "background"),
      secondBackground: /* @__PURE__ */ a((t) => this.tertiaryFixed(), "secondBackground"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(4.5, 7, 11, 21), "contrastCurve")
    });
  }
  onTertiaryFixedVariant() {
    return L.fromPalette({
      name: "on_tertiary_fixed_variant",
      palette: /* @__PURE__ */ a((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => Ft(t) ? 90 : 30, "tone"),
      background: /* @__PURE__ */ a((t) => this.tertiaryFixedDim(), "background"),
      secondBackground: /* @__PURE__ */ a((t) => this.tertiaryFixed(), "secondBackground"),
      contrastCurve: /* @__PURE__ */ a((t) => new et(3, 4.5, 7, 11), "contrastCurve")
    });
  }
  ////////////////////////////////////////////////////////////////
  // Other                                                      //
  ////////////////////////////////////////////////////////////////
  highestSurface(t) {
    return t.isDark ? this.surfaceBright() : this.surfaceDim();
  }
};
a(Xy, "ColorSpecDelegateImpl2021");
let vp = Xy;
function mt(n, t = 0, e = 100, i = 1) {
  let r = Pm(n.hue, n.chroma * i, 100, !0);
  return $e(t, e, r);
}
a(mt, "tMaxC");
function vr(n, t = 0, e = 100) {
  let i = Pm(n.hue, n.chroma, 0, !1);
  return $e(t, e, i);
}
a(vr, "tMinC");
function Pm(n, t, e, i) {
  let r = e, s = pt.from(n, t, r);
  for (; s.chroma < t && !(e < 0 || e > 100); ) {
    e += i ? -1 : 1;
    const o = pt.from(n, t, e);
    s.chroma < o.chroma && (s = o, r = e);
  }
  return r;
}
a(Pm, "findBestToneForChroma");
function at(n) {
  return n === 1.5 ? new et(1.5, 1.5, 3, 5.5) : n === 3 ? new et(3, 3, 4.5, 7) : n === 4.5 ? new et(4.5, 4.5, 7, 11) : n === 6 ? new et(6, 6, 7, 11) : n === 7 ? new et(7, 7, 11, 21) : n === 9 ? new et(9, 9, 11, 21) : n === 11 ? new et(11, 11, 21, 21) : n === 21 ? new et(21, 21, 21, 21) : new et(n, n, 7, 21);
}
a(at, "getCurve");
const Jy = class Jy extends vp {
  ////////////////////////////////////////////////////////////////
  // Surfaces [S]                                               //
  ////////////////////////////////////////////////////////////////
  surface() {
    const t = L.fromPalette({
      name: "surface",
      palette: /* @__PURE__ */ a((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => (super.surface().tone(e), e.platform === "phone" ? e.isDark ? 4 : pt.isYellow(e.neutralPalette.hue) ? 99 : e.variant === E.VIBRANT ? 97 : 98 : 0), "tone"),
      isBackground: !0
    });
    return ut(super.surface(), "2025", t);
  }
  surfaceDim() {
    const t = L.fromPalette({
      name: "surface_dim",
      palette: /* @__PURE__ */ a((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => e.isDark ? 4 : pt.isYellow(e.neutralPalette.hue) ? 90 : e.variant === E.VIBRANT ? 85 : 87, "tone"),
      isBackground: !0,
      chromaMultiplier: /* @__PURE__ */ a((e) => {
        if (!e.isDark) {
          if (e.variant === E.NEUTRAL)
            return 2.5;
          if (e.variant === E.TONAL_SPOT)
            return 1.7;
          if (e.variant === E.EXPRESSIVE)
            return pt.isYellow(e.neutralPalette.hue) ? 2.7 : 1.75;
          if (e.variant === E.VIBRANT)
            return 1.36;
        }
        return 1;
      }, "chromaMultiplier")
    });
    return ut(super.surfaceDim(), "2025", t);
  }
  surfaceBright() {
    const t = L.fromPalette({
      name: "surface_bright",
      palette: /* @__PURE__ */ a((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => e.isDark ? 18 : pt.isYellow(e.neutralPalette.hue) ? 99 : e.variant === E.VIBRANT ? 97 : 98, "tone"),
      isBackground: !0,
      chromaMultiplier: /* @__PURE__ */ a((e) => {
        if (e.isDark) {
          if (e.variant === E.NEUTRAL)
            return 2.5;
          if (e.variant === E.TONAL_SPOT)
            return 1.7;
          if (e.variant === E.EXPRESSIVE)
            return pt.isYellow(e.neutralPalette.hue) ? 2.7 : 1.75;
          if (e.variant === E.VIBRANT)
            return 1.36;
        }
        return 1;
      }, "chromaMultiplier")
    });
    return ut(super.surfaceBright(), "2025", t);
  }
  surfaceContainerLowest() {
    const t = L.fromPalette({
      name: "surface_container_lowest",
      palette: /* @__PURE__ */ a((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => e.isDark ? 0 : 100, "tone"),
      isBackground: !0
    });
    return ut(super.surfaceContainerLowest(), "2025", t);
  }
  surfaceContainerLow() {
    const t = L.fromPalette({
      name: "surface_container_low",
      palette: /* @__PURE__ */ a((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => e.platform === "phone" ? e.isDark ? 6 : pt.isYellow(e.neutralPalette.hue) ? 98 : e.variant === E.VIBRANT ? 95 : 96 : 15, "tone"),
      isBackground: !0,
      chromaMultiplier: /* @__PURE__ */ a((e) => {
        if (e.platform === "phone") {
          if (e.variant === E.NEUTRAL)
            return 1.3;
          if (e.variant === E.TONAL_SPOT)
            return 1.25;
          if (e.variant === E.EXPRESSIVE)
            return pt.isYellow(e.neutralPalette.hue) ? 1.3 : 1.15;
          if (e.variant === E.VIBRANT)
            return 1.08;
        }
        return 1;
      }, "chromaMultiplier")
    });
    return ut(super.surfaceContainerLow(), "2025", t);
  }
  surfaceContainer() {
    const t = L.fromPalette({
      name: "surface_container",
      palette: /* @__PURE__ */ a((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => e.platform === "phone" ? e.isDark ? 9 : pt.isYellow(e.neutralPalette.hue) ? 96 : e.variant === E.VIBRANT ? 92 : 94 : 20, "tone"),
      isBackground: !0,
      chromaMultiplier: /* @__PURE__ */ a((e) => {
        if (e.platform === "phone") {
          if (e.variant === E.NEUTRAL)
            return 1.6;
          if (e.variant === E.TONAL_SPOT)
            return 1.4;
          if (e.variant === E.EXPRESSIVE)
            return pt.isYellow(e.neutralPalette.hue) ? 1.6 : 1.3;
          if (e.variant === E.VIBRANT)
            return 1.15;
        }
        return 1;
      }, "chromaMultiplier")
    });
    return ut(super.surfaceContainer(), "2025", t);
  }
  surfaceContainerHigh() {
    const t = L.fromPalette({
      name: "surface_container_high",
      palette: /* @__PURE__ */ a((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => e.platform === "phone" ? e.isDark ? 12 : pt.isYellow(e.neutralPalette.hue) ? 94 : e.variant === E.VIBRANT ? 90 : 92 : 25, "tone"),
      isBackground: !0,
      chromaMultiplier: /* @__PURE__ */ a((e) => {
        if (e.platform === "phone") {
          if (e.variant === E.NEUTRAL)
            return 1.9;
          if (e.variant === E.TONAL_SPOT)
            return 1.5;
          if (e.variant === E.EXPRESSIVE)
            return pt.isYellow(e.neutralPalette.hue) ? 1.95 : 1.45;
          if (e.variant === E.VIBRANT)
            return 1.22;
        }
        return 1;
      }, "chromaMultiplier")
    });
    return ut(super.surfaceContainerHigh(), "2025", t);
  }
  surfaceContainerHighest() {
    const t = L.fromPalette({
      name: "surface_container_highest",
      palette: /* @__PURE__ */ a((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => e.isDark ? 15 : pt.isYellow(e.neutralPalette.hue) ? 92 : e.variant === E.VIBRANT ? 88 : 90, "tone"),
      isBackground: !0,
      chromaMultiplier: /* @__PURE__ */ a((e) => e.variant === E.NEUTRAL ? 2.2 : e.variant === E.TONAL_SPOT ? 1.7 : e.variant === E.EXPRESSIVE ? pt.isYellow(e.neutralPalette.hue) ? 2.3 : 1.6 : e.variant === E.VIBRANT ? 1.29 : 1, "chromaMultiplier")
    });
    return ut(super.surfaceContainerHighest(), "2025", t);
  }
  onSurface() {
    const t = L.fromPalette({
      name: "on_surface",
      palette: /* @__PURE__ */ a((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => e.variant === E.VIBRANT ? mt(e.neutralPalette, 0, 100, 1.1) : L.getInitialToneFromBackground((i) => i.platform === "phone" ? this.highestSurface(i) : this.surfaceContainerHigh())(e), "tone"),
      chromaMultiplier: /* @__PURE__ */ a((e) => {
        if (e.platform === "phone") {
          if (e.variant === E.NEUTRAL)
            return 2.2;
          if (e.variant === E.TONAL_SPOT)
            return 1.7;
          if (e.variant === E.EXPRESSIVE)
            return pt.isYellow(e.neutralPalette.hue) ? e.isDark ? 3 : 2.3 : 1.6;
        }
        return 1;
      }, "chromaMultiplier"),
      background: /* @__PURE__ */ a((e) => e.platform === "phone" ? this.highestSurface(e) : this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.isDark && e.platform === "phone" ? at(11) : at(9), "contrastCurve")
    });
    return ut(super.onSurface(), "2025", t);
  }
  onSurfaceVariant() {
    const t = L.fromPalette({
      name: "on_surface_variant",
      palette: /* @__PURE__ */ a((e) => e.neutralPalette, "palette"),
      chromaMultiplier: /* @__PURE__ */ a((e) => {
        if (e.platform === "phone") {
          if (e.variant === E.NEUTRAL)
            return 2.2;
          if (e.variant === E.TONAL_SPOT)
            return 1.7;
          if (e.variant === E.EXPRESSIVE)
            return pt.isYellow(e.neutralPalette.hue) ? e.isDark ? 3 : 2.3 : 1.6;
        }
        return 1;
      }, "chromaMultiplier"),
      background: /* @__PURE__ */ a((e) => e.platform === "phone" ? this.highestSurface(e) : this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" ? e.isDark ? at(6) : at(4.5) : at(7), "contrastCurve")
    });
    return ut(super.onSurfaceVariant(), "2025", t);
  }
  outline() {
    const t = L.fromPalette({
      name: "outline",
      palette: /* @__PURE__ */ a((e) => e.neutralPalette, "palette"),
      chromaMultiplier: /* @__PURE__ */ a((e) => {
        if (e.platform === "phone") {
          if (e.variant === E.NEUTRAL)
            return 2.2;
          if (e.variant === E.TONAL_SPOT)
            return 1.7;
          if (e.variant === E.EXPRESSIVE)
            return pt.isYellow(e.neutralPalette.hue) ? e.isDark ? 3 : 2.3 : 1.6;
        }
        return 1;
      }, "chromaMultiplier"),
      background: /* @__PURE__ */ a((e) => e.platform === "phone" ? this.highestSurface(e) : this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" ? at(3) : at(4.5), "contrastCurve")
    });
    return ut(super.outline(), "2025", t);
  }
  outlineVariant() {
    const t = L.fromPalette({
      name: "outline_variant",
      palette: /* @__PURE__ */ a((e) => e.neutralPalette, "palette"),
      chromaMultiplier: /* @__PURE__ */ a((e) => {
        if (e.platform === "phone") {
          if (e.variant === E.NEUTRAL)
            return 2.2;
          if (e.variant === E.TONAL_SPOT)
            return 1.7;
          if (e.variant === E.EXPRESSIVE)
            return pt.isYellow(e.neutralPalette.hue) ? e.isDark ? 3 : 2.3 : 1.6;
        }
        return 1;
      }, "chromaMultiplier"),
      background: /* @__PURE__ */ a((e) => e.platform === "phone" ? this.highestSurface(e) : this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" ? at(1.5) : at(3), "contrastCurve")
    });
    return ut(super.outlineVariant(), "2025", t);
  }
  inverseSurface() {
    const t = L.fromPalette({
      name: "inverse_surface",
      palette: /* @__PURE__ */ a((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => e.isDark ? 98 : 4, "tone"),
      isBackground: !0
    });
    return ut(super.inverseSurface(), "2025", t);
  }
  inverseOnSurface() {
    const t = L.fromPalette({
      name: "inverse_on_surface",
      palette: /* @__PURE__ */ a((e) => e.neutralPalette, "palette"),
      background: /* @__PURE__ */ a((e) => this.inverseSurface(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => at(7), "contrastCurve")
    });
    return ut(super.inverseOnSurface(), "2025", t);
  }
  ////////////////////////////////////////////////////////////////
  // Primaries [P]                                              //
  ////////////////////////////////////////////////////////////////
  primary() {
    const t = L.fromPalette({
      name: "primary",
      palette: /* @__PURE__ */ a((e) => e.primaryPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => e.variant === E.NEUTRAL ? e.platform === "phone" ? e.isDark ? 80 : 40 : 90 : e.variant === E.TONAL_SPOT ? e.platform === "phone" ? e.isDark ? 80 : mt(e.primaryPalette) : mt(e.primaryPalette, 0, 90) : e.variant === E.EXPRESSIVE ? e.platform === "phone" ? mt(e.primaryPalette, 0, pt.isYellow(e.primaryPalette.hue) ? 25 : pt.isCyan(e.primaryPalette.hue) ? 88 : 98) : mt(e.primaryPalette) : e.platform === "phone" ? mt(e.primaryPalette, 0, pt.isCyan(e.primaryPalette.hue) ? 88 : 98) : mt(e.primaryPalette), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((e) => e.platform === "phone" ? this.highestSurface(e) : this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" ? at(4.5) : at(7), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((e) => e.platform === "phone" ? new Pt(this.primaryContainer(), this.primary(), 5, "relative_lighter", !0, "farther") : void 0, "toneDeltaPair")
    });
    return ut(super.primary(), "2025", t);
  }
  primaryDim() {
    return L.fromPalette({
      name: "primary_dim",
      palette: /* @__PURE__ */ a((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.variant === E.NEUTRAL ? 85 : t.variant === E.TONAL_SPOT ? mt(t.primaryPalette, 0, 90) : mt(t.primaryPalette), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((t) => this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => at(4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((t) => new Pt(this.primaryDim(), this.primary(), 5, "darker", !0, "farther"), "toneDeltaPair")
    });
  }
  onPrimary() {
    const t = L.fromPalette({
      name: "on_primary",
      palette: /* @__PURE__ */ a((e) => e.primaryPalette, "palette"),
      background: /* @__PURE__ */ a((e) => e.platform === "phone" ? this.primary() : this.primaryDim(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" ? at(6) : at(7), "contrastCurve")
    });
    return ut(super.onPrimary(), "2025", t);
  }
  primaryContainer() {
    const t = L.fromPalette({
      name: "primary_container",
      palette: /* @__PURE__ */ a((e) => e.primaryPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => e.platform === "watch" ? 30 : e.variant === E.NEUTRAL ? e.isDark ? 30 : 90 : e.variant === E.TONAL_SPOT ? e.isDark ? vr(e.primaryPalette, 35, 93) : mt(e.primaryPalette, 0, 90) : e.variant === E.EXPRESSIVE ? e.isDark ? mt(e.primaryPalette, 30, 93) : mt(e.primaryPalette, 78, pt.isCyan(e.primaryPalette.hue) ? 88 : 90) : e.isDark ? vr(e.primaryPalette, 66, 93) : mt(e.primaryPalette, 66, pt.isCyan(e.primaryPalette.hue) ? 88 : 93), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((e) => e.platform === "phone" ? this.highestSurface(e) : void 0, "background"),
      toneDeltaPair: /* @__PURE__ */ a((e) => e.platform === "phone" ? void 0 : new Pt(this.primaryContainer(), this.primaryDim(), 10, "darker", !0, "farther"), "toneDeltaPair"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" && e.contrastLevel > 0 ? at(1.5) : void 0, "contrastCurve")
    });
    return ut(super.primaryContainer(), "2025", t);
  }
  onPrimaryContainer() {
    const t = L.fromPalette({
      name: "on_primary_container",
      palette: /* @__PURE__ */ a((e) => e.primaryPalette, "palette"),
      background: /* @__PURE__ */ a((e) => this.primaryContainer(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" ? at(6) : at(7), "contrastCurve")
    });
    return ut(super.onPrimaryContainer(), "2025", t);
  }
  primaryFixed() {
    const t = L.fromPalette({
      name: "primary_fixed",
      palette: /* @__PURE__ */ a((e) => e.primaryPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => {
        let i = Object.assign({}, e, { isDark: !1, contrastLevel: 0 });
        return this.primaryContainer().getTone(i);
      }, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((e) => e.platform === "phone" ? this.highestSurface(e) : void 0, "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" && e.contrastLevel > 0 ? at(1.5) : void 0, "contrastCurve")
    });
    return ut(super.primaryFixed(), "2025", t);
  }
  primaryFixedDim() {
    const t = L.fromPalette({
      name: "primary_fixed_dim",
      palette: /* @__PURE__ */ a((e) => e.primaryPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => this.primaryFixed().getTone(e), "tone"),
      isBackground: !0,
      toneDeltaPair: /* @__PURE__ */ a((e) => new Pt(this.primaryFixedDim(), this.primaryFixed(), 5, "darker", !0, "exact"), "toneDeltaPair")
    });
    return ut(super.primaryFixedDim(), "2025", t);
  }
  onPrimaryFixed() {
    const t = L.fromPalette({
      name: "on_primary_fixed",
      palette: /* @__PURE__ */ a((e) => e.primaryPalette, "palette"),
      background: /* @__PURE__ */ a((e) => this.primaryFixedDim(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => at(7), "contrastCurve")
    });
    return ut(super.onPrimaryFixed(), "2025", t);
  }
  onPrimaryFixedVariant() {
    const t = L.fromPalette({
      name: "on_primary_fixed_variant",
      palette: /* @__PURE__ */ a((e) => e.primaryPalette, "palette"),
      background: /* @__PURE__ */ a((e) => this.primaryFixedDim(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => at(4.5), "contrastCurve")
    });
    return ut(super.onPrimaryFixedVariant(), "2025", t);
  }
  inversePrimary() {
    const t = L.fromPalette({
      name: "inverse_primary",
      palette: /* @__PURE__ */ a((e) => e.primaryPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => mt(e.primaryPalette), "tone"),
      background: /* @__PURE__ */ a((e) => this.inverseSurface(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" ? at(6) : at(7), "contrastCurve")
    });
    return ut(super.inversePrimary(), "2025", t);
  }
  ////////////////////////////////////////////////////////////////
  // Secondaries [Q]                                            //
  ////////////////////////////////////////////////////////////////
  secondary() {
    const t = L.fromPalette({
      name: "secondary",
      palette: /* @__PURE__ */ a((e) => e.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => e.platform === "watch" ? e.variant === E.NEUTRAL ? 90 : mt(e.secondaryPalette, 0, 90) : e.variant === E.NEUTRAL ? e.isDark ? vr(e.secondaryPalette, 0, 98) : mt(e.secondaryPalette) : e.variant === E.VIBRANT ? mt(e.secondaryPalette, 0, e.isDark ? 90 : 98) : e.isDark ? 80 : mt(e.secondaryPalette), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((e) => e.platform === "phone" ? this.highestSurface(e) : this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" ? at(4.5) : at(7), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((e) => e.platform === "phone" ? new Pt(this.secondaryContainer(), this.secondary(), 5, "relative_lighter", !0, "farther") : void 0, "toneDeltaPair")
    });
    return ut(super.secondary(), "2025", t);
  }
  secondaryDim() {
    return L.fromPalette({
      name: "secondary_dim",
      palette: /* @__PURE__ */ a((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.variant === E.NEUTRAL ? 85 : mt(t.secondaryPalette, 0, 90), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((t) => this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => at(4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((t) => new Pt(this.secondaryDim(), this.secondary(), 5, "darker", !0, "farther"), "toneDeltaPair")
    });
  }
  onSecondary() {
    const t = L.fromPalette({
      name: "on_secondary",
      palette: /* @__PURE__ */ a((e) => e.secondaryPalette, "palette"),
      background: /* @__PURE__ */ a((e) => e.platform === "phone" ? this.secondary() : this.secondaryDim(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" ? at(6) : at(7), "contrastCurve")
    });
    return ut(super.onSecondary(), "2025", t);
  }
  secondaryContainer() {
    const t = L.fromPalette({
      name: "secondary_container",
      palette: /* @__PURE__ */ a((e) => e.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => e.platform === "watch" ? 30 : e.variant === E.VIBRANT ? e.isDark ? vr(e.secondaryPalette, 30, 40) : mt(e.secondaryPalette, 84, 90) : e.variant === E.EXPRESSIVE ? e.isDark ? 15 : mt(e.secondaryPalette, 90, 95) : e.isDark ? 25 : 90, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((e) => e.platform === "phone" ? this.highestSurface(e) : void 0, "background"),
      toneDeltaPair: /* @__PURE__ */ a((e) => e.platform === "watch" ? new Pt(this.secondaryContainer(), this.secondaryDim(), 10, "darker", !0, "farther") : void 0, "toneDeltaPair"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" && e.contrastLevel > 0 ? at(1.5) : void 0, "contrastCurve")
    });
    return ut(super.secondaryContainer(), "2025", t);
  }
  onSecondaryContainer() {
    const t = L.fromPalette({
      name: "on_secondary_container",
      palette: /* @__PURE__ */ a((e) => e.secondaryPalette, "palette"),
      background: /* @__PURE__ */ a((e) => this.secondaryContainer(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" ? at(6) : at(7), "contrastCurve")
    });
    return ut(super.onSecondaryContainer(), "2025", t);
  }
  secondaryFixed() {
    const t = L.fromPalette({
      name: "secondary_fixed",
      palette: /* @__PURE__ */ a((e) => e.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => {
        let i = Object.assign({}, e, { isDark: !1, contrastLevel: 0 });
        return this.secondaryContainer().getTone(i);
      }, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((e) => e.platform === "phone" ? this.highestSurface(e) : void 0, "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" && e.contrastLevel > 0 ? at(1.5) : void 0, "contrastCurve")
    });
    return ut(super.secondaryFixed(), "2025", t);
  }
  secondaryFixedDim() {
    const t = L.fromPalette({
      name: "secondary_fixed_dim",
      palette: /* @__PURE__ */ a((e) => e.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => this.secondaryFixed().getTone(e), "tone"),
      isBackground: !0,
      toneDeltaPair: /* @__PURE__ */ a((e) => new Pt(this.secondaryFixedDim(), this.secondaryFixed(), 5, "darker", !0, "exact"), "toneDeltaPair")
    });
    return ut(super.secondaryFixedDim(), "2025", t);
  }
  onSecondaryFixed() {
    const t = L.fromPalette({
      name: "on_secondary_fixed",
      palette: /* @__PURE__ */ a((e) => e.secondaryPalette, "palette"),
      background: /* @__PURE__ */ a((e) => this.secondaryFixedDim(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => at(7), "contrastCurve")
    });
    return ut(super.onSecondaryFixed(), "2025", t);
  }
  onSecondaryFixedVariant() {
    const t = L.fromPalette({
      name: "on_secondary_fixed_variant",
      palette: /* @__PURE__ */ a((e) => e.secondaryPalette, "palette"),
      background: /* @__PURE__ */ a((e) => this.secondaryFixedDim(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => at(4.5), "contrastCurve")
    });
    return ut(super.onSecondaryFixedVariant(), "2025", t);
  }
  ////////////////////////////////////////////////////////////////
  // Tertiaries [T]                                             //
  ////////////////////////////////////////////////////////////////
  tertiary() {
    const t = L.fromPalette({
      name: "tertiary",
      palette: /* @__PURE__ */ a((e) => e.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => e.platform === "watch" ? e.variant === E.TONAL_SPOT ? mt(e.tertiaryPalette, 0, 90) : mt(e.tertiaryPalette) : e.variant === E.EXPRESSIVE || e.variant === E.VIBRANT ? mt(e.tertiaryPalette, 0, pt.isCyan(e.tertiaryPalette.hue) ? 88 : e.isDark ? 98 : 100) : e.isDark ? mt(e.tertiaryPalette, 0, 98) : mt(e.tertiaryPalette), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((e) => e.platform === "phone" ? this.highestSurface(e) : this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" ? at(4.5) : at(7), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((e) => e.platform === "phone" ? new Pt(this.tertiaryContainer(), this.tertiary(), 5, "relative_lighter", !0, "farther") : void 0, "toneDeltaPair")
    });
    return ut(super.tertiary(), "2025", t);
  }
  tertiaryDim() {
    return L.fromPalette({
      name: "tertiary_dim",
      palette: /* @__PURE__ */ a((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => t.variant === E.TONAL_SPOT ? mt(t.tertiaryPalette, 0, 90) : mt(t.tertiaryPalette), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((t) => this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => at(4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((t) => new Pt(this.tertiaryDim(), this.tertiary(), 5, "darker", !0, "farther"), "toneDeltaPair")
    });
  }
  onTertiary() {
    const t = L.fromPalette({
      name: "on_tertiary",
      palette: /* @__PURE__ */ a((e) => e.tertiaryPalette, "palette"),
      background: /* @__PURE__ */ a((e) => e.platform === "phone" ? this.tertiary() : this.tertiaryDim(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" ? at(6) : at(7), "contrastCurve")
    });
    return ut(super.onTertiary(), "2025", t);
  }
  tertiaryContainer() {
    const t = L.fromPalette({
      name: "tertiary_container",
      palette: /* @__PURE__ */ a((e) => e.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => e.platform === "watch" ? e.variant === E.TONAL_SPOT ? mt(e.tertiaryPalette, 0, 90) : mt(e.tertiaryPalette) : e.variant === E.NEUTRAL ? e.isDark ? mt(e.tertiaryPalette, 0, 93) : mt(e.tertiaryPalette, 0, 96) : e.variant === E.TONAL_SPOT ? mt(e.tertiaryPalette, 0, e.isDark ? 93 : 100) : e.variant === E.EXPRESSIVE ? mt(e.tertiaryPalette, 75, pt.isCyan(e.tertiaryPalette.hue) ? 88 : e.isDark ? 93 : 100) : e.isDark ? mt(e.tertiaryPalette, 0, 93) : mt(e.tertiaryPalette, 72, 100), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((e) => e.platform === "phone" ? this.highestSurface(e) : void 0, "background"),
      toneDeltaPair: /* @__PURE__ */ a((e) => e.platform === "watch" ? new Pt(this.tertiaryContainer(), this.tertiaryDim(), 10, "darker", !0, "farther") : void 0, "toneDeltaPair"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" && e.contrastLevel > 0 ? at(1.5) : void 0, "contrastCurve")
    });
    return ut(super.tertiaryContainer(), "2025", t);
  }
  onTertiaryContainer() {
    const t = L.fromPalette({
      name: "on_tertiary_container",
      palette: /* @__PURE__ */ a((e) => e.tertiaryPalette, "palette"),
      background: /* @__PURE__ */ a((e) => this.tertiaryContainer(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" ? at(6) : at(7), "contrastCurve")
    });
    return ut(super.onTertiaryContainer(), "2025", t);
  }
  tertiaryFixed() {
    const t = L.fromPalette({
      name: "tertiary_fixed",
      palette: /* @__PURE__ */ a((e) => e.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => {
        let i = Object.assign({}, e, { isDark: !1, contrastLevel: 0 });
        return this.tertiaryContainer().getTone(i);
      }, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((e) => e.platform === "phone" ? this.highestSurface(e) : void 0, "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" && e.contrastLevel > 0 ? at(1.5) : void 0, "contrastCurve")
    });
    return ut(super.tertiaryFixed(), "2025", t);
  }
  tertiaryFixedDim() {
    const t = L.fromPalette({
      name: "tertiary_fixed_dim",
      palette: /* @__PURE__ */ a((e) => e.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => this.tertiaryFixed().getTone(e), "tone"),
      isBackground: !0,
      toneDeltaPair: /* @__PURE__ */ a((e) => new Pt(this.tertiaryFixedDim(), this.tertiaryFixed(), 5, "darker", !0, "exact"), "toneDeltaPair")
    });
    return ut(super.tertiaryFixedDim(), "2025", t);
  }
  onTertiaryFixed() {
    const t = L.fromPalette({
      name: "on_tertiary_fixed",
      palette: /* @__PURE__ */ a((e) => e.tertiaryPalette, "palette"),
      background: /* @__PURE__ */ a((e) => this.tertiaryFixedDim(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => at(7), "contrastCurve")
    });
    return ut(super.onTertiaryFixed(), "2025", t);
  }
  onTertiaryFixedVariant() {
    const t = L.fromPalette({
      name: "on_tertiary_fixed_variant",
      palette: /* @__PURE__ */ a((e) => e.tertiaryPalette, "palette"),
      background: /* @__PURE__ */ a((e) => this.tertiaryFixedDim(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => at(4.5), "contrastCurve")
    });
    return ut(super.onTertiaryFixedVariant(), "2025", t);
  }
  ////////////////////////////////////////////////////////////////
  // Errors [E]                                                 //
  ////////////////////////////////////////////////////////////////
  error() {
    const t = L.fromPalette({
      name: "error",
      palette: /* @__PURE__ */ a((e) => e.errorPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => e.platform === "phone" ? e.isDark ? vr(e.errorPalette, 0, 98) : mt(e.errorPalette) : vr(e.errorPalette), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((e) => e.platform === "phone" ? this.highestSurface(e) : this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" ? at(4.5) : at(7), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((e) => e.platform === "phone" ? new Pt(this.errorContainer(), this.error(), 5, "relative_lighter", !0, "farther") : void 0, "toneDeltaPair")
    });
    return ut(super.error(), "2025", t);
  }
  errorDim() {
    return L.fromPalette({
      name: "error_dim",
      palette: /* @__PURE__ */ a((t) => t.errorPalette, "palette"),
      tone: /* @__PURE__ */ a((t) => vr(t.errorPalette), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((t) => this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ a((t) => at(4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ a((t) => new Pt(this.errorDim(), this.error(), 5, "darker", !0, "farther"), "toneDeltaPair")
    });
  }
  onError() {
    const t = L.fromPalette({
      name: "on_error",
      palette: /* @__PURE__ */ a((e) => e.errorPalette, "palette"),
      background: /* @__PURE__ */ a((e) => e.platform === "phone" ? this.error() : this.errorDim(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" ? at(6) : at(7), "contrastCurve")
    });
    return ut(super.onError(), "2025", t);
  }
  errorContainer() {
    const t = L.fromPalette({
      name: "error_container",
      palette: /* @__PURE__ */ a((e) => e.errorPalette, "palette"),
      tone: /* @__PURE__ */ a((e) => e.platform === "watch" ? 30 : e.isDark ? vr(e.errorPalette, 30, 93) : mt(e.errorPalette, 0, 90), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ a((e) => e.platform === "phone" ? this.highestSurface(e) : void 0, "background"),
      toneDeltaPair: /* @__PURE__ */ a((e) => e.platform === "watch" ? new Pt(this.errorContainer(), this.errorDim(), 10, "darker", !0, "farther") : void 0, "toneDeltaPair"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" && e.contrastLevel > 0 ? at(1.5) : void 0, "contrastCurve")
    });
    return ut(super.errorContainer(), "2025", t);
  }
  onErrorContainer() {
    const t = L.fromPalette({
      name: "on_error_container",
      palette: /* @__PURE__ */ a((e) => e.errorPalette, "palette"),
      background: /* @__PURE__ */ a((e) => this.errorContainer(), "background"),
      contrastCurve: /* @__PURE__ */ a((e) => e.platform === "phone" ? at(4.5) : at(7), "contrastCurve")
    });
    return ut(super.onErrorContainer(), "2025", t);
  }
  /////////////////////////////////////////////////////////////////
  // Remapped Colors                                             //
  /////////////////////////////////////////////////////////////////
  surfaceVariant() {
    const t = Object.assign(this.surfaceContainerHighest().clone(), { name: "surface_variant" });
    return ut(super.surfaceVariant(), "2025", t);
  }
  surfaceTint() {
    const t = Object.assign(this.primary().clone(), { name: "surface_tint" });
    return ut(super.surfaceTint(), "2025", t);
  }
  background() {
    const t = Object.assign(this.surface().clone(), { name: "background" });
    return ut(super.background(), "2025", t);
  }
  onBackground() {
    const t = Object.assign(this.onSurface().clone(), {
      name: "on_background",
      tone: /* @__PURE__ */ a((e) => e.platform === "watch" ? 100 : this.onSurface().getTone(e), "tone")
    });
    return ut(super.onBackground(), "2025", t);
  }
};
a(Jy, "ColorSpecDelegateImpl2025");
let gp = Jy;
const G = class G {
  constructor() {
    this.allColors = [
      this.background(),
      this.onBackground(),
      this.surface(),
      this.surfaceDim(),
      this.surfaceBright(),
      this.surfaceContainerLowest(),
      this.surfaceContainerLow(),
      this.surfaceContainer(),
      this.surfaceContainerHigh(),
      this.surfaceContainerHighest(),
      this.onSurface(),
      this.onSurfaceVariant(),
      this.outline(),
      this.outlineVariant(),
      this.inverseSurface(),
      this.inverseOnSurface(),
      this.primary(),
      this.primaryDim(),
      this.onPrimary(),
      this.primaryContainer(),
      this.onPrimaryContainer(),
      this.primaryFixed(),
      this.primaryFixedDim(),
      this.onPrimaryFixed(),
      this.onPrimaryFixedVariant(),
      this.inversePrimary(),
      this.secondary(),
      this.secondaryDim(),
      this.onSecondary(),
      this.secondaryContainer(),
      this.onSecondaryContainer(),
      this.secondaryFixed(),
      this.secondaryFixedDim(),
      this.onSecondaryFixed(),
      this.onSecondaryFixedVariant(),
      this.tertiary(),
      this.tertiaryDim(),
      this.onTertiary(),
      this.tertiaryContainer(),
      this.onTertiaryContainer(),
      this.tertiaryFixed(),
      this.tertiaryFixedDim(),
      this.onTertiaryFixed(),
      this.onTertiaryFixedVariant(),
      this.error(),
      this.errorDim(),
      this.onError(),
      this.errorContainer(),
      this.onErrorContainer()
    ].filter((t) => t !== void 0);
  }
  highestSurface(t) {
    return G.colorSpec.highestSurface(t);
  }
  ////////////////////////////////////////////////////////////////
  // Main Palettes                                              //
  ////////////////////////////////////////////////////////////////
  primaryPaletteKeyColor() {
    return G.colorSpec.primaryPaletteKeyColor();
  }
  secondaryPaletteKeyColor() {
    return G.colorSpec.secondaryPaletteKeyColor();
  }
  tertiaryPaletteKeyColor() {
    return G.colorSpec.tertiaryPaletteKeyColor();
  }
  neutralPaletteKeyColor() {
    return G.colorSpec.neutralPaletteKeyColor();
  }
  neutralVariantPaletteKeyColor() {
    return G.colorSpec.neutralVariantPaletteKeyColor();
  }
  errorPaletteKeyColor() {
    return G.colorSpec.errorPaletteKeyColor();
  }
  ////////////////////////////////////////////////////////////////
  // Surfaces [S]                                               //
  ////////////////////////////////////////////////////////////////
  background() {
    return G.colorSpec.background();
  }
  onBackground() {
    return G.colorSpec.onBackground();
  }
  surface() {
    return G.colorSpec.surface();
  }
  surfaceDim() {
    return G.colorSpec.surfaceDim();
  }
  surfaceBright() {
    return G.colorSpec.surfaceBright();
  }
  surfaceContainerLowest() {
    return G.colorSpec.surfaceContainerLowest();
  }
  surfaceContainerLow() {
    return G.colorSpec.surfaceContainerLow();
  }
  surfaceContainer() {
    return G.colorSpec.surfaceContainer();
  }
  surfaceContainerHigh() {
    return G.colorSpec.surfaceContainerHigh();
  }
  surfaceContainerHighest() {
    return G.colorSpec.surfaceContainerHighest();
  }
  onSurface() {
    return G.colorSpec.onSurface();
  }
  surfaceVariant() {
    return G.colorSpec.surfaceVariant();
  }
  onSurfaceVariant() {
    return G.colorSpec.onSurfaceVariant();
  }
  outline() {
    return G.colorSpec.outline();
  }
  outlineVariant() {
    return G.colorSpec.outlineVariant();
  }
  inverseSurface() {
    return G.colorSpec.inverseSurface();
  }
  inverseOnSurface() {
    return G.colorSpec.inverseOnSurface();
  }
  shadow() {
    return G.colorSpec.shadow();
  }
  scrim() {
    return G.colorSpec.scrim();
  }
  surfaceTint() {
    return G.colorSpec.surfaceTint();
  }
  ////////////////////////////////////////////////////////////////
  // Primaries [P]                                              //
  ////////////////////////////////////////////////////////////////
  primary() {
    return G.colorSpec.primary();
  }
  primaryDim() {
    return G.colorSpec.primaryDim();
  }
  onPrimary() {
    return G.colorSpec.onPrimary();
  }
  primaryContainer() {
    return G.colorSpec.primaryContainer();
  }
  onPrimaryContainer() {
    return G.colorSpec.onPrimaryContainer();
  }
  inversePrimary() {
    return G.colorSpec.inversePrimary();
  }
  /////////////////////////////////////////////////////////////////
  // Primary Fixed [PF]                                          //
  /////////////////////////////////////////////////////////////////
  primaryFixed() {
    return G.colorSpec.primaryFixed();
  }
  primaryFixedDim() {
    return G.colorSpec.primaryFixedDim();
  }
  onPrimaryFixed() {
    return G.colorSpec.onPrimaryFixed();
  }
  onPrimaryFixedVariant() {
    return G.colorSpec.onPrimaryFixedVariant();
  }
  ////////////////////////////////////////////////////////////////
  // Secondaries [Q]                                            //
  ////////////////////////////////////////////////////////////////
  secondary() {
    return G.colorSpec.secondary();
  }
  secondaryDim() {
    return G.colorSpec.secondaryDim();
  }
  onSecondary() {
    return G.colorSpec.onSecondary();
  }
  secondaryContainer() {
    return G.colorSpec.secondaryContainer();
  }
  onSecondaryContainer() {
    return G.colorSpec.onSecondaryContainer();
  }
  /////////////////////////////////////////////////////////////////
  // Secondary Fixed [QF]                                        //
  /////////////////////////////////////////////////////////////////
  secondaryFixed() {
    return G.colorSpec.secondaryFixed();
  }
  secondaryFixedDim() {
    return G.colorSpec.secondaryFixedDim();
  }
  onSecondaryFixed() {
    return G.colorSpec.onSecondaryFixed();
  }
  onSecondaryFixedVariant() {
    return G.colorSpec.onSecondaryFixedVariant();
  }
  ////////////////////////////////////////////////////////////////
  // Tertiaries [T]                                             //
  ////////////////////////////////////////////////////////////////
  tertiary() {
    return G.colorSpec.tertiary();
  }
  tertiaryDim() {
    return G.colorSpec.tertiaryDim();
  }
  onTertiary() {
    return G.colorSpec.onTertiary();
  }
  tertiaryContainer() {
    return G.colorSpec.tertiaryContainer();
  }
  onTertiaryContainer() {
    return G.colorSpec.onTertiaryContainer();
  }
  /////////////////////////////////////////////////////////////////
  // Tertiary Fixed [TF]                                         //
  /////////////////////////////////////////////////////////////////
  tertiaryFixed() {
    return G.colorSpec.tertiaryFixed();
  }
  tertiaryFixedDim() {
    return G.colorSpec.tertiaryFixedDim();
  }
  onTertiaryFixed() {
    return G.colorSpec.onTertiaryFixed();
  }
  onTertiaryFixedVariant() {
    return G.colorSpec.onTertiaryFixedVariant();
  }
  ////////////////////////////////////////////////////////////////
  // Errors [E]                                                 //
  ////////////////////////////////////////////////////////////////
  error() {
    return G.colorSpec.error();
  }
  errorDim() {
    return G.colorSpec.errorDim();
  }
  onError() {
    return G.colorSpec.onError();
  }
  errorContainer() {
    return G.colorSpec.errorContainer();
  }
  onErrorContainer() {
    return G.colorSpec.onErrorContainer();
  }
  // Static variables are deprecated. Use the instance methods to get correct
  // specs based on request.
  /** @deprecated Use highestSurface() instead. */
  static highestSurface(t) {
    return G.colorSpec.highestSurface(t);
  }
};
a(G, "MaterialDynamicColors");
let F = G;
F.contentAccentToneDelta = 15;
F.colorSpec = new gp();
F.primaryPaletteKeyColor = F.colorSpec.primaryPaletteKeyColor();
F.secondaryPaletteKeyColor = F.colorSpec.secondaryPaletteKeyColor();
F.tertiaryPaletteKeyColor = F.colorSpec.tertiaryPaletteKeyColor();
F.neutralPaletteKeyColor = F.colorSpec.neutralPaletteKeyColor();
F.neutralVariantPaletteKeyColor = F.colorSpec.neutralVariantPaletteKeyColor();
F.background = F.colorSpec.background();
F.onBackground = F.colorSpec.onBackground();
F.surface = F.colorSpec.surface();
F.surfaceDim = F.colorSpec.surfaceDim();
F.surfaceBright = F.colorSpec.surfaceBright();
F.surfaceContainerLowest = F.colorSpec.surfaceContainerLowest();
F.surfaceContainerLow = F.colorSpec.surfaceContainerLow();
F.surfaceContainer = F.colorSpec.surfaceContainer();
F.surfaceContainerHigh = F.colorSpec.surfaceContainerHigh();
F.surfaceContainerHighest = F.colorSpec.surfaceContainerHighest();
F.onSurface = F.colorSpec.onSurface();
F.surfaceVariant = F.colorSpec.surfaceVariant();
F.onSurfaceVariant = F.colorSpec.onSurfaceVariant();
F.inverseSurface = F.colorSpec.inverseSurface();
F.inverseOnSurface = F.colorSpec.inverseOnSurface();
F.outline = F.colorSpec.outline();
F.outlineVariant = F.colorSpec.outlineVariant();
F.shadow = F.colorSpec.shadow();
F.scrim = F.colorSpec.scrim();
F.surfaceTint = F.colorSpec.surfaceTint();
F.primary = F.colorSpec.primary();
F.onPrimary = F.colorSpec.onPrimary();
F.primaryContainer = F.colorSpec.primaryContainer();
F.onPrimaryContainer = F.colorSpec.onPrimaryContainer();
F.inversePrimary = F.colorSpec.inversePrimary();
F.secondary = F.colorSpec.secondary();
F.onSecondary = F.colorSpec.onSecondary();
F.secondaryContainer = F.colorSpec.secondaryContainer();
F.onSecondaryContainer = F.colorSpec.onSecondaryContainer();
F.tertiary = F.colorSpec.tertiary();
F.onTertiary = F.colorSpec.onTertiary();
F.tertiaryContainer = F.colorSpec.tertiaryContainer();
F.onTertiaryContainer = F.colorSpec.onTertiaryContainer();
F.error = F.colorSpec.error();
F.onError = F.colorSpec.onError();
F.errorContainer = F.colorSpec.errorContainer();
F.onErrorContainer = F.colorSpec.onErrorContainer();
F.primaryFixed = F.colorSpec.primaryFixed();
F.primaryFixedDim = F.colorSpec.primaryFixedDim();
F.onPrimaryFixed = F.colorSpec.onPrimaryFixed();
F.onPrimaryFixedVariant = F.colorSpec.onPrimaryFixedVariant();
F.secondaryFixed = F.colorSpec.secondaryFixed();
F.secondaryFixedDim = F.colorSpec.secondaryFixedDim();
F.onSecondaryFixed = F.colorSpec.onSecondaryFixed();
F.onSecondaryFixedVariant = F.colorSpec.onSecondaryFixedVariant();
F.tertiaryFixed = F.colorSpec.tertiaryFixed();
F.tertiaryFixedDim = F.colorSpec.tertiaryFixedDim();
F.onTertiaryFixed = F.colorSpec.onTertiaryFixed();
F.onTertiaryFixedVariant = F.colorSpec.onTertiaryFixedVariant();
const wl = class wl {
  static maybeFallbackSpecVersion(t, e) {
    switch (e) {
      case E.EXPRESSIVE:
      case E.VIBRANT:
      case E.TONAL_SPOT:
      case E.NEUTRAL:
        return t;
      default:
        return "2021";
    }
  }
  constructor(t) {
    this.sourceColorArgb = t.sourceColorHct.toInt(), this.variant = t.variant, this.contrastLevel = t.contrastLevel, this.isDark = t.isDark, this.platform = t.platform ?? "phone", this.specVersion = wl.maybeFallbackSpecVersion(t.specVersion ?? "2021", this.variant), this.sourceColorHct = t.sourceColorHct, this.primaryPalette = t.primaryPalette ?? da(this.specVersion).getPrimaryPalette(this.variant, t.sourceColorHct, this.isDark, this.platform, this.contrastLevel), this.secondaryPalette = t.secondaryPalette ?? da(this.specVersion).getSecondaryPalette(this.variant, t.sourceColorHct, this.isDark, this.platform, this.contrastLevel), this.tertiaryPalette = t.tertiaryPalette ?? da(this.specVersion).getTertiaryPalette(this.variant, t.sourceColorHct, this.isDark, this.platform, this.contrastLevel), this.neutralPalette = t.neutralPalette ?? da(this.specVersion).getNeutralPalette(this.variant, t.sourceColorHct, this.isDark, this.platform, this.contrastLevel), this.neutralVariantPalette = t.neutralVariantPalette ?? da(this.specVersion).getNeutralVariantPalette(this.variant, t.sourceColorHct, this.isDark, this.platform, this.contrastLevel), this.errorPalette = t.errorPalette ?? da(this.specVersion).getErrorPalette(this.variant, t.sourceColorHct, this.isDark, this.platform, this.contrastLevel) ?? N.fromHueAndChroma(25, 84), this.colors = new F();
  }
  toString() {
    return `Scheme: variant=${E[this.variant]}, mode=${this.isDark ? "dark" : "light"}, platform=${this.platform}, contrastLevel=${this.contrastLevel.toFixed(1)}, seed=${this.sourceColorHct.toString()}, specVersion=${this.specVersion}`;
  }
  /**
   * Returns a new hue based on a piecewise function and input color hue.
   *
   * For example, for the following function:
   * result = 26 if 0 <= hue < 101
   * result = 39 if 101 <= hue < 210
   * result = 28 if 210 <= hue < 360
   *
   * call the function as:
   *
   * const hueBreakpoints = [0, 101, 210, 360];
   * const hues = [26, 39, 28];
   * const result = scheme.piecewise(hue, hueBreakpoints, hues);
   *
   * @param sourceColorHct The input value.
   * @param hueBreakpoints The breakpoints, in sorted order. No default lower or
   *     upper bounds are assumed.
   * @param hues The hues that should be applied when source color's hue is >=
   *     the same index in hueBrakpoints array, and < the hue at the next index
   *     in hueBrakpoints array. Otherwise, the source color's hue is returned.
   */
  static getPiecewiseHue(t, e, i) {
    const r = Math.min(e.length - 1, i.length), s = t.hue;
    for (let o = 0; o < r; o++)
      if (s >= e[o] && s < e[o + 1])
        return Ue(i[o]);
    return s;
  }
  /**
   * Returns a shifted hue based on a piecewise function and input color hue.
   *
   * For example, for the following function:
   * result = hue + 26 if 0 <= hue < 101
   * result = hue - 39 if 101 <= hue < 210
   * result = hue + 28 if 210 <= hue < 360
   *
   * call the function as:
   *
   * const hueBreakpoints = [0, 101, 210, 360];
   * const hues = [26, -39, 28];
   * const result = scheme.getRotatedHue(hue, hueBreakpoints, hues);
   *
   * @param sourceColorHct the source color of the theme, in HCT.
   * @param hueBreakpoints The "breakpoints", i.e. the hues at which a rotation
   *     should be apply. No default lower or upper bounds are assumed.
   * @param rotations The rotation that should be applied when source color's
   *     hue is >= the same index in hues array, and < the hue at the next
   *     index in hues array. Otherwise, the source color's hue is returned.
   */
  static getRotatedHue(t, e, i) {
    let r = wl.getPiecewiseHue(t, e, i);
    return Math.min(e.length - 1, i.length) <= 0 && (r = 0), Ue(t.hue + r);
  }
  getArgb(t) {
    return t.getArgb(this);
  }
  getHct(t) {
    return t.getHct(this);
  }
  // Palette key colors
  get primaryPaletteKeyColor() {
    return this.getArgb(this.colors.primaryPaletteKeyColor());
  }
  get secondaryPaletteKeyColor() {
    return this.getArgb(this.colors.secondaryPaletteKeyColor());
  }
  get tertiaryPaletteKeyColor() {
    return this.getArgb(this.colors.tertiaryPaletteKeyColor());
  }
  get neutralPaletteKeyColor() {
    return this.getArgb(this.colors.neutralPaletteKeyColor());
  }
  get neutralVariantPaletteKeyColor() {
    return this.getArgb(this.colors.neutralVariantPaletteKeyColor());
  }
  get errorPaletteKeyColor() {
    return this.getArgb(this.colors.errorPaletteKeyColor());
  }
  // Surface colors
  get background() {
    return this.getArgb(this.colors.background());
  }
  get onBackground() {
    return this.getArgb(this.colors.onBackground());
  }
  get surface() {
    return this.getArgb(this.colors.surface());
  }
  get surfaceDim() {
    return this.getArgb(this.colors.surfaceDim());
  }
  get surfaceBright() {
    return this.getArgb(this.colors.surfaceBright());
  }
  get surfaceContainerLowest() {
    return this.getArgb(this.colors.surfaceContainerLowest());
  }
  get surfaceContainerLow() {
    return this.getArgb(this.colors.surfaceContainerLow());
  }
  get surfaceContainer() {
    return this.getArgb(this.colors.surfaceContainer());
  }
  get surfaceContainerHigh() {
    return this.getArgb(this.colors.surfaceContainerHigh());
  }
  get surfaceContainerHighest() {
    return this.getArgb(this.colors.surfaceContainerHighest());
  }
  get onSurface() {
    return this.getArgb(this.colors.onSurface());
  }
  get surfaceVariant() {
    return this.getArgb(this.colors.surfaceVariant());
  }
  get onSurfaceVariant() {
    return this.getArgb(this.colors.onSurfaceVariant());
  }
  get inverseSurface() {
    return this.getArgb(this.colors.inverseSurface());
  }
  get inverseOnSurface() {
    return this.getArgb(this.colors.inverseOnSurface());
  }
  get outline() {
    return this.getArgb(this.colors.outline());
  }
  get outlineVariant() {
    return this.getArgb(this.colors.outlineVariant());
  }
  get shadow() {
    return this.getArgb(this.colors.shadow());
  }
  get scrim() {
    return this.getArgb(this.colors.scrim());
  }
  get surfaceTint() {
    return this.getArgb(this.colors.surfaceTint());
  }
  // Primary colors
  get primary() {
    return this.getArgb(this.colors.primary());
  }
  get primaryDim() {
    const t = this.colors.primaryDim();
    if (t === void 0)
      throw new Error("`primaryDim` color is undefined prior to 2025 spec.");
    return this.getArgb(t);
  }
  get onPrimary() {
    return this.getArgb(this.colors.onPrimary());
  }
  get primaryContainer() {
    return this.getArgb(this.colors.primaryContainer());
  }
  get onPrimaryContainer() {
    return this.getArgb(this.colors.onPrimaryContainer());
  }
  get primaryFixed() {
    return this.getArgb(this.colors.primaryFixed());
  }
  get primaryFixedDim() {
    return this.getArgb(this.colors.primaryFixedDim());
  }
  get onPrimaryFixed() {
    return this.getArgb(this.colors.onPrimaryFixed());
  }
  get onPrimaryFixedVariant() {
    return this.getArgb(this.colors.onPrimaryFixedVariant());
  }
  get inversePrimary() {
    return this.getArgb(this.colors.inversePrimary());
  }
  // Secondary colors
  get secondary() {
    return this.getArgb(this.colors.secondary());
  }
  get secondaryDim() {
    const t = this.colors.secondaryDim();
    if (t === void 0)
      throw new Error("`secondaryDim` color is undefined prior to 2025 spec.");
    return this.getArgb(t);
  }
  get onSecondary() {
    return this.getArgb(this.colors.onSecondary());
  }
  get secondaryContainer() {
    return this.getArgb(this.colors.secondaryContainer());
  }
  get onSecondaryContainer() {
    return this.getArgb(this.colors.onSecondaryContainer());
  }
  get secondaryFixed() {
    return this.getArgb(this.colors.secondaryFixed());
  }
  get secondaryFixedDim() {
    return this.getArgb(this.colors.secondaryFixedDim());
  }
  get onSecondaryFixed() {
    return this.getArgb(this.colors.onSecondaryFixed());
  }
  get onSecondaryFixedVariant() {
    return this.getArgb(this.colors.onSecondaryFixedVariant());
  }
  // Tertiary colors
  get tertiary() {
    return this.getArgb(this.colors.tertiary());
  }
  get tertiaryDim() {
    const t = this.colors.tertiaryDim();
    if (t === void 0)
      throw new Error("`tertiaryDim` color is undefined prior to 2025 spec.");
    return this.getArgb(t);
  }
  get onTertiary() {
    return this.getArgb(this.colors.onTertiary());
  }
  get tertiaryContainer() {
    return this.getArgb(this.colors.tertiaryContainer());
  }
  get onTertiaryContainer() {
    return this.getArgb(this.colors.onTertiaryContainer());
  }
  get tertiaryFixed() {
    return this.getArgb(this.colors.tertiaryFixed());
  }
  get tertiaryFixedDim() {
    return this.getArgb(this.colors.tertiaryFixedDim());
  }
  get onTertiaryFixed() {
    return this.getArgb(this.colors.onTertiaryFixed());
  }
  get onTertiaryFixedVariant() {
    return this.getArgb(this.colors.onTertiaryFixedVariant());
  }
  // Error colors
  get error() {
    return this.getArgb(this.colors.error());
  }
  get errorDim() {
    const t = this.colors.errorDim();
    if (t === void 0)
      throw new Error("`errorDim` color is undefined prior to 2025 spec.");
    return this.getArgb(t);
  }
  get onError() {
    return this.getArgb(this.colors.onError());
  }
  get errorContainer() {
    return this.getArgb(this.colors.errorContainer());
  }
  get onErrorContainer() {
    return this.getArgb(this.colors.onErrorContainer());
  }
};
a(wl, "DynamicScheme");
let me = wl;
me.DEFAULT_SPEC_VERSION = "2021";
me.DEFAULT_PLATFORM = "phone";
const tw = class tw {
  //////////////////////////////////////////////////////////////////
  // Scheme Palettes                                              //
  //////////////////////////////////////////////////////////////////
  getPrimaryPalette(t, e, i, r, s) {
    switch (t) {
      case E.CONTENT:
      case E.FIDELITY:
        return N.fromHueAndChroma(e.hue, e.chroma);
      case E.FRUIT_SALAD:
        return N.fromHueAndChroma(Ue(e.hue - 50), 48);
      case E.MONOCHROME:
        return N.fromHueAndChroma(e.hue, 0);
      case E.NEUTRAL:
        return N.fromHueAndChroma(e.hue, 12);
      case E.RAINBOW:
        return N.fromHueAndChroma(e.hue, 48);
      case E.TONAL_SPOT:
        return N.fromHueAndChroma(e.hue, 36);
      case E.EXPRESSIVE:
        return N.fromHueAndChroma(Ue(e.hue + 240), 40);
      case E.VIBRANT:
        return N.fromHueAndChroma(e.hue, 200);
      default:
        throw new Error(`Unsupported variant: ${t}`);
    }
  }
  getSecondaryPalette(t, e, i, r, s) {
    switch (t) {
      case E.CONTENT:
      case E.FIDELITY:
        return N.fromHueAndChroma(e.hue, Math.max(e.chroma - 32, e.chroma * 0.5));
      case E.FRUIT_SALAD:
        return N.fromHueAndChroma(Ue(e.hue - 50), 36);
      case E.MONOCHROME:
        return N.fromHueAndChroma(e.hue, 0);
      case E.NEUTRAL:
        return N.fromHueAndChroma(e.hue, 8);
      case E.RAINBOW:
        return N.fromHueAndChroma(e.hue, 16);
      case E.TONAL_SPOT:
        return N.fromHueAndChroma(e.hue, 16);
      case E.EXPRESSIVE:
        return N.fromHueAndChroma(me.getRotatedHue(e, [0, 21, 51, 121, 151, 191, 271, 321, 360], [45, 95, 45, 20, 45, 90, 45, 45, 45]), 24);
      case E.VIBRANT:
        return N.fromHueAndChroma(me.getRotatedHue(e, [0, 41, 61, 101, 131, 181, 251, 301, 360], [18, 15, 10, 12, 15, 18, 15, 12, 12]), 24);
      default:
        throw new Error(`Unsupported variant: ${t}`);
    }
  }
  getTertiaryPalette(t, e, i, r, s) {
    switch (t) {
      case E.CONTENT:
        return N.fromHct(vl.fixIfDisliked(new Qd(e).analogous(
          /* count= */
          3,
          /* divisions= */
          6
        )[2]));
      case E.FIDELITY:
        return N.fromHct(vl.fixIfDisliked(new Qd(e).complement));
      case E.FRUIT_SALAD:
        return N.fromHueAndChroma(e.hue, 36);
      case E.MONOCHROME:
        return N.fromHueAndChroma(e.hue, 0);
      case E.NEUTRAL:
        return N.fromHueAndChroma(e.hue, 16);
      case E.RAINBOW:
      case E.TONAL_SPOT:
        return N.fromHueAndChroma(Ue(e.hue + 60), 24);
      case E.EXPRESSIVE:
        return N.fromHueAndChroma(me.getRotatedHue(e, [0, 21, 51, 121, 151, 191, 271, 321, 360], [120, 120, 20, 45, 20, 15, 20, 120, 120]), 32);
      case E.VIBRANT:
        return N.fromHueAndChroma(me.getRotatedHue(e, [0, 41, 61, 101, 131, 181, 251, 301, 360], [35, 30, 20, 25, 30, 35, 30, 25, 25]), 32);
      default:
        throw new Error(`Unsupported variant: ${t}`);
    }
  }
  getNeutralPalette(t, e, i, r, s) {
    switch (t) {
      case E.CONTENT:
      case E.FIDELITY:
        return N.fromHueAndChroma(e.hue, e.chroma / 8);
      case E.FRUIT_SALAD:
        return N.fromHueAndChroma(e.hue, 10);
      case E.MONOCHROME:
        return N.fromHueAndChroma(e.hue, 0);
      case E.NEUTRAL:
        return N.fromHueAndChroma(e.hue, 2);
      case E.RAINBOW:
        return N.fromHueAndChroma(e.hue, 0);
      case E.TONAL_SPOT:
        return N.fromHueAndChroma(e.hue, 6);
      case E.EXPRESSIVE:
        return N.fromHueAndChroma(Ue(e.hue + 15), 8);
      case E.VIBRANT:
        return N.fromHueAndChroma(e.hue, 10);
      default:
        throw new Error(`Unsupported variant: ${t}`);
    }
  }
  getNeutralVariantPalette(t, e, i, r, s) {
    switch (t) {
      case E.CONTENT:
        return N.fromHueAndChroma(e.hue, e.chroma / 8 + 4);
      case E.FIDELITY:
        return N.fromHueAndChroma(e.hue, e.chroma / 8 + 4);
      case E.FRUIT_SALAD:
        return N.fromHueAndChroma(e.hue, 16);
      case E.MONOCHROME:
        return N.fromHueAndChroma(e.hue, 0);
      case E.NEUTRAL:
        return N.fromHueAndChroma(e.hue, 2);
      case E.RAINBOW:
        return N.fromHueAndChroma(e.hue, 0);
      case E.TONAL_SPOT:
        return N.fromHueAndChroma(e.hue, 8);
      case E.EXPRESSIVE:
        return N.fromHueAndChroma(Ue(e.hue + 15), 12);
      case E.VIBRANT:
        return N.fromHueAndChroma(e.hue, 12);
      default:
        throw new Error(`Unsupported variant: ${t}`);
    }
  }
  getErrorPalette(t, e, i, r, s) {
  }
};
a(tw, "DynamicSchemePalettesDelegateImpl2021");
let Gd = tw;
const Xe = class Xe extends Gd {
  //////////////////////////////////////////////////////////////////
  // Scheme Palettes                                              //
  //////////////////////////////////////////////////////////////////
  getPrimaryPalette(t, e, i, r, s) {
    switch (t) {
      case E.NEUTRAL:
        return N.fromHueAndChroma(e.hue, r === "phone" ? pt.isBlue(e.hue) ? 12 : 8 : pt.isBlue(e.hue) ? 16 : 12);
      case E.TONAL_SPOT:
        return N.fromHueAndChroma(e.hue, r === "phone" && i ? 26 : 32);
      case E.EXPRESSIVE:
        return N.fromHueAndChroma(e.hue, r === "phone" ? i ? 36 : 48 : 40);
      case E.VIBRANT:
        return N.fromHueAndChroma(e.hue, r === "phone" ? 74 : 56);
      default:
        return super.getPrimaryPalette(t, e, i, r, s);
    }
  }
  getSecondaryPalette(t, e, i, r, s) {
    switch (t) {
      case E.NEUTRAL:
        return N.fromHueAndChroma(e.hue, r === "phone" ? pt.isBlue(e.hue) ? 6 : 4 : pt.isBlue(e.hue) ? 10 : 6);
      case E.TONAL_SPOT:
        return N.fromHueAndChroma(e.hue, 16);
      case E.EXPRESSIVE:
        return N.fromHueAndChroma(me.getRotatedHue(e, [0, 105, 140, 204, 253, 278, 300, 333, 360], [-160, 155, -100, 96, -96, -156, -165, -160]), r === "phone" && i ? 16 : 24);
      case E.VIBRANT:
        return N.fromHueAndChroma(me.getRotatedHue(e, [0, 38, 105, 140, 333, 360], [-14, 10, -14, 10, -14]), r === "phone" ? 56 : 36);
      default:
        return super.getSecondaryPalette(t, e, i, r, s);
    }
  }
  getTertiaryPalette(t, e, i, r, s) {
    switch (t) {
      case E.NEUTRAL:
        return N.fromHueAndChroma(me.getRotatedHue(e, [0, 38, 105, 161, 204, 278, 333, 360], [-32, 26, 10, -39, 24, -15, -32]), r === "phone" ? 20 : 36);
      case E.TONAL_SPOT:
        return N.fromHueAndChroma(me.getRotatedHue(e, [0, 20, 71, 161, 333, 360], [-40, 48, -32, 40, -32]), r === "phone" ? 28 : 32);
      case E.EXPRESSIVE:
        return N.fromHueAndChroma(me.getRotatedHue(e, [0, 105, 140, 204, 253, 278, 300, 333, 360], [-165, 160, -105, 101, -101, -160, -170, -165]), 48);
      case E.VIBRANT:
        return N.fromHueAndChroma(me.getRotatedHue(e, [0, 38, 71, 105, 140, 161, 253, 333, 360], [-72, 35, 24, -24, 62, 50, 62, -72]), 56);
      default:
        return super.getTertiaryPalette(t, e, i, r, s);
    }
  }
  static getExpressiveNeutralHue(t) {
    return me.getRotatedHue(t, [0, 71, 124, 253, 278, 300, 360], [10, 0, 10, 0, 10, 0]);
  }
  static getExpressiveNeutralChroma(t, e, i) {
    const r = Xe.getExpressiveNeutralHue(t);
    return i === "phone" ? e ? pt.isYellow(r) ? 6 : 14 : 18 : 12;
  }
  static getVibrantNeutralHue(t) {
    return me.getRotatedHue(t, [0, 38, 105, 140, 333, 360], [-14, 10, -14, 10, -14]);
  }
  static getVibrantNeutralChroma(t, e) {
    const i = Xe.getVibrantNeutralHue(t);
    return e === "phone" || pt.isBlue(i) ? 28 : 20;
  }
  getNeutralPalette(t, e, i, r, s) {
    switch (t) {
      case E.NEUTRAL:
        return N.fromHueAndChroma(e.hue, r === "phone" ? 1.4 : 6);
      case E.TONAL_SPOT:
        return N.fromHueAndChroma(e.hue, r === "phone" ? 5 : 10);
      case E.EXPRESSIVE:
        return N.fromHueAndChroma(Xe.getExpressiveNeutralHue(e), Xe.getExpressiveNeutralChroma(e, i, r));
      case E.VIBRANT:
        return N.fromHueAndChroma(Xe.getVibrantNeutralHue(e), Xe.getVibrantNeutralChroma(e, r));
      default:
        return super.getNeutralPalette(t, e, i, r, s);
    }
  }
  getNeutralVariantPalette(t, e, i, r, s) {
    switch (t) {
      case E.NEUTRAL:
        return N.fromHueAndChroma(e.hue, (r === "phone" ? 1.4 : 6) * 2.2);
      case E.TONAL_SPOT:
        return N.fromHueAndChroma(e.hue, (r === "phone" ? 5 : 10) * 1.7);
      case E.EXPRESSIVE:
        const o = Xe.getExpressiveNeutralHue(e), c = Xe.getExpressiveNeutralChroma(e, i, r);
        return N.fromHueAndChroma(o, c * (o >= 105 && o < 125 ? 1.6 : 2.3));
      case E.VIBRANT:
        const l = Xe.getVibrantNeutralHue(e), p = Xe.getVibrantNeutralChroma(e, r);
        return N.fromHueAndChroma(l, p * 1.29);
      default:
        return super.getNeutralVariantPalette(t, e, i, r, s);
    }
  }
  getErrorPalette(t, e, i, r, s) {
    const o = me.getPiecewiseHue(e, [0, 3, 13, 23, 33, 43, 153, 273, 360], [12, 22, 32, 12, 22, 32, 22, 12]);
    switch (t) {
      case E.NEUTRAL:
        return N.fromHueAndChroma(o, r === "phone" ? 50 : 40);
      case E.TONAL_SPOT:
        return N.fromHueAndChroma(o, r === "phone" ? 60 : 48);
      case E.EXPRESSIVE:
        return N.fromHueAndChroma(o, r === "phone" ? 64 : 48);
      case E.VIBRANT:
        return N.fromHueAndChroma(o, r === "phone" ? 80 : 60);
      default:
        return super.getErrorPalette(t, e, i, r, s);
    }
  }
};
a(Xe, "DynamicSchemePalettesDelegateImpl2025");
let bp = Xe;
const Qg = new Gd(), Gg = new bp();
function da(n) {
  return n === "2025" ? Gg : Qg;
}
a(da, "getSpec");
function Zg(n) {
  n = n.replace("#", "");
  const t = n.length === 3, e = n.length === 6, i = n.length === 8;
  if (!t && !e && !i)
    throw new Error("unexpected hex " + n);
  let r = 0, s = 0, o = 0;
  return t ? (r = Ni(n.slice(0, 1).repeat(2)), s = Ni(n.slice(1, 2).repeat(2)), o = Ni(n.slice(2, 3).repeat(2))) : e ? (r = Ni(n.slice(0, 2)), s = Ni(n.slice(2, 4)), o = Ni(n.slice(4, 6))) : i && (r = Ni(n.slice(2, 4)), s = Ni(n.slice(4, 6)), o = Ni(n.slice(6, 8))), (255 << 24 | (r & 255) << 16 | (s & 255) << 8 | o & 255) >>> 0;
}
a(Zg, "argbFromHex");
function Ni(n) {
  return parseInt(n, 16);
}
a(Ni, "parseIntHex");
function Yg(n, t = !1) {
  const e = n.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+\.{0,1}\d*))?\)$/)?.slice(1).map((c, l) => l === 3 ? Math.round(parseFloat(c) * 255) : parseFloat(c));
  if (!e)
    throw new Error("Could not parse rgba color.");
  const [i, r, s, o] = e;
  return ((t ? 255 : o & 255) << 24 | (i & 255) << 16 | (r & 255) << 8 | s & 255) >>> 0;
}
a(Yg, "argbFromRgba");
function $i(n, t) {
  return Math.round(255 * t) << 24 | n & 16777215;
}
a($i, "addAlphaToArgb");
function Xg(n) {
  const t = ay(n), e = sy(n), i = oy(n), r = Fg(n), s = [t.toString(16), e.toString(16), i.toString(16)];
  r !== 255 && s.push(r.toString(16));
  for (const [o, c] of s.entries())
    c.length === 1 && (s[o] = "0" + c);
  return "#" + s.join("");
}
a(Xg, "hexWithAlphaFromArgb");
function Jg(n) {
  Pe();
  const t = document.createElement("wy-compute-styles");
  t.setAttribute("style", `color: ${n} !important;`), document.documentElement.append(t);
  const e = window.getComputedStyle(t).color;
  return t.remove(), e;
}
a(Jg, "getComputedColor");
const ew = class ew extends me {
  constructor(t, e, i, r = E.FIDELITY) {
    const s = t.chroma, o = Math.min(36, t.chroma * 16 / 36), c = o, l = Math.min(6, t.chroma * 6 / 36), p = Math.min(8, t.chroma * 8 / 36);
    super({
      sourceColorHct: t,
      variant: r,
      contrastLevel: i,
      isDark: e,
      primaryPalette: N.fromHueAndChroma(t.hue, s),
      secondaryPalette: N.fromHueAndChroma(t.hue, o),
      tertiaryPalette: N.fromHueAndChroma(Ue(t.hue - 6 * 22.5), c),
      neutralPalette: N.fromHueAndChroma(t.hue, l),
      neutralVariantPalette: N.fromHueAndChroma(t.hue, p)
    }), this.allTones = {
      //"100": 100,
      98: 98,
      // MD3
      95: 95,
      90: 90,
      80: 80,
      70: 70,
      60: 60,
      50: 50,
      40: 40,
      30: 30,
      20: 20,
      10: 10
      //"0": 0
    }, this.namedColorToneMap = {
      red: { light: 60, dark: 60 },
      "deep-orange": { light: 60, dark: 60 },
      orange: { light: 70, dark: 70 },
      amber: { light: 70, dark: 70 },
      yellow: { light: 70, dark: 80 },
      lime: { light: 70, dark: 70 },
      "light-green": { light: 70, dark: 70 },
      green: { light: 60, dark: 60 },
      teal: { light: 60, dark: 60 },
      cyan: { light: 50, dark: 60 },
      "light-blue": { light: 60, dark: 70 },
      blue: { light: 70, dark: 80 },
      indigo: { light: 60, dark: 60 },
      "deep-purple": { light: 60, dark: 70 },
      purple: { light: 60, dark: 70 },
      pink: { light: 60, dark: 70 },
      gray: { light: 50, dark: 60 }
    };
    const v = t.hue, C = t.chroma, g = Math.max(48, C), m = Math.min(g, 84), $ = 360 / 16, A = 27.4, M = -8, R = (v + 360 - A - M + $ / 2) % $ + A + M - $ / 2;
    this.errorPalette = N.fromHueAndChroma(R, 84), this.warningPalette = N.fromHueAndChroma(R + 4 * $, m), this.namedColorPalettes = {
      red: N.fromHueAndChroma(R, m),
      "deep-orange": N.fromHueAndChroma(R + 1 * $, m),
      orange: N.fromHueAndChroma(R + 2 * $, m),
      amber: N.fromHueAndChroma(R + 3 * $, m),
      yellow: N.fromHueAndChroma(R + 4 * $, m),
      lime: N.fromHueAndChroma(R + 5 * $, m),
      "light-green": N.fromHueAndChroma(R + 6 * $, m),
      green: N.fromHueAndChroma(R + 7 * $, m),
      teal: N.fromHueAndChroma(R + 8 * $, m),
      cyan: N.fromHueAndChroma(R + 9 * $, m),
      "light-blue": N.fromHueAndChroma(R + 10 * $, m),
      blue: N.fromHueAndChroma(R + 11 * $, m),
      indigo: N.fromHueAndChroma(R + 12 * $, m),
      "deep-purple": N.fromHueAndChroma(R + 13 * $, m),
      purple: N.fromHueAndChroma(R + 14 * $, m),
      pink: N.fromHueAndChroma(R + 15 * $, m),
      gray: N.fromHueAndChroma(v, 4)
    };
  }
  // Solid base colors
  get black() {
    return 0;
  }
  get white() {
    return 16777215;
  }
  // Custom transparency based surface container colors
  get surfaceLayerLowest() {
    return this.isDark ? $i(this.black, 0.5) : $i(this.white, 0.75);
  }
  get surfaceLayerLow() {
    return this.isDark ? $i(this.black, 0.25) : $i(this.white, 0.5);
  }
  get surfaceLayer() {
    return this.isDark ? $i(this.white, 0.05) : $i(this.black, 0.05);
  }
  get surfaceLayerHigh() {
    return this.isDark ? $i(this.white, 0.1) : $i(this.black, 0.075);
  }
  get surfaceLayerHighest() {
    return this.isDark ? $i(this.white, 0.15) : $i(this.black, 0.1);
  }
  // Custom Tokens
  get warning() {
    return this.warningPalette.tone(this.isDark ? 90 : 70);
  }
  get onWarning() {
    return this.warningPalette.tone(this.isDark ? 30 : 0);
  }
  get warningContainer() {
    return this.warningPalette.tone(this.isDark ? 50 : 90);
  }
  get onWarningContainer() {
    return this.warningPalette.tone(this.isDark ? 95 : 10);
  }
  get highlight() {
    return this.primaryPalette.tone(this.isDark ? 20 : 95);
  }
  get onHighlight() {
    return this.primaryPalette.tone(this.isDark ? 90 : 10);
  }
  // Named colors
  namedColor(t) {
    return this.namedColorPalettes[t].tone(this.namedColorToneMap[t][this.isDark ? "dark" : "light"]);
  }
  get red() {
    return this.namedColor(
      "red"
      /* Red */
    );
  }
  get deepOrange() {
    return this.namedColor(
      "deep-orange"
      /* DeepOrange */
    );
  }
  get orange() {
    return this.namedColor(
      "orange"
      /* Orange */
    );
  }
  get amber() {
    return this.namedColor(
      "amber"
      /* Amber */
    );
  }
  get yellow() {
    return this.namedColor(
      "yellow"
      /* Yellow */
    );
  }
  get lime() {
    return this.namedColor(
      "lime"
      /* Lime */
    );
  }
  get lightGreen() {
    return this.namedColor(
      "light-green"
      /* LightGreen */
    );
  }
  get green() {
    return this.namedColor(
      "green"
      /* Green */
    );
  }
  get teal() {
    return this.namedColor(
      "teal"
      /* Teal */
    );
  }
  get cyan() {
    return this.namedColor(
      "cyan"
      /* Cyan */
    );
  }
  get lightBlue() {
    return this.namedColor(
      "light-blue"
      /* LightBlue */
    );
  }
  get blue() {
    return this.namedColor(
      "blue"
      /* Blue */
    );
  }
  get indigo() {
    return this.namedColor(
      "indigo"
      /* Indigo */
    );
  }
  get deepPurple() {
    return this.namedColor(
      "deep-purple"
      /* DeepPurple */
    );
  }
  get purple() {
    return this.namedColor(
      "purple"
      /* Purple */
    );
  }
  get pink() {
    return this.namedColor(
      "pink"
      /* Pink */
    );
  }
  get gray() {
    return this.namedColor(
      "gray"
      /* Gray */
    );
  }
};
a(ew, "SchemeWeavy");
let Zd = ew;
function xp(n) {
  return getComputedStyle(n).getPropertyValue("--wy-theme-color") || void 0;
}
a(xp, "getCSSThemeColor");
function t0(n, t) {
  let e = xp(n);
  const i = new MutationObserver(() => {
    const o = xp(n);
    o !== e && (e = o, t(o));
  }), r = {
    attributes: !0,
    attributeFilter: ["class", "style"]
  };
  let s = n;
  for (; s && s !== document; )
    i.observe(s, r), s = s.parentNode;
  return () => i.disconnect();
}
a(t0, "observeCSSThemeColor");
function Cp() {
  return Pe(), Array.from(document.head.querySelectorAll("meta[name='theme-color']")).filter((e) => {
    const i = e.getAttribute("media");
    return !i || window.matchMedia(i)?.matches;
  }).pop()?.getAttribute("content") || void 0;
}
a(Cp, "getMetaThemeColor");
function e0(n) {
  Pe();
  const t = Array.from(document.head.querySelectorAll("meta[name='theme-color']"));
  if (!t)
    return () => {
    };
  let e = Cp();
  const i = /* @__PURE__ */ a(() => {
    const c = Cp();
    c !== e && (e = c, n(c));
  }, "checkChangedColor"), r = new MutationObserver(i), s = {
    attributes: !0,
    attributeFilter: ["content"]
  }, o = [];
  return t.forEach((c) => {
    r.observe(c, s);
    const l = c.getAttribute("media");
    if (l) {
      const p = window.matchMedia(l);
      p.addEventListener("change", i), o.push(p);
    }
  }), () => {
    r.disconnect(), o.forEach((c) => c.removeEventListener("change", i));
  };
}
a(e0, "observeMetaThemeColor");
const ol = [], i0 = 16;
function r0(n, t = !1) {
  if (ol.some((l) => l.seedColor === n)) {
    const l = ol.find((p) => p.seedColor === n)?.colors;
    if (l)
      return l;
  }
  const e = [];
  t && e.push(`--wy-theme-color:${n};`);
  let i = n;
  !n.startsWith("#") && !n.startsWith("rgb") && (i = Jg(n));
  const r = n.startsWith("#") ? Zg(i) : Yg(i), s = pt.fromInt(r), o = {
    light: new Zd(s, !1, 0, E.FIDELITY),
    dark: new Zd(s, !0, 0, E.FIDELITY)
  }, c = {
    primary: "primary",
    onPrimary: "on-primary",
    primaryContainer: "primary-container",
    onPrimaryContainer: "on-primary-container",
    secondary: "secondary",
    onSecondary: "on-secondary",
    secondaryContainer: "secondary-container",
    onSecondaryContainer: "on-secondary-container",
    tertiary: "tertiary",
    onTertiary: "on-tertiary",
    tertiaryContainer: "tertiary-container",
    onTertiaryContainer: "on-tertiary-container",
    error: "error",
    onError: "on-error",
    errorContainer: "error-container",
    onErrorContainer: "on-error-container",
    background: "background",
    onBackground: "on-background",
    surface: "surface",
    onSurface: "on-surface",
    surfaceVariant: "surface-variant",
    onSurfaceVariant: "on-surface-variant",
    surfaceContainerLowest: "surface-container-lowest",
    surfaceContainerLow: "surface-container-low",
    surfaceContainer: "surface-container",
    surfaceContainerHigh: "surface-container-high",
    surfaceContainerHighest: "surface-container-highest",
    outline: "outline",
    outlineVariant: "outline-variant",
    shadow: "shadow",
    scrim: "scrim",
    // Custom surface layers
    surfaceLayerLowest: "surface-layer-lowest",
    surfaceLayerLow: "surface-layer-low",
    surfaceLayer: "surface-layer",
    surfaceLayerHigh: "surface-layer-high",
    surfaceLayerHighest: "surface-layer-highest",
    // Custom tokens
    warning: "warning",
    onWarning: "on-warning",
    warningContainer: "warning-container",
    onWarningContainer: "on-warning-container",
    highlight: "highlight",
    onHighlight: "on-highlight",
    // Named colors
    red: "red",
    deepOrange: "deep-orange",
    orange: "orange",
    amber: "amber",
    yellow: "yellow",
    lime: "lime",
    lightGreen: "light-green",
    green: "green",
    teal: "teal",
    cyan: "cyan",
    lightBlue: "light-blue",
    blue: "blue",
    indigo: "indigo",
    deepPurple: "deep-purple",
    purple: "purple",
    pink: "pink",
    gray: "gray"
  };
  for (const l in o) {
    const p = o[l];
    for (const v in c) {
      const C = c[v], g = Xg(p[v]);
      e.push(`--wy-${C}-${l}:${g};`);
    }
  }
  return ol.unshift({ seedColor: n, colors: e }), ol.length = Math.min(ol.length, i0), e;
}
a(r0, "generateThemeColors");
const n0 = /* @__PURE__ */ a((n) => {
  if (Pe(), k1)
    document.adoptedStyleSheets = n.map((t) => t instanceof CSSStyleSheet ? t : t.styleSheet);
  else
    for (const t of n) {
      const e = document.createElement("style"), i = global.litNonce;
      i !== void 0 && e.setAttribute("nonce", i), e.textContent = t.cssText, (document.head || document.documentElement).appendChild(e);
    }
}, "adoptGlobalStyles"), se = j`@property --wy-color-scheme{syntax:\"normal | light | dark\";inherits:true;initial-value:normal}:is(.wy-light,[part~=wy-light]) :where(wy-chat),:is(.wy-light,[part~=wy-light]) :where(wy-comments),:is(.wy-light,[part~=wy-light]) :where(wy-component),:is(.wy-light,[part~=wy-light]) :where(wy-copilot),:is(.wy-light,[part~=wy-light]) :where(wy-files),:is(.wy-light,[part~=wy-light]) :where(wy-messenger),:is(.wy-light,[part~=wy-light]) :where(wy-notification-toasts),:is(.wy-light,[part~=wy-light]) :where(wy-notifications),:is(.wy-light,[part~=wy-light]) :where(wy-posts),:host(:is(.wy-light,[part~=wy-light])),:host :is(.wy-light,[part~=wy-light]),::slotted(:is(.wy-light,[part~=wy-light])){color-scheme:light;--wy-primary:var(--wy-primary-light, #2f628c);--wy-on-primary:var(--wy-on-primary-light, #ffffff);--wy-primary-container:var(--wy-primary-container-light, #cee5ff);--wy-on-primary-container:var(--wy-on-primary-container-light, #0d4a73);--wy-secondary:var(--wy-secondary-light, #51606f);--wy-on-secondary:var(--wy-on-secondary-light, #ffffff);--wy-secondary-container:var(--wy-secondary-container-light, #d5e4f7);--wy-on-secondary-container:var(--wy-on-secondary-container-light, #3a4857);--wy-tertiary:var(--wy-tertiary-light, #645f41);--wy-on-tertiary:var(--wy-on-tertiary-light, #ffffff);--wy-tertiary-container:var(--wy-tertiary-container-light, #ebe3bd);--wy-on-tertiary-container:var(--wy-on-tertiary-container-light, #4c472b);--wy-error:var(--wy-error-light, #ba1821);--wy-on-error:var(--wy-on-error-light, #ffffff);--wy-error-container:var(--wy-error-container-light, #ffdad6);--wy-on-error-container:var(--wy-on-error-container-light, #930012);--wy-background:var(--wy-background-light, #f7f9ff);--wy-on-background:var(--wy-on-background-light, #181c20);--wy-surface:var(--wy-surface-light, #f7f9ff);--wy-on-surface:var(--wy-on-surface-light, #181c20);--wy-surface-variant:var(--wy-surface-variant-light, #dee3eb);--wy-on-surface-variant:var(--wy-on-surface-variant-light, #42474e);--wy-outline:var(--wy-outline-light, #72777f);--wy-outline-variant:var(--wy-outline-variant-light, #c2c7cf);--wy-surface-container-highest:var(--wy-surface-container-highest-light, #e0e2e8);--wy-surface-container-high:var(--wy-surface-container-high-light, #e6e8ee);--wy-surface-container:var(--wy-surface-container-light, #eceef3);--wy-surface-container-low:var(--wy-surface-container-low-light, #f1f3f9);--wy-surface-container-lowest:var(--wy-surface-container-lowest-light, #ffffff);--wy-surface-layer-highest:var(--wy-surface-layer-highest-light, rgba(0, 0, 0, .1019607843));--wy-surface-layer-high:var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039));--wy-surface-layer:var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922));--wy-surface-layer-low:var(--wy-surface-layer-low-light, rgba(255, 255, 255, .5019607843));--wy-surface-layer-lowest:var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078));--wy-warning:var(--wy-warning-light, #adb140);--wy-on-warning:var(--wy-on-warning-light, #000000);--wy-warning-container:var(--wy-warning-container-light, #e5e972);--wy-on-warning-container:var(--wy-on-warning-container-light, #1c1d00);--wy-highlight:var(--wy-highlight-light, #e8f2ff);--wy-on-highlight:var(--wy-on-highlight-light, #001d32);--wy-link:var(--wy-primary-light, #2f628c);--wy-presence-active:var(--wy-green-light, #00a38d);--wy-shade:var(--wy-shade-light, rgba(0, 0, 0, .3));--wy-shade-invert:var(--wy-shade-invert-light, rgba(255, 255, 255, .15));--wy-shade-opaque:var(--wy-shade-opaque-light, white);--wy-blue:var(--wy-blue-light, #8aa9fc);--wy-indigo:var(--wy-indigo-light, #9285de);--wy-purple:var(--wy-purple-light, #c675b6);--wy-pink:var(--wy-pink-light, #d57193);--wy-red:var(--wy-red-light, #db726b);--wy-orange:var(--wy-orange-light, #e79b3a);--wy-yellow:var(--wy-yellow-light, #adb140);--wy-green:var(--wy-green-light, #00a38d);--wy-teal:var(--wy-teal-light, #00a0a9);--wy-cyan:var(--wy-cyan-light, #0081a2);--wy-gray:var(--wy-gray-light, #76777a);--wy-code-text:var(--wy-code-text-light, #3b3b3b);--wy-code-variable:var(--wy-code-variable-light, #001080);--wy-code-operator:var(--wy-code-operator-light, #000000);--wy-code-prolog:var(--wy-code-prolog-light, #000080);--wy-code-comment:var(--wy-code-comment-light, #008000);--wy-code-builtin:var(--wy-code-builtin-light, #0070C1);--wy-code-number:var(--wy-code-number-light, #098658);--wy-code-inserted:var(--wy-code-inserted-light, #098658);--wy-code-constant:var(--wy-code-constant-light, #811F3F);--wy-code-hexcode:var(--wy-code-hexcode-light, #811F3F);--wy-code-regex:var(--wy-code-regex-light, #811F3F);--wy-code-char:var(--wy-code-char-light, #811F3F);--wy-code-tag:var(--wy-code-tag-light, #800000);--wy-code-attr-name:var(--wy-code-attr-name-light, #E50000);--wy-code-selector:var(--wy-code-selector-light, #E50000);--wy-code-property:var(--wy-code-property-light, #E50000);--wy-code-deleted:var(--wy-code-deleted-light, #A31515);--wy-code-string:var(--wy-code-string-light, #A31515);--wy-code-changed:var(--wy-code-changed-light, #0451A5);--wy-code-punctuation:var(--wy-code-punctuation-light, #000000);--wy-code-function:var(--wy-code-function-light, #0000FF);--wy-code-keyword:var(--wy-code-keyword-light, #AF00DB);--wy-code-class-name:var(--wy-code-class-name-light, #267F99)}:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-chat),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-comments),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-component),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-copilot),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-files),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-messenger),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-notification-toasts),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-notifications),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-posts),:host(:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light])),:host :is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]),::slotted(:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light])){color-scheme:dark;--wy-primary:var(--wy-primary-dark, #9bcbfa);--wy-on-primary:var(--wy-on-primary-dark, #003353);--wy-primary-container:var(--wy-primary-container-dark, #0d4a73);--wy-on-primary-container:var(--wy-on-primary-container-dark, #cee5ff);--wy-secondary:var(--wy-secondary-dark, #b9c8da);--wy-on-secondary:var(--wy-on-secondary-dark, #233240);--wy-secondary-container:var(--wy-secondary-container-dark, #3a4857);--wy-on-secondary-container:var(--wy-on-secondary-container-dark, #d5e4f7);--wy-tertiary:var(--wy-tertiary-dark, #cfc7a2);--wy-on-tertiary:var(--wy-on-tertiary-dark, #353117);--wy-tertiary-container:var(--wy-tertiary-container-dark, #4c472b);--wy-on-tertiary-container:var(--wy-on-tertiary-container-dark, #ebe3bd);--wy-error:var(--wy-error-dark, #ffb3ad);--wy-on-error:var(--wy-on-error-dark, #680009);--wy-error-container:var(--wy-error-container-dark, #930012);--wy-on-error-container:var(--wy-on-error-container-dark, #ffdad6);--wy-background:var(--wy-background-dark, #101418);--wy-on-background:var(--wy-on-background-dark, #e0e2e8);--wy-surface:var(--wy-surface-dark, #101418);--wy-on-surface:var(--wy-on-surface-dark, #e0e2e8);--wy-surface-variant:var(--wy-surface-variant-dark, #42474e);--wy-on-surface-variant:var(--wy-on-surface-variant-dark, #c2c7cf);--wy-outline:var(--wy-outline-dark, #8c9198);--wy-outline-variant:var(--wy-outline-variant-dark, #42474e);--wy-surface-container-highest:var(--wy-surface-container-highest-dark, #323539);--wy-surface-container-high:var(--wy-surface-container-high-dark, #272a2f);--wy-surface-container:var(--wy-surface-container-dark, #1c2024);--wy-surface-container-low:var(--wy-surface-container-low-dark, #181c20);--wy-surface-container-lowest:var(--wy-surface-container-lowest-dark, #0b0f12);--wy-surface-layer-highest:var(--wy-surface-layer-highest-dark, rgba(255, 255, 255, .1490196078));--wy-surface-layer-high:var(--wy-surface-layer-high-dark, rgba(255, 255, 255, .1019607843));--wy-surface-layer:var(--wy-surface-layer-dark, rgba(255, 255, 255, .0509803922));--wy-surface-layer-low:var(--wy-surface-layer-low-dark, rgba(0, 0, 0, .2509803922));--wy-surface-layer-lowest:var(--wy-surface-layer-lowest-dark, rgba(0, 0, 0, .5019607843));--wy-warning:var(--wy-warning-dark, #e5e972);--wy-on-warning:var(--wy-on-warning-dark, #484a00);--wy-warning-container:var(--wy-warning-container-dark, #787c07);--wy-on-warning-container:var(--wy-on-warning-container-dark, #f4f87e);--wy-highlight:var(--wy-highlight-dark, #003353);--wy-on-highlight:var(--wy-on-highlight-dark, #cee5ff);--wy-link:var(--wy-primary-dark, #9bcbfa);--wy-presence-active:var(--wy-green-dark, #00a38d);--wy-shade:var(--wy-shade-dark, rgba(0, 0, 0, .5));--wy-shade-invert:var(--wy-shade-invert-dark, rgba(255, 255, 255, .25));--wy-shade-opaque:var(--wy-shade-opaque-dark, grey);--wy-blue:var(--wy-blue-dark, #b2c5ff);--wy-indigo:var(--wy-indigo-dark, #9285de);--wy-purple:var(--wy-purple-dark, #e48fd2);--wy-pink:var(--wy-pink-dark, #f58bad);--wy-red:var(--wy-red-dark, #db726b);--wy-orange:var(--wy-orange-dark, #e79b3a);--wy-yellow:var(--wy-yellow-dark, #c9cd59);--wy-green:var(--wy-green-dark, #00a38d);--wy-teal:var(--wy-teal-dark, #00a0a9);--wy-cyan:var(--wy-cyan-dark, #009dc4);--wy-gray:var(--wy-gray-dark, #909194);--wy-code-text:var(--wy-code-text-dark, #cccccc);--wy-code-variable:var(--wy-code-variable-dark, #9CDCFE);--wy-code-operator:var(--wy-code-operator-dark, #d4d4d4);--wy-code-prolog:var(--wy-code-prolog-dark, #569CD6);--wy-code-comment:var(--wy-code-comment-dark, #6a9955);--wy-code-builtin:var(--wy-code-builtin-dark, #4fc1ff);--wy-code-number:var(--wy-code-number-dark, #b5cea8);--wy-code-inserted:var(--wy-code-inserted-dark, #b5cea8);--wy-code-constant:var(--wy-code-constant-dark, #646695);--wy-code-hexcode:var(--wy-code-hexcode-dark, #646695);--wy-code-regex:var(--wy-code-regex-dark, #d16969);--wy-code-char:var(--wy-code-char-dark, #d16969);--wy-code-tag:var(--wy-code-tag-dark, #569cd6);--wy-code-attr-name:var(--wy-code-attr-name-dark, #9cdcfe);--wy-code-selector:var(--wy-code-selector-dark, #9cdcfe);--wy-code-property:var(--wy-code-property-dark, #9cdcfe);--wy-code-deleted:var(--wy-code-deleted-dark, #ce9178);--wy-code-string:var(--wy-code-string-dark, #ce9178);--wy-code-changed:var(--wy-code-changed-dark, #569cd6);--wy-code-punctuation:var(--wy-code-punctuation-dark, #D4D4D4);--wy-code-function:var(--wy-code-function-dark, #569cd6);--wy-code-keyword:var(--wy-code-keyword-dark, #C586C0);--wy-code-class-name:var(--wy-code-class-name-dark, #4ec9b0)}@container style(--wy-color-scheme: dark){:not(.wy-light):not([part~=wy-light]) :where(wy-chat),:not(.wy-light):not([part~=wy-light]) :where(wy-comments),:not(.wy-light):not([part~=wy-light]) :where(wy-component),:not(.wy-light):not([part~=wy-light]) :where(wy-copilot),:not(.wy-light):not([part~=wy-light]) :where(wy-files),:not(.wy-light):not([part~=wy-light]) :where(wy-messenger),:not(.wy-light):not([part~=wy-light]) :where(wy-notification-toasts),:not(.wy-light):not([part~=wy-light]) :where(wy-notifications),:not(.wy-light):not([part~=wy-light]) :where(wy-posts),:host(:not(.wy-light):not([part~=wy-light])),:host :not(.wy-light):not([part~=wy-light]),::slotted(:not(.wy-light):not([part~=wy-light])){color-scheme:dark;--wy-primary:var(--wy-primary-dark, #9bcbfa);--wy-on-primary:var(--wy-on-primary-dark, #003353);--wy-primary-container:var(--wy-primary-container-dark, #0d4a73);--wy-on-primary-container:var(--wy-on-primary-container-dark, #cee5ff);--wy-secondary:var(--wy-secondary-dark, #b9c8da);--wy-on-secondary:var(--wy-on-secondary-dark, #233240);--wy-secondary-container:var(--wy-secondary-container-dark, #3a4857);--wy-on-secondary-container:var(--wy-on-secondary-container-dark, #d5e4f7);--wy-tertiary:var(--wy-tertiary-dark, #cfc7a2);--wy-on-tertiary:var(--wy-on-tertiary-dark, #353117);--wy-tertiary-container:var(--wy-tertiary-container-dark, #4c472b);--wy-on-tertiary-container:var(--wy-on-tertiary-container-dark, #ebe3bd);--wy-error:var(--wy-error-dark, #ffb3ad);--wy-on-error:var(--wy-on-error-dark, #680009);--wy-error-container:var(--wy-error-container-dark, #930012);--wy-on-error-container:var(--wy-on-error-container-dark, #ffdad6);--wy-background:var(--wy-background-dark, #101418);--wy-on-background:var(--wy-on-background-dark, #e0e2e8);--wy-surface:var(--wy-surface-dark, #101418);--wy-on-surface:var(--wy-on-surface-dark, #e0e2e8);--wy-surface-variant:var(--wy-surface-variant-dark, #42474e);--wy-on-surface-variant:var(--wy-on-surface-variant-dark, #c2c7cf);--wy-outline:var(--wy-outline-dark, #8c9198);--wy-outline-variant:var(--wy-outline-variant-dark, #42474e);--wy-surface-container-highest:var(--wy-surface-container-highest-dark, #323539);--wy-surface-container-high:var(--wy-surface-container-high-dark, #272a2f);--wy-surface-container:var(--wy-surface-container-dark, #1c2024);--wy-surface-container-low:var(--wy-surface-container-low-dark, #181c20);--wy-surface-container-lowest:var(--wy-surface-container-lowest-dark, #0b0f12);--wy-surface-layer-highest:var(--wy-surface-layer-highest-dark, rgba(255, 255, 255, .1490196078));--wy-surface-layer-high:var(--wy-surface-layer-high-dark, rgba(255, 255, 255, .1019607843));--wy-surface-layer:var(--wy-surface-layer-dark, rgba(255, 255, 255, .0509803922));--wy-surface-layer-low:var(--wy-surface-layer-low-dark, rgba(0, 0, 0, .2509803922));--wy-surface-layer-lowest:var(--wy-surface-layer-lowest-dark, rgba(0, 0, 0, .5019607843));--wy-warning:var(--wy-warning-dark, #e5e972);--wy-on-warning:var(--wy-on-warning-dark, #484a00);--wy-warning-container:var(--wy-warning-container-dark, #787c07);--wy-on-warning-container:var(--wy-on-warning-container-dark, #f4f87e);--wy-highlight:var(--wy-highlight-dark, #003353);--wy-on-highlight:var(--wy-on-highlight-dark, #cee5ff);--wy-link:var(--wy-primary-dark, #9bcbfa);--wy-presence-active:var(--wy-green-dark, #00a38d);--wy-shade:var(--wy-shade-dark, rgba(0, 0, 0, .5));--wy-shade-invert:var(--wy-shade-invert-dark, rgba(255, 255, 255, .25));--wy-shade-opaque:var(--wy-shade-opaque-dark, grey);--wy-blue:var(--wy-blue-dark, #b2c5ff);--wy-indigo:var(--wy-indigo-dark, #9285de);--wy-purple:var(--wy-purple-dark, #e48fd2);--wy-pink:var(--wy-pink-dark, #f58bad);--wy-red:var(--wy-red-dark, #db726b);--wy-orange:var(--wy-orange-dark, #e79b3a);--wy-yellow:var(--wy-yellow-dark, #c9cd59);--wy-green:var(--wy-green-dark, #00a38d);--wy-teal:var(--wy-teal-dark, #00a0a9);--wy-cyan:var(--wy-cyan-dark, #009dc4);--wy-gray:var(--wy-gray-dark, #909194);--wy-code-text:var(--wy-code-text-dark, #cccccc);--wy-code-variable:var(--wy-code-variable-dark, #9CDCFE);--wy-code-operator:var(--wy-code-operator-dark, #d4d4d4);--wy-code-prolog:var(--wy-code-prolog-dark, #569CD6);--wy-code-comment:var(--wy-code-comment-dark, #6a9955);--wy-code-builtin:var(--wy-code-builtin-dark, #4fc1ff);--wy-code-number:var(--wy-code-number-dark, #b5cea8);--wy-code-inserted:var(--wy-code-inserted-dark, #b5cea8);--wy-code-constant:var(--wy-code-constant-dark, #646695);--wy-code-hexcode:var(--wy-code-hexcode-dark, #646695);--wy-code-regex:var(--wy-code-regex-dark, #d16969);--wy-code-char:var(--wy-code-char-dark, #d16969);--wy-code-tag:var(--wy-code-tag-dark, #569cd6);--wy-code-attr-name:var(--wy-code-attr-name-dark, #9cdcfe);--wy-code-selector:var(--wy-code-selector-dark, #9cdcfe);--wy-code-property:var(--wy-code-property-dark, #9cdcfe);--wy-code-deleted:var(--wy-code-deleted-dark, #ce9178);--wy-code-string:var(--wy-code-string-dark, #ce9178);--wy-code-changed:var(--wy-code-changed-dark, #569cd6);--wy-code-punctuation:var(--wy-code-punctuation-dark, #D4D4D4);--wy-code-function:var(--wy-code-function-dark, #569cd6);--wy-code-keyword:var(--wy-code-keyword-dark, #C586C0);--wy-code-class-name:var(--wy-code-class-name-dark, #4ec9b0)}}`, a0 = j`@property --wy-component-color{syntax:\"<color>\";inherits:true;initial-value:currentColor}@property --wy-component-background-color{syntax:\"<color>\";inherits:true;initial-value:rgba(0,0,0,0)}`, s0 = /* @__PURE__ */ a((n) => {
  var t;
  return t = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...i) {
      super(...i), n0([a0, se]);
    }
  }, a(t, "WeavyStyles"), t;
}, "WeavyStylesMixin"), o0 = /* @__PURE__ */ a((n) => {
  var t, e;
  return e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s);
      O(this, t);
      this.version = ae.version, this.whenUrl().then(() => {
        this.isDestroyed || this.checkVersion();
      });
    }
    /**
     * Checks the version of the Weavy Context against the Weavy Environment version.
     *
     */
    async checkVersion() {
      return y(this, t) || _(this, t, (async () => {
        await this.whenUrl(), this.networkStateIsPending = !0;
        let s;
        try {
          if (s = await fetch(new URL("/version", this.url), await this.fetchOptions({}, !1)), !s.ok)
            throw new Error(`Could not verify environment version. ${s.status} ${s.statusText}`, {
              cause: s.status
            });
          this.networkStateIsPending = !1, this.serverState = "ok";
        } catch (c) {
          throw this.networkStateIsPending = !1, this.serverState = "unreachable", new Error("Error checking Weavy version: " + c.toString(), { cause: c.cause });
        }
        const o = await s.text();
        if (!this.version || !o || this.version !== o)
          try {
            const c = this.version.split(".").slice(0, 2), l = o.split(".").slice(0, 2);
            if (c[0] !== l[0])
              throw new Error("Major version mismatch", {
                cause: "major"
              });
            if (c[1] !== l[1])
              throw new Error("Minor version mismatch", {
                cause: "minor"
              });
            if (c[2] !== l[2])
              throw new Error("Patch version mismatch", {
                cause: "patch"
              });
          } catch (c) {
            throw new Error(
              `Weavy version mismatch! ${ae.sourceName}@${this.version} ≠ ${this.url?.hostname}@${o} - This will likely cause errors!`,
              {
                cause: {
                  mismatch: c.cause,
                  client: {
                    name: ae.sourceName,
                    version: this.version
                  },
                  environment: {
                    name: this.url?.hostname,
                    version: o
                  }
                }
              }
            );
          } finally {
            _(this, t, void 0);
          }
        else
          console.info(`Weavy version ${this.version} ☑️`);
        return {
          client: {
            name: ae.sourceName,
            version: this.version
          },
          environment: {
            name: this.url?.hostname,
            version: o
          }
        };
      })()), await y(this, t);
    }
  }, t = new WeakMap(), a(e, "WeavyVersion"), e;
}, "WeavyVersionMixin");
var ts;
let _m = (ts = class extends Event {
  constructor(t, e, i, r) {
    super("context-request", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e, this.callback = i, this.subscribe = r ?? !1;
  }
}, a(ts, "s"), ts);
var es;
let oi = (es = class {
  constructor(t, e, i, r) {
    if (this.subscribe = !1, this.provided = !1, this.value = void 0, this.t = (s, o) => {
      this.unsubscribe && (this.unsubscribe !== o && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = s, this.host.requestUpdate(), this.provided && !this.subscribe || (this.provided = !0, this.callback && this.callback(s, o)), this.unsubscribe = o;
    }, this.host = t, e.context !== void 0) {
      const s = e;
      this.context = s.context, this.callback = s.callback, this.subscribe = s.subscribe ?? !1;
    } else this.context = e, this.callback = i, this.subscribe = r ?? !1;
    this.host.addController(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.host.dispatchEvent(new _m(this.context, this.host, this.t, this.subscribe));
  }
}, a(es, "s"), es);
var is;
let c0 = (is = class {
  get value() {
    return this.o;
  }
  set value(t) {
    this.setValue(t);
  }
  setValue(t, e = !1) {
    const i = e || !Object.is(t, this.o);
    this.o = t, i && this.updateObservers();
  }
  constructor(t) {
    this.subscriptions = /* @__PURE__ */ new Map(), this.updateObservers = () => {
      for (const [e, { disposer: i }] of this.subscriptions) e(this.o, i);
    }, t !== void 0 && (this.value = t);
  }
  addCallback(t, e, i) {
    if (!i) return void t(this.value);
    this.subscriptions.has(t) || this.subscriptions.set(t, { disposer: /* @__PURE__ */ a(() => {
      this.subscriptions.delete(t);
    }, "disposer"), consumerHost: e });
    const { disposer: r } = this.subscriptions.get(t);
    t(this.value, r);
  }
  clearCallbacks() {
    this.subscriptions.clear();
  }
}, a(is, "s"), is);
var rs;
let l0 = (rs = class extends Event {
  constructor(t, e) {
    super("context-provider", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e;
  }
}, a(rs, "e"), rs);
var ns;
let $p = (ns = class extends c0 {
  constructor(t, e, i) {
    super(e.context !== void 0 ? e.initialValue : i), this.onContextRequest = (r) => {
      if (r.context !== this.context) return;
      const s = r.contextTarget ?? r.composedPath()[0];
      s !== this.host && (r.stopPropagation(), this.addCallback(r.callback, s, r.subscribe));
    }, this.onProviderRequest = (r) => {
      if (r.context !== this.context || (r.contextTarget ?? r.composedPath()[0]) === this.host) return;
      const s = /* @__PURE__ */ new Set();
      for (const [o, { consumerHost: c }] of this.subscriptions) s.has(o) || (s.add(o), c.dispatchEvent(new _m(this.context, c, o, !0)));
      r.stopPropagation();
    }, this.host = t, e.context !== void 0 ? this.context = e.context : this.context = e, this.attachListeners(), this.host.addController?.(this);
  }
  attachListeners() {
    this.host.addEventListener("context-request", this.onContextRequest), this.host.addEventListener("context-provider", this.onProviderRequest);
  }
  hostConnected() {
    this.host.dispatchEvent(new l0(this.context, this.host));
  }
}, a(ns, "i"), ns);
function Yr({ context: n }) {
  return (t, e) => {
    const i = /* @__PURE__ */ new WeakMap();
    if (typeof e == "object") return { get() {
      return t.get.call(this);
    }, set(r) {
      return i.get(this).setValue(r), t.set.call(this, r);
    }, init(r) {
      return i.set(this, new $p(this, { context: n, initialValue: r })), r;
    } };
    {
      t.constructor.addInitializer(((o) => {
        i.set(o, new $p(o, { context: n }));
      }));
      const r = Object.getOwnPropertyDescriptor(t, e);
      let s;
      if (r === void 0) {
        const o = /* @__PURE__ */ new WeakMap();
        s = { get() {
          return o.get(this);
        }, set(c) {
          i.get(this).setValue(c), o.set(this, c);
        }, configurable: !0, enumerable: !0 };
      } else {
        const o = r.set;
        s = { ...r, set(c) {
          i.get(this).setValue(c), o?.call(this, c);
        } };
      }
      return void Object.defineProperty(t, e, s);
    }
  };
}
a(Yr, "e$4");
function be({ context: n, subscribe: t }) {
  return (e, i) => {
    typeof i == "object" ? i.addInitializer((function() {
      new oi(this, { context: n, callback: /* @__PURE__ */ a((r) => {
        e.set.call(this, r);
      }, "callback"), subscribe: t });
    })) : e.constructor.addInitializer(((r) => {
      new oi(r, { context: n, callback: /* @__PURE__ */ a((s) => {
        r[i] = s;
      }, "callback"), subscribe: t });
    }));
  };
}
a(be, "c$2");
const iw = class iw extends Event {
  /**
   *
   * @param context the context key to request
   * @param contextTarget the original context target of the requester
   * @param callback the callback that should be invoked when the context with the specified key is available
   * @param subscribe when, true indicates we want to subscribe to future updates
   */
  constructor(t, e, i, r) {
    super("context-request", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e, this.callback = i, this.subscribe = r ?? !1;
  }
};
a(iw, "ContextRequestEvent");
let kp = iw;
const rw = class rw extends Event {
  /**
   *
   * @param context the context which this provider can provide
   * @param contextTarget the original context target of the provider
   */
  constructor(t, e) {
    super("context-provider", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e;
  }
};
a(rw, "ContextProviderEvent");
let Pp = rw;
const nw = class nw extends $p {
  constructor(t, e, i) {
    e.context !== void 0 ? super(t, e) : super(t, e, i), e.context !== void 0 ? this._context = e.context : this._context = e, this.isAttached = !0, this.host instanceof it || this.dispatchWhenConnected();
  }
  dispatchWhenConnected() {
    this.isAttached && (this.host.isConnected ? this.host.dispatchEvent(new Pp(this._context, this.host)) : requestAnimationFrame(() => this.dispatchWhenConnected()));
  }
  detachListeners() {
    this.isAttached = !1, this.host.removeEventListener("context-request", this.onContextRequest), this.host.removeEventListener("context-provider", this.onProviderRequest);
  }
};
a(nw, "WyContextProvider");
let Yd = nw;
const he = Symbol.for("weavy-client");
function d0(n, t) {
  return Pe(), new Yd(n, { context: he, initialValue: t });
}
a(d0, "createWeavyContextProvider");
const cl = Xp() ? d0(document.documentElement) : void 0, h0 = /* @__PURE__ */ a((n) => {
  var t, e;
  return e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s);
      // CONTEXT PROVIDER
      // SHOULD BE APPLIED LAST TO ENSURE EVERYTHING IS SET BEFORE CONTEXT GETS PROVIDED
      O(this, t);
      this.host !== document.documentElement ? (cl?.detachListeners(), _(this, t, new Yd(this.host, {
        context: he,
        initialValue: this
      }))) : cl?.setValue(this);
    }
    updateContext() {
      this.host !== document.documentElement ? y(this, t)?.updateObservers() : cl?.updateObservers();
    }
    destroy() {
      super.destroy(), this.host !== document.documentElement ? y(this, t)?.detachListeners() : cl?.value === this && cl?.setValue(void 0);
    }
  }, t = new WeakMap(), a(e, "WeavyContextProvider"), e;
}, "WeavyContextProviderMixin");
var Ql, Gl, Gi, as;
const we = class we {
  // CONSTRUCTOR
  constructor(t) {
    // Promises
    // whenUrl
    O(this, Ql);
    O(this, Gl);
    // Reactive options
    O(this, Gi);
    O(this, as);
    this.weavySid = fl(), this.weavyId = `${we.sourceName}#${this.weavySid}`, this.cloudFilePickerUrl = we.defaults.cloudFilePickerUrl, this.configurationTimeout = we.defaults.configurationTimeout, this.disableEnvironmentImports = we.defaults.disableEnvironmentImports, this.gcTime = we.defaults.gcTime, this.scrollBehavior = we.defaults.scrollBehavior, this.staleTime = we.defaults.staleTime, this.tokenFactoryRetryDelay = we.defaults.tokenFactoryRetryDelay, this.tokenFactoryTimeout = we.defaults.tokenFactoryTimeout, _(this, Gl, new Promise((i) => {
      _(this, Ql, i);
    })), _(this, as, !1), console.info(`${we.sourceName}@${we.version} #${this.weavySid}`), Pe(), this.host = document.documentElement;
    const e = {};
    for (const i in t) {
      const r = i;
      t[r] !== void 0 && Object.assign(e, { [r]: t[r] });
    }
    e?.host && (this.host = e.host, delete e.host), e && Object.assign(this, e);
  }
  async whenUrl() {
    await y(this, Gl);
  }
  /**
   * The URL to the weavy environment.
   */
  get url() {
    return y(this, Gi);
  }
  set url(t) {
    var e;
    if (this.isDestroyed)
      throw new Ut();
    try {
      if (typeof t == "string")
        t && _(this, Gi, new URL(t, window.location.toString()));
      else if (t instanceof URL)
        _(this, Gi, t || void 0);
      else if (t == null)
        _(this, Gi, void 0);
      else
        throw new Error();
    } catch {
      throw new TypeError("Invalid url");
    }
    t && !this.disableEnvironmentImports && globalThis.WEAVY_IMPORT_URL === void 0 && (globalThis.WEAVY_IMPORT_URL = new URL(
      "./uikit-web/",
      t
    ).href), y(this, Gi) && ((e = y(this, Ql)) == null || e.call(this, y(this, Gi)));
  }
  /**
   * Prefix to use for caches.
   */
  get cachePrefix() {
    return `${we.version}:${this.url}`;
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async reset() {
    console.info(this.weavyId, "is reset");
  }
  get isDestroyed() {
    return y(this, as);
  }
  destroy() {
    _(this, as, !0), console.info(this.weavyId, "was destroyed");
  }
};
Ql = new WeakMap(), Gl = new WeakMap(), Gi = new WeakMap(), as = new WeakMap(), a(we, "WeavyClient"), we.version = "30.3.0", we.sourceName = "@weavy/uikit-web", we.defaults = {
  // StrictWeavyOptions
  cloudFilePickerUrl: "https://filebrowser.weavy.io/v14/",
  configurationTimeout: 5e3,
  disableEnvironmentImports: !1,
  gcTime: 1e3 * 60 * 60 * 24,
  // 24h,
  locale: hm,
  scrollBehavior: "auto",
  staleTime: 1e3 * 1,
  // 1s
  tokenFactoryRetryDelay: 2e3,
  tokenFactoryTimeout: 2e4,
  // WeavyComponentSettingProps
  annotations: "buttons-inline",
  enterToSend: "auto",
  reactions: "😍 😎 😉 😜 👍"
};
let ae = we;
const aw = class aw extends h0(
  Q1(
    W1(
      G1(
        U1(
          Lg(o0(K1(s0(Og(ae)))))
        )
      )
    )
  )
) {
};
a(aw, "Weavy");
let Gt = aw;
const cy = Symbol.for("weavy-app"), Sm = Symbol.for("weavy-context-id"), Mm = Symbol.for("weavy-data-blobs");
var S = /* @__PURE__ */ ((n) => (n.Attachments = "attachments", n.CloudFiles = "cloud_files", n.ContextData = "context_data", n.Comments = "comments", n.Embeds = "embeds", n.GoogleMeet = "google_meet", n.Meetings = "meetings", n.Mentions = "mentions", n.MicrosoftTeams = "microsoft_teams", n.Polls = "polls", n.Previews = "previews", n.Reactions = "reactions", n.Receipts = "receipts", n.Thumbnails = "thumbnails", n.Typing = "typing", n.Versions = "versions", n.WebDAV = "web_dav", n.ZoomMeetings = "zoom_meetings", n))(S || {});
const bh = Symbol.for("weavy-features");
var Rr, mn, Mi;
const mh = class mh {
  /**
   * Creates a feature policy. All features are initially enabled unless `defaultFeatures` is specified.
   *
   * @constructor
   * @param componentFeatures - Available features.
   */
  constructor(t, e) {
    O(this, Rr);
    O(this, mn);
    O(this, Mi);
    _(this, Rr, Object.keys(t)), _(this, mn, Object.entries(t).reduce(
      (i, [r, s]) => (s && i.push(r), i),
      []
    )), _(this, Mi, e ?? y(this, mn));
  }
  features() {
    return y(this, Rr);
  }
  supportedFeature(...t) {
    return t.every((e) => y(this, Rr).includes(e));
  }
  allowedFeatures() {
    return y(this, Mi);
  }
  allowsFeature(...t) {
    return t.every((e) => this.supportedFeature(e) ? y(this, Mi).includes(e) : !1);
  }
  allowsAnyFeature(...t) {
    return t.some((e) => this.supportedFeature(e) ? y(this, Mi).includes(e) : !1);
  }
  /**
   * Sets the allowed features.
   * @param allowedFeatures - Space separated string with features that will be enabled. Empty string will disable all features. `null` or `undefined` will enable all features.
   */
  setAllowedFeatures(t) {
    return _(this, Mi, typeof t == "string" ? Am(t, y(this, Rr)) : y(this, mn)), y(this, Mi);
  }
  immutable() {
    const t = ly(y(this, Rr), y(this, mn));
    return new mh(t, y(this, Mi));
  }
};
Rr = new WeakMap(), mn = new WeakMap(), Mi = new WeakMap(), a(mh, "ComponentFeatures");
let le = mh;
function Am(n, t) {
  return n.split(" ").filter((e) => {
    if (e) {
      if (t.includes(e))
        return !0;
      console.warn("Unknown feature provided:", e);
    }
    return !1;
  });
}
a(Am, "featureListFromString");
function ly(n, t) {
  return t ??= n, Object.fromEntries(
    n.map((e) => [e, t.includes(e)])
  );
}
a(ly, "featureConfigFromList");
const _p = Object.values(S), Em = Symbol.for("weavy-link");
var Zl;
const sw = class sw {
  // PROPERTY INIT
  constructor(t) {
    O(this, Zl);
    this.enterToSend = ae.defaults.enterToSend, this.reactions = ae.defaults.reactions, this.annotations = ae.defaults.annotations, _(this, Zl, t), Object.keys(this).forEach((i) => {
      i in t && Object.assign(this, { [i]: t[i] });
    });
  }
  /**
   * Provides a reference to the host.
   */
  get component() {
    return y(this, Zl);
  }
};
Zl = new WeakMap(), a(sw, "WeavyComponentSettings");
let Xd = sw;
const Rm = Symbol.for("weavy-component-settings"), xh = Symbol.for("weavy-user"), ow = class ow {
  constructor(t, e, i, r, s) {
    if (this.subscribe = !1, this.provided = !1, this.value = void 0, this._callback = (o, c) => {
      this.unsubscribe && (this.unsubscribe !== c && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = o, this.host.requestUpdate(), (!this.provided || this.subscribe) && (this.provided = !0, this.callback && this.callback(o, c)), this.unsubscribe = c;
    }, this.host = t, e.context !== void 0) {
      const o = e;
      this.context = o.context, this.callback = o.callback, this.subscribe = o.subscribe ?? !1, this.ref = o.ref ?? t;
    } else
      this.context = e, this.callback = i, this.subscribe = r ?? !1, this.ref = s ?? t;
    this.host.addController?.(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.ref.dispatchEvent(
      new kp(
        this.context,
        this.host,
        this._callback,
        this.subscribe
      )
    );
  }
};
a(ow, "ContextConsumer");
let Sp = ow;
const cw = class cw {
  /**
   * @param host - The host element
   * @param context - The Context to use. Should be constructed using createContext().
   */
  constructor(t, e, i) {
    this.whenRef = new Promise((r) => this.resolveRef = r), t.addController(this), this.host = t, this.setRef(i), this.setContext(e);
  }
  /**
   * The DOM connected element that can subscribe to a context
   */
  get ref() {
    return this._ref;
  }
  set ref(t) {
    this._ref = t, t && this.resolveRef?.(t);
  }
  /** 
   * Set the DOM connected element that can subscribe to a context.
   * Wrapper function for React linting compatibility. 
   */
  setRef(t) {
    this.ref = t;
  }
  async setContext(t) {
    this.whenContext = new Promise((i) => this.resolveContext = i);
    const e = await this.whenRef;
    this.context = new Sp(this.host, {
      context: t,
      subscribe: !0,
      callback: /* @__PURE__ */ a((i, r) => {
        this.resolveContext?.(i), this.host.requestUpdate();
      }, "callback"),
      ref: e
    }), await nm(e), this.context.dispatchRequest();
  }
  hostUpdate() {
    this.context?.value && this.resolveContext?.(this.context.value);
  }
};
a(cw, "ContextController");
let af = cw;
var st = /* @__PURE__ */ ((n) => (n.Chat = "d65dd4bc-418e-403c-9f56-f9cf4da931ed", n.Comments = "88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd", n.Files = "523edd88-4bbf-4547-b60f-2859a6d2ddc1", n.Posts = "5ebfa152-de85-48da-82dd-30a1b560c313", n.ChatRoom = "edb400ac-839b-45a7-b2a8-6a01820d1c44", n.PrivateChat = "7e14f418-8f15-46f4-b182-f619b671e470", n.AgentChat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", n))(st || {}), yi = /* @__PURE__ */ ((n) => (n.Chat = "chat", n.Comments = "comments", n.Files = "files", n.Posts = "posts", n.ChatRoom = "chat_room", n.PrivateChat = "private_chat", n.AgentChat = "agent_chat", n))(yi || {}), Tm = /* @__PURE__ */ ((n) => (n["d65dd4bc-418e-403c-9f56-f9cf4da931ed"] = "chat", n["88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd"] = "comments", n["523edd88-4bbf-4547-b60f-2859a6d2ddc1"] = "files", n["5ebfa152-de85-48da-82dd-30a1b560c313"] = "posts", n["edb400ac-839b-45a7-b2a8-6a01820d1c44"] = "chat_room", n["7e14f418-8f15-46f4-b182-f619b671e470"] = "private_chat", n["2352a1c6-abc6-420e-8b85-ca7d5aed8779"] = "agent_chat", n))(Tm || {}), Lm = /* @__PURE__ */ ((n) => (n.chat = "d65dd4bc-418e-403c-9f56-f9cf4da931ed", n.comments = "88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd", n.files = "523edd88-4bbf-4547-b60f-2859a6d2ddc1", n.posts = "5ebfa152-de85-48da-82dd-30a1b560c313", n.chat_room = "edb400ac-839b-45a7-b2a8-6a01820d1c44", n.private_chat = "7e14f418-8f15-46f4-b182-f619b671e470", n.agent_chat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", n))(Lm || {}), Om = /* @__PURE__ */ ((n) => (n["2352a1c6-abc6-420e-8b85-ca7d5aed8779"] = "agent_chat", n))(Om || {}), zm = /* @__PURE__ */ ((n) => (n.agent_chat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", n))(zm || {}), br = /* @__PURE__ */ ((n) => (n.None = "none", n.Read = "read", n.Write = "write", n.Admin = "admin", n))(br || {}), _n = /* @__PURE__ */ ((n) => (n.List = "list", n.Read = "read", n.Create = "create", n.Update = "update", n.Delete = "delete", n.Admin = "admin", n))(_n || {}), Ae = /* @__PURE__ */ ((n) => (n.App = "app", n.File = "file", n.Message = "message", n.User = "user", n.Comment = "comment", n.Post = "post", n))(Ae || {});
function hd(n, t, e, i, r, s = "GET") {
  return {
    // eslint-disable-next-line @tanstack/query/exhaustive-deps
    queryKey: t,
    queryFn: /* @__PURE__ */ a(async () => {
      const o = await n.fetch(e || "/api/" + t.join("/"), { method: s, body: r });
      if (o.ok)
        return await o.json();
      throw new Error(`Error calling ${e || "/api/" + t.join("/")}`);
    }, "queryFn"),
    ...i
  };
}
a(hd, "getApiOptions");
const Im = /* @__PURE__ */ a((n) => (t, e) => {
  e !== void 0 ? e.addInitializer((() => {
    customElements.define(n, t);
  })) : customElements.define(n, t);
}, "t$3");
const u0 = { attribute: !0, type: String, converter: _1, reflect: !1, hasChanged: P1 }, p0 = /* @__PURE__ */ a((n = u0, t, e) => {
  const { kind: i, metadata: r } = e;
  let s = globalThis.litPropertyMetadata.get(r);
  if (s === void 0 && globalThis.litPropertyMetadata.set(r, s = /* @__PURE__ */ new Map()), i === "setter" && ((n = Object.create(n)).wrapped = !0), s.set(e.name, n), i === "accessor") {
    const { name: o } = e;
    return { set(c) {
      const l = t.get.call(this);
      t.set.call(this, c), this.requestUpdate(o, l, n);
    }, init(c) {
      return c !== void 0 && this.C(o, void 0, n, c), c;
    } };
  }
  if (i === "setter") {
    const { name: o } = e;
    return function(c) {
      const l = this[o];
      t.call(this, c), this.requestUpdate(o, l, n);
    };
  }
  throw Error("Unsupported decorator location: " + i);
}, "r$3");
function u(n) {
  return (t, e) => typeof e == "object" ? p0(n, t, e) : ((i, r, s) => {
    const o = r.hasOwnProperty(s);
    return r.constructor.createProperty(s, i), o ? Object.getOwnPropertyDescriptor(r, s) : void 0;
  })(n, t, e);
}
a(u, "n$3");
function D(n) {
  return u({ ...n, state: !0, attribute: !1 });
}
a(D, "r$2");
const y0 = /* @__PURE__ */ a((n, t, e) => (e.configurable = !0, e.enumerable = !0, Reflect.decorate && typeof t != "object" && Object.defineProperty(n, t, e), e), "e$3");
function Kc(n) {
  return (t, e) => {
    const { slot: i, selector: r } = n ?? {}, s = "slot" + (i ? `[name=${i}]` : ":not([name])");
    return y0(t, e, { get() {
      const o = this.renderRoot?.querySelector(s), c = o?.assignedElements(n) ?? [];
      return r === void 0 ? c : c.filter(((l) => l.matches(r)));
    } });
  };
}
a(Kc, "o$6");
const lw = class lw {
  get result() {
    return this._result && this.observer ? this.observer.trackResult(this._result) : { isPending: !0 };
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenQueryClient = new Promise((e) => this.resolveQueryClient = e), this.setContext();
  }
  async setContext() {
    await yr(this.host), this.context = new oi(this.host, {
      context: he,
      subscribe: !0,
      callback: /* @__PURE__ */ a((t) => {
        t && (this.resolveContext?.(t), this.queryClient = t.queryClient, this.resolveQueryClient?.(t.queryClient));
      }, "callback")
    });
  }
  async trackQuery(t, e = !0) {
    this.observerUnsubscribe?.();
    const i = await this.whenQueryClient;
    if (!i)
      throw new Error("No QueryClient provided");
    const r = new gm(i, t);
    this.observer = r, this.observerSubscribe(e);
  }
  observerSubscribe(t = !0) {
    if (this.queryClient && this.observer) {
      t ? this._result = this.observer.getOptimisticResult(this.observer.options) : this._result = this.observer.getCurrentResult(), this.observerUnsubscribe = this.observer.subscribe(() => {
        if (this.observer) {
          const i = dd(this.result, this.observer.getCurrentResult());
          i !== this._result && (this._result = i, this.host.requestUpdate());
        }
      }), this.observer.updateResult(), this.host.requestUpdate();
      let e;
      t ? e = this.observer.fetchOptimistic(this.observer.options) : e = this.queryClient.getQueryCache().get(this.observer.options.queryHash)?.promise, e?.catch(() => {
      }).finally(() => {
        this.observer?.updateResult();
      });
    }
  }
  untrackQuery() {
    this.observerUnsubscribe?.(), this.observerUnsubscribe = void 0, this._result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    this.observerUnsubscribe?.();
  }
};
a(lw, "QueryController");
let qe = lw;
function Mp(n) {
  return n.signal instanceof AbortSignal || typeof n.abort == "function";
}
a(Mp, "hasAbort");
const dw = class dw {
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenObserver = new Promise((e) => this.resolveObserver = e), this.setContext();
  }
  async setContext() {
    await yr(this.host), this.context = new oi(this.host, { context: he, subscribe: !0 });
  }
  hostUpdate() {
    this.context?.value && this.resolveContext?.();
  }
  async trackMutation(t, e) {
    if (e || (await this.whenContext, e = this.context?.value?.queryClient), !e)
      throw new Error("No QueryClient provided");
    return this.observerUnsubscribe?.(), this.observer && (this.whenObserver = new Promise((i) => this.resolveObserver = i)), this.observer = new Mt(e, { ...t }), this.observerSubscribe(), this.resolveObserver?.(this.observer), this.observer;
  }
  observerSubscribe() {
    this.observer && (this.result = this.observer.getCurrentResult(), this.observerUnsubscribe ??= this.observer.subscribe(() => {
      if (this.observer) {
        const t = dd(this.result, this.observer.getCurrentResult());
        this.result !== t && (this.result = t, this.host.requestUpdate());
      }
    }), this.host.requestUpdate());
  }
  untrackMutation() {
    this.observerUnsubscribe?.(), this.observerUnsubscribe = void 0, this.result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  async mutate(t, e) {
    const i = await this.whenObserver, r = new AbortController();
    return i.mutate(
      {
        ...t,
        signal: r.signal,
        abort: r.abort.bind(r)
      },
      e
    );
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    this.observerUnsubscribe?.();
  }
};
a(dw, "MutationController");
let ti = dw;
function Fm(n) {
  if (n)
    return n.match(/^[0-9]+$/) ? parseInt(n) : n;
}
a(Fm, "toIntOrString");
const Ce = [];
for (let n = 0; n < 256; ++n)
  Ce.push((n + 256).toString(16).slice(1));
function w0(n, t = 0) {
  return (Ce[n[t + 0]] + Ce[n[t + 1]] + Ce[n[t + 2]] + Ce[n[t + 3]] + "-" + Ce[n[t + 4]] + Ce[n[t + 5]] + "-" + Ce[n[t + 6]] + Ce[n[t + 7]] + "-" + Ce[n[t + 8]] + Ce[n[t + 9]] + "-" + Ce[n[t + 10]] + Ce[n[t + 11]] + Ce[n[t + 12]] + Ce[n[t + 13]] + Ce[n[t + 14]] + Ce[n[t + 15]]).toLowerCase();
}
a(w0, "unsafeStringify");
let Du;
const f0 = new Uint8Array(16);
function m0() {
  if (!Du) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Du = crypto.getRandomValues.bind(crypto);
  }
  return Du(f0);
}
a(m0, "rng");
const v0 = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), sf = { randomUUID: v0 };
function g0(n, t, e) {
  n = n || {};
  const i = n.random ?? n.rng?.() ?? m0();
  if (i.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, w0(i);
}
a(g0, "_v4");
function pl(n, t, e) {
  return sf.randomUUID && !n ? sf.randomUUID() : g0(n);
}
a(pl, "v4");
function b0(n) {
  let t;
  if (n instanceof URL)
    t = { type: "url", item: n };
  else if (n instanceof File)
    t = { type: "file", item: n };
  else if (n instanceof Blob)
    t = {
      type: "file",
      item: new File([n], `${pl()}`, { type: n.type })
    };
  else if (typeof n == "string")
    t = {
      type: "file",
      item: new File([n], `${pl()}.data.txt`, { type: "text/plain;charset=UTF-8" })
    };
  else if (E1(n) || Yu(n))
    try {
      const e = Yu(n) ? n.toJSON() : JSON.stringify(n, B1(), 2);
      t = {
        type: "file",
        item: new File([e], `${pl()}.json.txt`, { type: "text/plain;charset=UTF-8" })
      };
    } catch (e) {
      console.error("Could not serialize context data to JSON.", e);
    }
  return t;
}
a(b0, "getContextDataRef");
const Ch = /* @__PURE__ */ a((n, t = 3) => {
  const e = [" B", " KB", " MB", " GB", " TB", " PB", " EB", " ZB", " YB"];
  let i = n, r = 0;
  for (; r < e.length - 1 && i >= 1024; )
    i = 100 * i / 1024 / 100, r++;
  return i.toLocaleString(void 0, { maximumSignificantDigits: t }) + e[r];
}, "fileSizeAsString");
function di(n) {
  return n.lastIndexOf(".") === -1 ? "." : (n.substring(n.lastIndexOf("."), n.length) || n).toLowerCase();
}
a(di, "getExtension");
function Dm(n) {
  switch (n) {
    case ".aac":
    case ".aif":
    case ".aiff":
    case ".au":
    case ".gsm":
    case ".m4a":
    case ".mid":
    case ".midi":
    case ".mka":
    case ".mp3":
    case ".oga":
    case ".ogg":
    case ".ra":
    case ".ram":
    case ".snd":
    case ".spx":
    case ".wav":
    case ".wma":
      return !0;
    default:
      return !1;
  }
}
a(Dm, "isAudio");
function x0(n) {
  switch (n) {
    case ".ai":
    case ".apng":
    case ".bmp":
    case ".emf":
    case ".eps":
    case ".gif":
    case ".heic":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".psd":
    case ".svg":
    case ".tif":
    case ".tiff":
    case ".webp":
    case ".wmf":
      return !0;
    default:
      return !1;
  }
}
a(x0, "isImage");
function C0(n) {
  switch (di(n)) {
    case ".apng":
    case ".bmp":
    case ".gif":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".svg":
    case ".webp":
      return !0;
    default:
      return !1;
  }
}
a(C0, "isWebImage");
function Vm(n) {
  switch (n) {
    case ".3g2":
    case ".asx":
    case ".asf":
    case ".avi":
    case ".flv":
    case ".mk3d":
    case ".mkv":
    case ".mov":
    case ".mp4":
    case ".mpeg":
    case ".mpg":
    case ".ogm":
    case ".ogv":
    case ".ogx":
    case ".qt":
    case ".rm":
    case ".rv":
    case ".smi":
    case ".smil":
    case ".swf":
    case ".webm":
    case ".wmv":
    case ".xaml":
      return !0;
    default:
      return !1;
  }
}
a(Vm, "isVideo");
function $0(n) {
  switch (n) {
    case ".markdown":
    case ".md":
      return !0;
    default:
      return !1;
  }
}
a($0, "isMarkdown");
function Hm(n) {
  switch (n) {
    case ".htm":
    case ".html":
    case ".xhtml":
    case ".xml":
      return !0;
    default:
      return !1;
  }
}
a(Hm, "isMarkup");
function dy(n) {
  if (Hm(n))
    return !0;
  switch (n) {
    case ".as":
    case ".as3":
    case ".asm":
    case ".aspx":
    case ".bat":
    case ".c":
    case ".cc":
    case ".cmake":
    case ".coffee":
    case ".cpp":
    case ".cs":
    case ".css":
    case ".cxx":
    case ".diff":
    case ".erb":
    case ".erl":
    case ".groovy":
    case ".gvy":
    case ".h":
    case ".haml":
    case ".hh":
    case ".hpp":
    case ".hxx":
    case ".java":
    case ".js":
    case ".json":
    case ".jsx":
    case ".less":
    case ".lst":
    case ".m":
    case ".make":
    case ".ml":
    case ".mm":
    case ".out":
    case ".patch":
    case ".php":
    case ".pl":
    case ".plist":
    case ".properties":
    case ".py":
    case ".rb":
    case ".sass":
    case ".scala":
    case ".scm":
    case ".script":
    case ".scss":
    case ".sh":
    case ".sml":
    case ".sql":
    case ".vb":
    case ".vi":
    case ".vim":
    case ".xsd":
    case ".xsl":
    case ".yaml":
    case ".yml":
      return !0;
    default:
      return !1;
  }
}
a(dy, "isCode");
function Bm(n) {
  if (dy(n) || $0(n))
    return !0;
  switch (n) {
    case ".txt":
      return !0;
    default:
      return !1;
  }
}
a(Bm, "isText");
function Xr(n) {
  const t = di(n);
  if (t === "") return { icon: "file" };
  if (Dm(t))
    return { icon: "file-music", color: "indigo" };
  if (x0(t))
    return { icon: "file-image", color: "cyan" };
  if (Vm(t))
    return { icon: "file-video", color: "pink" };
  if (Hm(t))
    return { icon: "file-xml", color: "purple" };
  if (dy(t))
    return { icon: "file-code", color: "purple" };
  if (Bm(t))
    return { icon: "file-document" };
  switch (t) {
    case ".7z":
    case ".zip":
      return { icon: "file-compressed", color: "orange" };
    case ".doc":
    case ".docm":
    case ".docx":
    case ".dotm":
    case ".dotx":
      return { icon: "file-word", color: "native" };
    case ".eml":
    case ".msg":
      return { icon: "email", color: "" };
    case ".xls":
    case ".xlsm":
    case ".xlsx":
    case ".xltx":
      return { icon: "file-excel", color: "native" };
    case ".pdf":
      return { icon: "file-pdf", color: "native" };
    case ".ppt":
    case ".pptm":
    case ".pptx":
    case ".potx":
      return { icon: "file-powerpoint", color: "native" };
    case ".pages":
      return { icon: "file", color: "orange" };
    case ".numbers":
      return { icon: "file", color: "green" };
    case ".keynote":
      return { icon: "file", color: "blue" };
  }
  return { icon: "file" };
}
a(Xr, "getIcon");
function k0(n) {
  const t = di(n);
  return t === "" ? "none" : C0(t) ? "image" : dy(t) ? "code" : Bm(t) ? "text" : Dm(t) ? "audio" : Vm(t) ? "video" : "none";
}
a(k0, "getWebPreviewFormat");
function ud(n) {
  switch (n) {
    case "Google Drive":
      return "google-drive";
    case "Dropbox":
      return "dropbox";
    case "OneDrive":
      return "onedrive";
    case "Box":
      return "box";
    default:
      return "";
  }
}
a(ud, "getProvider");
function hy(n) {
  let t = "file";
  switch (di(n)) {
    case ".7z":
    case ".zip":
      t = "archive";
      break;
    case ".aac":
    case ".aif":
    case ".aiff":
    case ".au":
    case ".gsm":
    case ".m4a":
    case ".mid":
    case ".midi":
    case ".mka":
    case ".mp3":
    case ".oga":
    case ".ogg":
    case ".ra":
    case ".ram":
    case ".snd":
    case ".spx":
    case ".wav":
    case ".wma":
      t = "audio";
      break;
    case ".c":
    case ".cgi":
    case ".cpp":
    case ".cs":
    case ".cshtml":
    case ".css":
    case ".html":
    case ".java":
    case ".js":
    case ".json":
    case ".less":
    case ".php":
    case ".pl":
    case ".ps1":
    case ".py":
    case ".rb":
    case ".rs":
    case ".scss":
    case ".sh":
    case ".swift":
    case ".sql":
    case ".ts":
    case ".xml":
    case ".yaml":
    case ".yml":
      t = "code";
      break;
    case ".doc":
    case ".docm":
    case ".docx":
    case ".dotm":
    case ".dotx":
    case ".gdoc":
    case ".pages":
    case ".pdf":
      t = "document";
      break;
    case ".eml":
    case ".msg":
      t = "email";
      break;
    case ".gslides":
    case ".keynote":
    case ".ppt":
    case ".pptm":
    case ".pptx":
    case ".potx":
      t = "presentation";
      break;
    case ".gsheet":
    case ".numbers":
    case ".xls":
    case ".xlsm":
    case ".xlsx":
    case ".xltx":
      t = "spreadsheet";
      break;
    case ".ai":
    case ".apng":
    case ".bmp":
    case ".emf":
    case ".eps":
    case ".gif":
    case ".heic":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".psd":
    case ".svg":
    case ".tif":
    case ".tiff":
    case ".webp":
    case ".wmf":
      t = "image";
      break;
    case ".md":
    case ".markdown":
    case ".txt":
      t = "text";
      break;
    case ".3g2":
    case ".asx":
    case ".asf":
    case ".avi":
    case ".flv":
    case ".mk3d":
    case ".mkv":
    case ".mov":
    case ".mp4":
    case ".mpeg":
    case ".mpg":
    case ".ogm":
    case ".ogv":
    case ".ogx":
    case ".qt":
    case ".rm":
    case ".rv":
    case ".smi":
    case ".smil":
    case ".swf":
    case ".webm":
    case ".wmv":
    case ".xaml":
      t = "video";
      break;
  }
  return t;
}
a(hy, "getKind");
function uy(n) {
  const t = n.target, e = t?.value.lastIndexOf(".");
  e === -1 ? t?.select() : e !== void 0 && t?.setSelectionRange(0, e);
}
a(uy, "handleSelectFilename");
async function Ap(n, t = "SHA-256") {
  return await new Promise((e) => {
    if (n) {
      const i = new FileReader();
      i.readAsArrayBuffer(n), i.onloadend = async () => {
        const r = await crypto.subtle.digest(t, i.result);
        let s = "";
        r && (s = Array.from(new Uint8Array(r)).map((c) => c.toString(16).padStart(2, "0")).join("")), e(s);
      };
    } else
      e("");
  });
}
a(Ap, "getHash");
function Vu(n, t) {
  return n.findAll(t.filters).map((e) => t.select ? t.select(e) : e.state);
}
a(Vu, "getResult");
const hw = class hw {
  constructor(t) {
    this.alwaysUpdate = !1, t.addController(this), this.host = t, this.setContext();
  }
  async setContext() {
    this.whenContext = new Promise((t) => this.resolveContext = t), await yr(this.host), this.context = new oi(this.host, { context: he, subscribe: !0 });
  }
  hostUpdate() {
    this.context?.value && this.resolveContext?.();
  }
  async trackMutationState(t, e) {
    if (e || (await this.whenContext, e = this.context?.value?.queryClient), !e)
      throw new Error("No QueryClient provided");
    return this.mutationCacheUnsubscribe?.(), this.options = t, this.mutationCache = e.getMutationCache(), this.mutationCacheSubscribe(), this.result;
  }
  mutationCacheSubscribe() {
    this.mutationCache && this.options && (this.result = Vu(this.mutationCache, this.options), this.mutationCacheUnsubscribe = this.mutationCache.subscribe((t) => {
      if (this.mutationCache && this.options && /added|removed|updated/.test(t.type)) {
        const e = Vu(this.mutationCache, this.options);
        this.result !== e && !_a(this.result, e) && (this.result = e, this.host.requestUpdate());
      }
    }), this.host.requestUpdate());
  }
  get isMutating() {
    return !this.mutationCache || !this.options?.filters ? 0 : Vu(this.mutationCache, { filters: { ...this.options.filters, status: "pending" } }).length;
  }
  untrackMutationState() {
    this.mutationCacheUnsubscribe?.(), this.mutationCacheUnsubscribe = void 0, this.result = void 0, this.options = void 0, this.mutationCache = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.mutationCacheSubscribe();
  }
  hostDisconnected() {
    this.mutationCacheUnsubscribe?.();
  }
};
a(hw, "MutationStateController");
let kc = hw;
function qt(n, t, e, i) {
  const r = n.getMutationCache(), s = r.find({
    mutationKey: t,
    predicate: /* @__PURE__ */ a((o) => o.state.variables === e, "predicate")
  });
  if (s && s.state.context) {
    const o = { ...s.state.context };
    i(o);
    const c = { ...s.state, context: o };
    s.state = c, r.notify({
      mutation: s,
      type: "updated",
      action: {
        type: "pending",
        context: s.state.context,
        variables: s.state.variables,
        isPaused: !1
      }
    });
  }
}
a(qt, "updateMutationContext");
function Nm(n, t, e) {
  const i = n.getMutationCache().find({ mutationKey: t, exact: !0, predicate: e });
  i && n.getMutationCache().remove(i);
}
a(Nm, "removeMutation");
function P0(n, t) {
  const e = n.getMutationCache();
  e.findAll({ mutationKey: t, exact: !0 }).forEach((r) => {
    e.remove(r);
  });
}
a(P0, "removeMutations");
const py = /* @__PURE__ */ a((n, t, e = 0, i = "application/octet-stream", r, s = Date.now()) => {
  const o = n && (n instanceof URL ? n.toString() : URL.createObjectURL(n));
  return {
    id: s,
    app: { id: -1 },
    name: t,
    kind: hy(t),
    size: e,
    media_type: i,
    embed_url: "",
    preview_format: k0(t),
    thumbnail_url: o,
    preview_url: o,
    download_url: o,
    rev: -1,
    created_by: r,
    created_at: (/* @__PURE__ */ new Date()).toUTCString(),
    is_subscribed: !1,
    is_trashed: !1,
    is_starred: !1
  };
}, "getTempFile");
function Um(n) {
  const t = n ? n.reduce(
    (e, i) => {
      const r = i.context?.file;
      return r && i.context?.status.progress && r.size ? {
        loaded: e.loaded + Math.floor(i.context.status.progress / 100 * r.size),
        total: e.total + r.size
      } : e;
    },
    { loaded: 0, total: 0 }
  ) : { loaded: 0, total: 0 };
  return {
    /** Loaded bytes */
    loaded: t.loaded,
    /** Total bytes */
    total: t.total,
    /** Progress of upload provided as 0-100 percent. */
    percent: t.total > 0 ? t.loaded / t.total * 100 : null
  };
}
a(Um, "getFileMutationsTotalProgress");
function Ep(n) {
  return n ? n.some((t) => t.context?.status.state === "conflict") ? "conflict" : n.some((t) => t.status === "error") ? "error" : n.every((t) => t.status === "success") ? "ok" : "pending" : "ok";
}
a(Ep, "getFileMutationsTotalStatus");
function of(n) {
  return n?.filter((t) => t.context?.status.state === "pending") || [];
}
a(of, "getPendingFileMutations");
function cf(n) {
  return n?.filter((t) => t.context?.status.state === "conflict" || t.status === "error") || [];
}
a(cf, "getFileMutationsByConflictOrError");
function _0(n, t) {
  const e = n.queryClient;
  e.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "blobs"],
    exact: !0
  }).forEach((i) => {
    i.state.context?.status.state === "error" && e.getMutationCache().remove(i);
  }), e.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "files"],
    exact: !0
  }).forEach((i) => {
    i.state.context?.status.state === "conflict" && e.getMutationCache().remove(i);
  });
}
a(_0, "removeErroredFileMutations");
function Rp(n, t, e) {
  const i = n.queryClient;
  i.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "blobs"],
    exact: !0,
    predicate: /* @__PURE__ */ a((r) => /error|success/.test(r.state.status) && (!e || r.state.variables?.blob?.name === e), "predicate")
  }).forEach((r) => {
    i.getMutationCache().remove(r);
  }), i.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "files"],
    exact: !0,
    predicate: /* @__PURE__ */ a((r) => /error|success/.test(r.state.status) && (!e || r.state.variables?.blob?.name === e), "predicate")
  }).forEach((r) => {
    i.getMutationCache().remove(r);
  });
}
a(Rp, "removeSettledFileMutations");
function S0(n, t, e) {
  const i = n.queryClient, r = ["apps", e.id, "files"];
  return {
    mutationFn: /* @__PURE__ */ a(async ({ blob: o, replace: c = !1 }) => {
      const l = await n.fetch("/api/apps/" + e.id + "/files", {
        method: "POST",
        body: JSON.stringify({ blob_id: o.id, replace: c })
      });
      if (!l.ok) {
        const p = await l.json();
        throw new Error(p.detail || p.title, { cause: p });
      }
      return await l.json();
    }, "mutationFn"),
    mutationKey: r,
    onMutate: /* @__PURE__ */ a(async (o) => {
      await i.cancelQueries({ queryKey: r, exact: !0 }), M0(n, e, o.blob.name), Rp(n, e, o.blob.name);
      let c;
      try {
        c = o.blob.thumbnail_url && new URL(o.blob.thumbnail_url) || void 0;
      } catch {
      }
      const l = py(c, o.blob.name, o.blob.size, o.blob.media_type, t);
      return {
        type: o.replace ? "replace" : "create",
        file: l,
        status: { state: "pending" }
      };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((o, c, l) => (qt(i, r, c, (p) => {
      p && (p.status.state = "ok", p.status.progress = void 0, p.status.text = void 0);
    }), i.invalidateQueries({ queryKey: r })), "onSuccess"),
    onError(o, c, l) {
      o?.cause?.status === 409 ? qt(i, r, c, (p) => {
        p && (p.status.progress = void 0, p.status.state = "conflict", p.status.text = o.message);
      }) : qt(i, r, c, (p) => {
        p && (p.status.state = "error", p.status.progress = void 0, p.status.text = o.message);
      });
    }
  };
}
a(S0, "getCreateFileMutationOptions");
function M0(n, t, e, i, r = "blobs") {
  const s = n.queryClient;
  s.getMutationCache().findAll({
    mutationKey: ["apps", t.id, r],
    exact: !0,
    status: "success",
    predicate: /* @__PURE__ */ a((o) => o.state.data?.name === e, "predicate")
  }).forEach((o) => {
    s.getMutationCache().remove(o);
  });
}
a(M0, "removeSuccessfulUploadBlobMutations");
async function qm(n, t, e, i) {
  const r = new FormData();
  r.append("blob", t);
  const s = await n.upload(
    "/api/blobs",
    "POST",
    r,
    qd.Auto,
    (c) => {
      e && e({ progress: c });
    },
    i
  );
  if (!s.ok) {
    const c = await s.json();
    throw new Error(c.detail || c.title, { cause: c });
  }
  return await s.json();
}
a(qm, "uploadBlob");
function A0(n) {
  return {
    mutationFn: /* @__PURE__ */ a(async (e) => await qm(n, e.file, e.onProgress), "mutationFn")
    // TODO: implement onmutate, onsuccess, onerror...
  };
}
a(A0, "getSimpleUploadBlobMutationOptions");
function yy(n, t, e, i, r = "blobs") {
  const s = n.queryClient, o = i ? ["apps", e, r, i] : ["apps", e, r];
  return {
    mutationFn: /* @__PURE__ */ a(async (l) => await qm(n, l.file, l.onProgress, l.signal), "mutationFn"),
    mutationKey: o,
    onMutate: /* @__PURE__ */ a(async (l) => {
      await s.cancelQueries({ queryKey: o, exact: !0 });
      const p = py(l.file, l.file.name, l.file.size, l.file.type, t);
      l.onProgress = ({ progress: C }) => {
        qt(s, o, l, (g) => {
          g.status.state = "pending", g.status.progress = C;
        });
      };
      const v = await Ap(l.file);
      return { type: "upload", file: p, status: { state: "pending" }, sha256: v };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((l, p, v) => {
      qt(s, o, p, (C) => {
        C.status.state = "ok", C.status.progress = void 0, C.status.text = void 0;
      });
    }, "onSuccess"),
    onError(l, p, v) {
      const C = l.cause;
      C && C.status === 409 ? qt(s, o, p, (g) => {
        g.status.state = "conflict", g.status.progress = void 0, g.status.text = C.detail || C.title;
      }) : qt(s, o, p, (g) => {
        g && (g.status.state = "error", g.status.progress = void 0, g.status.text = C.detail || C.title);
      });
    }
  };
}
a(yy, "getUploadBlobMutationOptions");
var E0 = Object.defineProperty, wy = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = void 0, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = o(t, e, r) || r);
  return r && E0(t, e, r), r;
}, "__decorateClass$1j"), ss, os, cs, ls, ds, hs, Zi;
const uw = class uw extends it {
  constructor() {
    super(...arguments);
    O(this, ss);
    O(this, os);
    O(this, cs);
    O(this, ls);
    O(this, ds);
    O(this, hs);
    O(this, Zi);
    this.contextId = pl(), _(this, os, new Promise((e) => {
      _(this, ss, e);
    })), _(this, ls, new Promise((e) => {
      _(this, cs, e);
    })), _(this, hs, new Promise((e) => {
      _(this, ds, e);
    })), _(this, Zi, new qe(this));
  }
  // PROPERTIES
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  // Promise.withResolvers() is available in ES2024, that needs to be set in TSConfig
  /**
   * Resolves when a contextual id is available.
   *
   * @internal
   * @returns {Promise<ContextIdType>}
   */
  async whenContextId() {
    return await y(this, os);
  }
  /**
   * Resolves when current user data is available.
   *
   * @returns {Promise<UserType>}
   */
  async whenUser() {
    return await y(this, ls);
  }
  /**
   * Resolves when a weavy context is available.
   *
   * @returns {Promise<WeavyType>}
   */
  async whenWeavy() {
    return await y(this, hs);
  }
  connectedCallback() {
    super.connectedCallback(), this.contextId && this.requestUpdate("contextId"), this.user && this.requestUpdate("user"), this.weavy && this.requestUpdate("weavy");
  }
  async scheduleUpdate() {
    await yr(this), await super.scheduleUpdate();
  }
  async willUpdate(e) {
    var i, r, s;
    super.willUpdate(e), this.weavyContextConsumer ??= new oi(this, { context: he, subscribe: !0 }), this.weavyContextConsumer?.value && this.weavy !== this.weavyContextConsumer?.value && (this.weavy = this.weavyContextConsumer?.value), e.has("weavy") && this.weavy && await y(this, Zi).trackQuery(hd(this.weavy, ["user"])), y(this, Zi).result?.isPending || (this.user && y(this, Zi).result.data && this.user.id !== y(this, Zi).result.data.id && (console.warn("User mismatch, resetting"), this.weavy?.reset()), this.user = y(this, Zi).result?.data), e.has("contextId") && this.contextId && (e.get("contextId") && _(this, os, new Promise((o) => {
      _(this, ss, o);
    })), (i = y(this, ss)) == null || i.call(this, this.contextId)), e.has("user") && this.user && (e.get("user") && _(this, ls, new Promise((o) => {
      _(this, cs, o);
    })), (r = y(this, cs)) == null || r.call(this, this.user)), e.has("weavy") && this.weavy && (e.get("weavy") && _(this, hs, new Promise((o) => {
      _(this, ds, o);
    })), (s = y(this, ds)) == null || s.call(this, this.weavy));
  }
};
ss = new WeakMap(), os = new WeakMap(), cs = new WeakMap(), ls = new WeakMap(), ds = new WeakMap(), hs = new WeakMap(), Zi = new WeakMap(), a(uw, "WeavyComponent");
let Pc = uw;
wy([
  D()
], Pc.prototype, "weavy");
wy([
  Yr({ context: Sm }),
  D()
], Pc.prototype, "contextId");
wy([
  Yr({ context: xh }),
  D()
], Pc.prototype, "user");
var R0 = Object.defineProperty, T0 = Object.getOwnPropertyDescriptor, Qe = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? T0(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && R0(t, e, r), r;
}, "__decorateClass$1i"), Yl, Xl, Jl, td, us, ps, ys, ws, vn, gn, fs, ms, Ai, vs, bn;
const pw = class pw extends Pc {
  constructor() {
    super();
    // DEPRECATED .data property
    O(this, Yl);
    // APP SUBSCRIBE
    // SETTINGS
    // annotations
    O(this, Xl);
    // enterToSend
    O(this, Jl);
    // reactions
    O(this, td);
    O(this, us);
    O(this, ps);
    O(this, ys);
    O(this, ws);
    O(this, vn);
    O(this, gn);
    O(this, fs);
    O(this, ms);
    O(this, Ai);
    O(this, vs);
    O(this, bn);
    this.storage = dm("localStorage"), this.storageLinkHandler = (e) => {
      e.storageArea === this.storage && e.key === "wy-link" && e.newValue && this.readStorageLink();
    }, this.linkEventHandler = async (e) => {
      !e.defaultPrevented && e.detail.link && (this.link && this.link.id === e.detail.link.id && (this.link = void 0, await this.updateComplete), this.link = e.detail.link, this.link || this.provideStorageLink(e.detail.link));
    }, this.notificationEventConsumer = (e) => {
      e.stopPropagation(), e.defaultPrevented || this.visibilityElement && this.visibilityElement.isConnected && this.visibilityElement.checkVisibility(b1) && this.matchesLink(e.detail.link) && e.preventDefault();
    }, _(this, ps, new Promise((e) => {
      _(this, us, e);
    })), _(this, ws, new Promise((e) => {
      _(this, ys, e);
    })), _(this, gn, new Promise((e) => {
      _(this, vn, e);
    })), _(this, ms, new Promise((e) => {
      _(this, fs, e);
    })), _(this, Ai, /* @__PURE__ */ new Map()), _(this, vs, new ti(this)), _(this, bn, new kc(this)), this.settings = new Xd(this);
  }
  /**
   * Checks if an entity matches the component configuration.
   *
   * @internal
   * @param link - Entity to check for a match.
   * @returns True if the entity targets this component.
   */
  matchesLink(e) {
    return (
      // Type app match, like the Messenger
      e?.app?.type && this.componentTypes?.includes(e.app.type) ? e.agent ? e.agent === this.agent : !0 : !1
    );
  }
  set link(e) {
    const i = this._link;
    this._link = this.matchesLink(e) ? e : void 0, this.requestUpdate("link", i);
  }
  get link() {
    return this._link;
  }
  /**
   * Clears the link and resets the promise.
   *
   * @internal
   */
  clearLink() {
    this.link && (_(this, gn, new Promise((e) => {
      _(this, vn, e);
    })), this.link = void 0);
  }
  /**
   * Shares a link with other blocks that may consume it automatically.
   *
   * @param link - The entity to provide.
   * @internal
   */
  provideStorageLink(e) {
    this.storage?.setItem("wy-link", btoa(JSON.stringify(e)));
  }
  /**
   * Reads a link from storage and exposes it via the link property and context.
   *
   * @internal
   */
  readStorageLink() {
    if (!this.storage) {
      console.error("Storage not available");
      return;
    }
    const e = this.storage.getItem("wy-link");
    if (e)
      try {
        const i = JSON.parse(atob(e));
        i && (this.link = i);
      } catch (i) {
        console.error("Error parsing link", i);
      }
  }
  /**
   * Consumes a link in storage. Make sure to consume it after it has been used.
   *
   * @internal
   */
  consumeStorageLink() {
    this.storage?.removeItem("wy-link");
  }
  /**
   * Element to match visibility on.
   */
  get visibilityElement() {
    return this;
  }
  set agent(e) {
    this._agentUid = e || void 0;
  }
  get agent() {
    return this._agentUid;
  }
  set data(e) {
    console.warn(".data property array is deprecated. Use .contextualData string instead."), _(this, Yl, e);
  }
  /**
   * DEPRECATED: Use `.contextualData` property instead.
   *
   * Array with contextual data.
   *
   * *Note: Only the first item in the array is currently used.*
   * @internal
   * @deprecated
   */
  get data() {
    return y(this, Yl);
  }
  set annotations(e) {
    _(this, Xl, e);
  }
  get annotations() {
    return y(this, Xl) ?? this.weavy?.annotations ?? ae.defaults.annotations;
  }
  set enterToSend(e) {
    _(this, Jl, e);
  }
  get enterToSend() {
    return y(this, Jl) ?? this.weavy?.enterToSend ?? ae.defaults.enterToSend;
  }
  set reactions(e) {
    _(this, td, e);
  }
  get reactions() {
    return y(this, td) ?? this.weavy?.reactions ?? ae.defaults.reactions;
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  // Promise.withResolvers() is available in ES2024, that needs to be set in TSConfig
  // #resolveAgentUser?: (agent: AgentType) => void;
  // #whenAgentUser = new Promise<AgentType>((r) => {
  //   this.#resolveAgentUser = r;
  // });
  // async whenAgentUser() {
  //   return await this.#whenAgentUser;
  // }
  /**
   * Resolves when context data blob uploads has finished.
   *
   * @internal
   * @returns {Promise<ContextDataBlobsType>}
   */
  async whenContextDataBlobs() {
    return await y(this, ps);
  }
  /**
   * Resolves when Weavy component features config is available.
   *
   * @internal
   * @returns {Promise<ComponentFeaturePolicy>}
   */
  async whenComponentFeatures() {
    return await y(this, ws);
  }
  /**
   * Resolves when a provided link is available.
   *
   * @internal
   * @returns {Promise<LinkType>}
   */
  async whenLink() {
    return await y(this, gn);
  }
  /**
   * Resolves when Weavy component settings are available.
   *
   * @internal
   * @returns {Promise<WeavyComponentSettingsType>}
   */
  async whenSettings() {
    return await y(this, ms);
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("wy-link", this.linkEventHandler), window.addEventListener("storage", this.storageLinkHandler), this.componentFeatures && this.requestUpdate("componentFeatures"), this.contextDataBlobs && this.requestUpdate("contextDataBlobs"), this.link && this.requestUpdate("link"), this.settings && this.requestUpdate("settings");
  }
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("wy-link", this.linkEventHandler), window.removeEventListener("storage", this.storageLinkHandler), this.weavy?.host.removeEventListener("wy-notification", this.notificationEventConsumer, { capture: !0 });
  }
  async willUpdate(e) {
    var r, s, o, c;
    await super.willUpdate(e), e.has("bot") && typeof this.bot == "string" && console.error(`Using .bot property is deprecated. Use .agent = "${this.bot}"; instead`);
    const i = Object.keys(this.settings);
    if ((e.has("weavy") || i.find((l) => e.has(l))) && (this.settings = new Xd(this)), e.has("features") && this.componentFeatures && (this.componentFeatures.setAllowedFeatures(this.features), this.componentFeatures instanceof le && (this.componentFeatures = this.componentFeatures.immutable())), (e.has("weavy") || e.has("contextId") || e.has("user") || e.has("componentFeatures")) && this.weavy && this.contextId && this.user && this.componentFeatures?.allowsFeature(S.ContextData) && (await y(this, vs).trackMutation(
      yy(this.weavy, this.user, this.contextId, void 0, "data")
    ), await y(this, bn).trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.contextId, "data"],
          exact: !0
        }
      },
      this.weavy.queryClient
    )), e.has("contextualData") || e.has("data") || e.has("componentFeatures")) {
      const l = this.contextualData ? [this.contextualData] : this.data ? this.data : [], p = y(this, Ai);
      if (_(this, Ai, /* @__PURE__ */ new Map()), l.forEach((v) => {
        const C = p.get(v);
        if (C)
          y(this, Ai).set(v, C);
        else {
          const g = b0(v);
          g && y(this, Ai).set(v, g);
        }
      }), y(this, Ai) && this.componentFeatures?.allowsFeature(S.ContextData)) {
        for (const m of Array.from(y(this, Ai).values()))
          if (m.type === "file") {
            const f = await Ap(m.item);
            await T1(
              y(this, bn).result ?? [],
              async (A) => (A.context?.sha256 ?? await Ap(A.variables?.file)) === f
            ) || await y(this, vs).mutate({ file: m.item });
          }
        const v = y(this, bn).result, C = v?.some((m) => m.status === "pending"), g = v?.map((m) => m.data?.id).filter((m) => m).reverse() ?? [];
        C || (this.contextDataBlobs = g);
      } else
        this.contextDataBlobs = [];
    }
    (e.has("componentTypes") || e.has("agent")) && this.componentTypes && this.readStorageLink(), e.has("link") && this.link && (console.info("Opening notification link"), this.consumeStorageLink()), e.has("contextDataBlobs") && this.contextDataBlobs && (e.get("contextDataBlobs") && _(this, ps, new Promise((l) => {
      _(this, us, l);
    })), (r = y(this, us)) == null || r.call(this, this.contextDataBlobs)), e.has("componentFeatures") && this.componentFeatures && (e.get("componentFeatures") && _(this, ws, new Promise((l) => {
      _(this, ys, l);
    })), (s = y(this, ys)) == null || s.call(this, this.componentFeatures)), e.has("link") && this.link && (e.get("link") && _(this, gn, new Promise((l) => {
      _(this, vn, l);
    })), (o = y(this, vn)) == null || o.call(this, this.link)), e.has("settings") && this.settings && (e.get("settings") && _(this, ms, new Promise((l) => {
      _(this, fs, l);
    })), (c = y(this, fs)) == null || c.call(this, this.settings)), e.has("weavy") && this.weavy && this.weavy.host.addEventListener("wy-notification", this.notificationEventConsumer, { capture: !0 });
  }
};
Yl = new WeakMap(), Xl = new WeakMap(), Jl = new WeakMap(), td = new WeakMap(), us = new WeakMap(), ps = new WeakMap(), ys = new WeakMap(), ws = new WeakMap(), vn = new WeakMap(), gn = new WeakMap(), fs = new WeakMap(), ms = new WeakMap(), Ai = new WeakMap(), vs = new WeakMap(), bn = new WeakMap(), a(pw, "WeavyTypeComponent");
let jt = pw;
Qe([
  Yr({ context: Mm }),
  D()
], jt.prototype, "contextDataBlobs", 2);
Qe([
  Yr({ context: bh }),
  D()
], jt.prototype, "componentFeatures", 2);
Qe([
  Yr({ context: Rm }),
  D()
], jt.prototype, "settings", 2);
Qe([
  Yr({ context: Em })
], jt.prototype, "_link", 2);
Qe([
  u({ type: Object })
], jt.prototype, "link", 1);
Qe([
  D()
], jt.prototype, "componentTypes", 2);
Qe([
  u()
], jt.prototype, "features", 2);
Qe([
  u({ type: String })
], jt.prototype, "agent", 1);
Qe([
  u({
    attribute: !0,
    type: String
  })
], jt.prototype, "contextualData", 2);
Qe([
  u({
    attribute: !0,
    type: String,
    converter: {
      fromAttribute(n) {
        return R1(n);
      }
    }
  })
], jt.prototype, "data", 1);
Qe([
  u({ type: String })
], jt.prototype, "annotations", 1);
Qe([
  u({ type: String })
], jt.prototype, "enterToSend", 1);
Qe([
  u({ type: String })
], jt.prototype, "reactions", 1);
Qe([
  u()
], jt.prototype, "bot", 2);
const L0 = new Map(am(Tm)), O0 = new Map(am(Lm)), Jd = new Map(Object.entries(Om)), H9 = new Map(Object.entries(zm));
var z0 = Object.defineProperty, I0 = Object.getOwnPropertyDescriptor, Qn = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? I0(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && z0(t, e, r), r;
}, "__decorateClass$1h");
const Fr = "unknown";
var gs, bs, Tr;
const yw = class yw extends jt {
  constructor() {
    super(...arguments);
    O(this, gs);
    O(this, bs);
    O(this, Tr);
    this.appSubscribeMutation = new ti(this), _(this, bs, new Promise((e) => {
      _(this, gs, e);
    })), _(this, Tr, new qe(this));
  }
  // @provide({ context: AgentContext })
  // @state()
  // agentUser: AgentType | undefined;
  /**
   * Sets the component to it's initial state and resets the app state.
   */
  reset() {
    this.app && (this.app = void 0), this._appName !== this._initialAppName && (this._appName = this._initialAppName);
  }
  /**
   * Checks if an entity matches the component configuration.
   *
   * @internal
   * @param link - Entity to check for a match.
   * @returns True if the entity targets this component.
   */
  matchesLink(e) {
    return (
      // Messenger conversation
      e?.app?.type && !this.appType && this.componentTypes?.includes(e.app.type) ? e.agent ? e.agent === this.agent : !0 : (
        // Normal contextual app
        !!(e && e.app && this.appType !== Fr && (typeof this.uid == "string" && e.app?.uid === this.uid || // Normal app with app uid
        typeof this.uid == "number" && e.app?.id === this.uid || // Normal app with app id
        !this.uid && this.app && e.app.id === this.app.id))
      )
    );
  }
  set link(e) {
    const i = this._link;
    !this.uid && this.appType && this.appType !== Fr ? this.whenApp().then(() => {
      this._link = this.matchesLink(e) ? e : void 0, this.requestUpdate("link", i);
    }) : (this._link = this.matchesLink(e) ? e : void 0, this.requestUpdate("link", i));
  }
  get link() {
    return this._link;
  }
  set name(e) {
    this._initialAppName = e, this._appName = e;
  }
  get name() {
    return this._appName;
  }
  /**
   * Subscribes or unsubscribes to notification updates from the app. Check `.app.is_subscribed` to see current state.
   *
   * @param subscribe - Set to `false` to unsubscribe from updates. Defaults to `true`.
   * @returns {Promise<void>}
   *
   * @example <caption>Toggle app subscription</caption>
   * ```js
   * // Wait for app data
   * await myWeavyComponent.whenApp();
   *
   * // Get current app subscription state
   * const isSubscribed = myWeavyComponent.app.is_subscribed;
   *
   * // Toggle the app subscription state
   * myWeavyComponent.subscribe(!isSubscribed);
   * ```
   */
  async subscribe(e = !0) {
    if (!this.uid)
      throw new Error(`Cannot ${e ? "subscribe" : "unsubscribe"} without a uid.`);
    await this.whenApp(), this.app?.id && this.appSubscribeMutation.mutate({ subscribe: e });
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  // Promise.withResolvers() is available in ES2024, that needs to be set in TSConfig
  /**
   * Resolves when app data is available.
   *
   * @returns {Promise<AppType>}
   */
  async whenApp() {
    return await y(this, bs);
  }
  connectedCallback() {
    super.connectedCallback(), this.app && this.requestUpdate("app");
  }
  async willUpdate(e) {
    var r;
    if (await super.willUpdate(e), e.has("autoUid") && typeof this.autoUid == "string" && (console.error(`Using .autoUid property is deprecated. Use .generateUid = "${this.autoUid}"; instead`), this.generateUid = this.autoUid), (e.has("generateUid") || e.has("user") || e.has("agent")) && this.generateUid && this.user && (this.appType && Jd.has(this.appType) && this.agent || this.appType && !Jd.has(this.appType))) {
      const s = [this.generateUid];
      this.agent && s.push(this.agent), this.user && s.push(this.user.uid || this.user.id), this.uid = s.join("-");
    }
    const i = this.name;
    if ((e.has("appType") || e.has("uid") || e.has("agent") || e.has("weavy")) && this._appName !== this._initialAppName && (this._appName = this._initialAppName, this.requestUpdate("name", i)), e.has("appType") || e.has("uid") || e.has("agent") || e.has("name") || e.has("weavy"))
      if (this.appType && this.uid && this.weavy) {
        const s = this.name ? { name: this.name } : void 0, o = this.agent ? [this.agent] : void 0;
        await y(this, Tr).trackQuery(F0(this.weavy, this.uid, this.appType, o, s));
      } else
        y(this, Tr).untrackQuery();
    if (y(this, Tr).result?.isPending || (this.app = y(this, Tr).result?.data, this.app?.name && this._appName !== this.app.name && (this.name = this.app.name, this.requestUpdate("name", i))), e.has("uid") && (this.uid || e.get("uid")) && this.uid !== e.get("uid") && this.clearLink(), !this.link && (e.has("uid") && this.uid || e.has("app") && this.app) && this.appType && this.appType !== Fr && this.readStorageLink(), e.has("app") && this.app) {
      const s = new CustomEvent("wy-app", {
        bubbles: !1,
        composed: !0,
        detail: {
          app: this.app
        }
      });
      this.dispatchEvent(s);
    }
    e.has("app") && this.app && (e.get("app") && _(this, bs, new Promise((s) => {
      _(this, gs, s);
    })), (r = y(this, gs)) == null || r.call(this, this.app)), (e.has("weavy") || e.has("app")) && this.weavy && this.app && this.appSubscribeMutation.trackMutation(V0(this.weavy, this.app));
  }
};
gs = new WeakMap(), bs = new WeakMap(), Tr = new WeakMap(), a(yw, "WeavyAppComponent");
let Re = yw;
Qn([
  Yr({ context: cy }),
  D()
], Re.prototype, "app", 2);
Qn([
  u({ type: Object })
], Re.prototype, "link", 1);
Qn([
  D()
], Re.prototype, "appType", 2);
Qn([
  u()
], Re.prototype, "generateUid", 2);
Qn([
  u({ converter: Fm })
], Re.prototype, "uid", 2);
Qn([
  u({ type: String })
], Re.prototype, "name", 1);
Qn([
  u()
], Re.prototype, "autoUid", 2);
function F0(n, t, e = Fr, i, r) {
  return {
    // eslint-disable-next-line @tanstack/query/exhaustive-deps
    queryKey: ["apps", t],
    queryFn: /* @__PURE__ */ a(async () => {
      const s = [];
      e === Fr || typeof t == "number" ? s.push(
        // Get existing app
        n.fetch(`/api/apps/${t}`)
      ) : i?.length ? (s.push(
        // Get existing app
        n.fetch(`/api/apps/${t}`)
      ), s.push(
        // Create app with members
        n.fetch("/api/apps", { method: "POST", body: JSON.stringify({ type: e, members: i, uid: t, ...r }) })
      )) : s.push(
        // Get, update or create app (upsert) using app uid
        n.fetch(`/api/apps/${t}`, { method: "PUT", body: JSON.stringify({ type: e, ...r }) })
      );
      const o = (await Promise.allSettled(s)).findLast(
        (l) => l.status === "fulfilled" && l.value?.ok
      ), c = o?.status === "fulfilled" && o.value;
      if (c)
        return await c.json();
      throw new Error(`Error getting or creating app ${t}`);
    }, "queryFn")
  };
}
a(F0, "getOrCreateAppOptions");
function D0(n) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ name: e, members: i, type: r, uid: s }) => await (await n.fetch("/api/apps", {
      method: "POST",
      body: JSON.stringify({
        name: e,
        members: i,
        type: r,
        uid: s
      })
    })).json(), "mutationFn"),
    onSettled: /* @__PURE__ */ a(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
a(D0, "getCreateAppMutationOptions");
function jm(n) {
  return new Mt(n.queryClient, D0(n));
}
a(jm, "getCreateAppMutation");
function V0(n, t) {
  const e = n.queryClient, i = ["apps", t.uid || t.id];
  return {
    mutationFn: /* @__PURE__ */ a(async ({ subscribe: s }) => {
      if (t.id >= 1) {
        const o = await n.fetch(`/api/apps/${t.id}/${s ? "subscribe" : "unsubscribe"}`, {
          method: "POST"
        });
        if (!o.ok)
          throw await o.json();
      } else
        throw new Error(`Could not subscribe to app ${t.uid || t.id}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((s) => {
      let o;
      return e.setQueryData(i, (l) => (o = l.is_subscribed, { ...l, is_subscribed: s.subscribe })), {
        previousSubscribe: o,
        subscribe: s.subscribe
      };
    }, "onMutate"),
    onError(s, o, c) {
      c && c.previousSubscribe !== void 0 && e.setQueryData(i, (l) => ({ ...l, is_subscribed: c?.previousSubscribe }));
    }
  };
}
a(V0, "getAppSubscribeMutationOptions");
function H0(n, t = [st.ChatRoom, st.PrivateChat], e) {
  const i = new URLSearchParams({
    count_only: "true",
    unread: "true",
    uid: "false"
  });
  e && i.append("member", e), t?.forEach((o) => i.append("type", o));
  const r = `/api/apps?${i.toString()}`;
  return hd(n, ["apps", "unread", t, e], r);
}
a(H0, "getAppsUnreadOptions");
function B0(n, t = {}, e, i, r, s, o) {
  return {
    ...t,
    initialPageParam: 0,
    queryKey: ["apps", "list", e, i, s, o],
    queryFn: /* @__PURE__ */ a(async (c) => {
      const l = new URLSearchParams();
      i && l.append("member", i), c.pageParam && typeof c.pageParam == "number" && l.append("skip", c.pageParam?.toString()), e?.forEach((m) => l.append("type", m)), l.append("order_by", s);
      const p = r?.();
      p && l.append("q", p), l.append("uid", "false");
      const v = `/api/apps?${l.toString()}`, g = await (await n.fetch(v)).json();
      return g.data = g.data || [], g;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ a((c) => {
      if (c.end && c?.end < c?.count)
        return c.end;
    }, "getNextPageParam")
  };
}
a(B0, "getAppListOptions");
var Ee = /* @__PURE__ */ ((n) => (n.Default = "", n.Select = "select", n.Star = "star", n.Unstar = "unstar", n.Subscribe = "subscribe", n.Unsubscribe = "unsubscribe", n.Pin = "pin", n.Unpin = "unpin", n.Download = "download", n.Preview = "preview", n))(Ee || {});
const ww = class ww {
  get weavy() {
    return this.weavyContext?.value;
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenWeavyContext = new Promise((e) => this.resolveWeavyContext = e), this.setContexts();
  }
  /**
   * Initiates context consumers
   */
  async setContexts() {
    await yr(this.host), this.weavyContext = new oi(this.host, { context: he, subscribe: !0 });
  }
  /**
   * Dispatch a `wy-action` event on the host.
   *
   * @fires {WyActionEventType} wy-action - Emitted when a conversation app is created and should be selected.
   */
  dispatchActionEvent(t) {
    const e = new CustomEvent("wy-action", {
      detail: { action: Ee.Select, app: t },
      bubbles: !0,
      composed: !0
    });
    return this.host.dispatchEvent(e);
  }
  /**
   * Create mutation controller.
   */
  async initMutation() {
    if (!this.addConversationMutation) {
      const t = await this.whenWeavyContext;
      this.addConversationMutation = jm(t);
    }
    return this.addConversationMutation;
  }
  /**
   * Create a conversation and trigger a `select` event.
   *
   * @param members - Array of members by id/uid for a new conversation.
   * @returns Whether the event was successful.
   * @fires {WyActionEventType} wy-action - Emitted when a conversation app is created and should be selected.
   */
  async create(t = []) {
    const e = await this.initMutation(), i = this.agent ?? this.host.agent, r = i ? { members: [i], type: yi.AgentChat } : { members: t, type: t.length === 1 ? yi.PrivateChat : yi.ChatRoom }, s = await e.mutate(r);
    return this.dispatchActionEvent(s), s;
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
  }
};
a(ww, "CreateConversationController");
let _c = ww;
var xs;
const fw = class fw {
  constructor(t) {
    O(this, xs, !1);
    t.addController(this), this.host = t, t.addEventListener("dragstart", () => this.isDragActive = !0), t.addEventListener("dragenter", () => this.isDragActive = !0), t.addEventListener("dragover", (e) => {
      e.preventDefault(), this.isDragActive = !0;
    }), t.addEventListener("dragleave", () => this.isDragActive = !1), t.addEventListener("dragend", () => this.isDragActive = !1), t.addEventListener("drop", (e) => this.handleDrop(e));
  }
  get isDragActive() {
    return y(this, xs);
  }
  set isDragActive(t) {
    y(this, xs) !== t && (_(this, xs, t), this.host.requestUpdate());
  }
  handleDrop(t) {
    t.preventDefault();
    const e = [];
    t.dataTransfer?.items ? [...t.dataTransfer.items].forEach((i) => {
      if (i.kind === "file") {
        const r = i.getAsFile();
        r ? e.push(r) : console.error("Could not add file");
      }
    }) : t.dataTransfer?.files && [...t.dataTransfer.files].forEach((i) => {
      e.push(i);
    }), e.length && this.dispatchUploadFiles(e), this.isDragActive = !1;
  }
  dispatchUploadFiles(t) {
    const e = new CustomEvent("drop-files", { detail: { files: t } });
    return this.host.dispatchEvent(e);
  }
  hostDisconnected() {
  }
};
xs = new WeakMap(), a(fw, "DropZoneController");
let th = fw;
function Fd(n, t) {
  Pe();
  const e = Pa({}, window.history.state, !0);
  if (!e.weavy || !e.weavy[n] || !Object.hasOwn(e.weavy[n], t))
    throw new Error("Property not found");
  return e.weavy[n][t];
}
a(Fd, "getBrowserStateProperty");
function Tp(n, t, e = "push", i) {
  if (Pe(), t) {
    const r = Pa({}, window.history.state, !0);
    r.weavy ??= {}, r.weavy[n] = t, i = i && String(i) || window.location.href;
    try {
      e === "replace" ? window.history.replaceState(r, "", i) : window.history.pushState(r, "", i);
    } catch (s) {
      console.warn("history: Could not push history state.", s, t);
    }
  }
}
a(Tp, "setBrowserState");
function N0(n, t, e) {
  Pe();
  const i = `${typeof n}:${t}`;
  e.forEach((r) => {
    try {
      const s = Fd(i, r), o = n[r];
      Wm(o, s) && (n[r] = s);
    } catch {
    }
  });
}
a(N0, "restoreHistoryProperties");
function Lp(n, t, e, i = "push") {
  Pe();
  const r = `${typeof n}:${t}`, s = {};
  e.forEach((o) => {
    s[o] = n[o];
  }), Tp(r, s, i);
}
a(Lp, "pushHistoryProperties");
function U0(n, t, e) {
  Lp(n, t, e, "replace");
}
a(U0, "updateHistoryProperties");
function Wm(n, t) {
  return n && t && (Dr(n) || Dr(t)) ? n && Object.hasOwn(n, "id") || t && Object.hasOwn(t, "id") ? n.id !== t.id : !_a(n, t) : n !== t;
}
a(Wm, "itemHasChanged");
const mw = class mw {
  constructor(t, e, i) {
    if (this._backCount = 0, this.restoreHistory = (r) => {
      if (this.prefixKey && this.properties) {
        N0(this.host, this.prefixKey, this.properties);
        try {
          this._backCount = Fd(this.prefixKey, "_backCount") || 0;
        } catch {
          this._backCount = 0;
        }
        this.updatePrevPropertyValues();
      }
    }, t.addController(this), this.host = t, i && (this.properties = i), e) {
      this.prefixKey = e;
      try {
        this._backCount = Fd(this.prefixKey, "_backCount") || this._backCount;
      } catch {
      }
    }
  }
  get hasBackNavigation() {
    return this._backCount > 0;
  }
  back() {
    window.history.back();
  }
  backAll() {
    window.history.go(this._backCount * -1);
  }
  observe(t, e) {
    if (this.properties = t, e) {
      this.prefixKey = e;
      try {
        this._backCount = Fd(this.prefixKey, "_hasBack") || this._backCount;
      } catch {
      }
    }
  }
  /**
   * Method to manually push history
   */
  pushCurrentState() {
    this.prefixKey && (Lp(this.host, this.prefixKey, this.properties), this._backCount++, Tp(this.prefixKey, { _backCount: this._backCount }, "replace"));
  }
  updatePrevPropertyValues() {
    this.properties && this.properties.forEach((t) => {
      this.prevPropertyValues ??= {};
      const e = this.host[t];
      this.prevPropertyValues[t] !== e && (this.prevPropertyValues[t] = e && JSON.parse(JSON.stringify(e)));
    });
  }
  hostConnected() {
    window.addEventListener("popstate", this.restoreHistory);
  }
  hostUpdated() {
    this.prefixKey && this.properties && (this.prevPropertyValues ? this.properties.some(
      (e) => {
        const i = this.prevPropertyValues?.[e], r = this.host[e];
        return Wm(i, r);
      }
    ) && (Lp(
      this.prevPropertyValues,
      this.prefixKey,
      this.properties
    ), this._backCount++, Tp(this.prefixKey, { _backCount: this._backCount }, "replace")) : this.prevPropertyValues = {}, U0(this.host, this.prefixKey, this.properties), this.updatePrevPropertyValues());
  }
  hostDisconnected() {
    window.removeEventListener("popstate", this.restoreHistory);
  }
};
a(mw, "HistoryController");
let lf = mw;
const vw = class vw {
  get result() {
    return this._result && this.observer ? this.observer.trackResult(this._result) : this.observer?.getCurrentResult() ?? { isPending: !0 };
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenQueryClient = new Promise((e) => this.resolveQueryClient = e), this.setContext();
  }
  async setContext() {
    await yr(this.host), this.context = new oi(this.host, {
      context: he,
      subscribe: !0,
      callback: /* @__PURE__ */ a((t) => {
        t && (this.resolveContext?.(t), this.queryClient = t.queryClient, this.resolveQueryClient?.(t.queryClient));
      }, "callback")
    });
  }
  async trackInfiniteQuery(t, e = !0) {
    this.observerUnsubscribe?.();
    const i = await this.whenQueryClient;
    if (!i)
      throw new Error("No QueryClient provided");
    const r = new $g(i, t);
    this.observer = r, this.observerSubscribe(e);
  }
  observerSubscribe(t = !0) {
    if (this.queryClient && this.observer) {
      t ? this._result = this.observer.getOptimisticResult(
        this.observer.options
      ) : this._result = this.observer.getCurrentResult(), this.observerUnsubscribe = this.observer.subscribe(() => {
        if (this.observer) {
          const i = dd(this.result, this.observer.getCurrentResult());
          i !== this._result && (this._result = i, this.host.requestUpdate());
        }
      }), this.observer.updateResult(), this.host.requestUpdate();
      let e;
      t ? e = this.observer.fetchOptimistic(this.observer.options) : e = this.queryClient.getQueryCache().get(
        this.observer.options.queryHash
      )?.promise, e?.catch(() => {
      }).finally(() => {
        this.observer?.updateResult();
      });
    }
  }
  untrackInfiniteQuery() {
    this.observerUnsubscribe?.(), this.observerUnsubscribe = void 0, this._result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    this.observerUnsubscribe?.();
  }
};
a(vw, "InfiniteQueryController");
let ir = vw;
function Op(n, t = !1) {
  for (n && !t && (n = n.nextElementSibling); n; ) {
    if (!(n instanceof HTMLElement))
      continue;
    const e = getComputedStyle(n);
    if (e.display !== "none") {
      if (e.display === "contents") {
        if (n.shadowRoot && n.shadowRoot.firstElementChild instanceof HTMLElement) {
          const i = Op(n.shadowRoot.firstElementChild, !0);
          if (i)
            return i;
        }
        if (n.firstElementChild instanceof HTMLElement) {
          const i = Op(n.firstElementChild, !0);
          if (i)
            return i;
        }
      }
      if (/absolute|sticky|fixed/.test(e.position) === !1)
        return n;
      n = n.nextElementSibling;
    }
  }
  return null;
}
a(Op, "getNextPositionedChild");
function $h(n, t = !1) {
  if (Pe(), n) {
    let e = getComputedStyle(n);
    const i = e.position === "absolute", r = t ? /(auto|scroll|overlay|hidden)/ : /(auto|overlay|scroll)/;
    if (e.position === "fixed" && document.scrollingElement)
      return document.scrollingElement;
    for (let s = n; s = s.parentElement || s.parentNode || s.host; )
      if (s instanceof Element && (e = getComputedStyle(s), !(i && e.position === "static") && r.test(e.overflow + e.overflowY + e.overflowX)))
        return s;
  }
  return document.scrollingElement || n;
}
a($h, "getScrollParent");
function q0(n) {
  if (n && n.isConnected) {
    const t = $h(n);
    return t.clientHeight !== t.scrollHeight;
  }
  return !1;
}
a(q0, "hasScroll");
function j0(n, t = 32) {
  if (n) {
    const e = $h(n);
    return Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) < t;
  }
  return !1;
}
a(j0, "isParentAtBottom");
async function W0(n, t = !1) {
  if (n) {
    const e = $h(n);
    Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) > 1 && (t ? e.scrollTo({
      top: e.scrollHeight,
      left: 0,
      behavior: "smooth"
    }) : e.scrollTop = e.scrollHeight), await new Promise((i) => {
      let r = e.scrollTop;
      const s = /* @__PURE__ */ a(() => {
        t && e.scrollTop === r && (e.scrollTop = e.scrollHeight), r = e.scrollTop, Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) > 1 ? requestAnimationFrame(s) : i(void 0);
      }, "scrollCheck");
      requestAnimationFrame(s);
    });
  }
}
a(W0, "scrollParentToBottom");
const K0 = 0, Q0 = void 0;
function G0(n, t, e = !1) {
  Pe(), t ??= /* @__PURE__ */ a(() => Promise.reject(new Error("No scroll function defined")), "whenNext");
  const i = e ? $h(n) : document.documentElement, r = i === document.documentElement ? document : i;
  let s = !1;
  const o = new IntersectionObserver(
    (c) => {
      c.forEach((l) => {
        if (l.isIntersecting && !s)
          if (s = !0, e && i && r instanceof HTMLElement) {
            const p = Op(l.target) || l.target, v = i.scrollHeight, C = p.offsetTop, g = /* @__PURE__ */ a(() => {
              queueMicrotask(() => {
                if (v !== i.scrollHeight) {
                  if (p?.isConnected) {
                    const m = p.offsetTop - C;
                    i.scrollTop += m;
                  }
                  requestAnimationFrame(() => s = !1);
                } else
                  queueMicrotask(() => {
                    if (v !== i.scrollHeight) {
                      if (p?.isConnected) {
                        const m = p.offsetTop - C;
                        i.scrollTop += m;
                      }
                      requestAnimationFrame(() => s = !1);
                    } else
                      requestAnimationFrame(() => {
                        if (o.takeRecords().length && p?.isConnected) {
                          const m = p.offsetTop - C;
                          i.scrollTop += m;
                        }
                        requestAnimationFrame(() => s = !1);
                      });
                  });
              });
            }, "afterNext");
            t().then(g);
          } else
            t().then(() => {
              requestAnimationFrame(() => s = !1);
            });
      });
    },
    { root: r, threshold: K0, rootMargin: Q0 }
  );
  return o.observe(n), o;
}
a(G0, "createScroller");
const gw = class gw {
  constructor(t, e = !1) {
    this.reverse = !1, this.isObservePending = !1, t.addController(this), this.host = t, this.reverse = e;
  }
  observe(t, e) {
    t && e && !t.isLoading && !this.isObservePending && (this.isObservePending = !0, requestAnimationFrame(() => {
      this.loadMoreRefElement = e, this.scroller?.disconnect(), this.scroller = G0(
        e,
        async () => {
          t.hasNextPage && !t.isFetching && (await t.fetchNextPage({ cancelRefetch: !1 }), this.reverse && await this.host.updateComplete);
        },
        this.reverse
      ), this.isObservePending = !1;
    }));
  }
  hostConnected() {
    this.loadMoreRefElement && this.scroller?.observe(this.loadMoreRefElement);
  }
  hostDisconnected() {
    this.scroller?.disconnect();
  }
};
a(gw, "InfiniteScrollController");
let rr = gw;
const bw = class bw extends rr {
  constructor(t) {
    super(t, !0);
  }
};
a(bw, "ReverseInfiniteScrollController");
let zp = bw;
var Yi, xn;
const xw = class xw {
  constructor(t) {
    O(this, Yi);
    O(this, xn);
    if (_(this, Yi, /* @__PURE__ */ new Map()), this.keyPrefix = "WEAVY_OFFLINE_CACHE", t)
      _(this, xn, t);
    else
      try {
        Pe(), _(this, xn, window.sessionStorage);
      } catch {
        console.warn("Session storage not available.");
      }
  }
  resetPersistPropertiesCache() {
    y(this, Yi).clear();
  }
  getStorageItem(t, e) {
    const i = y(this, xn)?.getItem(`${t}-${e.toString()}`);
    if (i)
      return JSON.parse(i);
  }
  setStorageItem(t, e, i) {
    const r = JSON.stringify(i);
    r && y(this, xn)?.setItem(`${t}-${e.toString()}`, r);
  }
  persistProperties(t, e, i, r, s) {
    const o = `${this.keyPrefix}:${r ? `${r}:` : ""}${typeof t}:${e}`, c = /* @__PURE__ */ new Map();
    for (const l of i) {
      if (!y(this, Yi).has(l.name)) {
        const p = this.getStorageItem(o, l.name);
        p && (l.override || !t[l.name]) && (c.set(l.name, t[l.name]), t[l.name] = p), y(this, Yi).set(l.name, p);
      }
      if (s?.(c), t[l.name] !== y(this, Yi).get(l.name)) {
        const p = t[l.name];
        y(this, Yi).set(l.name, p), this.setStorageItem(o, l.name, p);
      }
    }
  }
};
Yi = new WeakMap(), xn = new WeakMap(), a(xw, "PersistStorageCache");
let Ip = xw;
var Cn, Cs;
const Cw = class Cw {
  constructor(t) {
    O(this, Cn);
    O(this, Cs);
    _(this, Cn, ""), this.properties = [], this.initialProperties = /* @__PURE__ */ new Map(), this.persistStorageCache = new Ip(), t.addController(this), this.host = t;
  }
  get prefixKey() {
    return y(this, Cn);
  }
  set prefixKey(t) {
    t !== y(this, Cn) && (this.persistStorageCache.resetPersistPropertiesCache(), _(this, Cn, t), this.host.requestUpdate());
  }
  get cachePrefix() {
    return y(this, Cs);
  }
  set cachePrefix(t) {
    t !== y(this, Cs) && (this.persistStorageCache.resetPersistPropertiesCache(), _(this, Cs, t), this.host.requestUpdate());
  }
  observe(t, e, i, r) {
    this.properties = t, this.callback = r;
    const s = !!(this.prefixKey && this.prefixKey !== e || this.cachePrefix && this.cachePrefix !== i);
    this.properties.forEach((o) => {
      s && this.initialProperties.has(o.name) ? this.host[o.name] = this.initialProperties.get(o.name) : this.initialProperties.has(o.name) || this.initialProperties.set(o.name, this.host[o.name]);
    }), e && (this.prefixKey = e), i && (this.cachePrefix = i);
  }
  hostUpdate() {
    this.prefixKey && this.properties && this.host.weavy && this.persistStorageCache.persistProperties(this.host, this.prefixKey, this.properties, this.cachePrefix ? `${this.host.weavy.cachePrefix}:${this.cachePrefix}` : this.host.weavy.cachePrefix, this.callback);
  }
};
Cn = new WeakMap(), Cs = new WeakMap(), a(Cw, "PersistStateController");
let Sn = Cw;
const $w = class $w {
  constructor(t) {
    this.observers = [], this.conditions = {}, this.resizer = new ResizeObserver((e) => {
      let i = !1;
      for (const r of e)
        i = this.checkConditions(r) || i;
      i && this.host.requestUpdate();
    }), t.addController(this), this.host = t;
  }
  checkConditions(t) {
    let e = !1;
    return this.observers.forEach((i) => {
      if (t.target === i.target) {
        const r = this.conditions[i.name], s = i.condition(t);
        r !== s && (this.conditions[i.name] = s, e = !0);
      }
    }), e;
  }
  observe(t) {
    const e = t.target, i = e.getBoundingClientRect();
    this.observers.push(t), this.resizer.observe(e), this.checkConditions({
      contentBoxSize: [
        {
          inlineSize: e.clientWidth,
          blockSize: e.clientHeight
        }
      ],
      borderBoxSize: [
        {
          inlineSize: i.width,
          blockSize: i.height
        }
      ],
      devicePixelContentBoxSize: [
        {
          inlineSize: i.width * window.devicePixelRatio,
          blockSize: i.height * window.devicePixelRatio
        }
      ],
      contentRect: i,
      target: e
    });
  }
  reset() {
    this.conditions = {}, this.observers.length = 0, this.resizer.disconnect();
  }
  hostConnected() {
    this.observers.forEach((t) => {
      this.resizer.observe(t.target);
    });
  }
  hostDisconnected() {
    this.resizer.disconnect();
  }
};
a($w, "ResizeController");
let df = $w;
const kw = class kw {
  constructor(t, e) {
    this.additionalTargets = /* @__PURE__ */ new Set(), this.setExportParts = (i) => {
      (!this.host.hasAttribute("exportparts") || this.shadowParts) && (this.shadowParts ??= /* @__PURE__ */ new Set(), i.forEach((r) => {
        r.part.forEach((s) => this.shadowParts?.add(s)), r.getAttribute("exportparts")?.split(", ").forEach((s) => this.shadowParts?.add(s));
      }), this.shadowParts.size && this.host.setAttribute("exportparts", Array.from(this.shadowParts.values()).join(", ")));
    }, t.addController(this), this.host = t, this.addLocalName = e;
  }
  addPartsFrom(t) {
    t && !this.additionalTargets.has(t) && (this.setExportParts([t]), this.observer?.observe(t, {
      attributeFilter: ["part", "exportparts"]
    }), this.additionalTargets.add(t));
  }
  async hostConnected() {
    if (await this.host.updateComplete, Bw(this.host) && this.host.shadowRoot) {
      const t = Array.from(this.host.shadowRoot.querySelectorAll("[part], [exportparts]"));
      this.setExportParts(t), this.observer = new MutationObserver((e) => {
        const i = e.flatMap((r) => r.type === "attributes" ? [r.target] : Array.from(r.addedNodes)).filter((r) => r instanceof Element);
        this.setExportParts(i);
      }), this.observer.observe(this.host.shadowRoot, {
        subtree: !0,
        childList: !0,
        attributeFilter: ["part", "exportparts"]
      }), Array.from(this.additionalTargets).forEach((e) => {
        this.observer?.observe(e, {
          attributeFilter: ["part", "exportparts"]
        });
      });
    }
  }
  hostUpdated() {
    Bw(this.host) && this.addLocalName !== !1 && !this.host.part.contains(this.host.localName) && (this.addLocalName || getComputedStyle(this.host).display !== "contents") && this.host.part.add(this.host.localName);
  }
  hostDisconnected() {
    this.observer?.disconnect();
  }
};
a(kw, "ShadowPartsController");
let q = kw;
const Pw = class Pw {
  constructor(t) {
    this.delay = NaN, this.sleep = !1, t.addController(this), this.host = t;
  }
  createObserver(t) {
    this.scrollObserver?.disconnect(), this.swipeElement = t, this.scrollObserver = new IntersectionObserver(
      (e) => {
        e.forEach(async (i) => {
          i.isIntersecting && !this.sleep && i.intersectionRatio >= 1 && (this.sleep = !0, Number.isNaN(this.delay) || await new Promise((r) => {
            setTimeout(r, this.delay);
          }), i.target === this.prevElement && this.whenPrev && await this.whenPrev(), i.target === this.nextElement && this.whenNext && await this.whenNext(), await this.host.updateComplete);
        });
      },
      { root: t, threshold: 1, rootMargin: "0px" }
    );
  }
  observe(t, e) {
    this.prevElement && (this.scrollObserver?.unobserve(this.prevElement), this.prevElement = void 0), this.nextElement && (this.scrollObserver?.unobserve(this.nextElement), this.nextElement = void 0), t && (this.scrollObserver?.observe(t), this.prevElement = t), e && (this.scrollObserver?.observe(e), this.nextElement = e), this.sleep = !1;
  }
  clearObserver() {
    this.prevElement = void 0, this.nextElement = void 0, this.scrollObserver?.disconnect(), this.sleep = !1;
  }
  hostConnected() {
    this.scrollObserver && (this.prevElement && this.scrollObserver.observe(this.prevElement), this.nextElement && this.scrollObserver.observe(this.nextElement), this.sleep = !1);
  }
  hostDisconnected() {
    this.scrollObserver?.disconnect();
  }
};
a(Pw, "SwipeScrollController");
let Fp = Pw;
var $s, ed;
const _w = class _w {
  constructor(t, e) {
    O(this, $s);
    O(this, ed);
    _(this, $s, !0), this.styles = [], t.addController(this), this.host = t, e && (this.styles = e);
  }
  get themeColor() {
    return y(this, ed);
  }
  set themeColor(t) {
    _(this, ed, t), this.checkThemeUpdate();
  }
  checkThemeUpdate() {
    const t = this.themeColor || xp(this.host) || Cp();
    if (t && t !== this._resolvedThemeColor) {
      this._resolvedThemeColor = t, console.info("Configuring theme", this._resolvedThemeColor);
      const e = r0(this._resolvedThemeColor).join(""), i = j`
        :host {
          ${S1(e)};
        }
      `, r = this.host.renderRoot;
      M1(r, [...this.styles, i]);
    }
  }
  hostUpdate() {
    y(this, $s) && (this.checkThemeUpdate(), _(this, $s, !1));
  }
  hostConnected() {
    this.cssObserverDisconnect = t0(this.host, () => this.checkThemeUpdate()), this.metaObserverDisconnect = e0(() => this.checkThemeUpdate());
  }
  hostDisconnected() {
    this.cssObserverDisconnect?.(), this.metaObserverDisconnect?.();
  }
};
$s = new WeakMap(), ed = new WeakMap(), a(_w, "ThemeController");
let _e = _w;
const Sw = class Sw {
  constructor(t) {
    this.registrationRequested = !1, this.typingTimeout = null, this.discardTime = 5 * 1e3, this.typingMembers = [], this.names = [], this.ellipsis = "", this.handleRealtimeTyping = (e) => {
      e.entity.id === this.appId && e.actor.id !== this.userId && (this.setTypers(e.actor), this.updateTyping());
    }, this.handleRealtimeStopTyping = (e) => {
      this.typingMembers.forEach((i, r) => {
        i.id === e.actor.id && this.typingMembers.splice(r, 1);
      }), this.updateTyping();
    }, t.addController(this), this.host = t, this.setContexts();
  }
  get weavy() {
    return this.weavyContext?.value;
  }
  get componentFeatures() {
    return this._componentFeatures;
  }
  get appId() {
    return this._appId;
  }
  set appId(t) {
    t !== this._appId && (this.typingMembers = [], this.unregisterRealtime(), this._appId = t, this.registerRealtime());
  }
  get userId() {
    return this._userId;
  }
  set userId(t) {
    t !== this._userId && (this.typingMembers = [], this.unregisterRealtime(), this._userId = t, this.registerRealtime());
  }
  async setContexts() {
    this.whenWeavyContext = new Promise((t) => this.resolveWeavyContext = t), this.whenComponentFeaturesContext = new Promise((t) => this.resolveComponentFeaturesContext = t), await yr(this.host), this.weavyContext = new oi(this.host, { context: he, subscribe: !0 }), this.componentFeaturesContext = new oi(this.host, {
      context: bh,
      subscribe: !0
    });
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
    const t = this.componentFeaturesContext && this.componentFeaturesContext.value?.allowsFeature(S.Typing) !== this._componentFeatures?.allowsFeature(S.Typing);
    t && (this._componentFeatures = this.componentFeaturesContext?.value, this.componentFeaturesContext?.value && this.resolveComponentFeaturesContext?.(this.componentFeaturesContext.value), t && (this.unregisterRealtime(!0), this.registerRealtime()));
  }
  async registerRealtime() {
    !this.registrationRequested && this.appId && this._userId && (this.registrationRequested = !0, await Promise.all([this.whenWeavyContext, this.whenComponentFeaturesContext]), this.componentFeatures?.allowsFeature(S.Typing) && (this.weavy?.subscribe(`a${this.appId}`, "typing", this.handleRealtimeTyping), this.weavy?.subscribe(`a${this.appId}`, "message_created", this.handleRealtimeStopTyping)), this.registrationRequested = !1);
  }
  async unregisterRealtime(t = !1) {
    !this.registrationRequested && this.appId && this.userId && (!t && await this.whenWeavyContext, this.weavy?.unsubscribe(`a${this.appId}`, "typing", this.handleRealtimeTyping), this.weavy?.unsubscribe(`a${this.appId}`, "message_created", this.handleRealtimeStopTyping));
  }
  /**
   * @fires typing
   */
  updateTyping() {
    this.typingTimeout && (clearTimeout(this.typingTimeout), this.typingTimeout = null);
    const t = Date.now();
    if (this.typingMembers.forEach((i, r) => {
      t - i.time > this.discardTime && this.typingMembers.splice(r, 1);
    }), this.typingMembers.length) {
      const i = Date.now(), r = Math.round(
        (i - Math.max.apply(
          null,
          this.typingMembers.map((s) => s.time)
        )) / 1e3
      ) % 3 + 1;
      this.ellipsis = ".".repeat(r), this.names = this.typingMembers.map((s) => s.name).sort(), this.typingTimeout = window.setTimeout(() => this.updateTyping(), 1e3);
    } else
      this.names = [];
    this.host.requestUpdate();
    const e = new CustomEvent("typing", {
      bubbles: !0,
      composed: !1,
      detail: { count: this.typingMembers.length }
    });
    this.host.dispatchEvent(e);
  }
  setTypers(t) {
    this.typingMembers.forEach((i, r) => {
      i.id === t.id && this.typingMembers.splice(r, 1);
    });
    const e = { ...t, time: Date.now() };
    this.typingMembers.push(e);
  }
  hostDisconnected() {
    this.typingTimeout && (clearTimeout(this.typingTimeout), this.typingTimeout = null), this.typingMembers.length = 0, this.names.length = 0, this.weavy && this.unregisterRealtime(!0);
  }
};
a(Sw, "TypingController");
let eh = Sw;
var ks;
const Mw = class Mw {
  constructor(t) {
    O(this, ks);
    this.appTypes = [], _(this, ks, 0), this.registrationRequested = !1, this.handleRefresh = () => {
      this.unreadQuery.result.refetch();
    }, t.addController(this), this.host = t, this.unreadQuery = new qe(t), this.whenWeavyContext = new Promise((e) => this.resolveWeavyContext = e), this.setContexts(), this.registerRealtime();
  }
  /**
   * The number of unread items for the current scope
   */
  get unread() {
    return y(this, ks);
  }
  /**
   * Is the unread count pending?
   */
  get isUnreadPending() {
    return this.unreadQuery.result.isPending;
  }
  /**
   * The underlying query result for the unread count.
   */
  get unreadResult() {
    return this.unreadQuery.result;
  }
  get weavy() {
    return this.weavyContext?.value;
  }
  /**
   * Initiates context consumers
   */
  async setContexts() {
    await yr(this.host), this.weavyContext = new oi(this.host, { context: he, subscribe: !0 });
  }
  /**
   * Dispatch a `wy-unread` event on the host.
   *
   * @fires {WyUnreadEventType} wy-unread - Emitted when the number of unread items change.
   */
  dispatchUnreadEvent() {
    const t = new CustomEvent("wy-unread", {
      detail: { unread: this.unread },
      bubbles: !1,
      composed: !0
    });
    this.host.dispatchEvent(t);
  }
  /**
   * Register realtime handlers.
   */
  async registerRealtime() {
    this.registrationRequested || (this.registrationRequested = !0, await this.whenWeavyContext, this.weavy?.subscribe(null, "message_created", this.handleRefresh), this.weavy?.subscribe(null, "app_marked", this.handleRefresh), this.registrationRequested = !1);
  }
  /**
   * Unregister realtime handlers.
   *
   * @param skipAwait - Skip waiting for any context.
   */
  async unregisterRealtime(t = !1) {
    this.registrationRequested || (!t && await this.whenWeavyContext, this.weavy?.unsubscribe(null, "message_created", this.handleRefresh), this.weavy?.unsubscribe(null, "app_marked", this.handleRefresh));
  }
  async track(t, e) {
    this.appTypes = t, this.agent = e;
    const i = await this.whenWeavyContext;
    await this.unreadQuery.trackQuery(H0(i, t, this.agent), !0);
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
    const t = this.unreadQuery.result?.data?.count ?? 0;
    t !== this.unread && (_(this, ks, t), this.dispatchUnreadEvent(), this.host.requestUpdate());
  }
  hostDisconnected() {
    this.weavy && this.unregisterRealtime(!0);
  }
};
ks = new WeakMap(), a(Mw, "UnreadConversationsController");
let Sc = Mw;
var _t = /* @__PURE__ */ ((n) => (n.All = "", n.Activity = "activity", n.Mention = "mention", n.Reaction = "reaction", n))(_t || {});
function Z0(n, t, e = {}, i) {
  if (n) {
    if (n = JSON.parse(JSON.stringify(n)), n?.pages) {
      let r = -1;
      return {
        pages: [...n.pages.map((o, c) => {
          if (r >= 0)
            return o;
          const l = o.data || [], p = l.filter(
            (v) => v.id !== t.id && !0
          );
          return e && e.by ? (r = p.findIndex((v) => {
            let C = e.by && v[e.by], g = e.by && t[e.by];
            if (e.by === "updated_at" && (C ??= v.created_at, g ??= t.created_at), typeof C == "string" && typeof g == "string") {
              const m = C.localeCompare(g, void 0, {
                sensitivity: "base",
                numeric: !0
              });
              return e.descending ? m < 0 : m > 0;
            }
            return C && g && (e.descending ? C < g : C > g);
          }), r >= 0 ? (p.splice(r, 0, t), o.data = [...p], o.end && (o.end += 1 + p.length - l.length)) : n && c == n.pages.length - 1 && o.end === o.count ? (o.data = [...p, t], o.end && (o.end += 1 + p.length - l.length)) : o.data = [...p]) : c === 0 && (e.descending ? o.data = [t, ...p] : o.data = [...p, t], o.end && (o.end += 1 + p.length - l.length)), o;
        }) ?? []],
        pageParams: [...n.pageParams]
      };
    } else if (n?.data?.length) {
      let r = -1;
      const s = [
        ...n.data?.filter(
          (c) => c.id !== t.id && !0
        ) || []
      ];
      let o = n.count;
      return e && e.by ? (r = s.findIndex((c) => {
        let l = c[e.by], p = t[e.by];
        if (e.by === "updated_at" && (l ??= c.created_at, p ??= t.created_at), typeof l == "string" && typeof p == "string") {
          const v = l.localeCompare(p, void 0, {
            sensitivity: "base",
            numeric: !0
          });
          return e.descending ? v < 0 : v > 0;
        }
        return l && p && (e.descending ? l < p : l > p);
      }), r >= 0 ? s.splice(r, 0, t) : (s.push(t), o++)) : (e.descending ? s.unshift(t) : s.push(t), o++), {
        data: s,
        count: o
      };
    }
  }
  return n;
}
a(Z0, "addToQueryData");
function Km(n, t, e) {
  const i = t === void 0 ? () => !0 : t instanceof Function ? t : (r) => r.id === t;
  return n && (n = JSON.parse(JSON.stringify(n)), n.pages ? {
    pages: n.pages.map((s) => (s.data && (s.data = [
      ...s.data.map((o) => (i(o) && (o = { ...o }, e(o)), o))
    ]), s)) ?? [],
    pageParams: n.pageParams
  } : n.data?.length ? {
    ...n,
    data: [
      ...n.data?.map((r) => (i(r) && (r = { ...r }, e(r)), r)) || []
    ]
  } : n.data ? {
    data: [
      ...n.data.map((s) => (i(s) && (s = { ...s }, e(s)), s))
    ],
    count: n.count
  } : n);
}
a(Km, "updateQueryData");
function Qm(n, t) {
  if (t !== void 0) {
    const e = t instanceof Function ? t : (i) => i.id === t;
    if (n) {
      if (n = JSON.parse(JSON.stringify(n)), n.pages)
        return {
          pages: n.pages.map((r) => (r.data && (r.data = [...r.data.filter((s) => !e(s))]), r)) ?? [],
          pageParams: n.pageParams
        };
      if (n.data?.length) {
        const i = n.data?.length;
        let r = n.count;
        const s = [...n.data?.filter((o) => !e(o)) || []];
        return i !== s.length && r--, {
          data: s,
          count: r
        };
      }
    }
  }
  return n;
}
a(Qm, "removeQueryData");
const Vr = /* @__PURE__ */ a((n, t, e, i) => n.setQueryData(t, (r) => Z0(r, e, i)), "addCacheItem"), Zt = /* @__PURE__ */ a((n, t, e, i) => n.setQueryData(t, (r) => Km(
  r,
  e,
  i
)), "updateCacheItem"), yt = /* @__PURE__ */ a((n, t, e, i) => {
  n.setQueriesData(t, (r) => Km(
    r,
    e,
    i
  ));
}, "updateCacheItems"), kh = /* @__PURE__ */ a((n, t, e) => n.setQueryData(t, (i) => Qm(
  i,
  e
)), "removeCacheItem"), Y0 = /* @__PURE__ */ a((n, t, e) => {
  n.setQueriesData(t, (i) => Qm(i, e));
}, "removeCacheItems"), gl = /* @__PURE__ */ a((n, t, e) => {
  n.setQueriesData(t, (i) => {
    const { count: r } = i;
    return { count: e(r) };
  });
}, "updateCacheItemsCount");
function Hu(n, t, e, i = 1) {
  if (!n)
    return;
  const r = n.getQueryData(t);
  r?.pages?.length && r.pages.length > 1 && n.setQueryData(
    t,
    (s) => ({
      pages: s.pages.slice(0, i),
      pageParams: s.pageParams.slice(0, i)
    }),
    e
  );
}
a(Hu, "keepPages");
function Mn(n, t, e) {
  const i = n.getQueryCache().find({ queryKey: t });
  if (i && i.state.data) {
    const r = i.state.data.pages.flatMap((s) => s.data).filter((s) => s && s.id < 0).sort((s, o) => s && o ? s.id - o.id : 0);
    return r.length ? e ? r[r.length - 1] : r[0] : null;
  }
  return null;
}
a(Mn, "getPendingCacheItem");
function Ph(n, t, e) {
  const i = n.getQueryCache().find({ queryKey: t });
  return i && i.state.data ? i.state.data.pages.flatMap((r) => r.data).find((r) => r?.id === e) : null;
}
a(Ph, "getCacheItem");
function nr(n) {
  return (n?.pages.flatMap((t) => t.data) || []).filter((t) => t);
}
a(nr, "getFlatInfiniteResultData");
function hf(n) {
  return !n || !n?.pages.some((t) => t.data?.length);
}
a(hf, "isInfiniteResultDataEmpty");
function X0(n, t = _t.All, e, i = {}) {
  return {
    ...i,
    initialPageParam: 0,
    queryKey: ["notifications", "list", e, t],
    queryFn: /* @__PURE__ */ a(async (r) => {
      const s = new URLSearchParams({
        skip: r.pageParam?.toString() || "0",
        type: t
      }), o = `/api/${e ? `apps/${e.toString()}/` : ""}notifications?${s.toString()}`, l = await (await n.fetch(o)).json();
      return l.data = l.data || [], l;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ a((r) => {
      if (r.end && r.end < r.count)
        return r.end;
    }, "getNextPageParam")
  };
}
a(X0, "getNotificationsOptions");
function J0(n, t = _t.All, e) {
  const i = n.queryClient.getQueryData(["notifications", "list", e, t])?.pages.flatMap((s) => s.data);
  let r;
  return i?.forEach((s) => {
    r = r && s && r.id > s.id ? r : s;
  }), r;
}
a(J0, "getLastNotification");
function tb(n, t) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ notificationId: i }) => {
      const r = new URL(`/api/${t ? `apps/${t.toString()}/` : ""}notifications/mark`, n.url);
      i && r.searchParams.append("id", i.toString()), await n.fetch(r, { method: "PUT" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((i) => {
      const r = [];
      return yt(
        n.queryClient,
        { queryKey: t ? ["notifications", "list", t] : ["notifications", "list"], exact: !1 },
        void 0,
        (s) => {
          r.push({ id: s.id, is_unread: s.is_unread }), s.is_unread = !1;
        }
      ), t && r.length && yt(
        n.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        (s) => !!r.find((o) => o.id === s.id && s.is_unread),
        (s) => {
          s.is_unread = !1;
        }
      ), t || gl(
        n.queryClient,
        { queryKey: ["notifications", "unread"], exact: !1 },
        () => 0
      ), gl(
        n.queryClient,
        {
          queryKey: t ? ["apps", "notifications", "unread", t] : ["apps", "notifications", "unread"],
          exact: !1
        },
        () => 0
      ), { changedNotifications: r };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a(async () => {
      t && await n.queryClient.invalidateQueries({ queryKey: ["notifications", "unread"], exact: !1 });
    }, "onSuccess"),
    onSettled: /* @__PURE__ */ a(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["notifications", "list"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["notifications", "unread"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["apps", "notifications", "unread"], exact: !1 });
    }, "onSettled"),
    onError: /* @__PURE__ */ a((i, r, s) => {
      console.error(i.message);
    }, "onError")
  };
}
a(tb, "getMarkNotificationsMutationOptions");
function eb(n, t) {
  return new Mt(n.queryClient, tb(n, t));
}
a(eb, "getMarkNotificationsMutation");
function ib(n) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ markAsRead: e, notificationId: i }) => {
      const r = `/api/notifications/${i}/mark`;
      await n.fetch(r, { method: e ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((e) => {
      const i = /* @__PURE__ */ new Map();
      yt(
        n.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        e.notificationId,
        (r) => {
          !!r.is_unread === e.markAsRead && i.set(r.id, r), r.is_unread = !e.markAsRead;
        }
      ), i.size && (gl(
        n.queryClient,
        {
          queryKey: ["notifications", "unread"],
          predicate: /* @__PURE__ */ a((r) => r.queryKey[3] === "" || r.queryKey[3] === i.values().next().value?.type, "predicate"),
          exact: !1
        },
        (r) => Math.max(0, r + (e.markAsRead ? -1 : 1))
      ), i.forEach((r) => {
        r.link?.app && gl(
          n.queryClient,
          {
            queryKey: ["apps", "notifications", "unread"],
            predicate: /* @__PURE__ */ a((s) => {
              const o = s.queryKey[3] === r.link?.app?.id || s.queryKey[3] === r.link?.app?.uid, c = s.queryKey[4] === "" || s.queryKey[4] === r.type;
              return o && c;
            }, "predicate"),
            exact: !1
          },
          (s) => Math.max(0, s + (e.markAsRead ? -1 : 1))
        );
      }));
    }, "onMutate"),
    onError: /* @__PURE__ */ a(async (e, i) => {
      yt(
        n.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        i.notificationId,
        (r) => {
          r.is_unread = i.markAsRead;
        }
      ), await n.queryClient.invalidateQueries({ queryKey: ["notifications", "unread"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["apps", "notifications", "unread"], exact: !1 });
    }, "onError")
  };
}
a(ib, "getMarkNotificationMutationOptions");
function Gm(n) {
  return new Mt(n.queryClient, ib(n));
}
a(Gm, "getMarkNotificationMutation");
function rb(n, t = _t.All, e, i = {}) {
  const r = new URLSearchParams({
    type: t,
    count_only: "true",
    unread: "true"
  }), s = `/api/${e ? `apps/${e.toString()}/` : ""}notifications?${r.toString()}`;
  return hd(n, e ? ["apps", "notifications", "unread", e, t] : ["notifications", "unread", t], s, i);
}
a(rb, "getUnreadOptions");
var Ps;
const Aw = class Aw {
  constructor(t) {
    O(this, Ps);
    this.typeFilter = _t.All, _(this, Ps, 0), this.registrationRequested = !1, this.handleRefresh = () => {
      this.unreadQuery.result.refetch();
    }, t.addController(this), this.host = t, this.unreadQuery = new qe(t), this.whenWeavyContext = new Promise((e) => this.resolveWeavyContext = e), this.setContexts(), this.registerRealtime();
  }
  /**
   * The number of unread notifications for the current scope
   */
  get unread() {
    return y(this, Ps);
  }
  /**
   * Is the unread count pending?
   */
  get isUnreadPending() {
    return this.unreadQuery.result.isPending;
  }
  /**
   * The underlying query result for the unread count.
   */
  get unreadResult() {
    return this.unreadQuery.result;
  }
  get weavy() {
    return this.weavyContext?.value;
  }
  /**
   * Initiates context consumers
   */
  async setContexts() {
    await yr(this.host), this.weavyContext = new oi(this.host, { context: he, subscribe: !0 });
  }
  /**
   * Dispatch a `wy-unread` event on the host.
   *
   * @fires {WyUnreadEventType} wy-unread - Emitted when the number of unread notifications change.
   */
  dispatchNotificationUnreadEvent() {
    const t = new CustomEvent("wy-unread", {
      detail: { unread: this.unread },
      bubbles: !1,
      composed: !0
    });
    this.host.dispatchEvent(t);
  }
  /**
   * Register realtime handlers.
   */
  async registerRealtime() {
    this.registrationRequested || (this.registrationRequested = !0, await this.whenWeavyContext, this.weavy?.subscribe(null, "notification_created", this.handleRefresh), this.weavy?.subscribe(null, "notification_updated", this.handleRefresh), this.weavy?.subscribe(null, "notifications_marked", this.handleRefresh), this.registrationRequested = !1);
  }
  /**
   * Unregister realtime handlers.
   *
   * @param skipAwait - Skip waiting for any context.
   */
  async unregisterRealtime(t = !1) {
    this.registrationRequested || (!t && await this.whenWeavyContext, this.weavy?.unsubscribe(null, "notification_created", this.handleRefresh), this.weavy?.unsubscribe(null, "notification_updated", this.handleRefresh), this.weavy?.unsubscribe(null, "notifications_marked", this.handleRefresh));
  }
  /**
   * Tracks unread data. Initiates the query data with the given filtering scope.
   *
   * @param typeFilter - The notification types to track.
   * @param appId - Optional app id for the filtering scope.
   */
  async track(t, e) {
    this.appId = e, this.typeFilter = t;
    const i = await this.whenWeavyContext;
    this.markNotificationsMutation = eb(i, this.appId), await this.unreadQuery.trackQuery(rb(i, this.typeFilter, this.appId), !0);
  }
  async markAllAsRead() {
    const t = await this.whenWeavyContext, e = J0(t, _t.All, this.appId)?.id;
    await this.markNotificationsMutation?.mutate({ notificationId: e });
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
    const t = this.unreadQuery.result?.data?.count ?? 0;
    t !== this.unread && (_(this, Ps, t), this.dispatchNotificationUnreadEvent(), this.host.requestUpdate());
  }
  hostDisconnected() {
    this.weavy && this.unregisterRealtime(!0);
  }
};
Ps = new WeakMap(), a(Aw, "UnreadNotificationsController");
let bl = Aw;
var nb = Object.defineProperty, Zm = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = void 0, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = o(t, e, r) || r);
  return r && nb(t, e, r), r;
}, "__decorateClass$1g");
const Ew = class Ew extends Re {
  constructor() {
    super(...arguments), this.appType = Fr;
  }
};
a(Ew, "WeavyOptionalAppComponent");
let Hr = Ew;
Zm([
  D()
], Hr.prototype, "appType");
Zm([
  u({ converter: Fm })
], Hr.prototype, "uid");
var ab = Object.defineProperty, fy = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = void 0, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = o(t, e, r) || r);
  return r && ab(t, e, r), r;
}, "__decorateClass$1f"), _s, id, Ss, rd, Ms, nd;
const Rw = class Rw extends it {
  constructor() {
    super(...arguments);
    O(this, _s);
    O(this, id, new Promise((e) => {
      _(this, _s, e);
    }));
    O(this, Ss);
    O(this, rd, new Promise((e) => {
      _(this, Ss, e);
    }));
    O(this, Ms);
    O(this, nd, new Promise((e) => {
      _(this, Ms, e);
    }));
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  /**
   * Resolves when a contextual id is available.
   *
   * @internal
   * @returns {Promise<ContextIdType>}
   */
  async whenContextId() {
    return await y(this, id);
  }
  /**
   * Resolves when current user data is available.
   *
   * @internal
   * @returns {Promise<UserType>}
   */
  async whenUser() {
    return await y(this, rd);
  }
  /**
   * Resolves when a weavy context is available.
   *
   * @internal
   * @returns {Promise<WeavyType>}
   */
  async whenWeavy() {
    return await y(this, nd);
  }
  willUpdate(e) {
    var i, r, s;
    super.willUpdate(e), e.has("contextId") && this.contextId && (e.get("contextId") && _(this, id, new Promise((o) => {
      _(this, _s, o);
    })), (i = y(this, _s)) == null || i.call(this, this.contextId)), e.has("user") && this.user && (e.get("user") && _(this, rd, new Promise((o) => {
      _(this, Ss, o);
    })), (r = y(this, Ss)) == null || r.call(this, this.user)), e.has("weavy") && this.weavy && (e.get("weavy") && _(this, nd, new Promise((o) => {
      _(this, Ms, o);
    })), (s = y(this, Ms)) == null || s.call(this, this.weavy));
  }
  connectedCallback() {
    super.connectedCallback(), this.contextId && this.requestUpdate("contextId"), this.user && this.requestUpdate("user"), this.weavy && this.requestUpdate("weavy");
  }
};
_s = new WeakMap(), id = new WeakMap(), Ss = new WeakMap(), rd = new WeakMap(), Ms = new WeakMap(), nd = new WeakMap(), a(Rw, "WeavySubComponent");
let Te = Rw;
fy([
  be({ context: Sm, subscribe: !0 }),
  D()
], Te.prototype, "contextId");
fy([
  be({ context: xh, subscribe: !0 }),
  D()
], Te.prototype, "user");
fy([
  be({ context: he, subscribe: !0 }),
  D()
], Te.prototype, "weavy");
var sb = Object.defineProperty, pd = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = void 0, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = o(t, e, r) || r);
  return r && sb(t, e, r), r;
}, "__decorateClass$1e"), As, ad, Es, sd, Rs, od, Ts, cd, Ls, ld;
const Tw = class Tw extends Te {
  constructor() {
    super(...arguments);
    O(this, As);
    O(this, ad, new Promise((e) => {
      _(this, As, e);
    }));
    O(this, Es);
    O(this, sd, new Promise((e) => {
      _(this, Es, e);
    }));
    O(this, Rs);
    O(this, od, new Promise((e) => {
      _(this, Rs, e);
    }));
    O(this, Ts);
    O(this, cd, new Promise((e) => {
      _(this, Ts, e);
    }));
    O(this, Ls);
    O(this, ld, new Promise((e) => {
      _(this, Ls, e);
    }));
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  /**
   * Resolves when app data is available.
   *
   * @returns {Promise<AppType>}
   */
  async whenApp() {
    return await y(this, ad);
  }
  // #resolveAgentUser?: (agentUser: AgentType) => void;
  // #whenAgentUser = new Promise<AgentType>((r) => {
  //   this.#resolveAgentUser = r;
  // });
  // async whenAgentUser() {
  //   return await this.#whenAgentUser;
  // }
  /**
   * Resolves when context data blob uploads has finished.
   *
   * @internal
   * @returns {Promise<ContextDataBlobsType>}
   */
  async whenContextDataBlobs() {
    return await y(this, sd);
  }
  /**
   * Resolves when weavy component features config is available.
   *
   * @internal
   * @returns {Promise<ComponentFeaturePolicy>}
   */
  async whenComponentFeatures() {
    return await y(this, od);
  }
  /**
   * Resolves when a provided link is available.
   *
   * @returns {Promise<LinkType>}
   */
  async whenLink() {
    return await y(this, cd);
  }
  /**
   * Resolves when weavy component settings are available.
   *
   * @internal
   * @returns {Promise<WeavyComponentSettingsType>}
   */
  async whenSettings() {
    return await y(this, ld);
  }
  willUpdate(e) {
    var i, r, s, o, c;
    super.willUpdate(e), e.has("app") && this.app && (e.get("app") && _(this, ad, new Promise((l) => {
      _(this, As, l);
    })), (i = y(this, As)) == null || i.call(this, this.app)), e.has("contextDataBlobs") && this.contextDataBlobs && (e.get("contextDataBlobs") && _(this, sd, new Promise((l) => {
      _(this, Es, l);
    })), (r = y(this, Es)) == null || r.call(this, this.contextDataBlobs)), e.has("componentFeatures") && this.componentFeatures && (e.get("componentFeatures") && _(this, od, new Promise((l) => {
      _(this, Rs, l);
    })), (s = y(this, Rs)) == null || s.call(this, this.componentFeatures)), e.has("link") && this.link && (e.get("link") && _(this, cd, new Promise((l) => {
      _(this, Ts, l);
    })), (o = y(this, Ts)) == null || o.call(this, this.link)), e.has("settings") && this.settings && (e.get("settings") && _(this, ld, new Promise((l) => {
      _(this, Ls, l);
    })), (c = y(this, Ls)) == null || c.call(this, this.settings));
  }
  connectedCallback() {
    super.connectedCallback(), this.app && this.requestUpdate("app"), this.contextDataBlobs && this.requestUpdate("contextDataBlobs"), this.componentFeatures && this.requestUpdate("componentFeatures"), this.link && this.requestUpdate("link"), this.settings && this.requestUpdate("settings");
  }
};
As = new WeakMap(), ad = new WeakMap(), Es = new WeakMap(), sd = new WeakMap(), Rs = new WeakMap(), od = new WeakMap(), Ts = new WeakMap(), cd = new WeakMap(), Ls = new WeakMap(), ld = new WeakMap(), a(Tw, "WeavySubAppComponent");
let Dt = Tw;
pd([
  be({ context: cy, subscribe: !0 }),
  D()
], Dt.prototype, "app");
pd([
  be({ context: Mm, subscribe: !0 }),
  D()
], Dt.prototype, "contextDataBlobs");
pd([
  be({ context: bh, subscribe: !0 }),
  D()
], Dt.prototype, "componentFeatures");
pd([
  be({ context: Em, subscribe: !0 }),
  D()
], Dt.prototype, "link");
pd([
  be({ context: Rm, subscribe: !0 }),
  D()
], Dt.prototype, "settings");
function ob(n) {
  return typeof n == "string" && n ? n = eval?.(`"use strict";(${n})`) : n = void 0, n;
}
a(ob, "indirectEvalObject");
function my(n) {
  if (n)
    try {
      return new URL(n, window.location.toString());
    } catch {
      console.warn("Invalid url: ", n);
    }
}
a(my, "toUrl");
const B = /* @__PURE__ */ a((n) => (t, e) => {
  e !== void 0 ? e.addInitializer(() => {
    !customElements.get(n) && customElements.define(
      n,
      t
    );
  }) : !customElements.get(n) && customElements.define(n, t);
}, "customElement"), X = j`:host{display:contents}`;
var cb = Object.defineProperty, lb = Object.getOwnPropertyDescriptor, ue = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? lb(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && cb(t, e, r), r;
}, "__decorateClass$1d");
function uf(n) {
  return n != null && n !== !1;
}
a(uf, "acceptedValue");
var Os;
let Yt = (Os = class extends it {
  constructor() {
    super(), this.provider = !1, this.annotations = Gt.defaults.annotations, this.cloudFilePickerUrl = Gt.defaults.cloudFilePickerUrl, this.configurationTimeout = Gt.defaults.configurationTimeout, this.disableEnvironmentImports = Gt.defaults.disableEnvironmentImports, this.enterToSend = Gt.defaults.enterToSend, this.locale = Gt.defaults.locale, this.locales = Gt.defaults.locales, this.gcTime = Gt.defaults.gcTime, this.scrollBehavior = Gt.defaults.scrollBehavior, this.staleTime = Gt.defaults.staleTime, this.tokenFactory = Gt.defaults.tokenFactory, this.tokenFactoryRetryDelay = Gt.defaults.tokenFactoryRetryDelay, this.tokenFactoryTimeout = Gt.defaults.tokenFactoryTimeout, this.tokenUrl = Gt.defaults.tokenUrl, this.url = Gt.defaults.url, this.reactions = Gt.defaults.reactions, this.childElementCount && (this.provider = !0), this.weavy ??= new Gt({ host: this.provider ? this : void 0 });
  }
  /** The semver version of the package. */
  get version() {
    return Gt.version;
  }
  /** The Weavy source name; package name. */
  get sourceName() {
    return Gt.sourceName;
  }
  willUpdate(t) {
    if (super.willUpdate(t), this.weavy) {
      const e = {};
      Array.from(t.keys()).forEach((i) => {
        i !== "weavy" && (uf(this[i]) || uf(t.get(i))) && Object.assign(e, { [i]: this[i] });
      }), Object.assign(this.weavy, e);
    }
  }
  render() {
    return h` <slot></slot> `;
  }
}, a(Os, "WyContext"), Os);
Yt.styles = [se, X];
ue([
  u({ attribute: !0, type: Boolean })
], Yt.prototype, "provider", 2);
ue([
  u()
], Yt.prototype, "annotations", 2);
ue([
  u({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ a((n) => my(n), "fromAttribute")
    }
  })
], Yt.prototype, "cloudFilePickerUrl", 2);
ue([
  u({ type: Number, attribute: !0 })
], Yt.prototype, "configurationTimeout", 2);
ue([
  u({ type: Boolean })
], Yt.prototype, "disableEnvironmentImports", 2);
ue([
  u({ attribute: !0 })
], Yt.prototype, "enterToSend", 2);
ue([
  u({ attribute: !0 })
], Yt.prototype, "locale", 2);
ue([
  u({ attribute: !0, type: Array })
], Yt.prototype, "locales", 2);
ue([
  u({ attribute: !0, type: Number })
], Yt.prototype, "gcTime", 2);
ue([
  u({ attribute: !0 })
], Yt.prototype, "scrollBehavior", 2);
ue([
  u({ attribute: !0, type: Number })
], Yt.prototype, "staleTime", 2);
ue([
  u({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ a((n) => ob(n), "fromAttribute")
    }
  })
], Yt.prototype, "tokenFactory", 2);
ue([
  u({ attribute: !0, type: Number })
], Yt.prototype, "tokenFactoryRetryDelay", 2);
ue([
  u({ attribute: !0, type: Number })
], Yt.prototype, "tokenFactoryTimeout", 2);
ue([
  u({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ a((n) => my(n), "fromAttribute")
    }
  })
], Yt.prototype, "tokenUrl", 2);
ue([
  u({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ a((n) => my(n), "fromAttribute")
    }
  })
], Yt.prototype, "url", 2);
ue([
  u({ attribute: !0 })
], Yt.prototype, "reactions", 2);
ue([
  D()
], Yt.prototype, "weavy", 2);
Yt = ue([
  B("wy-context")
], Yt);
const Fe = j`:host{font-family:var(--wy-font-family, unset)}`;
var db = Object.defineProperty, hb = Object.getOwnPropertyDescriptor, vy = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? hb(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && db(t, e, r), r;
}, "__decorateClass$1c"), zs;
let Mc = (zs = class extends Re {
  constructor() {
    super(...arguments), this.appType = Fr, this.componentFeatures = new le(ly(_p)), this.theme = new _e(this, Mc.styles);
  }
  render() {
    return h`<slot></slot>`;
  }
}, a(zs, "WyComponent"), zs);
Mc.styles = [se, X, Fe];
vy([
  u({
    converter: {
      fromAttribute(n, t) {
        return O0.get(n) ?? n;
      }
    }
  })
], Mc.prototype, "appType", 2);
vy([
  u({
    converter: {
      fromAttribute(n, t) {
        const e = typeof n == "string" ? Am(n, _p) : _p;
        return new le(ly(e));
      }
    }
  })
], Mc.prototype, "componentFeatures", 2);
Mc = vy([
  B("wy-component")
], Mc);
const wr = j`:host{position:relative;display:flex;flex-direction:column;flex:1;min-height:3rem;min-width:16rem;isolation:isolate;box-sizing:border-box;container-type:inline-size}`, Gn = j`:host{padding:var(--wy-padding-outer, 0);border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}`, Zn = j`:host{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}:host:not(body){-webkit-overflow-scrolling:touch}`;
function ub(n, t, e = {}) {
  return {
    ...e,
    initialPageParam: 0,
    queryKey: ["messages", t],
    queryFn: /* @__PURE__ */ a(async (i) => {
      const r = i.pageParam, s = "/api/apps/" + t + "/messages?order_by=id+desc&skip=" + r, c = await (await n.fetch(s)).json();
      return c.data = c.data?.reverse() || [], c;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ a((i) => {
      if (i?.end && i?.end < i?.count)
        return i.end;
    }, "getNextPageParam"),
    select: /* @__PURE__ */ a((i) => ({
      // reverse scroll
      pages: [...i.pages].reverse(),
      pageParams: [...i.pageParams].reverse()
    }), "select")
  };
}
a(ub, "getMessagesOptions");
function pb(n, t) {
  return {
    mutationFn: /* @__PURE__ */ a(async (i) => await (await n.fetch("/api/apps/" + i.app_id + "/messages", {
      method: "POST",
      body: JSON.stringify({
        text: i.text,
        blobs: i.blobs,
        embed_id: i.embed_id || null,
        meeting_id: i.meeting_id,
        options: i.poll_options.filter((s) => s.text.trim() !== "").map((s) => ({ text: s.text })),
        metadata: i.metadata || null,
        context: i.context
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ a((i) => {
      const r = ["messages", i.app_id], s = Mn(n.queryClient, r, !1), o = {
        id: s ? s.id - 1 : -1,
        app: { id: i.app_id },
        text: i.text,
        html: i.text,
        plain: i.text,
        created_by: i.user,
        created_at: (/* @__PURE__ */ new Date()).toUTCString(),
        attachments: { count: 0 },
        reactions: { count: 0 },
        is_starred: !1,
        is_subscribed: !0,
        is_trashed: !1
      };
      Vr(n.queryClient, r, o);
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((i) => {
      yt(
        n.queryClient,
        { queryKey: ["members", i.app.id] },
        i.created_by.id,
        (p) => {
          p.marked_id = i.id, p.marked_at = i.created_at;
        }
      );
      const r = ["messages", i.app.id], { queryClient: s } = n, o = Ph(s, r, i.id), c = o ? null : Mn(s, r, !0), l = /* @__PURE__ */ a((p, v) => {
        Zt(s, r, p, (C) => {
          C.id = v.id, C.app = v.app, C.text = v.text, C.plain = v.plain, C.html = v.html, C.embed = v.embed, C.meeting = v.meeting, C.attachments = v.attachments, C.options = v.options, C.created_at = v.created_at, C.created_by = v.created_by, C.updated_at = v.updated_at, C.updated_by = v.updated_by;
        });
      }, "replaceCacheItem");
      o ? l(o.id, i) : c ? l(c.id, i) : Vr(s, r, i);
    }, "onSuccess")
  };
}
a(pb, "getAddMessageMutationOptions");
const { I: yb } = A1, wb = /* @__PURE__ */ a((n) => n.strings === void 0, "f$1"), pf = /* @__PURE__ */ a(() => document.createComment(""), "r$1"), ll = /* @__PURE__ */ a((n, t, e) => {
  const i = n._$AA.parentNode, r = t === void 0 ? n._$AB : t._$AA;
  if (e === void 0) {
    const s = i.insertBefore(pf(), r), o = i.insertBefore(pf(), r);
    e = new yb(s, o, n, n.options);
  } else {
    const s = e._$AB.nextSibling, o = e._$AM, c = o !== n;
    if (c) {
      let l;
      e._$AQ?.(n), e._$AM = n, e._$AP !== void 0 && (l = n._$AU) !== o._$AU && e._$AP(l);
    }
    if (s !== r || c) {
      let l = e._$AA;
      for (; l !== s; ) {
        const p = l.nextSibling;
        i.insertBefore(l, r), l = p;
      }
    }
  }
  return e;
}, "s$1"), sn = /* @__PURE__ */ a((n, t, e = n) => (n._$AI(t, e), n), "v"), fb = {}, Ym = /* @__PURE__ */ a((n, t = fb) => n._$AH = t, "m"), mb = /* @__PURE__ */ a((n) => n._$AH, "p"), Bu = /* @__PURE__ */ a((n) => {
  n._$AR(), n._$AA.remove();
}, "M");
const yd = { ATTRIBUTE: 1, CHILD: 2 }, Yn = /* @__PURE__ */ a((n) => (...t) => ({ _$litDirective$: n, values: t }), "e$2");
var Is;
let Qc = (Is = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, i) {
    this._$Ct = t, this._$AM = e, this._$Ci = i;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
}, a(Is, "i"), Is);
const yl = /* @__PURE__ */ a((n, t) => {
  const e = n._$AN;
  if (e === void 0) return !1;
  for (const i of e) i._$AO?.(t, !1), yl(i, t);
  return !0;
}, "s"), ih = /* @__PURE__ */ a((n) => {
  let t, e;
  do {
    if ((t = n._$AM) === void 0) break;
    e = t._$AN, e.delete(n), n = t;
  } while (e?.size === 0);
}, "o$5"), Xm = /* @__PURE__ */ a((n) => {
  for (let t; t = n._$AM; n = t) {
    let e = t._$AN;
    if (e === void 0) t._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(n)) break;
    e.add(n), bb(t);
  }
}, "r");
function vb(n) {
  this._$AN !== void 0 ? (ih(this), this._$AM = n, Xm(this)) : this._$AM = n;
}
a(vb, "h$1");
function gb(n, t = !1, e = 0) {
  const i = this._$AH, r = this._$AN;
  if (r !== void 0 && r.size !== 0) if (t) if (Array.isArray(i)) for (let s = e; s < i.length; s++) yl(i[s], !1), ih(i[s]);
  else i != null && (yl(i, !1), ih(i));
  else yl(this, n);
}
a(gb, "n$2");
const bb = /* @__PURE__ */ a((n) => {
  n.type == yd.CHILD && (n._$AP ??= gb, n._$AQ ??= vb);
}, "c$1"), Lw = class Lw extends Qc {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, e, i) {
    super._$AT(t, e, i), Xm(this), this.isConnected = t._$AU;
  }
  _$AO(t, e = !0) {
    t !== this.isConnected && (this.isConnected = t, t ? this.reconnected?.() : this.disconnected?.()), e && (yl(this, t), ih(this));
  }
  setValue(t) {
    if (wb(this._$Ct)) this._$Ct._$AI(t, this);
    else {
      const e = [...this._$Ct._$AH];
      e[this._$Ci] = t, this._$Ct._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};
a(Lw, "f");
let Dp = Lw;
const nt = /* @__PURE__ */ a(() => new Vp(), "e$1"), Ow = class Ow {
};
a(Ow, "h");
let Vp = Ow;
const Nu = /* @__PURE__ */ new WeakMap(), Q = Yn(class extends Dp {
  render(n) {
    return b;
  }
  update(n, [t]) {
    const e = t !== this.G;
    return e && this.G !== void 0 && this.rt(void 0), (e || this.lt !== this.ct) && (this.G = t, this.ht = n.options?.host, this.rt(this.ct = n.element)), b;
  }
  rt(n) {
    if (this.isConnected || (n = void 0), typeof this.G == "function") {
      const t = this.ht ?? globalThis;
      let e = Nu.get(t);
      e === void 0 && (e = /* @__PURE__ */ new WeakMap(), Nu.set(t, e)), e.get(this.G) !== void 0 && this.G.call(this.ht, void 0), e.set(this.G, n), n !== void 0 && this.G.call(this.ht, n);
    } else this.G.value = n;
  }
  get lt() {
    return typeof this.G == "function" ? Nu.get(this.ht ?? globalThis)?.get(this.G) : this.G?.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
function xb(n, t, e) {
  const i = n.queryClient;
  return {
    mutationKey: ["apps", t, "polls"],
    mutationFn: /* @__PURE__ */ a(async ({ optionId: o }) => {
      const c = await n.fetch(`/api/options/${o}/vote`, { method: "POST" });
      if (!c.ok) {
        const l = await c.json();
        throw new Error(l.detail || l.title, { cause: l });
      }
      return await c.json();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((o) => (yt(i, { queryKey: e }, o.parentId, (c) => {
      c.options?.data && (c.options.data = c.options.data?.map((l) => {
        if (l.has_voted) {
          l.has_voted = !1;
          const p = l.votes?.count || 1;
          l.votes ? l.votes.count = p - 1 : l.votes = { count: p - 1 };
        } else if (!l.has_voted && l.id === o.optionId) {
          l.has_voted = !0;
          const p = l.votes?.count || 0;
          l.votes ? l.votes.count = p + 1 : l.votes = { count: p + 1 };
        }
        return l;
      }));
    }), { id: o.optionId }), "onMutate"),
    onSuccess: /* @__PURE__ */ a(async (o, c) => {
      const p = await (await n.fetch("/api/" + c.parentType + "/" + c.parentId)).json();
      yt(
        i,
        { queryKey: e, exact: !1 },
        c.parentId,
        (v) => Object.assign(v, p)
      );
    }, "onSuccess")
    /*onError(error: Error, variables: MutatePollVariables) {
      updateCacheItems(queryClient, { queryKey: postsKey, exact: false }, variables.id, (existingPost: PostType) => Object.assign(existingPost, { is_subscribed: variables..is_subscribed }));
    },*/
  };
}
a(xb, "getPollMutationOptions");
function gy(n, t, e) {
  return new Mt(n.queryClient, xb(n, t, e));
}
a(gy, "getPollMutation");
function Cb(n, t) {
  return {
    queryKey: ["votes", t],
    enabled: !1,
    queryFn: /* @__PURE__ */ a(async () => await (await n.fetch(`/api/options/${t}`)).json(), "queryFn")
  };
}
a(Cb, "getVotesOptions");
const Ac = /* @__PURE__ */ a((n, t) => !!(n && t && t.indexOf(n) !== -1), "hasPermission");
function $b(n) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ app: e, messageId: i }) => {
      const r = i ? `/api/apps/${e.id}/mark?messageId=${i}` : `/api/apps/${e.id}/mark`;
      await n.fetch(r, { method: i ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a(async (e) => {
      await n.queryClient.cancelQueries({ queryKey: ["apps", e.app.id] }), await n.queryClient.cancelQueries({ queryKey: ["apps", "list"], exact: !1 }), await n.queryClient.cancelQueries({ queryKey: ["apps", "unread"], exact: !1 }), await n.queryClient.cancelQueries({ queryKey: ["members", e.app.id] }), n.queryClient.setQueryData(
        ["apps", e.app.id],
        (i) => i && { ...i, is_unread: !e.messageId || e.messageId < i.last_message.id }
      ), yt(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        e.app.id,
        (i) => {
          i.is_unread = !e.messageId || e.messageId < i.last_message.id;
        }
      ), e.userId && yt(n.queryClient, { queryKey: ["members", e.app.id] }, e.userId, (i) => {
        e.messageId ? (i.marked_at = (/* @__PURE__ */ new Date()).toISOString(), i.marked_id = e.messageId) : (i.marked_at = void 0, i.marked_id = void 0);
      }), gl(
        n.queryClient,
        {
          queryKey: ["apps", "unread"],
          exact: !1,
          predicate: /* @__PURE__ */ a((i) => {
            const s = i.queryKey[2].includes(e.app.type), o = i.queryKey[2], c = !o || !!e.app.members.data?.find((l) => l.uid && l.uid === o);
            return s && c;
          }, "predicate")
        },
        (i) => Math.max(0, i + (e.messageId ? -1 : 1))
      );
    }, "onMutate"),
    onError: /* @__PURE__ */ a((e, i) => {
      console.error(e.message), yt(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        i.app.id,
        (r) => {
          r.is_unread = !r.is_unread;
        }
      );
    }, "onError"),
    onSettled: /* @__PURE__ */ a(async (e, i, r) => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps", r.app.id] }), await n.queryClient.invalidateQueries({ queryKey: ["apps", "list"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["apps", "unread"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["members", r.app.id] });
    }, "onSettled")
  };
}
a($b, "getMarkConversationMutationOptions");
function kb(n) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ appId: e, star: i }) => {
      await n.fetch(`/api/apps/${e}/stars`, { method: i ? "POST" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((e) => {
      yt(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        e.appId,
        (i) => {
          i.is_starred = e.star;
        }
      );
    }, "onMutate"),
    onError: /* @__PURE__ */ a((e, i) => {
      console.error(e.message), yt(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        i.appId,
        (r) => {
          r.is_starred = !i.star;
        }
      );
    }, "onError")
  };
}
a(kb, "getStarConversationMutationOptions");
function Pb(n) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ appId: e, pin: i }) => {
      await n.fetch(`/api/apps/${e}/pin`, { method: i ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((e) => {
      yt(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        e.appId,
        (i) => {
          i.is_pinned = e.pin;
        }
      );
    }, "onMutate"),
    onSettled: /* @__PURE__ */ a(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
a(Pb, "getPinConversationMutationOptions");
function _b(n) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ appId: e, members: i }) => {
      await n.fetch(`/api/apps/${e}/members/${i.join(",")}`, { method: "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((e) => {
      kh(n.queryClient, ["apps", "list"], e.appId);
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((e, i) => {
      n.queryClient.removeQueries({ queryKey: ["apps", i.appId] }), n.queryClient.removeQueries({ queryKey: ["members", i.appId] });
    }, "onSuccess"),
    onSettled: /* @__PURE__ */ a(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] }), await n.queryClient.invalidateQueries({ queryKey: ["members"] });
    }, "onSettled")
  };
}
a(_b, "getLeaveConversationMutationOptions");
function Sb(n) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ appId: e }) => {
      await n.fetch(`/api/apps/${e}/remove`, { method: "POST" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((e) => {
      kh(n.queryClient, ["apps", "list"], e.appId);
    }, "onMutate"),
    onSettled: /* @__PURE__ */ a(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
a(Sb, "getRemoveConversationMutationOptions");
function Mb(n) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ appId: e, userId: i, access: r }) => {
      await n.fetch(`/api/apps/${e}/members/${i}`, { method: "PUT", body: JSON.stringify({ access: r }) });
    }, "mutationFn"),
    onSettled: /* @__PURE__ */ a(async (e, i, r) => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] }), await n.queryClient.invalidateQueries({ queryKey: ["members", r.appId] });
    }, "onSettled")
  };
}
a(Mb, "getUpdateMemberMutationOptions");
function Ab(n) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ appId: e, members: i }) => {
      await n.fetch(`/api/apps/${e}/members`, {
        method: "PUT",
        body: JSON.stringify(
          i.map((r) => ({ id: r, access: "write" }))
        )
      });
    }, "mutationFn"),
    onSettled: /* @__PURE__ */ a(async (e, i, r) => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] }), await n.queryClient.invalidateQueries({ queryKey: ["members", r.appId] });
    }, "onSettled")
  };
}
a(Ab, "getAddMembersToConversationMutationOptions");
function Eb(n) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ appId: e, name: i, blobId: r }) => await (await n.fetch(`/api/apps/${e}`, {
      method: "PATCH",
      body: JSON.stringify({
        name: i,
        picture: r
      })
    })).json(), "mutationFn"),
    onMutate: /* @__PURE__ */ a((e) => {
      const i = /* @__PURE__ */ a((r) => {
        typeof e.name == "string" && (r.name = e.name), typeof e?.thumbnailUrl == "string" && (r.avatar_url = e.thumbnailUrl);
      }, "modifyAppItem");
      Zt(n.queryClient, ["apps", e.appId], void 0, i), yt(n.queryClient, { queryKey: ["apps", "list"], exact: !1 }, e.appId, i);
    }, "onMutate")
  };
}
a(Eb, "getUpdateConversationMutationOptions");
function Rb(n) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ appId: e }) => {
      await n.fetch(`/api/apps/${e}/trash`, { method: "POST" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((e) => {
      kh(n.queryClient, ["apps", "list"], e.appId);
    }, "onMutate"),
    onSettled: /* @__PURE__ */ a(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
a(Rb, "getTrashConversationMutationOptions");
function Jm(n) {
  return new Mt(n.queryClient, $b(n));
}
a(Jm, "getMarkConversationMutation");
function Tb(n) {
  return new Mt(n.queryClient, kb(n));
}
a(Tb, "getStarConversationMutation");
function Lb(n) {
  return new Mt(n.queryClient, Pb(n));
}
a(Lb, "getPinConversationMutation");
function tv(n) {
  return new Mt(n.queryClient, _b(n));
}
a(tv, "getLeaveConversationMutation");
function Ob(n) {
  return new Mt(n.queryClient, Sb(n));
}
a(Ob, "getRemoveConversationMutation");
function zb(n) {
  return new Mt(n.queryClient, Mb(n));
}
a(zb, "getUpdateMemberMutation");
function Ib(n) {
  return new Mt(n.queryClient, Ab(n));
}
a(Ib, "getAddMembersToConversationMutation");
function ev(n) {
  return new Mt(n.queryClient, Eb(n));
}
a(ev, "getUpdateConversationMutation");
function Fb(n) {
  return new Mt(n.queryClient, Rb(n));
}
a(Fb, "getTrashConversationMutation");
function iv(n, t, e = [st.ChatRoom, st.PrivateChat], i) {
  return hd(n, ["apps", t], void 0, {
    initialData: /* @__PURE__ */ a(() => n?.queryClient.getQueryData(["apps", "list", e, i])?.pages.flatMap((r) => r.data).find((r) => r?.id === t), "initialData")
  });
}
a(iv, "getConversationOptions");
function rv(n, t, e) {
  return {
    queryKey: ["members", t],
    queryFn: /* @__PURE__ */ a(async () => await (await n.fetch(`/api/apps/${t}/members`)).json(), "queryFn"),
    ...e
  };
}
a(rv, "getMemberOptions");
function Db(n, t, e, i) {
  return {
    queryKey: ["search__members", e],
    initialPageParam: 0,
    enabled: !0,
    queryFn: /* @__PURE__ */ a(async (r) => {
      const s = t(), o = r.pageParam;
      let c;
      e ? c = await n.fetch(`/api/apps/${e}/members?q=${s}${i() !== void 0 ? `&agent=${!!i()}` : ""}&member=false&system=false&skip=${o}`) : c = await n.fetch(`/api/users?q=${s}${i() !== void 0 ? `&agent=${!!i()}` : ""}&system=false&skip=${o}`);
      const l = await c.json();
      return l.data = l.data || [], l;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ a((r) => {
      if (r.end && r.end < r.count)
        return r.end;
    }, "getNextPageParam")
  };
}
a(Db, "getInfiniteSearchMemberOptions");
const dt = /* @__PURE__ */ a((n) => n ?? b, "o$3");
const yf = /* @__PURE__ */ a((n, t, e) => {
  const i = /* @__PURE__ */ new Map();
  for (let r = t; r <= e; r++) i.set(n[r], r);
  return i;
}, "u"), je = Yn(class extends Qc {
  constructor(n) {
    if (super(n), n.type !== yd.CHILD) throw Error("repeat() can only be used in text expressions");
  }
  dt(n, t, e) {
    let i;
    e === void 0 ? e = t : t !== void 0 && (i = t);
    const r = [], s = [];
    let o = 0;
    for (const c of n) r[o] = i ? i(c, o) : o, s[o] = e(c, o), o++;
    return { values: s, keys: r };
  }
  render(n, t, e) {
    return this.dt(n, t, e).values;
  }
  update(n, [t, e, i]) {
    const r = mb(n), { values: s, keys: o } = this.dt(t, e, i);
    if (!Array.isArray(r)) return this.ut = o, s;
    const c = this.ut ??= [], l = [];
    let p, v, C = 0, g = r.length - 1, m = 0, f = s.length - 1;
    for (; C <= g && m <= f; ) if (r[C] === null) C++;
    else if (r[g] === null) g--;
    else if (c[C] === o[m]) l[m] = sn(r[C], s[m]), C++, m++;
    else if (c[g] === o[f]) l[f] = sn(r[g], s[f]), g--, f--;
    else if (c[C] === o[f]) l[f] = sn(r[C], s[f]), ll(n, l[f + 1], r[C]), C++, f--;
    else if (c[g] === o[m]) l[m] = sn(r[g], s[m]), ll(n, r[C], r[g]), g--, m++;
    else if (p === void 0 && (p = yf(o, m, f), v = yf(c, C, g)), p.has(c[C])) if (p.has(c[g])) {
      const $ = v.get(o[m]), A = $ !== void 0 ? r[$] : null;
      if (A === null) {
        const M = ll(n, r[C]);
        sn(M, s[m]), l[m] = M;
      } else l[m] = sn(A, s[m]), ll(n, r[C], A), r[$] = null;
      m++;
    } else Bu(r[g]), g--;
    else Bu(r[C]), C++;
    for (; m <= f; ) {
      const $ = ll(n, l[f + 1]);
      sn($, s[m]), l[m++] = $;
    }
    for (; C <= g; ) {
      const $ = r[C++];
      $ !== null && Bu($);
    }
    return this.ut = o, Ym(n, l), gh;
  }
});
const Dd = Yn(class extends Qc {
  constructor() {
    super(...arguments), this.key = b;
  }
  render(n, t) {
    return this.key = n, t;
  }
  update(n, [t, e]) {
    return t !== this.key && (Ym(n), this.key = t), e;
  }
});
function Br(n) {
  n.stopPropagation();
}
a(Br, "inputConsume");
function Vb(n) {
  n.key === "Escape" && (n.preventDefault(), n.stopPropagation(), n.target.value = "", n.target.dispatchEvent(new InputEvent("input", { data: "", inputType: "deleteContent" })));
}
a(Vb, "inputClearOnEscape");
function rh(n) {
  n.key === "Escape" && (n.preventDefault(), n.stopPropagation(), n.target.blur());
}
a(rh, "inputBlurOnEscape");
function Hb(n) {
  n.key === "Enter" && n.target.blur();
}
a(Hb, "inputBlurOnEnter");
function Bb(n) {
  n.target.value ? Vb(n) : rh(n);
}
a(Bb, "inputClearAndBlurOnEscape");
function nv(n) {
  n.key === "Enter" && (n.preventDefault(), n.stopPropagation(), n.target.click());
}
a(nv, "clickOnEnter");
function Nb(n) {
  n.key === " " && (n.preventDefault(), n.stopPropagation());
}
a(Nb, "consumeOnSpace");
function ve(n) {
  nv(n), Nb(n);
}
a(ve, "clickOnEnterAndConsumeOnSpace");
function Ie(n) {
  n.key === " " && (n.preventDefault(), n.stopPropagation(), n.target.click());
}
a(Ie, "clickOnSpace");
function by(n) {
  nv(n), Ie(n);
}
a(by, "clickOnEnterAndSpace");
const _h = j`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-messages]{padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));flex:1 1 100%;display:flex;flex-direction:column}[part~=wy-message-placeholder]{opacity:.5}[part~=wy-message-date-separator]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));pointer-events:none;position:sticky;display:block;top:calc(var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) + var(--wy-component-offset-top, 0px));z-index:10;align-self:center;justify-self:center;margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));background:var(--wy-surface-container-high, var(--wy-surface-container-high-light, #e6e8ee));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));padding:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-message]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));display:flex;flex-direction:row;align-items:flex-start;margin-bottom:calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + .5*var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));scroll-margin-block:6rem}[part~=wy-message][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-message-meta]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:0 0 calc(.5*var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) calc(.5*var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));color:var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}[part~=wy-message-bubble]{background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));display:flex;flex-direction:column;padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));max-width:min(32*var(--wy-size, 1rem),100% - 2*var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}[part~=wy-message-bubble-section]{flex:1 1 100%;display:block;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));clip-path:border-box}[part~=wy-message-author]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:calc(1lh + .5*var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) calc(.5*var(--wy-size, 1rem)) 0 0}[part~=wy-message-content]{display:flex;flex-direction:column;width:100%;align-items:flex-start;flex-wrap:wrap;min-width:0;position:relative}[part~=wy-message-agent]{--wy-component-background-color: var(--wy-tertiary-container, var(--wy-tertiary-container-light, #ebe3bd));--wy-component-color: var(--wy-on-tertiary-container, var(--wy-on-tertiary-container-light, #4c472b))}[part~=wy-message-me]{margin-right:0;margin-left:calc(2.5*var(--wy-size, 1rem));align-items:flex-end;--wy-component-background-color: var(--wy-secondary-container, var(--wy-secondary-container-light, #d5e4f7));--wy-component-color: var(--wy-on-secondary-container, var(--wy-on-secondary-container-light, #3a4857))}[part~=wy-message-me] [part~=wy-message-meta]{margin:0 calc(.5*var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) calc(.5*var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) 0}[part~=wy-message-me] [part~=wy-message-content]{align-items:flex-end}[part~=wy-message-bubble-emoji]{background:none;padding:0 0 var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-message-seenby]{display:flex;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));height:calc(1.125*var(--wy-size, 1rem));justify-content:flex-end;margin-top:calc(-.125*var(--wy-size, 1rem))}`, av = j`[part~=wy-footerbar]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));position:absolute;bottom:0;left:0;right:0;z-index:1020}[part~=wy-footerbar]:after{content:\"\";background-color:var(--wy-component-background-color);color:var(--wy-component-color);position:absolute;width:100%;left:0;bottom:0;height:100%;z-index:-1}[part~=wy-footerbar-sticky]{position:sticky}[part~=wy-footerbar-floating]{--wy-component-border-radius: var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));border-radius:var(--wy-component-border-radius)}[part~=wy-footerbar-floating]:after{border-radius:var(--wy-component-border-radius)}`, Xn = j`[part~=wy-pane]{display:flex;flex-direction:column;position:relative;min-height:0;height:100%;flex:1 1 auto}[part~=wy-pane-body]{display:flex;flex-direction:column;flex:1}[part~=wy-pane-group]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));display:flex;flex-direction:column;flex:1}[part~=wy-pane-group-fixed-size]{flex:0}[part~=wy-pane-toolbar]{display:flex;flex:1;justify-content:space-between;align-items:center;padding:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}`, Jr = j`[part~=wy-pager]{position:relative;align-self:center;justify-self:center}[part~=wy-pager-bottom]{width:16px;height:256px;max-height:100%;margin-top:-256px;margin-inline:auto;pointer-events:none}[part~=wy-pager-top]{width:16px;height:256px;max-height:100%;margin-bottom:-256px;margin-inline:auto;pointer-events:none}`, xy = j`[part~=wy-toasts]{background:none;border:none;padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin:0;box-sizing:border-box;width:100%;height:100%;display:flex;flex-direction:column;flex-wrap:wrap;align-content:flex-end;align-items:flex-end;justify-content:flex-end;pointer-events:none}[part~=wy-toasts][popover]{position:fixed;inset:0;z-index:1070}[part~=wy-toasts]>::slotted(*){pointer-events:auto}[part~=wy-toast]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background:var(--wy-component-background-color);color:var(--wy-component-color);gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));margin-top:0;margin-bottom:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));display:flex;cursor:pointer;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));padding:0;-webkit-user-select:none;user-select:none;box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));position:relative;overflow:hidden;min-height:calc(3*var(--wy-size, 1rem));max-width:calc(32*var(--wy-size, 1rem))}[part~=wy-toast][part~=wy-fade]{transition-property:opacity,min-height,padding-top,padding-bottom,margin-top,margin-bottom,height;transition-duration:var(--wy-transition-duration, .2s);transition-timing-function:var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))}[part~=wy-toast][part~=wy-fade]:not([part~=wy-show]){opacity:0;min-height:0;height:0;padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;pointer-events:none}[part~=wy-toast-action]{position:sticky;top:calc(4.5*var(--wy-size, 1rem));bottom:calc(4.5*var(--wy-size, 1rem));z-index:990;background-color:var(--wy-primary, var(--wy-primary-light, #2f628c));color:var(--wy-on-primary, var(--wy-on-primary-light, #ffffff));padding:calc(.5*var(--wy-size, 1rem)) calc(1*var(--wy-size, 1rem));margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:calc(.5*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));width:max-content;min-height:0;max-width:calc(100% - 3*var(--wy-size, 1rem));height:auto;align-self:center;text-align:center;box-shadow:none}[part~=wy-toast-primary]{background:var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73));color:var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff))}`;
var Cy = /* @__PURE__ */ ((n) => (n.Active = "active", n.Away = "away", n))(Cy || {});
const zw = class zw extends Qc {
  constructor(t) {
    if (super(t), t.type !== yd.ATTRIBUTE || t.name !== "part" || t.strings?.length > 2)
      throw new Error(
        "`partMap()` can only be used in the `part` attribute and must be the only section in the attribute."
      );
  }
  render(t) {
    return " " + Object.keys(t).filter((e) => t[e]).join(" ") + " ";
  }
  update(t, [e]) {
    if (this._previousShadowParts === void 0) {
      this._previousShadowParts = /* @__PURE__ */ new Set(), t.strings !== void 0 && (this._staticShadowParts = new Set(
        t.strings.join(" ").split(/\s/).filter((r) => r !== "")
      ));
      for (const r in e)
        e[r] && !this._staticShadowParts?.has(r) && this._previousShadowParts.add(r);
      return this.render(e);
    }
    const i = t.element.part;
    for (const r of this._previousShadowParts)
      r in e || (i.remove(r), this._previousShadowParts.delete(r));
    for (const r in e) {
      const s = !!e[r];
      s !== this._previousShadowParts.has(r) && !this._staticShadowParts?.has(r) && (s ? (i.add(r), this._previousShadowParts.add(r)) : (i.remove(r), this._previousShadowParts.delete(r)));
    }
    return gh;
  }
};
a(zw, "ShadowPartMapDirective");
let Hp = zw;
const J = Yn(Hp), Ht = j`:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]){box-sizing:border-box;text-align:initial;font-size:var(--wy-font-size, var(--wy-size, 1em))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:before,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:after{box-sizing:inherit}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a){text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-light, #2f628c))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):hover{text-decoration:var(--wy-link-hover-decoration, var(--wy-link-decoration, none))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])):hover{text-decoration:none}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(p),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(p){margin-top:0;margin-bottom:calc(1*var(--wy-size, 1rem))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(label),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(label){cursor:inherit}:where(:host([hidden])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"])[hidden],:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *[hidden]{display:none!important}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where([role=button]),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where([role=button]){cursor:pointer}`, $y = j`:host(wy-avatar){position:relative;display:inline-flex}[part~=wy-avatar-shape]{border-radius:var(--wy-avatar-border-radius, var(--wy-border-radius, 50%))}[part~=wy-avatar-img]{width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));object-fit:cover}[part~=wy-avatar-initials]{background-color:var(--wy-component-avatar-background-color, var(--wy-primary, var(--wy-primary-light, #2f628c)));color:var(--wy-component-avatar-color, var(--wy-on-primary, var(--wy-on-primary-light, #ffffff)));width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));display:flex;align-items:center;align-content:center;justify-content:center;justify-items:center;font-size:calc(var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem))))}[part~=wy-avatar-initials-text]{font-size:max(8px,var(--wy-avatar-font-size, .382em));font-weight:var(--wy-avatar-font-weight, var(--wy-font-weight-bold, unset));line-height:normal}[part~=wy-avatar-type-icon]{display:flex;position:absolute;z-index:1;bottom:0;right:-8.3333333333%;border-radius:50%;color:var(--wy-tertiary, var(--wy-tertiary-light, #645f41));stroke:var(--wy-on-tertiary, var(--wy-on-tertiary-light, #ffffff))}:host(wy-avatar-group){position:relative;display:inline-flex;flex-shrink:0;width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)))}[part~=wy-avatar-back]{position:absolute;top:0;left:0}[part~=wy-avatar-front]{position:absolute;bottom:0;right:0}:host(wy-avatar-header){padding:calc(1.5*var(--wy-size, 1rem));margin-left:auto;margin-right:auto;text-align:center;display:flex;flex-direction:column;justify-content:center;align-items:center}[part~=wy-avatar-description]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}`, sv = j`[part~=wy-presence]{width:calc(.75*var(--wy-size, 1rem));height:calc(.75*var(--wy-size, 1rem));border-radius:50%;position:absolute;bottom:0;right:-5%;box-sizing:border-box}[part~=wy-presence]:not([part~=wy-presence-active]){display:none}[part~=wy-presence]:after{content:\"\";position:absolute;width:100%;height:100%;top:0;left:0;border-radius:inherit;background-color:var(--wy-presence-active, var(--wy-green-light, #00a38d));background-clip:content-box;padding:calc(.125*var(--wy-size, 1rem));box-sizing:border-box}[part~=wy-presence-mask]{-webkit-mask-image:radial-gradient(circle calc(.75 * var(--wy-size, 1rem)) at bottom calc(.375 * var(--wy-size, 1rem)) right calc(.375 * var(--wy-size, 1rem) - 5%),rgba(0,0,0,0) calc(.375 * var(--wy-size, 1rem)),rgb(0,0,0) calc(.375 * var(--wy-size, 1rem) + 1px));mask-image:radial-gradient(circle calc(.75 * var(--wy-size, 1rem)) at bottom calc(.375 * var(--wy-size, 1rem)) right calc(.375 * var(--wy-size, 1rem) - 5%),#0000 calc(.375 * var(--wy-size, 1rem)),#000 calc(.375 * var(--wy-size, 1rem) + 1px))}[part~=wy-presence-in-text]{position:absolute;bottom:unset;right:unset}[part~=wy-presence-in-text]:after{left:calc(-.5*var(--wy-size, 1rem))}`;
var Ub = Object.defineProperty, qb = Object.getOwnPropertyDescriptor, ky = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? qb(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && Ub(t, e, r), r;
}, "__decorateClass$1b"), Fs;
let Ec = (Fs = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.placement = "avatar";
  }
  render() {
    const t = {
      "wy-presence": !0,
      "wy-presence-active": this.status === Cy.Active,
      "wy-presence-in-text": this.placement === "text"
    };
    return h` <span part=${J(t)} data-presence-id=${this.id}></span> `;
  }
}, a(Fs, "WyPresence"), Fs);
Ec.styles = [
  Ht,
  sv,
  X
];
ky([
  u()
], Ec.prototype, "placement", 2);
ky([
  u()
], Ec.prototype, "status", 2);
Ec = ky([
  B("wy-presence")
], Ec);
var jb = "M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M1,10V12H9V10M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12Z", Wb = "M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M6,10V7H4V10H1V12H4V15H6V12H9V10M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12Z", Kb = "M13 14H11V9H13M13 18H11V16H13M1 21H23L12 2L1 21Z", Qb = "M13,13H11V7H13M13,17H11V15H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", Gb = "M13 13H11V7H13M11 15H13V17H11M15.73 3H8.27L3 8.27V15.73L8.27 21H15.73L21 15.73V8.27L15.73 3Z", Zb = "M19.5,3.09L15,7.59V4H13V11H20V9H16.41L20.91,4.5L19.5,3.09M4,13V15H7.59L3.09,19.5L4.5,20.91L9,16.41V20H11V13H4Z", Yb = "M10,21V19H6.41L10.91,14.5L9.5,13.09L5,17.59V14H3V21H10M14.5,10.91L19,6.41V10H21V3H14V5H17.59L13.09,9.5L14.5,10.91Z", wf = "M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z", Xb = "M4,11V13H16L10.5,18.5L11.92,19.92L19.84,12L11.92,4.08L10.5,5.5L16,11H4Z", Jb = "M7.5,18A5.5,5.5 0 0,1 2,12.5A5.5,5.5 0 0,1 7.5,7H18A4,4 0 0,1 22,11A4,4 0 0,1 18,15H9.5A2.5,2.5 0 0,1 7,12.5A2.5,2.5 0 0,1 9.5,10H17V11.5H9.5A1,1 0 0,0 8.5,12.5A1,1 0 0,0 9.5,13.5H18A2.5,2.5 0 0,0 20.5,11A2.5,2.5 0 0,0 18,8.5H7.5A4,4 0 0,0 3.5,12.5A4,4 0 0,0 7.5,16.5H17V18H7.5Z", t2 = "M12,3A9,9 0 0,0 3,12H0L4,16L8,12H5A7,7 0 0,1 12,5A7,7 0 0,1 19,12A7,7 0 0,1 12,19C10.5,19 9.09,18.5 7.94,17.7L6.5,19.14C8.04,20.3 9.94,21 12,21A9,9 0 0,0 21,12A9,9 0 0,0 12,3M14,12A2,2 0 0,0 12,10A2,2 0 0,0 10,12A2,2 0 0,0 12,14A2,2 0 0,0 14,12Z", e2 = "M21,19V20H3V19L5,17V11C5,7.9 7.03,5.17 10,4.29C10,4.19 10,4.1 10,4A2,2 0 0,1 12,2A2,2 0 0,1 14,4C14,4.1 14,4.19 14,4.29C16.97,5.17 19,7.9 19,11V17L21,19M14,21A2,2 0 0,1 12,23A2,2 0 0,1 10,21", i2 = "M20.84,22.73L18.11,20H3V19L5,17V11C5,9.86 5.29,8.73 5.83,7.72L1.11,3L2.39,1.73L22.11,21.46L20.84,22.73M19,15.8V11C19,7.9 16.97,5.17 14,4.29C14,4.19 14,4.1 14,4A2,2 0 0,0 12,2A2,2 0 0,0 10,4C10,4.1 10,4.19 10,4.29C9.39,4.47 8.8,4.74 8.26,5.09L19,15.8M12,23A2,2 0 0,0 14,21H10A2,2 0 0,0 12,23Z", r2 = "M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3M9 17H7V10H9V17M13 17H11V7H13V17M17 17H15V13H17V17Z", Uu = "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z", n2 = "M0.41,13.41L6,19L7.41,17.58L1.83,12M22.24,5.58L11.66,16.17L7.5,12L6.07,13.41L11.66,19L23.66,7M18,7L16.59,5.58L10.24,11.93L11.66,13.34L18,7Z", a2 = "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41 10.59L10 14.17L17.59 6.58L19 8L10 17Z", s2 = "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M12 20C7.59 20 4 16.41 4 12S7.59 4 12 4 20 7.59 20 12 16.41 20 12 20M16.59 7.58L10 14.17L7.41 11.59L6 13L10 17L18 9L16.59 7.58Z", o2 = "M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3M19,5V19H5V5H19Z", c2 = "M19,19H5V5H15V3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V11H19M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z", l2 = "M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", d2 = "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z", h2 = "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z", u2 = "M6.5 20Q4.22 20 2.61 18.43 1 16.85 1 14.58 1 12.63 2.17 11.1 3.35 9.57 5.25 9.15 5.88 6.85 7.75 5.43 9.63 4 12 4 14.93 4 16.96 6.04 19 8.07 19 11 20.73 11.2 21.86 12.5 23 13.78 23 15.5 23 17.38 21.69 18.69 20.38 20 18.5 20Z", p2 = "M9,22A1,1 0 0,1 8,21V18H4A2,2 0 0,1 2,16V4C2,2.89 2.9,2 4,2H20A2,2 0 0,1 22,4V16A2,2 0 0,1 20,18H13.9L10.2,21.71C10,21.9 9.75,22 9.5,22V22H9Z", y2 = "M9,22A1,1 0 0,1 8,21V18H4A2,2 0 0,1 2,16V4C2,2.89 2.9,2 4,2H20A2,2 0 0,1 22,4V16A2,2 0 0,1 20,18H13.9L10.2,21.71C10,21.9 9.75,22 9.5,22V22H9M10,16V19.08L13.08,16H20V4H4V16H10Z", w2 = "M15,9H5V5H15M12,19A3,3 0 0,1 9,16A3,3 0 0,1 12,13A3,3 0 0,1 15,16A3,3 0 0,1 12,19M17,3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V7L17,3Z", f2 = "M19,1L17.74,3.75L15,5L17.74,6.26L19,9L20.25,6.26L23,5L20.25,3.75M9,4L6.5,9.5L1,12L6.5,14.5L9,20L11.5,14.5L17,12L11.5,9.5M19,15L17.74,17.74L15,19L17.74,20.25L19,23L20.25,20.25L23,19L20.25,17.74", m2 = "M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z", v2 = "M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19M8.46,11.88L9.87,10.47L12,12.59L14.12,10.47L15.53,11.88L13.41,14L15.53,16.12L14.12,17.53L12,15.41L9.88,17.53L8.47,16.12L10.59,14L8.46,11.88M15.5,4L14.5,3H9.5L8.5,4H5V6H19V4H15.5Z", g2 = "M14,14H16L12,10L8,14H10V18H14V14M6,7H18V19C18,19.5 17.8,20 17.39,20.39C17,20.8 16.5,21 16,21H8C7.5,21 7,20.8 6.61,20.39C6.2,20 6,19.5 6,19V7M19,4V6H5V4H8.5L9.5,3H14.5L15.5,4H19Z", b2 = "M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z", x2 = "M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z", C2 = "M17.9,17.39C17.64,16.59 16.89,16 16,16H15V13A1,1 0 0,0 14,12H8V10H10A1,1 0 0,0 11,9V7H13A2,2 0 0,0 15,5V4.59C17.93,5.77 20,8.64 20,12C20,14.08 19.2,15.97 17.9,17.39M11,19.93C7.05,19.44 4,16.08 4,12C4,11.38 4.08,10.78 4.21,10.21L9,15V16A2,2 0 0,0 11,18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", $2 = "M20,8L12,13L4,8V6L12,11L20,6M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C22,4.89 21.1,4 20,4Z", k2 = "M12,17.5C14.33,17.5 16.3,16.04 17.11,14H6.89C7.69,16.04 9.67,17.5 12,17.5M8.5,11A1.5,1.5 0 0,0 10,9.5A1.5,1.5 0 0,0 8.5,8A1.5,1.5 0 0,0 7,9.5A1.5,1.5 0 0,0 8.5,11M15.5,11A1.5,1.5 0 0,0 17,9.5A1.5,1.5 0 0,0 15.5,8A1.5,1.5 0 0,0 14,9.5A1.5,1.5 0 0,0 15.5,11M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2C6.47,2 2,6.5 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", P2 = "M15 18H18V15H20V18H23V20H20V23H18V20H15V18M12 17.5C9.67 17.5 7.69 16.04 6.89 14H15.69C14.5 14.78 13.62 15.97 13.23 17.36C12.83 17.45 12.42 17.5 12 17.5M8.5 11C7.67 11 7 10.33 7 9.5C7 8.67 7.67 8 8.5 8C9.33 8 10 8.67 10 9.5C10 10.33 9.33 11 8.5 11M15.5 11C14.67 11 14 10.33 14 9.5C14 8.67 14.67 8 15.5 8C16.33 8 17 8.67 17 9.5C17 10.33 16.33 11 15.5 11M12 20L13.07 19.93C13.18 20.61 13.4 21.26 13.72 21.85C13.16 21.95 12.58 22 12 22C6.47 22 2 17.5 2 12C2 6.5 6.47 2 12 2C17.5 2 22 6.5 22 12C22 12.59 21.95 13.16 21.85 13.72C21.26 13.4 20.62 13.18 19.93 13.07L20 12C20 7.58 16.42 4 12 4C7.58 4 4 7.58 4 12C4 16.42 7.58 20 12 20Z", _2 = "M13,9V3.5L18.5,9M6,2C4.89,2 4,2.89 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2H6Z", ff = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M6.12,15.5L9.86,19.24L11.28,17.83L8.95,15.5L11.28,13.17L9.86,11.76L6.12,15.5M17.28,15.5L13.54,11.76L12.12,13.17L14.45,15.5L12.12,17.83L13.54,19.24L17.28,15.5Z", mf = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M15,18V16H6V18H15M18,14V12H6V14H18Z", S2 = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.8,20H14L12,16.6L10,20H8.2L11.1,15.5L8.2,11H10L12,14.4L14,11H15.8L12.9,15.5L15.8,20M13,9V3.5L18.5,9H13Z", M2 = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M6,20H15L18,20V12L14,16L12,14L6,20M8,9A2,2 0 0,0 6,11A2,2 0 0,0 8,13A2,2 0 0,0 10,11A2,2 0 0,0 8,9Z", A2 = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M13,13H11V18A2,2 0 0,1 9,20A2,2 0 0,1 7,18A2,2 0 0,1 9,16C9.4,16 9.7,16.1 10,16.3V11H13V13M13,9V3.5L18.5,9H13Z", E2 = "M12.6,12.3H10.6V15.5H12.7C13.3,15.5 13.6,15.3 13.9,15C14.2,14.7 14.3,14.4 14.3,13.9C14.3,13.4 14.2,13.1 13.9,12.8C13.6,12.5 13.2,12.3 12.6,12.3M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.2,16C14.6,16.5 14.1,16.7 12.8,16.7H10.6V20H9V11H12.8C14.1,11 14.7,11.3 15.2,11.8C15.8,12.4 16,13 16,13.9C16,14.8 15.8,15.5 15.2,16M13,9V3.5L18.5,9H13Z", R2 = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M13.5,16V19H10.5V16H8L12,12L16,16H13.5M13,9V3.5L18.5,9H13Z", T2 = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M17,19V13L14,15.2V13H7V19H14V16.8L17,19Z", L2 = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.2,20H13.8L12,13.2L10.2,20H8.8L6.6,11H8.1L9.5,17.8L11.3,11H12.6L14.4,17.8L15.8,11H17.3L15.2,20M13,9V3.5L18.5,9H13Z", O2 = "M20,2H4C2.89,2 2,2.89 2,4V20C2,21.11 2.89,22 4,22H20C21.11,22 22,21.11 22,20V4C22,2.89 21.11,2 20,2M12,4L15,7H13V9H11V7H9M7,15L4,12L7,9V11H9V13H7M12,20L9,17H11V15H13V17H15M17,15V13H15V11H17V9L20,12", z2 = "M17 4H20C21.1 4 22 4.9 22 6V8H20V6H17V4M4 8V6H7V4H4C2.9 4 2 4.9 2 6V8H4M20 16V18H17V20H20C21.1 20 22 19.1 22 18V16H20M7 18H4V16H2V18C2 19.1 2.9 20 4 20H7V18M18 8H6V16H18V8Z", I2 = "M20 6H12L10 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V8C22 6.9 21.1 6 20 6M18 12H16V14H18V16H16V18H14V16H16V14H14V12H16V10H14V8H16V10H18V12Z", F2 = "M17,7H22V17H17V19A1,1 0 0,0 18,20H20V22H17.5C16.95,22 16,21.55 16,21C16,21.55 15.05,22 14.5,22H12V20H14A1,1 0 0,0 15,19V5A1,1 0 0,0 14,4H12V2H14.5C15.05,2 16,2.45 16,3C16,2.45 16.95,2 17.5,2H20V4H18A1,1 0 0,0 17,5V7M2,7H13V9H4V15H13V17H2V7M20,15V9H17V15H20Z", D2 = "M5,5H10V7H7V10H5V5M14,5H19V10H17V7H14V5M17,14H19V19H14V17H17V14M10,17V19H5V14H7V17H10Z", V2 = "M14,14H19V16H16V19H14V14M5,14H10V19H8V16H5V14M8,5H10V10H5V8H8V5M19,8V10H14V5H16V8H19Z", H2 = "M15.07,11.25L14.17,12.17C13.45,12.89 13,13.5 13,15H11V14.5C11,13.39 11.45,12.39 12.17,11.67L13.41,10.41C13.78,10.05 14,9.55 14,9C14,7.89 13.1,7 12,7A2,2 0 0,0 10,9H8A4,4 0 0,1 12,5A4,4 0 0,1 16,9C16,9.88 15.64,10.67 15.07,11.25M13,19H11V17H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12C22,6.47 17.5,2 12,2Z", B2 = "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M11,17H13V11H11V17Z", N2 = "M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z", U2 = "M7,10L12,15L17,10H7Z", q2 = "M7,15L12,10L17,15H7Z", j2 = "M20,2H4A2,2 0 0,0 2,4V22L6,18H20A2,2 0 0,0 22,16V4C22,2.89 21.1,2 20,2Z", W2 = "M20,2H4A2,2 0 0,0 2,4V22L6,18H20A2,2 0 0,0 22,16V4A2,2 0 0,0 20,2M6,9H18V11H6M14,14H6V12H14M18,8H6V6H18", K2 = "M19,13H5V11H19V13Z", Q2 = "M21 2C22.05 2 22.92 2.81 23 3.85L23 4V16C23 17.05 22.18 17.92 21.15 18L21 18H14V20H16V22H8V20H10V18H3C1.95 18 1.08 17.18 1 16.15L1 16V4C1 2.94 1.81 2.08 2.85 2L3 2H21M21 4H3V16H21V4M12 11C14.21 11 16 11.9 16 13V14H8V13C8 11.9 9.79 11 12 11M12 6C13.11 6 14 6.9 14 8S13.11 10 12 10 10 9.11 10 8 10.9 6 12 6Z", G2 = "M14,3V5H17.59L7.76,14.83L9.17,16.24L19,6.41V10H21V3M19,19H5V5H12V3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V12H19V19Z", Z2 = "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z", Y2 = "M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z", X2 = "M2,5.27L3.28,4L20,20.72L18.73,22L12.8,16.07V22H11.2V16H6V14L8,12V11.27L2,5.27M16,12L18,14V16H17.82L8,6.18V4H7V2H17V4H16V12Z", J2 = "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z", t5 = "M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M13,7H11V11H7V13H11V17H13V13H17V11H13V7Z", e5 = "M13,3A9,9 0 0,0 4,12H1L4.89,15.89L4.96,16.03L9,12H6A7,7 0 0,1 13,5A7,7 0 0,1 20,12A7,7 0 0,1 13,19C11.07,19 9.32,18.21 8.06,16.94L6.64,18.36C8.27,20 10.5,21 13,21A9,9 0 0,0 22,12A9,9 0 0,0 13,3Z", i5 = "M4,3H5V5H3V4A1,1 0 0,1 4,3M20,3A1,1 0 0,1 21,4V5H19V3H20M15,5V3H17V5H15M11,5V3H13V5H11M7,5V3H9V5H7M21,20A1,1 0 0,1 20,21H19V19H21V20M15,21V19H17V21H15M11,21V19H13V21H11M7,21V19H9V21H7M4,21A1,1 0 0,1 3,20V19H5V21H4M3,15H5V17H3V15M21,15V17H19V15H21M3,11H5V13H3V11M21,11V13H19V11H21M3,7H5V9H3V7M21,7V9H19V7H21Z", r5 = "M2,21L23,12L2,3V10L17,12L2,14V21Z", n5 = "M13,19H14A1,1 0 0,1 15,20H15.73L13,17.27V19M22,20V21.18L20.82,20H22M21,22.72L19.73,24L17.73,22H15A1,1 0 0,1 14,23H10A1,1 0 0,1 9,22H2V20H9A1,1 0 0,1 10,19H11V17H4A1,1 0 0,1 3,16V12A1,1 0 0,1 4,11H6.73L4.73,9H4A1,1 0 0,1 3,8V7.27L1,5.27L2.28,4L21,22.72M4,3H20A1,1 0 0,1 21,4V8A1,1 0 0,1 20,9H9.82L7,6.18V5H5.82L3.84,3C3.89,3 3.94,3 4,3M20,11A1,1 0 0,1 21,12V16A1,1 0 0,1 20,17H17.82L11.82,11H20M9,7H10V5H9V7M9,15H10V14.27L9,13.27V15M5,13V15H7V13H5Z", a5 = "M12 1L3 5V11C3 16.55 6.84 21.74 12 23C17.16 21.74 21 16.55 21 11V5L12 1M15.08 16L12 14.15L8.93 16L9.74 12.5L7.03 10.16L10.61 9.85L12 6.55L13.39 9.84L16.97 10.15L14.26 12.5L15.08 16Z", s5 = "M21 11C21 16.55 17.16 21.74 12 23C6.84 21.74 3 16.55 3 11V5L12 1L21 5V11M12 21C15.75 20 19 15.54 19 11.22V6.3L12 3.18L5 6.3V11.22C5 15.54 8.25 20 12 21M15.05 16L11.97 14.15L8.9 16L9.71 12.5L7 10.16L10.58 9.85L11.97 6.55L13.37 9.84L16.95 10.15L14.23 12.5L15.05 16", o5 = "M18 21L14 17H17V7H14L18 3L22 7H19V17H22M2 19V17H12V19M2 13V11H9V13M2 7V5H6V7H2Z", c5 = "M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z", l5 = "M12,1L9,9L1,12L9,15L12,23L15,15L23,12L15,9L12,1Z", d5 = "M20.8 22.7L17.9 19.8L18.2 21L12 17.3L5.8 21L7.4 14L2 9.2L6.9 8.8L1.1 3L2.4 1.7L22.1 21.4L20.8 22.7M22 9.2L14.8 8.6L12 2L10 6.8L16.9 13.7L22 9.2Z", h5 = "M21,9L17,5V8H10V10H17V13M7,11L3,15L7,19V16H14V14H7V11Z", u5 = "M23,10C23,8.89 22.1,8 21,8H14.68L15.64,3.43C15.66,3.33 15.67,3.22 15.67,3.11C15.67,2.7 15.5,2.32 15.23,2.05L14.17,1L7.59,7.58C7.22,7.95 7,8.45 7,9V19A2,2 0 0,0 9,21H18C18.83,21 19.54,20.5 19.84,19.78L22.86,12.73C22.95,12.5 23,12.26 23,12V10M1,21H5V9H1V21Z", p5 = "M5,9V21H1V9H5M9,21A2,2 0 0,1 7,19V9C7,8.45 7.22,7.95 7.59,7.59L14.17,1L15.23,2.06C15.5,2.33 15.67,2.7 15.67,3.11L15.64,3.43L14.69,8H21C22.11,8 23,8.9 23,10V12C23,12.26 22.95,12.5 22.86,12.73L19.84,19.78C19.54,20.5 18.83,21 18,21H9M9,19H18.03L21,12V10H12.21L13.34,4.68L9,9.03V19Z", y5 = "M9,3V4H4V6H5V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V6H20V4H15V3H9M9,8H11V17H9V8M13,8H15V17H13V8Z", w5 = "M17,10.5V7A1,1 0 0,0 16,6H4A1,1 0 0,0 3,7V17A1,1 0 0,0 4,18H16A1,1 0 0,0 17,17V13.5L21,17.5V6.5L17,10.5Z", f5 = "M3 5V19H20V5H3M7 7V9H5V7H7M5 13V11H7V13H5M5 15H7V17H5V15M18 17H9V15H18V17M18 13H9V11H18V13M18 9H9V7H18V9Z", m5 = "M4 5V18H21V5H4M14 7V10.5H11V7H14M6 7H9V10.5H6V7M6 16V12.5H9V16H6M11 16V12.5H14V16H11M19 16H16V12.5H19V16M16 10.5V7H19V10.5H16Z", v5 = "M2.28,3L1,4.27L2.47,5.74C2.04,6 1.61,6.29 1.2,6.6L3,9C3.53,8.6 4.08,8.25 4.66,7.93L6.89,10.16C6.15,10.5 5.44,10.91 4.8,11.4L6.6,13.8C7.38,13.22 8.26,12.77 9.2,12.47L11.75,15C10.5,15.07 9.34,15.5 8.4,16.2L12,21L14.46,17.73L17.74,21L19,19.72M12,3C9.85,3 7.8,3.38 5.9,4.07L8.29,6.47C9.5,6.16 10.72,6 12,6C15.38,6 18.5,7.11 21,9L22.8,6.6C19.79,4.34 16.06,3 12,3M12,9C11.62,9 11.25,9 10.88,9.05L14.07,12.25C15.29,12.53 16.43,13.07 17.4,13.8L19.2,11.4C17.2,9.89 14.7,9 12,9Z";
const vf = i5, gf = {
  "zoom-meetings": '<path d="M21.5 12.5c0 .96-.08 1.91-.23 2.83a7.198 7.198 0 01-5.95 5.95 17.527 17.527 0 01-5.66 0 7.198 7.198 0 01-5.95-5.95 17.527 17.527 0 010-5.66c.49-3.05 2.9-5.46 5.95-5.95a17.527 17.527 0 015.66 0c3.05.49 5.46 2.9 5.95 5.95.15.92.23 1.86.23 2.83z" fill="#0b5cff"/><path d="M14.43 14.75c0 .53-.43.96-.96.96H9.29c-1.07 0-1.93-.86-1.93-1.93v-3.54c0-.53.43-.96.96-.96h4.18c1.07 0 1.93.86 1.93 1.93v3.54zM16.87 9.86l-1.41 1.06c-.24.18-.39.47-.39.77v1.61c0 .3.14.59.39.77l1.41 1.06c.32.24.77.01.77-.39v-4.5c0-.4-.45-.62-.77-.39z" fill="#fff"/>',
  "google-meet": '<path fill="#1e88e5" d="M3.5 9.07v5.86l2.09.42 2.1-.42V9.07l-2.1-.42-2.09.42z"/><path d="M17.73 12v5.86c0 .69-.56 1.26-1.26 1.26H7.69l-.42-2.09.42-2.09h5.86v-2.93l2.09-.42 2.09.42z" fill="#4caf50"/><path d="M17.73 6.14V12h-4.19V9.07H7.68l-.42-2.09.42-2.09h8.79c.69 0 1.26.56 1.26 1.26z" fill="#fbc02d"/><path d="M7.69 14.93v4.19H4.76c-.69 0-1.26-.56-1.26-1.26v-2.93h4.19z" fill="#1565c0"/><path fill="#e53935" d="M7.69 4.88v4.19H3.5l4.19-4.19z"/><path fill="#2e7d32" d="M18.15 12l-.42 3.54L13.55 12l4.18-3.54.42 3.54z"/><path d="M21.5 6.19v11.63c0 .35-.41.55-.68.33l-3.09-2.6V8.48l3.09-2.6c.27-.22.68-.03.68.33z" fill="#4caf50"/>',
  "webex-meetings": '<defs><radialGradient id="prefix__b" cx="-951.63" cy="549.04" fx="-951.63" fy="549.04" r=".05" gradientTransform="matrix(-87.16473 -146.04628 -122.52671 73.12756 -15652.44 -179117.85)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#007383"/><stop offset=".41" stop-color="#00717e" stop-opacity=".75"/><stop offset=".87" stop-color="#007281" stop-opacity="0"/></radialGradient><radialGradient id="prefix__c" cx="-952.67" cy="549.07" fx="-952.67" fy="549.07" r=".05" gradientTransform="rotate(-126.7 -53497.341 -58162.752) scale(138.69 -91.09)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#218970"/><stop offset=".46" stop-color="#267e6a"/><stop offset="1" stop-color="#026c51" stop-opacity="0"/></radialGradient><radialGradient id="prefix__d" cx="-952.61" cy="541.2" fx="-952.61" fy="541.2" r=".05" gradientTransform="matrix(-33.8827 -107.79009 -56.09397 17.63256 -1902.72 -112216.84)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#178697"/><stop offset=".41" stop-color="#17838f" stop-opacity=".79"/><stop offset=".87" stop-color="#007281" stop-opacity="0"/></radialGradient><radialGradient id="prefix__e" cx="-949.76" cy="547.24" fx="-949.76" fy="547.24" r=".05" gradientTransform="matrix(-146.98086 -246.36712 -75.94201 45.30646 -98045.43 -258761.67)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#25342f" stop-opacity=".3"/><stop offset="1" stop-color="#25342f" stop-opacity="0"/></radialGradient><radialGradient id="prefix__f" cx="-942.87" cy="563.62" fx="-942.87" fy="563.62" r=".05" gradientTransform="rotate(85.1 -69752.427 38265.017) scale(108.08 -61.22)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#056d4f"/><stop offset=".23" stop-color="#056c4e" stop-opacity=".75"/><stop offset=".6" stop-color="#056c4e" stop-opacity=".3"/><stop offset=".87" stop-color="#056c4f" stop-opacity="0"/></radialGradient><radialGradient id="prefix__g" cx="-940.36" cy="556.77" fx="-940.36" fy="556.77" r=".05" gradientTransform="matrix(68.96997 106.65216 55.9082 -36.1548 33735.1 120422.29)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#22b67b"/><stop offset=".41" stop-color="#24be82"/><stop offset="1" stop-color="#24be82" stop-opacity=".07"/></radialGradient><radialGradient id="prefix__i" cx="-940.77" cy="554.96" fx="-940.77" fy="554.96" r=".05" gradientTransform="rotate(49.69 -177135.555 122596.9) scale(165.85 -165.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></radialGradient><radialGradient id="prefix__j" cx="-944.1" cy="553.18" fx="-944.1" fy="553.18" r=".05" gradientTransform="rotate(48.05 -367132.581 263331.898) scale(336.36 -335.78)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00b8ff"/><stop offset=".75" stop-color="#00b9fc" stop-opacity="0"/></radialGradient><radialGradient id="prefix__k" cx="-951.17" cy="546.23" fx="-951.17" fy="546.23" r=".05" gradientTransform="matrix(-48.64247 -154.74493 -107.10322 33.66679 12252.88 -165563.53)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00bcff" stop-opacity=".76"/><stop offset=".57" stop-color="#00bafc" stop-opacity="0"/></radialGradient><radialGradient id="prefix__l" cx="-953.78" cy="550.07" fx="-953.78" fy="550.07" r=".05" gradientTransform="matrix(-72.9418 -88.45403 -61.91396 51.05608 -35502.54 -112443.2)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5fec50"/><stop offset="1" stop-color="#3cc08e" stop-opacity="0"/></radialGradient><radialGradient id="prefix__m" cx="-954.59" cy="523.18" fx="-954.59" fy="523.18" r=".05" gradientTransform="rotate(-79.11 -8961.313 -26349.067) scale(34.73 -23.99)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#28855b"/><stop offset="1" stop-color="#14795c" stop-opacity="0"/></radialGradient><radialGradient id="prefix__n" cx="-955.7" cy="534.72" fx="-955.7" fy="534.72" r=".05" gradientTransform="matrix(6.00138 -27.99393 -39.07222 -8.37636 26647.75 -22260.21)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#28855b"/><stop offset="1" stop-color="#14795c" stop-opacity="0"/></radialGradient><radialGradient id="prefix__o" cx="-954.99" cy="550.19" fx="-954.99" fy="550.19" r=".05" gradientTransform="matrix(-64.43177 -69.7019 -48.95728 45.25565 -34575.21 -91452.74)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5ff05b"/><stop offset=".81" stop-color="#5de955" stop-opacity="0"/></radialGradient><radialGradient id="prefix__p" cx="-938.28" cy="553.05" fx="-938.28" fy="553.05" r=".05" gradientTransform="matrix(66.96005 51.3617 71.4219 -93.11248 23342.15 99701.75)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".97" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__q" cx="-940.1" cy="550.5" fx="-940.1" fy="550.5" r=".05" gradientTransform="matrix(98.43675 14.71147 21.98813 -147.126 80455.97 94829.3)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".59" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__r" cx="-938.38" cy="551.97" fx="-938.38" fy="551.97" r=".05" gradientTransform="rotate(24.69 -231174.852 140478.806) scale(85.04 -151.66)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".76" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__s" cx="-945.2" cy="560.82" fx="-945.2" fy="560.82" r=".05" gradientTransform="rotate(95.79 -93552.04 41883.384) scale(153.04 -83.75)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".59" stop-color="#123aa8" stop-opacity="0"/><stop offset="1" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__t" cx="-945.05" cy="562.66" fx="-945.05" fy="562.66" r=".05" gradientTransform="rotate(93.66 -104350.43 63182.76) scale(184.18 -65.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__u" cx="-942.29" cy="567.94" fx="-942.29" fy="567.94" r=".05" gradientTransform="matrix(8.78957 97.33394 51.50044 -4.65066 -20951.98 94373.6)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__v" cx="-942.85" cy="562.23" fx="-942.85" fy="562.23" r=".05" gradientTransform="matrix(4.89377 101.88254 84.00315 -4.03496 -42611.94 98338.06)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__w" cx="-941.74" cy="549.74" fx="-941.74" fy="549.74" r=".05" gradientTransform="rotate(-23.2 244205.91 -321749.854) scale(113.62 -222.29)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".71" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__x" cx="-959.91" cy="553.32" fx="-959.91" fy="553.32" r=".05" gradientTransform="matrix(-70.50332 -26.36011 -45.18376 120.84945 -42670.87 -92159.05)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#1a3da0"/><stop offset=".71" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__y" cx="-940.3" cy="551.63" fx="-940.3" fy="551.63" r=".05" gradientTransform="matrix(137.44492 41.41855 41.86 -138.90985 106154.62 115588.85)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#1e3882"/><stop offset=".76" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__A" cx="-940.77" cy="554.96" fx="-940.77" fy="554.96" r=".05" gradientTransform="rotate(49.69 -177135.55 122596.884) scale(165.85 -165.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></radialGradient><radialGradient id="prefix__D" cx="-951.17" cy="546.23" fx="-951.17" fy="546.23" r=".05" gradientTransform="matrix(-48.64247 -154.74493 -107.10322 33.66679 12252.88 -165563.53)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00bcff" stop-opacity=".76"/><stop offset=".57" stop-color="#00bafc" stop-opacity="0"/></radialGradient><linearGradient id="prefix__a" x1="76.14" y1="-95.89" x2="64.37" y2="-99.75" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5cee64"/><stop offset="1" stop-color="#0bf"/></linearGradient><linearGradient id="prefix__h" x1="56.74" y1="-98.36" x2="65.09" y2="-98.43" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient><linearGradient id="prefix__z" x1="61.48" y1="-92.95" x2="67.9" y2="-97.04" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset=".23" stop-color="#1dc4ff"/><stop offset="1" stop-color="#1cc1ff" stop-opacity="0"/></linearGradient><linearGradient id="prefix__B" x1="63.13" y1="-92.11" x2="64.93" y2="-93.74" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#26fbff"/><stop offset=".64" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient><linearGradient id="prefix__C" x1="60.36" y1="-97.78" x2="62.85" y2="-97.95" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#26fbff"/><stop offset=".64" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient></defs><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__a)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__b)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__c)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__d)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__e)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__f)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__g)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__h)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__i)"/><path d="M15.37 5.44c-1.34 0-2.88.45-3.9 2.4-.59 1.12-.89 2.38-1.16 3.63-.09.41-.18.83-.28 1.22v5.66c.51-.14 1.05-.42 1.57-.95 1.96-1.99 2.28-7.2 3.26-8.19.11-.11.23-.18.36-.18.39 0 .7.5.99 1.1.32.67.71 1.43 1.84 1.43.52 0 1.72-.38 1.72-1.85 0-.88-1.47-4.28-4.39-4.28z" fill="url(#prefix__j)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__k)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__l)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__m)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__n)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__o)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="#316aff"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__p)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__q)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__r)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__s)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__t)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__u)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__v)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__w)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__x)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__y)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__z)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__A)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__B)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__C)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__D)"/>',
  "microsoft-teams": '<path d="M15.56 9.91h4.65c.44 0 .8.36.8.8v4.24c0 1.61-1.31 2.92-2.92 2.92h-.01c-1.61 0-2.92-1.31-2.92-2.92v-4.62c0-.23.19-.42.42-.42z" fill="#5059c9"/><circle cx="18.7" cy="7.19" r="1.88" fill="#5059c9"/><circle cx="12.84" cy="6.35" r="2.72" fill="#7b83eb"/><path d="M16.47 9.91H8.8a.79.79 0 00-.77.8v4.83c-.06 2.6 2 4.77 4.6 4.83 2.6-.06 4.67-2.23 4.6-4.83v-4.83a.783.783 0 00-.77-.8z" fill="#7b83eb"/><path d="M3.77 7.4h7.67c.42 0 .77.34.77.77v7.67c0 .42-.34.77-.77.77H3.77a.77.77 0 01-.77-.77V8.17c0-.42.34-.77.77-.77z" fill="#5a62c3"/><path d="M9.62 10.32H8.09v4.18h-.98v-4.18H5.58v-.81h4.04v.81z" fill="#fff"/>'
}, g5 = {
  box: "M15.39,14.04V14.04C15.39,12.62 14.24,11.47 12.82,11.47C11.41,11.47 10.26,12.62 10.26,14.04V14.04C10.26,15.45 11.41,16.6 12.82,16.6C14.24,16.6 15.39,15.45 15.39,14.04M17.1,14.04C17.1,16.4 15.18,18.31 12.82,18.31C11.19,18.31 9.77,17.39 9.05,16.04C8.33,17.39 6.91,18.31 5.28,18.31C2.94,18.31 1.04,16.43 1,14.11V14.11H1V7H1V7C1,6.56 1.39,6.18 1.86,6.18C2.33,6.18 2.7,6.56 2.71,7V7H2.71V10.62C3.43,10.08 4.32,9.76 5.28,9.76C6.91,9.76 8.33,10.68 9.05,12.03C9.77,10.68 11.19,9.76 12.82,9.76C15.18,9.76 17.1,11.68 17.1,14.04V14.04M7.84,14.04V14.04C7.84,12.62 6.69,11.47 5.28,11.47C3.86,11.47 2.71,12.62 2.71,14.04V14.04C2.71,15.45 3.86,16.6 5.28,16.6C6.69,16.6 7.84,15.45 7.84,14.04M22.84,16.96V16.96C22.95,17.12 23,17.3 23,17.47C23,17.73 22.88,18 22.66,18.15C22.5,18.26 22.33,18.32 22.15,18.32C21.9,18.32 21.65,18.21 21.5,18L19.59,15.47L17.7,18V18C17.53,18.21 17.28,18.32 17.03,18.32C16.85,18.32 16.67,18.26 16.5,18.15C16.29,18 16.17,17.72 16.17,17.46C16.17,17.29 16.23,17.11 16.33,16.96V16.96H16.33V16.96L18.5,14.04L16.33,11.11V11.11H16.33V11.11C16.22,10.96 16.17,10.79 16.17,10.61C16.17,10.35 16.29,10.1 16.5,9.93C16.89,9.65 17.41,9.72 17.7,10.09V10.09L19.59,12.61L21.5,10.09C21.76,9.72 22.29,9.65 22.66,9.93C22.89,10.1 23,10.36 23,10.63C23,10.8 22.95,10.97 22.84,11.11V11.11H22.84V11.11L20.66,14.04L22.84,16.96V16.96H22.84Z",
  dropbox: "M3 6.2L8 9.39L13 6.2L8 3L3 6.2M13 6.2L18 9.39L23 6.2L18 3L13 6.2M3 12.55L8 15.74L13 12.55L8 9.35L3 12.55M18 9.35L13 12.55L18 15.74L23 12.55L18 9.35M8.03 16.8L13.04 20L18.04 16.8L13.04 13.61L8.03 16.8Z",
  "google-drive": "M7.71,3.5L1.15,15L4.58,21L11.13,9.5M9.73,15L6.3,21H19.42L22.85,15M22.28,14L15.42,2H8.58L8.57,2L15.43,14H22.28Z",
  onedrive: "M18.21 10.29Q19 10.34 19.7 10.68 20.39 11 20.9 11.57 21.41 12.12 21.71 12.83 22 13.54 22 14.34 22 15.18 21.68 15.92 21.36 16.66 20.8 17.21 20.25 17.76 19.5 18.08 18.78 18.41 17.94 18.41H7Q5.97 18.41 5.06 18 4.15 17.61 3.47 16.94 2.79 16.26 2.4 15.35 2 14.44 2 13.41 2 12.59 2.26 11.83 2.5 11.08 3 10.45 3.44 9.82 4.08 9.35 4.72 8.88 5.5 8.63 5.87 8.5 6.21 8.5 6.56 8.43 6.93 8.41H6.94Q7.37 7.75 7.95 7.23 8.5 6.71 9.2 6.34 9.87 6 10.62 5.78 11.37 5.59 12.16 5.59 13.22 5.59 14.2 5.94 15.18 6.29 16 6.91 16.8 7.53 17.37 8.39 17.95 9.26 18.21 10.29M12.16 6.84Q11.05 6.84 10.06 7.3 9.06 7.75 8.36 8.6 8.73 8.7 9.07 8.85 9.4 9 9.73 9.2L13.71 11.58L16 10.62Q16.21 10.53 16.44 10.45 16.67 10.38 16.92 10.33 16.68 9.55 16.21 8.91 15.74 8.27 15.11 7.81 14.5 7.35 13.73 7.1 13 6.84 12.16 6.84M4 15.66L12.27 12.18L9.08 10.26Q8.59 9.97 8.06 9.81 7.5 9.66 6.95 9.66 6.19 9.66 5.5 9.96 4.84 10.26 4.34 10.77 3.84 11.29 3.54 11.97 3.25 12.65 3.25 13.41 3.25 14 3.45 14.59 3.64 15.19 4 15.66M17.94 17.16Q18.41 17.16 18.84 17 19.27 16.86 19.64 16.58L13.61 13L5.03 16.59Q5.47 16.86 5.97 17 6.47 17.16 7 17.16M20.45 15.61Q20.75 15 20.75 14.34 20.75 13.7 20.5 13.17 20.26 12.65 19.85 12.28 19.43 11.91 18.88 11.71 18.32 11.5 17.7 11.5 17.35 11.5 17 11.6 16.66 11.68 16.33 11.81 16 11.93 15.67 12.08 15.35 12.23 15.04 12.37Z"
}, b5 = {
  email: $2,
  file: _2,
  "file-upload": R2,
  "file-music": A2,
  "file-image": M2,
  "file-video": T2,
  "file-code": ff,
  "file-xml": ff,
  "file-document": mf,
  "file-word": L2,
  "file-excel": S2,
  "file-pdf": mf,
  "file-powerpoint": E2,
  "file-compressed": I2
}, bf = {
  "account-minus": jb,
  "account-plus": Wb,
  alert: Kb,
  "alert-circle": Qb,
  "alert-octagon": Gb,
  "arrow-collapse": Zb,
  "arrow-expand": Yb,
  attachment: Jb,
  back: wf,
  "backup-restore": t2,
  bell: e2,
  "bell-off": i2,
  agent: l5,
  check: Uu,
  "check-all": n2,
  "check-circle-outline": s2,
  "checkbox-blank": o2,
  "checkbox-marked": c2,
  "circle-outline": l2,
  "check-circle": a2,
  close: d2,
  "close-circle": h2,
  cloud: u2,
  comment: p2,
  "comment-outline": y2,
  "content-save": w2,
  delete: m2,
  "delete-restore": g2,
  "delete-forever": v2,
  "dots-vertical": b2,
  download: x2,
  earth: C2,
  emoticon: k2,
  "emoticon-plus": P2,
  "fit-screen": z2,
  "fit-width": O2,
  fullscreen: D2,
  "fullscreen-exit": V2,
  "help-circle": H2,
  information: B2,
  magnify: N2,
  meeting: Q2,
  "menu-down": U2,
  "menu-up": q2,
  message: j2,
  "message-text": W2,
  minus: K2,
  next: Xb,
  "open-in-new": G2,
  pencil: Z2,
  pin: Y2,
  unpin: X2,
  plus: J2,
  "plus-circle-outline": t5,
  poll: r2,
  previous: wf,
  read: Uu,
  restore: e5,
  unread: Uu,
  send: r5,
  "server-network-off": n5,
  "shield-star": a5,
  "shield-star-outline": s5,
  sort: o5,
  star: c5,
  unstar: d5,
  stars: f2,
  "swap-horizontal": h5,
  textbox: F2,
  "thumb-up": u5,
  "thumb-up-outline": p5,
  trashcan: y5,
  video: w5,
  "view-list-outline": f5,
  "view-module-outline": m5,
  "wifi-off": v5,
  ...b5,
  ...g5
}, xf = {
  dropbox: "#0061fe",
  onedrive: "#0078d4",
  box: "#0161d5",
  "google-drive": "#1a73e8",
  zoom: "#4a8cff"
};
function Cf(n) {
  return n && n in bf ? bf[n] : "";
}
a(Cf, "getIconMapping");
function x5(n) {
  return n && n in gf ? gf[n] : "";
}
a(x5, "getSvgMapping");
const Iw = class Iw extends Qc {
  constructor(t) {
    if (super(t), this.it = b, t.type !== yd.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(t) {
    if (t === b || t == null) return this._t = void 0, this.it = t;
    if (t === gh) return t;
    if (typeof t != "string") throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (t === this.it) return this._t;
    this.it = t;
    const e = [t];
    return e.raw = e, this._t = { _$litType$: this.constructor.resultType, strings: e, values: [] };
  }
};
a(Iw, "e");
let Rc = Iw;
Rc.directiveName = "unsafeHTML", Rc.resultType = 1;
const An = Yn(Rc);
const Fw = class Fw extends Rc {
};
a(Fw, "t");
let xl = Fw;
xl.directiveName = "unsafeSVG", xl.resultType = 2;
const $f = Yn(xl), Py = j`[part~=wy-icon-wrapper]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative}[part~=wy-icon]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-icon][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon-first]{margin-left:calc(-.5*var(--wy-size, 1rem))}[part~=wy-icon-last]{margin-right:calc(-.5*var(--wy-size, 1rem))}[part~=wy-icon-inline]{vertical-align:-.25em}[part~=wy-icon-overlay]{position:absolute;bottom:0;right:0;border-radius:50%}:host(wy-icon-stack),[part~=wy-icon-stack]{display:inline-flex;position:relative;line-height:1}[part~=wy-icon-stack-layer]{position:absolute}[part~=wy-icon-stack-overlay]{position:absolute;bottom:0;right:0;border-radius:50%;width:calc(var(--wy-component-icon-width)/2);height:calc(var(--wy-component-icon-height)/2)}[part~=wy-icon-current-color]{fill:currentColor}[part~=wy-icon-state]{transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));align-self:center;justify-self:center;margin:auto;opacity:0}[part~=wy-icon-state][part~=wy-active]{opacity:1}[part~=wy-icon-display]{color:var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));border-radius:var(--wy-component-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;padding:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem))}[part~=wy-icon-display-fill]{flex:1 0 auto}[part~=wy-icon-display-icon]{color:var(--wy-component-color);--wy-component-icon-width: calc(4 * var(--wy-size, 1rem));--wy-component-icon-height: calc(4 * var(--wy-size, 1rem));padding:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem))}[part~=wy-icon-display-text],[part~=wy-icon-display-meta]{color:var(--wy-component-color);padding:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem));text-align:center;line-height:var(--wy-line-height, 1.5)}[part~=wy-icon-color-primary]{fill:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-icon-color-secondary]{fill:var(--wy-secondary, var(--wy-secondary-light, #51606f))}[part~=wy-icon-color-tertiary]{fill:var(--wy-tertiary, var(--wy-tertiary-light, #645f41))}[part~=wy-icon-color-surface]{fill:var(--wy-surface, var(--wy-surface-light, #f7f9ff))}[part~=wy-icon-color-surface-variant]{fill:var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb))}[part~=wy-icon-color-error]{fill:var(--wy-error, var(--wy-error-light, #ba1821))}[part~=wy-icon-color-warning]{fill:var(--wy-warning, var(--wy-warning-light, #adb140))}[part~=wy-icon-color-blue]{fill:var(--wy-blue, var(--wy-blue-light, #8aa9fc))}[part~=wy-icon-color-indigo]{fill:var(--wy-indigo, var(--wy-indigo-light, #9285de))}[part~=wy-icon-color-purple]{fill:var(--wy-purple, var(--wy-purple-light, #c675b6))}[part~=wy-icon-color-pink]{fill:var(--wy-pink, var(--wy-pink-light, #d57193))}[part~=wy-icon-color-red]{fill:var(--wy-red, var(--wy-red-light, #db726b))}[part~=wy-icon-color-orange]{fill:var(--wy-orange, var(--wy-orange-light, #e79b3a))}[part~=wy-icon-color-yellow]{fill:var(--wy-yellow, var(--wy-yellow-light, #adb140))}[part~=wy-icon-color-green]{fill:var(--wy-green, var(--wy-green-light, #00a38d))}[part~=wy-icon-color-teal]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a9))}[part~=wy-icon-color-cyan]{fill:var(--wy-cyan, var(--wy-cyan-light, #0081a2))}[part~=wy-icon-color-gray]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-icon-color-black]{fill:var(--wy-black, var(--wy-black, #000000))}[part~=wy-icon-color-white]{fill:var(--wy-white, var(--wy-white, #ffffff))}[part*=wy-kind-]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-kind-archive]{fill:var(--wy-orange, var(--wy-orange-light, #e79b3a))}[part~=wy-kind-audio]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a9))}[part~=wy-kind-code]{fill:var(--wy-green, var(--wy-green-light, #00a38d))}[part~=wy-kind-document]{fill:var(--wy-blue, var(--wy-blue-light, #8aa9fc))}[part~=wy-kind-email]{fill:var(--wy-red, var(--wy-red-light, #db726b))}[part~=wy-kind-presentation]{fill:var(--wy-orange, var(--wy-orange-light, #e79b3a))}[part~=wy-kind-spreadsheet]{fill:var(--wy-green, var(--wy-green-light, #00a38d))}[part~=wy-kind-image]{fill:var(--wy-pink, var(--wy-pink-light, #d57193))}[part~=wy-kind-text]{fill:var(--wy-cyan, var(--wy-cyan-light, #0081a2))}[part~=wy-kind-video]{fill:var(--wy-purple, var(--wy-purple-light, #c675b6))}[part~=wy-ext-pdf]{fill:var(--wy-red, var(--wy-red-light, #db726b))}[part~=wy-kind-text-icon]{width:calc(1.25*var(--wy-size, 1rem));height:calc(1.25*var(--wy-size, 1rem));vertical-align:calc(-.3125*var(--wy-size, 1rem))}`;
var C5 = Object.defineProperty, $5 = Object.getOwnPropertyDescriptor, Jt = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? $5(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && C5(t, e, r), r;
}, "__decorateClass$1a"), Ds;
let Wt = (Ds = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.color = "", this.size = 24, this.path = vf, this.inline = !1, this.first = !1, this.last = !1, this.layer = !1, this.state = !1, this.active = !1, this.uniqueId = `wy-icon-${fl()}`;
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("name") && this.name && (this.path = Cf(this.name) || vf, this.overlayPath = Cf(this.overlayName) || this.overlayPath, this.nativeIconColor = this.color === "native" && xf[this.name] || void 0, this.nativeOverlayColor = this.overlayName && xf[this.overlayName] || void 0);
  }
  render() {
    const t = this.kind ? om(this.kind) : this.kind, e = this.ext?.startsWith(".") ? this.ext.substring(1) : this.ext, i = {
      "wy-icon-wrapper": !0,
      "wy-icon-stack-layer": this.layer
    }, r = {
      "wy-icon": !0,
      "wy-icon-current-color": !t && !this.color,
      ["wy-kind-" + t]: !!t,
      ["wy-ext-" + e]: !!e,
      ["wy-icon-color-" + this.color]: !!this.color,
      "wy-icon-first": this.first,
      "wy-icon-last": this.last,
      "wy-icon-inline": this.inline,
      "wy-icon-state": this.state,
      "wy-active": this.active
    }, s = this.size !== 24, o = this.size / 16, c = s ? `width: var(--wy-component-icon-width, calc(${o} * var(--wy-size, 1rem))); height: var(--wy-component-icon-height, calc(${o} * var(--wy-size, 1rem)));` : "", l = this.svg && x5(this.svg);
    return this.overlayPath ? [
      h`
          <style>
            .icon-mask-bg {
              width: var(--wy-component-icon-width, calc(${o} * var(--wy-size, 1rem)));
              height: var(--wy-component-icon-height, calc(${o} * var(--wy-size, 1rem)));
              fill: white;
            }

            .icon-mask {
              width: calc(var(--wy-component-icon-width, calc(${o} * var(--wy-size, 1rem))));
              height: calc(var(--wy-component-icon-height, calc(${o} * var(--wy-size, 1rem))));
              ry: calc(var(--wy-border-radius-pill, var(--wy-border-radius, 50%)));
              x: calc(var(--wy-component-icon-width, calc(${o} * var(--wy-size, 1rem))) / 2);
              y: calc(var(--wy-component-icon-height, calc(${o} * var(--wy-size, 1rem))) / 2);
              stroke: black;
              stroke-width: 4px;
              fill: black;
            }
          </style>
        `,
      h`
          <div part=${J(i)}>
            <wy-icon-stack style="${c}">
              <svg
                part=${J(r)}
                viewBox="0 0 24 24"
                width="${this.size}"
                height="${this.size}"
                style="mask-image: url(#${this.uniqueId}-mask); -webkit-mask-image: url(#${this.uniqueId}-mask);"
              >
                <defs>
                  <mask id="${this.uniqueId}-mask">
                    <rect class="icon-mask-bg" />
                    <rect class="icon-mask" />
                  </mask>
                </defs>
                ${l ? $f(l) : Nd`
                    <path d="${this.path}" style="fill: ${dt(this.nativeIconColor)}" />
                  `}
                <!--rect width="24" height="24" fill="transparent" /-->
              </svg>
              <svg part="wy-icon-stack-overlay" viewBox="0 0 24 24" width="${this.size / 2}" height="${this.size / 2}">
                <path d="${this.overlayPath}" style="fill: ${dt(this.nativeOverlayColor)}" />
                <!--rect width="24" height="24" fill="transparent" /-->
              </svg>
            </wy-icon-stack>
            <slot></slot>
          </div>
        `
    ] : h`
      <div part=${J(i)}>
        <svg
          part=${J(r)}
          style="${c}"
          viewBox="0 0 24 24"
          width="${this.size}"
          height="${this.size}"
        >
          ${l ? $f(l) : Nd`
            <path d="${this.path}" style="fill: ${dt(this.nativeIconColor)}" />
          `}
          <!--rect width="24" height="24" fill="transparent" /-->
        </svg>
        <slot></slot>
      </div>
    `;
  }
}, a(Ds, "WyIcon"), Ds);
Wt.styles = [Ht, Py, X];
Jt([
  u()
], Wt.prototype, "name", 2);
Jt([
  u()
], Wt.prototype, "overlayName", 2);
Jt([
  u()
], Wt.prototype, "svg", 2);
Jt([
  u()
], Wt.prototype, "color", 2);
Jt([
  u({ type: Number })
], Wt.prototype, "size", 2);
Jt([
  u()
], Wt.prototype, "kind", 2);
Jt([
  u()
], Wt.prototype, "ext", 2);
Jt([
  u({ attribute: !1 })
], Wt.prototype, "path", 2);
Jt([
  u({ attribute: !1 })
], Wt.prototype, "overlayPath", 2);
Jt([
  u({ type: Boolean })
], Wt.prototype, "inline", 2);
Jt([
  u({ type: Boolean })
], Wt.prototype, "first", 2);
Jt([
  u({ type: Boolean })
], Wt.prototype, "last", 2);
Jt([
  u({ type: Boolean })
], Wt.prototype, "layer", 2);
Jt([
  u({ type: Boolean })
], Wt.prototype, "state", 2);
Jt([
  u({ type: Boolean })
], Wt.prototype, "active", 2);
Jt([
  D()
], Wt.prototype, "nativeIconColor", 2);
Jt([
  D()
], Wt.prototype, "nativeOverlayColor", 2);
Wt = Jt([
  B("wy-icon")
], Wt);
var Vs;
let nh = (Vs = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this);
  }
  render() {
    return h`<slot></slot>`;
  }
}, a(Vs, "WyIconStack"), Vs);
nh.styles = [Ht, Py];
nh = Jt([
  B("wy-icon-stack")
], nh);
var Hs;
let Cl = (Hs = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.fill = !1;
  }
  render() {
    return h`
      <div part="wy-icon-display ${J({ "wy-icon-display-fill": this.fill })}">
        <div part="wy-icon-display-icon">
          <slot></slot>
        </div>
        <div part="wy-icon-display-text">
          <slot name="text"></slot>
        </div>
        <div part="wy-icon-display-meta">
          <slot name="meta"></slot>
        </div>
      </div>
    `;
  }
}, a(Hs, "WyIconDisplay"), Hs);
Cl.styles = [Ht, Py, X];
Jt([
  u({ type: Boolean })
], Cl.prototype, "fill", 2);
Cl = Jt([
  B("wy-icon-display")
], Cl);
var k5 = Object.defineProperty, P5 = Object.getOwnPropertyDescriptor, ri = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? P5(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && k5(t, e, r), r;
}, "__decorateClass$19"), Bs;
let Li = (Bs = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.size = 32, this.src = "", this.name = "", this.description = "", this.isAgent = !1;
  }
  render() {
    const t = this.size / 16;
    let e;
    !this.src && this.name && (e = F1(this.name));
    const i = {
      "wy-avatar-shape": !0,
      "wy-avatar-img": !!this.src,
      "wy-avatar-initials": !this.src,
      "wy-presence-mask": this.presence === Cy.Active
    };
    return h`
      ${this.src ? h`
            <img
              alt=""
              title="${this.name}${this.description ? ` • ${this.description}` : ""}"
              part=${J(i)}
              style="--wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));"
              height="${this.size}"
              width="${this.size}"
              src="${this.src}"
              decoding="async"
              loading="lazy"
            />
          ` : h`
            <div
              part=${J(i)}
              style="--wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));"
              title="${this.name}${this.description ? ` • ${this.description}` : ""}"
            >
              <span part="wy-avatar-initials-text">${e}</span>
            </div>
          `}
      ${this.isAgent ? h`<wy-icon part="wy-avatar-type-icon" name="agent" size="${this.size / 3 * 1.25}"></wy-icon>` : b}
      ${this.presence && !this.isAgent ? h`<wy-presence part="wy-avatar-presence" .status=${this.presence} id=${this.id}></wy-presence>` : b}
    `;
  }
}, a(Bs, "WyAvatar"), Bs);
Li.styles = [Ht, $y, sv];
ri([
  u({ type: Number })
], Li.prototype, "size", 2);
ri([
  u()
], Li.prototype, "src", 2);
ri([
  u()
], Li.prototype, "name", 2);
ri([
  u()
], Li.prototype, "description", 2);
ri([
  u({ type: Boolean, reflect: !0 })
], Li.prototype, "isAgent", 2);
ri([
  u()
], Li.prototype, "presence", 2);
Li = ri([
  B("wy-avatar")
], Li);
var Ns;
let En = (Ns = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.size = 32, this.uniqueId = `wy-avatar-${fl()}`;
  }
  render() {
    if (!this.user)
      return b;
    const t = this.size / 16, e = (this.members || []).filter((s) => s.id !== this.user?.id).slice(0, 2).reverse(), i = e?.shift() || this.user, r = e?.shift() || (i !== this.user ? this.user : void 0);
    return [
      h`
        <style>
          :host {
            --wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));
          }

          [part~="wy-avatar-mask-bg"] {
            width: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            height: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            fill: white;
          }

          [part~="wy-avatar-mask"] {
            width: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            height: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            ry: var(--wy-avatar-border-radius, var(--wy-border-radius-pill, var(--wy-border-radius, 50%)));
            x: calc(${t / 3} * var(--wy-size, 1rem));
            y: calc(${t / 3} * var(--wy-size, 1rem));
            stroke: black;
            stroke-width: 4px;
            fill: black;
          }
        </style>
      `,
      h`
        <svg>
          <defs>
            <mask id="${this.uniqueId}-mask">
              <rect part="wy-avatar-mask-bg" />
              <rect part="wy-avatar-mask" />
            </mask>
          </defs>
        </svg>
      `,
      h`
        <wy-avatar
          part="wy-avatar-back"
          style="mask-image: url(#${this.uniqueId}-mask); -webkit-mask-image: url(#${this.uniqueId}-mask);"
          .src=${r?.avatar_url}
          .name=${r?.name}
          size=${this.size * 2 / 3}
        ></wy-avatar>
        <wy-avatar
          part="wy-avatar-front"
          .src=${i.avatar_url}
          .name=${i.name}
          .isAgent=${i.is_agent}
          size=${this.size * 2 / 3}
        ></wy-avatar>
      `
    ];
  }
}, a(Ns, "WyAvatarGroup"), Ns);
En.styles = [Ht, $y, X];
ri([
  u({ type: Number })
], En.prototype, "size", 2);
ri([
  u({
    type: Array,
    attribute: !1
  })
], En.prototype, "members", 2);
ri([
  be({ context: xh, subscribe: !0 }),
  D()
], En.prototype, "user", 2);
En = ri([
  B("wy-avatar-group")
], En);
var Us;
let $l = (Us = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this);
  }
  render() {
    return h`
      <slot></slot>
      ${this.description ? h` <div part="wy-avatar-description">${this.description}</div> ` : b}
    `;
  }
}, a(Us, "WyAvatarHeader"), Us);
$l.styles = [Ht, $y];
ri([
  u()
], $l.prototype, "description", 2);
$l = ri([
  B("wy-avatar-header")
], $l);
const _5 = j`[part~=wy-empty]{display:flex;align-items:center;justify-content:center;flex:1;min-width:0;position:relative;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}`, ov = j`[part~=wy-progress]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative}[part~=wy-progress-padded]{margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-progress-overlay]{position:absolute!important}[part~=wy-progress-reveal]{overflow:hidden;opacity:1;interpolate-size:allow-keywords;height:auto;transition:width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),margin var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-progress-reveal]{width:0;height:0;opacity:0;margin:0}}`, S5 = j`[part~=wy-progress-circular]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-progress-circular]:not([width]),[part~=wy-progress-circular][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress-circular]:not([height]),[part~=wy-progress-circular][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress-circular][part~=wy-primary]{color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-progress-remaining]{fill:none;stroke:var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb))}[part~=wy-progress-done]{fill:none;stroke:currentColor}[part~=wy-progress-overlay]{position:absolute;inset:0;margin:auto}[part~=wy-progress-indeterminate-circle]{stroke-dasharray:1,100;stroke-dashoffset:0;transform-origin:center;fill:none!important}[part~=wy-progress-indeterminate]{animation:wy-rotate 1.4s linear infinite}[part~=wy-progress-indeterminate] [part~=wy-progress-indeterminate-circle]{animation:wy-dash 1.4s ease-in-out infinite,wy-color 2.8s ease-in-out infinite}@keyframes wy-rotate{to{transform:rotate(360deg)}}@keyframes wy-dash{0%{stroke-dasharray:1,100;stroke-dashoffset:0}50%{stroke-dasharray:44.5,100;stroke-dashoffset:-17.5}to{stroke-dasharray:44.5,100;stroke-dashoffset:-62}}@keyframes wy-color{0%,to{stroke:var(--wy-primary, var(--wy-primary-light, #2f628c))}25%{stroke:var(--wy-primary, var(--wy-primary-light, #2f628c))}50%{stroke:#0000}75%{stroke:var(--wy-primary, var(--wy-primary-light, #2f628c))}}`;
var M5 = Object.defineProperty, A5 = Object.getOwnPropertyDescriptor, tn = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? A5(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && M5(t, e, r), r;
}, "__decorateClass$18"), qs;
let wi = (qs = class extends it {
  constructor() {
    super(...arguments), this.shadowParts = new q(this), this.size = 24, this.indeterminate = !1, this.padded = !1, this.overlay = !1, this.value = 0, this.max = 1, this.reveal = !1;
  }
  render() {
    const t = {
      "wy-progress": !0,
      "wy-progress-reveal": this.reveal,
      "wy-progress-overlay": this.overlay,
      "wy-progress-padded": this.padded
    }, e = {
      "wy-progress-circular": !0,
      "wy-primary": !this.indeterminate,
      "wy-progress-indeterminate": this.indeterminate
    }, i = 10, r = Math.PI * (i * 2);
    let s;
    try {
      Number.isFinite(this.value) && Number.isFinite(this.max) && this.max > 0 && (s = this.value / this.max);
    } catch (o) {
      console.error(o);
    }
    return h`
      <div part="${J(t)}">
        ${this.indeterminate || s === void 0 ? Nd`
              <svg
                part="${J(e)}"
                viewBox="0 0 24 24"
                width=${this.size}
                height=${this.size}
                role="progressbar"
                aria-label="${b}"
                aria-valuemin="0"
                aria-valuemax=${this.max}
                aria-valuenow=${b}
                xmlns="http://www.w3.org/2000/svg"
              >
                <circle
                  part="wy-progress-circle wy-progress-indeterminate-circle"
                  fill="none"
                  cx="12"
                  cy="12"
                  r=${i}
                  stroke-linecap="butt"
                  stroke-width="2"
                ></circle>
              </svg>
            ` : Nd`
              <svg
                part="${J(e)}"
                viewBox="0 0 24 24"
                width=${this.size}
                height=${this.size}
                transform="rotate(-90)"
                role="progressbar"
                aria-label="${b}"
                aria-valuemin="0"
                aria-valuemax=${this.max}
                aria-valuenow=${this.value}
                xmlns="http://www.w3.org/2000/svg"
              >
                <circle
                  part="wy-progress-circle wy-progress-remaining"
                  cx="12"
                  cy="12"
                  r=${i}
                  stroke-linecap="butt"
                  stroke-width="2"
                  fill="none"
                  stroke="#eee"
                ></circle>
                <circle
                  part="wy-progress-circle wy-progress-done"
                  cx="12"
                  cy="12"
                  r=${i}
                  stroke-dasharray=${r}
                  stroke-dashoffset=${r * (1 - s)}
                  stroke-linecap="butt"
                  stroke-width="2"
                  fill="none"
                  stroke="currentColor"
                  path-length="200"
                ></circle>
              </svg>
            `}
      </div>
    `;
  }
}, a(qs, "WyProgressCircular"), qs);
wi.styles = [Ht, ov, S5, X];
tn([
  u({ type: Number })
], wi.prototype, "size", 2);
tn([
  u({ type: Boolean })
], wi.prototype, "indeterminate", 2);
tn([
  u({ type: Boolean })
], wi.prototype, "padded", 2);
tn([
  u({ type: Boolean })
], wi.prototype, "overlay", 2);
tn([
  u({ type: Number })
], wi.prototype, "value", 2);
tn([
  u({ type: Number })
], wi.prototype, "max", 2);
tn([
  u({ type: Boolean })
], wi.prototype, "reveal", 2);
wi = tn([
  B("wy-progress-circular")
], wi);
var E5 = Object.defineProperty, R5 = Object.getOwnPropertyDescriptor, _y = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? R5(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && E5(t, e, r), r;
}, "__decorateClass$17"), js;
let Tc = (js = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.noNetwork = !1, this.handleUpdate = () => this.requestUpdate();
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("weavy")) {
      const e = t.get("weavy");
      e && e !== this.weavy && e.removeNetworkListener(this.handleUpdate), this.weavy && e !== this.weavy && this.weavy.addNetworkListener(this.handleUpdate);
    }
  }
  render() {
    return h`
      <div part="wy-empty">
        ${this.weavy && !this.noNetwork && this.weavy?.network.state === "unreachable" ? h`
              <wy-icon-display>
                <wy-icon name="server-network-off"></wy-icon>
                <span slot="text">${x("The server is offline, try again in a few minutes...")}</span>
                <wy-progress-circular indeterminate slot="meta" ?hidden=${!this.weavy?.network.isPending}></wy-progress-circular>
              </wy-icon-display>
            ` : !this.noNetwork && this.weavy?.network.state === "offline" ? h`
              <wy-icon-display>
                <wy-icon name="wifi-off"></wy-icon>
                <span slot="text">${x("You are currently offline.")}</span>
                <wy-progress-circular indeterminate slot="meta" ?hidden=${!this.weavy?.network.isPending}></wy-progress-circular>
              </wy-icon-display>
            ` : h`
              <slot>
                <wy-icon-display>
                  <wy-icon name="information"></wy-icon>
                  <slot slot="text" name="title">
                    <span>${x("Nothing to see here yet.")}</span>
                  </slot>
                </wy-icon-display>
              </slot>
            `}
      </div>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.weavy?.addNetworkListener(this.handleUpdate);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.weavy?.removeNetworkListener(this.handleUpdate);
  }
}, a(js, "WyEmpty"), js);
Tc.styles = [
  _5,
  X
];
_y([
  be({ context: he, subscribe: !0 }),
  D()
], Tc.prototype, "weavy", 2);
_y([
  u({ type: Boolean })
], Tc.prototype, "noNetwork", 2);
Tc = _y([
  B("wy-empty"),
  ht()
], Tc);
const T5 = j`@keyframes wy-bouncing{to{transform:translate3d(0,calc(-.25 * var(--wy-size, 1rem)),0)}}@keyframes wy-bouncing-fade{to{opacity:.2}}[part~=wy-bouncer]{width:calc(1.5*var(--wy-size, 1rem));height:calc(.75*var(--wy-size, 1rem))}[part~=wy-bouncer-dot]{position:relative;animation:wy-bouncing .6s infinite alternate,wy-bouncing-fade .6s infinite alternate;fill:currentColor}[part~=wy-bouncer-dot-start]{animation-delay:0s,.6s}[part~=wy-bouncer-dot-middle]{animation-delay:.3s,.3s}[part~=wy-bouncer-dot-end]{animation-delay:.6s,0s}`;
var L5 = Object.defineProperty, O5 = Object.getOwnPropertyDescriptor, fr = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? O5(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && L5(t, e, r), r;
}, "__decorateClass$16"), Ws;
let ci = (Ws = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.typing = new eh(this), this.isPrivateChat = !1, this.members = [], this.typingMembers = [], this.names = [];
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("conversationId") && (this.typing.appId = this.conversationId), t.has("userId") && (this.typing.userId = this.userId);
    const { typingMembers: e, names: i } = this.typing;
    this.typingMembers = e, this.names = i, e.length ? this.typingTime ||= /* @__PURE__ */ new Date() : this.typingTime = void 0;
  }
  render() {
    const t = this.typingMembers.map(
      (o) => this.members.find((c) => c.id === o.id)
    ).filter((o) => o), e = new Intl.ListFormat(this.weavy?.locale, { style: "long", type: "conjunction" }).format(
      this.names
    ), i = this.typingTime ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(this.typingTime) : "", r = this.typingTime ? new Intl.DateTimeFormat(this.weavy?.locale, { timeStyle: "short" }).format(this.typingTime) : "", s = h`
      <svg part="wy-bouncer" viewBox="0 0 32 16" xmlns="http://www.w3.org/2000/svg">
        <circle part="wy-bouncer-dot wy-bouncer-dot-start" cx="4" cy="10" r="4" />
        <circle part="wy-bouncer-dot wy-bouncer-dot-middle" cx="16" cy="10" r="4" />
        <circle part="wy-bouncer-dot wy-bouncer-dot-end" cx="28" cy="10" r="4" />
      </svg>
    `;
    return t.length ? h`
          <div part=${J({ "wy-message": !0, "wy-message-agent": !!t[0]?.is_agent })}>
            <div part="wy-message-author">
              ${t.length > 1 ? h`
                    <wy-avatar-group
                      .size=${32}
                      .members=${t}
                      title=${e}
                    ></wy-avatar-group>
                  ` : h`
                    <wy-avatar
                      .size=${32}
                      .src=${t[0]?.avatar_url}
                      .description=${t[0]?.comment}
                      .name=${e}
                      .isAgent=${t[0]?.is_agent}
                    ></wy-avatar>
                  `}
            </div>

            <div part="wy-message-content">
              <div part="wy-message-meta">
                ${this.isPrivateChat ? h`
                      <time datetime=${dt(this.typingTime?.toISOString())} title=${i}>${r}</time>
                    ` : e}
              </div>
              <div part="wy-message-bubble"> ${s} </div>
            </div>
          </div>
        ` : b;
  }
}, a(Ws, "WyMessageTyping"), Ws);
ci.styles = [Ht, T5, _h];
fr([
  be({ context: he, subscribe: !0 }),
  D()
], ci.prototype, "weavy", 2);
fr([
  u({ attribute: !0, type: Number })
], ci.prototype, "conversationId", 2);
fr([
  u({ attribute: !0, type: Number })
], ci.prototype, "userId", 2);
fr([
  u({ type: Boolean })
], ci.prototype, "isPrivateChat", 2);
fr([
  u({ attribute: !1 })
], ci.prototype, "members", 2);
fr([
  D()
], ci.prototype, "typingMembers", 2);
fr([
  D()
], ci.prototype, "names", 2);
fr([
  D()
], ci.prototype, "typingTime", 2);
ci = fr([
  B("wy-message-typing")
], ci);
const Sh = j`:host(wy-item),[part~=wy-item]{--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));display:flex;box-sizing:border-box}[part~=wy-item-rounded]{border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-item-rounded-outer]{border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-item-inner]{display:flex;position:relative;align-items:center;text-decoration:none;gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));flex:1 1 100%;min-width:0}[part~=wy-item-inner-no-padding]{padding:0}[part~=wy-item-sm]{min-height:calc(2*var(--wy-size, 1rem));padding:0 var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-item-md]{min-height:calc(3*var(--wy-size, 1rem))}[part~=wy-item-lg]{min-height:calc(4.5*var(--wy-size, 1rem))}[part~=wy-item-top]{align-items:flex-start}[part~=wy-item-body]{width:100%;min-width:0;min-height:100%;display:flex}[part~=wy-item-rows]{display:flex;flex-direction:column;min-width:0;justify-content:space-evenly;flex:1 1 100%}[part~=wy-item-row]{display:flex;align-items:center;column-gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));min-height:calc(var(--wy-button-line-height, var(--wy-line-height, 1.5))*var(--wy-size, 1rem))}[part~=wy-item-title] a:after{position:absolute;inset:0;z-index:1;content:\"\"}[part~=wy-item-title] a{color:inherit;text-decoration:none}[part~=wy-item-title]{color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset))}[part~=wy-item-title]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-item-image]{display:contents}[part~=wy-item-text]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-item-text]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-item-text-sm]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))}[part~=wy-item-meta]{white-space:nowrap}[part~=wy-item-actions]{--wy-component-background-color: transparent;display:flex;align-items:center;justify-items:flex-end;flex:0 0 auto;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-item-actions-top]{align-self:flex-start;margin:calc(-.25*var(--wy-size, 1rem))}[part~=wy-item-actions-bottom]{align-self:flex-start;margin:calc(-.125*var(--wy-size, 1rem)) 0 calc(-.625*var(--wy-size, 1rem))}[part~=wy-item-left]{margin-right:auto}[part~=wy-item-right]{margin-left:auto}[part~=wy-read]{opacity:var(--wy-opacity-muted, 65%);--wy-component-color: var(--wy-outline, var(--wy-outline-light, #72777f))}[part~=wy-unread]{--wy-component-color: color.token(--wy-on-background)}[part~=wy-unread] [part~=wy-item-title],[part~=wy-unread] [part~=wy-item-text]{font-weight:var(--wy-font-weight-bold, 600);color:var(--wy-component-color)}[part~=wy-item-interactive]{background-color:var(--wy-component-background-color);color:var(--wy-component-color);-webkit-user-select:none;user-select:none;cursor:pointer}[part~=wy-item-interactive]:hover,[part~=wy-item-interactive]:focus{--wy-component-background-color: var(--wy-component-background-color-hover, var(--wy-surface-layer-high, var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039))));text-decoration:none}[part~=wy-item-interactive]:active{--wy-component-background-color: var(--wy-component-background-color-active, var(--wy-surface-layer-highest, var(--wy-surface-layer-highest-light, rgba(0, 0, 0, .1019607843))))}[part~=wy-item-interactive][part~=wy-disabled],[part~=wy-item-interactive]:disabled{opacity:var(--wy-opacity-disabled, 38%);pointer-events:none}[part~=wy-item-interactive][part~=wy-selected]{--wy-component-background-color: var(--wy-component-background-color-selected, var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff)));--wy-component-color: var(--wy-component-color-selected, var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73)));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-color:var(--wy-component-background-color)}[part~=wy-item-trashed]{text-decoration:line-through;opacity:var(--wy-opacity-disabled, 38%)}[part~=wy-item-trashed][part~=wy-item-interactive]:hover{opacity:1}[part~=wy-item-list]{display:flex;flex-direction:column;gap:var(--wy-border, 1px);min-width:0}[part~=wy-item-list-filled]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));--wy-component-background-color: var(--wy-surface-layer-low, var(--wy-surface-layer-low-light, rgba(255, 255, 255, .5019607843)));--wy-component-background-color-hover: var(--wy-surface-layer-lowest, var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078)));--wy-component-background-color-active: var(--wy-surface-layer-lowest, var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078)))}[part~=wy-item-list-rounded]{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));clip-path:content-box}[part~=wy-item-list-rounded-outer]{border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));clip-path:content-box}[part~=wy-item-list-bordered]{border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));gap:0}[part~=wy-item-list-bordered]>:not(slot),[part~=wy-item-list-bordered] ::slotted(*){border-left:none;border-right:none}[part~=wy-item-list-bordered]>:not(slot):not(:first-child),[part~=wy-item-list-bordered] ::slotted(*:not(:first-child)){border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}`, Gc = j`[part~=wy-title]{font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));font-size:var(--wy-headings-font-size, var(--wy-font-size, 1em));font-style:var(--wy-headings-font-style, unset);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.5));margin-block:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-meta]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-meta-sm]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))}[part~=wy-quote]{color:var(--wy-outline, var(--wy-outline-light, #72777f))}[part~=wy-quote]:before,[part~=wy-quote]:after{content:'\"'}`;
var z5 = Object.defineProperty, I5 = Object.getOwnPropertyDescriptor, te = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? I5(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && z5(t, e, r), r;
}, "__decorateClass$15"), Ks;
let de = (Ks = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.size = "auto", this.align = "middle", this.actionsPosition = "end", this.rounded = !1, this.noPadding = !1, this.outer = !1, this.interactive = !1, this.selected = !1, this.disabled = !1, this.url = void 0, this.trashed = !1;
  }
  /**
   * If it has an url; handles ctrl click event for the item.
   * @param event MouseEvent
   */
  handleLinkClick(t) {
    if (this.disabled) {
      t.preventDefault(), t.stopPropagation();
      return;
    }
    vh(t) && t.stopPropagation();
  }
  render() {
    const t = !!this._slotActions.length, e = !!this._slotMeta.length, r = !!this._slotText.length || this.actionsPosition === "bottom" && t;
    return h`
      <div
        part=${J({
      "wy-item-rounded": this.rounded,
      "wy-item-rounded-outer": this.outer,
      "wy-item-inner": !0,
      "wy-item-inner-no-padding": this.noPadding,
      "wy-item-interactive": this.interactive,
      "wy-item-sm": this.size === "sm",
      "wy-item-md": this.size === "md",
      "wy-item-lg": this.size === "lg",
      "wy-item-top": this.align === "top",
      "wy-item-middle": this.align === "middle",
      "wy-item-bottom": this.align === "bottom",
      "wy-read": this.status === "read",
      "wy-unread": this.status === "unread",
      "wy-selected": this.selected,
      "wy-disabled": this.disabled
    })}
      >
        <div part="wy-item-image"><slot name="image"></slot></div>
        <div part="wy-item-body">
          <slot name="content">
            <div part="wy-item-rows">
              <div part="wy-item-row wy-item-row-first">
                <div part="wy-item-title wy-item-left">
                  ${this.url ? h`<a href=${this.url} @click=${(s) => this.handleLinkClick(s)}><slot name="title"></slot></a>` : h`<slot name="title"></slot>`}
                </div>
                <div part="wy-item-meta wy-meta wy-meta-sm" ?hidden=${!e}
                  ><slot name="meta" @slotchange=${() => this.requestUpdate()}></slot
                ></div>
              </div>
              <div part="wy-item-row wy-item-row-second" ?hidden=${!r}>
                <div part="wy-item-text wy-item-left ${J({ "wy-item-text-sm": this.size === "auto" })}"
                  ><slot name="text" @slotchange=${() => this.requestUpdate()}></slot
                ></div>
                ${this.actionsPosition === "bottom" ? h`
                      <div part="wy-item-actions wy-item-actions-bottom"
                        ><slot name="actions" @slotchange=${() => this.requestUpdate()}></slot
                      ></div>
                    ` : b}
              </div>
            </div>
          </slot>
        </div>
        ${this.actionsPosition !== "bottom" ? h`
              <div
                part="wy-item-actions ${J({
      "wy-item-actions-top": this.align === "top" || this.actionsPosition === "top"
    })}"
                ?hidden=${!t}
                ><slot name="actions" @slotchange=${() => this.requestUpdate()}></slot
              ></div>
            ` : b}
      </div>
    `;
  }
}, a(Ks, "WyItem"), Ks);
de.styles = [Ht, Sh, Gc];
te([
  u()
], de.prototype, "size", 2);
te([
  u()
], de.prototype, "align", 2);
te([
  u()
], de.prototype, "actionsPosition", 2);
te([
  u({ type: Boolean, reflect: !0 })
], de.prototype, "rounded", 2);
te([
  u({ type: Boolean, reflect: !0 })
], de.prototype, "noPadding", 2);
te([
  u({ type: Boolean, reflect: !0 })
], de.prototype, "outer", 2);
te([
  u({ type: Boolean, reflect: !0 })
], de.prototype, "interactive", 2);
te([
  u({ type: Boolean, reflect: !0 })
], de.prototype, "selected", 2);
te([
  u({ type: Boolean, reflect: !0 })
], de.prototype, "disabled", 2);
te([
  u({ reflect: !0 })
], de.prototype, "url", 2);
te([
  u({ type: Boolean, reflect: !0 })
], de.prototype, "trashed", 2);
te([
  u()
], de.prototype, "status", 2);
te([
  Kc({ slot: "actions" })
], de.prototype, "_slotActions", 2);
te([
  Kc({ slot: "meta" })
], de.prototype, "_slotMeta", 2);
te([
  Kc({ slot: "text" })
], de.prototype, "_slotText", 2);
de = te([
  B("wy-item")
], de);
var Qs;
let Nr = (Qs = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.outer = !1, this.bordered = !1, this.rounded = !1, this.filled = !1;
  }
  render() {
    const t = {
      "wy-item-list": !0,
      "wy-item-list-bordered": this.bordered,
      "wy-item-list-rounded": this.rounded,
      "wy-item-list-outer": this.outer,
      "wy-item-list-filled": this.filled
    };
    return h`<div part=${J(t)}><slot></slot></div>`;
  }
}, a(Qs, "WyItemList"), Qs);
Nr.styles = [Sh, X];
te([
  u({ type: Boolean })
], Nr.prototype, "outer", 2);
te([
  u({ type: Boolean })
], Nr.prototype, "bordered", 2);
te([
  u({ type: Boolean })
], Nr.prototype, "rounded", 2);
te([
  u({ type: Boolean })
], Nr.prototype, "filled", 2);
Nr = te([
  B("wy-item-list")
], Nr);
const cv = j`[part~=wy-button]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c));color:var(--wy-component-color);background:var(--wy-component-background-color, transparent);height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;font-size:var(--wy-button-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-button-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));text-align:center;text-decoration:none;vertical-align:middle;cursor:pointer;-webkit-user-select:none;user-select:none;border:var(--wy-button-border-width, var(--wy-border-outline, 0)) solid var(--wy-outline, var(--wy-outline-light, #72777f));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem))));display:inline-flex;align-items:center;justify-content:center;gap:var(--wy-button-gap, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));position:relative}[part~=wy-button][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.8);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.5)}[part~=wy-button][part~=wy-disabled],[part~=wy-button]:disabled{opacity:var(--wy-opacity-disabled, 38%);cursor:unset;pointer-events:none}[part~=wy-button-state-layer]>*{z-index:3}[part~=wy-button-state-layer]:before{content:\"\";z-index:2;position:absolute;inset:0;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-button-state-layer]:hover:before{opacity:8%}[part~=wy-button-state-layer]:focus:before,[part~=wy-button-state-layer]:active:before,[part~=wy-button-state-layer][part~=wy-active]:before{opacity:12%}[part~=wy-button-icon]{--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));line-height:1;align-items:center;justify-content:center}[part~=wy-button-icon][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);padding:0;margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.5)}[part~=wy-button-icon][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*-.1)}[part~=wy-button-icon][part~=wy-active]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-button-icon-inline]{height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));width:auto;min-width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));background:var(--wy-component-background-color);color:currentColor;display:flex;padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-button-icon-inline][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);min-width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.25);margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.5)}[part~=wy-button-icon-inline][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*-.1)}[part~=wy-button-inline]{border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-button-inline][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.8);min-width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.8);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.75);margin-inline:calc(-.75*var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-button-primary]{--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73))}[part~=wy-button-variant]{--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}[part~=wy-button-primary-text]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-button-inherit-color]{--wy-component-color: currentColor}[part~=wy-button-no-color]{--wy-component-background-color: transparent;--wy-component-color: unset}[part~=wy-button-link]{padding:0;color:var(--wy-link-color, var(--wy-primary, var(--wy-primary-light, #2f628c)));text-decoration:var(--wy-link-decoration, none)}[part~=wy-button-link]:hover,[part~=wy-button-link]:focus{text-decoration:var(--wy-link-hover-decoration, var(--wy-link-decoration, none))}[part~=wy-buttons]{display:flex;align-items:center;flex-wrap:wrap;gap:calc(.5*var(--wy-size, 1rem))}[part~=wy-buttons-reverse]{flex-direction:row-reverse}[part~=wy-buttons-floating]{position:sticky;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) 0;top:0;height:0;margin-bottom:calc(-1*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));z-index:1030;--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}[part~=wy-buttons-sticky]{position:sticky;padding:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));top:var(--wy-component-offset-top, 0px);z-index:1021;--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}`, lv = j`[part~=wy-tabs]{display:flex;overflow-y:hidden;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));flex:1 1 auto}[part~=wy-tabs]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-tabs]{scrollbar-width:thin;scrollbar-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf)) rgba(0,0,0,0)}[part~=wy-tabs]::-webkit-scrollbar{height:.375rem;width:.375rem;background:#0000;z-index:999}[part~=wy-tabs]::-webkit-scrollbar-track{background:#0000}[part~=wy-tabs]::-webkit-scrollbar-thumb{background-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));opacity:75%;border:0 solid rgba(0,0,0,0);border-radius:0;background-clip:padding-box}[part~=wy-tabs]::-webkit-scrollbar-thumb:hover{background-color:var(--wy-outline, var(--wy-outline-light, #72777f));opacity:75%}[part~=wy-tabs]::-webkit-scrollbar-thumb:window-inactive{background-color:var(--wy-outline, var(--wy-outline-light, #72777f));opacity:50%}[part~=wy-tab]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c));--wy-component-background-color: transparent;color:var(--wy-component-color);background:var(--wy-component-background-color);border:none;border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));display:inline-flex;flex-direction:column;align-items:center;justify-content:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));position:relative;text-align:center;text-decoration:none;cursor:pointer;-webkit-user-select:none;user-select:none}[part~=wy-tab] .wy-tab-icon{position:relative;padding:calc(.25*var(--wy-size, 1rem)) calc(1*var(--wy-size, 1rem));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem))));display:inline-flex}[part~=wy-tab] .wy-tab-icon:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-tab]:hover .wy-tab-icon:before{opacity:8%}[part~=wy-tab]:focus .wy-tab-icon:before,[part~=wy-tab]:active .wy-tab-icon:before,[part~=wy-tab].wy-active .wy-tab-icon:before{opacity:12%}[part~=wy-tab] .wy-tab-label{font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));font-weight:var(--wy-font-weight, unset)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]{padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.5);margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) auto;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]:before{margin:calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*-.25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*0)}`;
var F5 = Object.defineProperty, D5 = Object.getOwnPropertyDescriptor, Ge = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? D5(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && F5(t, e, r), r;
}, "__decorateClass$14"), Gs;
let ei = (Gs = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this, !1), this.kind = "filled", this.active = !1, this.small = !1, this.disabled = !1;
  }
  render() {
    const t = {
      "wy-button": !0,
      "wy-active": !!this.active,
      "wy-disabled": !!this.disabled,
      "wy-button-inline": this.kind === "inline",
      "wy-button-icon": this.kind === "icon",
      "wy-button-icon-inline": this.kind === "icon-inline",
      "wy-button-link": this.kind === "link",
      "wy-button-primary": this.color === "primary",
      "wy-button-primary-text": this.color === "primary-text",
      "wy-button-inherit-color": this.color === "inherit",
      "wy-button-no-color": this.color === "none",
      "wy-button-variant": this.color === "variant",
      "wy-button-type-submit": this.type === "submit",
      "wy-button-type-reset": this.type === "reset",
      "wy-button-state-layer": this.kind !== "link" && !this.disabled,
      "wy-button-sm": !!this.small,
      "wy-tab": this.kind === "tab",
      "wy-tab-sm": this.kind === "tab" && !!this.small
    };
    return this.href ? h`
      <a href=${this.href} target=${dt(this.target)} download=${dt(this.download)} part=${J(t)} aria-disabled=${this.disabled ? "true" : "false"}>
        <slot></slot>
      </a>
    ` : h`
      <button part=${J(t)} type=${dt(this.type)} ?disabled=${this.disabled} aria-disabled=${this.disabled ? "true" : "false"}>
        <slot></slot>
      </button>
    `;
  }
}, a(Gs, "WyButton"), Gs);
ei.styles = [
  Ht,
  cv,
  lv,
  X,
  j`
      :host {
        position: relative;
      }
    `
];
Ge([
  u()
], ei.prototype, "type", 2);
Ge([
  u()
], ei.prototype, "kind", 2);
Ge([
  u({ type: Boolean })
], ei.prototype, "active", 2);
Ge([
  u()
], ei.prototype, "color", 2);
Ge([
  u({ type: Boolean })
], ei.prototype, "small", 2);
Ge([
  u({ type: Boolean, reflect: !0 })
], ei.prototype, "disabled", 2);
Ge([
  u()
], ei.prototype, "href", 2);
Ge([
  u()
], ei.prototype, "target", 2);
Ge([
  u()
], ei.prototype, "download", 2);
ei = Ge([
  B("wy-button")
], ei);
var Zs;
let Rn = (Zs = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.tabs = !1, this.position = "normal", this.reverse = !1;
  }
  render() {
    const t = {
      "wy-buttons": !this.tabs,
      "wy-buttons-reverse": this.reverse,
      "wy-tabs": this.tabs,
      "wy-buttons-floating": this.position === "floating",
      "wy-buttons-sticky": this.position === "sticky"
    };
    return h`<div part=${J(t)}><slot></slot></div>`;
  }
}, a(Zs, "WyButtons"), Zs);
Rn.styles = [
  Ht,
  cv,
  lv,
  X
];
Ge([
  u({ type: Boolean })
], Rn.prototype, "tabs", 2);
Ge([
  u({ type: String })
], Rn.prototype, "position", 2);
Ge([
  u({ type: Boolean })
], Rn.prototype, "reverse", 2);
Rn = Ge([
  B("wy-buttons")
], Rn);
const dv = "important", V5 = " !" + dv, kl = Yn(class extends Qc {
  constructor(n) {
    if (super(n), n.type !== yd.ATTRIBUTE || n.name !== "style" || n.strings?.length > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(n) {
    return Object.keys(n).reduce(((t, e) => {
      const i = n[e];
      return i == null ? t : t + `${e = e.includes("-") ? e : e.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${i};`;
    }), "");
  }
  update(n, [t]) {
    const { style: e } = n.element;
    if (this.ft === void 0) return this.ft = new Set(Object.keys(t)), this.render(t);
    for (const i of this.ft) t[i] == null && (this.ft.delete(i), i.includes("-") ? e.removeProperty(i) : e[i] = null);
    for (const i in t) {
      const r = t[i];
      if (r != null) {
        this.ft.add(i);
        const s = typeof r == "string" && r.endsWith(V5);
        i.includes("-") || s ? e.setProperty(i, s ? r.slice(0, -11) : r, s ? dv : "") : e[i] = r;
      }
    }
    return gh;
  }
}), ah = Math.min, kn = Math.max, sh = Math.round, Od = Math.floor, Ti = /* @__PURE__ */ a((n) => ({
  x: n,
  y: n
}), "createCoords"), H5 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, B5 = {
  start: "end",
  end: "start"
};
function kf(n, t, e) {
  return kn(n, ah(t, e));
}
a(kf, "clamp");
function Mh(n, t) {
  return typeof n == "function" ? n(t) : n;
}
a(Mh, "evaluate");
function Tn(n) {
  return n.split("-")[0];
}
a(Tn, "getSide");
function Ah(n) {
  return n.split("-")[1];
}
a(Ah, "getAlignment");
function hv(n) {
  return n === "x" ? "y" : "x";
}
a(hv, "getOppositeAxis");
function uv(n) {
  return n === "y" ? "height" : "width";
}
a(uv, "getAxisLength");
const N5 = /* @__PURE__ */ new Set(["top", "bottom"]);
function zr(n) {
  return N5.has(Tn(n)) ? "y" : "x";
}
a(zr, "getSideAxis");
function pv(n) {
  return hv(zr(n));
}
a(pv, "getAlignmentAxis");
function U5(n, t, e) {
  e === void 0 && (e = !1);
  const i = Ah(n), r = pv(n), s = uv(r);
  let o = r === "x" ? i === (e ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return t.reference[s] > t.floating[s] && (o = oh(o)), [o, oh(o)];
}
a(U5, "getAlignmentSides");
function q5(n) {
  const t = oh(n);
  return [Bp(n), t, Bp(t)];
}
a(q5, "getExpandedPlacements");
function Bp(n) {
  return n.replace(/start|end/g, (t) => B5[t]);
}
a(Bp, "getOppositeAlignmentPlacement");
const Pf = ["left", "right"], _f = ["right", "left"], j5 = ["top", "bottom"], W5 = ["bottom", "top"];
function K5(n, t, e) {
  switch (n) {
    case "top":
    case "bottom":
      return e ? t ? _f : Pf : t ? Pf : _f;
    case "left":
    case "right":
      return t ? j5 : W5;
    default:
      return [];
  }
}
a(K5, "getSideList");
function Q5(n, t, e, i) {
  const r = Ah(n);
  let s = K5(Tn(n), e === "start", i);
  return r && (s = s.map((o) => o + "-" + r), t && (s = s.concat(s.map(Bp)))), s;
}
a(Q5, "getOppositeAxisPlacements");
function oh(n) {
  return n.replace(/left|right|bottom|top/g, (t) => H5[t]);
}
a(oh, "getOppositePlacement");
function G5(n) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...n
  };
}
a(G5, "expandPaddingObject");
function Z5(n) {
  return typeof n != "number" ? G5(n) : {
    top: n,
    right: n,
    bottom: n,
    left: n
  };
}
a(Z5, "getPaddingObject");
function ch(n) {
  const {
    x: t,
    y: e,
    width: i,
    height: r
  } = n;
  return {
    width: i,
    height: r,
    top: e,
    left: t,
    right: t + i,
    bottom: e + r,
    x: t,
    y: e
  };
}
a(ch, "rectToClientRect");
function Sf(n, t, e) {
  let {
    reference: i,
    floating: r
  } = n;
  const s = zr(t), o = pv(t), c = uv(o), l = Tn(t), p = s === "y", v = i.x + i.width / 2 - r.width / 2, C = i.y + i.height / 2 - r.height / 2, g = i[c] / 2 - r[c] / 2;
  let m;
  switch (l) {
    case "top":
      m = {
        x: v,
        y: i.y - r.height
      };
      break;
    case "bottom":
      m = {
        x: v,
        y: i.y + i.height
      };
      break;
    case "right":
      m = {
        x: i.x + i.width,
        y: C
      };
      break;
    case "left":
      m = {
        x: i.x - r.width,
        y: C
      };
      break;
    default:
      m = {
        x: i.x,
        y: i.y
      };
  }
  switch (Ah(t)) {
    case "start":
      m[o] -= g * (e && p ? -1 : 1);
      break;
    case "end":
      m[o] += g * (e && p ? -1 : 1);
      break;
  }
  return m;
}
a(Sf, "computeCoordsFromPlacement");
const Y5 = /* @__PURE__ */ a(async (n, t, e) => {
  const {
    placement: i = "bottom",
    strategy: r = "absolute",
    middleware: s = [],
    platform: o
  } = e, c = s.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let p = await o.getElementRects({
    reference: n,
    floating: t,
    strategy: r
  }), {
    x: v,
    y: C
  } = Sf(p, i, l), g = i, m = {}, f = 0;
  for (let $ = 0; $ < c.length; $++) {
    const {
      name: A,
      fn: M
    } = c[$], {
      x: R,
      y: V,
      data: W,
      reset: I
    } = await M({
      x: v,
      y: C,
      initialPlacement: i,
      placement: g,
      strategy: r,
      middlewareData: m,
      rects: p,
      platform: o,
      elements: {
        reference: n,
        floating: t
      }
    });
    v = R ?? v, C = V ?? C, m = {
      ...m,
      [A]: {
        ...m[A],
        ...W
      }
    }, I && f <= 50 && (f++, typeof I == "object" && (I.placement && (g = I.placement), I.rects && (p = I.rects === !0 ? await o.getElementRects({
      reference: n,
      floating: t,
      strategy: r
    }) : I.rects), {
      x: v,
      y: C
    } = Sf(p, g, l)), $ = -1);
  }
  return {
    x: v,
    y: C,
    placement: g,
    strategy: r,
    middlewareData: m
  };
}, "computePosition$1");
async function yv(n, t) {
  var e;
  t === void 0 && (t = {});
  const {
    x: i,
    y: r,
    platform: s,
    rects: o,
    elements: c,
    strategy: l
  } = n, {
    boundary: p = "clippingAncestors",
    rootBoundary: v = "viewport",
    elementContext: C = "floating",
    altBoundary: g = !1,
    padding: m = 0
  } = Mh(t, n), f = Z5(m), A = c[g ? C === "floating" ? "reference" : "floating" : C], M = ch(await s.getClippingRect({
    element: (e = await (s.isElement == null ? void 0 : s.isElement(A))) == null || e ? A : A.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(c.floating)),
    boundary: p,
    rootBoundary: v,
    strategy: l
  })), R = C === "floating" ? {
    x: i,
    y: r,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, V = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(c.floating)), W = await (s.isElement == null ? void 0 : s.isElement(V)) ? await (s.getScale == null ? void 0 : s.getScale(V)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, I = ch(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: c,
    rect: R,
    offsetParent: V,
    strategy: l
  }) : R);
  return {
    top: (M.top - I.top + f.top) / W.y,
    bottom: (I.bottom - M.bottom + f.bottom) / W.y,
    left: (M.left - I.left + f.left) / W.x,
    right: (I.right - M.right + f.right) / W.x
  };
}
a(yv, "detectOverflow");
const X5 = /* @__PURE__ */ a(function(n) {
  return n === void 0 && (n = {}), {
    name: "flip",
    options: n,
    async fn(t) {
      var e, i;
      const {
        placement: r,
        middlewareData: s,
        rects: o,
        initialPlacement: c,
        platform: l,
        elements: p
      } = t, {
        mainAxis: v = !0,
        crossAxis: C = !0,
        fallbackPlacements: g,
        fallbackStrategy: m = "bestFit",
        fallbackAxisSideDirection: f = "none",
        flipAlignment: $ = !0,
        ...A
      } = Mh(n, t);
      if ((e = s.arrow) != null && e.alignmentOffset)
        return {};
      const M = Tn(r), R = zr(c), V = Tn(c) === c, W = await (l.isRTL == null ? void 0 : l.isRTL(p.floating)), I = g || (V || !$ ? [oh(c)] : q5(c)), U = f !== "none";
      !g && U && I.push(...Q5(c, $, f, W));
      const K = [c, ...I], tt = await yv(t, A), ot = [];
      let rt = ((i = s.flip) == null ? void 0 : i.overflows) || [];
      if (v && ot.push(tt[M]), C) {
        const vt = U5(r, o, W);
        ot.push(tt[vt[0]], tt[vt[1]]);
      }
      if (rt = [...rt, {
        placement: r,
        overflows: ot
      }], !ot.every((vt) => vt <= 0)) {
        var Lt, Ot;
        const vt = (((Lt = s.flip) == null ? void 0 : Lt.index) || 0) + 1, Bt = K[vt];
        if (Bt && (!(C === "alignment" ? R !== zr(Bt) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        rt.every((xt) => zr(xt.placement) === R ? xt.overflows[0] > 0 : !0)))
          return {
            data: {
              index: vt,
              overflows: rt
            },
            reset: {
              placement: Bt
            }
          };
        let xe = (Ot = rt.filter((Rt) => Rt.overflows[0] <= 0).sort((Rt, xt) => Rt.overflows[1] - xt.overflows[1])[0]) == null ? void 0 : Ot.placement;
        if (!xe)
          switch (m) {
            case "bestFit": {
              var At;
              const Rt = (At = rt.filter((xt) => {
                if (U) {
                  const ie = zr(xt.placement);
                  return ie === R || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  ie === "y";
                }
                return !0;
              }).map((xt) => [xt.placement, xt.overflows.filter((ie) => ie > 0).reduce((ie, ct) => ie + ct, 0)]).sort((xt, ie) => xt[1] - ie[1])[0]) == null ? void 0 : At[0];
              Rt && (xe = Rt);
              break;
            }
            case "initialPlacement":
              xe = c;
              break;
          }
        if (r !== xe)
          return {
            reset: {
              placement: xe
            }
          };
      }
      return {};
    }
  };
}, "flip$1"), J5 = /* @__PURE__ */ new Set(["left", "top"]);
async function tx(n, t) {
  const {
    placement: e,
    platform: i,
    elements: r
  } = n, s = await (i.isRTL == null ? void 0 : i.isRTL(r.floating)), o = Tn(e), c = Ah(e), l = zr(e) === "y", p = J5.has(o) ? -1 : 1, v = s && l ? -1 : 1, C = Mh(t, n);
  let {
    mainAxis: g,
    crossAxis: m,
    alignmentAxis: f
  } = typeof C == "number" ? {
    mainAxis: C,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: C.mainAxis || 0,
    crossAxis: C.crossAxis || 0,
    alignmentAxis: C.alignmentAxis
  };
  return c && typeof f == "number" && (m = c === "end" ? f * -1 : f), l ? {
    x: m * v,
    y: g * p
  } : {
    x: g * p,
    y: m * v
  };
}
a(tx, "convertValueToCoords");
const ex = /* @__PURE__ */ a(function(n) {
  return n === void 0 && (n = 0), {
    name: "offset",
    options: n,
    async fn(t) {
      var e, i;
      const {
        x: r,
        y: s,
        placement: o,
        middlewareData: c
      } = t, l = await tx(t, n);
      return o === ((e = c.offset) == null ? void 0 : e.placement) && (i = c.arrow) != null && i.alignmentOffset ? {} : {
        x: r + l.x,
        y: s + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
}, "offset$1"), ix = /* @__PURE__ */ a(function(n) {
  return n === void 0 && (n = {}), {
    name: "shift",
    options: n,
    async fn(t) {
      const {
        x: e,
        y: i,
        placement: r
      } = t, {
        mainAxis: s = !0,
        crossAxis: o = !1,
        limiter: c = {
          fn: /* @__PURE__ */ a((A) => {
            let {
              x: M,
              y: R
            } = A;
            return {
              x: M,
              y: R
            };
          }, "fn")
        },
        ...l
      } = Mh(n, t), p = {
        x: e,
        y: i
      }, v = await yv(t, l), C = zr(Tn(r)), g = hv(C);
      let m = p[g], f = p[C];
      if (s) {
        const A = g === "y" ? "top" : "left", M = g === "y" ? "bottom" : "right", R = m + v[A], V = m - v[M];
        m = kf(R, m, V);
      }
      if (o) {
        const A = C === "y" ? "top" : "left", M = C === "y" ? "bottom" : "right", R = f + v[A], V = f - v[M];
        f = kf(R, f, V);
      }
      const $ = c.fn({
        ...t,
        [g]: m,
        [C]: f
      });
      return {
        ...$,
        data: {
          x: $.x - e,
          y: $.y - i,
          enabled: {
            [g]: s,
            [C]: o
          }
        }
      };
    }
  };
}, "shift$1");
function Eh() {
  return typeof window < "u";
}
a(Eh, "hasWindow");
function Zc(n) {
  return wv(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
a(Zc, "getNodeName");
function Je(n) {
  var t;
  return (n == null || (t = n.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
a(Je, "getWindow");
function Vi(n) {
  var t;
  return (t = (wv(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : t.documentElement;
}
a(Vi, "getDocumentElement");
function wv(n) {
  return Eh() ? n instanceof Node || n instanceof Je(n).Node : !1;
}
a(wv, "isNode");
function fi(n) {
  return Eh() ? n instanceof Element || n instanceof Je(n).Element : !1;
}
a(fi, "isElement");
function Oi(n) {
  return Eh() ? n instanceof HTMLElement || n instanceof Je(n).HTMLElement : !1;
}
a(Oi, "isHTMLElement");
function Mf(n) {
  return !Eh() || typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof Je(n).ShadowRoot;
}
a(Mf, "isShadowRoot");
const rx = /* @__PURE__ */ new Set(["inline", "contents"]);
function wd(n) {
  const {
    overflow: t,
    overflowX: e,
    overflowY: i,
    display: r
  } = mi(n);
  return /auto|scroll|overlay|hidden|clip/.test(t + i + e) && !rx.has(r);
}
a(wd, "isOverflowElement");
const nx = /* @__PURE__ */ new Set(["table", "td", "th"]);
function ax(n) {
  return nx.has(Zc(n));
}
a(ax, "isTableElement");
const sx = [":popover-open", ":modal"];
function Rh(n) {
  return sx.some((t) => {
    try {
      return n.matches(t);
    } catch {
      return !1;
    }
  });
}
a(Rh, "isTopLayer");
const ox = ["transform", "translate", "scale", "rotate", "perspective"], cx = ["transform", "translate", "scale", "rotate", "perspective", "filter"], lx = ["paint", "layout", "strict", "content"];
function Sy(n) {
  const t = My(), e = fi(n) ? mi(n) : n;
  return ox.some((i) => e[i] ? e[i] !== "none" : !1) || (e.containerType ? e.containerType !== "normal" : !1) || !t && (e.backdropFilter ? e.backdropFilter !== "none" : !1) || !t && (e.filter ? e.filter !== "none" : !1) || cx.some((i) => (e.willChange || "").includes(i)) || lx.some((i) => (e.contain || "").includes(i));
}
a(Sy, "isContainingBlock");
function dx(n) {
  let t = Ur(n);
  for (; Oi(t) && !Lc(t); ) {
    if (Sy(t))
      return t;
    if (Rh(t))
      return null;
    t = Ur(t);
  }
  return null;
}
a(dx, "getContainingBlock");
function My() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
a(My, "isWebKit");
const hx = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Lc(n) {
  return hx.has(Zc(n));
}
a(Lc, "isLastTraversableNode");
function mi(n) {
  return Je(n).getComputedStyle(n);
}
a(mi, "getComputedStyle$1");
function Th(n) {
  return fi(n) ? {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  } : {
    scrollLeft: n.scrollX,
    scrollTop: n.scrollY
  };
}
a(Th, "getNodeScroll");
function Ur(n) {
  if (Zc(n) === "html")
    return n;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    n.assignedSlot || // DOM Element detected.
    n.parentNode || // ShadowRoot detected.
    Mf(n) && n.host || // Fallback.
    Vi(n)
  );
  return Mf(t) ? t.host : t;
}
a(Ur, "getParentNode");
function fv(n) {
  const t = Ur(n);
  return Lc(t) ? n.ownerDocument ? n.ownerDocument.body : n.body : Oi(t) && wd(t) ? t : fv(t);
}
a(fv, "getNearestOverflowAncestor");
function Pl(n, t, e) {
  var i;
  t === void 0 && (t = []), e === void 0 && (e = !0);
  const r = fv(n), s = r === ((i = n.ownerDocument) == null ? void 0 : i.body), o = Je(r);
  if (s) {
    const c = Np(o);
    return t.concat(o, o.visualViewport || [], wd(r) ? r : [], c && e ? Pl(c) : []);
  }
  return t.concat(r, Pl(r, [], e));
}
a(Pl, "getOverflowAncestors");
function Np(n) {
  return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null;
}
a(Np, "getFrameElement");
function mv(n) {
  const t = mi(n);
  let e = parseFloat(t.width) || 0, i = parseFloat(t.height) || 0;
  const r = Oi(n), s = r ? n.offsetWidth : e, o = r ? n.offsetHeight : i, c = sh(e) !== s || sh(i) !== o;
  return c && (e = s, i = o), {
    width: e,
    height: i,
    $: c
  };
}
a(mv, "getCssDimensions");
function Ay(n) {
  return fi(n) ? n : n.contextElement;
}
a(Ay, "unwrapElement");
function Sa(n) {
  const t = Ay(n);
  if (!Oi(t))
    return Ti(1);
  const e = t.getBoundingClientRect(), {
    width: i,
    height: r,
    $: s
  } = mv(t);
  let o = (s ? sh(e.width) : e.width) / i, c = (s ? sh(e.height) : e.height) / r;
  return (!o || !Number.isFinite(o)) && (o = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: o,
    y: c
  };
}
a(Sa, "getScale");
const ux = /* @__PURE__ */ Ti(0);
function vv(n) {
  const t = Je(n);
  return !My() || !t.visualViewport ? ux : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
a(vv, "getVisualOffsets");
function px(n, t, e) {
  return t === void 0 && (t = !1), !e || t && e !== Je(n) ? !1 : t;
}
a(px, "shouldAddVisualOffsets");
function Ln(n, t, e, i) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  const r = n.getBoundingClientRect(), s = Ay(n);
  let o = Ti(1);
  t && (i ? fi(i) && (o = Sa(i)) : o = Sa(n));
  const c = px(s, e, i) ? vv(s) : Ti(0);
  let l = (r.left + c.x) / o.x, p = (r.top + c.y) / o.y, v = r.width / o.x, C = r.height / o.y;
  if (s) {
    const g = Je(s), m = i && fi(i) ? Je(i) : i;
    let f = g, $ = Np(f);
    for (; $ && i && m !== f; ) {
      const A = Sa($), M = $.getBoundingClientRect(), R = mi($), V = M.left + ($.clientLeft + parseFloat(R.paddingLeft)) * A.x, W = M.top + ($.clientTop + parseFloat(R.paddingTop)) * A.y;
      l *= A.x, p *= A.y, v *= A.x, C *= A.y, l += V, p += W, f = Je($), $ = Np(f);
    }
  }
  return ch({
    width: v,
    height: C,
    x: l,
    y: p
  });
}
a(Ln, "getBoundingClientRect");
function Lh(n, t) {
  const e = Th(n).scrollLeft;
  return t ? t.left + e : Ln(Vi(n)).left + e;
}
a(Lh, "getWindowScrollBarX");
function gv(n, t) {
  const e = n.getBoundingClientRect(), i = e.left + t.scrollLeft - Lh(n, e), r = e.top + t.scrollTop;
  return {
    x: i,
    y: r
  };
}
a(gv, "getHTMLOffset");
function yx(n) {
  let {
    elements: t,
    rect: e,
    offsetParent: i,
    strategy: r
  } = n;
  const s = r === "fixed", o = Vi(i), c = t ? Rh(t.floating) : !1;
  if (i === o || c && s)
    return e;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, p = Ti(1);
  const v = Ti(0), C = Oi(i);
  if ((C || !C && !s) && ((Zc(i) !== "body" || wd(o)) && (l = Th(i)), Oi(i))) {
    const m = Ln(i);
    p = Sa(i), v.x = m.x + i.clientLeft, v.y = m.y + i.clientTop;
  }
  const g = o && !C && !s ? gv(o, l) : Ti(0);
  return {
    width: e.width * p.x,
    height: e.height * p.y,
    x: e.x * p.x - l.scrollLeft * p.x + v.x + g.x,
    y: e.y * p.y - l.scrollTop * p.y + v.y + g.y
  };
}
a(yx, "convertOffsetParentRelativeRectToViewportRelativeRect");
function wx(n) {
  return Array.from(n.getClientRects());
}
a(wx, "getClientRects");
function fx(n) {
  const t = Vi(n), e = Th(n), i = n.ownerDocument.body, r = kn(t.scrollWidth, t.clientWidth, i.scrollWidth, i.clientWidth), s = kn(t.scrollHeight, t.clientHeight, i.scrollHeight, i.clientHeight);
  let o = -e.scrollLeft + Lh(n);
  const c = -e.scrollTop;
  return mi(i).direction === "rtl" && (o += kn(t.clientWidth, i.clientWidth) - r), {
    width: r,
    height: s,
    x: o,
    y: c
  };
}
a(fx, "getDocumentRect");
const Af = 25;
function mx(n, t) {
  const e = Je(n), i = Vi(n), r = e.visualViewport;
  let s = i.clientWidth, o = i.clientHeight, c = 0, l = 0;
  if (r) {
    s = r.width, o = r.height;
    const v = My();
    (!v || v && t === "fixed") && (c = r.offsetLeft, l = r.offsetTop);
  }
  const p = Lh(i);
  if (p <= 0) {
    const v = i.ownerDocument, C = v.body, g = getComputedStyle(C), m = v.compatMode === "CSS1Compat" && parseFloat(g.marginLeft) + parseFloat(g.marginRight) || 0, f = Math.abs(i.clientWidth - C.clientWidth - m);
    f <= Af && (s -= f);
  } else p <= Af && (s += p);
  return {
    width: s,
    height: o,
    x: c,
    y: l
  };
}
a(mx, "getViewportRect");
const vx = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function gx(n, t) {
  const e = Ln(n, !0, t === "fixed"), i = e.top + n.clientTop, r = e.left + n.clientLeft, s = Oi(n) ? Sa(n) : Ti(1), o = n.clientWidth * s.x, c = n.clientHeight * s.y, l = r * s.x, p = i * s.y;
  return {
    width: o,
    height: c,
    x: l,
    y: p
  };
}
a(gx, "getInnerBoundingClientRect");
function Ef(n, t, e) {
  let i;
  if (t === "viewport")
    i = mx(n, e);
  else if (t === "document")
    i = fx(Vi(n));
  else if (fi(t))
    i = gx(t, e);
  else {
    const r = vv(n);
    i = {
      x: t.x - r.x,
      y: t.y - r.y,
      width: t.width,
      height: t.height
    };
  }
  return ch(i);
}
a(Ef, "getClientRectFromClippingAncestor");
function bv(n, t) {
  const e = Ur(n);
  return e === t || !fi(e) || Lc(e) ? !1 : mi(e).position === "fixed" || bv(e, t);
}
a(bv, "hasFixedPositionAncestor");
function bx(n, t) {
  const e = t.get(n);
  if (e)
    return e;
  let i = Pl(n, [], !1).filter((c) => fi(c) && Zc(c) !== "body"), r = null;
  const s = mi(n).position === "fixed";
  let o = s ? Ur(n) : n;
  for (; fi(o) && !Lc(o); ) {
    const c = mi(o), l = Sy(o);
    !l && c.position === "fixed" && (r = null), (s ? !l && !r : !l && c.position === "static" && !!r && vx.has(r.position) || wd(o) && !l && bv(n, o)) ? i = i.filter((v) => v !== o) : r = c, o = Ur(o);
  }
  return t.set(n, i), i;
}
a(bx, "getClippingElementAncestors");
function xx(n) {
  let {
    element: t,
    boundary: e,
    rootBoundary: i,
    strategy: r
  } = n;
  const o = [...e === "clippingAncestors" ? Rh(t) ? [] : bx(t, this._c) : [].concat(e), i], c = o[0], l = o.reduce((p, v) => {
    const C = Ef(t, v, r);
    return p.top = kn(C.top, p.top), p.right = ah(C.right, p.right), p.bottom = ah(C.bottom, p.bottom), p.left = kn(C.left, p.left), p;
  }, Ef(t, c, r));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
a(xx, "getClippingRect");
function Cx(n) {
  const {
    width: t,
    height: e
  } = mv(n);
  return {
    width: t,
    height: e
  };
}
a(Cx, "getDimensions");
function $x(n, t, e) {
  const i = Oi(t), r = Vi(t), s = e === "fixed", o = Ln(n, !0, s, t);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = Ti(0);
  function p() {
    l.x = Lh(r);
  }
  if (a(p, "setLeftRTLScrollbarOffset"), i || !i && !s)
    if ((Zc(t) !== "body" || wd(r)) && (c = Th(t)), i) {
      const m = Ln(t, !0, s, t);
      l.x = m.x + t.clientLeft, l.y = m.y + t.clientTop;
    } else r && p();
  s && !i && r && p();
  const v = r && !i && !s ? gv(r, c) : Ti(0), C = o.left + c.scrollLeft - l.x - v.x, g = o.top + c.scrollTop - l.y - v.y;
  return {
    x: C,
    y: g,
    width: o.width,
    height: o.height
  };
}
a($x, "getRectRelativeToOffsetParent");
function qu(n) {
  return mi(n).position === "static";
}
a(qu, "isStaticPositioned");
function Rf(n, t) {
  if (!Oi(n) || mi(n).position === "fixed")
    return null;
  if (t)
    return t(n);
  let e = n.offsetParent;
  return Vi(n) === e && (e = e.ownerDocument.body), e;
}
a(Rf, "getTrueOffsetParent");
function xv(n, t) {
  const e = Je(n);
  if (Rh(n))
    return e;
  if (!Oi(n)) {
    let r = Ur(n);
    for (; r && !Lc(r); ) {
      if (fi(r) && !qu(r))
        return r;
      r = Ur(r);
    }
    return e;
  }
  let i = Rf(n, t);
  for (; i && ax(i) && qu(i); )
    i = Rf(i, t);
  return i && Lc(i) && qu(i) && !Sy(i) ? e : i || dx(n) || e;
}
a(xv, "getOffsetParent");
const kx = /* @__PURE__ */ a(async function(n) {
  const t = this.getOffsetParent || xv, e = this.getDimensions, i = await e(n.floating);
  return {
    reference: $x(n.reference, await t(n.floating), n.strategy),
    floating: {
      x: 0,
      y: 0,
      width: i.width,
      height: i.height
    }
  };
}, "getElementRects");
function Px(n) {
  return mi(n).direction === "rtl";
}
a(Px, "isRTL");
const _x = {
  convertOffsetParentRelativeRectToViewportRelativeRect: yx,
  getDocumentElement: Vi,
  getClippingRect: xx,
  getOffsetParent: xv,
  getElementRects: kx,
  getClientRects: wx,
  getDimensions: Cx,
  getScale: Sa,
  isElement: fi,
  isRTL: Px
};
function Cv(n, t) {
  return n.x === t.x && n.y === t.y && n.width === t.width && n.height === t.height;
}
a(Cv, "rectsAreEqual");
function Sx(n, t) {
  let e = null, i;
  const r = Vi(n);
  function s() {
    var c;
    clearTimeout(i), (c = e) == null || c.disconnect(), e = null;
  }
  a(s, "cleanup");
  function o(c, l) {
    c === void 0 && (c = !1), l === void 0 && (l = 1), s();
    const p = n.getBoundingClientRect(), {
      left: v,
      top: C,
      width: g,
      height: m
    } = p;
    if (c || t(), !g || !m)
      return;
    const f = Od(C), $ = Od(r.clientWidth - (v + g)), A = Od(r.clientHeight - (C + m)), M = Od(v), V = {
      rootMargin: -f + "px " + -$ + "px " + -A + "px " + -M + "px",
      threshold: kn(0, ah(1, l)) || 1
    };
    let W = !0;
    function I(U) {
      const K = U[0].intersectionRatio;
      if (K !== l) {
        if (!W)
          return o();
        K ? o(!1, K) : i = setTimeout(() => {
          o(!1, 1e-7);
        }, 1e3);
      }
      K === 1 && !Cv(p, n.getBoundingClientRect()) && o(), W = !1;
    }
    a(I, "handleObserve");
    try {
      e = new IntersectionObserver(I, {
        ...V,
        // Handle <iframe>s
        root: r.ownerDocument
      });
    } catch {
      e = new IntersectionObserver(I, V);
    }
    e.observe(n);
  }
  return a(o, "refresh"), o(!0), s;
}
a(Sx, "observeMove");
function $v(n, t, e, i) {
  i === void 0 && (i = {});
  const {
    ancestorScroll: r = !0,
    ancestorResize: s = !0,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = i, p = Ay(n), v = r || s ? [...p ? Pl(p) : [], ...Pl(t)] : [];
  v.forEach((M) => {
    r && M.addEventListener("scroll", e, {
      passive: !0
    }), s && M.addEventListener("resize", e);
  });
  const C = p && c ? Sx(p, e) : null;
  let g = -1, m = null;
  o && (m = new ResizeObserver((M) => {
    let [R] = M;
    R && R.target === p && m && (m.unobserve(t), cancelAnimationFrame(g), g = requestAnimationFrame(() => {
      var V;
      (V = m) == null || V.observe(t);
    })), e();
  }), p && !l && m.observe(p), m.observe(t));
  let f, $ = l ? Ln(n) : null;
  l && A();
  function A() {
    const M = Ln(n);
    $ && !Cv($, M) && e(), $ = M, f = requestAnimationFrame(A);
  }
  return a(A, "frameLoop"), e(), () => {
    var M;
    v.forEach((R) => {
      r && R.removeEventListener("scroll", e), s && R.removeEventListener("resize", e);
    }), C?.(), (M = m) == null || M.disconnect(), m = null, l && cancelAnimationFrame(f);
  };
}
a($v, "autoUpdate");
const kv = ex, Pv = ix, _v = X5, Sv = /* @__PURE__ */ a((n, t, e) => {
  const i = /* @__PURE__ */ new Map(), r = {
    platform: _x,
    ...e
  }, s = {
    ...r.platform,
    _c: i
  };
  return Y5(n, t, {
    ...r,
    platform: s
  });
}, "computePosition"), Oh = j`[part~=wy-dropdown-menu]{width:max-content;position:absolute;z-index:1000;min-width:calc(10*var(--wy-size, 1rem));border:none;padding:0;--wy-component-background-color: var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);font-size:var(--wy-font-size, var(--wy-size, 1em));text-align:left;background-clip:padding-box;border-radius:var(--wy-dropdown-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));box-shadow:var(--wy-dropdown-shadow, var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12)));overflow:hidden}[part~=wy-dropdown-menu]:not([popover]){display:block}[part~=wy-dropdown-item]{background-color:#0000;color:var(--wy-component-color, var(--wy-on-surface, var(--wy-on-surface-light, #181c20)));width:100%;min-height:calc(2.5*var(--wy-size, 1rem));padding:var(--wy-dropdown-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-dropdown-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));clear:both;font-family:var(--wy-font-family, unset),inherit;font-size:inherit;font-weight:var(--wy-font-weight, unset);line-height:1;text-align:inherit;text-decoration:none;white-space:nowrap;border:0;gap:var(--wy-dropdown-gap, var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));cursor:pointer;display:flex;align-items:center}[part~=wy-dropdown-item]:hover,[part~=wy-dropdown-item]:focus{--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));color:var(--wy-component-color);background-color:var(--wy-component-background-color);text-decoration:none}[part~=wy-dropdown-item][part~=wy-active],[part~=wy-dropdown-item]:active{--wy-component-color: var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73));--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));color:var(--wy-component-color);background-color:var(--wy-component-background-color);text-decoration:none}[part~=wy-dropdown-item][part~=wy-disabled],[part~=wy-dropdown-item]:disabled{color:var(--wy-component-color);background-color:var(--wy-component-background-color);pointer-events:none;opacity:var(--wy-opacity-disabled, 38%)}[part~=wy-dropdown-item]>img,[part~=wy-dropdown-item]>wy-icon{margin-right:calc(.5*var(--wy-size, 1rem));color:inherit}[part~=wy-dropdown-item]:active>wy-icon{color:inherit}[part~=wy-dropdown-item][part~=wy-dropdown-option] wy-icon{visibility:hidden}[part~=wy-dropdown-item][part~=wy-dropdown-option][part~=wy-selected] wy-icon{visibility:visible}[part~=wy-dropdown-divider]{height:0;margin:0;overflow:hidden;border:none;border-top:var(--wy-dropdown-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}`;
var Mx = Object.defineProperty, Ax = Object.getOwnPropertyDescriptor, Le = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? Ax(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && Mx(t, e, r), r;
}, "__decorateClass$13"), Ys;
let ii = (Ys = class extends it {
  constructor() {
    super(), this.exportParts = new q(this), this.directionX = "right", this.directionY = "down", this.icon = "dots-vertical", this.small = !1, this.disabled = !1, this._placement = "bottom-start", this.showMenu = !1, this.buttonRef = nt(), this.menuRef = nt(), this._documentClickHandler = (t) => {
      this.showMenu && (t.preventDefault(), this.menuRef.value?.popover || (this.showMenu = !1));
    }, this.addEventListener("click", (t) => {
      t.preventDefault();
    });
  }
  handleClose(t) {
    (t.type === "toggle" && t.newState === "closed" || t.type === "click") && (this.showMenu = !1, this.dispatchEvent(new CustomEvent("close")));
  }
  handleClickToggle(t) {
    t.stopPropagation(), this.showMenu = this.disabled ? !1 : !this.showMenu;
  }
  willUpdate(t) {
    if (super.willUpdate(t), (t.has("disabled") || t.has("showMenu")) && this.disabled && this.showMenu && (this.showMenu = !1), (t.has("directionX") || t.has("directionY")) && (this._placement = this.directionX === "right" && this.directionY === "down" ? "bottom-start" : this.directionX === "left" && this.directionY === "down" ? "bottom-end" : this.directionX === "right" && this.directionY === "up" ? "top-start" : "top-end"), t.has("showMenu") && (this.showMenu && !this.computePositionCleanup && this.buttonRef.value && this.menuRef.value ? this.computePositionCleanup = $v(this.buttonRef.value, this.menuRef.value, () => {
      if (this.buttonRef.value && this.menuRef.value) {
        const e = !this.menuRef.value.popover, i = e || !x1(this.buttonRef.value);
        Sv(this.buttonRef.value, this.menuRef.value, {
          placement: this._placement,
          strategy: e ? "fixed" : "absolute",
          middleware: [
            _v(),
            kv(({ placement: r }) => r.includes("top") ? 9 : 13),
            Pv({ mainAxis: !0, crossAxis: !0, padding: 4, altBoundary: i })
          ]
        }).then(({ x: r, y: s }) => {
          this.menuRef.value && Object.assign(this.menuRef.value.style, {
            marginLeft: `${r}px`,
            marginTop: `${s}px`,
            top: 0,
            left: 0,
            position: e ? "fixed" : void 0,
            zIndex: e ? 1075 : void 0
          });
        });
      }
    }) : !this.showMenu && this.computePositionCleanup && (this.computePositionCleanup?.(), this.computePositionCleanup = void 0)), this.showMenu) {
      requestAnimationFrame(() => {
        document.addEventListener("click", this._documentClickHandler, { once: !0, capture: !0 });
      });
      try {
        this.menuRef.value?.showPopover();
      } catch {
      }
    } else
      try {
        this.menuRef.value?.hidePopover();
      } catch {
      }
  }
  render() {
    const t = this._slotButton.length === 0 || this._slotButton.length === 1 && this._slotButton[0] instanceof Wt;
    return h`
      <span part="wy-dropdown">
        <span
          ${Q(this.buttonRef)}
          part="wy-dropdown-button-container"
          @click=${(e) => this.handleClickToggle(e)}
          @keydown=${ve}
          @keyup=${Ie}
        >
          <wy-button
            part="wy-dropdown-button"
            .kind=${t ? "icon" : void 0}
            ?small=${this.small}
            title=${this.title}
            ?active=${this.showMenu}
            ?disabled=${this.disabled}
          >
            <slot name="button-content" @slotchange=${() => this.requestUpdate()}>
              <wy-icon part="wy-dropdown-button-icon" name=${this.icon}></wy-icon>
            </slot>
          </wy-button>
        </span>

        <div
          ${Q(this.menuRef)}
          part="wy-dropdown-menu"
          @click=${(e) => this.handleClickToggle(e)}
          @keyup=${by}
          ?hidden=${Gu() && !this.showMenu}
          popover=${dt(Gu() ? void 0 : "auto")}
        >
          <slot></slot>
        </div>
      </span>
    `;
  }
  firstUpdated(t) {
    this.menuRef.value?.addEventListener(
      this.menuRef.value.popover ? "toggle" : "click",
      (e) => this.handleClose(e)
    );
  }
  disconnectedCallback() {
    this.computePositionCleanup?.(), super.disconnectedCallback();
  }
}, a(Ys, "WyDropdown"), Ys);
ii.styles = [Ht, Oh];
Le([
  u()
], ii.prototype, "directionX", 2);
Le([
  u()
], ii.prototype, "directionY", 2);
Le([
  u()
], ii.prototype, "icon", 2);
Le([
  u({ type: Boolean })
], ii.prototype, "small", 2);
Le([
  u({ type: Boolean })
], ii.prototype, "disabled", 2);
Le([
  D()
], ii.prototype, "_placement", 2);
Le([
  D()
], ii.prototype, "showMenu", 2);
Le([
  Kc({ slot: "button-content" })
], ii.prototype, "_slotButton", 2);
Le([
  D()
], ii.prototype, "computePositionCleanup", 2);
ii = Le([
  B("wy-dropdown")
], ii);
var Xs;
let _l = (Xs = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.active = !1;
  }
  render() {
    return h`<div part="wy-dropdown-item ${J({ "wy-active": this.active })}" tabindex="0"><slot></slot></div>`;
  }
}, a(Xs, "WyDropdownItem"), Xs);
_l.styles = [Ht, Oh, X];
Le([
  u({ type: Boolean })
], _l.prototype, "active", 2);
_l = Le([
  B("wy-dropdown-item")
], _l);
var Js;
let Oc = (Js = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.active = !1, this.selected = !1;
  }
  render() {
    const t = {
      visibility: this.selected ? null : "hidden"
    };
    return h`
      <div
        part="wy-dropdown-item wy-dropdown-option ${J({
      "wy-active": this.active,
      "wy-selected": this.selected
    })}"
        tabindex="0"
      >
        <slot name="icon" style=${kl(t)}
          ><wy-icon part="wy-dropdown-option-icon" name="check"></wy-icon
        ></slot>
        <slot></slot>
      </div>
    `;
  }
}, a(Js, "WyDropdownOption"), Js);
Oc.styles = [Ht, Oh, X];
Le([
  u({ type: Boolean })
], Oc.prototype, "active", 2);
Le([
  u({ type: Boolean })
], Oc.prototype, "selected", 2);
Oc = Le([
  B("wy-dropdown-option")
], Oc);
var to;
let lh = (to = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this);
  }
  render() {
    return h`<hr part="wy-dropdown-divider" />`;
  }
}, a(to, "WyDropdownDivider"), to);
lh.styles = [Ht, Oh, X];
lh = Le([
  B("wy-dropdown-divider")
], lh);
const Mv = j`[part~=wy-placeholder]{cursor:wait;color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));background:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));opacity:.5;animation:wy-placeholder-glow 2s ease-in-out infinite;line-height:1.45}@keyframes wy-placeholder-glow{50%{opacity:.2}}`;
var Ex = Object.defineProperty, Rx = Object.getOwnPropertyDescriptor, Av = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? Rx(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && Ex(t, e, r), r;
}, "__decorateClass$12"), eo;
let Sl = (eo = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.text = "";
  }
  render() {
    const t = this.text.trim();
    return h`
      <div part="wy-skeleton">
        ${t.length ? t.split(/(\n+)/).map((e) => {
      const i = e.split(/(\s+)/);
      return h`
                <div part="wy-placeholder-line">
                  ${i.map((r) => h` <span part="wy-placeholder">${r}</span> `)}
                </div>
              `;
    }) : b}
      </div>
    `;
  }
}, a(eo, "WySkeleton"), eo);
Sl.styles = [Mv, X];
Av([
  u()
], Sl.prototype, "text", 2);
Sl = Av([
  B("wy-skeleton")
], Sl);
function Ev(n) {
  const t = [n];
  for (; n && n.parent; )
    n = n.parent, t.push(n);
  return t;
}
a(Ev, "getEntityChain");
function Rv(n, t, e) {
  return n.type === t && (!e || n.id === e.id);
}
a(Rv, "isEntityMatch");
function zh(n, t, e) {
  return Ev(n).some((r) => r && Rv(r, t, e));
}
a(zh, "isEntityChainMatch");
function Tv(n, t, e) {
  return Ev(n).find((r) => r && Rv(r, t, e));
}
a(Tv, "getEntityChainMatch");
function Lv(n, t, e, i) {
  const r = Tv(n, i);
  return r && r.parent ? zh(r.parent, t, e) : !1;
}
a(Lv, "hasEntityChildType");
async function Ov(n, t, e) {
  let i;
  if (t && e?.link?.app?.id) {
    const s = await t.fetch(`/api/apps/${e.link.app.id}`);
    s.ok && (i = (await s.json()).metadata);
  }
  const r = new CustomEvent("wy-link", {
    bubbles: !0,
    composed: !0,
    cancelable: !0,
    detail: {
      link: e.link ? {
        ...e?.link,
        // HACK: pass along the agent uid so uikit can match the correct agent chat     
        agent: e.actor.is_agent && e.link?.app?.type && Jd.has(e.link.app.type) ? e.actor.uid : void 0
      } : void 0,
      metadata: e.metadata,
      app_type: e?.link?.app?.type && L0.get(e.link.app.type) || Fr,
      source_name: i?.source_name,
      source_url: i?.source_url,
      source_data: i?.source_data
    }
  });
  return n.dispatchEvent(r);
}
a(Ov, "dispatchLinkEvent");
function zv(n) {
  const t = n.args;
  switch (n.template) {
    case "**{0}** added *{1}* to **{2}**": {
      const [e, i, r] = t;
      return {
        title: x(gt`${e} added ${i} to ${r}`),
        titleHtml: x(h`<strong>${e}</strong> added <em>${i}</em> to <strong>${r}</strong>`)
      };
    }
    case "**{0}** edited *{1}*": {
      const [e, i] = t;
      return {
        title: x(gt`${e} edited ${i}`),
        titleHtml: x(h`<strong>${e}</strong> edited <em>${i}</em>`)
      };
    }
    case '**{0}** commented on *{1}*: "{2}"': {
      const [e, i, r] = t;
      return {
        title: x(gt`${e} commented on ${i}`),
        titleHtml: x(h`<strong>${e}</strong> commented on <em>${i}</em>`),
        detail: r
      };
    }
    case '**{0}** commented on **{1}**: "{2}"': {
      const [e, i, r] = t;
      return {
        title: x(gt`${e} commented on ${i}`),
        titleHtml: x(h`<strong>${e}</strong> commented on <strong>${i}</strong>`),
        detail: r
      };
    }
    case '**{0}** replied to your post: "{1}"': {
      const [e, i] = t;
      return {
        title: x(gt`${e} replied to your post`),
        titleHtml: x(h`<strong>${e}</strong> replied to your post`),
        detail: i
      };
    }
    case '**{0}** replied to a post: "{1}"': {
      const [e, i] = t;
      return {
        title: x(gt`${e} replied to a post`),
        titleHtml: x(h`<strong>${e}</strong> replied to a post`),
        detail: i
      };
    }
    case '**{0}** mentioned you in a comment: "{1}"': {
      const [e, i] = t;
      return {
        title: x(gt`${e} mentioned you in a comment`),
        titleHtml: x(h`<strong>${e}</strong> mentioned you in a comment`),
        detail: i
      };
    }
    case '**{0}** posted in **{1}**: "{2}"': {
      const [e, i, r] = t;
      return {
        title: x(gt`${e} posted in ${i}`),
        titleHtml: x(h`<strong>${e}</strong> posted in <strong>${i}</strong>`),
        detail: r
      };
    }
    case '**{0}** mentioned you in a post: "{1}"': {
      const [e, i] = t;
      return {
        title: x(gt`${e} mentioned you in a post`),
        titleHtml: x(h`<strong>${e}</strong> mentioned you in a post`),
        detail: i
      };
    }
    case 'New message from **{0}**: "{1}"': {
      const [e, i] = t;
      return {
        title: x(gt`New message from ${e}`),
        titleHtml: x(h`New message from <strong>${e}</strong>`),
        detail: i
      };
    }
    case '**{0}** sent a message in **{1}**: "{2}"': {
      const [e, i, r] = t;
      return {
        title: x(gt`${e} sent a message in ${i}`),
        titleHtml: x(h`<strong>${e}</strong> sent a message in <strong>${i}</strong>`),
        detail: r
      };
    }
    case '**{0}** mentioned you in a message: "{1}"': {
      const [e, i] = t;
      return {
        title: x(gt`${e} mentioned you in a message`),
        titleHtml: x(h`<strong>${e}</strong> mentioned you in a message`),
        detail: i
      };
    }
    case '**{0}** edited a post: "{1}"': {
      const [e, i] = t;
      return {
        title: x(gt`${e} edited a post`),
        titleHtml: x(h`<strong>${e}</strong> edited a post`),
        detail: i
      };
    }
    case "**{0}** liked *{1}*": {
      const [e, i] = t;
      return {
        title: x(gt`${e} liked ${i}`),
        titleHtml: x(h`<strong>${e}</strong> liked <em>${i}</em>`)
      };
    }
    case "**{0}** reacted {2} to *{1}*": {
      const [e, i, r] = t;
      return {
        title: x(gt`${e} reacted ${i} to ${r}`),
        titleHtml: x(h`<strong>${e}</strong> reacted ${i} to <em>${r}</em>`)
      };
    }
    case '**{0}** liked your comment: "{1}"': {
      const [e, i] = t;
      return {
        title: x(gt`${e} liked your comment`),
        titleHtml: x(h`<strong>${e}</strong> liked your comment`),
        detail: i
      };
    }
    case '**{0}** reacted {1} to your comment: "{2}"': {
      const [e, i, r] = t;
      return {
        title: x(gt`${e} reacted ${i} to your comment`),
        titleHtml: x(h`<strong>${e}</strong> reacted ${i} to your comment`),
        detail: r
      };
    }
    case '**{0}** liked your message: "{1}"': {
      const [e, i] = t;
      return {
        title: x(gt`${e} liked your message`),
        titleHtml: x(h`<strong>${e}</strong> liked your message`),
        detail: i
      };
    }
    case '**{0}** reacted {1} to your message: "{2}"': {
      const [e, i, r] = t;
      return {
        title: x(gt`${e} reacted ${i} to your message`),
        titleHtml: x(h`<strong>${e}</strong> reacted ${i} to your message`),
        detail: r
      };
    }
    case '**{0}** liked your post: "{1}"': {
      const [e, i] = t;
      return {
        title: x(gt`${e} liked your post`),
        titleHtml: x(h`<strong>${e}</strong> liked your post`),
        detail: i
      };
    }
    case '**{0}** reacted {1} to your post: "{2}"': {
      const [e, i, r] = t;
      return {
        title: x(gt`${e} reacted ${i} to your post`),
        titleHtml: x(h`<strong>${e}</strong> reacted ${i} to your post`),
        detail: r
      };
    }
    case "**{0}** voted on your poll": {
      const [e] = t;
      return {
        title: x(gt`${e} voted on your poll`),
        titleHtml: x(h`<strong>${e}</strong> voted on your poll`)
      };
    }
    case "**{0}** and **{1}** voted on your poll": {
      const [e, i] = t;
      return {
        title: x(gt`${e} and ${i} voted on your poll`),
        titleHtml: x(h`<strong>${e}</strong> and <strong>${i}</strong> voted on your poll`)
      };
    }
    case "**{0}**, **{1}** and **{2}** voted on your poll": {
      const [e, i, r] = t;
      return {
        title: x(gt`${e}, ${i} and ${r} voted on your poll`),
        titleHtml: x(
          h`<strong>${e}</strong>, <strong>${i}</strong> and <strong>${r}</strong> voted on your poll`
        )
      };
    }
    case "**{0}** and {1} others voted on your poll": {
      const [e, i] = t;
      return {
        title: x(gt`${e} and ${i} others voted on your poll`),
        titleHtml: x(h`<strong>${e}</strong> and ${i} others voted on your poll`)
      };
    }
    default:
      return {
        title: n.plain,
        titleHtml: h`${An(n.html)}`
      };
  }
}
a(zv, "getNotificationText");
const Ey = j`[part~=wy-code] pre,.wy-code pre,[part~=wy-content] pre{text-wrap:pretty}[part~=wy-code] .code,[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code .code,.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] .code,[part~=wy-content] code[class*=language-],[part~=wy-content] pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;word-wrap:break-word;line-height:1.25;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}@media print{[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] code[class*=language-],[part~=wy-content] pre[class*=language-]{text-shadow:none}}[part~=wy-code] pre[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}[part~=wy-code] :not(pre)>code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code :not(pre)>code[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] :not(pre)>code[class*=language-],[part~=wy-content] pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));background:var(--wy-background, var(--wy-background-light, #f7f9ff))}[part~=wy-code] :not(pre)>code[class*=language-],.wy-code :not(pre)>code[class*=language-],[part~=wy-content] :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}[part~=wy-code] .token.variable,.wy-code .token.variable,[part~=wy-content] .token.variable{color:var(--wy-code-variable, var(--wy-code-variable-light, #001080))}[part~=wy-code] .token.operator,.wy-code .token.operator,[part~=wy-content] .token.operator{color:var(--wy-code-operator, var(--wy-code-operator-light, #000000))}[part~=wy-code] .token.prolog,.wy-code .token.prolog,[part~=wy-content] .token.prolog{color:var(--wy-code-prolog, var(--wy-code-prolog-light, #000080))}[part~=wy-code] .token.comment,.wy-code .token.comment,[part~=wy-content] .token.comment{color:var(--wy-code-comment, var(--wy-code-comment-light, #008000))}[part~=wy-code] .token.builtin,.wy-code .token.builtin,[part~=wy-content] .token.builtin{color:var(--wy-code-builtin, var(--wy-code-builtin-light, #0070C1))}[part~=wy-code] .token.number,.wy-code .token.number,[part~=wy-content] .token.number{color:var(--wy-code-number, var(--wy-code-number-light, #098658))}[part~=wy-code] .token.inserted,.wy-code .token.inserted,[part~=wy-content] .token.inserted{color:var(--wy-code-inserted, var(--wy-code-inserted-light, #098658))}[part~=wy-code] .token.constant,.wy-code .token.constant,[part~=wy-content] .token.constant{color:var(--wy-code-constant, var(--wy-code-constant-light, #811F3F))}[part~=wy-code] .token.hexcode,.wy-code .token.hexcode,[part~=wy-content] .token.hexcode{color:var(--wy-code-hexcode, var(--wy-code-hexcode-light, #811F3F))}[part~=wy-code] .token.regex,.wy-code .token.regex,[part~=wy-content] .token.regex{color:var(--wy-code-regex, var(--wy-code-regex-light, #811F3F))}[part~=wy-code] .token.char,.wy-code .token.char,[part~=wy-content] .token.char{color:var(--wy-code-char, var(--wy-code-char-light, #811F3F))}[part~=wy-code] .token.tag,.wy-code .token.tag,[part~=wy-content] .token.tag{color:var(--wy-code-tag, var(--wy-code-tag-light, #800000))}[part~=wy-code] .token.attr-name,.wy-code .token.attr-name,[part~=wy-content] .token.attr-name{color:var(--wy-code-attr-name, var(--wy-code-attr-name-light, #E50000))}[part~=wy-code] .token.selector,.wy-code .token.selector,[part~=wy-content] .token.selector{color:var(--wy-code-selector, var(--wy-code-selector-light, #E50000))}[part~=wy-code] .token.property,.wy-code .token.property,[part~=wy-content] .token.property{color:var(--wy-code-property, var(--wy-code-property-light, #E50000))}[part~=wy-code] .token.deleted,.wy-code .token.deleted,[part~=wy-content] .token.deleted{color:var(--wy-code-deleted, var(--wy-code-deleted-light, #A31515))}[part~=wy-code] .token.string,.wy-code .token.string,[part~=wy-content] .token.string{color:var(--wy-code-string, var(--wy-code-string-light, #A31515))}[part~=wy-code] .token.changed,.wy-code .token.changed,[part~=wy-content] .token.changed{color:var(--wy-code-changed, var(--wy-code-changed-light, #0451A5))}[part~=wy-code] .token.punctuation,.wy-code .token.punctuation,[part~=wy-content] .token.punctuation{color:var(--wy-code-punctuation, var(--wy-code-punctuation-light, #000000))}[part~=wy-code] .token.function,.wy-code .token.function,[part~=wy-content] .token.function{color:var(--wy-code-function, var(--wy-code-function-light, #0000FF))}[part~=wy-code] .token.keyword,.wy-code .token.keyword,[part~=wy-content] .token.keyword{color:var(--wy-code-keyword, var(--wy-code-keyword-light, #AF00DB))}[part~=wy-code] .token.class-name,.wy-code .token.class-name,[part~=wy-content] .token.class-name{color:var(--wy-code-class-name, var(--wy-code-class-name-light, #267F99))}[part~=wy-code] .token.important,[part~=wy-code] .token.bold,.wy-code .token.important,.wy-code .token.bold,[part~=wy-content] .token.important,[part~=wy-content] .token.bold{font-weight:700}[part~=wy-code] .token.italic,.wy-code .token.italic,[part~=wy-content] .token.italic{font-style:italic}[part~=wy-content]{text-align:initial;font-size:var(--wy-font-size, var(--wy-size, 1em));overflow-wrap:break-word;min-width:0}[part~=wy-content]:empty{display:none}[part~=wy-content]>:first-child{margin-top:0}[part~=wy-content]>:last-child{margin-bottom:0}[part~=wy-content] a{text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-light, #2f628c))}[part~=wy-content] a:hover{text-decoration:var(--wy-link-hover-decoration, var(--wy-link-decoration, none))}[part~=wy-content] a:where(:not([href]):not([class])),[part~=wy-content] a:where(:not([href]):not([class])):hover{text-decoration:none}[part~=wy-content] p{margin-top:0;margin-bottom:calc(1*var(--wy-size, 1rem))}[part~=wy-content] b,[part~=wy-content] strong{font-weight:var(--wy-font-weight-bold, 600)}[part~=wy-content] blockquote{border-left:calc(2*var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));margin:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) 0;padding-left:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-content] blockquote>p{margin:0}[part~=wy-content] hr{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));border-width:var(--wy-border, 1px) 0 0 0;border-style:solid}[part~=wy-content] pre,[part~=wy-content] code{font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-content] :not(pre)>code{overflow-wrap:inherit}[part~=wy-content] pre>code{font-size:var(--wy-font-size, var(--wy-size, 1em));white-space:pre-wrap}[part~=wy-content] h1,[part~=wy-content] h2,[part~=wy-content] h3,[part~=wy-content] h4,[part~=wy-content] h5,[part~=wy-content] h6{font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.5))}[part~=wy-content] h1{font-size:var(--wy-h1-font-size, var(--wy-font-size-xxl, 1.5em));font-weight:var(--wy-h1-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h1-margin, 0 0 var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-content] h2{font-size:var(--wy-h2-font-size, var(--wy-font-size-xl, 1.25em));font-weight:var(--wy-h2-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h2-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content] h3{font-size:var(--wy-h3-font-size, var(--wy-font-size-lg, 1.125em));font-weight:var(--wy-h3-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h3-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content] h4{font-size:var(--wy-h4-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-h4-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h4-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 0)}[part~=wy-content] h5{font-size:var(--wy-h5-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-h5-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h5-margin, 0)}[part~=wy-content] h6{font-size:var(--wy-h6-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-h6-font-weight, inherit);margin:var(--wy-h6-margin, 0)}[part~=wy-content] table{display:block;width:100%;max-width:-moz-max-content;max-width:max-content;overflow-x:auto;white-space:nowrap;border-collapse:separate;border-spacing:0 0;margin-bottom:var(--wy-size, 1rem)}[part~=wy-content] table th,[part~=wy-content] table td{padding:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));border-color:inherit;border-style:solid}[part~=wy-content] table th{text-align:inherit;text-align:-webkit-match-parent;border-width:var(--wy-border, 1px) 0 var(--wy-border, 1px) var(--wy-border, 1px);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600))}[part~=wy-content] table th:first-child{border-top-left-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] table th:last-child{border-top-right-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-right-width:var(--wy-border, 1px)}[part~=wy-content] table td{border-width:0 0 var(--wy-border, 1px) var(--wy-border, 1px)}[part~=wy-content] table td:last-child{border-right-width:var(--wy-border, 1px)}[part~=wy-content] table tr:last-child td:first-child{border-bottom-left-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] table tr:last-child td:last-child{border-bottom-right-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] table>tbody{vertical-align:inherit}[part~=wy-content] table>thead{vertical-align:bottom}[part~=wy-content] img{max-width:100%;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin-block:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] ol{list-style-type:decimal}[part~=wy-content] ul{list-style-type:disc}[part~=wy-content] li{margin:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) 0}[part~=wy-content] ol,[part~=wy-content] ul{margin:var(--wy-size, 1rem) 0;padding:0 0 0 1.625em}[part~=wy-content] ol>li,[part~=wy-content] ul>li{padding-left:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content] ol>li>:first-child,[part~=wy-content] ul>li>:first-child{margin-bottom:0;margin-top:0}[part~=wy-content] ol>li>:last-child,[part~=wy-content] ul>li>:last-child{margin-bottom:0}[part~=wy-content] .wy-hashtag{color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-content] .wy-mention{font-weight:var(--wy-font-weight-bold, 600)}[part~=wy-content] .wy-mention:before{content:\"@\"}[part~=wy-content-emoji] .wy-emoji{font-size:3em}`;
function Ry(n) {
  const t = n;
  t && (t.complete && t.naturalHeight !== 0 ? !t.classList.contains("wy-loading") && !t.part.contains("wy-loading") ? (t.classList.add("wy-loading", "wy-loaded"), t.part.add("wy-loading", "wy-loaded")) : t.decode().then(() => {
    t.classList.add("wy-loaded"), t.part.add("wy-loaded");
  }) : (t.classList.add("wy-loading"), t.part.add("wy-loading")));
}
a(Ry, "checkImageLoad");
function Ty(n) {
  const t = n.target;
  t.tagName === "IMG" && (t.classList.contains("wy-loading") || t.part.contains("wy-loading")) && !t.classList.contains("wy-loaded") && !t.part.contains("wy-loaded") && (t.classList.add("wy-loaded"), t.part.add("wy-loaded"));
}
a(Ty, "imageLoaded");
const Tx = j`[part~=wy-image]{padding:0;width:50%;position:relative;flex:auto;background-color:inherit;background-clip:content-box;max-height:var(--wy-image-max-size, calc(32 * var(--wy-size, 1rem)))}[part~=wy-image-filled]{position:relative;background-size:100%,100% 100%;background-position:center;background-clip:content-box;clip-path:content-box;align-items:center;justify-content:center}[part~=wy-image-filled]:after{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;z-index:1;-webkit-backdrop-filter:blur(32px);backdrop-filter:blur(32px);background-color:var(--wy-shade, var(--wy-shade-light, rgba(0, 0, 0, .3)))}[part~=wy-image-full-width]{flex-basis:100%!important}[part~=wy-image-grid]{display:flex;flex-wrap:wrap;justify-content:space-evenly;position:relative;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));overflow:hidden;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-image-grid-outer]{border-radius:0}[part~=wy-image-area]{display:flex;height:100%;cursor:pointer;align-items:center}[part~=wy-image-content]{position:absolute;height:auto;max-height:100%;width:100%;object-fit:contain;z-index:2}[part~=wy-image-content][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-image-content][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-image-content][part~=wy-loading][part~=wy-loaded]~[part~=wy-image-preview]{transition-delay:.15s;opacity:0}[part~=wy-image-icon]{object-fit:scale-down;object-position:center center}[part~=wy-image-grid-more]{position:absolute;z-index:3;line-height:100%;color:var(--wy-white, #ffffff);inset:0;display:flex;align-items:center;justify-content:center;font-size:calc(1.5*var(--wy-size, 1rem));background:rgba(0,0,0,var(--wy-opacity-disabled, 38%))}`;
var Lx = Object.defineProperty, Ox = Object.getOwnPropertyDescriptor, Ih = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? Ox(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && Lx(t, e, r), r;
}, "__decorateClass$11");
const Tf = 128;
var io;
let On = (io = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.images = [], this.limit = 3, this.outer = !1;
  }
  /**
   * Dispatch a `file-open` event.
   *
   * @internal
   * @param e - Event that will be prevented.
   * @param file - The file to open.
   */
  dispatchFileOpen(t, e) {
    if (vh(t)) {
      t.stopPropagation();
      return;
    }
    if (t.preventDefault(), !e.is_trashed) {
      const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
      this.dispatchEvent(i);
    }
  }
  render() {
    const t = this.images.length > this.limit ? this.images.length - this.limit : 0, e = this.images.slice(0, this.limit);
    return h`
      <div
        part=${J({
      "wy-image-grid": !0,
      "wy-image-grid-outer": this.outer
    })}
      >
        ${e.map((i, r) => {
      const s = !i.width || i.width <= Tf || !i.height || i.height <= Tf, o = i.width && i.height ? i.width / i.height : 1, c = 64, l = o.toPrecision(5), p = (o * c).toPrecision(5) + "px", v = s ? c + "px" : (100 / o).toPrecision(5) + "%", C = i.width + "px", g = this.images.length !== 2 && r === 0, m = di(i.name), f = m === ".gif" || m === ".svg" ? i.download_url : i.preview_url;
      return f ? h`
                <a
                  href="${i.download_url ?? "#"}"
                  @click=${($) => {
        !$.defaultPrevented && this.dispatchFileOpen($, i);
      }}
                  part=${J({
        "wy-image": !0,
        "wy-image-filled": !0,
        "wy-image-full-width": g
      })}
                  style=${kl({
        flexBasis: p,
        flexGrow: l,
        flexShrink: l,
        width: C,
        backgroundImage: `linear-gradient(var(--wy-shade-invert, rgba(255,255,255,0.15))), url(${f}), linear-gradient(var(--wy-shade-opaque, white));`
      })}
                >
                  <div part="wy-image-area" style=${kl({ paddingBottom: v })}>
                    <img
                      part=${J({ "wy-image-content": !0, "wy-image-icon": s })}
                      src=${f}
                      ${Q(Ry)}
                      @load=${Ty}
                      alt=""
                      loading="lazy"
                      decoding="async"
                    />
                    ${r === e.length - 1 && t ? h`<span part="wy-image-grid-more">+${t}</span>` : ""}
                  </div>
                </a>
              ` : b;
    })}
      </div>
    `;
  }
}, a(io, "WyImageGrid"), io);
On.styles = [Tx, X];
Ih([
  u({ attribute: !1 })
], On.prototype, "images", 2);
Ih([
  u({ type: Number })
], On.prototype, "limit", 2);
Ih([
  u({ type: Boolean, reflect: !0 })
], On.prototype, "outer", 2);
On = Ih([
  B("wy-image-grid")
], On);
var zx = Object.defineProperty, Ix = Object.getOwnPropertyDescriptor, fd = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? Ix(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && zx(t, e, r), r;
}, "__decorateClass$10"), ro;
let Ml = (ro = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this);
  }
  /**
   * Triggers file-open event.
   *
   * @param e
   * @param file
   * @returns
   */
  dispatchFileOpen(t, e) {
    t.preventDefault();
    const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
    return this.dispatchEvent(i);
  }
  render() {
    const t = this.file.size && this.file.size > 0 ? Ch(this.file.size) : null, e = di(this.file.name), { icon: i } = Xr(this.file.name), r = hy(this.file.name), s = ud(this.file.provider);
    return h`    
      <wy-item
        @click=${(o) => {
      !o.defaultPrevented && !this.file.is_trashed && this.dispatchFileOpen(o, this.file);
    }}
        size="md"
        title=${this.file.name}
        url=${dt(this.file.download_url ?? this.file.external_url)}
        interactive
      >
        <wy-icon slot="image" name=${i} .overlayName=${s} size="48" kind=${r} ext=${e}></wy-icon>
        <span slot="title">${this.file.name}</span>
        ${t ? h`<span slot="text" title="${t}">${t}</span>` : b}
      </wy-item>
    `;
  }
}, a(ro, "WyAttachment"), ro);
Ml.styles = [Sh, X];
fd([
  u({ attribute: !1 })
], Ml.prototype, "file", 2);
Ml = fd([
  B("wy-attachment")
], Ml);
var no;
let zc = (no = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.files = [], this.filled = !1;
  }
  dispatchFileOpen(t) {
    const e = new CustomEvent("file-open", { detail: { fileId: t.id } });
    return this.dispatchEvent(e);
  }
  render() {
    return h`
      <wy-item-list rounded ?filled=${this.filled}>
        ${this.files.map((t) => h`<wy-attachment @file-open=${() => this.dispatchFileOpen(t)} .file=${t}></wy-attachment>`)}
      </wy-item-list>
    `;
  }
}, a(no, "WyAttachmentList"), no);
zc.styles = [Sh, X];
fd([
  u({ attribute: !1 })
], zc.prototype, "files", 2);
fd([
  u({ type: Boolean })
], zc.prototype, "filled", 2);
zc = fd([
  B("wy-attachment-list")
], zc);
var Fx = Object.defineProperty, Dx = Object.getOwnPropertyDescriptor, Fh = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? Dx(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && Fx(t, e, r), r;
}, "__decorateClass$$"), ao;
let Al = (ao = class extends Te {
  constructor() {
    super(...arguments), this.exportParts = new q(this);
  }
  /**
   * Triggers file-open event.
   * @internal
   */
  dispatchFileOpen(t, e) {
    t.preventDefault();
    const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
    return this.dispatchEvent(i);
  }
  render() {
    const t = this.file.size && this.file.size > 0 ? Ch(this.file.size) : null, e = di(this.file.name), { icon: i } = Xr(this.file.name), r = hy(this.file.name), s = ud(this.file.provider), o = `${this.file.name}${t ? ` • ${t}` : ""}`;
    return h`
      <wy-button
        part="wy-annotation"
        @click=${(c) => {
      !c.defaultPrevented && !this.file.is_trashed && this.dispatchFileOpen(c, this.file);
    }}
        kind="filled"
        small
        title=${o}
      >
        <wy-icon
          part="wy-annotation-icon"
          name=${i}
          .overlayName=${s}
          size="24"
          kind=${r}
          ext=${e}
        ></wy-icon>
        <span part="wy-annotation-text">${this.file.name}</span>
      </wy-button>
    `;
  }
}, a(ao, "WyAnnotation"), ao);
Al.styles = [X];
Fh([
  u({ type: Object, attribute: !1 })
], Al.prototype, "file", 2);
Al = Fh([
  B("wy-annotation")
], Al);
var so;
let El = (so = class extends Dt {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.files = [];
  }
  render() {
    return this.settings?.annotations === "none" ? b : h`
      <div part="wy-annotations">
        ${this.files.map((t) => h`<wy-annotation .file=${t}></wy-annotation>`)}
      </div>
    `;
  }
}, a(so, "WyAnnotationList"), so);
El.styles = [X];
Fh([
  u({ attribute: !1 })
], El.prototype, "files", 2);
El = Fh([
  B("wy-annotation-list")
], El);
function tr(n = "", t = "", e = "", i = !1) {
  if (Pe(), n) {
    const r = document.createElement("a");
    i && (/^(data:|blob:)/.test(n) ? r.download = e || "download" : n = n.includes("?d=1") || n.includes("&d=1") ? n : n.includes("?") ? n + "&d=1" : n + "?d=1"), t && (r.target = t), r.href = n, document.body.appendChild(r);
    try {
      r.click();
    } catch {
      if (console.warn("Could not open link normally, trying fallback"), /^(?:blob:|data:)/.test(n))
        console.error(`Could not ${i ? "download" : "open"} ${e}`);
      else
        try {
          window.open(n, t);
        } catch {
          console.error(`Could not ${i ? "download" : "open"} ${e}`);
        }
    }
    document.body.removeChild(r);
  }
}
a(tr, "openUrl");
function Lf(n, t) {
  return new URL(
    n,
    typeof WEAVY_IMPORT_URL == "string" && (!t || !new URL(t).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : t
  );
}
a(Lf, "environmentUrl");
const Iv = j`[part~=wy-embed]{display:flex;flex-direction:column;word-wrap:break-word;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));clip-path:border-box;--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));color:var(--wy-component-color)}[part~=wy-embed-interactive]{background-color:var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));-webkit-user-select:none;user-select:none;cursor:pointer}[part~=wy-embed-interactive]:active,[part~=wy-embed-interactive]:hover,[part~=wy-embed-interactive]:focus{background-color:var(--wy-surface-layer-high, var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039)))}[part~=wy-embed-interactive][part~=wy-disabled],[part~=wy-embed-interactive]:disabled{pointer-events:none;border-left:none;border-right:none;border-bottom:none;border-radius:0;background-color:#0000}[part~=wy-embed-area]{display:flex;justify-content:center;align-items:center}[part~=wy-embed-icon]{width:calc(3*var(--wy-size, 1rem));height:calc(3*var(--wy-size, 1rem));flex:0 0 auto;object-fit:contain}[part~=wy-embed-content]{display:flex;position:relative;padding:0;overflow:hidden;width:100%;flex-direction:column;align-items:center;justify-content:flex-start}[part~=wy-embed-content] iframe,[part~=wy-embed-content] embed,[part~=wy-embed-content] object,[part~=wy-embed-content] video{border:0;width:auto;height:auto;max-height:var(--wy-component-max-size, var(--wy-embed-content-max-size, calc(48 * var(--wy-size, 1rem))))}[part~=wy-embed-photo]{border-top-left-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-top-right-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-left-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-right-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));position:relative;background-size:cover;background-position:center;clip-path:border-box}[part~=wy-embed-photo]:after{border-top-left-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-top-right-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-left-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-right-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));content:\"\";position:absolute;width:100%;height:100%;z-index:1;-webkit-backdrop-filter:blur(32px);backdrop-filter:blur(32px);background-color:var(--wy-shade, var(--wy-shade-light, rgba(0, 0, 0, .3)))}[part~=wy-embed-photo-with-description]{--wy-component-border-bottom-radius: 0}[part~=wy-embed-image]{width:auto;height:auto;object-fit:contain;flex:0 1 auto;min-width:0;min-height:calc(3*var(--wy-size, 1rem));max-height:calc(var(--wy-component-max-size, var(--wy-embed-content-max-size, calc(48 * var(--wy-size, 1rem)))) - var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))*2 - var(--wy-button-line-height, var(--wy-line-height, 1.5))*var(--wy-size, 1rem));z-index:2}[part~=wy-embed-provider]{color:var(--wy-outline, var(--wy-outline-light, #72777f));text-transform:uppercase;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));margin-bottom:calc(.25*var(--wy-size, 1rem))}[part~=wy-embed-provider]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-embed-actions]{display:flex;justify-content:space-between}[part~=wy-embed-select]{display:flex;flex-direction:column;min-height:0;--wy-component-max-size: calc(12 * var(--wy-size, 1rem));--wy-component-background-color: transparent}[part~=wy-embed-select] wy-embed{border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));--wy-component-border-top-radius: 0;min-height:0;display:none}[part~=wy-embed-select] wy-embed:first-of-type{display:block}`;
var Vx = Object.defineProperty, Hx = Object.getOwnPropertyDescriptor, md = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? Hx(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && Vx(t, e, r), r;
}, "__decorateClass$_"), oo;
let Ic = (oo = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.disabled = !1, this.embedContentRef = nt();
  }
  /**
   * Dispatch a wy-action event for this embed.
   *
   * @internal
   * @param {ActionType | string} [action=""] - Action to dispatch.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchActionEvent(t = Ee.Default) {
    const e = new CustomEvent("wy-action", {
      detail: {
        action: t,
        embed: this.embed
      },
      bubbles: !0,
      composed: !0,
      cancelable: !0
    });
    return this.dispatchEvent(e);
  }
  render() {
    const t = this.embed.actions ? [...this.embed.actions] : [], e = t.shift(), i = t.length === 1 ? t.shift() : void 0, r = !!((this.embed.type === "photo" || this.embed.type === "link") && (this.embed.title || this.embed.description || this.embed.type === "photo" && this.embed.provider_name));
    return h`
      <slot name="before"></slot>
      <div
        part="wy-embed ${J({
      "wy-embed-interactive": !!this.embed.url,
      "wy-disabled": this.disabled
    })}"
        title=${this.embed.url ? this.embed.url : this.embed.title || ""}
        @click=${() => this.embed.url && this.dispatchActionEvent(Ee.Default) && tr(this.embed.url, "_blank")}
        @keydown=${ve}
        @keyup=${Ie}
      >
        ${(this.embed.type === "video" || this.embed.type === "rich") && this.embed.html ? h`
              <div part="wy-embed-area">
                <div
                  ${Q(this.embedContentRef)}
                  part=${J({
      "wy-embed-content": !0,
      "wy-embed-video": this.embed.type === "video",
      "wy-embed-rich": this.embed.type === "rich"
    })}
                  data-width=${dt(this.embed.width)}
                  data-height=${dt(this.embed.height)}
                >
                  ${An(this.embed.html)}
                </div>
              </div>
            ` : b}
        ${this.embed.type === "photo" && this.embed.image && this.embed.thumbnail_url ? h`
              <div
                part="wy-embed-photo wy-embed-area ${J({
      "wy-embed-photo-with-description": r
    })}"
                style="background-image: linear-gradient(var(--wy-shade-invert, rgba(255,255,255,0.15))), url(${this.embed.thumbnail_url}), linear-gradient(var(--wy-shade-opaque, white));"
              >
                <img
                  part="wy-embed-image"
                  src=${this.embed.thumbnail_url}
                  alt=${this.embed.provider_name || this.embed.title || ""}
                  width=${dt(this.embed.image.width)}
                  height=${dt(this.embed.image.height)}
                />
              </div>
            ` : b}
        ${r ? h`
              <wy-item size="auto">
                ${this.embed.type === "link" && this.embed.image && this.embed.thumbnail_url ? h`
                      <img
                        part="wy-embed-icon"
                        slot="image"
                        src=${this.embed.thumbnail_url}
                        alt=${this.embed.provider_name || this.embed.title || ""}
                        width=${dt(this.embed.image.width)}
                        height=${dt(this.embed.image.height)}
                      />
                    ` : b}
                ${this.embed.provider_name ? h`<span slot="meta" part="wy-embed-provider">${this.embed.provider_name}</span>` : b}
                ${this.embed.title ? h`<span slot="title">${this.embed.title}</span>` : b}
                ${this.embed.description ? h`<span slot="text">${this.embed.description}</span>` : b}
                ${i ? h`
                      <wy-button
                        slot="actions"
                        color="variant"
                        @click=${(s) => {
      s.stopPropagation(), this.dispatchActionEvent(i);
    }}
                      >
                        ${i}
                      </wy-button>
                    ` : b}
                ${e ? h`
                      <wy-button
                        slot="actions"
                        color="primary"
                        @click=${(s) => {
      s.stopPropagation(), this.dispatchActionEvent(e);
    }}
                      >
                        ${e}
                      </wy-button>
                    ` : b}
                ${t.length ? h`
                      <wy-dropdown slot="actions">
                        ${t.map(
      (s) => h`
                              <wy-dropdown-item
                                @click=${(o) => {
        o.preventDefault(), o.stopPropagation(), this.dispatchActionEvent(s);
      }}
                              >
                                ${s}
                              </wy-dropdown-item>
                            `
    )}
                      </wy-dropdown>
                    ` : b}
              </wy-item>
            ` : b}
      </div>
    `;
  }
  updated(t) {
    if (this.embedContentRef.value) {
      const e = this.embedContentRef.value.firstElementChild, { width: i, height: r } = this.embedContentRef.value.dataset, s = Number(r ?? ""), o = s > 128 && s < 256 ? s : 128;
      i && r && (e.style.aspectRatio = `${i} / ${r}`, e.style.minHeight = `${o}px`);
    }
  }
}, a(oo, "WyEmbed"), oo);
Ic.styles = [X, Iv];
md([
  u({ attribute: !1 })
], Ic.prototype, "embed", 2);
md([
  u({ type: Boolean, reflect: !0 })
], Ic.prototype, "disabled", 2);
Ic = md([
  B("wy-embed")
], Ic);
var co;
let Rl = (co = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this);
  }
  /**
   * Dispatch a local embed-remove event for the embed with the given id.
  *
   * @internal
   * @param id - Embed id to remove.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchRemove(t) {
    const e = new CustomEvent("embed-remove", {
      detail: { id: t },
      bubbles: !1,
      composed: !1
    });
    return this.dispatchEvent(e);
  }
  /**
   * Dispatch a local embed-swap event to request rotating/swapping embeds.
  *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSwap() {
    const t = new CustomEvent("embed-swap", {
      detail: {},
      bubbles: !1,
      composed: !1
    });
    return this.dispatchEvent(t);
  }
  render() {
    return h`
      <div part="wy-embed-select">
        ${je(
      this.embeds,
      (t) => t.id,
      (t) => h`
            <wy-embed disabled .embed=${t}>
              <div part="wy-embed-actions" slot="before">
                ${this.embeds.length > 1 ? h`
                      <wy-button kind="icon" @click=${() => this.dispatchSwap()}>
                        <wy-icon name="swap-horizontal"></wy-icon>
                      </wy-button>
                    ` : h`<span></span>`}

                <wy-button kind="icon" @click=${() => this.dispatchRemove(t.id)}
                  ><wy-icon name="close-circle"></wy-icon
                ></wy-button>
              </div>
            </wy-embed>
          `
    )}
      </div>
    `;
  }
}, a(co, "WyEmbedSelect"), co);
Rl.styles = [X, Iv];
md([
  u({ attribute: !1 })
], Rl.prototype, "embeds", 2);
Rl = md([
  B("wy-embed-select")
], Rl);
function Up(n) {
  switch (n) {
    case "zoom":
      return "zoom-meetings";
    case "microsoft":
      return "microsoft-teams";
    case "google":
      return "google-meet";
  }
}
a(Up, "getMeetingIconName");
function qp(n) {
  switch (n) {
    case "zoom":
      return x("Zoom meeting");
    case "microsoft":
      return x("Teams meeting");
    case "google":
      return x("Google Meet");
  }
}
a(qp, "getMeetingTitle");
var Bx = Object.defineProperty, Nx = Object.getOwnPropertyDescriptor, Fv = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? Nx(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && Bx(t, e, r), r;
}, "__decorateClass$Z"), lo;
let Tl = (lo = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this);
  }
  render() {
    const t = ((/* @__PURE__ */ new Date()).getTime() - new Date(this.meeting.created_at).getTime()) / 36e5 > 2;
    return h`
      <wy-item-list rounded filled>
        ${t ? h`
              <wy-item part="wy-meeting" size="lg" disabled title="${x("Meeting ended")}">
                <wy-icon slot="image" svg="${Up(this.meeting.provider)}" size="48"></wy-icon>
                <span slot="title">${qp(this.meeting.provider)}</span>
                <span slot="text">${this.meeting.code}</span>
              </wy-item>
            ` : h`
              <wy-item
                interactive
                size="lg"
                part="wy-meeting"
                @click=${(e) => {
      e.preventDefault(), tr(this.meeting.join_url, "_blank");
    }}
                url=${dt(this.meeting.join_url)}
                title="${x("Join meeting")}"
              >
                <wy-icon
                  slot="image"
                  svg="${Up(this.meeting.provider)}"
                  size="48"
                  color="native"
                ></wy-icon>
                <span slot="title">${qp(this.meeting.provider)}</span>
                <span slot="text">${this.meeting.code}</span>
              </wy-item>
            `}
        </wy-item-list>
    `;
  }
}, a(lo, "WyMeetingCard"), lo);
Tl.styles = [X];
Fv([
  u({ attribute: !1 })
], Tl.prototype, "meeting", 2);
Tl = Fv([
  B("wy-meeting-card"),
  ht()
], Tl);
const Ly = j`[part~=wy-poll]{min-width:0;display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));box-sizing:border-box;width:100%}[part~=wy-poll-form]{display:flex;flex-direction:column;gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-poll-form]:empty{display:none}[part~=wy-poll-option]{--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));display:flex;align-items:center;clip-path:border-box;overflow:hidden;position:relative;background-color:var(--wy-surface-layer-lowest, var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078)));border:var(--wy-border-outline, 0) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));padding:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));cursor:pointer;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-poll-option]>:not([part~=wy-poll-meter]){z-index:1}[part=wy-poll-image]{display:flex;height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);padding:0;line-height:1;align-items:center;justify-content:center}[part~=wy-poll-title]{width:100%;min-width:0;min-height:100%;color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset));align-content:center}[part~=wy-poll-title]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-poll-amount]{min-width:3em;text-align:end}[part~=wy-poll-meter]{position:absolute;top:0;left:0;bottom:0;background-color:var(--wy-surface-layer-highest, var(--wy-surface-layer-highest-light, rgba(0, 0, 0, .1019607843)))}`, Ux = j`[part~=wy-dialog]{background:none;border:none;padding:0;margin:0;width:100%;height:100%;max-width:100%;max-height:100%;container-type:inline-size;pointer-events:none}[part~=wy-dialog][popover]{position:fixed;inset:0;z-index:1055}[part~=wy-dialog-modal]{align-items:center;justify-content:center;overflow:visible}[part~=wy-dialog-modal][open]{display:flex}[part~=wy-dialog-modal]:popover-open{display:flex}[part~=wy-dialog-modal]:focus-visible{outline:none}[part~=wy-overlay]{--wy-component-background-color: var(--wy-background, var(--wy-background-light, #f7f9ff));--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;overflow:hidden;container-type:inline-size}[part~=wy-overlay]{interpolate-size:allow-keywords;transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) .01s,visibility .01s step-end var(--wy-transition-duration-fast, .1s)}[part~=wy-overlay]:not([part~=wy-open]){opacity:0;visibility:hidden}[part~=wy-overlay][part~=wy-open]{transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),visibility var(--wy-transition-duration, .2s) step-start,top var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),right var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),bottom var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),left var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));visibility:visible;opacity:1;transform:none;pointer-events:auto}@starting-style{[part~=wy-overlay][part~=wy-open]{opacity:0;visibility:hidden}}`, qx = j`[part~=wy-modal]{width:100%;height:100%;border-radius:0}@container (inline-size >= 768px){[part~=wy-modal-centered]{border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level4, 0 calc(1 * var(--wy-size, 1rem)) calc(2.25 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .14), 0 calc(.375 * var(--wy-size, 1rem)) calc(1.875 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .12), 0 calc(.5 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) calc(-.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));margin-left:calc(4*var(--wy-size, 1rem));margin-top:auto;margin-right:calc(4*var(--wy-size, 1rem));margin-bottom:auto;width:calc(32*var(--wy-size, 1rem));max-height:calc(32*var(--wy-size, 1rem))}}@container (inline-size >= 768px){[part~=wy-modal-centered][part~=wy-maximized]{margin:0;width:100%;height:100%;max-width:calc(100% - 2*var(--wy-size, 1rem));max-height:calc(100% - 2*var(--wy-size, 1rem))}}`, jx = j`[part~=wy-sheet]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));position:fixed;z-index:1055;bottom:calc(.5*var(--wy-size, 1rem));left:calc(.5*var(--wy-size, 1rem));right:calc(.5*var(--wy-size, 1rem));max-height:max(50vh,50%);min-height:calc(3*var(--wy-size, 1rem));margin:calc(.5*var(--wy-size, 1rem)) auto;max-width:calc(32*var(--wy-size, 1rem));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12))}[part~=wy-sheet]:not([part~=wy-open]){transform:translateY(calc(32 * var(--wy-size, 1rem)))}@starting-style{[part~=wy-sheet][part~=wy-open]{transform:translateY(calc(32 * var(--wy-size, 1rem)))}}`, Wx = j`[part~=wy-drawer]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));position:fixed;z-index:1055;box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));inset:0;border-radius:0}@container (inline-size >= 768px){[part~=wy-drawer]{top:var(--wy-padding-outer, 0px);right:var(--wy-padding-outer, 0px);bottom:var(--wy-padding-outer, 0px);left:auto;width:calc(24*var(--wy-size, 1rem));min-width:calc(24*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-outer, 0px)}}@container (inline-size >= 768px){[part~=wy-drawer][part~=wy-maximized]{width:calc(100% - 2*var(--wy-padding-outer, 0px))}}[part~=wy-drawer]:not([part~=wy-open]){transform:translate(calc(100% + var(--wy-padding-outer, 0px)))}@starting-style{[part~=wy-drawer][part~=wy-open]{transform:translate(calc(100% + var(--wy-padding-outer, 0px)))}}`, Oy = j`[part~=wy-header]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));background-color:var(--wy-component-background-color);box-sizing:border-box}@supports (position: sticky){[part~=wy-header]{position:sticky;top:0;z-index:1020}}[part~=wy-header]{z-index:1022}[part~=wy-header-floating]{--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-component-border-radius)}[part~=wy-header-outer]{--wy-component-border-radius: var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));border-radius:var(--wy-component-border-radius)}`, Dv = j`[part~=wy-titlebar]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));box-sizing:border-box;display:grid;align-items:center;justify-content:space-between;justify-items:center;min-height:var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));padding:calc(var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));flex:0 0 var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));grid-template-columns:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) minmax(0,max-content) var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));column-gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));line-height:var(--wy-line-height, 1.5);color:var(--wy-component-color)}[part~=wy-titlebar-buttons],[part~=wy-titlebar-section]{display:flex;flex:0 0 auto;align-items:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));max-width:100%;box-shadow:var(--wy-component-box-shadow);border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem))));background-color:var(--wy-component-background-color)}[part~=wy-titlebar-lg]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));height:auto}[part~=wy-titlebar-buttons-first]{justify-content:flex-start}[part~=wy-titlebar-buttons-last]{justify-content:flex-end}[part~=wy-titlebar-text]{max-width:100%;display:block;color:inherit!important;-webkit-user-select:none;user-select:none;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-titlebar-text]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-titlebar-text-trashed]{text-decoration:line-through}`;
var Kx = Object.defineProperty, Qx = Object.getOwnPropertyDescriptor, en = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? Qx(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && Kx(t, e, r), r;
}, "__decorateClass$Y"), ho;
let ar = (ho = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.header = !1, this.floating = !1, this.outer = !1, this.trashed = !1, this.size = "md";
  }
  /**
   * render function for the inner titlebar.
   * @internal
   * @returns
   */
  renderTitlebar() {
    return h`
      <nav part="wy-titlebar ${J({ "wy-titlebar-lg": this.size === "lg" })}">
        <slot name="first">
          <div part="wy-titlebar-icon wy-titlebar-buttons wy-titlebar-buttons-first">
            <slot name="icon"></slot>
          </div>
        </slot>
        <slot name="middle">
          <div part="wy-titlebar-title wy-titlebar-section">
            <slot name="title-section">
              <wy-titlebar-text ?trashed=${this.trashed}><slot name="title"></slot></wy-titlebar-text>
            </slot>
          </div>
        </slot>
        <slot name="last">
          <div part="wy-titlebar-actions wy-titlebar-buttons wy-titlebar-buttons-last">
            <slot name="actions"></slot>
          </div>
        </slot>
      </nav>
    `;
  }
  render() {
    return this.header ? h`<header part="wy-header ${J({ "wy-header-floating": this.floating, "wy-header-outer": this.outer })}"
          >${this.renderTitlebar()}</header
        >` : this.renderTitlebar();
  }
}, a(ho, "WyTitlebar"), ho);
ar.styles = [Oy, Dv, X];
en([
  u({ type: Boolean })
], ar.prototype, "header", 2);
en([
  u({ type: Boolean })
], ar.prototype, "floating", 2);
en([
  u({ type: Boolean })
], ar.prototype, "outer", 2);
en([
  u({ type: Boolean })
], ar.prototype, "trashed", 2);
en([
  u()
], ar.prototype, "size", 2);
ar = en([
  B("wy-titlebar")
], ar);
var uo;
let Ll = (uo = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.trashed = !1;
  }
  render() {
    const t = {
      "wy-titlebar-text-trashed": this.trashed
    };
    return h` <slot part="wy-titlebar-text ${J(t)}"></slot> `;
  }
}, a(uo, "WyTitlebarText"), uo);
Ll.styles = [Dv, X];
en([
  u({ type: Boolean })
], Ll.prototype, "trashed", 2);
Ll = en([
  B("wy-titlebar-text")
], Ll);
var Gx = Object.defineProperty, Zx = Object.getOwnPropertyDescriptor, vd = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? Zx(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && Gx(t, e, r), r;
}, "__decorateClass$X"), po;
let qr = (po = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.viewportRef = nt(), this.show = !0, this.type = "modal", this.maximized = !1, this.noHeader = !1, this.handleClose = (t) => {
      if (this.isModal() || t?.type === "toggle" && t.newState === "closed" || t?.type === "close") {
        this.show = !1;
        const e = new CustomEvent("close");
        this.dispatchEvent(e);
      }
    };
  }
  /**
   * Close the modal.
   */
  close() {
    this.show = !1;
    try {
      this.type !== "modal" && this.viewportRef.value?.popover ? this.viewportRef.value?.hidePopover() : this.viewportRef.value?.close();
    } catch {
    }
  }
  /**
   * Checks whether the overlay is using the modal api.
   *
   * @param [type] - Optional type to check
   * @returns Whether the overlay is using the modal api.
   */
  isModal(t) {
    return t ??= this.type, t === "modal" || t === "full";
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("type") && this.viewportRef.value) {
      const e = !this.isModal(t.get("type")) && this.viewportRef.value.popover ? "toggle" : "close";
      this.viewportRef.value.removeEventListener(e, this.handleClose);
    }
  }
  render() {
    if (this.type === "none")
      return b;
    const t = {
      "wy-dialog": !0,
      "wy-dialog-modal": this.isModal()
    }, e = {
      "wy-overlay": !0,
      "wy-modal": this.isModal(),
      // modal, full
      "wy-modal-centered": this.type === "modal",
      "wy-sheet": this.type === "sheet",
      "wy-drawer": this.type === "drawer",
      "wy-maximized": this.maximized,
      "wy-open": this.show
    }, i = this.isModal() ? void 0 : "auto";
    return h`
      <dialog
        part=${J(t)}
        tabindex="0"
        popover=${dt(i)}
        ${Q(this.viewportRef)}
      >
        <div part=${J(e)}>
          ${this.noHeader ? b : h`
                <slot name="header">
                  <wy-titlebar part="wy-overlay-titlebar" header>
                    <wy-button slot="icon" kind="icon" @click=${() => this.close()}>
                      <wy-icon name="close"></wy-icon>
                    </wy-button>
                    <slot slot="title" name="title"></slot>
                    <slot slot="actions" name="actions"></slot>
                  </wy-titlebar>
                </slot>
              `}
          <slot></slot>
        </div>
      </dialog>
    `;
  }
  updated(t) {
    if (t.has("type")) {
      const e = !this.isModal() && this.viewportRef.value?.popover ? "toggle" : "close";
      this.viewportRef.value?.addEventListener(e, this.handleClose), this.show && (!this.isModal(t.get("type")) && this.viewportRef.value?.popover ? this.viewportRef.value?.hidePopover() : this.viewportRef.value?.close(), this.requestUpdate("show"));
    }
    if (t.has("show"))
      try {
        this.show ? this.isModal() ? this.viewportRef.value?.showModal() : this.viewportRef.value?.popover ? this.viewportRef.value?.showPopover() : this.viewportRef.value?.show() : !this.isModal() && this.viewportRef.value?.popover ? this.viewportRef.value?.hidePopover() : this.viewportRef.value?.close();
      } catch {
      }
    t.has("show") && this.show && this.viewportRef.value?.focus();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.close();
  }
}, a(po, "WyOverlay"), po);
qr.styles = [se, X, Ux, qx, jx, Wx];
vd([
  u({ type: Boolean, reflect: !0 })
], qr.prototype, "show", 2);
vd([
  u({ type: String })
], qr.prototype, "type", 2);
vd([
  u({ type: Boolean })
], qr.prototype, "maximized", 2);
vd([
  u({ type: Boolean })
], qr.prototype, "noHeader", 2);
qr = vd([
  B("wy-overlay")
], qr);
const Yx = j`[part~=wy-container]{display:flex;flex-direction:column;position:relative;min-height:0;height:100%;flex:1 1 auto}[part~=wy-container-padded]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));gap:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-container-outer]{padding:var(--wy-padding-outer, 0)}`, Jn = j`[part~=wy-scroll-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x-y]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;overflow-x:auto;touch-action:pan-y,pan-x}[part~=wy-scroll-x-always],[part~=wy-scroll-y-always]{overflow-y:scroll}`;
var Xx = Object.defineProperty, Jx = Object.getOwnPropertyDescriptor, Yc = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? Jx(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && Xx(t, e, r), r;
}, "__decorateClass$W"), yo;
let sr = (yo = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.scrollX = !1, this.scrollY = !1, this.padded = !1, this.outer = !1, this.scrollbars = !1;
  }
  render() {
    const t = {
      "wy-container": !0,
      "wy-container-padded": this.padded,
      "wy-container-outer": this.outer,
      "wy-scroll-x": this.scrollX && !this.scrollY,
      "wy-scroll-y": this.scrollY && !this.scrollX,
      "wy-scroll-x-y": this.scrollX && this.scrollY,
      "wy-scroll-x-always": this.scrollbars && this.scrollX,
      "wy-scroll-y-always": this.scrollbars && this.scrollY
    };
    return h`
      <div part=${J(t)}>
        <slot></slot>
      </div>
    `;
  }
}, a(yo, "WyContainer"), yo);
sr.styles = [Jn, X, Yx];
Yc([
  u({ type: Boolean })
], sr.prototype, "scrollX", 2);
Yc([
  u({ type: Boolean })
], sr.prototype, "scrollY", 2);
Yc([
  u({ type: Boolean })
], sr.prototype, "padded", 2);
Yc([
  u({ type: Boolean })
], sr.prototype, "outer", 2);
Yc([
  u({ type: Boolean })
], sr.prototype, "scrollbars", 2);
sr = Yc([
  B("wy-container")
], sr);
var t4 = Object.defineProperty, e4 = Object.getOwnPropertyDescriptor, Xc = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? e4(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && t4(t, e, r), r;
}, "__decorateClass$V"), wo;
let Ol = (wo = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.pollOptions = [];
  }
  /**
   * Dispatch a `vote` event for the specified option.
   *
   * @param optionId - Identifier of the option to vote for.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  render() {
    const t = this.pollOptions.reduce((e, i) => e + (i.votes?.count || 0), 0);
    return h`
      <div part="wy-poll">
        ${this.pollOptions.map(
      (e) => h`<wy-poll-option
              @vote=${(i) => this.dispatchVote(i.detail.optionId)}
              .option=${e}
              .totalVotes=${t}
            ></wy-poll-option>`
    )}
      </div>
    `;
  }
}, a(wo, "WyPoll"), wo);
Ol.styles = [
  Ly,
  X
];
Xc([
  u({ type: Array, attribute: !1 })
], Ol.prototype, "pollOptions", 2);
Ol = Xc([
  B("wy-poll")
], Ol);
var fo;
let zn = (fo = class extends Te {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.totalVotes = 0, this.showSheet = !1, this.getVotesQuery = new qe(this);
  }
  async updated(t) {
    t.has("weavy") && this.weavy && this.option && this.option.id && await this.getVotesQuery.trackQuery(Cb(this.weavy, this.option.id));
  }
  /**
   * Dispatch a `vote` event for the provided option id.
   *
   * @internal
   * @param optionId - Identifier of the option to vote for.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    if (!t)
      return;
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Toggle the voter sheet and refresh vote data.
   *
   * @internal
   * @param e - Triggering user event.
   */
  openSheet(t) {
    t.preventDefault(), t.stopPropagation(), this.getVotesQuery.observer?.refetch(), this.showSheet = !this.showSheet;
  }
  render() {
    if (!this.option || !this.option.id)
      return b;
    const { data: t, isLoading: e } = this.getVotesQuery.result ?? {}, i = this.totalVotes > 0 ? Math.round((this.option.votes?.count || 0) / this.totalVotes * 100) : 0;
    return h`
      <div
        part="wy-poll-option"
        tabindex="0"
        @click=${() => this.dispatchVote(this.option?.id)}
        @keydown=${ve}
        @keyup=${Ie}
      >
        <div part="wy-poll-meter" style="width: ${i + "%"}"></div>
        <div part="wy-poll-image">
          ${this.option.has_voted ? h`<wy-icon name="check-circle"></wy-icon>` : h`<wy-icon name="circle-outline"></wy-icon>`}
        </div>
        <div part="wy-poll-title">${this.option.text}</div>
        ${i > 0 ? h`<span
              part="wy-poll-amount"
              tabindex="0"
              @click=${(r) => this.openSheet(r)}
              @keydown=${ve}
              @keyup=${Ie}
            >
              ${i + "%"}
            </span>` : h`<span part="wy-poll-amount"></span>`}
      </div>

      ${this.weavy ? h`
            <wy-overlay type="sheet" .show=${this.showSheet} @close=${() => this.showSheet = !1}>
              <span slot="title">${x(gt`Votes on ${this.option.text}`)}</span>
              <wy-container scrollY padded>
                ${this.showSheet && t && !e ? h`
                      ${t.votes?.data ? t.votes.data.map(
      (r) => h`
                              <wy-item>
                                <wy-avatar
                                  slot="image"
                                  .size=${32}
                                  .src=${r.avatar_url}
                                  .name=${r.name}
                                ></wy-avatar>
                                <span slot="title">${r.name}</span>
                              </wy-item>
                            `
    ) : b}
                    ` : b}
              </wy-container>
            </wy-overlay>
          ` : b}
    `;
  }
}, a(fo, "WyPollOption"), fo);
zn.styles = [Ly, X];
Xc([
  u({ type: Number, attribute: !1 })
], zn.prototype, "totalVotes", 2);
Xc([
  u({ attribute: !1 })
], zn.prototype, "option", 2);
Xc([
  D()
], zn.prototype, "showSheet", 2);
zn = Xc([
  B("wy-poll-option"),
  ht()
], zn);
function i4(n, t, e, i, r, s, o) {
  return new Mt(n.queryClient, {
    mutationFn: /* @__PURE__ */ a(async () => await n.fetch(`/api/${r}/${i}/reactions`, {
      method: s ? "POST" : "DELETE",
      body: JSON.stringify({ content: s })
    }), "mutationFn"),
    onMutate: /* @__PURE__ */ a(() => {
      const c = e === "apps" && r === "posts" ? [r, t] : [e, t, r];
      Zt(n.queryClient, c, i, (l) => {
        zl(l, s, o);
      });
    }, "onMutate")
  });
}
a(i4, "reactionMutation");
function r4(n, t, e) {
  return {
    queryKey: [t, e, "reactions"],
    enabled: !1,
    queryFn: /* @__PURE__ */ a(async () => await (await n.fetch("/api/" + t + "/" + e + "/reactions")).json(), "queryFn")
  };
}
a(r4, "getReactionListOptions");
function zl(n, t, e) {
  return !t && !n.reactions?.data || (n.reactions || (n.reactions = { count: 0, data: [] }), n.reactions.data || (n.reactions.data = []), t ? n.reactions.data = [
    ...n.reactions.data.filter((i) => i.created_by?.id !== e.id),
    { content: t, created_by: e }
  ] : n.reactions.data && (n.reactions.data = [...n.reactions.data.filter((i) => i.created_by?.id !== e.id)])), n;
}
a(zl, "updateReaction");
const n4 = j`[part~=wy-reaction]{font-size:calc(1.125*var(--wy-size, 1rem))}[part~=wy-reactions]{display:inline-flex;align-items:center;column-gap:calc(.25*var(--wy-size, 1rem))}[part~=wy-reactions] :first-child:not(:only-child){margin-left:calc(.25*var(--wy-size, 1rem))}[part~=wy-reactions] :last-child:not(:only-child){margin-right:calc(.25*var(--wy-size, 1rem))}[part~=wy-reaction-count]{margin:0 calc(.25*var(--wy-size, 1rem)) 0;line-height:1;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-reaction-menu]{width:max-content;position:absolute;z-index:1000;border:none;--wy-component-background-color: var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;margin:0;text-align:left;background-clip:padding-box;box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));overflow:hidden;padding:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));font-size:calc(1.25*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))))}[part~=wy-reaction-picker]{display:flex;flex-direction:row;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-reactions-line]{display:flex;align-items:center;gap:calc(.1875*var(--wy-size, 1rem));justify-content:end}[part~=wy-reactions-line-reverse]{flex-direction:row-reverse;justify-content:start}[part~=wy-reactions-line-bottom]{position:absolute;bottom:calc(-1*var(--wy-size, 1rem));right:calc(.25*var(--wy-size, 1rem));z-index:1}[part~=wy-reactions-line-below]{position:relative;height:0;min-height:0;max-height:0;margin:calc(var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) - var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) calc(-1*var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))) calc(-1*var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));padding-left:calc(.1875*var(--wy-size, 1rem));padding-right:calc(.1875*var(--wy-size, 1rem));gap:calc(.125*var(--wy-size, 1rem));flex:1 0 auto;justify-content:flex-end}`, Vv = j`[part~=wy-emoji-icon]{display:inline-flex;justify-content:center;align-items:center;line-height:1;width:1em;height:1em;font-size:calc(1.25*var(--wy-size, 1rem))}[part~=wy-emoji-icon-sm]{width:calc(1.125*var(--wy-size, 1rem));height:calc(1.125*var(--wy-size, 1rem));font-size:calc(1.125*var(--wy-size, 1rem))}`;
var a4 = Object.defineProperty, s4 = Object.getOwnPropertyDescriptor, oe = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? s4(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && a4(t, e, r), r;
}, "__decorateClass$U"), mo;
let Xt = (mo = class extends Dt {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.directionX = "left", this.directionY = "up", this.small = !1, this.reactions = [], this.emojis = "", this.parentType = "apps", this.entityType = "messages", this.line = !1, this.lineReverse = !1, this.lineBottom = !1, this.lineBelow = !1, this._placement = "bottom-start", this.show = !1, this.showSheet = !1, this.buttonRef = nt(), this.menuRef = nt(), this.reactionListQuery = new qe(this), this._documentClickHandler = (t) => {
      this.show && (t.preventDefault(), this.menuRef.value?.popover || (this.show = !1));
    }, this.handleReaction = async (t) => {
      if (!this.weavy || !this.parentId || !this.user)
        return;
      const e = i4(
        this.weavy,
        this.parentId,
        this.parentType,
        this.entityId,
        this.entityType,
        this.reactedEmoji === t ? void 0 : t,
        this.user
      );
      this.reactedEmoji = t, await e.mutate(), this.reactionListQuery.observer?.refetch();
    };
  }
  /**
   * Closes the picker when the popover hides.
   *
   * @internal
   */
  handleClose(t) {
    if (t.type === "toggle" && t.newState === "closed" || t.type === "click") {
      this.show = !1;
      const e = new CustomEvent("close");
      this.dispatchEvent(e);
    }
  }
  /**
   * Toggles the emoji picker visibility.
   *
   * @internal
   */
  handleClickToggle(t) {
    t.stopPropagation(), this.show = !this.show;
  }
  /**
   * Opens the detailed reaction sheet view.
   *
   * @internal
   */
  handleReactionsClick() {
    this.reactionListQuery.observer?.refetch(), this.showSheet = !this.showSheet, this.show = !1;
  }
  async willUpdate(t) {
    if (super.willUpdate(t), (t.has("weavy") || t.has("entityId") || t.has("showSheet")) && this.weavy && this.entityId && this.showSheet && await this.reactionListQuery.trackQuery(r4(this.weavy, this.entityType, this.entityId)), (t.has("reactions") || t.has("user")) && this.user && (this.reactedEmoji = this.reactions?.find((e) => e.created_by?.id === this.user?.id)?.content), (t.has("directionX") || t.has("directionY")) && (this._placement = this.directionX === "right" && this.directionY === "down" ? "bottom-start" : this.directionX === "left" && this.directionY === "down" ? "bottom-end" : this.directionX === "right" && this.directionY === "up" ? "top-start" : "top-end"), t.has("show") && (this.show && !this._computePositionCleanup && this.buttonRef.value && this.menuRef.value ? this._computePositionCleanup = $v(this.buttonRef.value, this.menuRef.value, () => {
      requestAnimationFrame(() => {
        this.buttonRef.value && this.menuRef.value && Sv(this.buttonRef.value, this.menuRef.value, {
          placement: this._placement,
          strategy: this.menuRef.value.popover ? "absolute" : "fixed",
          middleware: [
            _v(),
            kv({ mainAxis: 0, alignmentAxis: -8 }),
            Pv({ mainAxis: !0, crossAxis: !0, padding: 4, altBoundary: !0 })
          ]
        }).then(({ x: e, y: i }) => {
          this.menuRef.value && Object.assign(this.menuRef.value.style, {
            marginLeft: `${e}px`,
            marginTop: `${i}px`,
            top: 0,
            left: 0,
            position: this.menuRef.value.popover ? void 0 : "fixed",
            zIndex: this.menuRef.value.popover ? void 0 : 1075
          });
        });
      });
    }) : !this.show && this._computePositionCleanup && (this._computePositionCleanup(), this._computePositionCleanup = void 0)), this.show) {
      requestAnimationFrame(() => {
        document.addEventListener("click", this._documentClickHandler, { once: !0, capture: !0 });
      });
      try {
        this.menuRef.value?.showPopover();
      } catch {
      }
    } else
      try {
        this.menuRef.value?.hidePopover();
      } catch {
      }
    t.has("settings") && this.settings?.reactions && this.emojis != this.settings.reactions && (this.emojis = this.settings.reactions);
  }
  render() {
    const { data: t, isPending: e } = this.reactionListQuery.result ?? {};
    if (!this.emojis?.length)
      return b;
    const i = this.emojis?.length === 1 ? this.emojis[0] : "", r = [
      ...new Map(this.reactions?.map((p) => [p.content, p])).values()
    ], s = {
      "wy-emoji-icon": !0,
      "wy-emoji-icon-sm": this.small
    }, o = i ? h`
          ${this.reactions && this.reactions?.length > 1 ? h`<wy-button
                kind="icon-inline"
                ?active=${this.showSheet}
                ?small=${this.small}
                @click=${() => this.handleReactionsClick()}
              >
                <div part="wy-reactions">
                  <span part=${J(s)}>
                    <small part="wy-reaction-count">${this.reactions.length}</small>
                  </span>
                </div>
              </wy-button>` : b}

          <div>
            <wy-button
              part="wy-reaction-menu-button"
              color="inherit"
              kind="icon"
              ?small=${this.small}
              ?active=${this.reactedEmoji === i}
              @click=${() => {
      this.handleReaction(i);
    }}
              @keydown=${ve}
              @keyup=${Ie}
              title=${x("React", { desc: "Button action to react" })}
            >
              <span part=${J(s)} title=${i}>${i}</span>
            </wy-button>
          </div>
        ` : h`
          ${r.length ? h`
                <wy-button
                  kind="icon-inline"
                  ?active=${this.showSheet}
                  ?small=${this.small}
                  @click=${() => this.handleReactionsClick()}
                >
                  <div part="wy-reactions">
                    ${r.map((p) => h`<span part=${J(s)} title="">${p.content}</span>`)}
                    ${this.reactions && this.reactions?.length > 1 ? h`<small part="wy-reaction-count">${this.reactions.length}</small>` : b}
                  </div>
                </wy-button>
              ` : b}

          <div ${Q(this.buttonRef)}>
            <wy-button
              part="wy-reaction-menu-button"
              color="inherit"
              kind="icon"
              ?active=${this.show}
              ?small=${this.small}
              @click=${(p) => this.handleClickToggle(p)}
              @keydown=${ve}
              @keyup=${Ie}
              title=${x("React", { desc: "Button action to react" })}
            >
              <wy-icon name="emoticon" size=${this.small ? 20 : 24}></wy-icon>
            </wy-button>
          </div>

          <div
            ${Q(this.menuRef)}
            part="wy-reaction-menu"
            @click=${(p) => this.handleClickToggle(p)}
            @keyup=${by}
            ?hidden=${!this.show}
            popover=${dt(Gu() ? void 0 : "auto")}
          >
            <div part="wy-reaction-picker">
              ${this.emojis.split(" ").map(
      (p) => h`
                    <wy-button
                      kind="icon"
                      color="none"
                      ?active=${this.reactedEmoji === p}
                      @click=${() => {
        this.handleReaction(p);
      }}
                    >
                      <span part="wy-emoji-icon">${p}</span>
                    </wy-button>
                  `
    )}
            </div>
          </div>
        `, c = h`
      ${this.weavy && this.showSheet ? h`
            <wy-overlay type="sheet" .show=${this.showSheet} @close=${() => this.showSheet = !1}>
              <span slot="title">${x("Reactions")}</span>
              <wy-container scrollY padded>
                ${this.showSheet && t && !e ? h`
                      ${t.data?.map(
      (p) => h` <wy-reaction-item .reaction=${p}></wy-reaction-item> `
    )}
                    ` : b}
              </wy-container>
            </wy-overlay>
          ` : b}
    `, l = {
      "wy-reactions-line": !0,
      "wy-reactions-line-reverse": this.lineReverse,
      "wy-reactions-line-bottom": this.lineBottom,
      "wy-reactions-line-below": this.lineBelow
    };
    return this.line || this.lineReverse || this.lineBottom || this.lineBelow ? h`
          <div part=${J(l)}>${o}</div>
          ${c}
        ` : [o, c];
  }
  firstUpdated(t) {
    this.menuRef.value?.addEventListener(
      this.menuRef.value.popover ? "toggle" : "click",
      (e) => this.handleClose(e)
    );
  }
  disconnectedCallback() {
    this._computePositionCleanup?.(), super.disconnectedCallback();
  }
}, a(mo, "WyReactions"), mo);
Xt.styles = [Ht, n4, Vv, X];
oe([
  u()
], Xt.prototype, "directionX", 2);
oe([
  u()
], Xt.prototype, "directionY", 2);
oe([
  u({ type: Boolean })
], Xt.prototype, "small", 2);
oe([
  u({ attribute: !1 })
], Xt.prototype, "reactions", 2);
oe([
  u({ attribute: !1 })
], Xt.prototype, "emojis", 2);
oe([
  u({ type: String })
], Xt.prototype, "parentType", 2);
oe([
  u({ attribute: !0, type: Number })
], Xt.prototype, "parentId", 2);
oe([
  u({ attribute: !0, type: String })
], Xt.prototype, "entityType", 2);
oe([
  u({ attribute: !0, type: Number })
], Xt.prototype, "entityId", 2);
oe([
  u({ type: Boolean })
], Xt.prototype, "line", 2);
oe([
  u({ type: Boolean })
], Xt.prototype, "lineReverse", 2);
oe([
  u({ type: Boolean })
], Xt.prototype, "lineBottom", 2);
oe([
  u({ type: Boolean })
], Xt.prototype, "lineBelow", 2);
oe([
  D()
], Xt.prototype, "_placement", 2);
oe([
  D()
], Xt.prototype, "reactedEmoji", 2);
oe([
  D()
], Xt.prototype, "show", 2);
oe([
  D()
], Xt.prototype, "showSheet", 2);
Xt = oe([
  B("wy-reactions"),
  ht()
], Xt);
var vo;
let Il = (vo = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this);
  }
  render() {
    return h`
      <wy-item>
        <wy-avatar
          slot="image"
          .src=${this.reaction.created_by?.avatar_url}
          .name=${this.reaction.created_by?.name}
        ></wy-avatar>
        <span slot="title">${this.reaction.created_by?.name}</span>
        <span slot="actions" part="wy-emoji-icon">${this.reaction.content}</span>
      </wy-item>
    `;
  }
}, a(vo, "WyReactionItem"), vo);
Il.styles = [Ht, Vv];
oe([
  u({ attribute: !1 })
], Il.prototype, "reaction", 2);
Il = oe([
  B("wy-reaction-item")
], Il);
const o4 = j`[part~=wy-preview]{--wy-component-background-color: var(--wy-background, var(--wy-background-light, #f7f9ff));--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;box-sizing:border-box;align-items:stretch;justify-content:stretch;position:relative;flex:1 1 100%;min-width:calc(16*var(--wy-size, 1rem));min-height:calc(16*var(--wy-size, 1rem));max-height:100%;max-width:100%}[part~=wy-preview-layout]{width:100%;height:100%}[part~=wy-preview-main]{display:flex;height:calc(100% - var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem))))));min-height:0}@container (inline-size < 768px){[part~=wy-preview-main]{flex-direction:column}}[part~=wy-preview-swiper]{display:flex;flex-direction:row;flex:1 1 100%;align-items:center;justify-content:start;min-width:calc(16*var(--wy-size, 1rem));min-height:calc(16*var(--wy-size, 1rem));max-height:100%;max-width:100%;overflow-x:scroll;scroll-snap-type:x mandatory;scroll-behavior:auto;overscroll-behavior-x:none;scrollbar-width:none}[part~=wy-preview-swiper]::-webkit-scrollbar{display:none}[part~=wy-preview-swiper-disabled]{overflow-x:hidden}[part~=wy-preview-area]{position:relative;min-width:100%;min-height:100%;width:100%;height:100%;flex:1 1 auto;display:flex;flex-direction:column;scroll-snap-stop:always;scroll-snap-align:center}[part~=wy-nav-prev],[part~=wy-nav-next]{--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));background-color:var(--wy-component-background-color);position:absolute;top:50%;z-index:1000;border-radius:50%}[part~=wy-nav-prev]{left:calc(.5*var(--wy-size, 1rem))}[part~=wy-nav-next]{right:calc(.5*var(--wy-size, 1rem))}`, c4 = j`[part~=wy-sidebar]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background:var(--wy-component-background-color);color:var(--wy-component-color);min-width:0;min-height:0;flex-grow:0;flex-shrink:0;flex-basis:calc(22*var(--wy-size, 1rem));z-index:10;display:flex;flex-direction:column;transition:flex-basis var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));position:relative;order:9999;overflow:clip}[part~=wy-sidebar]>*{transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) - var(--wy-transition-duration-fast, .1s));min-width:calc(22*var(--wy-size, 1rem))}[part~=wy-sidebar][hidden]{display:flex!important;flex-basis:0}[part~=wy-sidebar][hidden]>*{transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));opacity:0}@container (inline-size >= 768px){[part~=wy-sidebar]>*{min-width:calc(22*var(--wy-size, 1rem))}[part~=wy-sidebar] [part~=wy-sidebar-handle]{display:none}}@container (inline-size < 768px){[part~=wy-sidebar]{transition:flex-basis var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),margin-top var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));border-top-left-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-top-right-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));flex-basis:50vh}[part~=wy-sidebar]:not([hidden]){margin-top:calc(-1*var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-sidebar]:not([hidden])[part~=wy-maximized]{flex-basis:calc(100% - var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))*.5);margin-top:calc(-50% + var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))*2.5 - var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-sidebar]:not([hidden])[part~=wy-maximized]~* [part~=wy-nav-prev],[part~=wy-sidebar]:not([hidden])[part~=wy-maximized]~* [part~=wy-nav-next]{display:none}[part~=wy-sidebar]>*{min-height:var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))}}[part~=wy-sidebar-handle]{width:calc(4*var(--wy-size, 1rem));background-clip:content-box;background-color:var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));height:calc(1*var(--wy-size, 1rem));border:calc(.375*var(--wy-size, 1rem)) solid rgba(0,0,0,0);position:absolute;top:0;z-index:2;left:50%;margin-left:calc(-2*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));cursor:pointer}`;
var l4 = Object.defineProperty, d4 = Object.getOwnPropertyDescriptor, Dh = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? d4(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && l4(t, e, r), r;
}, "__decorateClass$T"), go;
let In = (go = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this);
  }
  /**
   * Dispatch `file-preview-loaded` when the fallback content is ready.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  render() {
    const t = this.icon, e = ud(this.provider);
    return h`
      <wy-icon-display fill>
        <wy-icon name=${t} .overlayName=${e}></wy-icon>
        <span slot="text">
          ${this.provider ? h`
                <p>${x("No preview available :(")} </p>
                <wy-button kind="filled" color="variant" href=${this.src} target="_blank">${x(gt`Open in ${this.provider}`)}</wy-button>
              ` : h`<div>${x("No preview available :(")}</div>`}
        </span>
      </wy-icon-display>
    `;
  }
  updated(t) {
    (t.has("icon") || t.has("src")) && (this.icon || this.src) && this.dispatchLoaded();
  }
}, a(go, "WyPreviewIcon"), go);
In.styles = [
  X
];
Dh([
  u()
], In.prototype, "src", 2);
Dh([
  u()
], In.prototype, "icon", 2);
Dh([
  u()
], In.prototype, "provider", 2);
In = Dh([
  B("wy-preview-icon"),
  ht()
], In);
const h4 = j`[part~=wy-content-image]{min-width:0;display:flex;align-items:center;justify-content:center;position:relative;margin:auto;box-sizing:border-box;max-height:100%;max-width:100%;transition:transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform-origin var(--wy-transition-duration, .2s) step-end}[part~=wy-content-image][part~=wy-zoom]{cursor:zoom-out;transition:transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform-origin var(--wy-transition-duration, .2s) step-start}[part~=wy-content-image-img]{min-width:0;min-height:0;width:100%;height:100%}[part~=wy-content-image-img][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-content-image-img][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-content-image-img][part~=wy-loading][part~=wy-loaded]~[part~=wy-content-progress]{display:none}[part~=wy-content-image-img]~[part~=wy-content-progress]{position:absolute}`;
var u4 = Object.defineProperty, p4 = Object.getOwnPropertyDescriptor, Vh = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? p4(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && u4(t, e, r), r;
}, "__decorateClass$S"), bo;
let Fn = (bo = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this);
  }
  /**
   * Dispatches the `file-preview-loaded` event once the image has loaded.
   *
   * @internal
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  render() {
    const t = !!(this.width && this.height), e = t ? { "--width": this.width, "--height": this.height } : {};
    return h`
      <div part="wy-content-image ${J({ "wy-intrinsic-image": !t })}" style=${kl(e)}>
        <img
          part="wy-content-image-img"
          src=${this.src}
          ${Q(Ry)}
          @load=${(i) => {
      Ty(i), this.dispatchLoaded();
    }}
          width=${dt(this.width)}
          height=${dt(this.height)}
          decoding="async"
          alt=${x("Preview")}
        />
        ${t ? h`<wy-progress-circular part="wy-content-progress" indeterminate overlay></wy-progress-circular>` : b}
      </div>
    `;
  }
}, a(bo, "WyPreviewImage"), bo);
Fn.styles = [h4, X];
Vh([
  u()
], Fn.prototype, "src", 2);
Vh([
  u({ type: Number })
], Fn.prototype, "width", 2);
Vh([
  u({ type: Number })
], Fn.prototype, "height", 2);
Fn = Vh([
  B("wy-preview-image"),
  ht()
], Fn);
function Hv(n) {
  (n.classList.contains("wy-loading") || n.part.contains("wy-loading")) && (n.classList.add("wy-loaded"), n.part.add("wy-loaded")), n.classList.add("wy-error"), n.part.add("wy-error"), n.outerHTML = n.outerHTML.replace(/<(video|audio)/, "<div").replace(/(video|audio)>/, "div>");
}
a(Hv, "mediaFallback");
function y4(n) {
  const t = n.target;
  (t.tagName === "VIDEO" || t.tagName === "AUDIO") && (t.classList.contains("wy-loading") || t.part.contains("wy-loading")) && (t.classList.add("wy-loaded"), t.part.add("wy-loaded"));
}
a(y4, "mediaLoaded");
function Of(n) {
  const t = n.target;
  if (t.tagName === "SOURCE" && t.parentNode) {
    const e = t.parentNode, i = parseInt(e.dataset.errors || "0") + 1;
    e.dataset.errors = i.toString(), e.querySelectorAll("source").length >= i && (console.warn(e.tagName.toLowerCase() + " source error, switching to fallback"), Hv(e));
  }
}
a(Of, "mediaError");
function zf(n) {
  const t = n.target;
  (t.tagName === "VIDEO" || t.tagName === "AUDIO") && (t.tagName === "VIDEO" && !t.videoWidth || t.tagName === "AUDIO" && !t.duration) && (console.warn(t.tagName.toLowerCase() + " track not available, switching to fallback"), Hv(t));
}
a(zf, "codecError");
const w4 = j`[part~=wy-content-video]{box-sizing:border-box}[part~=wy-content-video]:not([part~=wy-error]){min-height:0;max-width:100%;max-height:100%;flex:1 1 auto}[part~=wy-content-video],[part~=wy-content-audio]{margin:auto}[part~=wy-content-video][part~=wy-loading]:not([part~=wy-loaded]),[part~=wy-content-audio][part~=wy-loading]:not([part~=wy-loaded]){visibility:hidden}[part~=wy-content-video][part~=wy-loading][part~=wy-loaded]~[part~=wy-content-progress],[part~=wy-content-audio][part~=wy-loading][part~=wy-loaded]~[part~=wy-content-progress]{display:none}[part~=wy-content-video]:focus,[part~=wy-content-audio]:focus{outline:none}`;
var f4 = Object.defineProperty, m4 = Object.getOwnPropertyDescriptor, Jc = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? m4(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && f4(t, e, r), r;
}, "__decorateClass$R"), xo;
let or = (xo = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.format = "", this.play = !1, this.name = "", this.handleLoaded = (t) => {
      y4(t), this.dispatchLoaded();
    };
  }
  /**
   * Dispatches the `file-preview-loaded` event after the media metadata becomes available.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  /**
   * Registers load and error listeners on the provided media element.
   *
   * @internal
   * @param mediaElement - Media element to observe.
   */
  registerLoading(t) {
    this.unregisterLoading(), t && (this.mediaElement = t, t.part.add("wy-loading"), t.addEventListener("error", Of, !0), t.addEventListener("loadedmetadata", this.handleLoaded, !0), t.addEventListener("loadedmetadata", zf, !0));
  }
  /**
   * Cleans up listeners and state from the previously registered media element.
   *
   * @internal
   */
  unregisterLoading() {
    this.mediaElement && (this.mediaElement.pause(), this.mediaElement.removeAttribute("autoplay"), this.mediaElement.setAttribute("preload", "none"), this.mediaElement.removeEventListener("error", Of, !0), this.mediaElement.removeEventListener("loadedmetadata", this.handleLoaded, !0), this.mediaElement.removeEventListener("loadedmetadata", zf, !0), this.mediaElement = void 0);
  }
  render() {
    return this.format === "video" ? h`
          <video ${Q((t) => this.registerLoading(t))} part="wy-content-video" controls crossorigin="use-credentials">
            <source src=${this.src} type=${dt(this.mediaType)} />
            <wy-preview-icon src=${this.src} icon="file-video"></wy-preview-icon>
          </video>
          <wy-progress-circular part="wy-content-progress" indeterminate overlay></wy-progress-circular>
        ` : h`
          <audio ${Q((t) => this.registerLoading(t))} part="wy-content-audio" controls crossorigin="use-credentials">
            <source src=${this.src} type=${dt(this.mediaType)} />
          </audio>
        `;
  }
  updated(t) {
    super.updated(t), t.has("play") && this.mediaElement && (this.play ? this.mediaElement.play() : this.mediaElement.pause());
  }
  disconnectedCallback() {
    this.unregisterLoading(), super.disconnectedCallback();
  }
}, a(xo, "WyPreviewMedia"), xo);
or.styles = [
  w4,
  X
];
Jc([
  u()
], or.prototype, "format", 2);
Jc([
  u()
], or.prototype, "src", 2);
Jc([
  u({ type: Boolean })
], or.prototype, "play", 2);
Jc([
  u()
], or.prototype, "name", 2);
Jc([
  u()
], or.prototype, "mediaType", 2);
or = Jc([
  B("wy-preview-media")
], or);
const v4 = j`[part~=wy-content-code]{align-self:flex-start;box-sizing:border-box;width:100%;padding:calc(2*var(--wy-size, 1rem)) calc(3.5*var(--wy-size, 1rem));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}`, g4 = j`[part~=wy-content-text],[part~=wy-content-html] pre,[part~=wy-content-html] code{word-break:break-word;white-space:pre-wrap}[part~=wy-content-html] hr{border-color:var(--wy-outline, var(--wy-outline-light, #72777f));border-width:var(--wy-border, 1px) 0 0 0;border-style:solid}[part~=wy-content-html] h1,[part~=wy-content-html] h2,[part~=wy-content-html] h3,[part~=wy-content-html] h4,[part~=wy-content-html] h5,[part~=wy-content-html] h6{font-family:var(--wy-document-headings-font-family, var(--wy-headings-font-family, var(--wy-font-family, unset)));line-height:var(--wy-document-headings-line-height, var(--wy-headings-line-height, var(--wy-line-height, 1.5)))}[part~=wy-content-html] h1{font-size:var(--wy-document-h1-font-size, calc(2 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h1-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h1-margin, 0 0 var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-content-html] h2{font-size:var(--wy-document-h2-font-size, calc(1.5 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h2-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h2-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content-html] h3{font-size:var(--wy-document-h3-font-size, calc(1.25 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h3-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h3-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content-html] h4{font-size:var(--wy-document-h4-font-size, calc(1.125 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h4-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h4-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 0)}[part~=wy-content-html] h5{font-size:var(--wy-document-h5-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-document-h5-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h5-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 0)}[part~=wy-content-html] h6{font-size:var(--wy-document-h6-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-document-h6-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h6-margin, 0)}`, b4 = j`[part~=wy-document]{--wy-component-background-color: var(--wy-background, var(--wy-background-light, #f7f9ff));--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);align-self:flex-start;padding:calc(2*var(--wy-size, 1rem)) calc(3.5*var(--wy-size, 1rem));box-sizing:border-box;width:100%;min-height:100%;flex:1 0 auto}@container (inline-size >= 768px){[part~=wy-document]{padding:calc(3*var(--wy-size, 1rem)) calc(4*var(--wy-size, 1rem));margin:calc(2*var(--wy-size, 1rem)) auto;border-radius:calc(.125*var(--wy-size, 1rem));box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));width:120ch;min-height:170ch;max-width:calc(100% - 3.5*var(--wy-size, 1rem))}}`, x4 = j`[part~=wy-code] pre,.wy-code pre{text-wrap:pretty}[part~=wy-code] .code,[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code .code,.wy-code code[class*=language-],.wy-code pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;word-wrap:break-word;line-height:1.25;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}@media print{[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code code[class*=language-],.wy-code pre[class*=language-]{text-shadow:none}}[part~=wy-code] pre[class*=language-],.wy-code pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}[part~=wy-code] :not(pre)>code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code :not(pre)>code[class*=language-],.wy-code pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));background:var(--wy-background, var(--wy-background-light, #f7f9ff))}[part~=wy-code] :not(pre)>code[class*=language-],.wy-code :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}[part~=wy-code] .token.variable,.wy-code .token.variable{color:var(--wy-code-variable, var(--wy-code-variable-light, #001080))}[part~=wy-code] .token.operator,.wy-code .token.operator{color:var(--wy-code-operator, var(--wy-code-operator-light, #000000))}[part~=wy-code] .token.prolog,.wy-code .token.prolog{color:var(--wy-code-prolog, var(--wy-code-prolog-light, #000080))}[part~=wy-code] .token.comment,.wy-code .token.comment{color:var(--wy-code-comment, var(--wy-code-comment-light, #008000))}[part~=wy-code] .token.builtin,.wy-code .token.builtin{color:var(--wy-code-builtin, var(--wy-code-builtin-light, #0070C1))}[part~=wy-code] .token.number,.wy-code .token.number{color:var(--wy-code-number, var(--wy-code-number-light, #098658))}[part~=wy-code] .token.inserted,.wy-code .token.inserted{color:var(--wy-code-inserted, var(--wy-code-inserted-light, #098658))}[part~=wy-code] .token.constant,.wy-code .token.constant{color:var(--wy-code-constant, var(--wy-code-constant-light, #811F3F))}[part~=wy-code] .token.hexcode,.wy-code .token.hexcode{color:var(--wy-code-hexcode, var(--wy-code-hexcode-light, #811F3F))}[part~=wy-code] .token.regex,.wy-code .token.regex{color:var(--wy-code-regex, var(--wy-code-regex-light, #811F3F))}[part~=wy-code] .token.char,.wy-code .token.char{color:var(--wy-code-char, var(--wy-code-char-light, #811F3F))}[part~=wy-code] .token.tag,.wy-code .token.tag{color:var(--wy-code-tag, var(--wy-code-tag-light, #800000))}[part~=wy-code] .token.attr-name,.wy-code .token.attr-name{color:var(--wy-code-attr-name, var(--wy-code-attr-name-light, #E50000))}[part~=wy-code] .token.selector,.wy-code .token.selector{color:var(--wy-code-selector, var(--wy-code-selector-light, #E50000))}[part~=wy-code] .token.property,.wy-code .token.property{color:var(--wy-code-property, var(--wy-code-property-light, #E50000))}[part~=wy-code] .token.deleted,.wy-code .token.deleted{color:var(--wy-code-deleted, var(--wy-code-deleted-light, #A31515))}[part~=wy-code] .token.string,.wy-code .token.string{color:var(--wy-code-string, var(--wy-code-string-light, #A31515))}[part~=wy-code] .token.changed,.wy-code .token.changed{color:var(--wy-code-changed, var(--wy-code-changed-light, #0451A5))}[part~=wy-code] .token.punctuation,.wy-code .token.punctuation{color:var(--wy-code-punctuation, var(--wy-code-punctuation-light, #000000))}[part~=wy-code] .token.function,.wy-code .token.function{color:var(--wy-code-function, var(--wy-code-function-light, #0000FF))}[part~=wy-code] .token.keyword,.wy-code .token.keyword{color:var(--wy-code-keyword, var(--wy-code-keyword-light, #AF00DB))}[part~=wy-code] .token.class-name,.wy-code .token.class-name{color:var(--wy-code-class-name, var(--wy-code-class-name-light, #267F99))}[part~=wy-code] .token.important,[part~=wy-code] .token.bold,.wy-code .token.important,.wy-code .token.bold{font-weight:700}[part~=wy-code] .token.italic,.wy-code .token.italic{font-style:italic}`;
var C4 = Object.defineProperty, $4 = Object.getOwnPropertyDescriptor, ta = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? $4(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && C4(t, e, r), r;
}, "__decorateClass$Q"), Co;
let zi = (Co = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.html = !1, this.code = !1, this.textOrHtmlContent = "", this.loading = !0;
  }
  /**
   * Dispatches the `file-preview-loaded` event when content becomes available.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  updated(t) {
    super.updated(t), (t.has("weavy") || t.has("src")) && this.weavy && (this.loading = !0, this.weavy.fetchOptions().then((e) => fetch(this.src, e)).then(N1).then((e) => new Response(e)).then((e) => e.text()).then((e) => {
      this.loading = !1, this.textOrHtmlContent = e, this.dispatchLoaded();
    }));
  }
  render() {
    return this.loading ? h` <wy-empty><wy-progress-circular part="wy-content-progress" indeterminate></wy-progress-circular></wy-empty> ` : this.html ? this.code ? h` <div part="wy-content-code wy-code">${An(this.textOrHtmlContent)}</div> ` : h`
            <div part="wy-document wy-light">
              <div part="wy-content-html">${An(this.textOrHtmlContent)}</div>
            </div>
          ` : this.code ? h` <div part="wy-content-code">${this.textOrHtmlContent}</div> ` : h`
          <div part="wy-document wy-light">
            <pre part="wy-content-text">${this.textOrHtmlContent}</pre>
          </div>
        `;
  }
}, a(Co, "WyPreviewText"), Co);
zi.styles = [se, g4, v4, b4, x4, X];
ta([
  be({ context: he, subscribe: !0 }),
  D()
], zi.prototype, "weavy", 2);
ta([
  u()
], zi.prototype, "src", 2);
ta([
  u({ type: Boolean })
], zi.prototype, "html", 2);
ta([
  u({ type: Boolean })
], zi.prototype, "code", 2);
ta([
  D()
], zi.prototype, "textOrHtmlContent", 2);
ta([
  D()
], zi.prototype, "loading", 2);
zi = ta([
  B("wy-preview-text")
], zi);
const k4 = j`[part~=wy-content-embed]{border:0;display:block;box-sizing:border-box;width:100%;height:100%;top:0;left:0;flex:1 1 100%}[part~=wy-content-embed][part~=wy-loaded]{--wy-component-background-color: var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}[part~=wy-content-embed][part~=wy-loaded]~[part~=wy-content-embed-fallback],[part~=wy-content-embed][part~=wy-loaded]~[part~=wy-content-progress]{display:none}[part~=wy-content-embed][part~=wy-loading]:not([part~=wy-loaded]){position:absolute;visibility:hidden;z-index:-1;pointer-events:none}[part~=wy-content-embed][part~=wy-loading]:not([part~=wy-loaded]):not([part~=wy-fallback])~[part~=wy-content-embed-fallback]{display:none}[part~=wy-content-embed][part~=wy-loading]:not([part~=wy-loaded])[part~=wy-fallback]~[part~=wy-content-progress]{display:none}`;
var P4 = Object.defineProperty, _4 = Object.getOwnPropertyDescriptor, gd = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? _4(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && P4(t, e, r), r;
}, "__decorateClass$P"), $o;
let jr = ($o = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this);
  }
  /**
   * Emit `file-preview-loaded` once the preview has finished loading.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  /**
   * Attach load listeners and register the provided embed element.
   *
   * @internal
   * @param embedElement - Newly rendered embed element.
   */
  registerLoading(t) {
    if (this.unregisterLoading?.(), t) {
      this.embedElement = t, t.part.add("wy-loading");
      const e = window.setTimeout(() => {
        t.part.add("wy-fallback"), this.dispatchLoaded();
      }, 2500), i = /* @__PURE__ */ a((r) => {
        const s = r.target;
        s.tagName === "OBJECT" && s.part.contains("wy-loading") && !s.part.contains("wy-loaded") && (s.part.add("wy-loaded"), window.clearTimeout(e), this.dispatchLoaded());
      }, "embedLoaded");
      t.addEventListener("load", i, !0), this.unregisterLoading = () => {
        this.embedElement && (t.removeEventListener("load", i, !0), window.clearTimeout(e), this.embedElement = void 0);
      };
    }
  }
  render() {
    return h`
      <object title=${x("Preview")} ${Q((t) => this.registerLoading(t))} part="wy-content-embed" data=${this.src}></object>
      <wy-progress-circular part="wy-content-progress" indeterminate overlay></wy-progress-circular>
      <wy-preview-icon
        src=${this.src}
        icon=${this.icon}
        provider=${dt(this.provider)}
        part="wy-content-embed-fallback"></wy-preview-icon>
    `;
  }
  disconnectedCallback() {
    this.unregisterLoading?.(), super.disconnectedCallback();
  }
}, a($o, "WyPreviewEmbed"), $o);
jr.styles = [
  k4,
  X
];
gd([
  u()
], jr.prototype, "src", 2);
gd([
  u()
], jr.prototype, "name", 2);
gd([
  u()
], jr.prototype, "icon", 2);
gd([
  u()
], jr.prototype, "provider", 2);
jr = gd([
  B("wy-preview-embed"),
  ht()
], jr);
const S4 = j`.wy-pdf-container{position:absolute;width:100%;height:100%;bottom:0;left:0}.wy-pdf-container{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-pdf-container:not(body){-webkit-overflow-scrolling:touch}.wy-pdf-container{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-pdf-container{overflow-y:auto;overflow-x:auto;touch-action:pan-y,pan-x}.wy-content-pdf .textLayer{position:absolute;text-align:initial;inset:0;overflow:clip;opacity:1;line-height:1;text-size-adjust:none;forced-color-adjust:none;transform-origin:0 0;caret-color:CanvasText;z-index:0}.wy-content-pdf .textLayer.highlighting{touch-action:none}.wy-content-pdf .textLayer :is(span,br){color:#0000;position:absolute;white-space:pre;cursor:text;transform-origin:0% 0%}.wy-content-pdf .textLayer>:not(.markedContent),.wy-content-pdf .textLayer .markedContent span:not(.markedContent){z-index:1}.wy-content-pdf .textLayer span.markedContent{top:0;height:0}.wy-content-pdf .textLayer span[role=img]{-webkit-user-select:none;user-select:none;cursor:default}.wy-content-pdf .textLayer .highlight{--highlight-bg-color: rgb(180 0 170 / .25);--highlight-selected-bg-color: rgb(0 100 0 / .25);--highlight-backdrop-filter: none;--highlight-selected-backdrop-filter: none}@media screen and (forced-colors:active){.wy-content-pdf .textLayer .highlight{--highlight-bg-color: transparent;--highlight-selected-bg-color: transparent;--highlight-backdrop-filter: var(--hcm-highlight-filter);--highlight-selected-backdrop-filter: var(--hcm-highlight-selected-filter)}}.wy-content-pdf .textLayer .highlight{margin:-1px;padding:1px;background-color:var(--highlight-bg-color);-webkit-backdrop-filter:var(--highlight-backdrop-filter);backdrop-filter:var(--highlight-backdrop-filter);border-radius:4px}.wy-content-pdf .textLayer .highlight.appended{position:initial}.wy-content-pdf .textLayer .highlight.begin{border-radius:4px 0 0 4px}.wy-content-pdf .textLayer .highlight.end{border-radius:0 4px 4px 0}.wy-content-pdf .textLayer .highlight.middle{border-radius:0}.wy-content-pdf .textLayer .highlight.selected{background-color:var(--highlight-selected-bg-color);-webkit-backdrop-filter:var(--highlight-selected-backdrop-filter);backdrop-filter:var(--highlight-selected-backdrop-filter)}.wy-content-pdf .textLayer ::selection{background:#0000ff40;background:color-mix(in srgb,AccentColor,transparent 75%)}.wy-content-pdf .textLayer br::selection{background:#0000}.wy-content-pdf .textLayer .endOfContent{display:block;position:absolute;inset:100% 0 0;z-index:0;cursor:default;-webkit-user-select:none;user-select:none}.wy-content-pdf .textLayer.selecting .endOfContent{top:0}.wy-content-pdf .annotationLayer{--annotation-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\");--input-focus-border-color: Highlight;--input-focus-outline: 1px solid Canvas;--input-unfocused-border-color: transparent;--input-disabled-border-color: transparent;--input-hover-border-color: black;--link-outline: none}@media screen and (forced-colors:active){.wy-content-pdf .annotationLayer{--input-focus-border-color: CanvasText;--input-unfocused-border-color: ActiveText;--input-disabled-border-color: GrayText;--input-hover-border-color: Highlight;--link-outline: 1.5px solid LinkText}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):required,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:required,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:required{outline:1.5px solid selectedItem}.wy-content-pdf .annotationLayer .linkAnnotation{outline:var(--link-outline)}.wy-content-pdf .annotationLayer .linkAnnotation:hover{-webkit-backdrop-filter:var(--hcm-highlight-filter);backdrop-filter:var(--hcm-highlight-filter)}.wy-content-pdf .annotationLayer .linkAnnotation>a:hover{opacity:0!important;background:none!important;box-shadow:none}.wy-content-pdf .annotationLayer .popupAnnotation .popup{outline:calc(1.5px*var(--scale-factor)) solid CanvasText!important;background-color:ButtonFace!important;color:ButtonText!important}.wy-content-pdf .annotationLayer .highlightArea:hover:after{position:absolute;top:0;left:0;width:100%;height:100%;-webkit-backdrop-filter:var(--hcm-highlight-filter);backdrop-filter:var(--hcm-highlight-filter);content:\"\";pointer-events:none}.wy-content-pdf .annotationLayer .popupAnnotation.focused .popup{outline:calc(3px*var(--scale-factor)) solid Highlight!important}}.wy-content-pdf .annotationLayer{position:absolute;top:0;left:0;pointer-events:none;transform-origin:0 0}.wy-content-pdf .annotationLayer[data-main-rotation=\"90\"] .norotate{transform:rotate(270deg) translate(-100%)}.wy-content-pdf .annotationLayer[data-main-rotation=\"180\"] .norotate{transform:rotate(180deg) translate(-100%,-100%)}.wy-content-pdf .annotationLayer[data-main-rotation=\"270\"] .norotate{transform:rotate(90deg) translateY(-100%)}.wy-content-pdf .annotationLayer.disabled section,.wy-content-pdf .annotationLayer.disabled .popup{pointer-events:none}.wy-content-pdf .annotationLayer .annotationContent{position:absolute;width:100%;height:100%;pointer-events:none}.wy-content-pdf .annotationLayer .annotationContent.freetext{background:#0000;border:none;inset:0;overflow:visible;white-space:nowrap;font:10px sans-serif;line-height:1.35;-webkit-user-select:none;user-select:none}.wy-content-pdf .annotationLayer section{position:absolute;text-align:initial;pointer-events:auto;box-sizing:border-box;transform-origin:0 0}.wy-content-pdf .annotationLayer section:has(div.annotationContent) canvas.annotationContent{display:none}.textLayer.selecting~.wy-content-pdf .annotationLayer section{pointer-events:none}.wy-content-pdf .annotationLayer :is(.linkAnnotation,.buttonWidgetAnnotation.pushButton)>a{position:absolute;font-size:1em;top:0;left:0;width:100%;height:100%}.wy-content-pdf .annotationLayer :is(.linkAnnotation,.buttonWidgetAnnotation.pushButton):not(.hasBorder)>a:hover{opacity:.2;background-color:#ff0;box-shadow:0 2px 10px #ff0}.wy-content-pdf .annotationLayer .linkAnnotation.hasBorder:hover{background-color:#ff03}.wy-content-pdf .annotationLayer .hasBorder{background-size:100% 100%}.wy-content-pdf .annotationLayer .textAnnotation img{position:absolute;cursor:pointer;width:100%;height:100%;top:0;left:0}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea),.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input{background-image:var(--annotation-unfocused-field-background);border:2px solid var(--input-unfocused-border-color);box-sizing:border-box;font:calc(9px*var(--scale-factor)) sans-serif;height:100%;margin:0;vertical-align:top;width:100%}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):required,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:required,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:required{outline:1.5px solid red}.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select option{padding:0}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input{border-radius:50%}.wy-content-pdf .annotationLayer .textWidgetAnnotation textarea{resize:none}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea)[disabled],.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select[disabled],.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input[disabled]{background:none;border:2px solid var(--input-disabled-border-color);cursor:not-allowed}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):hover,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:hover,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:hover{border:2px solid var(--input-hover-border-color)}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):hover,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:hover,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:hover{border-radius:2px}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):focus,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:focus{background:none;border:2px solid var(--input-focus-border-color);border-radius:2px;outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) :focus{background-image:none;background-color:#0000}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox :focus{border:2px solid var(--input-focus-border-color);border-radius:2px;outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton :focus{border:2px solid var(--input-focus-border-color);outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{background-color:CanvasText;content:\"\";display:block;position:absolute}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{height:80%;left:45%;width:1px}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{transform:rotate(45deg)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{transform:rotate(-45deg)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{border-radius:50%;height:50%;left:25%;top:25%;width:50%}.wy-content-pdf .annotationLayer .textWidgetAnnotation input.comb{font-family:monospace;padding-left:2px;padding-right:0}.wy-content-pdf .annotationLayer .textWidgetAnnotation input.comb:focus{width:103%}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input{appearance:none}.wy-content-pdf .annotationLayer .fileAttachmentAnnotation .popupTriggerArea{height:100%;width:100%}.wy-content-pdf .annotationLayer .popupAnnotation{position:absolute;font-size:calc(9px*var(--scale-factor));pointer-events:none;width:max-content;max-width:45%;height:auto}.wy-content-pdf .annotationLayer .popup{background-color:#ff9;box-shadow:0 calc(2px*var(--scale-factor)) calc(5px*var(--scale-factor)) #888;border-radius:calc(2px*var(--scale-factor));outline:1.5px solid #ffff4a;padding:calc(6px*var(--scale-factor));cursor:pointer;font:message-box;white-space:normal;word-wrap:break-word;pointer-events:auto}.wy-content-pdf .annotationLayer .popupAnnotation.focused .popup{outline-width:3px}.wy-content-pdf .annotationLayer .popup *{font-size:calc(9px*var(--scale-factor))}.wy-content-pdf .annotationLayer .popup>.header{display:inline-block}.wy-content-pdf .annotationLayer .popup>.header h1{display:inline}.wy-content-pdf .annotationLayer .popup>.header .popupDate{display:inline-block;margin-left:calc(5px*var(--scale-factor));width:fit-content}.wy-content-pdf .annotationLayer .popupContent{border-top:1px solid #333;margin-top:calc(2px*var(--scale-factor));padding-top:calc(2px*var(--scale-factor))}.wy-content-pdf .annotationLayer .richText>*{white-space:pre-wrap;font-size:calc(9px*var(--scale-factor))}.wy-content-pdf .annotationLayer .popupTriggerArea{cursor:pointer}.wy-content-pdf .annotationLayer section svg{position:absolute;width:100%;height:100%;top:0;left:0}.wy-content-pdf .annotationLayer .annotationTextContent{position:absolute;width:100%;height:100%;opacity:0;color:#0000;-webkit-user-select:none;user-select:none;pointer-events:none}.wy-content-pdf .annotationLayer .annotationTextContent span{width:100%;display:inline-block}.wy-content-pdf .annotationLayer svg.quadrilateralsContainer{contain:strict;width:0;height:0;position:absolute;top:0;left:0;z-index:-1}:host{--xfa-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\");--xfa-focus-outline: auto}@media screen and (forced-colors:active){:host{--xfa-focus-outline: 2px solid CanvasText}.wy-content-pdf .xfaLayer *:required{outline:1.5px solid selectedItem}}.wy-content-pdf .xfaLayer{background-color:#0000}.wy-content-pdf .xfaLayer .highlight{margin:-1px;padding:1px;background-color:#efcbed;border-radius:4px}.wy-content-pdf .xfaLayer .highlight.appended{position:initial}.wy-content-pdf .xfaLayer .highlight.begin{border-radius:4px 0 0 4px}.wy-content-pdf .xfaLayer .highlight.end{border-radius:0 4px 4px 0}.wy-content-pdf .xfaLayer .highlight.middle{border-radius:0}.wy-content-pdf .xfaLayer .highlight.selected{background-color:#cbdfcb}.wy-content-pdf .xfaPage{overflow:hidden;position:relative}.wy-content-pdf .xfaContentarea{position:absolute}.wy-content-pdf .xfaPrintOnly{display:none}.wy-content-pdf .xfaLayer{position:absolute;text-align:initial;top:0;left:0;transform-origin:0 0;line-height:1.2}.wy-content-pdf .xfaLayer *{color:inherit;font:inherit;font-style:inherit;font-weight:inherit;font-kerning:inherit;letter-spacing:-.01px;text-align:inherit;text-decoration:inherit;box-sizing:border-box;background-color:#0000;padding:0;margin:0;pointer-events:auto;line-height:inherit}.wy-content-pdf .xfaLayer *:required{outline:1.5px solid red}.wy-content-pdf .xfaLayer div,.wy-content-pdf .xfaLayer svg,.wy-content-pdf .xfaLayer svg *{pointer-events:none}.wy-content-pdf .xfaLayer a{color:#00f}.wy-content-pdf .xfaRich li{margin-left:3em}.wy-content-pdf .xfaFont{color:#000;font-weight:400;font-kerning:none;font-size:10px;font-style:normal;letter-spacing:0;text-decoration:none;vertical-align:0}.wy-content-pdf .xfaCaption{overflow:hidden;flex:0 0 auto}.wy-content-pdf .xfaCaptionForCheckButton{overflow:hidden;flex:1 1 auto}.wy-content-pdf .xfaLabel{height:100%;width:100%}.wy-content-pdf .xfaLeft{display:flex;flex-direction:row;align-items:center}.wy-content-pdf .xfaRight{display:flex;flex-direction:row-reverse;align-items:center}.wy-content-pdf :is(.xfaLeft,.xfaRight)>:is(.xfaCaption,.xfaCaptionForCheckButton){max-height:100%}.wy-content-pdf .xfaTop{display:flex;flex-direction:column;align-items:flex-start}.wy-content-pdf .xfaBottom{display:flex;flex-direction:column-reverse;align-items:flex-start}.wy-content-pdf :is(.xfaTop,.xfaBottom)>:is(.xfaCaption,.xfaCaptionForCheckButton){width:100%}.wy-content-pdf .xfaBorder{background-color:#0000;position:absolute;pointer-events:none}.wy-content-pdf .xfaWrapped{width:100%;height:100%}.wy-content-pdf :is(.xfaTextfield,.xfaSelect):focus{background-image:none;background-color:#0000;outline:var(--xfa-focus-outline);outline-offset:-1px}.wy-content-pdf :is(.xfaCheckbox,.xfaRadio):focus{outline:var(--xfa-focus-outline)}.wy-content-pdf .xfaTextfield,.wy-content-pdf .xfaSelect{height:100%;width:100%;flex:1 1 auto;border:none;resize:none;background-image:var(--xfa-unfocused-field-background)}.wy-content-pdf .xfaSelect{padding-inline:2px}.wy-content-pdf :is(.xfaTop,.xfaBottom)>:is(.xfaTextfield,.xfaSelect){flex:0 1 auto}.wy-content-pdf .xfaButton{cursor:pointer;width:100%;height:100%;border:none;text-align:center}.wy-content-pdf .xfaLink{width:100%;height:100%;position:absolute;top:0;left:0}.wy-content-pdf .xfaCheckbox,.wy-content-pdf .xfaRadio{width:100%;height:100%;flex:0 0 auto;border:none}.wy-content-pdf .xfaRich{white-space:pre-wrap;width:100%;height:100%}.wy-content-pdf .xfaImage{object-position:left top;object-fit:contain;width:100%;height:100%}.wy-content-pdf .xfaLrTb,.wy-content-pdf .xfaRlTb,.wy-content-pdf .xfaTb{display:flex;flex-direction:column;align-items:stretch}.wy-content-pdf .xfaLr{display:flex;flex-direction:row;align-items:stretch}.wy-content-pdf .xfaRl{display:flex;flex-direction:row-reverse;align-items:stretch}.wy-content-pdf .xfaTb>div{justify-content:left}.wy-content-pdf .xfaPosition,.wy-content-pdf .xfaArea{position:relative}.wy-content-pdf .xfaValignMiddle{display:flex;align-items:center}.wy-content-pdf .xfaTable{display:flex;flex-direction:column;align-items:stretch}.wy-content-pdf .xfaTable .xfaRow{display:flex;flex-direction:row;align-items:stretch}.wy-content-pdf .xfaTable .xfaRlRow{display:flex;flex-direction:row-reverse;align-items:stretch;flex:1}.wy-content-pdf .xfaTable .xfaRlRow>div{flex:1}.wy-content-pdf :is(.xfaNonInteractive,.xfaDisabled,.xfaReadOnly) :is(input,textarea){background:initial}@media print{.wy-content-pdf .xfaTextfield,.wy-content-pdf .xfaSelect{background:#0000}.wy-content-pdf .xfaSelect{appearance:none;text-indent:1px;text-overflow:\"\"}}:host{--viewer-container-height: 0;--pdfViewer-padding-bottom: 0;--page-margin: 1px auto -8px;--page-border: 9px solid transparent;--spreadHorizontalWrapped-margin-LR: -3.5px;--loading-icon-delay: .4s}@media screen and (forced-colors:active){:host{--pdfViewer-padding-bottom: 9px;--page-margin: 8px auto -1px;--page-border: 1px solid CanvasText;--spreadHorizontalWrapped-margin-LR: 3.5px}}.wy-content-pdf [data-main-rotation=\"90\"]{transform:rotate(90deg) translateY(-100%)}.wy-content-pdf [data-main-rotation=\"180\"]{transform:rotate(180deg) translate(-100%,-100%)}.wy-content-pdf [data-main-rotation=\"270\"]{transform:rotate(270deg) translate(-100%)}.wy-content-pdf #hiddenCopyElement,.wy-content-pdf .hiddenCanvasElement{position:absolute;top:0;left:0;width:0;height:0;display:none}.wy-content-pdf .pdfViewer{--scale-factor: 1;--page-bg-color: unset;padding-bottom:var(--pdfViewer-padding-bottom);--hcm-highlight-filter: none;--hcm-highlight-selected-filter: none}@media screen and (forced-colors:active){.wy-content-pdf .pdfViewer{--hcm-highlight-filter: invert(100%)}}.wy-content-pdf .pdfViewer.copyAll{cursor:wait}.wy-content-pdf .pdfViewer .canvasWrapper{overflow:hidden;width:100%;height:100%}.wy-content-pdf .pdfViewer .canvasWrapper canvas{position:absolute;top:0;left:0;margin:0;display:block;width:100%;height:100%;contain:content}.wy-content-pdf .pdfViewer .canvasWrapper canvas .structTree{contain:strict}.wy-content-pdf .pdfViewer .page{--scale-round-x: 1px;--scale-round-y: 1px;direction:ltr;width:816px;height:1056px;margin:var(--page-margin);position:relative;overflow:visible;border:var(--page-border);background-clip:content-box;background-color:var(--page-bg-color, rgb(255, 255, 255))}.wy-content-pdf .pdfViewer .dummyPage{position:relative;width:0;height:var(--viewer-container-height)}.wy-content-pdf .pdfViewer.noUserSelect{-webkit-user-select:none;user-select:none}.wy-content-pdf .pdfViewer.removePageBorders .page{margin:0 auto 10px;border:none}.wy-content-pdf .pdfViewer.singlePageView{display:inline-block}.wy-content-pdf .pdfViewer.singlePageView .page{margin:0;border:none}.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped),.wy-content-pdf .spread{margin-inline:3.5px;text-align:center}.wy-content-pdf .pdfViewer.scrollHorizontal,.wy-content-pdf .spread{white-space:nowrap}.wy-content-pdf .pdfViewer.removePageBorders,.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) .spread{margin-inline:0}.wy-content-pdf .spread :is(.page,.dummyPage),.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) :is(.page,.spread){display:inline-block;vertical-align:middle}.wy-content-pdf .spread .page,.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) .page{margin-inline:var(--spreadHorizontalWrapped-margin-LR)}.wy-content-pdf .pdfViewer.removePageBorders .spread .page,.wy-content-pdf .pdfViewer.removePageBorders:is(.scrollHorizontal,.scrollWrapped) .page{margin-inline:5px}.wy-content-pdf .pdfViewer .page.loadingIcon:after{position:absolute;top:0;left:0;content:\"\";width:100%;height:100%;display:none;transition-property:display;transition-delay:var(--loading-icon-delay);z-index:5;contain:strict}.wy-content-pdf .pdfViewer .page.loading:after{display:block}.wy-content-pdf .pdfViewer .page:not(.loading):after{transition-property:none;display:none}.wy-content-pdf .pdfPresentationMode .pdfViewer{padding-bottom:0}.wy-content-pdf .pdfPresentationMode .spread{margin:0}.wy-content-pdf .pdfPresentationMode .pdfViewer .page{margin:0 auto;border:2px solid rgba(0,0,0,0)}.wy-content-pdf .pdfViewer .page{box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));background-color:var(--wy-white, var(--wy-white, #ffffff))}.wy-content-pdf .pdfViewer .page.loadingIcon:after{background:url(\"data:image/svg+xml,%3Csvg viewBox='0 0 24 24' width='24' height='24' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cstyle type='text/css'%3Eg%7Banimation:rotate 2s linear infinite;transform-origin:center center%7Dcircle%7Bstroke-dasharray:1,100;stroke-dashoffset:0;animation:dash 1.5s ease-in-out infinite,color 6s ease-in-out infinite%7D@keyframes rotate%7B100%25%7Btransform:rotate(360deg)%7D%7D@keyframes dash%7B0%25%7Bstroke-dasharray:1,100;stroke-dashoffset:0%7D50%25%7Bstroke-dasharray:44.5,100;stroke-dashoffset:-17.5px%7D100%25%7Bstroke-dasharray:44.5,100;stroke-dashoffset:-62px%7D%7D@keyframes color%7B0%25,100%25%7Bstroke:%23216eb4%7D40%25%7Bstroke:%2328b7cf%7D66%25%7Bstroke:%23216eb4%7D80%25,90%25%7Bstroke:%2328b7cf%7D%7D%3C/style%3E%3Cg%3E%3Ccircle fill='none' cx='12' cy='12' r='11' stroke-linecap='butt' stroke-width='2' /%3E%3C/g%3E%3C/svg%3E\") center no-repeat}.wy-pdf-page-number{width:calc(3*var(--wy-size, 1rem))}.wy-pdf-zoom-level{width:calc(5*var(--wy-size, 1rem))}`, Bv = j`[part~=wy-toolbar]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));box-sizing:border-box;display:flex;flex-wrap:wrap;align-items:center;justify-content:flex-start;justify-items:center;min-height:var(--wy-toolbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));padding:calc(.5*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));flex:1 0 var(--wy-toolbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));column-gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));line-height:var(--wy-line-height, 1.5);background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-component-border-radius)}[part~=wy-toolbar-center]{margin:0 auto;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-toolbar-buttons]{display:flex;flex:0 0 auto;align-items:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));max-width:100%}[part~=wy-toolbar-buttons-last]{margin-inline-start:auto}[part~=wy-toolbar-text]{margin-left:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-toolbar-center-text]{text-align:center}[part~=wy-toolbars-bottom]{position:absolute;z-index:1030;bottom:calc(var(--wy-footerbar-height, calc(4 * var(--wy-size, 1rem)))/2);left:0;right:0;min-height:var(--wy-toolbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;justify-content:center;justify-items:center;box-sizing:border-box}`, rn = j`[part~=wy-input]{--wy-component-background-color: var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border:var(--wy-input-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));margin:calc(-1*var(--wy-input-border-width, var(--wy-border, 1px)));display:block;max-width:100%;min-width:0;flex:1 1 auto;min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em))*1.5*var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*2 + var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))*2);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-input-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem))));background-clip:padding-box;appearance:none;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-input]:focus{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));color:var(--wy-component-color);border-color:var(--wy-primary, var(--wy-primary-light, #2f628c));outline:0}[part~=wy-input]::placeholder{color:var(--wy-outline, var(--wy-outline-light, #72777f));opacity:1}[part~=wy-input]:disabled{opacity:38%}[part~=wy-input]::file-selector-button,[part~=wy-input]::-webkit-file-upload-button{color:var(--wy-component-color);background-color:var(--wy-component-background-color);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));margin:calc(-1*var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) calc(-1*var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));margin-inline-end:var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));pointer-events:none;border-color:inherit;border-style:solid;border-width:0;border-inline-end-width:var(--wy-input-border-width, var(--wy-border, 1px));border-radius:0}[part~=wy-input]:hover:not(:disabled):not([readonly])::file-selector-button,[part~=wy-input]:hover:not(:disabled):not([readonly]) ::-webkit-file-upload-button{background-color:var(--wy-component-background-color)}[part~=wy-input][type=file]{overflow:hidden}[part~=wy-input][type=file]:not(:disabled):not([readonly]){cursor:pointer}[part~=wy-input]::-webkit-date-and-time-value{height:calc(var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem))))*1em)}[part~=wy-input][type=search]::-webkit-search-cancel-button{-webkit-appearance:none}[part~=wy-input-filled]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-input-filled-border-radius, var(--wy-border-radius-lg, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem)))));border-color:var(--wy-component-background-color)}[part~=wy-input-filled]:focus{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-label]{display:inline-block;font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));font-size:var(--wy-headings-font-size, var(--wy-font-size, 1em));font-style:var(--wy-headings-font-style, unset);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.5));margin-block:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-description]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));margin-top:calc(.25*var(--wy-size, 1rem))}[part~=wy-is-invalid],[part~=wy-is-invalid]:focus{border-color:var(--wy-error, var(--wy-error-light, #ba1821))}[part~=wy-invalid-feedback]{margin-top:calc(.25*var(--wy-size, 1rem));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));color:var(--wy-error, var(--wy-error-light, #ba1821))}[part~=wy-input-group]{position:relative;display:flex;gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));align-items:center;flex:1 0 auto}[part~=wy-input-group-button-icon]{--wy-component-background-color: transparent}[part~=wy-input-group-input-with-overlay]{padding-right:calc(var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) + var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}[part~=wy-input-group-button-icon-overlay]{position:absolute;display:inline-flex;top:0;right:0;z-index:4;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));--wy-component-background-color: transparent}[part~=wy-input-group-input]:placeholder-shown~[part~=wy-input-group-button-icon][type=reset]{display:none}[part~=wy-input-group-input]:not(:placeholder-shown)~[part~=wy-input-group-button-icon][type=reset]+[part~=wy-input-group-button-icon]{display:none}[part~=wy-no-result]{text-align:center;padding:calc(1*var(--wy-size, 1rem))}`;
var M4 = Object.defineProperty, A4 = Object.getOwnPropertyDescriptor, Hh = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? A4(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && M4(t, e, r), r;
}, "__decorateClass$O"), ko;
let Dn = (ko = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.whenPdfjs = new Promise((t) => {
      this.whenPdfjsResolve = t;
    }), this.MAX_CANVAS_PIXELS = 0, this.TEXT_LAYER_MODE = 0, this.MAX_IMAGE_SIZE = -1, this.CMAP_PACKED = !0, this.DEFAULT_SCALE_DELTA = 1.1, this.MIN_SCALE = 0.25, this.MAX_SCALE = 10, this.DEFAULT_SCALE_VALUE = "auto", this.ENABLE_XFA = !0, this.DEFAULT_WORKER_URL = "/pdfjs/pdf.worker.min.mjs", this.DEFAULT_CMAPS_URL = "/pdfjs/cmaps/", this.pageNumberRef = nt(), this.totalPagesRef = nt(), this.zoomLevelRef = nt(), this.viewerContainerRef = nt(), this.resizer = new ResizeObserver(() => {
      this.pdfViewer && (this.delayedResize && (clearTimeout(this.delayedResize), this.delayedResize = void 0), this.delayedResize = window.setTimeout(() => {
        this.pdfViewer && (this.pdfViewer.currentScaleValue = this.pdfViewer._currentScaleValue);
      }, 100));
    });
  }
  /**
   * Emit `file-preview-loaded` once the viewer has initialized.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  ////////
  /**
   * Open the configured PDF source in the viewer.
   *
   * @internal
   */
  async open() {
    const { pdfjsLib: t } = await this.whenPdfjs;
    if (!this.pdfViewer || !this.pdfHistory || !this.l10n || !this.pdfLinkService)
      return;
    this.pdfLoadingTask && await this.close();
    const e = t.getDocument({
      url: this.src,
      maxImageSize: this.MAX_IMAGE_SIZE,
      enableXfa: this.ENABLE_XFA,
      cMapUrl: this.CMAP_URL?.toString() || "",
      cMapPacked: this.CMAP_PACKED
    });
    this.pdfLoadingTask = e, e.onProgress = (i) => {
    };
    try {
      const i = await e.promise;
      this.pdfDocument = i, this.pdfViewer.setDocument(i), this.pdfLinkService.setDocument(i), this.pdfHistory.initialize({
        // @ts-expect-error Type 'string | null' is not assignable to type 'string'.
        fingerprint: i.fingerprints[0]
      });
    } catch (i) {
      let r = "pdfjs-loading-error";
      i instanceof t.InvalidPDFException ? r = "pdfjs-invalid-file-error" : i instanceof t.MissingPDFException ? r = "pdfjs-missing-file-error" : i instanceof t.UnexpectedResponseException && (r = "pdfjs-unexpected-response-error"), await this.l10n.get(r, void 0, void 0).then((s) => {
        this.pdfViewError(t, s, { message: i?.message });
      });
    }
    this.dispatchLoaded();
  }
  /**
   * Close any currently loaded PDF and release resources.
   *
   * @internal
   */
  async close() {
    if (!this.pdfLoadingTask)
      return Promise.resolve();
    const t = this.pdfLoadingTask.destroy();
    return this.pdfLoadingTask = void 0, this.pdfDocument && (this.pdfDocument = void 0, this.pdfViewer?.setDocument(null), this.pdfLinkService?.setDocument(null, null), this.pdfHistory && this.pdfHistory.reset()), await t;
  }
  /**
   * Log a pdf.js related error with contextual metadata.
   *
   * @internal
   * @param pdfjsLib - pdf.js core library.
   * @param message - Human readable error.
   * @param moreInfo - Additional error metadata.
   */
  pdfViewError(t, e, i) {
    const r = [`PDF.js v${t?.version || "?"} (build: ${t?.build || "?"})`];
    i && (r.push(`Message: ${i.message}`), i.stack ? r.push(`Stack: ${i.stack}`) : (i.filename && r.push(`File: ${i.filename}`), i.lineNumber && r.push(`Line: ${i.lineNumber}`))), console.error(`${e}

${r.join(`
`)}`);
  }
  ///////
  /**
   * Navigate to the provided page number.
   *
   * @param pageNumber - One-based page index.
   */
  setPage(t) {
    this.pdfViewer && (this.pdfViewer.currentPageNumber = t);
  }
  /**
   * Increase zoom level by the configured delta.
   *
   * @param ticks - Number of zoom steps to apply.
   */
  zoomIn(t = 0) {
    if (this.pdfViewer) {
      let e = this.pdfViewer.currentScale;
      do
        e = parseFloat((e * this.DEFAULT_SCALE_DELTA).toFixed(2)), e = Math.ceil(e * 10) / 10, e = Math.min(this.MAX_SCALE, e);
      while (--t && e < this.MAX_SCALE);
      this.pdfViewer.currentScaleValue = e.toFixed(2);
    }
  }
  /**
   * Decrease zoom level by the configured delta.
   *
   * @param ticks - Number of zoom steps to apply.
   */
  zoomOut(t = 0) {
    if (this.pdfViewer) {
      let e = this.pdfViewer.currentScale;
      do
        e = parseFloat((e / this.DEFAULT_SCALE_DELTA).toFixed(2)), e = Math.floor(e * 10) / 10, e = Math.max(this.MIN_SCALE, e);
      while (--t && e > this.MIN_SCALE);
      this.pdfViewer.currentScaleValue = e.toFixed(2);
    }
  }
  /**
   * Apply an absolute zoom level or named scale preset.
   *
   * @param scale - Numeric zoom or preset name.
   */
  setScale(t) {
    this.pdfViewer && (this.pdfViewer.currentScaleValue = typeof t == "number" ? t.toFixed(2) : t);
  }
  /**
   * Validate and update the current page based on the input value.
   */
  updatePage() {
    if (this.pdfViewer && this.pageNumberRef.value) {
      const t = parseInt(this.pageNumberRef.value.value);
      isNaN(t) ? this.setPage(this.pdfViewer.currentPageNumber) : t > this.pdfViewer.pagesCount ? this.setPage(this.pdfViewer.pagesCount) : t <= 0 ? this.setPage(1) : this.setPage(t);
    }
  }
  /**
   * Select all text inside an input, aiding quick replacement.
   *
   * @param e - Input focus event.
   */
  select(t) {
    const e = t.target;
    e && e.setSelectionRange(0, e.value.length);
  }
  /**
   * Fit the PDF to the current viewport height.
   */
  fitToPage() {
    this.setScale("page-fit");
  }
  /**
   * Fit the PDF to the current viewport width.
   */
  fitToWidth() {
    this.setScale("page-width");
  }
  /**
   * Validate and persist zoom level from the input field.
   */
  updateZoom() {
    if (this.pdfViewer && this.zoomLevelRef.value) {
      const t = parseFloat(this.zoomLevelRef.value.value.replace("%", ""));
      isNaN(t) ? this.setScale(this.pdfViewer.currentScale + 1e-4) : this.setScale(t / 100);
    }
  }
  // clearDocument() {
  //   try {
  //     this.loadingTask?.destroy();
  //     //console.debug("loadingTask cleanup", loadingTask)
  //   } catch (e) {
  //     /* No worries */
  //   }
  //   try {
  //     // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  //     // @ts-ignore due to incorrect param type def?
  //     this.pdfViewer?.setDocument(null);
  //   } catch (e) {
  //     /* No worries */
  //   }
  //   try {
  //     this.pdfLinkService.setDocument(null, null);
  //   } catch (e) {
  //     /* No worries */
  //   }
  // }
  async willUpdate(t) {
    super.willUpdate(t), t.has("weavy") && this.weavy && (this.pdfjsLib || (await this.weavy.whenUrl(), this.pdfjsLib = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL("./es/pdfjs-dist/build/pdf.mjs-Bhye_tXX.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
    ), globalThis.pdfjsLib = this.pdfjsLib, this.pdfjsViewer = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL("./es/pdfjs-dist/web/pdf_viewer.mjs-bp-6p92T.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
    ), this.whenPdfjsResolve?.({
      pdfjsLib: this.pdfjsLib,
      pdfjsViewer: this.pdfjsViewer
    })), this.pdfjsLib && !this.WORKER_URL && (this.WORKER_URL = Lf(this.DEFAULT_WORKER_URL, import.meta.url), this.WORKER_URL.searchParams.append("v", this.weavy.version), this.pdfjsLib.GlobalWorkerOptions.workerSrc = this.WORKER_URL.toString()), this.CMAP_URL || (this.CMAP_URL = Lf(this.DEFAULT_CMAPS_URL, import.meta.url)));
  }
  update(t) {
    super.update(t), (t.has("weavy") || t.has("src") || t.has("pdfViewer")) && this.weavy && this.src && this.pdfViewer && this.open();
  }
  async updated() {
    if (this.weavy && this.viewerContainerRef.value && !this.pdfViewer) {
      const { pdfjsLib: t, pdfjsViewer: e } = await this.whenPdfjs;
      this.viewerContainerRef.value && !this.pdfViewer && (this.pdfEventBus = new e.EventBus(), this.pdfLinkService = new e.PDFLinkService({
        eventBus: this.pdfEventBus
      }), this.l10n = new e.GenericL10n(this.weavy?.locale), this.pdfViewer = new e.PDFViewer({
        container: this.viewerContainerRef.value,
        eventBus: this.pdfEventBus,
        linkService: this.pdfLinkService,
        //findController: this.pdfFindController,
        annotationEditorMode: t.AnnotationEditorType.DISABLE,
        l10n: this.l10n,
        maxCanvasPixels: this.MAX_CANVAS_PIXELS,
        textLayerMode: this.TEXT_LAYER_MODE
      }), this.pdfLinkService?.setViewer(this.pdfViewer), this.pdfHistory = new e.PDFHistory({
        eventBus: this.pdfEventBus,
        linkService: this.pdfLinkService
      }), this.pdfLinkService?.setHistory(this.pdfHistory), this.pdfEventBus?.on("scalechanging", () => {
        this.zoomLevelRef.value && this.pdfViewer ? this.zoomLevelRef.value.value = Math.round(this.pdfViewer.currentScale * 100).toFixed(0) + "%" : console.warn("Could not set zoom level");
      }), this.pdfEventBus?.on("pagechanging", () => {
        this.pageNumberRef.value && this.pdfViewer ? this.pageNumberRef.value.value = this.pdfViewer.currentPageNumber.toFixed(0) : console.warn("Could not set page number");
      }), this.pdfEventBus?.on("pagesinit", () => {
        this.isConnected && this.pdfViewer && this.pageNumberRef.value && this.totalPagesRef.value ? (this.pdfViewer.currentScaleValue = this.DEFAULT_SCALE_VALUE, this.pageNumberRef.value.value = "1", this.totalPagesRef.value.innerText = this.pdfViewer.pagesCount.toFixed(0), this.resizer.observe(this.pdfViewer.container)) : console.warn("Could not init pdf page");
      }));
    }
  }
  render() {
    return h`
      <div class="wy-content-pdf">
        <div part="wy-toolbars-bottom">
          <nav part="wy-toolbar wy-toolbar-center">
            <div part="wy-toolbar-buttons">
              <input
                type="text"
                part="wy-input wy-toolbar-center-text"
                class="wy-pdf-page-number"
                ${Q(this.pageNumberRef)}
                @keydown=${rh}
                @keyup=${Br}
                @change=${() => this.updatePage()}
                @click=${(t) => this.select(t)}
              />
              <span part="wy-toolbar-text">/</span>
              <span part="wy-toolbar-text" ${Q(this.totalPagesRef)}>1</span>
            </div>
            <div part="wy-toolbar-buttons">
              <wy-button kind="icon" class="btn-zoom-out" @click=${() => this.zoomOut()} title=${x("Zoom out")}>
                <wy-icon name="minus"></wy-icon>
              </wy-button>
              <input
                type="text"
                part="wy-input"
                class="wy-pdf-zoom-level"
                ${Q(this.zoomLevelRef)}
                @keydown=${rh}
                @keyup=${Br}
                @change=${() => this.updateZoom()}
                @click=${(t) => this.select(t)}
                value="100%"
              />
              <wy-button kind="icon" class="btn-zoom-in" @click=${() => this.zoomIn()} title=${x("Zoom in")}>
                <wy-icon name="plus"></wy-icon>
              </wy-button>
            </div>
            <div part="wy-toolbar-buttons">
              <wy-button kind="icon" class="btn-fit-page" @click=${() => this.fitToWidth()} title=${x("Fit to width")}>
                <wy-icon name="fit-width"></wy-icon>
              </wy-button>
              <wy-button kind="icon" @click=${() => this.fitToPage()} title=${x("Fit to screen")}>
                <wy-icon name="fit-screen"></wy-icon>
              </wy-button>
            </div>
          </nav>
        </div>
        <div ${Q(this.viewerContainerRef)} class="wy-pdf-container">
          <div class="pdfViewer"></div>
        </div>
      </div>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.pdfViewer && this.resizer.observe(this.pdfViewer.container);
  }
  disconnectedCallback() {
    this.resizer.unobserve(this);
    try {
      this.close(), this.pdfViewer?.cleanup();
    } catch {
    }
    this.pdfViewer = void 0, super.disconnectedCallback();
  }
}, a(ko, "WyPdfViewer"), ko);
Dn.styles = [
  S4,
  Bv,
  rn,
  X
];
Hh([
  be({ context: he, subscribe: !0 }),
  D()
], Dn.prototype, "weavy", 2);
Hh([
  u()
], Dn.prototype, "src", 2);
Hh([
  D()
], Dn.prototype, "pdfViewer", 2);
Dn = Hh([
  B("wy-pdf-viewer"),
  ht()
], Dn);
var E4 = Object.defineProperty, R4 = Object.getOwnPropertyDescriptor, zy = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? R4(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && E4(t, e, r), r;
}, "__decorateClass$N"), Po;
let Fc = (Po = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.current = !1;
  }
  /**
   * Emits the `file-preview-loaded` event when the preview has finished loading.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  render() {
    const t = this.file;
    if (!t) return b;
    const { icon: e } = Xr(t.name), i = di(t.name);
    let r = t.preview_url || t.download_url || "";
    t.preview_format === "image" && (i === ".gif" || i === ".svg") && (r = t.download_url || "");
    const o = r, c = t.external_url, l = t.is_trashed ? "none" : t.preview_format, p = t.name, v = t.width, C = t.height, g = t.media_type, m = t.provider;
    return l === "image" ? h`<wy-preview-image
        src=${o}
        width=${dt(v)}
        height=${dt(C)}
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-image>` : l === "pdf" ? h`<wy-pdf-viewer src=${o} @file-preview-loaded=${() => this.dispatchLoaded()}></wy-pdf-viewer>` : l === "video" || l === "audio" ? h`<wy-preview-media
        format=${l}
        src=${o}
        name=${p}
        mediaType=${g}
        ?play=${this.current}
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-media>` : l === "text" ? h`<wy-preview-text src=${o} @file-preview-loaded=${() => this.dispatchLoaded()}></wy-preview-text>` : l === "code" ? h`<wy-preview-text
        src=${o}
        ?html=${!/^(?:blob:|data:)/.test(o)}
        code
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-text>` : l === "html" ? h`<wy-preview-text
        src=${o}
        html
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-text>` : l === "embed" ? h`<wy-preview-embed
        src=${o}
        name=${p}
        icon=${e}
        provider=${dt(m)}
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-embed>` : l === "none" ? c ? h`<wy-preview-icon
            src=${c}
            icon=${e}
            provider=${dt(m)}
            @file-preview-loaded=${() => this.dispatchLoaded()}
          ></wy-preview-icon>` : h`<wy-preview-icon
            src=${o}
            icon=${e}
            @file-preview-loaded=${() => this.dispatchLoaded()}
          ></wy-preview-icon>` : b;
  }
}, a(Po, "WyPreviewItem"), Po);
Fc.styles = [X];
zy([
  u({ type: Object })
], Fc.prototype, "file", 2);
zy([
  u({ type: Boolean })
], Fc.prototype, "current", 2);
Fc = zy([
  B("wy-preview-item")
], Fc);
var T4 = Object.defineProperty, L4 = Object.getOwnPropertyDescriptor, bd = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? L4(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && T4(t, e, r), r;
}, "__decorateClass$M"), _o;
let Vn = (_o = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.small = !1, this.hasEventListener = {
      "edit-name": !1,
      subscribe: !1,
      trash: !1,
      restore: !1,
      "delete-forever": !1
    };
  }
  addEventListener(t, e, i) {
    if (this.hasEventListener) {
      const r = t;
      Object.prototype.hasOwnProperty.call(this.hasEventListener, r) && Object.assign(this.hasEventListener, {
        [r]: !0
      });
    }
    super.addEventListener(t, e, i);
  }
  /**
   * Open download URL for the current file.
   * @internal
   */
  triggerDownload() {
    this.file && tr(this.file.download_url, "_top", this.file.name, !0);
  }
  /**
   * Open external provider URL for the current file.
   * @internal
   */
  triggerExternal() {
    this.file && tr(this.file.external_url, "_blank", this.file.name);
  }
  /**
   * Open application-specific URL for the current file.
   * @internal
   */
  triggerApplication() {
    this.file && tr(this.file.application_url, "_top", this.file.name);
  }
  /**
   * Emit an `edit-name` event for the current file.
   * @internal
   */
  dispatchEditName() {
    const t = new CustomEvent("edit-name", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `subscribe` event toggling subscription state.
   *
   * @internal
   * @param subscribe - Desired subscription setting.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", {
      detail: {
        file: this.file,
        subscribe: t
      }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `trash` event for the current file.
   * @internal
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `restore` event for the current file.
   * @internal
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `delete-forever` event for the current file.
   * @internal
   */
  dispatchDeleteForever() {
    const t = new CustomEvent("delete-forever", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  render() {
    if (!this.file)
      return b;
    const { icon: t } = Xr(this.file.name), e = this.file.id >= 1, i = this.file.provider, r = this.file.provider || "app";
    return h`
      <wy-dropdown directionX="left" ?small=${this.small}>
        ${e && this.file.is_trashed ? h`
              ${this.hasEventListener.restore ? h`
                    <wy-dropdown-item @click=${() => this.dispatchRestore()}>
                      <wy-icon name="delete-restore"></wy-icon>
                      ${x("Restore")}
                    </wy-dropdown-item>
                  ` : b}
              ${this.hasEventListener.restore && this.hasEventListener["delete-forever"] ? h` <wy-dropdown-divider></wy-dropdown-divider> ` : b}
              ${this.hasEventListener["delete-forever"] ? h`
                    <wy-dropdown-item @click=${() => this.dispatchDeleteForever()}>
                      <wy-icon name="delete-forever"></wy-icon>
                      ${x("Delete")}
                    </wy-dropdown-item>
                  ` : b}
            ` : b}
        ${this.file.is_trashed ? b : h`
              ${this.file.external_url ? h`
                    <wy-dropdown-item @click=${() => this.triggerExternal()}>
                      <wy-icon name=${t}></wy-icon>
                      ${x(gt`Open in ${i}`)}
                    </wy-dropdown-item>
                  ` : h`
                    ${this.componentFeatures?.allowsFeature(S.WebDAV) && this.file.application_url ? h`
                          <wy-dropdown-item @click=${() => this.triggerApplication()}>
                            <wy-icon
                              name=${this.file.provider ? om(this.file.provider) : t}
                            ></wy-icon>
                            ${x(gt`Open in ${r}`)}
                          </wy-dropdown-item>
                        ` : b}
                    <wy-dropdown-item @click=${() => this.triggerDownload()}>
                      <wy-icon name="download"></wy-icon>
                      ${x("Download")}
                    </wy-dropdown-item>
                  `}
              ${e ? h`
                    ${this.hasEventListener["edit-name"] ? h`
                          <wy-dropdown-item @click=${() => this.dispatchEditName()}>
                            <wy-icon name="textbox"></wy-icon>
                            ${x("Rename")}
                          </wy-dropdown-item>
                        ` : b}
                    ${this.hasEventListener.subscribe ? this.file.is_subscribed ? h`
                            <wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                              <wy-icon name="bell-off"></wy-icon>
                              ${x("Unsubscribe")}
                            </wy-dropdown-item>
                          ` : h`
                            <wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                              <wy-icon name="bell"></wy-icon>
                              ${x("Subscribe")}
                            </wy-dropdown-item>
                          ` : b}
                    ${this.hasEventListener.trash ? h`
                          <wy-dropdown-divider></wy-dropdown-divider>
                          <wy-dropdown-item @click=${() => this.dispatchTrash()}>
                            <wy-icon name="delete"></wy-icon>
                            ${x("Trash")}
                          </wy-dropdown-item>
                        ` : b}
                  ` : b}
            `}
        <slot></slot>
      </wy-dropdown>
    `;
  }
}, a(_o, "WyFileMenu"), _o);
bd([
  be({ context: bh, subscribe: !0 }),
  D()
], Vn.prototype, "componentFeatures", 2);
bd([
  u({ type: Object })
], Vn.prototype, "file", 2);
bd([
  u({ type: Boolean })
], Vn.prototype, "small", 2);
bd([
  u({ type: Object })
], Vn.prototype, "hasEventListener", 2);
Vn = bd([
  B("wy-file-menu"),
  ht()
], Vn);
function O4(n, t, e, i = {}) {
  return {
    ...i,
    initialPageParam: 0,
    queryKey: [t, e, "comments"],
    queryFn: /* @__PURE__ */ a(async (r) => {
      const s = r.pageParam, o = "/api/" + t + "/" + e + "/comments?order_by=id&skip=" + s, l = await (await n.fetch(o)).json();
      return l.data = l.data || [], l;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ a((r) => {
      if (r.end && r.end < r.count)
        return r.end;
    }, "getNextPageParam")
  };
}
a(O4, "getCommentsOptions");
function z4(n, t) {
  return {
    mutationFn: /* @__PURE__ */ a(async (i) => await (await n.fetch("/api/comments/" + i.id, {
      method: "PATCH",
      body: JSON.stringify({
        text: i.text,
        blobs: i.blobs,
        attachments: i.attachments,
        meeting_id: i.meeting_id,
        options: i.poll_options.filter((s) => s.text.trim() !== "").map((s) => ({ id: s.id, text: s.text })),
        embed_id: i.embed_id || null
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onSuccess: /* @__PURE__ */ a((i, r) => {
      r.id && Zt(n.queryClient, [r.type, r.parent_id, "comments"], r.id, (s) => {
        s.text = i.text, s.html = i.html, s.attachments = i.attachments, s.meeting = i.meeting, s.updated_at = i.updated_at, s.updated_by = i.updated_by, s.options = i.options, s.embed = i.embed;
      });
    }, "onSuccess")
  };
}
a(z4, "getUpdateCommentMutationOptions");
function I4(n) {
  const t = n.queryClient;
  return {
    mutationFn: /* @__PURE__ */ a(async (i) => await (await n.fetch("/api/" + i.type + "/" + i.parent_id + "/comments", {
      method: "POST",
      body: JSON.stringify({
        text: i.text,
        blobs: i.blobs,
        meeting_id: i.meeting_id,
        options: i.poll_options.filter((s) => s.text.trim() !== "").map((s) => ({ text: s.text })),
        embed_id: i.embed_id,
        context: i.context
      })
    })).json(), "mutationFn"),
    onMutate: /* @__PURE__ */ a(async (i) => {
      const r = [i.type, i.parent_id, "comments"];
      await t.cancelQueries({ queryKey: r });
      const s = Mn(n.queryClient, r, !1);
      if (i.user) {
        const o = {
          id: s ? s.id - 1 : -1,
          app: i.type === "apps" ? { id: i.parent_id } : { id: -1 },
          is_trashed: !1,
          text: i.text,
          html: i.text,
          plain: i.text,
          created_by: i.user,
          created_at: (/* @__PURE__ */ new Date()).toUTCString(),
          attachments: { count: 0 },
          reactions: { count: 0 },
          is_subscribed: !1,
          is_starred: !1
        };
        i.type === "files" ? o.parent = { type: Ae.File, id: i.parent_id } : i.type === "posts" && (o.parent = { type: Ae.Post, id: i.parent_id }), Vr(t, r, o, { descending: !1 });
      }
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((i, r) => {
      const s = [r.type, i.parent?.id ?? i.app.id, "comments"];
      if (!Ph(n.queryClient, s, i.id)) {
        const c = Mn(n.queryClient, s, !0);
        c ? Zt(n.queryClient, s, c.id, (l) => {
          l.id = i.id, l.app = i.app, l.text = i.text, l.html = i.html, l.embed = i.embed, l.meeting = i.meeting, l.attachments = i.attachments, l.options = i.options, l.created_at = i.created_at, l.created_by = i.created_by, l.updated_at = i.updated_at, l.updated_by = i.updated_by;
        }) : Vr(n.queryClient, s, i), i.parent?.type === Ae.Post && Zt(t, ["posts", i.app.id], i.parent.id, (l) => {
          l.comments ? l.comments.count += 1 : l.comments = { count: 1 };
        });
      }
    }, "onSuccess")
  };
}
a(I4, "getAddCommentMutationOptions");
function F4(n, t, e) {
  const i = n.queryClient, s = {
    mutationKey: [t, e, "comments"],
    mutationFn: /* @__PURE__ */ a(async ({ id: o }) => {
      if (!(await n.fetch("/api/comments/" + o + "/trash", { method: "POST" })).ok)
        throw new Error();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((o) => {
      yt(
        i,
        { queryKey: s.mutationKey, exact: !1 },
        o.id,
        (c) => Object.assign(c, { is_trashed: !0 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((o, c) => {
      yt(
        i,
        { queryKey: s.mutationKey, exact: !1 },
        c.id,
        (l) => Object.assign(l, o)
      ), Zt(i, [c.type, c.appId], c.parentId, (l) => {
        l.comments.count -= 1;
      });
    }, "onSuccess")
  };
  return s;
}
a(F4, "getTrashCommentMutationOptions");
function D4(n, t, e) {
  return new Mt(n.queryClient, F4(n, t, e));
}
a(D4, "getTrashCommentMutation");
function V4(n, t, e) {
  const i = n.queryClient, s = {
    mutationKey: [t, e, "comments"],
    mutationFn: /* @__PURE__ */ a(async ({ id: o }) => {
      const c = await n.fetch("/api/comments/" + o + "/restore", { method: "POST" });
      if (!c.ok) {
        const l = await c.json();
        throw new Error(l.detail || l.title, { cause: l });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((o) => {
      yt(
        i,
        { queryKey: s.mutationKey, exact: !1 },
        o.id,
        (c) => Object.assign(c, { is_trashed: !1 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((o, c) => {
      yt(
        i,
        { queryKey: s.mutationKey, exact: !1 },
        c.id,
        (l) => Object.assign(l, o)
      ), Zt(i, [c.type, c.appId], c.parentId, (l) => {
        l.comments.count += 1;
      });
    }, "onSuccess")
  };
  return s;
}
a(V4, "getRestoreCommentMutationOptions");
function H4(n, t, e) {
  return new Mt(n.queryClient, V4(n, t, e));
}
a(H4, "getRestoreCommentMutation");
const Iy = j`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}:host(wy-comments){--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-border-radius: var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-comment-list-padded]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-comments]{display:flex;flex-direction:column}[part~=wy-comment]{display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));margin-bottom:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-comment][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-comment-reveal]{interpolate-size:allow-keywords;overflow:hidden;transition:height var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),margin-bottom var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-duration-fast, .1s);height:auto;opacity:1}@starting-style{[part~=wy-comment-reveal]{height:0;margin-bottom:0;opacity:0}}[part~=wy-comment-skeleton]{transition-delay:var(--wy-transition-reveal-delay, 1s)}[part~=wy-comment-body]{display:flex;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));min-width:0;flex:1 1 100%}[part~=wy-comment-footer]{margin-left:calc(-1*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));margin-top:calc(-1*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}::part(wy-trashed){text-decoration:line-through;color:var(--wy-outline, var(--wy-outline-light, #72777f))}wy-comment::part(wy-editor){padding-left:0;padding-right:0;margin-right:calc(-1*var(--wy-size, 1rem))}`, B4 = 1e3 * 60 * 60, ju = B4 * 24;
function tl(n, t, e, i = 7) {
  e ??= /* @__PURE__ */ new Date();
  const r = new Date(e.getFullYear(), e.getMonth(), e.getDate()), s = t.valueOf() - e.valueOf(), o = t.toDateString() === e.toDateString(), c = t.valueOf() > r.valueOf() - ju * i && t.valueOf() < r.valueOf() + ju * i;
  if (!o && c) {
    const l = Math.round(s / ju);
    return new Intl.RelativeTimeFormat(n, { numeric: "auto" }).format(l, "days");
  } else return o ? new Intl.DateTimeFormat(n, { timeStyle: "short" }).format(t) : new Intl.DateTimeFormat(n, { dateStyle: "short" }).format(t);
}
a(tl, "relativeTime");
const Nv = j`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}`;
var N4 = Object.defineProperty, U4 = Object.getOwnPropertyDescriptor, ea = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? U4(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && N4(t, e, r), r;
}, "__decorateClass$L"), So;
let Ii = (So = class extends Dt {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.location = "apps", this.highlight = !1, this.reveal = !1, this.editing = !1, this.previewAnnotationsRef = nt(), this.previewAttachmentsRef = nt(), this.highlightRef = nt(), this.updateCommentMutation = new ti(this);
  }
  /**
   * Dispatch a poll vote event for this comment.
   *
   * @internal
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", {
      detail: { optionId: t, parentId: this.comment.id, parentType: "comments" }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Dispatch a trash event for this comment.
   *
   * @internal
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.comment.id } });
    return this.dispatchEvent(t);
  }
  /**
   * Dispatch a restore event for this comment.
   *
   * @internal
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", {
      detail: { id: this.comment.id }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Submit updated comment content via mutation and exit edit mode.
   *
   * @internal
   */
  updateComment(t) {
    this.updateCommentMutation.mutate({
      id: this.comment.id,
      type: this.location,
      parent_id: this.parentId,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      attachments: t.detail.attachments,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId
    }), this.editing = !1;
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("parentId") || t.has("weavy")) && this.parentId && this.weavy && await this.updateCommentMutation.trackMutation(
      z4(this.weavy, [this.location, this.parentId, "comments"])
    ), t.has("link") && (this.highlight = !!(this.link && zh(this.link, Ae.Comment, { id: this.comment.id }))), t.has("highlight") && (this.highlight ? this.part.add("wy-highlight") : this.part.remove("wy-highlight"));
  }
  render() {
    const t = this.comment.attachments?.data?.filter((o) => o.kind === "image" && o.thumbnail_url) || [], e = this.comment.attachments?.data?.filter((o) => o.kind !== "image" || !o.thumbnail_url) || [], i = new Intl.DateTimeFormat(this.weavy?.locale, {
      dateStyle: "full",
      timeStyle: "short"
    }).format(new Date(this.comment.created_at)), r = tl(this.weavy?.locale, new Date(this.comment.created_at)), s = this.comment.id < 0;
    return h`
      <div part="wy-comment ${J({ "wy-comment-reveal": this.reveal, "wy-comment-skeleton": s })}">
        ${s ? h`
              <wy-item align="top" part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src="${this.comment.created_by.avatar_url}"
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>
                <div slot="content" part="wy-comment-body">
                  <div part="wy-comment-title">
                    ${this.comment.created_by.name}
                    <small part="wy-meta">
                      ·
                      <time datetime=${this.comment.created_at} title=${i}>${r}</time>
                      ${this.comment.updated_at ? h`<time datetime=${this.comment.updated_at}> · ${x("edited")}</time>` : b}
                    </small>
                  </div>
                  ${this.comment.html ? h`<div part="wy-content"><wy-skeleton .text=${this.comment.text}></wy-skeleton></div>` : ""}
                </div>
              </wy-item>
            ` : this.comment.is_trashed ? h`
              <wy-item part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src="${this.comment.created_by.avatar_url}"
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>
                <span part="wy-trashed" slot="title">${x("Comment was trashed.")}</span>
                <wy-button small slot="actions" @click=${() => this.dispatchRestore()} color="variant"
                  >${x("Undo")}</wy-button
                >
              </wy-item>
            ` : this.editing ? h`
              <wy-item align="top" part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src="${this.comment.created_by.avatar_url}"
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>
                <wy-button small slot="actions" @click=${() => this.editing = !1} kind="icon">
                  <wy-icon name="close"></wy-icon>
                </wy-button>
                <div slot="content" part="wy-comment-body">
                  <div part="wy-comment-title">
                    ${this.comment.created_by.name}

                    <small part="wy-meta">
                      ·
                      <time datetime=${this.comment.created_at} title=${i}>${r}</time>
                    </small>
                  </div>
                  <wy-editor
                    editorLocation=${this.location}
                    .text=${this.comment.text}
                    .embed=${this.comment.embed}
                    .options=${this.comment.options?.data}
                    .attachments=${this.comment.attachments?.data ?? []}
                    .parentId=${this.comment.id}
                    .typing=${!1}
                    .draft=${!1}
                    placeholder=${x("Edit comment...")}
                    buttonText=${x("Update", { desc: "Button action to update" })}
                    @submit=${(o) => this.updateComment(o)}
                  ></wy-editor>
                </div>
              </wy-item>
            ` : h`
              <wy-item align="top" part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src=${this.comment.created_by.avatar_url}
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>

                ${this.user && this.user.id === this.comment.created_by.id ? h`
                      <wy-dropdown small slot="actions">
                        ${this.user.id === this.comment.created_by.id ? h`
                              <wy-dropdown-item @click=${() => this.editing = !0}>
                                <wy-icon name="pencil"></wy-icon>
                                ${x("Edit")}
                              </wy-dropdown-item>
                            ` : b}
                        ${this.user.id === this.comment.created_by.id ? h`
                              <wy-dropdown-item @click=${() => this.dispatchTrash()}>
                                <wy-icon name="trashcan"></wy-icon>
                                ${x("Trash")}
                              </wy-dropdown-item>
                            ` : b}
                      </wy-dropdown>
                    ` : b}

                <div slot="content" part="wy-comment-body">
                  <div part="wy-comment-title">
                    ${this.comment.created_by.name}
                    <small part="wy-meta">
                      ·
                      <time datetime=${this.comment.created_at} title=${i}>${r}</time>
                      ${this.comment.updated_at ? h`<time datetime=${this.comment.updated_at}> · ${x("edited")}</time>` : b}
                    </small>
                  </div>

                  <!-- image grid -->
                  ${t && t.length ? h`<wy-image-grid
                        part="wy-comment-images"
                        .images=${t}
                        @file-open=${(o) => {
      this.previewAttachmentsRef.value?.open(o.detail.fileId);
    }}
                      ></wy-image-grid>` : ""}

                  <!-- text content -->
                  ${this.comment.html ? h`<div part="wy-content">${An(this.comment.html)}</div>` : ""}

                  <!-- annotations -->
                  ${this.comment.annotations?.data?.length ? h`<wy-annotation-list
                        .files=${this.comment.annotations.data}
                        @file-open=${(o) => {
      this.previewAnnotationsRef.value?.open(o.detail.fileId);
    }}
                      ></wy-annotation-list>` : b}

                  <!-- poll -->
                  ${this.comment.options?.data?.length ? h`
                        <wy-poll
                          .pollOptions=${this.comment.options.data}
                          @vote=${(o) => this.dispatchVote(o.detail.optionId)}
                        ></wy-poll>
                      ` : b}

                  <!-- embeds -->
                  ${this.comment.embed && this.componentFeatures?.allowsFeature(S.Embeds) ? h` <wy-embed .embed=${this.comment.embed}></wy-embed> ` : b}

                  <!-- files -->
                  ${e.length ? h`<wy-attachment-list
                        filled
                        .files=${e ?? []}
                        @file-open=${(o) => {
      this.previewAttachmentsRef.value?.open(o.detail.fileId);
    }}
                      ></wy-attachment-list>` : ""}

                  <!-- meeting -->
                  ${this.comment.meeting ? h`<wy-meeting-card .meeting=${this.comment.meeting}></wy-meeting-card>` : ""}

                  <div part="wy-comment-footer">
                    ${this.componentFeatures?.allowsFeature(S.Reactions) ? h` <wy-reactions
                          lineReverse
                          small
                          .reactions=${this.comment.reactions?.data}
                          parentType=${this.location}
                          parentId=${this.parentId}
                          entityId=${this.comment.id}
                          entityType="comments"
                        ></wy-reactions>` : b}
                    ${this.comment.annotations?.data?.length ? h`<wy-preview
                          ${Q(this.previewAnnotationsRef)}
                          .files=${this.comment.annotations.data}
                          .isAttachment=${!0}
                        ></wy-preview> ` : b}
                    ${this.comment.attachments?.data?.length ? h`<wy-preview
                          ${Q(this.previewAttachmentsRef)}
                          .files=${[...t, ...e]}
                          .isAttachment=${!0}
                        ></wy-preview> ` : b}
                  </div>
                </div>
              </wy-item>
            `}
      </div>
    `;
  }
  updated(t) {
    t.has("highlight") && this.highlight && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, a(So, "WyComment"), So);
Ii.styles = [Ht, Iy, Gc, Nv, Ey, X];
ea([
  u({ type: Object, attribute: !1 })
], Ii.prototype, "comment", 2);
ea([
  u({ type: Number })
], Ii.prototype, "parentId", 2);
ea([
  u({ attribute: !1 })
], Ii.prototype, "location", 2);
ea([
  D()
], Ii.prototype, "highlight", 2);
ea([
  u({ type: Boolean, reflect: !0 })
], Ii.prototype, "reveal", 2);
ea([
  D()
], Ii.prototype, "editing", 2);
Ii = ea([
  B("wy-comment"),
  ht()
], Ii);
const q4 = j`[part~=wy-comment-editor]{position:relative;border-radius:var(--wy-padding-outer, 0)}[part~=wy-comment-editor-bottom]{position:sticky;bottom:0;z-index:999;background-color:var(--wy-component-background-color);padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-radius:var(--wy-component-border-radius);color:var(--wy-component-color)}[part~=wy-comment-editor-inputs]{display:flex;flex-direction:row;align-items:flex-end;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-comment-editor-text]{flex:1 1 100%;display:flex;flex-direction:column}[part~=wy-editor-parts]{padding-top:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));min-height:0}[part~=wy-comment-editor] .cm-editor{flex:1 1 100%;max-height:calc(11.25*var(--wy-size, 1rem));background-color:var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:calc(1.25*var(--wy-size, 1rem));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid rgba(0,0,0,0);margin:calc(-1*var(--wy-input-border-width, var(--wy-border, 1px)))}[part~=wy-comment-editor] .cm-editor:focus{border-color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-comment-editor] .cm-editor .cm-content{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-comment-editor] [part~=wy-is-invalid]+.cm-editor,[part~=wy-comment-editor] [part~=wy-is-invalid] .cm-editor{border-color:var(--wy-error, var(--wy-error-light, #ba1821))!important}`;
var Wu, If;
function j4() {
  if (If) return Wu;
  If = 1;
  var n = "Expected a function", t = NaN, e = "[object Symbol]", i = /^\s+|\s+$/g, r = /^[-+]0x[0-9a-f]+$/i, s = /^0b[01]+$/i, o = /^0o[0-7]+$/i, c = parseInt, l = typeof Td == "object" && Td && Td.Object === Object && Td, p = typeof self == "object" && self && self.Object === Object && self, v = l || p || Function("return this")(), C = Object.prototype, g = C.toString, m = Math.max, f = Math.min, $ = /* @__PURE__ */ a(function() {
    return v.Date.now();
  }, "now");
  function A(U, K, tt) {
    var ot, rt, Lt, Ot, At, vt, Bt = 0, xe = !1, Rt = !1, xt = !0;
    if (typeof U != "function")
      throw new TypeError(n);
    K = I(K) || 0, R(tt) && (xe = !!tt.leading, Rt = "maxWait" in tt, Lt = Rt ? m(I(tt.maxWait) || 0, K) : Lt, xt = "trailing" in tt ? !!tt.trailing : xt);
    function ie(Ct) {
      var Ve = ot, Et = rt;
      return ot = rt = void 0, Bt = Ct, Ot = U.apply(Et, Ve), Ot;
    }
    a(ie, "invokeFunc");
    function ct(Ct) {
      return Bt = Ct, At = setTimeout(Ye, K), xe ? ie(Ct) : Ot;
    }
    a(ct, "leadingEdge");
    function kt(Ct) {
      var Ve = Ct - vt, Et = Ct - Bt, re = K - Ve;
      return Rt ? f(re, Lt - Et) : re;
    }
    a(kt, "remainingWait");
    function hi(Ct) {
      var Ve = Ct - vt, Et = Ct - Bt;
      return vt === void 0 || Ve >= K || Ve < 0 || Rt && Et >= Lt;
    }
    a(hi, "shouldInvoke");
    function Ye() {
      var Ct = $();
      if (hi(Ct))
        return Hi(Ct);
      At = setTimeout(Ye, kt(Ct));
    }
    a(Ye, "timerExpired");
    function Hi(Ct) {
      return At = void 0, xt && ot ? ie(Ct) : (ot = rt = void 0, Ot);
    }
    a(Hi, "trailingEdge");
    function Bi() {
      At !== void 0 && clearTimeout(At), Bt = 0, ot = vt = rt = At = void 0;
    }
    a(Bi, "cancel");
    function sl() {
      return At === void 0 ? Ot : Hi($());
    }
    a(sl, "flush");
    function Ci() {
      var Ct = $(), Ve = hi(Ct);
      if (ot = arguments, rt = this, vt = Ct, Ve) {
        if (At === void 0)
          return ct(vt);
        if (Rt)
          return At = setTimeout(Ye, K), ie(vt);
      }
      return At === void 0 && (At = setTimeout(Ye, K)), Ot;
    }
    return a(Ci, "debounced"), Ci.cancel = Bi, Ci.flush = sl, Ci;
  }
  a(A, "debounce");
  function M(U, K, tt) {
    var ot = !0, rt = !0;
    if (typeof U != "function")
      throw new TypeError(n);
    return R(tt) && (ot = "leading" in tt ? !!tt.leading : ot, rt = "trailing" in tt ? !!tt.trailing : rt), A(U, K, {
      leading: ot,
      maxWait: K,
      trailing: rt
    });
  }
  a(M, "throttle");
  function R(U) {
    var K = typeof U;
    return !!U && (K == "object" || K == "function");
  }
  a(R, "isObject");
  function V(U) {
    return !!U && typeof U == "object";
  }
  a(V, "isObjectLike");
  function W(U) {
    return typeof U == "symbol" || V(U) && g.call(U) == e;
  }
  a(W, "isSymbol");
  function I(U) {
    if (typeof U == "number")
      return U;
    if (W(U))
      return t;
    if (R(U)) {
      var K = typeof U.valueOf == "function" ? U.valueOf() : U;
      U = R(K) ? K + "" : K;
    }
    if (typeof U != "string")
      return U === 0 ? U : +U;
    U = U.replace(i, "");
    var tt = s.test(U);
    return tt || o.test(U) ? c(U.slice(2), tt ? 2 : 8) : r.test(U) ? t : +U;
  }
  return a(I, "toNumber"), Wu = M, Wu;
}
a(j4, "requireLodash_throttle");
var W4 = j4();
const jp = /* @__PURE__ */ q1(W4);
function K4(n, t) {
  return new Mt(n.queryClient, {
    mutationFn: /* @__PURE__ */ a(async () => await n.fetch(`/api/apps/${t}/typing`, {
      method: "PUT",
      body: JSON.stringify({})
    }), "mutationFn")
  });
}
a(K4, "typingMutation");
function Ff(n, t) {
  return new Mt(n.queryClient, {
    mutationFn: /* @__PURE__ */ a(async () => {
      const e = await n.fetch(`/x/${t}/meetings`, { method: "POST" });
      if (!e.ok)
        throw new Error("Failed to create meeting");
      return await e.json();
    }, "mutationFn")
  });
}
a(Ff, "addMeetingMutation");
async function Q4(n, t) {
  const e = await n.fetch("/api/blobs/external", { method: "POST", body: JSON.stringify(t) });
  if (!e.ok) {
    const r = await e.json();
    throw new Error(r.detail || r.title, { cause: r });
  }
  return await e.json();
}
a(Q4, "externalBlob");
function G4(n, t, e, i) {
  const r = n.queryClient, s = ["apps", e, "blobs", i];
  return {
    mutationFn: /* @__PURE__ */ a(async (c) => await Q4(n, c.externalBlob), "mutationFn"),
    mutationKey: s,
    onMutate: /* @__PURE__ */ a(async (c) => (await r.cancelQueries({ queryKey: s, exact: !0 }), { type: "attach", file: py(void 0, c.externalBlob.name, c.externalBlob.size, void 0, t), status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ a((c, l, p) => {
      qt(r, s, l, (v) => {
        v.status.state = "ok", v.status.progress = void 0, v.status.text = void 0;
      });
    }, "onSuccess"),
    onError(c, l, p) {
      const v = c.cause;
      v && v.status === 409 ? qt(r, s, l, (C) => {
        C.status.state = "conflict", C.status.progress = void 0, C.status.text = v.detail || v.title;
      }) : qt(r, s, l, (C) => {
        C && (C.status.state = "error", C.status.progress = void 0, C.status.text = v.detail || v.title);
      });
    }
  };
}
a(G4, "getExternalBlobMutationOptions");
function Uv(n, t, e, i) {
  return new Mt(n.queryClient, G4(n, t, e, i));
}
a(Uv, "getExternalBlobMutation");
const Z4 = /(((https?|ftp):\/\/|(www|ftp)\.)[\w]+(.[\w]+)([\w\-.,@?^=%&amp;:/~+#]*[\w\-@?^=%&amp;/~+#]))/gim;
let ha = [], Fl = [], dh = [], Vd = [], Xi = {};
const Y4 = /* @__PURE__ */ a((n, t) => n.length === t.length && n.every((e, i) => e === t[i]), "arrayEquals");
function X4() {
  return !!Object.keys(Xi).length;
}
a(X4, "isFetchingEmbeds");
async function J4(n, t) {
  let e;
  try {
    const i = await t.fetch(`/api/embeds?url=${encodeURIComponent(n)}`);
    if (!i.ok)
      throw new Error();
    e = await i.json(), delete Xi[n], Fl = [...Fl, n];
  } catch {
    dh = [...dh, n], delete Xi[n];
  }
  return e;
}
a(J4, "fetchEmbed");
const t3 = /* @__PURE__ */ a(() => {
  ha = [], Fl = [], dh = [], Vd = [], Xi = {};
}, "clearEmbeds"), Df = /* @__PURE__ */ a((n) => {
  Fl = n;
}, "initEmbeds"), e3 = /* @__PURE__ */ a((n, t, e) => {
  let i = n.match(Z4)?.map((r) => r) || null;
  if (i !== null && (i = i.map((r) => r.startsWith("//") ? "http:" + r : !r.startsWith("http://") && !r.startsWith("https://") ? "http://" + r : r)), !(i === null || i.length === 0)) {
    if (i.length !== ha.length || !Y4(i, ha)) {
      ha = i, i.forEach((r) => {
        !Fl.includes(r) && !dh.includes(r) && !Vd.includes(r) && typeof Xi[r] > "u" && (Pe(), Xi[r] = window.setTimeout(async () => {
          const s = await J4(r, e);
          s && t(s);
        }, 500));
      }), Vd = Vd.filter((r) => ha.includes(r));
      for (const r in Xi)
        ha.includes(r) || (Pe(), window.clearTimeout(Xi[r]), delete Xi[r]);
    }
  }
}, "getEmbeds"), si = Xp() ? window.navigator.userAgent : "", qv = si.includes("iPad") || si.includes("Android") && !si.includes("Mobi") || !1, i3 = si.includes("Mobi") || qv || !1, r3 = !i3 && !qv, Vf = si.includes("Windows") ? "Windows" : si.includes("Macintosh") ? "Mac" : si.includes("iPad") || si.includes("iPhone") || si.includes("iPod") ? "iOS" : si.includes("Android") ? "Android" : void 0;
Vf === "Android" && si.includes("; wv") || Vf === "iOS" && si.includes("Safari");
const n3 = j`[part~=wy-scroll-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x-y]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;overflow-x:auto;touch-action:pan-y,pan-x}[part~=wy-scroll-x-always],[part~=wy-scroll-y-always]{overflow-y:scroll}[part~=wy-code] pre,.wy-code pre,[part~=wy-editor] .cm-content pre{text-wrap:pretty}[part~=wy-code] .code,[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code .code,.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content .code,[part~=wy-editor] .cm-content code[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;word-wrap:break-word;line-height:1.25;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}@media print{[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content code[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{text-shadow:none}}[part~=wy-code] pre[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}[part~=wy-code] :not(pre)>code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code :not(pre)>code[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content :not(pre)>code[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));background:var(--wy-background, var(--wy-background-light, #f7f9ff))}[part~=wy-code] :not(pre)>code[class*=language-],.wy-code :not(pre)>code[class*=language-],[part~=wy-editor] .cm-content :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}[part~=wy-code] .token.variable,.wy-code .token.variable,[part~=wy-editor] .cm-content .token.variable{color:var(--wy-code-variable, var(--wy-code-variable-light, #001080))}[part~=wy-code] .token.operator,.wy-code .token.operator,[part~=wy-editor] .cm-content .token.operator{color:var(--wy-code-operator, var(--wy-code-operator-light, #000000))}[part~=wy-code] .token.prolog,.wy-code .token.prolog,[part~=wy-editor] .cm-content .token.prolog{color:var(--wy-code-prolog, var(--wy-code-prolog-light, #000080))}[part~=wy-code] .token.comment,.wy-code .token.comment,[part~=wy-editor] .cm-content .token.comment{color:var(--wy-code-comment, var(--wy-code-comment-light, #008000))}[part~=wy-code] .token.builtin,.wy-code .token.builtin,[part~=wy-editor] .cm-content .token.builtin{color:var(--wy-code-builtin, var(--wy-code-builtin-light, #0070C1))}[part~=wy-code] .token.number,.wy-code .token.number,[part~=wy-editor] .cm-content .token.number{color:var(--wy-code-number, var(--wy-code-number-light, #098658))}[part~=wy-code] .token.inserted,.wy-code .token.inserted,[part~=wy-editor] .cm-content .token.inserted{color:var(--wy-code-inserted, var(--wy-code-inserted-light, #098658))}[part~=wy-code] .token.constant,.wy-code .token.constant,[part~=wy-editor] .cm-content .token.constant{color:var(--wy-code-constant, var(--wy-code-constant-light, #811F3F))}[part~=wy-code] .token.hexcode,.wy-code .token.hexcode,[part~=wy-editor] .cm-content .token.hexcode{color:var(--wy-code-hexcode, var(--wy-code-hexcode-light, #811F3F))}[part~=wy-code] .token.regex,.wy-code .token.regex,[part~=wy-editor] .cm-content .token.regex{color:var(--wy-code-regex, var(--wy-code-regex-light, #811F3F))}[part~=wy-code] .token.char,.wy-code .token.char,[part~=wy-editor] .cm-content .token.char{color:var(--wy-code-char, var(--wy-code-char-light, #811F3F))}[part~=wy-code] .token.tag,.wy-code .token.tag,[part~=wy-editor] .cm-content .token.tag{color:var(--wy-code-tag, var(--wy-code-tag-light, #800000))}[part~=wy-code] .token.attr-name,.wy-code .token.attr-name,[part~=wy-editor] .cm-content .token.attr-name{color:var(--wy-code-attr-name, var(--wy-code-attr-name-light, #E50000))}[part~=wy-code] .token.selector,.wy-code .token.selector,[part~=wy-editor] .cm-content .token.selector{color:var(--wy-code-selector, var(--wy-code-selector-light, #E50000))}[part~=wy-code] .token.property,.wy-code .token.property,[part~=wy-editor] .cm-content .token.property{color:var(--wy-code-property, var(--wy-code-property-light, #E50000))}[part~=wy-code] .token.deleted,.wy-code .token.deleted,[part~=wy-editor] .cm-content .token.deleted{color:var(--wy-code-deleted, var(--wy-code-deleted-light, #A31515))}[part~=wy-code] .token.string,.wy-code .token.string,[part~=wy-editor] .cm-content .token.string{color:var(--wy-code-string, var(--wy-code-string-light, #A31515))}[part~=wy-code] .token.changed,.wy-code .token.changed,[part~=wy-editor] .cm-content .token.changed{color:var(--wy-code-changed, var(--wy-code-changed-light, #0451A5))}[part~=wy-code] .token.punctuation,.wy-code .token.punctuation,[part~=wy-editor] .cm-content .token.punctuation{color:var(--wy-code-punctuation, var(--wy-code-punctuation-light, #000000))}[part~=wy-code] .token.function,.wy-code .token.function,[part~=wy-editor] .cm-content .token.function{color:var(--wy-code-function, var(--wy-code-function-light, #0000FF))}[part~=wy-code] .token.keyword,.wy-code .token.keyword,[part~=wy-editor] .cm-content .token.keyword{color:var(--wy-code-keyword, var(--wy-code-keyword-light, #AF00DB))}[part~=wy-code] .token.class-name,.wy-code .token.class-name,[part~=wy-editor] .cm-content .token.class-name{color:var(--wy-code-class-name, var(--wy-code-class-name-light, #267F99))}[part~=wy-code] .token.important,[part~=wy-code] .token.bold,.wy-code .token.important,.wy-code .token.bold,[part~=wy-editor] .cm-content .token.important,[part~=wy-editor] .cm-content .token.bold{font-weight:700}[part~=wy-code] .token.italic,.wy-code .token.italic,[part~=wy-editor] .cm-content .token.italic{font-style:italic}[part~=wy-editor]{box-sizing:border-box}[part~=wy-editor] .cm-scroller{font-family:unset;line-height:1.5}[part~=wy-editor] .cm-widgetBuffer{vertical-align:unset}[part~=wy-editor] .cm-placeholder{pointer-events:none;color:var(--wy-outline, var(--wy-outline-light, #72777f))}[part~=wy-editor] .cm-content{caret-color:var(--wy-on-background, var(--wy-on-background-light, #181c20))}[part~=wy-editor] .cm-content ::part(wy-link){text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-light, #2f628c))}[part~=wy-editor] .wy-mention{font-weight:700}[part~=wy-editor] .cm-editor{box-sizing:border-box;flex-direction:column;position:relative!important;display:flex!important}[part~=wy-editor] .cm-editor.cm-focused{--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));color:var(--wy-component-color);border-color:var(--wy-primary, var(--wy-primary-light, #2f628c));outline:0}[part~=wy-editor] .cm-editor .cm-scroller{overflow:auto}[part~=wy-editor] .cm-editor .cm-line{display:block;padding:0px var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) 0px var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-editor] .cm-tooltip.cm-tooltip-autocomplete>ul{font-family:unset;max-height:calc(15*var(--wy-size, 1rem))}[part~=wy-editor] .cm-tooltip.cm-tooltip-autocomplete>ul>li{padding:0}[part~=wy-editor] .cm-tooltip{border:none;background-clip:padding-box;background-color:var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));overflow:hidden;z-index:1000}[part~=wy-editor] .cm-tooltip-autocomplete ul li[aria-selected] wy-item{background:var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));color:unset}[part~=wy-editor] .cm-tooltip-autocomplete .cm-completionLabel{display:none}[part~=wy-editor] .cm-tooltip-autocomplete ::part(wy-item-interactive):hover,[part~=wy-editor] .cm-tooltip-autocomplete ::part(wy-item-interactive):focus{background:var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb))}`, a3 = j`[part~=wy-post-editor]{padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-post-editor-inputs]{display:flex;flex-direction:row;align-items:flex-end;justify-content:space-between;flex-wrap:wrap;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-post-editor-buttons]{display:flex;flex-direction:row;align-items:flex-end;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));flex:1 0 auto}[part~=wy-post-editor-text]{flex:1 1 100%;display:flex;flex-direction:column}[part~=wy-editor-parts]{display:flex;flex-direction:column;gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));min-height:0}[part~=wy-post-editor] .cm-editor{flex:1 1 100%;max-height:11.25em;min-height:4em;background-color:var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid rgba(0,0,0,0);caret-color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-post-editor] .cm-editor:focus{border-color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-post-editor] .cm-editor .cm-content{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-post-editor] .cm-editor .cm-line{padding:0}[part~=wy-post-editor] [part~=wy-is-invalid]+[data-editor-target] .cm-editor,[part~=wy-post-editor] [part~=wy-is-invalid] .cm-editor{border-color:var(--wy-error, var(--wy-error-light, #ba1821))!important}`, jv = j`[part~=wy-dragging]:after{content:attr(data-drag-title);background-color:#ffffff80;display:flex;justify-content:center;align-items:center;border:calc(.125*var(--wy-size, 1rem)) dashed var(--wy-outline, var(--wy-outline-light, #72777f));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));font-size:calc(1.5*var(--wy-size, 1rem));font-weight:var(--wy-font-weight-bold, 600);z-index:10000;position:absolute;inset:0}`;
var s3 = Object.defineProperty, o3 = Object.getOwnPropertyDescriptor, ia = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? o3(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && s3(t, e, r), r;
}, "__decorateClass$K"), Mo;
let Fi = (Mo = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.status = {
      state: "ok"
    }, this.interactive = !1, this.rounded = !1, this.isRenaming = !1;
  }
  /**
   * Emit an `edit-name` event requesting rename mode for the provided file.
   *
   * @param file - File that should enter rename mode.
   * @returns Whether the event was not canceled.
   */
  dispatchEditName(t) {
    const e = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `rename` event with a new filename.
   *
   * @param file - File being renamed.
   * @param name - New filename to apply.
   * @returns Whether the event was not canceled.
   */
  dispatchRename(t, e) {
    const i = new CustomEvent("rename", { detail: { file: t, name: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit a `trash` event to move the file to the recycle bin.
   *
   * @param file - File slated for trashing.
   * @returns Whether the event was not canceled.
   */
  dispatchTrash(t) {
    const e = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `restore` event to recover the provided file.
   *
   * @param file - File to restore from trash.
   * @returns Whether the event was not canceled.
   */
  dispatchRestore(t) {
    const e = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `delete-forever` event to permanently remove the file.
   *
   * @param file - File targeted for permanent deletion.
   * @returns Whether the event was not canceled.
   */
  dispatchDeleteForever(t) {
    const e = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling subscription for the file.
   *
   * @param file - File whose subscription changes.
   * @param subscribe - Desired subscription state.
   * @returns Whether the event was not canceled.
   */
  dispatchSubscribe(t, e) {
    const i = new CustomEvent("subscribe", { detail: { file: t, subscribe: e } });
    return this.dispatchEvent(i);
  }
  render() {
    const t = this.file;
    if (!t) return b;
    const { icon: e } = Xr(t.name), i = di(t.name), r = /* @__PURE__ */ a((o) => {
      o.stopImmediatePropagation();
      const c = o.target;
      c.value && c.value !== t.name ? this.dispatchRename(t, c.value) : this.dispatchEditName({ id: NaN });
    }, "handleRename"), s = /* @__PURE__ */ a((o) => {
      const c = o.target;
      o.key === "Escape" ? (o.preventDefault(), c.value = t.name, c.blur()) : o.key === "Enter" && (o.preventDefault(), c.blur());
    }, "handleRenameKey");
    return h`
      <wy-item
        ?rounded=${this.rounded}
        ?interactive=${this.interactive && !t.is_trashed && !this.isRenaming}
        ?trashed=${t.is_trashed}
        title=${t.name}
        size="sm"
      >
        ${this.status.state === "error" ? h`<wy-icon
              slot="image"
              name="alert-octagon"
              color="error"
              title=${dt(this.status.text)}
            ></wy-icon>` : this.status.state === "conflict" ? h`<wy-icon slot="image" name="alert" color="yellow" title=${dt(this.status.text)}></wy-icon>` : h`<wy-icon slot="image" .name=${e} .size=${24} .kind=${t.kind} ext=${i}></wy-icon>`}
        ${this.isRenaming ? h`
              <input
                slot="title"
                type="text"
                maxlength="256"
                part="wy-input"
                .defaultValue=${t.name}
                @blur=${r}
                @keyup=${(o) => {
      Br(o), s(o);
    }}
                @click=${(o) => o.preventDefault()}
                @focus=${uy}
                ${Q(Jp)}
              />
            ` : h`
              <span slot="title" title=${t.name + (this.status.text ? `: ${this.status.text}` : "")}>
                <slot name="title"
                  >${this.title || t.name}${this.status.text ? h`: <em>${this.status.text}</em>` : b}</slot
                >
              </span>
            `}

        <slot slot="actions" name="actions">
          <wy-file-menu
            .file=${t}
            @edit-name=${(o) => this.dispatchEditName(o.detail.file)}
            @trash=${(o) => this.dispatchTrash(o.detail.file)}
            @restore=${(o) => this.dispatchRestore(o.detail.file)}
            @delete-forever=${(o) => this.dispatchDeleteForever(o.detail.file)}
            @subscribe=${(o) => this.dispatchSubscribe(o.detail.file, o.detail.subscribe)}
          >
          </wy-file-menu>
        </slot>
      </wy-item>
    `;
  }
}, a(Mo, "WyFileItem"), Mo);
Fi.styles = [rn];
ia([
  u({ type: Object })
], Fi.prototype, "file", 2);
ia([
  u({ type: Object })
], Fi.prototype, "status", 2);
ia([
  u({ type: Boolean })
], Fi.prototype, "interactive", 2);
ia([
  u({ type: Boolean })
], Fi.prototype, "rounded", 2);
ia([
  u()
], Fi.prototype, "actionType", 2);
ia([
  D()
], Fi.prototype, "isRenaming", 2);
Fi = ia([
  B("wy-file-item")
], Fi);
const c3 = /* @__PURE__ */ a((n) => {
  var t, e, i, r, Wp, Wv, Kp, ua, Qp, v;
  return v = class extends n {
    /**
     * @constructor
     * @hideconstructor
     */
    constructor(...m) {
      super(...m);
      O(this, r);
      O(this, t, []);
      O(this, e);
      O(this, i, /* @__PURE__ */ new Set());
    }
    get eventParent() {
      return y(this, e);
    }
    set eventParent(m) {
      m?.eventChildren && m.eventChildren.add(this), _(this, e, m);
    }
    get eventChildren() {
      return y(this, i);
    }
    /**
     * Registers one or several event listeners. All event listeners are managed and automatically unregistered on destroy.
     *
     * When listening to weavy events, you may also listen to `before:` and `after:` events by simply adding the prefix to a weavy event.
     * Event handlers listening to weavy events may return modified data that is returned to the trigger. The data is passed on to the next event in the trigger event chain. If an event handler calls `event.stopPropagation()` or `return false`, the event chain will be stopped and the value is returned.
     *
     * @example <caption>Instance event</caption>
     * myInstance.on("before:options", function(options) { ... })
     * myInstance.on("options", function(options) { ... })
     * myInstance.on("after:options", function(options) { ... })
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#on
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string|Object} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     */
    on(...m) {
      const f = lt(this, r, Qp).call(this, m);
      if (m[3]) {
        const A = /* @__PURE__ */ a((...M) => {
          try {
            f.handler.apply(this, M);
          } catch {
            try {
              f.handler();
            } catch (R) {
              console.warn("Could not invoke one handler:", R);
            }
          }
          lt(this, r, Kp).call(this, f.events, f.selector, null, f.handler);
        }, "attachedHandler");
        lt(this, r, Wp).call(this, f.events, f.selector, A, f.handler);
      } else
        lt(this, r, Wp).call(this, f.events, f.selector, f.handler, f.handler);
    }
    /**
     * Registers one or several event listeners that are executed once. All event listeners are managed and automatically unregistered on destroy.
     *
     * Similar to {@link WeavyEvents#on}.
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#one
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string|Object} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {Function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     */
    one(m, f, $) {
      this.on(m, f, $, !0);
    }
    /**
     * Unregisters event listeners. The arguments must match the arguments provided on registration using .on() or .one().
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#off
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     * @returns {boolean} Was the handler removed?
     */
    off(...m) {
      const f = lt(this, r, Qp).call(this, m), $ = lt(this, r, Wv).call(this, f.events, f.selector, f.handler);
      return lt(this, r, Kp).call(this, f.events, f.selector, $, f.handler);
    }
    /**
     * Clears all registered eventhandlers
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#clear
     */
    clearEventHandlers() {
      y(this, t).length = 0;
    }
    /**
     * Trigger a custom event. Events are per default triggered on the weavy instance using the weavy namespace.
     *
     * The trigger has an event chain that adds `before:` and `after:` events automatically for all events except when any custom `prefix:` is specified. This way you may customize the eventchain by specifying `before:`, `on:` and `after:` in your event name to fire them one at the time. The `on:` prefix will then be removed from the name when the event is fired.
     *
     * Eventhandlers listening to the event may return modified data that is returned by the trigger event. The data is passed on to the next event in the trigger event chain. If an event handler calls `event.stopPropagation()` or `return false`, the event chain will be stopped and the value is returned.
     *
     * @example
     * // Normal triggering
     * weavyEvents.triggerEvent("myevent");
     *
     * // Will trigger the following events on the root instance
     * // 1. before:myevent.event.weavy
     * // 2. myevent.event.weavy
     * // 3. after:myevent.event.weavy
     *
     * @example
     * // Custom triggering, one at the time
     * weavyEvents.triggerEvent("before:myevent");
     * weavyEvents.triggerEvent("on:myevent");
     * weavyEvents.triggerEvent("after:myevent");
     *
     * @example
     * // Advanced triggering with data handling
     *
     * function doSomething() {
     *     // Will trigger the events sequentially and check the response data in between
     *
     *     var myTriggerData = { counter: 123, label: "my label" };
     *
     *     // Custom triggering, one at the time
     *
     *     // 1. Trigger before: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("before:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("before:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     // ...
     *
     *     // 2. Continue with on: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("on:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("on:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     // ...
     *
     *     // 3. At last trigger after: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("after:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("after:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     console.log("myevent was fully executed", myTriggerData);
     *     return myTriggerData;
     * }
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#triggerEvent
     * @param {string} name - The name of the event.
     * @param {(Array/Object/JSON)} [data] - Data may be an array or plain object with data or a JSON encoded string.
     * @param {any} ...additionalData - Any raw extra data
     * @returns {data} The data passed to the event trigger including any modifications by event handlers. Returns false if the event is cancelled.
     */
    triggerEvent(m, f, ...$) {
      const A = /^(before|on|after):/.test(m), M = A ? m.split(":")[0] : "";
      m = m.replace(/^(before|on|after):/, "");
      const R = "before:" + m, V = m, W = "after:" + m;
      if (f && typeof f == "string")
        try {
          f = JSON.parse(f);
        } catch {
          console.warn("Could not parse event data", m, f);
        }
      let I;
      if (A) {
        if (M === "before" || M === "after") {
          if (y(this, e) && (I = y(this, e).triggerEvent(
            M === "before" ? R : W,
            f,
            ...$
          ), f = I || I === !1 ? I : f, f === !1) || (I = lt(this, r, ua).call(this, M === "before" ? R : W, f, ...$), f = I || I === !1 ? I : f, f === !1))
            return f;
        } else if (M === "on" && (I = lt(this, r, ua).call(this, V, f, ...$), f = I || I === !1 ? I : f, f === !1 || y(this, e) && (I = y(this, e).triggerEvent("on:" + V, f, ...$), f = I || I === !1 ? I : f, f === !1)))
          return f;
      } else {
        if (y(this, e) && (I = y(this, e).triggerEvent(R, f, ...$), f = I || I === !1 ? I : f, f === !1) || (I = lt(this, r, ua).call(this, R, f, ...$), f = I || I === !1 ? I : f, f === !1) || (I = lt(this, r, ua).call(this, V, f, ...$), f = I || I === !1 ? I : f, f === !1) || y(this, e) && (I = y(this, e).triggerEvent("on:" + V, f, ...$), f = I || I === !1 ? I : f, f === !1) || y(this, e) && (I = y(this, e).triggerEvent(W, f, ...$), f = I || I === !1 ? I : f, f === !1))
          return f;
        I = lt(this, r, ua).call(this, W, f, ...$), f = I || I === !1 ? I : f;
      }
      return f;
    }
  }, t = new WeakMap(), e = new WeakMap(), i = new WeakMap(), r = new WeakSet(), /**
   * Saves a single event handler.
   *
   * @internal
   * @function
   * @param {string} event - One or more events. Multiple events are currently not registered individually.
   * @param {string|Object} [selector] - Optional refinement selector
   * @param {function} handler - The handler function. may be wrapped for once-handlers
   * @param {function} originalHandler - The original non-wrapped event handler.
   */
  Wp = /* @__PURE__ */ a(function(m, f, $, A) {
    y(this, t).push({
      events: m,
      selector: f,
      handler: $,
      originalHandler: A
    });
  }, "#registerEventHandler"), /**
   * Returns the event handler or wrapped event handler. The arguments must match the registered event handler.
   *
   * @internal
   * @function
   * @param {string} events - The events registered
   * @param {string|Object} [selector] - The optional selector for the handler.
   * @param {function} handler - The registered handler
   * @param {function} [originalHandler] - The original registered handler
   */
  Wv = /* @__PURE__ */ a(function(m, f, $, A) {
    const M = {
      events: m,
      selector: f,
      handler: $,
      originalHandler: A || $
    }, R = y(this, t).filter((V) => _a(M, V, !0)).pop();
    return R && R.handler;
  }, "#getEventHandler"), /**
   * Unregister an event handler. Arguments must match the registered event handler.
   *
   * @internal
   * @function
   * @param {string} event - The events registered
   * @param {function} handler - The registered handler
   * @param {string|Object} [selector] - The optional selector for the handler.
   * @returns {boolean} - True if any handler was removed
   */
  Kp = /* @__PURE__ */ a(function(m, f, $, A) {
    const M = {
      events: m,
      selector: f,
      handler: $,
      originalHandler: A
    };
    let R = !1;
    return y(this, t).forEach((V, W) => {
      _a(M, V, !0) && (R = !0, y(this, t).splice(W, 1));
    }), R;
  }, "#unregisterEventHandler"), /**
   * Triggers any local event handlers registered. Each handler may modify the data and return it or return false to cancel the event chain. .stopPropagation() and .preventDefault() may also be used.
   *
   * @example
   * weavyEvents.on("myevent", function(e, data) { ... })
   *
   * triggerHandler(this, "myevent", { key: 1 })
   *
   * @internal
   * @function
   * @param {any} eventName - The name of the event. Event names without prefix will also trigger handlers with the "on:" prefix.
   * @param {any} data - Any data to pass to the handler
   * @param {any} ...additionalData - Any extra data
   */
  ua = /* @__PURE__ */ a(function(m, f, ...$) {
    let A = !1;
    return y(this, t).forEach((M) => {
      M.events.split(" ").forEach((R) => {
        if (R = R.indexOf("on:") === 0 ? R.split("on:")[1] : R, m === R && (!M.selector || _a(M.selector, f, !0))) {
          const V = M.handler(f, ...$);
          V ? f = V : V === !1 && (A = !0);
        }
      });
    }), A ? !1 : f;
  }, "#triggerHandler"), /**
   * Extracts and normalizes all parts of the events arguments.
   *
   * @internal
   * @function
   * @param {Array.<Object>} eventArguments - The function argument list: `[context], events, [selector], handler`
   * @returns {Object}
   * @property {string} events - Event names with added namespace for local events.
   * @property {string|Object} selector - The optional selector.
   * @property {function} handler - The handler function
   * @
   */
  Qp = /* @__PURE__ */ a(function(m) {
    const f = typeof m[1] == "function" ? m[1] : m[2], $ = typeof m[1] == "function" ? null : m[1];
    return { events: m[0], selector: $, handler: f };
  }, "#getEventArguments"), a(v, "WeavyEvents"), v;
}, "MixinWeavyEvents"), l3 = c3(class {
});
function Hf(n) {
  let t = "";
  try {
    t = /^((?:https?:\/\/[^/]+)|(?:file:\/\/))\/?/.exec(n)?.[1] || "";
  } catch {
    console.error(
      "Unable to resolve location origin. Make sure you are using http, https or file protocol and have a valid location URL."
    );
  }
  return t;
}
a(Hf, "extractOrigin");
const Dw = class Dw extends l3 {
  constructor(t = {}) {
    super(), this.contentWindows = /* @__PURE__ */ new Set(), this.contentWindowsMapByWeavyId = /* @__PURE__ */ new Map(), this.contentWindowOrigins = /* @__PURE__ */ new WeakMap(), this.contentWindowNames = /* @__PURE__ */ new WeakMap(), this.contentWindowWeavyIds = /* @__PURE__ */ new WeakMap(), this.contentWindowDomain = /* @__PURE__ */ new WeakMap(), this.origin = Xp() ? Hf(window.location.href) : "", this.timeout = 2e3, t?.timeout && (this.timeout = t.timeout), window.addEventListener("message", (e) => {
      if (e.data.name && e.data.weavyId !== void 0) {
        if (e.data.weavyMessageId && e.data.name !== "message-receipt" && e.data.name !== "unready")
          try {
            e.source?.postMessage(
              { name: "message-receipt", weavyId: e.data.weavyId, weavyMessageId: e.data.weavyMessageId },
              { targetOrigin: e.origin }
            );
          } catch {
            console.error("could not post back message-receipt to source");
          }
        switch (e.data.name) {
          case "register-child": {
            if ((!e.source || !this.contentWindowWeavyIds.has(e.source)) && console.warn("register-child: contentWindow not pre-registered", e.source), e.source && this.contentWindowOrigins.get(e.source) !== e.origin) {
              console.error(
                "register-child: " + this.contentWindowNames.get(e.source) + " has invalid origin",
                e.origin
              );
              return;
            }
            try {
              const i = e.source ? this.contentWindowWeavyIds.get(e.source) : void 0, r = e.source ? this.contentWindowNames.get(e.source) : void 0;
              r && e.source && e.source.postMessage(
                {
                  name: "register-window",
                  windowName: r,
                  weavyId: i || !0
                },
                { targetOrigin: e.origin }
              );
            } catch (i) {
              console.error("could not register frame window", i);
            }
            break;
          }
          case "ready": {
            e.source && this.contentWindowsMapByWeavyId.has(e.data.weavyId) && this.contentWindowNames.has(e.source) && this.contentWindowsMapByWeavyId.get(e.data.weavyId)?.get(this.contentWindowNames.get(e.source)) && (this.contentWindowDomain.set(e.source, e.origin), this.distributeMessage(e));
            break;
          }
          case "unready": {
            this.contentWindowsMapByWeavyId.has(e.data.weavyId) && this.distributeMessage(e, !0);
            break;
          }
          default: {
            (e.source === window || this.contentWindowsMapByWeavyId.size) && this.distributeMessage(e);
            break;
          }
        }
      }
    });
  }
  /**
   * The weavy console logging.
   */
  get console() {
    return console;
  }
  distributeMessage(t, e = !1) {
    const i = t.source === window && t.origin === this.origin;
    if (e ||= t.source && this.contentWindowOrigins.has(t.source) && t.origin === this.contentWindowOrigins.get(t.source) || !1, i || e) {
      e && !t.data.windowName && t.source && (t.data.windowName = this.contentWindowNames.get(t.source));
      const r = t.data.name;
      r && this.triggerEvent(r, t.data, t), this.triggerEvent("message", t.data, t);
    }
  }
  /**
   * Sends the id of a frame to the frame content scripts, so that the frame gets aware of which id it has.
   * The frame needs to have a unique name attribute.
   *
   * @category panels
   * @param {string} weavyId - The id of the group or entity which the contentWindow belongs to.
   * @param {Window} contentWindow - The frame window to send the data to.
   */
  registerContentWindow(t, e, i, r) {
    try {
      if (!e) {
        console.error("registerContentWindow() No valid contentWindow to register, must be a window and have a name.");
        return;
      }
    } catch {
      console.error("registerContentWindow() cannot access contentWindowName");
    }
    t.self && (t = t.self), this.console.log("registerContentWindow", t), (!i || i === "true") && (i = !0), this.contentWindowsMapByWeavyId.has(i) || this.contentWindowsMapByWeavyId.set(i, /* @__PURE__ */ new Map()), this.contentWindowsMapByWeavyId.get(i)?.set(e, t), this.contentWindows.add(t), this.contentWindowNames.set(t, e), this.contentWindowWeavyIds.set(t, i), this.contentWindowOrigins.set(t, r);
  }
  unregisterAll(t) {
    this.contentWindowsMapByWeavyId.has(t) && (this.contentWindowsMapByWeavyId.get(t)?.forEach((e, i) => {
      this.unregisterContentWindow(i, t);
    }), this.contentWindowsMapByWeavyId.get(t), this.contentWindowsMapByWeavyId.delete(t));
  }
  unregisterContentWindow(t, e) {
    if (this.contentWindowsMapByWeavyId.has(e)) {
      if (this.contentWindowsMapByWeavyId.get(e)?.has(t)) {
        const i = this.contentWindowsMapByWeavyId.get(e)?.get(t);
        if (i)
          try {
            this.contentWindows.delete(i), this.contentWindowNames.delete(i), this.contentWindowWeavyIds.delete(i), this.contentWindowOrigins.delete(i);
          } catch {
          }
      }
      if (this.contentWindowsMapByWeavyId.get(e)?.delete(t), this.contentWindowsMapByWeavyId.get(e)?.size === 0)
        try {
          this.contentWindowsMapByWeavyId.delete(e);
        } catch {
        }
    }
  }
  async whenPostMessage(t, e, i) {
    Pe(), i === null && (i = void 0);
    const r = t === window.self, s = r ? Hf(window.location.href) : this.contentWindowOrigins.get(t);
    if (r || t && s === this.contentWindowDomain.get(t)) {
      e.weavyMessageId || (e.weavyMessageId = fl() + fl());
      let c;
      await Promise.race([
        new Promise((l, p) => {
          c = window.setTimeout(() => {
            p(new Error("postMessage() receipt timed out: " + e.weavyMessageId + ", " + e.name));
          }, this.timeout || 2e3);
        }),
        new Promise((l) => {
          this.on("message-receipt", { weavyId: e.weavyId, weavyMessageId: e.weavyMessageId }, () => {
            clearTimeout(c), l(void 0);
          }), t.postMessage(e, { targetOrigin: s, transfer: i });
        })
      ]);
    } else
      throw new Error("postMessage() Invalid window origin: " + s + ", " + e.name);
  }
  postToChildren(t, e) {
    if (typeof t != "object" || !t.name) {
      console.error("postToChildren() Invalid message format", t);
      return;
    }
    e === null && (e = void 0), t.distributeName = t.name, t.name = "distribute", t.weavyId = t.weavyId || !0, this.contentWindows.forEach((i) => {
      const r = this.contentWindowOrigins.get(i);
      if (r === this.contentWindowDomain.get(i))
        try {
          i.postMessage(t, { targetOrigin: r, transfer: e });
        } catch {
          console.warn(
            "postToChildren() could not distribute message to " + this.contentWindowNames.get(i)
          );
        }
    });
  }
  async postToFrame(t, e, i, r) {
    if (typeof i != "object" || !i.name) {
      console.error("postToFrame() Invalid message format", i);
      return;
    }
    const s = this.contentWindowsMapByWeavyId.get(e)?.get(t);
    if (!s)
      throw new Error(`postToFrame() Window not registered: ${e}, ${t}`);
    return i.weavyId = e, await this.whenPostMessage(s, i, r);
  }
  async postToSelf(t, e) {
    if (typeof t != "object" || !t.name) {
      console.error("postToSelf() Invalid message format", t);
      return;
    }
    return t.weavyId = t.weavyId || !0, await this.whenPostMessage(window.self, t, e);
  }
  postToSource(t, e, i) {
    if (t.source && t.data.weavyId !== void 0) {
      const r = t.source === window.self && t.origin === this.origin, s = this.contentWindowOrigins.has(t.source) && t.origin === this.contentWindowOrigins.get(t.source);
      if (i === null && (i = void 0), r || s) {
        e.weavyId = t.data.weavyId;
        try {
          t.source.postMessage(e, { targetOrigin: t.origin, transfer: i });
        } catch (o) {
          console.error("postToSource() Could not post message back to source", o);
        }
      }
    }
  }
};
a(Dw, "WeavyPostalParent");
let Gp = Dw;
var d3 = Object.defineProperty, h3 = Object.getOwnPropertyDescriptor, Bh = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? h3(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && d3(t, e, r), r;
}, "__decorateClass$J"), Ao;
let Hn = (Ao = class extends Te {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.iframeVisible = !1, this.showOverlay = !1, this.isRegistered = !1, this.iframeElementRef = nt(), this.overlayRef = nt();
  }
  /**
   * Open the file picker overlay.
   */
  open() {
    this.showOverlay = !0;
  }
  /**
   * Close the file picker overlay.
   */
  close() {
    this.showOverlay = !1, this.iframeVisible = !1;
  }
  /**
   * Returns the topmost available window/frame origin used when building the iframe src.
   *
   * @internal
   */
  get origin() {
    let t = "";
    try {
      window.location.ancestorOrigins && 0 < window.location.ancestorOrigins.length ? t = window.location.ancestorOrigins[window.location.ancestorOrigins.length - 1] : window.top && (t = window.top.document.location.origin);
    } catch {
    }
    if (!t)
      try {
        t = window.self.document.location.origin;
      } catch {
        console.error("Filebrowser: Could not read current origin.");
      }
    return t;
  }
  /**
   * Trigger `external-blobs` event with any selected blobs.
   *
   * @internal
   * @param {ExternalBlobType[] | null} externalBlobs - The externally selected blobs.
   * @returns {boolean} Whether the event was successful.
   */
  dispatchExternalBlobs(t) {
    const e = new CustomEvent("external-blobs", {
      detail: { externalBlobs: t }
    });
    return this.dispatchEvent(e);
  }
  connectedCallback() {
    super.connectedCallback(), this.handleFiles = (t, e) => {
      e.source === this.iframeElementRef.value?.contentWindow?.self && (this.dispatchExternalBlobs(t.blobs), this.close());
    }, this.handleClose = (t, e) => {
      e.source === this.iframeElementRef.value?.contentWindow?.self && this.close();
    }, this.handleGoogleSelected = (t, e) => {
      e.source === this.iframeElementRef.value?.contentWindow?.self && this.overlayRef.value && (this.overlayRef.value.maximized = !0);
    }, this.weavyPostal || (this.weavyPostal = new Gp()), this.weavyPostal.on("add-external-blobs", this.handleFiles), this.weavyPostal.on("request:file-browser-close", this.handleClose), this.weavyPostal.on("google-selected", this.handleGoogleSelected);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.weavyPostal?.off("add-external-blobs", this.handleFiles), this.weavyPostal?.off("request:file-browser-close", this.handleClose), this.weavyPostal?.off("google-selected", this.handleGoogleSelected);
  }
  updated() {
    this.weavy && (this.showOverlay && !this.src && (this.src = new URL(
      "?origin=" + this.origin + "&v=X&t=" + Date.now().toString() + "&weavyId=wy-filebrowser",
      this.weavy.cloudFilePickerUrl
    )), this.weavyPostal && !this.isRegistered && this.showOverlay && this.src ? this.iframeElementRef.value?.contentWindow && (this.weavyPostal.registerContentWindow(
      this.iframeElementRef.value?.contentWindow.self,
      "weavy-filebrowser",
      "wy-filebrowser",
      this.src.origin
    ), this.isRegistered = !0) : this.weavyPostal && this.isRegistered && !this.showOverlay && this.src && (this.weavyPostal.unregisterContentWindow("weavy-filebrowser", "wy-filebrowser"), this.isRegistered = !1, this.src = void 0));
  }
  render() {
    return this.weavy ? h`
      <wy-overlay
        ?noHeader=${this.iframeVisible}
        part="wy-cloud-files-overlay"
        .show=${this.showOverlay}
        ${Q(this.overlayRef)}
        @close=${() => this.close()}
      >
        ${this.showOverlay ? h`
              <wy-progress-circular
                part="wy-cloud-files-progress"
                indeterminate
                overlay
                ?hidden=${this.iframeVisible}
              ></wy-progress-circular>
              <iframe
                part="wy-cloud-picker-frame"
                ${Q(this.iframeElementRef)}
                @load=${() => this.iframeVisible = !0}
                src=${dt(this.src?.toString())}
                id="weavy-filebrowser"
                name="weavy-filebrowser"
                title=${x("Cloud File Browser")}
              ></iframe>
            ` : b}
      </wy-overlay>
    ` : b;
  }
}, a(Ao, "WyCloudFiles"), Ao);
Hn.styles = [
  X,
  j`
      [part~="wy-cloud-picker-frame"] {
        flex: 1 1 100%;
        border: 0;
      }
    `
];
Bh([
  D()
], Hn.prototype, "src", 2);
Bh([
  D()
], Hn.prototype, "iframeVisible", 2);
Bh([
  D()
], Hn.prototype, "showOverlay", 2);
Hn = Bh([
  B("wy-cloud-files"),
  ht()
], Hn);
var u3 = Object.defineProperty, p3 = Object.getOwnPropertyDescriptor, zt = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? p3(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && u3(t, e, r), r;
}, "__decorateClass$I"), Eo;
let $t = (Eo = class extends Dt {
  constructor() {
    super(), this.exportParts = new q(this), this.storage = dm("localStorage"), this.disabled = !1, this._placeholder = "", this.text = "", this.metadata = {}, this.options = [], this.attachments = [], this.buttonText = "", this.typing = !0, this.draft = !1, this.editorType = "posts", this.editorClass = "wy-post-editor", this.editorLocation = "apps", this.editorError = !1, this.showPolls = !1, this.pollOptions = [], this._embeds = [], this.draftKey = "", this.uploadBlobMutation = new ti(
      this
    ), this.mutatingFiles = new kc(this), this.fileInputRef = nt(), this.cloudFilesRef = nt(), this.dropZone = new th(this), this.keyMap = [], this.editorRef = nt(), this.editorInitialized = !1, this.throttledTyping = jp(
      async () => {
        this.weavy && this.app && !Jd.has(this.app.type) && await K4(this.weavy, this.app.id).mutate();
      },
      2e3,
      { leading: !0, trailing: !1 }
    ), this.throttledDrafting = jp(
      () => {
        this.saveDraft();
      },
      500,
      { leading: !0, trailing: !0 }
    ), this.openFileInput = () => {
      this.fileInputRef.value?.click();
    }, this.openCloudFiles = () => {
      this.cloudFilesRef.value?.open();
    }, this.createMeeting = async (t) => {
      if (this.weavy && t.source === this.authWindow && this.weavy.url.origin === t.origin && t.data && t.data.name && t.data.name.endsWith("-authorized")) {
        const e = t.data.name.slice(0, -11), r = await Ff(this.weavy, e).mutate();
        r.auth_url || (this.meeting = r);
      }
    }, this.addEventListener("drop-files", (t) => this.handleDropFiles(t)), this.addEventListener("keydown", rh), this.addEventListener("keyup", Br);
  }
  set placeholder(t) {
    this._placeholder = t;
  }
  get placeholder() {
    return this._placeholder;
  }
  /**
   * Select all content in the editor.
   *
   * @internal
   */
  selectAllContent() {
    this.editor?.dispatch({
      selection: {
        anchor: 0,
        head: this.editor.state.doc.length
      }
    });
  }
  /**
   * Place cursor at the end of the editor content.
   *
   * @internal
   */
  setCursorLast() {
    this.editor?.dispatch({
      selection: {
        anchor: this.editor.state.doc.length,
        head: this.editor.state.doc.length
      }
    });
  }
  /**
   * Focus the editor input.
   *
   * @internal
   */
  focusInput() {
    this.editor?.focus();
  }
  set embeds(t) {
    const e = t.filter((i) => i.type !== "link" || i.title || i.description);
    this._embeds = [...e];
  }
  get embeds() {
    return this._embeds;
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("app") && (this.mutationAppId = void 0), (t.has("weavy") || t.has("app") || t.has("user") || t.has("parentId")) && this.weavy && this.app && this.user) {
      if (this.mutationAppId = this.mutationAppId ?? this.app?.id ?? Date.now() * -1, this.draftKey = `draft-${this.editorType}-${this.parentId || this.mutationAppId}`, this.uploadBlobMutation.trackMutation(
        yy(
          this.weavy,
          this.user,
          this.mutationAppId,
          `${this.editorLocation}-${this.parentId || this.mutationAppId}`
        )
      ), this.mutatingFiles.trackMutationState(
        {
          filters: {
            mutationKey: [
              "apps",
              this.mutationAppId,
              "blobs",
              `${this.editorLocation}-${this.parentId || this.mutationAppId}`
            ],
            exact: !0
          }
        },
        this.weavy.queryClient
      ), this.externalBlobMutation = Uv(
        this.weavy,
        this.user,
        this.mutationAppId,
        `${this.editorLocation}-${this.parentId || this.mutationAppId}`
      ), this.draft && this.storage) {
        const e = this.storage.getItem(this.draftKey);
        if (e) {
          const i = JSON.parse(e);
          this.text = i.text, this.embeds = i.embeds, this.meeting = i.meeting, i.pollOptions?.length > 0 && (this.showPolls = !0, this.pollOptions = i.pollOptions), Df(this.embeds.map((r) => r.url).filter((r) => typeof r == "string"));
        } else
          this.clearEditor();
      }
      this.embed && (this.embeds = [this.embed], Df(this.embeds.map((e) => e.url).filter((e) => typeof e == "string"))), this.options && this.options.length > 0 && (this.pollOptions = this.options, this.showPolls = !0);
    }
    t.has("text") && this.editor && this.editor.state.doc.toString() !== this.text && this.editor.dispatch({ changes: { from: 0, to: this.editor.state.doc.length, insert: this.text } });
  }
  updated(t) {
    if ((t.has("weavy") || t.has("app") || t.has("user") || t.has("parentId")) && this.weavy && this.user && this.editorRef.value && this.weavy.whenUrl().then(() => {
      import(
        /* webpackIgnore: true */
        /* @vite-ignore */
        new URL("./es/editor-M1x0pxVu.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
      ).then((e) => e.editor).then(
        ({
          weavyHighlighter: e,
          syntaxHighlighting: i,
          history: r,
          dropCursor: s,
          mentions: o,
          autocompletion: c,
          placeholder: l,
          keymap: p,
          weavyKeymap: v,
          defaultKeymap: C,
          historyKeymap: g,
          markdown: m,
          languages: f,
          EditorView: $,
          EditorState: A,
          weavyEnterSendKeymap: M,
          weavyModifierEnterSendKeymap: R,
          Compartment: V
        }) => {
          this.editorInitialized || (this.editorInitialized = !0, this.editorEditable = new V(), this.editorPlaceholder = new V(), this.editorKeymap = new V(), this.EditorView = $, this.placeholderExtension = l, this.keymapFacet = p, this.keymaps = {
            weavyEnterSendKeymap: M,
            weavyModifierEnterSendKeymap: R,
            weavyKeymap: v,
            defaultKeymap: [...C],
            historyKeymap: [...g]
          }, this.editorExtensions = [
            $.contentAttributes.of({
              spellcheck: "true",
              autocorrect: "on",
              autocapitalize: "on",
              enterkeyhint: this.settings?.enterToSend === "always" ? "send" : "enter"
            }),
            r(),
            s(),
            o,
            c({
              override: this.componentFeatures?.allowsFeature(S.Mentions) ? [(W) => this.autocomplete(W)] : [],
              //showMention
              closeOnBlur: !1,
              aboveCursor: this.editorType !== "posts",
              icons: !1,
              addToOptions: [
                {
                  render: /* @__PURE__ */ a(function(W, I) {
                    const U = document.createElement("wy-item");
                    U.interactive = !1, (!W.item?.access || W.item.access === br.None) && (U.disabled = !0);
                    const K = document.createElement("wy-avatar");
                    K.slot = "image", K.src = W.item?.avatar_url || "", K.name = W.item?.name || "";
                    const tt = document.createElement("span");
                    return tt.slot = "title", tt.innerText = W.item?.name || "", U.appendChild(K), U.appendChild(tt), U;
                  }, "render"),
                  position: 10
                }
              ]
            }),
            i(e, { fallback: !0 }),
            $.lineWrapping,
            m({ codeLanguages: f }),
            $.domEventHandlers({
              paste: /* @__PURE__ */ a((W, I) => {
                let U = [];
                const K = W.clipboardData?.items || [];
                for (const tt of K)
                  if (tt.kind === "file") {
                    const ot = tt.getAsFile();
                    ot && (U = [...U, ot]);
                  }
                if (this.componentFeatures?.allowsFeature(S.Attachments) && U.length > 0) {
                  for (let tt = 0; tt < U.length; tt++)
                    this.handleUploadFiles(U);
                  return !0;
                }
              }, "paste"),
              keyup: /* @__PURE__ */ a((W, I) => {
                this.text = I.state.doc.toString(), this.componentFeatures?.allowsFeature(S.Typing) && this.typing && I.state.doc.toString() !== "" && this.throttledTyping(), this.draft && this.throttledDrafting(), this.componentFeatures?.allowsFeature(S.Embeds) && I.state.doc.toString() !== "" && this.handleEmbeds(I.state.doc.toString());
              }, "keyup")
            }),
            // Compartments
            this.editorEditable.of($.editable.of(!this.disabled)),
            this.editorPlaceholder.of(this.placeholderExtension(this.placeholder)),
            this.editorKeymap.of(this.keymapFacet.of(this.getKeymaps())),
            $.updateListener.of((W) => {
              this.setPlaceHolderText();
              const I = Array.from(
                (this.editor?.state).config.compartments.keys()
              );
              this.editorEditable = I[0], this.editorPlaceholder = I[1], this.editorKeymap = I[2];
            })
          ], this.editor || (this.editor = new $({
            state: A.create({
              doc: this.text,
              extensions: this.editorExtensions
            }),
            parent: this.editorRef.value
          }), this.editorRef.value?.addEventListener("wy-submit", this.submit.bind(this))));
        }
      );
    }), t.has("disabled") && this.editor && this.editorEditable && this.EditorView && this.editor.dispatch({
      // Update readonly state
      effects: this.editorEditable.reconfigure(this.EditorView.editable.of(!this.disabled))
    }), t.has("placeholder") && this.editor && this.editorPlaceholder && this.placeholderExtension) {
      const e = this.placeholderExtension(this.placeholder);
      this.editor.dispatch({
        // Update placeholder state
        effects: this.editorPlaceholder.reconfigure(e)
      }), this.setPlaceHolderText();
    }
    t.has("settings") && this.editor && this.editorKeymap && this.keymapFacet && (this.editor.dispatch({
      // Update readonly state
      effects: this.editorKeymap.reconfigure(this.keymapFacet.of(this.getKeymaps()))
    }), this.setEnterKeyHint());
  }
  /**
   * Update the visible placeholder text within the fallback DOM copy.
   *
   * @internal
   */
  setPlaceHolderText() {
    const t = this.renderRoot.querySelector(".cm-placeholder");
    t && this.editor && (t.setAttribute("aria-label", `placeholder ${this.placeholder}`), t.innerText = this.placeholder);
  }
  /**
   * Update contentEditable attribute on the fallback editor.
   *
   * @internal
   */
  setEditable() {
    const t = this.renderRoot.querySelector(".cm-content");
    t && this.editor && (t.contentEditable = String(!this.disabled));
  }
  /**
   * Update enter key hint on the content element.
   *
   * @internal
   */
  setEnterKeyHint() {
    const t = this.renderRoot.querySelector(".cm-content");
    t && this.editor && (t.enterKeyHint = this.settings?.enterToSend === "always" ? "send" : "enter");
  }
  /**
   * Compute and return keymaps for the current settings/editor type.
   *
   * @internal
   */
  getKeymaps() {
    if (!this.keymaps)
      return [];
    const { weavyEnterSendKeymap: t, weavyModifierEnterSendKeymap: e, weavyKeymap: i, defaultKeymap: r, historyKeymap: s } = this.keymaps;
    let o = this.settings?.enterToSend === "never" ? [] : [...e];
    return ((!this.settings?.enterToSend || this.settings?.enterToSend === "auto") && this.editorType === "messages" && r3 || this.settings?.enterToSend === "always") && (o = [...t, ...o]), [...o, ...i, ...r, ...s];
  }
  connectedCallback() {
    super.connectedCallback(), window.addEventListener("message", this.createMeeting);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("message", this.createMeeting);
  }
  handleRemoveMeeting() {
    this.meeting = void 0;
  }
  /**
   * Autocomplete handler for mentions. Returns completion results or null.
   *
   * Called by the editor to resolve mention suggestions.
   *
   * @internal
   * @param context - Completion context from the editor
   * @returns Promise<CompletionResult | null>
   */
  async autocomplete(t) {
    if (!this.weavy || !this.app)
      return null;
    let e = t.matchBefore(/(?:^|\s)(?!\]\()@(?=\S)([^@]+)/);
    if (!t.explicit && !e) return null;
    e = t.matchBefore(/@[^@]+/);
    const i = e?.text.substring(1), s = await (await this.weavy.fetch(`/api/apps/${this.app.id}/members?member=null&q=${i}`)).json();
    let o = [];
    return s.data && (o = s.data.filter((c) => typeof c.name < "u").map((c) => ({
      item: c,
      label: c.name,
      apply: /* @__PURE__ */ a((l, p, v, C) => {
        const g = "[" + c.name + "](@u" + c.id.toString() + ")";
        let m = l.state.update({ changes: { from: v - 1, to: v } });
        l.dispatch(m), m = l.state.update({
          changes: { from: v - 1, to: C - 1, insert: g }
        }), l.dispatch(m);
      }, "apply")
    }))), {
      from: e ? e.from + 1 : t.pos,
      options: o,
      filter: !1
    };
  }
  /**
   * Handle files dropped on the editor.
   *
   * @internal
   * @param e - Drop files event
   */
  handleDropFiles(t) {
    const e = t.detail;
    e.files && this.handleUploadFiles(e.files);
  }
  /**
   * Upload array of File objects via the upload blob mutation controller.
   *
   * Preserves input value if provided and saves draft after each upload.
   *
   * @internal
   * @param files - FileList or array of File objects to upload
   * @param input - Optional input element to reset after upload
   */
  async handleUploadFiles(t, e) {
    if (t) {
      for (let i = 0; i < t.length; i++) {
        const s = { file: t[i] };
        await this.uploadBlobMutation.mutate(s), this.saveDraft();
      }
      e && (e.value = "");
    }
  }
  /**
   * Handle external blob imports (cloud/external sources).
   *
   * @internal
   * @param externalBlobs - Array of external blob descriptors
   */
  handleExternalBlobs(t) {
    if (t)
      for (let e = 0; e < t.length; e++) {
        const i = t[e];
        this.externalBlobMutation?.mutate({ externalBlob: i });
      }
  }
  /**
   * Handle removal/abortion of an upload mutation and clean cache state.
   *
   * @internal
   * @param mutation - Mutation state object to remove
   */
  handleRemoveUpload(t) {
    !this.weavy || !this.mutationAppId || (t.status === "pending" && Mp(t.variables) && t.variables.abort?.(), Nm(
      this.weavy.queryClient,
      ["apps", this.mutationAppId, "blobs", `${this.editorLocation}-${this.parentId || this.mutationAppId}`],
      (e) => e.state.data?.id === t.data?.id
    ));
  }
  /**
   * Persist draft to storage if draft mode is enabled.
   *
   * Saves editor text, embeds, poll options and ongoing file uploads to localStorage.
   *
   * @internal
   */
  saveDraft() {
    if (!this.draft || !this.storage) return;
    const t = this.mutatingFiles.result;
    let e = this.editor?.state.doc.toString();
    if (e === void 0 && (e = this.text), (!t || !t.length) && !this.meeting && !this.embeds.length && (!this.pollOptions.length || this.pollOptions.filter((i) => i.text.trim() !== "").length === 0) && e === "")
      this.storage.removeItem(this.draftKey);
    else {
      const i = {
        meeting: this.meeting,
        text: e,
        pollOptions: this.pollOptions.filter((r) => r.text.trim() !== ""),
        embeds: this.embeds
      };
      this.storage.setItem(this.draftKey, JSON.stringify(i));
    }
  }
  /**
   * Handle removal of an attachment reference from the editor state.
   *
   * @internal
   * @param attachment - Attachment to remove
   */
  handleRemoveAttachment(t) {
    this.attachments = this.attachments.filter((e) => e.id !== t.id);
  }
  /**
   * Submit the editor content by dispatching a `submit` event.
   *
   * Validates that there is content to submit and that no uploads/embeds are still processing.
   *
   * @internal
   */
  submit() {
    const t = this.mutatingFiles.result, e = t?.some((v) => v.status === "pending"), i = this.editor?.state.doc.toString().trim() ?? "", r = this.meeting?.id, s = t?.map((v) => v.data?.id).filter((v) => v), o = this.attachments?.map((v) => v.id) || [], c = this.pollOptions.filter((v) => v.text.trim() !== "");
    if (X4() || e || !this.contextDataBlobs || !i && !r && s?.length == 0 && c.length == 0 && o.length == 0 && this.embeds.length == 0)
      return;
    const l = this.contextDataBlobs.length ? this.contextDataBlobs : void 0, p = new CustomEvent("submit", {
      detail: { text: i, meetingId: r, blobs: s, attachments: o, pollOptions: c, embedId: this.embeds[0]?.id, contextData: l },
      bubbles: !0,
      composed: !0
    });
    this.dispatchEvent(p), this.resetEditor();
  }
  /**
   * Reset the editor state after a successful submit.
   *
   * Clears editor content, removes pending uploads from the query cache and deletes the stored draft.
   *
   * @internal
   */
  resetEditor() {
    this.clearEditor(), this.weavy && this.mutationAppId && P0(this.weavy.queryClient, [
      "apps",
      this.mutationAppId,
      "blobs",
      `${this.editorLocation}-${this.parentId || this.mutationAppId}`
    ]), this.storage?.removeItem(this.draftKey);
  }
  /**
   * Clear the editor UI and internal state (text, embeds, attachments, metadata).
   *
   * @internal
   */
  clearEditor() {
    this.editor?.dispatch({ changes: { from: 0, to: this.editor.state.doc.length, insert: "" } }), this.text = "", this.meeting = void 0, this.pollOptions = [], this.showPolls = !1, this.embeds = [], this.metadata = {}, t3();
  }
  /**
   * Create or initiate a meeting for the current user.
   *
   * If the meeting requires third-party auth, opens an auth popup; otherwise stores the created meeting.
   *
   * @internal
   * @param name - Provider key for the meeting (e.g. "zoom", "google", "microsoft")
   */
  async handleMeetingClick(t) {
    if (!this.weavy || !this.user)
      return;
    const i = await Ff(this.weavy, t).mutate();
    i.auth_url ? this.authWindow = window.open(i.auth_url, "oauthwin", "height=640,width=480") : this.meeting = i;
  }
  /**
   * Add a discovered embed to the editor and persist draft.
   *
   * @internal
   * @param embed - Embed object to add.
   */
  setEmbeds(t) {
    this.embeds = [t, ...this.embeds], this.saveDraft();
  }
  /**
   * Scan content for embeds and add them via setEmbeds callback.
   *
   * @internal
   * @param content - Text content to scan for embed links.
   */
  handleEmbeds(t) {
    this.weavy && e3(t, this.setEmbeds.bind(this), this.weavy);
  }
  /**
   * Remove an embed by id from the editor embeds list and persist draft.
   *
   * @internal
   * @param e - Embed remove event containing embed id.
   */
  removeEmbed(t) {
    this.embeds = this.embeds.filter((e) => e.id !== t.detail.id), this.saveDraft();
  }
  /**
   * Cycle the primary embed (move first to the end) and persist draft.
   *
   * @internal
   */
  swapEmbed() {
    const t = this.embeds.shift();
    t && (this.embeds = [...this.embeds, t]), this.saveDraft();
  }
  /**
   * Toggle the poll UI in the editor and initialize default options when opened.
   *
   * @internal
   */
  openPolls() {
    this.showPolls ? this.showPolls = !1 : (this.pollOptions.length === 0 && (this.pollOptions = Array.from({ length: 3 }, () => ({ id: null, text: "" }))), this.showPolls = !0);
  }
  /**
   * Handle change to a poll option input and persist draft.
   *
   * @internal
   * @param e - Input event
   * @param index - Index of the poll option changed
   */
  handlePollOptionChange(t, e) {
    const i = [...this.pollOptions];
    i[e].text = t.target.value, this.pollOptions = i, this.saveDraft();
  }
  /**
   * Add a new poll option when focus reaches the last option (limit 5).
   *
   * @internal
   * @param e - Focus/keyboard event
   * @param index - Index of the poll option that triggered the add
   */
  handlePollOptionAdd(t, e) {
    if (e === this.pollOptions.length - 1 && this.pollOptions.length < 5) {
      const i = { id: null, text: "" };
      this.pollOptions = [...this.pollOptions, i], this.saveDraft();
    }
  }
  /**
   * Editor loading fallback dummy.
   * Hard copy of the rendered nodes when the editor is empty. Cleaned up to not be editable.
   */
  renderEditorDummy() {
    return this.editorInitialized ? b : h`
          <div class="cm-editor">
            <div class="cm-announced"></div>
            <div tabindex="-1" class="cm-scroller">
              <div class="cm-content cm-lineWrapping">
                <div class="cm-line"
                  ><img class="cm-widgetBuffer" aria-hidden="true" /><span class="cm-placeholder"
                    >${this.placeholder}</span
                  ><br
                /></div>
              </div>
            </div>
          </div>
        `;
  }
  renderTopSlot() {
    return b;
  }
  renderMiddleSlot() {
    return h`
      <!-- Input -->
      <div part=${J({ "wy-post-editor-text": !0, "wy-is-invalid": this.editorError })} ${Q(this.editorRef)}>
        ${this.renderEditorDummy()}
      </div>

      <div part="wy-post-editor-inputs">
        <div part="wy-post-editor-buttons">
          ${this.componentFeatures?.allowsFeature(S.Attachments) ? h`<wy-button
                  kind="icon"
                  @click=${this.openFileInput}
                  title=${x("From device")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon name="attachment"></wy-icon>
                </wy-button>
                <input
                  type="file"
                  ${Q(this.fileInputRef)}
                  @click=${(t) => t.stopPropagation()}
                  @change=${(t) => this.handleUploadFiles(
      Array.from(t.target.files || []),
      t.target
    )}
                  multiple
                  hidden
                  tabindex="-1"
                  ?disabled=${this.disabled}
                />` : b}
          ${this.componentFeatures?.allowsFeature(S.CloudFiles) ? h`<wy-button
                kind="icon"
                @click=${this.openCloudFiles}
                title=${x("From cloud")}
                ?disabled=${this.disabled}
              >
                <wy-icon name="cloud"></wy-icon>
              </wy-button>` : b}
          ${this.componentFeatures?.allowsAnyFeature(S.Meetings, S.ZoomMeetings) ? h`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("zoom")}
                  title=${x("Zoom meeting")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="zoom-meetings"></wy-icon>
                </wy-button>
              ` : b}
          ${this.componentFeatures?.allowsAnyFeature(S.Meetings, S.GoogleMeet) ? h`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("google")}
                  title=${x("Google Meet")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="google-meet"></wy-icon>
                </wy-button>
              ` : b}
          ${this.componentFeatures?.allowsAnyFeature(S.Meetings, S.MicrosoftTeams) ? h`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("microsoft")}
                  title=${x("Microsoft Teams")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="microsoft-teams"></wy-icon>
                </wy-button>
              ` : b}
          ${this.componentFeatures?.allowsFeature(S.Polls) ? h`<wy-button
                kind="icon"
                @click=${() => this.openPolls()}
                title=${x("Poll")}
                ?disabled=${this.disabled}
              >
                <wy-icon name="poll"></wy-icon>
              </wy-button>` : b}
        </div>

        <!-- Button -->
        <wy-button @click="${() => this.submit()}" color="primary" title=${this.buttonText} ?disabled=${this.disabled}>
          ${this.buttonText}
        </wy-button>
      </div>
    `;
  }
  /**
   * Render the bottom slot which aggregates lists (polls, meetings, file uploads, attachments, embeds).
   *
   * @internal
   */
  renderBottomSlot() {
    return [this.renderLists()];
  }
  /**
   * Render the lists section (poll options, meetings, file uploads, attachments, embeds).
   *
   * @internal
   */
  renderLists() {
    const t = this.mutatingFiles.result, e = this.componentFeatures?.allowsFeature(S.Polls) && this.showPolls && this.pollOptions.length > 0 || !1, i = this.meeting?.provider === "zoom" && this.componentFeatures?.allowsAnyFeature(S.Meetings, S.ZoomMeetings) || this.meeting?.provider === "google" && this.componentFeatures?.allowsAnyFeature(S.Meetings, S.GoogleMeet) || this.meeting?.provider === "microsoft" && this.componentFeatures?.allowsAnyFeature(S.Meetings, S.MicrosoftTeams) || !1, r = t && t.length > 0 || !1, s = this.attachments && this.attachments.length > 0, o = this.componentFeatures?.allowsFeature(S.Embeds) && this.embeds.length > 0 || !1;
    return this.disabled || !(e || i || r || s || o) ? b : h` <div part="wy-editor-parts">
      <!-- polls -->
      ${e ? h`
            <div part="wy-poll-form">
              ${this.pollOptions.map((c, l) => {
      const p = l + 1;
      return h`<input
                  value="${c.text}"
                  part="wy-input"
                  type="text"
                  placeholder=${x(gt`Option ${p}`)}
                  @change=${(v) => this.handlePollOptionChange(v, l)}
                  @keyup=${Br}
                  @focus=${(v) => this.handlePollOptionAdd(v, l)}
                />`;
    })}
            </div>
          ` : b}

      <!-- meetings -->
      ${i && this.meeting ? h`
            <wy-item size="sm">
              <wy-icon slot="image" svg="${Up(this.meeting.provider)}"></wy-icon>
              <span slot="title">${qp(this.meeting.provider)}</span>
              <wy-button slot="actions" kind="icon" @click=${() => this.handleRemoveMeeting()}>
                <wy-icon name="close"></wy-icon>
              </wy-button>
            </wy-item>
          ` : b}

      <!-- blobs -->
      ${r && t ? h`<div>
            ${je(
      t,
      (c) => "mutation" + c.submittedAt,
      (c) => {
        if (c.context?.file) {
          const l = c.context.file, p = {
            ...c.context.status
          };
          return h`
                    <wy-file-item
                      .file=${c.context.file}
                      .status=${p}
                      title="${sm(c.context.type)}: ${l.name + (p.text ? `: ${p.text}` : "")}"
                    >
                      <span slot="title"
                        ><strong></strong> ${l.name}
                        ${p.text ? h`: <em>${p.text}</em>` : b}</span
                      >
                      ${p.state === "pending" ? h`
                            <wy-progress-circular
                              slot="actions"
                              padded
                              ?indeterminate=${!p.progress}
                              .max=${100}
                              .value=${p.progress || 0}
                            ></wy-progress-circular>
                          ` : b}
                      <wy-button
                        slot="actions"
                        kind="icon"
                        @click=${() => {
            this.handleRemoveUpload(c);
          }}
                        title=${x("Discard", { desc: "Button action to discard" })}
                      >
                        <wy-icon name="close"></wy-icon>
                      </wy-button>
                    </wy-file-item>
                  `;
        }
        return b;
      }
    )}
          </div>` : b}

      <!-- attachments -->
      ${s ? this.attachments.map(
      (c) => h`<wy-file-item .file=${c} title="${c.name}">
              <span slot="title">${c.name}</span>
              <wy-button
                slot="actions"
                kind="icon"
                @click=${() => this.handleRemoveAttachment(c)}
                title=${x("Remove", { desc: "Button action to remove" })}
              >
                <wy-icon name="close"></wy-icon>
              </wy-button>
            </wy-file-item>`
    ) : b}

      <!-- embeds -->
      ${o ? h`
            <wy-embed-select
              .embeds=${this.embeds}
              @embed-remove=${(c) => this.removeEmbed(c)}
              @embed-swap=${() => this.swapEmbed()}
            ></wy-embed-select>
          ` : b}
    </div>`;
  }
  /**
   * Render the cloud files picker if cloud files feature is enabled.
   *
   * @internal
   */
  renderCloudFiles() {
    return this.disabled ? b : h`
      <wy-cloud-files
        ${Q(this.cloudFilesRef)}
        @external-blobs=${(t) => this.handleExternalBlobs(t.detail.externalBlobs)}
      ></wy-cloud-files>
    `;
  }
  render() {
    const t = this.dropZone.isDragActive;
    return h`
      <div
        part=${J({
      "wy-editor": !0,
      [this.editorClass]: !0,
      "wy-dragging": t
    })}
        data-drag-title=${x("Drop files here")}
      >
        ${this.renderTopSlot()} ${this.renderMiddleSlot()} ${this.renderBottomSlot()}
      </div>
      ${this.renderCloudFiles()}
    `;
  }
}, a(Eo, "WyEditor"), Eo);
$t.styles = [Ht, n3, a3, Ly, jv, rn];
zt([
  u({ type: Boolean })
], $t.prototype, "disabled", 2);
zt([
  u({ attribute: !1 })
], $t.prototype, "parentId", 2);
zt([
  u()
], $t.prototype, "placeholder", 1);
zt([
  u()
], $t.prototype, "text", 2);
zt([
  u({ type: Object })
], $t.prototype, "metadata", 2);
zt([
  u({ attribute: !1 })
], $t.prototype, "embed", 2);
zt([
  u({ attribute: !1 })
], $t.prototype, "options", 2);
zt([
  u({ attribute: !1 })
], $t.prototype, "attachments", 2);
zt([
  u()
], $t.prototype, "buttonText", 2);
zt([
  u({ type: Boolean })
], $t.prototype, "typing", 2);
zt([
  u({ type: Boolean })
], $t.prototype, "draft", 2);
zt([
  u()
], $t.prototype, "editorType", 2);
zt([
  u()
], $t.prototype, "editorClass", 2);
zt([
  u()
], $t.prototype, "editorLocation", 2);
zt([
  D()
], $t.prototype, "meeting", 2);
zt([
  D()
], $t.prototype, "editorError", 2);
zt([
  D()
], $t.prototype, "showPolls", 2);
zt([
  D()
], $t.prototype, "pollOptions", 2);
zt([
  D()
], $t.prototype, "embeds", 1);
zt([
  D()
], $t.prototype, "draftKey", 2);
zt([
  D()
], $t.prototype, "mutationAppId", 2);
zt([
  D()
], $t.prototype, "keyMap", 2);
zt([
  D()
], $t.prototype, "editorExtensions", 2);
zt([
  D()
], $t.prototype, "editor", 2);
$t = zt([
  B("wy-editor"),
  ht()
], $t);
var y3 = Object.getOwnPropertyDescriptor, w3 = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? y3(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = o(r) || r);
  return r;
}, "__decorateClass$H"), Ro;
let hh = (Ro = class extends $t {
  constructor() {
    super(), this.editorType = "comments", this.editorClass = "wy-comment-editor";
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("editorLocation") && (this.editorLocation === "files" ? this.editorClass = "wy-comment-editor wy-comment-editor-bottom" : this.editorLocation === "apps" && (this.editorClass = "wy-comment-editor wy-comment-editor-bottom"));
  }
  /**
   * Render the top slot for comment editor with no content.
   *
   * @internal
   */
  renderTopSlot() {
    return b;
  }
  /**
   * Render the primary middle slot containing the add-menu, editor and send button.
   *
   * Overrides the base implementation to provide message-specific controls and layout.
   *
   * @internal
   */
  renderMiddleSlot() {
    return h`<div part="wy-comment-editor-inputs">
      <!-- Add -->
      ${this.componentFeatures?.allowsAnyFeature(
      S.Attachments,
      S.CloudFiles,
      S.Meetings,
      S.ZoomMeetings,
      S.GoogleMeet,
      S.MicrosoftTeams,
      S.Polls
    ) ? h`<wy-dropdown icon="plus" directionY="up" ?disabled=${this.disabled}>
            ${this.componentFeatures?.allowsFeature(S.Attachments) ? h`<wy-dropdown-item @click=${this.openFileInput} title=${x("From device")}>
                    <wy-icon name="attachment"></wy-icon>
                    <span>${x("From device")}</span>
                  </wy-dropdown-item>
                  <input
                    type="file"
                    ${Q(this.fileInputRef)}
                    @click=${(t) => t.stopPropagation()}
                    @change=${(t) => this.handleUploadFiles(
      Array.from(t.target.files || []),
      t.target
    )}
                    multiple
                    hidden
                    tabindex="-1"
                  />` : b}
            ${this.componentFeatures?.allowsFeature(S.CloudFiles) ? h`<wy-dropdown-item @click=${this.openCloudFiles} title=${x("From cloud")}>
                  <wy-icon name="cloud"></wy-icon>
                  <span>${x("From cloud")}</span>
                </wy-dropdown-item>` : b}
            ${this.componentFeatures?.allowsAnyFeature(S.Meetings, S.ZoomMeetings) ? h`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("zoom")} title=${x("Zoom meeting")}>
                    <wy-icon svg="zoom-meetings"></wy-icon>
                    <span>${x("Zoom meeting")}</span>
                  </wy-dropdown-item>
                ` : b}
            ${this.componentFeatures?.allowsAnyFeature(S.Meetings, S.GoogleMeet) ? h`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("google")} title=${x("Google Meet")}>
                    <wy-icon svg="google-meet"></wy-icon>
                    <span>${x("Google Meet")}</span>
                  </wy-dropdown-item>
                ` : b}
            ${this.componentFeatures?.allowsAnyFeature(S.Meetings, S.MicrosoftTeams) ? h`
                  <wy-dropdown-item
                    @click=${() => this.handleMeetingClick("microsoft")}
                    title=${x("Microsoft Teams")}
                  >
                    <wy-icon svg="microsoft-teams"></wy-icon>
                    <span>${x("Microsoft Teams")}</span>
                  </wy-dropdown-item>
                ` : b}
            ${this.componentFeatures?.allowsFeature(S.Polls) ? h`<wy-dropdown-item @click=${() => this.openPolls()} title=${x("Poll")}>
                  <wy-icon name="poll"></wy-icon>
                  <span>${x("Poll")}</span>
                </wy-dropdown-item>` : b}
          </wy-dropdown>` : b}

      <!-- Input -->
      <div
        part=${J({ "wy-comment-editor-text": !0, "wy-is-invalid": this.editorError })}
        ${Q(this.editorRef)}
      >
        ${this.renderEditorDummy()}
      </div>

      <!-- Button -->
      <wy-button kind="icon" @click="${() => this.submit()}" title=${this.buttonText} ?disabled=${this.disabled}>
        <wy-icon name="send"></wy-icon>
      </wy-button>
    </div>`;
  }
  /**
   * Render content that appears below the message editor.
   *
   * By default returns the same lists section used by the base editor.
   *
   * @internal
   */
  renderBottomSlot() {
    return [
      this.renderLists()
    ];
  }
}, a(Ro, "WyCommentEditor"), Ro);
hh.styles = [...$t.styles, q4];
hh = w3([
  B("wy-comment-editor"),
  ht()
], hh);
var f3 = Object.defineProperty, m3 = Object.getOwnPropertyDescriptor, Kv = /* @__PURE__ */ a((n) => {
  throw TypeError(n);
}, "__typeError$9"), el = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? m3(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && f3(t, e, r), r;
}, "__decorateClass$G"), Qv = /* @__PURE__ */ a((n, t, e) => t.has(n) || Kv("Cannot " + e), "__accessCheck$9"), zd = /* @__PURE__ */ a((n, t, e) => (Qv(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$9"), Ku = /* @__PURE__ */ a((n, t, e) => t.has(n) ? Kv("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$9"), Qu = /* @__PURE__ */ a((n, t, e, i) => (Qv(n, t, "write to private field"), t.set(n, e), e), "__privateSet$8"), Hd, Zp, pa, To;
let cr = (To = class extends Dt {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.location = "apps", this.reveal = !1, this.padded = !1, Ku(this, Hd), Ku(this, Zp, new Promise((t) => {
      Qu(this, Hd, t);
    })), this.commentsQuery = new ir(this), this.addCommentMutation = new ti(this), this.infiniteScroll = new rr(this), this.pagerRef = nt(), Ku(this, pa), this.handleRealtimeCommentCreated = () => {
      this.weavy?.queryClient.invalidateQueries({ queryKey: [this.location, this.parentId, "comments"] });
    }, this.handleRealtimeReactionAdded = (t) => {
      !this.weavy || t.entity.type !== Ae.Comment || Zt(
        this.weavy.queryClient,
        [this.location, this.parentId, "comments"],
        t.entity.id,
        (e) => {
          zl(e, t.reaction, t.actor);
        }
      );
    }, this.handleRealtimeReactionDeleted = (t) => {
      !this.weavy || t.entity.type !== Ae.Comment || Zt(
        this.weavy.queryClient,
        [this.location, this.parentId, "comments"],
        t.entity.id,
        (e) => {
          zl(e, void 0, t.actor);
        }
      );
    };
  }
  /**
   * Resolves when `parentId` is available.
   *
   * @returns Promise<number>
   */
  async whenParentId() {
    return await zd(this, Zp);
  }
  async willUpdate(t) {
    var e, i;
    if (super.willUpdate(t), t.has("parentId") && this.parentId && ((e = zd(this, Hd)) == null || e.call(this, this.parentId)), (t.has("parentId") || t.has("weavy") || t.has("componentFeatures")) && this.parentId && this.weavy && (await this.commentsQuery.trackInfiniteQuery(O4(this.weavy, this.location, this.parentId)), await this.addCommentMutation.trackMutation(I4(this.weavy)), this.removeCommentMutation = D4(this.weavy, this.location, this.parentId), this.restoreCommentMutation = H4(this.weavy, this.location, this.parentId)), (t.has("weavy") || t.has("app") || t.has("componentFeatures")) && this.weavy && this.app) {
      this.pollMutation = gy(this.weavy, this.app.id, [this.location, this.parentId, "comments"]), (i = zd(this, pa)) == null || i.call(this);
      const r = `a${this.app.id}`;
      this.weavy.subscribe(r, "comment_created", this.handleRealtimeCommentCreated), this.componentFeatures?.allowsFeature(S.Reactions) && (this.weavy.subscribe(r, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(r, "reaction_removed", this.handleRealtimeReactionDeleted)), Qu(this, pa, () => {
        this.weavy?.unsubscribe(r, "comment_created", this.handleRealtimeCommentCreated), this.weavy?.unsubscribe(r, "reaction_added", this.handleRealtimeReactionAdded), this.weavy?.unsubscribe(r, "reaction_removed", this.handleRealtimeReactionDeleted), Qu(this, pa, void 0);
      });
    }
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.commentsQuery.result, this.pagerRef.value);
  }
  /**
   * Handle submit from the comment editor and trigger add comment mutation.
   *
   * @internal
   */
  async handleSubmit(t) {
    this.app && this.parentId && this.user && await this.addCommentMutation.mutate({
      app_id: this.app.id,
      parent_id: this.parentId,
      type: this.location,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      context: t.detail.contextData,
      user: this.user
    });
  }
  /**
   * Render comment items from a flattened page array.
   *
   * @internal
   */
  renderComments(t) {
    return t ? je(
      t,
      (e) => e.id,
      (e) => this.parentId ? h`<wy-comment
                id="comment-${e.id}"
                ?reveal=${this.reveal}
                .parentId=${this.parentId}
                .location=${this.location}
                .comment=${e}
                @trash=${async (i) => {
        const r = await this.whenApp(), s = await this.whenParentId();
        this.removeCommentMutation?.mutate({
          id: i.detail.id,
          appId: r.id,
          parentId: s,
          type: this.location
        });
      }}
                @restore=${async (i) => {
        const r = await this.whenApp(), s = await this.whenParentId();
        this.restoreCommentMutation?.mutate({
          id: i.detail.id,
          appId: r.id,
          parentId: s,
          type: this.location
        });
      }}
                @vote=${(i) => {
        i.detail.parentId && i.detail.parentType && this.pollMutation?.mutate({
          optionId: i.detail.optionId,
          parentType: i.detail.parentType,
          parentId: i.detail.parentId
        });
      }}
              ></wy-comment>` : b
    ) : b;
  }
  render() {
    const { data: t, hasNextPage: e, isPending: i } = this.commentsQuery.result ?? {}, r = nr(t);
    return h`
      ${r && r.length ? h`
            <div part="wy-comments">
              ${this.renderComments(r)}
              ${e ? h`<div ${Q(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : b}
            </div>
          ` : h`
            <wy-empty noNetwork
              ><wy-progress-circular indeterminate padded reveal ?hidden=${!i}></wy-progress-circular
            ></wy-empty>
          `}

      <wy-comment-editor
        editorLocation=${this.location}
        .parentId=${this.parentId}
        .typing=${!1}
        .draft=${!0}
        ?disabled=${!Ac(_n.Create, this.app?.permissions)}
        placeholder=${this.placeholder ?? x("Create a comment...")}
        buttonText=${x("Comment", { desc: "Button action to comment" })}
        @submit=${(s) => this.handleSubmit(s)}
      ></wy-comment-editor>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = zd(this, pa)) == null || t.call(this), super.disconnectedCallback();
  }
}, a(To, "WyCommentList"), To);
Hd = /* @__PURE__ */ new WeakMap();
Zp = /* @__PURE__ */ new WeakMap();
pa = /* @__PURE__ */ new WeakMap();
cr.styles = [Iy, Jr];
el([
  u({ type: Number })
], cr.prototype, "parentId", 2);
el([
  u({ attribute: !1 })
], cr.prototype, "location", 2);
el([
  u()
], cr.prototype, "placeholder", 2);
el([
  u({ type: Boolean, reflect: !0 })
], cr.prototype, "reveal", 2);
el([
  u({ type: Boolean, reflect: !0 })
], cr.prototype, "padded", 2);
cr = el([
  B("wy-comment-list"),
  ht()
], cr);
function Fy(n, t) {
  return ["apps", n.id, "file", t.id, "versions"];
}
a(Fy, "getFileVersionsKey");
function v3(n, t, e) {
  const i = n.queryClient, r = ["apps", t.id, "files"], s = Fy(t, e), o = {
    mutationKey: r,
    mutationFn: /* @__PURE__ */ a(async ({ versionFile: c }) => {
      if (c.id >= 1 && c.rev) {
        if (!(await n.fetch(`/api/files/${c.id}/versions/${c.rev}/restore`, {
          method: "POST"
        })).ok)
          throw new Error();
      } else
        throw new Error(`Could not restore ${c.name} to version ${c.rev}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((c) => (yt(
      i,
      { queryKey: o.mutationKey, exact: !1 },
      c.versionFile.id,
      (l) => Object.assign(l, c.versionFile, { status: "pending" })
    ), { type: "version", file: e, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ a((c, l) => {
      yt(
        i,
        { queryKey: o.mutationKey, exact: !1 },
        l.versionFile.id,
        (p) => Object.assign(p, c, { status: "ok" })
      ), qt(i, o.mutationKey, l, (p) => {
        p.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ a((c, l, p) => {
      p?.file && yt(
        i,
        { queryKey: o.mutationKey, exact: !1 },
        l.versionFile.id,
        (v) => Object.assign(v, p.file, { status: "error" })
      ), qt(i, o.mutationKey, l, (v) => {
        v.status.state = "error", v.status.text = c.message;
      });
    }, "onError"),
    onSettled: /* @__PURE__ */ a(async () => {
      await i.invalidateQueries({ queryKey: s });
    }, "onSettled")
  };
  return o;
}
a(v3, "getFileVersionRestoreMutationOptions");
function g3(n, t, e) {
  return new Mt(n.queryClient, v3(n, t, e));
}
a(g3, "getFileVersionRestoreMutation");
function b3(n, t, e) {
  const i = n.queryClient, r = Fy(t, e);
  return {
    mutationKey: r,
    mutationFn: /* @__PURE__ */ a(async ({ versionFile: o }) => {
      if (o.id >= 1 && o.rev) {
        const c = await n.fetch(`/api/files/${o.id}/versions/${o.rev}`, {
          method: "DELETE"
        });
        if (!c.ok) {
          const l = await c.json();
          throw new Error(l.detail || l.title, { cause: l });
        }
      } else {
        const c = {
          status: 400,
          title: `Could not remove ${o.name} version ${o.rev}.`
        };
        throw new Error(c.detail || c.title, { cause: c });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((o) => {
      Zt(
        i,
        r,
        /* @__PURE__ */ a((l) => l.id === o.versionFile.id && l.rev === o.versionFile.rev, "versionPredicate"),
        (l) => Object.assign(l, { status: "pending" })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((o, c) => {
      kh(i, r, /* @__PURE__ */ a((p) => p.id === c.versionFile.id && p.rev === c.versionFile.rev, "versionPredicate"));
    }, "onSuccess"),
    onError: /* @__PURE__ */ a((o, c) => {
      Zt(
        i,
        r,
        /* @__PURE__ */ a((p) => p.id === c.versionFile.id && p.rev === c.versionFile.rev, "versionPredicate"),
        (p) => Object.assign(p, { status: void 0 })
      );
    }, "onError")
  };
}
a(b3, "getFileVersionDeleteMutationOptions");
function x3(n, t, e) {
  return new Mt(n.queryClient, b3(n, t, e));
}
a(x3, "getFileVersionDeleteMutation");
var C3 = Object.defineProperty, $3 = Object.getOwnPropertyDescriptor, Dy = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? $3(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && C3(t, e, r), r;
}, "__decorateClass$F"), Lo;
let Dl = (Lo = class extends Dt {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.fileVersionsQuery = new qe(this);
  }
  /**
   * Selects the provided version and emits `file-version-select`.
   *
   * @param versionFile - Version to select.
   */
  selectVersion(t) {
    this.activeVersion = t, this.dispatchFileVersionSelect(t);
  }
  /**
   * Emit a `file-version-select` event with the chosen version.
   *
   * @internal
   * @param versionFile - Version to announce.
   * @returns Whether the event was not canceled.
   */
  dispatchFileVersionSelect(t) {
    const e = new CustomEvent("file-version-select", {
      detail: { versionFile: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Revert the file to the supplied version.
   *
   * @internal
   * @param versionFile - Version to restore.
   */
  handleRevert(t) {
    this.fileVersionRestoreMutation?.mutate({ versionFile: t }), this.selectVersion(t);
  }
  /**
   * Remove the supplied version and adjust the active selection if needed.
   *
   * @internal
   * @param versionFile - Version to delete.
   */
  handleRemove(t) {
    this.fileVersionDeleteMutation?.mutate({ versionFile: t }), this.activeVersion === t && (this.activeVersion = this.file);
  }
  /**
   * Download the provided version via the browser.
   *
   * @internal
   * @param file - Version file to download.
   */
  triggerDownload(t) {
    tr(t.download_url, "_top", t.name, !0);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("file") || t.has("app")) && this.weavy && this.file && this.app && (await this.fileVersionsQuery.trackQuery(
      hd(
        this.weavy,
        Fy(this.app, this.file),
        `/api/files/${this.file.id}/versions`
      )
    ), this.fileVersionRestoreMutation = g3(this.weavy, this.app, this.file), this.fileVersionDeleteMutation = x3(this.weavy, this.app, this.file));
  }
  render() {
    const { data: t, isPending: e } = this.fileVersionsQuery.result ?? { isPending: !0 };
    return e ? h`<wy-progress-circular indeterminate overlay></wy-progress-circular>` : t?.data ? h`
          <wy-item-list part="wy-versions">
            ${je(
      t.data,
      (i) => i.id,
      (i, r) => {
        const s = Xr(i.name || "").icon, o = t.data ? t.data.length - r : NaN, c = di(i.name), l = new Date(i.updated_at || i.created_at), p = !!this.file.external_url, v = new Intl.DateTimeFormat(this.weavy?.locale, {
          dateStyle: "full",
          timeStyle: "short"
        }).format(l), C = tl(this.weavy?.locale, new Date(l));
        return p ? h`
                      <wy-empty noNetwork>
                        <span slot="title">${x("Versions are not available for external cloud files.")}</span>
                      </wy-empty>
                    ` : h`
                      <wy-item
                        size="lg"
                        interactive
                        ?selected=${i.rev == this.activeVersion?.rev}
                        tabindex="0"
                        @click=${() => this.selectVersion(i)}
                        @keydown=${ve}
                        @keyup=${Ie}
                      >
                        <wy-icon
                          slot="image"
                          name=${s}
                          size="48"
                          kind=${i.kind}
                          ext=${c}
                        ></wy-icon>
                        <span slot="title">${o}. ${i.name}</span>
                        <span slot="text">
                          <time datetime=${i.updated_at || i.created_at} title=${v}
                            >${C}</time
                          >
                          ${i.updated_by ? h`· ${i.updated_by?.name}` : b}
                        </span>

                        <wy-dropdown slot="actions" directionX="left">
                          <wy-dropdown-item @click=${() => this.triggerDownload(i)}>
                            <wy-icon name="download"></wy-icon>
                            ${x("Download")}
                          </wy-dropdown-item>

                          ${r !== 0 ? h`
                                <wy-dropdown-divider></wy-dropdown-divider>
                                <wy-dropdown-item @click=${() => this.handleRevert(i)}>
                                  <wy-icon name="restore"></wy-icon>
                                  ${"Revert"}
                                </wy-dropdown-item>
                                <wy-dropdown-item @click=${() => this.handleRemove(i)}>
                                  <wy-icon name="delete"></wy-icon>
                                  ${x("Remove", { desc: "Button action to remove" })}
                                </wy-dropdown-item>
                              ` : b}
                        </wy-dropdown>
                      </wy-item>
                    `;
      }
    )}
          </wy-item-list>
        ` : b;
  }
}, a(Lo, "WyFileVersions"), Lo);
Dy([
  u({ attribute: !1 })
], Dl.prototype, "file", 2);
Dy([
  u({ attribute: !1 })
], Dl.prototype, "activeVersion", 2);
Dl = Dy([
  B("wy-file-versions"),
  ht()
], Dl);
var k3 = Object.defineProperty, P3 = Object.getOwnPropertyDescriptor, pe = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? P3(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && k3(t, e, r), r;
}, "__decorateClass$E"), Oo;
let Kt = (Oo = class extends Dt {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.currentId = NaN, this.isAttachment = !1, this.filled = !1, this.showOverlay = !1, this.commentsOpen = !1, this.versionsOpen = !1, this.sidePanelMaximized = !1, this.persistState = new Sn(this), this.swipeScroller = new Fp(this), this.previewFileRef = nt(), this.nextRef = nt(), this.prevRef = nt(), this.loadingQueue = [], this.disableSwipeScroll = !1, this.handleKeys = (t) => {
      this.showOverlay && (t.key === "ArrowLeft" ? (t.stopPropagation(), this.setPrev()) : t.key === "ArrowRight" && (t.stopPropagation(), this.setNext()));
    };
  }
  /**
   * Moves a file to the front of the loading queue.
   *
   * @internal
   * @param file - File to prioritize.
   * @param state - Optional state override.
   */
  moveFirstInQueue(t, e) {
    let i = { file: t };
    const r = this.loadingQueue.filter((s) => s.file === t ? (i = s, !1) : !0);
    this.loadingQueue = [{ ...i, ...e }, ...r];
  }
  /**
   * Updates loading metadata for the supplied file.
   *
   * @internal
   * @param file - File whose state should change.
   * @param state - State patch to merge.
   */
  updateLoadingState(t, e) {
    t && (this.loadingQueue = this.loadingQueue.map((i) => t === i.file ? { ...i, ...e } : i));
  }
  /**
   * Marks the next unloaded item as loading.
   *
   * @internal
   */
  loadNextInQueue() {
    const t = this.loadingQueue.find((e) => !e.loaded);
    t && !t?.loading && this.updateLoadingState(t.file, { loading: !0 });
  }
  /**
   * Emits `wy-preview-open` with the current preview context.
   *
   * @internal
   */
  async dispatchOpen() {
    const t = await this.whenApp(), e = await this.whenComponentFeatures(), i = this.currentId, r = this.commentsOpen ? "comments" : this.versionsOpen ? "versions" : void 0, s = this.currentFile ? [this.currentFile] : [], o = this.isAttachment, c = this.contextDataBlobs, l = new CustomEvent("wy-preview-open", {
      detail: {
        fileId: i,
        tab: r,
        files: s,
        app: t,
        features: e.allowedFeatures().join(" "),
        isAttachment: o,
        contextDataBlobs: c
      },
      cancelable: !0,
      bubbles: !1,
      composed: !0
    });
    this.dispatchEvent(l) || (this.showOverlay = !1, this.commentsOpen = !1, this.versionsOpen = !1);
  }
  /**
   * Emits the `wy-preview-close` event.
   *
   * @internal
   */
  dispatchClose() {
    const t = new CustomEvent("wy-preview-close", {
      cancelable: !1,
      bubbles: !1,
      composed: !0
    });
    this.dispatchEvent(t);
  }
  /**
   * Opens the overlay for the provided file identifier.
   *
   * @param fileId - File to display.
   * @param showTab - Optional sidebar tab to activate.
   */
  async open(t, e) {
    await this.whenApp(), await this.updateComplete, t && (this.currentId = t), e && this.toggleSidebarTab(e, !0), this.showOverlay = !0;
  }
  /**
   * Closes the preview overlay.
   */
  close() {
    this.showOverlay = !1;
  }
  /**
   * Toggles sidebar visibility for comments or versions.
   *
   * @internal
   * @param tab - Sidebar to affect.
   * @param state - Forced open state; toggles when omitted.
   */
  toggleSidebarTab(t, e) {
    t === "comments" ? (this.versionsOpen = !1, this.commentsOpen = e !== void 0 ? e : !this.commentsOpen) : t === "versions" ? (this.commentsOpen = !1, this.versionsOpen = e !== void 0 ? e : !this.versionsOpen) : (this.commentsOpen = !1, this.versionsOpen = !1);
  }
  /**
   * Handles file version selection events.
   *
   * @internal
   * @param e - Version selection event.
   */
  handleVersionFile(t) {
    this.currentVersionFile = t.detail.versionFile;
  }
  /**
   * Scrolls to the previous preview area.
   *
   * @internal
   */
  scrollToPrev() {
    this.prevRef.value && (this.unblockSwipeScroll(), this.prevRef.value.scrollIntoView({ behavior: this.weavy?.scrollBehavior }));
  }
  /**
   * Scrolls to the next preview area.
   *
   * @internal
   */
  scrollToNext() {
    this.nextRef.value && (this.unblockSwipeScroll(), this.nextRef.value.scrollIntoView({ behavior: this.weavy?.scrollBehavior }));
  }
  /**
   * Disables swipe scrolling for a short duration.
   *
   * @internal
   * @param duration - Milliseconds before re-enabling.
   */
  blockSwipeScroll(t = 20) {
    window.clearTimeout(this.disableSwipeScrollTimeout), this.disableSwipeScroll = !0, this.disableSwipeScrollTimeout = window.setTimeout(() => this.disableSwipeScroll = !1, t);
  }
  /**
   * Re-enables swipe scrolling immediately.
   *
   * @internal
   */
  unblockSwipeScroll() {
    window.clearTimeout(this.disableSwipeScrollTimeout), this.disableSwipeScroll = !1;
  }
  /**
   * Selects the previous file when available.
   *
   * @internal
   */
  setPrev() {
    this.previousFile && (this.currentId = this.previousFile.id, this.blockSwipeScroll());
  }
  /**
   * Selects the next file when available.
   *
   * @internal
   */
  setNext() {
    this.nextFile && (this.currentId = this.nextFile.id, this.blockSwipeScroll());
  }
  /**
   * Registers swipe observers on the active scroll element.
   *
   * @internal
   */
  registerSwipeScroller() {
    this.swipeScrollElement && (this.swipeScroller.whenPrev ??= () => this.setPrev(), this.swipeScroller.whenNext ??= () => this.setNext(), this.swipeScroller.createObserver(this.swipeScrollElement));
  }
  async willUpdate(t) {
    if (super.willUpdate(t), (t.has("app") || t.has("user")) && this.app && this.user && !this.isAttachment && (this.persistState.observe(
      [
        { name: "commentsOpen", override: !0 },
        { name: "versionsOpen", override: !0 }
      ],
      `a${this.app.id}-preview`,
      `u${this.user.id}`
    ), this.commentsOpen && this.versionsOpen && (this.versionsOpen = !1)), t.has("queryResult") && this.queryResult) {
      const { data: e } = this.queryResult ?? {};
      this.files = e?.filter((i) => i && !i.is_trashed);
    }
    if (t.has("infiniteQueryResult") && this.infiniteQueryResult) {
      const { data: e } = this.infiniteQueryResult ?? {};
      this.files = nr(e).filter((i) => i && !i.is_trashed);
    }
    t.has("currentFile") && this.currentFile && this.currentFile.id !== this.currentId && (this.currentId = this.currentFile.id), (t.has("files") || t.has("currentId") || t.has("showOverlay")) && this.files && this.showOverlay && (this.currentFile = void 0, this.previousFile = void 0, this.nextFile = void 0, this.currentVersionFile = void 0, this.currentVersionFile = this.currentFile = this.files.find((e, i) => this.files && e.id === this.currentId ? (i >= 1 && (this.previousFile = this.files[i - 1]), i < this.files.length - 1 && (this.nextFile = this.files[i + 1]), this.infiniteQueryResult && i >= this.files.length - 2 && this.infiniteQueryResult.hasNextPage && !this.infiniteQueryResult.isFetchingNextPage && this.infiniteQueryResult.fetchNextPage(), this.infiniteQueryResult && i <= 1 && this.infiniteQueryResult.hasPreviousPage && !this.infiniteQueryResult.isFetchingPreviousPage && this.infiniteQueryResult.fetchPreviousPage(), !0) : !1)), t.has("currentFile") && this.currentFile && !this.files && (this.files = [this.currentFile]), t.has("previousFile") && this.previousFile && this.moveFirstInQueue(this.previousFile), t.has("nextFile") && this.nextFile && this.moveFirstInQueue(this.nextFile), t.has("currentVersionFile") && this.currentVersionFile && this.moveFirstInQueue(this.currentVersionFile, { loading: !0 }), t.has("loadingQueue") && this.loadNextInQueue(), t.has("showOverlay") && (this.showOverlay ? await this.dispatchOpen() : t.get("showOverlay") && this.dispatchClose());
  }
  /**
   * Renders the preview header for the active file.
   *
   * @internal
   * @param activeFile - File displayed in the main pane.
   */
  renderHeader(t) {
    return h`
      <wy-titlebar header ?trashed=${!!t?.is_trashed}>
        <wy-button slot="icon" kind="icon" @click=${() => this.close()}><wy-icon name="close"></wy-icon></wy-button>
        ${t ? h` <span slot="title">${t.name}</span> ` : b}
        ${t ? h`
              ${this.componentFeatures?.allowsFeature(S.Comments) && t.id >= 1 && !this.isAttachment ? h`
                    <wy-button
                      slot="actions"
                      kind="icon"
                      ?active=${this.commentsOpen}
                      @click=${() => this.toggleSidebarTab("comments")}
                      title=${x("Comments")}
                    >
                      <wy-icon-stack>
                        ${t.comments?.count && t.comments?.count > 0 ? h`<wy-icon name="comment" state ?active=${!this.commentsOpen}></wy-icon>
                              <wy-icon name="comment" layer state ?active=${this.commentsOpen}></wy-icon>` : h`<wy-icon name="comment-outline" state ?active=${!this.commentsOpen}></wy-icon>
                              <wy-icon name="comment" layer state ?active=${this.commentsOpen}></wy-icon>`}
                      </wy-icon-stack>
                    </wy-button>
                  ` : b}
              <wy-file-menu slot="actions" .file=${t}>
                ${this.componentFeatures?.allowsFeature(S.Versions) && t.id >= 1 && !this.isAttachment ? h`
                      <wy-dropdown-item ?active=${this.versionsOpen} @click=${() => this.toggleSidebarTab("versions")}>
                        <wy-icon name="backup-restore"></wy-icon>
                        ${x("Versions")}
                      </wy-dropdown-item>
                    ` : b}
              </wy-file-menu>
            ` : b}
      </wy-titlebar>
    `;
  }
  render() {
    let t = this.files === void 0;
    this.queryResult ? t = this.queryResult.isPending : this.infiniteQueryResult && (t = this.infiniteQueryResult.isPending);
    const e = [this.previousFile, this.currentVersionFile, this.nextFile].filter((r) => r);
    this.commentsOpen && this.versionsOpen && (this.versionsOpen = !1);
    const i = {
      "wy-preview-swiper-disabled": this.disableSwipeScroll
    };
    return this.weavy ? h`
      <wy-overlay
        part="wy-dark"
        maximized
        noHeader
        type=${this.filled ? "full" : "modal"}
        .show=${this.showOverlay}
        @keyup=${this.handleKeys}
        @close=${() => {
      this.showOverlay = !1;
    }}
      >
        ${this.showOverlay ? h`<div part="wy-preview-layout">
              ${this.renderHeader(this.currentFile)}

              <div part="wy-preview-main">
                ${this.isAttachment ? b : h` <aside
                        id="tab-comments"
                        part="wy-sidebar ${J({
      "wy-active": this.commentsOpen,
      "wy-maximized": this.sidePanelMaximized
    })}"
                        ?hidden=${!this.commentsOpen}
                      >
                        <nav>
                          <wy-item size="md">
                            <span slot="title" part="wy-title">${x("Comments")}</span>
                            <wy-button
                              slot="actions"
                              kind="icon"
                              @click=${() => this.toggleSidebarTab("comments", !1)}
                            >
                              <wy-icon name="close"></wy-icon>
                            </wy-button>
                          </wy-item>
                          <button
                            @click=${() => this.sidePanelMaximized = !this.sidePanelMaximized}
                            part="wy-sidebar-handle"
                            title=${this.sidePanelMaximized ? x("Restore side panel") : x("Maximize side panel")}
                          ></button>
                        </nav>
                        <div part="wy-pane wy-scroll-y">
                          ${this.commentsOpen && this.currentFile && this.currentFile.id >= 1 && this.app && this.user ? h`
                                <wy-comment-list
                                  reveal
                                  .parentId=${this.currentFile.id}
                                  .location=${"files"}
                                ></wy-comment-list>
                              ` : b}
                        </div>
                      </aside>
                      <aside
                        id="tab-versions"
                        part="wy-sidebar ${J({
      "wy-active": this.versionsOpen,
      "wy-maximized": this.sidePanelMaximized
    })}"
                        ?hidden=${!this.versionsOpen}
                      >
                        <nav>
                          <wy-item size="md">
                            <span slot="title" part="wy-title">${x("Versions")}</span>
                            <wy-button
                              slot="actions"
                              kind="icon"
                              @click=${() => this.toggleSidebarTab("versions", !1)}
                            >
                              <wy-icon name="close"></wy-icon>
                            </wy-button>
                          </wy-item>
                          <button
                            @click=${() => this.sidePanelMaximized = !this.sidePanelMaximized}
                            part="wy-sidebar-handle"
                            title=${this.sidePanelMaximized ? x("Restore side panel") : x("Maximize side panel")}
                          ></button>
                        </nav>
                        <div part="wy-pane wy-scroll-y">
                          <div part="wy-pane-body">
                            ${this.versionsOpen && this.currentFile && this.app ? h`
                                  <wy-file-versions
                                    .file=${this.currentFile}
                                    .activeVersion=${this.currentVersionFile}
                                    @file-version-select=${(r) => this.handleVersionFile(r)}
                                  ></wy-file-versions>
                                ` : b}
                          </div>
                        </div>
                      </aside>`}

                <div part="wy-preview">
                  <div
                    ${Q((r) => {
      r && (this.swipeScrollElement = r);
    })}
                    part="wy-preview-swiper ${J(i)}"
                  >
                    ${je(
      e,
      (r) => "preview-area-" + r?.id,
      (r) => {
        const s = /* @__PURE__ */ a((l) => {
          l?.scrollIntoView(), requestAnimationFrame(() => l?.scrollIntoView());
        }, "currentPreviewFileCallback"), o = r === this.currentVersionFile ? s : r === this.nextFile ? this.nextRef : r === this.previousFile ? this.prevRef : void 0, c = this.loadingQueue.find((l) => l.file === r);
        return r ? h`
                              <div
                                id="preview-${r.id}"
                                ${Q(o)}
                                part="wy-preview-area wy-scroll-x-y"
                              >
                                ${!t && (c?.loading || c?.loaded) ? h`
                                      <wy-preview-item
                                        .file=${r}
                                        ?current=${r === this.currentVersionFile}
                                        @file-preview-loaded=${(l) => this.updateLoadingState(l.detail.file, { loaded: !0 })}
                                      ></wy-preview-item>
                                    ` : h` <wy-progress-circular indeterminate overlay></wy-progress-circular> `}
                              </div>
                            ` : b;
      }
    )}
                  </div>
                  ${this.currentFile ? h`
                        ${this.previousFile ? h`
                              <nav part="wy-nav-prev">
                                <wy-button kind="icon" @click=${() => this.scrollToPrev()}>
                                  <wy-icon name="previous"></wy-icon>
                                </wy-button>
                              </nav>
                            ` : b}
                        ${this.nextFile ? h`
                              <nav part="wy-nav-next">
                                <wy-button kind="icon" @click=${() => this.scrollToNext()}>
                                  <wy-icon name="next"></wy-icon>
                                </wy-button>
                              </nav>
                            ` : b}
                      ` : b}
                </div>
              </div>
            </div> ` : b}
      </wy-overlay>
    ` : b;
  }
  updated(t) {
    t.has("swipeScrollElement") && t.get("swipeScrollElement") !== this.swipeScrollElement && this.registerSwipeScroller(), !this.disableSwipeScroll && this.swipeScroller.swipeElement === this.swipeScrollElement ? this.swipeScroller.observe(this.prevRef.value, this.nextRef.value) : this.swipeScroller.clearObserver();
  }
}, a(Oo, "WyPreview"), Oo);
Kt.styles = [o4, c4, Xn, Jn, Gc, se];
pe([
  u({ attribute: !1 })
], Kt.prototype, "files", 2);
pe([
  u({ attribute: !1 })
], Kt.prototype, "queryResult", 2);
pe([
  u({ attribute: !1 })
], Kt.prototype, "infiniteQueryResult", 2);
pe([
  u({ type: Object })
], Kt.prototype, "user", 2);
pe([
  u({ type: Number })
], Kt.prototype, "currentId", 2);
pe([
  u({ type: Boolean })
], Kt.prototype, "isAttachment", 2);
pe([
  u({ type: Boolean })
], Kt.prototype, "filled", 2);
pe([
  D()
], Kt.prototype, "currentFile", 2);
pe([
  D()
], Kt.prototype, "currentVersionFile", 2);
pe([
  D()
], Kt.prototype, "previousFile", 2);
pe([
  D()
], Kt.prototype, "nextFile", 2);
pe([
  D()
], Kt.prototype, "showOverlay", 2);
pe([
  D()
], Kt.prototype, "commentsOpen", 2);
pe([
  D()
], Kt.prototype, "versionsOpen", 2);
pe([
  D()
], Kt.prototype, "sidePanelMaximized", 2);
pe([
  D()
], Kt.prototype, "swipeScrollElement", 2);
pe([
  D()
], Kt.prototype, "loadingQueue", 2);
pe([
  D()
], Kt.prototype, "disableSwipeScroll", 2);
Kt = pe([
  B("wy-preview"),
  ht()
], Kt);
var _3 = Object.defineProperty, S3 = Object.getOwnPropertyDescriptor, ce = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? S3(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && _3(t, e, r), r;
}, "__decorateClass$D"), zo;
let Vt = (zo = class extends Dt {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.me = !1, this.isAgent = !1, this.isPrivateChat = !1, this.name = "", this.comment = "", this.avatar = "", this.createdAt = "", this.html = "", this.text = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.seenBy = [], this.highlight = !1, this.previewAnnotationsRef = nt(), this.previewAttachmentsRef = nt(), this.highlightRef = nt();
  }
  /**
   * Emit a `vote` event for the specified poll option.
   *
   * @internal
   * @param optionId - Identifier of the selected poll option.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", {
      detail: { optionId: t, parentId: this.messageId }
    });
    return this.dispatchEvent(e);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("link") && (this.highlight = !!(this.link && zh(this.link, Ae.Message, { id: this.messageId })));
  }
  render() {
    const t = this.attachments?.filter((o) => o.kind === "image" && o.thumbnail_url) || [], e = this.attachments?.filter((o) => o.kind !== "image" || !o.thumbnail_url) || [], i = this.createdAt ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.createdAt)
    ) : "", r = this.createdAt ? new Intl.DateTimeFormat(this.weavy?.locale, { timeStyle: "short" }).format(new Date(this.createdAt)) : "", s = !this.annotations?.length && !this.attachments?.length && !this.embed && !this.meeting && !this.pollOptions?.length && V1(this.text);
    return h`
      <div
        part=${J({ "wy-message": !0, "wy-message-me": this.me, "wy-message-agent": this.isAgent, "wy-highlight": this.highlight })}
        ${Q(this.highlightRef)}
      >
        ${this.me ? "" : h`
              <div part="wy-message-author">
                <wy-avatar
                  .src=${this.avatar}
                  .size=${32}
                  .name=${this.name}
                  .description=${this.comment}
                  .isAgent=${this.isAgent}
                ></wy-avatar>
              </div>
            `}

        <div part="wy-message-content">
          <div part="wy-message-meta">
            ${!this.isPrivateChat && !this.me ? h` <span>${this.name} · </span> ` : ""}
            <time datetime=${this.createdAt} title=${i}>${r}</time>
          </div>

          <div part=${J({ "wy-message-bubble": !0, "wy-message-bubble-emoji": s })}>
            ${this.messageId < 0 ? h`<wy-skeleton .text=${this.text}></wy-skeleton>` : h`
                  ${t && t.length ? h`<wy-image-grid
                        part="wy-message-bubble-section"
                        .images=${t}
                        @file-open=${(o) => {
      this.previewAttachmentsRef.value?.open(o.detail.fileId);
    }}
                      ></wy-image-grid>` : b}


                  <!-- text -->
                  ${this.html ? h`<div part=${J({ "wy-content": !0, "wy-message-bubble-section": !0, "wy-content-emoji": s })}>${An(this.html)}</div>` : b}

                  ${this.annotations && this.annotations.length ? h`<wy-annotation-list
                        part="wy-message-bubble-section"
                        .files=${this.annotations}
                        @file-open=${(o) => {
      this.previewAnnotationsRef.value?.open(o.detail.fileId);
    }}
                      ></wy-annotation-list>` : b}

                  ${this.pollOptions && this.pollOptions.length ? h`<wy-poll
                        .pollOptions=${this.pollOptions}
                        @vote=${(o) => this.dispatchVote(o.detail.optionId)}
                      ></wy-poll>` : b}

                  ${this.componentFeatures?.allowsFeature(S.Embeds) && this.embed ? h` <wy-embed .embed=${this.embed}></wy-embed> ` : b}

                  ${e && e.length ? h`<wy-attachment-list
                        filled
                        part="wy-message-bubble-section"
                        .files=${e}
                        @file-open=${(o) => {
      this.previewAttachmentsRef.value?.open(o.detail.fileId);
    }}
                      ></wy-attachment-list>` : b}

                  ${this.meeting ? h`<wy-meeting-card .meeting=${this.meeting}></wy-meeting-card>` : b}

                  ${this.componentFeatures?.allowsFeature(S.Reactions) && this.conversation ? h`
                        ${Dd(
      `reactions-${this.conversation.id}-${this.messageId}`,
      h`<wy-reactions
                            lineBelow
                            ?lineReverse=${!this.me}
                            small
                            directionX=${this.me ? "right" : "left"}
                            .reactions=${this.reactions}
                            parentId=${this.conversation.id}
                            parentType="apps"
                            entityId=${this.messageId}
                            entityType="messages"
                          ></wy-reactions>`
    )}
                      ` : b}
                `}
          </div>
        </div>
      </div>
      ${this.componentFeatures?.allowsFeature(S.Receipts) ? h`<div part="wy-message-seenby">
            ${this.seenBy && this.seenBy.length ? h`
                  ${this.seenBy.map((o) => {
      const c = o.marked_at ? new Intl.DateTimeFormat(this.weavy?.locale, {
        dateStyle: "full",
        timeStyle: "short"
      }).format(new Date(o.marked_at)) : "";
      return h`<wy-avatar
                      title=${x(gt`Seen by ${o.name} at ${c}`)}
                      .name=${o.name}
                      .src=${o.avatar_url}
                      size=${18}
                    ></wy-avatar>`;
    })}
                ` : b}
          </div>` : b}
      ${this.annotations ? Dd(
      `annotation-preview-message-${this.messageId}`,
      h`
              <wy-preview
                ${Q(this.previewAnnotationsRef)}
                .files=${this.annotations}
                .isAttachment=${!0}
              ></wy-preview>
            `
    ) : b}
      ${this.attachments ? Dd(
      `preview-message-${this.messageId}`,
      h`
              <wy-preview
                ${Q(this.previewAttachmentsRef)}
                .files=${[...t, ...e]}
                .isAttachment=${!0}
              ></wy-preview>
            `
    ) : b}
    `;
  }
  updated(t) {
    t.has("highlight") && this.highlight && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, a(zo, "WyMessage"), zo);
Vt.styles = [_h, Ey, X];
ce([
  u({ attribute: !1 })
], Vt.prototype, "conversation", 2);
ce([
  u({ type: Number })
], Vt.prototype, "messageId", 2);
ce([
  u({ type: Boolean })
], Vt.prototype, "me", 2);
ce([
  u({ type: Boolean })
], Vt.prototype, "isAgent", 2);
ce([
  u({ type: Boolean })
], Vt.prototype, "isPrivateChat", 2);
ce([
  u()
], Vt.prototype, "name", 2);
ce([
  u()
], Vt.prototype, "comment", 2);
ce([
  u()
], Vt.prototype, "avatar", 2);
ce([
  u()
], Vt.prototype, "createdAt", 2);
ce([
  u()
], Vt.prototype, "html", 2);
ce([
  u()
], Vt.prototype, "text", 2);
ce([
  u({ type: Array })
], Vt.prototype, "annotations", 2);
ce([
  u({ type: Array })
], Vt.prototype, "attachments", 2);
ce([
  u({ attribute: !1 })
], Vt.prototype, "meeting", 2);
ce([
  u({ type: Array })
], Vt.prototype, "pollOptions", 2);
ce([
  u({ attribute: !1 })
], Vt.prototype, "embed", 2);
ce([
  u({ type: Array })
], Vt.prototype, "reactions", 2);
ce([
  u({ type: Array })
], Vt.prototype, "seenBy", 2);
ce([
  u({ type: Boolean })
], Vt.prototype, "highlight", 2);
Vt = ce([
  B("wy-message"),
  ht()
], Vt);
var M3 = Object.defineProperty, A3 = Object.getOwnPropertyDescriptor, Gv = /* @__PURE__ */ a((n) => {
  throw TypeError(n);
}, "__typeError$8"), bi = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? A3(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && M3(t, e, r), r;
}, "__decorateClass$C"), Zv = /* @__PURE__ */ a((n, t, e) => t.has(n) || Gv("Cannot " + e), "__accessCheck$8"), Bf = /* @__PURE__ */ a((n, t, e) => (Zv(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$8"), E3 = /* @__PURE__ */ a((n, t, e) => t.has(n) ? Gv("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$8"), Nf = /* @__PURE__ */ a((n, t, e, i) => (Zv(n, t, "write to private field"), t.set(n, e), e), "__privateSet$7"), ya, Io;
let We = (Io = class extends Dt {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.header = !1, this.lastReadMessagePosition = "below", this.showNewMessages = !1, this.isCreatingConversation = !1, this.showReadReceipts = !1, this.messagesQuery = new ir(this), this.membersQuery = new qe(this), this.addMessageMutation = new ti(this), this.infiniteScroll = new zp(this), this.pagerRef = nt(), this.bottomRef = nt(), this.editorRef = nt(), this.shouldBeAtBottom = !0, this.isTyping = !1, this.handleRealtimeMessage = async (t) => {
      if (!this.weavy || !this.conversation || !(this.conversationId && this.conversationId > 0) || !this.user)
        return;
      await this.messagesQuery.observer?.getCurrentQuery().promise;
      const e = t.message.app.uid ?? t.message.app.id, i = ["messages", t.message.app.id];
      let r = Ph(this.weavy.queryClient, i, t.message.id);
      r || (t.message.created_by.id === this.user.id && (r = Mn(this.weavy.queryClient, i, !0), r && Zt(this.weavy.queryClient, i, r.id, (s) => {
        s.id = t.message.id, s.app = t.message.app, s.text = t.message.text, s.html = t.message.html, s.embed = t.message.embed, s.meeting = t.message.meeting, s.attachments = t.message.attachments, s.options = t.message.options, s.created_at = t.message.created_at, s.created_by = t.message.created_by, s.updated_at = t.message.updated_at, s.updated_by = t.message.updated_by;
      })), r || Vr(this.weavy.queryClient, i, t.message)), this.weavy.queryClient.setQueryData(
        ["apps", e],
        (s) => s && { ...s, last_message: t.message }
      ), t.actor.id !== this.user.id && (this.isAtBottom ? (this.markAsRead(t.message.id), requestAnimationFrame(() => {
        this.scrollToBottom();
      })) : (this.weavy.queryClient.setQueryData(
        ["apps", e],
        (s) => s && { ...s, is_unread: !0 }
      ), this.lastReadMessagePosition = "above", this.lastReadMessageId = t.message.id, this.showNewMessages = !0), yt(
        this.weavy.queryClient,
        { queryKey: ["members", t.message.app.id], exact: !1 },
        t.actor.id,
        (s) => {
          s.marked_id = t.message.id, s.marked_at = t.message.created_at;
        }
      ));
    }, this.handleRealtimeReactionAdded = (t) => {
      !this.weavy || !this.user || !this.conversation || yt(
        this.weavy.queryClient,
        { queryKey: ["messages"], exact: !1 },
        t.entity.id,
        (e) => {
          e.reactions || (e.reactions = { count: 0 }), e.reactions.data = [
            ...(e.reactions.data || []).filter((i) => i.created_by?.id !== t.actor.id),
            { content: t.reaction, created_by: t.actor }
          ];
        }
      );
    }, this.handleRealtimeReactionDeleted = (t) => {
      !this.weavy || !this.conversation || !this.user || yt(
        this.weavy.queryClient,
        { queryKey: ["messages"], exact: !1 },
        t.entity.id,
        (e) => {
          e.reactions && e.reactions.data && (e.reactions.data = e.reactions.data.filter((i) => i.created_by?.id !== t.actor.id));
        }
      );
    }, this.handleRealtimeMarked = (t) => {
      !this.weavy || !this.conversation || yt(
        this.weavy.queryClient,
        { queryKey: ["members", this.conversation.id] },
        t.actor.id,
        (e) => {
          e.marked_id = t.marked_id, e.marked_at = t.marked_at;
        }
      );
    }, this.markAsReadHandler = () => {
      !document.hidden && this.isAtBottom && this.markAsRead();
    }, E3(this, ya);
  }
  isPrivateChat(t) {
    return (t ?? this.conversation)?.type === st.PrivateChat;
  }
  isChatRoom(t) {
    return (t ?? this.conversation)?.type === st.ChatRoom;
  }
  /**
   * Read-only helper returning whether the viewport is currently scrolled to the bottom.
   *
   * @internal
   */
  get isAtBottom() {
    return this.bottomRef.value ? j0(this.bottomRef.value) : !0;
  }
  /**
   * Scroll the conversation to the bottom.
   *
   * @param smooth - Whether to perform a smooth scroll.
   * @returns Promise<void>
   *
   * @internal
   */
  async scrollToBottom(t = !1) {
    this.bottomRef.value && await Zu(this.bottomRef.value), q0(this.bottomRef.value) && this.conversationId && this.conversationId > 0 && (requestAnimationFrame(() => {
      Hu(this.weavy?.queryClient, ["messages", this.conversationId], void 0, 1);
    }), await W0(this.bottomRef.value, t));
  }
  /**
   * Handle typing indicator events from child components.
   *
   * @internal
   * @param e - Typing event
   */
  handleTyping(t) {
    this.isTyping = !!t.detail.count, this.isTyping && this.isAtBottom && requestAnimationFrame(() => {
      this.scrollToBottom(!0);
    });
  }
  /**
   * Submit handler for the message editor. Adds a message and optionally creates a conversation first.
   *
   * @internal
   * @param e - Editor submit event
   * @returns Promise<MessageType>
   */
  async handleSubmit(t) {
    if (!this.user)
      throw new Error("Error submitting message. Missing user.");
    const e = {
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      blobs: t.detail.blobs,
      user: this.user,
      context: t.detail.contextData
    };
    if (this.agentInstructions && (e.metadata = {
      instructions: this.agentInstructions
    }), !this.conversation && this.weavy && this.createConversation && (this.isCreatingConversation = !0, await this.createConversation(e), await this.updateComplete), !this.conversation)
      throw new Error("Error submitting message. Missing conversation.");
    const i = await this.addMessageMutation.mutate({
      ...e,
      app_id: this.conversation.id
    });
    return this.showNewMessages = !1, requestAnimationFrame(() => {
      this.scrollToBottom();
    }), this.isCreatingConversation = !1, i;
  }
  /**
   * Set the editor text programmatically.
   *
   * @param text - Text to set in the editor.
   * @returns Promise<void>
   *
   * @internal
   */
  async setEditorText(t) {
    this.editorRef.value && (this.editorRef.value.text = t, await this.editorRef.value.updateComplete, await new Promise((e) => requestAnimationFrame(e)));
  }
  /**
   * Set metadata on the editor instance.
   *
   * @param metadata - Optional metadata object.
   * @returns Promise<void>
   *
   * @internal
   */
  async setEditorMetadata(t = {}) {
    await this.updateComplete, this.editorRef.value && (this.editorRef.value.metadata = t);
  }
  /**
   * Select all content in the editor.
   *
   * @internal
   */
  async selectAllInEditor() {
    this.editorRef.value && (await this.updateComplete, await this.editorRef.value.updateComplete, this.editorRef.value?.selectAllContent());
  }
  /**
   * Move the editor cursor to the end of the content.
   *
   * @internal
   */
  async setCursorLastInEditor() {
    this.editorRef.value && (await this.updateComplete, await this.editorRef.value.updateComplete, this.editorRef.value?.setCursorLast());
  }
  /**
   * Focus the editor input.
   *
   * @internal
   */
  focusEditor() {
    this.editorRef.value && this.editorRef.value?.focusInput();
  }
  /**
   * Sets the conversation title when the conversation is empty, based on message text.
   *
   * @internal
   * @param name - Title string to set.
   * @returns Promise<void>
   */
  async setEmptyConversationTitle(t) {
    !this.conversation || this.conversation.name || (t = lm(t), await this.updateConversationMutation?.mutate({ appId: this.conversation.id, name: t }));
  }
  /**
   * Mark the conversation as read. Respects visibility and component lifecycle.
   *
   * @param messageId - Optional message id to mark as read.
   * @returns Promise<void>
   *
   * @internal
   */
  async markAsRead(t) {
    await C1(), await Promise.race([Zu(this), nm(this, !1)]), !(!this.componentFeatures?.allowsFeature(S.Receipts) || !this.isConnected) && this.conversation && this.conversation.last_message && await this.markConversationMutation?.mutate({
      app: this.conversation,
      messageId: t ?? this.conversation.last_message.id,
      userId: this.user?.id
    });
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("weavy") && this.weavy && (this.updateConversationMutation = ev(this.weavy), this.markConversationMutation = Jm(this.weavy)), (t.has("weavy") || t.has("conversationId") || t.has("componentFeatures")) && this.weavy) {
      (e = Bf(this, ya)) == null || e.call(this);
      const i = t.get("conversationId");
      if (i && i > 0 && requestAnimationFrame(() => {
        Hu(this.weavy?.queryClient, ["messages", i], void 0, 1);
      }), this.conversationId && this.conversationId > 0) {
        await this.messagesQuery.trackInfiniteQuery(ub(this.weavy, this.conversationId)), await this.addMessageMutation.trackMutation(
          pb(this.weavy, ["messages", this.conversationId])
        ), await this.membersQuery.trackQuery(rv(this.weavy, this.conversationId, {})), this.pollMutation = gy(this.weavy, this.conversationId, ["messages", this.conversationId]), this.lastReadMessageId = void 0, this.showNewMessages = !1;
        const r = `a${this.conversationId}`;
        this.weavy.subscribe(r, "message_created", this.handleRealtimeMessage), this.componentFeatures?.allowsFeature(S.Reactions) && (this.weavy.subscribe(r, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(r, "reaction_removed", this.handleRealtimeReactionDeleted)), this.componentFeatures?.allowsFeature(S.Receipts) && this.weavy.subscribe(r, "app_marked", this.handleRealtimeMarked).then((s) => {
          this.showReadReceipts = s;
        }), Nf(this, ya, () => {
          this.weavy?.unsubscribe(r, "message_created", this.handleRealtimeMessage), this.weavy?.unsubscribe(r, "reaction_added", this.handleRealtimeReactionAdded), this.weavy?.unsubscribe(r, "reaction_removed", this.handleRealtimeReactionDeleted), this.weavy?.unsubscribe(r, "app_marked", this.handleRealtimeMarked), this.showReadReceipts = !1, Nf(this, ya, void 0);
        });
      } else
        this.messagesQuery.untrackInfiniteQuery(), this.addMessageMutation.untrackMutation(), this.membersQuery.untrackQuery();
    }
    if (t.has("showNewMessages") && this.showNewMessages && (this.shouldBeAtBottom = this.isAtBottom), t.has("conversationId") && t.get("conversationId") !== this.conversationId ? this.shouldBeAtBottom = !!this.conversationId : this.shouldBeAtBottom = this.isAtBottom, t.has("conversation")) {
      const i = t.get("conversation");
      if (i?.id !== this.conversation?.id || i?.is_unread !== this.conversation?.is_unread)
        if (this.componentFeatures?.allowsFeature(S.Receipts) && this.conversation?.is_unread) {
          const r = this.membersQuery.result.data?.data?.find(
            (s) => s.id === this.user?.id
          )?.marked_id;
          r && r < this.conversation.last_message.id && (this.lastReadMessagePosition = "below", this.lastReadMessageId = r, this.showNewMessages = !0), (i?.id !== this.conversation?.id || i?.last_message.id !== this.conversation?.last_message.id && (this.shouldBeAtBottom || this.isAtBottom)) && this.markAsRead();
        } else i?.id !== this.conversation?.id && (this.showNewMessages = !1);
    }
    if (this.conversation && !this.conversation?.name && !hf(this.messagesQuery.result.data)) {
      const r = nr(this.messagesQuery.result.data).find((s) => s.plain);
      r && this.setEmptyConversationTitle(cm(r.plain));
    }
  }
  renderConversationHeader() {
    if (!this.header)
      return h` <!-- Top of the conversation --> `;
    const { isPending: t, hasNextPage: e } = this.messagesQuery.result ?? {};
    if (!this.conversation || t || e)
      return b;
    const { data: i } = this.membersQuery.result ?? {}, r = this.user && this.isPrivateChat() ? (this.conversation?.members?.data || []).filter((s) => s.id !== this.user?.id)?.[0] ?? this.user : null;
    return h`
      <wy-avatar-header description=${dt(r?.comment)}>
        ${this.conversation.avatar_url ? h`<wy-avatar .size=${96} src=${this.conversation.avatar_url}></wy-avatar>` : this.isChatRoom() ? h` <wy-avatar-group
              .members=${i?.data}
              title=${this.conversation.name}
              .size=${96}
            ></wy-avatar-group>` : r?.avatar_url ? h`
              <wy-avatar
                src=${dt(r?.avatar_url)}
                name=${this.conversation.name}
                description=${dt(r?.comment)}
                ?isAgent=${r?.is_agent}
                size=${96}
              ></wy-avatar>
            ` : b}
      </wy-avatar-header>
    `;
  }
  renderMessages() {
    const { isPending: t } = this.weavy?.network ?? { isPending: !0 }, {
      data: e,
      isPending: i
      //hasNextPage,
    } = this.messagesQuery.result ?? { isPending: t }, { data: r } = this.membersQuery.result ?? {}, s = nr(e);
    let o;
    return this.conversation && e && !hf(e) ? h`
          <div part="wy-messages">
            <div ${Q(this.pagerRef)} part="wy-pager wy-pager-top"></div>

            ${s && this.conversation && this.user ? je(
      s,
      (c) => c.id,
      (c, l) => {
        const p = new Date(c.created_at);
        let v = h``;
        if (o?.toDateString() !== p.toDateString()) {
          const m = new Intl.DateTimeFormat(this.weavy?.locale, {
            dateStyle: "short"
          }).format(p);
          o = p, v = h`<time part="wy-message-date-separator">${m}</time>`;
        }
        let C = h``;
        this.lastReadMessageId && this.lastReadMessageId === c.id && (C = h`<div
                        id="unread-marker"
                        part="wy-toast wy-toast-action wy-fade ${this.showNewMessages ? "wy-show" : ""}"
                        tabindex=${this.showNewMessages ? 0 : -1}
                        @click=${() => {
          let m = `#message-${this.lastReadMessageId}`;
          this.lastReadMessagePosition === "below" && (m += "~ wy-message"), this.renderRoot.querySelector(m)?.scrollIntoView({
            block: "start",
            inline: "nearest",
            behavior: "smooth"
          });
        }}
                        @keydown=${ve}
                        @keyup=${Ie}
                      >
                        ${x("New messages")}
                      </div>`);
        const g = r?.data?.find((m) => m.id === c.created_by.id) || c.created_by;
        return h`${[
          h`${v}`,
          h`${this.lastReadMessagePosition === "above" ? C : b}`,
          Dd(
            `message-${c.id}`,
            h`<wy-message
                          id="message-${c.id}"
                          .conversation=${this.conversation}
                          .messageId=${c.id}
                          .me=${g.id === this.user?.id}
                          .isAgent=${g.is_agent || !1}
                          .isPrivateChat=${this.conversation?.type === st.PrivateChat || this.conversation?.type === st.AgentChat}
                          .name=${g.name}
                          .comment=${g.comment}
                          .avatar=${g.avatar_url}
                          .createdAt=${c.created_at}
                          .text=${c.plain}
                          .html=${c.html}
                          .annotations=${c.annotations?.data}
                          .attachments=${c.attachments?.data}
                          .meeting=${c.meeting}
                          .pollOptions=${c.options?.data}
                          .embed=${c.embed}
                          .reactions=${c.reactions?.data}
                          .seenBy=${this.showReadReceipts && r && r.data && r.data.length > 0 ? r.data.filter((m) => m.marked_id === c.id && m.id !== this.user?.id) : []}
                          @vote=${(m) => {
              m.detail.parentId && m.detail.parentType && m.detail.parentId && this.pollMutation?.mutate({
                optionId: m.detail.optionId,
                parentType: m.detail.parentType,
                parentId: m.detail.parentId
              });
            }}
                        ></wy-message>`
          ),
          h`${this.lastReadMessagePosition === "below" ? C : b}`
        ]}`;
      }
    ) : b}
            ${this.componentFeatures?.allowsFeature(S.Typing) ? h`
                  <wy-message-typing
                    .conversationId=${this.conversation.id}
                    .userId=${this.user?.id}
                    .isPrivateChat=${this.isPrivateChat()}
                    .members=${r?.data ?? []}
                    @typing=${(c) => this.handleTyping(c)}
                  ></wy-message-typing>
                ` : b}
          </div>
        ` : h`
          <div part="wy-messages">
            <wy-empty part="wy-pane">
              ${i && this.conversationId || this.isCreatingConversation ? h`<wy-progress-circular indeterminate overlay></wy-progress-circular>` : h` <slot name="empty">${this.conversationId ? x("Start the conversation!") : b}</slot> `}
            </wy-empty>
          </div>
        `;
  }
  render() {
    return h`
      ${this.renderConversationHeader()} ${this.renderMessages()}
      <div ${Q(this.bottomRef)}></div>
      <div part="wy-footerbar wy-footerbar-sticky wy-footerbar-floating">
        <slot name="footerbar"></slot>
        <wy-message-editor
          ${Q(this.editorRef)}
          .draft=${!0}
          placeholder=${this.placeholder ?? x("Type a message...")}
          ?disabled=${this.conversation && !Ac(_n.Create, this.conversation?.permissions)}
          @submit=${(t) => this.handleSubmit(t)}
        ></wy-message-editor>
      </div>
    `;
  }
  updated() {
    this.shouldBeAtBottom && (Hu(this.weavy?.queryClient, ["messages", this.conversationId], void 0, 1), requestAnimationFrame(() => {
      this.scrollToBottom();
    })), this.bottomObserver || (this.bottomObserver = new IntersectionObserver((t) => {
      t.forEach((e) => {
        e.isIntersecting && !this.isTyping && this.conversation?.is_unread && this.markAsRead();
      });
    })), this.bottomRef && this.bottomRef.value && this.bottomObserver.observe(this.bottomRef.value), this.infiniteScroll.observe(this.messagesQuery.result, this.pagerRef.value);
  }
  // hook up observer
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("visibilitychange", this.markAsReadHandler), this.conversationId && this.requestUpdate("conversationId");
  }
  disconnectedCallback() {
    var t;
    (t = Bf(this, ya)) == null || t.call(this), this.bottomObserver && this.bottomObserver.disconnect(), document.removeEventListener("visibilitychange", this.markAsReadHandler), this.conversation = void 0, this.shouldBeAtBottom = this.isAtBottom, super.disconnectedCallback();
  }
}, a(Io, "WyConversation"), Io);
ya = /* @__PURE__ */ new WeakMap();
We.styles = [
  _h,
  Jr,
  Xn,
  av,
  xy,
  j`
      :host {
        position: relative;
        display: flex;
        flex-direction: column;
        flex: 1 1 auto;
      }
    `
];
bi([
  Yr({ context: cy }),
  u({ attribute: !1 })
], We.prototype, "conversation", 2);
bi([
  u({ type: Number })
], We.prototype, "conversationId", 2);
bi([
  u({ type: Boolean })
], We.prototype, "header", 2);
bi([
  u()
], We.prototype, "agentInstructions", 2);
bi([
  u()
], We.prototype, "placeholder", 2);
bi([
  D()
], We.prototype, "lastReadMessagePosition", 2);
bi([
  D()
], We.prototype, "lastReadMessageId", 2);
bi([
  D()
], We.prototype, "showNewMessages", 2);
bi([
  D()
], We.prototype, "isCreatingConversation", 2);
bi([
  D()
], We.prototype, "showReadReceipts", 2);
We = bi([
  B("wy-conversation"),
  ht()
], We);
const R3 = j`:host{--_track-height: 4px;--_track-shape: 2px;--_active-indicator-height: 2px;--_active-indicator-color: var(--wy-primary, var(--wy-primary-light, #2f628c));--_warning-color: var(--wy-warning, var(--wy-warning-light, #adb140));--_error-color: var(--wy-error, var(--wy-error-light, #ba1821));--_track-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));display:contents;position:relative}[part~=wy-progress-linear]{border-radius:var(--_track-shape);position:relative;min-width:80px;height:var(--_track-height);content-visibility:auto;contain:strict;flex:1;direction:ltr;inset:0;border-radius:inherit;overflow:hidden;display:flex;align-items:center}[part~=wy-progress-linear][part~=wy-progress-padded]{margin:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem))}[part~=wy-inactive-track],[part~=wy-bar],[part~=wy-bar-inner]{position:absolute}[part~=wy-bar]{animation:none;width:100%;height:var(--_active-indicator-height);transform-origin:left center;transition:transform .25s cubic-bezier(.4,0,.6,1)}[part~=wy-secondary-bar]{display:none}[part~=wy-bar-inner]{inset:0;animation:none;background:var(--_active-indicator-color)}[part~=wy-inactive-track]{background:var(--_track-color);inset:0;transition:transform .25s cubic-bezier(.4,0,.6,1);transform-origin:left center}[part~=wy-progress-indeterminate] [part~=wy-bar]{transition:none}[part~=wy-progress-indeterminate] [part~=wy-primary-bar]{inset-inline-start:-145.167%}[part~=wy-progress-indeterminate] [part~=wy-secondary-bar]{inset-inline-start:-54.8889%;display:block}[part~=wy-progress-indeterminate] [part~=wy-primary-bar]{animation:linear infinite 2s;animation-name:primary-indeterminate-translate}[part~=wy-progress-indeterminate] [part~=wy-primary-bar]>[part~=wy-bar-inner]{animation:linear infinite 2s primary-indeterminate-scale}[part~=wy-progress-indeterminate] [part~=wy-secondary-bar]{animation:linear infinite 2s;animation-name:secondary-indeterminate-translate}[part~=wy-progress-indeterminate] [part~=wy-secondary-bar]>[part~=wy-bar-inner]{animation:linear infinite 2s secondary-indeterminate-scale}@keyframes primary-indeterminate-scale{0%{transform:scaleX(.08)}36.65%{animation-timing-function:cubic-bezier(.334731,.12482,.785844,1);transform:scaleX(.08)}69.15%{animation-timing-function:cubic-bezier(.06,.11,.6,1);transform:scaleX(.661479)}to{transform:scaleX(.08)}}@keyframes secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(.205028,.057051,.57661,.453971);transform:scaleX(.08)}19.15%{animation-timing-function:cubic-bezier(.152313,.196432,.648374,1.00432);transform:scaleX(.457104)}44.15%{animation-timing-function:cubic-bezier(.257759,-.003163,.211762,1.38179);transform:scaleX(.72796)}to{transform:scaleX(.08)}}@keyframes primary-indeterminate-translate{0%{transform:translate(0)}20%{animation-timing-function:cubic-bezier(.5,0,.701732,.495819);transform:translate(0)}59.15%{animation-timing-function:cubic-bezier(.302435,.381352,.55,.956352);transform:translate(83.6714%)}to{transform:translate(200.611%)}}@keyframes secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(.15,0,.515058,.409685);transform:translate(0)}25%{animation-timing-function:cubic-bezier(.31033,.284058,.8,.733712);transform:translate(37.6519%)}48.35%{animation-timing-function:cubic-bezier(.4,.627035,.6,.902026);transform:translate(84.3862%)}to{transform:translate(160.278%)}}[part~=wy-progress-warning] [part~=wy-primary-bar],[part~=wy-progress-warning] [part~=wy-secondary-bar],[part~=wy-progress-warning] [part~=wy-bar-inner],[part~=wy-progress-error] [part~=wy-primary-bar],[part~=wy-progress-error] [part~=wy-secondary-bar],[part~=wy-progress-error] [part~=wy-bar-inner]{animation:none!important}[part~=wy-progress-warning] [part~=wy-secondary-bar],[part~=wy-progress-error] [part~=wy-secondary-bar]{display:none!important}[part~=wy-progress-warning] [part~=wy-primary-bar],[part~=wy-progress-error] [part~=wy-primary-bar]{transform:scaleX(1)!important}[part~=wy-progress-warning] [part~=wy-bar-inner]{background:var(--_warning-color)}[part~=wy-progress-error] [part~=wy-bar-inner]{background:var(--_error-color)}`;
var T3 = Object.defineProperty, L3 = Object.getOwnPropertyDescriptor, mr = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? L3(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && T3(t, e, r), r;
}, "__decorateClass$B"), Fo;
let li = (Fo = class extends it {
  constructor() {
    super(...arguments), this.shadowParts = new q(this), this.padded = !1, this.overlay = !1, this.reveal = !1, this.value = 0, this.max = 1, this.indeterminate = !1, this.warning = !1, this.error = !1;
  }
  render() {
    let t;
    try {
      Number.isFinite(this.value) && Number.isFinite(this.max) && this.max > 0 && (t = this.value / this.max);
    } catch (s) {
      console.error(s);
    }
    const e = this.indeterminate || t === void 0, i = {
      transform: `scaleX(${(e ? 1 : this.value / this.max) * 100}%)`
    }, r = {
      "wy-progress": !0,
      "wy-progress-linear": !0,
      "wy-progress-indeterminate": e,
      "wy-progress-overlay": this.overlay,
      "wy-progress-padded": this.padded,
      "wy-progress-reveal": this.reveal,
      "wy-progress-warning": this.warning,
      "wy-progress-error": this.error
    };
    return h`
      <div
        part=${J(r)}
        role="progressbar"
        aria-label="${b}"
        aria-valuemin="0"
        aria-valuemax=${this.max}
        aria-valuenow=${e ? b : this.value}
      >
        <div part="wy-inactive-track"></div>
        <div part="wy-bar wy-primary-bar" style=${kl(i)}>
          <div part="wy-bar-inner"></div>
        </div>
        <div part="wy-bar wy-secondary-bar">
          <div part="wy-bar-inner"></div>
        </div>
      </div>
    `;
  }
}, a(Fo, "WyProgressLinear"), Fo);
li.styles = [Ht, ov, R3];
mr([
  u({ type: Boolean })
], li.prototype, "padded", 2);
mr([
  u({ type: Boolean })
], li.prototype, "overlay", 2);
mr([
  u({ type: Boolean })
], li.prototype, "reveal", 2);
mr([
  u({ type: Number })
], li.prototype, "value", 2);
mr([
  u({ type: Number })
], li.prototype, "max", 2);
mr([
  u({ type: Boolean })
], li.prototype, "indeterminate", 2);
mr([
  u({ type: Boolean })
], li.prototype, "warning", 2);
mr([
  u({ type: Boolean })
], li.prototype, "error", 2);
li = mr([
  B("wy-progress-linear")
], li);
var O3 = Object.getOwnPropertyDescriptor, Yv = /* @__PURE__ */ a((n) => {
  throw TypeError(n);
}, "__typeError$7"), z3 = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? O3(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = o(r) || r);
  return r;
}, "__decorateClass$A"), I3 = /* @__PURE__ */ a((n, t, e) => t.has(n) || Yv("Cannot " + e), "__accessCheck$7"), Uf = /* @__PURE__ */ a((n, t, e) => (I3(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$7"), F3 = /* @__PURE__ */ a((n, t, e) => t.has(n) ? Yv("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$7"), Bd, Do;
let uh = (Do = class extends Dt {
  constructor() {
    super(...arguments), this.exportParts = new q(this), F3(this, Bd, new kc(this));
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("contextId") || t.has("componentFeatures")) && this.weavy && this.contextId && this.componentFeatures?.allowsFeature(S.ContextData) && await Uf(this, Bd).trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.contextId, "data"],
          exact: !0
        }
      },
      this.weavy.queryClient
    );
  }
  render() {
    const { result: t, isMutating: e } = Uf(this, Bd), i = t?.filter((o) => o.variables?.file), r = Um(i), s = Ep(i);
    return this.componentFeatures?.allowsFeature(S.ContextData) && t && t.length ? h`
          ${e || r.percent !== null && r.percent < 100 ? h`
                <wy-progress-linear
                  ?indeterminate=${r.percent === null}
                  overlay
                  reveal
                  ?warning=${s === "error"}
                  value=${r.percent ?? 0}
                  max=${100}
                ></wy-progress-linear>
              ` : b}
        ` : b;
  }
}, a(Do, "WyContextDataProgress"), Do);
Bd = /* @__PURE__ */ new WeakMap();
uh.styles = [X];
uh = z3([
  B("wy-context-data-progress")
], uh);
var D3 = Object.defineProperty, V3 = Object.getOwnPropertyDescriptor, Vy = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? V3(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && D3(t, e, r), r;
}, "__decorateClass$z"), Vo;
let Dc = (Vo = class extends Re {
  constructor() {
    super(...arguments), this.appType = st.Chat, this.componentFeatures = new le({
      // All available features as enabled/disabled by default
      [S.Attachments]: !0,
      [S.ContextData]: !0,
      [S.CloudFiles]: !0,
      [S.Embeds]: !0,
      [S.GoogleMeet]: !0,
      [S.Meetings]: !0,
      [S.Mentions]: !0,
      [S.MicrosoftTeams]: !0,
      [S.Polls]: !0,
      [S.Previews]: !0,
      [S.Reactions]: !0,
      [S.Receipts]: !1,
      [S.Typing]: !1,
      [S.ZoomMeetings]: !0
    }), this.theme = new _e(this, Dc.styles);
  }
  render() {
    return h`
      <wy-buttons position="floating" reverse><slot name="actions"></slot></wy-buttons>
      <wy-conversation
        .agentInstructions=${this.instructions}
        .conversation=${this.app}
        .conversationId=${this.app?.id}
        .placeholder=${this.placeholder}
      >
        <wy-context-data-progress slot="footerbar"></wy-context-data-progress>
      </wy-conversation>
    `;
  }
}, a(Vo, "WyChat"), Vo);
Dc.styles = [wr, Gn, Zn, se, Fe];
Vy([
  u()
], Dc.prototype, "instructions", 2);
Vy([
  u()
], Dc.prototype, "placeholder", 2);
Dc = Vy([
  B("wy-chat"),
  ht()
], Dc);
var H3 = Object.defineProperty, B3 = Object.getOwnPropertyDescriptor, Xv = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? B3(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && H3(t, e, r), r;
}, "__decorateClass$y"), Ho;
let Vl = (Ho = class extends Re {
  constructor() {
    super(...arguments), this.appType = st.Comments, this.componentFeatures = new le({
      // All available features as enabled/disabled by default
      [S.Attachments]: !0,
      [S.CloudFiles]: !0,
      [S.ContextData]: !0,
      [S.Embeds]: !0,
      [S.GoogleMeet]: !1,
      [S.Meetings]: !1,
      [S.Mentions]: !0,
      [S.MicrosoftTeams]: !1,
      [S.Polls]: !0,
      [S.Previews]: !0,
      [S.Reactions]: !0,
      [S.Typing]: !1,
      // Has no effect currently
      [S.ZoomMeetings]: !1
    }), this.theme = new _e(this, Vl.styles);
  }
  render() {
    return h`
      <wy-buttons position="floating" reverse><slot name="actions"></slot></wy-buttons>
      <wy-comment-list .parentId=${this.app?.id} .location=${"apps"} .placeholder=${this.placeholder}></wy-comment-list>
      <wy-context-data-progress></wy-context-data-progress>
    `;
  }
}, a(Ho, "WyComments"), Ho);
Vl.styles = [wr, Gn, Zn, se, Fe, Iy];
Xv([
  u()
], Vl.prototype, "placeholder", 2);
Vl = Xv([
  B("wy-comments"),
  ht()
], Vl);
function N3(n) {
  if (!this.weavy || !this.app)
    return;
  const t = {
    message: n.message,
    direction: n.message.created_by.id === this.user?.id ? "outbound" : "inbound"
  };
  n.message.created_by.is_agent && (t.agent = n.message.created_by.uid);
  const e = new CustomEvent("wy-message", {
    bubbles: !1,
    cancelable: !1,
    composed: !0,
    detail: t
  });
  this.dispatchEvent(e);
}
a(N3, "triggerMessageEvent");
var U3 = Object.defineProperty, q3 = Object.getOwnPropertyDescriptor, Hy = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? q3(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && U3(t, e, r), r;
}, "__decorateClass$x"), Bo;
let Vc = (Bo = class extends Re {
  constructor() {
    super(...arguments), this.appType = st.AgentChat, this.componentFeatures = new le({
      // All available features as enabled/disabled by default
      [S.Attachments]: !1,
      [S.ContextData]: !0,
      [S.Embeds]: !0,
      [S.Mentions]: !1,
      [S.Previews]: !0,
      [S.Reactions]: !1,
      [S.Typing]: !0
    }), this.theme = new _e(this, Vc.styles), this.conversationRef = nt(), this.handleRealtimeMessage = N3.bind(this);
  }
  /**
   * Sets the editor input to a suggested text. This replaces the text content of the editor. This can be used to create any custom suggestions.
   *
   * @param {string} text - The text suggestion to place in the editor.
   */
  async setSuggestion(t) {
    await this.conversationRef.value?.setEditorText(t);
  }
  async willUpdate(t) {
    if (await super.willUpdate(t), t.has("weavy") && this.weavy && (this.addConversationMutation = jm(this.weavy)), (t.has("app") || t.has("weavy")) && this.weavy && (this.unsubscribeToRealtime?.(), this.app)) {
      const e = `a${this.app.id}`;
      this.weavy.subscribe(e, "message_created", this.handleRealtimeMessage), this.unsubscribeToRealtime = () => {
        this.weavy?.unsubscribe(e, "message_created", this.handleRealtimeMessage), this.unsubscribeToRealtime = void 0;
      };
    }
    t.has("agent") && t.get("agent") && this.agent && this.reset();
  }
  render() {
    return this.agent ? h`
          <wy-buttons position="floating" reverse>
            <slot name="actions"></slot>
          </wy-buttons>
          <wy-conversation
            ${Q(this.conversationRef)}
            .conversation=${this.app}
            .conversationId=${this.app?.id}
            .placeholder=${this.placeholder ?? x("Ask anything...")}
            .agentInstructions=${this.instructions}
            .createConversation=${this.agent && this.addConversationMutation ? async (t) => {
      if (!this.agent || !this.addConversationMutation)
        throw new Error("Agent or addConversationMutation not defined");
      const e = {
        uid: `wy-copilot-${pl()}`,
        name: lm(cm(this.name ?? t.text)),
        members: [this.agent],
        type: yi.AgentChat
      }, i = await this.addConversationMutation.mutate(e);
      return this.app = i, await this.updateComplete, i;
    } : void 0}
          >
            <slot
              slot="empty"
              name="empty"
              @click=${async (t) => {
      t.target.matches(".suggestion") && (t.stopPropagation(), await this.setSuggestion(t.target.innerText), await this.conversationRef.value?.setCursorLastInEditor(), this.conversationRef.value?.focusEditor());
    }}
              @keydown=${ve}
              @keyup=${Ie}
            >
              <slot name="header">
                <wy-icon-display>
                  <slot name="icon">
                    <wy-icon name="stars"></wy-icon>
                  </slot>
                </wy-icon-display>
              </slot>
              <slot name="suggestions">
                <wy-item-list>
                  <slot name="suggestion-list">
                    <!--wy-button class="suggestion">Summarize this page</wy-button-->
                  </slot>
                </wy-item-list>
              </slot>
              <slot name="footer"></slot>
            </slot>
            <wy-context-data-progress slot="footerbar"></wy-context-data-progress>
          </wy-conversation>
        ` : h`
          <wy-empty>
            <wy-icon-display>
              <slot name="icon">
                <wy-icon name="stars"></wy-icon>
              </slot>
            </wy-icon-display>
          </wy-empty>
        `;
  }
}, a(Bo, "WyCopilot"), Bo);
Vc.styles = [wr, Gn, Zn, se, Fe];
Hy([
  u()
], Vc.prototype, "instructions", 2);
Hy([
  u()
], Vc.prototype, "placeholder", 2);
Vc = Hy([
  B("wy-copilot"),
  ht()
], Vc);
var j3 = Object.defineProperty, W3 = Object.getOwnPropertyDescriptor, xd = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? W3(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && j3(t, e, r), r;
}, "__decorateClass$w"), No;
let Wr = (No = class extends Dt {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.order = { by: "name", descending: !1 }, this.view = "list", this.showTrashed = !1, this.showUploadSheet = !1, this.mutatingFiles = new kc(
      this
    ), this.previousFailedFileMutations = [], this.fileInputRef = nt(), this.cloudFilesRef = nt(), this.openFileInput = () => {
      this.fileInputRef.value?.click();
    }, this.openCloudFiles = () => {
      this.cloudFilesRef.value?.open();
    };
  }
  // remove file attachment
  /**
   * Remove (or abort) an ongoing upload mutation.
   *
   * @internal
   * @param mutationState - Mutation state to remove.
   */
  async handleRemoveMutation(t) {
    const e = await this.whenWeavy(), i = await this.whenApp();
    t.status === "pending" && Mp(t.variables) && t.variables.abort?.();
    const r = t.status === "error" && !t.variables?.blob || t.status === "pending" ? ["apps", i.id, "blobs"] : ["apps", i.id, "files"];
    Nm(
      e.queryClient,
      r,
      (s) => s.state.submittedAt === t.submittedAt
    );
  }
  /**
   * Retry an upload by replacing the existing file.
   *
   * @internal
   * @param mutation - Failed mutation carrying the blob data.
   */
  handleOverwriteUpload(t) {
    const e = t.variables?.blob;
    e && this.dispatchCreateFiles([e], !0);
  }
  /**
   * Dispatch an `upload-files` event with the selected files.
   *
   * @param files - Files chosen from the native picker.
   * @returns Whether the event was not canceled.
   */
  dispatchUploadFiles(t) {
    this.weavy && this.app && (_0(this.weavy, this.app), Ep(this.mutatingFiles.result) === "ok" && Rp(this.weavy, this.app));
    const e = new CustomEvent("upload-files", {
      detail: { files: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit an `external-blobs` event with selected cloud blobs.
   *
   * @internal
   * @param externalBlobs - Blobs returned from the cloud picker.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchExternalBlobs(t) {
    const e = new CustomEvent("external-blobs", {
      detail: { externalBlobs: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `create-files` event for programmatic uploads.
   *
   * @internal
   * @param blobs - Blobs to create files from.
   * @param replace - When true, replace the existing file.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchCreateFiles(t, e = !1) {
    const i = new CustomEvent("create-files", {
      detail: { blobs: t, replace: e }
    });
    return this.dispatchEvent(i);
  }
  /**
   * Emit an `order` event reflecting the chosen sort order.
   *
   * @internal
   * @param order - Order to apply.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `view` event for changing layout mode.
   *
   * @internal
   * @param view - Layout to activate.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchView(t) {
    const e = new CustomEvent("view", { detail: { view: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `show-trashed` event to toggle trashed visibility.
   *
   * @internal
   * @param showTrashed - Whether to show trashed files.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchShowTrashed(t) {
    const e = new CustomEvent("show-trashed", {
      detail: { showTrashed: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event to toggle app subscription.
   *
   * @internal
   * @param subscribe - Desired subscription state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", { detail: { subscribe: t } });
    return this.dispatchEvent(e);
  }
  async willUpdate(t) {
    super.willUpdate(t), t.has("app") && this.app && this.app.id !== t.get("app")?.id && this.weavy && Rp(this.weavy, this.app), (t.has("weavy") || t.has("app")) && this.weavy && this.app && await this.mutatingFiles.trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.app.id],
          exact: !1
        }
      },
      this.weavy.queryClient
    );
  }
  renderFileMutation(t) {
    if (t.context?.file) {
      const e = t.context.file, i = {
        ...t.context.status
      };
      return t.context.status.state === "conflict" && (i.text = x("Replace existing file?")), h`
        <wy-file-item
          rounded
          .file=${t.context?.file}
          .status=${i}
          .actionType=${t.context.type}
          title="${sm(t.context.type)}: ${e.name}"
        >
          <span slot="title">${e.name}</span>
          ${t.context.status.state === "conflict" && i.text ? h`: <span slot="actions" title=${i.text}><em>${i.text}</em></span>` : b}
          ${i.state === "conflict" && t.variables?.blob ? h`
                <wy-button
                  slot="actions"
                  kind="icon"
                  @click=${() => this.handleOverwriteUpload(
        t
      )}
                  title=${x("Replace")}
                >
                  <wy-icon name="check"></wy-icon>
                </wy-button>
              ` : b}
          ${i.state === "pending" ? h`
                <wy-progress-circular
                  slot="actions"
                  padded
                  ?indeterminate=${!i.progress}
                  .max=${100}
                  .value=${i.progress || 0}
                ></wy-progress-circular>

                ${Mp(t.variables) ? h`<wy-button slot="actions" kind="icon" @click=${() => this.handleRemoveMutation(t)}>
                      <wy-icon name="close"></wy-icon>
                    </wy-button>` : b}
              ` : h`<wy-button slot="actions" kind="icon" @click=${() => this.handleRemoveMutation(t)}>
                <wy-icon name="close"></wy-icon>
              </wy-button> `}
        </wy-file-item>
      `;
    }
    return b;
  }
  render() {
    const t = this.mutatingFiles.result, e = cf(t), i = of(t), r = Um(t), s = Ep(t);
    return h`
      <header part="wy-files-header wy-header wy-header-outer">
        <nav part="wy-files-header-toolbar wy-toolbar">
          <div part="wy-toolbar-buttons">
            ${Ac(_n.Create, this.app?.permissions) ? h`
                  <wy-dropdown title=${x("Add files")}>
                    <wy-icon slot="button-content" name="plus" first></wy-icon>
                    <span slot="button-content">${x("Add files")}</span>
                    <wy-dropdown-item @click=${this.openFileInput} title=${x("From device")}>
                      <wy-icon name="attachment"></wy-icon>
                      <span>${x("From device")}</span>
                    </wy-dropdown-item>
                    <input
                      type="file"
                      data-testid="uploadFile"
                      ${Q(this.fileInputRef)}
                      @click=${(o) => o.stopPropagation()}
                      @change=${(o) => {
      this.dispatchUploadFiles(o.target.files) && (o.target.value = "");
    }}
                      multiple
                      hidden
                      tabindex="-1"
                    />
                    ${this.componentFeatures?.allowsFeature(S.CloudFiles) ? h`
                          <wy-dropdown-item @click=${this.openCloudFiles} title=${x("From cloud")}>
                            <wy-icon name="cloud"></wy-icon>
                            <span>${x("From cloud")}</span>
                          </wy-dropdown-item>
                        ` : b}
                  </wy-dropdown>
                ` : b}
            ${t?.length ? h`
                  <wy-button
                    kind="icon"
                    @click=${() => {
      this.showUploadSheet = !this.showUploadSheet;
    }}
                    title=${s === "conflict" ? x("File conflict") : s === "error" ? x("Upload error") : s === "pending" ? x("Pending") : x("All uploads finished")}
                  >
                    ${s === "conflict" ? h`<wy-icon name="alert" color="yellow"></wy-icon>` : s === "error" ? h`<wy-icon name="alert-octagon" color="error"></wy-icon>` : s === "pending" ? h`<wy-progress-circular
                          ?indeterminate=${r.percent === null}
                          .value=${r.loaded}
                          .max=${r.total}
                        ></wy-progress-circular>` : h`<wy-icon name="check"></wy-icon>`}
                  </wy-button>
                ` : b}
          </div>
          <div part="wy-toolbar-buttons wy-toolbar-buttons-last">
            <slot name="actions"></slot>

            <wy-dropdown icon="sort" title="Sort items by" directionX="left">
              <wy-dropdown-option
                ?selected=${this.order.by === "name"}
                @click=${() => this.dispatchOrder({ ...this.order, by: "name" })}
              >
                ${x("Name")}
              </wy-dropdown-option>
              <wy-dropdown-option
                ?selected=${this.order.by === "updated_at"}
                @click=${() => this.dispatchOrder({ ...this.order, by: "updated_at" })}
              >
                ${x("Modified")}
              </wy-dropdown-option>
              <wy-dropdown-option
                ?selected=${this.order.by === "size"}
                @click=${() => this.dispatchOrder({ ...this.order, by: "size" })}
              >
                ${x("Size")}
              </wy-dropdown-option>
              <wy-dropdown-divider></wy-dropdown-divider>
              <wy-dropdown-option
                ?selected=${!this.order.descending}
                @click=${() => this.dispatchOrder({ ...this.order, descending: !1 })}
              >
                ${x("Ascending")}
              </wy-dropdown-option>
              <wy-dropdown-option
                ?selected=${this.order.descending}
                @click=${() => this.dispatchOrder({ ...this.order, descending: !0 })}
              >
                ${x("Descending")}
              </wy-dropdown-option>
            </wy-dropdown>

            <wy-dropdown
              icon=${this.view === "grid" ? "view-module-outline" : "view-list-outline"}
              title="View options"
              directionX="left"
            >
              <wy-dropdown-option ?selected=${this.view === "list"} @click=${() => this.dispatchView("list")}>
                ${x("List view")}
              </wy-dropdown-option>
              <wy-dropdown-option ?selected=${this.view === "grid"} @click=${() => this.dispatchView("grid")}>
                ${x("Grid view")}
              </wy-dropdown-option>
              <wy-dropdown-divider></wy-dropdown-divider>
              <wy-dropdown-option ?selected=${!this.showTrashed} @click=${() => this.dispatchShowTrashed(!1)}>
                ${x("Hide trashed")}
              </wy-dropdown-option>
              <wy-dropdown-option ?selected=${this.showTrashed} @click=${() => this.dispatchShowTrashed(!0)}>
                ${x("Show trashed")}
              </wy-dropdown-option>
            </wy-dropdown>

            <wy-dropdown directionX="left" ?disabled=${!this.app}>
              ${this.app?.is_subscribed ? h`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                    <wy-icon name="bell-off"></wy-icon>
                    ${x("Unsubscribe")}
                  </wy-dropdown-item>` : h`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                    <wy-icon name="bell"></wy-icon>
                    ${x("Subscribe")}
                  </wy-dropdown-item>`}
              ${this.app?.archive_url ? h`<wy-dropdown-item
                    @click=${() => tr(
      this.app?.archive_url,
      "_top",
      `${this.app?.uid ? this.app.uid : `${this.app?.type}-${this.app?.id}`}.zip`,
      !0
    )}
                  >
                    <wy-icon name="download"></wy-icon>
                    ${x("Download files")}
                  </wy-dropdown-item>` : b}
            </wy-dropdown>
          </div>
        </nav>

        <wy-context-data-progress></wy-context-data-progress>
      </header>

      ${this.weavy ? h`
            <wy-overlay
              type="sheet"
              .show=${this.showUploadSheet}
              @close=${() => {
      this.showUploadSheet = !1;
    }}
            >
              <span slot="title">${x("File actions")}</span>
              <wy-container scrollY padded>
                ${!e.length && !i.length ? h`
                      <wy-empty noNetwork><wy-container padded>${x("No pending uploads")}</wy-container></wy-empty>
                    ` : b}
                ${e.length ? h`
                      ${je(
      e,
      (o) => "mutation" + o.submittedAt,
      (o) => this.renderFileMutation(o)
    )}
                    ` : b}
                ${i.length ? h`
                      ${je(
      i,
      (o) => "mutation" + o.submittedAt,
      (o) => this.renderFileMutation(o)
    )}
                    ` : b}
              </wy-container>
            </wy-overlay>
          ` : b}

      <wy-cloud-files
        ${Q(this.cloudFilesRef)}
        @external-blobs=${(o) => this.dispatchExternalBlobs(o.detail.externalBlobs)}
      ></wy-cloud-files>
    `;
  }
  updated(t) {
    super.updated(t);
    const e = cf(this.mutatingFiles.result), i = of(this.mutatingFiles.result);
    e.some(
      (s) => !this.previousFailedFileMutations.includes(s)
    ) ? this.showUploadSheet = !0 : this.showUploadSheet && !e.length && !i.length && setTimeout(() => {
      !e.length && !i.length && (this.showUploadSheet = !1);
    }, 1500), this.previousFailedFileMutations = e ?? [];
  }
}, a(No, "WyFilesHeader"), No);
Wr.styles = [Oy, Bv, X];
xd([
  u({ type: Object })
], Wr.prototype, "order", 2);
xd([
  u()
], Wr.prototype, "view", 2);
xd([
  u({ type: Boolean })
], Wr.prototype, "showTrashed", 2);
xd([
  D()
], Wr.prototype, "showUploadSheet", 2);
Wr = xd([
  B("wy-files-header"),
  ht()
], Wr);
function K3(n, t, e = {}, i = {}) {
  if (!n)
    throw new Error("useFileList must be used within a WeavyContext");
  return {
    ...i,
    queryKey: ["apps", t, "files", e],
    initialPageParam: 0,
    queryFn: /* @__PURE__ */ a(async (s) => {
      const o = s.pageParam, c = !!e?.trashed, l = e.order ? e.order.by + (e.order.descending ? "+desc" : "") : "";
      let p = "/api/apps/" + t + "/files?skip=" + o + "&order_by=" + l;
      return c && (p += "&trashed=null"), await (await n.fetch(p)).json();
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ a((s) => s.end && s.end < s.count ? s.end : null, "getNextPageParam")
  };
}
a(K3, "getInfiniteFileListOptions");
function Q3(n, t) {
  const e = n.queryClient, r = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ a(async ({ file: s }) => {
      if (s.id >= 1) {
        if (!(await n.fetch("/api/files/" + s.id + "/trash", { method: "POST" })).ok)
          throw new Error();
      } else
        throw new Error(`Could not trash ${s.name}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((s) => (yt(
      e,
      { queryKey: r.mutationKey, exact: !1 },
      s.file.id,
      (o) => Object.assign(o, { is_trashed: !0 })
    ), { type: "trash", file: s.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ a((s, o) => {
      yt(
        e,
        { queryKey: r.mutationKey, exact: !1 },
        o.file.id,
        (c) => Object.assign(c, s)
      ), qt(e, r.mutationKey, o, (c) => {
        c.status.state = "ok";
      });
    }, "onSuccess"),
    onError(s, o) {
      yt(
        e,
        { queryKey: r.mutationKey, exact: !1 },
        o.file.id,
        (c) => Object.assign(c, { is_trashed: !1 })
      ), qt(e, r.mutationKey, o, (c) => {
        c.status.state = "error", c.status.text = s.message;
      });
    }
  };
  return r;
}
a(Q3, "getTrashFileMutationOptions");
function G3(n, t) {
  return new Mt(n.queryClient, Q3(n, t));
}
a(G3, "getTrashFileMutation");
function Z3(n, t) {
  const e = n.queryClient, r = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ a(async ({ file: s }) => {
      if (s.id >= 1) {
        const o = await n.fetch("/api/files/" + s.id + "/restore", { method: "POST" });
        if (!o.ok) {
          const c = await o.json();
          throw new Error(c.detail || c.title, { cause: c });
        }
      } else {
        const o = { status: 400, title: `Could not restore ${s.name}.` };
        throw new Error(o.detail || o.title, { cause: o });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((s) => (yt(
      e,
      { queryKey: r.mutationKey, exact: !1 },
      s.file.id,
      (o) => Object.assign(o, { status: "pending" })
    ), { type: "restore", file: s.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ a((s, o) => {
      yt(
        e,
        { queryKey: r.mutationKey, exact: !1 },
        o.file.id,
        (c) => Object.assign(c, { is_trashed: !1, status: "ok" })
      ), qt(e, r.mutationKey, o, (c) => {
        c.status.state = "ok";
      });
    }, "onSuccess"),
    onError(s, o) {
      yt(
        e,
        { queryKey: r.mutationKey, exact: !1 },
        o.file.id,
        (c) => Object.assign(c, { is_trashed: !0 })
      ), qt(e, r.mutationKey, o, (c) => {
        c.status.state = "error", c.status.text = s.message;
      });
    }
  };
  return r;
}
a(Z3, "getRestoreFileMutationOptions");
function Y3(n, t) {
  return new Mt(n.queryClient, Z3(n, t));
}
a(Y3, "getRestoreFileMutation");
function X3(n, t) {
  const e = n.queryClient, r = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ a(async ({ file: s }) => {
      if (s.id >= 1 && s.is_trashed) {
        const o = await n.fetch("/api/files/" + s.id, { method: "DELETE" });
        if (!o.ok) {
          const c = await o.json();
          throw new Error(c.detail || c.title, { cause: c });
        }
      } else {
        const o = { status: 400, title: `Could not delete ${s.name} forever.` };
        throw new Error(o.detail || o.title, { cause: o });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((s) => (yt(
      e,
      { queryKey: r.mutationKey, exact: !1 },
      s.file.id,
      (o) => Object.assign(o, { status: "pending" })
    ), { type: "delete-forever", file: s.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ a((s, o) => {
      Y0(e, { queryKey: r.mutationKey, exact: !1 }, o.file.id), qt(e, r.mutationKey, o, (c) => {
        c.status.state = "ok";
      });
    }, "onSuccess"),
    onError(s, o) {
      yt(
        e,
        { queryKey: r.mutationKey, exact: !1 },
        o.file.id,
        (c) => Object.assign(c, { status: void 0 })
      ), qt(e, r.mutationKey, o, (c) => {
        c.status.state = "error", c.status.text = s.message;
      });
    }
  };
  return r;
}
a(X3, "getDeleteForeverFileMutationOptions");
function J3(n, t) {
  return new Mt(n.queryClient, X3(n, t));
}
a(J3, "getDeleteForeverFileMutation");
function tC(n, t) {
  const e = n.queryClient, i = ["apps", t.id, "files"];
  return {
    mutationKey: i,
    mutationFn: /* @__PURE__ */ a(async ({ file: s, subscribe: o }) => {
      if (s.id >= 1) {
        const c = await n.fetch(`/api/files/${s.id}/${o ? "subscribe" : "unsubscribe"}`, {
          method: "POST"
        });
        if (!c.ok) {
          const l = await c.json();
          throw new Error(l.detail || l.title, { cause: l });
        }
      } else
        throw new Error(`Could not ${o ? "subscribe" : "unsubscribe"} to ${s.name}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((s) => (yt(
      e,
      { queryKey: i, exact: !1 },
      s.file.id,
      (o) => Object.assign(o, { is_subscribed: s.subscribe, status: "pending" })
    ), {
      type: s.subscribe ? "subscribe" : "unsubscribe",
      file: s.file,
      status: { state: "pending" }
    }), "onMutate"),
    onSuccess: /* @__PURE__ */ a((s, o) => {
      yt(
        e,
        { queryKey: i, exact: !1 },
        o.file.id,
        (c) => Object.assign(c, { status: "ok" })
      ), qt(e, i, o, (c) => {
        c.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ a((s, o) => {
      yt(
        e,
        { queryKey: i, exact: !1 },
        o.file.id,
        (c) => Object.assign(c, { is_subscribed: o.file.is_subscribed, status: "error" })
      ), qt(e, i, o, (c) => {
        c.status.state = "error", c.status.text = s.message;
      });
    }, "onError")
  };
}
a(tC, "getSubscribeFileMutationOptions");
function eC(n, t) {
  return new Mt(n.queryClient, tC(n, t));
}
a(eC, "getSubscribeFileMutation");
function iC(n, t) {
  const e = n.queryClient, r = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ a(async ({ file: s, name: o }) => {
      if (s.id >= 1) {
        const c = await n.fetch("/api/files/" + s.id, {
          method: "PATCH",
          body: JSON.stringify({
            name: o
          })
        });
        if (!c.ok) {
          const l = await c.json();
          throw new Error(l.detail || l.title, { cause: l });
        }
        return await c.json();
      } else
        throw new Error(`Could not rename ${s.name}`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((s) => (yt(
      e,
      { queryKey: r.mutationKey, exact: !1 },
      s.file.id,
      (o) => Object.assign(o, { name: s.name })
    ), { type: "rename", file: s.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ a((s, o) => {
      yt(
        e,
        { queryKey: r.mutationKey, exact: !1 },
        o.file.id,
        (c) => Object.assign(c, s)
      ), qt(e, r.mutationKey, o, (c) => {
        c.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ a((s, o) => {
      yt(
        e,
        { queryKey: r.mutationKey, exact: !1 },
        o.file.id,
        (c) => Object.assign(c, { name: o.file.name })
      ), qt(e, r.mutationKey, o, (c) => {
        c.status.state = "error", c.status.text = s.message;
      });
    }, "onError")
  };
  return r;
}
a(iC, "getRenameFileMutationOptions");
function rC(n, t) {
  return new Mt(n.queryClient, iC(n, t));
}
a(rC, "getRenameFileMutation");
const nC = j`[part~=wy-grid]{display:grid;grid-auto-flow:dense;grid-template-columns:repeat(auto-fill,minmax(calc(10 * var(--wy-size, 1rem)),1fr));grid-gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) 0}`, aC = j`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-card]{--wy-component-background-color: var(--wy-surface-layer-high, var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039)));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));--wy-component-border-radius: var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));position:relative;display:flex;flex-direction:column;min-width:0;word-wrap:break-word;background-clip:border-box;padding:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-card][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-card-primary]{--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73))}[part~=wy-trashed]{text-decoration:line-through;opacity:var(--wy-opacity-disabled, 38%)}[part~=wy-card-hover]{cursor:pointer;-webkit-user-select:none;user-select:none}[part~=wy-card-hover]:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-card-hover]:hover:before{opacity:var(--wy-opacity-state-hover, 8%)}[part~=wy-card-hover]:focus:before{opacity:var(--wy-opacity-state-focus, 12%)}[part~=wy-card-hover]:active:before,[part~=wy-card-hover][part~=wy-active]:before{opacity:var(--wy-opacity-state-active, 12%)}[part~=wy-card-actions]{position:absolute;top:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));right:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));align-items:center;display:flex}[part~=wy-card-icon]{--wy-component-icon-width: calc(6 * var(--wy-size, 1rem));--wy-component-icon-height: calc(6 * var(--wy-size, 1rem));display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;margin:auto}[part~=wy-card-image]{width:auto;height:auto;border-radius:var(--wy-component-border-radius);object-fit:cover;object-position:center;flex:1 1 100%;max-height:calc(10*var(--wy-size, 1rem))}[part~=wy-card-image][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-card-image][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-card-image-top]{object-position:top center}[part~=wy-card-title]{padding:0 var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:flex;align-items:center;justify-content:space-between;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));height:2.25rem;box-sizing:border-box}[part~=wy-input]{height:2.25rem;box-sizing:border-box;flex:0 1 auto}[part~=wy-card-text]{line-height:var(--wy-line-height, 1.5);flex:0 1 auto;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}[part~=wy-card-action]{flex:0 0 auto;white-space:nowrap}`, sC = j`[part~=wy-badge]{display:inline-block;text-align:center;vertical-align:middle;align-self:center;font-weight:var(--wy-font-weight-bold, 600);font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));line-height:1.333333;color:var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));background-color:var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));padding:.333333em;min-width:1lh}[part~=wy-badge]:empty{display:none!important}[part~=wy-badge-positioned]{margin:calc(-.5*(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + .333333em*2));position:absolute}[part~=wy-badge-positioned]:not(:empty){display:block}[part~=wy-badge-top-right]{top:0;right:0}[part~=wy-badge-bottom-right]{bottom:0;right:0}[part~=wy-badge-bottom-left]{bottom:0;left:0}[part~=wy-badge-top-left]{top:0;left:0}[part~=wy-badge-compact]{padding:.25em;max-width:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))*3 + .25em);height:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + .25em);line-height:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + .25em)}[part~=wy-badge-compact]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-badge-compact][part~=wy-badge-positioned]{margin:calc(-.5*(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + .25em*2))}[part~=wy-badge-dot]{content-visibility:hidden;line-height:0;min-width:0;height:0;width:0;padding:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-badge-dot][part~=wy-badge-positioned]{margin:calc(-1*var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-badge-reveal]{opacity:1;transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-badge-reveal]{opacity:0}}`;
var oC = Object.defineProperty, cC = Object.getOwnPropertyDescriptor, il = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? cC(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && oC(t, e, r), r;
}, "__decorateClass$v"), Uo;
let lr = (Uo = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.appearance = "count", this.position = "inline", this.reveal = !1, this.count = NaN, this.limit = 99;
  }
  render() {
    const t = Number.isInteger(this.count) ? this.count > this.limit ? `${this.limit}+` : this.count : "", e = /^(top|bottom)-(right|left)$/.test(this.position), i = {
      "wy-badge": !0,
      "wy-badge-reveal": this.reveal,
      "wy-badge-compact": this.appearance === "compact",
      "wy-badge-dot": this.appearance === "dot",
      "wy-badge-positioned": e,
      [`wy-badge-${this.position}`]: e
    };
    return this.appearance !== "none" && t ? h`<span part=${J(i)} title=${this.count}>${t}</span>` : b;
  }
}, a(Uo, "WyBadge"), Uo);
lr.styles = [sC, X];
il([
  u({ type: String })
], lr.prototype, "appearance", 2);
il([
  u({ type: String })
], lr.prototype, "position", 2);
il([
  u({ type: Boolean })
], lr.prototype, "reveal", 2);
il([
  u({ type: Number })
], lr.prototype, "count", 2);
il([
  u({ type: Number })
], lr.prototype, "limit", 2);
lr = il([
  B("wy-badge")
], lr);
var lC = Object.defineProperty, dC = Object.getOwnPropertyDescriptor, Nh = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? dC(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && lC(t, e, r), r;
}, "__decorateClass$u"), qo;
let Bn = (qo = class extends Te {
  constructor() {
    super(), this.exportParts = new q(this), this.isRenamingId = NaN, this.highlightId = NaN, this.highlightRef = nt(), this.addEventListener("edit-name", (t) => {
      this.isRenamingId = t.detail.file.id;
    }), this.addEventListener("rename", () => {
      this.isRenamingId = NaN;
    });
  }
  /**
   * Emit a `file-open` event requesting preview for the given file.
   *
   * @param fileId - Identifier of the file to open.
   * @param tab - Optional preview tab to activate.
   * @returns Whether the event was not canceled.
   */
  dispatchFileOpen(t, e) {
    const i = new CustomEvent("file-open", { detail: { fileId: t, tab: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit an `order` event with the selected sort order.
   *
   * @param order - Order to apply.
   * @returns Whether the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit an `edit-name` event to enter rename mode for the given file.
   *
   * @param file - File that should be renamed.
   * @returns Whether the event was not canceled.
   */
  dispatchEditName(t) {
    const e = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `rename` event containing the updated file name.
   *
   * @param file - File being renamed.
   * @param name - New filename.
   * @returns Whether the event was not canceled.
   */
  dispatchRename(t, e) {
    const i = new CustomEvent("rename", { detail: { file: t, name: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit a `trash` event to move the file to the recycle bin.
   *
   * @param file - File to trash.
   * @returns Whether the event was not canceled.
   */
  dispatchTrash(t) {
    const e = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `restore` event to recover a trashed file.
   *
   * @param file - File to restore.
   * @returns Whether the event was not canceled.
   */
  dispatchRestore(t) {
    const e = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `delete-forever` event to permanently remove a file.
   *
   * @param file - File to delete.
   * @returns Whether the event was not canceled.
   */
  dispatchDeleteForever(t) {
    const e = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling file subscription.
   *
   * @param file - File to subscribe or unsubscribe.
   * @param subscribe - Desired subscription state.
   * @returns Whether the event was not canceled.
   */
  dispatchSubscribe(t, e) {
    const i = new CustomEvent("subscribe", { detail: { file: t, subscribe: e } });
    return this.dispatchEvent(i);
  }
  render() {
    return this.files && this.files.length ? h`
        <div part="wy-grid">
          ${je(
      this.files,
      (t) => t.id,
      (t) => {
        const e = t.size && t.size > 0 ? Ch(t.size) : b, i = t.updated_at || t.created_at, r = new Intl.DateTimeFormat(this.weavy?.locale, {
          dateStyle: "full",
          timeStyle: "short"
        }).format(new Date(i)), s = !!(this.isRenamingId && this.isRenamingId === t.id), { icon: o } = Xr(t.name), c = di(t.name), l = ud(t.provider), p = /* @__PURE__ */ a((g) => {
          g.stopImmediatePropagation();
          const m = g.target;
          m.value && m.value !== t.name ? this.dispatchRename(t, m.value) : this.dispatchEditName({ id: NaN });
        }, "handleRename"), v = /* @__PURE__ */ a((g) => {
          const m = g.target;
          g.key === "Escape" ? (g.preventDefault(), m.value = t.name, m.blur()) : g.key === "Enter" && (g.preventDefault(), m.blur());
        }, "handleRenameKey"), C = !!(this.highlightId && this.highlightId === t.id);
        return h`
                <div
                  part=${J({
          "wy-card": !0,
          "wy-trashed": t.is_trashed,
          "wy-card-hover": !t.is_trashed && !s,
          "wy-highlight": C
        })}
                  title="${t.name} • ${e} • ${r}"
                  tabindex="0"
                  @click=${(g) => {
          vh(g) && (g.stopPropagation(), g.preventDefault(), tr(t.download_url ?? t.external_url, "_blank")), !g.defaultPrevented && !t.is_trashed && this.dispatchFileOpen(t.id);
        }}
                  @keydown=${ve}
                  @keyup=${Ie}
                  ${C && this.highlightRef ? Q(this.highlightRef) : b}
                >
                  <div part="wy-card-actions">
                    <wy-file-menu
                      small
                      .file=${t}
                      @edit-name=${(g) => this.dispatchEditName(g.detail.file)}
                      @trash=${(g) => this.dispatchTrash(g.detail.file)}
                      @restore=${(g) => this.dispatchRestore(g.detail.file)}
                      @delete-forever=${(g) => this.dispatchDeleteForever(g.detail.file)}
                      @subscribe=${(g) => this.dispatchSubscribe(g.detail.file, g.detail.subscribe)}
                    ></wy-file-menu>
                  </div>
                  ${!t.is_trashed && t.thumbnail_url ? h`
                        <img
                          part="wy-card-image ${J({ "wy-card-image-top": t.kind !== "image" })}"
                          width=${dt(t.width)}
                          height=${dt(t.height)}
                          src=${t.thumbnail_url}
                          alt=${t.name}
                          ${Q(Ry)}
                          @load=${Ty}
                          loading="lazy"
                          decoding="async"
                        />
                      ` : h`
                        <div part="wy-card-icon ">
                          <wy-icon
                            name=${o}
                            .overlayName=${l}
                            size="96"
                            kind=${t.kind}
                            ext=${c}
                          ></wy-icon>
                        </div>
                      `}
                  ${s ? h`
                        <input
                          type="text"
                          name="filename"
                          maxlength="256"
                          part="wy-input"
                          .defaultValue=${t.name}
                          @blur=${p}
                          @keyup=${(g) => {
          Br(g), v(g);
        }}
                          @click=${(g) => g.preventDefault()}
                          @focus=${uy}
                          ${Q(Jp)}
                        />
                      ` : h`<div part="wy-card-title">
                        <div part="wy-card-text">${t.name}</div> ${t.comments?.count ? h`<wy-button
                              part="wy-card-button-icon"
                              small
                              color="none"
                              kind="inline"
                              @click=${(g) => {
          !g.defaultPrevented && !t.is_trashed && (g.target.blur(), this.dispatchFileOpen(t.id, "comments"), g.stopPropagation());
        }}
                              title=${x(gt`${t.comments.count} comments`)}
                            >
                              <wy-badge count=${t.comments.count}></wy-badge>
                            </wy-button>` : b}
                      </div>`}
                </div>
              `;
      }
    )}
        </div>
      ` : b;
  }
  updated(t) {
    t.has("highlightId") && this.highlightId && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, a(qo, "WyFileGrid"), qo);
Bn.styles = [rn, nC, aC, X];
Nh([
  u({ attribute: !1 })
], Bn.prototype, "files", 2);
Nh([
  D()
], Bn.prototype, "isRenamingId", 2);
Nh([
  D()
], Bn.prototype, "highlightId", 2);
Bn = Nh([
  Im("wy-file-grid"),
  ht()
], Bn);
const hC = j`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-table]{table-layout:fixed;width:100%;vertical-align:top;border-collapse:collapse}[part~=wy-table] tr[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-table] th{font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600))}[part~=wy-table] th,[part~=wy-table] td{background-color:var(--wy-component-background-color);padding:var(--wy-table-cell-padding-y, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))) var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));box-shadow:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf)) 0 -1px 0 0 inset;line-height:1;vertical-align:middle;height:calc(calc(2 * var(--wy-size, 1rem)) + var(--wy-table-cell-padding-y, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*2)}[part~=wy-table]>tbody{vertical-align:inherit}[part~=wy-table]>thead{vertical-align:bottom}[part~=wy-table][part~=wy-table-interactive]>tbody>tr:hover>*{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));color:var(--wy-component-color);cursor:pointer}[part~=wy-col-icon]{vertical-align:middle;text-align:center;padding:calc(var(--wy-table-cell-padding-y, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*.5) calc(var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*.5);width:calc(calc(2 * var(--wy-size, 1rem)) + var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*2);font-size:var(--wy-font-size, var(--wy-size, 1em));font-weight:var(--wy-font-weight, unset);text-transform:none;letter-spacing:normal}[part~=wy-col-icon-content]{display:flex;justify-content:center;align-items:center}[part~=wy-trashed]{text-decoration:line-through}[part~=wy-sort-link]{display:inline-flex;align-items:center;color:var(--wy-primary, var(--wy-primary-light, #2f628c));cursor:pointer}`, uC = j`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}table thead{text-align:left;display:none}@container (inline-size >= 576px){table thead{display:table-header-group}}[part~=wy-col-name]{width:100%}[part~=wy-col-name]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-col-name] [part~=wy-input]{width:100%;box-sizing:border-box}[part~=wy-col-time]{width:calc(8*var(--wy-size, 1rem));display:none}@container (inline-size >= 768px){[part~=wy-col-time]{display:table-cell}}[part~=wy-col-time]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-col-kind]{width:calc(8*var(--wy-size, 1rem));display:none}@container (inline-size >= 768px){[part~=wy-col-kind]{display:table-cell}}[part~=wy-col-kind]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-col-size]{width:calc(6*var(--wy-size, 1rem));text-align:right;display:none}@container (inline-size >= 576px){[part~=wy-col-size]{display:table-cell}}[part~=wy-col-size]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}`;
var pC = Object.defineProperty, yC = Object.getOwnPropertyDescriptor, Cd = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? yC(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && pC(t, e, r), r;
}, "__decorateClass$t"), jo;
let Kr = (jo = class extends Te {
  constructor() {
    super(), this.exportParts = new q(this), this.order = { by: "name", descending: !1 }, this.isRenamingId = NaN, this.highlightId = NaN, this.highlightRef = nt(), this.addEventListener("edit-name", (t) => {
      this.isRenamingId = t.detail.file.id;
    }), this.addEventListener("rename", () => {
      this.isRenamingId = NaN;
    });
  }
  /**
   * Emit a `file-open` event requesting preview for the supplied file.
   *
   * @param fileId - Identifier of the file to open.
   * @param tab - Optional preview tab to activate.
   * @returns Whether the event was not canceled.
   */
  dispatchFileOpen(t, e) {
    const i = new CustomEvent("file-open", { detail: { fileId: t, tab: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit an `order` event with the provided sort order.
   *
   * @param order - Order to apply.
   * @returns Whether the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit an `edit-name` event to enter rename mode for the specified file.
   *
   * @param file - File that should be renamed.
   * @returns Whether the event was not canceled.
   */
  dispatchEditName(t) {
    const e = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `rename` event carrying the updated filename.
   *
   * @param file - File being renamed.
   * @param name - New filename value.
   * @returns Whether the event was not canceled.
   */
  dispatchRename(t, e) {
    const i = new CustomEvent("rename", { detail: { file: t, name: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit a `trash` event to move the file to the recycle bin.
   *
   * @param file - File to trash.
   * @returns Whether the event was not canceled.
   */
  dispatchTrash(t) {
    const e = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `restore` event to recover a trashed file.
   *
   * @param file - File to restore.
   * @returns Whether the event was not canceled.
   */
  dispatchRestore(t) {
    const e = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `delete-forever` event to permanently remove the file.
   *
   * @param file - File targeted for permanent deletion.
   * @returns Whether the event was not canceled.
   */
  dispatchDeleteForever(t) {
    const e = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling subscription state for the file.
   *
   * @param file - File whose subscription changes.
   * @param subscribe - Desired subscription state.
   * @returns Whether the event was not canceled.
   */
  dispatchSubscribe(t, e) {
    const i = new CustomEvent("subscribe", { detail: { file: t, subscribe: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Render the complete file table layout.
   *
   * @param files - Files to render.
   * @param order - Current table order.
   * @param isRenamingId - File id in rename mode.
   * @param highlightId - File id to highlight.
   * @param highlightRef - Reference for scrolling highlighted rows.
   */
  renderFileTable(t, e, i, r, s) {
    return t && t.length ? h`
          <table part="wy-table wy-table-interactive">
            <thead>${this.renderFileTableHeaders.call(this, e)}</thead>
            <tbody>
              ${je(
      t,
      (o) => o.id,
      (o) => this.renderFileTableRow.call(this, this.weavy, { file: o }, i, r, s)
    )}
            </tbody>
          </table>
        ` : b;
  }
  /**
   * Render table header cells with sorting affordances.
   *
   * @param order - Current sort order.
   */
  renderFileTableHeaders(t) {
    const e = [
      { col: "icon", by: void 0, title: "" },
      // File icon
      { col: "name", by: "name", title: x("Name") },
      { col: "icon", by: void 0, title: "" },
      // Comments icon
      { col: "time", by: "updated_at", title: x("Modified") },
      { col: "kind", by: void 0, title: x("Kind") },
      { col: "size", by: "size", title: x("Size") },
      { col: "icon", by: void 0, title: "" }
      // Menu
    ];
    return h`
      <tr>
        ${e.map((i) => {
      if (i.title) {
        const r = i.by === t?.by, s = /* @__PURE__ */ a((o) => {
          o.preventDefault(), i.by && this.dispatchOrder({ by: i.by, descending: r && !t?.descending });
        }, "onHeaderClick");
        return h` <th part="wy-th ${`wy-col-${i.col}`}">
              ${i.by ? h`<div
                    part="wy-sort-link"
                    tabindex="0"
                    @click=${s}
                    @keydown=${ve}
                    @keyup=${Ie}
                    >${i.title}
                    ${r && h`<wy-icon name=${t?.descending ? "menu-down" : "menu-up"}></wy-icon>` || b}</div
                  >` : i.title}
            </th>`;
      } else
        return h`<th part="wy-th wy-col-icon"></th>`;
    })}
      </tr>
    `;
  }
  /**
   * Render a single file table row.
   *
   * @param weavy - Current Weavy context.
   * @param row - Row data containing the file.
   * @param isRenamingId - File id in rename mode.
   * @param highlightId - File id to highlight.
   * @param highlightRef - Reference for scrolling highlighted rows.
   */
  renderFileTableRow(t, { file: e }, i, r, s) {
    const o = e.size && e.size > 0 ? Ch(e.size) : b, c = e.updated_at || e.created_at, l = new Intl.DateTimeFormat(t?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(c)
    ), p = new Intl.DateTimeFormat(t?.locale, { dateStyle: "short" }).format(
      new Date(c)
    ), v = !!(i && i === e.id), { icon: C } = Xr(e.name), g = di(e.name), m = ud(e.provider), f = /* @__PURE__ */ a((M) => {
      M.stopImmediatePropagation();
      const R = M.target;
      R.value && R.value !== e.name ? this.dispatchRename(e, R.value) : this.dispatchEditName({ id: NaN });
    }, "handleRename"), $ = /* @__PURE__ */ a((M) => {
      const R = M.target;
      M.key === "Escape" ? (M.preventDefault(), R.value = e.name, R.blur()) : M.key === "Enter" && (M.preventDefault(), R.blur());
    }, "handleRenameKey"), A = !!(r && r === e.id);
    return h`
      <tr
        part=${J({ "wy-tr": !0, "wy-highlight": A, "wy-trashed": e.is_trashed })}
        @click=${(M) => {
      vh(M) && (M.stopPropagation(), M.preventDefault(), tr(e.download_url ?? e.external_url, "_blank")), !M.defaultPrevented && !e.is_trashed && this.dispatchFileOpen(e.id);
    }}
        ${A && s ? Q(s) : b}
      >
        <td part="wy-td wy-col-icon"
          ><wy-icon part="wy-col-icon-content" name=${C} .overlayName=${m} size="24" kind=${e.kind} ext=${g}></wy-icon
        ></td>
        <td part="wy-td wy-col-name">
          ${v ? h`
                <input
                  type="text"
                  name="filename"
                  maxlength="256"
                  part="wy-input"
                  .defaultValue=${e.name}
                  @blur=${f}
                  @keyup=${(M) => {
      Br(M), $(M);
    }}
                  @click=${(M) => M.preventDefault()}
                  @focus=${uy}
                  ${Q(Jp)}
                />
              ` : h`${e.name}`}
        </td>
        <td part="wy-td wy-col-icon"
          >${e.comments?.count ? h`<wy-button
                part="wy-col-icon-content"
                kind="inline"
                @click=${(M) => {
      !M.defaultPrevented && !e.is_trashed && (M.target.blur(), this.dispatchFileOpen(e.id, "comments"), M.stopPropagation());
    }}
                title=${x(gt`${e.comments.count} comments`)}
              >
                <wy-badge count=${e.comments.count}></wy-badge>
              </wy-button>` : b}</td
        >
        <td part="wy-td wy-col-time"
          ><time datetime="${c}" title=${l}>${p}</time></td
        >
        <td part="wy-td wy-col-kind">${e.kind}</td>
        <td part="wy-td wy-col-size">${o}</td>
        <td part="wy-td wy-col-icon">
          <wy-file-menu
            part="wy-col-icon-content"
            .file=${e}
            @edit-name=${(M) => this.dispatchEditName(M.detail.file)}
            @trash=${(M) => this.dispatchTrash(M.detail.file)}
            @restore=${(M) => this.dispatchRestore(M.detail.file)}
            @delete-forever=${(M) => this.dispatchDeleteForever(M.detail.file)}
            @subscribe=${(M) => this.dispatchSubscribe(M.detail.file, M.detail.subscribe)}
          >
          </wy-file-menu>
        </td>
      </tr>
    `;
  }
  render() {
    return this.files && this.files.length ? this.renderFileTable.call(
      this,
      this.files,
      this.order,
      this.isRenamingId,
      this.highlightId,
      this.highlightRef
    ) : b;
  }
  updated(t) {
    t.has("highlightId") && this.highlightId && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, a(jo, "WyFileTable"), jo);
Kr.styles = [rn, hC, uC, X];
Cd([
  u({ attribute: !1 })
], Kr.prototype, "files", 2);
Cd([
  u({ attribute: !1 })
], Kr.prototype, "order", 2);
Cd([
  D()
], Kr.prototype, "isRenamingId", 2);
Cd([
  D()
], Kr.prototype, "highlightId", 2);
Kr = Cd([
  Im("wy-file-table"),
  ht()
], Kr);
var wC = Object.defineProperty, fC = Object.getOwnPropertyDescriptor, Jv = /* @__PURE__ */ a((n) => {
  throw TypeError(n);
}, "__typeError$6"), rl = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? fC(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && wC(t, e, r), r;
}, "__decorateClass$s"), t1 = /* @__PURE__ */ a((n, t, e) => t.has(n) || Jv("Cannot " + e), "__accessCheck$6"), qf = /* @__PURE__ */ a((n, t, e) => (t1(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$6"), mC = /* @__PURE__ */ a((n, t, e) => t.has(n) ? Jv("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$6"), jf = /* @__PURE__ */ a((n, t, e, i) => (t1(n, t, "write to private field"), t.set(n, e), e), "__privateSet$6"), wa, Wo;
let dr = (Wo = class extends Dt {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.order = { by: "name", descending: !1 }, this.view = "list", this.showTrashed = !1, this.highlightId = NaN, this.highlightComment = !1, this.filesQuery = new ir(this), this.previewRef = nt(), this.infiniteScroll = new rr(this), this.pagerRef = nt(), this.handleRealtimeFileCreated = (t) => {
      !this.weavy || !this.app || (t.file.created_by = t.actor, this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) }));
    }, this.handleRealtimeFileUpdated = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileTrashed = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileRestored = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileDeleted = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeCommentCreated = () => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, mC(this, wa);
  }
  /**
   * Resolve the query key used for the app file listing.
   *
   * @internal
   * @param app - App owning the files.
   */
  getFilesQueryKey(t) {
    return ["apps", t.id, "files"];
  }
  /**
   * Emit a `file-open` event requesting preview for the supplied file.
   *
   * @param fileId - Identifier of the file to open.
   * @param tab - Optional preview tab to activate.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchFileOpen(t, e) {
    const i = new CustomEvent("file-open", { detail: { fileId: t, tab: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit an `order` event with the provided sort order.
   *
   * @param order - Order to apply.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("link") && (this.highlightId = this.link && Tv(this.link, Ae.File)?.id, this.highlightComment = this.link && this.highlightId ? Lv(this.link, Ae.File, { id: this.highlightId }, Ae.Comment) : !1), t.has("highlightComment") && this.highlightComment && this.highlightId && this.dispatchFileOpen(this.highlightId, "comments"), (t.has("weavy") || t.has("app") || t.has("order") || t.has("showTrashed")) && this.weavy && this.app && await this.filesQuery.trackInfiniteQuery(
      K3(this.weavy, this.app.id, {
        order: this.order,
        trashed: this.showTrashed
      })
    ), (t.has("weavy") || t.has("app") || t.has("user")) && this.weavy && this.app && this.user) {
      this.renameFileMutation = rC(this.weavy, this.app), this.subscribeFileMutation = eC(this.weavy, this.app), this.trashFileMutation = G3(this.weavy, this.app), this.restoreFileMutation = Y3(this.weavy, this.app), this.deleteForeverFileMutation = J3(this.weavy, this.app), (e = qf(this, wa)) == null || e.call(this);
      const i = `a${this.app.id}`;
      this.weavy.subscribe(i, "file_created", this.handleRealtimeFileCreated), this.weavy.subscribe(i, "file_updated", this.handleRealtimeFileUpdated), this.weavy.subscribe(i, "file_trashed", this.handleRealtimeFileTrashed), this.weavy.subscribe(i, "file_restored", this.handleRealtimeFileRestored), this.weavy.subscribe(i, "file_deleted", this.handleRealtimeFileDeleted), this.weavy.subscribe(i, "comment_created", this.handleRealtimeCommentCreated), jf(this, wa, () => {
        this.weavy?.unsubscribe(i, "file_created", this.handleRealtimeFileCreated), this.weavy?.unsubscribe(i, "file_updated", this.handleRealtimeFileUpdated), this.weavy?.unsubscribe(i, "file_trashed", this.handleRealtimeFileTrashed), this.weavy?.unsubscribe(i, "file_restored", this.handleRealtimeFileRestored), this.weavy?.unsubscribe(i, "file_deleted", this.handleRealtimeFileDeleted), this.weavy?.unsubscribe(i, "comment_created", this.handleRealtimeCommentCreated), jf(this, wa, void 0);
      });
    }
  }
  render() {
    const { data: t, hasNextPage: e, isPending: i } = this.filesQuery.result, r = nr(t);
    return r && r.length ? h`
        ${this.view === "grid" ? h`
              <wy-file-grid
                .files=${r}
                .highlightId=${this.highlightId}
                @file-open=${(s) => {
      this.previewRef.value?.open(s.detail.fileId, s.detail.tab);
    }}
                @order=${(s) => this.dispatchOrder(s.detail.order)}
                @rename=${(s) => {
      this.renameFileMutation?.mutate({ file: s.detail.file, name: s.detail.name });
    }}
                @subscribe=${(s) => {
      this.subscribeFileMutation?.mutate({
        file: s.detail.file,
        subscribe: s.detail.subscribe
      });
    }}
                @trash=${(s) => {
      this.trashFileMutation?.mutate({ file: s.detail.file });
    }}
                @restore=${(s) => {
      this.restoreFileMutation?.mutate({ file: s.detail.file });
    }}
                @delete-forever=${(s) => {
      this.deleteForeverFileMutation?.mutate({ file: s.detail.file });
    }}
              ></wy-file-grid>
            ` : h`
              <wy-file-table
                .files=${r}
                .order=${this.order}
                .highlightId=${this.highlightId}
                @file-open=${(s) => {
      this.previewRef.value?.open(s.detail.fileId, s.detail.tab);
    }}
                @order=${(s) => this.dispatchOrder(s.detail.order)}
                @rename=${(s) => {
      this.renameFileMutation?.mutate({ file: s.detail.file, name: s.detail.name });
    }}
                @subscribe=${(s) => {
      this.subscribeFileMutation?.mutate({
        file: s.detail.file,
        subscribe: s.detail.subscribe
      });
    }}
                @trash=${(s) => {
      this.trashFileMutation?.mutate({ file: s.detail.file });
    }}
                @restore=${(s) => {
      this.restoreFileMutation?.mutate({ file: s.detail.file });
    }}
                @delete-forever=${(s) => {
      this.deleteForeverFileMutation?.mutate({ file: s.detail.file });
    }}
              ></wy-file-table>
            `}
        ${e ? h`<div ${Q(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : b}
        ${t ? h` <wy-preview ${Q(this.previewRef)} .infiniteQueryResult=${this.filesQuery.result}></wy-preview> ` : b}
      ` : h`
        <wy-empty>
          ${i ? h`<wy-progress-circular indeterminate padded reveal></wy-progress-circular>` : h` <wy-icon-display>
                <wy-icon name="file-upload"></wy-icon>
                <span slot="text">${x("Add some files to get started!")}</span>
              </wy-icon-display>`}
        </wy-empty>
      `;
  }
  updated() {
    this.infiniteScroll.observe(this.filesQuery.result, this.pagerRef.value);
  }
  disconnectedCallback() {
    var t;
    (t = qf(this, wa)) == null || t.call(this), super.disconnectedCallback();
  }
}, a(Wo, "WyFilesList"), Wo);
wa = /* @__PURE__ */ new WeakMap();
dr.styles = [Jr];
rl([
  u({ type: Object })
], dr.prototype, "order", 2);
rl([
  u()
], dr.prototype, "view", 2);
rl([
  u({ type: Boolean })
], dr.prototype, "showTrashed", 2);
rl([
  D()
], dr.prototype, "highlightId", 2);
rl([
  D()
], dr.prototype, "highlightComment", 2);
dr = rl([
  B("wy-files-list"),
  ht()
], dr);
var vC = Object.defineProperty, gC = Object.getOwnPropertyDescriptor, Uh = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? gC(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && vC(t, e, r), r;
}, "__decorateClass$r"), Ko;
let Nn = (Ko = class extends Re {
  constructor() {
    super(), this.appType = st.Files, this.componentFeatures = new le({
      // All available features as enabled/disabled by default
      [S.Attachments]: !0,
      [S.CloudFiles]: !0,
      [S.Comments]: !0,
      [S.ContextData]: !0,
      [S.Embeds]: !0,
      [S.GoogleMeet]: !1,
      [S.Meetings]: !1,
      [S.Mentions]: !0,
      [S.MicrosoftTeams]: !1,
      [S.Polls]: !0,
      [S.Previews]: !0,
      [S.Reactions]: !0,
      [S.Typing]: !1,
      // Has no effect currently
      [S.Versions]: !0,
      [S.WebDAV]: !0,
      [S.ZoomMeetings]: !1
    }), this.theme = new _e(this, Nn.styles), this.view = "list", this.order = { by: "name", descending: !1 }, this.showTrashed = !1, this.persistState = new Sn(this), this.dropZone = new th(this), this.uploadBlobMutation = new ti(this), this.createFileMutation = new ti(this), this.addEventListener("drop-files", (t) => this.handleBlobUpload(t));
  }
  /** @internal */
  handleBlobUpload(t) {
    const e = t.detail;
    if (e.files)
      for (let i = 0; i < e.files.length; i++) {
        const s = { file: e.files[i] };
        this.uploadBlobMutation.mutate(s).then((o) => this.handleCreateFile(o));
      }
  }
  /** @internal */
  handleExternalBlobs(t) {
    if (t.detail.externalBlobs)
      for (let e = 0; e < t.detail.externalBlobs.length; e++) {
        const i = t.detail.externalBlobs[e];
        this.externalBlobMutation?.mutate({ externalBlob: i }).then((r) => this.handleCreateFile(r));
      }
  }
  /** @internal */
  async handleCreateFile(t, e) {
    return await this.createFileMutation.mutate({ blob: t, replace: e });
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("uid") || t.has("weavy") || t.has("user")) && this.uid && this.weavy && this.user && this.persistState.observe(
      [
        { name: "view", override: !0 },
        { name: "order", override: !0 },
        { name: "showTrashed", override: !0 }
      ],
      this.uid.toString(),
      `u${this.user.id}`
    ), (t.has("weavy") || t.has("app") || t.has("user")) && this.weavy && this.app && this.user && (await this.uploadBlobMutation.trackMutation(yy(this.weavy, this.user, this.app.id)), await this.createFileMutation.trackMutation(S0(this.weavy, this.user, this.app)), this.externalBlobMutation = Uv(this.weavy, this.user, this.app.id));
  }
  render() {
    const t = this.dropZone.isDragActive;
    return h`
      <div
        part="wy-files ${J({ "wy-dragging": t })}"
        data-drag-title=${x("Drop files here")}
      >
        <wy-files-header
          .order=${this.order}
          .showTrashed=${this.showTrashed}
          .view=${this.view}
          @upload-files=${(e) => this.handleBlobUpload(e)}
          @external-blobs=${(e) => this.handleExternalBlobs(e)}
          @create-files=${(e) => e.detail.blobs.forEach((i) => this.handleCreateFile(i, e.detail.replace))}
          @order=${(e) => {
      this.order = e.detail.order;
    }}
          @show-trashed=${(e) => {
      this.showTrashed = e.detail.showTrashed;
    }}
          @view=${(e) => {
      this.view = e.detail.view;
    }}
          @subscribe=${(e) => this.subscribe(e.detail.subscribe)}
        >
          <slot name="actions" slot="actions"></slot>
        </wy-files-header>

        <wy-files-list
          .view=${this.view}
          .order=${this.order}
          .showTrashed=${this.showTrashed}
          @order=${(e) => {
      this.order = e.detail.order;
    }}
        ></wy-files-list>
      </div>
    `;
  }
}, a(Ko, "WyFiles"), Ko);
Nn.styles = [
  jv,
  se,
  wr,
  Gn,
  Fe,
  Zn
];
Uh([
  u()
], Nn.prototype, "view", 2);
Uh([
  u({ type: Object })
], Nn.prototype, "order", 2);
Uh([
  u({ type: Boolean })
], Nn.prototype, "showTrashed", 2);
Nn = Uh([
  B("wy-files"),
  ht()
], Nn);
function bC(n, t) {
  const e = n.queryClient, r = {
    mutationKey: ["posts", t.id],
    mutationFn: /* @__PURE__ */ a(async ({ id: s }) => {
      if (!(await n.fetch("/api/posts/" + s + "/trash", { method: "POST" })).ok)
        throw new Error();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((s) => {
      yt(
        e,
        { queryKey: r.mutationKey, exact: !1 },
        s.id,
        (o) => Object.assign(o, { is_trashed: !0 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((s, o) => {
      yt(
        e,
        { queryKey: r.mutationKey, exact: !1 },
        o.id,
        (c) => Object.assign(c, s)
      );
    }, "onSuccess")
  };
  return r;
}
a(bC, "getTrashPostMutationOptions");
function xC(n, t) {
  return new Mt(n.queryClient, bC(n, t));
}
a(xC, "getTrashPostMutation");
function CC(n, t) {
  const e = n.queryClient, r = {
    mutationKey: ["posts", t.id],
    mutationFn: /* @__PURE__ */ a(async ({ id: s }) => {
      const o = await n.fetch("/api/posts/" + s + "/restore", { method: "POST" });
      if (!o.ok) {
        const c = await o.json();
        throw new Error(c.detail || c.title, { cause: c });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((s) => {
      yt(
        e,
        { queryKey: r.mutationKey, exact: !1 },
        s.id,
        (o) => Object.assign(o, { is_trashed: !1 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((s, o) => {
      yt(
        e,
        { queryKey: r.mutationKey, exact: !1 },
        o.id,
        (c) => Object.assign(c, { is_trashed: !1 })
      );
    }, "onSuccess")
  };
  return r;
}
a(CC, "getRestorePostMutationOptions");
function $C(n, t) {
  return new Mt(n.queryClient, CC(n, t));
}
a($C, "getRestorePostMutation");
function kC(n, t) {
  const e = n.queryClient, i = ["posts", t.id];
  return {
    mutationKey: i,
    mutationFn: /* @__PURE__ */ a(async ({ id: s, subscribe: o }) => {
      const c = await n.fetch(
        `/api/posts/${s}/${o ? "subscribe" : "unsubscribe"}`,
        { method: "POST" }
      );
      if (!c.ok) {
        const l = await c.json();
        throw new Error(l.detail || l.title, { cause: l });
      }
      return await c.json();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((s) => {
      yt(
        e,
        { queryKey: i, exact: !1 },
        s.id,
        (o) => Object.assign(o, { is_subscribed: s.subscribe })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((s, o) => {
      yt(
        e,
        { queryKey: i, exact: !1 },
        o.id,
        (c) => Object.assign(c, s)
      );
    }, "onSuccess")
  };
}
a(kC, "getSubscribePostMutationOptions");
function PC(n, t) {
  return new Mt(n.queryClient, kC(n, t));
}
a(PC, "getSubscribePostMutation");
function _C(n, t) {
  return {
    initialPageParam: 0,
    queryKey: ["posts", t],
    queryFn: /* @__PURE__ */ a(async (e) => {
      const i = e.pageParam, r = "/api/apps/" + t + "/posts?order_by=id+desc&skip=" + i, o = await (await n.fetch(r)).json();
      return o.data = o.data || [], o;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ a((e) => {
      if (e.end && e.end < e.count)
        return e.end;
    }, "getNextPageParam")
  };
}
a(_C, "getPostsOptions");
function SC(n, t) {
  return {
    mutationFn: /* @__PURE__ */ a(async (i) => await (await n.fetch("/api/posts/" + i.id, {
      method: "PATCH",
      body: JSON.stringify({
        text: i.text,
        blobs: i.blobs,
        attachments: i.attachments,
        meeting_id: i.meeting_id,
        options: i.poll_options.filter((s) => s.text.trim() !== "").map((s) => ({ id: s.id, text: s.text })),
        embed_id: i.embed_id || null
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ a((i) => {
      Zt(n.queryClient, ["posts", i.app_id], i.id, (r) => {
        r.text = i.text, r.html = i.text;
      });
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((i, r) => {
      r.id && Zt(n.queryClient, ["posts", r.app_id], r.id, (s) => {
        s.text = i.text, s.html = i.html, s.attachments = i.attachments, s.embed = i.embed, s.meeting = i.meeting, s.updated_at = i.updated_at, s.updated_by = i.updated_by, s.options = i.options;
      });
    }, "onSuccess")
  };
}
a(SC, "getUpdatePostMutationOptions");
function MC(n, t) {
  const e = n.queryClient;
  return {
    mutationFn: /* @__PURE__ */ a(async (r) => await (await n.fetch("/api/apps/" + r.app_id + "/posts", {
      method: "POST",
      body: JSON.stringify({
        text: r.text,
        blobs: r.blobs,
        meeting_id: r.meeting_id,
        options: r.poll_options.filter((o) => o.text.trim() !== "").map((o) => ({ text: o.text })),
        embed_id: r.embed_id,
        context: r.context
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ a(async (r) => {
      const s = ["posts", r.app_id];
      await e.cancelQueries({ queryKey: s });
      const o = Mn(n.queryClient, s, !1);
      if (r.user) {
        const c = {
          id: o ? o.id - 1 : -1,
          app: { id: r.app_id },
          is_subscribed: !0,
          is_trashed: !1,
          text: r.text,
          html: r.text,
          plain: r.text,
          created_by: r.user,
          created_at: (/* @__PURE__ */ new Date()).toUTCString(),
          attachments: { count: 0 },
          reactions: { count: 0 },
          is_starred: !1,
          comments: { count: 0 }
        };
        Vr(e, ["posts", r.app_id], c, { descending: !0 });
      }
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((r) => {
      const s = ["posts", r.app.id];
      if (!Ph(n.queryClient, s, r.id)) {
        const c = Mn(n.queryClient, s, !0);
        c ? Zt(n.queryClient, s, c.id, (l) => {
          l.id = r.id, l.app = r.app, l.text = r.text, l.html = r.html, l.embed = r.embed, l.meeting = r.meeting, l.attachments = r.attachments, l.options = r.options, l.created_at = r.created_at, l.created_by = r.created_by, l.updated_at = r.updated_at, l.updated_by = r.updated_by;
        }) : Vr(n.queryClient, s, r);
      }
    }, "onSuccess")
  };
}
a(MC, "getAddPostMutationOptions");
const qh = j`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-posts]{display:flex;flex-direction:column;gap:var(--wy-gap-xl, calc(2 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-posts-header]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));color:var(--wy-component-color);display:flex;flex-direction:column;position:relative;--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-post]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-background, var(--wy-background-light, #f7f9ff));color:var(--wy-component-color);display:flex;flex-direction:column;position:relative;clip-path:border-box;--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-component-border-radius)}[part~=wy-post][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-post-images]{display:flex;flex-direction:column;margin-top:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-post-header]{display:flex;flex-direction:column;padding:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) 0;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-post-body]{display:flex;flex-direction:column;padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) 0;gap:var(--wy-gap-xl, calc(2 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-post-footer]{display:flex;align-items:center;justify-content:space-between;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-content]{padding:0 var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-comments]{background-color:var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));interpolate-size:allow-keywords;padding:0 var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));height:0;visibility:hidden;transition:height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),padding var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));overflow:hidden}[part~=wy-post-comments][part~=wy-show]{height:auto;visibility:visible;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-post-trashed]{padding-bottom:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}::part(wy-trashed){text-decoration:line-through;color:var(--wy-outline, var(--wy-outline-light, #72777f))}`;
var AC = Object.defineProperty, EC = Object.getOwnPropertyDescriptor, By = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? EC(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && AC(t, e, r), r;
}, "__decorateClass$q"), Qo;
let Hc = (Qo = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this);
  }
  /**
   * Emit a `restore` event requesting restoration of the trashed post.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  render() {
    return h`
      <div part="wy-post wy-post-trashed">
        <wy-item part="wy-post-header" size="md" noPadding>
          <wy-avatar
            slot="image"
            .src="${this.createdBy.avatar_url}"
            .isAgent=${this.createdBy.is_agent}
            .size=${48}
            .name=${this.createdBy.name}
          ></wy-avatar>
          <span part="wy-trashed" slot="title">${x("Post was trashed.")}</span>
          <wy-button small slot="actions" @click=${() => this.dispatchRestore()} color="variant"
            >${x("Undo")}</wy-button
          >
        </wy-item>
      </div>
    `;
  }
}, a(Qo, "WyPostTrashed"), Qo);
Hc.styles = [qh, X];
By([
  u({ type: Number })
], Hc.prototype, "postId", 2);
By([
  u({ attribute: !1 })
], Hc.prototype, "createdBy", 2);
Hc = By([
  B("wy-post-trashed"),
  ht()
], Hc);
var RC = Object.defineProperty, TC = Object.getOwnPropertyDescriptor, ee = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? TC(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && RC(t, e, r), r;
}, "__decorateClass$p"), Go;
let It = (Go = class extends Dt {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.html = "", this.text = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.commentCount = 0, this.seenBy = [], this.highlight = !1, this.showComments = !1, this.loadComments = !1, this.isCommentLinked = !1, this.previewAnnotationsRef = nt(), this.previewAttachmentsRef = nt(), this.highlightRef = nt();
  }
  /**
   * Emit a `vote` event for the specified poll option.
   *
   * @internal
   * @param optionId - Identifier of the selected poll option.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling post subscription state.
   *
   * @internal
   * @param subscribe - Desired subscription state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", {
      detail: { id: this.postId, subscribe: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `trash` event requesting the post to move into trash.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  /**
   * Emit an `edit` event toggling edit mode for this post.
   *
   * @internal
   * @param edit - Desired edit state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchEdit(t) {
    const e = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Toggle comment visibility and ensure comment data is loaded.
   *
   * @internal
   * @param e - Click event originating from the comment button.
   */
  handleCommentsClick(t) {
    t.preventDefault(), this.showComments = !this.showComments, this.loadComments = !0;
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("link") && (this.highlight = !!(this.link && zh(this.link, Ae.Post, { id: this.postId })), this.isCommentLinked = !!(this.link && Lv(this.link, Ae.Post, { id: this.postId }, Ae.Comment))), t.has("isCommentLinked") && this.isCommentLinked && (this.loadComments = !0, this.showComments = !0);
  }
  render() {
    const t = this.attachments?.filter((f) => f.kind === "image" && f.thumbnail_url), e = this.attachments?.filter((f) => f.kind !== "image" || !f.thumbnail_url), i = new Intl.DateTimeFormat(this.weavy?.locale, {
      dateStyle: "full",
      timeStyle: "short"
    }).format(new Date(this.createdAt)), r = tl(this.weavy?.locale, new Date(this.createdAt)), s = this.modifiedAt && this.weavy ? new Intl.DateTimeFormat(this.weavy.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.modifiedAt)
    ) : "", o = !!(t && t.length), c = !!this.html, l = !!(this.annotations && this.annotations.length), p = !!(this.pollOptions && this.pollOptions.length), v = !!(this.componentFeatures?.allowsFeature(S.Embeds) && this.embed), C = e && !!e.length, g = !!this.meeting, m = c || l || p || v || C || g;
    return this.postId < 0 ? h`
          <div part="wy-post">
            <wy-item part="wy-post-header" align="top" size="md" noPadding>
              <wy-avatar
                slot="image"
                .src="${this.createdBy.avatar_url}"
                .isAgent=${this.createdBy.is_agent}
                .size=${48}
                .name=${this.createdBy.name}
              ></wy-avatar>
              <span slot="title" part="wy-placeholder">${this.createdBy.name}</span>
              <time slot="text" part="wy-placeholder">${r}</time>
            </wy-item>
            <div part="wy-post-body">
              <div part="wy-content wy-post-content"><wy-skeleton .text=${this.text}></wy-skeleton></div>
            </div>
            <div part="wy-post-footer"></div>
          </div>
        ` : h`
          <div
            part=${J({ "wy-post": !0, "wy-highlight": this.highlight && !this.isCommentLinked })}
            ${Q(this.highlightRef)}
          >
            <wy-item part="wy-post-header" align="top" size="md" noPadding>
              <wy-avatar
                slot="image"
                .src="${this.createdBy.avatar_url}"
                .isAgent=${this.createdBy.is_agent}
                .size=${48}
                .name=${this.createdBy.name}
              ></wy-avatar>
              <span slot="title">${this.createdBy.name}</span>
              <span slot="text">
                <time datetime=${this.createdAt} title=${i}>${r}</time>
                ${this.modifiedAt ? h`<time datetime="${this.modifiedAt}" title=${s}> · ${x("edited")}</time>` : b}
              </span>
              <wy-dropdown slot="actions">
                ${this.isSubscribed ? h`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                        <wy-icon name="bell-off"></wy-icon>
                        ${x("Unsubscribe")}
                      </wy-dropdown-item>` : h`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                        <wy-icon name="bell"></wy-icon>
                        ${x("Subscribe")}
                      </wy-dropdown-item>`}
                ${this.user && this.user.id === this.createdBy.id ? h`<wy-dropdown-item @click=${() => this.dispatchEdit(!0)}>
                        <wy-icon name="pencil"></wy-icon>
                        ${x("Edit")}
                      </wy-dropdown-item>` : b}
                ${this.user && this.user.id === this.createdBy.id ? h`<wy-dropdown-item @click=${() => this.dispatchTrash()}>
                        <wy-icon name="trashcan"></wy-icon>
                        ${x("Trash")}
                      </wy-dropdown-item>` : b}
              </wy-dropdown>
            </wy-item>

            <!-- image grid -->
            ${o ? h`<wy-image-grid
                    part="wy-post-images"
                    outer
                    .images=${t}
                    @file-open=${(f) => {
      this.previewAttachmentsRef.value?.open(f.detail.fileId);
    }}
                  ></wy-image-grid>` : ""}

            ${m ? h`
                    <div part="wy-post-body">
                      <!-- text content -->
                      ${c ? h`<div part="wy-content wy-post-content">${An(this.html)}</div>` : ""}

                      <!-- annotations -->
                      ${l ? h`<wy-annotation-list
                            .files=${this.annotations}
                            @file-open=${(f) => {
      this.previewAnnotationsRef.value?.open(f.detail.fileId);
    }}
                          ></wy-annotation-list>` : b}

                      <!-- poll -->
                      ${p && this.pollOptions ? h`
                            <wy-poll
                              .pollOptions=${this.pollOptions}
                              @vote=${(f) => this.dispatchVote(f.detail.optionId)}
                            ></wy-poll>
                          ` : b}

                      <!-- embeds -->
                      ${v && this.embed ? h` <wy-embed .embed=${this.embed}></wy-embed> ` : b}

                      <!-- files -->
                      ${C ? h`<wy-attachment-list
                            filled
                            part="wy-post-attachments"
                            .files=${e ?? []}
                            @file-open=${(f) => {
      this.previewAttachmentsRef.value?.open(f.detail.fileId);
    }}
                          ></wy-attachment-list>` : b}
                      <!-- meeting -->
                      ${g && this.meeting ? h`<wy-meeting-card .meeting=${this.meeting}></wy-meeting-card>` : b}
                    </div>
                  ` : b}
          <div part="wy-post-footer">

            <!-- comment count -->
            ${this.componentFeatures?.allowsFeature(S.Comments) ? h` <wy-button
                    small
                    kind="inline"
                    ?active=${this.showComments}
                    part="wy-meta"
                    color="inherit"
                    @click=${(f) => this.handleCommentsClick(f)}
                  >
                    ${this.commentCount !== 1 ? x(gt`${this.commentCount} comments`) : x("1 comment")}
                  </wy-button>` : b}

            <!-- reactions -->
            ${this.componentFeatures?.allowsFeature(S.Reactions) && this.app ? h`
                    <wy-reactions
                      line
                      small
                      .reactions=${this.reactions}
                      parentId=${this.app.id}
                      parentType="apps"
                      entityId=${this.postId}
                      entityType="posts"
                    ></wy-reactions>
                  ` : b}

          </div>

          <!-- comments -->
          <div part="wy-post-comments ${J({ "wy-show": this.showComments })}">
            ${this.loadComments ? h`
                    <wy-comment-list
                      reveal
                      part="wy-post-comment-list"
                      .parentId=${this.postId}
                      .location=${"posts"}
                    ></wy-comment-list>
                  ` : b}
          </div>
        </div>

            ${this.annotations?.length ? h`<wy-preview
                    ${Q(this.previewAnnotationsRef)}
                    .files=${this.annotations}
                    .isAttachment=${!0}
                  ></wy-preview> ` : b}
            ${this.attachments?.length ? h`<wy-preview
                    ${Q(this.previewAttachmentsRef)}
                    .files=${[...t, ...e]}
                    .isAttachment=${!0}
                  ></wy-preview> ` : b}
          </div>
        `;
  }
  updated(t) {
    t.has("highlight") && this.highlight && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, a(Go, "WyPostView"), Go);
It.styles = [qh, Nv, Ey, Mv, _h, Gc, X];
ee([
  u({ type: Number })
], It.prototype, "postId", 2);
ee([
  u({ attribute: !1 })
], It.prototype, "createdBy", 2);
ee([
  u()
], It.prototype, "createdAt", 2);
ee([
  u()
], It.prototype, "modifiedAt", 2);
ee([
  u({ type: Boolean })
], It.prototype, "isSubscribed", 2);
ee([
  u({ type: Boolean })
], It.prototype, "isTrashed", 2);
ee([
  u()
], It.prototype, "html", 2);
ee([
  u()
], It.prototype, "text", 2);
ee([
  u({ type: Array })
], It.prototype, "annotations", 2);
ee([
  u({ type: Array })
], It.prototype, "attachments", 2);
ee([
  u({ type: Array })
], It.prototype, "pollOptions", 2);
ee([
  u({ attribute: !1 })
], It.prototype, "meeting", 2);
ee([
  u({ attribute: !1 })
], It.prototype, "embed", 2);
ee([
  u({ type: Array })
], It.prototype, "reactions", 2);
ee([
  u({ attribute: !1 })
], It.prototype, "commentCount", 2);
ee([
  u({ type: Array })
], It.prototype, "seenBy", 2);
ee([
  u({ type: Boolean })
], It.prototype, "highlight", 2);
ee([
  D()
], It.prototype, "showComments", 2);
ee([
  D()
], It.prototype, "loadComments", 2);
ee([
  D()
], It.prototype, "isCommentLinked", 2);
It = ee([
  B("wy-post-view"),
  ht()
], It);
var LC = Object.defineProperty, OC = Object.getOwnPropertyDescriptor, De = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? OC(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && LC(t, e, r), r;
}, "__decorateClass$o"), Zo;
let ge = (Zo = class extends Dt {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.temp = !1, this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.text = "", this.attachments = [], this.pollOptions = [], this.reactions = [], this.seenBy = [], this.updatePostMutation = new ti(this);
  }
  /**
   * Emit an `edit` event toggling edit mode for the post.
   *
   * @param edit - Desired edit state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchEdit(t) {
    const e = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Handle editor submit events and trigger the post update mutation.
   *
   * @param e - Editor submit detail containing updated content.
   */
  async handleSubmit(t) {
    const e = await this.whenApp();
    this.updatePostMutation.mutate({
      id: this.postId,
      app_id: e.id,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      attachments: t.detail.attachments,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId
    }), this.dispatchEdit(!1);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && await this.updatePostMutation.trackMutation(SC(this.weavy, ["posts", this.app.id]));
  }
  render() {
    const t = tl(this.weavy?.locale, new Date(this.createdAt));
    return h`
      <div part="wy-post">
        <wy-item part="wy-post-header" align="top" size="md" noPadding>
          <wy-avatar
            slot="image"
            .src="${this.createdBy.avatar_url}"
            .isAgent=${this.createdBy.is_agent}
            .size=${48}
            .name=${this.createdBy.name}
          ></wy-avatar>
          <span slot="title" part="wy-placeholder">${this.createdBy.name}</span>
          <time slot="text" part="wy-placeholder">${t}</time>
          <wy-button slot="actions" kind="icon" @click=${() => this.dispatchEdit(!1)}>
            <wy-icon name="close"></wy-icon>
          </wy-button>
        </wy-item>

        <wy-editor
          editorLocation="apps"
          .text=${this.text}
          .embed=${this.embed}
          .options=${this.pollOptions}
          .attachments=${this.attachments ?? []}
          .parentId=${this.postId}
          .typing=${!1}
          .draft=${!1}
          placeholder=${x("Edit post...")}
          buttonText=${x("Update", { desc: "Button action to update" })}
          @submit=${(e) => this.handleSubmit(e)}
        ></wy-editor>
      </div>
    `;
  }
}, a(Zo, "WyPostEdit"), Zo);
ge.styles = [qh, Gc, X];
De([
  u({ type: Number })
], ge.prototype, "postId", 2);
De([
  u({ type: Boolean })
], ge.prototype, "temp", 2);
De([
  u({ attribute: !1 })
], ge.prototype, "createdBy", 2);
De([
  u()
], ge.prototype, "createdAt", 2);
De([
  u()
], ge.prototype, "modifiedAt", 2);
De([
  u({ type: Boolean })
], ge.prototype, "isSubscribed", 2);
De([
  u({ type: Boolean })
], ge.prototype, "isTrashed", 2);
De([
  u()
], ge.prototype, "text", 2);
De([
  u({ type: Array })
], ge.prototype, "attachments", 2);
De([
  u({ type: Array })
], ge.prototype, "pollOptions", 2);
De([
  u({ attribute: !1 })
], ge.prototype, "meeting", 2);
De([
  u({ attribute: !1 })
], ge.prototype, "embed", 2);
De([
  u({ type: Array })
], ge.prototype, "reactions", 2);
De([
  u({ type: Array })
], ge.prototype, "seenBy", 2);
ge = De([
  B("wy-post-edit"),
  ht()
], ge);
var zC = Object.defineProperty, IC = Object.getOwnPropertyDescriptor, ye = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? IC(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && zC(t, e, r), r;
}, "__decorateClass$n"), Yo;
let Qt = (Yo = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.html = "", this.text = "", this.plain = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.commentCount = 0, this.seenBy = [], this.editing = !1;
  }
  /**
   * Emit a `vote` event scoped to the post.
   *
   * @internal
   * @param optionId - Identifier of the selected poll option.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", {
      detail: { optionId: t, parentId: this.postId, parentType: "posts" }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling post subscription.
   *
   * @internal
   * @param subscribe - Desired subscription state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", {
      detail: { id: this.postId, subscribe: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `trash` event requesting the post to be trashed.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `restore` event requesting the post to be restored.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  render() {
    return h`
      ${this.isTrashed ? h`<wy-post-trashed
            postId=${this.postId}
            .createdBy=${this.createdBy}
            @restore=${() => {
      this.dispatchRestore();
    }}
          ></wy-post-trashed> ` : b}
      ${!this.isTrashed && this.editing ? h`<wy-post-edit
            .postId=${this.postId}
            .createdBy=${this.createdBy}
            .createdAt=${this.createdAt}
            .text=${this.text}
            .embed=${this.embed}
            .pollOptions=${this.pollOptions}
            .attachments=${this.attachments}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}
          ></wy-post-edit> ` : b}
      ${!this.isTrashed && !this.editing ? h`<wy-post-view
            id="${this.id}"
            .postId=${this.postId}
            .createdBy=${this.createdBy}
            .createdAt=${this.createdAt}
            .modifiedAt=${this.modifiedAt}
            .isSubscribed=${this.isSubscribed}
            .isTrashed=${this.isTrashed}
            .html=${this.html}
            .text=${this.plain}
            .annotations=${this.annotations ?? []}
            .attachments=${this.attachments ?? []}
            .meeting=${this.meeting}
            .pollOptions=${this.pollOptions}
            .embed=${this.embed}
            .reactions=${this.reactions}
            .commentCount=${this.commentCount}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}
            @subscribe=${(t) => {
      this.dispatchSubscribe(t.detail.subscribe);
    }}
            @trash=${() => {
      this.dispatchTrash();
    }}
            @vote=${(t) => {
      this.dispatchVote(t.detail.optionId);
    }}
          ></wy-post-view> ` : b}
    `;
  }
}, a(Yo, "WyPost"), Yo);
Qt.styles = [Ht];
ye([
  u({ type: Number })
], Qt.prototype, "postId", 2);
ye([
  u({ attribute: !1 })
], Qt.prototype, "createdBy", 2);
ye([
  u()
], Qt.prototype, "createdAt", 2);
ye([
  u()
], Qt.prototype, "modifiedAt", 2);
ye([
  u({ type: Boolean })
], Qt.prototype, "isSubscribed", 2);
ye([
  u({ type: Boolean })
], Qt.prototype, "isTrashed", 2);
ye([
  u()
], Qt.prototype, "html", 2);
ye([
  u()
], Qt.prototype, "text", 2);
ye([
  u()
], Qt.prototype, "plain", 2);
ye([
  u({ attribute: !1 })
], Qt.prototype, "annotations", 2);
ye([
  u({ attribute: !1 })
], Qt.prototype, "attachments", 2);
ye([
  u({ type: Array })
], Qt.prototype, "pollOptions", 2);
ye([
  u({ attribute: !1 })
], Qt.prototype, "meeting", 2);
ye([
  u({ attribute: !1 })
], Qt.prototype, "embed", 2);
ye([
  u({ type: Array })
], Qt.prototype, "reactions", 2);
ye([
  u({ attribute: !1 })
], Qt.prototype, "commentCount", 2);
ye([
  u({ type: Array })
], Qt.prototype, "seenBy", 2);
ye([
  D()
], Qt.prototype, "editing", 2);
Qt = ye([
  B("wy-post")
], Qt);
var FC = Object.defineProperty, DC = Object.getOwnPropertyDescriptor, e1 = /* @__PURE__ */ a((n) => {
  throw TypeError(n);
}, "__typeError$5"), i1 = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? DC(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && FC(t, e, r), r;
}, "__decorateClass$m"), r1 = /* @__PURE__ */ a((n, t, e) => t.has(n) || e1("Cannot " + e), "__accessCheck$5"), Wf = /* @__PURE__ */ a((n, t, e) => (r1(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$5"), VC = /* @__PURE__ */ a((n, t, e) => t.has(n) ? e1("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$5"), Kf = /* @__PURE__ */ a((n, t, e, i) => (r1(n, t, "write to private field"), t.set(n, e), e), "__privateSet$5"), fa, Xo;
let Hl = (Xo = class extends Dt {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.postsQuery = new ir(this), this.infiniteScroll = new rr(this), this.pagerRef = nt(), this.addPostMutation = new ti(this), this.handleRealtimePostCreated = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp(), r = await this.whenUser();
      t.post.app.id !== i.id || t.post.created_by?.id === r.id || (t.post.created_by = t.actor, Vr(e.queryClient, ["posts", i.id], t.post, {
        descending: !0
      }));
    }, this.handleRealtimeCommentCreated = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp(), r = await this.whenUser();
      t.actor.id === r.id || !t.comment.parent || (Zt(e.queryClient, ["posts", i.id], t.comment.parent.id, (s) => {
        s.comments ? s.comments.count += 1 : s.comments = { count: 1 };
      }), await e.queryClient.invalidateQueries({ queryKey: ["posts", t.comment.app.id, "comments"] }));
    }, this.handleRealtimeReactionAdded = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp();
      t.entity.type === Ae.Post && Zt(e.queryClient, ["posts", i.id], t.entity.id, (r) => {
        zl(r, t.reaction, t.actor);
      });
    }, this.handleRealtimeReactionDeleted = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp();
      t.entity.type === Ae.Post && Zt(e.queryClient, ["posts", i.id], t.entity.id, (r) => {
        zl(r, void 0, t.actor);
      });
    }, VC(this, fa);
  }
  /**
   * Handle editor submissions by dispatching the create-post mutation.
   *
   * @param e - Submitted editor data.
   */
  async handleSubmit(t) {
    const e = await this.whenApp(), i = await this.whenUser();
    this.addPostMutation.mutate({
      app_id: e.id,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      user: i,
      context: t.detail.contextData
    });
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && this.app?.id !== t.get("app")?.id && await this.postsQuery.trackInfiniteQuery(_C(this.weavy, this.app.id)), (t.has("weavy") || t.has("app") || t.has("componentFeatures")) && this.weavy && this.app && this.app?.id !== t.get("app")?.id) {
      await this.addPostMutation.trackMutation(MC(this.weavy, ["posts", this.app.id])), this.subscribePostMutation = PC(this.weavy, this.app), this.removePostMutation = xC(this.weavy, this.app), this.restorePostMutation = $C(this.weavy, this.app), this.pollMutation = gy(this.weavy, this.app.id, ["posts", this.app.id]), (e = Wf(this, fa)) == null || e.call(this);
      const i = `a${this.app.id}`;
      this.weavy.subscribe(i, "post_created", this.handleRealtimePostCreated), this.weavy.subscribe(i, "comment_created", this.handleRealtimeCommentCreated), this.componentFeatures?.allowsFeature(S.Reactions) && (this.weavy.subscribe(i, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(i, "reaction_removed", this.handleRealtimeReactionDeleted)), Kf(this, fa, () => {
        this.weavy?.unsubscribe(i, "post_created", this.handleRealtimePostCreated), this.weavy?.unsubscribe(i, "comment_created", this.handleRealtimeCommentCreated), this.weavy?.unsubscribe(i, "reaction_added", this.handleRealtimeReactionAdded), this.weavy?.unsubscribe(i, "reaction_removed", this.handleRealtimeReactionDeleted), Kf(this, fa, void 0);
      });
    }
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.postsQuery.result, this.pagerRef.value);
  }
  render() {
    const { data: t, isPending: e, hasNextPage: i } = this.postsQuery.result ?? {}, r = nr(t);
    return h`
      <div part="wy-posts">
        <div part="wy-posts-header">
          <wy-editor
            editorLocation="apps"
            ?disabled=${!Ac(_n.Create, this.app?.permissions)}
            .typing=${!1}
            .draft=${!0}
            placeholder=${this.placeholder ?? x("Create a post...")}
            buttonText=${x("Post")}
            @submit=${(s) => this.handleSubmit(s)}
          ></wy-editor>
        </div>

        <!-- this.user ?? -->
        ${e ? h`<wy-empty><wy-progress-circular indeterminate padded></wy-progress-circular></wy-empty> ` : h`
              ${r ? je(
      r,
      (s) => s.id,
      (s) => h`<wy-post
                        id="post-${s.id}"
                        .postId=${s.id}
                        .createdBy=${s.created_by}
                        .createdAt=${s.created_at}
                        .modifiedAt=${s.updated_at}
                        .isSubscribed=${s.is_subscribed}
                        .isTrashed=${s.is_trashed}
                        .html=${s.html}
                        .text=${s.text}
                        .plain=${s.plain}
                        .annotations=${s.annotations?.data}
                        .attachments=${s.attachments?.data}
                        .meeting=${s.meeting}
                        .pollOptions=${s.options?.data}
                        .embed=${s.embed}
                        .reactions=${s.reactions?.data}
                        .commentCount=${s.comments?.count || 0}
                        @subscribe=${(o) => {
        this.subscribePostMutation?.mutate({
          id: o.detail.id,
          subscribe: o.detail.subscribe
        });
      }}
                        @trash=${(o) => {
        this.removePostMutation?.mutate({ id: o.detail.id });
      }}
                        @restore=${(o) => {
        this.restorePostMutation?.mutate({ id: o.detail.id });
      }}
                        @vote=${(o) => {
        o.detail.parentType && o.detail.parentId && this.pollMutation?.mutate({
          optionId: o.detail.optionId,
          parentType: o.detail.parentType,
          parentId: o.detail.parentId
        });
      }}
                      ></wy-post>`
    ) : h`<wy-empty></wy-empty>`}
              ${i ? h`<div ${Q(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : b}
            `}
      </div>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = Wf(this, fa)) == null || t.call(this), super.disconnectedCallback();
  }
}, a(Xo, "WyPostList"), Xo);
fa = /* @__PURE__ */ new WeakMap();
Hl.styles = [qh, Oy, Jr, X];
i1([
  u()
], Hl.prototype, "placeholder", 2);
Hl = i1([
  B("wy-post-list"),
  ht()
], Hl);
var HC = Object.defineProperty, BC = Object.getOwnPropertyDescriptor, n1 = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? BC(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && HC(t, e, r), r;
}, "__decorateClass$l"), Jo;
let Bl = (Jo = class extends Re {
  constructor() {
    super(...arguments), this.appType = st.Posts, this.componentFeatures = new le({
      // All available features as enabled/disabled by default
      [S.Attachments]: !0,
      [S.CloudFiles]: !0,
      [S.Comments]: !0,
      [S.ContextData]: !0,
      [S.Embeds]: !0,
      [S.GoogleMeet]: !1,
      [S.Meetings]: !1,
      [S.Mentions]: !0,
      [S.MicrosoftTeams]: !1,
      [S.Polls]: !0,
      [S.Previews]: !0,
      [S.Reactions]: !0,
      [S.Typing]: !1,
      // Has no effect currently
      [S.ZoomMeetings]: !1
    }), this.theme = new _e(this, Bl.styles);
  }
  render() {
    return h`
      <wy-buttons position="floating" reverse><slot name="actions"></slot></wy-buttons>
      <wy-post-list .placeholder=${this.placeholder}></wy-post-list>
      <wy-context-data-progress></wy-context-data-progress>
    `;
  }
}, a(Jo, "WyPosts"), Jo);
Bl.styles = [se, wr, Gn, Zn, Fe];
n1([
  u()
], Bl.prototype, "placeholder", 2);
Bl = n1([
  B("wy-posts"),
  ht()
], Bl);
const NC = j`[part~=wy-notification] strong{font-weight:var(--wy-font-weight-bold, 600)}[part~=wy-notification] p{display:inline}[part~=wy-notification-text]{color:var(--wy-component-color)}[part~=wy-notification-text]{display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;overflow:hidden}[part~=wy-notification-text]{white-space:normal}`;
var UC = Object.defineProperty, qC = Object.getOwnPropertyDescriptor, $d = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? qC(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && UC(t, e, r), r;
}, "__decorateClass$k"), tc;
let Qr = (tc = class extends Te {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.selected = !1, this.standalone = !1;
  }
  /**
   * Emit a `select` event for the current notification.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSelect(t) {
    const e = new CustomEvent("select", {
      detail: { notificationId: this.notificationId }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `mark` event toggling read status.
   *
   * @internal
   * @param e - Source event triggering the action.
   * @param markAsRead - Target read state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchMark(t, e) {
    if (t.stopPropagation(), e === !!this.notification.is_unread) {
      const i = new CustomEvent("mark", {
        detail: { notificationId: this.notificationId, markAsRead: e }
      });
      return this.dispatchEvent(i);
    }
    return !0;
  }
  /**
   * Emit a `hide` event when the toast should disappear.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchHide() {
    if (this.standalone) {
      const t = new CustomEvent("hide", {
        bubbles: !0
      });
      return this.dispatchEvent(t);
    }
    return !0;
  }
  /**
   * Emit a `close` event when the toast should close.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchClose() {
    if (this.standalone) {
      const t = new CustomEvent("close", {
        bubbles: !0
      });
      return this.dispatchEvent(t);
    }
    return !0;
  }
  /**
   * Handle click interactions and trigger navigation plus dismissal.
   *
   * @internal
   */
  async handleClick(t) {
    this.dispatchSelect(t), this.dispatchMark(t, !0), this.dispatchHide(), await Ov(this, this.weavy, this.notification), this.dispatchClose();
  }
  render() {
    const t = this.notification.created_at ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.notification.created_at)
    ) : "", e = this.notification.created_at ? tl(this.weavy?.locale, new Date(this.notification.created_at)) : "", i = this.notification.actor, { title: r, titleHtml: s, detail: o } = zv(this.notification);
    return h`
      <wy-item
        part="wy-notification"
        size="md"
        interactive
        outer
        status=${!this.standalone && !this.notification.is_unread ? "read" : void 0}
        ?selected=${!this.standalone && this.selected}
        align="top"
        actionsPosition=${this.standalone ? "end" : "bottom"}
        tabindex="0"
        @click=${(c) => this.handleClick(c)}
        @keydown=${ve}
        @keyup=${Ie}
      >
        <wy-avatar
          slot="image"
          src=${dt(i?.avatar_url)}
          name=${dt(i?.name)}
          description=${dt(i?.comment)}
          presence=${i?.presence || "away"}
          ?isAgent=${i?.is_agent}
          id=${dt(i?.id)}
          size=${48}
        ></wy-avatar>

        <div slot="title" part="wy-notification-text" title=${r + (o ? `: "${o}"` : "")}>
          ${s}${o ? h`: <q part="wy-quote">${o}</q> ` : b}
      </div>

        ${this.standalone ? b : h`
              <time slot="text" part="wy-meta" datetime=${this.notification.created_at.toString()} title=${t}>
                ${e}
              </time>
            `}
        ${this.standalone ? h`
              <wy-button
                slot="actions"
                kind="icon"
                @click=${(c) => this.dispatchMark(c, !!this.notification.is_unread) && this.dispatchClose()}
              >
                <wy-icon name="close"></wy-icon>
              </wy-button>
            ` : h`
              <wy-button
                small
                slot="actions"
                kind="icon"
                @click=${(c) => this.dispatchMark(c, !!this.notification.is_unread) && this.dispatchClose()}
                title=${this.notification.is_unread ? x("Mark as read") : x("Mark as unread")}
              >
                <wy-icon
                  name=${this.notification.is_unread ? "read" : "unread"}
                  color=${this.notification.is_unread ? "" : "secondary"}
                ></wy-icon>
              </wy-button>
            `}
      </wy-item>
    `;
  }
}, a(tc, "WyNotificationListItem"), tc);
Qr.styles = [Ht, Gc, NC, X];
$d([
  u({ type: Number })
], Qr.prototype, "notificationId", 2);
$d([
  u({ type: Boolean, reflect: !0 })
], Qr.prototype, "selected", 2);
$d([
  u({ type: Boolean })
], Qr.prototype, "standalone", 2);
$d([
  u({ attribute: !1 })
], Qr.prototype, "notification", 2);
Qr = $d([
  B("wy-notification-list-item"),
  ht()
], Qr);
var jC = Object.defineProperty, WC = Object.getOwnPropertyDescriptor, a1 = /* @__PURE__ */ a((n) => {
  throw TypeError(n);
}, "__typeError$4"), ra = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? WC(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && jC(t, e, r), r;
}, "__decorateClass$j"), s1 = /* @__PURE__ */ a((n, t, e) => t.has(n) || a1("Cannot " + e), "__accessCheck$4"), Qf = /* @__PURE__ */ a((n, t, e) => (s1(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$4"), KC = /* @__PURE__ */ a((n, t, e) => t.has(n) ? a1("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$4"), Gf = /* @__PURE__ */ a((n, t, e, i) => (s1(n, t, "write to private field"), t.set(n, e), e), "__privateSet$4"), ma, ec;
let Bc = (ec = class extends Dt {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.typeFilter = _t.All, this.notificationsQuery = new ir(this), this.infiniteScroll = new rr(this), this.pagerRef = nt(), this.handleRefresh = (t) => {
      this.notificationsQuery.result.refetch();
    }, this.handlePresenceChange = (t) => {
      this.weavy && (Array.isArray(t) || (t = [parseInt(t)]), Zt(this.weavy.queryClient, ["notifications", "list"], void 0, (e) => {
        const i = e.actor;
        i.presence = t.indexOf(i.id) != -1 ? "active" : "away", e.actor = i;
      }));
    }, KC(this, ma);
  }
  /**
   * Mark or unmark a notification as read.
   *
   * @param notificationId - Target notification id.
   * @param markAsRead - Desired read state.
   */
  async markAsRead(t, e = !0) {
    await this.markNotificationMutation?.mutate({ notificationId: t, markAsRead: e });
  }
  /**
   * Select the provided notification and emit a `wy-action` event.
   *
   * @internal
   * @param notification - Notification to select.
   */
  selectNotification(t) {
    this.notificationId = t.id, this.dispatchAction(Ee.Select, t);
  }
  /**
   * Triggers `wy-action` event.
   *
   * @internal
   * @param action - The performed action.
   * @param notification - Selected notification payload.
   * @returns Whether the event was successful.
   */
  dispatchAction(t, e) {
    const i = new CustomEvent("wy-action", {
      detail: { action: t, notification: e },
      bubbles: !0,
      composed: !0
    });
    return this.dispatchEvent(i);
  }
  async willUpdate(t) {
    var e;
    super.willUpdate(t), (t.has("weavy") || t.has("typeFilter") || t.has("app")) && this.weavy && await this.notificationsQuery.trackInfiniteQuery(
      X0(this.weavy, this.typeFilter, this.app?.id)
    ), t.has("weavy") && this.weavy && (this.markNotificationMutation = Gm(this.weavy), (e = Qf(this, ma)) == null || e.call(this), this.weavy.subscribe(null, "online", this.handlePresenceChange), this.weavy.subscribe(null, "notification_created", this.handleRefresh), this.weavy.subscribe(null, "notification_updated", this.handleRefresh), this.weavy.subscribe(null, "notifications_marked", this.handleRefresh), Gf(this, ma, () => {
      this.weavy?.unsubscribe(null, "online", this.handlePresenceChange), this.weavy?.unsubscribe(null, "notification_created", this.handleRefresh), this.weavy?.unsubscribe(null, "notification_updated", this.handleRefresh), this.weavy?.unsubscribe(null, "notifications_marked", this.handleRefresh), Gf(this, ma, void 0);
    }));
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.notificationsQuery.result, this.pagerRef.value);
  }
  /**
   * Render the notifications collection.
   *
   * @internal
   * @param user - Current user.
   * @param infiniteData - Notification pages.
   */
  renderNotifications(t, e) {
    if (e) {
      const i = nr(e);
      return je(
        i,
        (r) => r?.id,
        (r) => [
          h`<wy-notification-list-item
              notificationId=${r.id}
              .notification=${r}
              .selected=${this.notificationId == r.id}
              @select=${(s) => this.selectNotification(r)}
              @mark=${(s) => this.markAsRead(s.detail.notificationId, s.detail.markAsRead)}
            ></wy-notification-list-item>`
        ]
      );
    }
    return b;
  }
  render() {
    const { data: t, hasNextPage: e, isPending: i } = this.notificationsQuery.result ?? {};
    return h`
      ${this.user ? h`
            <div class="wy-notifications">
              ${!i && this.user && t ? t.pages[0]?.count ? this.renderNotifications(this.user, t) : h`
                      <div part="wy-pane-body">
                        <div part="wy-pane-group">
                          <slot name="empty">
                            <wy-empty>${x("No updates yet.")}</wy-empty>
                          </slot>
                        </div>
                      </div>
                    ` : h`<wy-empty><wy-progress-circular indeterminate padded></wy-progress-circular></wy-empty>`}
              ${e ? h`<div ${Q(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : b}
            </div>
          ` : h`<wy-empty part="wy-pane"><wy-progress-circular indeterminate overlay></wy-progress-circular></wy-empty>`}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = Qf(this, ma)) == null || t.call(this), super.disconnectedCallback();
  }
}, a(ec, "WyNotificationList"), ec);
ma = /* @__PURE__ */ new WeakMap();
Bc.styles = [
  Xn,
  Jr,
  j`
      :host {
        position: relative;
      }
    `
];
ra([
  u({ type: Number })
], Bc.prototype, "notificationId", 2);
ra([
  u()
], Bc.prototype, "typeFilter", 2);
Bc = ra([
  B("wy-notification-list"),
  ht()
], Bc);
var ic;
let Un = (ic = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.typeFilter = _t.All, this.activeFilter = _t.All;
  }
  /**
   * Trigger `filter` event.
   *
   * @param typeFilter - Filter to emit.
   * @returns Whether the event was dispatched successfully.
   */
  dispatchFilter(t) {
    const e = new CustomEvent("filter", {
      detail: { typeFilter: t }
    });
    return this.dispatchEvent(e);
  }
  render() {
    const t = !!this._slotDefault.length;
    return h`
      <div part="wy-pane-toolbar">
        <slot @slotchange=${() => this.requestUpdate()}></slot>
        ${t ? b : h`
              <wy-buttons tabs>
                <wy-button
                  ?active=${this.typeFilter === _t.All}
                  @click=${() => {
      this.dispatchFilter(_t.All) && (this.typeFilter = _t.All);
    }}
                  kind="tab"
                  small
                >
                  ${x("All")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === _t.Activity}
                  @click=${() => {
      this.dispatchFilter(_t.Activity) && (this.typeFilter = _t.Activity);
    }}
                  kind="tab"
                  small
                >
                  ${x("Activities")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === _t.Mention}
                  @click=${() => {
      this.dispatchFilter(_t.Mention) && (this.typeFilter = _t.Mention);
    }}
                  kind="tab"
                  small
                >
                  ${x("Mentions")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === _t.Reaction}
                  @click=${() => {
      this.dispatchFilter(_t.Reaction) && (this.typeFilter = _t.Reaction);
    }}
                  kind="tab"
                  small
                >
                  ${x("Reactions")}
                </wy-button>
              </wy-buttons>
            `}

        <slot name="actions" @slotchange=${() => this.requestUpdate()}></slot>
      </div>
    `;
  }
}, a(ic, "WyNotificationHeader"), ic);
Un.styles = [
  Xn,
  Jr,
  j`
      :host {
        position: relative;
      }
    `
];
ra([
  u()
], Un.prototype, "typeFilter", 2);
ra([
  D()
], Un.prototype, "activeFilter", 2);
ra([
  Kc({ flatten: !0, selector: ":not(slot)" })
], Un.prototype, "_slotDefault", 2);
Un = ra([
  B("wy-notification-header"),
  ht()
], Un);
var QC = Object.defineProperty, GC = Object.getOwnPropertyDescriptor, Ny = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? GC(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && QC(t, e, r), r;
}, "__decorateClass$i"), rc;
let Nc = (rc = class extends Hr {
  constructor() {
    super(...arguments), this.unreadNotifications = new bl(this), this.theme = new _e(this, Nc.styles), this.currentTypeFilter = _t.All, this.typeFilter = _t.All;
  }
  /** Current unread notification count. */
  get unread() {
    return this.unreadNotifications.unread;
  }
  /** Marks all tracked notifications as read. */
  async markAllAsRead() {
    await this.unreadNotifications.markAllAsRead();
  }
  async willUpdate(t) {
    await super.willUpdate(t), t.has("typeFilter") && (this.currentTypeFilter = this.typeFilter), (t.has("typeFilter") || t.has("app")) && await this.unreadNotifications.track(this.typeFilter, this.app?.id);
  }
  render() {
    const t = this.typeFilter === _t.All;
    return h`
      ${t ? h`
            <wy-notification-header
              @filter=${(e) => {
      this.currentTypeFilter = e.detail.typeFilter;
    }}
            >
              <slot name="actions" slot="actions">
                <wy-button kind="icon" @click=${() => this.markAllAsRead()} title=${x("Mark all as read")}>
                  <wy-icon name="check-all"></wy-icon>
                </wy-button>
              </slot>
            </wy-notification-header>
          ` : b}
      ${this.user ? h` <wy-notification-list typeFilter=${this.currentTypeFilter}></wy-notification-list> ` : h`
            <wy-empty>
              <wy-progress-circular indeterminate padded reveal></wy-progress-circular>
            </wy-empty>
          `}
    `;
  }
}, a(rc, "WyNotifications"), rc);
Nc.styles = [se, wr, Gn, Zn, Fe];
Ny([
  D()
], Nc.prototype, "currentTypeFilter", 2);
Ny([
  u()
], Nc.prototype, "typeFilter", 2);
Nc = Ny([
  B("wy-notifications"),
  ht()
], Nc);
const o1 = j`:host{display:inline-flex}`;
var ZC = Object.defineProperty, YC = Object.getOwnPropertyDescriptor, jh = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? YC(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && ZC(t, e, r), r;
}, "__decorateClass$h"), nc;
let qn = (nc = class extends Hr {
  constructor() {
    super(...arguments), this.theme = new _e(this, qn.styles), this.unreadNotifications = new bl(this), this.badge = "count", this.badgePosition = "inline", this.typeFilter = _t.All;
  }
  /** Current unread notification count. */
  get unread() {
    return this.unreadNotifications.unread;
  }
  /** Marks all tracked notifications as read. */
  async markAllAsRead() {
    await this.unreadNotifications.markAllAsRead();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("typeFilter") || t.has("app")) && await this.unreadNotifications.track(this.typeFilter, this.app?.id);
  }
  render() {
    return this.user && this.badge !== "none" ? h`
          <wy-badge
            appearance=${this.badge}
            position=${this.badgePosition}
            .count=${this.unreadNotifications.isUnreadPending ? NaN : this.unreadNotifications.unread}
          ></wy-badge>
        ` : b;
  }
}, a(nc, "WyNotificationBadge"), nc);
qn.styles = [o1, se, Fe];
jh([
  u({ type: String })
], qn.prototype, "badge", 2);
jh([
  u({ type: String })
], qn.prototype, "badgePosition", 2);
jh([
  u()
], qn.prototype, "typeFilter", 2);
qn = jh([
  B("wy-notification-badge")
], qn);
var XC = Object.defineProperty, JC = Object.getOwnPropertyDescriptor, nn = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? JC(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && XC(t, e, r), r;
}, "__decorateClass$g"), ac;
let vi = (ac = class extends Hr {
  constructor() {
    super(...arguments), this.theme = new _e(this, vi.styles), this.unreadNotifications = new bl(this), this.overlay = "sheet", this.badge = "compact", this.badgePosition = "top-right", this.typeFilter = _t.All, this.currentTypeFilter = _t.All, this.showNotificationList = !1;
  }
  set list(t) {
    console.warn(`.list is deprecated. Use .overlay = "${t}"; instead`), this.overlay = t;
  }
  get list() {
    return this.overlay;
  }
  /** Current unread notification count. */
  get unread() {
    return this.unreadNotifications.unread;
  }
  /** Marks all tracked notifications as read. */
  async markAllAsRead() {
    await this.unreadNotifications.markAllAsRead();
  }
  async willUpdate(t) {
    await super.willUpdate(t), t.has("typeFilter") && (this.currentTypeFilter = this.typeFilter), (t.has("typeFilter") || t.has("app")) && await this.unreadNotifications.track(this.typeFilter, this.app?.id);
  }
  render() {
    const t = this.typeFilter === _t.All;
    return h`
      <wy-button
        kind="icon"
        ?active=${this.showNotificationList}
        @click=${() => this.showNotificationList = !this.showNotificationList}
      >
        <wy-icon name="bell">
          ${this.user && this.badge !== "none" ? h`
                <wy-badge
                  appearance=${this.badge}
                  position=${this.badgePosition}
                  .count=${this.unreadNotifications.isUnreadPending ? NaN : this.unreadNotifications.unread}
                ></wy-badge>
              ` : b}
        </wy-icon>
      </wy-button>

      ${this.overlay !== "none" ? h`<wy-overlay
            type=${this.overlay}
            .show=${this.showNotificationList}
            @close=${() => this.showNotificationList = !1}
          >
            <slot name="actions" slot="actions">
              <wy-button kind="icon" @click=${() => this.markAllAsRead()} title=${x("Mark all as read")}>
                <wy-icon name="check-all"></wy-icon>
              </wy-button>
              ${this.app ? h`
                    <wy-dropdown>
                      ${this.app?.is_subscribed ? h`
                            <wy-dropdown-item @click=${() => this.subscribe(!1)}>
                              <wy-icon name="bell-off"></wy-icon>
                              ${x("Unsubscribe")}
                            </wy-dropdown-item>
                          ` : h`
                            <wy-dropdown-item @click=${() => this.subscribe(!0)}>
                              <wy-icon name="bell"></wy-icon>
                              ${x("Subscribe")}
                            </wy-dropdown-item>
                          `}
                    </wy-dropdown>
                  ` : b}
            </slot>
            <slot slot="title">${x("Notifications")}</slot>
            <wy-container scrollY>
              ${this.showNotificationList ? h`
                    ${t ? h`
                          <wy-notification-header
                            @filter=${(e) => {
      this.currentTypeFilter = e.detail.typeFilter;
    }}
                          ></wy-notification-header>
                        ` : b}
                    <wy-notification-list typeFilter=${this.currentTypeFilter}>
                      ${this.app && !this.app?.is_subscribed ? h`
                            <wy-empty slot="empty">
                              <div>${x("You are not subscribed to updates yet.")}</div>
                              <wy-button color="primary" @click=${() => this.subscribe(!0)}
                                >${x("Subscribe")}</wy-button
                              >
                            </wy-empty>
                          ` : b}
                    </wy-notification-list>
                  ` : b}
            </wy-container>
          </wy-overlay>` : b}
    `;
  }
}, a(ac, "WyNotificationButton"), ac);
vi.styles = [X, se, Fe];
nn([
  u({ type: String })
], vi.prototype, "overlay", 2);
nn([
  u({ type: String })
], vi.prototype, "list", 1);
nn([
  u({ type: String })
], vi.prototype, "badge", 2);
nn([
  u({ type: String })
], vi.prototype, "badgePosition", 2);
nn([
  u()
], vi.prototype, "typeFilter", 2);
nn([
  D()
], vi.prototype, "currentTypeFilter", 2);
nn([
  D()
], vi.prototype, "showNotificationList", 2);
vi = nn([
  B("wy-notification-button"),
  ht()
], vi);
var t9 = Object.defineProperty, e9 = Object.getOwnPropertyDescriptor, kd = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? e9(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && t9(t, e, r), r;
}, "__decorateClass$f"), sc;
let Nl = (sc = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.show = !1, this.viewportRef = nt();
  }
  /**
   * Close the popover layer.
   */
  close() {
    this.show = !1;
    try {
      this.viewportRef.value?.hidePopover();
    } catch {
    }
  }
  /**
   * Handler when popover is toggled.
   * @internal
   */
  handleClose(t) {
    if (t.type === "toggle" && t.newState === "closed" || t.type === "click") {
      this.show = !1;
      const e = new CustomEvent("hide");
      this.dispatchEvent(e);
    }
  }
  render() {
    return h`
      <div part="wy-toasts" tabindex="0" ${Q(this.viewportRef)} ?hidden=${!this.show} popover="auto">
        <slot></slot>
      </div>
    `;
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("show"))
      try {
        this.show ? this.viewportRef.value?.showPopover() : this.viewportRef.value?.hidePopover();
      } catch {
      }
    t.has("show") && this.show && this.viewportRef.value?.focus();
  }
  firstUpdated(t) {
    this.viewportRef.value?.addEventListener(this.viewportRef.value.popover ? "toggle" : "click", (e) => {
      this.handleClose(e);
    }), this.show && this.viewportRef.value?.showPopover();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
  }
}, a(sc, "WyToasts"), sc);
Nl.styles = [
  xy,
  X
];
kd([
  u({ type: Boolean })
], Nl.prototype, "show", 2);
Nl = kd([
  B("wy-toasts")
], Nl);
var oc;
let hr = (oc = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.toastRef = nt(), this.show = !1, this.duration = hr.defaultDuration;
  }
  /**
   * Hide the toast.
   */
  hide() {
    this.show = !1;
  }
  /**
   * Hide and close the toast.
   * 
   * @param silent - Indicates that the toast should close silently.
   * @fires {ClosedEventType} closed - When the toast has been hidden and closed.
   */
  async close(t = !1) {
    this.show = !1, await new Promise((i) => requestAnimationFrame(i)), this.toastRef.value && await Zu(this.toastRef.value, !1);
    const e = new CustomEvent("closed", { detail: { silent: t } });
    this.dispatchEvent(e);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("show") && (this.timeout && (window.clearTimeout(this.timeout), this.timeout = void 0), this.show && this.duration > 0 && this.duration < 1 / 0 && (this.timeout = window.setTimeout(() => this.close(!0), this.duration)));
  }
  render() {
    return h`
      <div
        ${Q(this.toastRef)}
        part="wy-toast wy-fade ${this.show ? "wy-show" : ""}"
        @hide=${(t) => {
      t.stopPropagation(), this.hide();
    }}
        @close=${() => this.close()}
        @keyup=${by}
      >
        <slot></slot>
      </div>
    `;
  }
  firstUpdated() {
    requestAnimationFrame(() => {
      this.show = !0;
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.timeout && (window.clearTimeout(this.timeout), this.timeout = void 0);
  }
}, a(oc, "WyToast"), oc);
hr.styles = [
  xy,
  X
];
hr.defaultDuration = 5e3;
kd([
  D()
], hr.prototype, "show", 2);
kd([
  u({ type: Number })
], hr.prototype, "duration", 2);
hr = kd([
  B("wy-toast")
], hr);
var i9 = Object.defineProperty, r9 = Object.getOwnPropertyDescriptor, c1 = /* @__PURE__ */ a((n) => {
  throw TypeError(n);
}, "__typeError$3"), nl = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? r9(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && i9(t, e, r), r;
}, "__decorateClass$e"), l1 = /* @__PURE__ */ a((n, t, e) => t.has(n) || c1("Cannot " + e), "__accessCheck$3"), Zf = /* @__PURE__ */ a((n, t, e) => (l1(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$3"), n9 = /* @__PURE__ */ a((n, t, e) => t.has(n) ? c1("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$3"), Yf = /* @__PURE__ */ a((n, t, e, i) => (l1(n, t, "write to private field"), t.set(n, e), e), "__privateSet$3"), va, cc;
let ur = (cc = class extends Hr {
  constructor() {
    super(...arguments), this.theme = new _e(this, ur.styles), this.typeFilter = _t.All, this.appearance = "internal", this.requestUserPermission = !1, this.duration = hr.defaultDuration, this._notifications = [], this._nativeNotifications = [], this.handleEvent = async (t) => {
      if (this.typeFilter === _t.All || this.typeFilter === t.notification.type)
        if (t.action === "notification_deleted")
          this.removeNotification(t.notification.id), this.closeNativeNotification(t.notification.id);
        else {
          const { title: e, detail: i } = zv(t.notification), r = {
            ...t.notification,
            title: e,
            detail: i,
            lang: this.weavy?.locale
          }, s = new CustomEvent("wy-notification", {
            bubbles: !0,
            composed: !0,
            cancelable: !0,
            detail: r
          });
          (!this.requestUserPermission && this.appearance !== "native" || await this.hasUserPermission() ? this.dispatchEvent(s) : !1) && (t.action === "notification_created" && t.notification.is_unread ? await this.addOrUpdateNotification(t.notification) : await this.updateNotification(t.notification), await this.addOrUpdateNativeNotification(r));
        }
    }, n9(this, va);
  }
  /** @internal */
  async addOrUpdateNotification(t) {
    if (!this.requestUserPermission || await this.hasUserPermission()) {
      const e = [...this._notifications], i = e.findIndex((r) => r.id === t.id);
      i !== -1 ? (e.splice(i, 1, t), this._notifications = e) : (e.push(t), this._notifications = e);
    }
  }
  /** @internal */
  async updateNotification(t) {
    if (!this.requestUserPermission || await this.hasUserPermission()) {
      const e = [...this._notifications], i = e.findIndex((r) => r.id === t.id);
      i !== -1 && (e.splice(i, 1, t), this._notifications = e);
    }
  }
  /** @internal */
  removeNotification(t) {
    const e = [...this._notifications], i = e.findIndex((r) => r.id === t);
    i !== -1 && (e.splice(i, 1), this._notifications = e);
  }
  /** @internal */
  async addOrUpdateNativeNotification(t) {
    if (this.appearance === "native" && await this.hasUserPermission()) {
      const e = this.removeNativeNotification(t.id), i = t.actor, r = new Notification(t.title, {
        tag: `wy-${t.id}`,
        lang: t.lang,
        body: t.detail,
        icon: i.avatar_url,
        // @ts-expect-error Property `renotify` not available in ts types yet
        renotify: e && t.is_unread
      });
      r.onclick = async () => {
        await this.markAsRead(t.id, !0), await Ov(this, this.weavy, t);
      }, r.onclose = () => {
        this.removeNativeNotification(t.id);
      }, this._nativeNotifications = [...this._nativeNotifications, r];
    }
  }
  /** @internal */
  removeNativeNotification(t) {
    const e = [...this._nativeNotifications], i = e.findIndex(
      (r) => r.tag === `wy-${t}`
    );
    return i ? (e.splice(i, 1), this._nativeNotifications = e, !0) : !1;
  }
  /** @internal */
  closeNativeNotification(t) {
    const e = this._nativeNotifications.findIndex(
      (i) => i.tag === `wy-${t}`
    );
    return e ? (this._nativeNotifications[e].close(), !0) : !1;
  }
  /** Checks if the user has granted permission for desktop notifications. A request will be made if permission has not yet been granted. */
  async hasUserPermission() {
    if (!("Notification" in window))
      console.error("This browser does not support desktop notifications");
    else if (!window.isSecureContext)
      console.error(
        `Desktop notifications can only be used in secure contexts. 
        See https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts`
      );
    else {
      if (Notification.permission === "granted")
        return !0;
      if (Notification.permission !== "denied")
        return await Notification.requestPermission() === "granted";
    }
    return !1;
  }
  /** Clears queued internal toast notifications. */
  clearNotifications() {
    this._notifications = [];
  }
  /**
   * Marks a notification as read or unread.
   * @param notificationId - The ID of the notification to mark.
   * @param [markAsRead=true] - Whether to mark the notification as read (true) or unread (false).
   */
  async markAsRead(t, e = !0) {
    await this.markNotificationMutation?.mutate({ notificationId: t, markAsRead: e });
  }
  async willUpdate(t) {
    var e;
    await super.willUpdate(t), t.has("weavy") && this.weavy && (this.markNotificationMutation = Gm(this.weavy), (e = Zf(this, va)) == null || e.call(this), this.weavy.subscribe(null, "notification_created", this.handleEvent), this.weavy.subscribe(null, "notification_updated", this.handleEvent), Yf(this, va, () => {
      this.weavy?.unsubscribe(null, "notification_created", this.handleEvent), this.weavy?.unsubscribe(null, "notification_updated", this.handleEvent), Yf(this, va, void 0);
    })), (t.has("requestUserPermission") && this.requestUserPermission || t.has("appearance") && this.appearance === "native") && this.hasUserPermission();
  }
  render() {
    return h`
      ${this.user && this.appearance === "internal" ? h`
            <wy-toasts ?show=${!!this._notifications.length} @hide=${() => this.clearNotifications()}>
              ${je(
      this._notifications,
      (t) => t.id,
      (t) => h`
                    <wy-toast
                      duration=${this.duration}
                      @closed=${(e) => {
        e.detail.silent || this.markAsRead(t.id, !0), this.removeNotification(t.id);
      }}
                    >
                      <wy-notification-list-item standalone .notification=${t}></wy-notification-list-item>
                    </wy-toast>
                  `
    )}
            </wy-toasts>
          ` : b}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = Zf(this, va)) == null || t.call(this), super.disconnectedCallback();
  }
}, a(cc, "WyNotificationToasts"), cc);
va = /* @__PURE__ */ new WeakMap();
ur.styles = [se, X, Fe];
nl([
  u()
], ur.prototype, "typeFilter", 2);
nl([
  u()
], ur.prototype, "appearance", 2);
nl([
  u({ type: Boolean })
], ur.prototype, "requestUserPermission", 2);
nl([
  u({ type: Number })
], ur.prototype, "duration", 2);
nl([
  D()
], ur.prototype, "_notifications", 2);
ur = nl([
  B("wy-notification-toasts"),
  ht()
], ur);
const B9 = new Map(
  Object.entries({
    [yi.ChatRoom]: st.ChatRoom,
    [yi.PrivateChat]: st.PrivateChat,
    [st.ChatRoom]: yi.ChatRoom,
    [st.PrivateChat]: yi.PrivateChat
  })
), N9 = new Map(
  Object.entries({
    [yi.AgentChat]: st.AgentChat,
    [st.AgentChat]: yi.AgentChat
  })
), Uc = {
  // All available features as enabled/disabled by default
  [S.Attachments]: !0,
  [S.CloudFiles]: !0,
  [S.ContextData]: !0,
  [S.Embeds]: !0,
  [S.GoogleMeet]: !0,
  [S.Meetings]: !0,
  [S.Mentions]: !0,
  [S.MicrosoftTeams]: !0,
  [S.Polls]: !0,
  [S.Previews]: !0,
  [S.Reactions]: !0,
  [S.Receipts]: !0,
  [S.Typing]: !0,
  [S.ZoomMeetings]: !0
}, Uy = {
  // All available features as enabled/disabled by default
  [S.Attachments]: !0,
  [S.ContextData]: !0,
  [S.Embeds]: !0,
  [S.Previews]: !0,
  [S.Reactions]: !1,
  [S.Receipts]: !0,
  [S.Typing]: !0
}, qy = j`[part~=wy-messenger-layout]{display:flex;flex:1;align-items:stretch;position:relative;container-type:inline-size;align-self:stretch;min-height:0;min-width:0;box-sizing:border-box}[part~=wy-messenger-overlay-container]{--wy-padding-outer: var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));--wy-component-offset-top: calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem))))))}[part~=wy-messenger-conversation-list]{flex:0 1 100%;min-width:0;max-width:none;display:flex;flex-direction:column;padding:var(--wy-padding-outer, 0);gap:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-messenger-conversation]{display:flex;flex-direction:column;overflow-anchor:none;height:100%;width:100%;flex:0 1 100%;box-sizing:border-box;padding:var(--wy-padding-outer, 0);--wy-component-offset-top: var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))}[part~=wy-close-conversation]{display:contents}@container (inline-size < 768px){[part~=wy-messenger-conversation-list]:not([data-conversation-id=\"\"]){display:none}[part~=wy-messenger-conversation][data-conversation-id=\"\"]{display:none}}@container (inline-size >= 768px){[part~=wy-messenger-conversation-list]{flex:0 1 50%;max-width:calc(24*var(--wy-size, 1rem));padding-right:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));border-right:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-messenger-conversation]{min-width:max(50%,calc(16 * var(--wy-size, 1rem)));padding-left:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-close-conversation]{display:none}}`;
var a9 = Object.defineProperty, s9 = Object.getOwnPropertyDescriptor, jy = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? s9(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && a9(t, e, r), r;
}, "__decorateClass$d"), lc;
let qc = (lc = class extends Te {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.uploadBlobMutation = new ti(this), this.fileInputRef = nt(), this.openFileInput = () => {
      this.fileInputRef.value?.click();
    };
  }
  /**
   * Uploads the first selected file and resets the input.
   *
   * @internal
   */
  async handleBlobChange(t, e) {
    if (t && this.weavy) {
      const r = { file: t[0] };
      await this.uploadBlobMutation.trackMutation(A0(this.weavy));
      const s = await this.uploadBlobMutation.mutate(r);
      e && (e.value = "");
      const o = new CustomEvent("blob-uploaded", { detail: { blob: s } });
      this.dispatchEvent(o);
    }
  }
  render() {
    return h`
      <div part="wy-upload">
        <slot
          part="wy-upload-placeholder"
          name="placeholder"
          @click=${this.openFileInput}
          @keydown=${ve}
          @keyup=${Ie}
        ></slot>
        <input
          accept=${dt(this.accept)}
          type="file"
          ${Q(this.fileInputRef)}
          @click=${(t) => t.stopPropagation()}
          @change=${(t) => this.handleBlobChange(t.target.files, t.target)}
          hidden
        />
        <slot part="wy-upload-action" name="action">
          ${this.label ? h`<wy-button part="wy-upload-button" @click=${this.openFileInput}>${this.label}</wy-button>` : b}
        </slot>
      </div>
    `;
  }
}, a(lc, "WyUpload"), lc);
qc.styles = [
  j`
      :host {
        display: contents;
      }

      [part~="wy-upload"] {
        text-align: center;
      }

      [part~="wy-upload-placeholder"] {
        cursor: pointer;
      }
    `
];
jy([
  u({ attribute: !1 })
], qc.prototype, "label", 2);
jy([
  u({ attribute: !1 })
], qc.prototype, "accept", 2);
qc = jy([
  B("wy-upload")
], qc);
var o9 = Object.defineProperty, c9 = Object.getOwnPropertyDescriptor, Wh = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? c9(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && o9(t, e, r), r;
}, "__decorateClass$c"), dc;
let jn = (dc = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.inputRef = nt(), this.compact = !1, this.query = "", this.throttledSearch = jp(
      () => {
        this.query = this.inputRef.value?.value || "";
      },
      250,
      { leading: !1, trailing: !0 }
    );
  }
  /**
   * Put focus on the input field.
   */
  focusInput() {
    this.inputRef.value?.focus();
  }
  /**
   * Clear the input field.
   */
  clear() {
    this.query = "";
  }
  willUpdate(t) {
    if (t.has("query")) {
      const e = new CustomEvent("search", {
        bubbles: !0,
        composed: !1,
        detail: { query: this.query }
      });
      this.dispatchEvent(e);
    }
  }
  render() {
    const t = {
      "wy-input": !0,
      "wy-input-group-input": !0,
      "wy-input-filled": !0,
      "wy-input-group-input-with-overlay": this.compact
    }, e = {
      "wy-input-group-button-icon": !0,
      "wy-input-group-button-icon-overlay": this.compact
    };
    return h`
      <div part="wy-input-group">
        <input
          part=${J(t)}
          name="text"
          .value=${this.query || ""}
          ${Q(this.inputRef)}
          @input=${() => this.throttledSearch()}
          @keydown=${Bb}
          @keyup=${Br}
          placeholder=${this.placeholder || x("Search...")}
          size="4"
        />
        <wy-button type="reset" @click=${() => this.clear()} kind="icon" part=${J(e)}>
          <wy-icon name="close-circle"></wy-icon>
        </wy-button>
        <wy-button kind="icon" part=${J(e)}>
          <wy-icon name="magnify"></wy-icon>
        </wy-button>
      </div>
    `;
  }
}, a(dc, "WySearch"), dc);
jn.styles = [rn, X];
Wh([
  u()
], jn.prototype, "placeholder", 2);
Wh([
  u({ type: Boolean })
], jn.prototype, "compact", 2);
Wh([
  D()
], jn.prototype, "query", 2);
jn = Wh([
  B("wy-search"),
  ht()
], jn);
var l9 = Object.defineProperty, d9 = Object.getOwnPropertyDescriptor, an = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? d9(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && l9(t, e, r), r;
}, "__decorateClass$b"), hc;
let gi = (hc = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.agentFilter = void 0, this.selected = [], this.select = [], this.text = "", this.peopleQuery = new ir(this), this.searchRef = nt(), this.infiniteScroll = new rr(this), this.pagerRef = nt();
  }
  /**
   * Emits the selected members via the `submit` event.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchSubmit() {
    this.selected = [...this.selected, ...this.select];
    const t = new CustomEvent("submit", {
      detail: { members: this.selected }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Checks whether a member is currently selected.
   *
   * @internal
   */
  isChecked(t) {
    return this.select.find((e) => e.id === t) != null;
  }
  /**
   * Toggles selection state for the provided member.
   *
   * @internal
   */
  handleSelected(t, e) {
    e ? this.select = [...this.select, t] : (this.select = this.select.filter((i) => i.id !== t.id), this.selected = this.selected.filter((i) => i.id !== t.id));
  }
  /**
   * Renders the list of currently selected members.
   *
   * @internal
   */
  getSelected() {
    return this.selected.length > 0 ? h`
        ${this.selected.map((t) => h`
            <wy-item
              interactive
              @click=${() => this.handleSelected(t, !1)}
              @keydown=${ve}
              @keyup=${ve}
            >
              <wy-avatar
                slot="image"
                id=${t.id}
                .src=${t.avatar_url}
                .name=${t.name}
                .description=${t.comment}
                .presence=${t.presence}
                .isAgent=${t.is_agent}
                size=${32}
              ></wy-avatar>
              <span slot="title"> ${t.name} </span>
              <wy-button slot="actions" kind="icon" .active=${!1}
                ><wy-icon name="checkbox-marked"></wy-icon
              ></wy-button>
            </wy-item>
          `)}
      ` : b;
  }
  /**
   * Renders search results for the current query and filter.
   *
   * @internal
   */
  getSearchResult() {
    const { data: t, hasNextPage: e, isPending: i } = this.peopleQuery.result ?? { data: [], isPending: !0 }, r = nr(t), s = !!r.length, o = [];
    return i ? o.push(h`<wy-progress-circular indeterminate overlay></wy-progress-circular>`) : s || o.push(h`<div part="wy-pane-group">
        <div part="wy-no-result">
          ${this.text ? x("Your search did not match any people.") : x("No more users found.")}
        </div>
      </div>`), s && o.push(
      h` ${r.filter((c) => this.selected.find((l) => l.id === c.id) === void 0).map((c) => h` <wy-item
              interactive
              @click=${() => this.handleSelected(c, !this.isChecked(c.id))}
              @keydown=${ve}
              @keyup=${ve}
            >
              <wy-avatar
                slot="image"
                id=${c.id}
                .src=${c.avatar_url}
                .name=${c.name}
                .description=${c.comment}
                .presence=${c.presence}
                .isAgent=${c.is_agent}
                size=${32}
              ></wy-avatar>
              <span slot="title"> ${c.name} </span>
              <wy-button slot="actions" kind="icon" .active=${!1}
                ><wy-icon name="${this.isChecked(c.id) ? "checkbox-marked" : "checkbox-blank"}"></wy-icon
              ></wy-button>
            </wy-item>`) ?? b}`
    ), e && o.push(h`<div ${Q(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>`), o;
  }
  render() {
    return h`<div part="wy-pane wy-scroll-y wy-scroll-y-always">
      <div part="wy-pane-body">
        <div part="wy-pane-group wy-pane-group-fixed-size">
          <wy-search ${Q(this.searchRef)} @search=${(t) => this.text = t.detail.query}></wy-search>
        </div>
        <div>
          <wy-buttons tabs>
            <wy-button
              ?active=${this.agentFilter === void 0}
              @click=${() => this.agentFilter = void 0}
              kind="tab"
              small
              >${x("All")}</wy-button
            >
            <wy-button ?active=${this.agentFilter === !1} @click=${() => this.agentFilter = !1} kind="tab" small
              >${x("People")}</wy-button
            >
            <wy-button ?active=${this.agentFilter === !0} @click=${() => this.agentFilter = !0} kind="tab" small
              >${x("Agents")}</wy-button
            >
          </wy-buttons>
        </div>
        <div part="wy-pane-body"> ${this.getSelected()} ${this.getSearchResult()} </div>
      </div>
      <div part="wy-footerbar wy-footerbar-sticky">
        <div part="wy-pane-group">
          <wy-buttons reverse>
            <wy-button
              color="primary"
              @click=${() => this.dispatchSubmit()}
              ?disabled=${this.selected.length === 0 && this.select.length === 0 ? !0 : void 0}
              >${this.buttonTitle ?? x("Create")}</wy-button
            >
          </wy-buttons>
        </div>
      </div>
    </div>`;
  }
  async willUpdate(t) {
    super.willUpdate(t), t.has("weavy") && this.weavy && await this.peopleQuery.trackInfiniteQuery(
      Db(
        this.weavy,
        () => this.text,
        this.appId,
        () => this.agentFilter
      )
    );
  }
  async updated(t) {
    this.infiniteScroll.observe(this.peopleQuery.result, this.pagerRef.value), (t.has("text") || t.has("agentFilter")) && (this.select.length > 0 && (this.selected = [...this.selected, ...this.select], this.select = []), await this.peopleQuery.result?.refetch?.(), this.searchRef.value?.focusInput());
  }
}, a(hc, "WyUsersSearch"), hc);
gi.styles = [Jn, av, rn, Jr, X, Xn];
an([
  be({ context: he, subscribe: !0 }),
  D()
], gi.prototype, "weavy", 2);
an([
  u({ attribute: !1 })
], gi.prototype, "appId", 2);
an([
  u({ attribute: !1 })
], gi.prototype, "buttonTitle", 2);
an([
  D()
], gi.prototype, "agentFilter", 2);
an([
  D()
], gi.prototype, "selected", 2);
an([
  D()
], gi.prototype, "select", 2);
an([
  D()
], gi.prototype, "text", 2);
gi = an([
  B("wy-users-search"),
  ht()
], gi);
var h9 = Object.defineProperty, u9 = Object.getOwnPropertyDescriptor, d1 = /* @__PURE__ */ a((n) => {
  throw TypeError(n);
}, "__typeError$2"), na = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? u9(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && h9(t, e, r), r;
}, "__decorateClass$a"), h1 = /* @__PURE__ */ a((n, t, e) => t.has(n) || d1("Cannot " + e), "__accessCheck$2"), Xf = /* @__PURE__ */ a((n, t, e) => (h1(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$2"), p9 = /* @__PURE__ */ a((n, t, e) => t.has(n) ? d1("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$2"), Jf = /* @__PURE__ */ a((n, t, e, i) => (h1(n, t, "write to private field"), t.set(n, e), e), "__privateSet$2"), ga, uc;
let Di = (uc = class extends Te {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.showDetails = !1, this.showAddMembers = !1, this.conversationTitle = "", this.conversationTitleInput = "", this.membersQuery = new qe(this), this.handleRealtimeAppUpdated = (t) => {
      !this.conversationId || t.app.id !== this.conversationId || (this.conversationTitle = this.conversationTitleInput = t.app.name);
    }, this.handlePresenceChange = (t) => {
      if (!this.weavy)
        return;
      Array.isArray(t) || (t = [parseInt(t)]);
      const e = /* @__PURE__ */ a((i = []) => (i.forEach((r) => {
        r.presence = t.indexOf(r.id) != -1 ? "active" : "away";
      }), i), "updateMembersInApps");
      this.weavy.queryClient.setQueryData(["apps", this.conversationId], (i) => (i.members.data = e(i.members.data), i)), this.weavy.queryClient.setQueryData(["members", this.conversationId], (i) => e(i));
    }, p9(this, ga);
  }
  /** Checks whether the current or provided conversation is an agent chat. */
  isAgentChat(t) {
    return (t ?? this.conversation)?.type === st.AgentChat;
  }
  /** Checks whether the current or provided conversation is a chat room. */
  isChatRoom(t) {
    return (t ?? this.conversation)?.type === st.ChatRoom;
  }
  /** Checks whether the current or provided conversation is a private chat. */
  isPrivateChat(t) {
    return (t ?? this.conversation)?.type === st.PrivateChat;
  }
  /**
   * Adds a list of members to the conversation.
   *
   * @internal
   */
  async addMembers(t) {
    this.showAddMembers = !1, this.showDetails = !0, !(!this.weavy || !this.conversationId) && (await this.addMembersMutation?.mutate({ appId: this.conversationId, members: t.map((e) => e.id) }), await this.membersQuery.result.refetch(), await this.weavy.queryClient.invalidateQueries({ queryKey: ["apps"] }));
  }
  /**
   * Handles saving the conversation name from the conversation name input.
   *
   * @internal
   */
  async handleSaveConversationName() {
    if (!this.weavy || !this.conversationId)
      return;
    const t = this.conversationTitleInput.trim() === "" ? null : this.conversationTitleInput.trim();
    await this.updateConversationMutation?.mutate({ appId: this.conversationId, name: t });
  }
  /**
   * Updates the avatar with an uploaded blob picture.
   *
   * @internal
   */
  async handleAvatarUploaded(t) {
    !this.weavy || !this.conversationId || await this.updateConversationMutation?.mutate({
      appId: this.conversationId,
      blobId: t.id,
      thumbnailUrl: t.thumbnail_url
    });
  }
  /**
   * Clears the set avatar for the conversation.
   *
   * @internal
   */
  async clearAvatar() {
    !this.weavy || !this.conversationId || await this.updateConversationMutation?.mutate({ appId: this.conversationId, blobId: null, thumbnailUrl: null });
  }
  /**
   * Updates the access for a member in the conversation.
   *
   * @internal
   */
  async updateMember(t, e) {
    !this.weavy || !this.conversationId || (await this.updateMemberMutation?.mutate({
      appId: this.conversationId,
      userId: t,
      access: e
    }), await this.membersQuery.result.refetch());
  }
  /**
   * Removes the current or provided member from the conversation.
   *
   * If no memberId is provided, the current user leaves the conversation and the component state is cleared.
   *
   * @internal
   */
  async leaveConversation(t) {
    !this.weavy || !this.conversationId || !this.user || (t && await this.leaveConversationMutation?.mutate({
      appId: this.conversationId,
      members: [t]
    }), !t || t === this.user.id ? (this.showDetails = !1, this.conversation = void 0, this.conversationId = void 0, this.dispatchAction(Ee.Select, null)) : await this.membersQuery.result.refetch(), await this.weavy.queryClient.invalidateQueries({ queryKey: ["apps"] }));
  }
  /**
   * Triggers `wy-action` event.
   *
   * @param action - The performed action.
   * @param conversation - The conversation to select or `null` to clear.
   * @returns Whether the event was successful.
   *
   * @internal
   */
  dispatchAction(t, e) {
    this.conversationId = e?.id;
    const i = new CustomEvent("wy-action", { detail: { action: t, app: e }, bubbles: !0, composed: !0 });
    return this.dispatchEvent(i);
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("weavy") && this.weavy && (this.leaveConversationMutation = tv(this.weavy), this.addMembersMutation = Ib(this.weavy), this.updateConversationMutation = ev(this.weavy), this.updateMemberMutation = zb(this.weavy)), t.has("conversationId") && (this.showDetails = !1), (t.has("weavy") || t.has("conversationId")) && this.weavy)
      if ((e = Xf(this, ga)) == null || e.call(this), this.conversationId) {
        await this.membersQuery.trackQuery(
          rv(this.weavy, this.conversationId, {
            initialData: /* @__PURE__ */ a(() => {
              if (this.conversationId)
                return this.weavy?.queryClient.getQueryData(["apps", this.conversationId])?.members;
            }, "initialData")
          })
        );
        const i = `a${this.conversationId}`;
        this.weavy.subscribe(i, "app_updated", this.handleRealtimeAppUpdated), this.weavy.subscribe(null, "online", this.handlePresenceChange), Jf(this, ga, () => {
          this.weavy?.unsubscribe(i, "app_updated", this.handleRealtimeAppUpdated), this.weavy?.unsubscribe(null, "online", this.handlePresenceChange), Jf(this, ga, void 0);
        });
      } else
        this.membersQuery.untrackQuery();
    t.has("conversation") && this.conversation && (this.conversationTitleInput = this.conversationTitle = this.conversation.name);
  }
  render() {
    const { data: t } = this.membersQuery.result ?? {}, e = (t?.data || []).filter((r) => r.access === br.Admin).length, i = this.user && this.isPrivateChat() ? (this.conversation?.members?.data || []).filter((r) => r.id !== this.user?.id)?.[0] ?? this.user : null;
    return this.conversationId ? h`
          <wy-titlebar outer header floating part="wy-conversation-titlebar">
            <slot slot="icon" name="icon"><span></span></slot>
            ${this.conversation && this.user ? h`
                  ${this.conversation.type === st.PrivateChat ? h`<wy-presence
                        slot="title-section"
                        placement="text"
                        .status=${i?.presence}
                        id=${dt(i?.id)}
                      ></wy-presence>` : b}
                  <wy-titlebar-text slot="title-section">${this.conversationTitle}</wy-titlebar-text>
                ` : b}
            ${this.isChatRoom() ? h`<wy-button
                  slot="actions"
                  kind="icon"
                  @click=${() => this.showDetails = !0}
                  title="${x("Details")}"
                >
                  <wy-icon name="information"></wy-icon>
                </wy-button>` : b}
          </wy-titlebar>

          <!-- details modal -->
          ${this.weavy ? h`
                <wy-overlay
                  part="wy-conversation-details"
                  .show=${this.showDetails}
                  @close=${() => {
      this.showDetails = !1;
    }}
                >
                  <wy-titlebar header slot="header">
                    <wy-button
                      slot="icon"
                      kind="icon"
                      @click=${() => {
      this.showDetails = !1;
    }}
                    >
                      <wy-icon name="close"></wy-icon>
                    </wy-button>
                    <span slot="title">${this.conversationTitle}</span>
                  </wy-titlebar>
                  <div part="wy-scroll-y">
                    ${this.showDetails && this.conversation && this.user ? h`
                          <wy-avatar-header>
                            ${this.isChatRoom() ? h`
                                  <wy-upload
                                    @blob-uploaded=${(r) => this.handleAvatarUploaded(r.detail.blob)}
                                    .accept=${"image/*"}
                                    .label=${x("Select picture")}
                                  >
                                    <div slot="placeholder">
                                      ${this.conversation.avatar_url ? h`<wy-avatar .size=${96} src=${this.conversation.avatar_url}></wy-avatar>` : h`<wy-avatar-group
                                            .members=${t?.data}
                                            title=${this.conversation.name}
                                            .size=${96}
                                          ></wy-avatar-group>`}
                                    </div>
                                    ${this.conversation.avatar_url ? h`<div slot="action"
                                          ><wy-button @click=${() => this.clearAvatar()}
                                            >${x("Remove picture")}</wy-button
                                          ></div
                                        >` : b}
                                  </wy-upload>
                                ` : h`
                                  <wy-avatar
                                    src=${dt(i?.avatar_url)}
                                    name=${dt(i?.name)}
                                    presence=${i?.presence || "away"}
                                    ?isAgent=${i?.is_agent}
                                    id=${dt(i?.id)}
                                    size=${96}
                                  ></wy-avatar>
                                `}
                          </wy-avatar-header>
                          ${this.isChatRoom() ? h`
                                <div part="wy-pane-group">
                                  <label part="wy-label" for="roomName">${x("Room name")}</label>

                                  <input
                                    id="roomName"
                                    part="wy-input"
                                    .value=${this.conversationTitleInput}
                                    @input=${(r) => {
      this.conversationTitleInput = r.target.value;
    }}
                                    @keyup=${Hb}
                                    @blur=${() => this.handleSaveConversationName()}
                                  />

                                  <div part="wy-description">
                                    ${x("Changing the name of a group chat changes it for everyone.")}
                                  </div>
                                  <br />
                                  <label part="wy-label">${x("Members")}</label>
                                  ${t ? h`
                                        <wy-item-list>
                                          ${t.data?.map(
      (r) => h`
                                              <wy-item>
                                                <wy-avatar
                                                  slot="image"
                                                  .src=${r.avatar_url}
                                                  .name=${r.name}
                                                  .description=${r.comment}
                                                  .isAgent=${r.is_agent}
                                                  size=${32}
                                                ></wy-avatar>
                                                <span slot="title">
                                                  ${r.name}
                                                  ${r.access === br.Admin ? h` <wy-icon
                                                        size="20"
                                                        inline
                                                        name="shield-star"
                                                        title=${x("Admin")}
                                                      ></wy-icon>` : b}
                                                </span>
                                                ${this.user && this.user.id === r.id && !Ac(_n.Admin, this.conversation?.permissions) ? h` <wy-button
                                                      slot="actions"
                                                      @click=${() => this.leaveConversation(r.id)}
                                                      title=${x("Leave conversation")}
                                                      kind="icon"
                                                    >
                                                      <wy-icon name="close"></wy-icon>
                                                    </wy-button>` : Ac(_n.Admin, this.conversation?.permissions) ? h`<wy-dropdown slot="actions">
                                                      <wy-dropdown-item
                                                        @click=${() => this.leaveConversation(r.id)}
                                                      >
                                                        <wy-icon name="account-minus"></wy-icon>
                                                        ${this.user && this.user.id === r.id ? x("Leave conversation") : x("Remove member")}
                                                      </wy-dropdown-item>
                                                      ${e > 1 && r.access === br.Admin ? h`<wy-dropdown-item
                                                            @click=${() => this.updateMember(r.id, br.Write)}
                                                          >
                                                            <wy-icon name="shield-star-outline"></wy-icon>
                                                            ${x("Remove as admin")}
                                                          </wy-dropdown-item>` : r.access !== br.Admin ? h`<wy-dropdown-item
                                                            @click=${() => this.updateMember(r.id, br.Admin)}
                                                          >
                                                            <wy-icon name="shield-star"></wy-icon>
                                                            ${x("Make admin")}
                                                          </wy-dropdown-item>` : b}
                                                    </wy-dropdown>` : b}
                                              </wy-item>
                                            `
    ) ?? b}
                                        </wy-item-list>
                                      ` : b}
                                  <div>
                                    <wy-button
                                      part="wy-conversation-details-add-members-button"
                                      kind="filled"
                                      color="primary"
                                      @click=${() => {
      this.showDetails = !1, this.showAddMembers = !0;
    }}
                                      title=${x("Add members")}
                                    >
                                      ${x("Add members")}
                                    </wy-button>
                                  </div>
                                </div>
                              ` : b}
                        ` : b}
                  </div>
                </wy-overlay>
              ` : b}

          <!-- add members modal -->
          ${this.weavy ? h`
                <wy-overlay
                  part="wy-conversation-add-members"
                  .show=${this.showAddMembers}
                  @close=${() => {
      this.showAddMembers = !1;
    }}
                >
                  <wy-titlebar header>
                    <wy-button
                      slot="icon"
                      kind="icon"
                      @click=${() => {
      this.showAddMembers = !1;
    }}
                    >
                      <wy-icon name="close"></wy-icon>
                    </wy-button>
                    <span slot="title">${x("Add members")}</span>
                  </wy-titlebar>
                  ${this.showAddMembers ? h`
                        <wy-users-search
                          .buttonTitle=${x("Add members")}
                          .appId=${this.conversationId}
                          @submit=${(r) => this.addMembers(r.detail.members)}
                        ></wy-users-search>
                      ` : b}
                </wy-overlay>
              ` : b}
        ` : b;
  }
  disconnectedCallback() {
    var t;
    (t = Xf(this, ga)) == null || t.call(this), super.disconnectedCallback();
  }
}, a(uc, "WyConversationHeader"), uc);
ga = /* @__PURE__ */ new WeakMap();
Di.styles = [rn, Xn, Jn, X];
na([
  u({ attribute: !1 })
], Di.prototype, "conversationId", 2);
na([
  u({ attribute: !1 })
], Di.prototype, "conversation", 2);
na([
  D()
], Di.prototype, "showDetails", 2);
na([
  D()
], Di.prototype, "showAddMembers", 2);
na([
  D()
], Di.prototype, "conversationTitle", 2);
na([
  D()
], Di.prototype, "conversationTitleInput", 2);
Di = na([
  B("wy-conversation-header"),
  ht()
], Di);
var y9 = Object.defineProperty, w9 = Object.getOwnPropertyDescriptor, al = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? w9(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && y9(t, e, r), r;
}, "__decorateClass$9"), pc;
let pr = (pc = class extends jt {
  constructor() {
    super(...arguments), this.componentFeatures = new le(Uc), this.theme = new _e(this, pr.styles), this.unreadConversationsController = new Sc(this), this.createConversationController = new _c(this), this.componentTypes = [st.ChatRoom, st.PrivateChat], this.conversationId = null, this.conversationQuery = new qe(this), this.persistState = new Sn(this), this.conversationListRef = nt(), this.conversationNewRef = nt();
  }
  set agent(t) {
    super.agent = t, this._agentUid ? (this.componentTypes = [st.AgentChat], this.componentFeatures = new le(
      Uy,
      this.componentFeatures.allowedFeatures()
    )) : (this.componentTypes = [st.ChatRoom, st.PrivateChat], this.componentFeatures = new le(
      Uc,
      this.componentFeatures.allowedFeatures()
    )), this.conversationId = null;
  }
  get agent() {
    return super.agent;
  }
  /** Current unread conversation count. */
  get unread() {
    return this.unreadConversationsController.unread;
  }
  /**
   * Creates a new conversation.
   *
   * When in agent mode, a conversation is created instantly.
   *
   * @param members - Optional array of member ids or member uids.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select member dialog to let the user select members for creating a conversation.
   *
   * @returns Promise resolving to any selected member ids or uids.
   */
  async selectMembers() {
    return this.conversationId = null, await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("weavy") || t.has("agent") || t.has("user")) && this.weavy && this.user && this.persistState.observe(
      [{ name: "conversationId", override: !1 }],
      this.agent || "messenger",
      `u${this.user?.id}`,
      (e) => {
        if (e.has("conversationId") && this.conversationId) {
          const i = new CustomEvent("wy-action", {
            detail: {
              action: Ee.Select,
              app: { id: this.conversationId }
            },
            bubbles: !0,
            composed: !0
          });
          this.dispatchEvent(i);
        }
      }
    ), t.has("link") && this.link?.app && (this.conversationId = this.link.app.id), (t.has("conversationId") || t.has("weavy")) && this.weavy && (this.conversationId ? this.conversationQuery.trackQuery(
      iv(this.weavy, this.conversationId, this.componentTypes)
    ) : this.conversationQuery.untrackQuery()), t.has("agent") && (this.createConversationController.agent = this.agent), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversationsController.track(this.componentTypes, this.agent);
  }
  render() {
    const { isPending: t } = this.weavy?.network ?? { isPending: !0 }, { data: e } = this.conversationQuery.result ?? {}, i = this.conversationListRef.value?.conversationsQuery.result.data?.pages[0].count || 0;
    return h`
      <div part="wy-messenger-layout">
        <div
          part="wy-messenger-conversation-list wy-scroll-y"
          data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
        >
          <slot name="header"></slot>
          <wy-conversation-list
            ${Q(this.conversationListRef)}
            .conversationTypes=${this.componentTypes}
            .agent=${this.agent}
            conversationId=${dt(this.conversationId !== null ? this.conversationId : void 0)}
            @wy-action=${(r) => {
      !r.defaultPrevented && r.detail.action === Ee.Select && r.detail.app !== void 0 && (this.conversationId = r.detail.app?.id);
    }}
          >
            <wy-conversation-new
              slot="actions"
              .agent=${this.agent}
              @create=${async (r) => {
      const s = await this.createConversationController.create(r.detail.members);
      s && (this.conversationId = s.id);
    }}
              ${Q(this.conversationNewRef)}
            >
              <slot name="conversation-new"></slot>
            </wy-conversation-new>
            <slot name="actions" slot="actions"></slot>
          </wy-conversation-list>
        </div>

        <div
          part="wy-messenger-conversation wy-scroll-y"
          data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
        >
          <wy-conversation-header
            .conversationId=${this.conversationId || void 0}
            .conversation=${e}
            @wy-action=${(r) => {
      !r.defaultPrevented && r.detail.action === Ee.Select && r.detail.app !== void 0 && (this.conversationId = r.detail.app?.id);
    }}
            ?hidden=${!this.conversationId}
          >
            <span slot="icon" part="wy-close-conversation">
              <wy-button kind="inline" @click=${() => this.conversationId = null}>
                <wy-icon name="back">
                  <wy-badge
                    reveal
                    .count=${this.unreadConversationsController.isUnreadPending ? NaN : this.unreadConversationsController.unread}
                  ></wy-badge>
                </wy-icon>
              </wy-button>
            </span>
          </wy-conversation-header>

          ${this.conversationId ? h`<wy-conversation
                .conversationId=${this.conversationId}
                .conversation=${e}
                .agentInstructions=${this.instructions}
                .placeholder=${this.placeholder ?? (this.agent ? x("Ask anything...") : void 0)}
                .header=${!this.agent}
              ></wy-conversation>` : i ? h`<wy-empty noNetwork>${x("Select a conversation")}</wy-empty>` : b}
        </div>

        <wy-context-data-progress></wy-context-data-progress>
      </div>
    `;
  }
}, a(pc, "WyMessenger"), pc);
pr.styles = [se, Jn, qy, wr, Fe];
al([
  u({ attribute: !1 })
], pr.prototype, "componentTypes", 2);
al([
  u({ type: String })
], pr.prototype, "agent", 1);
al([
  u()
], pr.prototype, "instructions", 2);
al([
  u()
], pr.prototype, "placeholder", 2);
al([
  u({ type: Number })
], pr.prototype, "conversationId", 2);
pr = al([
  B("wy-messenger"),
  ht()
], pr);
var f9 = Object.defineProperty, m9 = Object.getOwnPropertyDescriptor, xi = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? m9(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && f9(t, e, r), r;
}, "__decorateClass$8"), yc;
let Ke = (yc = class extends jt {
  constructor() {
    super(...arguments), this.componentFeatures = new le(Uc), this.theme = new _e(this, Ke.styles), this.unreadConversationsController = new Sc(this), this.createConversationController = new _c(this), this.overlay = "drawer", this.badge = "compact", this.badgePosition = "top-right", this.componentTypes = [st.ChatRoom, st.PrivateChat], this.conversationId = null, this.show = !1, this.maximized = !1, this.conversationQuery = new qe(this), this.persistState = new Sn(this), this.messengerRef = nt(), this.conversationListRef = nt(), this.conversationNewRef = nt();
  }
  /** Check visibility on the Messenger */
  get visibilityElement() {
    return this.messengerRef.value;
  }
  set agent(t) {
    super.agent = t, this._agentUid ? (this.componentTypes = [st.AgentChat], this.componentFeatures = new le(
      Uy,
      this.componentFeatures.allowedFeatures()
    )) : (this.componentTypes = [st.ChatRoom, st.PrivateChat], this.componentFeatures = new le(
      Uc,
      this.componentFeatures.allowedFeatures()
    )), this.conversationId = null;
  }
  get agent() {
    return super.agent;
  }
  /** Current unread conversation count. */
  get unread() {
    return this.unreadConversationsController.unread;
  }
  /**
   * Creates a new conversation.
   *
   * - When in agent mode, a conversation is created instantly.
   *
   * @param members {(number|string)[] | undefined} - Optional array of member id or member uid.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select member dialog to let the user select members for creating a conversation.
   *
   * @returns Any selected member ids or uids.
   */
  async selectMembers() {
    return this.conversationId = null, await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("weavy") || t.has("agent") || t.has("user")) && this.weavy && this.user && this.persistState.observe(
      [{ name: "conversationId", override: !1 }],
      this.agent || "messenger",
      `u${this.user?.id}`,
      (e) => {
        if (e.has("conversationId") && this.conversationId) {
          const i = new CustomEvent("wy-action", {
            detail: {
              action: Ee.Select,
              app: { id: this.conversationId }
            },
            bubbles: !0,
            composed: !0
          });
          this.dispatchEvent(i);
        }
      }
    ), t.has("link") && this.link?.app && (this.conversationId = this.link.app.id), (t.has("conversationId") || t.has("weavy")) && this.weavy && (this.conversationId ? this.conversationQuery.trackQuery(iv(this.weavy, this.conversationId, this.componentTypes)) : this.conversationQuery.untrackQuery()), t.has("agent") && (this.createConversationController.agent = this.agent), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversationsController.track(this.componentTypes, this.agent);
  }
  render() {
    const { isPending: t } = this.weavy?.network ?? { isPending: !0 }, { data: e } = this.conversationQuery.result ?? {}, i = this.conversationListRef.value?.conversationsQuery.result.data?.pages[0].count || 0;
    return h`
      <wy-button kind="icon" ?active=${this.show} @click=${() => this.show = !this.show}>
        <wy-icon name="message-text">
          ${this.user && this.badge !== "none" ? h`
                <wy-badge
                  appearance=${this.badge}
                  position=${this.badgePosition}
                  .count=${this.unreadConversationsController.isUnreadPending ? NaN : this.unreadConversationsController.unread}
                ></wy-badge>
              ` : b}
        </wy-icon>
      </wy-button>

      ${this.overlay !== "none" ? h`<wy-overlay
            type=${this.overlay}
            .show=${this.show}
            .maximized=${this.maximized}
            @close=${() => this.show = !1}
            noHeader
          >
            <div ${Q(this.messengerRef)} part="wy-messenger-layout wy-messenger-overlay-container">
              <div
                part="wy-messenger-conversation-list wy-scroll-y"
                data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
              >
                <slot name="header">
                  <wy-titlebar floating header outer>
                    <wy-button kind="icon" slot="icon" @click=${() => this.show = !1}
                      ><wy-icon name="close"></wy-icon
                    ></wy-button>
                    <slot name="title" slot="title">${x("Conversations")}</slot>
                    <slot name="actions" slot="actions"></slot>
                    <wy-button kind="icon" slot="actions" @click=${() => this.maximized = !this.maximized}
                      ><wy-icon name=${this.maximized ? "arrow-collapse" : "arrow-expand"}></wy-icon
                    ></wy-button>
                  </wy-titlebar>
                </slot>

                <wy-conversation-list
                  ${Q(this.conversationListRef)}
                  .conversationTypes=${this.componentTypes}
                  .agent=${this.agent}
                  conversationId=${dt(this.conversationId !== null ? this.conversationId : void 0)}
                  @wy-action=${(r) => {
      !r.defaultPrevented && r.detail.action === Ee.Select && r.detail.app !== void 0 && (this.conversationId = r.detail.app?.id);
    }}
                >
                  <wy-conversation-new
                    slot="actions"
                    .agent=${this.agent}
                    @create=${async (r) => {
      const s = await this.createConversationController.create(r.detail.members);
      s && (this.conversationId = s.id);
    }}
                    ${Q(this.conversationNewRef)}
                  >
                    <slot name="conversation-new"></slot>
                  </wy-conversation-new>
                </wy-conversation-list>
              </div>

              <div
                part="wy-messenger-conversation wy-scroll-y"
                data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
              >
                <wy-conversation-header
                  .conversationId=${this.conversationId || void 0}
                  .conversation=${e}
                  @wy-action=${(r) => {
      !r.defaultPrevented && r.detail.action === Ee.Select && r.detail.app !== void 0 && (this.conversationId = r.detail.app?.id);
    }}
                  ?hidden=${!this.conversationId}
                >
                  <span slot="icon" part="wy-close-conversation">
                    <wy-button kind="icon" @click=${() => this.conversationId = null}>
                      <wy-icon name="back"></wy-icon>
                    </wy-button>
                    <wy-badge
                      reveal
                      .count=${this.unreadConversationsController.isUnreadPending ? NaN : this.unreadConversationsController.unread}
                    ></wy-badge>
                  </span>
                </wy-conversation-header>

                ${this.conversationId ? h`<wy-conversation
                      .conversationId=${this.conversationId}
                      .conversation=${e}
                      .agentInstructions=${this.instructions}
                      .placeholder=${this.placeholder ?? (this.agent ? x("Ask anything...") : void 0)}
                      .header=${!this.agent}
                    ></wy-conversation>` : i ? h`<wy-empty noNetwork>${x("Select a conversation")}</wy-empty>` : b}
              </div>

              <wy-context-data-progress></wy-context-data-progress>
            </div>
          </wy-overlay> ` : b}
    `;
  }
}, a(yc, "WyMessengerButton"), yc);
Ke.styles = [X, se, Fe, Jn, qy];
xi([
  u({ type: String })
], Ke.prototype, "overlay", 2);
xi([
  u({ type: String })
], Ke.prototype, "badge", 2);
xi([
  u({ type: String })
], Ke.prototype, "badgePosition", 2);
xi([
  u({ attribute: !1 })
], Ke.prototype, "componentTypes", 2);
xi([
  u({ type: String })
], Ke.prototype, "agent", 1);
xi([
  u()
], Ke.prototype, "instructions", 2);
xi([
  u()
], Ke.prototype, "placeholder", 2);
xi([
  u({ type: Number })
], Ke.prototype, "conversationId", 2);
xi([
  D()
], Ke.prototype, "show", 2);
xi([
  D()
], Ke.prototype, "maximized", 2);
Ke = xi([
  B("wy-messenger-button"),
  ht()
], Ke);
var v9 = Object.getOwnPropertyDescriptor, g9 = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? v9(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = o(r) || r);
  return r;
}, "__decorateClass$7"), wc;
let ph = (wc = class extends jt {
  constructor() {
    super(...arguments), this.theme = new _e(this, ph.styles), this.createConversationController = new _c(this), this.conversationNewRef = nt();
  }
  /**
   * Creates a new conversation.
   *
   * When in agent mode, the conversation is created instantly.
   *
   * @param members - Optional array of member ids or member uids.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select-member dialog.
   *
   * @returns Promise resolving to the selected member ids or uids.
   */
  async selectMembers() {
    return await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), t.has("agent") && (this.createConversationController.agent = this.agent);
  }
  render() {
    return h`
      <wy-conversation-new
        .agent=${this.agent}
        @create=${async (t) => {
      await this.createConversationController.create(t.detail.members);
    }}
        ${Q(this.conversationNewRef)}
      ></wy-conversation-new>
    `;
  }
}, a(wc, "WyMessengerNew"), wc);
ph.styles = [se, Jn, qy, wr, Fe];
ph = g9([
  B("wy-messenger-new")
], ph);
var b9 = Object.defineProperty, x9 = Object.getOwnPropertyDescriptor, Pd = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? x9(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && b9(t, e, r), r;
}, "__decorateClass$6"), fc;
let Gr = (fc = class extends jt {
  constructor() {
    super(...arguments), this.theme = new _e(this, Gr.styles), this.unreadConversations = new Sc(this), this.componentTypes = [st.ChatRoom, st.PrivateChat], this.badge = "count", this.badgePosition = "inline";
  }
  set agent(t) {
    super.agent = t, this._agentUid ? this.componentTypes = [st.AgentChat] : this.componentTypes = [st.ChatRoom, st.PrivateChat];
  }
  get agent() {
    return super.agent;
  }
  /**
   * Current unread conversation count.
   */
  get unread() {
    return this.unreadConversations.unread;
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversations.track(this.componentTypes, this.agent);
  }
  render() {
    return this.user && this.badge !== "none" ? h`
          <wy-badge
            appearance=${this.badge}
            position=${this.badgePosition}
            .count=${this.unreadConversations.isUnreadPending ? NaN : this.unreadConversations.unread}
          ></wy-badge>
        ` : b;
  }
}, a(fc, "WyMessengerBadge"), fc);
Gr.styles = [o1, se, Fe];
Pd([
  u({ attribute: !1 })
], Gr.prototype, "componentTypes", 2);
Pd([
  u({ type: String })
], Gr.prototype, "badge", 2);
Pd([
  u({ type: String })
], Gr.prototype, "badgePosition", 2);
Pd([
  u({ type: String })
], Gr.prototype, "agent", 1);
Gr = Pd([
  B("wy-messenger-badge")
], Gr);
const u1 = j`[part~=wy-conversations]{position:relative;display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-conversation-list]{display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}`;
var C9 = Object.defineProperty, $9 = Object.getOwnPropertyDescriptor, Kh = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? $9(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && C9(t, e, r), r;
}, "__decorateClass$5"), mc;
let jc = (mc = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.typing = new eh(this);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("appId") && (this.typing.appId = this.appId), t.has("userId") && (this.typing.userId = this.userId);
  }
  render() {
    const { names: t, ellipsis: e } = this.typing;
    let i;
    if (t.length === 1) {
      const r = t[0];
      i = x(gt`${r} is typing${e}`, { desc: "A is typing..." });
    } else if (t.length > 1) {
      const r = new Intl.ListFormat(this.weavy?.locale, { style: "long", type: "conjunction" }).format(
        t
      );
      i = x(gt`${r} are typing${e}`, {
        desc: "A, B and C are typing..."
      });
    }
    return i ? h`<span>${i}</span>` : h`<slot></slot>`;
  }
}, a(mc, "WyTyping"), mc);
Kh([
  be({ context: he, subscribe: !0 }),
  D()
], jc.prototype, "weavy", 2);
Kh([
  u({ attribute: !0, type: Number })
], jc.prototype, "appId", 2);
Kh([
  u({ attribute: !0, type: Number })
], jc.prototype, "userId", 2);
jc = Kh([
  B("wy-typing"),
  ht()
], jc);
var k9 = Object.defineProperty, P9 = Object.getOwnPropertyDescriptor, p1 = /* @__PURE__ */ a((n) => {
  throw TypeError(n);
}, "__typeError$1"), Ze = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? P9(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && k9(t, e, r), r;
}, "__decorateClass$4"), y1 = /* @__PURE__ */ a((n, t, e) => t.has(n) || p1("Cannot " + e), "__accessCheck$1"), tm = /* @__PURE__ */ a((n, t, e) => (y1(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$1"), _9 = /* @__PURE__ */ a((n, t, e) => t.has(n) ? p1("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$1"), em = /* @__PURE__ */ a((n, t, e, i) => (y1(n, t, "write to private field"), t.set(n, e), e), "__privateSet$1"), ba, vc;
let Se = (vc = class extends it {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.unread = !1, this.avatarUrl = "", this.hideAvatar = !1, this.name = "", this.type = st.PrivateChat, this.selected = !1, this.starred = !1, this.pinned = !1, this.handleMessageCreated = (t) => {
      !this.user || !this.weavy || (Zt(this.weavy.queryClient, ["apps", t.message.app.id], void 0, (e) => {
        e.last_message = t.message, e.is_unread = t.message.created_by.id !== this.user?.id;
      }), yt(
        this.weavy.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.message.app.id,
        (e) => {
          e.last_message = t.message, e.is_unread = t.message.created_by.id !== this.user?.id;
        }
      ));
    }, this.handleConversationUpdated = () => {
      this.weavy?.queryClient.invalidateQueries({ queryKey: ["apps"], exact: !1 });
    }, this.handleConversationMarked = (t) => {
      this.user && t.actor.id === this.user.id && this.weavy?.queryClient.invalidateQueries({ queryKey: ["apps"], exact: !1 });
    }, _9(this, ba);
  }
  /**
   * Trigger `selected` event.
   *
   * @returns Whether the event was dispatched successfully.
   */
  dispatchSelected() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("selected", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Trigger `star` event.
   *
   * @param star - Whether the conversation should be starred.
   * @returns Whether the event was dispatched successfully.
   */
  dispatchStar(t) {
    if (!this.conversationId)
      return;
    const e = new CustomEvent("star", {
      detail: { id: this.conversationId, star: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Trigger `pin` event.
   *
   * @param pin - Whether the conversation should be pinned.
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchPin(t) {
    if (!this.conversationId)
      return;
    const e = new CustomEvent("pin", {
      detail: { id: this.conversationId, pin: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Trigger `mark` event for marking the conversation as read/unread.
   *
   * @param mark - Whether the conversation should be marked as read.
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchMarked(t) {
    if (!this.conversationId)
      return;
    const e = new CustomEvent("mark", {
      detail: { id: this.conversationId, messageId: t ? this.lastMessage?.id : null }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Triggers `leave` event when the current user is leaving the conversation.
   *
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchLeaveConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("leave", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Triggers `remove` when the conversation should be removed.
   *
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchRemoveConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("remove", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Triggers `trash` event when the conversation should be trashed.
   *
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchTrashConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("trash", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  willUpdate(t) {
    var e;
    if (super.willUpdate(t), (t.has("weavy") || t.has("conversationId")) && this.weavy && this.conversationId) {
      (e = tm(this, ba)) == null || e.call(this);
      const i = `a${this.conversationId}`;
      this.weavy.subscribe(i, "app_updated", this.handleConversationUpdated), this.weavy.subscribe(i, "member_added", this.handleConversationUpdated), this.weavy.subscribe(i, "message_created", this.handleMessageCreated), this.weavy.subscribe(i, "app_marked", this.handleConversationMarked), em(this, ba, () => {
        this.weavy?.unsubscribe(i, "app_updated", this.handleConversationUpdated), this.weavy?.unsubscribe(i, "member_added", this.handleConversationUpdated), this.weavy?.unsubscribe(i, "message_created", this.handleMessageCreated), this.weavy?.unsubscribe(i, "app_marked", this.handleConversationMarked), em(this, ba, void 0);
      });
    }
  }
  render() {
    const t = this.lastMessage?.created_at ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.lastMessage.created_at)
    ) : "", e = this.lastMessage?.created_at ? tl(this.weavy?.locale, new Date(this.lastMessage.created_at)) : "", i = this.type === st.PrivateChat && this.user ? (this.members?.data || []).filter((r) => r.id !== this.user?.id)?.[0] ?? this.user : null;
    return h`
      <wy-item
        part="wy-conversation-item"
        size="lg"
        interactive
        outer
        status=${this.unread ? "unread" : void 0}
        ?selected=${this.selected}
        tabindex="0"
        actionsPosition="bottom"
        @click=${(r) => (r.preventDefault(), this.dispatchSelected())}
        @keydown=${ve}
        @keyup=${Ie}
      >
        ${this.type !== st.AgentChat ? this.avatarUrl ? h`<wy-avatar slot="image" .size=${48} src=${this.avatarUrl}></wy-avatar>` : this.type == st.ChatRoom ? h` <wy-avatar-group
                slot="image"
                .members=${this.members?.data}
                title=${this.name}
                .size=${48}
              ></wy-avatar-group>` : h`
                <wy-avatar
                  slot="image"
                  src=${dt(i?.avatar_url)}
                  name=${dt(i?.name)}
                  description=${dt(i?.comment)}
                  presence=${i?.presence || "away"}
                  ?isAgent=${i?.is_agent}
                  id=${dt(i?.id)}
                  size=${48}
                ></wy-avatar>
              ` : b}

        <span slot="title">${this.name || this.lastMessage?.plain || x("Untitled conversation")}</span>
        ${this.lastMessage ? h`
              <time slot="meta" datetime=${this.lastMessage.created_at.toString()} title=${t}
                >${e}</time
              >
            ` : b}
        <span slot="text">
          ${this.user ? h`
                <wy-typing appId=${this.conversationId} userId=${this.user.id}>
                  ${this.lastMessage ? h`
                        ${this.user.id === this.lastMessage.created_by.id ? h`${x("You")}: ` : b}
                        ${this.members.count > 2 && this.user.id !== this.lastMessage?.created_by.id ? h`${this.lastMessage?.created_by.name}: ` : b}
                      ` : b}
                  ${this.lastMessage?.text ? h`<span>${this.lastMessage.plain}</span>` : b}
                  ${!this.lastMessage?.text && (this.lastMessage?.attachments?.count || 0) > 0 ? h`<wy-icon kind="text-icon" name="attachment"></wy-icon>` : b}
                  ${!this.lastMessage?.text && this.lastMessage?.meeting?.id ? h`<wy-icon kind="text-icon" name="video"></wy-icon>` : b}
                  ${!this.lastMessage?.text && (this.lastMessage?.options?.count || 0) > 0 ? h`<wy-icon kind="text-icon" name="poll"></wy-icon>` : b}
                  ${this.lastMessage ? b : h`&nbsp;`}
                </wy-typing>
              ` : b}
        </span>

        ${this.starred ? h`<wy-button
              small
              slot="actions"
              kind="icon"
              @click=${(r) => {
      r.stopPropagation(), this.dispatchStar(!1);
    }}
            >
              <wy-icon name="star" size=${24} color="yellow"></wy-icon>
            </wy-button>` : b}
        ${this.pinned ? h`<wy-button
              small
              slot="actions"
              kind="icon"
              @click=${(r) => {
      r.stopPropagation(), this.dispatchPin(!1);
    }}
            >
              <wy-icon name="pin" size=${20} color=""></wy-icon>
            </wy-button>` : b}
 
        <wy-dropdown small slot="actions" directionX="left">
          <wy-dropdown-item @click=${() => this.dispatchMarked(this.unread)}>
            <wy-icon name=${this.unread ? "read" : "unread"}></wy-icon>
            ${this.unread ? x("Mark as read") : x("Mark as unread")}
          </wy-dropdown-item>
          <wy-dropdown-item @click=${() => this.dispatchPin(!this.pinned)}>
            <wy-icon name=${this.pinned ? "unpin" : "pin"}></wy-icon>
            ${this.pinned ? x("Unpin") : x("Pin")}
          </wy-dropdown-item>
          <wy-dropdown-item @click=${() => this.dispatchStar(!this.starred)}>
            <wy-icon name=${this.starred ? "unstar" : "star"}></wy-icon>
            ${this.starred ? x("Unstar") : x("Star")}
          </wy-dropdown-item>
          ${this.type === st.PrivateChat ? h`<wy-dropdown-item @click=${() => this.dispatchRemoveConversation()}>
                <wy-icon name="trashcan"></wy-icon>
                ${x("Delete")}
              </wy-dropdown-item>` : b}
          ${this.type === st.ChatRoom ? h`<wy-dropdown-item @click=${() => this.dispatchLeaveConversation()}>
                <wy-icon name="account-minus"></wy-icon>
                ${x("Leave")}
              </wy-dropdown-item>` : b}
          ${this.type === st.AgentChat ? h`
                <wy-dropdown-item @click=${() => this.dispatchTrashConversation()}>
                  <wy-icon name="trashcan"></wy-icon>
                  ${x("Delete")}
                </wy-dropdown-item>
              ` : b}
        </wy-dropdown>
      </wy-item>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.weavy && this.requestUpdate("weavy");
  }
  disconnectedCallback() {
    var t;
    (t = tm(this, ba)) == null || t.call(this), super.disconnectedCallback();
  }
}, a(vc, "WyConversationItem"), vc);
ba = /* @__PURE__ */ new WeakMap();
Se.styles = [u1];
Ze([
  be({ context: he, subscribe: !0 }),
  D()
], Se.prototype, "weavy", 2);
Ze([
  be({ context: xh, subscribe: !0 }),
  D()
], Se.prototype, "user", 2);
Ze([
  u({ attribute: !0, type: Number })
], Se.prototype, "conversationId", 2);
Ze([
  u({ attribute: !0, type: Boolean, reflect: !0 })
], Se.prototype, "unread", 2);
Ze([
  u({ attribute: !0 })
], Se.prototype, "avatarUrl", 2);
Ze([
  u({ attribute: !0, type: Boolean, reflect: !0 })
], Se.prototype, "hideAvatar", 2);
Ze([
  u({ attribute: !0 })
], Se.prototype, "name", 2);
Ze([
  u({ attribute: !0, type: String })
], Se.prototype, "type", 2);
Ze([
  u({ attribute: !0, type: Boolean, reflect: !0 })
], Se.prototype, "selected", 2);
Ze([
  u({ attribute: !0, type: Boolean, reflect: !0 })
], Se.prototype, "starred", 2);
Ze([
  u({ attribute: !0, type: Boolean, reflect: !0 })
], Se.prototype, "pinned", 2);
Ze([
  u({ attribute: !1 })
], Se.prototype, "members", 2);
Ze([
  u({ attribute: !1 })
], Se.prototype, "lastMessage", 2);
Se = Ze([
  B("wy-conversation-item"),
  ht()
], Se);
var S9 = Object.defineProperty, M9 = Object.getOwnPropertyDescriptor, w1 = /* @__PURE__ */ a((n) => {
  throw TypeError(n);
}, "__typeError"), _d = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? M9(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && S9(t, e, r), r;
}, "__decorateClass$3"), f1 = /* @__PURE__ */ a((n, t, e) => t.has(n) || w1("Cannot " + e), "__accessCheck"), im = /* @__PURE__ */ a((n, t, e) => (f1(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet"), A9 = /* @__PURE__ */ a((n, t, e) => t.has(n) ? w1("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd"), rm = /* @__PURE__ */ a((n, t, e, i) => (f1(n, t, "write to private field"), t.set(n, e), e), "__privateSet"), xa, gc;
let Zr = (gc = class extends Te {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this.conversationTypes = [st.ChatRoom, st.PrivateChat], this.searchText = "", this.conversationsQuery = new ir(this), this.infiniteScroll = new rr(this), this.pagerRef = nt(), this.handleRefresh = () => {
      this.conversationsQuery.result.refetch();
    }, this.handlePresenceChange = (t) => {
      if (!this.weavy)
        return;
      Array.isArray(t) || (t = [parseInt(t)]);
      const e = /* @__PURE__ */ a((i) => {
        const r = i.members.data ?? [];
        r.forEach((s) => {
          s.presence = t.indexOf(s.id) != -1 ? "active" : "away";
        }), i.members.data = r;
      }, "updateMembersInApps");
      yt(
        this.weavy.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        void 0,
        e
      );
    }, A9(this, xa);
  }
  /**
   * Selects a conversation and triggers an action event.
   *
   * @param conversation - The conversation to select.
   */
  selectConversation(t) {
    this.conversationId = t?.id, this.dispatchAction(Ee.Select, t);
  }
  /**
   * Triggers `wy-action` event.
   * @param action - The performed action.
   * @param app - The conversation to select.
   * @returns Whether the event was successful.
   */
  dispatchAction(t, e) {
    const i = new CustomEvent("wy-action", {
      detail: { action: t, app: e },
      bubbles: !0,
      composed: !0
    });
    return this.dispatchEvent(i);
  }
  /**
   * Marks a conversation as read.
   *
   * @param appId - The id of the conversation to mark.
   * @param messageId - Optional message id to set the marker to.
   */
  async handleMark(t, e) {
    await this.markConversationMutation?.mutate({ app: t, messageId: e, userId: this.user?.id });
  }
  /**
   * Sets a conversation as starred.
   *
   * @param appId -  The id of the conversation to star.
   * @param star - Whether to make the conversation starred.
   */
  async handleStar(t, e) {
    await this.starConversationMutation?.mutate({ appId: t, star: e });
  }
  /**
   * Sets a conversation as pinned.
   *
   * @param appId - The id of the conversation to pin.
   * @param pin - Whether to make the conversation pinned.
   */
  async handlePin(t, e) {
    await this.pinConversationMutation?.mutate({ appId: t, pin: e });
  }
  /**
   * Leave a conversation (for the current user).
   *
   * @param appId - The id of the conversation to leave.
   */
  async handleLeaveConversation(t) {
    this.conversationId === t && this.selectConversation(null);
    const e = await this.whenUser();
    await this.leaveConversationMutation?.mutate({ appId: t, members: [e.id] }), this.conversationsQuery.result.refetch();
  }
  /**
   * Remove a conversation.
   *
   * @param appId - The id of the conversation to remove.
   */
  async handleRemoveConversation(t) {
    this.conversationId === t && this.selectConversation(null), await this.removeConversationMutation?.mutate({ appId: t }), this.conversationsQuery.result.refetch();
  }
  /**
   * Trash a conversation.
   *
   * @param appId - The id of the conversation to trash.
   */
  async handleTrashConversation(t) {
    this.conversationId === t && this.selectConversation(null), await this.trashConversationMutation?.mutate({ appId: t }), this.conversationsQuery.result.refetch();
  }
  async willUpdate(t) {
    var e;
    super.willUpdate(t), (t.has("weavy") || t.has("conversationTypes")) && this.weavy && (await this.conversationsQuery.trackInfiniteQuery(
      B0(
        this.weavy,
        {},
        this.conversationTypes,
        this.agent,
        () => this.searchText,
        "pinned_at desc,rev desc",
        !1
      )
    ), this.markConversationMutation = Jm(this.weavy), this.starConversationMutation = Tb(this.weavy), this.pinConversationMutation = Lb(this.weavy), this.leaveConversationMutation = tv(this.weavy), this.removeConversationMutation = Ob(this.weavy), this.trashConversationMutation = Fb(this.weavy), (e = im(this, xa)) == null || e.call(this), this.weavy.subscribe(null, "app_created", this.handleRefresh), this.weavy.subscribe(null, "message_created", this.handleRefresh), this.weavy.subscribe(null, "member_added", this.handleRefresh), this.weavy.subscribe(null, "online", this.handlePresenceChange), rm(this, xa, () => {
      this.weavy?.unsubscribe(null, "app_created", this.handleRefresh), this.weavy?.unsubscribe(null, "message_created", this.handleRefresh), this.weavy?.unsubscribe(null, "member_added", this.handleRefresh), this.weavy?.unsubscribe(null, "online", this.handlePresenceChange), rm(this, xa, void 0);
    }));
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.conversationsQuery.result, this.pagerRef.value);
  }
  async updated(t) {
    t.has("searchText") && t.get("searchText") !== void 0 && this.conversationsQuery.result && await this.conversationsQuery.result.refetch?.();
  }
  renderConversations(t) {
    if (t) {
      const e = nr(t);
      return je(
        e,
        (i) => i?.id,
        (i) => [
          h`<wy-conversation-item
              conversationId=${i?.id}
              .avatarUrl=${i?.avatar_url}
              .hideAvatar=${!!this.agent}
              .name=${i.name}
              .lastMessage=${i.last_message}
              .members=${i.members}
              .unread=${i.is_unread}
              .starred=${i.is_starred}
              .pinned=${i.is_pinned}
              .type=${i.type}
              .selected=${this.conversationId == i.id}
              @selected=${() => this.selectConversation(i)}
              @mark=${(r) => this.handleMark(i, r.detail.messageId)}
              @star=${(r) => this.handleStar(r.detail.id, r.detail.star)}
              @pin=${(r) => this.handlePin(r.detail.id, r.detail.pin)}
              @leave=${(r) => this.handleLeaveConversation(r.detail.id)}
              @remove=${(r) => this.handleRemoveConversation(r.detail.id)}
              @trash=${(r) => this.handleTrashConversation(r.detail.id)}
            ></wy-conversation-item>`
        ]
      );
    }
    return b;
  }
  render() {
    const { data: t, isPending: e, hasNextPage: i } = this.conversationsQuery.result ?? {};
    return h`
      <div part="wy-conversations">
        <wy-buttons part="wy-conversations-toolbar" position=${this.agent ? "floating" : "sticky"} ?reverse=${!!this.agent}>
          <slot name="navigation"></slot>
          ${this.agent ? b : h`
                <wy-search
                  compact
                  placeholder=${x("Search for conversations...")}
                  @search=${(r) => this.searchText = r.detail.query}
                ></wy-search>
              `}
          <slot name="actions"></slot>
        </wy-buttons>

        <div part="wy-conversation-list">
          ${!e && this.user && t ? t.pages[0]?.count || this.searchText ? this.renderConversations(t) : h`
                  <div part="wy-pane-body">
                    <div part="wy-pane-group">
                      <wy-empty noNetwork>${x("Create a conversation to get started.")}</wy-empty>
                    </div>
                  </div>
                ` : h`<wy-empty><wy-progress-circular indeterminate padded></wy-progress-circular></wy-empty>`}
          ${i ? h`<div ${Q(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : b}
        </div>
      </div>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = im(this, xa)) == null || t.call(this), super.disconnectedCallback();
  }
}, a(gc, "WyConversationList"), gc);
xa = /* @__PURE__ */ new WeakMap();
Zr.styles = [u1, Xn, X, Jr];
_d([
  u({ type: Number })
], Zr.prototype, "conversationId", 2);
_d([
  u({ type: Array })
], Zr.prototype, "conversationTypes", 2);
_d([
  u()
], Zr.prototype, "agent", 2);
_d([
  D()
], Zr.prototype, "searchText", 2);
Zr = _d([
  B("wy-conversation-list"),
  ht()
], Zr);
var E9 = Object.defineProperty, R9 = Object.getOwnPropertyDescriptor, Qh = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? R9(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && E9(t, e, r), r;
}, "__decorateClass$2"), bc;
let Wn = (bc = class extends jt {
  constructor() {
    super(...arguments), this.componentFeatures = new le(Uc), this.theme = new _e(this, Wn.styles), this.unreadConversations = new Sc(this), this.createConversationController = new _c(this), this.componentTypes = [st.ChatRoom, st.PrivateChat], this.conversationId = null, this.conversationQuery = new qe(this), this.persistState = new Sn(this), this.conversationNewRef = nt();
  }
  set agent(t) {
    super.agent = t, this._agentUid ? (this.componentTypes = [st.AgentChat], this.componentFeatures = new le(
      Uy,
      this.componentFeatures.allowedFeatures()
    )) : (this.componentTypes = [st.ChatRoom, st.PrivateChat], this.componentFeatures = new le(
      Uc,
      this.componentFeatures.allowedFeatures()
    )), this.conversationId = null;
  }
  get agent() {
    return super.agent;
  }
  /** Current unread conversation count. */
  get unread() {
    return this.unreadConversations.unread;
  }
  /**
   * Creates a new conversation.
   *
   * When in agent mode, a conversation is created instantly.
   *
   * @param members - Optional array of member id or member uid.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select member dialog to let the user choose members.
   *
   * @returns Promise resolving to any selected member ids or uids.
   */
  async selectMembers() {
    return await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("weavy") || t.has("agent") || t.has("user")) && this.weavy && this.user && this.persistState.observe(
      [{ name: "conversationId", override: !1 }],
      this.agent || "messenger",
      `u${this.user?.id}`,
      (e) => {
        if (e.has("conversationId") && this.conversationId) {
          const i = new CustomEvent("wy-action", {
            detail: {
              action: Ee.Select,
              app: { id: this.conversationId }
            },
            bubbles: !0,
            composed: !0
          });
          this.dispatchEvent(i);
        }
      }
    ), t.has("agent") && (this.createConversationController.agent = this.agent), t.has("link") && this.link?.app && (this.conversationId = this.link.app.id), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversations.track(this.componentTypes, this.agent);
  }
  render() {
    return h`
      <wy-conversation-list
        .conversationTypes=${this.componentTypes}
        .agent=${this.agent}
        conversationId=${dt(this.conversationId !== null ? this.conversationId : void 0)}
        @wy-action=${(t) => {
      !t.defaultPrevented && t.detail.action === Ee.Select && t.detail.app !== void 0 && (this.conversationId = t.detail.app?.id);
    }}
      >
        <wy-conversation-new
          slot="actions"
          .agent=${this.agent}
          @wy-action=${(t) => {
      !t.defaultPrevented && t.detail.action === Ee.Select && t.detail.app !== void 0 && (this.conversationId = t.detail.app?.id);
    }}
          ${Q(this.conversationNewRef)}
        >
          <slot name="conversation-new"></slot>
        </wy-conversation-new>
        <slot name="actions" slot="actions"></slot>
      </wy-conversation-list>
    `;
  }
}, a(bc, "WyMessengerConversations"), bc);
Wn.styles = [se, wr, Fe, Gn, Zn];
Qh([
  u({ attribute: !1 })
], Wn.prototype, "componentTypes", 2);
Qh([
  u({ type: String })
], Wn.prototype, "agent", 1);
Qh([
  u({ type: Number })
], Wn.prototype, "conversationId", 2);
Wn = Qh([
  B("wy-messenger-conversations"),
  ht()
], Wn);
var T9 = Object.defineProperty, L9 = Object.getOwnPropertyDescriptor, Gh = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? L9(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = (i ? o(t, e, r) : o(r)) || r);
  return i && r && T9(t, e, r), r;
}, "__decorateClass$1"), xc;
let Kn = (xc = class extends Te {
  constructor() {
    super(...arguments), this.exportParts = new q(this), this._whenMembers = this.createMembersPromise(), this.show = !1;
  }
  /**
   * Resolves when members are selected from the modal.
   *
   * @returns Promise<MemberIdType[]>
   */
  async whenMembers() {
    return this._whenMembers;
  }
  /**
   * Create an internal members promise and store resolve/reject handlers.
   *
   * @internal
   */
  createMembersPromise() {
    const t = new Promise((e, i) => {
      this._resolveMembers = e, this._rejectMembers = i;
    });
    return this._whenMembers = t, t;
  }
  /**
   * Open the new conversation dialog and return selected members.
   *
   * @returns Promise<MemberIdType[]>
   */
  async selectMembers() {
    return this.show = !0, await this.whenMembers();
  }
  /**
   * Close the new conversation dialog and resolve or reject the selection promise.
   *
   * @internal
   * @param members - Optional selected member ids to resolve the promise with.
   */
  close(t) {
    this.show = !1, t ? this._resolveMembers?.(t) : this._rejectMembers?.("Selection aborted by user; no members selected"), this.createMembersPromise();
  }
  /**
   * Create a conversation by dispatching a `create` event and closing the dialog.
   *
   * @param members - Array of members by id/uid for a new conversation.
   */
  async submit(t = []) {
    await this.whenUser(), this.close(t);
    const e = new CustomEvent("create", {
      detail: { members: t }
    });
    this.dispatchEvent(e), this.createMembersPromise();
  }
  render() {
    return h`
      ${this.slotElements.length ? b : h`
            <wy-button
              part="wy-conversation-new-button"
              kind="icon"
              @click=${async () => {
      if (this.agent)
        await this.submit();
      else
        try {
          await this.selectMembers();
        } catch {
        }
    }}
            >
              <wy-icon name="plus"></wy-icon>
            </wy-button>
          `}
      <slot></slot>

      ${!this.agent && this.weavy && this.user ? h`<wy-overlay
            part="wy-conversation-new-dialog"
            .show=${this.show}
            @close=${() => {
      this.show = !1;
    }}
          >
            <wy-titlebar header slot="header">
              <wy-button slot="icon" kind="icon" @click=${() => this.close()}>
                <wy-icon name="close"></wy-icon>
              </wy-button>
              <span slot="title">${x("New conversation")}</span>
            </wy-titlebar>
            ${this.show ? h`
                  <wy-users-search
                    @submit=${(t) => this.submit(t.detail.members.map((e) => e.id))}
                  ></wy-users-search>
                ` : b}
          </wy-overlay>` : b}
    `;
  }
}, a(xc, "WyConversationNew"), xc);
Kn.styles = [X];
Gh([
  u()
], Kn.prototype, "agent", 2);
Gh([
  D()
], Kn.prototype, "show", 2);
Gh([
  Kc({ flatten: !0, selector: ":not(slot)" })
], Kn.prototype, "slotElements", 2);
Kn = Gh([
  B("wy-conversation-new"),
  ht()
], Kn);
const O9 = j`[part~=wy-message-editor-inputs]{display:flex;flex-direction:row;align-items:flex-end;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em))*1.5*var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*2 + var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))*2)}[part~=wy-message-editor-text]{flex:1 1 100%;display:flex;flex-direction:column;margin-inline:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-editor-parts]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));min-height:0}[part~=wy-message-editor] .cm-editor{flex:1 1 100%;max-height:11.25em;background-color:var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:var(--wy-input-filled-border-radius, var(--wy-border-radius-lg, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem)))));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid rgba(0,0,0,0);margin:calc(-1*var(--wy-input-border-width, var(--wy-border, 1px)))}[part~=wy-message-editor] .cm-editor:focus{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-message-editor] .cm-editor.cm-focused{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-message-editor] .cm-editor .cm-content{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)), inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em))*1.5*var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*2 - var(--wy-input-border-width, var(--wy-border, 1px)));line-height:calc(1.5*var(--wy-size, 1rem))}[part~=wy-message-editor] [part~=wy-is-invalid]+[data-editor-target] .cm-editor,[part~=wy-message-editor] [part~=wy-is-invalid] .cm-editor{border-color:var(--wy-error, var(--wy-error-light, #ba1821))!important}`;
var z9 = Object.getOwnPropertyDescriptor, I9 = /* @__PURE__ */ a((n, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? z9(t, e) : t, s = n.length - 1, o; s >= 0; s--)
    (o = n[s]) && (r = o(r) || r);
  return r;
}, "__decorateClass"), Cc;
let yh = (Cc = class extends $t {
  constructor() {
    super(), this.editorType = "messages", this.editorClass = "wy-message-editor";
  }
  /**
   * Render content that appears above the message editor.
   *
   * By default returns the same lists section used by the base editor.
   *
   * @internal
   */
  renderTopSlot() {
    return [
      this.renderLists()
    ];
  }
  /**
   * Render the primary middle slot containing the add-menu, editor and send button.
   *
   * Overrides the base implementation to provide message-specific controls and layout.
   *
   * @internal
   */
  renderMiddleSlot() {
    return h` <div part="wy-message-editor-inputs">
      <!-- Add -->
      ${this.componentFeatures?.allowsAnyFeature(
      S.Attachments,
      S.CloudFiles,
      S.Polls,
      S.Meetings,
      S.ZoomMeetings,
      S.GoogleMeet,
      S.MicrosoftTeams
    ) ? h`<wy-dropdown icon="plus" directionY="up" ?disabled=${this.disabled}>
            ${this.componentFeatures?.allowsFeature(S.Attachments) ? h`
                  <wy-dropdown-item @click=${this.openFileInput} title=${x("From device")}>
                    <wy-icon name="attachment"></wy-icon>
                    <span>${x("From device")}</span>
                  </wy-dropdown-item>
                  <input
                    type="file"
                    ${Q(this.fileInputRef)}
                    @click=${(t) => t.stopPropagation()}
                    @change=${(t) => this.handleUploadFiles(
      Array.from(t.target.files || []),
      t.target
    )}
                    multiple
                    hidden
                    tabindex="-1"
                  />
                ` : b}
            ${this.componentFeatures?.allowsFeature(S.CloudFiles) ? h`
                  <wy-dropdown-item @click=${this.openCloudFiles} title=${x("From cloud")}>
                    <wy-icon name="cloud"></wy-icon>
                    <span>${x("From cloud")}</span>
                  </wy-dropdown-item>
                ` : b}
            ${this.componentFeatures?.allowsFeature(S.Polls) ? h`
                  <wy-dropdown-item @click=${() => this.openPolls()} title=${x("Poll")}>
                    <wy-icon name="poll"></wy-icon>
                    <span>${x("Poll")}</span>
                  </wy-dropdown-item>
                ` : b}
            ${this.componentFeatures?.allowsAnyFeature(S.Meetings, S.ZoomMeetings) ? h`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("zoom")} title=${x("Zoom meeting")}>
                    <wy-icon svg="zoom-meetings"></wy-icon>
                    <span>${x("Zoom meeting")}</span>
                  </wy-dropdown-item>
                ` : b}
            ${this.componentFeatures?.allowsAnyFeature(S.Meetings, S.GoogleMeet) ? h`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("google")} title=${x("Google Meet")}>
                    <wy-icon svg="google-meet"></wy-icon>
                    <span>${x("Google Meet")}</span>
                  </wy-dropdown-item>
                ` : b}
            ${this.componentFeatures?.allowsAnyFeature(S.Meetings, S.MicrosoftTeams) ? h`
                  <wy-dropdown-item
                    @click=${() => this.handleMeetingClick("microsoft")}
                    title=${x("Microsoft Teams")}
                  >
                    <wy-icon svg="microsoft-teams"></wy-icon>
                    <span>${x("Microsoft Teams")}</span>
                  </wy-dropdown-item>
                ` : b}
          </wy-dropdown>` : b}

      <!-- Input -->
      <div part="wy-message-editor-text" ${Q(this.editorRef)}> ${this.renderEditorDummy()} </div>

      <!-- Button -->
      <wy-button
        kind="icon"
        color="primary-text"
        title=${x("Send", { desc: "Button action to send" })}
        @click="${() => this.submit()}"
        ?disabled=${this.disabled}
      >
        <wy-icon name="send"></wy-icon>
      </wy-button>
    </div>`;
  }
  /**
   * Render the bottom slot for message editor with no content.
   *
   * @internal
   */
  renderBottomSlot() {
    return b;
  }
}, a(Cc, "WyMessageEditor"), Cc);
yh.styles = [...$t.styles, O9];
yh = I9([
  B("wy-message-editor"),
  ht()
], yh);
const U9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get WyAnnotation() {
    return Al;
  },
  get WyAnnotationList() {
    return El;
  },
  get WyAttachment() {
    return Ml;
  },
  get WyAttachmentList() {
    return zc;
  },
  get WyAvatar() {
    return Li;
  },
  get WyAvatarGroup() {
    return En;
  },
  get WyAvatarHeader() {
    return $l;
  },
  get WyBadge() {
    return lr;
  },
  get WyButton() {
    return ei;
  },
  get WyButtons() {
    return Rn;
  },
  get WyCloudFiles() {
    return Hn;
  },
  get WyComment() {
    return Ii;
  },
  get WyCommentEditor() {
    return hh;
  },
  get WyCommentList() {
    return cr;
  },
  get WyContainer() {
    return sr;
  },
  get WyContextDataProgress() {
    return uh;
  },
  get WyConversation() {
    return We;
  },
  get WyConversationHeader() {
    return Di;
  },
  get WyConversationItem() {
    return Se;
  },
  get WyConversationList() {
    return Zr;
  },
  get WyConversationNew() {
    return Kn;
  },
  get WyDropdown() {
    return ii;
  },
  get WyDropdownDivider() {
    return lh;
  },
  get WyDropdownItem() {
    return _l;
  },
  get WyDropdownOption() {
    return Oc;
  },
  get WyEditor() {
    return $t;
  },
  get WyEmbed() {
    return Ic;
  },
  get WyEmbedSelect() {
    return Rl;
  },
  get WyEmpty() {
    return Tc;
  },
  get WyFileGrid() {
    return Bn;
  },
  get WyFileItem() {
    return Fi;
  },
  get WyFileMenu() {
    return Vn;
  },
  get WyFileTable() {
    return Kr;
  },
  get WyFileVersions() {
    return Dl;
  },
  get WyFilesHeader() {
    return Wr;
  },
  get WyFilesList() {
    return dr;
  },
  get WyIcon() {
    return Wt;
  },
  get WyIconDisplay() {
    return Cl;
  },
  get WyIconStack() {
    return nh;
  },
  get WyImageGrid() {
    return On;
  },
  get WyItem() {
    return de;
  },
  get WyItemList() {
    return Nr;
  },
  get WyMeetingCard() {
    return Tl;
  },
  get WyMessage() {
    return Vt;
  },
  get WyMessageEditor() {
    return yh;
  },
  get WyMessageTyping() {
    return ci;
  },
  get WyNotificationHeader() {
    return Un;
  },
  get WyNotificationList() {
    return Bc;
  },
  get WyNotificationListItem() {
    return Qr;
  },
  get WyOverlay() {
    return qr;
  },
  get WyPdfViewer() {
    return Dn;
  },
  get WyPoll() {
    return Ol;
  },
  get WyPollOption() {
    return zn;
  },
  get WyPost() {
    return Qt;
  },
  get WyPostEdit() {
    return ge;
  },
  get WyPostList() {
    return Hl;
  },
  get WyPostTrashed() {
    return Hc;
  },
  get WyPostView() {
    return It;
  },
  get WyPresence() {
    return Ec;
  },
  get WyPreview() {
    return Kt;
  },
  get WyPreviewEmbed() {
    return jr;
  },
  get WyPreviewIcon() {
    return In;
  },
  get WyPreviewImage() {
    return Fn;
  },
  get WyPreviewItem() {
    return Fc;
  },
  get WyPreviewMedia() {
    return or;
  },
  get WyPreviewText() {
    return zi;
  },
  get WyProgressCircular() {
    return wi;
  },
  get WyProgressLinear() {
    return li;
  },
  get WyReactionItem() {
    return Il;
  },
  get WyReactions() {
    return Xt;
  },
  get WySearch() {
    return jn;
  },
  get WySkeleton() {
    return Sl;
  },
  get WyTitlebar() {
    return ar;
  },
  get WyTitlebarText() {
    return Ll;
  },
  get WyToast() {
    return hr;
  },
  get WyToasts() {
    return Nl;
  },
  get WyTyping() {
    return jc;
  },
  get WyUpload() {
    return qc;
  },
  get WyUsersSearch() {
    return gi;
  }
}, Symbol.toStringTag, { value: "Module" }));
export {
  Jd as AgentAppTypeGuids,
  H9 as AgentAppTypeStrings,
  cy as AppContext,
  L0 as AppTypeGuids,
  O0 as AppTypeStrings,
  le as ComponentFeatures,
  af as ContextController,
  Sm as ContextIdContext,
  _c as CreateConversationController,
  Mm as DataBlobsContext,
  Uy as DefaultMessengerAgentFeatures,
  Uc as DefaultMessengerFeatures,
  th as DropZoneController,
  S as Feature,
  bh as FeaturePolicyContext,
  lf as HistoryController,
  ir as InfiniteQueryController,
  rr as InfiniteScrollController,
  Em as LinkContext,
  N9 as MessengerAgentTypes,
  B9 as MessengerTypes,
  ti as MutationController,
  kc as MutationStateController,
  Sn as PersistStateController,
  qe as QueryController,
  df as ResizeController,
  zp as ReverseInfiniteScrollController,
  q as ShadowPartsController,
  Fp as SwipeScrollController,
  _e as ThemeController,
  eh as TypingController,
  Fr as UnknownApp,
  Sc as UnreadConversationsController,
  bl as UnreadNotificationsController,
  xh as UserContext,
  Gt as Weavy,
  Re as WeavyAppComponent,
  ae as WeavyClient,
  Pc as WeavyComponent,
  Xd as WeavyComponentSettings,
  Rm as WeavyComponentSettingsContext,
  U9 as WeavyComponents,
  he as WeavyContext,
  Hr as WeavyOptionalAppComponent,
  Dt as WeavySubAppComponent,
  Te as WeavySubComponent,
  jt as WeavyTypeComponent,
  Dc as WyChat,
  Vl as WyComments,
  Mc as WyComponent,
  Yt as WyContext,
  Vc as WyCopilot,
  Nn as WyFiles,
  pr as WyMessenger,
  Gr as WyMessengerBadge,
  Ke as WyMessengerButton,
  Wn as WyMessengerConversations,
  ph as WyMessengerNew,
  qn as WyNotificationBadge,
  vi as WyNotificationButton,
  ur as WyNotificationToasts,
  Nc as WyNotifications,
  Bl as WyPosts,
  _p as allFeatures,
  d0 as createWeavyContextProvider,
  ly as featureConfigFromList,
  Am as featureListFromString,
  cl as globalContextProvider,
  Mp as hasAbort
};
