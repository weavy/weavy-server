var Xv = Object.defineProperty;
var xw = (i) => {
  throw TypeError(i);
};
var a = (i, t) => Xv(i, "name", { value: t, configurable: !0 });
var Pp = (i, t, e) => t.has(i) || xw("Cannot " + e);
var y = (i, t, e) => (Pp(i, t, "read from private field"), e ? e.call(i) : t.get(i)), O = (i, t, e) => t.has(i) ? xw("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(i) : t.set(i, e), P = (i, t, e, r) => (Pp(i, t, "write to private field"), r ? r.call(i, e) : t.set(i, e), e), st = (i, t, e) => (Pp(i, t, "access private method"), e);
var kd = (i, t, e, r) => ({
  set _(s) {
    P(i, t, s, e);
  },
  get _() {
    return y(i, t, r);
  }
});
import { observeConnected as Jv, throwOnDomNotAvailable as we, isDomAvailable as Vu, whenConnected as Ff, whenParentsDefined as ar, defaultVisibilityCheckOptions as t1, isInShadowDom as $w, isModifiedClick as dh, isPopoverPolyfilled as Up, inOverlay as e1, autofocusRef as Uu, whenElementVisible as Bp, whenDocumentVisible as i1 } from "./es/editor-M1x0pxVu.js";
import { configureLocalization as r1, e as s1, i as B, i$1 as X, m as n1, b as a1, r as o1, S as c1, x as h, W as l1, E as v, w as hh, T as Id, msg as b, localized as ot, str as ut } from "./es/locales/sv-SE-DNn-JJCG.js";
function Td(i) {
  return Object.prototype.toString.call(i) === "[object Object]";
}
a(Td, "isObject");
function Sr(i) {
  if (Td(i) === !1) return !1;
  const t = i.constructor;
  if (t === void 0) return !0;
  const e = t.prototype;
  return !(Td(e) === !1 || Object.prototype.hasOwnProperty.call(e, "isPrototypeOf") === !1);
}
a(Sr, "isPlainObject$1");
function qp(i) {
  return typeof i.toJSON == "function";
}
a(qp, "hasToJSON");
function d1(i) {
  return typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i === null || Sr(i) || Array.isArray(i);
}
a(d1, "isJSONSerializable");
function yn(i, t, e = !1) {
  i = i || {}, t = t || {};
  const r = {};
  for (const s in i)
    Object.prototype.hasOwnProperty.call(i, s) && (r[s] = i[s]);
  for (const s in t)
    Object.prototype.hasOwnProperty.call(t, s) && (e && r[s] && Sr(r[s]) && Sr(t[s]) ? r[s] = yn(r[s], t[s], e) : r[s] = t[s]);
  return r;
}
a(yn, "assign");
function h1(i) {
  return i ? Array.isArray(i) ? i : [i] : [];
}
a(h1, "asArray");
async function p1(i, t) {
  for (const e of i)
    if (await t(e))
      return e;
}
a(p1, "findAsyncSequential");
function wn(i, t, e = !1, r = !1) {
  if (!r && (!Sr(i) || !Sr(t)) || r && (!Td(i) || !Td(t)))
    return !1;
  const s = Object.getOwnPropertyNames(i), n = Object.getOwnPropertyNames(t);
  if (!e && s.length !== n.length)
    return !1;
  for (let o = 0; o < s.length; o++) {
    const c = s[o], l = i[c], u = t[c];
    if (l !== u && !wn(l, u, e))
      return !1;
  }
  return !0;
}
a(wn, "eqObjects");
function Df(i) {
  return Object.entries(i);
}
a(Df, "objectAsIterable");
function Hf(i) {
  return i.charAt(0).toUpperCase() + i.substring(1).toLowerCase();
}
a(Hf, "toUpperCaseFirst");
const u1 = '\\s,.:;"', y1 = new RegExp(`^|[${u1}]|$`, "g"), w1 = ".!?", f1 = new RegExp(`^|(?<=[${w1}])|$`);
function Vf(i) {
  return i.length > 0 ? i.replace(/([a-z\d])([A-Z]+)/g, "$1-$2").replace(/_|\s+/g, "-").toLowerCase() : i;
}
a(Vf, "toKebabCase");
function m1(i, t = 2) {
  if (!i)
    return null;
  let e = "";
  const r = i.split(y1).filter((s) => s);
  return r.length == 1 ? e = r[0] : r.forEach((s) => {
    e += s.charAt(0);
  }), e.substring(0, t).toUpperCase();
}
a(m1, "getInitials");
function Uf(i) {
  let t;
  const e = i.split(f1).filter((r) => r);
  return e.length ? t = e[0] : t = i, t;
}
a(Uf, "getTitleFromText");
function Bf(i, t = 256) {
  return i.length > t && (i = i.substring(0, t - 1) + "…"), i;
}
a(Bf, "truncateText");
const v1 = /^[\p{Extended_Pictographic}\p{Emoji_Presentation}]+$/u;
function g1(i) {
  return !!i?.match(v1)?.length;
}
a(g1, "checkOnlyEmojis");
const b1 = {
  //mode: 'cors', // no-cors, *cors, same-origin
  // cache: 'default' means the server is in control of the caching which is preferred instead of using 'reload'
  //cache: 'default', // *default, no-cache, reload, force-cache, only-if-cached
  credentials: "omit",
  // include, *same-origin, omit
  headers: {
    // https://stackoverflow.com/questions/8163703/cross-domain-ajax-doesnt-send-x-requested-with-header
    "X-Requested-With": "XMLHttpRequest"
  },
  redirect: "manual"
  // manual, *follow, error
  //referrerPolicy: 'no-referrer-when-downgrade', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
};
function x1() {
  const i = /* @__PURE__ */ new WeakSet(), t = /* @__PURE__ */ a(function(e, r) {
    if (qp(r) && (r = r.toJSON()), !(r !== null && typeof r == "object"))
      return r;
    if (i.has(r))
      return "[Circular]";
    let s;
    if (i.add(r), Sr(r)) {
      const n = {};
      Object.keys(r).forEach((o) => {
        n[o] = t(o, r[o]);
      }), s = n;
    } else Array.isArray(r) && (s = r.map((n, o) => t(o, n)));
    return i.delete(r), s;
  }, "replacer");
  return t;
}
a(x1, "getCircularReferenceReplacer");
function ol() {
  return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
}
a(ol, "S4");
function $1(i) {
  if (i && i.ok && i.body) {
    const t = i.body.getReader();
    return new ReadableStream({
      start(e) {
        const r = /* @__PURE__ */ a(() => t.read().then(({ done: s, value: n }) => {
          if (s) {
            e.close();
            return;
          }
          return e.enqueue(n), r();
        }), "pump");
        return r();
      }
    });
  } else
    throw new Error("Could not parse text stream");
}
a($1, "getTextStreamFromResponse");
function qf(i) {
  let t;
  try {
    if (t = window[i], t) {
      const e = "__storage_test__";
      t.setItem(e, e), t.removeItem(e);
    }
  } catch (e) {
    e instanceof DOMException && e.name === "QuotaExceededError" && // acknowledge QuotaExceededError only if there's something already stored
    t && t.length !== 0 && console.error("Storage not available:", i);
  }
  return t;
}
a(qf, "getStorage");
const Ry = class Ry extends Error {
  constructor() {
    super("Instance destroyed"), this.name = "DestroyError";
  }
};
a(Ry, "DestroyError");
let Tt = Ry;
const C1 = /* @__PURE__ */ a((i) => {
  var t;
  return t = class extends i {
    // AUTHENTICATION
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), this._whenTokenFactory = new Promise((s) => {
        this._resolveTokenFactory = s;
      }), this._whenUrlAndTokenFactory = new Promise((s) => {
        this._resolveUrlAndTokenFactory = (n) => {
          s(n), this.configurationState = "configured";
        };
      }), this._whenTokenIsValid = new Promise((s) => {
        this._resolveTokenIsValid = s;
      }), this._tokenPromise = null, this._token = "", this._validTokenFromFactory = async (s = !1) => {
        const n = [this.whenTokenFactory()];
        this.tokenFactoryRetryDelay >= 0 && this.tokenFactoryRetryDelay < 1 / 0 && n.push(new Promise((c) => setTimeout(c, this.tokenFactoryRetryDelay))), await Promise.race(n);
        const o = await this.tokenFactory?.(s) ?? "";
        if (this._validateToken(o)) {
          if (s && o === this._token && this.tokenFactoryRetryDelay >= 0 && this.tokenFactoryRetryDelay < 1 / 0)
            return await new Promise((c) => setTimeout(c, this.tokenFactoryRetryDelay)), await this._validTokenFromFactory(!0);
        } else if (this._whenTokenFactory = new Promise((c) => {
          this._resolveTokenFactory = c;
        }), !s)
          return await this._validTokenFromFactory(!1);
        if (!o)
          throw new TypeError("Could not get a valid token from tokenFactory.");
        return this._resolveTokenFactory?.(!0), this.whenUrl().then(this._resolveUrlAndTokenFactory), o;
      }, Promise.all([this.whenUrl(), this.whenTokenFactory()]).then(() => {
        this.url && this.tokenFactory && this._resolveUrlAndTokenFactory?.(!0);
      });
    }
    async whenTokenFactory() {
      await this._whenTokenFactory;
    }
    async whenUrlAndTokenFactory() {
      await this._whenUrlAndTokenFactory;
    }
    async whenTokenIsValid() {
      await this._whenTokenIsValid;
    }
    /**
     * Async function returning an `access_token` string for _your_ authenticated user. A boolean `refresh` parameter is provided to let you now if a fresh token is needed from Weavy.
     */
    get tokenFactory() {
      return this._tokenFactory;
    }
    set tokenFactory(r) {
      if (this.isDestroyed)
        throw new Tt();
      this._tokenFactory && this._tokenFactory !== r && this.whenTokenFactory().then(() => {
        this.queryClient.refetchQueries({ stale: !0 });
      }), this._tokenFactory = r ?? void 0, this._tokenFactory && queueMicrotask(() => {
        this._resolveTokenFactory?.(!0);
      });
    }
    /**
     * An URL to an endpoint returning an JSON data containing an `access_token` string property for _your_ authenticated user. A boolean `refresh=true` query parameter is provided in the request to let you now if when a fresh token is needed from Weavy.
     */
    get tokenUrl() {
      return this._tokenUrl;
    }
    set tokenUrl(r) {
      if (this.isDestroyed)
        throw new Tt();
      try {
        if (typeof r == "string")
          r && (this._tokenUrl = new URL(r, window.location.toString()));
        else if (r instanceof URL)
          this._tokenUrl = r;
        else if (r == null)
          this._tokenUrl = void 0;
        else
          throw new Error();
      } catch (s) {
        throw new Error("Invalid url", s);
      }
      this._tokenUrl && !this.tokenFactory && (this.tokenFactory = async (s) => {
        if (!this.tokenUrl)
          throw new Error("tokenURL property is not valid");
        const n = new URL(this.tokenUrl);
        s ? n.searchParams.set("refresh", "true") : n.searchParams.delete("refresh");
        const o = await fetch(n);
        if (o.ok) {
          const c = await o.json();
          if (c.access_token === void 0)
            throw new Error("Token response does not contain required property: access_token");
          return c.access_token;
        } else
          throw new Error("Could not get access token from server!");
      });
    }
    _validateToken(r) {
      if (!r)
        return !1;
      if (typeof r != "string")
        throw new TypeError(`You have provided an invalid string access token of type ${typeof r}.`);
      if (typeof r == "string" && !r.startsWith("wyu_"))
        throw r.startsWith("wys_") ? new TypeError("You have provided an API key for authentication. Provide a user access token instead.") : new TypeError("You have provided an invalid string as access token.");
      return this._resolveTokenIsValid?.(r), !0;
    }
    async getToken(r = !1) {
      if (this.isDestroyed)
        throw new Tt();
      if (this._token && !r)
        return this._token;
      if (this._tokenPromise)
        return await this._tokenPromise;
      this._tokenPromise = new Promise((s, n) => {
        this._validTokenFromFactory(r).then(s).catch(n), this.tokenFactoryTimeout >= 0 && this.tokenFactoryTimeout < 1 / 0 && setTimeout(() => n(new Error("Token factory timeout.")), this.tokenFactoryTimeout), window.addEventListener("offline", () => n(new Error("Network changed.")), { once: !0 }), window.addEventListener("online", () => n(new Error("Network changed.")), { once: !0 });
      });
      try {
        const s = await this._tokenPromise;
        return this._tokenPromise = null, this._token = s, this._token;
      } catch (s) {
        throw this._tokenPromise = null, s;
      }
    }
  }, a(t, "WeavyAuthentication"), t;
}, "WeavyAuthenticationMixin");
var _d = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function k1(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
a(k1, "getDefaultExportFromCjs");
function Mp(i) {
  throw new Error('Could not dynamically require "' + i + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
a(Mp, "commonjsRequire");
var Sp = { exports: {} }, Cw;
function _1() {
  return Cw || (Cw = 1, (function(i, t) {
    var e;
    e = /* @__PURE__ */ a(() => (() => {
      var r = { d: /* @__PURE__ */ a((D, d) => {
        for (var w in d) r.o(d, w) && !r.o(D, w) && Object.defineProperty(D, w, { enumerable: !0, get: d[w] });
      }, "d") };
      r.g = (function() {
        if (typeof globalThis == "object") return globalThis;
        try {
          return this || new Function("return this")();
        } catch {
          if (typeof window == "object") return window;
        }
      })(), r.o = (D, d) => Object.prototype.hasOwnProperty.call(D, d), r.r = (D) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(D, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(D, "t", { value: !0 });
      };
      var s, n = {};
      r.r(n), r.d(n, { AbortError: /* @__PURE__ */ a(() => l, "AbortError"), DefaultHttpClient: /* @__PURE__ */ a(() => kt, "DefaultHttpClient"), HttpClient: /* @__PURE__ */ a(() => S, "HttpClient"), HttpError: /* @__PURE__ */ a(() => o, "HttpError"), HttpResponse: /* @__PURE__ */ a(() => g, "HttpResponse"), HttpTransportType: /* @__PURE__ */ a(() => Ct, "HttpTransportType"), HubConnection: /* @__PURE__ */ a(() => Oi, "HubConnection"), HubConnectionBuilder: /* @__PURE__ */ a(() => Qh, "HubConnectionBuilder"), HubConnectionState: /* @__PURE__ */ a(() => gt, "HubConnectionState"), JsonHubProtocol: /* @__PURE__ */ a(() => xd, "JsonHubProtocol"), LogLevel: /* @__PURE__ */ a(() => s, "LogLevel"), MessageType: /* @__PURE__ */ a(() => rt, "MessageType"), NullLogger: /* @__PURE__ */ a(() => I, "NullLogger"), Subject: /* @__PURE__ */ a(() => ri, "Subject"), TimeoutError: /* @__PURE__ */ a(() => c, "TimeoutError"), TransferFormat: /* @__PURE__ */ a(() => Zt, "TransferFormat"), VERSION: /* @__PURE__ */ a(() => A, "VERSION") });
      const Kh = class Kh extends Error {
        constructor(d, w) {
          const C = new.target.prototype;
          super(`${d}: Status code '${w}'`), this.statusCode = w, this.__proto__ = C;
        }
      };
      a(Kh, "i");
      let o = Kh;
      const Gh = class Gh extends Error {
        constructor(d = "A timeout occurred.") {
          const w = new.target.prototype;
          super(d), this.__proto__ = w;
        }
      };
      a(Gh, "n");
      let c = Gh;
      const Zh = class Zh extends Error {
        constructor(d = "An abort occurred.") {
          const w = new.target.prototype;
          super(d), this.__proto__ = w;
        }
      };
      a(Zh, "r");
      let l = Zh;
      const Yh = class Yh extends Error {
        constructor(d, w) {
          const C = new.target.prototype;
          super(d), this.transport = w, this.errorType = "UnsupportedTransportError", this.__proto__ = C;
        }
      };
      a(Yh, "o");
      let u = Yh;
      const Xh = class Xh extends Error {
        constructor(d, w) {
          const C = new.target.prototype;
          super(d), this.transport = w, this.errorType = "DisabledTransportError", this.__proto__ = C;
        }
      };
      a(Xh, "h");
      let f = Xh;
      const Jh = class Jh extends Error {
        constructor(d, w) {
          const C = new.target.prototype;
          super(d), this.transport = w, this.errorType = "FailedToStartTransportError", this.__proto__ = C;
        }
      };
      a(Jh, "c");
      let $ = Jh;
      const tp = class tp extends Error {
        constructor(d) {
          const w = new.target.prototype;
          super(d), this.errorType = "FailedToNegotiateWithServerError", this.__proto__ = w;
        }
      };
      a(tp, "a");
      let m = tp;
      const ep = class ep extends Error {
        constructor(d, w) {
          const C = new.target.prototype;
          super(d), this.innerErrors = w, this.__proto__ = C;
        }
      };
      a(ep, "l");
      let x = ep;
      const ip = class ip {
        constructor(d, w, C) {
          this.statusCode = d, this.statusText = w, this.content = C;
        }
      };
      a(ip, "u");
      let g = ip;
      const rp = class rp {
        get(d, w) {
          return this.send({ ...w, method: "GET", url: d });
        }
        post(d, w) {
          return this.send({ ...w, method: "POST", url: d });
        }
        delete(d, w) {
          return this.send({ ...w, method: "DELETE", url: d });
        }
        getCookieString(d) {
          return "";
        }
      };
      a(rp, "d");
      let S = rp;
      (function(D) {
        D[D.Trace = 0] = "Trace", D[D.Debug = 1] = "Debug", D[D.Information = 2] = "Information", D[D.Warning = 3] = "Warning", D[D.Error = 4] = "Error", D[D.Critical = 5] = "Critical", D[D.None = 6] = "None";
      })(s || (s = {}));
      const sp = class sp {
        constructor() {
        }
        log(d, w) {
        }
      };
      a(sp, "f");
      let I = sp;
      I.instance = new I();
      const A = "9.0.6", np = class np {
        static isRequired(d, w) {
          if (d == null) throw new Error(`The '${w}' argument is required.`);
        }
        static isNotEmpty(d, w) {
          if (!d || d.match(/^\s*$/)) throw new Error(`The '${w}' argument should not be empty.`);
        }
        static isIn(d, w, C) {
          if (!(d in w)) throw new Error(`Unknown ${C} value: ${d}.`);
        }
      };
      a(np, "w");
      let E = np;
      const Ys = class Ys {
        static get isBrowser() {
          return !Ys.isNode && typeof window == "object" && typeof window.document == "object";
        }
        static get isWebWorker() {
          return !Ys.isNode && typeof self == "object" && "importScripts" in self;
        }
        static get isReactNative() {
          return !Ys.isNode && typeof window == "object" && window.document === void 0;
        }
        static get isNode() {
          return typeof process < "u" && process.release && process.release.name === "node";
        }
      };
      a(Ys, "g");
      let T = Ys;
      function q(D, d) {
        let w = "";
        return R(D) ? (w = `Binary data of length ${D.byteLength}`, d && (w += `. Content: '${(function(C) {
          const _ = new Uint8Array(C);
          let z = "";
          return _.forEach(((L) => {
            z += `0x${L < 16 ? "0" : ""}${L.toString(16)} `;
          })), z.substr(0, z.length - 1);
        })(D)}'`)) : typeof D == "string" && (w = `String data of length ${D.length}`, d && (w += `. Content: '${D}'`)), w;
      }
      a(q, "m");
      function R(D) {
        return D && typeof ArrayBuffer < "u" && (D instanceof ArrayBuffer || D.constructor && D.constructor.name === "ArrayBuffer");
      }
      a(R, "y");
      async function V(D, d, w, C, _, z) {
        const L = {}, [W, Q] = it();
        L[W] = Q, D.log(s.Trace, `(${d} transport) sending data. ${q(_, z.logMessageContent)}.`);
        const dt = R(_) ? "arraybuffer" : "text", _t = await w.post(C, { content: _, headers: { ...L, ...z.headers }, responseType: dt, timeout: z.timeout, withCredentials: z.withCredentials });
        D.log(s.Trace, `(${d} transport) request complete. Response status: ${_t.statusCode}.`);
      }
      a(V, "b");
      const ap = class ap {
        constructor(d, w) {
          this.i = d, this.h = w;
        }
        dispose() {
          const d = this.i.observers.indexOf(this.h);
          d > -1 && this.i.observers.splice(d, 1), this.i.observers.length === 0 && this.i.cancelCallback && this.i.cancelCallback().catch(((w) => {
          }));
        }
      };
      a(ap, "v");
      let N = ap;
      const op = class op {
        constructor(d) {
          this.l = d, this.out = console;
        }
        log(d, w) {
          if (d >= this.l) {
            const C = `[${(/* @__PURE__ */ new Date()).toISOString()}] ${s[d]}: ${w}`;
            switch (d) {
              case s.Critical:
              case s.Error:
                this.out.error(C);
                break;
              case s.Warning:
                this.out.warn(C);
                break;
              case s.Information:
                this.out.info(C);
                break;
              default:
                this.out.log(C);
            }
          }
        }
      };
      a(op, "E");
      let Y = op;
      function it() {
        let D = "X-SignalR-User-Agent";
        return T.isNode && (D = "User-Agent"), [D, J(A, Pt(), T.isNode ? "NodeJS" : "Browser", Mt())];
      }
      a(it, "$");
      function J(D, d, w, C) {
        let _ = "Microsoft SignalR/";
        const z = D.split(".");
        return _ += `${z[0]}.${z[1]}`, _ += ` (${D}; `, _ += d && d !== "" ? `${d}; ` : "Unknown OS; ", _ += `${w}`, _ += C ? `; ${C}` : "; Unknown Runtime Version", _ += ")", _;
      }
      a(J, "C");
      function Pt() {
        if (!T.isNode) return "";
        switch (process.platform) {
          case "win32":
            return "Windows NT";
          case "darwin":
            return "macOS";
          case "linux":
            return "Linux";
          default:
            return process.platform;
        }
      }
      a(Pt, "S");
      function Mt() {
        if (T.isNode) return process.versions.node;
      }
      a(Mt, "k");
      function wt(D) {
        return D.stack ? D.stack : D.message ? D.message : `${D}`;
      }
      a(wt, "P");
      const cp = class cp extends S {
        constructor(d) {
          if (super(), this.u = d, typeof fetch > "u" || T.isNode) {
            const w = Mp;
            this.p = new (w("tough-cookie")).CookieJar(), typeof fetch > "u" ? this.m = w("node-fetch") : this.m = fetch, this.m = w("fetch-cookie")(this.m, this.p);
          } else this.m = fetch.bind((function() {
            if (typeof globalThis < "u") return globalThis;
            if (typeof self < "u") return self;
            if (typeof window < "u") return window;
            if (r.g !== void 0) return r.g;
            throw new Error("could not find global");
          })());
          if (typeof AbortController > "u") {
            const w = Mp;
            this.v = w("abort-controller");
          } else this.v = AbortController;
        }
        async send(d) {
          if (d.abortSignal && d.abortSignal.aborted) throw new l();
          if (!d.method) throw new Error("No method defined.");
          if (!d.url) throw new Error("No url defined.");
          const w = new this.v();
          let C;
          d.abortSignal && (d.abortSignal.onabort = () => {
            w.abort(), C = new l();
          });
          let _, z = null;
          if (d.timeout) {
            const Q = d.timeout;
            z = setTimeout((() => {
              w.abort(), this.u.log(s.Warning, "Timeout from HTTP request."), C = new c();
            }), Q);
          }
          d.content === "" && (d.content = void 0), d.content && (d.headers = d.headers || {}, R(d.content) ? d.headers["Content-Type"] = "application/octet-stream" : d.headers["Content-Type"] = "text/plain;charset=UTF-8");
          try {
            _ = await this.m(d.url, { body: d.content, cache: "no-cache", credentials: d.withCredentials === !0 ? "include" : "same-origin", headers: { "X-Requested-With": "XMLHttpRequest", ...d.headers }, method: d.method, mode: "cors", redirect: "follow", signal: w.signal });
          } catch (Q) {
            throw C || (this.u.log(s.Warning, `Error from HTTP request. ${Q}.`), Q);
          } finally {
            z && clearTimeout(z), d.abortSignal && (d.abortSignal.onabort = null);
          }
          if (!_.ok) {
            const Q = await Ot(_, "text");
            throw new o(Q || _.statusText, _.status);
          }
          const L = Ot(_, d.responseType), W = await L;
          return new g(_.status, _.statusText, W);
        }
        getCookieString(d) {
          let w = "";
          return T.isNode && this.p && this.p.getCookies(d, ((C, _) => w = _.join("; "))), w;
        }
      };
      a(cp, "T");
      let pt = cp;
      function Ot(D, d) {
        let w;
        switch (d) {
          case "arraybuffer":
            w = D.arrayBuffer();
            break;
          case "text":
          default:
            w = D.text();
            break;
          case "blob":
          case "document":
          case "json":
            throw new Error(`${d} is not supported.`);
        }
        return w;
      }
      a(Ot, "I");
      const lp = class lp extends S {
        constructor(d) {
          super(), this.u = d;
        }
        send(d) {
          return d.abortSignal && d.abortSignal.aborted ? Promise.reject(new l()) : d.method ? d.url ? new Promise(((w, C) => {
            const _ = new XMLHttpRequest();
            _.open(d.method, d.url, !0), _.withCredentials = d.withCredentials === void 0 || d.withCredentials, _.setRequestHeader("X-Requested-With", "XMLHttpRequest"), d.content === "" && (d.content = void 0), d.content && (R(d.content) ? _.setRequestHeader("Content-Type", "application/octet-stream") : _.setRequestHeader("Content-Type", "text/plain;charset=UTF-8"));
            const z = d.headers;
            z && Object.keys(z).forEach(((L) => {
              _.setRequestHeader(L, z[L]);
            })), d.responseType && (_.responseType = d.responseType), d.abortSignal && (d.abortSignal.onabort = () => {
              _.abort(), C(new l());
            }), d.timeout && (_.timeout = d.timeout), _.onload = () => {
              d.abortSignal && (d.abortSignal.onabort = null), _.status >= 200 && _.status < 300 ? w(new g(_.status, _.statusText, _.response || _.responseText)) : C(new o(_.response || _.responseText || _.statusText, _.status));
            }, _.onerror = () => {
              this.u.log(s.Warning, `Error from HTTP request. ${_.status}: ${_.statusText}.`), C(new o(_.statusText, _.status));
            }, _.ontimeout = () => {
              this.u.log(s.Warning, "Timeout from HTTP request."), C(new c());
            }, _.send(d.content);
          })) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."));
        }
      };
      a(lp, "_");
      let pe = lp;
      const dp = class dp extends S {
        constructor(d) {
          if (super(), typeof fetch < "u" || T.isNode) this.$ = new pt(d);
          else {
            if (typeof XMLHttpRequest > "u") throw new Error("No usable HttpClient found.");
            this.$ = new pe(d);
          }
        }
        send(d) {
          return d.abortSignal && d.abortSignal.aborted ? Promise.reject(new l()) : d.method ? d.url ? this.$.send(d) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."));
        }
        getCookieString(d) {
          return this.$.getCookieString(d);
        }
      };
      a(dp, "H");
      let kt = dp;
      const Xs = class Xs {
        static write(d) {
          return `${d}${Xs.RecordSeparator}`;
        }
        static parse(d) {
          if (d[d.length - 1] !== Xs.RecordSeparator) throw new Error("Message is incomplete.");
          const w = d.split(Xs.RecordSeparator);
          return w.pop(), w;
        }
      };
      a(Xs, "D");
      let ft = Xs;
      ft.RecordSeparatorCode = 30, ft.RecordSeparator = String.fromCharCode(ft.RecordSeparatorCode);
      const hp = class hp {
        writeHandshakeRequest(d) {
          return ft.write(JSON.stringify(d));
        }
        parseHandshakeResponse(d) {
          let w, C;
          if (R(d)) {
            const L = new Uint8Array(d), W = L.indexOf(ft.RecordSeparatorCode);
            if (W === -1) throw new Error("Message is incomplete.");
            const Q = W + 1;
            w = String.fromCharCode.apply(null, Array.prototype.slice.call(L.slice(0, Q))), C = L.byteLength > Q ? L.slice(Q).buffer : null;
          } else {
            const L = d, W = L.indexOf(ft.RecordSeparator);
            if (W === -1) throw new Error("Message is incomplete.");
            const Q = W + 1;
            w = L.substring(0, Q), C = L.length > Q ? L.substring(Q) : null;
          }
          const _ = ft.parse(w), z = JSON.parse(_[0]);
          if (z.type) throw new Error("Expected a handshake response from the server.");
          return [C, z];
        }
      };
      a(hp, "R");
      let Gt = hp;
      var rt, gt;
      (function(D) {
        D[D.Invocation = 1] = "Invocation", D[D.StreamItem = 2] = "StreamItem", D[D.Completion = 3] = "Completion", D[D.StreamInvocation = 4] = "StreamInvocation", D[D.CancelInvocation = 5] = "CancelInvocation", D[D.Ping = 6] = "Ping", D[D.Close = 7] = "Close", D[D.Ack = 8] = "Ack", D[D.Sequence = 9] = "Sequence";
      })(rt || (rt = {}));
      const pp = class pp {
        constructor() {
          this.observers = [];
        }
        next(d) {
          for (const w of this.observers) w.next(d);
        }
        error(d) {
          for (const w of this.observers) w.error && w.error(d);
        }
        complete() {
          for (const d of this.observers) d.complete && d.complete();
        }
        subscribe(d) {
          return this.observers.push(d), new N(this, d);
        }
      };
      a(pp, "U");
      let ri = pp;
      const up = class up {
        constructor(d, w, C) {
          this.C = 1e5, this.S = [], this.k = 0, this.P = !1, this.T = 1, this.I = 0, this._ = 0, this.H = !1, this.D = d, this.R = w, this.C = C;
        }
        async A(d) {
          const w = this.D.writeMessage(d);
          let C = Promise.resolve();
          if (this.U(d)) {
            this.k++;
            let _ = /* @__PURE__ */ a(() => {
            }, "t"), z = /* @__PURE__ */ a(() => {
            }, "i");
            R(w) ? this._ += w.byteLength : this._ += w.length, this._ >= this.C && (C = new Promise(((L, W) => {
              _ = L, z = W;
            }))), this.S.push(new Li(w, this.k, _, z));
          }
          try {
            this.H || await this.R.send(w);
          } catch {
            this.L();
          }
          await C;
        }
        N(d) {
          let w = -1;
          for (let C = 0; C < this.S.length; C++) {
            const _ = this.S[C];
            if (_.q <= d.sequenceId) w = C, R(_.M) ? this._ -= _.M.byteLength : this._ -= _.M.length, _.j();
            else {
              if (!(this._ < this.C)) break;
              _.j();
            }
          }
          w !== -1 && (this.S = this.S.slice(w + 1));
        }
        W(d) {
          if (this.P) return d.type === rt.Sequence && (this.P = !1, !0);
          if (!this.U(d)) return !0;
          const w = this.T;
          return this.T++, w <= this.I ? (w === this.I && this.O(), !1) : (this.I = w, this.O(), !0);
        }
        F(d) {
          d.sequenceId > this.T ? this.R.stop(new Error("Sequence ID greater than amount of messages we've received.")) : this.T = d.sequenceId;
        }
        L() {
          this.H = !0, this.P = !0;
        }
        async B() {
          const d = this.S.length !== 0 ? this.S[0].q : this.k + 1;
          await this.R.send(this.D.writeMessage({ type: rt.Sequence, sequenceId: d }));
          const w = this.S;
          for (const C of w) await this.R.send(C.M);
          this.H = !1;
        }
        X(d) {
          d != null || (d = new Error("Unable to reconnect to server."));
          for (const w of this.S) w.J(d);
        }
        U(d) {
          switch (d.type) {
            case rt.Invocation:
            case rt.StreamItem:
            case rt.Completion:
            case rt.StreamInvocation:
            case rt.CancelInvocation:
              return !0;
            case rt.Close:
            case rt.Sequence:
            case rt.Ping:
            case rt.Ack:
              return !1;
          }
        }
        O() {
          this.V === void 0 && (this.V = setTimeout((async () => {
            try {
              this.H || await this.R.send(this.D.writeMessage({ type: rt.Ack, sequenceId: this.I }));
            } catch {
            }
            clearTimeout(this.V), this.V = void 0;
          }), 1e3));
        }
      };
      a(up, "L");
      let qe = up;
      const yp = class yp {
        constructor(d, w, C, _) {
          this.M = d, this.q = w, this.j = C, this.J = _;
        }
      };
      a(yp, "N");
      let Li = yp;
      (function(D) {
        D.Disconnected = "Disconnected", D.Connecting = "Connecting", D.Connected = "Connected", D.Disconnecting = "Disconnecting", D.Reconnecting = "Reconnecting";
      })(gt || (gt = {}));
      const $d = class $d {
        static create(d, w, C, _, z, L, W) {
          return new $d(d, w, C, _, z, L, W);
        }
        constructor(d, w, C, _, z, L, W) {
          this.K = 0, this.G = () => {
            this.u.log(s.Warning, "The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep");
          }, E.isRequired(d, "connection"), E.isRequired(w, "logger"), E.isRequired(C, "protocol"), this.serverTimeoutInMilliseconds = z ?? 3e4, this.keepAliveIntervalInMilliseconds = L ?? 15e3, this.Y = W ?? 1e5, this.u = w, this.D = C, this.connection = d, this.Z = _, this.tt = new Gt(), this.connection.onreceive = (Q) => this.et(Q), this.connection.onclose = (Q) => this.st(Q), this.it = {}, this.nt = {}, this.rt = [], this.ot = [], this.ht = [], this.ct = 0, this.lt = !1, this.ut = gt.Disconnected, this.dt = !1, this.ft = this.D.writeMessage({ type: rt.Ping });
        }
        get state() {
          return this.ut;
        }
        get connectionId() {
          return this.connection && this.connection.connectionId || null;
        }
        get baseUrl() {
          return this.connection.baseUrl || "";
        }
        set baseUrl(d) {
          if (this.ut !== gt.Disconnected && this.ut !== gt.Reconnecting) throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");
          if (!d) throw new Error("The HubConnection url must be a valid url.");
          this.connection.baseUrl = d;
        }
        start() {
          return this.wt = this.gt(), this.wt;
        }
        async gt() {
          if (this.ut !== gt.Disconnected) return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));
          this.ut = gt.Connecting, this.u.log(s.Debug, "Starting HubConnection.");
          try {
            await this.yt(), T.isBrowser && window.document.addEventListener("freeze", this.G), this.ut = gt.Connected, this.dt = !0, this.u.log(s.Debug, "HubConnection connected successfully.");
          } catch (d) {
            return this.ut = gt.Disconnected, this.u.log(s.Debug, `HubConnection failed to start successfully because of error '${d}'.`), Promise.reject(d);
          }
        }
        async yt() {
          this.bt = void 0, this.lt = !1;
          const d = new Promise(((w, C) => {
            this.vt = w, this.Et = C;
          }));
          await this.connection.start(this.D.transferFormat);
          try {
            let w = this.D.version;
            this.connection.features.reconnect || (w = 1);
            const C = { protocol: this.D.name, version: w };
            if (this.u.log(s.Debug, "Sending handshake request."), await this.$t(this.tt.writeHandshakeRequest(C)), this.u.log(s.Information, `Using HubProtocol '${this.D.name}'.`), this.Ct(), this.St(), this.kt(), await d, this.bt) throw this.bt;
            this.connection.features.reconnect && (this.Pt = new qe(this.D, this.connection, this.Y), this.connection.features.disconnected = this.Pt.L.bind(this.Pt), this.connection.features.resend = () => {
              if (this.Pt) return this.Pt.B();
            }), this.connection.features.inherentKeepAlive || await this.$t(this.ft);
          } catch (w) {
            throw this.u.log(s.Debug, `Hub handshake failed with error '${w}' during start(). Stopping HubConnection.`), this.Ct(), this.Tt(), await this.connection.stop(w), w;
          }
        }
        async stop() {
          const d = this.wt;
          this.connection.features.reconnect = !1, this.It = this._t(), await this.It;
          try {
            await d;
          } catch {
          }
        }
        _t(d) {
          if (this.ut === gt.Disconnected) return this.u.log(s.Debug, `Call to HubConnection.stop(${d}) ignored because it is already in the disconnected state.`), Promise.resolve();
          if (this.ut === gt.Disconnecting) return this.u.log(s.Debug, `Call to HttpConnection.stop(${d}) ignored because the connection is already in the disconnecting state.`), this.It;
          const w = this.ut;
          return this.ut = gt.Disconnecting, this.u.log(s.Debug, "Stopping HubConnection."), this.Ht ? (this.u.log(s.Debug, "Connection stopped during reconnect delay. Done reconnecting."), clearTimeout(this.Ht), this.Ht = void 0, this.Dt(), Promise.resolve()) : (w === gt.Connected && this.Rt(), this.Ct(), this.Tt(), this.bt = d || new l("The connection was stopped before the hub handshake could complete."), this.connection.stop(d));
        }
        async Rt() {
          try {
            await this.xt(this.At());
          } catch {
          }
        }
        stream(d, ...w) {
          const [C, _] = this.Ut(w), z = this.Lt(d, w, _);
          let L;
          const W = new ri();
          return W.cancelCallback = () => {
            const Q = this.Nt(z.invocationId);
            return delete this.it[z.invocationId], L.then((() => this.xt(Q)));
          }, this.it[z.invocationId] = (Q, dt) => {
            dt ? W.error(dt) : Q && (Q.type === rt.Completion ? Q.error ? W.error(new Error(Q.error)) : W.complete() : W.next(Q.item));
          }, L = this.xt(z).catch(((Q) => {
            W.error(Q), delete this.it[z.invocationId];
          })), this.qt(C, L), W;
        }
        $t(d) {
          return this.kt(), this.connection.send(d);
        }
        xt(d) {
          return this.Pt ? this.Pt.A(d) : this.$t(this.D.writeMessage(d));
        }
        send(d, ...w) {
          const [C, _] = this.Ut(w), z = this.xt(this.Mt(d, w, !0, _));
          return this.qt(C, z), z;
        }
        invoke(d, ...w) {
          const [C, _] = this.Ut(w), z = this.Mt(d, w, !1, _);
          return new Promise(((L, W) => {
            this.it[z.invocationId] = (dt, _t) => {
              _t ? W(_t) : dt && (dt.type === rt.Completion ? dt.error ? W(new Error(dt.error)) : L(dt.result) : W(new Error(`Unexpected message type: ${dt.type}`)));
            };
            const Q = this.xt(z).catch(((dt) => {
              W(dt), delete this.it[z.invocationId];
            }));
            this.qt(C, Q);
          }));
        }
        on(d, w) {
          d && w && (d = d.toLowerCase(), this.nt[d] || (this.nt[d] = []), this.nt[d].indexOf(w) === -1 && this.nt[d].push(w));
        }
        off(d, w) {
          if (!d) return;
          d = d.toLowerCase();
          const C = this.nt[d];
          if (C) if (w) {
            const _ = C.indexOf(w);
            _ !== -1 && (C.splice(_, 1), C.length === 0 && delete this.nt[d]);
          } else delete this.nt[d];
        }
        onclose(d) {
          d && this.rt.push(d);
        }
        onreconnecting(d) {
          d && this.ot.push(d);
        }
        onreconnected(d) {
          d && this.ht.push(d);
        }
        et(d) {
          if (this.Ct(), this.lt || (d = this.jt(d), this.lt = !0), d) {
            const w = this.D.parseMessages(d, this.u);
            for (const C of w) if (!this.Pt || this.Pt.W(C)) switch (C.type) {
              case rt.Invocation:
                this.Wt(C).catch(((_) => {
                  this.u.log(s.Error, `Invoke client method threw error: ${wt(_)}`);
                }));
                break;
              case rt.StreamItem:
              case rt.Completion: {
                const _ = this.it[C.invocationId];
                if (_) {
                  C.type === rt.Completion && delete this.it[C.invocationId];
                  try {
                    _(C);
                  } catch (z) {
                    this.u.log(s.Error, `Stream callback threw error: ${wt(z)}`);
                  }
                }
                break;
              }
              case rt.Ping:
                break;
              case rt.Close: {
                this.u.log(s.Information, "Close message received from server.");
                const _ = C.error ? new Error("Server returned an error on close: " + C.error) : void 0;
                C.allowReconnect === !0 ? this.connection.stop(_) : this.It = this._t(_);
                break;
              }
              case rt.Ack:
                this.Pt && this.Pt.N(C);
                break;
              case rt.Sequence:
                this.Pt && this.Pt.F(C);
                break;
              default:
                this.u.log(s.Warning, `Invalid message type: ${C.type}.`);
            }
          }
          this.St();
        }
        jt(d) {
          let w, C;
          try {
            [C, w] = this.tt.parseHandshakeResponse(d);
          } catch (_) {
            const z = "Error parsing handshake response: " + _;
            this.u.log(s.Error, z);
            const L = new Error(z);
            throw this.Et(L), L;
          }
          if (w.error) {
            const _ = "Server returned handshake error: " + w.error;
            this.u.log(s.Error, _);
            const z = new Error(_);
            throw this.Et(z), z;
          }
          return this.u.log(s.Debug, "Server handshake complete."), this.vt(), C;
        }
        kt() {
          this.connection.features.inherentKeepAlive || (this.K = (/* @__PURE__ */ new Date()).getTime() + this.keepAliveIntervalInMilliseconds, this.Tt());
        }
        St() {
          if (!(this.connection.features && this.connection.features.inherentKeepAlive || (this.Ot = setTimeout((() => this.serverTimeout()), this.serverTimeoutInMilliseconds), this.Ft !== void 0))) {
            let d = this.K - (/* @__PURE__ */ new Date()).getTime();
            d < 0 && (d = 0), this.Ft = setTimeout((async () => {
              if (this.ut === gt.Connected) try {
                await this.$t(this.ft);
              } catch {
                this.Tt();
              }
            }), d);
          }
        }
        serverTimeout() {
          this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."));
        }
        async Wt(d) {
          const w = d.target.toLowerCase(), C = this.nt[w];
          if (!C) return this.u.log(s.Warning, `No client method with the name '${w}' found.`), void (d.invocationId && (this.u.log(s.Warning, `No result given for '${w}' method and invocation ID '${d.invocationId}'.`), await this.xt(this.Bt(d.invocationId, "Client didn't provide a result.", null))));
          const _ = C.slice(), z = !!d.invocationId;
          let L, W, Q;
          for (const dt of _) try {
            const _t = L;
            L = await dt.apply(this, d.arguments), z && L && _t && (this.u.log(s.Error, `Multiple results provided for '${w}'. Sending error to server.`), Q = this.Bt(d.invocationId, "Client provided multiple results.", null)), W = void 0;
          } catch (_t) {
            W = _t, this.u.log(s.Error, `A callback for the method '${w}' threw error '${_t}'.`);
          }
          Q ? await this.xt(Q) : z ? (W ? Q = this.Bt(d.invocationId, `${W}`, null) : L !== void 0 ? Q = this.Bt(d.invocationId, null, L) : (this.u.log(s.Warning, `No result given for '${w}' method and invocation ID '${d.invocationId}'.`), Q = this.Bt(d.invocationId, "Client didn't provide a result.", null)), await this.xt(Q)) : L && this.u.log(s.Error, `Result given for '${w}' method but server is not expecting a result.`);
        }
        st(d) {
          this.u.log(s.Debug, `HubConnection.connectionClosed(${d}) called while in state ${this.ut}.`), this.bt = this.bt || d || new l("The underlying connection was closed before the hub handshake could complete."), this.vt && this.vt(), this.Xt(d || new Error("Invocation canceled due to the underlying connection being closed.")), this.Ct(), this.Tt(), this.ut === gt.Disconnecting ? this.Dt(d) : this.ut === gt.Connected && this.Z ? this.Jt(d) : this.ut === gt.Connected && this.Dt(d);
        }
        Dt(d) {
          if (this.dt) {
            this.ut = gt.Disconnected, this.dt = !1, this.Pt && (this.Pt.X(d ?? new Error("Connection closed.")), this.Pt = void 0), T.isBrowser && window.document.removeEventListener("freeze", this.G);
            try {
              this.rt.forEach(((w) => w.apply(this, [d])));
            } catch (w) {
              this.u.log(s.Error, `An onclose callback called with error '${d}' threw error '${w}'.`);
            }
          }
        }
        async Jt(d) {
          const w = Date.now();
          let C = 0, _ = d !== void 0 ? d : new Error("Attempting to reconnect due to a unknown error."), z = this.zt(C++, 0, _);
          if (z === null) return this.u.log(s.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."), void this.Dt(d);
          if (this.ut = gt.Reconnecting, d ? this.u.log(s.Information, `Connection reconnecting because of error '${d}'.`) : this.u.log(s.Information, "Connection reconnecting."), this.ot.length !== 0) {
            try {
              this.ot.forEach(((L) => L.apply(this, [d])));
            } catch (L) {
              this.u.log(s.Error, `An onreconnecting callback called with error '${d}' threw error '${L}'.`);
            }
            if (this.ut !== gt.Reconnecting) return void this.u.log(s.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.");
          }
          for (; z !== null; ) {
            if (this.u.log(s.Information, `Reconnect attempt number ${C} will start in ${z} ms.`), await new Promise(((L) => {
              this.Ht = setTimeout(L, z);
            })), this.Ht = void 0, this.ut !== gt.Reconnecting) return void this.u.log(s.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting.");
            try {
              if (await this.yt(), this.ut = gt.Connected, this.u.log(s.Information, "HubConnection reconnected successfully."), this.ht.length !== 0) try {
                this.ht.forEach(((L) => L.apply(this, [this.connection.connectionId])));
              } catch (L) {
                this.u.log(s.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${L}'.`);
              }
              return;
            } catch (L) {
              if (this.u.log(s.Information, `Reconnect attempt failed because of error '${L}'.`), this.ut !== gt.Reconnecting) return this.u.log(s.Debug, `Connection moved to the '${this.ut}' from the reconnecting state during reconnect attempt. Done reconnecting.`), void (this.ut === gt.Disconnecting && this.Dt());
              _ = L instanceof Error ? L : new Error(L.toString()), z = this.zt(C++, Date.now() - w, _);
            }
          }
          this.u.log(s.Information, `Reconnect retries have been exhausted after ${Date.now() - w} ms and ${C} failed attempts. Connection disconnecting.`), this.Dt();
        }
        zt(d, w, C) {
          try {
            return this.Z.nextRetryDelayInMilliseconds({ elapsedMilliseconds: w, previousRetryCount: d, retryReason: C });
          } catch (_) {
            return this.u.log(s.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${d}, ${w}) threw error '${_}'.`), null;
          }
        }
        Xt(d) {
          const w = this.it;
          this.it = {}, Object.keys(w).forEach(((C) => {
            const _ = w[C];
            try {
              _(null, d);
            } catch (z) {
              this.u.log(s.Error, `Stream 'error' callback called with '${d}' threw error: ${wt(z)}`);
            }
          }));
        }
        Tt() {
          this.Ft && (clearTimeout(this.Ft), this.Ft = void 0);
        }
        Ct() {
          this.Ot && clearTimeout(this.Ot);
        }
        Mt(d, w, C, _) {
          if (C) return _.length !== 0 ? { target: d, arguments: w, streamIds: _, type: rt.Invocation } : { target: d, arguments: w, type: rt.Invocation };
          {
            const z = this.ct;
            return this.ct++, _.length !== 0 ? { target: d, arguments: w, invocationId: z.toString(), streamIds: _, type: rt.Invocation } : { target: d, arguments: w, invocationId: z.toString(), type: rt.Invocation };
          }
        }
        qt(d, w) {
          if (d.length !== 0) {
            w || (w = Promise.resolve());
            for (const C in d) d[C].subscribe({ complete: /* @__PURE__ */ a(() => {
              w = w.then((() => this.xt(this.Bt(C))));
            }, "complete"), error: /* @__PURE__ */ a((_) => {
              let z;
              z = _ instanceof Error ? _.message : _ && _.toString ? _.toString() : "Unknown error", w = w.then((() => this.xt(this.Bt(C, z))));
            }, "error"), next: /* @__PURE__ */ a((_) => {
              w = w.then((() => this.xt(this.Vt(C, _))));
            }, "next") });
          }
        }
        Ut(d) {
          const w = [], C = [];
          for (let _ = 0; _ < d.length; _++) {
            const z = d[_];
            if (this.Kt(z)) {
              const L = this.ct;
              this.ct++, w[L] = z, C.push(L.toString()), d.splice(_, 1);
            }
          }
          return [w, C];
        }
        Kt(d) {
          return d && d.subscribe && typeof d.subscribe == "function";
        }
        Lt(d, w, C) {
          const _ = this.ct;
          return this.ct++, C.length !== 0 ? { target: d, arguments: w, invocationId: _.toString(), streamIds: C, type: rt.StreamInvocation } : { target: d, arguments: w, invocationId: _.toString(), type: rt.StreamInvocation };
        }
        Nt(d) {
          return { invocationId: d, type: rt.CancelInvocation };
        }
        Vt(d, w) {
          return { invocationId: d, item: w, type: rt.StreamItem };
        }
        Bt(d, w, C) {
          return w ? { error: w, invocationId: d, type: rt.Completion } : { invocationId: d, result: C, type: rt.Completion };
        }
        At() {
          return { type: rt.Close };
        }
      };
      a($d, "q");
      let Oi = $d;
      const Xc = [0, 2e3, 1e4, 3e4, null], wp = class wp {
        constructor(d) {
          this.Gt = d !== void 0 ? [...d, null] : Xc;
        }
        nextRetryDelayInMilliseconds(d) {
          return this.Gt[d.previousRetryCount];
        }
      };
      a(wp, "j");
      let ui = wp;
      const fp = class fp {
      };
      a(fp, "W");
      let mt = fp;
      mt.Authorization = "Authorization", mt.Cookie = "Cookie";
      const mp = class mp extends S {
        constructor(d, w) {
          super(), this.Qt = d, this.Yt = w;
        }
        async send(d) {
          let w = !0;
          this.Yt && (!this.Zt || d.url && d.url.indexOf("/negotiate?") > 0) && (w = !1, this.Zt = await this.Yt()), this.te(d);
          const C = await this.Qt.send(d);
          return w && C.statusCode === 401 && this.Yt ? (this.Zt = await this.Yt(), this.te(d), await this.Qt.send(d)) : C;
        }
        te(d) {
          d.headers || (d.headers = {}), this.Zt ? d.headers[mt.Authorization] = `Bearer ${this.Zt}` : this.Yt && d.headers[mt.Authorization] && delete d.headers[mt.Authorization];
        }
        getCookieString(d) {
          return this.Qt.getCookieString(d);
        }
      };
      a(mp, "O");
      let ze = mp;
      var Ct, Zt;
      (function(D) {
        D[D.None = 0] = "None", D[D.WebSockets = 1] = "WebSockets", D[D.ServerSentEvents = 2] = "ServerSentEvents", D[D.LongPolling = 4] = "LongPolling";
      })(Ct || (Ct = {})), (function(D) {
        D[D.Text = 1] = "Text", D[D.Binary = 2] = "Binary";
      })(Zt || (Zt = {}));
      const vp = class vp {
        constructor() {
          this.ee = !1, this.onabort = null;
        }
        abort() {
          this.ee || (this.ee = !0, this.onabort && this.onabort());
        }
        get signal() {
          return this;
        }
        get aborted() {
          return this.ee;
        }
      };
      a(vp, "X");
      let Bh = vp;
      const gp = class gp {
        get pollAborted() {
          return this.se.aborted;
        }
        constructor(d, w, C) {
          this.$ = d, this.u = w, this.se = new Bh(), this.ie = C, this.ne = !1, this.onreceive = null, this.onclose = null;
        }
        async connect(d, w) {
          if (E.isRequired(d, "url"), E.isRequired(w, "transferFormat"), E.isIn(w, Zt, "transferFormat"), this.re = d, this.u.log(s.Trace, "(LongPolling transport) Connecting."), w === Zt.Binary && typeof XMLHttpRequest < "u" && typeof new XMLHttpRequest().responseType != "string") throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");
          const [C, _] = it(), z = { [C]: _, ...this.ie.headers }, L = { abortSignal: this.se.signal, headers: z, timeout: 1e5, withCredentials: this.ie.withCredentials };
          w === Zt.Binary && (L.responseType = "arraybuffer");
          const W = `${d}&_=${Date.now()}`;
          this.u.log(s.Trace, `(LongPolling transport) polling: ${W}.`);
          const Q = await this.$.get(W, L);
          Q.statusCode !== 200 ? (this.u.log(s.Error, `(LongPolling transport) Unexpected response code: ${Q.statusCode}.`), this.oe = new o(Q.statusText || "", Q.statusCode), this.ne = !1) : this.ne = !0, this.he = this.ce(this.re, L);
        }
        async ce(d, w) {
          try {
            for (; this.ne; ) try {
              const C = `${d}&_=${Date.now()}`;
              this.u.log(s.Trace, `(LongPolling transport) polling: ${C}.`);
              const _ = await this.$.get(C, w);
              _.statusCode === 204 ? (this.u.log(s.Information, "(LongPolling transport) Poll terminated by server."), this.ne = !1) : _.statusCode !== 200 ? (this.u.log(s.Error, `(LongPolling transport) Unexpected response code: ${_.statusCode}.`), this.oe = new o(_.statusText || "", _.statusCode), this.ne = !1) : _.content ? (this.u.log(s.Trace, `(LongPolling transport) data received. ${q(_.content, this.ie.logMessageContent)}.`), this.onreceive && this.onreceive(_.content)) : this.u.log(s.Trace, "(LongPolling transport) Poll timed out, reissuing.");
            } catch (C) {
              this.ne ? C instanceof c ? this.u.log(s.Trace, "(LongPolling transport) Poll timed out, reissuing.") : (this.oe = C, this.ne = !1) : this.u.log(s.Trace, `(LongPolling transport) Poll errored after shutdown: ${C.message}`);
            }
          } finally {
            this.u.log(s.Trace, "(LongPolling transport) Polling complete."), this.pollAborted || this.ae();
          }
        }
        async send(d) {
          return this.ne ? V(this.u, "LongPolling", this.$, this.re, d, this.ie) : Promise.reject(new Error("Cannot send until the transport is connected"));
        }
        async stop() {
          this.u.log(s.Trace, "(LongPolling transport) Stopping polling."), this.ne = !1, this.se.abort();
          try {
            await this.he, this.u.log(s.Trace, `(LongPolling transport) sending DELETE request to ${this.re}.`);
            const d = {}, [w, C] = it();
            d[w] = C;
            const _ = { headers: { ...d, ...this.ie.headers }, timeout: this.ie.timeout, withCredentials: this.ie.withCredentials };
            let z;
            try {
              await this.$.delete(this.re, _);
            } catch (L) {
              z = L;
            }
            z ? z instanceof o && (z.statusCode === 404 ? this.u.log(s.Trace, "(LongPolling transport) A 404 response was returned from sending a DELETE request.") : this.u.log(s.Trace, `(LongPolling transport) Error sending a DELETE request: ${z}`)) : this.u.log(s.Trace, "(LongPolling transport) DELETE request accepted.");
          } finally {
            this.u.log(s.Trace, "(LongPolling transport) Stop finished."), this.ae();
          }
        }
        ae() {
          if (this.onclose) {
            let d = "(LongPolling transport) Firing onclose event.";
            this.oe && (d += " Error: " + this.oe), this.u.log(s.Trace, d), this.onclose(this.oe);
          }
        }
      };
      a(gp, "J");
      let bd = gp;
      const bp = class bp {
        constructor(d, w, C, _) {
          this.$ = d, this.Zt = w, this.u = C, this.ie = _, this.onreceive = null, this.onclose = null;
        }
        async connect(d, w) {
          return E.isRequired(d, "url"), E.isRequired(w, "transferFormat"), E.isIn(w, Zt, "transferFormat"), this.u.log(s.Trace, "(SSE transport) Connecting."), this.re = d, this.Zt && (d += (d.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(this.Zt)}`), new Promise(((C, _) => {
            let z, L = !1;
            if (w === Zt.Text) {
              if (T.isBrowser || T.isWebWorker) z = new this.ie.EventSource(d, { withCredentials: this.ie.withCredentials });
              else {
                const W = this.$.getCookieString(d), Q = {};
                Q.Cookie = W;
                const [dt, _t] = it();
                Q[dt] = _t, z = new this.ie.EventSource(d, { withCredentials: this.ie.withCredentials, headers: { ...Q, ...this.ie.headers } });
              }
              try {
                z.onmessage = (W) => {
                  if (this.onreceive) try {
                    this.u.log(s.Trace, `(SSE transport) data received. ${q(W.data, this.ie.logMessageContent)}.`), this.onreceive(W.data);
                  } catch (Q) {
                    return void this.le(Q);
                  }
                }, z.onerror = (W) => {
                  L ? this.le() : _(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled."));
                }, z.onopen = () => {
                  this.u.log(s.Information, `SSE connected to ${this.re}`), this.ue = z, L = !0, C();
                };
              } catch (W) {
                return void _(W);
              }
            } else _(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));
          }));
        }
        async send(d) {
          return this.ue ? V(this.u, "SSE", this.$, this.re, d, this.ie) : Promise.reject(new Error("Cannot send until the transport is connected"));
        }
        stop() {
          return this.le(), Promise.resolve();
        }
        le(d) {
          this.ue && (this.ue.close(), this.ue = void 0, this.onclose && this.onclose(d));
        }
      };
      a(bp, "z");
      let qh = bp;
      const xp = class xp {
        constructor(d, w, C, _, z, L) {
          this.u = C, this.Yt = w, this.de = _, this.fe = z, this.$ = d, this.onreceive = null, this.onclose = null, this.pe = L;
        }
        async connect(d, w) {
          let C;
          return E.isRequired(d, "url"), E.isRequired(w, "transferFormat"), E.isIn(w, Zt, "transferFormat"), this.u.log(s.Trace, "(WebSockets transport) Connecting."), this.Yt && (C = await this.Yt()), new Promise(((_, z) => {
            let L;
            d = d.replace(/^http/, "ws");
            const W = this.$.getCookieString(d);
            let Q = !1;
            if (T.isNode || T.isReactNative) {
              const dt = {}, [_t, Js] = it();
              dt[_t] = Js, C && (dt[mt.Authorization] = `Bearer ${C}`), W && (dt[mt.Cookie] = W), L = new this.fe(d, void 0, { headers: { ...dt, ...this.pe } });
            } else C && (d += (d.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(C)}`);
            L || (L = new this.fe(d)), w === Zt.Binary && (L.binaryType = "arraybuffer"), L.onopen = (dt) => {
              this.u.log(s.Information, `WebSocket connected to ${d}.`), this.we = L, Q = !0, _();
            }, L.onerror = (dt) => {
              let _t = null;
              _t = typeof ErrorEvent < "u" && dt instanceof ErrorEvent ? dt.error : "There was an error with the transport", this.u.log(s.Information, `(WebSockets transport) ${_t}.`);
            }, L.onmessage = (dt) => {
              if (this.u.log(s.Trace, `(WebSockets transport) data received. ${q(dt.data, this.de)}.`), this.onreceive) try {
                this.onreceive(dt.data);
              } catch (_t) {
                return void this.le(_t);
              }
            }, L.onclose = (dt) => {
              if (Q) this.le(dt);
              else {
                let _t = null;
                _t = typeof ErrorEvent < "u" && dt instanceof ErrorEvent ? dt.error : "WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.", z(new Error(_t));
              }
            };
          }));
        }
        send(d) {
          return this.we && this.we.readyState === this.fe.OPEN ? (this.u.log(s.Trace, `(WebSockets transport) sending data. ${q(d, this.de)}.`), this.we.send(d), Promise.resolve()) : Promise.reject("WebSocket is not in the OPEN state");
        }
        stop() {
          return this.we && this.le(void 0), Promise.resolve();
        }
        le(d) {
          this.we && (this.we.onclose = () => {
          }, this.we.onmessage = () => {
          }, this.we.onerror = () => {
          }, this.we.close(), this.we = void 0), this.u.log(s.Trace, "(WebSockets transport) socket closed."), this.onclose && (!this.ge(d) || d.wasClean !== !1 && d.code === 1e3 ? d instanceof Error ? this.onclose(d) : this.onclose() : this.onclose(new Error(`WebSocket closed with status code: ${d.code} (${d.reason || "no reason given"}).`)));
        }
        ge(d) {
          return d && typeof d.wasClean == "boolean" && typeof d.code == "number";
        }
      };
      a(xp, "V");
      let Nh = xp;
      const $p = class $p {
        constructor(d, w = {}) {
          var C;
          if (this.me = () => {
          }, this.features = {}, this.ye = 1, E.isRequired(d, "url"), this.u = (C = w.logger) === void 0 ? new Y(s.Information) : C === null ? I.instance : C.log !== void 0 ? C : new Y(C), this.baseUrl = this.be(d), (w = w || {}).logMessageContent = w.logMessageContent !== void 0 && w.logMessageContent, typeof w.withCredentials != "boolean" && w.withCredentials !== void 0) throw new Error("withCredentials option was not a 'boolean' or 'undefined' value");
          w.withCredentials = w.withCredentials === void 0 || w.withCredentials, w.timeout = w.timeout === void 0 ? 1e5 : w.timeout;
          let _ = null, z = null;
          if (T.isNode) {
            const L = Mp;
            _ = L("ws"), z = L("eventsource");
          }
          T.isNode || typeof WebSocket > "u" || w.WebSocket ? T.isNode && !w.WebSocket && _ && (w.WebSocket = _) : w.WebSocket = WebSocket, T.isNode || typeof EventSource > "u" || w.EventSource ? T.isNode && !w.EventSource && z !== void 0 && (w.EventSource = z) : w.EventSource = EventSource, this.$ = new ze(w.httpClient || new kt(this.u), w.accessTokenFactory), this.ut = "Disconnected", this.dt = !1, this.ie = w, this.onreceive = null, this.onclose = null;
        }
        async start(d) {
          if (d = d || Zt.Binary, E.isIn(d, Zt, "transferFormat"), this.u.log(s.Debug, `Starting connection with transfer format '${Zt[d]}'.`), this.ut !== "Disconnected") return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."));
          if (this.ut = "Connecting", this.ve = this.yt(d), await this.ve, this.ut === "Disconnecting") {
            const w = "Failed to start the HttpConnection before stop() was called.";
            return this.u.log(s.Error, w), await this.It, Promise.reject(new l(w));
          }
          if (this.ut !== "Connected") {
            const w = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";
            return this.u.log(s.Error, w), Promise.reject(new l(w));
          }
          this.dt = !0;
        }
        send(d) {
          return this.ut !== "Connected" ? Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State.")) : (this.Ee || (this.Ee = new Wh(this.transport)), this.Ee.send(d));
        }
        async stop(d) {
          return this.ut === "Disconnected" ? (this.u.log(s.Debug, `Call to HttpConnection.stop(${d}) ignored because the connection is already in the disconnected state.`), Promise.resolve()) : this.ut === "Disconnecting" ? (this.u.log(s.Debug, `Call to HttpConnection.stop(${d}) ignored because the connection is already in the disconnecting state.`), this.It) : (this.ut = "Disconnecting", this.It = new Promise(((w) => {
            this.me = w;
          })), await this._t(d), void await this.It);
        }
        async _t(d) {
          this.$e = d;
          try {
            await this.ve;
          } catch {
          }
          if (this.transport) {
            try {
              await this.transport.stop();
            } catch (w) {
              this.u.log(s.Error, `HttpConnection.transport.stop() threw error '${w}'.`), this.Ce();
            }
            this.transport = void 0;
          } else this.u.log(s.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.");
        }
        async yt(d) {
          let w = this.baseUrl;
          this.Yt = this.ie.accessTokenFactory, this.$.Yt = this.Yt;
          try {
            if (this.ie.skipNegotiation) {
              if (this.ie.transport !== Ct.WebSockets) throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");
              this.transport = this.Se(Ct.WebSockets), await this.ke(w, d);
            } else {
              let C = null, _ = 0;
              do {
                if (C = await this.Pe(w), this.ut === "Disconnecting" || this.ut === "Disconnected") throw new l("The connection was stopped during negotiation.");
                if (C.error) throw new Error(C.error);
                if (C.ProtocolVersion) throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");
                if (C.url && (w = C.url), C.accessToken) {
                  const z = C.accessToken;
                  this.Yt = () => z, this.$.Zt = z, this.$.Yt = void 0;
                }
                _++;
              } while (C.url && _ < 100);
              if (_ === 100 && C.url) throw new Error("Negotiate redirection limit exceeded.");
              await this.Te(w, this.ie.transport, C, d);
            }
            this.transport instanceof bd && (this.features.inherentKeepAlive = !0), this.ut === "Connecting" && (this.u.log(s.Debug, "The HttpConnection connected successfully."), this.ut = "Connected");
          } catch (C) {
            return this.u.log(s.Error, "Failed to start the connection: " + C), this.ut = "Disconnected", this.transport = void 0, this.me(), Promise.reject(C);
          }
        }
        async Pe(d) {
          const w = {}, [C, _] = it();
          w[C] = _;
          const z = this.Ie(d);
          this.u.log(s.Debug, `Sending negotiation request: ${z}.`);
          try {
            const L = await this.$.post(z, { content: "", headers: { ...w, ...this.ie.headers }, timeout: this.ie.timeout, withCredentials: this.ie.withCredentials });
            if (L.statusCode !== 200) return Promise.reject(new Error(`Unexpected status code returned from negotiate '${L.statusCode}'`));
            const W = JSON.parse(L.content);
            return (!W.negotiateVersion || W.negotiateVersion < 1) && (W.connectionToken = W.connectionId), W.useStatefulReconnect && this.ie._e !== !0 ? Promise.reject(new m("Client didn't negotiate Stateful Reconnect but the server did.")) : W;
          } catch (L) {
            let W = "Failed to complete negotiation with the server: " + L;
            return L instanceof o && L.statusCode === 404 && (W += " Either this is not a SignalR endpoint or there is a proxy blocking the connection."), this.u.log(s.Error, W), Promise.reject(new m(W));
          }
        }
        He(d, w) {
          return w ? d + (d.indexOf("?") === -1 ? "?" : "&") + `id=${w}` : d;
        }
        async Te(d, w, C, _) {
          let z = this.He(d, C.connectionToken);
          if (this.De(w)) return this.u.log(s.Debug, "Connection was provided an instance of ITransport, using that directly."), this.transport = w, await this.ke(z, _), void (this.connectionId = C.connectionId);
          const L = [], W = C.availableTransports || [];
          let Q = C;
          for (const dt of W) {
            const _t = this.Re(dt, w, _, Q?.useStatefulReconnect === !0);
            if (_t instanceof Error) L.push(`${dt.transport} failed:`), L.push(_t);
            else if (this.De(_t)) {
              if (this.transport = _t, !Q) {
                try {
                  Q = await this.Pe(d);
                } catch (Js) {
                  return Promise.reject(Js);
                }
                z = this.He(d, Q.connectionToken);
              }
              try {
                return await this.ke(z, _), void (this.connectionId = Q.connectionId);
              } catch (Js) {
                if (this.u.log(s.Error, `Failed to start the transport '${dt.transport}': ${Js}`), Q = void 0, L.push(new $(`${dt.transport} failed: ${Js}`, Ct[dt.transport])), this.ut !== "Connecting") {
                  const bw = "Failed to select transport before stop() was called.";
                  return this.u.log(s.Debug, bw), Promise.reject(new l(bw));
                }
              }
            }
          }
          return L.length > 0 ? Promise.reject(new x(`Unable to connect to the server with any of the available transports. ${L.join(" ")}`, L)) : Promise.reject(new Error("None of the transports supported by the client are supported by the server."));
        }
        Se(d) {
          switch (d) {
            case Ct.WebSockets:
              if (!this.ie.WebSocket) throw new Error("'WebSocket' is not supported in your environment.");
              return new Nh(this.$, this.Yt, this.u, this.ie.logMessageContent, this.ie.WebSocket, this.ie.headers || {});
            case Ct.ServerSentEvents:
              if (!this.ie.EventSource) throw new Error("'EventSource' is not supported in your environment.");
              return new qh(this.$, this.$.Zt, this.u, this.ie);
            case Ct.LongPolling:
              return new bd(this.$, this.u, this.ie);
            default:
              throw new Error(`Unknown transport: ${d}.`);
          }
        }
        ke(d, w) {
          return this.transport.onreceive = this.onreceive, this.features.reconnect ? this.transport.onclose = async (C) => {
            let _ = !1;
            if (this.features.reconnect) {
              try {
                this.features.disconnected(), await this.transport.connect(d, w), await this.features.resend();
              } catch {
                _ = !0;
              }
              _ && this.Ce(C);
            } else this.Ce(C);
          } : this.transport.onclose = (C) => this.Ce(C), this.transport.connect(d, w);
        }
        Re(d, w, C, _) {
          const z = Ct[d.transport];
          if (z == null) return this.u.log(s.Debug, `Skipping transport '${d.transport}' because it is not supported by this client.`), new Error(`Skipping transport '${d.transport}' because it is not supported by this client.`);
          if (!(function(L, W) {
            return !L || !!(W & L);
          })(w, z)) return this.u.log(s.Debug, `Skipping transport '${Ct[z]}' because it was disabled by the client.`), new f(`'${Ct[z]}' is disabled by the client.`, z);
          if (!(d.transferFormats.map(((L) => Zt[L])).indexOf(C) >= 0)) return this.u.log(s.Debug, `Skipping transport '${Ct[z]}' because it does not support the requested transfer format '${Zt[C]}'.`), new Error(`'${Ct[z]}' does not support ${Zt[C]}.`);
          if (z === Ct.WebSockets && !this.ie.WebSocket || z === Ct.ServerSentEvents && !this.ie.EventSource) return this.u.log(s.Debug, `Skipping transport '${Ct[z]}' because it is not supported in your environment.'`), new u(`'${Ct[z]}' is not supported in your environment.`, z);
          this.u.log(s.Debug, `Selecting transport '${Ct[z]}'.`);
          try {
            return this.features.reconnect = z === Ct.WebSockets ? _ : void 0, this.Se(z);
          } catch (L) {
            return L;
          }
        }
        De(d) {
          return d && typeof d == "object" && "connect" in d;
        }
        Ce(d) {
          if (this.u.log(s.Debug, `HttpConnection.stopConnection(${d}) called while in state ${this.ut}.`), this.transport = void 0, d = this.$e || d, this.$e = void 0, this.ut !== "Disconnected") {
            if (this.ut === "Connecting") throw this.u.log(s.Warning, `Call to HttpConnection.stopConnection(${d}) was ignored because the connection is still in the connecting state.`), new Error(`HttpConnection.stopConnection(${d}) was called while the connection is still in the connecting state.`);
            if (this.ut === "Disconnecting" && this.me(), d ? this.u.log(s.Error, `Connection disconnected with error '${d}'.`) : this.u.log(s.Information, "Connection disconnected."), this.Ee && (this.Ee.stop().catch(((w) => {
              this.u.log(s.Error, `TransportSendQueue.stop() threw error '${w}'.`);
            })), this.Ee = void 0), this.connectionId = void 0, this.ut = "Disconnected", this.dt) {
              this.dt = !1;
              try {
                this.onclose && this.onclose(d);
              } catch (w) {
                this.u.log(s.Error, `HttpConnection.onclose(${d}) threw error '${w}'.`);
              }
            }
          } else this.u.log(s.Debug, `Call to HttpConnection.stopConnection(${d}) was ignored because the connection is already in the disconnected state.`);
        }
        be(d) {
          if (d.lastIndexOf("https://", 0) === 0 || d.lastIndexOf("http://", 0) === 0) return d;
          if (!T.isBrowser) throw new Error(`Cannot resolve '${d}'.`);
          const w = window.document.createElement("a");
          return w.href = d, this.u.log(s.Information, `Normalizing '${d}' to '${w.href}'.`), w.href;
        }
        Ie(d) {
          const w = new URL(d);
          w.pathname.endsWith("/") ? w.pathname += "negotiate" : w.pathname += "/negotiate";
          const C = new URLSearchParams(w.searchParams);
          return C.has("negotiateVersion") || C.append("negotiateVersion", this.ye.toString()), C.has("useStatefulReconnect") ? C.get("useStatefulReconnect") === "true" && (this.ie._e = !0) : this.ie._e === !0 && C.append("useStatefulReconnect", "true"), w.search = C.toString(), w.toString();
        }
      };
      a($p, "K");
      let jh = $p;
      const Cd = class Cd {
        constructor(d) {
          this.xe = d, this.Ae = [], this.Ue = !0, this.Le = new Zs(), this.Ne = new Zs(), this.qe = this.Me();
        }
        send(d) {
          return this.je(d), this.Ne || (this.Ne = new Zs()), this.Ne.promise;
        }
        stop() {
          return this.Ue = !1, this.Le.resolve(), this.qe;
        }
        je(d) {
          if (this.Ae.length && typeof this.Ae[0] != typeof d) throw new Error(`Expected data to be of type ${typeof this.Ae} but was of type ${typeof d}`);
          this.Ae.push(d), this.Le.resolve();
        }
        async Me() {
          for (; ; ) {
            if (await this.Le.promise, !this.Ue) {
              this.Ne && this.Ne.reject("Connection stopped.");
              break;
            }
            this.Le = new Zs();
            const d = this.Ne;
            this.Ne = void 0;
            const w = typeof this.Ae[0] == "string" ? this.Ae.join("") : Cd.We(this.Ae);
            this.Ae.length = 0;
            try {
              await this.xe.send(w), d.resolve();
            } catch (C) {
              d.reject(C);
            }
          }
        }
        static We(d) {
          const w = d.map(((z) => z.byteLength)).reduce(((z, L) => z + L)), C = new Uint8Array(w);
          let _ = 0;
          for (const z of d) C.set(new Uint8Array(z), _), _ += z.byteLength;
          return C.buffer;
        }
      };
      a(Cd, "G");
      let Wh = Cd;
      const Cp = class Cp {
        constructor() {
          this.promise = new Promise(((d, w) => [this.j, this.Oe] = [d, w]));
        }
        resolve() {
          this.j();
        }
        reject(d) {
          this.Oe(d);
        }
      };
      a(Cp, "Q");
      let Zs = Cp;
      const kp = class kp {
        constructor() {
          this.name = "json", this.version = 2, this.transferFormat = Zt.Text;
        }
        parseMessages(d, w) {
          if (typeof d != "string") throw new Error("Invalid input for JSON hub protocol. Expected a string.");
          if (!d) return [];
          w === null && (w = I.instance);
          const C = ft.parse(d), _ = [];
          for (const z of C) {
            const L = JSON.parse(z);
            if (typeof L.type != "number") throw new Error("Invalid payload.");
            switch (L.type) {
              case rt.Invocation:
                this.U(L);
                break;
              case rt.StreamItem:
                this.Fe(L);
                break;
              case rt.Completion:
                this.Be(L);
                break;
              case rt.Ping:
              case rt.Close:
                break;
              case rt.Ack:
                this.Xe(L);
                break;
              case rt.Sequence:
                this.Je(L);
                break;
              default:
                w.log(s.Information, "Unknown message type '" + L.type + "' ignored.");
                continue;
            }
            _.push(L);
          }
          return _;
        }
        writeMessage(d) {
          return ft.write(JSON.stringify(d));
        }
        U(d) {
          this.ze(d.target, "Invalid payload for Invocation message."), d.invocationId !== void 0 && this.ze(d.invocationId, "Invalid payload for Invocation message.");
        }
        Fe(d) {
          if (this.ze(d.invocationId, "Invalid payload for StreamItem message."), d.item === void 0) throw new Error("Invalid payload for StreamItem message.");
        }
        Be(d) {
          if (d.result && d.error) throw new Error("Invalid payload for Completion message.");
          !d.result && d.error && this.ze(d.error, "Invalid payload for Completion message."), this.ze(d.invocationId, "Invalid payload for Completion message.");
        }
        Xe(d) {
          if (typeof d.sequenceId != "number") throw new Error("Invalid SequenceId for Ack message.");
        }
        Je(d) {
          if (typeof d.sequenceId != "number") throw new Error("Invalid SequenceId for Sequence message.");
        }
        ze(d, w) {
          if (typeof d != "string" || d === "") throw new Error(w);
        }
      };
      a(kp, "Y");
      let xd = kp;
      const Yv = { trace: s.Trace, debug: s.Debug, info: s.Information, information: s.Information, warn: s.Warning, warning: s.Warning, error: s.Error, critical: s.Critical, none: s.None }, _p = class _p {
        configureLogging(d) {
          if (E.isRequired(d, "logging"), d.log !== void 0) this.logger = d;
          else if (typeof d == "string") {
            const w = (function(C) {
              const _ = Yv[C.toLowerCase()];
              if (_ !== void 0) return _;
              throw new Error(`Unknown log level: ${C}`);
            })(d);
            this.logger = new Y(w);
          } else this.logger = new Y(d);
          return this;
        }
        withUrl(d, w) {
          return E.isRequired(d, "url"), E.isNotEmpty(d, "url"), this.url = d, this.httpConnectionOptions = typeof w == "object" ? { ...this.httpConnectionOptions, ...w } : { ...this.httpConnectionOptions, transport: w }, this;
        }
        withHubProtocol(d) {
          return E.isRequired(d, "protocol"), this.protocol = d, this;
        }
        withAutomaticReconnect(d) {
          if (this.reconnectPolicy) throw new Error("A reconnectPolicy has already been set.");
          return d ? Array.isArray(d) ? this.reconnectPolicy = new ui(d) : this.reconnectPolicy = d : this.reconnectPolicy = new ui(), this;
        }
        withServerTimeout(d) {
          return E.isRequired(d, "milliseconds"), this.Ve = d, this;
        }
        withKeepAliveInterval(d) {
          return E.isRequired(d, "milliseconds"), this.Ke = d, this;
        }
        withStatefulReconnect(d) {
          return this.httpConnectionOptions === void 0 && (this.httpConnectionOptions = {}), this.httpConnectionOptions._e = !0, this.Y = d?.bufferSize, this;
        }
        build() {
          const d = this.httpConnectionOptions || {};
          if (d.logger === void 0 && (d.logger = this.logger), !this.url) throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");
          const w = new jh(this.url, d);
          return Oi.create(w, this.logger || I.instance, this.protocol || new xd(), this.reconnectPolicy, this.Ve, this.Ke, this.Y);
        }
      };
      a(_p, "tt");
      let Qh = _p;
      return Uint8Array.prototype.indexOf || Object.defineProperty(Uint8Array.prototype, "indexOf", { value: Array.prototype.indexOf, writable: !0 }), Uint8Array.prototype.slice || Object.defineProperty(Uint8Array.prototype, "slice", { value: /* @__PURE__ */ a(function(D, d) {
        return new Uint8Array(Array.prototype.slice.call(this, D, d));
      }, "value"), writable: !0 }), Uint8Array.prototype.forEach || Object.defineProperty(Uint8Array.prototype, "forEach", { value: Array.prototype.forEach, writable: !0 }), n;
    })(), "e"), i.exports = e();
  })(Sp)), Sp.exports;
}
a(_1, "requireSignalr_min");
var kw = /* @__PURE__ */ _1();
const P1 = /* @__PURE__ */ a((i) => {
  var t;
  return t = class extends i {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), this._whenConnectionRequested = new Promise((s) => {
        this._resolveConnectionRequested = s;
      }), this._whenConnectionCreated = new Promise((s) => {
        this._resolveConnectionCreated = s;
      }), this._connectionEventListeners = [], this.signalRAccessTokenRefresh = !1, this._whenConnectionStarted = new Promise((s, n) => {
        this._whenConnectionStartedResolve = s, this._whenConnectionStartedReject = n;
      }), this.whenConnectionRequested().then(() => {
        this.isDestroyed || this.createConnection();
      });
    }
    async whenConnectionRequested() {
      await this._whenConnectionRequested;
    }
    async whenConnectionCreated() {
      return await this._whenConnectionCreated;
    }
    get rtmConnection() {
      return this._connection;
    }
    async whenConnectionStarted() {
      return await this._whenConnectionStarted;
    }
    async createConnection() {
      if (this.isDestroyed)
        throw new Tt();
      if (this.networkStateIsPending = !0, await this.whenUrlAndTokenFactory(), this._connection) {
        const r = new URL("/hubs/rtm", this.url);
        this._connection.baseUrl !== r.toString() && (this.connectionState = "reconnecting", console.info(
          this.weavyId,
          "Reconnecting due to changed url.",
          this._connection.baseUrl,
          "=>",
          r.toString()
        ), await this.disconnect(), this._connection.baseUrl = r.toString(), this.connect());
      } else {
        this.connectionState = "connecting";
        const r = new URL("/hubs/rtm", this.url);
        this._connection = new kw.HubConnectionBuilder().configureLogging(kw.LogLevel.None).withUrl(r.toString(), {
          accessTokenFactory: /* @__PURE__ */ a(async () => {
            try {
              if (this.signalRAccessTokenRefresh) {
                const s = await this.getToken(!0);
                return this.signalRAccessTokenRefresh = !1, s;
              } else
                return await this.getToken();
            } catch (s) {
              throw console.error(s), s;
            }
          }, "accessTokenFactory")
        }).withAutomaticReconnect({
          nextRetryDelayInMilliseconds: /* @__PURE__ */ a((s) => !this.isDestroyed && window.navigator.onLine && document?.visibilityState !== "hidden" && s.elapsedMilliseconds < 6e4 ? [0, 2e3, 1e4][s.previousRetryCount] || 1e4 : null, "nextRetryDelayInMilliseconds")
        }).build(), this._connection.onclose(() => {
          console.info(this.weavyId, "SignalR closed."), this.connectionState = "disconnected", !this.isDestroyed && (this.networkStateIsPending = !0, this._whenConnectionStarted = new Promise((s, n) => {
            this._whenConnectionStartedResolve = s, this._whenConnectionStartedReject = n;
          }), this.connect());
        }), this._connection.onreconnecting(() => {
          console.info(this.weavyId, "SignalR reconnecting..."), this.connectionState = "reconnecting";
        }), this._connection.onreconnected((s) => {
          console.info(this.weavyId, `SignalR reconnected ${s}`), this.connectionState = "connected", this.networkStateIsPending = !1;
          for (let n = 0; n < this._connectionEventListeners.length; n++)
            this._connection?.invoke("Subscribe", this._connectionEventListeners[n].name);
        }), this._resolveConnectionCreated?.(this._connection), this.connect();
      }
      return this._connection;
    }
    async disconnect() {
      this._connection && (await this._connection.stop(), this.connectionState = "disconnected");
    }
    async connect() {
      if (this.isDestroyed)
        throw new Tt();
      let r;
      this._connection ? r = this._connection : r = await this.whenConnectionCreated(), console.info(this.weavyId, "Connecting SignalR...");
      try {
        if (!window.navigator.onLine)
          throw new Error();
        await Promise.race([r.start(), this.whenConnectionStarted()]), this.signalRAccessTokenRefresh = !1, this.networkStateIsPending = !1, this.connectionState = "connected", this._whenConnectionStartedResolve?.(r), console.info(this.weavyId, `SignalR connected ${r.connectionId}`);
      } catch (s) {
        if (s instanceof Tt)
          return console.warn(this.weavyId, "SignalR connection aborted."), r;
        window.navigator.onLine ? !this.signalRAccessTokenRefresh && window.document.visibilityState !== "hidden" && s.toString().includes("Unauthorized") ? (console.info(this.weavyId, "Retrying SignalR connect with fresh token."), this.signalRAccessTokenRefresh = !0) : (console.info(
          this.weavyId,
          "Server is probably down, retrying SignalR connect after a delay or when window regains focus."
        ), this.connectionState = "reconnecting", await new Promise((n) => {
          setTimeout(n, 5e3), window.addEventListener("visibilitychange", n, { once: !0 }), window.addEventListener("offline", n, { once: !0 }), window.addEventListener("online", n, { once: !0 });
        })) : (this.networkStateIsPending = !1, console.info(this.weavyId, "Offline, reconnecting SignalR when online."), await new Promise((n) => {
          window.addEventListener("online", n, { once: !0 });
        })), window.navigator.onLine && document?.visibilityState !== "hidden" && await new Promise((n) => setTimeout(n, 1e3)), this.checkVersion(), this.networkStateIsPending = !0, await this.connect();
      }
      return r;
    }
    async subscribe(r, s, n) {
      if (this.isDestroyed)
        throw new Tt();
      this._resolveConnectionRequested?.(!0);
      const o = r ? r + ":" + s : s;
      try {
        if (this._connectionEventListeners || await new Promise((l) => queueMicrotask(() => l(!0))), this._connectionEventListeners.some((l) => l.name === o && l.callback === n))
          throw new Error("Duplicate subscribe: " + o);
        if (this._connectionEventListeners.push({ name: o, callback: n }), await this.whenConnectionStarted(), !this._connection)
          throw new Error("Connection not created");
        if (this._connection.on(o, n), await this._connection.invoke("Subscribe", o) === !1)
          throw new Error("Could not subscribe to " + o);
        return !0;
      } catch (c) {
        c instanceof Tt || console.error(this.weavyId, "Error in Subscribe:", c);
        const l = this._connectionEventListeners.findIndex((u) => u.name === o && u.callback === n);
        return l !== -1 && (this._connectionEventListeners.splice(l, 1), this._connection?.off(o, n)), !1;
      }
    }
    async unsubscribe(r, s, n) {
      if (this.isDestroyed)
        throw new Tt();
      try {
        const o = r ? r + ":" + s : s, c = this._connectionEventListeners.findIndex((l) => l.name === o && l.callback === n);
        if (c !== -1) {
          if (this._connectionEventListeners.splice(c, 1), await this.whenConnectionStarted(), !this._connection)
            throw new Error("Connection not created");
          this._connection?.off(o, n), this._connectionEventListeners.some((l) => l.name === o) || await this._connection.invoke("Unsubscribe", o);
        }
      } catch (o) {
        o instanceof Tt || console.error(this.weavyId, "Error in Unsubscribe:", o);
      }
    }
    destroy() {
      super.destroy(), this.disconnect(), this._whenConnectionStartedReject && (this._whenConnectionStarted.catch(() => {
      }), this._whenConnectionStartedReject(new Tt()));
    }
  }, a(t, "WeavyConnection"), t;
}, "WeavyConnectionMixin");
var Fd = /* @__PURE__ */ ((i) => (i.JSON = "application/json;charset=utf-8", i.FormData = "multipart/form-data;charset=utf-8", i.URLEncoded = "application/x-www-form-urlencoded;charset=utf-8", i.Text = "text/plain;charset=utf-8", i.Auto = "", i))(Fd || {});
const M1 = /* @__PURE__ */ a((i) => {
  var t;
  return t = class extends i {
    // FETCH
    async fetchOptions(r = {}, s = !0) {
      if (this.isDestroyed)
        throw new Tt();
      const n = {
        headers: {
          "X-Weavy-Source": `${te.sourceName}@${te.version}`,
          "Content-Type": Fd.JSON
        },
        method: "GET"
      }, o = yn(yn(b1, n, !0), r, !0);
      return s ? yn(
        o,
        {
          headers: {
            Authorization: "Bearer " + await this.getToken()
          }
        },
        !0
      ) : o;
    }
    async fetch(r, s, n = !0) {
      if (this.isDestroyed)
        throw new Tt();
      const o = await this.fetchOptions(s);
      this.networkStateIsPending = !0;
      const c = await fetch(new URL(r, this.url), o);
      if (c.ok)
        this.networkStateIsPending = !1, this.serverState = "ok";
      else if (c.status === 401 || c.status === 403) {
        if (n)
          return await this.getToken(!0), await this.fetch(r, s, !1);
        this.networkStateIsPending = !1, this.serverState = "unauthorized";
      } else
        this.networkStateIsPending = !1;
      return c;
    }
    async upload(r, s, n, o = Fd.JSON, c, l, u = !0) {
      if (this.isDestroyed)
        throw new Tt();
      const f = await this.getToken();
      return await new Promise(($, m) => {
        const x = new XMLHttpRequest();
        x.open(s, new URL(r, this.url), !0), x.setRequestHeader("Authorization", "Bearer " + f), x.setRequestHeader("X-Weavy-Source", `${te.sourceName}@${te.version}`), o && x.setRequestHeader("Content-Type", o), c && x.upload.addEventListener("progress", (g) => {
          c(g.loaded / g.total * 100 || 100);
        }), x.onload = (g) => {
          u && (x.status === 401 || x.status === 401) ? this.getToken(!0).then(() => this.upload(r, s, n, o, c, l, !1)).then($).catch(m) : $(new Response(x.response, { status: x.status, statusText: x.statusText }));
        }, x.onerror = m, x.onabort = m, l?.addEventListener("abort", () => {
          x.abort();
        }), x.send(n);
      });
    }
    // DEPRECATED
    async get(r) {
      return console.warn(`weavy.get() is deprecated, use weavy.fetch("${r}") instead.`), this.fetch(r);
    }
    // DEPRECATED
    async post(r, s, n, o) {
      console.warn(
        `weavy.post() is deprecated, use weavy.fetch("${r}", { method: "${s}"}) instead.`
      );
      const c = o ? { "Content-Type": o } : void 0;
      return this.fetch(r, { method: s, body: n, headers: c });
    }
  }, a(t, "WeavyFetch"), t;
}, "WeavyFetchMixin"), Nf = "en", S1 = /* @__PURE__ */ a((i) => {
  var t;
  return t = class extends i {
    constructor() {
      super(...arguments), this._locales = /* @__PURE__ */ new Map([
        ["sv-SE", () => import(
          /* webpackIgnore: true */
          /* @vite-ignore */
          new URL("./es/locales/sv-SE-DNn-JJCG.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
        ).then((r) => r.svSE)]
      ]), this._locale = t.sourceLocale;
    }
    /**
     * The locale used in the Weavy source.
     */
    static get sourceLocale() {
      try {
        return Nf;
      } catch {
        return "";
      }
    }
    get locales() {
      return Array.from(this._locales.entries());
    }
    set locales(r) {
      if (this.isDestroyed)
        throw new Tt();
      if (this.localization)
        throw new Error("Locales may only be configured once");
      if (r) {
        if (!Array.isArray(r))
          throw new TypeError("Provided locales have invalid format.");
        r.forEach((s) => {
          if (!Array.isArray(s) || s.length !== 2 || typeof s[0] != "string")
            throw new TypeError("Invalid locale provided: " + s[0]);
          this._locales.set(...s);
        }), this.configureLocalization();
      }
    }
    get localization() {
      return this._localization;
    }
    /**
     * Selected locale. The locale must be pre configured in `.locales`.
     */
    get locale() {
      return this._locale;
    }
    set locale(r) {
      if (this.isDestroyed)
        throw new Tt();
      !this._locale && !r || (r ||= t.sourceLocale, this._locale = r, this.localization ? this.localization.setLocale(this._locale) : queueMicrotask(() => {
        this.localization ? this.localization.setLocale(this._locale) : this._locale !== t.sourceLocale && (this._locales.has(this._locale) && this.configureLocalization(), this.localization ? this.localization.setLocale(this._locale) : console.error(
          this.weavyId,
          `You need to configure additional languages in config to use '${r}'.`
        ));
      }));
    }
    async loadLocale(r) {
      if (this.isDestroyed)
        throw new Tt();
      if (this._locales?.has(r)) {
        const s = this._locales.get(r);
        return console.info(
          this.weavyId,
          typeof s == "function" ? "loading locale" : "preloaded locale",
          r
        ), await (typeof s == "function" ? s() : s);
      } else
        throw new Error("The requested locale is not configured");
    }
    configureLocalization() {
      if (this.isDestroyed)
        throw new Tt();
      if (this._locales?.size && !this.localization) {
        const r = this._locales.keys();
        console.info(this.weavyId, "Configuring locales", r);
        const { getLocale: s, setLocale: n } = r1({
          sourceLocale: t.sourceLocale,
          targetLocales: r,
          loadLocale: /* @__PURE__ */ a((o) => this.loadLocale(o), "loadLocale")
        });
        this._localization = {
          getLocale: s,
          setLocale: n
        };
      }
    }
  }, a(t, "WeavyLocalization"), t;
}, "WeavyLocalizationMixin"), A1 = /* @__PURE__ */ a((i) => {
  var t;
  return t = class extends i {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), this._configurationState = "pending", this._networkEvents = /* @__PURE__ */ new Set(), this._connectionState = "connecting", this._serverState = "ok", this._networkState = window.navigator.onLine ? "online" : "offline", this._networkStateIsPending = !1, window.addEventListener("online", () => {
        this.networkState = "online";
      }), window.addEventListener("offline", () => {
        this.networkState = "offline", this.networkStateIsPending = !1;
      }), queueMicrotask(() => this.requestConfigurationCheck());
    }
    get configurationState() {
      return this._configurationState;
    }
    set configurationState(r) {
      this._configurationState = r, this._configurationTimer && r === "configured" && (window.clearTimeout(this._configurationTimer), this._configurationTimer = null), this.triggerNetworkChange();
    }
    get networkState() {
      return this._networkState;
    }
    set networkState(r) {
      this._networkState = r, this.triggerNetworkChange();
    }
    get serverState() {
      return this._serverState;
    }
    set serverState(r) {
      this._serverState = r, this.triggerNetworkChange();
    }
    get connectionState() {
      return this._connectionState;
    }
    set connectionState(r) {
      this._connectionState = r, this.triggerNetworkChange();
    }
    get networkStateIsPending() {
      return this._networkStateIsPending;
    }
    set networkStateIsPending(r) {
      this._networkStateIsPending = r, this.triggerNetworkChange();
    }
    get network() {
      return {
        state: this._networkState === "online" ? (this._connectionState === "connected" || this._serverState === "ok") && this.configurationState !== "uninitialized" ? "online" : "unreachable" : "offline",
        isPending: this._networkStateIsPending
      };
    }
    requestConfigurationCheck() {
      !this._configurationTimer && this.configurationTimeout >= 0 && this.configurationTimeout < 1 / 0 && (this._configurationTimer = window.setTimeout(() => {
        this.configurationState === "pending" && (this.configurationState = "uninitialized", console.error("Weavy was not configured with required url and tokenFactory/tokenUrl within a reasonable time. Please check your configuration!")), this._configurationTimer = null;
      }, this.configurationTimeout));
    }
    triggerNetworkChange() {
      const r = this.network;
      this._networkEvents.forEach((s) => {
        s(r);
      });
    }
    addNetworkListener(r) {
      this._networkEvents.add(r);
    }
    removeNetworkListener(r) {
      this._networkEvents.delete(r);
    }
  }, a(t, "WeavyNetwork"), t;
}, "WeavyNetworkMixin");
var vn, Fc = (vn = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, a(vn, "Subscribable"), vn), z1 = {
  // We need the wrapper function syntax below instead of direct references to
  // global setTimeout etc.
  //
  // BAD: `setTimeout: setTimeout`
  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
  //
  // If we use direct references here, then anything that wants to spy on or
  // replace the global setTimeout (like tests) won't work since we'll already
  // have a hard reference to the original implementation at the time when this
  // file was imported.
  setTimeout: /* @__PURE__ */ a((i, t) => setTimeout(i, t), "setTimeout"),
  clearTimeout: /* @__PURE__ */ a((i) => clearTimeout(i), "clearTimeout"),
  setInterval: /* @__PURE__ */ a((i, t) => setInterval(i, t), "setInterval"),
  clearInterval: /* @__PURE__ */ a((i) => clearInterval(i), "clearInterval")
}, pr, Hu, gn, R1 = (gn = class {
  constructor() {
    // We cannot have TimeoutManager<T> as we must instantiate it with a concrete
    // type at app boot; and if we leave that type, then any new timer provider
    // would need to support ReturnType<typeof setTimeout>, which is infeasible.
    //
    // We settle for type safety for the TimeoutProvider type, and accept that
    // this class is unsafe internally to allow for extension.
    O(this, pr, z1);
    O(this, Hu, !1);
  }
  setTimeoutProvider(t) {
    P(this, pr, t);
  }
  setTimeout(t, e) {
    return y(this, pr).setTimeout(t, e);
  }
  clearTimeout(t) {
    y(this, pr).clearTimeout(t);
  }
  setInterval(t, e) {
    return y(this, pr).setInterval(t, e);
  }
  clearInterval(t) {
    y(this, pr).clearInterval(t);
  }
}, pr = new WeakMap(), Hu = new WeakMap(), a(gn, "TimeoutManager"), gn), Cr = new R1();
function E1(i) {
  setTimeout(i, 0);
}
a(E1, "systemSetTimeoutZero");
var uc = typeof window > "u" || "Deno" in globalThis;
function me() {
}
a(me, "noop$1");
function L1(i, t) {
  return typeof i == "function" ? i(t) : i;
}
a(L1, "functionalUpdate");
function Np(i) {
  return typeof i == "number" && i >= 0 && i !== 1 / 0;
}
a(Np, "isValidTimeout");
function jf(i, t) {
  return Math.max(i + (t || 0) - Date.now(), 0);
}
a(jf, "timeUntilStale");
function Pr(i, t) {
  return typeof i == "function" ? i(t) : i;
}
a(Pr, "resolveStaleTime");
function Ye(i, t) {
  return typeof i == "function" ? i(t) : i;
}
a(Ye, "resolveEnabled");
function _w(i, t) {
  const {
    type: e = "all",
    exact: r,
    fetchStatus: s,
    predicate: n,
    queryKey: o,
    stale: c
  } = i;
  if (o) {
    if (r) {
      if (t.queryHash !== Bu(o, t.options))
        return !1;
    } else if (!cl(t.queryKey, o))
      return !1;
  }
  if (e !== "all") {
    const l = t.isActive();
    if (e === "active" && !l || e === "inactive" && l)
      return !1;
  }
  return !(typeof c == "boolean" && t.isStale() !== c || s && s !== t.state.fetchStatus || n && !n(t));
}
a(_w, "matchQuery");
function Pw(i, t) {
  const { exact: e, status: r, predicate: s, mutationKey: n } = i;
  if (n) {
    if (!t.options.mutationKey)
      return !1;
    if (e) {
      if (ws(t.options.mutationKey) !== ws(n))
        return !1;
    } else if (!cl(t.options.mutationKey, n))
      return !1;
  }
  return !(r && t.state.status !== r || s && !s(t));
}
a(Pw, "matchMutation");
function Bu(i, t) {
  return (t?.queryKeyHashFn || ws)(i);
}
a(Bu, "hashQueryKeyByOptions");
function ws(i) {
  return JSON.stringify(
    i,
    (t, e) => jp(e) ? Object.keys(e).sort().reduce((r, s) => (r[s] = e[s], r), {}) : e
  );
}
a(ws, "hashKey");
function cl(i, t) {
  return i === t ? !0 : typeof i != typeof t ? !1 : i && t && typeof i == "object" && typeof t == "object" ? Object.keys(t).every((e) => cl(i[e], t[e])) : !1;
}
a(cl, "partialMatchKey");
var O1 = Object.prototype.hasOwnProperty;
function rd(i, t, e = 0) {
  if (i === t)
    return i;
  if (e > 500) return t;
  const r = Mw(i) && Mw(t);
  if (!r && !(jp(i) && jp(t))) return t;
  const n = (r ? i : Object.keys(i)).length, o = r ? t : Object.keys(t), c = o.length, l = r ? new Array(c) : {};
  let u = 0;
  for (let f = 0; f < c; f++) {
    const $ = r ? f : o[f], m = i[$], x = t[$];
    if (m === x) {
      l[$] = m, (r ? f < n : O1.call(i, $)) && u++;
      continue;
    }
    if (m === null || x === null || typeof m != "object" || typeof x != "object") {
      l[$] = x;
      continue;
    }
    const g = rd(m, x, e + 1);
    l[$] = g, g === m && u++;
  }
  return n === c && u === n ? i : l;
}
a(rd, "replaceEqualDeep");
function Dd(i, t) {
  if (!t || Object.keys(i).length !== Object.keys(t).length)
    return !1;
  for (const e in i)
    if (i[e] !== t[e])
      return !1;
  return !0;
}
a(Dd, "shallowEqualObjects");
function Mw(i) {
  return Array.isArray(i) && i.length === Object.keys(i).length;
}
a(Mw, "isPlainArray");
function jp(i) {
  if (!Sw(i))
    return !1;
  const t = i.constructor;
  if (t === void 0)
    return !0;
  const e = t.prototype;
  return !(!Sw(e) || !e.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(i) !== Object.prototype);
}
a(jp, "isPlainObject");
function Sw(i) {
  return Object.prototype.toString.call(i) === "[object Object]";
}
a(Sw, "hasObjectPrototype");
function I1(i) {
  return new Promise((t) => {
    Cr.setTimeout(t, i);
  });
}
a(I1, "sleep");
function Wp(i, t, e) {
  return typeof e.structuralSharing == "function" ? e.structuralSharing(i, t) : e.structuralSharing !== !1 ? rd(i, t) : t;
}
a(Wp, "replaceData");
function T1(i, t, e = 0) {
  const r = [...i, t];
  return e && r.length > e ? r.slice(1) : r;
}
a(T1, "addToEnd");
function F1(i, t, e = 0) {
  const r = [t, ...i];
  return e && r.length > e ? r.slice(0, -1) : r;
}
a(F1, "addToStart");
var qu = Symbol();
function Wf(i, t) {
  return !i.queryFn && t?.initialPromise ? () => t.initialPromise : !i.queryFn || i.queryFn === qu ? () => Promise.reject(new Error(`Missing queryFn: '${i.queryHash}'`)) : i.queryFn;
}
a(Wf, "ensureQueryFn");
function D1(i, t, e) {
  let r = !1, s;
  return Object.defineProperty(i, "signal", {
    enumerable: !0,
    get: /* @__PURE__ */ a(() => (s ??= t(), r || (r = !0, s.aborted ? e() : s.addEventListener("abort", e, { once: !0 })), s), "get")
  }), i;
}
a(D1, "addConsumeAwareSignal");
var Xr, ur, bn, xn, H1 = (xn = class extends Fc {
  constructor() {
    super();
    O(this, Xr);
    O(this, ur);
    O(this, bn);
    P(this, bn, (e) => {
      if (!uc && window.addEventListener) {
        const r = /* @__PURE__ */ a(() => e(), "listener");
        return window.addEventListener("visibilitychange", r, !1), () => {
          window.removeEventListener("visibilitychange", r);
        };
      }
    });
  }
  onSubscribe() {
    y(this, ur) || this.setEventListener(y(this, bn));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = y(this, ur)) == null || e.call(this), P(this, ur, void 0));
  }
  setEventListener(e) {
    var r;
    P(this, bn, e), (r = y(this, ur)) == null || r.call(this), P(this, ur, e((s) => {
      typeof s == "boolean" ? this.setFocused(s) : this.onFocus();
    }));
  }
  setFocused(e) {
    y(this, Xr) !== e && (P(this, Xr, e), this.onFocus());
  }
  onFocus() {
    const e = this.isFocused();
    this.listeners.forEach((r) => {
      r(e);
    });
  }
  isFocused() {
    return typeof y(this, Xr) == "boolean" ? y(this, Xr) : globalThis.document?.visibilityState !== "hidden";
  }
}, Xr = new WeakMap(), ur = new WeakMap(), bn = new WeakMap(), a(xn, "FocusManager"), xn), Nu = new H1();
function Qp() {
  let i, t;
  const e = new Promise((s, n) => {
    i = s, t = n;
  });
  e.status = "pending", e.catch(() => {
  });
  function r(s) {
    Object.assign(e, s), delete e.resolve, delete e.reject;
  }
  return a(r, "finalize"), e.resolve = (s) => {
    r({
      status: "fulfilled",
      value: s
    }), i(s);
  }, e.reject = (s) => {
    r({
      status: "rejected",
      reason: s
    }), t(s);
  }, e;
}
a(Qp, "pendingThenable");
function V1(i) {
  let t;
  if (i.then((e) => (t = e, e), me)?.catch(me), t !== void 0)
    return { data: t };
}
a(V1, "tryResolveSync");
function Qf(i) {
  return i;
}
a(Qf, "defaultTransformerFn");
function U1(i) {
  return {
    mutationKey: i.options.mutationKey,
    state: i.state,
    ...i.options.scope && { scope: i.options.scope },
    ...i.meta && { meta: i.meta }
  };
}
a(U1, "dehydrateMutation");
function B1(i, t, e) {
  const r = /* @__PURE__ */ a(() => {
    const s = i.promise?.then(t).catch((n) => e(n) ? Promise.reject(new Error("redacted")) : Promise.reject(n));
    return s?.catch(me), s;
  }, "dehydratePromise");
  return {
    dehydratedAt: Date.now(),
    state: {
      ...i.state,
      ...i.state.data !== void 0 && {
        data: t(i.state.data)
      }
    },
    queryKey: i.queryKey,
    queryHash: i.queryHash,
    ...i.state.status === "pending" && {
      promise: r()
    },
    ...i.meta && { meta: i.meta }
  };
}
a(B1, "dehydrateQuery");
function q1(i) {
  return i.state.isPaused;
}
a(q1, "defaultShouldDehydrateMutation");
function N1(i) {
  return i.state.status === "success";
}
a(N1, "defaultShouldDehydrateQuery");
function j1(i) {
  return !0;
}
a(j1, "defaultShouldRedactErrors");
function W1(i, t = {}) {
  const e = t.shouldDehydrateMutation ?? i.getDefaultOptions().dehydrate?.shouldDehydrateMutation ?? q1, r = i.getMutationCache().getAll().flatMap(
    (l) => e(l) ? [U1(l)] : []
  ), s = t.shouldDehydrateQuery ?? i.getDefaultOptions().dehydrate?.shouldDehydrateQuery ?? N1, n = t.shouldRedactErrors ?? i.getDefaultOptions().dehydrate?.shouldRedactErrors ?? j1, o = t.serializeData ?? i.getDefaultOptions().dehydrate?.serializeData ?? Qf, c = i.getQueryCache().getAll().flatMap(
    (l) => s(l) ? [B1(l, o, n)] : []
  );
  return { mutations: r, queries: c };
}
a(W1, "dehydrate");
function Q1(i, t, e) {
  if (typeof t != "object" || t === null)
    return;
  const r = i.getMutationCache(), s = i.getQueryCache(), n = i.getDefaultOptions().hydrate?.deserializeData ?? Qf, o = t.mutations || [], c = t.queries || [];
  o.forEach(({ state: l, ...u }) => {
    r.build(
      i,
      {
        ...i.getDefaultOptions().hydrate?.mutations,
        ...e?.defaultOptions?.mutations,
        ...u
      },
      l
    );
  }), c.forEach(
    ({ queryKey: l, state: u, queryHash: f, meta: $, promise: m, dehydratedAt: x }) => {
      const g = m ? V1(m) : void 0, S = u.data === void 0 ? g?.data : u.data, I = S === void 0 ? S : n(S);
      let A = s.get(f);
      const E = A?.state.status === "pending", T = A?.state.fetchStatus === "fetching";
      if (A) {
        const q = g && // We only need this undefined check to handle older dehydration
        // payloads that might not have dehydratedAt
        x !== void 0 && x > A.state.dataUpdatedAt;
        if (u.dataUpdatedAt > A.state.dataUpdatedAt || q) {
          const { fetchStatus: R, ...V } = u;
          A.setState({
            ...V,
            data: I
          });
        }
      } else
        A = s.build(
          i,
          {
            ...i.getDefaultOptions().hydrate?.queries,
            ...e?.defaultOptions?.queries,
            queryKey: l,
            queryHash: f,
            meta: $
          },
          // Reset fetch status to idle to avoid
          // query being stuck in fetching state upon hydration
          {
            ...u,
            data: I,
            fetchStatus: "idle",
            status: I !== void 0 ? "success" : u.status
          }
        );
      m && !E && !T && // Only hydrate if dehydration is newer than any existing data,
      // this is always true for new queries
      (x === void 0 || x > A.state.dataUpdatedAt) && A.fetch(void 0, {
        // RSC transformed promises are not thenable
        initialPromise: Promise.resolve(m).then(n)
      }).catch(me);
    }
  );
}
a(Q1, "hydrate");
var K1 = E1;
function G1() {
  let i = [], t = 0, e = /* @__PURE__ */ a((c) => {
    c();
  }, "notifyFn"), r = /* @__PURE__ */ a((c) => {
    c();
  }, "batchNotifyFn"), s = K1;
  const n = /* @__PURE__ */ a((c) => {
    t ? i.push(c) : s(() => {
      e(c);
    });
  }, "schedule"), o = /* @__PURE__ */ a(() => {
    const c = i;
    i = [], c.length && s(() => {
      r(() => {
        c.forEach((l) => {
          e(l);
        });
      });
    });
  }, "flush");
  return {
    batch: /* @__PURE__ */ a((c) => {
      let l;
      t++;
      try {
        l = c();
      } finally {
        t--, t || o();
      }
      return l;
    }, "batch"),
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: /* @__PURE__ */ a((c) => (...l) => {
      n(() => {
        c(...l);
      });
    }, "batchCalls"),
    schedule: n,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: /* @__PURE__ */ a((c) => {
      e = c;
    }, "setNotifyFunction"),
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: /* @__PURE__ */ a((c) => {
      r = c;
    }, "setBatchNotifyFunction"),
    setScheduler: /* @__PURE__ */ a((c) => {
      s = c;
    }, "setScheduler")
  };
}
a(G1, "createNotifyManager");
var ye = G1(), $n, yr, Cn, kn, Z1 = (kn = class extends Fc {
  constructor() {
    super();
    O(this, $n, !0);
    O(this, yr);
    O(this, Cn);
    P(this, Cn, (e) => {
      if (!uc && window.addEventListener) {
        const r = /* @__PURE__ */ a(() => e(!0), "onlineListener"), s = /* @__PURE__ */ a(() => e(!1), "offlineListener");
        return window.addEventListener("online", r, !1), window.addEventListener("offline", s, !1), () => {
          window.removeEventListener("online", r), window.removeEventListener("offline", s);
        };
      }
    });
  }
  onSubscribe() {
    y(this, yr) || this.setEventListener(y(this, Cn));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = y(this, yr)) == null || e.call(this), P(this, yr, void 0));
  }
  setEventListener(e) {
    var r;
    P(this, Cn, e), (r = y(this, yr)) == null || r.call(this), P(this, yr, e(this.setOnline.bind(this)));
  }
  setOnline(e) {
    y(this, $n) !== e && (P(this, $n, e), this.listeners.forEach((s) => {
      s(e);
    }));
  }
  isOnline() {
    return y(this, $n);
  }
}, $n = new WeakMap(), yr = new WeakMap(), Cn = new WeakMap(), a(kn, "OnlineManager"), kn), Hd = new Z1();
function Y1(i) {
  return Math.min(1e3 * 2 ** i, 3e4);
}
a(Y1, "defaultRetryDelay");
function Kf(i) {
  return (i ?? "online") === "online" ? Hd.isOnline() : !0;
}
a(Kf, "canFetch");
var _n, Kp = (_n = class extends Error {
  constructor(t) {
    super("CancelledError"), this.revert = t?.revert, this.silent = t?.silent;
  }
}, a(_n, "CancelledError"), _n);
function Gf(i) {
  let t = !1, e = 0, r;
  const s = Qp(), n = /* @__PURE__ */ a(() => s.status !== "pending", "isResolved"), o = /* @__PURE__ */ a((S) => {
    if (!n()) {
      const I = new Kp(S);
      m(I), i.onCancel?.(I);
    }
  }, "cancel"), c = /* @__PURE__ */ a(() => {
    t = !0;
  }, "cancelRetry"), l = /* @__PURE__ */ a(() => {
    t = !1;
  }, "continueRetry"), u = /* @__PURE__ */ a(() => Nu.isFocused() && (i.networkMode === "always" || Hd.isOnline()) && i.canRun(), "canContinue"), f = /* @__PURE__ */ a(() => Kf(i.networkMode) && i.canRun(), "canStart"), $ = /* @__PURE__ */ a((S) => {
    n() || (r?.(), s.resolve(S));
  }, "resolve"), m = /* @__PURE__ */ a((S) => {
    n() || (r?.(), s.reject(S));
  }, "reject"), x = /* @__PURE__ */ a(() => new Promise((S) => {
    r = /* @__PURE__ */ a((I) => {
      (n() || u()) && S(I);
    }, "continueFn"), i.onPause?.();
  }).then(() => {
    r = void 0, n() || i.onContinue?.();
  }), "pause"), g = /* @__PURE__ */ a(() => {
    if (n())
      return;
    let S;
    const I = e === 0 ? i.initialPromise : void 0;
    try {
      S = I ?? i.fn();
    } catch (A) {
      S = Promise.reject(A);
    }
    Promise.resolve(S).then($).catch((A) => {
      if (n())
        return;
      const E = i.retry ?? (uc ? 0 : 3), T = i.retryDelay ?? Y1, q = typeof T == "function" ? T(e, A) : T, R = E === !0 || typeof E == "number" && e < E || typeof E == "function" && E(e, A);
      if (t || !R) {
        m(A);
        return;
      }
      e++, i.onFail?.(e, A), I1(q).then(() => u() ? void 0 : x()).then(() => {
        t ? m(A) : g();
      });
    });
  }, "run");
  return {
    promise: s,
    status: /* @__PURE__ */ a(() => s.status, "status"),
    cancel: o,
    continue: /* @__PURE__ */ a(() => (r?.(), s), "continue"),
    cancelRetry: c,
    continueRetry: l,
    canStart: f,
    start: /* @__PURE__ */ a(() => (f() ? g() : x().then(g), s), "start")
  };
}
a(Gf, "createRetryer");
var Jr, Pn, Zf = (Pn = class {
  constructor() {
    O(this, Jr);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), Np(this.gcTime) && P(this, Jr, Cr.setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t ?? (uc ? 1 / 0 : 300 * 1e3)
    );
  }
  clearGcTimeout() {
    y(this, Jr) && (Cr.clearTimeout(y(this, Jr)), P(this, Jr, void 0));
  }
}, Jr = new WeakMap(), a(Pn, "Removable"), Pn), ts, Mn, Ze, es, ce, Tl, is, si, Ti, Sn, X1 = (Sn = class extends Zf {
  constructor(e) {
    super();
    O(this, si);
    O(this, ts);
    O(this, Mn);
    O(this, Ze);
    O(this, es);
    O(this, ce);
    O(this, Tl);
    O(this, is);
    P(this, is, !1), P(this, Tl, e.defaultOptions), this.setOptions(e.options), this.observers = [], P(this, es, e.client), P(this, Ze, y(this, es).getQueryCache()), this.queryKey = e.queryKey, this.queryHash = e.queryHash, P(this, ts, zw(this.options)), this.state = e.state ?? y(this, ts), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return y(this, ce)?.promise;
  }
  setOptions(e) {
    if (this.options = { ...y(this, Tl), ...e }, this.updateGcTime(this.options.gcTime), this.state && this.state.data === void 0) {
      const r = zw(this.options);
      r.data !== void 0 && (this.setState(
        Aw(r.data, r.dataUpdatedAt)
      ), P(this, ts, r));
    }
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && y(this, Ze).remove(this);
  }
  setData(e, r) {
    const s = Wp(this.state.data, e, this.options);
    return st(this, si, Ti).call(this, {
      data: s,
      type: "success",
      dataUpdatedAt: r?.updatedAt,
      manual: r?.manual
    }), s;
  }
  setState(e, r) {
    st(this, si, Ti).call(this, { type: "setState", state: e, setStateOptions: r });
  }
  cancel(e) {
    const r = y(this, ce)?.promise;
    return y(this, ce)?.cancel(e), r ? r.then(me).catch(me) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(y(this, ts));
  }
  isActive() {
    return this.observers.some(
      (e) => Ye(e.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === qu || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => Pr(e.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => e.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(e = 0) {
    return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !jf(this.state.dataUpdatedAt, e);
  }
  onFocus() {
    this.observers.find((r) => r.shouldFetchOnWindowFocus())?.refetch({ cancelRefetch: !1 }), y(this, ce)?.continue();
  }
  onOnline() {
    this.observers.find((r) => r.shouldFetchOnReconnect())?.refetch({ cancelRefetch: !1 }), y(this, ce)?.continue();
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), y(this, Ze).notify({ type: "observerAdded", query: this, observer: e }));
  }
  removeObserver(e) {
    this.observers.includes(e) && (this.observers = this.observers.filter((r) => r !== e), this.observers.length || (y(this, ce) && (y(this, is) ? y(this, ce).cancel({ revert: !0 }) : y(this, ce).cancelRetry()), this.scheduleGc()), y(this, Ze).notify({ type: "observerRemoved", query: this, observer: e }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || st(this, si, Ti).call(this, { type: "invalidate" });
  }
  async fetch(e, r) {
    if (this.state.fetchStatus !== "idle" && // If the promise in the retryer is already rejected, we have to definitely
    // re-start the fetch; there is a chance that the query is still in a
    // pending state when that happens
    y(this, ce)?.status() !== "rejected") {
      if (this.state.data !== void 0 && r?.cancelRefetch)
        this.cancel({ silent: !0 });
      else if (y(this, ce))
        return y(this, ce).continueRetry(), y(this, ce).promise;
    }
    if (e && this.setOptions(e), !this.options.queryFn) {
      const u = this.observers.find((f) => f.options.queryFn);
      u && this.setOptions(u.options);
    }
    const s = new AbortController(), n = /* @__PURE__ */ a((u) => {
      Object.defineProperty(u, "signal", {
        enumerable: !0,
        get: /* @__PURE__ */ a(() => (P(this, is, !0), s.signal), "get")
      });
    }, "addSignalProperty"), o = /* @__PURE__ */ a(() => {
      const u = Wf(this.options, r), $ = (/* @__PURE__ */ a(() => {
        const m = {
          client: y(this, es),
          queryKey: this.queryKey,
          meta: this.meta
        };
        return n(m), m;
      }, "createQueryFnContext"))();
      return P(this, is, !1), this.options.persister ? this.options.persister(
        u,
        $,
        this
      ) : u($);
    }, "fetchFn"), l = (/* @__PURE__ */ a(() => {
      const u = {
        fetchOptions: r,
        options: this.options,
        queryKey: this.queryKey,
        client: y(this, es),
        state: this.state,
        fetchFn: o
      };
      return n(u), u;
    }, "createFetchContext"))();
    this.options.behavior?.onFetch(l, this), P(this, Mn, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== l.fetchOptions?.meta) && st(this, si, Ti).call(this, { type: "fetch", meta: l.fetchOptions?.meta }), P(this, ce, Gf({
      initialPromise: r?.initialPromise,
      fn: l.fetchFn,
      onCancel: /* @__PURE__ */ a((u) => {
        u instanceof Kp && u.revert && this.setState({
          ...y(this, Mn),
          fetchStatus: "idle"
        }), s.abort();
      }, "onCancel"),
      onFail: /* @__PURE__ */ a((u, f) => {
        st(this, si, Ti).call(this, { type: "failed", failureCount: u, error: f });
      }, "onFail"),
      onPause: /* @__PURE__ */ a(() => {
        st(this, si, Ti).call(this, { type: "pause" });
      }, "onPause"),
      onContinue: /* @__PURE__ */ a(() => {
        st(this, si, Ti).call(this, { type: "continue" });
      }, "onContinue"),
      retry: l.options.retry,
      retryDelay: l.options.retryDelay,
      networkMode: l.options.networkMode,
      canRun: /* @__PURE__ */ a(() => !0, "canRun")
    }));
    try {
      const u = await y(this, ce).start();
      if (u === void 0)
        throw new Error(`${this.queryHash} data is undefined`);
      return this.setData(u), y(this, Ze).config.onSuccess?.(u, this), y(this, Ze).config.onSettled?.(
        u,
        this.state.error,
        this
      ), u;
    } catch (u) {
      if (u instanceof Kp) {
        if (u.silent)
          return y(this, ce).promise;
        if (u.revert) {
          if (this.state.data === void 0)
            throw u;
          return this.state.data;
        }
      }
      throw st(this, si, Ti).call(this, {
        type: "error",
        error: u
      }), y(this, Ze).config.onError?.(
        u,
        this
      ), y(this, Ze).config.onSettled?.(
        this.state.data,
        u,
        this
      ), u;
    } finally {
      this.scheduleGc();
    }
  }
}, ts = new WeakMap(), Mn = new WeakMap(), Ze = new WeakMap(), es = new WeakMap(), ce = new WeakMap(), Tl = new WeakMap(), is = new WeakMap(), si = new WeakSet(), Ti = /* @__PURE__ */ a(function(e) {
  const r = /* @__PURE__ */ a((s) => {
    switch (e.type) {
      case "failed":
        return {
          ...s,
          fetchFailureCount: e.failureCount,
          fetchFailureReason: e.error
        };
      case "pause":
        return {
          ...s,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...s,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...s,
          ...Yf(s.data, this.options),
          fetchMeta: e.meta ?? null
        };
      case "success":
        const n = {
          ...s,
          ...Aw(e.data, e.dataUpdatedAt),
          dataUpdateCount: s.dataUpdateCount + 1,
          ...!e.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
        return P(this, Mn, e.manual ? n : void 0), n;
      case "error":
        const o = e.error;
        return {
          ...s,
          error: o,
          errorUpdateCount: s.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: s.fetchFailureCount + 1,
          fetchFailureReason: o,
          fetchStatus: "idle",
          status: "error",
          // flag existing data as invalidated if we get a background error
          // note that "no data" always means stale so we can set unconditionally here
          isInvalidated: !0
        };
      case "invalidate":
        return {
          ...s,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...s,
          ...e.state
        };
    }
  }, "reducer");
  this.state = r(this.state), ye.batch(() => {
    this.observers.forEach((s) => {
      s.onQueryUpdate();
    }), y(this, Ze).notify({ query: this, type: "updated", action: e });
  });
}, "#dispatch"), a(Sn, "Query"), Sn);
function Yf(i, t) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: Kf(t.networkMode) ? "fetching" : "paused",
    ...i === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
a(Yf, "fetchState");
function Aw(i, t) {
  return {
    data: i,
    dataUpdatedAt: t ?? Date.now(),
    error: null,
    isInvalidated: !1,
    status: "success"
  };
}
a(Aw, "successState");
function zw(i) {
  const t = typeof i.initialData == "function" ? i.initialData() : i.initialData, e = t !== void 0, r = e ? typeof i.initialDataUpdatedAt == "function" ? i.initialDataUpdatedAt() : i.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: e ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: e ? "success" : "pending",
    fetchStatus: "idle"
  };
}
a(zw, "getDefaultState$1");
var Le, yt, Fl, _e, rs, An, Fi, wr, Dl, zn, Rn, ss, ns, fr, En, xt, il, Gp, Zp, Yp, Xp, Jp, tu, eu, Jf, Ln, Xf = (Ln = class extends Fc {
  constructor(e, r) {
    super();
    O(this, xt);
    O(this, Le);
    O(this, yt);
    O(this, Fl);
    O(this, _e);
    O(this, rs);
    O(this, An);
    O(this, Fi);
    O(this, wr);
    O(this, Dl);
    O(this, zn);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    O(this, Rn);
    O(this, ss);
    O(this, ns);
    O(this, fr);
    O(this, En, /* @__PURE__ */ new Set());
    this.options = r, P(this, Le, e), P(this, wr, null), P(this, Fi, Qp()), this.bindMethods(), this.setOptions(r);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (y(this, yt).addObserver(this), Rw(y(this, yt), this.options) ? st(this, xt, il).call(this) : this.updateResult(), st(this, xt, Xp).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return iu(
      y(this, yt),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return iu(
      y(this, yt),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), st(this, xt, Jp).call(this), st(this, xt, tu).call(this), y(this, yt).removeObserver(this);
  }
  setOptions(e) {
    const r = this.options, s = y(this, yt);
    if (this.options = y(this, Le).defaultQueryOptions(e), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof Ye(this.options.enabled, y(this, yt)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    st(this, xt, eu).call(this), y(this, yt).setOptions(this.options), r._defaulted && !Dd(this.options, r) && y(this, Le).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: y(this, yt),
      observer: this
    });
    const n = this.hasListeners();
    n && Ew(
      y(this, yt),
      s,
      this.options,
      r
    ) && st(this, xt, il).call(this), this.updateResult(), n && (y(this, yt) !== s || Ye(this.options.enabled, y(this, yt)) !== Ye(r.enabled, y(this, yt)) || Pr(this.options.staleTime, y(this, yt)) !== Pr(r.staleTime, y(this, yt))) && st(this, xt, Gp).call(this);
    const o = st(this, xt, Zp).call(this);
    n && (y(this, yt) !== s || Ye(this.options.enabled, y(this, yt)) !== Ye(r.enabled, y(this, yt)) || o !== y(this, fr)) && st(this, xt, Yp).call(this, o);
  }
  getOptimisticResult(e) {
    const r = y(this, Le).getQueryCache().build(y(this, Le), e), s = this.createResult(r, e);
    return tg(this, s) && (P(this, _e, s), P(this, An, this.options), P(this, rs, y(this, yt).state)), s;
  }
  getCurrentResult() {
    return y(this, _e);
  }
  trackResult(e, r) {
    return new Proxy(e, {
      get: /* @__PURE__ */ a((s, n) => (this.trackProp(n), r?.(n), n === "promise" && (this.trackProp("data"), !this.options.experimental_prefetchInRender && y(this, Fi).status === "pending" && y(this, Fi).reject(
        new Error(
          "experimental_prefetchInRender feature flag is not enabled"
        )
      )), Reflect.get(s, n)), "get")
    });
  }
  trackProp(e) {
    y(this, En).add(e);
  }
  getCurrentQuery() {
    return y(this, yt);
  }
  refetch({ ...e } = {}) {
    return this.fetch({
      ...e
    });
  }
  fetchOptimistic(e) {
    const r = y(this, Le).defaultQueryOptions(e), s = y(this, Le).getQueryCache().build(y(this, Le), r);
    return s.fetch().then(() => this.createResult(s, r));
  }
  fetch(e) {
    return st(this, xt, il).call(this, {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), y(this, _e)));
  }
  createResult(e, r) {
    const s = y(this, yt), n = this.options, o = y(this, _e), c = y(this, rs), l = y(this, An), f = e !== s ? e.state : y(this, Fl), { state: $ } = e;
    let m = { ...$ }, x = !1, g;
    if (r._optimisticResults) {
      const J = this.hasListeners(), Pt = !J && Rw(e, r), Mt = J && Ew(e, s, r, n);
      (Pt || Mt) && (m = {
        ...m,
        ...Yf($.data, e.options)
      }), r._optimisticResults === "isRestoring" && (m.fetchStatus = "idle");
    }
    let { error: S, errorUpdatedAt: I, status: A } = m;
    g = m.data;
    let E = !1;
    if (r.placeholderData !== void 0 && g === void 0 && A === "pending") {
      let J;
      o?.isPlaceholderData && r.placeholderData === l?.placeholderData ? (J = o.data, E = !0) : J = typeof r.placeholderData == "function" ? r.placeholderData(
        y(this, Rn)?.state.data,
        y(this, Rn)
      ) : r.placeholderData, J !== void 0 && (A = "success", g = Wp(
        o?.data,
        J,
        r
      ), x = !0);
    }
    if (r.select && g !== void 0 && !E)
      if (o && g === c?.data && r.select === y(this, Dl))
        g = y(this, zn);
      else
        try {
          P(this, Dl, r.select), g = r.select(g), g = Wp(o?.data, g, r), P(this, zn, g), P(this, wr, null);
        } catch (J) {
          P(this, wr, J);
        }
    y(this, wr) && (S = y(this, wr), g = y(this, zn), I = Date.now(), A = "error");
    const T = m.fetchStatus === "fetching", q = A === "pending", R = A === "error", V = q && T, N = g !== void 0, it = {
      status: A,
      fetchStatus: m.fetchStatus,
      isPending: q,
      isSuccess: A === "success",
      isError: R,
      isInitialLoading: V,
      isLoading: V,
      data: g,
      dataUpdatedAt: m.dataUpdatedAt,
      error: S,
      errorUpdatedAt: I,
      failureCount: m.fetchFailureCount,
      failureReason: m.fetchFailureReason,
      errorUpdateCount: m.errorUpdateCount,
      isFetched: m.dataUpdateCount > 0 || m.errorUpdateCount > 0,
      isFetchedAfterMount: m.dataUpdateCount > f.dataUpdateCount || m.errorUpdateCount > f.errorUpdateCount,
      isFetching: T,
      isRefetching: T && !q,
      isLoadingError: R && !N,
      isPaused: m.fetchStatus === "paused",
      isPlaceholderData: x,
      isRefetchError: R && N,
      isStale: ju(e, r),
      refetch: this.refetch,
      promise: y(this, Fi),
      isEnabled: Ye(r.enabled, e) !== !1
    };
    if (this.options.experimental_prefetchInRender) {
      const J = it.data !== void 0, Pt = it.status === "error" && !J, Mt = /* @__PURE__ */ a((Ot) => {
        Pt ? Ot.reject(it.error) : J && Ot.resolve(it.data);
      }, "finalizeThenableIfPossible"), wt = /* @__PURE__ */ a(() => {
        const Ot = P(this, Fi, it.promise = Qp());
        Mt(Ot);
      }, "recreateThenable"), pt = y(this, Fi);
      switch (pt.status) {
        case "pending":
          e.queryHash === s.queryHash && Mt(pt);
          break;
        case "fulfilled":
          (Pt || it.data !== pt.value) && wt();
          break;
        case "rejected":
          (!Pt || it.error !== pt.reason) && wt();
          break;
      }
    }
    return it;
  }
  updateResult() {
    const e = y(this, _e), r = this.createResult(y(this, yt), this.options);
    if (P(this, rs, y(this, yt).state), P(this, An, this.options), y(this, rs).data !== void 0 && P(this, Rn, y(this, yt)), Dd(r, e))
      return;
    P(this, _e, r);
    const s = /* @__PURE__ */ a(() => {
      if (!e)
        return !0;
      const { notifyOnChangeProps: n } = this.options, o = typeof n == "function" ? n() : n;
      if (o === "all" || !o && !y(this, En).size)
        return !0;
      const c = new Set(
        o ?? y(this, En)
      );
      return this.options.throwOnError && c.add("error"), Object.keys(y(this, _e)).some((l) => {
        const u = l;
        return y(this, _e)[u] !== e[u] && c.has(u);
      });
    }, "shouldNotifyListeners");
    st(this, xt, Jf).call(this, { listeners: s() });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && st(this, xt, Xp).call(this);
  }
}, Le = new WeakMap(), yt = new WeakMap(), Fl = new WeakMap(), _e = new WeakMap(), rs = new WeakMap(), An = new WeakMap(), Fi = new WeakMap(), wr = new WeakMap(), Dl = new WeakMap(), zn = new WeakMap(), Rn = new WeakMap(), ss = new WeakMap(), ns = new WeakMap(), fr = new WeakMap(), En = new WeakMap(), xt = new WeakSet(), il = /* @__PURE__ */ a(function(e) {
  st(this, xt, eu).call(this);
  let r = y(this, yt).fetch(
    this.options,
    e
  );
  return e?.throwOnError || (r = r.catch(me)), r;
}, "#executeFetch"), Gp = /* @__PURE__ */ a(function() {
  st(this, xt, Jp).call(this);
  const e = Pr(
    this.options.staleTime,
    y(this, yt)
  );
  if (uc || y(this, _e).isStale || !Np(e))
    return;
  const s = jf(y(this, _e).dataUpdatedAt, e) + 1;
  P(this, ss, Cr.setTimeout(() => {
    y(this, _e).isStale || this.updateResult();
  }, s));
}, "#updateStaleTimeout"), Zp = /* @__PURE__ */ a(function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(y(this, yt)) : this.options.refetchInterval) ?? !1;
}, "#computeRefetchInterval"), Yp = /* @__PURE__ */ a(function(e) {
  st(this, xt, tu).call(this), P(this, fr, e), !(uc || Ye(this.options.enabled, y(this, yt)) === !1 || !Np(y(this, fr)) || y(this, fr) === 0) && P(this, ns, Cr.setInterval(() => {
    (this.options.refetchIntervalInBackground || Nu.isFocused()) && st(this, xt, il).call(this);
  }, y(this, fr)));
}, "#updateRefetchInterval"), Xp = /* @__PURE__ */ a(function() {
  st(this, xt, Gp).call(this), st(this, xt, Yp).call(this, st(this, xt, Zp).call(this));
}, "#updateTimers"), Jp = /* @__PURE__ */ a(function() {
  y(this, ss) && (Cr.clearTimeout(y(this, ss)), P(this, ss, void 0));
}, "#clearStaleTimeout"), tu = /* @__PURE__ */ a(function() {
  y(this, ns) && (Cr.clearInterval(y(this, ns)), P(this, ns, void 0));
}, "#clearRefetchInterval"), eu = /* @__PURE__ */ a(function() {
  const e = y(this, Le).getQueryCache().build(y(this, Le), this.options);
  if (e === y(this, yt))
    return;
  const r = y(this, yt);
  P(this, yt, e), P(this, Fl, e.state), this.hasListeners() && (r?.removeObserver(this), e.addObserver(this));
}, "#updateQuery"), Jf = /* @__PURE__ */ a(function(e) {
  ye.batch(() => {
    e.listeners && this.listeners.forEach((r) => {
      r(y(this, _e));
    }), y(this, Le).getQueryCache().notify({
      query: y(this, yt),
      type: "observerResultsUpdated"
    });
  });
}, "#notify"), a(Ln, "QueryObserver"), Ln);
function J1(i, t) {
  return Ye(t.enabled, i) !== !1 && i.state.data === void 0 && !(i.state.status === "error" && t.retryOnMount === !1);
}
a(J1, "shouldLoadOnMount");
function Rw(i, t) {
  return J1(i, t) || i.state.data !== void 0 && iu(i, t, t.refetchOnMount);
}
a(Rw, "shouldFetchOnMount");
function iu(i, t, e) {
  if (Ye(t.enabled, i) !== !1 && Pr(t.staleTime, i) !== "static") {
    const r = typeof e == "function" ? e(i) : e;
    return r === "always" || r !== !1 && ju(i, t);
  }
  return !1;
}
a(iu, "shouldFetchOn");
function Ew(i, t, e, r) {
  return (i !== t || Ye(r.enabled, i) === !1) && (!e.suspense || i.state.status !== "error") && ju(i, e);
}
a(Ew, "shouldFetchOptionally");
function ju(i, t) {
  return Ye(t.enabled, i) !== !1 && i.isStaleByTime(Pr(t.staleTime, i));
}
a(ju, "isStale");
function tg(i, t) {
  return !Dd(i.getCurrentResult(), t);
}
a(tg, "shouldAssignObserverCurrentProperties");
function Vd(i) {
  return {
    onFetch: /* @__PURE__ */ a((t, e) => {
      const r = t.options, s = t.fetchOptions?.meta?.fetchMore?.direction, n = t.state.data?.pages || [], o = t.state.data?.pageParams || [];
      let c = { pages: [], pageParams: [] }, l = 0;
      const u = /* @__PURE__ */ a(async () => {
        let f = !1;
        const $ = /* @__PURE__ */ a((g) => {
          D1(
            g,
            () => t.signal,
            () => f = !0
          );
        }, "addSignalProperty"), m = Wf(t.options, t.fetchOptions), x = /* @__PURE__ */ a(async (g, S, I) => {
          if (f)
            return Promise.reject();
          if (S == null && g.pages.length)
            return Promise.resolve(g);
          const E = (/* @__PURE__ */ a(() => {
            const V = {
              client: t.client,
              queryKey: t.queryKey,
              pageParam: S,
              direction: I ? "backward" : "forward",
              meta: t.options.meta
            };
            return $(V), V;
          }, "createQueryFnContext"))(), T = await m(E), { maxPages: q } = t.options, R = I ? F1 : T1;
          return {
            pages: R(g.pages, T, q),
            pageParams: R(g.pageParams, S, q)
          };
        }, "fetchPage");
        if (s && n.length) {
          const g = s === "backward", S = g ? tm : ru, I = {
            pages: n,
            pageParams: o
          }, A = S(r, I);
          c = await x(I, A, g);
        } else {
          const g = i ?? n.length;
          do {
            const S = l === 0 ? o[0] ?? r.initialPageParam : ru(r, c);
            if (l > 0 && S == null)
              break;
            c = await x(c, S), l++;
          } while (l < g);
        }
        return c;
      }, "fetchFn");
      t.options.persister ? t.fetchFn = () => t.options.persister?.(
        u,
        {
          client: t.client,
          queryKey: t.queryKey,
          meta: t.options.meta,
          signal: t.signal
        },
        e
      ) : t.fetchFn = u;
    }, "onFetch")
  };
}
a(Vd, "infiniteQueryBehavior");
function ru(i, { pages: t, pageParams: e }) {
  const r = t.length - 1;
  return t.length > 0 ? i.getNextPageParam(
    t[r],
    t,
    e[r],
    e
  ) : void 0;
}
a(ru, "getNextPageParam");
function tm(i, { pages: t, pageParams: e }) {
  return t.length > 0 ? i.getPreviousPageParam?.(t[0], t, e[0], e) : void 0;
}
a(tm, "getPreviousPageParam");
function eg(i, t) {
  return t ? ru(i, t) != null : !1;
}
a(eg, "hasNextPage");
function ig(i, t) {
  return !t || !i.getPreviousPageParam ? !1 : tm(i, t) != null;
}
a(ig, "hasPreviousPage");
var On, rg = (On = class extends Xf {
  constructor(t, e) {
    super(t, e);
  }
  bindMethods() {
    super.bindMethods(), this.fetchNextPage = this.fetchNextPage.bind(this), this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
  }
  setOptions(t) {
    super.setOptions({
      ...t,
      behavior: Vd()
    });
  }
  getOptimisticResult(t) {
    return t.behavior = Vd(), super.getOptimisticResult(t);
  }
  fetchNextPage(t) {
    return this.fetch({
      ...t,
      meta: {
        fetchMore: { direction: "forward" }
      }
    });
  }
  fetchPreviousPage(t) {
    return this.fetch({
      ...t,
      meta: {
        fetchMore: { direction: "backward" }
      }
    });
  }
  createResult(t, e) {
    const { state: r } = t, s = super.createResult(t, e), { isFetching: n, isRefetching: o, isError: c, isRefetchError: l } = s, u = r.fetchMeta?.fetchMore?.direction, f = c && u === "forward", $ = n && u === "forward", m = c && u === "backward", x = n && u === "backward";
    return {
      ...s,
      fetchNextPage: this.fetchNextPage,
      fetchPreviousPage: this.fetchPreviousPage,
      hasNextPage: eg(e, r.data),
      hasPreviousPage: ig(e, r.data),
      isFetchNextPageError: f,
      isFetchingNextPage: $,
      isFetchPreviousPageError: m,
      isFetchingPreviousPage: x,
      isRefetchError: l && !f && !m,
      isRefetching: o && !$ && !x
    };
  }
}, a(On, "InfiniteQueryObserver"), On), Hl, fi, Pe, as, mi, lr, In, sg = (In = class extends Zf {
  constructor(e) {
    super();
    O(this, mi);
    O(this, Hl);
    O(this, fi);
    O(this, Pe);
    O(this, as);
    P(this, Hl, e.client), this.mutationId = e.mutationId, P(this, Pe, e.mutationCache), P(this, fi, []), this.state = e.state || em(), this.setOptions(e.options), this.scheduleGc();
  }
  setOptions(e) {
    this.options = e, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(e) {
    y(this, fi).includes(e) || (y(this, fi).push(e), this.clearGcTimeout(), y(this, Pe).notify({
      type: "observerAdded",
      mutation: this,
      observer: e
    }));
  }
  removeObserver(e) {
    P(this, fi, y(this, fi).filter((r) => r !== e)), this.scheduleGc(), y(this, Pe).notify({
      type: "observerRemoved",
      mutation: this,
      observer: e
    });
  }
  optionalRemove() {
    y(this, fi).length || (this.state.status === "pending" ? this.scheduleGc() : y(this, Pe).remove(this));
  }
  continue() {
    return y(this, as)?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(e) {
    const r = /* @__PURE__ */ a(() => {
      st(this, mi, lr).call(this, { type: "continue" });
    }, "onContinue"), s = {
      client: y(this, Hl),
      meta: this.options.meta,
      mutationKey: this.options.mutationKey
    };
    P(this, as, Gf({
      fn: /* @__PURE__ */ a(() => this.options.mutationFn ? this.options.mutationFn(e, s) : Promise.reject(new Error("No mutationFn found")), "fn"),
      onFail: /* @__PURE__ */ a((c, l) => {
        st(this, mi, lr).call(this, { type: "failed", failureCount: c, error: l });
      }, "onFail"),
      onPause: /* @__PURE__ */ a(() => {
        st(this, mi, lr).call(this, { type: "pause" });
      }, "onPause"),
      onContinue: r,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: /* @__PURE__ */ a(() => y(this, Pe).canRun(this), "canRun")
    }));
    const n = this.state.status === "pending", o = !y(this, as).canStart();
    try {
      if (n)
        r();
      else {
        st(this, mi, lr).call(this, { type: "pending", variables: e, isPaused: o }), await y(this, Pe).config.onMutate?.(
          e,
          this,
          s
        );
        const l = await this.options.onMutate?.(
          e,
          s
        );
        l !== this.state.context && st(this, mi, lr).call(this, {
          type: "pending",
          context: l,
          variables: e,
          isPaused: o
        });
      }
      const c = await y(this, as).start();
      return await y(this, Pe).config.onSuccess?.(
        c,
        e,
        this.state.context,
        this,
        s
      ), await this.options.onSuccess?.(
        c,
        e,
        this.state.context,
        s
      ), await y(this, Pe).config.onSettled?.(
        c,
        null,
        this.state.variables,
        this.state.context,
        this,
        s
      ), await this.options.onSettled?.(
        c,
        null,
        e,
        this.state.context,
        s
      ), st(this, mi, lr).call(this, { type: "success", data: c }), c;
    } catch (c) {
      try {
        await y(this, Pe).config.onError?.(
          c,
          e,
          this.state.context,
          this,
          s
        );
      } catch (l) {
        Promise.reject(l);
      }
      try {
        await this.options.onError?.(
          c,
          e,
          this.state.context,
          s
        );
      } catch (l) {
        Promise.reject(l);
      }
      try {
        await y(this, Pe).config.onSettled?.(
          void 0,
          c,
          this.state.variables,
          this.state.context,
          this,
          s
        );
      } catch (l) {
        Promise.reject(l);
      }
      try {
        await this.options.onSettled?.(
          void 0,
          c,
          e,
          this.state.context,
          s
        );
      } catch (l) {
        Promise.reject(l);
      }
      throw st(this, mi, lr).call(this, { type: "error", error: c }), c;
    } finally {
      y(this, Pe).runNext(this);
    }
  }
}, Hl = new WeakMap(), fi = new WeakMap(), Pe = new WeakMap(), as = new WeakMap(), mi = new WeakSet(), lr = /* @__PURE__ */ a(function(e) {
  const r = /* @__PURE__ */ a((s) => {
    switch (e.type) {
      case "failed":
        return {
          ...s,
          failureCount: e.failureCount,
          failureReason: e.error
        };
      case "pause":
        return {
          ...s,
          isPaused: !0
        };
      case "continue":
        return {
          ...s,
          isPaused: !1
        };
      case "pending":
        return {
          ...s,
          context: e.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: e.isPaused,
          status: "pending",
          variables: e.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...s,
          data: e.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...s,
          data: void 0,
          error: e.error,
          failureCount: s.failureCount + 1,
          failureReason: e.error,
          isPaused: !1,
          status: "error"
        };
    }
  }, "reducer");
  this.state = r(this.state), ye.batch(() => {
    y(this, fi).forEach((s) => {
      s.onMutationUpdate(e);
    }), y(this, Pe).notify({
      mutation: this,
      type: "updated",
      action: e
    });
  });
}, "#dispatch"), a(In, "Mutation"), In);
function em() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
a(em, "getDefaultState");
var Di, ni, Vl, Tn, ng = (Tn = class extends Fc {
  constructor(e = {}) {
    super();
    O(this, Di);
    O(this, ni);
    O(this, Vl);
    this.config = e, P(this, Di, /* @__PURE__ */ new Set()), P(this, ni, /* @__PURE__ */ new Map()), P(this, Vl, 0);
  }
  build(e, r, s) {
    const n = new sg({
      client: e,
      mutationCache: this,
      mutationId: ++kd(this, Vl)._,
      options: e.defaultMutationOptions(r),
      state: s
    });
    return this.add(n), n;
  }
  add(e) {
    y(this, Di).add(e);
    const r = Pd(e);
    if (typeof r == "string") {
      const s = y(this, ni).get(r);
      s ? s.push(e) : y(this, ni).set(r, [e]);
    }
    this.notify({ type: "added", mutation: e });
  }
  remove(e) {
    if (y(this, Di).delete(e)) {
      const r = Pd(e);
      if (typeof r == "string") {
        const s = y(this, ni).get(r);
        if (s)
          if (s.length > 1) {
            const n = s.indexOf(e);
            n !== -1 && s.splice(n, 1);
          } else s[0] === e && y(this, ni).delete(r);
      }
    }
    this.notify({ type: "removed", mutation: e });
  }
  canRun(e) {
    const r = Pd(e);
    if (typeof r == "string") {
      const n = y(this, ni).get(r)?.find(
        (o) => o.state.status === "pending"
      );
      return !n || n === e;
    } else
      return !0;
  }
  runNext(e) {
    const r = Pd(e);
    return typeof r == "string" ? y(this, ni).get(r)?.find((n) => n !== e && n.state.isPaused)?.continue() ?? Promise.resolve() : Promise.resolve();
  }
  clear() {
    ye.batch(() => {
      y(this, Di).forEach((e) => {
        this.notify({ type: "removed", mutation: e });
      }), y(this, Di).clear(), y(this, ni).clear();
    });
  }
  getAll() {
    return Array.from(y(this, Di));
  }
  find(e) {
    const r = { exact: !0, ...e };
    return this.getAll().find(
      (s) => Pw(r, s)
    );
  }
  findAll(e = {}) {
    return this.getAll().filter((r) => Pw(e, r));
  }
  notify(e) {
    ye.batch(() => {
      this.listeners.forEach((r) => {
        r(e);
      });
    });
  }
  resumePausedMutations() {
    const e = this.getAll().filter((r) => r.state.isPaused);
    return ye.batch(
      () => Promise.all(
        e.map((r) => r.continue().catch(me))
      )
    );
  }
}, Di = new WeakMap(), ni = new WeakMap(), Vl = new WeakMap(), a(Tn, "MutationCache"), Tn);
function Pd(i) {
  return i.options.scope?.id;
}
a(Pd, "scopeFor");
var Hi, mr, Oe, Vi, Qi, Ad, su, Fn, $t = (Fn = class extends Fc {
  constructor(e, r) {
    super();
    O(this, Qi);
    O(this, Hi);
    O(this, mr);
    O(this, Oe);
    O(this, Vi);
    P(this, Hi, e), this.setOptions(r), this.bindMethods(), st(this, Qi, Ad).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);
  }
  setOptions(e) {
    const r = this.options;
    this.options = y(this, Hi).defaultMutationOptions(e), Dd(this.options, r) || y(this, Hi).getMutationCache().notify({
      type: "observerOptionsUpdated",
      mutation: y(this, Oe),
      observer: this
    }), r?.mutationKey && this.options.mutationKey && ws(r.mutationKey) !== ws(this.options.mutationKey) ? this.reset() : y(this, Oe)?.state.status === "pending" && y(this, Oe).setOptions(this.options);
  }
  onUnsubscribe() {
    this.hasListeners() || y(this, Oe)?.removeObserver(this);
  }
  onMutationUpdate(e) {
    st(this, Qi, Ad).call(this), st(this, Qi, su).call(this, e);
  }
  getCurrentResult() {
    return y(this, mr);
  }
  reset() {
    y(this, Oe)?.removeObserver(this), P(this, Oe, void 0), st(this, Qi, Ad).call(this), st(this, Qi, su).call(this);
  }
  mutate(e, r) {
    return P(this, Vi, r), y(this, Oe)?.removeObserver(this), P(this, Oe, y(this, Hi).getMutationCache().build(y(this, Hi), this.options)), y(this, Oe).addObserver(this), y(this, Oe).execute(e);
  }
}, Hi = new WeakMap(), mr = new WeakMap(), Oe = new WeakMap(), Vi = new WeakMap(), Qi = new WeakSet(), Ad = /* @__PURE__ */ a(function() {
  const e = y(this, Oe)?.state ?? em();
  P(this, mr, {
    ...e,
    isPending: e.status === "pending",
    isSuccess: e.status === "success",
    isError: e.status === "error",
    isIdle: e.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, "#updateResult"), su = /* @__PURE__ */ a(function(e) {
  ye.batch(() => {
    if (y(this, Vi) && this.hasListeners()) {
      const r = y(this, mr).variables, s = y(this, mr).context, n = {
        client: y(this, Hi),
        meta: this.options.meta,
        mutationKey: this.options.mutationKey
      };
      if (e?.type === "success") {
        try {
          y(this, Vi).onSuccess?.(
            e.data,
            r,
            s,
            n
          );
        } catch (o) {
          Promise.reject(o);
        }
        try {
          y(this, Vi).onSettled?.(
            e.data,
            null,
            r,
            s,
            n
          );
        } catch (o) {
          Promise.reject(o);
        }
      } else if (e?.type === "error") {
        try {
          y(this, Vi).onError?.(
            e.error,
            r,
            s,
            n
          );
        } catch (o) {
          Promise.reject(o);
        }
        try {
          y(this, Vi).onSettled?.(
            void 0,
            e.error,
            r,
            s,
            n
          );
        } catch (o) {
          Promise.reject(o);
        }
      }
    }
    this.listeners.forEach((r) => {
      r(y(this, mr));
    });
  });
}, "#notify"), a(Fn, "MutationObserver"), Fn), vi, Dn, ag = (Dn = class extends Fc {
  constructor(e = {}) {
    super();
    O(this, vi);
    this.config = e, P(this, vi, /* @__PURE__ */ new Map());
  }
  build(e, r, s) {
    const n = r.queryKey, o = r.queryHash ?? Bu(n, r);
    let c = this.get(o);
    return c || (c = new X1({
      client: e,
      queryKey: n,
      queryHash: o,
      options: e.defaultQueryOptions(r),
      state: s,
      defaultOptions: e.getQueryDefaults(n)
    }), this.add(c)), c;
  }
  add(e) {
    y(this, vi).has(e.queryHash) || (y(this, vi).set(e.queryHash, e), this.notify({
      type: "added",
      query: e
    }));
  }
  remove(e) {
    const r = y(this, vi).get(e.queryHash);
    r && (e.destroy(), r === e && y(this, vi).delete(e.queryHash), this.notify({ type: "removed", query: e }));
  }
  clear() {
    ye.batch(() => {
      this.getAll().forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return y(this, vi).get(e);
  }
  getAll() {
    return [...y(this, vi).values()];
  }
  find(e) {
    const r = { exact: !0, ...e };
    return this.getAll().find(
      (s) => _w(r, s)
    );
  }
  findAll(e = {}) {
    const r = this.getAll();
    return Object.keys(e).length > 0 ? r.filter((s) => _w(e, s)) : r;
  }
  notify(e) {
    ye.batch(() => {
      this.listeners.forEach((r) => {
        r(e);
      });
    });
  }
  onFocus() {
    ye.batch(() => {
      this.getAll().forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    ye.batch(() => {
      this.getAll().forEach((e) => {
        e.onOnline();
      });
    });
  }
}, vi = new WeakMap(), a(Dn, "QueryCache"), Dn), It, vr, gr, Hn, Vn, br, Un, Bn, qn, og = (qn = class {
  constructor(t = {}) {
    O(this, It);
    O(this, vr);
    O(this, gr);
    O(this, Hn);
    O(this, Vn);
    O(this, br);
    O(this, Un);
    O(this, Bn);
    P(this, It, t.queryCache || new ag()), P(this, vr, t.mutationCache || new ng()), P(this, gr, t.defaultOptions || {}), P(this, Hn, /* @__PURE__ */ new Map()), P(this, Vn, /* @__PURE__ */ new Map()), P(this, br, 0);
  }
  mount() {
    kd(this, br)._++, y(this, br) === 1 && (P(this, Un, Nu.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), y(this, It).onFocus());
    })), P(this, Bn, Hd.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), y(this, It).onOnline());
    })));
  }
  unmount() {
    var t, e;
    kd(this, br)._--, y(this, br) === 0 && ((t = y(this, Un)) == null || t.call(this), P(this, Un, void 0), (e = y(this, Bn)) == null || e.call(this), P(this, Bn, void 0));
  }
  isFetching(t) {
    return y(this, It).findAll({ ...t, fetchStatus: "fetching" }).length;
  }
  isMutating(t) {
    return y(this, vr).findAll({ ...t, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(t) {
    const e = this.defaultQueryOptions({ queryKey: t });
    return y(this, It).get(e.queryHash)?.state.data;
  }
  ensureQueryData(t) {
    const e = this.defaultQueryOptions(t), r = y(this, It).build(this, e), s = r.state.data;
    return s === void 0 ? this.fetchQuery(t) : (t.revalidateIfStale && r.isStaleByTime(Pr(e.staleTime, r)) && this.prefetchQuery(e), Promise.resolve(s));
  }
  getQueriesData(t) {
    return y(this, It).findAll(t).map(({ queryKey: e, state: r }) => {
      const s = r.data;
      return [e, s];
    });
  }
  setQueryData(t, e, r) {
    const s = this.defaultQueryOptions({ queryKey: t }), o = y(this, It).get(
      s.queryHash
    )?.state.data, c = L1(e, o);
    if (c !== void 0)
      return y(this, It).build(this, s).setData(c, { ...r, manual: !0 });
  }
  setQueriesData(t, e, r) {
    return ye.batch(
      () => y(this, It).findAll(t).map(({ queryKey: s }) => [
        s,
        this.setQueryData(s, e, r)
      ])
    );
  }
  getQueryState(t) {
    const e = this.defaultQueryOptions({ queryKey: t });
    return y(this, It).get(
      e.queryHash
    )?.state;
  }
  removeQueries(t) {
    const e = y(this, It);
    ye.batch(() => {
      e.findAll(t).forEach((r) => {
        e.remove(r);
      });
    });
  }
  resetQueries(t, e) {
    const r = y(this, It);
    return ye.batch(() => (r.findAll(t).forEach((s) => {
      s.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...t
      },
      e
    )));
  }
  cancelQueries(t, e = {}) {
    const r = { revert: !0, ...e }, s = ye.batch(
      () => y(this, It).findAll(t).map((n) => n.cancel(r))
    );
    return Promise.all(s).then(me).catch(me);
  }
  invalidateQueries(t, e = {}) {
    return ye.batch(() => (y(this, It).findAll(t).forEach((r) => {
      r.invalidate();
    }), t?.refetchType === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...t,
        type: t?.refetchType ?? t?.type ?? "active"
      },
      e
    )));
  }
  refetchQueries(t, e = {}) {
    const r = {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }, s = ye.batch(
      () => y(this, It).findAll(t).filter((n) => !n.isDisabled() && !n.isStatic()).map((n) => {
        let o = n.fetch(void 0, r);
        return r.throwOnError || (o = o.catch(me)), n.state.fetchStatus === "paused" ? Promise.resolve() : o;
      })
    );
    return Promise.all(s).then(me);
  }
  fetchQuery(t) {
    const e = this.defaultQueryOptions(t);
    e.retry === void 0 && (e.retry = !1);
    const r = y(this, It).build(this, e);
    return r.isStaleByTime(
      Pr(e.staleTime, r)
    ) ? r.fetch(e) : Promise.resolve(r.state.data);
  }
  prefetchQuery(t) {
    return this.fetchQuery(t).then(me).catch(me);
  }
  fetchInfiniteQuery(t) {
    return t.behavior = Vd(t.pages), this.fetchQuery(t);
  }
  prefetchInfiniteQuery(t) {
    return this.fetchInfiniteQuery(t).then(me).catch(me);
  }
  ensureInfiniteQueryData(t) {
    return t.behavior = Vd(t.pages), this.ensureQueryData(t);
  }
  resumePausedMutations() {
    return Hd.isOnline() ? y(this, vr).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return y(this, It);
  }
  getMutationCache() {
    return y(this, vr);
  }
  getDefaultOptions() {
    return y(this, gr);
  }
  setDefaultOptions(t) {
    P(this, gr, t);
  }
  setQueryDefaults(t, e) {
    y(this, Hn).set(ws(t), {
      queryKey: t,
      defaultOptions: e
    });
  }
  getQueryDefaults(t) {
    const e = [...y(this, Hn).values()], r = {};
    return e.forEach((s) => {
      cl(t, s.queryKey) && Object.assign(r, s.defaultOptions);
    }), r;
  }
  setMutationDefaults(t, e) {
    y(this, Vn).set(ws(t), {
      mutationKey: t,
      defaultOptions: e
    });
  }
  getMutationDefaults(t) {
    const e = [...y(this, Vn).values()], r = {};
    return e.forEach((s) => {
      cl(t, s.mutationKey) && Object.assign(r, s.defaultOptions);
    }), r;
  }
  defaultQueryOptions(t) {
    if (t._defaulted)
      return t;
    const e = {
      ...y(this, gr).queries,
      ...this.getQueryDefaults(t.queryKey),
      ...t,
      _defaulted: !0
    };
    return e.queryHash || (e.queryHash = Bu(
      e.queryKey,
      e
    )), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.queryFn === qu && (e.enabled = !1), e;
  }
  defaultMutationOptions(t) {
    return t?._defaulted ? t : {
      ...y(this, gr).mutations,
      ...t?.mutationKey && this.getMutationDefaults(t.mutationKey),
      ...t,
      _defaulted: !0
    };
  }
  clear() {
    y(this, It).clear(), y(this, vr).clear();
  }
}, It = new WeakMap(), vr = new WeakMap(), gr = new WeakMap(), Hn = new WeakMap(), Vn = new WeakMap(), br = new WeakMap(), Un = new WeakMap(), Bn = new WeakMap(), a(qn, "QueryClient"), qn);
function Ap() {
}
a(Ap, "noop");
function cg({
  storage: i,
  key: t = "REACT_QUERY_OFFLINE_CACHE",
  throttleTime: e = 1e3,
  serialize: r = JSON.stringify,
  deserialize: s = JSON.parse,
  retry: n
}) {
  if (i) {
    const o = /* @__PURE__ */ a((c) => {
      try {
        i.setItem(t, r(c));
        return;
      } catch (l) {
        return l;
      }
    }, "trySave");
    return {
      persistClient: lg((c) => {
        let l = c, u = o(l), f = 0;
        for (; u && l; )
          f++, l = n?.({
            persistedClient: l,
            error: u,
            errorCount: f
          }), l && (u = o(l));
      }, e),
      restoreClient: /* @__PURE__ */ a(() => {
        const c = i.getItem(t);
        if (c)
          return s(c);
      }, "restoreClient"),
      removeClient: /* @__PURE__ */ a(() => {
        i.removeItem(t);
      }, "removeClient")
    };
  }
  return {
    persistClient: Ap,
    restoreClient: Ap,
    removeClient: Ap
  };
}
a(cg, "createSyncStoragePersister");
function lg(i, t = 100) {
  let e = null, r;
  return function(...s) {
    r = s, e === null && (e = Cr.setTimeout(() => {
      i(...r), e = null;
    }, t));
  };
}
a(lg, "throttle$1");
var dg = ["added", "removed", "updated"];
function Lw(i) {
  return dg.includes(i);
}
a(Lw, "isCacheEventType");
async function hg({
  queryClient: i,
  persister: t,
  maxAge: e = 1e3 * 60 * 60 * 24,
  buster: r = "",
  hydrateOptions: s
}) {
  try {
    const n = await t.restoreClient();
    if (n)
      if (n.timestamp) {
        const o = Date.now() - n.timestamp > e, c = n.buster !== r;
        if (o || c)
          return t.removeClient();
        Q1(i, n.clientState, s);
      } else
        return t.removeClient();
  } catch (n) {
    throw await t.removeClient(), n;
  }
}
a(hg, "persistQueryClientRestore");
async function Ow({
  queryClient: i,
  persister: t,
  buster: e = "",
  dehydrateOptions: r
}) {
  const s = {
    buster: e,
    timestamp: Date.now(),
    clientState: W1(i, r)
  };
  await t.persistClient(s);
}
a(Ow, "persistQueryClientSave");
function pg(i) {
  const t = i.queryClient.getQueryCache().subscribe((r) => {
    Lw(r.type) && Ow(i);
  }), e = i.queryClient.getMutationCache().subscribe((r) => {
    Lw(r.type) && Ow(i);
  });
  return () => {
    t(), e();
  };
}
a(pg, "persistQueryClientSubscribe");
const ug = /* @__PURE__ */ a((i) => {
  var t;
  return t = class extends i {
    // QUERY CLIENT
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), this._queryClient = new og({
        defaultOptions: {
          queries: {
            staleTime: this.staleTime,
            gcTime: this.gcTime
          }
        }
      }), this.initQueryClient();
    }
    get queryClient() {
      return this._queryClient;
    }
    async initQueryClient() {
      if (this.isDestroyed)
        throw new Tt();
      await this.whenUrl();
      try {
        this._sessionStoragePersister = cg({
          key: "WEAVY_QUERY_OFFLINE_CACHE",
          storage: window.sessionStorage,
          throttleTime: this.staleTime
        });
        const r = {
          queryClient: this._queryClient,
          persister: this._sessionStoragePersister,
          maxAge: this.gcTime,
          // 24h - should match gcTime
          buster: this.cachePrefix,
          // Cache busting parameter (build hash or similar)
          hydrateOptions: void 0,
          dehydrateOptions: {
            shouldDehydrateMutation: /* @__PURE__ */ a((s) => {
              const n = s.state.context?.status?.state === "pending";
              return !!(s.state.context && !n || s.state.isPaused);
            }, "shouldDehydrateMutation")
          }
        };
        await hg(r), this._unsubscribeQueryClient = pg(r);
      } catch {
        console.warn(this.weavyId, "Query cache persister not available.");
      }
      this.host.isConnected && this._queryClient.mount(), this._hostIsConnectedObserver = Jv(this.host, (r) => {
        this.isDestroyed || (r ? (console.info(this.weavyId, "Query client mounted"), this._queryClient.mount()) : (console.info(this.weavyId, "Query client unmounted"), this._queryClient.unmount()));
      });
    }
    async reset() {
      await super.reset(), await this._queryClient.cancelQueries(), await this._sessionStoragePersister?.removeClient(), await this.queryClient.resetQueries();
    }
    async disconnectQueryClient() {
      console.info(this.weavyId, "Query client disconnected"), await this._queryClient.cancelQueries(), await this._sessionStoragePersister?.removeClient(), this._unsubscribeQueryClient?.(), this._queryClient.unmount(), this._queryClient.clear();
    }
    destroy() {
      super.destroy(), this._hostIsConnectedObserver?.disconnect(), this.disconnectQueryClient();
    }
  }, a(t, "WeavyQuery"), t;
}, "WeavyQueryMixin"), yg = /* @__PURE__ */ a((i) => {
  var t;
  return t = class extends i {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r);
    }
    set annotations(r) {
      this._annotations = r, this.updateContext();
    }
    get annotations() {
      return this._annotations ?? te.defaults.annotations;
    }
    set enterToSend(r) {
      this._enterToSend = r, this.updateContext();
    }
    get enterToSend() {
      return this._enterToSend ?? te.defaults.enterToSend;
    }
    set reactions(r) {
      this._reactions = r, this.updateContext();
    }
    get reactions() {
      return this._reactions ?? te.defaults.reactions;
    }
  }, a(t, "WeavySettings"), t;
}, "WeavySettingsMixin");
function Re(i) {
  return i < 0 ? -1 : i === 0 ? 0 : 1;
}
a(Re, "signum");
function rl(i, t, e) {
  return (1 - e) * i + e * t;
}
a(rl, "lerp");
function wg(i, t, e) {
  return e < i ? i : e > t ? t : e;
}
a(wg, "clampInt");
function Ud(i, t, e) {
  return e < i ? i : e > t ? t : e;
}
a(Ud, "clampDouble");
function ll(i) {
  return i = i % 360, i < 0 && (i = i + 360), i;
}
a(ll, "sanitizeDegreesDouble");
function nu(i, t) {
  const e = i[0] * t[0][0] + i[1] * t[0][1] + i[2] * t[0][2], r = i[0] * t[1][0] + i[1] * t[1][1] + i[2] * t[1][2], s = i[0] * t[2][0] + i[1] * t[2][1] + i[2] * t[2][2];
  return [e, r, s];
}
a(nu, "matrixMultiply");
const fg = [
  [0.41233895, 0.35762064, 0.18051042],
  [0.2126, 0.7152, 0.0722],
  [0.01932141, 0.11916382, 0.95034478]
], mg = [
  [
    3.2413774792388685,
    -1.5376652402851851,
    -0.49885366846268053
  ],
  [
    -0.9691452513005321,
    1.8758853451067872,
    0.04156585616912061
  ],
  [
    0.05562093689691305,
    -0.20395524564742123,
    1.0571799111220335
  ]
], vg = [95.047, 100, 108.883];
function Wu(i, t, e) {
  return (255 << 24 | (i & 255) << 16 | (t & 255) << 8 | e & 255) >>> 0;
}
a(Wu, "argbFromRgb");
function Iw(i) {
  const t = us(i[0]), e = us(i[1]), r = us(i[2]);
  return Wu(t, e, r);
}
a(Iw, "argbFromLinrgb");
function gg(i) {
  return i >> 24 & 255;
}
a(gg, "alphaFromArgb");
function im(i) {
  return i >> 16 & 255;
}
a(im, "redFromArgb");
function rm(i) {
  return i >> 8 & 255;
}
a(rm, "greenFromArgb");
function sm(i) {
  return i & 255;
}
a(sm, "blueFromArgb");
function bg(i, t, e) {
  const r = mg, s = r[0][0] * i + r[0][1] * t + r[0][2] * e, n = r[1][0] * i + r[1][1] * t + r[1][2] * e, o = r[2][0] * i + r[2][1] * t + r[2][2] * e, c = us(s), l = us(n), u = us(o);
  return Wu(c, l, u);
}
a(bg, "argbFromXyz");
function xg(i) {
  const t = fn(im(i)), e = fn(rm(i)), r = fn(sm(i));
  return nu([t, e, r], fg);
}
a(xg, "xyzFromArgb");
function $g(i) {
  const t = kr(i), e = us(t);
  return Wu(e, e, e);
}
a($g, "argbFromLstar");
function Tw(i) {
  const t = xg(i)[1];
  return 116 * nm(t / 100) - 16;
}
a(Tw, "lstarFromArgb");
function kr(i) {
  return 100 * kg((i + 16) / 116);
}
a(kr, "yFromLstar");
function au(i) {
  return nm(i / 100) * 116 - 16;
}
a(au, "lstarFromY");
function fn(i) {
  const t = i / 255;
  return t <= 0.040449936 ? t / 12.92 * 100 : Math.pow((t + 0.055) / 1.055, 2.4) * 100;
}
a(fn, "linearized");
function us(i) {
  const t = i / 100;
  let e = 0;
  return t <= 31308e-7 ? e = t * 12.92 : e = 1.055 * Math.pow(t, 1 / 2.4) - 0.055, wg(0, 255, Math.round(e * 255));
}
a(us, "delinearized");
function Cg() {
  return vg;
}
a(Cg, "whitePointD65");
function nm(i) {
  const t = 0.008856451679035631, e = 24389 / 27;
  return i > t ? Math.pow(i, 1 / 3) : (e * i + 16) / 116;
}
a(nm, "labF");
function kg(i) {
  const t = 0.008856451679035631, e = 24389 / 27, r = i * i * i;
  return r > t ? r : (116 * i - 16) / e;
}
a(kg, "labInvf");
const oh = class oh {
  /**
   * Create ViewingConditions from a simple, physically relevant, set of
   * parameters.
   *
   * @param whitePoint White point, measured in the XYZ color space.
   *     default = D65, or sunny day afternoon
   * @param adaptingLuminance The luminance of the adapting field. Informally,
   *     how bright it is in the room where the color is viewed. Can be
   *     calculated from lux by multiplying lux by 0.0586. default = 11.72,
   *     or 200 lux.
   * @param backgroundLstar The lightness of the area surrounding the color.
   *     measured by L* in L*a*b*. default = 50.0
   * @param surround A general description of the lighting surrounding the
   *     color. 0 is pitch dark, like watching a movie in a theater. 1.0 is a
   *     dimly light room, like watching TV at home at night. 2.0 means there
   *     is no difference between the lighting on the color and around it.
   *     default = 2.0
   * @param discountingIlluminant Whether the eye accounts for the tint of the
   *     ambient lighting, such as knowing an apple is still red in green light.
   *     default = false, the eye does not perform this process on
   *       self-luminous objects like displays.
   */
  static make(t = Cg(), e = 200 / Math.PI * kr(50) / 100, r = 50, s = 2, n = !1) {
    const o = t, c = o[0] * 0.401288 + o[1] * 0.650173 + o[2] * -0.051461, l = o[0] * -0.250268 + o[1] * 1.204414 + o[2] * 0.045854, u = o[0] * -2079e-6 + o[1] * 0.048952 + o[2] * 0.953127, f = 0.8 + s / 10, $ = f >= 0.9 ? rl(0.59, 0.69, (f - 0.9) * 10) : rl(0.525, 0.59, (f - 0.8) * 10);
    let m = n ? 1 : f * (1 - 1 / 3.6 * Math.exp((-e - 42) / 92));
    m = m > 1 ? 1 : m < 0 ? 0 : m;
    const x = f, g = [
      m * (100 / c) + 1 - m,
      m * (100 / l) + 1 - m,
      m * (100 / u) + 1 - m
    ], S = 1 / (5 * e + 1), I = S * S * S * S, A = 1 - I, E = I * e + 0.1 * A * A * Math.cbrt(5 * e), T = kr(r) / t[1], q = 1.48 + Math.sqrt(T), R = 0.725 / Math.pow(T, 0.2), V = R, N = [
      Math.pow(E * g[0] * c / 100, 0.42),
      Math.pow(E * g[1] * l / 100, 0.42),
      Math.pow(E * g[2] * u / 100, 0.42)
    ], Y = [
      400 * N[0] / (N[0] + 27.13),
      400 * N[1] / (N[1] + 27.13),
      400 * N[2] / (N[2] + 27.13)
    ], it = (2 * Y[0] + Y[1] + 0.05 * Y[2]) * R;
    return new oh(T, it, R, V, $, x, g, E, Math.pow(E, 0.25), q);
  }
  /**
   * Parameters are intermediate values of the CAM16 conversion process. Their
   * names are shorthand for technical color science terminology, this class
   * would not benefit from documenting them individually. A brief overview
   * is available in the CAM16 specification, and a complete overview requires
   * a color science textbook, such as Fairchild's Color Appearance Models.
   */
  constructor(t, e, r, s, n, o, c, l, u, f) {
    this.n = t, this.aw = e, this.nbb = r, this.ncb = s, this.c = n, this.nc = o, this.rgbD = c, this.fl = l, this.fLRoot = u, this.z = f;
  }
};
a(oh, "ViewingConditions");
let xi = oh;
xi.DEFAULT = xi.make();
const wi = class wi {
  /**
   * All of the CAM16 dimensions can be calculated from 3 of the dimensions, in
   * the following combinations:
   *      -  {j or q} and {c, m, or s} and hue
   *      - jstar, astar, bstar
   * Prefer using a static method that constructs from 3 of those dimensions.
   * This constructor is intended for those methods to use to return all
   * possible dimensions.
   *
   * @param hue
   * @param chroma informally, colorfulness / color intensity. like saturation
   *     in HSL, except perceptually accurate.
   * @param j lightness
   * @param q brightness; ratio of lightness to white point's lightness
   * @param m colorfulness
   * @param s saturation; ratio of chroma to white point's chroma
   * @param jstar CAM16-UCS J coordinate
   * @param astar CAM16-UCS a coordinate
   * @param bstar CAM16-UCS b coordinate
   */
  constructor(t, e, r, s, n, o, c, l, u) {
    this.hue = t, this.chroma = e, this.j = r, this.q = s, this.m = n, this.s = o, this.jstar = c, this.astar = l, this.bstar = u;
  }
  /**
   * CAM16 instances also have coordinates in the CAM16-UCS space, called J*,
   * a*, b*, or jstar, astar, bstar in code. CAM16-UCS is included in the CAM16
   * specification, and is used to measure distances between colors.
   */
  distance(t) {
    const e = this.jstar - t.jstar, r = this.astar - t.astar, s = this.bstar - t.bstar, n = Math.sqrt(e * e + r * r + s * s);
    return 1.41 * Math.pow(n, 0.63);
  }
  /**
   * @param argb ARGB representation of a color.
   * @return CAM16 color, assuming the color was viewed in default viewing
   *     conditions.
   */
  static fromInt(t) {
    return wi.fromIntInViewingConditions(t, xi.DEFAULT);
  }
  /**
   * @param argb ARGB representation of a color.
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   * @return CAM16 color.
   */
  static fromIntInViewingConditions(t, e) {
    const r = (t & 16711680) >> 16, s = (t & 65280) >> 8, n = t & 255, o = fn(r), c = fn(s), l = fn(n), u = 0.41233895 * o + 0.35762064 * c + 0.18051042 * l, f = 0.2126 * o + 0.7152 * c + 0.0722 * l, $ = 0.01932141 * o + 0.11916382 * c + 0.95034478 * l, m = 0.401288 * u + 0.650173 * f - 0.051461 * $, x = -0.250268 * u + 1.204414 * f + 0.045854 * $, g = -2079e-6 * u + 0.048952 * f + 0.953127 * $, S = e.rgbD[0] * m, I = e.rgbD[1] * x, A = e.rgbD[2] * g, E = Math.pow(e.fl * Math.abs(S) / 100, 0.42), T = Math.pow(e.fl * Math.abs(I) / 100, 0.42), q = Math.pow(e.fl * Math.abs(A) / 100, 0.42), R = Re(S) * 400 * E / (E + 27.13), V = Re(I) * 400 * T / (T + 27.13), N = Re(A) * 400 * q / (q + 27.13), Y = (11 * R + -12 * V + N) / 11, it = (R + V - 2 * N) / 9, J = (20 * R + 20 * V + 21 * N) / 20, Pt = (40 * R + 20 * V + N) / 20, wt = Math.atan2(it, Y) * 180 / Math.PI, pt = wt < 0 ? wt + 360 : wt >= 360 ? wt - 360 : wt, Ot = pt * Math.PI / 180, pe = Pt * e.nbb, kt = 100 * Math.pow(pe / e.aw, e.c * e.z), ft = 4 / e.c * Math.sqrt(kt / 100) * (e.aw + 4) * e.fLRoot, Gt = pt < 20.14 ? pt + 360 : pt, rt = 0.25 * (Math.cos(Gt * Math.PI / 180 + 2) + 3.8), ri = 5e4 / 13 * rt * e.nc * e.ncb * Math.sqrt(Y * Y + it * it) / (J + 0.305), qe = Math.pow(ri, 0.9) * Math.pow(1.64 - Math.pow(0.29, e.n), 0.73), Li = qe * Math.sqrt(kt / 100), Oi = Li * e.fLRoot, Xc = 50 * Math.sqrt(qe * e.c / (e.aw + 4)), ui = (1 + 100 * 7e-3) * kt / (1 + 7e-3 * kt), mt = 1 / 0.0228 * Math.log(1 + 0.0228 * Oi), ze = mt * Math.cos(Ot), Ct = mt * Math.sin(Ot);
    return new wi(pt, Li, kt, ft, Oi, Xc, ui, ze, Ct);
  }
  /**
   * @param j CAM16 lightness
   * @param c CAM16 chroma
   * @param h CAM16 hue
   */
  static fromJch(t, e, r) {
    return wi.fromJchInViewingConditions(t, e, r, xi.DEFAULT);
  }
  /**
   * @param j CAM16 lightness
   * @param c CAM16 chroma
   * @param h CAM16 hue
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   */
  static fromJchInViewingConditions(t, e, r, s) {
    const n = 4 / s.c * Math.sqrt(t / 100) * (s.aw + 4) * s.fLRoot, o = e * s.fLRoot, c = e / Math.sqrt(t / 100), l = 50 * Math.sqrt(c * s.c / (s.aw + 4)), u = r * Math.PI / 180, f = (1 + 100 * 7e-3) * t / (1 + 7e-3 * t), $ = 1 / 0.0228 * Math.log(1 + 0.0228 * o), m = $ * Math.cos(u), x = $ * Math.sin(u);
    return new wi(r, e, t, n, o, l, f, m, x);
  }
  /**
   * @param jstar CAM16-UCS lightness.
   * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the Y axis.
   * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the X axis.
   */
  static fromUcs(t, e, r) {
    return wi.fromUcsInViewingConditions(t, e, r, xi.DEFAULT);
  }
  /**
   * @param jstar CAM16-UCS lightness.
   * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the Y axis.
   * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the X axis.
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   */
  static fromUcsInViewingConditions(t, e, r, s) {
    const n = e, o = r, c = Math.sqrt(n * n + o * o), u = (Math.exp(c * 0.0228) - 1) / 0.0228 / s.fLRoot;
    let f = Math.atan2(o, n) * (180 / Math.PI);
    f < 0 && (f += 360);
    const $ = t / (1 - (t - 100) * 7e-3);
    return wi.fromJchInViewingConditions($, u, f, s);
  }
  /**
   *  @return ARGB representation of color, assuming the color was viewed in
   *     default viewing conditions, which are near-identical to the default
   *     viewing conditions for sRGB.
   */
  toInt() {
    return this.viewed(xi.DEFAULT);
  }
  /**
   * @param viewingConditions Information about the environment where the color
   *     will be viewed.
   * @return ARGB representation of color
   */
  viewed(t) {
    const e = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100), r = Math.pow(e / Math.pow(1.64 - Math.pow(0.29, t.n), 0.73), 1 / 0.9), s = this.hue * Math.PI / 180, n = 0.25 * (Math.cos(s + 2) + 3.8), o = t.aw * Math.pow(this.j / 100, 1 / t.c / t.z), c = n * (5e4 / 13) * t.nc * t.ncb, l = o / t.nbb, u = Math.sin(s), f = Math.cos(s), $ = 23 * (l + 0.305) * r / (23 * c + 11 * r * f + 108 * r * u), m = $ * f, x = $ * u, g = (460 * l + 451 * m + 288 * x) / 1403, S = (460 * l - 891 * m - 261 * x) / 1403, I = (460 * l - 220 * m - 6300 * x) / 1403, A = Math.max(0, 27.13 * Math.abs(g) / (400 - Math.abs(g))), E = Re(g) * (100 / t.fl) * Math.pow(A, 1 / 0.42), T = Math.max(0, 27.13 * Math.abs(S) / (400 - Math.abs(S))), q = Re(S) * (100 / t.fl) * Math.pow(T, 1 / 0.42), R = Math.max(0, 27.13 * Math.abs(I) / (400 - Math.abs(I))), V = Re(I) * (100 / t.fl) * Math.pow(R, 1 / 0.42), N = E / t.rgbD[0], Y = q / t.rgbD[1], it = V / t.rgbD[2], J = 1.86206786 * N - 1.01125463 * Y + 0.14918677 * it, Pt = 0.38752654 * N + 0.62144744 * Y - 897398e-8 * it, Mt = -0.0158415 * N - 0.03412294 * Y + 1.04996444 * it;
    return bg(J, Pt, Mt);
  }
  /// Given color expressed in XYZ and viewed in [viewingConditions], convert to
  /// CAM16.
  static fromXyzInViewingConditions(t, e, r, s) {
    const n = 0.401288 * t + 0.650173 * e - 0.051461 * r, o = -0.250268 * t + 1.204414 * e + 0.045854 * r, c = -2079e-6 * t + 0.048952 * e + 0.953127 * r, l = s.rgbD[0] * n, u = s.rgbD[1] * o, f = s.rgbD[2] * c, $ = Math.pow(s.fl * Math.abs(l) / 100, 0.42), m = Math.pow(s.fl * Math.abs(u) / 100, 0.42), x = Math.pow(s.fl * Math.abs(f) / 100, 0.42), g = Re(l) * 400 * $ / ($ + 27.13), S = Re(u) * 400 * m / (m + 27.13), I = Re(f) * 400 * x / (x + 27.13), A = (11 * g + -12 * S + I) / 11, E = (g + S - 2 * I) / 9, T = (20 * g + 20 * S + 21 * I) / 20, q = (40 * g + 20 * S + I) / 20, V = Math.atan2(E, A) * 180 / Math.PI, N = V < 0 ? V + 360 : V >= 360 ? V - 360 : V, Y = N * Math.PI / 180, it = q * s.nbb, J = 100 * Math.pow(it / s.aw, s.c * s.z), Pt = 4 / s.c * Math.sqrt(J / 100) * (s.aw + 4) * s.fLRoot, Mt = N < 20.14 ? N + 360 : N, wt = 1 / 4 * (Math.cos(Mt * Math.PI / 180 + 2) + 3.8), Ot = 5e4 / 13 * wt * s.nc * s.ncb * Math.sqrt(A * A + E * E) / (T + 0.305), pe = Math.pow(Ot, 0.9) * Math.pow(1.64 - Math.pow(0.29, s.n), 0.73), kt = pe * Math.sqrt(J / 100), ft = kt * s.fLRoot, Gt = 50 * Math.sqrt(pe * s.c / (s.aw + 4)), rt = (1 + 100 * 7e-3) * J / (1 + 7e-3 * J), gt = Math.log(1 + 0.0228 * ft) / 0.0228, ri = gt * Math.cos(Y), qe = gt * Math.sin(Y);
    return new wi(N, kt, J, Pt, ft, Gt, rt, ri, qe);
  }
  /// XYZ representation of CAM16 seen in [viewingConditions].
  xyzInViewingConditions(t) {
    const e = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100), r = Math.pow(e / Math.pow(1.64 - Math.pow(0.29, t.n), 0.73), 1 / 0.9), s = this.hue * Math.PI / 180, n = 0.25 * (Math.cos(s + 2) + 3.8), o = t.aw * Math.pow(this.j / 100, 1 / t.c / t.z), c = n * (5e4 / 13) * t.nc * t.ncb, l = o / t.nbb, u = Math.sin(s), f = Math.cos(s), $ = 23 * (l + 0.305) * r / (23 * c + 11 * r * f + 108 * r * u), m = $ * f, x = $ * u, g = (460 * l + 451 * m + 288 * x) / 1403, S = (460 * l - 891 * m - 261 * x) / 1403, I = (460 * l - 220 * m - 6300 * x) / 1403, A = Math.max(0, 27.13 * Math.abs(g) / (400 - Math.abs(g))), E = Re(g) * (100 / t.fl) * Math.pow(A, 1 / 0.42), T = Math.max(0, 27.13 * Math.abs(S) / (400 - Math.abs(S))), q = Re(S) * (100 / t.fl) * Math.pow(T, 1 / 0.42), R = Math.max(0, 27.13 * Math.abs(I) / (400 - Math.abs(I))), V = Re(I) * (100 / t.fl) * Math.pow(R, 1 / 0.42), N = E / t.rgbD[0], Y = q / t.rgbD[1], it = V / t.rgbD[2], J = 1.86206786 * N - 1.01125463 * Y + 0.14918677 * it, Pt = 0.38752654 * N + 0.62144744 * Y - 897398e-8 * it, Mt = -0.0158415 * N - 0.03412294 * Y + 1.04996444 * it;
    return [J, Pt, Mt];
  }
};
a(wi, "Cam16");
let Yr = wi;
const lt = class lt {
  /**
   * Sanitizes a small enough angle in radians.
   *
   * @param angle An angle in radians; must not deviate too much
   * from 0.
   * @return A coterminal angle between 0 and 2pi.
   */
  static sanitizeRadians(t) {
    return (t + Math.PI * 8) % (Math.PI * 2);
  }
  /**
   * Delinearizes an RGB component, returning a floating-point
   * number.
   *
   * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents
   * linear R/G/B channel
   * @return 0.0 <= output <= 255.0, color channel converted to
   * regular RGB space
   */
  static trueDelinearized(t) {
    const e = t / 100;
    let r = 0;
    return e <= 31308e-7 ? r = e * 12.92 : r = 1.055 * Math.pow(e, 1 / 2.4) - 0.055, r * 255;
  }
  static chromaticAdaptation(t) {
    const e = Math.pow(Math.abs(t), 0.42);
    return Re(t) * 400 * e / (e + 27.13);
  }
  /**
   * Returns the hue of a linear RGB color in CAM16.
   *
   * @param linrgb The linear RGB coordinates of a color.
   * @return The hue of the color in CAM16, in radians.
   */
  static hueOf(t) {
    const e = nu(t, lt.SCALED_DISCOUNT_FROM_LINRGB), r = lt.chromaticAdaptation(e[0]), s = lt.chromaticAdaptation(e[1]), n = lt.chromaticAdaptation(e[2]), o = (11 * r + -12 * s + n) / 11, c = (r + s - 2 * n) / 9;
    return Math.atan2(c, o);
  }
  static areInCyclicOrder(t, e, r) {
    const s = lt.sanitizeRadians(e - t), n = lt.sanitizeRadians(r - t);
    return s < n;
  }
  /**
   * Solves the lerp equation.
   *
   * @param source The starting number.
   * @param mid The number in the middle.
   * @param target The ending number.
   * @return A number t such that lerp(source, target, t) = mid.
   */
  static intercept(t, e, r) {
    return (e - t) / (r - t);
  }
  static lerpPoint(t, e, r) {
    return [
      t[0] + (r[0] - t[0]) * e,
      t[1] + (r[1] - t[1]) * e,
      t[2] + (r[2] - t[2]) * e
    ];
  }
  /**
   * Intersects a segment with a plane.
   *
   * @param source The coordinates of point A.
   * @param coordinate The R-, G-, or B-coordinate of the plane.
   * @param target The coordinates of point B.
   * @param axis The axis the plane is perpendicular with. (0: R, 1:
   * G, 2: B)
   * @return The intersection point of the segment AB with the plane
   * R=coordinate, G=coordinate, or B=coordinate
   */
  static setCoordinate(t, e, r, s) {
    const n = lt.intercept(t[s], e, r[s]);
    return lt.lerpPoint(t, n, r);
  }
  static isBounded(t) {
    return 0 <= t && t <= 100;
  }
  /**
   * Returns the nth possible vertex of the polygonal intersection.
   *
   * @param y The Y value of the plane.
   * @param n The zero-based index of the point. 0 <= n <= 11.
   * @return The nth possible vertex of the polygonal intersection
   * of the y plane and the RGB cube, in linear RGB coordinates, if
   * it exists. If this possible vertex lies outside of the cube,
   * [-1.0, -1.0, -1.0] is returned.
   */
  static nthVertex(t, e) {
    const r = lt.Y_FROM_LINRGB[0], s = lt.Y_FROM_LINRGB[1], n = lt.Y_FROM_LINRGB[2], o = e % 4 <= 1 ? 0 : 100, c = e % 2 === 0 ? 0 : 100;
    if (e < 4) {
      const l = o, u = c, f = (t - l * s - u * n) / r;
      return lt.isBounded(f) ? [f, l, u] : [-1, -1, -1];
    } else if (e < 8) {
      const l = o, u = c, f = (t - u * r - l * n) / s;
      return lt.isBounded(f) ? [u, f, l] : [-1, -1, -1];
    } else {
      const l = o, u = c, f = (t - l * r - u * s) / n;
      return lt.isBounded(f) ? [l, u, f] : [-1, -1, -1];
    }
  }
  /**
   * Finds the segment containing the desired color.
   *
   * @param y The Y value of the color.
   * @param targetHue The hue of the color.
   * @return A list of two sets of linear RGB coordinates, each
   * corresponding to an endpoint of the segment containing the
   * desired color.
   */
  static bisectToSegment(t, e) {
    let r = [-1, -1, -1], s = r, n = 0, o = 0, c = !1, l = !0;
    for (let u = 0; u < 12; u++) {
      const f = lt.nthVertex(t, u);
      if (f[0] < 0)
        continue;
      const $ = lt.hueOf(f);
      if (!c) {
        r = f, s = f, n = $, o = $, c = !0;
        continue;
      }
      (l || lt.areInCyclicOrder(n, $, o)) && (l = !1, lt.areInCyclicOrder(n, e, $) ? (s = f, o = $) : (r = f, n = $));
    }
    return [r, s];
  }
  static midpoint(t, e) {
    return [
      (t[0] + e[0]) / 2,
      (t[1] + e[1]) / 2,
      (t[2] + e[2]) / 2
    ];
  }
  static criticalPlaneBelow(t) {
    return Math.floor(t - 0.5);
  }
  static criticalPlaneAbove(t) {
    return Math.ceil(t - 0.5);
  }
  /**
   * Finds a color with the given Y and hue on the boundary of the
   * cube.
   *
   * @param y The Y value of the color.
   * @param targetHue The hue of the color.
   * @return The desired color, in linear RGB coordinates.
   */
  static bisectToLimit(t, e) {
    const r = lt.bisectToSegment(t, e);
    let s = r[0], n = lt.hueOf(s), o = r[1];
    for (let c = 0; c < 3; c++)
      if (s[c] !== o[c]) {
        let l = -1, u = 255;
        s[c] < o[c] ? (l = lt.criticalPlaneBelow(lt.trueDelinearized(s[c])), u = lt.criticalPlaneAbove(lt.trueDelinearized(o[c]))) : (l = lt.criticalPlaneAbove(lt.trueDelinearized(s[c])), u = lt.criticalPlaneBelow(lt.trueDelinearized(o[c])));
        for (let f = 0; f < 8 && !(Math.abs(u - l) <= 1); f++) {
          const $ = Math.floor((l + u) / 2), m = lt.CRITICAL_PLANES[$], x = lt.setCoordinate(s, m, o, c), g = lt.hueOf(x);
          lt.areInCyclicOrder(n, e, g) ? (o = x, u = $) : (s = x, n = g, l = $);
        }
      }
    return lt.midpoint(s, o);
  }
  static inverseChromaticAdaptation(t) {
    const e = Math.abs(t), r = Math.max(0, 27.13 * e / (400 - e));
    return Re(t) * Math.pow(r, 1 / 0.42);
  }
  /**
   * Finds a color with the given hue, chroma, and Y.
   *
   * @param hueRadians The desired hue in radians.
   * @param chroma The desired chroma.
   * @param y The desired Y.
   * @return The desired color as a hexadecimal integer, if found; 0
   * otherwise.
   */
  static findResultByJ(t, e, r) {
    let s = Math.sqrt(r) * 11;
    const n = xi.DEFAULT, o = 1 / Math.pow(1.64 - Math.pow(0.29, n.n), 0.73), l = 0.25 * (Math.cos(t + 2) + 3.8) * (5e4 / 13) * n.nc * n.ncb, u = Math.sin(t), f = Math.cos(t);
    for (let $ = 0; $ < 5; $++) {
      const m = s / 100, x = e === 0 || s === 0 ? 0 : e / Math.sqrt(m), g = Math.pow(x * o, 1 / 0.9), I = n.aw * Math.pow(m, 1 / n.c / n.z) / n.nbb, A = 23 * (I + 0.305) * g / (23 * l + 11 * g * f + 108 * g * u), E = A * f, T = A * u, q = (460 * I + 451 * E + 288 * T) / 1403, R = (460 * I - 891 * E - 261 * T) / 1403, V = (460 * I - 220 * E - 6300 * T) / 1403, N = lt.inverseChromaticAdaptation(q), Y = lt.inverseChromaticAdaptation(R), it = lt.inverseChromaticAdaptation(V), J = nu([N, Y, it], lt.LINRGB_FROM_SCALED_DISCOUNT);
      if (J[0] < 0 || J[1] < 0 || J[2] < 0)
        return 0;
      const Pt = lt.Y_FROM_LINRGB[0], Mt = lt.Y_FROM_LINRGB[1], wt = lt.Y_FROM_LINRGB[2], pt = Pt * J[0] + Mt * J[1] + wt * J[2];
      if (pt <= 0)
        return 0;
      if ($ === 4 || Math.abs(pt - r) < 2e-3)
        return J[0] > 100.01 || J[1] > 100.01 || J[2] > 100.01 ? 0 : Iw(J);
      s = s - (pt - r) * s / (2 * pt);
    }
    return 0;
  }
  /**
   * Finds an sRGB color with the given hue, chroma, and L*, if
   * possible.
   *
   * @param hueDegrees The desired hue, in degrees.
   * @param chroma The desired chroma.
   * @param lstar The desired L*.
   * @return A hexadecimal representing the sRGB color. The color
   * has sufficiently close hue, chroma, and L* to the desired
   * values, if possible; otherwise, the hue and L* will be
   * sufficiently close, and chroma will be maximized.
   */
  static solveToInt(t, e, r) {
    if (e < 1e-4 || r < 1e-4 || r > 99.9999)
      return $g(r);
    t = ll(t);
    const s = t / 180 * Math.PI, n = kr(r), o = lt.findResultByJ(s, e, n);
    if (o !== 0)
      return o;
    const c = lt.bisectToLimit(n, s);
    return Iw(c);
  }
  /**
   * Finds an sRGB color with the given hue, chroma, and L*, if
   * possible.
   *
   * @param hueDegrees The desired hue, in degrees.
   * @param chroma The desired chroma.
   * @param lstar The desired L*.
   * @return An CAM16 object representing the sRGB color. The color
   * has sufficiently close hue, chroma, and L* to the desired
   * values, if possible; otherwise, the hue and L* will be
   * sufficiently close, and chroma will be maximized.
   */
  static solveToCam(t, e, r) {
    return Yr.fromInt(lt.solveToInt(t, e, r));
  }
};
a(lt, "HctSolver");
let $i = lt;
$i.SCALED_DISCOUNT_FROM_LINRGB = [
  [
    0.001200833568784504,
    0.002389694492170889,
    2795742885861124e-19
  ],
  [
    5891086651375999e-19,
    0.0029785502573438758,
    3270666104008398e-19
  ],
  [
    10146692491640572e-20,
    5364214359186694e-19,
    0.0032979401770712076
  ]
];
$i.LINRGB_FROM_SCALED_DISCOUNT = [
  [
    1373.2198709594231,
    -1100.4251190754821,
    -7.278681089101213
  ],
  [
    -271.815969077903,
    559.6580465940733,
    -32.46047482791194
  ],
  [
    1.9622899599665666,
    -57.173814538844006,
    308.7233197812385
  ]
];
$i.Y_FROM_LINRGB = [0.2126, 0.7152, 0.0722];
$i.CRITICAL_PLANES = [
  0.015176349177441876,
  0.045529047532325624,
  0.07588174588720938,
  0.10623444424209313,
  0.13658714259697685,
  0.16693984095186062,
  0.19729253930674434,
  0.2276452376616281,
  0.2579979360165119,
  0.28835063437139563,
  0.3188300904430532,
  0.350925934958123,
  0.3848314933096426,
  0.42057480301049466,
  0.458183274052838,
  0.4976837250274023,
  0.5391024159806381,
  0.5824650784040898,
  0.6277969426914107,
  0.6751227633498623,
  0.7244668422128921,
  0.775853049866786,
  0.829304845476233,
  0.8848452951698498,
  0.942497089126609,
  1.0022825574869039,
  1.0642236851973577,
  1.1283421258858297,
  1.1946592148522128,
  1.2631959812511864,
  1.3339731595349034,
  1.407011200216447,
  1.4823302800086415,
  1.5599503113873272,
  1.6398909516233677,
  1.7221716113234105,
  1.8068114625156377,
  1.8938294463134073,
  1.9832442801866852,
  2.075074464868551,
  2.1693382909216234,
  2.2660538449872063,
  2.36523901573795,
  2.4669114995532007,
  2.5710888059345764,
  2.6777882626779785,
  2.7870270208169257,
  2.898822059350997,
  3.0131901897720907,
  3.1301480604002863,
  3.2497121605402226,
  3.3718988244681087,
  3.4967242352587946,
  3.624204428461639,
  3.754355295633311,
  3.887192587735158,
  4.022731918402185,
  4.160988767090289,
  4.301978482107941,
  4.445716283538092,
  4.592217266055746,
  4.741496401646282,
  4.893568542229298,
  5.048448422192488,
  5.20615066083972,
  5.3666897647573375,
  5.5300801301023865,
  5.696336044816294,
  5.865471690767354,
  6.037501145825082,
  6.212438385869475,
  6.390297286737924,
  6.571091626112461,
  6.7548350853498045,
  6.941541251256611,
  7.131223617812143,
  7.323895587840543,
  7.5195704746346665,
  7.7182615035334345,
  7.919981813454504,
  8.124744458384042,
  8.332562408825165,
  8.543448553206703,
  8.757415699253682,
  8.974476575321063,
  9.194643831691977,
  9.417930041841839,
  9.644347703669503,
  9.873909240696694,
  10.106627003236781,
  10.342513269534024,
  10.58158024687427,
  10.8238400726681,
  11.069304815507364,
  11.317986476196008,
  11.569896988756009,
  11.825048221409341,
  12.083451977536606,
  12.345119996613247,
  12.610063955123938,
  12.878295467455942,
  13.149826086772048,
  13.42466730586372,
  13.702830557985108,
  13.984327217668513,
  14.269168601521828,
  14.55736596900856,
  14.848930523210871,
  15.143873411576273,
  15.44220572664832,
  15.743938506781891,
  16.04908273684337,
  16.35764934889634,
  16.66964922287304,
  16.985093187232053,
  17.30399201960269,
  17.62635644741625,
  17.95219714852476,
  18.281524751807332,
  18.614349837764564,
  18.95068293910138,
  19.290534541298456,
  19.633915083172692,
  19.98083495742689,
  20.331304511189067,
  20.685334046541502,
  21.042933821039977,
  21.404114048223256,
  21.76888489811322,
  22.137256497705877,
  22.50923893145328,
  22.884842241736916,
  23.264076429332462,
  23.6469514538663,
  24.033477234264016,
  24.42366364919083,
  24.817520537484558,
  25.21505769858089,
  25.61628489293138,
  26.021211842414342,
  26.429848230738664,
  26.842203703840827,
  27.258287870275353,
  27.678110301598522,
  28.10168053274597,
  28.529008062403893,
  28.96010235337422,
  29.39497283293396,
  29.83362889318845,
  30.276079891419332,
  30.722335150426627,
  31.172403958865512,
  31.62629557157785,
  32.08401920991837,
  32.54558406207592,
  33.010999283389665,
  33.4802739966603,
  33.953417292456834,
  34.430438229418264,
  34.911345834551085,
  35.39614910352207,
  35.88485700094671,
  36.37747846067349,
  36.87402238606382,
  37.37449765026789,
  37.87891309649659,
  38.38727753828926,
  38.89959975977785,
  39.41588851594697,
  39.93615253289054,
  40.460400508064545,
  40.98864111053629,
  41.520882981230194,
  42.05713473317016,
  42.597404951718396,
  43.141702194811224,
  43.6900349931913,
  44.24241185063697,
  44.798841244188324,
  45.35933162437017,
  45.92389141541209,
  46.49252901546552,
  47.065252796817916,
  47.64207110610409,
  48.22299226451468,
  48.808024568002054,
  49.3971762874833,
  49.9904556690408,
  50.587870934119984,
  51.189430279724725,
  51.79514187861014,
  52.40501387947288,
  53.0190544071392,
  53.637271562750364,
  54.259673423945976,
  54.88626804504493,
  55.517063457223934,
  56.15206766869424,
  56.79128866487574,
  57.43473440856916,
  58.08241284012621,
  58.734331877617365,
  59.39049941699807,
  60.05092333227251,
  60.715611475655585,
  61.38457167773311,
  62.057811747619894,
  62.7353394731159,
  63.417162620860914,
  64.10328893648692,
  64.79372614476921,
  65.48848194977529,
  66.18756403501224,
  66.89098006357258,
  67.59873767827808,
  68.31084450182222,
  69.02730813691093,
  69.74813616640164,
  70.47333615344107,
  71.20291564160104,
  71.93688215501312,
  72.67524319850172,
  73.41800625771542,
  74.16517879925733,
  74.9167682708136,
  75.67278210128072,
  76.43322770089146,
  77.1981124613393,
  77.96744375590167,
  78.74122893956174,
  79.51947534912904,
  80.30219030335869,
  81.08938110306934,
  81.88105503125999,
  82.67721935322541,
  83.4778813166706,
  84.28304815182372,
  85.09272707154808,
  85.90692527145302,
  86.72564993000343,
  87.54890820862819,
  88.3767072518277,
  89.2090541872801,
  90.04595612594655,
  90.88742016217518,
  91.73345337380438,
  92.58406282226491,
  93.43925555268066,
  94.29903859396902,
  95.16341895893969,
  96.03240364439274,
  96.9059996312159,
  97.78421388448044,
  98.6670533535366,
  99.55452497210776
];
const pn = class pn {
  static from(t, e, r) {
    return new pn($i.solveToInt(t, e, r));
  }
  /**
   * @param argb ARGB representation of a color.
   * @return HCT representation of a color in default viewing conditions
   */
  static fromInt(t) {
    return new pn(t);
  }
  toInt() {
    return this.argb;
  }
  /**
   * A number, in degrees, representing ex. red, orange, yellow, etc.
   * Ranges from 0 <= hue < 360.
   */
  get hue() {
    return this.internalHue;
  }
  /**
   * @param newHue 0 <= newHue < 360; invalid values are corrected.
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set hue(t) {
    this.setInternalState($i.solveToInt(t, this.internalChroma, this.internalTone));
  }
  get chroma() {
    return this.internalChroma;
  }
  /**
   * @param newChroma 0 <= newChroma < ?
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set chroma(t) {
    this.setInternalState($i.solveToInt(this.internalHue, t, this.internalTone));
  }
  /** Lightness. Ranges from 0 to 100. */
  get tone() {
    return this.internalTone;
  }
  /**
   * @param newTone 0 <= newTone <= 100; invalid valids are corrected.
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set tone(t) {
    this.setInternalState($i.solveToInt(this.internalHue, this.internalChroma, t));
  }
  constructor(t) {
    this.argb = t;
    const e = Yr.fromInt(t);
    this.internalHue = e.hue, this.internalChroma = e.chroma, this.internalTone = Tw(t), this.argb = t;
  }
  setInternalState(t) {
    const e = Yr.fromInt(t);
    this.internalHue = e.hue, this.internalChroma = e.chroma, this.internalTone = Tw(t), this.argb = t;
  }
  /**
   * Translates a color into different [ViewingConditions].
   *
   * Colors change appearance. They look different with lights on versus off,
   * the same color, as in hex code, on white looks different when on black.
   * This is called color relativity, most famously explicated by Josef Albers
   * in Interaction of Color.
   *
   * In color science, color appearance models can account for this and
   * calculate the appearance of a color in different settings. HCT is based on
   * CAM16, a color appearance model, and uses it to make these calculations.
   *
   * See [ViewingConditions.make] for parameters affecting color appearance.
   */
  inViewingConditions(t) {
    const r = Yr.fromInt(this.toInt()).xyzInViewingConditions(t), s = Yr.fromXyzInViewingConditions(r[0], r[1], r[2], xi.make());
    return pn.from(s.hue, s.chroma, au(r[1]));
  }
};
a(pn, "Hct");
let Ne = pn;
const hr = class hr {
  /**
   * Returns a contrast ratio, which ranges from 1 to 21.
   *
   * @param toneA Tone between 0 and 100. Values outside will be clamped.
   * @param toneB Tone between 0 and 100. Values outside will be clamped.
   */
  static ratioOfTones(t, e) {
    return t = Ud(0, 100, t), e = Ud(0, 100, e), hr.ratioOfYs(kr(t), kr(e));
  }
  static ratioOfYs(t, e) {
    const r = t > e ? t : e, s = r === e ? t : e;
    return (r + 5) / (s + 5);
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns -1 if ratio cannot be achieved with tone parameter.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in -1 being returned.
   * @param ratio Contrast ratio of return value and tone.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static lighter(t, e) {
    if (t < 0 || t > 100)
      return -1;
    const r = kr(t), s = e * (r + 5) - 5, n = hr.ratioOfYs(s, r), o = Math.abs(n - e);
    if (n < e && o > 0.04)
      return -1;
    const c = au(s) + 0.4;
    return c < 0 || c > 100 ? -1 : c;
  }
  /**
   * Returns a tone <= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns -1 if ratio cannot be achieved with tone parameter.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in -1 being returned.
   * @param ratio Contrast ratio of return value and tone.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static darker(t, e) {
    if (t < 0 || t > 100)
      return -1;
    const r = kr(t), s = (r + 5) / e - 5, n = hr.ratioOfYs(r, s), o = Math.abs(n - e);
    if (n < e && o > 0.04)
      return -1;
    const c = au(s) - 0.4;
    return c < 0 || c > 100 ? -1 : c;
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns 100 if ratio cannot be achieved with tone parameter.
   *
   * This method is unsafe because the returned value is guaranteed to be in
   * bounds for tone, i.e. between 0 and 100. However, that value may not reach
   * the ratio with tone. For example, there is no color lighter than T100.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in 100 being returned.
   * @param ratio Desired contrast ratio of return value and tone parameter.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static lighterUnsafe(t, e) {
    const r = hr.lighter(t, e);
    return r < 0 ? 100 : r;
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns 100 if ratio cannot be achieved with tone parameter.
   *
   * This method is unsafe because the returned value is guaranteed to be in
   * bounds for tone, i.e. between 0 and 100. However, that value may not reach
   * the [ratio with [tone]. For example, there is no color darker than T0.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in 0 being returned.
   * @param ratio Desired contrast ratio of return value and tone parameter.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static darkerUnsafe(t, e) {
    const r = hr.darker(t, e);
    return r < 0 ? 0 : r;
  }
};
a(hr, "Contrast");
let Ee = hr;
const ch = class ch {
  /**
   * Returns true if a color is disliked.
   *
   * @param hct A color to be judged.
   * @return Whether the color is disliked.
   *
   * Disliked is defined as a dark yellow-green that is not neutral.
   */
  static isDisliked(t) {
    const e = Math.round(t.hue) >= 90 && Math.round(t.hue) <= 111, r = Math.round(t.chroma) > 16, s = Math.round(t.tone) < 65;
    return e && r && s;
  }
  /**
   * If a color is disliked, lighten it to make it likable.
   *
   * @param hct A color to be judged.
   * @return A new color if the original color is disliked, or the original
   *   color if it is acceptable.
   */
  static fixIfDisliked(t) {
    return ch.isDisliked(t) ? Ne.from(t.hue, t.chroma, 70) : t;
  }
};
a(ch, "DislikeAnalyzer");
let ou = ch;
const ke = class ke {
  /**
   * Create a DynamicColor defined by a TonalPalette and HCT tone.
   *
   * @param args Functions with DynamicScheme as input. Must provide a palette
   * and tone. May provide a background DynamicColor and ToneDeltaConstraint.
   */
  static fromPalette(t) {
    return new ke(t.name ?? "", t.palette, t.tone, t.isBackground ?? !1, t.background, t.secondBackground, t.contrastCurve, t.toneDeltaPair);
  }
  /**
   * The base constructor for DynamicColor.
   *
   * _Strongly_ prefer using one of the convenience constructors. This class is
   * arguably too flexible to ensure it can support any scenario. Functional
   * arguments allow  overriding without risks that come with subclasses.
   *
   * For example, the default behavior of adjust tone at max contrast
   * to be at a 7.0 ratio with its background is principled and
   * matches accessibility guidance. That does not mean it's the desired
   * approach for _every_ design system, and every color pairing,
   * always, in every case.
   *
   * @param name The name of the dynamic color. Defaults to empty.
   * @param palette Function that provides a TonalPalette given
   * DynamicScheme. A TonalPalette is defined by a hue and chroma, so this
   * replaces the need to specify hue/chroma. By providing a tonal palette, when
   * contrast adjustments are made, intended chroma can be preserved.
   * @param tone Function that provides a tone, given a DynamicScheme.
   * @param isBackground Whether this dynamic color is a background, with
   * some other color as the foreground. Defaults to false.
   * @param background The background of the dynamic color (as a function of a
   *     `DynamicScheme`), if it exists.
   * @param secondBackground A second background of the dynamic color (as a
   *     function of a `DynamicScheme`), if it
   * exists.
   * @param contrastCurve A `ContrastCurve` object specifying how its contrast
   * against its background should behave in various contrast levels options.
   * @param toneDeltaPair A `ToneDeltaPair` object specifying a tone delta
   * constraint between two colors. One of them must be the color being
   * constructed.
   */
  constructor(t, e, r, s, n, o, c, l) {
    if (this.name = t, this.palette = e, this.tone = r, this.isBackground = s, this.background = n, this.secondBackground = o, this.contrastCurve = c, this.toneDeltaPair = l, this.hctCache = /* @__PURE__ */ new Map(), !n && o)
      throw new Error(`Color ${t} has secondBackgrounddefined, but background is not defined.`);
    if (!n && c)
      throw new Error(`Color ${t} has contrastCurvedefined, but background is not defined.`);
    if (n && !c)
      throw new Error(`Color ${t} has backgrounddefined, but contrastCurve is not defined.`);
  }
  /**
   * Return a ARGB integer (i.e. a hex code).
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getArgb(t) {
    return this.getHct(t).toInt();
  }
  /**
   * Return a color, expressed in the HCT color space, that this
   * DynamicColor is under the conditions in scheme.
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getHct(t) {
    const e = this.hctCache.get(t);
    if (e != null)
      return e;
    const r = this.getTone(t), s = this.palette(t).getHct(r);
    return this.hctCache.size > 4 && this.hctCache.clear(), this.hctCache.set(t, s), s;
  }
  /**
   * Return a tone, T in the HCT color space, that this DynamicColor is under
   * the conditions in scheme.
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getTone(t) {
    const e = t.contrastLevel < 0;
    if (this.toneDeltaPair) {
      const r = this.toneDeltaPair(t), s = r.roleA, n = r.roleB, o = r.delta, c = r.polarity, l = r.stayTogether, f = this.background(t).getTone(t), $ = c === "nearer" || c === "lighter" && !t.isDark || c === "darker" && t.isDark, m = $ ? s : n, x = $ ? n : s, g = this.name === m.name, S = t.isDark ? 1 : -1, I = m.contrastCurve.get(t.contrastLevel), A = x.contrastCurve.get(t.contrastLevel), E = m.tone(t);
      let T = Ee.ratioOfTones(f, E) >= I ? E : ke.foregroundTone(f, I);
      const q = x.tone(t);
      let R = Ee.ratioOfTones(f, q) >= A ? q : ke.foregroundTone(f, A);
      return e && (T = ke.foregroundTone(f, I), R = ke.foregroundTone(f, A)), (R - T) * S >= o || (R = Ud(0, 100, T + o * S), (R - T) * S >= o || (T = Ud(0, 100, R - o * S))), 50 <= T && T < 60 ? S > 0 ? (T = 60, R = Math.max(R, T + o * S)) : (T = 49, R = Math.min(R, T + o * S)) : 50 <= R && R < 60 && (l ? S > 0 ? (T = 60, R = Math.max(R, T + o * S)) : (T = 49, R = Math.min(R, T + o * S)) : S > 0 ? R = 60 : R = 49), g ? T : R;
    } else {
      let r = this.tone(t);
      if (this.background == null)
        return r;
      const s = this.background(t).getTone(t), n = this.contrastCurve.get(t.contrastLevel);
      if (Ee.ratioOfTones(s, r) >= n || (r = ke.foregroundTone(s, n)), e && (r = ke.foregroundTone(s, n)), this.isBackground && 50 <= r && r < 60 && (Ee.ratioOfTones(49, s) >= n ? r = 49 : r = 60), this.secondBackground) {
        const [o, c] = [this.background, this.secondBackground], [l, u] = [o(t).getTone(t), c(t).getTone(t)], [f, $] = [Math.max(l, u), Math.min(l, u)];
        if (Ee.ratioOfTones(f, r) >= n && Ee.ratioOfTones($, r) >= n)
          return r;
        const m = Ee.lighter(f, n), x = Ee.darker($, n), g = [];
        return m !== -1 && g.push(m), x !== -1 && g.push(x), ke.tonePrefersLightForeground(l) || ke.tonePrefersLightForeground(u) ? m < 0 ? 100 : m : g.length === 1 ? g[0] : x < 0 ? 0 : x;
      }
      return r;
    }
  }
  /**
   * Given a background tone, find a foreground tone, while ensuring they reach
   * a contrast ratio that is as close to [ratio] as possible.
   *
   * @param bgTone Tone in HCT. Range is 0 to 100, undefined behavior when it
   *     falls outside that range.
   * @param ratio The contrast ratio desired between bgTone and the return
   *     value.
   */
  static foregroundTone(t, e) {
    const r = Ee.lighterUnsafe(t, e), s = Ee.darkerUnsafe(t, e), n = Ee.ratioOfTones(r, t), o = Ee.ratioOfTones(s, t);
    if (ke.tonePrefersLightForeground(t)) {
      const l = Math.abs(n - o) < 0.1 && n < e && o < e;
      return n >= e || n >= o || l ? r : s;
    } else
      return o >= e || o >= n ? s : r;
  }
  /**
   * Returns whether [tone] prefers a light foreground.
   *
   * People prefer white foregrounds on ~T60-70. Observed over time, and also
   * by Andrew Somers during research for APCA.
   *
   * T60 used as to create the smallest discontinuity possible when skipping
   * down to T49 in order to ensure light foregrounds.
   * Since `tertiaryContainer` in dark monochrome scheme requires a tone of
   * 60, it should not be adjusted. Therefore, 60 is excluded here.
   */
  static tonePrefersLightForeground(t) {
    return Math.round(t) < 60;
  }
  /**
   * Returns whether [tone] can reach a contrast ratio of 4.5 with a lighter
   * color.
   */
  static toneAllowsLightForeground(t) {
    return Math.round(t) <= 49;
  }
  /**
   * Adjust a tone such that white has 4.5 contrast, if the tone is
   * reasonably close to supporting it.
   */
  static enableLightForeground(t) {
    return ke.tonePrefersLightForeground(t) && !ke.toneAllowsLightForeground(t) ? 49 : t;
  }
};
a(ke, "DynamicColor");
let G = ke;
const un = class un {
  /**
   * @param argb ARGB representation of a color
   * @return Tones matching that color's hue and chroma.
   */
  static fromInt(t) {
    const e = Ne.fromInt(t);
    return un.fromHct(e);
  }
  /**
   * @param hct Hct
   * @return Tones matching that color's hue and chroma.
   */
  static fromHct(t) {
    return new un(t.hue, t.chroma, t);
  }
  /**
   * @param hue HCT hue
   * @param chroma HCT chroma
   * @return Tones matching hue and chroma.
   */
  static fromHueAndChroma(t, e) {
    const r = new cu(t, e).create();
    return new un(t, e, r);
  }
  constructor(t, e, r) {
    this.hue = t, this.chroma = e, this.keyColor = r, this.cache = /* @__PURE__ */ new Map();
  }
  /**
   * @param tone HCT tone, measured from 0 to 100.
   * @return ARGB representation of a color with that tone.
   */
  tone(t) {
    let e = this.cache.get(t);
    return e === void 0 && (e = Ne.from(this.hue, this.chroma, t).toInt(), this.cache.set(t, e)), e;
  }
  /**
   * @param tone HCT tone.
   * @return HCT representation of a color with that tone.
   */
  getHct(t) {
    return Ne.fromInt(this.tone(t));
  }
};
a(un, "TonalPalette");
let ht = un;
const Ey = class Ey {
  constructor(t, e) {
    this.hue = t, this.requestedChroma = e, this.chromaCache = /* @__PURE__ */ new Map(), this.maxChromaValue = 200;
  }
  /**
   * Creates a key color from a [hue] and a [chroma].
   * The key color is the first tone, starting from T50, matching the given hue
   * and chroma.
   *
   * @return Key color [Hct]
   */
  create() {
    let s = 0, n = 100;
    for (; s < n; ) {
      const o = Math.floor((s + n) / 2), c = this.maxChroma(o) < this.maxChroma(o + 1);
      if (this.maxChroma(o) >= this.requestedChroma - 0.01)
        if (Math.abs(s - 50) < Math.abs(n - 50))
          n = o;
        else {
          if (s === o)
            return Ne.from(this.hue, this.requestedChroma, s);
          s = o;
        }
      else
        c ? s = o + 1 : n = o;
    }
    return Ne.from(this.hue, this.requestedChroma, s);
  }
  // Find the maximum chroma for a given tone
  maxChroma(t) {
    if (this.chromaCache.has(t))
      return this.chromaCache.get(t);
    const e = Ne.from(this.hue, this.maxChromaValue, t).chroma;
    return this.chromaCache.set(t, e), e;
  }
};
a(Ey, "KeyColor");
let cu = Ey;
const Ly = class Ly {
  /**
   * Creates a `ContrastCurve` object.
   *
   * @param low Value for contrast level -1.0
   * @param normal Value for contrast level 0.0
   * @param medium Value for contrast level 0.5
   * @param high Value for contrast level 1.0
   */
  constructor(t, e, r, s) {
    this.low = t, this.normal = e, this.medium = r, this.high = s;
  }
  /**
   * Returns the value at a given contrast level.
   *
   * @param contrastLevel The contrast level. 0.0 is the default (normal); -1.0
   *     is the lowest; 1.0 is the highest.
   * @return The value. For contrast ratios, a number between 1.0 and 21.0.
   */
  get(t) {
    return t <= -1 ? this.low : t < 0 ? rl(this.low, this.normal, (t - -1) / 1) : t < 0.5 ? rl(this.normal, this.medium, (t - 0) / 0.5) : t < 1 ? rl(this.medium, this.high, (t - 0.5) / 0.5) : this.high;
  }
};
a(Ly, "ContrastCurve");
let at = Ly;
const Oy = class Oy {
  /**
   * Documents a constraint in tone distance between two DynamicColors.
   *
   * The polarity is an adjective that describes "A", compared to "B".
   *
   * For instance, ToneDeltaPair(A, B, 15, 'darker', stayTogether) states that
   * A's tone should be at least 15 darker than B's.
   *
   * 'nearer' and 'farther' describes closeness to the surface roles. For
   * instance, ToneDeltaPair(A, B, 10, 'nearer', stayTogether) states that A
   * should be 10 lighter than B in light mode, and 10 darker than B in dark
   * mode.
   *
   * @param roleA The first role in a pair.
   * @param roleB The second role in a pair.
   * @param delta Required difference between tones. Absolute value, negative
   * values have undefined behavior.
   * @param polarity The relative relation between tones of roleA and roleB,
   * as described above.
   * @param stayTogether Whether these two roles should stay on the same side of
   * the "awkward zone" (T50-59). This is necessary for certain cases where
   * one role has two backgrounds.
   */
  constructor(t, e, r, s, n) {
    this.roleA = t, this.roleB = e, this.delta = r, this.polarity = s, this.stayTogether = n;
  }
};
a(Oy, "ToneDeltaPair");
let be = Oy;
var fs;
(function(i) {
  i[i.MONOCHROME = 0] = "MONOCHROME", i[i.NEUTRAL = 1] = "NEUTRAL", i[i.TONAL_SPOT = 2] = "TONAL_SPOT", i[i.VIBRANT = 3] = "VIBRANT", i[i.EXPRESSIVE = 4] = "EXPRESSIVE", i[i.FIDELITY = 5] = "FIDELITY", i[i.CONTENT = 6] = "CONTENT", i[i.RAINBOW = 7] = "RAINBOW", i[i.FRUIT_SALAD = 8] = "FRUIT_SALAD";
})(fs || (fs = {}));
function Dc(i) {
  return i.variant === fs.FIDELITY || i.variant === fs.CONTENT;
}
a(Dc, "isFidelity");
function Lt(i) {
  return i.variant === fs.MONOCHROME;
}
a(Lt, "isMonochrome");
function _g(i, t, e, r) {
  let s = e, n = Ne.from(i, t, e);
  if (n.chroma < t) {
    let o = n.chroma;
    for (; n.chroma < t; ) {
      s += r ? -1 : 1;
      const c = Ne.from(i, t, s);
      if (o > c.chroma || Math.abs(c.chroma - t) < 0.4)
        break;
      const l = Math.abs(c.chroma - t), u = Math.abs(n.chroma - t);
      l < u && (n = c), o = Math.max(o, c.chroma);
    }
  }
  return s;
}
a(_g, "findDesiredChromaByTone");
const al = class al {
  static highestSurface(t) {
    return t.isDark ? al.surfaceBright : al.surfaceDim;
  }
};
a(al, "MaterialDynamicColors");
let k = al;
k.contentAccentToneDelta = 15;
k.primaryPaletteKeyColor = G.fromPalette({
  name: "primary_palette_key_color",
  palette: /* @__PURE__ */ a((i) => i.primaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.primaryPalette.keyColor.tone, "tone")
});
k.secondaryPaletteKeyColor = G.fromPalette({
  name: "secondary_palette_key_color",
  palette: /* @__PURE__ */ a((i) => i.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.secondaryPalette.keyColor.tone, "tone")
});
k.tertiaryPaletteKeyColor = G.fromPalette({
  name: "tertiary_palette_key_color",
  palette: /* @__PURE__ */ a((i) => i.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.tertiaryPalette.keyColor.tone, "tone")
});
k.neutralPaletteKeyColor = G.fromPalette({
  name: "neutral_palette_key_color",
  palette: /* @__PURE__ */ a((i) => i.neutralPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.neutralPalette.keyColor.tone, "tone")
});
k.neutralVariantPaletteKeyColor = G.fromPalette({
  name: "neutral_variant_palette_key_color",
  palette: /* @__PURE__ */ a((i) => i.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.neutralVariantPalette.keyColor.tone, "tone")
});
k.background = G.fromPalette({
  name: "background",
  palette: /* @__PURE__ */ a((i) => i.neutralPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? 6 : 98, "tone"),
  isBackground: !0
});
k.onBackground = G.fromPalette({
  name: "on_background",
  palette: /* @__PURE__ */ a((i) => i.neutralPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ a((i) => k.background, "background"),
  contrastCurve: new at(3, 3, 4.5, 7)
});
k.surface = G.fromPalette({
  name: "surface",
  palette: /* @__PURE__ */ a((i) => i.neutralPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? 6 : 98, "tone"),
  isBackground: !0
});
k.surfaceDim = G.fromPalette({
  name: "surface_dim",
  palette: /* @__PURE__ */ a((i) => i.neutralPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? 6 : new at(87, 87, 80, 75).get(i.contrastLevel), "tone"),
  isBackground: !0
});
k.surfaceBright = G.fromPalette({
  name: "surface_bright",
  palette: /* @__PURE__ */ a((i) => i.neutralPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? new at(24, 24, 29, 34).get(i.contrastLevel) : 98, "tone"),
  isBackground: !0
});
k.surfaceContainerLowest = G.fromPalette({
  name: "surface_container_lowest",
  palette: /* @__PURE__ */ a((i) => i.neutralPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? new at(4, 4, 2, 0).get(i.contrastLevel) : 100, "tone"),
  isBackground: !0
});
k.surfaceContainerLow = G.fromPalette({
  name: "surface_container_low",
  palette: /* @__PURE__ */ a((i) => i.neutralPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? new at(10, 10, 11, 12).get(i.contrastLevel) : new at(96, 96, 96, 95).get(i.contrastLevel), "tone"),
  isBackground: !0
});
k.surfaceContainer = G.fromPalette({
  name: "surface_container",
  palette: /* @__PURE__ */ a((i) => i.neutralPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? new at(12, 12, 16, 20).get(i.contrastLevel) : new at(94, 94, 92, 90).get(i.contrastLevel), "tone"),
  isBackground: !0
});
k.surfaceContainerHigh = G.fromPalette({
  name: "surface_container_high",
  palette: /* @__PURE__ */ a((i) => i.neutralPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? new at(17, 17, 21, 25).get(i.contrastLevel) : new at(92, 92, 88, 85).get(i.contrastLevel), "tone"),
  isBackground: !0
});
k.surfaceContainerHighest = G.fromPalette({
  name: "surface_container_highest",
  palette: /* @__PURE__ */ a((i) => i.neutralPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? new at(22, 22, 26, 30).get(i.contrastLevel) : new at(90, 90, 84, 80).get(i.contrastLevel), "tone"),
  isBackground: !0
});
k.onSurface = G.fromPalette({
  name: "on_surface",
  palette: /* @__PURE__ */ a((i) => i.neutralPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ a((i) => k.highestSurface(i), "background"),
  contrastCurve: new at(4.5, 7, 11, 21)
});
k.surfaceVariant = G.fromPalette({
  name: "surface_variant",
  palette: /* @__PURE__ */ a((i) => i.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? 30 : 90, "tone"),
  isBackground: !0
});
k.onSurfaceVariant = G.fromPalette({
  name: "on_surface_variant",
  palette: /* @__PURE__ */ a((i) => i.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? 80 : 30, "tone"),
  background: /* @__PURE__ */ a((i) => k.highestSurface(i), "background"),
  contrastCurve: new at(3, 4.5, 7, 11)
});
k.inverseSurface = G.fromPalette({
  name: "inverse_surface",
  palette: /* @__PURE__ */ a((i) => i.neutralPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? 90 : 20, "tone")
});
k.inverseOnSurface = G.fromPalette({
  name: "inverse_on_surface",
  palette: /* @__PURE__ */ a((i) => i.neutralPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? 20 : 95, "tone"),
  background: /* @__PURE__ */ a((i) => k.inverseSurface, "background"),
  contrastCurve: new at(4.5, 7, 11, 21)
});
k.outline = G.fromPalette({
  name: "outline",
  palette: /* @__PURE__ */ a((i) => i.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? 60 : 50, "tone"),
  background: /* @__PURE__ */ a((i) => k.highestSurface(i), "background"),
  contrastCurve: new at(1.5, 3, 4.5, 7)
});
k.outlineVariant = G.fromPalette({
  name: "outline_variant",
  palette: /* @__PURE__ */ a((i) => i.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? 30 : 80, "tone"),
  background: /* @__PURE__ */ a((i) => k.highestSurface(i), "background"),
  contrastCurve: new at(1, 1, 3, 4.5)
});
k.shadow = G.fromPalette({
  name: "shadow",
  palette: /* @__PURE__ */ a((i) => i.neutralPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => 0, "tone")
});
k.scrim = G.fromPalette({
  name: "scrim",
  palette: /* @__PURE__ */ a((i) => i.neutralPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => 0, "tone")
});
k.surfaceTint = G.fromPalette({
  name: "surface_tint",
  palette: /* @__PURE__ */ a((i) => i.primaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? 80 : 40, "tone"),
  isBackground: !0
});
k.primary = G.fromPalette({
  name: "primary",
  palette: /* @__PURE__ */ a((i) => i.primaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Lt(i) ? i.isDark ? 100 : 0 : i.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ a((i) => k.highestSurface(i), "background"),
  contrastCurve: new at(3, 4.5, 7, 7),
  toneDeltaPair: /* @__PURE__ */ a((i) => new be(k.primaryContainer, k.primary, 10, "nearer", !1), "toneDeltaPair")
});
k.onPrimary = G.fromPalette({
  name: "on_primary",
  palette: /* @__PURE__ */ a((i) => i.primaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Lt(i) ? i.isDark ? 10 : 90 : i.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ a((i) => k.primary, "background"),
  contrastCurve: new at(4.5, 7, 11, 21)
});
k.primaryContainer = G.fromPalette({
  name: "primary_container",
  palette: /* @__PURE__ */ a((i) => i.primaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Dc(i) ? i.sourceColorHct.tone : Lt(i) ? i.isDark ? 85 : 25 : i.isDark ? 30 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ a((i) => k.highestSurface(i), "background"),
  contrastCurve: new at(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ a((i) => new be(k.primaryContainer, k.primary, 10, "nearer", !1), "toneDeltaPair")
});
k.onPrimaryContainer = G.fromPalette({
  name: "on_primary_container",
  palette: /* @__PURE__ */ a((i) => i.primaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Dc(i) ? G.foregroundTone(k.primaryContainer.tone(i), 4.5) : Lt(i) ? i.isDark ? 0 : 100 : i.isDark ? 90 : 30, "tone"),
  background: /* @__PURE__ */ a((i) => k.primaryContainer, "background"),
  contrastCurve: new at(3, 4.5, 7, 11)
});
k.inversePrimary = G.fromPalette({
  name: "inverse_primary",
  palette: /* @__PURE__ */ a((i) => i.primaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? 40 : 80, "tone"),
  background: /* @__PURE__ */ a((i) => k.inverseSurface, "background"),
  contrastCurve: new at(3, 4.5, 7, 7)
});
k.secondary = G.fromPalette({
  name: "secondary",
  palette: /* @__PURE__ */ a((i) => i.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ a((i) => k.highestSurface(i), "background"),
  contrastCurve: new at(3, 4.5, 7, 7),
  toneDeltaPair: /* @__PURE__ */ a((i) => new be(k.secondaryContainer, k.secondary, 10, "nearer", !1), "toneDeltaPair")
});
k.onSecondary = G.fromPalette({
  name: "on_secondary",
  palette: /* @__PURE__ */ a((i) => i.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Lt(i) ? i.isDark ? 10 : 100 : i.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ a((i) => k.secondary, "background"),
  contrastCurve: new at(4.5, 7, 11, 21)
});
k.secondaryContainer = G.fromPalette({
  name: "secondary_container",
  palette: /* @__PURE__ */ a((i) => i.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => {
    const t = i.isDark ? 30 : 90;
    return Lt(i) ? i.isDark ? 30 : 85 : Dc(i) ? _g(i.secondaryPalette.hue, i.secondaryPalette.chroma, t, !i.isDark) : t;
  }, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ a((i) => k.highestSurface(i), "background"),
  contrastCurve: new at(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ a((i) => new be(k.secondaryContainer, k.secondary, 10, "nearer", !1), "toneDeltaPair")
});
k.onSecondaryContainer = G.fromPalette({
  name: "on_secondary_container",
  palette: /* @__PURE__ */ a((i) => i.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Lt(i) ? i.isDark ? 90 : 10 : Dc(i) ? G.foregroundTone(k.secondaryContainer.tone(i), 4.5) : i.isDark ? 90 : 30, "tone"),
  background: /* @__PURE__ */ a((i) => k.secondaryContainer, "background"),
  contrastCurve: new at(3, 4.5, 7, 11)
});
k.tertiary = G.fromPalette({
  name: "tertiary",
  palette: /* @__PURE__ */ a((i) => i.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Lt(i) ? i.isDark ? 90 : 25 : i.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ a((i) => k.highestSurface(i), "background"),
  contrastCurve: new at(3, 4.5, 7, 7),
  toneDeltaPair: /* @__PURE__ */ a((i) => new be(k.tertiaryContainer, k.tertiary, 10, "nearer", !1), "toneDeltaPair")
});
k.onTertiary = G.fromPalette({
  name: "on_tertiary",
  palette: /* @__PURE__ */ a((i) => i.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Lt(i) ? i.isDark ? 10 : 90 : i.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ a((i) => k.tertiary, "background"),
  contrastCurve: new at(4.5, 7, 11, 21)
});
k.tertiaryContainer = G.fromPalette({
  name: "tertiary_container",
  palette: /* @__PURE__ */ a((i) => i.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => {
    if (Lt(i))
      return i.isDark ? 60 : 49;
    if (!Dc(i))
      return i.isDark ? 30 : 90;
    const t = i.tertiaryPalette.getHct(i.sourceColorHct.tone);
    return ou.fixIfDisliked(t).tone;
  }, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ a((i) => k.highestSurface(i), "background"),
  contrastCurve: new at(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ a((i) => new be(k.tertiaryContainer, k.tertiary, 10, "nearer", !1), "toneDeltaPair")
});
k.onTertiaryContainer = G.fromPalette({
  name: "on_tertiary_container",
  palette: /* @__PURE__ */ a((i) => i.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Lt(i) ? i.isDark ? 0 : 100 : Dc(i) ? G.foregroundTone(k.tertiaryContainer.tone(i), 4.5) : i.isDark ? 90 : 30, "tone"),
  background: /* @__PURE__ */ a((i) => k.tertiaryContainer, "background"),
  contrastCurve: new at(3, 4.5, 7, 11)
});
k.error = G.fromPalette({
  name: "error",
  palette: /* @__PURE__ */ a((i) => i.errorPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ a((i) => k.highestSurface(i), "background"),
  contrastCurve: new at(3, 4.5, 7, 7),
  toneDeltaPair: /* @__PURE__ */ a((i) => new be(k.errorContainer, k.error, 10, "nearer", !1), "toneDeltaPair")
});
k.onError = G.fromPalette({
  name: "on_error",
  palette: /* @__PURE__ */ a((i) => i.errorPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ a((i) => k.error, "background"),
  contrastCurve: new at(4.5, 7, 11, 21)
});
k.errorContainer = G.fromPalette({
  name: "error_container",
  palette: /* @__PURE__ */ a((i) => i.errorPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => i.isDark ? 30 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ a((i) => k.highestSurface(i), "background"),
  contrastCurve: new at(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ a((i) => new be(k.errorContainer, k.error, 10, "nearer", !1), "toneDeltaPair")
});
k.onErrorContainer = G.fromPalette({
  name: "on_error_container",
  palette: /* @__PURE__ */ a((i) => i.errorPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Lt(i) ? i.isDark ? 90 : 10 : i.isDark ? 90 : 30, "tone"),
  background: /* @__PURE__ */ a((i) => k.errorContainer, "background"),
  contrastCurve: new at(3, 4.5, 7, 11)
});
k.primaryFixed = G.fromPalette({
  name: "primary_fixed",
  palette: /* @__PURE__ */ a((i) => i.primaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Lt(i) ? 40 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ a((i) => k.highestSurface(i), "background"),
  contrastCurve: new at(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ a((i) => new be(k.primaryFixed, k.primaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
k.primaryFixedDim = G.fromPalette({
  name: "primary_fixed_dim",
  palette: /* @__PURE__ */ a((i) => i.primaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Lt(i) ? 30 : 80, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ a((i) => k.highestSurface(i), "background"),
  contrastCurve: new at(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ a((i) => new be(k.primaryFixed, k.primaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
k.onPrimaryFixed = G.fromPalette({
  name: "on_primary_fixed",
  palette: /* @__PURE__ */ a((i) => i.primaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Lt(i) ? 100 : 10, "tone"),
  background: /* @__PURE__ */ a((i) => k.primaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ a((i) => k.primaryFixed, "secondBackground"),
  contrastCurve: new at(4.5, 7, 11, 21)
});
k.onPrimaryFixedVariant = G.fromPalette({
  name: "on_primary_fixed_variant",
  palette: /* @__PURE__ */ a((i) => i.primaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Lt(i) ? 90 : 30, "tone"),
  background: /* @__PURE__ */ a((i) => k.primaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ a((i) => k.primaryFixed, "secondBackground"),
  contrastCurve: new at(3, 4.5, 7, 11)
});
k.secondaryFixed = G.fromPalette({
  name: "secondary_fixed",
  palette: /* @__PURE__ */ a((i) => i.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Lt(i) ? 80 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ a((i) => k.highestSurface(i), "background"),
  contrastCurve: new at(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ a((i) => new be(k.secondaryFixed, k.secondaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
k.secondaryFixedDim = G.fromPalette({
  name: "secondary_fixed_dim",
  palette: /* @__PURE__ */ a((i) => i.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Lt(i) ? 70 : 80, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ a((i) => k.highestSurface(i), "background"),
  contrastCurve: new at(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ a((i) => new be(k.secondaryFixed, k.secondaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
k.onSecondaryFixed = G.fromPalette({
  name: "on_secondary_fixed",
  palette: /* @__PURE__ */ a((i) => i.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => 10, "tone"),
  background: /* @__PURE__ */ a((i) => k.secondaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ a((i) => k.secondaryFixed, "secondBackground"),
  contrastCurve: new at(4.5, 7, 11, 21)
});
k.onSecondaryFixedVariant = G.fromPalette({
  name: "on_secondary_fixed_variant",
  palette: /* @__PURE__ */ a((i) => i.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Lt(i) ? 25 : 30, "tone"),
  background: /* @__PURE__ */ a((i) => k.secondaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ a((i) => k.secondaryFixed, "secondBackground"),
  contrastCurve: new at(3, 4.5, 7, 11)
});
k.tertiaryFixed = G.fromPalette({
  name: "tertiary_fixed",
  palette: /* @__PURE__ */ a((i) => i.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Lt(i) ? 40 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ a((i) => k.highestSurface(i), "background"),
  contrastCurve: new at(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ a((i) => new be(k.tertiaryFixed, k.tertiaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
k.tertiaryFixedDim = G.fromPalette({
  name: "tertiary_fixed_dim",
  palette: /* @__PURE__ */ a((i) => i.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Lt(i) ? 30 : 80, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ a((i) => k.highestSurface(i), "background"),
  contrastCurve: new at(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ a((i) => new be(k.tertiaryFixed, k.tertiaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
k.onTertiaryFixed = G.fromPalette({
  name: "on_tertiary_fixed",
  palette: /* @__PURE__ */ a((i) => i.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Lt(i) ? 100 : 10, "tone"),
  background: /* @__PURE__ */ a((i) => k.tertiaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ a((i) => k.tertiaryFixed, "secondBackground"),
  contrastCurve: new at(4.5, 7, 11, 21)
});
k.onTertiaryFixedVariant = G.fromPalette({
  name: "on_tertiary_fixed_variant",
  palette: /* @__PURE__ */ a((i) => i.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ a((i) => Lt(i) ? 90 : 30, "tone"),
  background: /* @__PURE__ */ a((i) => k.tertiaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ a((i) => k.tertiaryFixed, "secondBackground"),
  contrastCurve: new at(3, 4.5, 7, 11)
});
const Iy = class Iy {
  constructor(t) {
    this.sourceColorArgb = t.sourceColorArgb, this.variant = t.variant, this.contrastLevel = t.contrastLevel, this.isDark = t.isDark, this.sourceColorHct = Ne.fromInt(t.sourceColorArgb), this.primaryPalette = t.primaryPalette, this.secondaryPalette = t.secondaryPalette, this.tertiaryPalette = t.tertiaryPalette, this.neutralPalette = t.neutralPalette, this.neutralVariantPalette = t.neutralVariantPalette, this.errorPalette = ht.fromHueAndChroma(25, 84);
  }
  /**
   * Support design spec'ing Dynamic Color by schemes that specify hue
   * rotations that should be applied at certain breakpoints.
   * @param sourceColor the source color of the theme, in HCT.
   * @param hues The "breakpoints", i.e. the hues at which a rotation should
   * be apply.
   * @param rotations The rotation that should be applied when source color's
   * hue is >= the same index in hues array, and <= the hue at the next index
   * in hues array.
   */
  static getRotatedHue(t, e, r) {
    const s = t.hue;
    if (e.length !== r.length)
      throw new Error(`mismatch between hue length ${e.length} & rotations ${r.length}`);
    if (r.length === 1)
      return ll(t.hue + r[0]);
    const n = e.length;
    for (let o = 0; o <= n - 2; o++) {
      const c = e[o], l = e[o + 1];
      if (c < s && s < l)
        return ll(s + r[o]);
    }
    return s;
  }
  getArgb(t) {
    return t.getArgb(this);
  }
  getHct(t) {
    return t.getHct(this);
  }
  get primaryPaletteKeyColor() {
    return this.getArgb(k.primaryPaletteKeyColor);
  }
  get secondaryPaletteKeyColor() {
    return this.getArgb(k.secondaryPaletteKeyColor);
  }
  get tertiaryPaletteKeyColor() {
    return this.getArgb(k.tertiaryPaletteKeyColor);
  }
  get neutralPaletteKeyColor() {
    return this.getArgb(k.neutralPaletteKeyColor);
  }
  get neutralVariantPaletteKeyColor() {
    return this.getArgb(k.neutralVariantPaletteKeyColor);
  }
  get background() {
    return this.getArgb(k.background);
  }
  get onBackground() {
    return this.getArgb(k.onBackground);
  }
  get surface() {
    return this.getArgb(k.surface);
  }
  get surfaceDim() {
    return this.getArgb(k.surfaceDim);
  }
  get surfaceBright() {
    return this.getArgb(k.surfaceBright);
  }
  get surfaceContainerLowest() {
    return this.getArgb(k.surfaceContainerLowest);
  }
  get surfaceContainerLow() {
    return this.getArgb(k.surfaceContainerLow);
  }
  get surfaceContainer() {
    return this.getArgb(k.surfaceContainer);
  }
  get surfaceContainerHigh() {
    return this.getArgb(k.surfaceContainerHigh);
  }
  get surfaceContainerHighest() {
    return this.getArgb(k.surfaceContainerHighest);
  }
  get onSurface() {
    return this.getArgb(k.onSurface);
  }
  get surfaceVariant() {
    return this.getArgb(k.surfaceVariant);
  }
  get onSurfaceVariant() {
    return this.getArgb(k.onSurfaceVariant);
  }
  get inverseSurface() {
    return this.getArgb(k.inverseSurface);
  }
  get inverseOnSurface() {
    return this.getArgb(k.inverseOnSurface);
  }
  get outline() {
    return this.getArgb(k.outline);
  }
  get outlineVariant() {
    return this.getArgb(k.outlineVariant);
  }
  get shadow() {
    return this.getArgb(k.shadow);
  }
  get scrim() {
    return this.getArgb(k.scrim);
  }
  get surfaceTint() {
    return this.getArgb(k.surfaceTint);
  }
  get primary() {
    return this.getArgb(k.primary);
  }
  get onPrimary() {
    return this.getArgb(k.onPrimary);
  }
  get primaryContainer() {
    return this.getArgb(k.primaryContainer);
  }
  get onPrimaryContainer() {
    return this.getArgb(k.onPrimaryContainer);
  }
  get inversePrimary() {
    return this.getArgb(k.inversePrimary);
  }
  get secondary() {
    return this.getArgb(k.secondary);
  }
  get onSecondary() {
    return this.getArgb(k.onSecondary);
  }
  get secondaryContainer() {
    return this.getArgb(k.secondaryContainer);
  }
  get onSecondaryContainer() {
    return this.getArgb(k.onSecondaryContainer);
  }
  get tertiary() {
    return this.getArgb(k.tertiary);
  }
  get onTertiary() {
    return this.getArgb(k.onTertiary);
  }
  get tertiaryContainer() {
    return this.getArgb(k.tertiaryContainer);
  }
  get onTertiaryContainer() {
    return this.getArgb(k.onTertiaryContainer);
  }
  get error() {
    return this.getArgb(k.error);
  }
  get onError() {
    return this.getArgb(k.onError);
  }
  get errorContainer() {
    return this.getArgb(k.errorContainer);
  }
  get onErrorContainer() {
    return this.getArgb(k.onErrorContainer);
  }
  get primaryFixed() {
    return this.getArgb(k.primaryFixed);
  }
  get primaryFixedDim() {
    return this.getArgb(k.primaryFixedDim);
  }
  get onPrimaryFixed() {
    return this.getArgb(k.onPrimaryFixed);
  }
  get onPrimaryFixedVariant() {
    return this.getArgb(k.onPrimaryFixedVariant);
  }
  get secondaryFixed() {
    return this.getArgb(k.secondaryFixed);
  }
  get secondaryFixedDim() {
    return this.getArgb(k.secondaryFixedDim);
  }
  get onSecondaryFixed() {
    return this.getArgb(k.onSecondaryFixed);
  }
  get onSecondaryFixedVariant() {
    return this.getArgb(k.onSecondaryFixedVariant);
  }
  get tertiaryFixed() {
    return this.getArgb(k.tertiaryFixed);
  }
  get tertiaryFixedDim() {
    return this.getArgb(k.tertiaryFixedDim);
  }
  get onTertiaryFixed() {
    return this.getArgb(k.onTertiaryFixed);
  }
  get onTertiaryFixedVariant() {
    return this.getArgb(k.onTertiaryFixedVariant);
  }
};
a(Iy, "DynamicScheme");
let ji = Iy;
const Gr = class Gr extends ji {
  constructor(t, e, r) {
    super({
      sourceColorArgb: t.toInt(),
      variant: fs.EXPRESSIVE,
      contrastLevel: r,
      isDark: e,
      primaryPalette: ht.fromHueAndChroma(ll(t.hue + 240), 40),
      secondaryPalette: ht.fromHueAndChroma(ji.getRotatedHue(t, Gr.hues, Gr.secondaryRotations), 24),
      tertiaryPalette: ht.fromHueAndChroma(ji.getRotatedHue(t, Gr.hues, Gr.tertiaryRotations), 32),
      neutralPalette: ht.fromHueAndChroma(t.hue + 15, 8),
      neutralVariantPalette: ht.fromHueAndChroma(t.hue + 15, 12)
    });
  }
};
a(Gr, "SchemeExpressive");
let dl = Gr;
dl.hues = [
  0,
  21,
  51,
  121,
  151,
  191,
  271,
  321,
  360
];
dl.secondaryRotations = [
  45,
  95,
  45,
  20,
  45,
  90,
  45,
  45,
  45
];
dl.tertiaryRotations = [
  120,
  120,
  20,
  45,
  20,
  15,
  20,
  120,
  120
];
const Zr = class Zr extends ji {
  constructor(t, e, r) {
    super({
      sourceColorArgb: t.toInt(),
      variant: fs.VIBRANT,
      contrastLevel: r,
      isDark: e,
      primaryPalette: ht.fromHueAndChroma(t.hue, 200),
      secondaryPalette: ht.fromHueAndChroma(ji.getRotatedHue(t, Zr.hues, Zr.secondaryRotations), 24),
      tertiaryPalette: ht.fromHueAndChroma(ji.getRotatedHue(t, Zr.hues, Zr.tertiaryRotations), 32),
      neutralPalette: ht.fromHueAndChroma(t.hue, 10),
      neutralVariantPalette: ht.fromHueAndChroma(t.hue, 12)
    });
  }
};
a(Zr, "SchemeVibrant");
let hl = Zr;
hl.hues = [
  0,
  41,
  61,
  101,
  131,
  181,
  251,
  301,
  360
];
hl.secondaryRotations = [
  18,
  15,
  10,
  12,
  15,
  18,
  15,
  12,
  12
];
hl.tertiaryRotations = [
  35,
  30,
  20,
  25,
  30,
  35,
  30,
  25,
  25
];
function Pg(i) {
  i = i.replace("#", "");
  const t = i.length === 3, e = i.length === 6, r = i.length === 8;
  if (!t && !e && !r)
    throw new Error("unexpected hex " + i);
  let s = 0, n = 0, o = 0;
  return t ? (s = Ii(i.slice(0, 1).repeat(2)), n = Ii(i.slice(1, 2).repeat(2)), o = Ii(i.slice(2, 3).repeat(2))) : e ? (s = Ii(i.slice(0, 2)), n = Ii(i.slice(2, 4)), o = Ii(i.slice(4, 6))) : r && (s = Ii(i.slice(2, 4)), n = Ii(i.slice(4, 6)), o = Ii(i.slice(6, 8))), (255 << 24 | (s & 255) << 16 | (n & 255) << 8 | o & 255) >>> 0;
}
a(Pg, "argbFromHex");
function Ii(i) {
  return parseInt(i, 16);
}
a(Ii, "parseIntHex");
function Mg(i, t = !1) {
  const e = i.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+\.{0,1}\d*))?\)$/)?.slice(1).map((c, l) => l === 3 ? Math.round(parseFloat(c) * 255) : parseFloat(c));
  if (!e)
    throw new Error("Could not parse rgba color.");
  const [r, s, n, o] = e;
  return ((t ? 255 : o & 255) << 24 | (r & 255) << 16 | (s & 255) << 8 | n & 255) >>> 0;
}
a(Mg, "argbFromRgba");
function yi(i, t) {
  return Math.round(255 * t) << 24 | i & 16777215;
}
a(yi, "addAlphaToArgb");
function Sg(i) {
  const t = im(i), e = rm(i), r = sm(i), s = gg(i), n = [t.toString(16), e.toString(16), r.toString(16)];
  s !== 255 && n.push(s.toString(16));
  for (const [o, c] of n.entries())
    c.length === 1 && (n[o] = "0" + c);
  return "#" + n.join("");
}
a(Sg, "hexWithAlphaFromArgb");
function Ag(i) {
  we();
  const t = document.createElement("wy-compute-styles");
  t.setAttribute("style", `color: ${i} !important;`), document.documentElement.append(t);
  const e = window.getComputedStyle(t).color;
  return t.remove(), e;
}
a(Ag, "getComputedColor");
const Ty = class Ty extends ji {
  constructor(t, e, r) {
    super({
      sourceColorArgb: t.toInt(),
      variant: 2,
      contrastLevel: r,
      isDark: e,
      primaryPalette: ht.fromHueAndChroma(t.hue, 36),
      secondaryPalette: ht.fromHueAndChroma(t.hue, 16),
      tertiaryPalette: ht.fromHueAndChroma(ll(t.hue - 6 * 22.5), 16),
      neutralPalette: ht.fromHueAndChroma(t.hue, 6),
      neutralVariantPalette: ht.fromHueAndChroma(t.hue, 8)
    }), this.allTones = {
      //"100": 100,
      98: 98,
      // MD3
      95: 95,
      90: 90,
      80: 80,
      70: 70,
      60: 60,
      50: 50,
      40: 40,
      30: 30,
      20: 20,
      10: 10
      //"0": 0
    }, this.namedColorToneMap = {
      red: { light: 60, dark: 60 },
      "deep-orange": { light: 60, dark: 60 },
      orange: { light: 70, dark: 70 },
      amber: { light: 70, dark: 70 },
      yellow: { light: 70, dark: 80 },
      lime: { light: 70, dark: 70 },
      "light-green": { light: 70, dark: 70 },
      green: { light: 60, dark: 60 },
      teal: { light: 60, dark: 60 },
      cyan: { light: 50, dark: 60 },
      "light-blue": { light: 60, dark: 70 },
      blue: { light: 70, dark: 80 },
      indigo: { light: 60, dark: 60 },
      "deep-purple": { light: 60, dark: 70 },
      purple: { light: 60, dark: 70 },
      pink: { light: 60, dark: 70 },
      gray: { light: 50, dark: 60 }
    };
    const s = t.hue, n = t.chroma, o = Math.max(48, n), c = Math.min(o, 84), u = 360 / 16, f = 27.4, $ = -8, m = (s + 360 - f - $ + u / 2) % u + f + $ - u / 2;
    this.errorPalette = ht.fromHueAndChroma(m, 84), this.warningPalette = ht.fromHueAndChroma(m + 4 * u, c), this.namedColorPalettes = {
      red: ht.fromHueAndChroma(m, c),
      "deep-orange": ht.fromHueAndChroma(m + 1 * u, c),
      orange: ht.fromHueAndChroma(m + 2 * u, c),
      amber: ht.fromHueAndChroma(m + 3 * u, c),
      yellow: ht.fromHueAndChroma(m + 4 * u, c),
      lime: ht.fromHueAndChroma(m + 5 * u, c),
      "light-green": ht.fromHueAndChroma(m + 6 * u, c),
      green: ht.fromHueAndChroma(m + 7 * u, c),
      teal: ht.fromHueAndChroma(m + 8 * u, c),
      cyan: ht.fromHueAndChroma(m + 9 * u, c),
      "light-blue": ht.fromHueAndChroma(m + 10 * u, c),
      blue: ht.fromHueAndChroma(m + 11 * u, c),
      indigo: ht.fromHueAndChroma(m + 12 * u, c),
      "deep-purple": ht.fromHueAndChroma(m + 13 * u, c),
      purple: ht.fromHueAndChroma(m + 14 * u, c),
      pink: ht.fromHueAndChroma(m + 15 * u, c),
      gray: ht.fromHueAndChroma(s, 4)
    };
  }
  // Solid base colors
  get black() {
    return 0;
  }
  get white() {
    return 16777215;
  }
  // Custom transparency based surface container colors
  get surfaceLayerLowest() {
    return this.isDark ? yi(this.black, 0.5) : yi(this.white, 0.75);
  }
  get surfaceLayerLow() {
    return this.isDark ? yi(this.black, 0.25) : yi(this.white, 0.5);
  }
  get surfaceLayer() {
    return this.isDark ? yi(this.white, 0.05) : yi(this.black, 0.05);
  }
  get surfaceLayerHigh() {
    return this.isDark ? yi(this.white, 0.1) : yi(this.black, 0.075);
  }
  get surfaceLayerHighest() {
    return this.isDark ? yi(this.white, 0.15) : yi(this.black, 0.1);
  }
  // Custom Tokens
  get warning() {
    return this.warningPalette.tone(this.isDark ? 90 : 70);
  }
  get onWarning() {
    return this.warningPalette.tone(this.isDark ? 30 : 0);
  }
  get warningContainer() {
    return this.warningPalette.tone(this.isDark ? 50 : 90);
  }
  get onWarningContainer() {
    return this.warningPalette.tone(this.isDark ? 95 : 10);
  }
  get highlight() {
    return this.primaryPalette.tone(this.isDark ? 20 : 95);
  }
  get onHighlight() {
    return this.primaryPalette.tone(this.isDark ? 90 : 10);
  }
  // Named colors
  namedColor(t) {
    return this.namedColorPalettes[t].tone(this.namedColorToneMap[t][this.isDark ? "dark" : "light"]);
  }
  get red() {
    return this.namedColor(
      "red"
      /* Red */
    );
  }
  get deepOrange() {
    return this.namedColor(
      "deep-orange"
      /* DeepOrange */
    );
  }
  get orange() {
    return this.namedColor(
      "orange"
      /* Orange */
    );
  }
  get amber() {
    return this.namedColor(
      "amber"
      /* Amber */
    );
  }
  get yellow() {
    return this.namedColor(
      "yellow"
      /* Yellow */
    );
  }
  get lime() {
    return this.namedColor(
      "lime"
      /* Lime */
    );
  }
  get lightGreen() {
    return this.namedColor(
      "light-green"
      /* LightGreen */
    );
  }
  get green() {
    return this.namedColor(
      "green"
      /* Green */
    );
  }
  get teal() {
    return this.namedColor(
      "teal"
      /* Teal */
    );
  }
  get cyan() {
    return this.namedColor(
      "cyan"
      /* Cyan */
    );
  }
  get lightBlue() {
    return this.namedColor(
      "light-blue"
      /* LightBlue */
    );
  }
  get blue() {
    return this.namedColor(
      "blue"
      /* Blue */
    );
  }
  get indigo() {
    return this.namedColor(
      "indigo"
      /* Indigo */
    );
  }
  get deepPurple() {
    return this.namedColor(
      "deep-purple"
      /* DeepPurple */
    );
  }
  get purple() {
    return this.namedColor(
      "purple"
      /* Purple */
    );
  }
  get pink() {
    return this.namedColor(
      "pink"
      /* Pink */
    );
  }
  get gray() {
    return this.namedColor(
      "gray"
      /* Gray */
    );
  }
};
a(Ty, "SchemeWeavy");
let Bd = Ty;
function lu(i) {
  return getComputedStyle(i).getPropertyValue("--wy-theme-color") || void 0;
}
a(lu, "getCSSThemeColor");
function zg(i, t) {
  let e = lu(i);
  const r = new MutationObserver(() => {
    const o = lu(i);
    o !== e && (e = o, t(o));
  }), s = {
    attributes: !0,
    attributeFilter: ["class", "style"]
  };
  let n = i;
  for (; n && n !== document; )
    r.observe(n, s), n = n.parentNode;
  return () => r.disconnect();
}
a(zg, "observeCSSThemeColor");
function du() {
  return we(), Array.from(document.head.querySelectorAll("meta[name='theme-color']")).filter((e) => {
    const r = e.getAttribute("media");
    return !r || window.matchMedia(r)?.matches;
  }).pop()?.getAttribute("content") || void 0;
}
a(du, "getMetaThemeColor");
function Rg(i) {
  we();
  const t = Array.from(document.head.querySelectorAll("meta[name='theme-color']"));
  if (!t)
    return () => {
    };
  let e = du();
  const r = /* @__PURE__ */ a(() => {
    const c = du();
    c !== e && (e = c, i(c));
  }, "checkChangedColor"), s = new MutationObserver(r), n = {
    attributes: !0,
    attributeFilter: ["content"]
  }, o = [];
  return t.forEach((c) => {
    s.observe(c, n);
    const l = c.getAttribute("media");
    if (l) {
      const u = window.matchMedia(l);
      u.addEventListener("change", r), o.push(u);
    }
  }), () => {
    s.disconnect(), o.forEach((c) => c.removeEventListener("change", r));
  };
}
a(Rg, "observeMetaThemeColor");
const Jc = [], Eg = 16;
function Lg(i, t = !1) {
  if (Jc.some((l) => l.seedColor === i)) {
    const l = Jc.find((u) => u.seedColor === i)?.colors;
    if (l)
      return l;
  }
  const e = [];
  t && e.push(`--wy-theme-color:${i};`);
  let r = i;
  !i.startsWith("#") && !i.startsWith("rgb") && (r = Ag(i));
  const s = i.startsWith("#") ? Pg(r) : Mg(r), n = Ne.fromInt(s), o = {
    light: new Bd(n, !1, 0),
    dark: new Bd(n, !0, 0)
  }, c = {
    primary: "primary",
    onPrimary: "on-primary",
    primaryContainer: "primary-container",
    onPrimaryContainer: "on-primary-container",
    secondary: "secondary",
    onSecondary: "on-secondary",
    secondaryContainer: "secondary-container",
    onSecondaryContainer: "on-secondary-container",
    tertiary: "tertiary",
    onTertiary: "on-tertiary",
    tertiaryContainer: "tertiary-container",
    onTertiaryContainer: "on-tertiary-container",
    error: "error",
    onError: "on-error",
    errorContainer: "error-container",
    onErrorContainer: "on-error-container",
    background: "background",
    onBackground: "on-background",
    surface: "surface",
    onSurface: "on-surface",
    surfaceVariant: "surface-variant",
    onSurfaceVariant: "on-surface-variant",
    surfaceContainerLowest: "surface-container-lowest",
    surfaceContainerLow: "surface-container-low",
    surfaceContainer: "surface-container",
    surfaceContainerHigh: "surface-container-high",
    surfaceContainerHighest: "surface-container-highest",
    outline: "outline",
    outlineVariant: "outline-variant",
    shadow: "shadow",
    scrim: "scrim",
    // Custom surface layers
    surfaceLayerLowest: "surface-layer-lowest",
    surfaceLayerLow: "surface-layer-low",
    surfaceLayer: "surface-layer",
    surfaceLayerHigh: "surface-layer-high",
    surfaceLayerHighest: "surface-layer-highest",
    // Custom tokens
    warning: "warning",
    onWarning: "on-warning",
    warningContainer: "warning-container",
    onWarningContainer: "on-warning-container",
    highlight: "highlight",
    onHighlight: "on-highlight",
    // Named colors
    red: "red",
    deepOrange: "deep-orange",
    orange: "orange",
    amber: "amber",
    yellow: "yellow",
    lime: "lime",
    lightGreen: "light-green",
    green: "green",
    teal: "teal",
    cyan: "cyan",
    lightBlue: "light-blue",
    blue: "blue",
    indigo: "indigo",
    deepPurple: "deep-purple",
    purple: "purple",
    pink: "pink",
    gray: "gray"
  };
  for (const l in o) {
    const u = o[l];
    for (const f in c) {
      const $ = c[f], m = Sg(u[f]);
      e.push(`--wy-${$}-${l}:${m};`);
    }
  }
  return Jc.unshift({ seedColor: i, colors: e }), Jc.length = Math.min(Jc.length, Eg), e;
}
a(Lg, "generateThemeColors");
const Og = /* @__PURE__ */ a((i) => {
  if (we(), s1)
    document.adoptedStyleSheets = i.map((t) => t instanceof CSSStyleSheet ? t : t.styleSheet);
  else
    for (const t of i) {
      const e = document.createElement("style"), r = global.litNonce;
      r !== void 0 && e.setAttribute("nonce", r), e.textContent = t.cssText, (document.head || document.documentElement).appendChild(e);
    }
}, "adoptGlobalStyles"), Yt = B`@property --wy-color-scheme{syntax:\"normal | light | dark\";inherits:true;initial-value:normal}:is(.wy-light,[part~=wy-light]) :where(wy-chat),:is(.wy-light,[part~=wy-light]) :where(wy-comments),:is(.wy-light,[part~=wy-light]) :where(wy-component),:is(.wy-light,[part~=wy-light]) :where(wy-copilot),:is(.wy-light,[part~=wy-light]) :where(wy-files),:is(.wy-light,[part~=wy-light]) :where(wy-messenger),:is(.wy-light,[part~=wy-light]) :where(wy-notification-toasts),:is(.wy-light,[part~=wy-light]) :where(wy-notifications),:is(.wy-light,[part~=wy-light]) :where(wy-posts),:host(:is(.wy-light,[part~=wy-light])),:host :is(.wy-light,[part~=wy-light]),::slotted(:is(.wy-light,[part~=wy-light])){color-scheme:light;--wy-primary:var(--wy-primary-light, #2f628c);--wy-on-primary:var(--wy-on-primary-light, #ffffff);--wy-primary-container:var(--wy-primary-container-light, #cee5ff);--wy-on-primary-container:var(--wy-on-primary-container-light, #0d4a73);--wy-secondary:var(--wy-secondary-light, #51606f);--wy-on-secondary:var(--wy-on-secondary-light, #ffffff);--wy-secondary-container:var(--wy-secondary-container-light, #d5e4f7);--wy-on-secondary-container:var(--wy-on-secondary-container-light, #3a4857);--wy-tertiary:var(--wy-tertiary-light, #645f41);--wy-on-tertiary:var(--wy-on-tertiary-light, #ffffff);--wy-tertiary-container:var(--wy-tertiary-container-light, #ebe3bd);--wy-on-tertiary-container:var(--wy-on-tertiary-container-light, #4c472b);--wy-error:var(--wy-error-light, #ba1821);--wy-on-error:var(--wy-on-error-light, #ffffff);--wy-error-container:var(--wy-error-container-light, #ffdad6);--wy-on-error-container:var(--wy-on-error-container-light, #930012);--wy-background:var(--wy-background-light, #f7f9ff);--wy-on-background:var(--wy-on-background-light, #181c20);--wy-surface:var(--wy-surface-light, #f7f9ff);--wy-on-surface:var(--wy-on-surface-light, #181c20);--wy-surface-variant:var(--wy-surface-variant-light, #dee3eb);--wy-on-surface-variant:var(--wy-on-surface-variant-light, #42474e);--wy-outline:var(--wy-outline-light, #72777f);--wy-outline-variant:var(--wy-outline-variant-light, #c2c7cf);--wy-surface-container-highest:var(--wy-surface-container-highest-light, #e0e2e8);--wy-surface-container-high:var(--wy-surface-container-high-light, #e6e8ee);--wy-surface-container:var(--wy-surface-container-light, #eceef3);--wy-surface-container-low:var(--wy-surface-container-low-light, #f1f3f9);--wy-surface-container-lowest:var(--wy-surface-container-lowest-light, #ffffff);--wy-surface-layer-highest:var(--wy-surface-layer-highest-light, rgba(0, 0, 0, .1019607843));--wy-surface-layer-high:var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039));--wy-surface-layer:var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922));--wy-surface-layer-low:var(--wy-surface-layer-low-light, rgba(255, 255, 255, .5019607843));--wy-surface-layer-lowest:var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078));--wy-warning:var(--wy-warning-light, #adb140);--wy-on-warning:var(--wy-on-warning-light, #000000);--wy-warning-container:var(--wy-warning-container-light, #e5e972);--wy-on-warning-container:var(--wy-on-warning-container-light, #1c1d00);--wy-highlight:var(--wy-highlight-light, #e8f2ff);--wy-on-highlight:var(--wy-on-highlight-light, #001d32);--wy-link:var(--wy-primary-light, #2f628c);--wy-presence-active:var(--wy-green-light, #00a38d);--wy-shade:var(--wy-shade-light, rgba(0, 0, 0, .3));--wy-shade-invert:var(--wy-shade-invert-light, rgba(255, 255, 255, .15));--wy-shade-opaque:var(--wy-shade-opaque-light, white);--wy-blue:var(--wy-blue-light, #8aa9fc);--wy-indigo:var(--wy-indigo-light, #9285de);--wy-purple:var(--wy-purple-light, #c675b6);--wy-pink:var(--wy-pink-light, #d57193);--wy-red:var(--wy-red-light, #db726b);--wy-orange:var(--wy-orange-light, #e79b3a);--wy-yellow:var(--wy-yellow-light, #adb140);--wy-green:var(--wy-green-light, #00a38d);--wy-teal:var(--wy-teal-light, #00a0a9);--wy-cyan:var(--wy-cyan-light, #0081a2);--wy-gray:var(--wy-gray-light, #76777a);--wy-code-text:var(--wy-code-text-light, #3b3b3b);--wy-code-variable:var(--wy-code-variable-light, #001080);--wy-code-operator:var(--wy-code-operator-light, #000000);--wy-code-prolog:var(--wy-code-prolog-light, #000080);--wy-code-comment:var(--wy-code-comment-light, #008000);--wy-code-builtin:var(--wy-code-builtin-light, #0070C1);--wy-code-number:var(--wy-code-number-light, #098658);--wy-code-inserted:var(--wy-code-inserted-light, #098658);--wy-code-constant:var(--wy-code-constant-light, #811F3F);--wy-code-hexcode:var(--wy-code-hexcode-light, #811F3F);--wy-code-regex:var(--wy-code-regex-light, #811F3F);--wy-code-char:var(--wy-code-char-light, #811F3F);--wy-code-tag:var(--wy-code-tag-light, #800000);--wy-code-attr-name:var(--wy-code-attr-name-light, #E50000);--wy-code-selector:var(--wy-code-selector-light, #E50000);--wy-code-property:var(--wy-code-property-light, #E50000);--wy-code-deleted:var(--wy-code-deleted-light, #A31515);--wy-code-string:var(--wy-code-string-light, #A31515);--wy-code-changed:var(--wy-code-changed-light, #0451A5);--wy-code-punctuation:var(--wy-code-punctuation-light, #000000);--wy-code-function:var(--wy-code-function-light, #0000FF);--wy-code-keyword:var(--wy-code-keyword-light, #AF00DB);--wy-code-class-name:var(--wy-code-class-name-light, #267F99)}:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-chat),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-comments),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-component),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-copilot),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-files),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-messenger),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-notification-toasts),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-notifications),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-posts),:host(:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light])),:host :is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]),::slotted(:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light])){color-scheme:dark;--wy-primary:var(--wy-primary-dark, #9bcbfa);--wy-on-primary:var(--wy-on-primary-dark, #003353);--wy-primary-container:var(--wy-primary-container-dark, #0d4a73);--wy-on-primary-container:var(--wy-on-primary-container-dark, #cee5ff);--wy-secondary:var(--wy-secondary-dark, #b9c8da);--wy-on-secondary:var(--wy-on-secondary-dark, #233240);--wy-secondary-container:var(--wy-secondary-container-dark, #3a4857);--wy-on-secondary-container:var(--wy-on-secondary-container-dark, #d5e4f7);--wy-tertiary:var(--wy-tertiary-dark, #cfc7a2);--wy-on-tertiary:var(--wy-on-tertiary-dark, #353117);--wy-tertiary-container:var(--wy-tertiary-container-dark, #4c472b);--wy-on-tertiary-container:var(--wy-on-tertiary-container-dark, #ebe3bd);--wy-error:var(--wy-error-dark, #ffb3ad);--wy-on-error:var(--wy-on-error-dark, #680009);--wy-error-container:var(--wy-error-container-dark, #930012);--wy-on-error-container:var(--wy-on-error-container-dark, #ffdad6);--wy-background:var(--wy-background-dark, #101418);--wy-on-background:var(--wy-on-background-dark, #e0e2e8);--wy-surface:var(--wy-surface-dark, #101418);--wy-on-surface:var(--wy-on-surface-dark, #e0e2e8);--wy-surface-variant:var(--wy-surface-variant-dark, #42474e);--wy-on-surface-variant:var(--wy-on-surface-variant-dark, #c2c7cf);--wy-outline:var(--wy-outline-dark, #8c9198);--wy-outline-variant:var(--wy-outline-variant-dark, #42474e);--wy-surface-container-highest:var(--wy-surface-container-highest-dark, #323539);--wy-surface-container-high:var(--wy-surface-container-high-dark, #272a2f);--wy-surface-container:var(--wy-surface-container-dark, #1c2024);--wy-surface-container-low:var(--wy-surface-container-low-dark, #181c20);--wy-surface-container-lowest:var(--wy-surface-container-lowest-dark, #0b0f12);--wy-surface-layer-highest:var(--wy-surface-layer-highest-dark, rgba(255, 255, 255, .1490196078));--wy-surface-layer-high:var(--wy-surface-layer-high-dark, rgba(255, 255, 255, .1019607843));--wy-surface-layer:var(--wy-surface-layer-dark, rgba(255, 255, 255, .0509803922));--wy-surface-layer-low:var(--wy-surface-layer-low-dark, rgba(0, 0, 0, .2509803922));--wy-surface-layer-lowest:var(--wy-surface-layer-lowest-dark, rgba(0, 0, 0, .5019607843));--wy-warning:var(--wy-warning-dark, #e5e972);--wy-on-warning:var(--wy-on-warning-dark, #484a00);--wy-warning-container:var(--wy-warning-container-dark, #787c07);--wy-on-warning-container:var(--wy-on-warning-container-dark, #f4f87e);--wy-highlight:var(--wy-highlight-dark, #003353);--wy-on-highlight:var(--wy-on-highlight-dark, #cee5ff);--wy-link:var(--wy-primary-dark, #9bcbfa);--wy-presence-active:var(--wy-green-dark, #00a38d);--wy-shade:var(--wy-shade-dark, rgba(0, 0, 0, .5));--wy-shade-invert:var(--wy-shade-invert-dark, rgba(255, 255, 255, .25));--wy-shade-opaque:var(--wy-shade-opaque-dark, grey);--wy-blue:var(--wy-blue-dark, #b2c5ff);--wy-indigo:var(--wy-indigo-dark, #9285de);--wy-purple:var(--wy-purple-dark, #e48fd2);--wy-pink:var(--wy-pink-dark, #f58bad);--wy-red:var(--wy-red-dark, #db726b);--wy-orange:var(--wy-orange-dark, #e79b3a);--wy-yellow:var(--wy-yellow-dark, #c9cd59);--wy-green:var(--wy-green-dark, #00a38d);--wy-teal:var(--wy-teal-dark, #00a0a9);--wy-cyan:var(--wy-cyan-dark, #009dc4);--wy-gray:var(--wy-gray-dark, #909194);--wy-code-text:var(--wy-code-text-dark, #cccccc);--wy-code-variable:var(--wy-code-variable-dark, #9CDCFE);--wy-code-operator:var(--wy-code-operator-dark, #d4d4d4);--wy-code-prolog:var(--wy-code-prolog-dark, #569CD6);--wy-code-comment:var(--wy-code-comment-dark, #6a9955);--wy-code-builtin:var(--wy-code-builtin-dark, #4fc1ff);--wy-code-number:var(--wy-code-number-dark, #b5cea8);--wy-code-inserted:var(--wy-code-inserted-dark, #b5cea8);--wy-code-constant:var(--wy-code-constant-dark, #646695);--wy-code-hexcode:var(--wy-code-hexcode-dark, #646695);--wy-code-regex:var(--wy-code-regex-dark, #d16969);--wy-code-char:var(--wy-code-char-dark, #d16969);--wy-code-tag:var(--wy-code-tag-dark, #569cd6);--wy-code-attr-name:var(--wy-code-attr-name-dark, #9cdcfe);--wy-code-selector:var(--wy-code-selector-dark, #9cdcfe);--wy-code-property:var(--wy-code-property-dark, #9cdcfe);--wy-code-deleted:var(--wy-code-deleted-dark, #ce9178);--wy-code-string:var(--wy-code-string-dark, #ce9178);--wy-code-changed:var(--wy-code-changed-dark, #569cd6);--wy-code-punctuation:var(--wy-code-punctuation-dark, #D4D4D4);--wy-code-function:var(--wy-code-function-dark, #569cd6);--wy-code-keyword:var(--wy-code-keyword-dark, #C586C0);--wy-code-class-name:var(--wy-code-class-name-dark, #4ec9b0)}@container style(--wy-color-scheme: dark){:not(.wy-light):not([part~=wy-light]) :where(wy-chat),:not(.wy-light):not([part~=wy-light]) :where(wy-comments),:not(.wy-light):not([part~=wy-light]) :where(wy-component),:not(.wy-light):not([part~=wy-light]) :where(wy-copilot),:not(.wy-light):not([part~=wy-light]) :where(wy-files),:not(.wy-light):not([part~=wy-light]) :where(wy-messenger),:not(.wy-light):not([part~=wy-light]) :where(wy-notification-toasts),:not(.wy-light):not([part~=wy-light]) :where(wy-notifications),:not(.wy-light):not([part~=wy-light]) :where(wy-posts),:host(:not(.wy-light):not([part~=wy-light])),:host :not(.wy-light):not([part~=wy-light]),::slotted(:not(.wy-light):not([part~=wy-light])){color-scheme:dark;--wy-primary:var(--wy-primary-dark, #9bcbfa);--wy-on-primary:var(--wy-on-primary-dark, #003353);--wy-primary-container:var(--wy-primary-container-dark, #0d4a73);--wy-on-primary-container:var(--wy-on-primary-container-dark, #cee5ff);--wy-secondary:var(--wy-secondary-dark, #b9c8da);--wy-on-secondary:var(--wy-on-secondary-dark, #233240);--wy-secondary-container:var(--wy-secondary-container-dark, #3a4857);--wy-on-secondary-container:var(--wy-on-secondary-container-dark, #d5e4f7);--wy-tertiary:var(--wy-tertiary-dark, #cfc7a2);--wy-on-tertiary:var(--wy-on-tertiary-dark, #353117);--wy-tertiary-container:var(--wy-tertiary-container-dark, #4c472b);--wy-on-tertiary-container:var(--wy-on-tertiary-container-dark, #ebe3bd);--wy-error:var(--wy-error-dark, #ffb3ad);--wy-on-error:var(--wy-on-error-dark, #680009);--wy-error-container:var(--wy-error-container-dark, #930012);--wy-on-error-container:var(--wy-on-error-container-dark, #ffdad6);--wy-background:var(--wy-background-dark, #101418);--wy-on-background:var(--wy-on-background-dark, #e0e2e8);--wy-surface:var(--wy-surface-dark, #101418);--wy-on-surface:var(--wy-on-surface-dark, #e0e2e8);--wy-surface-variant:var(--wy-surface-variant-dark, #42474e);--wy-on-surface-variant:var(--wy-on-surface-variant-dark, #c2c7cf);--wy-outline:var(--wy-outline-dark, #8c9198);--wy-outline-variant:var(--wy-outline-variant-dark, #42474e);--wy-surface-container-highest:var(--wy-surface-container-highest-dark, #323539);--wy-surface-container-high:var(--wy-surface-container-high-dark, #272a2f);--wy-surface-container:var(--wy-surface-container-dark, #1c2024);--wy-surface-container-low:var(--wy-surface-container-low-dark, #181c20);--wy-surface-container-lowest:var(--wy-surface-container-lowest-dark, #0b0f12);--wy-surface-layer-highest:var(--wy-surface-layer-highest-dark, rgba(255, 255, 255, .1490196078));--wy-surface-layer-high:var(--wy-surface-layer-high-dark, rgba(255, 255, 255, .1019607843));--wy-surface-layer:var(--wy-surface-layer-dark, rgba(255, 255, 255, .0509803922));--wy-surface-layer-low:var(--wy-surface-layer-low-dark, rgba(0, 0, 0, .2509803922));--wy-surface-layer-lowest:var(--wy-surface-layer-lowest-dark, rgba(0, 0, 0, .5019607843));--wy-warning:var(--wy-warning-dark, #e5e972);--wy-on-warning:var(--wy-on-warning-dark, #484a00);--wy-warning-container:var(--wy-warning-container-dark, #787c07);--wy-on-warning-container:var(--wy-on-warning-container-dark, #f4f87e);--wy-highlight:var(--wy-highlight-dark, #003353);--wy-on-highlight:var(--wy-on-highlight-dark, #cee5ff);--wy-link:var(--wy-primary-dark, #9bcbfa);--wy-presence-active:var(--wy-green-dark, #00a38d);--wy-shade:var(--wy-shade-dark, rgba(0, 0, 0, .5));--wy-shade-invert:var(--wy-shade-invert-dark, rgba(255, 255, 255, .25));--wy-shade-opaque:var(--wy-shade-opaque-dark, grey);--wy-blue:var(--wy-blue-dark, #b2c5ff);--wy-indigo:var(--wy-indigo-dark, #9285de);--wy-purple:var(--wy-purple-dark, #e48fd2);--wy-pink:var(--wy-pink-dark, #f58bad);--wy-red:var(--wy-red-dark, #db726b);--wy-orange:var(--wy-orange-dark, #e79b3a);--wy-yellow:var(--wy-yellow-dark, #c9cd59);--wy-green:var(--wy-green-dark, #00a38d);--wy-teal:var(--wy-teal-dark, #00a0a9);--wy-cyan:var(--wy-cyan-dark, #009dc4);--wy-gray:var(--wy-gray-dark, #909194);--wy-code-text:var(--wy-code-text-dark, #cccccc);--wy-code-variable:var(--wy-code-variable-dark, #9CDCFE);--wy-code-operator:var(--wy-code-operator-dark, #d4d4d4);--wy-code-prolog:var(--wy-code-prolog-dark, #569CD6);--wy-code-comment:var(--wy-code-comment-dark, #6a9955);--wy-code-builtin:var(--wy-code-builtin-dark, #4fc1ff);--wy-code-number:var(--wy-code-number-dark, #b5cea8);--wy-code-inserted:var(--wy-code-inserted-dark, #b5cea8);--wy-code-constant:var(--wy-code-constant-dark, #646695);--wy-code-hexcode:var(--wy-code-hexcode-dark, #646695);--wy-code-regex:var(--wy-code-regex-dark, #d16969);--wy-code-char:var(--wy-code-char-dark, #d16969);--wy-code-tag:var(--wy-code-tag-dark, #569cd6);--wy-code-attr-name:var(--wy-code-attr-name-dark, #9cdcfe);--wy-code-selector:var(--wy-code-selector-dark, #9cdcfe);--wy-code-property:var(--wy-code-property-dark, #9cdcfe);--wy-code-deleted:var(--wy-code-deleted-dark, #ce9178);--wy-code-string:var(--wy-code-string-dark, #ce9178);--wy-code-changed:var(--wy-code-changed-dark, #569cd6);--wy-code-punctuation:var(--wy-code-punctuation-dark, #D4D4D4);--wy-code-function:var(--wy-code-function-dark, #569cd6);--wy-code-keyword:var(--wy-code-keyword-dark, #C586C0);--wy-code-class-name:var(--wy-code-class-name-dark, #4ec9b0)}}`, Ig = B`@property --wy-component-color{syntax:\"<color>\";inherits:true;initial-value:currentColor}@property --wy-component-background-color{syntax:\"<color>\";inherits:true;initial-value:rgba(0,0,0,0)}`, Tg = /* @__PURE__ */ a((i) => {
  var t;
  return t = class extends i {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), Og([Ig, Yt]);
    }
  }, a(t, "WeavyStyles"), t;
}, "WeavyStylesMixin"), Fg = /* @__PURE__ */ a((i) => {
  var t;
  return t = class extends i {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), this.version = te.version, this.whenUrl().then(() => {
        this.isDestroyed || this.checkVersion();
      });
    }
    /**
     * Checks the version of the Weavy Context against the Weavy Environment version.
     *
     * @param {string} [version] - Optional version to check against the environment version.
     */
    async checkVersion(r = this.version) {
      await this.whenUrl(), this.networkStateIsPending = !0;
      let s;
      try {
        if (s = await fetch(new URL("/version", this.url), await this.fetchOptions({}, !1)), !s.ok)
          throw new Error("Could not verify environment version.");
        this.networkStateIsPending = !1, this.serverState = "ok";
      } catch (o) {
        this.networkStateIsPending = !1, this.serverState = "unreachable", console.warn("Could not check version: " + o.toString());
        return;
      }
      const n = await s.text();
      if (n.startsWith("v") && (!r || !n || r !== n))
        try {
          const o = r.split(".").slice(0, 2), c = n.split(".").slice(0, 2);
          if (o[0] !== c[0])
            throw new Error();
          o[1] !== c[1] && console.error(
            `Version inconsistency: ${te.sourceName}@${this.version} ≠ ${this.url?.hostname}@${n} - This may cause unexpected errors!`
          );
        } catch {
          throw new Error(
            `Version mismatch! ${te.sourceName}@${this.version} ≠ ${this.url?.hostname}@${n} - This will likely cause errors!`
          );
        }
    }
  }, a(t, "WeavyVersion"), t;
}, "WeavyVersionMixin");
var Nn;
let am = (Nn = class extends Event {
  constructor(t, e, r, s) {
    super("context-request", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e, this.callback = r, this.subscribe = s ?? !1;
  }
}, a(Nn, "s"), Nn);
var jn;
let Je = (jn = class {
  constructor(t, e, r, s) {
    if (this.subscribe = !1, this.provided = !1, this.value = void 0, this.t = (n, o) => {
      this.unsubscribe && (this.unsubscribe !== o && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = n, this.host.requestUpdate(), this.provided && !this.subscribe || (this.provided = !0, this.callback && this.callback(n, o)), this.unsubscribe = o;
    }, this.host = t, e.context !== void 0) {
      const n = e;
      this.context = n.context, this.callback = n.callback, this.subscribe = n.subscribe ?? !1;
    } else this.context = e, this.callback = r, this.subscribe = s ?? !1;
    this.host.addController(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.host.dispatchEvent(new am(this.context, this.host, this.t, this.subscribe));
  }
}, a(jn, "s"), jn);
var Wn;
let Dg = (Wn = class {
  get value() {
    return this.o;
  }
  set value(t) {
    this.setValue(t);
  }
  setValue(t, e = !1) {
    const r = e || !Object.is(t, this.o);
    this.o = t, r && this.updateObservers();
  }
  constructor(t) {
    this.subscriptions = /* @__PURE__ */ new Map(), this.updateObservers = () => {
      for (const [e, { disposer: r }] of this.subscriptions) e(this.o, r);
    }, t !== void 0 && (this.value = t);
  }
  addCallback(t, e, r) {
    if (!r) return void t(this.value);
    this.subscriptions.has(t) || this.subscriptions.set(t, { disposer: /* @__PURE__ */ a(() => {
      this.subscriptions.delete(t);
    }, "disposer"), consumerHost: e });
    const { disposer: s } = this.subscriptions.get(t);
    t(this.value, s);
  }
  clearCallbacks() {
    this.subscriptions.clear();
  }
}, a(Wn, "s"), Wn);
var Qn;
let Hg = (Qn = class extends Event {
  constructor(t, e) {
    super("context-provider", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e;
  }
}, a(Qn, "e"), Qn);
var Kn;
let hu = (Kn = class extends Dg {
  constructor(t, e, r) {
    super(e.context !== void 0 ? e.initialValue : r), this.onContextRequest = (s) => {
      if (s.context !== this.context) return;
      const n = s.contextTarget ?? s.composedPath()[0];
      n !== this.host && (s.stopPropagation(), this.addCallback(s.callback, n, s.subscribe));
    }, this.onProviderRequest = (s) => {
      if (s.context !== this.context || (s.contextTarget ?? s.composedPath()[0]) === this.host) return;
      const n = /* @__PURE__ */ new Set();
      for (const [o, { consumerHost: c }] of this.subscriptions) n.has(o) || (n.add(o), c.dispatchEvent(new am(this.context, c, o, !0)));
      s.stopPropagation();
    }, this.host = t, e.context !== void 0 ? this.context = e.context : this.context = e, this.attachListeners(), this.host.addController?.(this);
  }
  attachListeners() {
    this.host.addEventListener("context-request", this.onContextRequest), this.host.addEventListener("context-provider", this.onProviderRequest);
  }
  hostConnected() {
    this.host.dispatchEvent(new Hg(this.context, this.host));
  }
}, a(Kn, "i"), Kn);
function Vr({ context: i }) {
  return (t, e) => {
    const r = /* @__PURE__ */ new WeakMap();
    if (typeof e == "object") return { get() {
      return t.get.call(this);
    }, set(s) {
      return r.get(this).setValue(s), t.set.call(this, s);
    }, init(s) {
      return r.set(this, new hu(this, { context: i, initialValue: s })), s;
    } };
    {
      t.constructor.addInitializer(((o) => {
        r.set(o, new hu(o, { context: i }));
      }));
      const s = Object.getOwnPropertyDescriptor(t, e);
      let n;
      if (s === void 0) {
        const o = /* @__PURE__ */ new WeakMap();
        n = { get() {
          return o.get(this);
        }, set(c) {
          r.get(this).setValue(c), o.set(this, c);
        }, configurable: !0, enumerable: !0 };
      } else {
        const o = s.set;
        n = { ...s, set(c) {
          r.get(this).setValue(c), o?.call(this, c);
        } };
      }
      return void Object.defineProperty(t, e, n);
    }
  };
}
a(Vr, "e$4");
function he({ context: i, subscribe: t }) {
  return (e, r) => {
    typeof r == "object" ? r.addInitializer((function() {
      new Je(this, { context: i, callback: /* @__PURE__ */ a((s) => {
        e.set.call(this, s);
      }, "callback"), subscribe: t });
    })) : e.constructor.addInitializer(((s) => {
      new Je(s, { context: i, callback: /* @__PURE__ */ a((n) => {
        s[r] = n;
      }, "callback"), subscribe: t });
    }));
  };
}
a(he, "c$2");
const Fy = class Fy extends Event {
  /**
   *
   * @param context the context key to request
   * @param contextTarget the original context target of the requester
   * @param callback the callback that should be invoked when the context with the specified key is available
   * @param subscribe when, true indicates we want to subscribe to future updates
   */
  constructor(t, e, r, s) {
    super("context-request", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e, this.callback = r, this.subscribe = s ?? !1;
  }
};
a(Fy, "ContextRequestEvent");
let pu = Fy;
const Dy = class Dy extends Event {
  /**
   *
   * @param context the context which this provider can provide
   * @param contextTarget the original context target of the provider
   */
  constructor(t, e) {
    super("context-provider", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e;
  }
};
a(Dy, "ContextProviderEvent");
let uu = Dy;
const Hy = class Hy extends hu {
  constructor(t, e, r) {
    e.context !== void 0 ? super(t, e) : super(t, e, r), e.context !== void 0 ? this._context = e.context : this._context = e, this.isAttached = !0, this.host instanceof X || this.dispatchWhenConnected();
  }
  dispatchWhenConnected() {
    this.isAttached && (this.host.isConnected ? this.host.dispatchEvent(new uu(this._context, this.host)) : requestAnimationFrame(() => this.dispatchWhenConnected()));
  }
  detachListeners() {
    this.isAttached = !1, this.host.removeEventListener("context-request", this.onContextRequest), this.host.removeEventListener("context-provider", this.onProviderRequest);
  }
};
a(Hy, "WyContextProvider");
let qd = Hy;
const re = Symbol.for("weavy-client");
function Vg(i, t) {
  return we(), new qd(i, { context: re, initialValue: t });
}
a(Vg, "createWeavyContextProvider");
const tl = Vu() ? Vg(document.documentElement) : void 0, Ug = /* @__PURE__ */ a((i) => {
  var t, e;
  return e = class extends i {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...n) {
      super(...n);
      // CONTEXT PROVIDER
      // SHOULD BE APPLIED LAST TO ENSURE EVERYTHING IS SET BEFORE CONTEXT GETS PROVIDED
      O(this, t);
      this.host !== document.documentElement ? (tl?.detachListeners(), P(this, t, new qd(this.host, {
        context: re,
        initialValue: this
      }))) : tl?.setValue(this);
    }
    updateContext() {
      this.host !== document.documentElement ? y(this, t)?.updateObservers() : tl?.updateObservers();
    }
    destroy() {
      super.destroy(), this.host !== document.documentElement ? y(this, t)?.detachListeners() : tl?.value === this && tl?.setValue(void 0);
    }
  }, t = new WeakMap(), a(e, "WeavyContextProvider"), e;
}, "WeavyContextProviderMixin");
var Ul, Bl, Ui, Gn;
const oe = class oe {
  // CONSTRUCTOR
  constructor(t) {
    // Promises
    // whenUrl
    O(this, Ul);
    O(this, Bl);
    // Reactive options
    O(this, Ui);
    O(this, Gn);
    this.weavySid = ol(), this.weavyId = `${oe.sourceName}#${this.weavySid}`, this.cloudFilePickerUrl = oe.defaults.cloudFilePickerUrl, this.configurationTimeout = oe.defaults.configurationTimeout, this.disableEnvironmentImports = oe.defaults.disableEnvironmentImports, this.gcTime = oe.defaults.gcTime, this.scrollBehavior = oe.defaults.scrollBehavior, this.staleTime = oe.defaults.staleTime, this.tokenFactoryRetryDelay = oe.defaults.tokenFactoryRetryDelay, this.tokenFactoryTimeout = oe.defaults.tokenFactoryTimeout, P(this, Bl, new Promise((r) => {
      P(this, Ul, r);
    })), P(this, Gn, !1), console.info(`${oe.sourceName}@${oe.version} #${this.weavySid}`), we(), this.host = document.documentElement;
    const e = {};
    for (const r in t) {
      const s = r;
      t[s] !== void 0 && Object.assign(e, { [s]: t[s] });
    }
    e?.host && (this.host = e.host, delete e.host), e && Object.assign(this, e);
  }
  async whenUrl() {
    await y(this, Bl);
  }
  /**
   * The URL to the weavy environment.
   */
  get url() {
    return y(this, Ui);
  }
  set url(t) {
    var e;
    if (this.isDestroyed)
      throw new Tt();
    try {
      if (typeof t == "string")
        t && P(this, Ui, new URL(t, window.location.toString()));
      else if (t instanceof URL)
        P(this, Ui, t || void 0);
      else if (t == null)
        P(this, Ui, void 0);
      else
        throw new Error();
    } catch {
      throw new TypeError("Invalid url");
    }
    t && !this.disableEnvironmentImports && globalThis.WEAVY_IMPORT_URL === void 0 && (globalThis.WEAVY_IMPORT_URL = new URL(
      "./uikit-web/",
      t
    ).href), y(this, Ui) && ((e = y(this, Ul)) == null || e.call(this, y(this, Ui)));
  }
  /**
   * Prefix to use for caches.
   */
  get cachePrefix() {
    return `${oe.version}:${this.url}`;
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async reset() {
    console.info(this.weavyId, "is reset");
  }
  get isDestroyed() {
    return y(this, Gn);
  }
  destroy() {
    P(this, Gn, !0), console.info(this.weavyId, "was destroyed");
  }
};
Ul = new WeakMap(), Bl = new WeakMap(), Ui = new WeakMap(), Gn = new WeakMap(), a(oe, "WeavyClient"), oe.version = "30.1.1", oe.sourceName = "@weavy/uikit-web", oe.defaults = {
  // StrictWeavyOptions
  cloudFilePickerUrl: "https://filebrowser.weavy.io/v14/",
  configurationTimeout: 5e3,
  disableEnvironmentImports: !1,
  gcTime: 1e3 * 60 * 60 * 24,
  // 24h,
  locale: Nf,
  scrollBehavior: "auto",
  staleTime: 1e3 * 1,
  // 1s
  tokenFactoryRetryDelay: 2e3,
  tokenFactoryTimeout: 2e4,
  // WeavyComponentSettingProps
  annotations: "buttons-inline",
  enterToSend: "auto",
  reactions: "😍 😎 😉 😜 👍"
};
let te = oe;
const Vy = class Vy extends Ug(
  S1(
    P1(
      A1(
        C1(
          ug(Fg(M1(Tg(yg(te)))))
        )
      )
    )
  )
) {
};
a(Vy, "Weavy");
let Bt = Vy;
const Qu = Symbol.for("weavy-app"), om = Symbol.for("weavy-context-id"), cm = Symbol.for("weavy-data-blobs");
var M = /* @__PURE__ */ ((i) => (i.Attachments = "attachments", i.CloudFiles = "cloud_files", i.ContextData = "context_data", i.Comments = "comments", i.Embeds = "embeds", i.GoogleMeet = "google_meet", i.Meetings = "meetings", i.Mentions = "mentions", i.MicrosoftTeams = "microsoft_teams", i.Polls = "polls", i.Previews = "previews", i.Reactions = "reactions", i.Receipts = "receipts", i.Thumbnails = "thumbnails", i.Typing = "typing", i.Versions = "versions", i.WebDAV = "web_dav", i.ZoomMeetings = "zoom_meetings", i))(M || {});
const ph = Symbol.for("weavy-features");
var xr, os, gi;
const lh = class lh {
  /**
   * Creates a feature policy. All features are initially enabled unless `defaultFeatures` is specified.
   *
   * @constructor
   * @param componentFeatures - Available features.
   */
  constructor(t, e) {
    O(this, xr);
    O(this, os);
    O(this, gi);
    P(this, xr, Object.keys(t)), P(this, os, Object.entries(t).reduce(
      (r, [s, n]) => (n && r.push(s), r),
      []
    )), P(this, gi, e ?? y(this, os));
  }
  features() {
    return y(this, xr);
  }
  supportedFeature(...t) {
    return t.every((e) => y(this, xr).includes(e));
  }
  allowedFeatures() {
    return y(this, gi);
  }
  allowsFeature(...t) {
    return t.every((e) => this.supportedFeature(e) ? y(this, gi).includes(e) : !1);
  }
  allowsAnyFeature(...t) {
    return t.some((e) => this.supportedFeature(e) ? y(this, gi).includes(e) : !1);
  }
  /**
   * Sets the allowed features.
   * @param allowedFeatures - Space separated string with features that will be enabled. Empty string will disable all features. `null` or `undefined` will enable all features.
   */
  setAllowedFeatures(t) {
    return P(this, gi, typeof t == "string" ? lm(t, y(this, xr)) : y(this, os)), y(this, gi);
  }
  immutable() {
    const t = Ku(y(this, xr), y(this, os));
    return new lh(t, y(this, gi));
  }
};
xr = new WeakMap(), os = new WeakMap(), gi = new WeakMap(), a(lh, "ComponentFeatures");
let ee = lh;
function lm(i, t) {
  return i.split(" ").filter((e) => {
    if (e) {
      if (t.includes(e))
        return !0;
      console.warn("Unknown feature provided:", e);
    }
    return !1;
  });
}
a(lm, "featureListFromString");
function Ku(i, t) {
  return t ??= i, Object.fromEntries(
    i.map((e) => [e, t.includes(e)])
  );
}
a(Ku, "featureConfigFromList");
const yu = Object.values(M), dm = Symbol.for("weavy-link");
var ql;
const Uy = class Uy {
  // PROPERTY INIT
  constructor(t) {
    O(this, ql);
    this.enterToSend = te.defaults.enterToSend, this.reactions = te.defaults.reactions, this.annotations = te.defaults.annotations, P(this, ql, t), Object.keys(this).forEach((r) => {
      r in t && Object.assign(this, { [r]: t[r] });
    });
  }
  /**
   * Provides a reference to the host.
   */
  get component() {
    return y(this, ql);
  }
};
ql = new WeakMap(), a(Uy, "WeavyComponentSettings");
let Nd = Uy;
const hm = Symbol.for("weavy-component-settings"), uh = Symbol.for("weavy-user"), By = class By {
  constructor(t, e, r, s, n) {
    if (this.subscribe = !1, this.provided = !1, this.value = void 0, this._callback = (o, c) => {
      this.unsubscribe && (this.unsubscribe !== c && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = o, this.host.requestUpdate(), (!this.provided || this.subscribe) && (this.provided = !0, this.callback && this.callback(o, c)), this.unsubscribe = c;
    }, this.host = t, e.context !== void 0) {
      const o = e;
      this.context = o.context, this.callback = o.callback, this.subscribe = o.subscribe ?? !1, this.ref = o.ref ?? t;
    } else
      this.context = e, this.callback = r, this.subscribe = s ?? !1, this.ref = n ?? t;
    this.host.addController?.(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.ref.dispatchEvent(
      new pu(
        this.context,
        this.host,
        this._callback,
        this.subscribe
      )
    );
  }
};
a(By, "ContextConsumer");
let wu = By;
const qy = class qy {
  /**
   * @param host - The host element
   * @param context - The Context to use. Should be constructed using createContext().
   */
  constructor(t, e, r) {
    this.whenRef = new Promise((s) => this.resolveRef = s), t.addController(this), this.host = t, this.setRef(r), this.setContext(e);
  }
  /**
   * The DOM connected element that can subscribe to a context
   */
  get ref() {
    return this._ref;
  }
  set ref(t) {
    this._ref = t, t && this.resolveRef?.(t);
  }
  /** 
   * Set the DOM connected element that can subscribe to a context.
   * Wrapper function for React linting compatibility. 
   */
  setRef(t) {
    this.ref = t;
  }
  async setContext(t) {
    this.whenContext = new Promise((r) => this.resolveContext = r);
    const e = await this.whenRef;
    this.context = new wu(this.host, {
      context: t,
      subscribe: !0,
      callback: /* @__PURE__ */ a((r, s) => {
        this.resolveContext?.(r), this.host.requestUpdate();
      }, "callback"),
      ref: e
    }), await Ff(e), this.context.dispatchRequest();
  }
  hostUpdate() {
    this.context?.value && this.resolveContext?.(this.context.value);
  }
};
a(qy, "ContextController");
let Fw = qy;
var tt = /* @__PURE__ */ ((i) => (i.Chat = "d65dd4bc-418e-403c-9f56-f9cf4da931ed", i.Comments = "88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd", i.Files = "523edd88-4bbf-4547-b60f-2859a6d2ddc1", i.Posts = "5ebfa152-de85-48da-82dd-30a1b560c313", i.ChatRoom = "edb400ac-839b-45a7-b2a8-6a01820d1c44", i.PrivateChat = "7e14f418-8f15-46f4-b182-f619b671e470", i.AgentChat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", i))(tt || {}), ai = /* @__PURE__ */ ((i) => (i.Chat = "chat", i.Comments = "comments", i.Files = "files", i.Posts = "posts", i.ChatRoom = "chat_room", i.PrivateChat = "private_chat", i.AgentChat = "agent_chat", i))(ai || {}), pm = /* @__PURE__ */ ((i) => (i["d65dd4bc-418e-403c-9f56-f9cf4da931ed"] = "chat", i["88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd"] = "comments", i["523edd88-4bbf-4547-b60f-2859a6d2ddc1"] = "files", i["5ebfa152-de85-48da-82dd-30a1b560c313"] = "posts", i["edb400ac-839b-45a7-b2a8-6a01820d1c44"] = "chat_room", i["7e14f418-8f15-46f4-b182-f619b671e470"] = "private_chat", i["2352a1c6-abc6-420e-8b85-ca7d5aed8779"] = "agent_chat", i))(pm || {}), um = /* @__PURE__ */ ((i) => (i.chat = "d65dd4bc-418e-403c-9f56-f9cf4da931ed", i.comments = "88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd", i.files = "523edd88-4bbf-4547-b60f-2859a6d2ddc1", i.posts = "5ebfa152-de85-48da-82dd-30a1b560c313", i.chat_room = "edb400ac-839b-45a7-b2a8-6a01820d1c44", i.private_chat = "7e14f418-8f15-46f4-b182-f619b671e470", i.agent_chat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", i))(um || {}), ym = /* @__PURE__ */ ((i) => (i["2352a1c6-abc6-420e-8b85-ca7d5aed8779"] = "agent_chat", i))(ym || {}), wm = /* @__PURE__ */ ((i) => (i.agent_chat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", i))(wm || {}), dr = /* @__PURE__ */ ((i) => (i.None = "none", i.Read = "read", i.Write = "write", i.Admin = "admin", i))(dr || {}), ms = /* @__PURE__ */ ((i) => (i.List = "list", i.Read = "read", i.Create = "create", i.Update = "update", i.Delete = "delete", i.Admin = "admin", i))(ms || {}), ve = /* @__PURE__ */ ((i) => (i.App = "app", i.File = "file", i.Message = "message", i.User = "user", i.Comment = "comment", i.Post = "post", i))(ve || {});
function sd(i, t, e, r, s, n = "GET") {
  return {
    // eslint-disable-next-line @tanstack/query/exhaustive-deps
    queryKey: t,
    queryFn: /* @__PURE__ */ a(async () => {
      const o = await i.fetch(e || "/api/" + t.join("/"), { method: n, body: s });
      if (o.ok)
        return await o.json();
      throw new Error(`Error calling ${e || "/api/" + t.join("/")}`);
    }, "queryFn"),
    ...r
  };
}
a(sd, "getApiOptions");
const fm = /* @__PURE__ */ a((i) => (t, e) => {
  e !== void 0 ? e.addInitializer((() => {
    customElements.define(i, t);
  })) : customElements.define(i, t);
}, "t$3");
const Bg = { attribute: !0, type: String, converter: a1, reflect: !1, hasChanged: n1 }, qg = /* @__PURE__ */ a((i = Bg, t, e) => {
  const { kind: r, metadata: s } = e;
  let n = globalThis.litPropertyMetadata.get(s);
  if (n === void 0 && globalThis.litPropertyMetadata.set(s, n = /* @__PURE__ */ new Map()), r === "setter" && ((i = Object.create(i)).wrapped = !0), n.set(e.name, i), r === "accessor") {
    const { name: o } = e;
    return { set(c) {
      const l = t.get.call(this);
      t.set.call(this, c), this.requestUpdate(o, l, i);
    }, init(c) {
      return c !== void 0 && this.C(o, void 0, i, c), c;
    } };
  }
  if (r === "setter") {
    const { name: o } = e;
    return function(c) {
      const l = this[o];
      t.call(this, c), this.requestUpdate(o, l, i);
    };
  }
  throw Error("Unsupported decorator location: " + r);
}, "r$3");
function p(i) {
  return (t, e) => typeof e == "object" ? qg(i, t, e) : ((r, s, n) => {
    const o = s.hasOwnProperty(n);
    return s.constructor.createProperty(n, r), o ? Object.getOwnPropertyDescriptor(s, n) : void 0;
  })(i, t, e);
}
a(p, "n$3");
function F(i) {
  return p({ ...i, state: !0, attribute: !1 });
}
a(F, "r$2");
const Ng = /* @__PURE__ */ a((i, t, e) => (e.configurable = !0, e.enumerable = !0, Reflect.decorate && typeof t != "object" && Object.defineProperty(i, t, e), e), "e$3");
function Hc(i) {
  return (t, e) => {
    const { slot: r, selector: s } = i ?? {}, n = "slot" + (r ? `[name=${r}]` : ":not([name])");
    return Ng(t, e, { get() {
      const o = this.renderRoot?.querySelector(n), c = o?.assignedElements(i) ?? [];
      return s === void 0 ? c : c.filter(((l) => l.matches(s)));
    } });
  };
}
a(Hc, "o$6");
const Ny = class Ny {
  get result() {
    return this._result && this.observer ? this.observer.trackResult(this._result) : { isPending: !0 };
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenQueryClient = new Promise((e) => this.resolveQueryClient = e), this.setContext();
  }
  async setContext() {
    await ar(this.host), this.context = new Je(this.host, {
      context: re,
      subscribe: !0,
      callback: /* @__PURE__ */ a((t) => {
        t && (this.resolveContext?.(t), this.queryClient = t.queryClient, this.resolveQueryClient?.(t.queryClient));
      }, "callback")
    });
  }
  async trackQuery(t, e = !0) {
    this.observerUnsubscribe?.();
    const r = await this.whenQueryClient;
    if (!r)
      throw new Error("No QueryClient provided");
    const s = new Xf(r, t);
    this.observer = s, this.observerSubscribe(e);
  }
  observerSubscribe(t = !0) {
    if (this.queryClient && this.observer) {
      t ? this._result = this.observer.getOptimisticResult(this.observer.options) : this._result = this.observer.getCurrentResult(), this.observerUnsubscribe = this.observer.subscribe(() => {
        if (this.observer) {
          const r = rd(this.result, this.observer.getCurrentResult());
          r !== this._result && (this._result = r, this.host.requestUpdate());
        }
      }), this.observer.updateResult(), this.host.requestUpdate();
      let e;
      t ? e = this.observer.fetchOptimistic(this.observer.options) : e = this.queryClient.getQueryCache().get(this.observer.options.queryHash)?.promise, e?.catch(() => {
      }).finally(() => {
        this.observer?.updateResult();
      });
    }
  }
  untrackQuery() {
    this.observerUnsubscribe?.(), this.observerUnsubscribe = void 0, this._result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    this.observerUnsubscribe?.();
  }
};
a(Ny, "QueryController");
let Ie = Ny;
function fu(i) {
  return i.signal instanceof AbortSignal || typeof i.abort == "function";
}
a(fu, "hasAbort");
const jy = class jy {
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenObserver = new Promise((e) => this.resolveObserver = e), this.setContext();
  }
  async setContext() {
    await ar(this.host), this.context = new Je(this.host, { context: re, subscribe: !0 });
  }
  hostUpdate() {
    this.context?.value && this.resolveContext?.();
  }
  async trackMutation(t, e) {
    if (e || (await this.whenContext, e = this.context?.value?.queryClient), !e)
      throw new Error("No QueryClient provided");
    return this.observerUnsubscribe?.(), this.observer && (this.whenObserver = new Promise((r) => this.resolveObserver = r)), this.observer = new $t(e, { ...t }), this.observerSubscribe(), this.resolveObserver?.(this.observer), this.observer;
  }
  observerSubscribe() {
    this.observer && (this.result = this.observer.getCurrentResult(), this.observerUnsubscribe ??= this.observer.subscribe(() => {
      if (this.observer) {
        const t = rd(this.result, this.observer.getCurrentResult());
        this.result !== t && (this.result = t, this.host.requestUpdate());
      }
    }), this.host.requestUpdate());
  }
  untrackMutation() {
    this.observerUnsubscribe?.(), this.observerUnsubscribe = void 0, this.result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  async mutate(t, e) {
    const r = await this.whenObserver, s = new AbortController();
    return r.mutate(
      {
        ...t,
        signal: s.signal,
        abort: s.abort.bind(s)
      },
      e
    );
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    this.observerUnsubscribe?.();
  }
};
a(jy, "MutationController");
let We = jy;
function mm(i) {
  if (i)
    return i.match(/^[0-9]+$/) ? parseInt(i) : i;
}
a(mm, "toIntOrString");
const ue = [];
for (let i = 0; i < 256; ++i)
  ue.push((i + 256).toString(16).slice(1));
function jg(i, t = 0) {
  return (ue[i[t + 0]] + ue[i[t + 1]] + ue[i[t + 2]] + ue[i[t + 3]] + "-" + ue[i[t + 4]] + ue[i[t + 5]] + "-" + ue[i[t + 6]] + ue[i[t + 7]] + "-" + ue[i[t + 8]] + ue[i[t + 9]] + "-" + ue[i[t + 10]] + ue[i[t + 11]] + ue[i[t + 12]] + ue[i[t + 13]] + ue[i[t + 14]] + ue[i[t + 15]]).toLowerCase();
}
a(jg, "unsafeStringify");
let zp;
const Wg = new Uint8Array(16);
function Qg() {
  if (!zp) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    zp = crypto.getRandomValues.bind(crypto);
  }
  return zp(Wg);
}
a(Qg, "rng");
const Kg = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Dw = { randomUUID: Kg };
function Gg(i, t, e) {
  i = i || {};
  const r = i.random ?? i.rng?.() ?? Qg();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, jg(r);
}
a(Gg, "_v4");
function sl(i, t, e) {
  return Dw.randomUUID && !i ? Dw.randomUUID() : Gg(i);
}
a(sl, "v4");
function Zg(i) {
  let t;
  if (i instanceof URL)
    t = { type: "url", item: i };
  else if (i instanceof File)
    t = { type: "file", item: i };
  else if (i instanceof Blob)
    t = {
      type: "file",
      item: new File([i], `${sl()}`, { type: i.type })
    };
  else if (typeof i == "string")
    t = {
      type: "file",
      item: new File([i], `${sl()}.data.txt`, { type: "text/plain;charset=UTF-8" })
    };
  else if (d1(i) || qp(i))
    try {
      const e = qp(i) ? i.toJSON() : JSON.stringify(i, x1(), 2);
      t = {
        type: "file",
        item: new File([e], `${sl()}.json.txt`, { type: "text/plain;charset=UTF-8" })
      };
    } catch (e) {
      console.error("Could not serialize context data to JSON.", e);
    }
  return t;
}
a(Zg, "getContextDataRef");
const yh = /* @__PURE__ */ a((i, t = 3) => {
  const e = [" B", " KB", " MB", " GB", " TB", " PB", " EB", " ZB", " YB"];
  let r = i, s = 0;
  for (; s < e.length - 1 && r >= 1024; )
    r = 100 * r / 1024 / 100, s++;
  return r.toLocaleString(void 0, { maximumSignificantDigits: t }) + e[s];
}, "fileSizeAsString");
function ii(i) {
  return i.lastIndexOf(".") === -1 ? "." : (i.substring(i.lastIndexOf("."), i.length) || i).toLowerCase();
}
a(ii, "getExtension");
function vm(i) {
  switch (i) {
    case ".aac":
    case ".aif":
    case ".aiff":
    case ".au":
    case ".gsm":
    case ".m4a":
    case ".mid":
    case ".midi":
    case ".mka":
    case ".mp3":
    case ".oga":
    case ".ogg":
    case ".ra":
    case ".ram":
    case ".snd":
    case ".spx":
    case ".wav":
    case ".wma":
      return !0;
    default:
      return !1;
  }
}
a(vm, "isAudio");
function Yg(i) {
  switch (i) {
    case ".ai":
    case ".apng":
    case ".bmp":
    case ".emf":
    case ".eps":
    case ".gif":
    case ".heic":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".psd":
    case ".svg":
    case ".tif":
    case ".tiff":
    case ".webp":
    case ".wmf":
      return !0;
    default:
      return !1;
  }
}
a(Yg, "isImage");
function Xg(i) {
  switch (ii(i)) {
    case ".apng":
    case ".bmp":
    case ".gif":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".svg":
    case ".webp":
      return !0;
    default:
      return !1;
  }
}
a(Xg, "isWebImage");
function gm(i) {
  switch (i) {
    case ".3g2":
    case ".asx":
    case ".asf":
    case ".avi":
    case ".flv":
    case ".mk3d":
    case ".mkv":
    case ".mov":
    case ".mp4":
    case ".mpeg":
    case ".mpg":
    case ".ogm":
    case ".ogv":
    case ".ogx":
    case ".qt":
    case ".rm":
    case ".rv":
    case ".smi":
    case ".smil":
    case ".swf":
    case ".webm":
    case ".wmv":
    case ".xaml":
      return !0;
    default:
      return !1;
  }
}
a(gm, "isVideo");
function Jg(i) {
  switch (i) {
    case ".markdown":
    case ".md":
      return !0;
    default:
      return !1;
  }
}
a(Jg, "isMarkdown");
function bm(i) {
  switch (i) {
    case ".htm":
    case ".html":
    case ".xhtml":
    case ".xml":
      return !0;
    default:
      return !1;
  }
}
a(bm, "isMarkup");
function Gu(i) {
  if (bm(i))
    return !0;
  switch (i) {
    case ".as":
    case ".as3":
    case ".asm":
    case ".aspx":
    case ".bat":
    case ".c":
    case ".cc":
    case ".cmake":
    case ".coffee":
    case ".cpp":
    case ".cs":
    case ".css":
    case ".cxx":
    case ".diff":
    case ".erb":
    case ".erl":
    case ".groovy":
    case ".gvy":
    case ".h":
    case ".haml":
    case ".hh":
    case ".hpp":
    case ".hxx":
    case ".java":
    case ".js":
    case ".json":
    case ".jsx":
    case ".less":
    case ".lst":
    case ".m":
    case ".make":
    case ".ml":
    case ".mm":
    case ".out":
    case ".patch":
    case ".php":
    case ".pl":
    case ".plist":
    case ".properties":
    case ".py":
    case ".rb":
    case ".sass":
    case ".scala":
    case ".scm":
    case ".script":
    case ".scss":
    case ".sh":
    case ".sml":
    case ".sql":
    case ".vb":
    case ".vi":
    case ".vim":
    case ".xsd":
    case ".xsl":
    case ".yaml":
    case ".yml":
      return !0;
    default:
      return !1;
  }
}
a(Gu, "isCode");
function xm(i) {
  if (Gu(i) || Jg(i))
    return !0;
  switch (i) {
    case ".txt":
      return !0;
    default:
      return !1;
  }
}
a(xm, "isText");
function Ur(i) {
  const t = ii(i);
  if (t === "") return { icon: "file" };
  if (vm(t))
    return { icon: "file-music", color: "indigo" };
  if (Yg(t))
    return { icon: "file-image", color: "cyan" };
  if (gm(t))
    return { icon: "file-video", color: "pink" };
  if (bm(t))
    return { icon: "file-xml", color: "purple" };
  if (Gu(t))
    return { icon: "file-code", color: "purple" };
  if (xm(t))
    return { icon: "file-document" };
  switch (t) {
    case ".7z":
    case ".zip":
      return { icon: "file-compressed", color: "orange" };
    case ".doc":
    case ".docm":
    case ".docx":
    case ".dotm":
    case ".dotx":
      return { icon: "file-word", color: "native" };
    case ".eml":
    case ".msg":
      return { icon: "email", color: "" };
    case ".xls":
    case ".xlsm":
    case ".xlsx":
    case ".xltx":
      return { icon: "file-excel", color: "native" };
    case ".pdf":
      return { icon: "file-pdf", color: "native" };
    case ".ppt":
    case ".pptm":
    case ".pptx":
    case ".potx":
      return { icon: "file-powerpoint", color: "native" };
    case ".pages":
      return { icon: "file", color: "orange" };
    case ".numbers":
      return { icon: "file", color: "green" };
    case ".keynote":
      return { icon: "file", color: "blue" };
  }
  return { icon: "file" };
}
a(Ur, "getIcon");
function t0(i) {
  const t = ii(i);
  return t === "" ? "none" : Xg(t) ? "image" : Gu(t) ? "code" : xm(t) ? "text" : vm(t) ? "audio" : gm(t) ? "video" : "none";
}
a(t0, "getWebPreviewFormat");
function nd(i) {
  switch (i) {
    case "Google Drive":
      return "google-drive";
    case "Dropbox":
      return "dropbox";
    case "OneDrive":
      return "onedrive";
    case "Box":
      return "box";
    default:
      return "";
  }
}
a(nd, "getProvider");
function Zu(i) {
  let t = "file";
  switch (ii(i)) {
    case ".7z":
    case ".zip":
      t = "archive";
      break;
    case ".aac":
    case ".aif":
    case ".aiff":
    case ".au":
    case ".gsm":
    case ".m4a":
    case ".mid":
    case ".midi":
    case ".mka":
    case ".mp3":
    case ".oga":
    case ".ogg":
    case ".ra":
    case ".ram":
    case ".snd":
    case ".spx":
    case ".wav":
    case ".wma":
      t = "audio";
      break;
    case ".c":
    case ".cgi":
    case ".cpp":
    case ".cs":
    case ".cshtml":
    case ".css":
    case ".html":
    case ".java":
    case ".js":
    case ".json":
    case ".less":
    case ".php":
    case ".pl":
    case ".ps1":
    case ".py":
    case ".rb":
    case ".rs":
    case ".scss":
    case ".sh":
    case ".swift":
    case ".sql":
    case ".ts":
    case ".xml":
    case ".yaml":
    case ".yml":
      t = "code";
      break;
    case ".doc":
    case ".docm":
    case ".docx":
    case ".dotm":
    case ".dotx":
    case ".gdoc":
    case ".pages":
    case ".pdf":
      t = "document";
      break;
    case ".eml":
    case ".msg":
      t = "email";
      break;
    case ".gslides":
    case ".keynote":
    case ".ppt":
    case ".pptm":
    case ".pptx":
    case ".potx":
      t = "presentation";
      break;
    case ".gsheet":
    case ".numbers":
    case ".xls":
    case ".xlsm":
    case ".xlsx":
    case ".xltx":
      t = "spreadsheet";
      break;
    case ".ai":
    case ".apng":
    case ".bmp":
    case ".emf":
    case ".eps":
    case ".gif":
    case ".heic":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".psd":
    case ".svg":
    case ".tif":
    case ".tiff":
    case ".webp":
    case ".wmf":
      t = "image";
      break;
    case ".md":
    case ".markdown":
    case ".txt":
      t = "text";
      break;
    case ".3g2":
    case ".asx":
    case ".asf":
    case ".avi":
    case ".flv":
    case ".mk3d":
    case ".mkv":
    case ".mov":
    case ".mp4":
    case ".mpeg":
    case ".mpg":
    case ".ogm":
    case ".ogv":
    case ".ogx":
    case ".qt":
    case ".rm":
    case ".rv":
    case ".smi":
    case ".smil":
    case ".swf":
    case ".webm":
    case ".wmv":
    case ".xaml":
      t = "video";
      break;
  }
  return t;
}
a(Zu, "getKind");
function Yu(i) {
  const t = i.target, e = t?.value.lastIndexOf(".");
  e === -1 ? t?.select() : e !== void 0 && t?.setSelectionRange(0, e);
}
a(Yu, "handleSelectFilename");
async function mu(i, t = "SHA-256") {
  return await new Promise((e) => {
    if (i) {
      const r = new FileReader();
      r.readAsArrayBuffer(i), r.onloadend = async () => {
        const s = await crypto.subtle.digest(t, r.result);
        let n = "";
        s && (n = Array.from(new Uint8Array(s)).map((c) => c.toString(16).padStart(2, "0")).join("")), e(n);
      };
    } else
      e("");
  });
}
a(mu, "getHash");
function Rp(i, t) {
  return i.findAll(t.filters).map((e) => t.select ? t.select(e) : e.state);
}
a(Rp, "getResult");
const Wy = class Wy {
  constructor(t) {
    this.alwaysUpdate = !1, t.addController(this), this.host = t, this.setContext();
  }
  async setContext() {
    this.whenContext = new Promise((t) => this.resolveContext = t), await ar(this.host), this.context = new Je(this.host, { context: re, subscribe: !0 });
  }
  hostUpdate() {
    this.context?.value && this.resolveContext?.();
  }
  async trackMutationState(t, e) {
    if (e || (await this.whenContext, e = this.context?.value?.queryClient), !e)
      throw new Error("No QueryClient provided");
    return this.mutationCacheUnsubscribe?.(), this.options = t, this.mutationCache = e.getMutationCache(), this.mutationCacheSubscribe(), this.result;
  }
  mutationCacheSubscribe() {
    this.mutationCache && this.options && (this.result = Rp(this.mutationCache, this.options), this.mutationCacheUnsubscribe = this.mutationCache.subscribe((t) => {
      if (this.mutationCache && this.options && /added|removed|updated/.test(t.type)) {
        const e = Rp(this.mutationCache, this.options);
        this.result !== e && !wn(this.result, e) && (this.result = e, this.host.requestUpdate());
      }
    }), this.host.requestUpdate());
  }
  get isMutating() {
    return !this.mutationCache || !this.options?.filters ? 0 : Rp(this.mutationCache, { filters: { ...this.options.filters, status: "pending" } }).length;
  }
  untrackMutationState() {
    this.mutationCacheUnsubscribe?.(), this.mutationCacheUnsubscribe = void 0, this.result = void 0, this.options = void 0, this.mutationCache = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.mutationCacheSubscribe();
  }
  hostDisconnected() {
    this.mutationCacheUnsubscribe?.();
  }
};
a(Wy, "MutationStateController");
let yc = Wy;
function Ft(i, t, e, r) {
  const s = i.getMutationCache(), n = s.find({
    mutationKey: t,
    predicate: /* @__PURE__ */ a((o) => o.state.variables === e, "predicate")
  });
  if (n && n.state.context) {
    const o = { ...n.state.context };
    r(o);
    const c = { ...n.state, context: o };
    n.state = c, s.notify({
      mutation: n,
      type: "updated",
      action: {
        type: "pending",
        context: n.state.context,
        variables: n.state.variables,
        isPaused: !1
      }
    });
  }
}
a(Ft, "updateMutationContext");
function $m(i, t, e) {
  const r = i.getMutationCache().find({ mutationKey: t, exact: !0, predicate: e });
  r && i.getMutationCache().remove(r);
}
a($m, "removeMutation");
function e0(i, t) {
  const e = i.getMutationCache();
  e.findAll({ mutationKey: t, exact: !0 }).forEach((s) => {
    e.remove(s);
  });
}
a(e0, "removeMutations");
const Xu = /* @__PURE__ */ a((i, t, e = 0, r = "application/octet-stream", s, n = Date.now()) => {
  const o = i && (i instanceof URL ? i.toString() : URL.createObjectURL(i));
  return {
    id: n,
    app: { id: -1 },
    name: t,
    kind: Zu(t),
    size: e,
    media_type: r,
    embed_url: "",
    preview_format: t0(t),
    thumbnail_url: o,
    preview_url: o,
    download_url: o,
    rev: -1,
    created_by: s,
    created_at: (/* @__PURE__ */ new Date()).toUTCString(),
    is_subscribed: !1,
    is_trashed: !1,
    is_starred: !1
  };
}, "getTempFile");
function Cm(i) {
  const t = i ? i.reduce(
    (e, r) => {
      const s = r.context?.file;
      return s && r.context?.status.progress && s.size ? {
        loaded: e.loaded + Math.floor(r.context.status.progress / 100 * s.size),
        total: e.total + s.size
      } : e;
    },
    { loaded: 0, total: 0 }
  ) : { loaded: 0, total: 0 };
  return {
    /** Loaded bytes */
    loaded: t.loaded,
    /** Total bytes */
    total: t.total,
    /** Progress of upload provided as 0-100 percent. */
    percent: t.total > 0 ? t.loaded / t.total * 100 : null
  };
}
a(Cm, "getFileMutationsTotalProgress");
function vu(i) {
  return i ? i.some((t) => t.context?.status.state === "conflict") ? "conflict" : i.some((t) => t.status === "error") ? "error" : i.every((t) => t.status === "success") ? "ok" : "pending" : "ok";
}
a(vu, "getFileMutationsTotalStatus");
function Hw(i) {
  return i?.filter((t) => t.context?.status.state === "pending") || [];
}
a(Hw, "getPendingFileMutations");
function Vw(i) {
  return i?.filter((t) => t.context?.status.state === "conflict" || t.status === "error") || [];
}
a(Vw, "getFileMutationsByConflictOrError");
function i0(i, t) {
  const e = i.queryClient;
  e.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "blobs"],
    exact: !0
  }).forEach((r) => {
    r.state.context?.status.state === "error" && e.getMutationCache().remove(r);
  }), e.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "files"],
    exact: !0
  }).forEach((r) => {
    r.state.context?.status.state === "conflict" && e.getMutationCache().remove(r);
  });
}
a(i0, "removeErroredFileMutations");
function gu(i, t, e) {
  const r = i.queryClient;
  r.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "blobs"],
    exact: !0,
    predicate: /* @__PURE__ */ a((s) => /error|success/.test(s.state.status) && (!e || s.state.variables?.blob?.name === e), "predicate")
  }).forEach((s) => {
    r.getMutationCache().remove(s);
  }), r.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "files"],
    exact: !0,
    predicate: /* @__PURE__ */ a((s) => /error|success/.test(s.state.status) && (!e || s.state.variables?.blob?.name === e), "predicate")
  }).forEach((s) => {
    r.getMutationCache().remove(s);
  });
}
a(gu, "removeSettledFileMutations");
function r0(i, t, e) {
  const r = i.queryClient, s = ["apps", e.id, "files"];
  return {
    mutationFn: /* @__PURE__ */ a(async ({ blob: o, replace: c = !1 }) => {
      const l = await i.fetch("/api/apps/" + e.id + "/files", {
        method: "POST",
        body: JSON.stringify({ blob_id: o.id, replace: c })
      });
      if (!l.ok) {
        const u = await l.json();
        throw new Error(u.detail || u.title, { cause: u });
      }
      return await l.json();
    }, "mutationFn"),
    mutationKey: s,
    onMutate: /* @__PURE__ */ a(async (o) => {
      await r.cancelQueries({ queryKey: s, exact: !0 }), s0(i, e, o.blob.name), gu(i, e, o.blob.name);
      let c;
      try {
        c = o.blob.thumbnail_url && new URL(o.blob.thumbnail_url) || void 0;
      } catch {
      }
      const l = Xu(c, o.blob.name, o.blob.size, o.blob.media_type, t);
      return {
        type: o.replace ? "replace" : "create",
        file: l,
        status: { state: "pending" }
      };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((o, c, l) => (Ft(r, s, c, (u) => {
      u && (u.status.state = "ok", u.status.progress = void 0, u.status.text = void 0);
    }), r.invalidateQueries({ queryKey: s })), "onSuccess"),
    onError(o, c, l) {
      o?.cause?.status === 409 ? Ft(r, s, c, (u) => {
        u && (u.status.progress = void 0, u.status.state = "conflict", u.status.text = o.message);
      }) : Ft(r, s, c, (u) => {
        u && (u.status.state = "error", u.status.progress = void 0, u.status.text = o.message);
      });
    }
  };
}
a(r0, "getCreateFileMutationOptions");
function s0(i, t, e, r, s = "blobs") {
  const n = i.queryClient;
  n.getMutationCache().findAll({
    mutationKey: ["apps", t.id, s],
    exact: !0,
    status: "success",
    predicate: /* @__PURE__ */ a((o) => o.state.data?.name === e, "predicate")
  }).forEach((o) => {
    n.getMutationCache().remove(o);
  });
}
a(s0, "removeSuccessfulUploadBlobMutations");
async function km(i, t, e, r) {
  const s = new FormData();
  s.append("blob", t);
  const n = await i.upload(
    "/api/blobs",
    "POST",
    s,
    Fd.Auto,
    (c) => {
      e && e({ progress: c });
    },
    r
  );
  if (!n.ok) {
    const c = await n.json();
    throw new Error(c.detail || c.title, { cause: c });
  }
  return await n.json();
}
a(km, "uploadBlob");
function n0(i) {
  return {
    mutationFn: /* @__PURE__ */ a(async (e) => await km(i, e.file, e.onProgress), "mutationFn")
    // TODO: implement onmutate, onsuccess, onerror...
  };
}
a(n0, "getSimpleUploadBlobMutationOptions");
function Ju(i, t, e, r, s = "blobs") {
  const n = i.queryClient, o = r ? ["apps", e, s, r] : ["apps", e, s];
  return {
    mutationFn: /* @__PURE__ */ a(async (l) => await km(i, l.file, l.onProgress, l.signal), "mutationFn"),
    mutationKey: o,
    onMutate: /* @__PURE__ */ a(async (l) => {
      await n.cancelQueries({ queryKey: o, exact: !0 });
      const u = Xu(l.file, l.file.name, l.file.size, l.file.type, t);
      l.onProgress = ({ progress: $ }) => {
        Ft(n, o, l, (m) => {
          m.status.state = "pending", m.status.progress = $;
        });
      };
      const f = await mu(l.file);
      return { type: "upload", file: u, status: { state: "pending" }, sha256: f };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((l, u, f) => {
      Ft(n, o, u, ($) => {
        $.status.state = "ok", $.status.progress = void 0, $.status.text = void 0;
      });
    }, "onSuccess"),
    onError(l, u, f) {
      const $ = l.cause;
      $ && $.status === 409 ? Ft(n, o, u, (m) => {
        m.status.state = "conflict", m.status.progress = void 0, m.status.text = $.detail || $.title;
      }) : Ft(n, o, u, (m) => {
        m && (m.status.state = "error", m.status.progress = void 0, m.status.text = $.detail || $.title);
      });
    }
  };
}
a(Ju, "getUploadBlobMutationOptions");
var a0 = Object.defineProperty, ty = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = void 0, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = o(t, e, s) || s);
  return s && a0(t, e, s), s;
}, "__decorateClass$1j"), Zn, Yn, Xn, Jn, ta, ea, Bi;
const Qy = class Qy extends X {
  constructor() {
    super(...arguments);
    O(this, Zn);
    O(this, Yn);
    O(this, Xn);
    O(this, Jn);
    O(this, ta);
    O(this, ea);
    O(this, Bi);
    this.contextId = sl(), P(this, Yn, new Promise((e) => {
      P(this, Zn, e);
    })), P(this, Jn, new Promise((e) => {
      P(this, Xn, e);
    })), P(this, ea, new Promise((e) => {
      P(this, ta, e);
    })), P(this, Bi, new Ie(this));
  }
  // PROPERTIES
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  // Promise.withResolvers() is available in ES2024, that needs to be set in TSConfig
  /**
   * Resolves when a contextual id is available.
   *
   * @internal
   * @returns {Promise<ContextIdType>}
   */
  async whenContextId() {
    return await y(this, Yn);
  }
  /**
   * Resolves when current user data is available.
   *
   * @returns {Promise<UserType>}
   */
  async whenUser() {
    return await y(this, Jn);
  }
  /**
   * Resolves when a weavy context is available.
   *
   * @returns {Promise<WeavyType>}
   */
  async whenWeavy() {
    return await y(this, ea);
  }
  connectedCallback() {
    super.connectedCallback(), this.contextId && this.requestUpdate("contextId"), this.user && this.requestUpdate("user"), this.weavy && this.requestUpdate("weavy");
  }
  async scheduleUpdate() {
    await ar(this), await super.scheduleUpdate();
  }
  async willUpdate(e) {
    var r, s, n;
    super.willUpdate(e), this.weavyContextConsumer ??= new Je(this, { context: re, subscribe: !0 }), this.weavyContextConsumer?.value && this.weavy !== this.weavyContextConsumer?.value && (this.weavy = this.weavyContextConsumer?.value), e.has("weavy") && this.weavy && await y(this, Bi).trackQuery(sd(this.weavy, ["user"])), y(this, Bi).result?.isPending || (this.user && y(this, Bi).result.data && this.user.id !== y(this, Bi).result.data.id && (console.warn("User mismatch, resetting"), this.weavy?.reset()), this.user = y(this, Bi).result?.data), e.has("contextId") && this.contextId && (e.get("contextId") && P(this, Yn, new Promise((o) => {
      P(this, Zn, o);
    })), (r = y(this, Zn)) == null || r.call(this, this.contextId)), e.has("user") && this.user && (e.get("user") && P(this, Jn, new Promise((o) => {
      P(this, Xn, o);
    })), (s = y(this, Xn)) == null || s.call(this, this.user)), e.has("weavy") && this.weavy && (e.get("weavy") && P(this, ea, new Promise((o) => {
      P(this, ta, o);
    })), (n = y(this, ta)) == null || n.call(this, this.weavy));
  }
};
Zn = new WeakMap(), Yn = new WeakMap(), Xn = new WeakMap(), Jn = new WeakMap(), ta = new WeakMap(), ea = new WeakMap(), Bi = new WeakMap(), a(Qy, "WeavyComponent");
let wc = Qy;
ty([
  F()
], wc.prototype, "weavy");
ty([
  Vr({ context: om }),
  F()
], wc.prototype, "contextId");
ty([
  Vr({ context: uh }),
  F()
], wc.prototype, "user");
var o0 = Object.defineProperty, c0 = Object.getOwnPropertyDescriptor, Ve = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? c0(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && o0(t, e, s), s;
}, "__decorateClass$1i"), Nl, jl, Wl, Ql, ia, ra, sa, na, cs, ls, aa, oa, bi, ca, ds;
const Ky = class Ky extends wc {
  constructor() {
    super();
    // DEPRECATED .data property
    O(this, Nl);
    // APP SUBSCRIBE
    // SETTINGS
    // annotations
    O(this, jl);
    // enterToSend
    O(this, Wl);
    // reactions
    O(this, Ql);
    O(this, ia);
    O(this, ra);
    O(this, sa);
    O(this, na);
    O(this, cs);
    O(this, ls);
    O(this, aa);
    O(this, oa);
    O(this, bi);
    O(this, ca);
    O(this, ds);
    this.storage = qf("localStorage"), this.storageLinkHandler = (e) => {
      e.storageArea === this.storage && e.key === "wy-link" && e.newValue && this.readStorageLink();
    }, this.linkEventHandler = async (e) => {
      !e.defaultPrevented && e.detail.link && (this.link && this.link.id === e.detail.link.id && (this.link = void 0, await this.updateComplete), this.link = e.detail.link, this.link || this.provideStorageLink(e.detail.link));
    }, this.notificationEventConsumer = (e) => {
      e.stopPropagation(), e.defaultPrevented || this.isConnected && this.checkVisibility(t1) && this.matchesLink(e.detail.link) && e.preventDefault();
    }, P(this, ra, new Promise((e) => {
      P(this, ia, e);
    })), P(this, na, new Promise((e) => {
      P(this, sa, e);
    })), P(this, ls, new Promise((e) => {
      P(this, cs, e);
    })), P(this, oa, new Promise((e) => {
      P(this, aa, e);
    })), P(this, bi, /* @__PURE__ */ new Map()), P(this, ca, new We(this)), P(this, ds, new yc(this)), this.settings = new Nd(this);
  }
  /**
   * Checks if an entity matches the component configuration.
   *
   * @internal
   * @param link - Entity to check for a match.
   * @returns True if the entity targets this component.
   */
  matchesLink(e) {
    return (
      // Type app match, like the Messenger
      e?.app?.type && this.componentTypes?.includes(e.app.type) ? e.agent ? e.agent === this.agent : !0 : !1
    );
  }
  set link(e) {
    const r = this._link;
    this._link = this.matchesLink(e) ? e : void 0, this.requestUpdate("link", r);
  }
  get link() {
    return this._link;
  }
  /**
   * Clears the link and resets the promise.
   *
   * @internal
   */
  clearLink() {
    this.link && (P(this, ls, new Promise((e) => {
      P(this, cs, e);
    })), this.link = void 0);
  }
  /**
   * Shares a link with other blocks that may consume it automatically.
   *
   * @param link - The entity to provide.
   * @internal
   */
  provideStorageLink(e) {
    this.storage?.setItem("wy-link", btoa(JSON.stringify(e)));
  }
  /**
   * Reads a link from storage and exposes it via the link property and context.
   *
   * @internal
   */
  readStorageLink() {
    if (!this.storage) {
      console.error("Storage not available");
      return;
    }
    const e = this.storage.getItem("wy-link");
    if (e)
      try {
        const r = JSON.parse(atob(e));
        r && (this.link = r);
      } catch (r) {
        console.error("Error parsing link", r);
      }
  }
  /**
   * Consumes a link in storage. Make sure to consume it after it has been used.
   *
   * @internal
   */
  consumeStorageLink() {
    this.storage?.removeItem("wy-link");
  }
  set agent(e) {
    this._agentUid = e || void 0;
  }
  get agent() {
    return this._agentUid;
  }
  set data(e) {
    console.warn(".data property array is deprecated. Use .contextualData string instead."), P(this, Nl, e);
  }
  /**
   * DEPRECATED: Use `.contextualData` property instead.
   *
   * Array with contextual data.
   *
   * *Note: Only the first item in the array is currently used.*
   * @internal
   * @deprecated
   */
  get data() {
    return y(this, Nl);
  }
  set annotations(e) {
    P(this, jl, e);
  }
  get annotations() {
    return y(this, jl) ?? this.weavy?.annotations ?? te.defaults.annotations;
  }
  set enterToSend(e) {
    P(this, Wl, e);
  }
  get enterToSend() {
    return y(this, Wl) ?? this.weavy?.enterToSend ?? te.defaults.enterToSend;
  }
  set reactions(e) {
    P(this, Ql, e);
  }
  get reactions() {
    return y(this, Ql) ?? this.weavy?.reactions ?? te.defaults.reactions;
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  // Promise.withResolvers() is available in ES2024, that needs to be set in TSConfig
  // #resolveAgentUser?: (agent: AgentType) => void;
  // #whenAgentUser = new Promise<AgentType>((r) => {
  //   this.#resolveAgentUser = r;
  // });
  // async whenAgentUser() {
  //   return await this.#whenAgentUser;
  // }
  /**
   * Resolves when context data blob uploads has finished.
   *
   * @internal
   * @returns {Promise<ContextDataBlobsType>}
   */
  async whenContextDataBlobs() {
    return await y(this, ra);
  }
  /**
   * Resolves when Weavy component features config is available.
   *
   * @internal
   * @returns {Promise<ComponentFeaturePolicy>}
   */
  async whenComponentFeatures() {
    return await y(this, na);
  }
  /**
   * Resolves when a provided link is available.
   *
   * @internal
   * @returns {Promise<LinkType>}
   */
  async whenLink() {
    return await y(this, ls);
  }
  /**
   * Resolves when Weavy component settings are available.
   *
   * @internal
   * @returns {Promise<WeavyComponentSettingsType>}
   */
  async whenSettings() {
    return await y(this, oa);
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("wy-link", this.linkEventHandler), window.addEventListener("storage", this.storageLinkHandler), this.componentFeatures && this.requestUpdate("componentFeatures"), this.contextDataBlobs && this.requestUpdate("contextDataBlobs"), this.link && this.requestUpdate("link"), this.settings && this.requestUpdate("settings");
  }
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("wy-link", this.linkEventHandler), window.removeEventListener("storage", this.storageLinkHandler), this.weavy?.host.removeEventListener("wy-notification", this.notificationEventConsumer, { capture: !0 });
  }
  async willUpdate(e) {
    var s, n, o, c;
    await super.willUpdate(e), e.has("bot") && typeof this.bot == "string" && console.error(`Using .bot property is deprecated. Use .agent = "${this.bot}"; instead`);
    const r = Object.keys(this.settings);
    if ((e.has("weavy") || r.find((l) => e.has(l))) && (this.settings = new Nd(this)), e.has("features") && this.componentFeatures && (this.componentFeatures.setAllowedFeatures(this.features), this.componentFeatures instanceof ee && (this.componentFeatures = this.componentFeatures.immutable())), (e.has("weavy") || e.has("contextId") || e.has("user") || e.has("componentFeatures")) && this.weavy && this.contextId && this.user && this.componentFeatures?.allowsFeature(M.ContextData) && (await y(this, ca).trackMutation(
      Ju(this.weavy, this.user, this.contextId, void 0, "data")
    ), await y(this, ds).trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.contextId, "data"],
          exact: !0
        }
      },
      this.weavy.queryClient
    )), e.has("contextualData") || e.has("data") || e.has("componentFeatures")) {
      const l = this.contextualData ? [this.contextualData] : this.data ? this.data : [], u = y(this, bi);
      if (P(this, bi, /* @__PURE__ */ new Map()), l.forEach((f) => {
        const $ = u.get(f);
        if ($)
          y(this, bi).set(f, $);
        else {
          const m = Zg(f);
          m && y(this, bi).set(f, m);
        }
      }), y(this, bi) && this.componentFeatures?.allowsFeature(M.ContextData)) {
        for (const x of Array.from(y(this, bi).values()))
          if (x.type === "file") {
            const g = await mu(x.item);
            await p1(
              y(this, ds).result ?? [],
              async (I) => (I.context?.sha256 ?? await mu(I.variables?.file)) === g
            ) || await y(this, ca).mutate({ file: x.item });
          }
        const f = y(this, ds).result, $ = f?.some((x) => x.status === "pending"), m = f?.map((x) => x.data?.id).filter((x) => x).reverse() ?? [];
        $ || (this.contextDataBlobs = m);
      } else
        this.contextDataBlobs = [];
    }
    (e.has("componentTypes") || e.has("agent")) && this.componentTypes && this.readStorageLink(), e.has("link") && this.link && (console.info("Opening notification link"), this.consumeStorageLink()), e.has("contextDataBlobs") && this.contextDataBlobs && (e.get("contextDataBlobs") && P(this, ra, new Promise((l) => {
      P(this, ia, l);
    })), (s = y(this, ia)) == null || s.call(this, this.contextDataBlobs)), e.has("componentFeatures") && this.componentFeatures && (e.get("componentFeatures") && P(this, na, new Promise((l) => {
      P(this, sa, l);
    })), (n = y(this, sa)) == null || n.call(this, this.componentFeatures)), e.has("link") && this.link && (e.get("link") && P(this, ls, new Promise((l) => {
      P(this, cs, l);
    })), (o = y(this, cs)) == null || o.call(this, this.link)), e.has("settings") && this.settings && (e.get("settings") && P(this, oa, new Promise((l) => {
      P(this, aa, l);
    })), (c = y(this, aa)) == null || c.call(this, this.settings)), e.has("weavy") && this.weavy && this.weavy.host.addEventListener("wy-notification", this.notificationEventConsumer, { capture: !0 });
  }
};
Nl = new WeakMap(), jl = new WeakMap(), Wl = new WeakMap(), Ql = new WeakMap(), ia = new WeakMap(), ra = new WeakMap(), sa = new WeakMap(), na = new WeakMap(), cs = new WeakMap(), ls = new WeakMap(), aa = new WeakMap(), oa = new WeakMap(), bi = new WeakMap(), ca = new WeakMap(), ds = new WeakMap(), a(Ky, "WeavyTypeComponent");
let Dt = Ky;
Ve([
  Vr({ context: cm }),
  F()
], Dt.prototype, "contextDataBlobs", 2);
Ve([
  Vr({ context: ph }),
  F()
], Dt.prototype, "componentFeatures", 2);
Ve([
  Vr({ context: hm }),
  F()
], Dt.prototype, "settings", 2);
Ve([
  Vr({ context: dm })
], Dt.prototype, "_link", 2);
Ve([
  p({ type: Object })
], Dt.prototype, "link", 1);
Ve([
  F()
], Dt.prototype, "componentTypes", 2);
Ve([
  p()
], Dt.prototype, "features", 2);
Ve([
  p({ type: String })
], Dt.prototype, "agent", 1);
Ve([
  p({
    attribute: !0,
    type: String
  })
], Dt.prototype, "contextualData", 2);
Ve([
  p({
    attribute: !0,
    type: String,
    converter: {
      fromAttribute(i) {
        return h1(i);
      }
    }
  })
], Dt.prototype, "data", 1);
Ve([
  p({ type: String })
], Dt.prototype, "annotations", 1);
Ve([
  p({ type: String })
], Dt.prototype, "enterToSend", 1);
Ve([
  p({ type: String })
], Dt.prototype, "reactions", 1);
Ve([
  p()
], Dt.prototype, "bot", 2);
const l0 = new Map(Df(pm)), d0 = new Map(Df(um)), jd = new Map(Object.entries(ym)), f9 = new Map(Object.entries(wm));
var h0 = Object.defineProperty, p0 = Object.getOwnPropertyDescriptor, Hs = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? p0(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && h0(t, e, s), s;
}, "__decorateClass$1h");
const Mr = "unknown";
var la, da, $r;
const Gy = class Gy extends Dt {
  constructor() {
    super(...arguments);
    O(this, la);
    O(this, da);
    O(this, $r);
    this.appSubscribeMutation = new We(this), P(this, da, new Promise((e) => {
      P(this, la, e);
    })), P(this, $r, new Ie(this));
  }
  // @provide({ context: AgentContext })
  // @state()
  // agentUser: AgentType | undefined;
  /**
   * Sets the component to it's initial state and resets the app state.
   */
  reset() {
    this.app && (this.app = void 0), this._appName !== this._initialAppName && (this._appName = this._initialAppName);
  }
  /**
   * Checks if an entity matches the component configuration.
   *
   * @internal
   * @param link - Entity to check for a match.
   * @returns True if the entity targets this component.
   */
  matchesLink(e) {
    return (
      // Messenger conversation
      e?.app?.type && !this.appType && this.componentTypes?.includes(e.app.type) ? e.agent ? e.agent === this.agent : !0 : (
        // Normal contextual app
        !!(e && e.app && this.appType !== Mr && (typeof this.uid == "string" && e.app?.uid === this.uid || // Normal app with app uid
        typeof this.uid == "number" && e.app?.id === this.uid || // Normal app with app id
        this.agent && e.app.type === this.appType && e.agent === this.agent))
      )
    );
  }
  set link(e) {
    const r = this._link;
    !this.uid && this.appType && this.appType !== Mr ? this.whenApp().then(() => {
      this._link = this.matchesLink(e) ? e : void 0, this.requestUpdate("link", r);
    }) : (this._link = this.matchesLink(e) ? e : void 0, this.requestUpdate("link", r));
  }
  get link() {
    return this._link;
  }
  set name(e) {
    this._initialAppName = e, this._appName = e;
  }
  get name() {
    return this._appName;
  }
  /**
   * Subscribes or unsubscribes to notification updates from the app. Check `.app.is_subscribed` to see current state.
   *
   * @param subscribe - Set to `false` to unsubscribe from updates. Defaults to `true`.
   * @returns {Promise<void>}
   *
   * @example <caption>Toggle app subscription</caption>
   * ```js
   * // Wait for app data
   * await myWeavyComponent.whenApp();
   *
   * // Get current app subscription state
   * const isSubscribed = myWeavyComponent.app.is_subscribed;
   *
   * // Toggle the app subscription state
   * myWeavyComponent.subscribe(!isSubscribed);
   * ```
   */
  async subscribe(e = !0) {
    if (!this.uid)
      throw new Error(`Cannot ${e ? "subscribe" : "unsubscribe"} without a uid.`);
    await this.whenApp(), this.app?.id && this.appSubscribeMutation.mutate({ subscribe: e });
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  // Promise.withResolvers() is available in ES2024, that needs to be set in TSConfig
  /**
   * Resolves when app data is available.
   *
   * @returns {Promise<AppType>}
   */
  async whenApp() {
    return await y(this, da);
  }
  connectedCallback() {
    super.connectedCallback(), this.app && this.requestUpdate("app");
  }
  async willUpdate(e) {
    var s;
    if (await super.willUpdate(e), e.has("autoUid") && typeof this.autoUid == "string" && (console.error(`Using .autoUid property is deprecated. Use .generateUid = "${this.autoUid}"; instead`), this.generateUid = this.autoUid), (e.has("generateUid") || e.has("user") || e.has("agent")) && this.generateUid && this.user && (this.appType && jd.has(this.appType) && this.agent || this.appType && !jd.has(this.appType))) {
      const n = [this.generateUid];
      this.agent && n.push(this.agent), this.user && n.push(this.user.uid || this.user.id), this.uid = n.join("-");
    }
    const r = this.name;
    if ((e.has("appType") || e.has("uid") || e.has("agent") || e.has("weavy")) && this._appName !== this._initialAppName && (this._appName = this._initialAppName, this.requestUpdate("name", r)), e.has("appType") || e.has("uid") || e.has("agent") || e.has("name") || e.has("weavy"))
      if (this.appType && this.uid && this.weavy) {
        const n = this.name ? { name: this.name } : void 0, o = this.agent ? [this.agent] : void 0;
        await y(this, $r).trackQuery(u0(this.weavy, this.uid, this.appType, o, n));
      } else
        y(this, $r).untrackQuery();
    if (y(this, $r).result?.isPending || (this.app = y(this, $r).result?.data, this.app?.name && this._appName !== this.app.name && (this.name = this.app.name, this.requestUpdate("name", r))), e.has("uid") && (this.uid || e.get("uid")) && this.uid !== e.get("uid") && this.clearLink(), !this.link && (e.has("uid") && this.uid || e.has("app") && this.app) && this.appType && this.appType !== Mr && this.readStorageLink(), e.has("app") && this.app) {
      const n = new CustomEvent("wy-app", {
        bubbles: !1,
        composed: !0,
        detail: {
          app: this.app
        }
      });
      this.dispatchEvent(n);
    }
    e.has("app") && this.app && (e.get("app") && P(this, da, new Promise((n) => {
      P(this, la, n);
    })), (s = y(this, la)) == null || s.call(this, this.app)), (e.has("weavy") || e.has("app")) && this.weavy && this.app && this.appSubscribeMutation.trackMutation(w0(this.weavy, this.app));
  }
};
la = new WeakMap(), da = new WeakMap(), $r = new WeakMap(), a(Gy, "WeavyAppComponent");
let xe = Gy;
Hs([
  Vr({ context: Qu }),
  F()
], xe.prototype, "app", 2);
Hs([
  p({ type: Object })
], xe.prototype, "link", 1);
Hs([
  F()
], xe.prototype, "appType", 2);
Hs([
  p()
], xe.prototype, "generateUid", 2);
Hs([
  p({ converter: mm })
], xe.prototype, "uid", 2);
Hs([
  p({ type: String })
], xe.prototype, "name", 1);
Hs([
  p()
], xe.prototype, "autoUid", 2);
function u0(i, t, e = Mr, r, s) {
  return {
    // eslint-disable-next-line @tanstack/query/exhaustive-deps
    queryKey: ["apps", t],
    queryFn: /* @__PURE__ */ a(async () => {
      const n = [];
      e === Mr || typeof t == "number" ? n.push(
        // Get existing app
        i.fetch(`/api/apps/${t}`)
      ) : r?.length ? (n.push(
        // Get existing app
        i.fetch(`/api/apps/${t}`)
      ), n.push(
        // Create app with members
        i.fetch("/api/apps", { method: "POST", body: JSON.stringify({ type: e, members: r, uid: t, ...s }) })
      )) : n.push(
        // Get, update or create app (upsert) using app uid
        i.fetch(`/api/apps/${t}`, { method: "PUT", body: JSON.stringify({ type: e, ...s }) })
      );
      const o = (await Promise.allSettled(n)).findLast(
        (l) => l.status === "fulfilled" && l.value?.ok
      ), c = o?.status === "fulfilled" && o.value;
      if (c)
        return await c.json();
      throw new Error(`Error getting or creating app ${t}`);
    }, "queryFn")
  };
}
a(u0, "getOrCreateAppOptions");
function y0(i) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ name: e, members: r, type: s, uid: n }) => await (await i.fetch("/api/apps", {
      method: "POST",
      body: JSON.stringify({
        name: e,
        members: r,
        type: s,
        uid: n
      })
    })).json(), "mutationFn"),
    onSettled: /* @__PURE__ */ a(async () => {
      await i.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
a(y0, "getCreateAppMutationOptions");
function _m(i) {
  return new $t(i.queryClient, y0(i));
}
a(_m, "getCreateAppMutation");
function w0(i, t) {
  const e = i.queryClient, r = ["apps", t.uid || t.id];
  return {
    mutationFn: /* @__PURE__ */ a(async ({ subscribe: n }) => {
      if (t.id >= 1) {
        const o = await i.fetch(`/api/apps/${t.id}/${n ? "subscribe" : "unsubscribe"}`, {
          method: "POST"
        });
        if (!o.ok)
          throw await o.json();
      } else
        throw new Error(`Could not subscribe to app ${t.uid || t.id}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((n) => {
      let o;
      return e.setQueryData(r, (l) => (o = l.is_subscribed, { ...l, is_subscribed: n.subscribe })), {
        previousSubscribe: o,
        subscribe: n.subscribe
      };
    }, "onMutate"),
    onError(n, o, c) {
      c && c.previousSubscribe !== void 0 && e.setQueryData(r, (l) => ({ ...l, is_subscribed: c?.previousSubscribe }));
    }
  };
}
a(w0, "getAppSubscribeMutationOptions");
function f0(i, t = [tt.ChatRoom, tt.PrivateChat], e) {
  const r = new URLSearchParams({
    count_only: "true",
    unread: "true",
    uid: "false"
  });
  e && r.append("member", e), t?.forEach((o) => r.append("type", o));
  const s = `/api/apps?${r.toString()}`;
  return sd(i, ["apps", "unread", t, e], s);
}
a(f0, "getAppsUnreadOptions");
function m0(i, t = {}, e, r, s, n, o) {
  return {
    ...t,
    initialPageParam: 0,
    queryKey: ["apps", "list", e, r, n, o],
    queryFn: /* @__PURE__ */ a(async (c) => {
      const l = new URLSearchParams();
      r && l.append("member", r), c.pageParam && typeof c.pageParam == "number" && l.append("skip", c.pageParam?.toString()), e?.forEach((x) => l.append("type", x)), l.append("order_by", n);
      const u = s?.();
      u && l.append("q", u), l.append("uid", "false");
      const f = `/api/apps?${l.toString()}`, m = await (await i.fetch(f)).json();
      return m.data = m.data || [], m;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ a((c) => {
      if (c.end && c?.end < c?.count)
        return c.end;
    }, "getNextPageParam")
  };
}
a(m0, "getAppListOptions");
var ge = /* @__PURE__ */ ((i) => (i.Default = "", i.Select = "select", i.Star = "star", i.Unstar = "unstar", i.Subscribe = "subscribe", i.Unsubscribe = "unsubscribe", i.Pin = "pin", i.Unpin = "unpin", i.Download = "download", i.Preview = "preview", i))(ge || {});
const Zy = class Zy {
  get weavy() {
    return this.weavyContext?.value;
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenWeavyContext = new Promise((e) => this.resolveWeavyContext = e), this.setContexts();
  }
  /**
   * Initiates context consumers
   */
  async setContexts() {
    await ar(this.host), this.weavyContext = new Je(this.host, { context: re, subscribe: !0 });
  }
  /**
   * Dispatch a `wy-action` event on the host.
   *
   * @fires {WyActionEventType} wy-action - Emitted when a conversation app is created and should be selected.
   */
  dispatchActionEvent(t) {
    const e = new CustomEvent("wy-action", {
      detail: { action: ge.Select, app: t },
      bubbles: !0,
      composed: !0
    });
    return this.host.dispatchEvent(e);
  }
  /**
   * Create mutation controller.
   */
  async initMutation() {
    if (!this.addConversationMutation) {
      const t = await this.whenWeavyContext;
      this.addConversationMutation = _m(t);
    }
    return this.addConversationMutation;
  }
  /**
   * Create a conversation and trigger a `select` event.
   *
   * @param members - Array of members by id/uid for a new conversation.
   * @returns Whether the event was successful.
   * @fires {WyActionEventType} wy-action - Emitted when a conversation app is created and should be selected.
   */
  async create(t = []) {
    const e = await this.initMutation(), r = this.agent ?? this.host.agent, s = r ? { members: [r], type: ai.AgentChat } : { members: t, type: t.length === 1 ? ai.PrivateChat : ai.ChatRoom }, n = await e.mutate(s);
    return this.dispatchActionEvent(n), n;
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
  }
};
a(Zy, "CreateConversationController");
let fc = Zy;
var ha;
const Yy = class Yy {
  constructor(t) {
    O(this, ha, !1);
    t.addController(this), this.host = t, t.addEventListener("dragstart", () => this.isDragActive = !0), t.addEventListener("dragenter", () => this.isDragActive = !0), t.addEventListener("dragover", (e) => {
      e.preventDefault(), this.isDragActive = !0;
    }), t.addEventListener("dragleave", () => this.isDragActive = !1), t.addEventListener("dragend", () => this.isDragActive = !1), t.addEventListener("drop", (e) => this.handleDrop(e));
  }
  get isDragActive() {
    return y(this, ha);
  }
  set isDragActive(t) {
    y(this, ha) !== t && (P(this, ha, t), this.host.requestUpdate());
  }
  handleDrop(t) {
    t.preventDefault();
    const e = [];
    t.dataTransfer?.items ? [...t.dataTransfer.items].forEach((r) => {
      if (r.kind === "file") {
        const s = r.getAsFile();
        s ? e.push(s) : console.error("Could not add file");
      }
    }) : t.dataTransfer?.files && [...t.dataTransfer.files].forEach((r) => {
      e.push(r);
    }), e.length && this.dispatchUploadFiles(e), this.isDragActive = !1;
  }
  dispatchUploadFiles(t) {
    const e = new CustomEvent("drop-files", { detail: { files: t } });
    return this.host.dispatchEvent(e);
  }
  hostDisconnected() {
  }
};
ha = new WeakMap(), a(Yy, "DropZoneController");
let Wd = Yy;
function zd(i, t) {
  we();
  const e = yn({}, window.history.state, !0);
  if (!e.weavy || !e.weavy[i] || !Object.hasOwn(e.weavy[i], t))
    throw new Error("Property not found");
  return e.weavy[i][t];
}
a(zd, "getBrowserStateProperty");
function bu(i, t, e = "push", r) {
  if (we(), t) {
    const s = yn({}, window.history.state, !0);
    s.weavy ??= {}, s.weavy[i] = t, r = r && String(r) || window.location.href;
    try {
      e === "replace" ? window.history.replaceState(s, "", r) : window.history.pushState(s, "", r);
    } catch (n) {
      console.warn("history: Could not push history state.", n, t);
    }
  }
}
a(bu, "setBrowserState");
function v0(i, t, e) {
  we();
  const r = `${typeof i}:${t}`;
  e.forEach((s) => {
    try {
      const n = zd(r, s), o = i[s];
      Pm(o, n) && (i[s] = n);
    } catch {
    }
  });
}
a(v0, "restoreHistoryProperties");
function xu(i, t, e, r = "push") {
  we();
  const s = `${typeof i}:${t}`, n = {};
  e.forEach((o) => {
    n[o] = i[o];
  }), bu(s, n, r);
}
a(xu, "pushHistoryProperties");
function g0(i, t, e) {
  xu(i, t, e, "replace");
}
a(g0, "updateHistoryProperties");
function Pm(i, t) {
  return i && t && (Sr(i) || Sr(t)) ? i && Object.hasOwn(i, "id") || t && Object.hasOwn(t, "id") ? i.id !== t.id : !wn(i, t) : i !== t;
}
a(Pm, "itemHasChanged");
const Xy = class Xy {
  constructor(t, e, r) {
    if (this._backCount = 0, this.restoreHistory = (s) => {
      if (this.prefixKey && this.properties) {
        v0(this.host, this.prefixKey, this.properties);
        try {
          this._backCount = zd(this.prefixKey, "_backCount") || 0;
        } catch {
          this._backCount = 0;
        }
        this.updatePrevPropertyValues();
      }
    }, t.addController(this), this.host = t, r && (this.properties = r), e) {
      this.prefixKey = e;
      try {
        this._backCount = zd(this.prefixKey, "_backCount") || this._backCount;
      } catch {
      }
    }
  }
  get hasBackNavigation() {
    return this._backCount > 0;
  }
  back() {
    window.history.back();
  }
  backAll() {
    window.history.go(this._backCount * -1);
  }
  observe(t, e) {
    if (this.properties = t, e) {
      this.prefixKey = e;
      try {
        this._backCount = zd(this.prefixKey, "_hasBack") || this._backCount;
      } catch {
      }
    }
  }
  /**
   * Method to manually push history
   */
  pushCurrentState() {
    this.prefixKey && (xu(this.host, this.prefixKey, this.properties), this._backCount++, bu(this.prefixKey, { _backCount: this._backCount }, "replace"));
  }
  updatePrevPropertyValues() {
    this.properties && this.properties.forEach((t) => {
      this.prevPropertyValues ??= {};
      const e = this.host[t];
      this.prevPropertyValues[t] !== e && (this.prevPropertyValues[t] = e && JSON.parse(JSON.stringify(e)));
    });
  }
  hostConnected() {
    window.addEventListener("popstate", this.restoreHistory);
  }
  hostUpdated() {
    this.prefixKey && this.properties && (this.prevPropertyValues ? this.properties.some(
      (e) => {
        const r = this.prevPropertyValues?.[e], s = this.host[e];
        return Pm(r, s);
      }
    ) && (xu(
      this.prevPropertyValues,
      this.prefixKey,
      this.properties
    ), this._backCount++, bu(this.prefixKey, { _backCount: this._backCount }, "replace")) : this.prevPropertyValues = {}, g0(this.host, this.prefixKey, this.properties), this.updatePrevPropertyValues());
  }
  hostDisconnected() {
    window.removeEventListener("popstate", this.restoreHistory);
  }
};
a(Xy, "HistoryController");
let Uw = Xy;
const Jy = class Jy {
  get result() {
    return this._result && this.observer ? this.observer.trackResult(this._result) : this.observer?.getCurrentResult() ?? { isPending: !0 };
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenQueryClient = new Promise((e) => this.resolveQueryClient = e), this.setContext();
  }
  async setContext() {
    await ar(this.host), this.context = new Je(this.host, {
      context: re,
      subscribe: !0,
      callback: /* @__PURE__ */ a((t) => {
        t && (this.resolveContext?.(t), this.queryClient = t.queryClient, this.resolveQueryClient?.(t.queryClient));
      }, "callback")
    });
  }
  async trackInfiniteQuery(t, e = !0) {
    this.observerUnsubscribe?.();
    const r = await this.whenQueryClient;
    if (!r)
      throw new Error("No QueryClient provided");
    const s = new rg(r, t);
    this.observer = s, this.observerSubscribe(e);
  }
  observerSubscribe(t = !0) {
    if (this.queryClient && this.observer) {
      t ? this._result = this.observer.getOptimisticResult(
        this.observer.options
      ) : this._result = this.observer.getCurrentResult(), this.observerUnsubscribe = this.observer.subscribe(() => {
        if (this.observer) {
          const r = rd(this.result, this.observer.getCurrentResult());
          r !== this._result && (this._result = r, this.host.requestUpdate());
        }
      }), this.observer.updateResult(), this.host.requestUpdate();
      let e;
      t ? e = this.observer.fetchOptimistic(this.observer.options) : e = this.queryClient.getQueryCache().get(
        this.observer.options.queryHash
      )?.promise, e?.catch(() => {
      }).finally(() => {
        this.observer?.updateResult();
      });
    }
  }
  untrackInfiniteQuery() {
    this.observerUnsubscribe?.(), this.observerUnsubscribe = void 0, this._result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    this.observerUnsubscribe?.();
  }
};
a(Jy, "InfiniteQueryController");
let Ki = Jy;
function $u(i, t = !1) {
  for (i && !t && (i = i.nextElementSibling); i; ) {
    if (!(i instanceof HTMLElement))
      continue;
    const e = getComputedStyle(i);
    if (e.display !== "none") {
      if (e.display === "contents") {
        if (i.shadowRoot && i.shadowRoot.firstElementChild instanceof HTMLElement) {
          const r = $u(i.shadowRoot.firstElementChild, !0);
          if (r)
            return r;
        }
        if (i.firstElementChild instanceof HTMLElement) {
          const r = $u(i.firstElementChild, !0);
          if (r)
            return r;
        }
      }
      if (/absolute|sticky|fixed/.test(e.position) === !1)
        return i;
      i = i.nextElementSibling;
    }
  }
  return null;
}
a($u, "getNextPositionedChild");
function wh(i, t = !1) {
  if (we(), i) {
    let e = getComputedStyle(i);
    const r = e.position === "absolute", s = t ? /(auto|scroll|overlay|hidden)/ : /(auto|overlay|scroll)/;
    if (e.position === "fixed" && document.scrollingElement)
      return document.scrollingElement;
    for (let n = i; n = n.parentElement || n.parentNode || n.host; )
      if (n instanceof Element && (e = getComputedStyle(n), !(r && e.position === "static") && s.test(e.overflow + e.overflowY + e.overflowX)))
        return n;
  }
  return document.scrollingElement || i;
}
a(wh, "getScrollParent");
function b0(i) {
  if (i && i.isConnected) {
    const t = wh(i);
    return t.clientHeight !== t.scrollHeight;
  }
  return !1;
}
a(b0, "hasScroll");
function x0(i, t = 32) {
  if (i) {
    const e = wh(i);
    return Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) < t;
  }
  return !1;
}
a(x0, "isParentAtBottom");
async function $0(i, t = !1) {
  if (i) {
    const e = wh(i);
    Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) > 1 && (t ? e.scrollTo({
      top: e.scrollHeight,
      left: 0,
      behavior: "smooth"
    }) : e.scrollTop = e.scrollHeight), await new Promise((r) => {
      let s = e.scrollTop;
      const n = /* @__PURE__ */ a(() => {
        t && e.scrollTop === s && (e.scrollTop = e.scrollHeight), s = e.scrollTop, Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) > 1 ? requestAnimationFrame(n) : r(void 0);
      }, "scrollCheck");
      requestAnimationFrame(n);
    });
  }
}
a($0, "scrollParentToBottom");
const C0 = 0, k0 = void 0;
function _0(i, t, e = !1) {
  we(), t ??= /* @__PURE__ */ a(() => Promise.reject(new Error("No scroll function defined")), "whenNext");
  const r = e ? wh(i) : document.documentElement, s = r === document.documentElement ? document : r;
  let n = !1;
  const o = new IntersectionObserver(
    (c) => {
      c.forEach((l) => {
        if (l.isIntersecting && !n)
          if (n = !0, e && r && s instanceof HTMLElement) {
            const u = $u(l.target) || l.target, f = r.scrollHeight, $ = u.offsetTop, m = /* @__PURE__ */ a(() => {
              queueMicrotask(() => {
                if (f !== r.scrollHeight) {
                  if (u?.isConnected) {
                    const x = u.offsetTop - $;
                    r.scrollTop += x;
                  }
                  requestAnimationFrame(() => n = !1);
                } else
                  queueMicrotask(() => {
                    if (f !== r.scrollHeight) {
                      if (u?.isConnected) {
                        const x = u.offsetTop - $;
                        r.scrollTop += x;
                      }
                      requestAnimationFrame(() => n = !1);
                    } else
                      requestAnimationFrame(() => {
                        if (o.takeRecords().length && u?.isConnected) {
                          const x = u.offsetTop - $;
                          r.scrollTop += x;
                        }
                        requestAnimationFrame(() => n = !1);
                      });
                  });
              });
            }, "afterNext");
            t().then(m);
          } else
            t().then(() => {
              requestAnimationFrame(() => n = !1);
            });
      });
    },
    { root: s, threshold: C0, rootMargin: k0 }
  );
  return o.observe(i), o;
}
a(_0, "createScroller");
const tw = class tw {
  constructor(t, e = !1) {
    this.reverse = !1, this.isObservePending = !1, t.addController(this), this.host = t, this.reverse = e;
  }
  observe(t, e) {
    t && e && !t.isLoading && !this.isObservePending && (this.isObservePending = !0, requestAnimationFrame(() => {
      this.loadMoreRefElement = e, this.scroller?.disconnect(), this.scroller = _0(
        e,
        async () => {
          t.hasNextPage && !t.isFetching && (await t.fetchNextPage({ cancelRefetch: !1 }), this.reverse && await this.host.updateComplete);
        },
        this.reverse
      ), this.isObservePending = !1;
    }));
  }
  hostConnected() {
    this.loadMoreRefElement && this.scroller?.observe(this.loadMoreRefElement);
  }
  hostDisconnected() {
    this.scroller?.disconnect();
  }
};
a(tw, "InfiniteScrollController");
let Gi = tw;
const ew = class ew extends Gi {
  constructor(t) {
    super(t, !0);
  }
};
a(ew, "ReverseInfiniteScrollController");
let Cu = ew;
var qi, hs;
const iw = class iw {
  constructor(t) {
    O(this, qi);
    O(this, hs);
    if (P(this, qi, /* @__PURE__ */ new Map()), this.keyPrefix = "WEAVY_OFFLINE_CACHE", t)
      P(this, hs, t);
    else
      try {
        we(), P(this, hs, window.sessionStorage);
      } catch {
        console.warn("Session storage not available.");
      }
  }
  resetPersistPropertiesCache() {
    y(this, qi).clear();
  }
  getStorageItem(t, e) {
    const r = y(this, hs)?.getItem(`${t}-${e.toString()}`);
    if (r)
      return JSON.parse(r);
  }
  setStorageItem(t, e, r) {
    const s = JSON.stringify(r);
    s && y(this, hs)?.setItem(`${t}-${e.toString()}`, s);
  }
  persistProperties(t, e, r, s, n) {
    const o = `${this.keyPrefix}:${s ? `${s}:` : ""}${typeof t}:${e}`, c = /* @__PURE__ */ new Map();
    for (const l of r) {
      if (!y(this, qi).has(l.name)) {
        const u = this.getStorageItem(o, l.name);
        u && (l.override || !t[l.name]) && (c.set(l.name, t[l.name]), t[l.name] = u), y(this, qi).set(l.name, u);
      }
      if (n?.(c), t[l.name] !== y(this, qi).get(l.name)) {
        const u = t[l.name];
        y(this, qi).set(l.name, u), this.setStorageItem(o, l.name, u);
      }
    }
  }
};
qi = new WeakMap(), hs = new WeakMap(), a(iw, "PersistStorageCache");
let ku = iw;
var ps, pa;
const rw = class rw {
  constructor(t) {
    O(this, ps);
    O(this, pa);
    P(this, ps, ""), this.properties = [], this.initialProperties = /* @__PURE__ */ new Map(), this.persistStorageCache = new ku(), t.addController(this), this.host = t;
  }
  get prefixKey() {
    return y(this, ps);
  }
  set prefixKey(t) {
    t !== y(this, ps) && (this.persistStorageCache.resetPersistPropertiesCache(), P(this, ps, t), this.host.requestUpdate());
  }
  get cachePrefix() {
    return y(this, pa);
  }
  set cachePrefix(t) {
    t !== y(this, pa) && (this.persistStorageCache.resetPersistPropertiesCache(), P(this, pa, t), this.host.requestUpdate());
  }
  observe(t, e, r, s) {
    this.properties = t, this.callback = s;
    const n = !!(this.prefixKey && this.prefixKey !== e || this.cachePrefix && this.cachePrefix !== r);
    this.properties.forEach((o) => {
      n && this.initialProperties.has(o.name) ? this.host[o.name] = this.initialProperties.get(o.name) : this.initialProperties.has(o.name) || this.initialProperties.set(o.name, this.host[o.name]);
    }), e && (this.prefixKey = e), r && (this.cachePrefix = r);
  }
  hostUpdate() {
    this.prefixKey && this.properties && this.host.weavy && this.persistStorageCache.persistProperties(this.host, this.prefixKey, this.properties, this.cachePrefix ? `${this.host.weavy.cachePrefix}:${this.cachePrefix}` : this.host.weavy.cachePrefix, this.callback);
  }
};
ps = new WeakMap(), pa = new WeakMap(), a(rw, "PersistStateController");
let vs = rw;
const sw = class sw {
  constructor(t) {
    this.observers = [], this.conditions = {}, this.resizer = new ResizeObserver((e) => {
      let r = !1;
      for (const s of e)
        r = this.checkConditions(s) || r;
      r && this.host.requestUpdate();
    }), t.addController(this), this.host = t;
  }
  checkConditions(t) {
    let e = !1;
    return this.observers.forEach((r) => {
      if (t.target === r.target) {
        const s = this.conditions[r.name], n = r.condition(t);
        s !== n && (this.conditions[r.name] = n, e = !0);
      }
    }), e;
  }
  observe(t) {
    const e = t.target, r = e.getBoundingClientRect();
    this.observers.push(t), this.resizer.observe(e), this.checkConditions({
      contentBoxSize: [
        {
          inlineSize: e.clientWidth,
          blockSize: e.clientHeight
        }
      ],
      borderBoxSize: [
        {
          inlineSize: r.width,
          blockSize: r.height
        }
      ],
      devicePixelContentBoxSize: [
        {
          inlineSize: r.width * window.devicePixelRatio,
          blockSize: r.height * window.devicePixelRatio
        }
      ],
      contentRect: r,
      target: e
    });
  }
  reset() {
    this.conditions = {}, this.observers.length = 0, this.resizer.disconnect();
  }
  hostConnected() {
    this.observers.forEach((t) => {
      this.resizer.observe(t.target);
    });
  }
  hostDisconnected() {
    this.resizer.disconnect();
  }
};
a(sw, "ResizeController");
let Bw = sw;
const nw = class nw {
  constructor(t, e) {
    this.additionalTargets = /* @__PURE__ */ new Set(), this.setExportParts = (r) => {
      (!this.host.hasAttribute("exportparts") || this.shadowParts) && (this.shadowParts ??= /* @__PURE__ */ new Set(), r.forEach((s) => {
        s.part.forEach((n) => this.shadowParts?.add(n)), s.getAttribute("exportparts")?.split(", ").forEach((n) => this.shadowParts?.add(n));
      }), this.shadowParts.size && this.host.setAttribute("exportparts", Array.from(this.shadowParts.values()).join(", ")));
    }, t.addController(this), this.host = t, this.addLocalName = e;
  }
  addPartsFrom(t) {
    t && !this.additionalTargets.has(t) && (this.setExportParts([t]), this.observer?.observe(t, {
      attributeFilter: ["part", "exportparts"]
    }), this.additionalTargets.add(t));
  }
  async hostConnected() {
    if (await this.host.updateComplete, $w(this.host) && this.host.shadowRoot) {
      const t = Array.from(this.host.shadowRoot.querySelectorAll("[part], [exportparts]"));
      this.setExportParts(t), this.observer = new MutationObserver((e) => {
        const r = e.flatMap((s) => s.type === "attributes" ? [s.target] : Array.from(s.addedNodes)).filter((s) => s instanceof Element);
        this.setExportParts(r);
      }), this.observer.observe(this.host.shadowRoot, {
        subtree: !0,
        childList: !0,
        attributeFilter: ["part", "exportparts"]
      }), Array.from(this.additionalTargets).forEach((e) => {
        this.observer?.observe(e, {
          attributeFilter: ["part", "exportparts"]
        });
      });
    }
  }
  hostUpdated() {
    $w(this.host) && this.addLocalName !== !1 && !this.host.part.contains(this.host.localName) && (this.addLocalName || getComputedStyle(this.host).display !== "contents") && this.host.part.add(this.host.localName);
  }
  hostDisconnected() {
    this.observer?.disconnect();
  }
};
a(nw, "ShadowPartsController");
let U = nw;
const aw = class aw {
  constructor(t) {
    this.delay = NaN, this.sleep = !1, t.addController(this), this.host = t;
  }
  createObserver(t) {
    this.scrollObserver?.disconnect(), this.swipeElement = t, this.scrollObserver = new IntersectionObserver(
      (e) => {
        e.forEach(async (r) => {
          r.isIntersecting && !this.sleep && r.intersectionRatio >= 1 && (this.sleep = !0, Number.isNaN(this.delay) || await new Promise((s) => {
            setTimeout(s, this.delay);
          }), r.target === this.prevElement && this.whenPrev && await this.whenPrev(), r.target === this.nextElement && this.whenNext && await this.whenNext(), await this.host.updateComplete);
        });
      },
      { root: t, threshold: 1, rootMargin: "0px" }
    );
  }
  observe(t, e) {
    this.prevElement && (this.scrollObserver?.unobserve(this.prevElement), this.prevElement = void 0), this.nextElement && (this.scrollObserver?.unobserve(this.nextElement), this.nextElement = void 0), t && (this.scrollObserver?.observe(t), this.prevElement = t), e && (this.scrollObserver?.observe(e), this.nextElement = e), this.sleep = !1;
  }
  clearObserver() {
    this.prevElement = void 0, this.nextElement = void 0, this.scrollObserver?.disconnect(), this.sleep = !1;
  }
  hostConnected() {
    this.scrollObserver && (this.prevElement && this.scrollObserver.observe(this.prevElement), this.nextElement && this.scrollObserver.observe(this.nextElement), this.sleep = !1);
  }
  hostDisconnected() {
    this.scrollObserver?.disconnect();
  }
};
a(aw, "SwipeScrollController");
let _u = aw;
var ua, Kl;
const ow = class ow {
  constructor(t, e) {
    O(this, ua);
    O(this, Kl);
    P(this, ua, !0), this.styles = [], t.addController(this), this.host = t, e && (this.styles = e);
  }
  get themeColor() {
    return y(this, Kl);
  }
  set themeColor(t) {
    P(this, Kl, t), this.checkThemeUpdate();
  }
  checkThemeUpdate() {
    const t = this.themeColor || lu(this.host) || du();
    if (t && t !== this._resolvedThemeColor) {
      this._resolvedThemeColor = t, console.info("Configuring theme", this._resolvedThemeColor);
      const e = Lg(this._resolvedThemeColor).join(""), r = B`
        :host {
          ${o1(e)};
        }
      `, s = this.host.renderRoot;
      c1(s, [...this.styles, r]);
    }
  }
  hostUpdate() {
    y(this, ua) && (this.checkThemeUpdate(), P(this, ua, !1));
  }
  hostConnected() {
    this.cssObserverDisconnect = zg(this.host, () => this.checkThemeUpdate()), this.metaObserverDisconnect = Rg(() => this.checkThemeUpdate());
  }
  hostDisconnected() {
    this.cssObserverDisconnect?.(), this.metaObserverDisconnect?.();
  }
};
ua = new WeakMap(), Kl = new WeakMap(), a(ow, "ThemeController");
let Te = ow;
const cw = class cw {
  constructor(t) {
    this.registrationRequested = !1, this.typingTimeout = null, this.discardTime = 5 * 1e3, this.typingMembers = [], this.names = [], this.ellipsis = "", this.handleRealtimeTyping = (e) => {
      e.entity.id === this.appId && e.actor.id !== this.userId && (this.setTypers(e.actor), this.updateTyping());
    }, this.handleRealtimeStopTyping = (e) => {
      this.typingMembers.forEach((r, s) => {
        r.id === e.actor.id && this.typingMembers.splice(s, 1);
      }), this.updateTyping();
    }, t.addController(this), this.host = t, this.setContexts();
  }
  get weavy() {
    return this.weavyContext?.value;
  }
  get componentFeatures() {
    return this._componentFeatures;
  }
  get appId() {
    return this._appId;
  }
  set appId(t) {
    t !== this._appId && (this.typingMembers = [], this.unregisterRealtime(), this._appId = t, this.registerRealtime());
  }
  get userId() {
    return this._userId;
  }
  set userId(t) {
    t !== this._userId && (this.typingMembers = [], this.unregisterRealtime(), this._userId = t, this.registerRealtime());
  }
  async setContexts() {
    this.whenWeavyContext = new Promise((t) => this.resolveWeavyContext = t), this.whenComponentFeaturesContext = new Promise((t) => this.resolveComponentFeaturesContext = t), await ar(this.host), this.weavyContext = new Je(this.host, { context: re, subscribe: !0 }), this.componentFeaturesContext = new Je(this.host, {
      context: ph,
      subscribe: !0
    });
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
    const t = this.componentFeaturesContext && this.componentFeaturesContext.value?.allowsFeature(M.Typing) !== this._componentFeatures?.allowsFeature(M.Typing);
    t && (this._componentFeatures = this.componentFeaturesContext?.value, this.componentFeaturesContext?.value && this.resolveComponentFeaturesContext?.(this.componentFeaturesContext.value), t && (this.unregisterRealtime(!0), this.registerRealtime()));
  }
  async registerRealtime() {
    !this.registrationRequested && this.appId && this._userId && (this.registrationRequested = !0, await Promise.all([this.whenWeavyContext, this.whenComponentFeaturesContext]), this.componentFeatures?.allowsFeature(M.Typing) && (this.weavy?.subscribe(`a${this.appId}`, "typing", this.handleRealtimeTyping), this.weavy?.subscribe(`a${this.appId}`, "message_created", this.handleRealtimeStopTyping)), this.registrationRequested = !1);
  }
  async unregisterRealtime(t = !1) {
    !this.registrationRequested && this.appId && this.userId && (!t && await this.whenWeavyContext, this.weavy?.unsubscribe(`a${this.appId}`, "typing", this.handleRealtimeTyping), this.weavy?.unsubscribe(`a${this.appId}`, "message_created", this.handleRealtimeStopTyping));
  }
  /**
   * @fires typing
   */
  updateTyping() {
    this.typingTimeout && (clearTimeout(this.typingTimeout), this.typingTimeout = null);
    const t = Date.now();
    if (this.typingMembers.forEach((r, s) => {
      t - r.time > this.discardTime && this.typingMembers.splice(s, 1);
    }), this.typingMembers.length) {
      const r = Date.now(), s = Math.round(
        (r - Math.max.apply(
          null,
          this.typingMembers.map((n) => n.time)
        )) / 1e3
      ) % 3 + 1;
      this.ellipsis = ".".repeat(s), this.names = this.typingMembers.map((n) => n.name).sort(), this.typingTimeout = window.setTimeout(() => this.updateTyping(), 1e3);
    } else
      this.names = [];
    this.host.requestUpdate();
    const e = new CustomEvent("typing", {
      bubbles: !0,
      composed: !1,
      detail: { count: this.typingMembers.length }
    });
    this.host.dispatchEvent(e);
  }
  setTypers(t) {
    this.typingMembers.forEach((r, s) => {
      r.id === t.id && this.typingMembers.splice(s, 1);
    });
    const e = { ...t, time: Date.now() };
    this.typingMembers.push(e);
  }
  hostDisconnected() {
    this.typingTimeout && (clearTimeout(this.typingTimeout), this.typingTimeout = null), this.typingMembers.length = 0, this.names.length = 0, this.weavy && this.unregisterRealtime(!0);
  }
};
a(cw, "TypingController");
let Qd = cw;
var ya;
const lw = class lw {
  constructor(t) {
    O(this, ya);
    this.appTypes = [], P(this, ya, 0), this.registrationRequested = !1, this.handleRefresh = () => {
      this.unreadQuery.result.refetch();
    }, t.addController(this), this.host = t, this.unreadQuery = new Ie(t), this.whenWeavyContext = new Promise((e) => this.resolveWeavyContext = e), this.setContexts(), this.registerRealtime();
  }
  /**
   * The number of unread items for the current scope
   */
  get unread() {
    return y(this, ya);
  }
  /**
   * Is the unread count pending?
   */
  get isUnreadPending() {
    return this.unreadQuery.result.isPending;
  }
  /**
   * The underlying query result for the unread count.
   */
  get unreadResult() {
    return this.unreadQuery.result;
  }
  get weavy() {
    return this.weavyContext?.value;
  }
  /**
   * Initiates context consumers
   */
  async setContexts() {
    await ar(this.host), this.weavyContext = new Je(this.host, { context: re, subscribe: !0 });
  }
  /**
   * Dispatch a `wy-unread` event on the host.
   *
   * @fires {WyUnreadEventType} wy-unread - Emitted when the number of unread items change.
   */
  dispatchUnreadEvent() {
    const t = new CustomEvent("wy-unread", {
      detail: { unread: this.unread },
      bubbles: !1,
      composed: !0
    });
    this.host.dispatchEvent(t);
  }
  /**
   * Register realtime handlers.
   */
  async registerRealtime() {
    this.registrationRequested || (this.registrationRequested = !0, await this.whenWeavyContext, this.weavy?.subscribe(null, "message_created", this.handleRefresh), this.weavy?.subscribe(null, "app_marked", this.handleRefresh), this.registrationRequested = !1);
  }
  /**
   * Unregister realtime handlers.
   *
   * @param skipAwait - Skip waiting for any context.
   */
  async unregisterRealtime(t = !1) {
    this.registrationRequested || (!t && await this.whenWeavyContext, this.weavy?.unsubscribe(null, "message_created", this.handleRefresh), this.weavy?.unsubscribe(null, "app_marked", this.handleRefresh));
  }
  async track(t, e) {
    this.appTypes = t, this.agent = e;
    const r = await this.whenWeavyContext;
    await this.unreadQuery.trackQuery(f0(r, t, this.agent), !0);
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
    const t = this.unreadQuery.result?.data?.count ?? 0;
    t !== this.unread && (P(this, ya, t), this.dispatchUnreadEvent(), this.host.requestUpdate());
  }
  hostDisconnected() {
    this.weavy && this.unregisterRealtime(!0);
  }
};
ya = new WeakMap(), a(lw, "UnreadConversationsController");
let mc = lw;
var bt = /* @__PURE__ */ ((i) => (i.All = "", i.Activity = "activity", i.Mention = "mention", i.Reaction = "reaction", i))(bt || {});
function P0(i, t, e = {}, r) {
  if (i) {
    if (i = JSON.parse(JSON.stringify(i)), i?.pages) {
      let s = -1;
      return {
        pages: [...i.pages.map((o, c) => {
          if (s >= 0)
            return o;
          const l = o.data || [], u = l.filter(
            (f) => f.id !== t.id && !0
          );
          return e && e.by ? (s = u.findIndex((f) => {
            let $ = e.by && f[e.by], m = e.by && t[e.by];
            if (e.by === "updated_at" && ($ ??= f.created_at, m ??= t.created_at), typeof $ == "string" && typeof m == "string") {
              const x = $.localeCompare(m, void 0, {
                sensitivity: "base",
                numeric: !0
              });
              return e.descending ? x < 0 : x > 0;
            }
            return $ && m && (e.descending ? $ < m : $ > m);
          }), s >= 0 ? (u.splice(s, 0, t), o.data = [...u], o.end && (o.end += 1 + u.length - l.length)) : i && c == i.pages.length - 1 && o.end === o.count ? (o.data = [...u, t], o.end && (o.end += 1 + u.length - l.length)) : o.data = [...u]) : c === 0 && (e.descending ? o.data = [t, ...u] : o.data = [...u, t], o.end && (o.end += 1 + u.length - l.length)), o;
        }) ?? []],
        pageParams: [...i.pageParams]
      };
    } else if (i?.data?.length) {
      let s = -1;
      const n = [
        ...i.data?.filter(
          (c) => c.id !== t.id && !0
        ) || []
      ];
      let o = i.count;
      return e && e.by ? (s = n.findIndex((c) => {
        let l = c[e.by], u = t[e.by];
        if (e.by === "updated_at" && (l ??= c.created_at, u ??= t.created_at), typeof l == "string" && typeof u == "string") {
          const f = l.localeCompare(u, void 0, {
            sensitivity: "base",
            numeric: !0
          });
          return e.descending ? f < 0 : f > 0;
        }
        return l && u && (e.descending ? l < u : l > u);
      }), s >= 0 ? n.splice(s, 0, t) : (n.push(t), o++)) : (e.descending ? n.unshift(t) : n.push(t), o++), {
        data: n,
        count: o
      };
    }
  }
  return i;
}
a(P0, "addToQueryData");
function Mm(i, t, e) {
  const r = t === void 0 ? () => !0 : t instanceof Function ? t : (s) => s.id === t;
  return i && (i = JSON.parse(JSON.stringify(i)), i.pages ? {
    pages: i.pages.map((n) => (n.data && (n.data = [
      ...n.data.map((o) => (r(o) && (o = { ...o }, e(o)), o))
    ]), n)) ?? [],
    pageParams: i.pageParams
  } : i.data?.length ? {
    ...i,
    data: [
      ...i.data?.map((s) => (r(s) && (s = { ...s }, e(s)), s)) || []
    ]
  } : i.data ? {
    data: [
      ...i.data.map((n) => (r(n) && (n = { ...n }, e(n)), n))
    ],
    count: i.count
  } : i);
}
a(Mm, "updateQueryData");
function Sm(i, t) {
  if (t !== void 0) {
    const e = t instanceof Function ? t : (r) => r.id === t;
    if (i) {
      if (i = JSON.parse(JSON.stringify(i)), i.pages)
        return {
          pages: i.pages.map((s) => (s.data && (s.data = [...s.data.filter((n) => !e(n))]), s)) ?? [],
          pageParams: i.pageParams
        };
      if (i.data?.length) {
        const r = i.data?.length;
        let s = i.count;
        const n = [...i.data?.filter((o) => !e(o)) || []];
        return r !== n.length && s--, {
          data: n,
          count: s
        };
      }
    }
  }
  return i;
}
a(Sm, "removeQueryData");
const Ar = /* @__PURE__ */ a((i, t, e, r) => i.setQueryData(t, (s) => P0(s, e, r)), "addCacheItem"), qt = /* @__PURE__ */ a((i, t, e, r) => i.setQueryData(t, (s) => Mm(
  s,
  e,
  r
)), "updateCacheItem"), ct = /* @__PURE__ */ a((i, t, e, r) => {
  i.setQueriesData(t, (s) => Mm(
    s,
    e,
    r
  ));
}, "updateCacheItems"), fh = /* @__PURE__ */ a((i, t, e) => i.setQueryData(t, (r) => Sm(
  r,
  e
)), "removeCacheItem"), M0 = /* @__PURE__ */ a((i, t, e) => {
  i.setQueriesData(t, (r) => Sm(r, e));
}, "removeCacheItems"), pl = /* @__PURE__ */ a((i, t, e) => {
  i.setQueriesData(t, (r) => {
    const { count: s } = r;
    return { count: e(s) };
  });
}, "updateCacheItemsCount");
function Ep(i, t, e, r = 1) {
  if (!i)
    return;
  const s = i.getQueryData(t);
  s?.pages?.length && s.pages.length > 1 && i.setQueryData(
    t,
    (n) => ({
      pages: n.pages.slice(0, r),
      pageParams: n.pageParams.slice(0, r)
    }),
    e
  );
}
a(Ep, "keepPages");
function gs(i, t, e) {
  const r = i.getQueryCache().find({ queryKey: t });
  if (r && r.state.data) {
    const s = r.state.data.pages.flatMap((n) => n.data).filter((n) => n && n.id < 0).sort((n, o) => n && o ? n.id - o.id : 0);
    return s.length ? e ? s[s.length - 1] : s[0] : null;
  }
  return null;
}
a(gs, "getPendingCacheItem");
function mh(i, t, e) {
  const r = i.getQueryCache().find({ queryKey: t });
  return r && r.state.data ? r.state.data.pages.flatMap((s) => s.data).find((s) => s?.id === e) : null;
}
a(mh, "getCacheItem");
function Zi(i) {
  return (i?.pages.flatMap((t) => t.data) || []).filter((t) => t);
}
a(Zi, "getFlatInfiniteResultData");
function qw(i) {
  return !i || !i?.pages.some((t) => t.data?.length);
}
a(qw, "isInfiniteResultDataEmpty");
function S0(i, t = bt.All, e, r = {}) {
  return {
    ...r,
    initialPageParam: 0,
    queryKey: ["notifications", "list", e, t],
    queryFn: /* @__PURE__ */ a(async (s) => {
      const n = new URLSearchParams({
        skip: s.pageParam?.toString() || "0",
        type: t
      }), o = `/api/${e ? `apps/${e.toString()}/` : ""}notifications?${n.toString()}`, l = await (await i.fetch(o)).json();
      return l.data = l.data || [], l;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ a((s) => {
      if (s.end && s.end < s.count)
        return s.end;
    }, "getNextPageParam")
  };
}
a(S0, "getNotificationsOptions");
function A0(i, t = bt.All, e) {
  const r = i.queryClient.getQueryData(["notifications", "list", e, t])?.pages.flatMap((n) => n.data);
  let s;
  return r?.forEach((n) => {
    s = s && n && s.id > n.id ? s : n;
  }), s;
}
a(A0, "getLastNotification");
function z0(i, t) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ notificationId: r }) => {
      const s = new URL(`/api/${t ? `apps/${t.toString()}/` : ""}notifications/mark`, i.url);
      r && s.searchParams.append("id", r.toString()), await i.fetch(s, { method: "PUT" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((r) => {
      const s = [];
      return ct(
        i.queryClient,
        { queryKey: t ? ["notifications", "list", t] : ["notifications", "list"], exact: !1 },
        void 0,
        (n) => {
          s.push({ id: n.id, is_unread: n.is_unread }), n.is_unread = !1;
        }
      ), t && s.length && ct(
        i.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        (n) => !!s.find((o) => o.id === n.id && n.is_unread),
        (n) => {
          n.is_unread = !1;
        }
      ), t || pl(
        i.queryClient,
        { queryKey: ["notifications", "unread"], exact: !1 },
        () => 0
      ), pl(
        i.queryClient,
        {
          queryKey: t ? ["apps", "notifications", "unread", t] : ["apps", "notifications", "unread"],
          exact: !1
        },
        () => 0
      ), { changedNotifications: s };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a(async () => {
      t && await i.queryClient.invalidateQueries({ queryKey: ["notifications", "unread"], exact: !1 });
    }, "onSuccess"),
    onSettled: /* @__PURE__ */ a(async () => {
      await i.queryClient.invalidateQueries({ queryKey: ["notifications", "list"], exact: !1 }), await i.queryClient.invalidateQueries({ queryKey: ["notifications", "unread"], exact: !1 }), await i.queryClient.invalidateQueries({ queryKey: ["apps", "notifications", "unread"], exact: !1 });
    }, "onSettled"),
    onError: /* @__PURE__ */ a((r, s, n) => {
      console.error(r.message);
    }, "onError")
  };
}
a(z0, "getMarkNotificationsMutationOptions");
function R0(i, t) {
  return new $t(i.queryClient, z0(i, t));
}
a(R0, "getMarkNotificationsMutation");
function E0(i) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ markAsRead: e, notificationId: r }) => {
      const s = `/api/notifications/${r}/mark`;
      await i.fetch(s, { method: e ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((e) => {
      const r = /* @__PURE__ */ new Map();
      ct(
        i.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        e.notificationId,
        (s) => {
          !!s.is_unread === e.markAsRead && r.set(s.id, s), s.is_unread = !e.markAsRead;
        }
      ), r.size && (pl(
        i.queryClient,
        {
          queryKey: ["notifications", "unread"],
          predicate: /* @__PURE__ */ a((s) => s.queryKey[3] === "" || s.queryKey[3] === r.values().next().value?.type, "predicate"),
          exact: !1
        },
        (s) => Math.max(0, s + (e.markAsRead ? -1 : 1))
      ), r.forEach((s) => {
        s.link?.app && pl(
          i.queryClient,
          {
            queryKey: ["apps", "notifications", "unread"],
            predicate: /* @__PURE__ */ a((n) => {
              const o = n.queryKey[3] === s.link?.app?.id || n.queryKey[3] === s.link?.app?.uid, c = n.queryKey[4] === "" || n.queryKey[4] === s.type;
              return o && c;
            }, "predicate"),
            exact: !1
          },
          (n) => Math.max(0, n + (e.markAsRead ? -1 : 1))
        );
      }));
    }, "onMutate"),
    onError: /* @__PURE__ */ a(async (e, r) => {
      ct(
        i.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        r.notificationId,
        (s) => {
          s.is_unread = r.markAsRead;
        }
      ), await i.queryClient.invalidateQueries({ queryKey: ["notifications", "unread"], exact: !1 }), await i.queryClient.invalidateQueries({ queryKey: ["apps", "notifications", "unread"], exact: !1 });
    }, "onError")
  };
}
a(E0, "getMarkNotificationMutationOptions");
function Am(i) {
  return new $t(i.queryClient, E0(i));
}
a(Am, "getMarkNotificationMutation");
function L0(i, t = bt.All, e, r = {}) {
  const s = new URLSearchParams({
    type: t,
    count_only: "true",
    unread: "true"
  }), n = `/api/${e ? `apps/${e.toString()}/` : ""}notifications?${s.toString()}`;
  return sd(i, e ? ["apps", "notifications", "unread", e, t] : ["notifications", "unread", t], n, r);
}
a(L0, "getUnreadOptions");
var wa;
const dw = class dw {
  constructor(t) {
    O(this, wa);
    this.typeFilter = bt.All, P(this, wa, 0), this.registrationRequested = !1, this.handleRefresh = () => {
      this.unreadQuery.result.refetch();
    }, t.addController(this), this.host = t, this.unreadQuery = new Ie(t), this.whenWeavyContext = new Promise((e) => this.resolveWeavyContext = e), this.setContexts(), this.registerRealtime();
  }
  /**
   * The number of unread notifications for the current scope
   */
  get unread() {
    return y(this, wa);
  }
  /**
   * Is the unread count pending?
   */
  get isUnreadPending() {
    return this.unreadQuery.result.isPending;
  }
  /**
   * The underlying query result for the unread count.
   */
  get unreadResult() {
    return this.unreadQuery.result;
  }
  get weavy() {
    return this.weavyContext?.value;
  }
  /**
   * Initiates context consumers
   */
  async setContexts() {
    await ar(this.host), this.weavyContext = new Je(this.host, { context: re, subscribe: !0 });
  }
  /**
   * Dispatch a `wy-unread` event on the host.
   *
   * @fires {WyUnreadEventType} wy-unread - Emitted when the number of unread notifications change.
   */
  dispatchNotificationUnreadEvent() {
    const t = new CustomEvent("wy-unread", {
      detail: { unread: this.unread },
      bubbles: !1,
      composed: !0
    });
    this.host.dispatchEvent(t);
  }
  /**
   * Register realtime handlers.
   */
  async registerRealtime() {
    this.registrationRequested || (this.registrationRequested = !0, await this.whenWeavyContext, this.weavy?.subscribe(null, "notification_created", this.handleRefresh), this.weavy?.subscribe(null, "notification_updated", this.handleRefresh), this.weavy?.subscribe(null, "notifications_marked", this.handleRefresh), this.registrationRequested = !1);
  }
  /**
   * Unregister realtime handlers.
   *
   * @param skipAwait - Skip waiting for any context.
   */
  async unregisterRealtime(t = !1) {
    this.registrationRequested || (!t && await this.whenWeavyContext, this.weavy?.unsubscribe(null, "notification_created", this.handleRefresh), this.weavy?.unsubscribe(null, "notification_updated", this.handleRefresh), this.weavy?.unsubscribe(null, "notifications_marked", this.handleRefresh));
  }
  /**
   * Tracks unread data. Initiates the query data with the given filtering scope.
   *
   * @param typeFilter - The notification types to track.
   * @param appId - Optional app id for the filtering scope.
   */
  async track(t, e) {
    this.appId = e, this.typeFilter = t;
    const r = await this.whenWeavyContext;
    this.markNotificationsMutation = R0(r, this.appId), await this.unreadQuery.trackQuery(L0(r, this.typeFilter, this.appId), !0);
  }
  async markAllAsRead() {
    const t = await this.whenWeavyContext, e = A0(t, bt.All, this.appId)?.id;
    await this.markNotificationsMutation?.mutate({ notificationId: e });
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
    const t = this.unreadQuery.result?.data?.count ?? 0;
    t !== this.unread && (P(this, wa, t), this.dispatchNotificationUnreadEvent(), this.host.requestUpdate());
  }
  hostDisconnected() {
    this.weavy && this.unregisterRealtime(!0);
  }
};
wa = new WeakMap(), a(dw, "UnreadNotificationsController");
let ul = dw;
var O0 = Object.defineProperty, zm = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = void 0, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = o(t, e, s) || s);
  return s && O0(t, e, s), s;
}, "__decorateClass$1g");
const hw = class hw extends xe {
  constructor() {
    super(...arguments), this.appType = Mr;
  }
};
a(hw, "WeavyOptionalAppComponent");
let zr = hw;
zm([
  F()
], zr.prototype, "appType");
zm([
  p({ converter: mm })
], zr.prototype, "uid");
var I0 = Object.defineProperty, ey = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = void 0, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = o(t, e, s) || s);
  return s && I0(t, e, s), s;
}, "__decorateClass$1f"), fa, Gl, ma, Zl, va, Yl;
const pw = class pw extends X {
  constructor() {
    super(...arguments);
    O(this, fa);
    O(this, Gl, new Promise((e) => {
      P(this, fa, e);
    }));
    O(this, ma);
    O(this, Zl, new Promise((e) => {
      P(this, ma, e);
    }));
    O(this, va);
    O(this, Yl, new Promise((e) => {
      P(this, va, e);
    }));
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  /**
   * Resolves when a contextual id is available.
   *
   * @internal
   * @returns {Promise<ContextIdType>}
   */
  async whenContextId() {
    return await y(this, Gl);
  }
  /**
   * Resolves when current user data is available.
   *
   * @internal
   * @returns {Promise<UserType>}
   */
  async whenUser() {
    return await y(this, Zl);
  }
  /**
   * Resolves when a weavy context is available.
   *
   * @internal
   * @returns {Promise<WeavyType>}
   */
  async whenWeavy() {
    return await y(this, Yl);
  }
  willUpdate(e) {
    var r, s, n;
    super.willUpdate(e), e.has("contextId") && this.contextId && (e.get("contextId") && P(this, Gl, new Promise((o) => {
      P(this, fa, o);
    })), (r = y(this, fa)) == null || r.call(this, this.contextId)), e.has("user") && this.user && (e.get("user") && P(this, Zl, new Promise((o) => {
      P(this, ma, o);
    })), (s = y(this, ma)) == null || s.call(this, this.user)), e.has("weavy") && this.weavy && (e.get("weavy") && P(this, Yl, new Promise((o) => {
      P(this, va, o);
    })), (n = y(this, va)) == null || n.call(this, this.weavy));
  }
  connectedCallback() {
    super.connectedCallback(), this.contextId && this.requestUpdate("contextId"), this.user && this.requestUpdate("user"), this.weavy && this.requestUpdate("weavy");
  }
};
fa = new WeakMap(), Gl = new WeakMap(), ma = new WeakMap(), Zl = new WeakMap(), va = new WeakMap(), Yl = new WeakMap(), a(pw, "WeavySubComponent");
let $e = pw;
ey([
  he({ context: om, subscribe: !0 }),
  F()
], $e.prototype, "contextId");
ey([
  he({ context: uh, subscribe: !0 }),
  F()
], $e.prototype, "user");
ey([
  he({ context: re, subscribe: !0 }),
  F()
], $e.prototype, "weavy");
var T0 = Object.defineProperty, ad = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = void 0, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = o(t, e, s) || s);
  return s && T0(t, e, s), s;
}, "__decorateClass$1e"), ga, Xl, ba, Jl, xa, td, $a, ed, Ca, id;
const uw = class uw extends $e {
  constructor() {
    super(...arguments);
    O(this, ga);
    O(this, Xl, new Promise((e) => {
      P(this, ga, e);
    }));
    O(this, ba);
    O(this, Jl, new Promise((e) => {
      P(this, ba, e);
    }));
    O(this, xa);
    O(this, td, new Promise((e) => {
      P(this, xa, e);
    }));
    O(this, $a);
    O(this, ed, new Promise((e) => {
      P(this, $a, e);
    }));
    O(this, Ca);
    O(this, id, new Promise((e) => {
      P(this, Ca, e);
    }));
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  /**
   * Resolves when app data is available.
   *
   * @returns {Promise<AppType>}
   */
  async whenApp() {
    return await y(this, Xl);
  }
  // #resolveAgentUser?: (agentUser: AgentType) => void;
  // #whenAgentUser = new Promise<AgentType>((r) => {
  //   this.#resolveAgentUser = r;
  // });
  // async whenAgentUser() {
  //   return await this.#whenAgentUser;
  // }
  /**
   * Resolves when context data blob uploads has finished.
   *
   * @internal
   * @returns {Promise<ContextDataBlobsType>}
   */
  async whenContextDataBlobs() {
    return await y(this, Jl);
  }
  /**
   * Resolves when weavy component features config is available.
   *
   * @internal
   * @returns {Promise<ComponentFeaturePolicy>}
   */
  async whenComponentFeatures() {
    return await y(this, td);
  }
  /**
   * Resolves when a provided link is available.
   *
   * @returns {Promise<LinkType>}
   */
  async whenLink() {
    return await y(this, ed);
  }
  /**
   * Resolves when weavy component settings are available.
   *
   * @internal
   * @returns {Promise<WeavyComponentSettingsType>}
   */
  async whenSettings() {
    return await y(this, id);
  }
  willUpdate(e) {
    var r, s, n, o, c;
    super.willUpdate(e), e.has("app") && this.app && (e.get("app") && P(this, Xl, new Promise((l) => {
      P(this, ga, l);
    })), (r = y(this, ga)) == null || r.call(this, this.app)), e.has("contextDataBlobs") && this.contextDataBlobs && (e.get("contextDataBlobs") && P(this, Jl, new Promise((l) => {
      P(this, ba, l);
    })), (s = y(this, ba)) == null || s.call(this, this.contextDataBlobs)), e.has("componentFeatures") && this.componentFeatures && (e.get("componentFeatures") && P(this, td, new Promise((l) => {
      P(this, xa, l);
    })), (n = y(this, xa)) == null || n.call(this, this.componentFeatures)), e.has("link") && this.link && (e.get("link") && P(this, ed, new Promise((l) => {
      P(this, $a, l);
    })), (o = y(this, $a)) == null || o.call(this, this.link)), e.has("settings") && this.settings && (e.get("settings") && P(this, id, new Promise((l) => {
      P(this, Ca, l);
    })), (c = y(this, Ca)) == null || c.call(this, this.settings));
  }
  connectedCallback() {
    super.connectedCallback(), this.app && this.requestUpdate("app"), this.contextDataBlobs && this.requestUpdate("contextDataBlobs"), this.componentFeatures && this.requestUpdate("componentFeatures"), this.link && this.requestUpdate("link"), this.settings && this.requestUpdate("settings");
  }
};
ga = new WeakMap(), Xl = new WeakMap(), ba = new WeakMap(), Jl = new WeakMap(), xa = new WeakMap(), td = new WeakMap(), $a = new WeakMap(), ed = new WeakMap(), Ca = new WeakMap(), id = new WeakMap(), a(uw, "WeavySubAppComponent");
let Rt = uw;
ad([
  he({ context: Qu, subscribe: !0 }),
  F()
], Rt.prototype, "app");
ad([
  he({ context: cm, subscribe: !0 }),
  F()
], Rt.prototype, "contextDataBlobs");
ad([
  he({ context: ph, subscribe: !0 }),
  F()
], Rt.prototype, "componentFeatures");
ad([
  he({ context: dm, subscribe: !0 }),
  F()
], Rt.prototype, "link");
ad([
  he({ context: hm, subscribe: !0 }),
  F()
], Rt.prototype, "settings");
function F0(i) {
  return typeof i == "string" && i ? i = eval?.(`"use strict";(${i})`) : i = void 0, i;
}
a(F0, "indirectEvalObject");
function iy(i) {
  if (i)
    try {
      return new URL(i, window.location.toString());
    } catch {
      console.warn("Invalid url: ", i);
    }
}
a(iy, "toUrl");
const H = /* @__PURE__ */ a((i) => (t, e) => {
  e !== void 0 ? e.addInitializer(() => {
    !customElements.get(i) && customElements.define(
      i,
      t
    );
  }) : !customElements.get(i) && customElements.define(i, t);
}, "customElement"), Z = B`:host{display:contents}`;
var D0 = Object.defineProperty, H0 = Object.getOwnPropertyDescriptor, se = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? H0(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && D0(t, e, s), s;
}, "__decorateClass$1d");
function Nw(i) {
  return i != null && i !== !1;
}
a(Nw, "acceptedValue");
var ka;
let Nt = (ka = class extends X {
  constructor() {
    super(), this.provider = !1, this.annotations = Bt.defaults.annotations, this.cloudFilePickerUrl = Bt.defaults.cloudFilePickerUrl, this.configurationTimeout = Bt.defaults.configurationTimeout, this.disableEnvironmentImports = Bt.defaults.disableEnvironmentImports, this.enterToSend = Bt.defaults.enterToSend, this.locale = Bt.defaults.locale, this.locales = Bt.defaults.locales, this.gcTime = Bt.defaults.gcTime, this.scrollBehavior = Bt.defaults.scrollBehavior, this.staleTime = Bt.defaults.staleTime, this.tokenFactory = Bt.defaults.tokenFactory, this.tokenFactoryRetryDelay = Bt.defaults.tokenFactoryRetryDelay, this.tokenFactoryTimeout = Bt.defaults.tokenFactoryTimeout, this.tokenUrl = Bt.defaults.tokenUrl, this.url = Bt.defaults.url, this.reactions = Bt.defaults.reactions, this.childElementCount && (this.provider = !0), this.weavy ??= new Bt({ host: this.provider ? this : void 0 });
  }
  /** The semver version of the package. */
  get version() {
    return Bt.version;
  }
  /** The Weavy source name; package name. */
  get sourceName() {
    return Bt.sourceName;
  }
  willUpdate(t) {
    if (super.willUpdate(t), this.weavy) {
      const e = {};
      Array.from(t.keys()).forEach((r) => {
        r !== "weavy" && (Nw(this[r]) || Nw(t.get(r))) && Object.assign(e, { [r]: this[r] });
      }), Object.assign(this.weavy, e);
    }
  }
  render() {
    return h` <slot></slot> `;
  }
}, a(ka, "WyContext"), ka);
Nt.styles = [Yt, Z];
se([
  p({ attribute: !0, type: Boolean })
], Nt.prototype, "provider", 2);
se([
  p()
], Nt.prototype, "annotations", 2);
se([
  p({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ a((i) => iy(i), "fromAttribute")
    }
  })
], Nt.prototype, "cloudFilePickerUrl", 2);
se([
  p({ type: Number, attribute: !0 })
], Nt.prototype, "configurationTimeout", 2);
se([
  p({ type: Boolean })
], Nt.prototype, "disableEnvironmentImports", 2);
se([
  p({ attribute: !0 })
], Nt.prototype, "enterToSend", 2);
se([
  p({ attribute: !0 })
], Nt.prototype, "locale", 2);
se([
  p({ attribute: !0, type: Array })
], Nt.prototype, "locales", 2);
se([
  p({ attribute: !0, type: Number })
], Nt.prototype, "gcTime", 2);
se([
  p({ attribute: !0 })
], Nt.prototype, "scrollBehavior", 2);
se([
  p({ attribute: !0, type: Number })
], Nt.prototype, "staleTime", 2);
se([
  p({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ a((i) => F0(i), "fromAttribute")
    }
  })
], Nt.prototype, "tokenFactory", 2);
se([
  p({ attribute: !0, type: Number })
], Nt.prototype, "tokenFactoryRetryDelay", 2);
se([
  p({ attribute: !0, type: Number })
], Nt.prototype, "tokenFactoryTimeout", 2);
se([
  p({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ a((i) => iy(i), "fromAttribute")
    }
  })
], Nt.prototype, "tokenUrl", 2);
se([
  p({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ a((i) => iy(i), "fromAttribute")
    }
  })
], Nt.prototype, "url", 2);
se([
  p({ attribute: !0 })
], Nt.prototype, "reactions", 2);
se([
  F()
], Nt.prototype, "weavy", 2);
Nt = se([
  H("wy-context")
], Nt);
const Se = B`:host{font-family:var(--wy-font-family, unset)}`;
var V0 = Object.defineProperty, U0 = Object.getOwnPropertyDescriptor, ry = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? U0(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && V0(t, e, s), s;
}, "__decorateClass$1c"), _a;
let vc = (_a = class extends xe {
  constructor() {
    super(...arguments), this.appType = Mr, this.componentFeatures = new ee(Ku(yu)), this.theme = new Te(this, vc.styles);
  }
  render() {
    return h`<slot></slot>`;
  }
}, a(_a, "WyComponent"), _a);
vc.styles = [Yt, Z, Se];
ry([
  p({
    converter: {
      fromAttribute(i, t) {
        return d0.get(i) ?? i;
      }
    }
  })
], vc.prototype, "appType", 2);
ry([
  p({
    converter: {
      fromAttribute(i, t) {
        const e = typeof i == "string" ? lm(i, yu) : yu;
        return new ee(Ku(e));
      }
    }
  })
], vc.prototype, "componentFeatures", 2);
vc = ry([
  H("wy-component")
], vc);
const Ri = B`:host{position:relative;display:flex;flex-direction:column;flex:1;min-height:3rem;min-width:16rem;isolation:isolate;box-sizing:border-box;container-type:inline-size}`, Vs = B`:host{padding:var(--wy-padding-outer, var(--wy-padding, 0));border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}`, Us = B`:host{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}:host:not(body){-webkit-overflow-scrolling:touch}`;
function B0(i, t, e = {}) {
  return {
    ...e,
    initialPageParam: 0,
    queryKey: ["messages", t],
    queryFn: /* @__PURE__ */ a(async (r) => {
      const s = r.pageParam, n = "/api/apps/" + t + "/messages?order_by=id+desc&skip=" + s, c = await (await i.fetch(n)).json();
      return c.data = c.data?.reverse() || [], c;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ a((r) => {
      if (r?.end && r?.end < r?.count)
        return r.end;
    }, "getNextPageParam"),
    select: /* @__PURE__ */ a((r) => ({
      // reverse scroll
      pages: [...r.pages].reverse(),
      pageParams: [...r.pageParams].reverse()
    }), "select")
  };
}
a(B0, "getMessagesOptions");
function q0(i, t) {
  return {
    mutationFn: /* @__PURE__ */ a(async (r) => await (await i.fetch("/api/apps/" + r.app_id + "/messages", {
      method: "POST",
      body: JSON.stringify({
        text: r.text,
        blobs: r.blobs,
        embed_id: r.embed_id || null,
        meeting_id: r.meeting_id,
        options: r.poll_options.filter((n) => n.text.trim() !== "").map((n) => ({ text: n.text })),
        metadata: r.metadata || null,
        context: r.context
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ a((r) => {
      const s = ["messages", r.app_id], n = gs(i.queryClient, s, !1), o = {
        id: n ? n.id - 1 : -1,
        app: { id: r.app_id },
        text: r.text,
        html: r.text,
        plain: r.text,
        created_by: r.user,
        created_at: (/* @__PURE__ */ new Date()).toUTCString(),
        attachments: { count: 0 },
        reactions: { count: 0 },
        is_starred: !1,
        is_subscribed: !0,
        is_trashed: !1
      };
      Ar(i.queryClient, s, o);
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((r) => {
      ct(
        i.queryClient,
        { queryKey: ["members", r.app.id] },
        r.created_by.id,
        (u) => {
          u.marked_id = r.id, u.marked_at = r.created_at;
        }
      );
      const s = ["messages", r.app.id], { queryClient: n } = i, o = mh(n, s, r.id), c = o ? null : gs(n, s, !0), l = /* @__PURE__ */ a((u, f) => {
        qt(n, s, u, ($) => {
          $.id = f.id, $.app = f.app, $.text = f.text, $.plain = f.plain, $.html = f.html, $.embed = f.embed, $.meeting = f.meeting, $.attachments = f.attachments, $.options = f.options, $.created_at = f.created_at, $.created_by = f.created_by, $.updated_at = f.updated_at, $.updated_by = f.updated_by;
        });
      }, "replaceCacheItem");
      o ? l(o.id, r) : c ? l(c.id, r) : Ar(n, s, r);
    }, "onSuccess")
  };
}
a(q0, "getAddMessageMutationOptions");
const { I: N0 } = l1, j0 = /* @__PURE__ */ a((i) => i.strings === void 0, "f$1"), jw = /* @__PURE__ */ a(() => document.createComment(""), "r$1"), el = /* @__PURE__ */ a((i, t, e) => {
  const r = i._$AA.parentNode, s = t === void 0 ? i._$AB : t._$AA;
  if (e === void 0) {
    const n = r.insertBefore(jw(), s), o = r.insertBefore(jw(), s);
    e = new N0(n, o, i, i.options);
  } else {
    const n = e._$AB.nextSibling, o = e._$AM, c = o !== i;
    if (c) {
      let l;
      e._$AQ?.(i), e._$AM = i, e._$AP !== void 0 && (l = i._$AU) !== o._$AU && e._$AP(l);
    }
    if (n !== s || c) {
      let l = e._$AA;
      for (; l !== n; ) {
        const u = l.nextSibling;
        r.insertBefore(l, s), l = u;
      }
    }
  }
  return e;
}, "s$1"), Kr = /* @__PURE__ */ a((i, t, e = i) => (i._$AI(t, e), i), "v"), W0 = {}, Rm = /* @__PURE__ */ a((i, t = W0) => i._$AH = t, "m"), Q0 = /* @__PURE__ */ a((i) => i._$AH, "p"), Lp = /* @__PURE__ */ a((i) => {
  i._$AR(), i._$AA.remove();
}, "M");
const od = { ATTRIBUTE: 1, CHILD: 2 }, Bs = /* @__PURE__ */ a((i) => (...t) => ({ _$litDirective$: i, values: t }), "e$2");
var Pa;
let Vc = (Pa = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, r) {
    this._$Ct = t, this._$AM = e, this._$Ci = r;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
}, a(Pa, "i"), Pa);
const nl = /* @__PURE__ */ a((i, t) => {
  const e = i._$AN;
  if (e === void 0) return !1;
  for (const r of e) r._$AO?.(t, !1), nl(r, t);
  return !0;
}, "s"), Kd = /* @__PURE__ */ a((i) => {
  let t, e;
  do {
    if ((t = i._$AM) === void 0) break;
    e = t._$AN, e.delete(i), i = t;
  } while (e?.size === 0);
}, "o$5"), Em = /* @__PURE__ */ a((i) => {
  for (let t; t = i._$AM; i = t) {
    let e = t._$AN;
    if (e === void 0) t._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(i)) break;
    e.add(i), Z0(t);
  }
}, "r");
function K0(i) {
  this._$AN !== void 0 ? (Kd(this), this._$AM = i, Em(this)) : this._$AM = i;
}
a(K0, "h$1");
function G0(i, t = !1, e = 0) {
  const r = this._$AH, s = this._$AN;
  if (s !== void 0 && s.size !== 0) if (t) if (Array.isArray(r)) for (let n = e; n < r.length; n++) nl(r[n], !1), Kd(r[n]);
  else r != null && (nl(r, !1), Kd(r));
  else nl(this, i);
}
a(G0, "n$2");
const Z0 = /* @__PURE__ */ a((i) => {
  i.type == od.CHILD && (i._$AP ??= G0, i._$AQ ??= K0);
}, "c$1"), yw = class yw extends Vc {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, e, r) {
    super._$AT(t, e, r), Em(this), this.isConnected = t._$AU;
  }
  _$AO(t, e = !0) {
    t !== this.isConnected && (this.isConnected = t, t ? this.reconnected?.() : this.disconnected?.()), e && (nl(this, t), Kd(this));
  }
  setValue(t) {
    if (j0(this._$Ct)) this._$Ct._$AI(t, this);
    else {
      const e = [...this._$Ct._$AH];
      e[this._$Ci] = t, this._$Ct._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};
a(yw, "f");
let Pu = yw;
const et = /* @__PURE__ */ a(() => new Mu(), "e$1"), ww = class ww {
};
a(ww, "h");
let Mu = ww;
const Op = /* @__PURE__ */ new WeakMap(), j = Bs(class extends Pu {
  render(i) {
    return v;
  }
  update(i, [t]) {
    const e = t !== this.G;
    return e && this.G !== void 0 && this.rt(void 0), (e || this.lt !== this.ct) && (this.G = t, this.ht = i.options?.host, this.rt(this.ct = i.element)), v;
  }
  rt(i) {
    if (this.isConnected || (i = void 0), typeof this.G == "function") {
      const t = this.ht ?? globalThis;
      let e = Op.get(t);
      e === void 0 && (e = /* @__PURE__ */ new WeakMap(), Op.set(t, e)), e.get(this.G) !== void 0 && this.G.call(this.ht, void 0), e.set(this.G, i), i !== void 0 && this.G.call(this.ht, i);
    } else this.G.value = i;
  }
  get lt() {
    return typeof this.G == "function" ? Op.get(this.ht ?? globalThis)?.get(this.G) : this.G?.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
function Y0(i, t, e) {
  const r = i.queryClient;
  return {
    mutationKey: ["apps", t, "polls"],
    mutationFn: /* @__PURE__ */ a(async ({ optionId: o }) => {
      const c = await i.fetch(`/api/options/${o}/vote`, { method: "POST" });
      if (!c.ok) {
        const l = await c.json();
        throw new Error(l.detail || l.title, { cause: l });
      }
      return await c.json();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((o) => (ct(r, { queryKey: e }, o.parentId, (c) => {
      c.options?.data && (c.options.data = c.options.data?.map((l) => {
        if (l.has_voted) {
          l.has_voted = !1;
          const u = l.votes?.count || 1;
          l.votes ? l.votes.count = u - 1 : l.votes = { count: u - 1 };
        } else if (!l.has_voted && l.id === o.optionId) {
          l.has_voted = !0;
          const u = l.votes?.count || 0;
          l.votes ? l.votes.count = u + 1 : l.votes = { count: u + 1 };
        }
        return l;
      }));
    }), { id: o.optionId }), "onMutate"),
    onSuccess: /* @__PURE__ */ a(async (o, c) => {
      const u = await (await i.fetch("/api/" + c.parentType + "/" + c.parentId)).json();
      ct(
        r,
        { queryKey: e, exact: !1 },
        c.parentId,
        (f) => Object.assign(f, u)
      );
    }, "onSuccess")
    /*onError(error: Error, variables: MutatePollVariables) {
      updateCacheItems(queryClient, { queryKey: postsKey, exact: false }, variables.id, (existingPost: PostType) => Object.assign(existingPost, { is_subscribed: variables..is_subscribed }));
    },*/
  };
}
a(Y0, "getPollMutationOptions");
function sy(i, t, e) {
  return new $t(i.queryClient, Y0(i, t, e));
}
a(sy, "getPollMutation");
function X0(i, t) {
  return {
    queryKey: ["votes", t],
    enabled: !1,
    queryFn: /* @__PURE__ */ a(async () => await (await i.fetch(`/api/options/${t}`)).json(), "queryFn")
  };
}
a(X0, "getVotesOptions");
const gc = /* @__PURE__ */ a((i, t) => !!(i && t && t.indexOf(i) !== -1), "hasPermission");
function J0(i) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ app: e, messageId: r }) => {
      const s = r ? `/api/apps/${e.id}/mark?messageId=${r}` : `/api/apps/${e.id}/mark`;
      await i.fetch(s, { method: r ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a(async (e) => {
      await i.queryClient.cancelQueries({ queryKey: ["apps", e.app.id] }), await i.queryClient.cancelQueries({ queryKey: ["apps", "list"], exact: !1 }), await i.queryClient.cancelQueries({ queryKey: ["apps", "unread"], exact: !1 }), await i.queryClient.cancelQueries({ queryKey: ["members", e.app.id] }), i.queryClient.setQueryData(
        ["apps", e.app.id],
        (r) => r && { ...r, is_unread: !e.messageId || e.messageId < r.last_message.id }
      ), ct(
        i.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        e.app.id,
        (r) => {
          r.is_unread = !e.messageId || e.messageId < r.last_message.id;
        }
      ), e.userId && ct(i.queryClient, { queryKey: ["members", e.app.id] }, e.userId, (r) => {
        e.messageId ? (r.marked_at = (/* @__PURE__ */ new Date()).toISOString(), r.marked_id = e.messageId) : (r.marked_at = void 0, r.marked_id = void 0);
      }), pl(
        i.queryClient,
        {
          queryKey: ["apps", "unread"],
          exact: !1,
          predicate: /* @__PURE__ */ a((r) => {
            const n = r.queryKey[2].includes(e.app.type), o = r.queryKey[2], c = !o || !!e.app.members.data?.find((l) => l.uid && l.uid === o);
            return n && c;
          }, "predicate")
        },
        (r) => Math.max(0, r + (e.messageId ? -1 : 1))
      );
    }, "onMutate"),
    onError: /* @__PURE__ */ a((e, r) => {
      console.error(e.message), ct(
        i.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        r.app.id,
        (s) => {
          s.is_unread = !s.is_unread;
        }
      );
    }, "onError"),
    onSettled: /* @__PURE__ */ a(async (e, r, s) => {
      await i.queryClient.invalidateQueries({ queryKey: ["apps", s.app.id] }), await i.queryClient.invalidateQueries({ queryKey: ["apps", "list"], exact: !1 }), await i.queryClient.invalidateQueries({ queryKey: ["apps", "unread"], exact: !1 }), await i.queryClient.invalidateQueries({ queryKey: ["members", s.app.id] });
    }, "onSettled")
  };
}
a(J0, "getMarkConversationMutationOptions");
function tb(i) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ appId: e, star: r }) => {
      await i.fetch(`/api/apps/${e}/stars`, { method: r ? "POST" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((e) => {
      ct(
        i.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        e.appId,
        (r) => {
          r.is_starred = e.star;
        }
      );
    }, "onMutate"),
    onError: /* @__PURE__ */ a((e, r) => {
      console.error(e.message), ct(
        i.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        r.appId,
        (s) => {
          s.is_starred = !r.star;
        }
      );
    }, "onError")
  };
}
a(tb, "getStarConversationMutationOptions");
function eb(i) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ appId: e, pin: r }) => {
      await i.fetch(`/api/apps/${e}/pin`, { method: r ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((e) => {
      ct(
        i.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        e.appId,
        (r) => {
          r.is_pinned = e.pin;
        }
      );
    }, "onMutate"),
    onSettled: /* @__PURE__ */ a(async () => {
      await i.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
a(eb, "getPinConversationMutationOptions");
function ib(i) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ appId: e, members: r }) => {
      await i.fetch(`/api/apps/${e}/members/${r.join(",")}`, { method: "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((e) => {
      fh(i.queryClient, ["apps", "list"], e.appId);
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((e, r) => {
      i.queryClient.removeQueries({ queryKey: ["apps", r.appId] }), i.queryClient.removeQueries({ queryKey: ["members", r.appId] });
    }, "onSuccess"),
    onSettled: /* @__PURE__ */ a(async () => {
      await i.queryClient.invalidateQueries({ queryKey: ["apps"] }), await i.queryClient.invalidateQueries({ queryKey: ["members"] });
    }, "onSettled")
  };
}
a(ib, "getLeaveConversationMutationOptions");
function rb(i) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ appId: e }) => {
      await i.fetch(`/api/apps/${e}/remove`, { method: "POST" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((e) => {
      fh(i.queryClient, ["apps", "list"], e.appId);
    }, "onMutate"),
    onSettled: /* @__PURE__ */ a(async () => {
      await i.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
a(rb, "getRemoveConversationMutationOptions");
function sb(i) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ appId: e, userId: r, access: s }) => {
      await i.fetch(`/api/apps/${e}/members/${r}`, { method: "PUT", body: JSON.stringify({ access: s }) });
    }, "mutationFn"),
    onSettled: /* @__PURE__ */ a(async (e, r, s) => {
      await i.queryClient.invalidateQueries({ queryKey: ["apps"] }), await i.queryClient.invalidateQueries({ queryKey: ["members", s.appId] });
    }, "onSettled")
  };
}
a(sb, "getUpdateMemberMutationOptions");
function nb(i) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ appId: e, members: r }) => {
      await i.fetch(`/api/apps/${e}/members`, {
        method: "PUT",
        body: JSON.stringify(
          r.map((s) => ({ id: s, access: "write" }))
        )
      });
    }, "mutationFn"),
    onSettled: /* @__PURE__ */ a(async (e, r, s) => {
      await i.queryClient.invalidateQueries({ queryKey: ["apps"] }), await i.queryClient.invalidateQueries({ queryKey: ["members", s.appId] });
    }, "onSettled")
  };
}
a(nb, "getAddMembersToConversationMutationOptions");
function ab(i) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ appId: e, name: r, blobId: s }) => await (await i.fetch(`/api/apps/${e}`, {
      method: "PATCH",
      body: JSON.stringify({
        name: r,
        picture: s
      })
    })).json(), "mutationFn"),
    onMutate: /* @__PURE__ */ a((e) => {
      const r = /* @__PURE__ */ a((s) => {
        typeof e.name == "string" && (s.name = e.name), typeof e?.thumbnailUrl == "string" && (s.avatar_url = e.thumbnailUrl);
      }, "modifyAppItem");
      qt(i.queryClient, ["apps", e.appId], void 0, r), ct(i.queryClient, { queryKey: ["apps", "list"], exact: !1 }, e.appId, r);
    }, "onMutate")
  };
}
a(ab, "getUpdateConversationMutationOptions");
function ob(i) {
  return {
    mutationFn: /* @__PURE__ */ a(async ({ appId: e }) => {
      await i.fetch(`/api/apps/${e}/trash`, { method: "POST" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((e) => {
      fh(i.queryClient, ["apps", "list"], e.appId);
    }, "onMutate"),
    onSettled: /* @__PURE__ */ a(async () => {
      await i.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
a(ob, "getTrashConversationMutationOptions");
function Lm(i) {
  return new $t(i.queryClient, J0(i));
}
a(Lm, "getMarkConversationMutation");
function cb(i) {
  return new $t(i.queryClient, tb(i));
}
a(cb, "getStarConversationMutation");
function lb(i) {
  return new $t(i.queryClient, eb(i));
}
a(lb, "getPinConversationMutation");
function Om(i) {
  return new $t(i.queryClient, ib(i));
}
a(Om, "getLeaveConversationMutation");
function db(i) {
  return new $t(i.queryClient, rb(i));
}
a(db, "getRemoveConversationMutation");
function hb(i) {
  return new $t(i.queryClient, sb(i));
}
a(hb, "getUpdateMemberMutation");
function pb(i) {
  return new $t(i.queryClient, nb(i));
}
a(pb, "getAddMembersToConversationMutation");
function Im(i) {
  return new $t(i.queryClient, ab(i));
}
a(Im, "getUpdateConversationMutation");
function ub(i) {
  return new $t(i.queryClient, ob(i));
}
a(ub, "getTrashConversationMutation");
function Tm(i, t, e = [tt.ChatRoom, tt.PrivateChat], r) {
  return sd(i, ["apps", t], void 0, {
    initialData: /* @__PURE__ */ a(() => i?.queryClient.getQueryData(["apps", "list", e, r])?.pages.flatMap((s) => s.data).find((s) => s?.id === t), "initialData")
  });
}
a(Tm, "getConversationOptions");
function Fm(i, t, e) {
  return {
    queryKey: ["members", t],
    queryFn: /* @__PURE__ */ a(async () => await (await i.fetch(`/api/apps/${t}/members`)).json(), "queryFn"),
    ...e
  };
}
a(Fm, "getMemberOptions");
function yb(i, t, e, r) {
  return {
    queryKey: ["search__members", e],
    initialPageParam: 0,
    enabled: !0,
    queryFn: /* @__PURE__ */ a(async (s) => {
      const n = t(), o = s.pageParam;
      let c;
      e ? c = await i.fetch(`/api/apps/${e}/members?q=${n}${r() !== void 0 ? `&agent=${!!r()}` : ""}&member=false&system=false&skip=${o}`) : c = await i.fetch(`/api/users?q=${n}${r() !== void 0 ? `&agent=${!!r()}` : ""}&system=false&skip=${o}`);
      const l = await c.json();
      return l.data = l.data || [], l;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ a((s) => {
      if (s.end && s.end < s.count)
        return s.end;
    }, "getNextPageParam")
  };
}
a(yb, "getInfiniteSearchMemberOptions");
const nt = /* @__PURE__ */ a((i) => i ?? v, "o$3");
const Ww = /* @__PURE__ */ a((i, t, e) => {
  const r = /* @__PURE__ */ new Map();
  for (let s = t; s <= e; s++) r.set(i[s], s);
  return r;
}, "u"), Fe = Bs(class extends Vc {
  constructor(i) {
    if (super(i), i.type !== od.CHILD) throw Error("repeat() can only be used in text expressions");
  }
  dt(i, t, e) {
    let r;
    e === void 0 ? e = t : t !== void 0 && (r = t);
    const s = [], n = [];
    let o = 0;
    for (const c of i) s[o] = r ? r(c, o) : o, n[o] = e(c, o), o++;
    return { values: n, keys: s };
  }
  render(i, t, e) {
    return this.dt(i, t, e).values;
  }
  update(i, [t, e, r]) {
    const s = Q0(i), { values: n, keys: o } = this.dt(t, e, r);
    if (!Array.isArray(s)) return this.ut = o, n;
    const c = this.ut ??= [], l = [];
    let u, f, $ = 0, m = s.length - 1, x = 0, g = n.length - 1;
    for (; $ <= m && x <= g; ) if (s[$] === null) $++;
    else if (s[m] === null) m--;
    else if (c[$] === o[x]) l[x] = Kr(s[$], n[x]), $++, x++;
    else if (c[m] === o[g]) l[g] = Kr(s[m], n[g]), m--, g--;
    else if (c[$] === o[g]) l[g] = Kr(s[$], n[g]), el(i, l[g + 1], s[$]), $++, g--;
    else if (c[m] === o[x]) l[x] = Kr(s[m], n[x]), el(i, s[$], s[m]), m--, x++;
    else if (u === void 0 && (u = Ww(o, x, g), f = Ww(c, $, m)), u.has(c[$])) if (u.has(c[m])) {
      const S = f.get(o[x]), I = S !== void 0 ? s[S] : null;
      if (I === null) {
        const A = el(i, s[$]);
        Kr(A, n[x]), l[x] = A;
      } else l[x] = Kr(I, n[x]), el(i, s[$], I), s[S] = null;
      x++;
    } else Lp(s[m]), m--;
    else Lp(s[$]), $++;
    for (; x <= g; ) {
      const S = el(i, l[g + 1]);
      Kr(S, n[x]), l[x++] = S;
    }
    for (; $ <= m; ) {
      const S = s[$++];
      S !== null && Lp(S);
    }
    return this.ut = o, Rm(i, l), hh;
  }
});
const Rd = Bs(class extends Vc {
  constructor() {
    super(...arguments), this.key = v;
  }
  render(i, t) {
    return this.key = i, t;
  }
  update(i, [t, e]) {
    return t !== this.key && (Rm(i), this.key = t), e;
  }
});
function Rr(i) {
  i.stopPropagation();
}
a(Rr, "inputConsume");
function wb(i) {
  i.key === "Escape" && (i.preventDefault(), i.stopPropagation(), i.target.value = "", i.target.dispatchEvent(new InputEvent("input", { data: "", inputType: "deleteContent" })));
}
a(wb, "inputClearOnEscape");
function Gd(i) {
  i.key === "Escape" && (i.preventDefault(), i.stopPropagation(), i.target.blur());
}
a(Gd, "inputBlurOnEscape");
function fb(i) {
  i.key === "Enter" && i.target.blur();
}
a(fb, "inputBlurOnEnter");
function mb(i) {
  i.target.value ? wb(i) : Gd(i);
}
a(mb, "inputClearAndBlurOnEscape");
function Dm(i) {
  i.key === "Enter" && (i.preventDefault(), i.stopPropagation(), i.target.click());
}
a(Dm, "clickOnEnter");
function vb(i) {
  i.key === " " && (i.preventDefault(), i.stopPropagation());
}
a(vb, "consumeOnSpace");
function le(i) {
  Dm(i), vb(i);
}
a(le, "clickOnEnterAndConsumeOnSpace");
function Me(i) {
  i.key === " " && (i.preventDefault(), i.stopPropagation(), i.target.click());
}
a(Me, "clickOnSpace");
function ny(i) {
  Dm(i), Me(i);
}
a(ny, "clickOnEnterAndSpace");
const vh = B`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-messages]{padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));flex:1 1 100%}[part~=wy-message-placeholder]{opacity:.5}[part~=wy-message-date-separator]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));pointer-events:none;position:sticky;display:block;top:calc(var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) + var(--wy-component-offset-top, 0px));z-index:10;align-self:center;justify-self:center;margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));background:var(--wy-surface-container-high, var(--wy-surface-container-high-light, #e6e8ee));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-message]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));display:flex;flex-direction:row;align-items:flex-start;margin-bottom:calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + .5*var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));scroll-margin-block:6rem}[part~=wy-message][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-message-meta]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:0 0 calc(.5*var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5*var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));color:var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}[part~=wy-message-bubble]{background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));display:flex;flex-direction:column;padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));max-width:min(32*var(--wy-size, 1rem),100% - 2*var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}[part~=wy-message-bubble-section]{flex:1 1 100%;display:block;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));clip-path:border-box}[part~=wy-message-author]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:calc(1lh + .5*var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5*var(--wy-size, 1rem)) 0 0}[part~=wy-message-content]{display:flex;flex-direction:column;width:100%;align-items:flex-start;flex-wrap:wrap;min-width:0;position:relative}[part~=wy-message-agent]{--wy-component-background-color: var(--wy-tertiary-container, var(--wy-tertiary-container-light, #ebe3bd));--wy-component-color: var(--wy-on-tertiary-container, var(--wy-on-tertiary-container-light, #4c472b))}[part~=wy-message-me]{margin-right:0;margin-left:calc(2.5*var(--wy-size, 1rem));align-items:flex-end;--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73))}[part~=wy-message-me] [part~=wy-message-meta]{margin:0 calc(.5*var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5*var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) 0}[part~=wy-message-me] [part~=wy-message-content]{align-items:flex-end}[part~=wy-message-bubble-emoji]{background:none;padding:0 0 var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-message-seenby]{display:flex;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));height:calc(1.125*var(--wy-size, 1rem));justify-content:flex-end;margin-top:calc(-.125*var(--wy-size, 1rem))}`, Hm = B`[part~=wy-footerbar]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));position:absolute;bottom:0;left:0;right:0;z-index:1020}[part~=wy-footerbar]:after{content:\"\";background-color:var(--wy-component-background-color);color:var(--wy-component-color);position:absolute;width:100%;left:0;bottom:0;height:100%;z-index:-1}[part~=wy-footerbar-sticky]{position:sticky}[part~=wy-footerbar-floating]{--wy-component-border-radius: var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));border-radius:var(--wy-component-border-radius)}[part~=wy-footerbar-floating]:after{border-radius:var(--wy-component-border-radius)}`, qs = B`[part~=wy-pane]{display:flex;flex-direction:column;position:relative;min-height:0;height:100%;flex:1 1 auto}[part~=wy-pane-body]{display:flex;flex-direction:column;flex:1}[part~=wy-pane-group]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));display:flex;flex-direction:column;flex:1}[part~=wy-pane-group-fixed-size]{flex:0}[part~=wy-pane-toolbar]{display:flex;flex:1;justify-content:space-between;align-items:center;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}`, Br = B`[part~=wy-pager]{position:relative;align-self:center;justify-self:center}[part~=wy-pager-bottom]{width:16px;height:256px;max-height:100%;margin-top:-256px;margin-inline:auto;pointer-events:none}[part~=wy-pager-top]{width:16px;height:256px;max-height:100%;margin-bottom:-256px;margin-inline:auto;pointer-events:none}`, ay = B`[part~=wy-toasts]{background:none;border:none;padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin:0;box-sizing:border-box;width:100%;height:100%;display:flex;flex-direction:column;flex-wrap:wrap;align-content:flex-end;align-items:flex-end;justify-content:flex-end;pointer-events:none}[part~=wy-toasts][popover]{position:fixed;inset:0;z-index:1070}[part~=wy-toasts]>::slotted(*){pointer-events:auto}[part~=wy-toast]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background:var(--wy-component-background-color);color:var(--wy-component-color);gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));margin-top:0;margin-bottom:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));display:flex;cursor:pointer;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));padding:0;-webkit-user-select:none;user-select:none;box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));position:relative;overflow:hidden;min-height:calc(3*var(--wy-size, 1rem));max-width:calc(32*var(--wy-size, 1rem))}[part~=wy-toast][part~=wy-fade]{transition-property:opacity,min-height,padding-top,padding-bottom,margin-top,margin-bottom,height;transition-duration:var(--wy-transition-duration, .2s);transition-timing-function:var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))}[part~=wy-toast][part~=wy-fade]:not([part~=wy-show]){opacity:0;min-height:0;height:0;padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;pointer-events:none}[part~=wy-toast-action]{position:sticky;top:calc(4.5*var(--wy-size, 1rem));bottom:calc(4.5*var(--wy-size, 1rem));z-index:990;background-color:var(--wy-primary, var(--wy-primary-light, #2f628c));color:var(--wy-on-primary, var(--wy-on-primary-light, #ffffff));padding:calc(.5*var(--wy-size, 1rem)) calc(1*var(--wy-size, 1rem));margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:calc(.5*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));width:max-content;min-height:0;max-width:calc(100% - 3*var(--wy-size, 1rem));height:auto;align-self:center;text-align:center;box-shadow:none}[part~=wy-toast-primary]{background:var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73));color:var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff))}`;
var oy = /* @__PURE__ */ ((i) => (i.Active = "active", i.Away = "away", i))(oy || {});
const fw = class fw extends Vc {
  constructor(t) {
    if (super(t), t.type !== od.ATTRIBUTE || t.name !== "part" || t.strings?.length > 2)
      throw new Error(
        "`partMap()` can only be used in the `part` attribute and must be the only section in the attribute."
      );
  }
  render(t) {
    return " " + Object.keys(t).filter((e) => t[e]).join(" ") + " ";
  }
  update(t, [e]) {
    if (this._previousShadowParts === void 0) {
      this._previousShadowParts = /* @__PURE__ */ new Set(), t.strings !== void 0 && (this._staticShadowParts = new Set(
        t.strings.join(" ").split(/\s/).filter((s) => s !== "")
      ));
      for (const s in e)
        e[s] && !this._staticShadowParts?.has(s) && this._previousShadowParts.add(s);
      return this.render(e);
    }
    const r = t.element.part;
    for (const s of this._previousShadowParts)
      s in e || (r.remove(s), this._previousShadowParts.delete(s));
    for (const s in e) {
      const n = !!e[s];
      n !== this._previousShadowParts.has(s) && !this._staticShadowParts?.has(s) && (n ? (r.add(s), this._previousShadowParts.add(s)) : (r.remove(s), this._previousShadowParts.delete(s)));
    }
    return hh;
  }
};
a(fw, "ShadowPartMapDirective");
let Su = fw;
const K = Bs(Su), zt = B`:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]){box-sizing:border-box;text-align:initial;font-size:var(--wy-font-size, var(--wy-size, 1em))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:before,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:after{box-sizing:inherit}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a){text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-light, #2f628c))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):hover{text-decoration:var(--wy-link-hover-decoration, var(--wy-link-decoration, none))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])):hover{text-decoration:none}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(p),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(p){margin-top:0;margin-bottom:calc(1*var(--wy-size, 1rem))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(label),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(label){cursor:inherit}:where(:host([hidden])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"])[hidden],:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *[hidden]{display:none!important}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where([role=button]),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where([role=button]){cursor:pointer}`, cy = B`:host(wy-avatar){position:relative;display:inline-flex}[part~=wy-avatar-shape]{border-radius:var(--wy-avatar-border-radius, var(--wy-border-radius, 50%))}[part~=wy-avatar-img]{width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));object-fit:cover}[part~=wy-avatar-initials]{background-color:var(--wy-component-avatar-background-color, var(--wy-primary, var(--wy-primary-light, #2f628c)));color:var(--wy-component-avatar-color, var(--wy-on-primary, var(--wy-on-primary-light, #ffffff)));width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));display:flex;align-items:center;align-content:center;justify-content:center;justify-items:center;font-size:calc(var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem))))}[part~=wy-avatar-initials-text]{font-size:max(8px,var(--wy-avatar-font-size, .382em));font-weight:var(--wy-avatar-font-weight, var(--wy-font-weight-bold, unset));line-height:normal}[part~=wy-avatar-type-icon]{display:flex;position:absolute;z-index:1;bottom:0;right:-8.3333333333%;border-radius:50%;color:var(--wy-tertiary, var(--wy-tertiary-light, #645f41));stroke:var(--wy-on-tertiary, var(--wy-on-tertiary-light, #ffffff))}:host(wy-avatar-group){position:relative;display:inline-flex;flex-shrink:0;width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)))}[part~=wy-avatar-back]{position:absolute;top:0;left:0}[part~=wy-avatar-front]{position:absolute;bottom:0;right:0}:host(wy-avatar-header){padding:calc(1.5*var(--wy-size, 1rem));margin-left:auto;margin-right:auto;text-align:center;display:flex;flex-direction:column;justify-content:center;align-items:center}[part~=wy-avatar-description]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}`, Vm = B`[part~=wy-presence]{width:calc(.75*var(--wy-size, 1rem));height:calc(.75*var(--wy-size, 1rem));border-radius:50%;position:absolute;bottom:0;right:-5%;box-sizing:border-box}[part~=wy-presence]:not([part~=wy-presence-active]){display:none}[part~=wy-presence]:after{content:\"\";position:absolute;width:100%;height:100%;top:0;left:0;border-radius:inherit;background-color:var(--wy-presence-active, var(--wy-green-light, #00a38d));background-clip:content-box;padding:calc(.125*var(--wy-size, 1rem));box-sizing:border-box}[part~=wy-presence-mask]{-webkit-mask-image:radial-gradient(circle calc(.75 * var(--wy-size, 1rem)) at bottom calc(.375 * var(--wy-size, 1rem)) right calc(.375 * var(--wy-size, 1rem) - 5%),rgba(0,0,0,0) calc(.375 * var(--wy-size, 1rem)),rgb(0,0,0) calc(.375 * var(--wy-size, 1rem) + 1px));mask-image:radial-gradient(circle calc(.75 * var(--wy-size, 1rem)) at bottom calc(.375 * var(--wy-size, 1rem)) right calc(.375 * var(--wy-size, 1rem) - 5%),#0000 calc(.375 * var(--wy-size, 1rem)),#000 calc(.375 * var(--wy-size, 1rem) + 1px))}[part~=wy-presence-in-text]{position:absolute;bottom:unset;right:unset}[part~=wy-presence-in-text]:after{left:calc(-.5*var(--wy-size, 1rem))}`;
var gb = Object.defineProperty, bb = Object.getOwnPropertyDescriptor, ly = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? bb(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && gb(t, e, s), s;
}, "__decorateClass$1b"), Ma;
let bc = (Ma = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.placement = "avatar";
  }
  render() {
    const t = {
      "wy-presence": !0,
      "wy-presence-active": this.status === oy.Active,
      "wy-presence-in-text": this.placement === "text"
    };
    return h` <span part=${K(t)} data-presence-id=${this.id}></span> `;
  }
}, a(Ma, "WyPresence"), Ma);
bc.styles = [
  zt,
  Vm,
  Z
];
ly([
  p()
], bc.prototype, "placement", 2);
ly([
  p()
], bc.prototype, "status", 2);
bc = ly([
  H("wy-presence")
], bc);
var xb = "M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M1,10V12H9V10M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12Z", $b = "M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M6,10V7H4V10H1V12H4V15H6V12H9V10M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12Z", Cb = "M13 14H11V9H13M13 18H11V16H13M1 21H23L12 2L1 21Z", kb = "M13,13H11V7H13M13,17H11V15H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", _b = "M13 13H11V7H13M11 15H13V17H11M15.73 3H8.27L3 8.27V15.73L8.27 21H15.73L21 15.73V8.27L15.73 3Z", Pb = "M19.5,3.09L15,7.59V4H13V11H20V9H16.41L20.91,4.5L19.5,3.09M4,13V15H7.59L3.09,19.5L4.5,20.91L9,16.41V20H11V13H4Z", Mb = "M10,21V19H6.41L10.91,14.5L9.5,13.09L5,17.59V14H3V21H10M14.5,10.91L19,6.41V10H21V3H14V5H17.59L13.09,9.5L14.5,10.91Z", Qw = "M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z", Sb = "M4,11V13H16L10.5,18.5L11.92,19.92L19.84,12L11.92,4.08L10.5,5.5L16,11H4Z", Ab = "M7.5,18A5.5,5.5 0 0,1 2,12.5A5.5,5.5 0 0,1 7.5,7H18A4,4 0 0,1 22,11A4,4 0 0,1 18,15H9.5A2.5,2.5 0 0,1 7,12.5A2.5,2.5 0 0,1 9.5,10H17V11.5H9.5A1,1 0 0,0 8.5,12.5A1,1 0 0,0 9.5,13.5H18A2.5,2.5 0 0,0 20.5,11A2.5,2.5 0 0,0 18,8.5H7.5A4,4 0 0,0 3.5,12.5A4,4 0 0,0 7.5,16.5H17V18H7.5Z", zb = "M12,3A9,9 0 0,0 3,12H0L4,16L8,12H5A7,7 0 0,1 12,5A7,7 0 0,1 19,12A7,7 0 0,1 12,19C10.5,19 9.09,18.5 7.94,17.7L6.5,19.14C8.04,20.3 9.94,21 12,21A9,9 0 0,0 21,12A9,9 0 0,0 12,3M14,12A2,2 0 0,0 12,10A2,2 0 0,0 10,12A2,2 0 0,0 12,14A2,2 0 0,0 14,12Z", Rb = "M21,19V20H3V19L5,17V11C5,7.9 7.03,5.17 10,4.29C10,4.19 10,4.1 10,4A2,2 0 0,1 12,2A2,2 0 0,1 14,4C14,4.1 14,4.19 14,4.29C16.97,5.17 19,7.9 19,11V17L21,19M14,21A2,2 0 0,1 12,23A2,2 0 0,1 10,21", Eb = "M20.84,22.73L18.11,20H3V19L5,17V11C5,9.86 5.29,8.73 5.83,7.72L1.11,3L2.39,1.73L22.11,21.46L20.84,22.73M19,15.8V11C19,7.9 16.97,5.17 14,4.29C14,4.19 14,4.1 14,4A2,2 0 0,0 12,2A2,2 0 0,0 10,4C10,4.1 10,4.19 10,4.29C9.39,4.47 8.8,4.74 8.26,5.09L19,15.8M12,23A2,2 0 0,0 14,21H10A2,2 0 0,0 12,23Z", Lb = "M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3M9 17H7V10H9V17M13 17H11V7H13V17M17 17H15V13H17V17Z", Ip = "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z", Ob = "M0.41,13.41L6,19L7.41,17.58L1.83,12M22.24,5.58L11.66,16.17L7.5,12L6.07,13.41L11.66,19L23.66,7M18,7L16.59,5.58L10.24,11.93L11.66,13.34L18,7Z", Ib = "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41 10.59L10 14.17L17.59 6.58L19 8L10 17Z", Tb = "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M12 20C7.59 20 4 16.41 4 12S7.59 4 12 4 20 7.59 20 12 16.41 20 12 20M16.59 7.58L10 14.17L7.41 11.59L6 13L10 17L18 9L16.59 7.58Z", Fb = "M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3M19,5V19H5V5H19Z", Db = "M19,19H5V5H15V3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V11H19M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z", Hb = "M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", Vb = "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z", Ub = "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z", Bb = "M6.5 20Q4.22 20 2.61 18.43 1 16.85 1 14.58 1 12.63 2.17 11.1 3.35 9.57 5.25 9.15 5.88 6.85 7.75 5.43 9.63 4 12 4 14.93 4 16.96 6.04 19 8.07 19 11 20.73 11.2 21.86 12.5 23 13.78 23 15.5 23 17.38 21.69 18.69 20.38 20 18.5 20Z", qb = "M9,22A1,1 0 0,1 8,21V18H4A2,2 0 0,1 2,16V4C2,2.89 2.9,2 4,2H20A2,2 0 0,1 22,4V16A2,2 0 0,1 20,18H13.9L10.2,21.71C10,21.9 9.75,22 9.5,22V22H9Z", Nb = "M9,22A1,1 0 0,1 8,21V18H4A2,2 0 0,1 2,16V4C2,2.89 2.9,2 4,2H20A2,2 0 0,1 22,4V16A2,2 0 0,1 20,18H13.9L10.2,21.71C10,21.9 9.75,22 9.5,22V22H9M10,16V19.08L13.08,16H20V4H4V16H10Z", jb = "M15,9H5V5H15M12,19A3,3 0 0,1 9,16A3,3 0 0,1 12,13A3,3 0 0,1 15,16A3,3 0 0,1 12,19M17,3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V7L17,3Z", Wb = "M19,1L17.74,3.75L15,5L17.74,6.26L19,9L20.25,6.26L23,5L20.25,3.75M9,4L6.5,9.5L1,12L6.5,14.5L9,20L11.5,14.5L17,12L11.5,9.5M19,15L17.74,17.74L15,19L17.74,20.25L19,23L20.25,20.25L23,19L20.25,17.74", Qb = "M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z", Kb = "M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19M8.46,11.88L9.87,10.47L12,12.59L14.12,10.47L15.53,11.88L13.41,14L15.53,16.12L14.12,17.53L12,15.41L9.88,17.53L8.47,16.12L10.59,14L8.46,11.88M15.5,4L14.5,3H9.5L8.5,4H5V6H19V4H15.5Z", Gb = "M14,14H16L12,10L8,14H10V18H14V14M6,7H18V19C18,19.5 17.8,20 17.39,20.39C17,20.8 16.5,21 16,21H8C7.5,21 7,20.8 6.61,20.39C6.2,20 6,19.5 6,19V7M19,4V6H5V4H8.5L9.5,3H14.5L15.5,4H19Z", Zb = "M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z", Yb = "M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z", Xb = "M17.9,17.39C17.64,16.59 16.89,16 16,16H15V13A1,1 0 0,0 14,12H8V10H10A1,1 0 0,0 11,9V7H13A2,2 0 0,0 15,5V4.59C17.93,5.77 20,8.64 20,12C20,14.08 19.2,15.97 17.9,17.39M11,19.93C7.05,19.44 4,16.08 4,12C4,11.38 4.08,10.78 4.21,10.21L9,15V16A2,2 0 0,0 11,18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", Jb = "M20,8L12,13L4,8V6L12,11L20,6M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C22,4.89 21.1,4 20,4Z", t2 = "M12,17.5C14.33,17.5 16.3,16.04 17.11,14H6.89C7.69,16.04 9.67,17.5 12,17.5M8.5,11A1.5,1.5 0 0,0 10,9.5A1.5,1.5 0 0,0 8.5,8A1.5,1.5 0 0,0 7,9.5A1.5,1.5 0 0,0 8.5,11M15.5,11A1.5,1.5 0 0,0 17,9.5A1.5,1.5 0 0,0 15.5,8A1.5,1.5 0 0,0 14,9.5A1.5,1.5 0 0,0 15.5,11M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2C6.47,2 2,6.5 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", e2 = "M15 18H18V15H20V18H23V20H20V23H18V20H15V18M12 17.5C9.67 17.5 7.69 16.04 6.89 14H15.69C14.5 14.78 13.62 15.97 13.23 17.36C12.83 17.45 12.42 17.5 12 17.5M8.5 11C7.67 11 7 10.33 7 9.5C7 8.67 7.67 8 8.5 8C9.33 8 10 8.67 10 9.5C10 10.33 9.33 11 8.5 11M15.5 11C14.67 11 14 10.33 14 9.5C14 8.67 14.67 8 15.5 8C16.33 8 17 8.67 17 9.5C17 10.33 16.33 11 15.5 11M12 20L13.07 19.93C13.18 20.61 13.4 21.26 13.72 21.85C13.16 21.95 12.58 22 12 22C6.47 22 2 17.5 2 12C2 6.5 6.47 2 12 2C17.5 2 22 6.5 22 12C22 12.59 21.95 13.16 21.85 13.72C21.26 13.4 20.62 13.18 19.93 13.07L20 12C20 7.58 16.42 4 12 4C7.58 4 4 7.58 4 12C4 16.42 7.58 20 12 20Z", i2 = "M13,9V3.5L18.5,9M6,2C4.89,2 4,2.89 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2H6Z", Kw = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M6.12,15.5L9.86,19.24L11.28,17.83L8.95,15.5L11.28,13.17L9.86,11.76L6.12,15.5M17.28,15.5L13.54,11.76L12.12,13.17L14.45,15.5L12.12,17.83L13.54,19.24L17.28,15.5Z", Gw = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M15,18V16H6V18H15M18,14V12H6V14H18Z", r2 = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.8,20H14L12,16.6L10,20H8.2L11.1,15.5L8.2,11H10L12,14.4L14,11H15.8L12.9,15.5L15.8,20M13,9V3.5L18.5,9H13Z", s2 = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M6,20H15L18,20V12L14,16L12,14L6,20M8,9A2,2 0 0,0 6,11A2,2 0 0,0 8,13A2,2 0 0,0 10,11A2,2 0 0,0 8,9Z", n2 = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M13,13H11V18A2,2 0 0,1 9,20A2,2 0 0,1 7,18A2,2 0 0,1 9,16C9.4,16 9.7,16.1 10,16.3V11H13V13M13,9V3.5L18.5,9H13Z", a2 = "M12.6,12.3H10.6V15.5H12.7C13.3,15.5 13.6,15.3 13.9,15C14.2,14.7 14.3,14.4 14.3,13.9C14.3,13.4 14.2,13.1 13.9,12.8C13.6,12.5 13.2,12.3 12.6,12.3M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.2,16C14.6,16.5 14.1,16.7 12.8,16.7H10.6V20H9V11H12.8C14.1,11 14.7,11.3 15.2,11.8C15.8,12.4 16,13 16,13.9C16,14.8 15.8,15.5 15.2,16M13,9V3.5L18.5,9H13Z", o2 = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M13.5,16V19H10.5V16H8L12,12L16,16H13.5M13,9V3.5L18.5,9H13Z", c2 = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M17,19V13L14,15.2V13H7V19H14V16.8L17,19Z", l2 = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.2,20H13.8L12,13.2L10.2,20H8.8L6.6,11H8.1L9.5,17.8L11.3,11H12.6L14.4,17.8L15.8,11H17.3L15.2,20M13,9V3.5L18.5,9H13Z", d2 = "M20,2H4C2.89,2 2,2.89 2,4V20C2,21.11 2.89,22 4,22H20C21.11,22 22,21.11 22,20V4C22,2.89 21.11,2 20,2M12,4L15,7H13V9H11V7H9M7,15L4,12L7,9V11H9V13H7M12,20L9,17H11V15H13V17H15M17,15V13H15V11H17V9L20,12", h2 = "M17 4H20C21.1 4 22 4.9 22 6V8H20V6H17V4M4 8V6H7V4H4C2.9 4 2 4.9 2 6V8H4M20 16V18H17V20H20C21.1 20 22 19.1 22 18V16H20M7 18H4V16H2V18C2 19.1 2.9 20 4 20H7V18M18 8H6V16H18V8Z", p2 = "M20 6H12L10 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V8C22 6.9 21.1 6 20 6M18 12H16V14H18V16H16V18H14V16H16V14H14V12H16V10H14V8H16V10H18V12Z", u2 = "M17,7H22V17H17V19A1,1 0 0,0 18,20H20V22H17.5C16.95,22 16,21.55 16,21C16,21.55 15.05,22 14.5,22H12V20H14A1,1 0 0,0 15,19V5A1,1 0 0,0 14,4H12V2H14.5C15.05,2 16,2.45 16,3C16,2.45 16.95,2 17.5,2H20V4H18A1,1 0 0,0 17,5V7M2,7H13V9H4V15H13V17H2V7M20,15V9H17V15H20Z", y2 = "M5,5H10V7H7V10H5V5M14,5H19V10H17V7H14V5M17,14H19V19H14V17H17V14M10,17V19H5V14H7V17H10Z", w2 = "M14,14H19V16H16V19H14V14M5,14H10V19H8V16H5V14M8,5H10V10H5V8H8V5M19,8V10H14V5H16V8H19Z", f2 = "M15.07,11.25L14.17,12.17C13.45,12.89 13,13.5 13,15H11V14.5C11,13.39 11.45,12.39 12.17,11.67L13.41,10.41C13.78,10.05 14,9.55 14,9C14,7.89 13.1,7 12,7A2,2 0 0,0 10,9H8A4,4 0 0,1 12,5A4,4 0 0,1 16,9C16,9.88 15.64,10.67 15.07,11.25M13,19H11V17H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12C22,6.47 17.5,2 12,2Z", m2 = "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M11,17H13V11H11V17Z", v2 = "M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z", g2 = "M7,10L12,15L17,10H7Z", b2 = "M7,15L12,10L17,15H7Z", x2 = "M20,2H4A2,2 0 0,0 2,4V22L6,18H20A2,2 0 0,0 22,16V4C22,2.89 21.1,2 20,2Z", $2 = "M20,2H4A2,2 0 0,0 2,4V22L6,18H20A2,2 0 0,0 22,16V4A2,2 0 0,0 20,2M6,9H18V11H6M14,14H6V12H14M18,8H6V6H18", C2 = "M19,13H5V11H19V13Z", k2 = "M21 2C22.05 2 22.92 2.81 23 3.85L23 4V16C23 17.05 22.18 17.92 21.15 18L21 18H14V20H16V22H8V20H10V18H3C1.95 18 1.08 17.18 1 16.15L1 16V4C1 2.94 1.81 2.08 2.85 2L3 2H21M21 4H3V16H21V4M12 11C14.21 11 16 11.9 16 13V14H8V13C8 11.9 9.79 11 12 11M12 6C13.11 6 14 6.9 14 8S13.11 10 12 10 10 9.11 10 8 10.9 6 12 6Z", _2 = "M14,3V5H17.59L7.76,14.83L9.17,16.24L19,6.41V10H21V3M19,19H5V5H12V3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V12H19V19Z", P2 = "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z", M2 = "M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z", S2 = "M2,5.27L3.28,4L20,20.72L18.73,22L12.8,16.07V22H11.2V16H6V14L8,12V11.27L2,5.27M16,12L18,14V16H17.82L8,6.18V4H7V2H17V4H16V12Z", A2 = "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z", z2 = "M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M13,7H11V11H7V13H11V17H13V13H17V11H13V7Z", R2 = "M13,3A9,9 0 0,0 4,12H1L4.89,15.89L4.96,16.03L9,12H6A7,7 0 0,1 13,5A7,7 0 0,1 20,12A7,7 0 0,1 13,19C11.07,19 9.32,18.21 8.06,16.94L6.64,18.36C8.27,20 10.5,21 13,21A9,9 0 0,0 22,12A9,9 0 0,0 13,3Z", E2 = "M4,3H5V5H3V4A1,1 0 0,1 4,3M20,3A1,1 0 0,1 21,4V5H19V3H20M15,5V3H17V5H15M11,5V3H13V5H11M7,5V3H9V5H7M21,20A1,1 0 0,1 20,21H19V19H21V20M15,21V19H17V21H15M11,21V19H13V21H11M7,21V19H9V21H7M4,21A1,1 0 0,1 3,20V19H5V21H4M3,15H5V17H3V15M21,15V17H19V15H21M3,11H5V13H3V11M21,11V13H19V11H21M3,7H5V9H3V7M21,7V9H19V7H21Z", L2 = "M2,21L23,12L2,3V10L17,12L2,14V21Z", O2 = "M13,19H14A1,1 0 0,1 15,20H15.73L13,17.27V19M22,20V21.18L20.82,20H22M21,22.72L19.73,24L17.73,22H15A1,1 0 0,1 14,23H10A1,1 0 0,1 9,22H2V20H9A1,1 0 0,1 10,19H11V17H4A1,1 0 0,1 3,16V12A1,1 0 0,1 4,11H6.73L4.73,9H4A1,1 0 0,1 3,8V7.27L1,5.27L2.28,4L21,22.72M4,3H20A1,1 0 0,1 21,4V8A1,1 0 0,1 20,9H9.82L7,6.18V5H5.82L3.84,3C3.89,3 3.94,3 4,3M20,11A1,1 0 0,1 21,12V16A1,1 0 0,1 20,17H17.82L11.82,11H20M9,7H10V5H9V7M9,15H10V14.27L9,13.27V15M5,13V15H7V13H5Z", I2 = "M12 1L3 5V11C3 16.55 6.84 21.74 12 23C17.16 21.74 21 16.55 21 11V5L12 1M15.08 16L12 14.15L8.93 16L9.74 12.5L7.03 10.16L10.61 9.85L12 6.55L13.39 9.84L16.97 10.15L14.26 12.5L15.08 16Z", T2 = "M21 11C21 16.55 17.16 21.74 12 23C6.84 21.74 3 16.55 3 11V5L12 1L21 5V11M12 21C15.75 20 19 15.54 19 11.22V6.3L12 3.18L5 6.3V11.22C5 15.54 8.25 20 12 21M15.05 16L11.97 14.15L8.9 16L9.71 12.5L7 10.16L10.58 9.85L11.97 6.55L13.37 9.84L16.95 10.15L14.23 12.5L15.05 16", F2 = "M18 21L14 17H17V7H14L18 3L22 7H19V17H22M2 19V17H12V19M2 13V11H9V13M2 7V5H6V7H2Z", D2 = "M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z", H2 = "M12,1L9,9L1,12L9,15L12,23L15,15L23,12L15,9L12,1Z", V2 = "M20.8 22.7L17.9 19.8L18.2 21L12 17.3L5.8 21L7.4 14L2 9.2L6.9 8.8L1.1 3L2.4 1.7L22.1 21.4L20.8 22.7M22 9.2L14.8 8.6L12 2L10 6.8L16.9 13.7L22 9.2Z", U2 = "M21,9L17,5V8H10V10H17V13M7,11L3,15L7,19V16H14V14H7V11Z", B2 = "M23,10C23,8.89 22.1,8 21,8H14.68L15.64,3.43C15.66,3.33 15.67,3.22 15.67,3.11C15.67,2.7 15.5,2.32 15.23,2.05L14.17,1L7.59,7.58C7.22,7.95 7,8.45 7,9V19A2,2 0 0,0 9,21H18C18.83,21 19.54,20.5 19.84,19.78L22.86,12.73C22.95,12.5 23,12.26 23,12V10M1,21H5V9H1V21Z", q2 = "M5,9V21H1V9H5M9,21A2,2 0 0,1 7,19V9C7,8.45 7.22,7.95 7.59,7.59L14.17,1L15.23,2.06C15.5,2.33 15.67,2.7 15.67,3.11L15.64,3.43L14.69,8H21C22.11,8 23,8.9 23,10V12C23,12.26 22.95,12.5 22.86,12.73L19.84,19.78C19.54,20.5 18.83,21 18,21H9M9,19H18.03L21,12V10H12.21L13.34,4.68L9,9.03V19Z", N2 = "M9,3V4H4V6H5V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V6H20V4H15V3H9M9,8H11V17H9V8M13,8H15V17H13V8Z", j2 = "M17,10.5V7A1,1 0 0,0 16,6H4A1,1 0 0,0 3,7V17A1,1 0 0,0 4,18H16A1,1 0 0,0 17,17V13.5L21,17.5V6.5L17,10.5Z", W2 = "M3 5V19H20V5H3M7 7V9H5V7H7M5 13V11H7V13H5M5 15H7V17H5V15M18 17H9V15H18V17M18 13H9V11H18V13M18 9H9V7H18V9Z", Q2 = "M4 5V18H21V5H4M14 7V10.5H11V7H14M6 7H9V10.5H6V7M6 16V12.5H9V16H6M11 16V12.5H14V16H11M19 16H16V12.5H19V16M16 10.5V7H19V10.5H16Z", K2 = "M2.28,3L1,4.27L2.47,5.74C2.04,6 1.61,6.29 1.2,6.6L3,9C3.53,8.6 4.08,8.25 4.66,7.93L6.89,10.16C6.15,10.5 5.44,10.91 4.8,11.4L6.6,13.8C7.38,13.22 8.26,12.77 9.2,12.47L11.75,15C10.5,15.07 9.34,15.5 8.4,16.2L12,21L14.46,17.73L17.74,21L19,19.72M12,3C9.85,3 7.8,3.38 5.9,4.07L8.29,6.47C9.5,6.16 10.72,6 12,6C15.38,6 18.5,7.11 21,9L22.8,6.6C19.79,4.34 16.06,3 12,3M12,9C11.62,9 11.25,9 10.88,9.05L14.07,12.25C15.29,12.53 16.43,13.07 17.4,13.8L19.2,11.4C17.2,9.89 14.7,9 12,9Z";
const Zw = E2, Yw = {
  "zoom-meetings": '<path d="M21.5 12.5c0 .96-.08 1.91-.23 2.83a7.198 7.198 0 01-5.95 5.95 17.527 17.527 0 01-5.66 0 7.198 7.198 0 01-5.95-5.95 17.527 17.527 0 010-5.66c.49-3.05 2.9-5.46 5.95-5.95a17.527 17.527 0 015.66 0c3.05.49 5.46 2.9 5.95 5.95.15.92.23 1.86.23 2.83z" fill="#0b5cff"/><path d="M14.43 14.75c0 .53-.43.96-.96.96H9.29c-1.07 0-1.93-.86-1.93-1.93v-3.54c0-.53.43-.96.96-.96h4.18c1.07 0 1.93.86 1.93 1.93v3.54zM16.87 9.86l-1.41 1.06c-.24.18-.39.47-.39.77v1.61c0 .3.14.59.39.77l1.41 1.06c.32.24.77.01.77-.39v-4.5c0-.4-.45-.62-.77-.39z" fill="#fff"/>',
  "google-meet": '<path fill="#1e88e5" d="M3.5 9.07v5.86l2.09.42 2.1-.42V9.07l-2.1-.42-2.09.42z"/><path d="M17.73 12v5.86c0 .69-.56 1.26-1.26 1.26H7.69l-.42-2.09.42-2.09h5.86v-2.93l2.09-.42 2.09.42z" fill="#4caf50"/><path d="M17.73 6.14V12h-4.19V9.07H7.68l-.42-2.09.42-2.09h8.79c.69 0 1.26.56 1.26 1.26z" fill="#fbc02d"/><path d="M7.69 14.93v4.19H4.76c-.69 0-1.26-.56-1.26-1.26v-2.93h4.19z" fill="#1565c0"/><path fill="#e53935" d="M7.69 4.88v4.19H3.5l4.19-4.19z"/><path fill="#2e7d32" d="M18.15 12l-.42 3.54L13.55 12l4.18-3.54.42 3.54z"/><path d="M21.5 6.19v11.63c0 .35-.41.55-.68.33l-3.09-2.6V8.48l3.09-2.6c.27-.22.68-.03.68.33z" fill="#4caf50"/>',
  "webex-meetings": '<defs><radialGradient id="prefix__b" cx="-951.63" cy="549.04" fx="-951.63" fy="549.04" r=".05" gradientTransform="matrix(-87.16473 -146.04628 -122.52671 73.12756 -15652.44 -179117.85)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#007383"/><stop offset=".41" stop-color="#00717e" stop-opacity=".75"/><stop offset=".87" stop-color="#007281" stop-opacity="0"/></radialGradient><radialGradient id="prefix__c" cx="-952.67" cy="549.07" fx="-952.67" fy="549.07" r=".05" gradientTransform="rotate(-126.7 -53497.341 -58162.752) scale(138.69 -91.09)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#218970"/><stop offset=".46" stop-color="#267e6a"/><stop offset="1" stop-color="#026c51" stop-opacity="0"/></radialGradient><radialGradient id="prefix__d" cx="-952.61" cy="541.2" fx="-952.61" fy="541.2" r=".05" gradientTransform="matrix(-33.8827 -107.79009 -56.09397 17.63256 -1902.72 -112216.84)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#178697"/><stop offset=".41" stop-color="#17838f" stop-opacity=".79"/><stop offset=".87" stop-color="#007281" stop-opacity="0"/></radialGradient><radialGradient id="prefix__e" cx="-949.76" cy="547.24" fx="-949.76" fy="547.24" r=".05" gradientTransform="matrix(-146.98086 -246.36712 -75.94201 45.30646 -98045.43 -258761.67)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#25342f" stop-opacity=".3"/><stop offset="1" stop-color="#25342f" stop-opacity="0"/></radialGradient><radialGradient id="prefix__f" cx="-942.87" cy="563.62" fx="-942.87" fy="563.62" r=".05" gradientTransform="rotate(85.1 -69752.427 38265.017) scale(108.08 -61.22)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#056d4f"/><stop offset=".23" stop-color="#056c4e" stop-opacity=".75"/><stop offset=".6" stop-color="#056c4e" stop-opacity=".3"/><stop offset=".87" stop-color="#056c4f" stop-opacity="0"/></radialGradient><radialGradient id="prefix__g" cx="-940.36" cy="556.77" fx="-940.36" fy="556.77" r=".05" gradientTransform="matrix(68.96997 106.65216 55.9082 -36.1548 33735.1 120422.29)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#22b67b"/><stop offset=".41" stop-color="#24be82"/><stop offset="1" stop-color="#24be82" stop-opacity=".07"/></radialGradient><radialGradient id="prefix__i" cx="-940.77" cy="554.96" fx="-940.77" fy="554.96" r=".05" gradientTransform="rotate(49.69 -177135.555 122596.9) scale(165.85 -165.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></radialGradient><radialGradient id="prefix__j" cx="-944.1" cy="553.18" fx="-944.1" fy="553.18" r=".05" gradientTransform="rotate(48.05 -367132.581 263331.898) scale(336.36 -335.78)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00b8ff"/><stop offset=".75" stop-color="#00b9fc" stop-opacity="0"/></radialGradient><radialGradient id="prefix__k" cx="-951.17" cy="546.23" fx="-951.17" fy="546.23" r=".05" gradientTransform="matrix(-48.64247 -154.74493 -107.10322 33.66679 12252.88 -165563.53)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00bcff" stop-opacity=".76"/><stop offset=".57" stop-color="#00bafc" stop-opacity="0"/></radialGradient><radialGradient id="prefix__l" cx="-953.78" cy="550.07" fx="-953.78" fy="550.07" r=".05" gradientTransform="matrix(-72.9418 -88.45403 -61.91396 51.05608 -35502.54 -112443.2)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5fec50"/><stop offset="1" stop-color="#3cc08e" stop-opacity="0"/></radialGradient><radialGradient id="prefix__m" cx="-954.59" cy="523.18" fx="-954.59" fy="523.18" r=".05" gradientTransform="rotate(-79.11 -8961.313 -26349.067) scale(34.73 -23.99)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#28855b"/><stop offset="1" stop-color="#14795c" stop-opacity="0"/></radialGradient><radialGradient id="prefix__n" cx="-955.7" cy="534.72" fx="-955.7" fy="534.72" r=".05" gradientTransform="matrix(6.00138 -27.99393 -39.07222 -8.37636 26647.75 -22260.21)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#28855b"/><stop offset="1" stop-color="#14795c" stop-opacity="0"/></radialGradient><radialGradient id="prefix__o" cx="-954.99" cy="550.19" fx="-954.99" fy="550.19" r=".05" gradientTransform="matrix(-64.43177 -69.7019 -48.95728 45.25565 -34575.21 -91452.74)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5ff05b"/><stop offset=".81" stop-color="#5de955" stop-opacity="0"/></radialGradient><radialGradient id="prefix__p" cx="-938.28" cy="553.05" fx="-938.28" fy="553.05" r=".05" gradientTransform="matrix(66.96005 51.3617 71.4219 -93.11248 23342.15 99701.75)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".97" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__q" cx="-940.1" cy="550.5" fx="-940.1" fy="550.5" r=".05" gradientTransform="matrix(98.43675 14.71147 21.98813 -147.126 80455.97 94829.3)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".59" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__r" cx="-938.38" cy="551.97" fx="-938.38" fy="551.97" r=".05" gradientTransform="rotate(24.69 -231174.852 140478.806) scale(85.04 -151.66)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".76" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__s" cx="-945.2" cy="560.82" fx="-945.2" fy="560.82" r=".05" gradientTransform="rotate(95.79 -93552.04 41883.384) scale(153.04 -83.75)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".59" stop-color="#123aa8" stop-opacity="0"/><stop offset="1" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__t" cx="-945.05" cy="562.66" fx="-945.05" fy="562.66" r=".05" gradientTransform="rotate(93.66 -104350.43 63182.76) scale(184.18 -65.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__u" cx="-942.29" cy="567.94" fx="-942.29" fy="567.94" r=".05" gradientTransform="matrix(8.78957 97.33394 51.50044 -4.65066 -20951.98 94373.6)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__v" cx="-942.85" cy="562.23" fx="-942.85" fy="562.23" r=".05" gradientTransform="matrix(4.89377 101.88254 84.00315 -4.03496 -42611.94 98338.06)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__w" cx="-941.74" cy="549.74" fx="-941.74" fy="549.74" r=".05" gradientTransform="rotate(-23.2 244205.91 -321749.854) scale(113.62 -222.29)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".71" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__x" cx="-959.91" cy="553.32" fx="-959.91" fy="553.32" r=".05" gradientTransform="matrix(-70.50332 -26.36011 -45.18376 120.84945 -42670.87 -92159.05)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#1a3da0"/><stop offset=".71" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__y" cx="-940.3" cy="551.63" fx="-940.3" fy="551.63" r=".05" gradientTransform="matrix(137.44492 41.41855 41.86 -138.90985 106154.62 115588.85)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#1e3882"/><stop offset=".76" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__A" cx="-940.77" cy="554.96" fx="-940.77" fy="554.96" r=".05" gradientTransform="rotate(49.69 -177135.55 122596.884) scale(165.85 -165.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></radialGradient><radialGradient id="prefix__D" cx="-951.17" cy="546.23" fx="-951.17" fy="546.23" r=".05" gradientTransform="matrix(-48.64247 -154.74493 -107.10322 33.66679 12252.88 -165563.53)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00bcff" stop-opacity=".76"/><stop offset=".57" stop-color="#00bafc" stop-opacity="0"/></radialGradient><linearGradient id="prefix__a" x1="76.14" y1="-95.89" x2="64.37" y2="-99.75" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5cee64"/><stop offset="1" stop-color="#0bf"/></linearGradient><linearGradient id="prefix__h" x1="56.74" y1="-98.36" x2="65.09" y2="-98.43" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient><linearGradient id="prefix__z" x1="61.48" y1="-92.95" x2="67.9" y2="-97.04" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset=".23" stop-color="#1dc4ff"/><stop offset="1" stop-color="#1cc1ff" stop-opacity="0"/></linearGradient><linearGradient id="prefix__B" x1="63.13" y1="-92.11" x2="64.93" y2="-93.74" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#26fbff"/><stop offset=".64" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient><linearGradient id="prefix__C" x1="60.36" y1="-97.78" x2="62.85" y2="-97.95" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#26fbff"/><stop offset=".64" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient></defs><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__a)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__b)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__c)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__d)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__e)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__f)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__g)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__h)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__i)"/><path d="M15.37 5.44c-1.34 0-2.88.45-3.9 2.4-.59 1.12-.89 2.38-1.16 3.63-.09.41-.18.83-.28 1.22v5.66c.51-.14 1.05-.42 1.57-.95 1.96-1.99 2.28-7.2 3.26-8.19.11-.11.23-.18.36-.18.39 0 .7.5.99 1.1.32.67.71 1.43 1.84 1.43.52 0 1.72-.38 1.72-1.85 0-.88-1.47-4.28-4.39-4.28z" fill="url(#prefix__j)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__k)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__l)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__m)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__n)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__o)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="#316aff"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__p)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__q)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__r)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__s)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__t)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__u)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__v)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__w)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__x)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__y)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__z)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__A)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__B)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__C)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__D)"/>',
  "microsoft-teams": '<path d="M15.56 9.91h4.65c.44 0 .8.36.8.8v4.24c0 1.61-1.31 2.92-2.92 2.92h-.01c-1.61 0-2.92-1.31-2.92-2.92v-4.62c0-.23.19-.42.42-.42z" fill="#5059c9"/><circle cx="18.7" cy="7.19" r="1.88" fill="#5059c9"/><circle cx="12.84" cy="6.35" r="2.72" fill="#7b83eb"/><path d="M16.47 9.91H8.8a.79.79 0 00-.77.8v4.83c-.06 2.6 2 4.77 4.6 4.83 2.6-.06 4.67-2.23 4.6-4.83v-4.83a.783.783 0 00-.77-.8z" fill="#7b83eb"/><path d="M3.77 7.4h7.67c.42 0 .77.34.77.77v7.67c0 .42-.34.77-.77.77H3.77a.77.77 0 01-.77-.77V8.17c0-.42.34-.77.77-.77z" fill="#5a62c3"/><path d="M9.62 10.32H8.09v4.18h-.98v-4.18H5.58v-.81h4.04v.81z" fill="#fff"/>'
}, G2 = {
  box: "M15.39,14.04V14.04C15.39,12.62 14.24,11.47 12.82,11.47C11.41,11.47 10.26,12.62 10.26,14.04V14.04C10.26,15.45 11.41,16.6 12.82,16.6C14.24,16.6 15.39,15.45 15.39,14.04M17.1,14.04C17.1,16.4 15.18,18.31 12.82,18.31C11.19,18.31 9.77,17.39 9.05,16.04C8.33,17.39 6.91,18.31 5.28,18.31C2.94,18.31 1.04,16.43 1,14.11V14.11H1V7H1V7C1,6.56 1.39,6.18 1.86,6.18C2.33,6.18 2.7,6.56 2.71,7V7H2.71V10.62C3.43,10.08 4.32,9.76 5.28,9.76C6.91,9.76 8.33,10.68 9.05,12.03C9.77,10.68 11.19,9.76 12.82,9.76C15.18,9.76 17.1,11.68 17.1,14.04V14.04M7.84,14.04V14.04C7.84,12.62 6.69,11.47 5.28,11.47C3.86,11.47 2.71,12.62 2.71,14.04V14.04C2.71,15.45 3.86,16.6 5.28,16.6C6.69,16.6 7.84,15.45 7.84,14.04M22.84,16.96V16.96C22.95,17.12 23,17.3 23,17.47C23,17.73 22.88,18 22.66,18.15C22.5,18.26 22.33,18.32 22.15,18.32C21.9,18.32 21.65,18.21 21.5,18L19.59,15.47L17.7,18V18C17.53,18.21 17.28,18.32 17.03,18.32C16.85,18.32 16.67,18.26 16.5,18.15C16.29,18 16.17,17.72 16.17,17.46C16.17,17.29 16.23,17.11 16.33,16.96V16.96H16.33V16.96L18.5,14.04L16.33,11.11V11.11H16.33V11.11C16.22,10.96 16.17,10.79 16.17,10.61C16.17,10.35 16.29,10.1 16.5,9.93C16.89,9.65 17.41,9.72 17.7,10.09V10.09L19.59,12.61L21.5,10.09C21.76,9.72 22.29,9.65 22.66,9.93C22.89,10.1 23,10.36 23,10.63C23,10.8 22.95,10.97 22.84,11.11V11.11H22.84V11.11L20.66,14.04L22.84,16.96V16.96H22.84Z",
  dropbox: "M3 6.2L8 9.39L13 6.2L8 3L3 6.2M13 6.2L18 9.39L23 6.2L18 3L13 6.2M3 12.55L8 15.74L13 12.55L8 9.35L3 12.55M18 9.35L13 12.55L18 15.74L23 12.55L18 9.35M8.03 16.8L13.04 20L18.04 16.8L13.04 13.61L8.03 16.8Z",
  "google-drive": "M7.71,3.5L1.15,15L4.58,21L11.13,9.5M9.73,15L6.3,21H19.42L22.85,15M22.28,14L15.42,2H8.58L8.57,2L15.43,14H22.28Z",
  onedrive: "M18.21 10.29Q19 10.34 19.7 10.68 20.39 11 20.9 11.57 21.41 12.12 21.71 12.83 22 13.54 22 14.34 22 15.18 21.68 15.92 21.36 16.66 20.8 17.21 20.25 17.76 19.5 18.08 18.78 18.41 17.94 18.41H7Q5.97 18.41 5.06 18 4.15 17.61 3.47 16.94 2.79 16.26 2.4 15.35 2 14.44 2 13.41 2 12.59 2.26 11.83 2.5 11.08 3 10.45 3.44 9.82 4.08 9.35 4.72 8.88 5.5 8.63 5.87 8.5 6.21 8.5 6.56 8.43 6.93 8.41H6.94Q7.37 7.75 7.95 7.23 8.5 6.71 9.2 6.34 9.87 6 10.62 5.78 11.37 5.59 12.16 5.59 13.22 5.59 14.2 5.94 15.18 6.29 16 6.91 16.8 7.53 17.37 8.39 17.95 9.26 18.21 10.29M12.16 6.84Q11.05 6.84 10.06 7.3 9.06 7.75 8.36 8.6 8.73 8.7 9.07 8.85 9.4 9 9.73 9.2L13.71 11.58L16 10.62Q16.21 10.53 16.44 10.45 16.67 10.38 16.92 10.33 16.68 9.55 16.21 8.91 15.74 8.27 15.11 7.81 14.5 7.35 13.73 7.1 13 6.84 12.16 6.84M4 15.66L12.27 12.18L9.08 10.26Q8.59 9.97 8.06 9.81 7.5 9.66 6.95 9.66 6.19 9.66 5.5 9.96 4.84 10.26 4.34 10.77 3.84 11.29 3.54 11.97 3.25 12.65 3.25 13.41 3.25 14 3.45 14.59 3.64 15.19 4 15.66M17.94 17.16Q18.41 17.16 18.84 17 19.27 16.86 19.64 16.58L13.61 13L5.03 16.59Q5.47 16.86 5.97 17 6.47 17.16 7 17.16M20.45 15.61Q20.75 15 20.75 14.34 20.75 13.7 20.5 13.17 20.26 12.65 19.85 12.28 19.43 11.91 18.88 11.71 18.32 11.5 17.7 11.5 17.35 11.5 17 11.6 16.66 11.68 16.33 11.81 16 11.93 15.67 12.08 15.35 12.23 15.04 12.37Z"
}, Z2 = {
  email: Jb,
  file: i2,
  "file-upload": o2,
  "file-music": n2,
  "file-image": s2,
  "file-video": c2,
  "file-code": Kw,
  "file-xml": Kw,
  "file-document": Gw,
  "file-word": l2,
  "file-excel": r2,
  "file-pdf": Gw,
  "file-powerpoint": a2,
  "file-compressed": p2
}, Xw = {
  "account-minus": xb,
  "account-plus": $b,
  alert: Cb,
  "alert-circle": kb,
  "alert-octagon": _b,
  "arrow-collapse": Pb,
  "arrow-expand": Mb,
  attachment: Ab,
  back: Qw,
  "backup-restore": zb,
  bell: Rb,
  "bell-off": Eb,
  agent: H2,
  check: Ip,
  "check-all": Ob,
  "check-circle-outline": Tb,
  "checkbox-blank": Fb,
  "checkbox-marked": Db,
  "circle-outline": Hb,
  "check-circle": Ib,
  close: Vb,
  "close-circle": Ub,
  cloud: Bb,
  comment: qb,
  "comment-outline": Nb,
  "content-save": jb,
  delete: Qb,
  "delete-restore": Gb,
  "delete-forever": Kb,
  "dots-vertical": Zb,
  download: Yb,
  earth: Xb,
  emoticon: t2,
  "emoticon-plus": e2,
  "fit-screen": h2,
  "fit-width": d2,
  fullscreen: y2,
  "fullscreen-exit": w2,
  "help-circle": f2,
  information: m2,
  magnify: v2,
  meeting: k2,
  "menu-down": g2,
  "menu-up": b2,
  message: x2,
  "message-text": $2,
  minus: C2,
  next: Sb,
  "open-in-new": _2,
  pencil: P2,
  pin: M2,
  unpin: S2,
  plus: A2,
  "plus-circle-outline": z2,
  poll: Lb,
  previous: Qw,
  read: Ip,
  restore: R2,
  unread: Ip,
  send: L2,
  "server-network-off": O2,
  "shield-star": I2,
  "shield-star-outline": T2,
  sort: F2,
  star: D2,
  unstar: V2,
  stars: Wb,
  "swap-horizontal": U2,
  textbox: u2,
  "thumb-up": B2,
  "thumb-up-outline": q2,
  trashcan: N2,
  video: j2,
  "view-list-outline": W2,
  "view-module-outline": Q2,
  "wifi-off": K2,
  ...Z2,
  ...G2
}, Jw = {
  dropbox: "#0061fe",
  onedrive: "#0078d4",
  box: "#0161d5",
  "google-drive": "#1a73e8",
  zoom: "#4a8cff"
};
function tf(i) {
  return i && i in Xw ? Xw[i] : "";
}
a(tf, "getIconMapping");
function Y2(i) {
  return i && i in Yw ? Yw[i] : "";
}
a(Y2, "getSvgMapping");
const mw = class mw extends Vc {
  constructor(t) {
    if (super(t), this.it = v, t.type !== od.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(t) {
    if (t === v || t == null) return this._t = void 0, this.it = t;
    if (t === hh) return t;
    if (typeof t != "string") throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (t === this.it) return this._t;
    this.it = t;
    const e = [t];
    return e.raw = e, this._t = { _$litType$: this.constructor.resultType, strings: e, values: [] };
  }
};
a(mw, "e");
let xc = mw;
xc.directiveName = "unsafeHTML", xc.resultType = 1;
const bs = Bs(xc);
const vw = class vw extends xc {
};
a(vw, "t");
let yl = vw;
yl.directiveName = "unsafeSVG", yl.resultType = 2;
const ef = Bs(yl), dy = B`[part~=wy-icon-wrapper]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative}[part~=wy-icon]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-icon][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon-first]{margin-left:calc(-.5*var(--wy-size, 1rem))}[part~=wy-icon-last]{margin-right:calc(-.5*var(--wy-size, 1rem))}[part~=wy-icon-inline]{vertical-align:-.25em}[part~=wy-icon-overlay]{position:absolute;bottom:0;right:0;border-radius:50%}:host(wy-icon-stack),[part~=wy-icon-stack]{display:inline-flex;position:relative;line-height:1}[part~=wy-icon-stack-layer]{position:absolute}[part~=wy-icon-stack-overlay]{position:absolute;bottom:0;right:0;border-radius:50%;width:calc(var(--wy-component-icon-width)/2);height:calc(var(--wy-component-icon-height)/2)}[part~=wy-icon-current-color]{fill:currentColor}[part~=wy-icon-state]{transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));align-self:center;justify-self:center;margin:auto;opacity:0}[part~=wy-icon-state][part~=wy-active]{opacity:1}[part~=wy-icon-display]{color:var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));border-radius:var(--wy-component-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;padding:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem))}[part~=wy-icon-display-fill]{flex:1 0 auto}[part~=wy-icon-display-icon]{color:var(--wy-component-color);--wy-component-icon-width: calc(4 * var(--wy-size, 1rem));--wy-component-icon-height: calc(4 * var(--wy-size, 1rem));padding:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem))}[part~=wy-icon-display-text],[part~=wy-icon-display-meta]{color:var(--wy-component-color);padding:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem));text-align:center;line-height:var(--wy-line-height, 1.5)}[part~=wy-icon-color-primary]{fill:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-icon-color-secondary]{fill:var(--wy-secondary, var(--wy-secondary-light, #51606f))}[part~=wy-icon-color-tertiary]{fill:var(--wy-tertiary, var(--wy-tertiary-light, #645f41))}[part~=wy-icon-color-surface]{fill:var(--wy-surface, var(--wy-surface-light, #f7f9ff))}[part~=wy-icon-color-surface-variant]{fill:var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb))}[part~=wy-icon-color-error]{fill:var(--wy-error, var(--wy-error-light, #ba1821))}[part~=wy-icon-color-warning]{fill:var(--wy-warning, var(--wy-warning-light, #adb140))}[part~=wy-icon-color-blue]{fill:var(--wy-blue, var(--wy-blue-light, #8aa9fc))}[part~=wy-icon-color-indigo]{fill:var(--wy-indigo, var(--wy-indigo-light, #9285de))}[part~=wy-icon-color-purple]{fill:var(--wy-purple, var(--wy-purple-light, #c675b6))}[part~=wy-icon-color-pink]{fill:var(--wy-pink, var(--wy-pink-light, #d57193))}[part~=wy-icon-color-red]{fill:var(--wy-red, var(--wy-red-light, #db726b))}[part~=wy-icon-color-orange]{fill:var(--wy-orange, var(--wy-orange-light, #e79b3a))}[part~=wy-icon-color-yellow]{fill:var(--wy-yellow, var(--wy-yellow-light, #adb140))}[part~=wy-icon-color-green]{fill:var(--wy-green, var(--wy-green-light, #00a38d))}[part~=wy-icon-color-teal]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a9))}[part~=wy-icon-color-cyan]{fill:var(--wy-cyan, var(--wy-cyan-light, #0081a2))}[part~=wy-icon-color-gray]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-icon-color-black]{fill:var(--wy-black, var(--wy-black, #000000))}[part~=wy-icon-color-white]{fill:var(--wy-white, var(--wy-white, #ffffff))}[part*=wy-kind-]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-kind-archive]{fill:var(--wy-orange, var(--wy-orange-light, #e79b3a))}[part~=wy-kind-audio]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a9))}[part~=wy-kind-code]{fill:var(--wy-green, var(--wy-green-light, #00a38d))}[part~=wy-kind-document]{fill:var(--wy-blue, var(--wy-blue-light, #8aa9fc))}[part~=wy-kind-email]{fill:var(--wy-red, var(--wy-red-light, #db726b))}[part~=wy-kind-presentation]{fill:var(--wy-orange, var(--wy-orange-light, #e79b3a))}[part~=wy-kind-spreadsheet]{fill:var(--wy-green, var(--wy-green-light, #00a38d))}[part~=wy-kind-image]{fill:var(--wy-pink, var(--wy-pink-light, #d57193))}[part~=wy-kind-text]{fill:var(--wy-cyan, var(--wy-cyan-light, #0081a2))}[part~=wy-kind-video]{fill:var(--wy-purple, var(--wy-purple-light, #c675b6))}[part~=wy-ext-pdf]{fill:var(--wy-red, var(--wy-red-light, #db726b))}[part~=wy-kind-text-icon]{width:calc(1.25*var(--wy-size, 1rem));height:calc(1.25*var(--wy-size, 1rem));vertical-align:calc(-.3125*var(--wy-size, 1rem))}`;
var X2 = Object.defineProperty, J2 = Object.getOwnPropertyDescriptor, Wt = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? J2(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && X2(t, e, s), s;
}, "__decorateClass$1a"), Sa;
let Ht = (Sa = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.color = "", this.size = 24, this.path = Zw, this.inline = !1, this.first = !1, this.last = !1, this.layer = !1, this.state = !1, this.active = !1, this.uniqueId = `wy-icon-${ol()}`;
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("name") && this.name && (this.path = tf(this.name) || Zw, this.overlayPath = tf(this.overlayName) || this.overlayPath, this.nativeIconColor = this.color === "native" && Jw[this.name] || void 0, this.nativeOverlayColor = this.overlayName && Jw[this.overlayName] || void 0);
  }
  render() {
    const t = this.kind ? Vf(this.kind) : this.kind, e = this.ext?.startsWith(".") ? this.ext.substring(1) : this.ext, r = {
      "wy-icon-wrapper": !0,
      "wy-icon-stack-layer": this.layer
    }, s = {
      "wy-icon": !0,
      "wy-icon-current-color": !t && !this.color,
      ["wy-kind-" + t]: !!t,
      ["wy-ext-" + e]: !!e,
      ["wy-icon-color-" + this.color]: !!this.color,
      "wy-icon-first": this.first,
      "wy-icon-last": this.last,
      "wy-icon-inline": this.inline,
      "wy-icon-state": this.state,
      "wy-active": this.active
    }, n = this.size !== 24, o = this.size / 16, c = n ? `width: var(--wy-component-icon-width, calc(${o} * var(--wy-size, 1rem))); height: var(--wy-component-icon-height, calc(${o} * var(--wy-size, 1rem)));` : "", l = this.svg && Y2(this.svg);
    return this.overlayPath ? [
      h`
          <style>
            .icon-mask-bg {
              width: var(--wy-component-icon-width, calc(${o} * var(--wy-size, 1rem)));
              height: var(--wy-component-icon-height, calc(${o} * var(--wy-size, 1rem)));
              fill: white;
            }

            .icon-mask {
              width: calc(var(--wy-component-icon-width, calc(${o} * var(--wy-size, 1rem))));
              height: calc(var(--wy-component-icon-height, calc(${o} * var(--wy-size, 1rem))));
              ry: calc(var(--wy-border-radius-pill, var(--wy-border-radius, 50%)));
              x: calc(var(--wy-component-icon-width, calc(${o} * var(--wy-size, 1rem))) / 2);
              y: calc(var(--wy-component-icon-height, calc(${o} * var(--wy-size, 1rem))) / 2);
              stroke: black;
              stroke-width: 4px;
              fill: black;
            }
          </style>
        `,
      h`
          <div part=${K(r)}>
            <wy-icon-stack style="${c}">
              <svg
                part=${K(s)}
                viewBox="0 0 24 24"
                width="${this.size}"
                height="${this.size}"
                style="mask-image: url(#${this.uniqueId}-mask); -webkit-mask-image: url(#${this.uniqueId}-mask);"
              >
                <defs>
                  <mask id="${this.uniqueId}-mask">
                    <rect class="icon-mask-bg" />
                    <rect class="icon-mask" />
                  </mask>
                </defs>
                ${l ? ef(l) : Id`
                    <path d="${this.path}" style="fill: ${nt(this.nativeIconColor)}" />
                  `}
                <!--rect width="24" height="24" fill="transparent" /-->
              </svg>
              <svg part="wy-icon-stack-overlay" viewBox="0 0 24 24" width="${this.size / 2}" height="${this.size / 2}">
                <path d="${this.overlayPath}" style="fill: ${nt(this.nativeOverlayColor)}" />
                <!--rect width="24" height="24" fill="transparent" /-->
              </svg>
            </wy-icon-stack>
            <slot></slot>
          </div>
        `
    ] : h`
      <div part=${K(r)}>
        <svg
          part=${K(s)}
          style="${c}"
          viewBox="0 0 24 24"
          width="${this.size}"
          height="${this.size}"
        >
          ${l ? ef(l) : Id`
            <path d="${this.path}" style="fill: ${nt(this.nativeIconColor)}" />
          `}
          <!--rect width="24" height="24" fill="transparent" /-->
        </svg>
        <slot></slot>
      </div>
    `;
  }
}, a(Sa, "WyIcon"), Sa);
Ht.styles = [zt, dy, Z];
Wt([
  p()
], Ht.prototype, "name", 2);
Wt([
  p()
], Ht.prototype, "overlayName", 2);
Wt([
  p()
], Ht.prototype, "svg", 2);
Wt([
  p()
], Ht.prototype, "color", 2);
Wt([
  p({ type: Number })
], Ht.prototype, "size", 2);
Wt([
  p()
], Ht.prototype, "kind", 2);
Wt([
  p()
], Ht.prototype, "ext", 2);
Wt([
  p({ attribute: !1 })
], Ht.prototype, "path", 2);
Wt([
  p({ attribute: !1 })
], Ht.prototype, "overlayPath", 2);
Wt([
  p({ type: Boolean })
], Ht.prototype, "inline", 2);
Wt([
  p({ type: Boolean })
], Ht.prototype, "first", 2);
Wt([
  p({ type: Boolean })
], Ht.prototype, "last", 2);
Wt([
  p({ type: Boolean })
], Ht.prototype, "layer", 2);
Wt([
  p({ type: Boolean })
], Ht.prototype, "state", 2);
Wt([
  p({ type: Boolean })
], Ht.prototype, "active", 2);
Wt([
  F()
], Ht.prototype, "nativeIconColor", 2);
Wt([
  F()
], Ht.prototype, "nativeOverlayColor", 2);
Ht = Wt([
  H("wy-icon")
], Ht);
var Aa;
let Zd = (Aa = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this);
  }
  render() {
    return h`<slot></slot>`;
  }
}, a(Aa, "WyIconStack"), Aa);
Zd.styles = [zt, dy];
Zd = Wt([
  H("wy-icon-stack")
], Zd);
var za;
let wl = (za = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.fill = !1;
  }
  render() {
    return h`
      <div part="wy-icon-display ${K({ "wy-icon-display-fill": this.fill })}">
        <div part="wy-icon-display-icon">
          <slot></slot>
        </div>
        <div part="wy-icon-display-text">
          <slot name="text"></slot>
        </div>
        <div part="wy-icon-display-meta">
          <slot name="meta"></slot>
        </div>
      </div>
    `;
  }
}, a(za, "WyIconDisplay"), za);
wl.styles = [zt, dy, Z];
Wt([
  p({ type: Boolean })
], wl.prototype, "fill", 2);
wl = Wt([
  H("wy-icon-display")
], wl);
var t5 = Object.defineProperty, e5 = Object.getOwnPropertyDescriptor, Ge = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? e5(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && t5(t, e, s), s;
}, "__decorateClass$19"), Ra;
let ki = (Ra = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.size = 32, this.src = "", this.name = "", this.description = "", this.isAgent = !1;
  }
  render() {
    const t = this.size / 16;
    let e;
    !this.src && this.name && (e = m1(this.name));
    const r = {
      "wy-avatar-shape": !0,
      "wy-avatar-img": !!this.src,
      "wy-avatar-initials": !this.src,
      "wy-presence-mask": this.presence === oy.Active
    };
    return h`
      ${this.src ? h`
            <img
              alt=""
              title="${this.name}${this.description ? ` • ${this.description}` : ""}"
              part=${K(r)}
              style="--wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));"
              height="${this.size}"
              width="${this.size}"
              src="${this.src}"
              decoding="async"
              loading="lazy"
            />
          ` : h`
            <div
              part=${K(r)}
              style="--wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));"
              title="${this.name}${this.description ? ` • ${this.description}` : ""}"
            >
              <span part="wy-avatar-initials-text">${e}</span>
            </div>
          `}
      ${this.isAgent ? h`<wy-icon part="wy-avatar-type-icon" name="agent" size="${this.size / 3 * 1.25}"></wy-icon>` : v}
      ${this.presence && !this.isAgent ? h`<wy-presence part="wy-avatar-presence" .status=${this.presence} id=${this.id}></wy-presence>` : v}
    `;
  }
}, a(Ra, "WyAvatar"), Ra);
ki.styles = [zt, cy, Vm];
Ge([
  p({ type: Number })
], ki.prototype, "size", 2);
Ge([
  p()
], ki.prototype, "src", 2);
Ge([
  p()
], ki.prototype, "name", 2);
Ge([
  p()
], ki.prototype, "description", 2);
Ge([
  p({ type: Boolean, reflect: !0 })
], ki.prototype, "isAgent", 2);
Ge([
  p()
], ki.prototype, "presence", 2);
ki = Ge([
  H("wy-avatar")
], ki);
var Ea;
let xs = (Ea = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.size = 32, this.uniqueId = `wy-avatar-${ol()}`;
  }
  render() {
    if (!this.user)
      return v;
    const t = this.size / 16, e = (this.members || []).filter((n) => n.id !== this.user?.id).slice(0, 2).reverse(), r = e?.shift() || this.user, s = e?.shift() || (r !== this.user ? this.user : void 0);
    return [
      h`
        <style>
          :host {
            --wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));
          }

          [part~="wy-avatar-mask-bg"] {
            width: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            height: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            fill: white;
          }

          [part~="wy-avatar-mask"] {
            width: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            height: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            ry: var(--wy-avatar-border-radius, var(--wy-border-radius-pill, var(--wy-border-radius, 50%)));
            x: calc(${t / 3} * var(--wy-size, 1rem));
            y: calc(${t / 3} * var(--wy-size, 1rem));
            stroke: black;
            stroke-width: 4px;
            fill: black;
          }
        </style>
      `,
      h`
        <svg>
          <defs>
            <mask id="${this.uniqueId}-mask">
              <rect part="wy-avatar-mask-bg" />
              <rect part="wy-avatar-mask" />
            </mask>
          </defs>
        </svg>
      `,
      h`
        <wy-avatar
          part="wy-avatar-back"
          style="mask-image: url(#${this.uniqueId}-mask); -webkit-mask-image: url(#${this.uniqueId}-mask);"
          .src=${s?.avatar_url}
          .name=${s?.name}
          size=${this.size * 2 / 3}
        ></wy-avatar>
        <wy-avatar
          part="wy-avatar-front"
          .src=${r.avatar_url}
          .name=${r.name}
          .isAgent=${r.is_agent}
          size=${this.size * 2 / 3}
        ></wy-avatar>
      `
    ];
  }
}, a(Ea, "WyAvatarGroup"), Ea);
xs.styles = [zt, cy, Z];
Ge([
  p({ type: Number })
], xs.prototype, "size", 2);
Ge([
  p({
    type: Array,
    attribute: !1
  })
], xs.prototype, "members", 2);
Ge([
  he({ context: uh, subscribe: !0 }),
  F()
], xs.prototype, "user", 2);
xs = Ge([
  H("wy-avatar-group")
], xs);
var La;
let fl = (La = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this);
  }
  render() {
    return h`
      <slot></slot>
      ${this.description ? h` <div part="wy-avatar-description">${this.description}</div> ` : v}
    `;
  }
}, a(La, "WyAvatarHeader"), La);
fl.styles = [zt, cy];
Ge([
  p()
], fl.prototype, "description", 2);
fl = Ge([
  H("wy-avatar-header")
], fl);
const i5 = B`[part~=wy-empty]{display:flex;align-items:center;justify-content:center;flex:1;min-width:0;position:relative;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}`, Um = B`[part~=wy-progress]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative}[part~=wy-progress-padded]{margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-progress-overlay]{position:absolute!important}[part~=wy-progress-reveal]{overflow:hidden;opacity:1;interpolate-size:allow-keywords;height:auto;transition:width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),margin var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-progress-reveal]{width:0;height:0;opacity:0;margin:0}}`, r5 = B`[part~=wy-progress-circular]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-progress-circular]:not([width]),[part~=wy-progress-circular][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress-circular]:not([height]),[part~=wy-progress-circular][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress-circular][part~=wy-primary]{color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-progress-remaining]{fill:none;stroke:var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb))}[part~=wy-progress-done]{fill:none;stroke:currentColor}[part~=wy-progress-overlay]{position:absolute;inset:0;margin:auto}[part~=wy-progress-indeterminate-circle]{stroke-dasharray:1,100;stroke-dashoffset:0;transform-origin:center;fill:none!important}[part~=wy-progress-indeterminate]{animation:wy-rotate 1.4s linear infinite}[part~=wy-progress-indeterminate] [part~=wy-progress-indeterminate-circle]{animation:wy-dash 1.4s ease-in-out infinite,wy-color 2.8s ease-in-out infinite}@keyframes wy-rotate{to{transform:rotate(360deg)}}@keyframes wy-dash{0%{stroke-dasharray:1,100;stroke-dashoffset:0}50%{stroke-dasharray:44.5,100;stroke-dashoffset:-17.5}to{stroke-dasharray:44.5,100;stroke-dashoffset:-62}}@keyframes wy-color{0%,to{stroke:var(--wy-primary, var(--wy-primary-light, #2f628c))}25%{stroke:var(--wy-primary, var(--wy-primary-light, #2f628c))}50%{stroke:#0000}75%{stroke:var(--wy-primary, var(--wy-primary-light, #2f628c))}}`;
var s5 = Object.defineProperty, n5 = Object.getOwnPropertyDescriptor, qr = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? n5(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && s5(t, e, s), s;
}, "__decorateClass$18"), Oa;
let oi = (Oa = class extends X {
  constructor() {
    super(...arguments), this.shadowParts = new U(this), this.size = 24, this.indeterminate = !1, this.padded = !1, this.overlay = !1, this.value = 0, this.max = 1, this.reveal = !1;
  }
  render() {
    const t = {
      "wy-progress": !0,
      "wy-progress-reveal": this.reveal,
      "wy-progress-overlay": this.overlay,
      "wy-progress-padded": this.padded
    }, e = {
      "wy-progress-circular": !0,
      "wy-primary": !this.indeterminate,
      "wy-progress-indeterminate": this.indeterminate
    }, r = 10, s = Math.PI * (r * 2);
    let n;
    try {
      Number.isFinite(this.value) && Number.isFinite(this.max) && this.max > 0 && (n = this.value / this.max);
    } catch (o) {
      console.error(o);
    }
    return h`
      <div part="${K(t)}">
        ${this.indeterminate || n === void 0 ? Id`
              <svg
                part="${K(e)}"
                viewBox="0 0 24 24"
                width=${this.size}
                height=${this.size}
                role="progressbar"
                aria-label="${v}"
                aria-valuemin="0"
                aria-valuemax=${this.max}
                aria-valuenow=${v}
                xmlns="http://www.w3.org/2000/svg"
              >
                <circle
                  part="wy-progress-circle wy-progress-indeterminate-circle"
                  fill="none"
                  cx="12"
                  cy="12"
                  r=${r}
                  stroke-linecap="butt"
                  stroke-width="2"
                ></circle>
              </svg>
            ` : Id`
              <svg
                part="${K(e)}"
                viewBox="0 0 24 24"
                width=${this.size}
                height=${this.size}
                transform="rotate(-90)"
                role="progressbar"
                aria-label="${v}"
                aria-valuemin="0"
                aria-valuemax=${this.max}
                aria-valuenow=${this.value}
                xmlns="http://www.w3.org/2000/svg"
              >
                <circle
                  part="wy-progress-circle wy-progress-remaining"
                  cx="12"
                  cy="12"
                  r=${r}
                  stroke-linecap="butt"
                  stroke-width="2"
                  fill="none"
                  stroke="#eee"
                ></circle>
                <circle
                  part="wy-progress-circle wy-progress-done"
                  cx="12"
                  cy="12"
                  r=${r}
                  stroke-dasharray=${s}
                  stroke-dashoffset=${s * (1 - n)}
                  stroke-linecap="butt"
                  stroke-width="2"
                  fill="none"
                  stroke="currentColor"
                  path-length="200"
                ></circle>
              </svg>
            `}
      </div>
    `;
  }
}, a(Oa, "WyProgressCircular"), Oa);
oi.styles = [zt, Um, r5, Z];
qr([
  p({ type: Number })
], oi.prototype, "size", 2);
qr([
  p({ type: Boolean })
], oi.prototype, "indeterminate", 2);
qr([
  p({ type: Boolean })
], oi.prototype, "padded", 2);
qr([
  p({ type: Boolean })
], oi.prototype, "overlay", 2);
qr([
  p({ type: Number })
], oi.prototype, "value", 2);
qr([
  p({ type: Number })
], oi.prototype, "max", 2);
qr([
  p({ type: Boolean })
], oi.prototype, "reveal", 2);
oi = qr([
  H("wy-progress-circular")
], oi);
var a5 = Object.defineProperty, o5 = Object.getOwnPropertyDescriptor, hy = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? o5(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && a5(t, e, s), s;
}, "__decorateClass$17"), Ia;
let $c = (Ia = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.noNetwork = !1, this.handleUpdate = () => this.requestUpdate();
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("weavy")) {
      const e = t.get("weavy");
      e && e !== this.weavy && e.removeNetworkListener(this.handleUpdate), this.weavy && e !== this.weavy && this.weavy.addNetworkListener(this.handleUpdate);
    }
  }
  render() {
    return h`
      <div part="wy-empty">
        ${this.weavy && !this.noNetwork && this.weavy?.network.state === "unreachable" ? h`
              <wy-icon-display>
                <wy-icon name="server-network-off"></wy-icon>
                <span slot="text">${b("The server is offline, try again in a few minutes...")}</span>
                <wy-progress-circular indeterminate slot="meta" ?hidden=${!this.weavy?.network.isPending}></wy-progress-circular>
              </wy-icon-display>
            ` : !this.noNetwork && this.weavy?.network.state === "offline" ? h`
              <wy-icon-display>
                <wy-icon name="wifi-off"></wy-icon>
                <span slot="text">${b("You are currently offline.")}</span>
                <wy-progress-circular indeterminate slot="meta" ?hidden=${!this.weavy?.network.isPending}></wy-progress-circular>
              </wy-icon-display>
            ` : h`
              <slot>
                <wy-icon-display>
                  <wy-icon name="information"></wy-icon>
                  <slot slot="text" name="title">
                    <span>${b("Nothing to see here yet.")}</span>
                  </slot>
                </wy-icon-display>
              </slot>
            `}
      </div>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.weavy?.addNetworkListener(this.handleUpdate);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.weavy?.removeNetworkListener(this.handleUpdate);
  }
}, a(Ia, "WyEmpty"), Ia);
$c.styles = [
  i5,
  Z
];
hy([
  he({ context: re, subscribe: !0 }),
  F()
], $c.prototype, "weavy", 2);
hy([
  p({ type: Boolean })
], $c.prototype, "noNetwork", 2);
$c = hy([
  H("wy-empty"),
  ot()
], $c);
const c5 = B`@keyframes wy-bouncing{to{transform:translate3d(0,calc(-.25 * var(--wy-size, 1rem)),0)}}@keyframes wy-bouncing-fade{to{opacity:.2}}[part~=wy-bouncer]{width:calc(1.5*var(--wy-size, 1rem));height:calc(.75*var(--wy-size, 1rem))}[part~=wy-bouncer-dot]{position:relative;animation:wy-bouncing .6s infinite alternate,wy-bouncing-fade .6s infinite alternate;fill:currentColor}[part~=wy-bouncer-dot-start]{animation-delay:0s,.6s}[part~=wy-bouncer-dot-middle]{animation-delay:.3s,.3s}[part~=wy-bouncer-dot-end]{animation-delay:.6s,0s}`;
var l5 = Object.defineProperty, d5 = Object.getOwnPropertyDescriptor, or = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? d5(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && l5(t, e, s), s;
}, "__decorateClass$16"), Ta;
let ti = (Ta = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.typing = new Qd(this), this.isPrivateChat = !1, this.members = [], this.typingMembers = [], this.names = [];
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("conversationId") && (this.typing.appId = this.conversationId), t.has("userId") && (this.typing.userId = this.userId);
    const { typingMembers: e, names: r } = this.typing;
    this.typingMembers = e, this.names = r, e.length ? this.typingTime ||= /* @__PURE__ */ new Date() : this.typingTime = void 0;
  }
  render() {
    const t = this.typingMembers.map(
      (o) => this.members.find((c) => c.id === o.id)
    ).filter((o) => o), e = new Intl.ListFormat(this.weavy?.locale, { style: "long", type: "conjunction" }).format(
      this.names
    ), r = this.typingTime ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(this.typingTime) : "", s = this.typingTime ? new Intl.DateTimeFormat(this.weavy?.locale, { timeStyle: "short" }).format(this.typingTime) : "", n = h`
      <svg part="wy-bouncer" viewBox="0 0 32 16" xmlns="http://www.w3.org/2000/svg">
        <circle part="wy-bouncer-dot wy-bouncer-dot-start" cx="4" cy="10" r="4" />
        <circle part="wy-bouncer-dot wy-bouncer-dot-middle" cx="16" cy="10" r="4" />
        <circle part="wy-bouncer-dot wy-bouncer-dot-end" cx="28" cy="10" r="4" />
      </svg>
    `;
    return t.length ? h`
          <div part=${K({ "wy-message": !0, "wy-message-agent": !!t[0]?.is_agent })}>
            <div part="wy-message-author">
              ${t.length > 1 ? h`
                    <wy-avatar-group
                      .size=${32}
                      .members=${t}
                      title=${e}
                    ></wy-avatar-group>
                  ` : h`
                    <wy-avatar
                      .size=${32}
                      .src=${t[0]?.avatar_url}
                      .description=${t[0]?.comment}
                      .name=${e}
                      .isAgent=${t[0]?.is_agent}
                    ></wy-avatar>
                  `}
            </div>

            <div part="wy-message-content">
              <div part="wy-message-meta">
                ${this.isPrivateChat ? h`
                      <time datetime=${nt(this.typingTime?.toISOString())} title=${r}>${s}</time>
                    ` : e}
              </div>
              <div part="wy-message-bubble"> ${n} </div>
            </div>
          </div>
        ` : v;
  }
}, a(Ta, "WyMessageTyping"), Ta);
ti.styles = [zt, c5, vh];
or([
  he({ context: re, subscribe: !0 }),
  F()
], ti.prototype, "weavy", 2);
or([
  p({ attribute: !0, type: Number })
], ti.prototype, "conversationId", 2);
or([
  p({ attribute: !0, type: Number })
], ti.prototype, "userId", 2);
or([
  p({ type: Boolean })
], ti.prototype, "isPrivateChat", 2);
or([
  p({ attribute: !1 })
], ti.prototype, "members", 2);
or([
  F()
], ti.prototype, "typingMembers", 2);
or([
  F()
], ti.prototype, "names", 2);
or([
  F()
], ti.prototype, "typingTime", 2);
ti = or([
  H("wy-message-typing")
], ti);
const gh = B`:host(wy-item),[part~=wy-item]{--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));display:flex;clip-path:border-box;box-sizing:border-box}[part~=wy-item-rounded]{border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-item-rounded-outer]{border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-item-inner]{display:flex;position:relative;align-items:center;text-decoration:none;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));flex:1 1 100%;min-width:0}[part~=wy-item-inner-no-padding]{padding:0}[part~=wy-item-sm]{min-height:calc(2*var(--wy-size, 1rem));padding:0 var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-item-md]{min-height:calc(3*var(--wy-size, 1rem))}[part~=wy-item-lg]{min-height:calc(4.5*var(--wy-size, 1rem))}[part~=wy-item-top]{align-items:flex-start}[part~=wy-item-body]{width:100%;min-width:0;min-height:100%;display:flex}[part~=wy-item-rows]{display:flex;flex-direction:column;min-width:0;justify-content:space-evenly;flex:1 1 100%}[part~=wy-item-row]{display:flex;align-items:center;column-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));min-height:calc(var(--wy-button-line-height, var(--wy-line-height, 1.5))*var(--wy-size, 1rem))}[part~=wy-item-title] a:after{position:absolute;inset:0;z-index:1;content:\"\"}[part~=wy-item-title] a{color:inherit;text-decoration:none}[part~=wy-item-title]{color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset))}[part~=wy-item-title]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-item-image]{display:contents}[part~=wy-item-text]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-item-text]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-item-text-sm]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))}[part~=wy-item-meta]{white-space:nowrap}[part~=wy-item-actions]{--wy-component-background-color: transparent;display:flex;align-items:center;justify-items:flex-end;flex:0 0 auto;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-item-actions-top]{align-self:flex-start;margin:calc(-.25*var(--wy-size, 1rem))}[part~=wy-item-actions-bottom]{align-self:flex-start;margin:calc(-.125*var(--wy-size, 1rem)) 0 calc(-.625*var(--wy-size, 1rem))}[part~=wy-item-left]{margin-right:auto}[part~=wy-item-right]{margin-left:auto}[part~=wy-read]{opacity:var(--wy-opacity-muted, 65%);--wy-component-color: var(--wy-outline, var(--wy-outline-light, #72777f))}[part~=wy-unread]{--wy-component-color: color.token(--wy-on-background)}[part~=wy-unread] [part~=wy-item-title],[part~=wy-unread] [part~=wy-item-text]{font-weight:var(--wy-font-weight-bold, 600);color:var(--wy-component-color)}[part~=wy-item-interactive]{background-color:var(--wy-component-background-color);color:var(--wy-component-color);-webkit-user-select:none;user-select:none;cursor:pointer}[part~=wy-item-interactive]:hover,[part~=wy-item-interactive]:focus{--wy-component-background-color: var(--wy-component-background-color-hover, var(--wy-surface-layer-high, var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039))));text-decoration:none}[part~=wy-item-interactive]:active{--wy-component-background-color: var(--wy-component-background-color-active, var(--wy-surface-layer-highest, var(--wy-surface-layer-highest-light, rgba(0, 0, 0, .1019607843))))}[part~=wy-item-interactive][part~=wy-disabled],[part~=wy-item-interactive]:disabled{opacity:var(--wy-opacity-disabled, 38%);pointer-events:none}[part~=wy-item-interactive][part~=wy-selected]{--wy-component-background-color: var(--wy-component-background-color-selected, var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff)));--wy-component-color: var(--wy-component-color-selected, var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73)));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-color:var(--wy-component-background-color)}[part~=wy-item-trashed]{text-decoration:line-through;opacity:var(--wy-opacity-disabled, 38%)}[part~=wy-item-trashed][part~=wy-item-interactive]:hover{opacity:1}[part~=wy-item-list]{display:flex;flex-direction:column;gap:var(--wy-border, 1px);min-width:0}[part~=wy-item-list-filled]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));--wy-component-background-color: var(--wy-surface-layer-low, var(--wy-surface-layer-low-light, rgba(255, 255, 255, .5019607843)));--wy-component-background-color-hover: var(--wy-surface-layer-lowest, var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078)));--wy-component-background-color-active: var(--wy-surface-layer-lowest, var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078)))}[part~=wy-item-list-rounded]{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));clip-path:content-box}[part~=wy-item-list-rounded-outer]{border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));clip-path:content-box}[part~=wy-item-list-bordered]{border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));gap:0}[part~=wy-item-list-bordered]>:not(slot),[part~=wy-item-list-bordered] ::slotted(*){border-left:none;border-right:none}[part~=wy-item-list-bordered]>:not(slot):not(:first-child),[part~=wy-item-list-bordered] ::slotted(*:not(:first-child)){border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}`, Uc = B`[part~=wy-title]{font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));font-size:var(--wy-headings-font-size, var(--wy-font-size, 1em));font-style:var(--wy-headings-font-style, unset);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.5));margin-block:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-meta]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-meta-sm]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))}[part~=wy-quote]{color:var(--wy-outline, var(--wy-outline-light, #72777f))}[part~=wy-quote]:before,[part~=wy-quote]:after{content:'\"'}`;
var h5 = Object.defineProperty, p5 = Object.getOwnPropertyDescriptor, Qt = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? p5(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && h5(t, e, s), s;
}, "__decorateClass$15"), Fa;
let ie = (Fa = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.size = "auto", this.align = "middle", this.actionsPosition = "end", this.rounded = !1, this.noPadding = !1, this.outer = !1, this.interactive = !1, this.selected = !1, this.disabled = !1, this.url = void 0, this.trashed = !1;
  }
  /**
   * If it has an url; handles ctrl click event for the item.
   * @param event MouseEvent
   */
  handleLinkClick(t) {
    if (this.disabled) {
      t.preventDefault(), t.stopPropagation();
      return;
    }
    dh(t) && t.stopPropagation();
  }
  render() {
    const t = !!this._slotActions.length, e = !!this._slotMeta.length, s = !!this._slotText.length || this.actionsPosition === "bottom" && t;
    return h`
      <div
        part=${K({
      "wy-item-rounded": this.rounded,
      "wy-item-rounded-outer": this.outer,
      "wy-item-inner": !0,
      "wy-item-inner-no-padding": this.noPadding,
      "wy-item-interactive": this.interactive,
      "wy-item-sm": this.size === "sm",
      "wy-item-md": this.size === "md",
      "wy-item-lg": this.size === "lg",
      "wy-item-top": this.align === "top",
      "wy-item-middle": this.align === "middle",
      "wy-item-bottom": this.align === "bottom",
      "wy-read": this.status === "read",
      "wy-unread": this.status === "unread",
      "wy-selected": this.selected,
      "wy-disabled": this.disabled
    })}
      >
        <div part="wy-item-image"><slot name="image"></slot></div>
        <div part="wy-item-body">
          <slot name="content">
            <div part="wy-item-rows">
              <div part="wy-item-row wy-item-row-first">
                <div part="wy-item-title wy-item-left">
                  ${this.url ? h`<a href=${this.url} @click=${(n) => this.handleLinkClick(n)}><slot name="title"></slot></a>` : h`<slot name="title"></slot>`}
                </div>
                <div part="wy-item-meta wy-meta wy-meta-sm" ?hidden=${!e}
                  ><slot name="meta" @slotchange=${() => this.requestUpdate()}></slot
                ></div>
              </div>
              <div part="wy-item-row wy-item-row-second" ?hidden=${!s}>
                <div part="wy-item-text wy-item-left ${K({ "wy-item-text-sm": this.size === "auto" })}"
                  ><slot name="text" @slotchange=${() => this.requestUpdate()}></slot
                ></div>
                ${this.actionsPosition === "bottom" ? h`
                      <div part="wy-item-actions wy-item-actions-bottom"
                        ><slot name="actions" @slotchange=${() => this.requestUpdate()}></slot
                      ></div>
                    ` : v}
              </div>
            </div>
          </slot>
        </div>
        ${this.actionsPosition !== "bottom" ? h`
              <div
                part="wy-item-actions ${K({
      "wy-item-actions-top": this.align === "top" || this.actionsPosition === "top"
    })}"
                ?hidden=${!t}
                ><slot name="actions" @slotchange=${() => this.requestUpdate()}></slot
              ></div>
            ` : v}
      </div>
    `;
  }
}, a(Fa, "WyItem"), Fa);
ie.styles = [zt, gh, Uc];
Qt([
  p()
], ie.prototype, "size", 2);
Qt([
  p()
], ie.prototype, "align", 2);
Qt([
  p()
], ie.prototype, "actionsPosition", 2);
Qt([
  p({ type: Boolean, reflect: !0 })
], ie.prototype, "rounded", 2);
Qt([
  p({ type: Boolean, reflect: !0 })
], ie.prototype, "noPadding", 2);
Qt([
  p({ type: Boolean, reflect: !0 })
], ie.prototype, "outer", 2);
Qt([
  p({ type: Boolean, reflect: !0 })
], ie.prototype, "interactive", 2);
Qt([
  p({ type: Boolean, reflect: !0 })
], ie.prototype, "selected", 2);
Qt([
  p({ type: Boolean, reflect: !0 })
], ie.prototype, "disabled", 2);
Qt([
  p({ reflect: !0 })
], ie.prototype, "url", 2);
Qt([
  p({ type: Boolean, reflect: !0 })
], ie.prototype, "trashed", 2);
Qt([
  p()
], ie.prototype, "status", 2);
Qt([
  Hc({ slot: "actions" })
], ie.prototype, "_slotActions", 2);
Qt([
  Hc({ slot: "meta" })
], ie.prototype, "_slotMeta", 2);
Qt([
  Hc({ slot: "text" })
], ie.prototype, "_slotText", 2);
ie = Qt([
  H("wy-item")
], ie);
var Da;
let Er = (Da = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.outer = !1, this.bordered = !1, this.rounded = !1, this.filled = !1;
  }
  render() {
    const t = {
      "wy-item-list": !0,
      "wy-item-list-bordered": this.bordered,
      "wy-item-list-rounded": this.rounded,
      "wy-item-list-outer": this.outer,
      "wy-item-list-filled": this.filled
    };
    return h`<div part=${K(t)}><slot></slot></div>`;
  }
}, a(Da, "WyItemList"), Da);
Er.styles = [gh, Z];
Qt([
  p({ type: Boolean })
], Er.prototype, "outer", 2);
Qt([
  p({ type: Boolean })
], Er.prototype, "bordered", 2);
Qt([
  p({ type: Boolean })
], Er.prototype, "rounded", 2);
Qt([
  p({ type: Boolean })
], Er.prototype, "filled", 2);
Er = Qt([
  H("wy-item-list")
], Er);
const Bm = B`[part~=wy-button]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c));color:var(--wy-component-color);background:var(--wy-component-background-color, transparent);height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;font-size:var(--wy-button-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-button-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));text-align:center;text-decoration:none;vertical-align:middle;cursor:pointer;-webkit-user-select:none;user-select:none;border:var(--wy-button-border-width, var(--wy-border-outline, 0)) solid var(--wy-outline, var(--wy-outline-light, #72777f));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem))));display:inline-flex;align-items:center;justify-content:center;gap:var(--wy-button-gap, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));position:relative}[part~=wy-button][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.8);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.5)}[part~=wy-button][part~=wy-disabled],[part~=wy-button]:disabled{opacity:var(--wy-opacity-disabled, 38%);cursor:unset;pointer-events:none}[part~=wy-button-state-layer]>*{z-index:3}[part~=wy-button-state-layer]:before{content:\"\";z-index:2;position:absolute;inset:0;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-button-state-layer]:hover:before{opacity:8%}[part~=wy-button-state-layer]:focus:before,[part~=wy-button-state-layer]:active:before,[part~=wy-button-state-layer][part~=wy-active]:before{opacity:12%}[part~=wy-button-icon]{--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));line-height:1;align-items:center;justify-content:center}[part~=wy-button-icon][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);padding:0;margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.5)}[part~=wy-button-icon][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*-.1)}[part~=wy-button-icon][part~=wy-active]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-button-icon-inline]{height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));width:auto;min-width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));background:var(--wy-component-background-color);color:currentColor;display:flex;padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-button-icon-inline][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);min-width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.25);margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.5)}[part~=wy-button-icon-inline][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*-.1)}[part~=wy-button-inline]{border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));margin-inline:calc(-1*var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-button-inline][part~=wy-button-sm]{padding:calc(.5*var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin-inline:calc(-.5*var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-button-primary]{--wy-component-background-color: var(--wy-primary, var(--wy-primary-light, #2f628c));--wy-component-color: var(--wy-on-primary, var(--wy-on-primary-light, #ffffff))}[part~=wy-button-variant]{--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}[part~=wy-button-primary-text]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-button-inherit-color]{--wy-component-color: currentColor}[part~=wy-button-no-color]{--wy-component-background-color: transparent;--wy-component-color: unset}[part~=wy-button-link]{padding:0;color:var(--wy-link-color, var(--wy-primary, var(--wy-primary-light, #2f628c)));text-decoration:var(--wy-link-decoration, none)}[part~=wy-button-link]:hover,[part~=wy-button-link]:focus{text-decoration:var(--wy-link-hover-decoration, var(--wy-link-decoration, none))}[part~=wy-buttons]{display:flex;align-items:center;flex-wrap:wrap;gap:calc(.5*var(--wy-size, 1rem))}[part~=wy-buttons-reverse]{flex-direction:row-reverse}[part~=wy-buttons-floating]{position:sticky;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) 0;top:0;height:0;margin-bottom:calc(-1*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));z-index:1030;--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}[part~=wy-buttons-sticky]{position:sticky;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));top:var(--wy-component-offset-top, 0px);z-index:1021;--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}`, qm = B`[part~=wy-tabs]{display:flex;overflow-y:hidden;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));flex:1 1 auto}[part~=wy-tabs]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-tabs]{scrollbar-width:thin;scrollbar-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf)) rgba(0,0,0,0)}[part~=wy-tabs]::-webkit-scrollbar{height:.375rem;width:.375rem;background:#0000;z-index:999}[part~=wy-tabs]::-webkit-scrollbar-track{background:#0000}[part~=wy-tabs]::-webkit-scrollbar-thumb{background-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));opacity:75%;border:0 solid rgba(0,0,0,0);border-radius:0;background-clip:padding-box}[part~=wy-tabs]::-webkit-scrollbar-thumb:hover{background-color:var(--wy-outline, var(--wy-outline-light, #72777f));opacity:75%}[part~=wy-tabs]::-webkit-scrollbar-thumb:window-inactive{background-color:var(--wy-outline, var(--wy-outline-light, #72777f));opacity:50%}[part~=wy-tab]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c));--wy-component-background-color: transparent;color:var(--wy-component-color);background:var(--wy-component-background-color);border:none;border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));display:inline-flex;flex-direction:column;align-items:center;justify-content:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));position:relative;text-align:center;text-decoration:none;cursor:pointer;-webkit-user-select:none;user-select:none}[part~=wy-tab] .wy-tab-icon{position:relative;padding:calc(.25*var(--wy-size, 1rem)) calc(1*var(--wy-size, 1rem));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem))));display:inline-flex}[part~=wy-tab] .wy-tab-icon:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-tab]:hover .wy-tab-icon:before{opacity:8%}[part~=wy-tab]:focus .wy-tab-icon:before,[part~=wy-tab]:active .wy-tab-icon:before,[part~=wy-tab].wy-active .wy-tab-icon:before{opacity:12%}[part~=wy-tab] .wy-tab-label{font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));font-weight:var(--wy-font-weight, unset)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]{padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.5);margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) auto;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]:before{margin:calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*-.25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*0)}`;
var u5 = Object.defineProperty, y5 = Object.getOwnPropertyDescriptor, Ue = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? y5(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && u5(t, e, s), s;
}, "__decorateClass$14"), Ha;
let Qe = (Ha = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this, !1), this.kind = "filled", this.active = !1, this.small = !1, this.disabled = !1;
  }
  render() {
    const t = {
      "wy-button": !0,
      "wy-active": !!this.active,
      "wy-disabled": !!this.disabled,
      "wy-button-inline": this.kind === "inline",
      "wy-button-icon": this.kind === "icon",
      "wy-button-icon-inline": this.kind === "icon-inline",
      "wy-button-link": this.kind === "link",
      "wy-button-primary": this.color === "primary",
      "wy-button-primary-text": this.color === "primary-text",
      "wy-button-inherit-color": this.color === "inherit",
      "wy-button-no-color": this.color === "none",
      "wy-button-variant": this.color === "variant",
      "wy-button-type-submit": this.type === "submit",
      "wy-button-type-reset": this.type === "reset",
      "wy-button-state-layer": this.kind !== "link" && !this.disabled,
      "wy-button-sm": !!this.small,
      "wy-tab": this.kind === "tab",
      "wy-tab-sm": this.kind === "tab" && !!this.small
    };
    return this.href ? h`
      <a href=${this.href} target=${nt(this.target)} download=${nt(this.download)} part=${K(t)} aria-disabled=${this.disabled ? "true" : "false"}>
        <slot></slot>
      </a>
    ` : h`
      <button part=${K(t)} type=${nt(this.type)} ?disabled=${this.disabled} aria-disabled=${this.disabled ? "true" : "false"}>
        <slot></slot>
      </button>
    `;
  }
}, a(Ha, "WyButton"), Ha);
Qe.styles = [
  zt,
  Bm,
  qm,
  Z,
  B`
      :host {
        position: relative;
      }
    `
];
Ue([
  p()
], Qe.prototype, "type", 2);
Ue([
  p()
], Qe.prototype, "kind", 2);
Ue([
  p({ type: Boolean })
], Qe.prototype, "active", 2);
Ue([
  p()
], Qe.prototype, "color", 2);
Ue([
  p({ type: Boolean })
], Qe.prototype, "small", 2);
Ue([
  p({ type: Boolean, reflect: !0 })
], Qe.prototype, "disabled", 2);
Ue([
  p()
], Qe.prototype, "href", 2);
Ue([
  p()
], Qe.prototype, "target", 2);
Ue([
  p()
], Qe.prototype, "download", 2);
Qe = Ue([
  H("wy-button")
], Qe);
var Va;
let $s = (Va = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.tabs = !1, this.position = "normal", this.reverse = !1;
  }
  render() {
    const t = {
      "wy-buttons": !this.tabs,
      "wy-buttons-reverse": this.reverse,
      "wy-tabs": this.tabs,
      "wy-buttons-floating": this.position === "floating",
      "wy-buttons-sticky": this.position === "sticky"
    };
    return h`<div part=${K(t)}><slot></slot></div>`;
  }
}, a(Va, "WyButtons"), Va);
$s.styles = [
  zt,
  Bm,
  qm,
  Z
];
Ue([
  p({ type: Boolean })
], $s.prototype, "tabs", 2);
Ue([
  p({ type: String })
], $s.prototype, "position", 2);
Ue([
  p({ type: Boolean })
], $s.prototype, "reverse", 2);
$s = Ue([
  H("wy-buttons")
], $s);
const Nm = "important", w5 = " !" + Nm, ml = Bs(class extends Vc {
  constructor(i) {
    if (super(i), i.type !== od.ATTRIBUTE || i.name !== "style" || i.strings?.length > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(i) {
    return Object.keys(i).reduce(((t, e) => {
      const r = i[e];
      return r == null ? t : t + `${e = e.includes("-") ? e : e.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${r};`;
    }), "");
  }
  update(i, [t]) {
    const { style: e } = i.element;
    if (this.ft === void 0) return this.ft = new Set(Object.keys(t)), this.render(t);
    for (const r of this.ft) t[r] == null && (this.ft.delete(r), r.includes("-") ? e.removeProperty(r) : e[r] = null);
    for (const r in t) {
      const s = t[r];
      if (s != null) {
        this.ft.add(r);
        const n = typeof s == "string" && s.endsWith(w5);
        r.includes("-") || n ? e.setProperty(r, n ? s.slice(0, -11) : s, n ? Nm : "") : e[r] = s;
      }
    }
    return hh;
  }
}), Yd = Math.min, ys = Math.max, Xd = Math.round, Md = Math.floor, Ci = /* @__PURE__ */ a((i) => ({
  x: i,
  y: i
}), "createCoords"), f5 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, m5 = {
  start: "end",
  end: "start"
};
function rf(i, t, e) {
  return ys(i, Yd(t, e));
}
a(rf, "clamp");
function bh(i, t) {
  return typeof i == "function" ? i(t) : i;
}
a(bh, "evaluate");
function Cs(i) {
  return i.split("-")[0];
}
a(Cs, "getSide");
function xh(i) {
  return i.split("-")[1];
}
a(xh, "getAlignment");
function jm(i) {
  return i === "x" ? "y" : "x";
}
a(jm, "getOppositeAxis");
function Wm(i) {
  return i === "y" ? "height" : "width";
}
a(Wm, "getAxisLength");
const v5 = /* @__PURE__ */ new Set(["top", "bottom"]);
function _r(i) {
  return v5.has(Cs(i)) ? "y" : "x";
}
a(_r, "getSideAxis");
function Qm(i) {
  return jm(_r(i));
}
a(Qm, "getAlignmentAxis");
function g5(i, t, e) {
  e === void 0 && (e = !1);
  const r = xh(i), s = Qm(i), n = Wm(s);
  let o = s === "x" ? r === (e ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[n] > t.floating[n] && (o = Jd(o)), [o, Jd(o)];
}
a(g5, "getAlignmentSides");
function b5(i) {
  const t = Jd(i);
  return [Au(i), t, Au(t)];
}
a(b5, "getExpandedPlacements");
function Au(i) {
  return i.replace(/start|end/g, (t) => m5[t]);
}
a(Au, "getOppositeAlignmentPlacement");
const sf = ["left", "right"], nf = ["right", "left"], x5 = ["top", "bottom"], $5 = ["bottom", "top"];
function C5(i, t, e) {
  switch (i) {
    case "top":
    case "bottom":
      return e ? t ? nf : sf : t ? sf : nf;
    case "left":
    case "right":
      return t ? x5 : $5;
    default:
      return [];
  }
}
a(C5, "getSideList");
function k5(i, t, e, r) {
  const s = xh(i);
  let n = C5(Cs(i), e === "start", r);
  return s && (n = n.map((o) => o + "-" + s), t && (n = n.concat(n.map(Au)))), n;
}
a(k5, "getOppositeAxisPlacements");
function Jd(i) {
  return i.replace(/left|right|bottom|top/g, (t) => f5[t]);
}
a(Jd, "getOppositePlacement");
function _5(i) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...i
  };
}
a(_5, "expandPaddingObject");
function P5(i) {
  return typeof i != "number" ? _5(i) : {
    top: i,
    right: i,
    bottom: i,
    left: i
  };
}
a(P5, "getPaddingObject");
function th(i) {
  const {
    x: t,
    y: e,
    width: r,
    height: s
  } = i;
  return {
    width: r,
    height: s,
    top: e,
    left: t,
    right: t + r,
    bottom: e + s,
    x: t,
    y: e
  };
}
a(th, "rectToClientRect");
function af(i, t, e) {
  let {
    reference: r,
    floating: s
  } = i;
  const n = _r(t), o = Qm(t), c = Wm(o), l = Cs(t), u = n === "y", f = r.x + r.width / 2 - s.width / 2, $ = r.y + r.height / 2 - s.height / 2, m = r[c] / 2 - s[c] / 2;
  let x;
  switch (l) {
    case "top":
      x = {
        x: f,
        y: r.y - s.height
      };
      break;
    case "bottom":
      x = {
        x: f,
        y: r.y + r.height
      };
      break;
    case "right":
      x = {
        x: r.x + r.width,
        y: $
      };
      break;
    case "left":
      x = {
        x: r.x - s.width,
        y: $
      };
      break;
    default:
      x = {
        x: r.x,
        y: r.y
      };
  }
  switch (xh(t)) {
    case "start":
      x[o] -= m * (e && u ? -1 : 1);
      break;
    case "end":
      x[o] += m * (e && u ? -1 : 1);
      break;
  }
  return x;
}
a(af, "computeCoordsFromPlacement");
const M5 = /* @__PURE__ */ a(async (i, t, e) => {
  const {
    placement: r = "bottom",
    strategy: s = "absolute",
    middleware: n = [],
    platform: o
  } = e, c = n.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let u = await o.getElementRects({
    reference: i,
    floating: t,
    strategy: s
  }), {
    x: f,
    y: $
  } = af(u, r, l), m = r, x = {}, g = 0;
  for (let S = 0; S < c.length; S++) {
    const {
      name: I,
      fn: A
    } = c[S], {
      x: E,
      y: T,
      data: q,
      reset: R
    } = await A({
      x: f,
      y: $,
      initialPlacement: r,
      placement: m,
      strategy: s,
      middlewareData: x,
      rects: u,
      platform: o,
      elements: {
        reference: i,
        floating: t
      }
    });
    f = E ?? f, $ = T ?? $, x = {
      ...x,
      [I]: {
        ...x[I],
        ...q
      }
    }, R && g <= 50 && (g++, typeof R == "object" && (R.placement && (m = R.placement), R.rects && (u = R.rects === !0 ? await o.getElementRects({
      reference: i,
      floating: t,
      strategy: s
    }) : R.rects), {
      x: f,
      y: $
    } = af(u, m, l)), S = -1);
  }
  return {
    x: f,
    y: $,
    placement: m,
    strategy: s,
    middlewareData: x
  };
}, "computePosition$1");
async function Km(i, t) {
  var e;
  t === void 0 && (t = {});
  const {
    x: r,
    y: s,
    platform: n,
    rects: o,
    elements: c,
    strategy: l
  } = i, {
    boundary: u = "clippingAncestors",
    rootBoundary: f = "viewport",
    elementContext: $ = "floating",
    altBoundary: m = !1,
    padding: x = 0
  } = bh(t, i), g = P5(x), I = c[m ? $ === "floating" ? "reference" : "floating" : $], A = th(await n.getClippingRect({
    element: (e = await (n.isElement == null ? void 0 : n.isElement(I))) == null || e ? I : I.contextElement || await (n.getDocumentElement == null ? void 0 : n.getDocumentElement(c.floating)),
    boundary: u,
    rootBoundary: f,
    strategy: l
  })), E = $ === "floating" ? {
    x: r,
    y: s,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, T = await (n.getOffsetParent == null ? void 0 : n.getOffsetParent(c.floating)), q = await (n.isElement == null ? void 0 : n.isElement(T)) ? await (n.getScale == null ? void 0 : n.getScale(T)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, R = th(n.convertOffsetParentRelativeRectToViewportRelativeRect ? await n.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: c,
    rect: E,
    offsetParent: T,
    strategy: l
  }) : E);
  return {
    top: (A.top - R.top + g.top) / q.y,
    bottom: (R.bottom - A.bottom + g.bottom) / q.y,
    left: (A.left - R.left + g.left) / q.x,
    right: (R.right - A.right + g.right) / q.x
  };
}
a(Km, "detectOverflow");
const S5 = /* @__PURE__ */ a(function(i) {
  return i === void 0 && (i = {}), {
    name: "flip",
    options: i,
    async fn(t) {
      var e, r;
      const {
        placement: s,
        middlewareData: n,
        rects: o,
        initialPlacement: c,
        platform: l,
        elements: u
      } = t, {
        mainAxis: f = !0,
        crossAxis: $ = !0,
        fallbackPlacements: m,
        fallbackStrategy: x = "bestFit",
        fallbackAxisSideDirection: g = "none",
        flipAlignment: S = !0,
        ...I
      } = bh(i, t);
      if ((e = n.arrow) != null && e.alignmentOffset)
        return {};
      const A = Cs(s), E = _r(c), T = Cs(c) === c, q = await (l.isRTL == null ? void 0 : l.isRTL(u.floating)), R = m || (T || !S ? [Jd(c)] : b5(c)), V = g !== "none";
      !m && V && R.push(...k5(c, S, g, q));
      const N = [c, ...R], Y = await Km(t, I), it = [];
      let J = ((r = n.flip) == null ? void 0 : r.overflows) || [];
      if (f && it.push(Y[A]), $) {
        const pt = g5(s, o, q);
        it.push(Y[pt[0]], Y[pt[1]]);
      }
      if (J = [...J, {
        placement: s,
        overflows: it
      }], !it.every((pt) => pt <= 0)) {
        var Pt, Mt;
        const pt = (((Pt = n.flip) == null ? void 0 : Pt.index) || 0) + 1, Ot = N[pt];
        if (Ot && (!($ === "alignment" ? E !== _r(Ot) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        J.every((ft) => _r(ft.placement) === E ? ft.overflows[0] > 0 : !0)))
          return {
            data: {
              index: pt,
              overflows: J
            },
            reset: {
              placement: Ot
            }
          };
        let pe = (Mt = J.filter((kt) => kt.overflows[0] <= 0).sort((kt, ft) => kt.overflows[1] - ft.overflows[1])[0]) == null ? void 0 : Mt.placement;
        if (!pe)
          switch (x) {
            case "bestFit": {
              var wt;
              const kt = (wt = J.filter((ft) => {
                if (V) {
                  const Gt = _r(ft.placement);
                  return Gt === E || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Gt === "y";
                }
                return !0;
              }).map((ft) => [ft.placement, ft.overflows.filter((Gt) => Gt > 0).reduce((Gt, rt) => Gt + rt, 0)]).sort((ft, Gt) => ft[1] - Gt[1])[0]) == null ? void 0 : wt[0];
              kt && (pe = kt);
              break;
            }
            case "initialPlacement":
              pe = c;
              break;
          }
        if (s !== pe)
          return {
            reset: {
              placement: pe
            }
          };
      }
      return {};
    }
  };
}, "flip$1"), A5 = /* @__PURE__ */ new Set(["left", "top"]);
async function z5(i, t) {
  const {
    placement: e,
    platform: r,
    elements: s
  } = i, n = await (r.isRTL == null ? void 0 : r.isRTL(s.floating)), o = Cs(e), c = xh(e), l = _r(e) === "y", u = A5.has(o) ? -1 : 1, f = n && l ? -1 : 1, $ = bh(t, i);
  let {
    mainAxis: m,
    crossAxis: x,
    alignmentAxis: g
  } = typeof $ == "number" ? {
    mainAxis: $,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: $.mainAxis || 0,
    crossAxis: $.crossAxis || 0,
    alignmentAxis: $.alignmentAxis
  };
  return c && typeof g == "number" && (x = c === "end" ? g * -1 : g), l ? {
    x: x * f,
    y: m * u
  } : {
    x: m * u,
    y: x * f
  };
}
a(z5, "convertValueToCoords");
const R5 = /* @__PURE__ */ a(function(i) {
  return i === void 0 && (i = 0), {
    name: "offset",
    options: i,
    async fn(t) {
      var e, r;
      const {
        x: s,
        y: n,
        placement: o,
        middlewareData: c
      } = t, l = await z5(t, i);
      return o === ((e = c.offset) == null ? void 0 : e.placement) && (r = c.arrow) != null && r.alignmentOffset ? {} : {
        x: s + l.x,
        y: n + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
}, "offset$1"), E5 = /* @__PURE__ */ a(function(i) {
  return i === void 0 && (i = {}), {
    name: "shift",
    options: i,
    async fn(t) {
      const {
        x: e,
        y: r,
        placement: s
      } = t, {
        mainAxis: n = !0,
        crossAxis: o = !1,
        limiter: c = {
          fn: /* @__PURE__ */ a((I) => {
            let {
              x: A,
              y: E
            } = I;
            return {
              x: A,
              y: E
            };
          }, "fn")
        },
        ...l
      } = bh(i, t), u = {
        x: e,
        y: r
      }, f = await Km(t, l), $ = _r(Cs(s)), m = jm($);
      let x = u[m], g = u[$];
      if (n) {
        const I = m === "y" ? "top" : "left", A = m === "y" ? "bottom" : "right", E = x + f[I], T = x - f[A];
        x = rf(E, x, T);
      }
      if (o) {
        const I = $ === "y" ? "top" : "left", A = $ === "y" ? "bottom" : "right", E = g + f[I], T = g - f[A];
        g = rf(E, g, T);
      }
      const S = c.fn({
        ...t,
        [m]: x,
        [$]: g
      });
      return {
        ...S,
        data: {
          x: S.x - e,
          y: S.y - r,
          enabled: {
            [m]: n,
            [$]: o
          }
        }
      };
    }
  };
}, "shift$1");
function $h() {
  return typeof window < "u";
}
a($h, "hasWindow");
function Bc(i) {
  return Gm(i) ? (i.nodeName || "").toLowerCase() : "#document";
}
a(Bc, "getNodeName");
function je(i) {
  var t;
  return (i == null || (t = i.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
a(je, "getWindow");
function Ei(i) {
  var t;
  return (t = (Gm(i) ? i.ownerDocument : i.document) || window.document) == null ? void 0 : t.documentElement;
}
a(Ei, "getDocumentElement");
function Gm(i) {
  return $h() ? i instanceof Node || i instanceof je(i).Node : !1;
}
a(Gm, "isNode");
function ci(i) {
  return $h() ? i instanceof Element || i instanceof je(i).Element : !1;
}
a(ci, "isElement");
function _i(i) {
  return $h() ? i instanceof HTMLElement || i instanceof je(i).HTMLElement : !1;
}
a(_i, "isHTMLElement");
function of(i) {
  return !$h() || typeof ShadowRoot > "u" ? !1 : i instanceof ShadowRoot || i instanceof je(i).ShadowRoot;
}
a(of, "isShadowRoot");
const L5 = /* @__PURE__ */ new Set(["inline", "contents"]);
function cd(i) {
  const {
    overflow: t,
    overflowX: e,
    overflowY: r,
    display: s
  } = li(i);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + e) && !L5.has(s);
}
a(cd, "isOverflowElement");
const O5 = /* @__PURE__ */ new Set(["table", "td", "th"]);
function I5(i) {
  return O5.has(Bc(i));
}
a(I5, "isTableElement");
const T5 = [":popover-open", ":modal"];
function Ch(i) {
  return T5.some((t) => {
    try {
      return i.matches(t);
    } catch {
      return !1;
    }
  });
}
a(Ch, "isTopLayer");
const F5 = ["transform", "translate", "scale", "rotate", "perspective"], D5 = ["transform", "translate", "scale", "rotate", "perspective", "filter"], H5 = ["paint", "layout", "strict", "content"];
function py(i) {
  const t = uy(), e = ci(i) ? li(i) : i;
  return F5.some((r) => e[r] ? e[r] !== "none" : !1) || (e.containerType ? e.containerType !== "normal" : !1) || !t && (e.backdropFilter ? e.backdropFilter !== "none" : !1) || !t && (e.filter ? e.filter !== "none" : !1) || D5.some((r) => (e.willChange || "").includes(r)) || H5.some((r) => (e.contain || "").includes(r));
}
a(py, "isContainingBlock");
function V5(i) {
  let t = Lr(i);
  for (; _i(t) && !Cc(t); ) {
    if (py(t))
      return t;
    if (Ch(t))
      return null;
    t = Lr(t);
  }
  return null;
}
a(V5, "getContainingBlock");
function uy() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
a(uy, "isWebKit");
const U5 = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Cc(i) {
  return U5.has(Bc(i));
}
a(Cc, "isLastTraversableNode");
function li(i) {
  return je(i).getComputedStyle(i);
}
a(li, "getComputedStyle$1");
function kh(i) {
  return ci(i) ? {
    scrollLeft: i.scrollLeft,
    scrollTop: i.scrollTop
  } : {
    scrollLeft: i.scrollX,
    scrollTop: i.scrollY
  };
}
a(kh, "getNodeScroll");
function Lr(i) {
  if (Bc(i) === "html")
    return i;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    i.assignedSlot || // DOM Element detected.
    i.parentNode || // ShadowRoot detected.
    of(i) && i.host || // Fallback.
    Ei(i)
  );
  return of(t) ? t.host : t;
}
a(Lr, "getParentNode");
function Zm(i) {
  const t = Lr(i);
  return Cc(t) ? i.ownerDocument ? i.ownerDocument.body : i.body : _i(t) && cd(t) ? t : Zm(t);
}
a(Zm, "getNearestOverflowAncestor");
function vl(i, t, e) {
  var r;
  t === void 0 && (t = []), e === void 0 && (e = !0);
  const s = Zm(i), n = s === ((r = i.ownerDocument) == null ? void 0 : r.body), o = je(s);
  if (n) {
    const c = zu(o);
    return t.concat(o, o.visualViewport || [], cd(s) ? s : [], c && e ? vl(c) : []);
  }
  return t.concat(s, vl(s, [], e));
}
a(vl, "getOverflowAncestors");
function zu(i) {
  return i.parent && Object.getPrototypeOf(i.parent) ? i.frameElement : null;
}
a(zu, "getFrameElement");
function Ym(i) {
  const t = li(i);
  let e = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const s = _i(i), n = s ? i.offsetWidth : e, o = s ? i.offsetHeight : r, c = Xd(e) !== n || Xd(r) !== o;
  return c && (e = n, r = o), {
    width: e,
    height: r,
    $: c
  };
}
a(Ym, "getCssDimensions");
function yy(i) {
  return ci(i) ? i : i.contextElement;
}
a(yy, "unwrapElement");
function mn(i) {
  const t = yy(i);
  if (!_i(t))
    return Ci(1);
  const e = t.getBoundingClientRect(), {
    width: r,
    height: s,
    $: n
  } = Ym(t);
  let o = (n ? Xd(e.width) : e.width) / r, c = (n ? Xd(e.height) : e.height) / s;
  return (!o || !Number.isFinite(o)) && (o = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: o,
    y: c
  };
}
a(mn, "getScale");
const B5 = /* @__PURE__ */ Ci(0);
function Xm(i) {
  const t = je(i);
  return !uy() || !t.visualViewport ? B5 : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
a(Xm, "getVisualOffsets");
function q5(i, t, e) {
  return t === void 0 && (t = !1), !e || t && e !== je(i) ? !1 : t;
}
a(q5, "shouldAddVisualOffsets");
function ks(i, t, e, r) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  const s = i.getBoundingClientRect(), n = yy(i);
  let o = Ci(1);
  t && (r ? ci(r) && (o = mn(r)) : o = mn(i));
  const c = q5(n, e, r) ? Xm(n) : Ci(0);
  let l = (s.left + c.x) / o.x, u = (s.top + c.y) / o.y, f = s.width / o.x, $ = s.height / o.y;
  if (n) {
    const m = je(n), x = r && ci(r) ? je(r) : r;
    let g = m, S = zu(g);
    for (; S && r && x !== g; ) {
      const I = mn(S), A = S.getBoundingClientRect(), E = li(S), T = A.left + (S.clientLeft + parseFloat(E.paddingLeft)) * I.x, q = A.top + (S.clientTop + parseFloat(E.paddingTop)) * I.y;
      l *= I.x, u *= I.y, f *= I.x, $ *= I.y, l += T, u += q, g = je(S), S = zu(g);
    }
  }
  return th({
    width: f,
    height: $,
    x: l,
    y: u
  });
}
a(ks, "getBoundingClientRect");
function _h(i, t) {
  const e = kh(i).scrollLeft;
  return t ? t.left + e : ks(Ei(i)).left + e;
}
a(_h, "getWindowScrollBarX");
function Jm(i, t) {
  const e = i.getBoundingClientRect(), r = e.left + t.scrollLeft - _h(i, e), s = e.top + t.scrollTop;
  return {
    x: r,
    y: s
  };
}
a(Jm, "getHTMLOffset");
function N5(i) {
  let {
    elements: t,
    rect: e,
    offsetParent: r,
    strategy: s
  } = i;
  const n = s === "fixed", o = Ei(r), c = t ? Ch(t.floating) : !1;
  if (r === o || c && n)
    return e;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = Ci(1);
  const f = Ci(0), $ = _i(r);
  if (($ || !$ && !n) && ((Bc(r) !== "body" || cd(o)) && (l = kh(r)), _i(r))) {
    const x = ks(r);
    u = mn(r), f.x = x.x + r.clientLeft, f.y = x.y + r.clientTop;
  }
  const m = o && !$ && !n ? Jm(o, l) : Ci(0);
  return {
    width: e.width * u.x,
    height: e.height * u.y,
    x: e.x * u.x - l.scrollLeft * u.x + f.x + m.x,
    y: e.y * u.y - l.scrollTop * u.y + f.y + m.y
  };
}
a(N5, "convertOffsetParentRelativeRectToViewportRelativeRect");
function j5(i) {
  return Array.from(i.getClientRects());
}
a(j5, "getClientRects");
function W5(i) {
  const t = Ei(i), e = kh(i), r = i.ownerDocument.body, s = ys(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), n = ys(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -e.scrollLeft + _h(i);
  const c = -e.scrollTop;
  return li(r).direction === "rtl" && (o += ys(t.clientWidth, r.clientWidth) - s), {
    width: s,
    height: n,
    x: o,
    y: c
  };
}
a(W5, "getDocumentRect");
const cf = 25;
function Q5(i, t) {
  const e = je(i), r = Ei(i), s = e.visualViewport;
  let n = r.clientWidth, o = r.clientHeight, c = 0, l = 0;
  if (s) {
    n = s.width, o = s.height;
    const f = uy();
    (!f || f && t === "fixed") && (c = s.offsetLeft, l = s.offsetTop);
  }
  const u = _h(r);
  if (u <= 0) {
    const f = r.ownerDocument, $ = f.body, m = getComputedStyle($), x = f.compatMode === "CSS1Compat" && parseFloat(m.marginLeft) + parseFloat(m.marginRight) || 0, g = Math.abs(r.clientWidth - $.clientWidth - x);
    g <= cf && (n -= g);
  } else u <= cf && (n += u);
  return {
    width: n,
    height: o,
    x: c,
    y: l
  };
}
a(Q5, "getViewportRect");
const K5 = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function G5(i, t) {
  const e = ks(i, !0, t === "fixed"), r = e.top + i.clientTop, s = e.left + i.clientLeft, n = _i(i) ? mn(i) : Ci(1), o = i.clientWidth * n.x, c = i.clientHeight * n.y, l = s * n.x, u = r * n.y;
  return {
    width: o,
    height: c,
    x: l,
    y: u
  };
}
a(G5, "getInnerBoundingClientRect");
function lf(i, t, e) {
  let r;
  if (t === "viewport")
    r = Q5(i, e);
  else if (t === "document")
    r = W5(Ei(i));
  else if (ci(t))
    r = G5(t, e);
  else {
    const s = Xm(i);
    r = {
      x: t.x - s.x,
      y: t.y - s.y,
      width: t.width,
      height: t.height
    };
  }
  return th(r);
}
a(lf, "getClientRectFromClippingAncestor");
function tv(i, t) {
  const e = Lr(i);
  return e === t || !ci(e) || Cc(e) ? !1 : li(e).position === "fixed" || tv(e, t);
}
a(tv, "hasFixedPositionAncestor");
function Z5(i, t) {
  const e = t.get(i);
  if (e)
    return e;
  let r = vl(i, [], !1).filter((c) => ci(c) && Bc(c) !== "body"), s = null;
  const n = li(i).position === "fixed";
  let o = n ? Lr(i) : i;
  for (; ci(o) && !Cc(o); ) {
    const c = li(o), l = py(o);
    !l && c.position === "fixed" && (s = null), (n ? !l && !s : !l && c.position === "static" && !!s && K5.has(s.position) || cd(o) && !l && tv(i, o)) ? r = r.filter((f) => f !== o) : s = c, o = Lr(o);
  }
  return t.set(i, r), r;
}
a(Z5, "getClippingElementAncestors");
function Y5(i) {
  let {
    element: t,
    boundary: e,
    rootBoundary: r,
    strategy: s
  } = i;
  const o = [...e === "clippingAncestors" ? Ch(t) ? [] : Z5(t, this._c) : [].concat(e), r], c = o[0], l = o.reduce((u, f) => {
    const $ = lf(t, f, s);
    return u.top = ys($.top, u.top), u.right = Yd($.right, u.right), u.bottom = Yd($.bottom, u.bottom), u.left = ys($.left, u.left), u;
  }, lf(t, c, s));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
a(Y5, "getClippingRect");
function X5(i) {
  const {
    width: t,
    height: e
  } = Ym(i);
  return {
    width: t,
    height: e
  };
}
a(X5, "getDimensions");
function J5(i, t, e) {
  const r = _i(t), s = Ei(t), n = e === "fixed", o = ks(i, !0, n, t);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = Ci(0);
  function u() {
    l.x = _h(s);
  }
  if (a(u, "setLeftRTLScrollbarOffset"), r || !r && !n)
    if ((Bc(t) !== "body" || cd(s)) && (c = kh(t)), r) {
      const x = ks(t, !0, n, t);
      l.x = x.x + t.clientLeft, l.y = x.y + t.clientTop;
    } else s && u();
  n && !r && s && u();
  const f = s && !r && !n ? Jm(s, c) : Ci(0), $ = o.left + c.scrollLeft - l.x - f.x, m = o.top + c.scrollTop - l.y - f.y;
  return {
    x: $,
    y: m,
    width: o.width,
    height: o.height
  };
}
a(J5, "getRectRelativeToOffsetParent");
function Tp(i) {
  return li(i).position === "static";
}
a(Tp, "isStaticPositioned");
function df(i, t) {
  if (!_i(i) || li(i).position === "fixed")
    return null;
  if (t)
    return t(i);
  let e = i.offsetParent;
  return Ei(i) === e && (e = e.ownerDocument.body), e;
}
a(df, "getTrueOffsetParent");
function ev(i, t) {
  const e = je(i);
  if (Ch(i))
    return e;
  if (!_i(i)) {
    let s = Lr(i);
    for (; s && !Cc(s); ) {
      if (ci(s) && !Tp(s))
        return s;
      s = Lr(s);
    }
    return e;
  }
  let r = df(i, t);
  for (; r && I5(r) && Tp(r); )
    r = df(r, t);
  return r && Cc(r) && Tp(r) && !py(r) ? e : r || V5(i) || e;
}
a(ev, "getOffsetParent");
const tx = /* @__PURE__ */ a(async function(i) {
  const t = this.getOffsetParent || ev, e = this.getDimensions, r = await e(i.floating);
  return {
    reference: J5(i.reference, await t(i.floating), i.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
}, "getElementRects");
function ex(i) {
  return li(i).direction === "rtl";
}
a(ex, "isRTL");
const ix = {
  convertOffsetParentRelativeRectToViewportRelativeRect: N5,
  getDocumentElement: Ei,
  getClippingRect: Y5,
  getOffsetParent: ev,
  getElementRects: tx,
  getClientRects: j5,
  getDimensions: X5,
  getScale: mn,
  isElement: ci,
  isRTL: ex
};
function iv(i, t) {
  return i.x === t.x && i.y === t.y && i.width === t.width && i.height === t.height;
}
a(iv, "rectsAreEqual");
function rx(i, t) {
  let e = null, r;
  const s = Ei(i);
  function n() {
    var c;
    clearTimeout(r), (c = e) == null || c.disconnect(), e = null;
  }
  a(n, "cleanup");
  function o(c, l) {
    c === void 0 && (c = !1), l === void 0 && (l = 1), n();
    const u = i.getBoundingClientRect(), {
      left: f,
      top: $,
      width: m,
      height: x
    } = u;
    if (c || t(), !m || !x)
      return;
    const g = Md($), S = Md(s.clientWidth - (f + m)), I = Md(s.clientHeight - ($ + x)), A = Md(f), T = {
      rootMargin: -g + "px " + -S + "px " + -I + "px " + -A + "px",
      threshold: ys(0, Yd(1, l)) || 1
    };
    let q = !0;
    function R(V) {
      const N = V[0].intersectionRatio;
      if (N !== l) {
        if (!q)
          return o();
        N ? o(!1, N) : r = setTimeout(() => {
          o(!1, 1e-7);
        }, 1e3);
      }
      N === 1 && !iv(u, i.getBoundingClientRect()) && o(), q = !1;
    }
    a(R, "handleObserve");
    try {
      e = new IntersectionObserver(R, {
        ...T,
        // Handle <iframe>s
        root: s.ownerDocument
      });
    } catch {
      e = new IntersectionObserver(R, T);
    }
    e.observe(i);
  }
  return a(o, "refresh"), o(!0), n;
}
a(rx, "observeMove");
function rv(i, t, e, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: s = !0,
    ancestorResize: n = !0,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = r, u = yy(i), f = s || n ? [...u ? vl(u) : [], ...vl(t)] : [];
  f.forEach((A) => {
    s && A.addEventListener("scroll", e, {
      passive: !0
    }), n && A.addEventListener("resize", e);
  });
  const $ = u && c ? rx(u, e) : null;
  let m = -1, x = null;
  o && (x = new ResizeObserver((A) => {
    let [E] = A;
    E && E.target === u && x && (x.unobserve(t), cancelAnimationFrame(m), m = requestAnimationFrame(() => {
      var T;
      (T = x) == null || T.observe(t);
    })), e();
  }), u && !l && x.observe(u), x.observe(t));
  let g, S = l ? ks(i) : null;
  l && I();
  function I() {
    const A = ks(i);
    S && !iv(S, A) && e(), S = A, g = requestAnimationFrame(I);
  }
  return a(I, "frameLoop"), e(), () => {
    var A;
    f.forEach((E) => {
      s && E.removeEventListener("scroll", e), n && E.removeEventListener("resize", e);
    }), $?.(), (A = x) == null || A.disconnect(), x = null, l && cancelAnimationFrame(g);
  };
}
a(rv, "autoUpdate");
const sv = R5, nv = E5, av = S5, ov = /* @__PURE__ */ a((i, t, e) => {
  const r = /* @__PURE__ */ new Map(), s = {
    platform: ix,
    ...e
  }, n = {
    ...s.platform,
    _c: r
  };
  return M5(i, t, {
    ...s,
    platform: n
  });
}, "computePosition"), Ph = B`[part~=wy-dropdown-menu]{width:max-content;position:absolute;z-index:1000;min-width:calc(10*var(--wy-size, 1rem));border:none;padding:0;--wy-component-background-color: var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);font-size:var(--wy-font-size, var(--wy-size, 1em));text-align:left;background-clip:padding-box;border-radius:var(--wy-dropdown-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));box-shadow:var(--wy-dropdown-shadow, var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12)));overflow:hidden}[part~=wy-dropdown-menu]:not([popover]){display:block}[part~=wy-dropdown-item]{background-color:#0000;color:var(--wy-component-color, var(--wy-on-surface, var(--wy-on-surface-light, #181c20)));width:100%;min-height:calc(2.5*var(--wy-size, 1rem));padding:var(--wy-dropdown-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-dropdown-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));clear:both;font-family:var(--wy-font-family, unset),inherit;font-size:inherit;font-weight:var(--wy-font-weight, unset);line-height:1;text-align:inherit;text-decoration:none;white-space:nowrap;border:0;gap:var(--wy-dropdown-gap, var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));cursor:pointer;display:flex;align-items:center}[part~=wy-dropdown-item]:hover,[part~=wy-dropdown-item]:focus{--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));color:var(--wy-component-color);background-color:var(--wy-component-background-color);text-decoration:none}[part~=wy-dropdown-item][part~=wy-active],[part~=wy-dropdown-item]:active{--wy-component-color: var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73));--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));color:var(--wy-component-color);background-color:var(--wy-component-background-color);text-decoration:none}[part~=wy-dropdown-item][part~=wy-disabled],[part~=wy-dropdown-item]:disabled{color:var(--wy-component-color);background-color:var(--wy-component-background-color);pointer-events:none;opacity:var(--wy-opacity-disabled, 38%)}[part~=wy-dropdown-item]>img,[part~=wy-dropdown-item]>wy-icon{margin-right:calc(.5*var(--wy-size, 1rem));color:inherit}[part~=wy-dropdown-item]:active>wy-icon{color:inherit}[part~=wy-dropdown-item][part~=wy-dropdown-option] wy-icon{visibility:hidden}[part~=wy-dropdown-item][part~=wy-dropdown-option][part~=wy-selected] wy-icon{visibility:visible}[part~=wy-dropdown-divider]{height:0;margin:0;overflow:hidden;border:none;border-top:var(--wy-dropdown-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}`;
var sx = Object.defineProperty, nx = Object.getOwnPropertyDescriptor, Ce = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? nx(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && sx(t, e, s), s;
}, "__decorateClass$13"), Ua;
let Ke = (Ua = class extends X {
  constructor() {
    super(), this.exportParts = new U(this), this.directionX = "right", this.directionY = "down", this.icon = "dots-vertical", this.small = !1, this.disabled = !1, this._placement = "bottom-start", this.showMenu = !1, this.buttonRef = et(), this.menuRef = et(), this._documentClickHandler = (t) => {
      this.showMenu && (t.preventDefault(), this.menuRef.value?.popover || (this.showMenu = !1));
    }, this.addEventListener("click", (t) => {
      t.preventDefault();
    });
  }
  handleClose(t) {
    (t.type === "toggle" && t.newState === "closed" || t.type === "click") && (this.showMenu = !1, this.dispatchEvent(new CustomEvent("close")));
  }
  handleClickToggle(t) {
    t.stopPropagation(), this.showMenu = this.disabled ? !1 : !this.showMenu;
  }
  willUpdate(t) {
    if (super.willUpdate(t), (t.has("disabled") || t.has("showMenu")) && this.disabled && this.showMenu && (this.showMenu = !1), (t.has("directionX") || t.has("directionY")) && (this._placement = this.directionX === "right" && this.directionY === "down" ? "bottom-start" : this.directionX === "left" && this.directionY === "down" ? "bottom-end" : this.directionX === "right" && this.directionY === "up" ? "top-start" : "top-end"), t.has("showMenu") && (this.showMenu && !this.computePositionCleanup && this.buttonRef.value && this.menuRef.value ? this.computePositionCleanup = rv(this.buttonRef.value, this.menuRef.value, () => {
      if (this.buttonRef.value && this.menuRef.value) {
        const e = !this.menuRef.value.popover, r = e || !e1(this.buttonRef.value);
        ov(this.buttonRef.value, this.menuRef.value, {
          placement: this._placement,
          strategy: e ? "fixed" : "absolute",
          middleware: [
            av(),
            sv(({ placement: s }) => s.includes("top") ? 9 : 13),
            nv({ mainAxis: !0, crossAxis: !0, padding: 4, altBoundary: r })
          ]
        }).then(({ x: s, y: n }) => {
          this.menuRef.value && Object.assign(this.menuRef.value.style, {
            marginLeft: `${s}px`,
            marginTop: `${n}px`,
            top: 0,
            left: 0,
            position: e ? "fixed" : void 0,
            zIndex: e ? 1075 : void 0
          });
        });
      }
    }) : !this.showMenu && this.computePositionCleanup && (this.computePositionCleanup?.(), this.computePositionCleanup = void 0)), this.showMenu) {
      requestAnimationFrame(() => {
        document.addEventListener("click", this._documentClickHandler, { once: !0, capture: !0 });
      });
      try {
        this.menuRef.value?.showPopover();
      } catch {
      }
    } else
      try {
        this.menuRef.value?.hidePopover();
      } catch {
      }
  }
  render() {
    const t = this._slotButton.length === 0 || this._slotButton.length === 1 && this._slotButton[0] instanceof Ht;
    return h`
      <span part="wy-dropdown">
        <span
          ${j(this.buttonRef)}
          part="wy-dropdown-button-container"
          @click=${(e) => this.handleClickToggle(e)}
          @keydown=${le}
          @keyup=${Me}
        >
          <wy-button
            part="wy-dropdown-button"
            .kind=${t ? "icon" : void 0}
            ?small=${this.small}
            title=${this.title}
            ?active=${this.showMenu}
            ?disabled=${this.disabled}
          >
            <slot name="button-content" @slotchange=${() => this.requestUpdate()}>
              <wy-icon part="wy-dropdown-button-icon" name=${this.icon}></wy-icon>
            </slot>
          </wy-button>
        </span>

        <div
          ${j(this.menuRef)}
          part="wy-dropdown-menu"
          @click=${(e) => this.handleClickToggle(e)}
          @keyup=${ny}
          ?hidden=${Up() && !this.showMenu}
          popover=${nt(Up() ? void 0 : "auto")}
        >
          <slot></slot>
        </div>
      </span>
    `;
  }
  firstUpdated(t) {
    this.menuRef.value?.addEventListener(
      this.menuRef.value.popover ? "toggle" : "click",
      (e) => this.handleClose(e)
    );
  }
  disconnectedCallback() {
    this.computePositionCleanup?.(), super.disconnectedCallback();
  }
}, a(Ua, "WyDropdown"), Ua);
Ke.styles = [zt, Ph];
Ce([
  p()
], Ke.prototype, "directionX", 2);
Ce([
  p()
], Ke.prototype, "directionY", 2);
Ce([
  p()
], Ke.prototype, "icon", 2);
Ce([
  p({ type: Boolean })
], Ke.prototype, "small", 2);
Ce([
  p({ type: Boolean })
], Ke.prototype, "disabled", 2);
Ce([
  F()
], Ke.prototype, "_placement", 2);
Ce([
  F()
], Ke.prototype, "showMenu", 2);
Ce([
  Hc({ slot: "button-content" })
], Ke.prototype, "_slotButton", 2);
Ce([
  F()
], Ke.prototype, "computePositionCleanup", 2);
Ke = Ce([
  H("wy-dropdown")
], Ke);
var Ba;
let gl = (Ba = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.active = !1;
  }
  render() {
    return h`<div part="wy-dropdown-item ${K({ "wy-active": this.active })}" tabindex="0"><slot></slot></div>`;
  }
}, a(Ba, "WyDropdownItem"), Ba);
gl.styles = [zt, Ph, Z];
Ce([
  p({ type: Boolean })
], gl.prototype, "active", 2);
gl = Ce([
  H("wy-dropdown-item")
], gl);
var qa;
let kc = (qa = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.active = !1, this.selected = !1;
  }
  render() {
    const t = {
      visibility: this.selected ? null : "hidden"
    };
    return h`
      <div
        part="wy-dropdown-item wy-dropdown-option ${K({
      "wy-active": this.active,
      "wy-selected": this.selected
    })}"
        tabindex="0"
      >
        <slot name="icon" style=${ml(t)}
          ><wy-icon part="wy-dropdown-option-icon" name="check"></wy-icon
        ></slot>
        <slot></slot>
      </div>
    `;
  }
}, a(qa, "WyDropdownOption"), qa);
kc.styles = [zt, Ph, Z];
Ce([
  p({ type: Boolean })
], kc.prototype, "active", 2);
Ce([
  p({ type: Boolean })
], kc.prototype, "selected", 2);
kc = Ce([
  H("wy-dropdown-option")
], kc);
var Na;
let eh = (Na = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this);
  }
  render() {
    return h`<hr part="wy-dropdown-divider" />`;
  }
}, a(Na, "WyDropdownDivider"), Na);
eh.styles = [zt, Ph, Z];
eh = Ce([
  H("wy-dropdown-divider")
], eh);
const cv = B`[part~=wy-placeholder]{cursor:wait;color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));background:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));opacity:.5;animation:wy-placeholder-glow 2s ease-in-out infinite;line-height:1.45}@keyframes wy-placeholder-glow{50%{opacity:.2}}`;
var ax = Object.defineProperty, ox = Object.getOwnPropertyDescriptor, lv = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? ox(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && ax(t, e, s), s;
}, "__decorateClass$12"), ja;
let bl = (ja = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.text = "";
  }
  render() {
    const t = this.text.trim();
    return h`
      <div part="wy-skeleton">
        ${t.length ? t.split(/(\n+)/).map((e) => {
      const r = e.split(/(\s+)/);
      return h`
                <div part="wy-placeholder-line">
                  ${r.map((s) => h` <span part="wy-placeholder">${s}</span> `)}
                </div>
              `;
    }) : v}
      </div>
    `;
  }
}, a(ja, "WySkeleton"), ja);
bl.styles = [cv, Z];
lv([
  p()
], bl.prototype, "text", 2);
bl = lv([
  H("wy-skeleton")
], bl);
function dv(i) {
  const t = [i];
  for (; i && i.parent; )
    i = i.parent, t.push(i);
  return t;
}
a(dv, "getEntityChain");
function hv(i, t, e) {
  return i.type === t && (!e || i.id === e.id);
}
a(hv, "isEntityMatch");
function Mh(i, t, e) {
  return dv(i).some((s) => s && hv(s, t, e));
}
a(Mh, "isEntityChainMatch");
function pv(i, t, e) {
  return dv(i).find((s) => s && hv(s, t, e));
}
a(pv, "getEntityChainMatch");
function uv(i, t, e, r) {
  const s = pv(i, r);
  return s && s.parent ? Mh(s.parent, t, e) : !1;
}
a(uv, "hasEntityChildType");
async function yv(i, t, e) {
  let r;
  if (t && e?.link?.app?.id) {
    const n = await t.fetch(`/api/apps/${e.link.app.id}`);
    n.ok && (r = (await n.json()).metadata);
  }
  const s = new CustomEvent("wy-link", {
    bubbles: !0,
    composed: !0,
    cancelable: !0,
    detail: {
      link: e.link ? {
        ...e?.link,
        // HACK: pass along the agent uid so uikit can match the correct agent chat     
        agent: e.actor.is_agent && e.link?.app?.type && jd.has(e.link.app.type) ? e.actor.uid : void 0
      } : void 0,
      metadata: e.metadata,
      app_type: e?.link?.app?.type && l0.get(e.link.app.type) || Mr,
      source_name: r?.source_name,
      source_url: r?.source_url,
      source_data: r?.source_data
    }
  });
  return i.dispatchEvent(s);
}
a(yv, "dispatchLinkEvent");
function wv(i) {
  const t = i.args;
  switch (i.template) {
    case "**{0}** added *{1}* to **{2}**": {
      const [e, r, s] = t;
      return {
        title: b(ut`${e} added ${r} to ${s}`),
        titleHtml: b(h`<strong>${e}</strong> added <em>${r}</em> to <strong>${s}</strong>`)
      };
    }
    case "**{0}** edited *{1}*": {
      const [e, r] = t;
      return {
        title: b(ut`${e} edited ${r}`),
        titleHtml: b(h`<strong>${e}</strong> edited <em>${r}</em>`)
      };
    }
    case '**{0}** commented on *{1}*: "{2}"': {
      const [e, r, s] = t;
      return {
        title: b(ut`${e} commented on ${r}`),
        titleHtml: b(h`<strong>${e}</strong> commented on <em>${r}</em>`),
        detail: s
      };
    }
    case '**{0}** commented on **{1}**: "{2}"': {
      const [e, r, s] = t;
      return {
        title: b(ut`${e} commented on ${r}`),
        titleHtml: b(h`<strong>${e}</strong> commented on <strong>${r}</strong>`),
        detail: s
      };
    }
    case '**{0}** replied to your post: "{1}"': {
      const [e, r] = t;
      return {
        title: b(ut`${e} replied to your post`),
        titleHtml: b(h`<strong>${e}</strong> replied to your post`),
        detail: r
      };
    }
    case '**{0}** replied to a post: "{1}"': {
      const [e, r] = t;
      return {
        title: b(ut`${e} replied to a post`),
        titleHtml: b(h`<strong>${e}</strong> replied to a post`),
        detail: r
      };
    }
    case '**{0}** mentioned you in a comment: "{1}"': {
      const [e, r] = t;
      return {
        title: b(ut`${e} mentioned you in a comment`),
        titleHtml: b(h`<strong>${e}</strong> mentioned you in a comment`),
        detail: r
      };
    }
    case '**{0}** posted in **{1}**: "{2}"': {
      const [e, r, s] = t;
      return {
        title: b(ut`${e} posted in ${r}`),
        titleHtml: b(h`<strong>${e}</strong> posted in <strong>${r}</strong>`),
        detail: s
      };
    }
    case '**{0}** mentioned you in a post: "{1}"': {
      const [e, r] = t;
      return {
        title: b(ut`${e} mentioned you in a post`),
        titleHtml: b(h`<strong>${e}</strong> mentioned you in a post`),
        detail: r
      };
    }
    case 'New message from **{0}**: "{1}"': {
      const [e, r] = t;
      return {
        title: b(ut`New message from ${e}`),
        titleHtml: b(h`New message from <strong>${e}</strong>`),
        detail: r
      };
    }
    case '**{0}** sent a message in **{1}**: "{2}"': {
      const [e, r, s] = t;
      return {
        title: b(ut`${e} sent a message in ${r}`),
        titleHtml: b(h`<strong>${e}</strong> sent a message in <strong>${r}</strong>`),
        detail: s
      };
    }
    case '**{0}** mentioned you in a message: "{1}"': {
      const [e, r] = t;
      return {
        title: b(ut`${e} mentioned you in a message`),
        titleHtml: b(h`<strong>${e}</strong> mentioned you in a message`),
        detail: r
      };
    }
    case '**{0}** edited a post: "{1}"': {
      const [e, r] = t;
      return {
        title: b(ut`${e} edited a post`),
        titleHtml: b(h`<strong>${e}</strong> edited a post`),
        detail: r
      };
    }
    case "**{0}** liked *{1}*": {
      const [e, r] = t;
      return {
        title: b(ut`${e} liked ${r}`),
        titleHtml: b(h`<strong>${e}</strong> liked <em>${r}</em>`)
      };
    }
    case "**{0}** reacted {2} to *{1}*": {
      const [e, r, s] = t;
      return {
        title: b(ut`${e} reacted ${r} to ${s}`),
        titleHtml: b(h`<strong>${e}</strong> reacted ${r} to <em>${s}</em>`)
      };
    }
    case '**{0}** liked your comment: "{1}"': {
      const [e, r] = t;
      return {
        title: b(ut`${e} liked your comment`),
        titleHtml: b(h`<strong>${e}</strong> liked your comment`),
        detail: r
      };
    }
    case '**{0}** reacted {1} to your comment: "{2}"': {
      const [e, r, s] = t;
      return {
        title: b(ut`${e} reacted ${r} to your comment`),
        titleHtml: b(h`<strong>${e}</strong> reacted ${r} to your comment`),
        detail: s
      };
    }
    case '**{0}** liked your message: "{1}"': {
      const [e, r] = t;
      return {
        title: b(ut`${e} liked your message`),
        titleHtml: b(h`<strong>${e}</strong> liked your message`),
        detail: r
      };
    }
    case '**{0}** reacted {1} to your message: "{2}"': {
      const [e, r, s] = t;
      return {
        title: b(ut`${e} reacted ${r} to your message`),
        titleHtml: b(h`<strong>${e}</strong> reacted ${r} to your message`),
        detail: s
      };
    }
    case '**{0}** liked your post: "{1}"': {
      const [e, r] = t;
      return {
        title: b(ut`${e} liked your post`),
        titleHtml: b(h`<strong>${e}</strong> liked your post`),
        detail: r
      };
    }
    case '**{0}** reacted {1} to your post: "{2}"': {
      const [e, r, s] = t;
      return {
        title: b(ut`${e} reacted ${r} to your post`),
        titleHtml: b(h`<strong>${e}</strong> reacted ${r} to your post`),
        detail: s
      };
    }
    case "**{0}** voted on your poll": {
      const [e] = t;
      return {
        title: b(ut`${e} voted on your poll`),
        titleHtml: b(h`<strong>${e}</strong> voted on your poll`)
      };
    }
    case "**{0}** and **{1}** voted on your poll": {
      const [e, r] = t;
      return {
        title: b(ut`${e} and ${r} voted on your poll`),
        titleHtml: b(h`<strong>${e}</strong> and <strong>${r}</strong> voted on your poll`)
      };
    }
    case "**{0}**, **{1}** and **{2}** voted on your poll": {
      const [e, r, s] = t;
      return {
        title: b(ut`${e}, ${r} and ${s} voted on your poll`),
        titleHtml: b(
          h`<strong>${e}</strong>, <strong>${r}</strong> and <strong>${s}</strong> voted on your poll`
        )
      };
    }
    case "**{0}** and {1} others voted on your poll": {
      const [e, r] = t;
      return {
        title: b(ut`${e} and ${r} others voted on your poll`),
        titleHtml: b(h`<strong>${e}</strong> and ${r} others voted on your poll`)
      };
    }
    default:
      return {
        title: i.plain,
        titleHtml: h`${bs(i.html)}`
      };
  }
}
a(wv, "getNotificationText");
const wy = B`[part~=wy-code] pre,.wy-code pre,[part~=wy-content] pre{text-wrap:pretty}[part~=wy-code] .code,[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code .code,.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] .code,[part~=wy-content] code[class*=language-],[part~=wy-content] pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;word-wrap:break-word;line-height:1.25;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}@media print{[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] code[class*=language-],[part~=wy-content] pre[class*=language-]{text-shadow:none}}[part~=wy-code] pre[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}[part~=wy-code] :not(pre)>code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code :not(pre)>code[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] :not(pre)>code[class*=language-],[part~=wy-content] pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));background:var(--wy-background, var(--wy-background-light, #f7f9ff))}[part~=wy-code] :not(pre)>code[class*=language-],.wy-code :not(pre)>code[class*=language-],[part~=wy-content] :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}[part~=wy-code] .token.variable,.wy-code .token.variable,[part~=wy-content] .token.variable{color:var(--wy-code-variable, var(--wy-code-variable-light, #001080))}[part~=wy-code] .token.operator,.wy-code .token.operator,[part~=wy-content] .token.operator{color:var(--wy-code-operator, var(--wy-code-operator-light, #000000))}[part~=wy-code] .token.prolog,.wy-code .token.prolog,[part~=wy-content] .token.prolog{color:var(--wy-code-prolog, var(--wy-code-prolog-light, #000080))}[part~=wy-code] .token.comment,.wy-code .token.comment,[part~=wy-content] .token.comment{color:var(--wy-code-comment, var(--wy-code-comment-light, #008000))}[part~=wy-code] .token.builtin,.wy-code .token.builtin,[part~=wy-content] .token.builtin{color:var(--wy-code-builtin, var(--wy-code-builtin-light, #0070C1))}[part~=wy-code] .token.number,.wy-code .token.number,[part~=wy-content] .token.number{color:var(--wy-code-number, var(--wy-code-number-light, #098658))}[part~=wy-code] .token.inserted,.wy-code .token.inserted,[part~=wy-content] .token.inserted{color:var(--wy-code-inserted, var(--wy-code-inserted-light, #098658))}[part~=wy-code] .token.constant,.wy-code .token.constant,[part~=wy-content] .token.constant{color:var(--wy-code-constant, var(--wy-code-constant-light, #811F3F))}[part~=wy-code] .token.hexcode,.wy-code .token.hexcode,[part~=wy-content] .token.hexcode{color:var(--wy-code-hexcode, var(--wy-code-hexcode-light, #811F3F))}[part~=wy-code] .token.regex,.wy-code .token.regex,[part~=wy-content] .token.regex{color:var(--wy-code-regex, var(--wy-code-regex-light, #811F3F))}[part~=wy-code] .token.char,.wy-code .token.char,[part~=wy-content] .token.char{color:var(--wy-code-char, var(--wy-code-char-light, #811F3F))}[part~=wy-code] .token.tag,.wy-code .token.tag,[part~=wy-content] .token.tag{color:var(--wy-code-tag, var(--wy-code-tag-light, #800000))}[part~=wy-code] .token.attr-name,.wy-code .token.attr-name,[part~=wy-content] .token.attr-name{color:var(--wy-code-attr-name, var(--wy-code-attr-name-light, #E50000))}[part~=wy-code] .token.selector,.wy-code .token.selector,[part~=wy-content] .token.selector{color:var(--wy-code-selector, var(--wy-code-selector-light, #E50000))}[part~=wy-code] .token.property,.wy-code .token.property,[part~=wy-content] .token.property{color:var(--wy-code-property, var(--wy-code-property-light, #E50000))}[part~=wy-code] .token.deleted,.wy-code .token.deleted,[part~=wy-content] .token.deleted{color:var(--wy-code-deleted, var(--wy-code-deleted-light, #A31515))}[part~=wy-code] .token.string,.wy-code .token.string,[part~=wy-content] .token.string{color:var(--wy-code-string, var(--wy-code-string-light, #A31515))}[part~=wy-code] .token.changed,.wy-code .token.changed,[part~=wy-content] .token.changed{color:var(--wy-code-changed, var(--wy-code-changed-light, #0451A5))}[part~=wy-code] .token.punctuation,.wy-code .token.punctuation,[part~=wy-content] .token.punctuation{color:var(--wy-code-punctuation, var(--wy-code-punctuation-light, #000000))}[part~=wy-code] .token.function,.wy-code .token.function,[part~=wy-content] .token.function{color:var(--wy-code-function, var(--wy-code-function-light, #0000FF))}[part~=wy-code] .token.keyword,.wy-code .token.keyword,[part~=wy-content] .token.keyword{color:var(--wy-code-keyword, var(--wy-code-keyword-light, #AF00DB))}[part~=wy-code] .token.class-name,.wy-code .token.class-name,[part~=wy-content] .token.class-name{color:var(--wy-code-class-name, var(--wy-code-class-name-light, #267F99))}[part~=wy-code] .token.important,[part~=wy-code] .token.bold,.wy-code .token.important,.wy-code .token.bold,[part~=wy-content] .token.important,[part~=wy-content] .token.bold{font-weight:700}[part~=wy-code] .token.italic,.wy-code .token.italic,[part~=wy-content] .token.italic{font-style:italic}[part~=wy-content]{overflow-wrap:break-word;min-width:0}[part~=wy-content]:empty{display:none}[part~=wy-content]>:first-child{margin-top:0}[part~=wy-content]>:last-child{margin-bottom:0}[part~=wy-content] b,[part~=wy-content] strong{font-weight:var(--wy-font-weight-bold, 600)}[part~=wy-content] blockquote{border-left:calc(2*var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));margin:var(--wy-gap, calc(.5 * var(--wy-size, 1rem))) 0;padding-left:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-content] blockquote>p{margin:0}[part~=wy-content] hr{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));border-width:var(--wy-border, 1px) 0 0 0;border-style:solid}[part~=wy-content] pre,[part~=wy-content] code{font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-content] :not(pre)>code{overflow-wrap:inherit}[part~=wy-content] pre>code{font-size:var(--wy-font-size, var(--wy-size, 1em));white-space:pre-wrap}[part~=wy-content] h1,[part~=wy-content] h2,[part~=wy-content] h3,[part~=wy-content] h4,[part~=wy-content] h5,[part~=wy-content] h6{font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.5))}[part~=wy-content] h1{font-size:var(--wy-h1-font-size, var(--wy-font-size-xxl, 1.5em));font-weight:var(--wy-h1-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h1-margin, 0 0 var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-content] h2{font-size:var(--wy-h2-font-size, var(--wy-font-size-xl, 1.25em));font-weight:var(--wy-h2-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h2-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content] h3{font-size:var(--wy-h3-font-size, var(--wy-font-size-lg, 1.125em));font-weight:var(--wy-h3-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h3-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content] h4{font-size:var(--wy-h4-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-h4-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h4-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 0)}[part~=wy-content] h5{font-size:var(--wy-h5-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-h5-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h5-margin, 0)}[part~=wy-content] h6{font-size:var(--wy-h6-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-h6-font-weight, inherit);margin:var(--wy-h6-margin, 0)}[part~=wy-content] table{display:block;width:100%;max-width:-moz-max-content;max-width:max-content;overflow-x:auto;white-space:nowrap;border-collapse:separate;border-spacing:0 0;margin-bottom:var(--wy-size, 1rem)}[part~=wy-content] table th,[part~=wy-content] table td{padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));border-color:inherit;border-style:solid}[part~=wy-content] table th{text-align:inherit;text-align:-webkit-match-parent;border-width:var(--wy-border, 1px) 0 var(--wy-border, 1px) var(--wy-border, 1px);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600))}[part~=wy-content] table th:first-child{border-top-left-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] table th:last-child{border-top-right-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-right-width:var(--wy-border, 1px)}[part~=wy-content] table td{border-width:0 0 var(--wy-border, 1px) var(--wy-border, 1px)}[part~=wy-content] table td:last-child{border-right-width:var(--wy-border, 1px)}[part~=wy-content] table tr:last-child td:first-child{border-bottom-left-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] table tr:last-child td:last-child{border-bottom-right-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] table>tbody{vertical-align:inherit}[part~=wy-content] table>thead{vertical-align:bottom}[part~=wy-content] img{max-width:100%;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin-block:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] ol{list-style-type:decimal}[part~=wy-content] ul{list-style-type:disc}[part~=wy-content] li{margin:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0}[part~=wy-content] ol,[part~=wy-content] ul{margin:var(--wy-size, 1rem) 0;padding:0 0 0 1.625em}[part~=wy-content] ol>li,[part~=wy-content] ul>li{padding-left:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] ol>li>:first-child,[part~=wy-content] ul>li>:first-child{margin-bottom:0;margin-top:0}[part~=wy-content] ol>li>:last-child,[part~=wy-content] ul>li>:last-child{margin-bottom:0}[part~=wy-content] .wy-hashtag{color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-content] .wy-mention{font-weight:var(--wy-font-weight-bold, 600)}[part~=wy-content] .wy-mention:before{content:\"@\"}[part~=wy-content-emoji] .wy-emoji{font-size:3em}`;
function fy(i) {
  const t = i;
  t && (t.complete && t.naturalHeight !== 0 ? !t.classList.contains("wy-loading") && !t.part.contains("wy-loading") ? (t.classList.add("wy-loading", "wy-loaded"), t.part.add("wy-loading", "wy-loaded")) : t.decode().then(() => {
    t.classList.add("wy-loaded"), t.part.add("wy-loaded");
  }) : (t.classList.add("wy-loading"), t.part.add("wy-loading")));
}
a(fy, "checkImageLoad");
function my(i) {
  const t = i.target;
  t.tagName === "IMG" && (t.classList.contains("wy-loading") || t.part.contains("wy-loading")) && !t.classList.contains("wy-loaded") && !t.part.contains("wy-loaded") && (t.classList.add("wy-loaded"), t.part.add("wy-loaded"));
}
a(my, "imageLoaded");
const cx = B`[part~=wy-image]{padding:0;width:50%;position:relative;flex:auto;background-color:inherit;background-clip:content-box;max-height:var(--wy-image-max-size, calc(32 * var(--wy-size, 1rem)))}[part~=wy-image-filled]{position:relative;background-size:100%,100% 100%;background-position:center;background-clip:content-box;clip-path:content-box;align-items:center;justify-content:center}[part~=wy-image-filled]:after{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;z-index:1;-webkit-backdrop-filter:blur(32px);backdrop-filter:blur(32px);background-color:var(--wy-shade, var(--wy-shade-light, rgba(0, 0, 0, .3)))}[part~=wy-image-full-width]{flex-basis:100%!important}[part~=wy-image-grid]{display:flex;flex-wrap:wrap;justify-content:space-evenly;position:relative;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));overflow:hidden;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-image-grid-outer]{border-radius:0}[part~=wy-image-area]{display:flex;height:100%;cursor:pointer;align-items:center}[part~=wy-image-content]{position:absolute;height:auto;max-height:100%;width:100%;object-fit:contain;z-index:2}[part~=wy-image-content][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-image-content][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-image-content][part~=wy-loading][part~=wy-loaded]~[part~=wy-image-preview]{transition-delay:.15s;opacity:0}[part~=wy-image-icon]{object-fit:scale-down;object-position:center center}[part~=wy-image-grid-more]{position:absolute;z-index:3;line-height:100%;color:var(--wy-white, #ffffff);inset:0;display:flex;align-items:center;justify-content:center;font-size:calc(1.5*var(--wy-size, 1rem));background:rgba(0,0,0,var(--wy-opacity-disabled, 38%))}`;
var lx = Object.defineProperty, dx = Object.getOwnPropertyDescriptor, Sh = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? dx(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && lx(t, e, s), s;
}, "__decorateClass$11");
const hf = 128;
var Wa;
let _s = (Wa = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.images = [], this.limit = 3, this.outer = !1;
  }
  /**
   * Dispatch a `file-open` event.
   *
   * @internal
   * @param e - Event that will be prevented.
   * @param file - The file to open.
   */
  dispatchFileOpen(t, e) {
    if (dh(t)) {
      t.stopPropagation();
      return;
    }
    if (t.preventDefault(), !e.is_trashed) {
      const r = new CustomEvent("file-open", { detail: { fileId: e.id } });
      this.dispatchEvent(r);
    }
  }
  render() {
    const t = this.images.length > this.limit ? this.images.length - this.limit : 0, e = this.images.slice(0, this.limit);
    return h`
      <div
        part=${K({
      "wy-image-grid": !0,
      "wy-image-grid-outer": this.outer
    })}
      >
        ${e.map((r, s) => {
      const n = !r.width || r.width <= hf || !r.height || r.height <= hf, o = r.width && r.height ? r.width / r.height : 1, c = 64, l = o.toPrecision(5), u = (o * c).toPrecision(5) + "px", f = n ? c + "px" : (100 / o).toPrecision(5) + "%", $ = r.width + "px", m = this.images.length !== 2 && s === 0, x = ii(r.name), g = x === ".gif" || x === ".svg" ? r.download_url : r.preview_url;
      return g ? h`
                <a
                  href="${r.download_url ?? "#"}"
                  @click=${(S) => {
        !S.defaultPrevented && this.dispatchFileOpen(S, r);
      }}
                  part=${K({
        "wy-image": !0,
        "wy-image-filled": !0,
        "wy-image-full-width": m
      })}
                  style=${ml({
        flexBasis: u,
        flexGrow: l,
        flexShrink: l,
        width: $,
        backgroundImage: `linear-gradient(var(--wy-shade-invert, rgba(255,255,255,0.15))), url(${g}), linear-gradient(var(--wy-shade-opaque, white));`
      })}
                >
                  <div part="wy-image-area" style=${ml({ paddingBottom: f })}>
                    <img
                      part=${K({ "wy-image-content": !0, "wy-image-icon": n })}
                      src=${g}
                      ${j(fy)}
                      @load=${my}
                      alt=""
                      loading="lazy"
                      decoding="async"
                    />
                    ${s === e.length - 1 && t ? h`<span part="wy-image-grid-more">+${t}</span>` : ""}
                  </div>
                </a>
              ` : v;
    })}
      </div>
    `;
  }
}, a(Wa, "WyImageGrid"), Wa);
_s.styles = [cx, Z];
Sh([
  p({ attribute: !1 })
], _s.prototype, "images", 2);
Sh([
  p({ type: Number })
], _s.prototype, "limit", 2);
Sh([
  p({ type: Boolean, reflect: !0 })
], _s.prototype, "outer", 2);
_s = Sh([
  H("wy-image-grid")
], _s);
var hx = Object.defineProperty, px = Object.getOwnPropertyDescriptor, ld = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? px(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && hx(t, e, s), s;
}, "__decorateClass$10"), Qa;
let xl = (Qa = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this);
  }
  /**
   * Triggers file-open event.
   *
   * @param e
   * @param file
   * @returns
   */
  dispatchFileOpen(t, e) {
    t.preventDefault();
    const r = new CustomEvent("file-open", { detail: { fileId: e.id } });
    return this.dispatchEvent(r);
  }
  render() {
    const t = this.file.size && this.file.size > 0 ? yh(this.file.size) : null, e = ii(this.file.name), { icon: r } = Ur(this.file.name), s = Zu(this.file.name), n = nd(this.file.provider);
    return h`    
      <wy-item
        @click=${(o) => {
      !o.defaultPrevented && !this.file.is_trashed && this.dispatchFileOpen(o, this.file);
    }}
        size="md"
        title=${this.file.name}
        url=${nt(this.file.download_url ?? this.file.external_url)}
        interactive
      >
        <wy-icon slot="image" name=${r} .overlayName=${n} size="48" kind=${s} ext=${e}></wy-icon>
        <span slot="title">${this.file.name}</span>
        ${t ? h`<span slot="text" title="${t}">${t}</span>` : v}
      </wy-item>
    `;
  }
}, a(Qa, "WyAttachment"), Qa);
xl.styles = [gh, Z];
ld([
  p({ attribute: !1 })
], xl.prototype, "file", 2);
xl = ld([
  H("wy-attachment")
], xl);
var Ka;
let _c = (Ka = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.files = [], this.filled = !1;
  }
  dispatchFileOpen(t) {
    const e = new CustomEvent("file-open", { detail: { fileId: t.id } });
    return this.dispatchEvent(e);
  }
  render() {
    return h`
      <wy-item-list rounded ?filled=${this.filled}>
        ${this.files.map((t) => h`<wy-attachment @file-open=${() => this.dispatchFileOpen(t)} .file=${t}></wy-attachment>`)}
      </wy-item-list>
    `;
  }
}, a(Ka, "WyAttachmentList"), Ka);
_c.styles = [gh, Z];
ld([
  p({ attribute: !1 })
], _c.prototype, "files", 2);
ld([
  p({ type: Boolean })
], _c.prototype, "filled", 2);
_c = ld([
  H("wy-attachment-list")
], _c);
var ux = Object.defineProperty, yx = Object.getOwnPropertyDescriptor, Ah = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? yx(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && ux(t, e, s), s;
}, "__decorateClass$$"), Ga;
let $l = (Ga = class extends $e {
  constructor() {
    super(...arguments), this.exportParts = new U(this);
  }
  /**
   * Triggers file-open event.
   * @internal
   */
  dispatchFileOpen(t, e) {
    t.preventDefault();
    const r = new CustomEvent("file-open", { detail: { fileId: e.id } });
    return this.dispatchEvent(r);
  }
  render() {
    const t = this.file.size && this.file.size > 0 ? yh(this.file.size) : null, e = ii(this.file.name), { icon: r } = Ur(this.file.name), s = Zu(this.file.name), n = nd(this.file.provider), o = `${this.file.name}${t ? ` • ${t}` : ""}`;
    return h`
      <wy-button
        part="wy-annotation"
        @click=${(c) => {
      !c.defaultPrevented && !this.file.is_trashed && this.dispatchFileOpen(c, this.file);
    }}
        kind="filled"
        small
        title=${o}
      >
        <wy-icon
          part="wy-annotation-icon"
          name=${r}
          .overlayName=${n}
          size="24"
          kind=${s}
          ext=${e}
        ></wy-icon>
        <span part="wy-annotation-text">${this.file.name}</span>
      </wy-button>
    `;
  }
}, a(Ga, "WyAnnotation"), Ga);
$l.styles = [Z];
Ah([
  p({ type: Object, attribute: !1 })
], $l.prototype, "file", 2);
$l = Ah([
  H("wy-annotation")
], $l);
var Za;
let Cl = (Za = class extends Rt {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.files = [];
  }
  render() {
    return this.settings?.annotations === "none" ? v : h`
      <div part="wy-annotations">
        ${this.files.map((t) => h`<wy-annotation .file=${t}></wy-annotation>`)}
      </div>
    `;
  }
}, a(Za, "WyAnnotationList"), Za);
Cl.styles = [Z];
Ah([
  p({ attribute: !1 })
], Cl.prototype, "files", 2);
Cl = Ah([
  H("wy-annotation-list")
], Cl);
function Wi(i = "", t = "", e = "", r = !1) {
  if (we(), i) {
    const s = document.createElement("a");
    r && (/^(data:|blob:)/.test(i) ? s.download = e || "download" : i = i.includes("?d=1") || i.includes("&d=1") ? i : i.includes("?") ? i + "&d=1" : i + "?d=1"), t && (s.target = t), s.href = i, document.body.appendChild(s);
    try {
      s.click();
    } catch {
      if (console.warn("Could not open link normally, trying fallback"), /^(?:blob:|data:)/.test(i))
        console.error(`Could not ${r ? "download" : "open"} ${e}`);
      else
        try {
          window.open(i, t);
        } catch {
          console.error(`Could not ${r ? "download" : "open"} ${e}`);
        }
    }
    document.body.removeChild(s);
  }
}
a(Wi, "openUrl");
function pf(i, t) {
  return new URL(
    i,
    typeof WEAVY_IMPORT_URL == "string" && (!t || !new URL(t).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : t
  );
}
a(pf, "environmentUrl");
const fv = B`[part~=wy-embed]{display:flex;flex-direction:column;word-wrap:break-word;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));clip-path:border-box;--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));color:var(--wy-component-color)}[part~=wy-embed-interactive]{background-color:var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));-webkit-user-select:none;user-select:none;cursor:pointer}[part~=wy-embed-interactive]:active,[part~=wy-embed-interactive]:hover,[part~=wy-embed-interactive]:focus{background-color:var(--wy-surface-layer-high, var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039)))}[part~=wy-embed-interactive][part~=wy-disabled],[part~=wy-embed-interactive]:disabled{pointer-events:none;border-left:none;border-right:none;border-bottom:none;border-radius:0;background-color:#0000}[part~=wy-embed-area]{display:flex;justify-content:center;align-items:center}[part~=wy-embed-icon]{width:calc(3*var(--wy-size, 1rem));height:calc(3*var(--wy-size, 1rem));flex:0 0 auto;object-fit:contain}[part~=wy-embed-content]{display:flex;position:relative;padding:0;overflow:hidden;width:100%;flex-direction:column;align-items:center;justify-content:flex-start}[part~=wy-embed-content] iframe,[part~=wy-embed-content] embed,[part~=wy-embed-content] object,[part~=wy-embed-content] video{border:0;width:auto;height:auto;max-height:var(--wy-component-max-size, var(--wy-embed-content-max-size, calc(48 * var(--wy-size, 1rem))))}[part~=wy-embed-photo]{border-top-left-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-top-right-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-left-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-right-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));position:relative;background-size:cover;background-position:center;clip-path:border-box}[part~=wy-embed-photo]:after{border-top-left-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-top-right-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-left-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-right-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));content:\"\";position:absolute;width:100%;height:100%;z-index:1;-webkit-backdrop-filter:blur(32px);backdrop-filter:blur(32px);background-color:var(--wy-shade, var(--wy-shade-light, rgba(0, 0, 0, .3)))}[part~=wy-embed-photo-with-description]{--wy-component-border-bottom-radius: 0}[part~=wy-embed-image]{width:auto;height:auto;object-fit:contain;flex:0 1 auto;min-width:0;min-height:calc(3*var(--wy-size, 1rem));max-height:calc(var(--wy-component-max-size, var(--wy-embed-content-max-size, calc(48 * var(--wy-size, 1rem)))) - var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))*2 - var(--wy-button-line-height, var(--wy-line-height, 1.5))*var(--wy-size, 1rem));z-index:2}[part~=wy-embed-provider]{color:var(--wy-outline, var(--wy-outline-light, #72777f));text-transform:uppercase;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));margin-bottom:calc(.25*var(--wy-size, 1rem))}[part~=wy-embed-provider]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-embed-actions]{display:flex;justify-content:space-between}[part~=wy-embed-select]{display:flex;flex-direction:column;min-height:0;--wy-component-max-size: calc(12 * var(--wy-size, 1rem));--wy-component-background-color: transparent}[part~=wy-embed-select] wy-embed{border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));--wy-component-border-top-radius: 0;min-height:0;display:none}[part~=wy-embed-select] wy-embed:first-of-type{display:block}`;
var wx = Object.defineProperty, fx = Object.getOwnPropertyDescriptor, dd = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? fx(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && wx(t, e, s), s;
}, "__decorateClass$_"), Ya;
let Pc = (Ya = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.disabled = !1, this.embedContentRef = et();
  }
  /**
   * Dispatch a wy-action event for this embed.
   *
   * @internal
   * @param {ActionType | string} [action=""] - Action to dispatch.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchActionEvent(t = ge.Default) {
    const e = new CustomEvent("wy-action", {
      detail: {
        action: t,
        embed: this.embed
      },
      bubbles: !0,
      composed: !0,
      cancelable: !0
    });
    return this.dispatchEvent(e);
  }
  render() {
    const t = this.embed.actions ? [...this.embed.actions] : [], e = t.shift(), r = t.length === 1 ? t.shift() : void 0, s = !!((this.embed.type === "photo" || this.embed.type === "link") && (this.embed.title || this.embed.description || this.embed.type === "photo" && this.embed.provider_name));
    return h`
      <slot name="before"></slot>
      <div
        part="wy-embed ${K({
      "wy-embed-interactive": !!this.embed.url,
      "wy-disabled": this.disabled
    })}"
        title=${this.embed.url ? this.embed.url : this.embed.title || ""}
        @click=${() => this.embed.url && this.dispatchActionEvent(ge.Default) && Wi(this.embed.url, "_blank")}
        @keydown=${le}
        @keyup=${Me}
      >
        ${(this.embed.type === "video" || this.embed.type === "rich") && this.embed.html ? h`
              <div part="wy-embed-area">
                <div
                  ${j(this.embedContentRef)}
                  part=${K({
      "wy-embed-content": !0,
      "wy-embed-video": this.embed.type === "video",
      "wy-embed-rich": this.embed.type === "rich"
    })}
                  data-width=${nt(this.embed.width)}
                  data-height=${nt(this.embed.height)}
                >
                  ${bs(this.embed.html)}
                </div>
              </div>
            ` : v}
        ${this.embed.type === "photo" && this.embed.image && this.embed.thumbnail_url ? h`
              <div
                part="wy-embed-photo wy-embed-area ${K({
      "wy-embed-photo-with-description": s
    })}"
                style="background-image: linear-gradient(var(--wy-shade-invert, rgba(255,255,255,0.15))), url(${this.embed.thumbnail_url}), linear-gradient(var(--wy-shade-opaque, white));"
              >
                <img
                  part="wy-embed-image"
                  src=${this.embed.thumbnail_url}
                  alt=${this.embed.provider_name || this.embed.title || ""}
                  width=${nt(this.embed.image.width)}
                  height=${nt(this.embed.image.height)}
                />
              </div>
            ` : v}
        ${s ? h`
              <wy-item size="auto">
                ${this.embed.type === "link" && this.embed.image && this.embed.thumbnail_url ? h`
                      <img
                        part="wy-embed-icon"
                        slot="image"
                        src=${this.embed.thumbnail_url}
                        alt=${this.embed.provider_name || this.embed.title || ""}
                        width=${nt(this.embed.image.width)}
                        height=${nt(this.embed.image.height)}
                      />
                    ` : v}
                ${this.embed.provider_name ? h`<span slot="meta" part="wy-embed-provider">${this.embed.provider_name}</span>` : v}
                ${this.embed.title ? h`<span slot="title">${this.embed.title}</span>` : v}
                ${this.embed.description ? h`<span slot="text">${this.embed.description}</span>` : v}
                ${r ? h`
                      <wy-button
                        slot="actions"
                        color="variant"
                        @click=${(n) => {
      n.stopPropagation(), this.dispatchActionEvent(r);
    }}
                      >
                        ${r}
                      </wy-button>
                    ` : v}
                ${e ? h`
                      <wy-button
                        slot="actions"
                        color="primary"
                        @click=${(n) => {
      n.stopPropagation(), this.dispatchActionEvent(e);
    }}
                      >
                        ${e}
                      </wy-button>
                    ` : v}
                ${t.length ? h`
                      <wy-dropdown slot="actions">
                        ${t.map(
      (n) => h`
                              <wy-dropdown-item
                                @click=${(o) => {
        o.preventDefault(), o.stopPropagation(), this.dispatchActionEvent(n);
      }}
                              >
                                ${n}
                              </wy-dropdown-item>
                            `
    )}
                      </wy-dropdown>
                    ` : v}
              </wy-item>
            ` : v}
      </div>
    `;
  }
  updated(t) {
    if (this.embedContentRef.value) {
      const e = this.embedContentRef.value.firstElementChild, { width: r, height: s } = this.embedContentRef.value.dataset, n = Number(s ?? ""), o = n > 128 && n < 256 ? n : 128;
      r && s && (e.style.aspectRatio = `${r} / ${s}`, e.style.minHeight = `${o}px`);
    }
  }
}, a(Ya, "WyEmbed"), Ya);
Pc.styles = [Z, fv];
dd([
  p({ attribute: !1 })
], Pc.prototype, "embed", 2);
dd([
  p({ type: Boolean, reflect: !0 })
], Pc.prototype, "disabled", 2);
Pc = dd([
  H("wy-embed")
], Pc);
var Xa;
let kl = (Xa = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this);
  }
  /**
   * Dispatch a local embed-remove event for the embed with the given id.
  *
   * @internal
   * @param id - Embed id to remove.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchRemove(t) {
    const e = new CustomEvent("embed-remove", {
      detail: { id: t },
      bubbles: !1,
      composed: !1
    });
    return this.dispatchEvent(e);
  }
  /**
   * Dispatch a local embed-swap event to request rotating/swapping embeds.
  *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSwap() {
    const t = new CustomEvent("embed-swap", {
      detail: {},
      bubbles: !1,
      composed: !1
    });
    return this.dispatchEvent(t);
  }
  render() {
    return h`
      <div part="wy-embed-select">
        ${Fe(
      this.embeds,
      (t) => t.id,
      (t) => h`
            <wy-embed disabled .embed=${t}>
              <div part="wy-embed-actions" slot="before">
                ${this.embeds.length > 1 ? h`
                      <wy-button kind="icon" @click=${() => this.dispatchSwap()}>
                        <wy-icon name="swap-horizontal"></wy-icon>
                      </wy-button>
                    ` : h`<span></span>`}

                <wy-button kind="icon" @click=${() => this.dispatchRemove(t.id)}
                  ><wy-icon name="close-circle"></wy-icon
                ></wy-button>
              </div>
            </wy-embed>
          `
    )}
      </div>
    `;
  }
}, a(Xa, "WyEmbedSelect"), Xa);
kl.styles = [Z, fv];
dd([
  p({ attribute: !1 })
], kl.prototype, "embeds", 2);
kl = dd([
  H("wy-embed-select")
], kl);
function Ru(i) {
  switch (i) {
    case "zoom":
      return "zoom-meetings";
    case "microsoft":
      return "microsoft-teams";
    case "google":
      return "google-meet";
  }
}
a(Ru, "getMeetingIconName");
function Eu(i) {
  switch (i) {
    case "zoom":
      return b("Zoom meeting");
    case "microsoft":
      return b("Teams meeting");
    case "google":
      return b("Google Meet");
  }
}
a(Eu, "getMeetingTitle");
var mx = Object.defineProperty, vx = Object.getOwnPropertyDescriptor, mv = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? vx(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && mx(t, e, s), s;
}, "__decorateClass$Z"), Ja;
let _l = (Ja = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this);
  }
  render() {
    const t = ((/* @__PURE__ */ new Date()).getTime() - new Date(this.meeting.created_at).getTime()) / 36e5 > 2;
    return h`
      <wy-item-list rounded filled>
        ${t ? h`
              <wy-item part="wy-meeting" size="lg" disabled title="${b("Meeting ended")}">
                <wy-icon slot="image" svg="${Ru(this.meeting.provider)}" size="48"></wy-icon>
                <span slot="title">${Eu(this.meeting.provider)}</span>
                <span slot="text">${this.meeting.code}</span>
              </wy-item>
            ` : h`
              <wy-item
                interactive
                size="lg"
                part="wy-meeting"
                @click=${(e) => {
      e.preventDefault(), Wi(this.meeting.join_url, "_blank");
    }}
                url=${nt(this.meeting.join_url)}
                title="${b("Join meeting")}"
              >
                <wy-icon
                  slot="image"
                  svg="${Ru(this.meeting.provider)}"
                  size="48"
                  color="native"
                ></wy-icon>
                <span slot="title">${Eu(this.meeting.provider)}</span>
                <span slot="text">${this.meeting.code}</span>
              </wy-item>
            `}
        </wy-item-list>
    `;
  }
}, a(Ja, "WyMeetingCard"), Ja);
_l.styles = [Z];
mv([
  p({ attribute: !1 })
], _l.prototype, "meeting", 2);
_l = mv([
  H("wy-meeting-card"),
  ot()
], _l);
const vy = B`[part~=wy-poll]{min-width:0;display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));box-sizing:border-box;width:100%}[part~=wy-poll-form]{display:flex;flex-direction:column;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-poll-form]:empty{display:none}[part~=wy-poll-option]{--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));display:flex;align-items:center;clip-path:border-box;overflow:hidden;position:relative;background-color:var(--wy-surface-layer-lowest, var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078)));border:var(--wy-border-outline, 0) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));cursor:pointer;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-poll-option]>:not([part~=wy-poll-meter]){z-index:1}[part=wy-poll-image]{display:flex;height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);padding:0;line-height:1;align-items:center;justify-content:center}[part~=wy-poll-title]{width:100%;min-width:0;min-height:100%;color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset));align-content:center}[part~=wy-poll-title]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-poll-amount]{min-width:3em;text-align:end}[part~=wy-poll-meter]{position:absolute;top:0;left:0;bottom:0;background-color:var(--wy-surface-layer-highest, var(--wy-surface-layer-highest-light, rgba(0, 0, 0, .1019607843)))}`, gx = B`[part~=wy-dialog]{background:none;border:none;padding:0;margin:0;width:100%;height:100%;max-width:100%;max-height:100%;container-type:inline-size;pointer-events:none}[part~=wy-dialog][popover]{position:fixed;inset:0;z-index:1055}[part~=wy-dialog-modal]{align-items:center;justify-content:center;overflow:visible}[part~=wy-dialog-modal][open]{display:flex}[part~=wy-dialog-modal]:popover-open{display:flex}[part~=wy-dialog-modal]:focus-visible{outline:none}[part~=wy-overlay]{--wy-component-background-color: var(--wy-background, var(--wy-background-light, #f7f9ff));--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;overflow:hidden;container-type:inline-size}[part~=wy-overlay]{interpolate-size:allow-keywords;transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) .01s,visibility .01s step-end var(--wy-transition-duration-fast, .1s)}[part~=wy-overlay]:not([part~=wy-open]){opacity:0;visibility:hidden}[part~=wy-overlay][part~=wy-open]{transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),visibility var(--wy-transition-duration, .2s) step-start,top var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),right var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),bottom var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),left var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));visibility:visible;opacity:1;transform:none;pointer-events:auto}@starting-style{[part~=wy-overlay][part~=wy-open]{opacity:0;visibility:hidden}}`, bx = B`[part~=wy-modal]{width:100%;height:100%;border-radius:0}@container (inline-size >= 768px){[part~=wy-modal-centered]{border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level4, 0 calc(1 * var(--wy-size, 1rem)) calc(2.25 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .14), 0 calc(.375 * var(--wy-size, 1rem)) calc(1.875 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .12), 0 calc(.5 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) calc(-.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));margin-left:calc(4*var(--wy-size, 1rem));margin-top:auto;margin-right:calc(4*var(--wy-size, 1rem));margin-bottom:auto;width:calc(32*var(--wy-size, 1rem));max-height:calc(32*var(--wy-size, 1rem))}}@container (inline-size >= 768px){[part~=wy-modal-centered][part~=wy-maximized]{margin:0;width:100%;height:100%;max-width:calc(100% - 2*var(--wy-size, 1rem));max-height:calc(100% - 2*var(--wy-size, 1rem))}}`, xx = B`[part~=wy-sheet]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));position:fixed;z-index:1055;bottom:calc(.5*var(--wy-size, 1rem));left:calc(.5*var(--wy-size, 1rem));right:calc(.5*var(--wy-size, 1rem));max-height:max(50vh,50%);min-height:calc(3*var(--wy-size, 1rem));margin:calc(.5*var(--wy-size, 1rem)) auto;max-width:calc(32*var(--wy-size, 1rem));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12))}[part~=wy-sheet]:not([part~=wy-open]){transform:translateY(calc(32 * var(--wy-size, 1rem)))}@starting-style{[part~=wy-sheet][part~=wy-open]{transform:translateY(calc(32 * var(--wy-size, 1rem)))}}`, $x = B`[part~=wy-drawer]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));position:fixed;z-index:1055;box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));inset:0;border-radius:0}@container (inline-size >= 768px){[part~=wy-drawer]{top:var(--wy-padding-outer, 0px);right:var(--wy-padding-outer, 0px);bottom:var(--wy-padding-outer, 0px);left:auto;width:calc(24*var(--wy-size, 1rem));min-width:calc(24*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-outer, 0px)}}@container (inline-size >= 768px){[part~=wy-drawer][part~=wy-maximized]{width:calc(100% - 2*var(--wy-padding-outer, 0px))}}[part~=wy-drawer]:not([part~=wy-open]){transform:translate(calc(100% + var(--wy-padding-outer, 0px)))}@starting-style{[part~=wy-drawer][part~=wy-open]{transform:translate(calc(100% + var(--wy-padding-outer, 0px)))}}`, gy = B`[part~=wy-header]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));background-color:var(--wy-component-background-color);box-sizing:border-box}@supports (position: sticky){[part~=wy-header]{position:sticky;top:0;z-index:1020}}[part~=wy-header]{z-index:1022}[part~=wy-header-floating]{--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-component-border-radius)}[part~=wy-header-outer]{--wy-component-border-radius: var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));border-radius:var(--wy-component-border-radius)}`, vv = B`[part~=wy-titlebar]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));box-sizing:border-box;display:grid;align-items:center;justify-content:space-between;justify-items:center;min-height:var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));padding:calc(var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));flex:0 0 var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));grid-template-columns:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) minmax(0,max-content) var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));column-gap:calc(2*var(--wy-gap, calc(.5 * var(--wy-size, 1rem))) + var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));line-height:var(--wy-line-height, 1.5);color:var(--wy-component-color)}[part~=wy-titlebar-buttons],[part~=wy-titlebar-section]{display:flex;flex:0 0 auto;align-items:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));max-width:100%;box-shadow:var(--wy-component-box-shadow);border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem))));background-color:var(--wy-component-background-color)}[part~=wy-titlebar-lg]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));height:auto}[part~=wy-titlebar-buttons-first]{justify-content:flex-start}[part~=wy-titlebar-buttons-last]{justify-content:flex-end}[part~=wy-titlebar-text]{max-width:100%;display:block;color:inherit!important;-webkit-user-select:none;user-select:none;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-titlebar-text]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-titlebar-text-trashed]{text-decoration:line-through}`;
var Cx = Object.defineProperty, kx = Object.getOwnPropertyDescriptor, Nr = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? kx(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && Cx(t, e, s), s;
}, "__decorateClass$Y"), to;
let Yi = (to = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.header = !1, this.floating = !1, this.outer = !1, this.trashed = !1, this.size = "md";
  }
  /**
   * render function for the inner titlebar.
   * @internal
   * @returns
   */
  renderTitlebar() {
    return h`
      <nav part="wy-titlebar ${K({ "wy-titlebar-lg": this.size === "lg" })}">
        <slot name="first">
          <div part="wy-titlebar-icon wy-titlebar-buttons wy-titlebar-buttons-first">
            <slot name="icon"></slot>
          </div>
        </slot>
        <slot name="middle">
          <div part="wy-titlebar-title wy-titlebar-section">
            <slot name="title-section">
              <wy-titlebar-text ?trashed=${this.trashed}><slot name="title"></slot></wy-titlebar-text>
            </slot>
          </div>
        </slot>
        <slot name="last">
          <div part="wy-titlebar-actions wy-titlebar-buttons wy-titlebar-buttons-last">
            <slot name="actions"></slot>
          </div>
        </slot>
      </nav>
    `;
  }
  render() {
    return this.header ? h`<header part="wy-header ${K({ "wy-header-floating": this.floating, "wy-header-outer": this.outer })}"
          >${this.renderTitlebar()}</header
        >` : this.renderTitlebar();
  }
}, a(to, "WyTitlebar"), to);
Yi.styles = [gy, vv, Z];
Nr([
  p({ type: Boolean })
], Yi.prototype, "header", 2);
Nr([
  p({ type: Boolean })
], Yi.prototype, "floating", 2);
Nr([
  p({ type: Boolean })
], Yi.prototype, "outer", 2);
Nr([
  p({ type: Boolean })
], Yi.prototype, "trashed", 2);
Nr([
  p()
], Yi.prototype, "size", 2);
Yi = Nr([
  H("wy-titlebar")
], Yi);
var eo;
let Pl = (eo = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.trashed = !1;
  }
  render() {
    const t = {
      "wy-titlebar-text-trashed": this.trashed
    };
    return h` <slot part="wy-titlebar-text ${K(t)}"></slot> `;
  }
}, a(eo, "WyTitlebarText"), eo);
Pl.styles = [vv, Z];
Nr([
  p({ type: Boolean })
], Pl.prototype, "trashed", 2);
Pl = Nr([
  H("wy-titlebar-text")
], Pl);
var _x = Object.defineProperty, Px = Object.getOwnPropertyDescriptor, hd = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? Px(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && _x(t, e, s), s;
}, "__decorateClass$X"), io;
let Or = (io = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.viewportRef = et(), this.show = !0, this.type = "modal", this.maximized = !1, this.noHeader = !1, this.handleClose = (t) => {
      if (this.isModal() || t?.type === "toggle" && t.newState === "closed" || t?.type === "close") {
        this.show = !1;
        const e = new CustomEvent("close");
        this.dispatchEvent(e);
      }
    };
  }
  /**
   * Close the modal.
   */
  close() {
    this.show = !1;
    try {
      this.type !== "modal" && this.viewportRef.value?.popover ? this.viewportRef.value?.hidePopover() : this.viewportRef.value?.close();
    } catch {
    }
  }
  /**
   * Checks whether the overlay is using the modal api.
   *
   * @param [type] - Optional type to check
   * @returns Whether the overlay is using the modal api.
   */
  isModal(t) {
    return t ??= this.type, t === "modal" || t === "full";
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("type") && this.viewportRef.value) {
      const e = !this.isModal(t.get("type")) && this.viewportRef.value.popover ? "toggle" : "close";
      this.viewportRef.value.removeEventListener(e, this.handleClose);
    }
  }
  render() {
    if (this.type === "none")
      return v;
    const t = {
      "wy-dialog": !0,
      "wy-dialog-modal": this.isModal()
    }, e = {
      "wy-overlay": !0,
      "wy-modal": this.isModal(),
      // modal, full
      "wy-modal-centered": this.type === "modal",
      "wy-sheet": this.type === "sheet",
      "wy-drawer": this.type === "drawer",
      "wy-maximized": this.maximized,
      "wy-open": this.show
    }, r = this.isModal() ? void 0 : "auto";
    return h`
      <dialog
        part=${K(t)}
        tabindex="0"
        popover=${nt(r)}
        ${j(this.viewportRef)}
      >
        <div part=${K(e)}>
          ${this.noHeader ? v : h`
                <slot name="header">
                  <wy-titlebar part="wy-overlay-titlebar" header>
                    <wy-button slot="icon" kind="icon" @click=${() => this.close()}>
                      <wy-icon name="close"></wy-icon>
                    </wy-button>
                    <slot slot="title" name="title"></slot>
                    <slot slot="actions" name="actions"></slot>
                  </wy-titlebar>
                </slot>
              `}
          <slot></slot>
        </div>
      </dialog>
    `;
  }
  updated(t) {
    if (t.has("type")) {
      const e = !this.isModal() && this.viewportRef.value?.popover ? "toggle" : "close";
      this.viewportRef.value?.addEventListener(e, this.handleClose), this.show && (!this.isModal(t.get("type")) && this.viewportRef.value?.popover ? this.viewportRef.value?.hidePopover() : this.viewportRef.value?.close(), this.requestUpdate("show"));
    }
    if (t.has("show"))
      try {
        this.show ? this.isModal() ? this.viewportRef.value?.showModal() : this.viewportRef.value?.popover ? this.viewportRef.value?.showPopover() : this.viewportRef.value?.show() : !this.isModal() && this.viewportRef.value?.popover ? this.viewportRef.value?.hidePopover() : this.viewportRef.value?.close();
      } catch {
      }
    t.has("show") && this.show && this.viewportRef.value?.focus();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.close();
  }
}, a(io, "WyOverlay"), io);
Or.styles = [Yt, Z, gx, bx, xx, $x];
hd([
  p({ type: Boolean, reflect: !0 })
], Or.prototype, "show", 2);
hd([
  p({ type: String })
], Or.prototype, "type", 2);
hd([
  p({ type: Boolean })
], Or.prototype, "maximized", 2);
hd([
  p({ type: Boolean })
], Or.prototype, "noHeader", 2);
Or = hd([
  H("wy-overlay")
], Or);
const Mx = B`[part~=wy-container]{display:flex;flex-direction:column;position:relative;min-height:0;height:100%;flex:1 1 auto}[part~=wy-container-padded]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));gap:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-container-outer]{padding:var(--wy-padding-outer, var(--wy-padding, 0))}`, Ns = B`[part~=wy-scroll-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x-y]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;overflow-x:auto;touch-action:pan-y,pan-x}[part~=wy-scroll-x-always],[part~=wy-scroll-y-always]{overflow-y:scroll}`;
var Sx = Object.defineProperty, Ax = Object.getOwnPropertyDescriptor, qc = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? Ax(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && Sx(t, e, s), s;
}, "__decorateClass$W"), ro;
let Xi = (ro = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.scrollX = !1, this.scrollY = !1, this.padded = !1, this.outer = !1, this.scrollbars = !1;
  }
  render() {
    const t = {
      "wy-container": !0,
      "wy-container-padded": this.padded,
      "wy-container-outer": this.outer,
      "wy-scroll-x": this.scrollX && !this.scrollY,
      "wy-scroll-y": this.scrollY && !this.scrollX,
      "wy-scroll-x-y": this.scrollX && this.scrollY,
      "wy-scroll-x-always": this.scrollbars && this.scrollX,
      "wy-scroll-y-always": this.scrollbars && this.scrollY
    };
    return h`
      <div part=${K(t)}>
        <slot></slot>
      </div>
    `;
  }
}, a(ro, "WyContainer"), ro);
Xi.styles = [Ns, Z, Mx];
qc([
  p({ type: Boolean })
], Xi.prototype, "scrollX", 2);
qc([
  p({ type: Boolean })
], Xi.prototype, "scrollY", 2);
qc([
  p({ type: Boolean })
], Xi.prototype, "padded", 2);
qc([
  p({ type: Boolean })
], Xi.prototype, "outer", 2);
qc([
  p({ type: Boolean })
], Xi.prototype, "scrollbars", 2);
Xi = qc([
  H("wy-container")
], Xi);
var zx = Object.defineProperty, Rx = Object.getOwnPropertyDescriptor, Nc = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? Rx(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && zx(t, e, s), s;
}, "__decorateClass$V"), so;
let Ml = (so = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.pollOptions = [];
  }
  /**
   * Dispatch a `vote` event for the specified option.
   *
   * @param optionId - Identifier of the option to vote for.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  render() {
    const t = this.pollOptions.reduce((e, r) => e + (r.votes?.count || 0), 0);
    return h`
      <div part="wy-poll">
        ${this.pollOptions.map(
      (e) => h`<wy-poll-option
              @vote=${(r) => this.dispatchVote(r.detail.optionId)}
              .option=${e}
              .totalVotes=${t}
            ></wy-poll-option>`
    )}
      </div>
    `;
  }
}, a(so, "WyPoll"), so);
Ml.styles = [
  vy,
  Z
];
Nc([
  p({ type: Array, attribute: !1 })
], Ml.prototype, "pollOptions", 2);
Ml = Nc([
  H("wy-poll")
], Ml);
var no;
let Ps = (no = class extends $e {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.totalVotes = 0, this.showSheet = !1, this.getVotesQuery = new Ie(this);
  }
  async updated(t) {
    t.has("weavy") && this.weavy && this.option && this.option.id && await this.getVotesQuery.trackQuery(X0(this.weavy, this.option.id));
  }
  /**
   * Dispatch a `vote` event for the provided option id.
   *
   * @internal
   * @param optionId - Identifier of the option to vote for.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    if (!t)
      return;
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Toggle the voter sheet and refresh vote data.
   *
   * @internal
   * @param e - Triggering user event.
   */
  openSheet(t) {
    t.preventDefault(), t.stopPropagation(), this.getVotesQuery.observer?.refetch(), this.showSheet = !this.showSheet;
  }
  render() {
    if (!this.option || !this.option.id)
      return v;
    const { data: t, isLoading: e } = this.getVotesQuery.result ?? {}, r = this.totalVotes > 0 ? Math.round((this.option.votes?.count || 0) / this.totalVotes * 100) : 0;
    return h`
      <div
        part="wy-poll-option"
        tabindex="0"
        @click=${() => this.dispatchVote(this.option?.id)}
        @keydown=${le}
        @keyup=${Me}
      >
        <div part="wy-poll-meter" style="width: ${r + "%"}"></div>
        <div part="wy-poll-image">
          ${this.option.has_voted ? h`<wy-icon name="check-circle"></wy-icon>` : h`<wy-icon name="circle-outline"></wy-icon>`}
        </div>
        <div part="wy-poll-title">${this.option.text}</div>
        ${r > 0 ? h`<span
              part="wy-poll-amount"
              tabindex="0"
              @click=${(s) => this.openSheet(s)}
              @keydown=${le}
              @keyup=${Me}
            >
              ${r + "%"}
            </span>` : h`<span part="wy-poll-amount"></span>`}
      </div>

      ${this.weavy ? h`
            <wy-overlay type="sheet" .show=${this.showSheet} @close=${() => this.showSheet = !1}>
              <span slot="title">${b(ut`Votes on ${this.option.text}`)}</span>
              <wy-container scrollY padded>
                ${this.showSheet && t && !e ? h`
                      ${t.votes?.data ? t.votes.data.map(
      (s) => h`
                              <wy-item>
                                <wy-avatar
                                  slot="image"
                                  .size=${32}
                                  .src=${s.avatar_url}
                                  .name=${s.name}
                                ></wy-avatar>
                                <span slot="title">${s.name}</span>
                              </wy-item>
                            `
    ) : v}
                    ` : v}
              </wy-container>
            </wy-overlay>
          ` : v}
    `;
  }
}, a(no, "WyPollOption"), no);
Ps.styles = [vy, Z];
Nc([
  p({ type: Number, attribute: !1 })
], Ps.prototype, "totalVotes", 2);
Nc([
  p({ attribute: !1 })
], Ps.prototype, "option", 2);
Nc([
  F()
], Ps.prototype, "showSheet", 2);
Ps = Nc([
  H("wy-poll-option"),
  ot()
], Ps);
function Ex(i, t, e, r, s, n, o) {
  return new $t(i.queryClient, {
    mutationFn: /* @__PURE__ */ a(async () => await i.fetch(`/api/${s}/${r}/reactions`, {
      method: n ? "POST" : "DELETE",
      body: JSON.stringify({ content: n })
    }), "mutationFn"),
    onMutate: /* @__PURE__ */ a(() => {
      const c = e === "apps" && s === "posts" ? [s, t] : [e, t, s];
      qt(i.queryClient, c, r, (l) => {
        Sl(l, n, o);
      });
    }, "onMutate")
  });
}
a(Ex, "reactionMutation");
function Lx(i, t, e) {
  return {
    queryKey: [t, e, "reactions"],
    enabled: !1,
    queryFn: /* @__PURE__ */ a(async () => await (await i.fetch("/api/" + t + "/" + e + "/reactions")).json(), "queryFn")
  };
}
a(Lx, "getReactionListOptions");
function Sl(i, t, e) {
  return !t && !i.reactions?.data || (i.reactions || (i.reactions = { count: 0, data: [] }), i.reactions.data || (i.reactions.data = []), t ? i.reactions.data = [
    ...i.reactions.data.filter((r) => r.created_by?.id !== e.id),
    { content: t, created_by: e }
  ] : i.reactions.data && (i.reactions.data = [...i.reactions.data.filter((r) => r.created_by?.id !== e.id)])), i;
}
a(Sl, "updateReaction");
const Ox = B`[part~=wy-reaction]{font-size:calc(1.125*var(--wy-size, 1rem))}[part~=wy-reactions]{display:inline-flex;align-items:center;column-gap:calc(.25*var(--wy-size, 1rem))}[part~=wy-reactions] :first-child:not(:only-child){margin-left:calc(.25*var(--wy-size, 1rem))}[part~=wy-reactions] :last-child:not(:only-child){margin-right:calc(.25*var(--wy-size, 1rem))}[part~=wy-reaction-count]{margin:0 calc(.25*var(--wy-size, 1rem)) 0;line-height:1;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-reaction-menu]{width:max-content;position:absolute;z-index:1000;border:none;--wy-component-background-color: var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;margin:0;text-align:left;background-clip:padding-box;box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));overflow:hidden;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));font-size:calc(1.25*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))))}[part~=wy-reaction-picker]{display:flex;flex-direction:row;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-reactions-line]{display:flex;align-items:center;gap:calc(.1875*var(--wy-size, 1rem));justify-content:end}[part~=wy-reactions-line-reverse]{flex-direction:row-reverse;justify-content:start}[part~=wy-reactions-line-bottom]{position:absolute;bottom:calc(-1*var(--wy-size, 1rem));right:calc(.25*var(--wy-size, 1rem));z-index:1}[part~=wy-reactions-line-below]{position:relative;height:0;min-height:0;max-height:0;margin:calc(var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) - var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(-1*var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))) calc(-1*var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));padding-left:calc(.1875*var(--wy-size, 1rem));padding-right:calc(.1875*var(--wy-size, 1rem));gap:calc(.125*var(--wy-size, 1rem));flex:1 0 auto;justify-content:flex-end}`, gv = B`[part~=wy-emoji-icon]{display:inline-flex;justify-content:center;align-items:center;line-height:1;width:1em;height:1em;font-size:calc(1.25*var(--wy-size, 1rem))}[part~=wy-emoji-icon-sm]{width:calc(1.125*var(--wy-size, 1rem));height:calc(1.125*var(--wy-size, 1rem));font-size:calc(1.125*var(--wy-size, 1rem))}`;
var Ix = Object.defineProperty, Tx = Object.getOwnPropertyDescriptor, Xt = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? Tx(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && Ix(t, e, s), s;
}, "__decorateClass$U"), ao;
let jt = (ao = class extends Rt {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.directionX = "left", this.directionY = "up", this.small = !1, this.reactions = [], this.emojis = "", this.parentType = "apps", this.entityType = "messages", this.line = !1, this.lineReverse = !1, this.lineBottom = !1, this.lineBelow = !1, this._placement = "bottom-start", this.show = !1, this.showSheet = !1, this.buttonRef = et(), this.menuRef = et(), this.reactionListQuery = new Ie(this), this._documentClickHandler = (t) => {
      this.show && (t.preventDefault(), this.menuRef.value?.popover || (this.show = !1));
    }, this.handleReaction = async (t) => {
      if (!this.weavy || !this.parentId || !this.user)
        return;
      const e = Ex(
        this.weavy,
        this.parentId,
        this.parentType,
        this.entityId,
        this.entityType,
        this.reactedEmoji === t ? void 0 : t,
        this.user
      );
      this.reactedEmoji = t, await e.mutate(), this.reactionListQuery.observer?.refetch();
    };
  }
  /**
   * Closes the picker when the popover hides.
   *
   * @internal
   */
  handleClose(t) {
    if (t.type === "toggle" && t.newState === "closed" || t.type === "click") {
      this.show = !1;
      const e = new CustomEvent("close");
      this.dispatchEvent(e);
    }
  }
  /**
   * Toggles the emoji picker visibility.
   *
   * @internal
   */
  handleClickToggle(t) {
    t.stopPropagation(), this.show = !this.show;
  }
  /**
   * Opens the detailed reaction sheet view.
   *
   * @internal
   */
  handleReactionsClick() {
    this.reactionListQuery.observer?.refetch(), this.showSheet = !this.showSheet, this.show = !1;
  }
  async willUpdate(t) {
    if (super.willUpdate(t), (t.has("weavy") || t.has("entityId") || t.has("showSheet")) && this.weavy && this.entityId && this.showSheet && await this.reactionListQuery.trackQuery(Lx(this.weavy, this.entityType, this.entityId)), (t.has("reactions") || t.has("user")) && this.user && (this.reactedEmoji = this.reactions?.find((e) => e.created_by?.id === this.user?.id)?.content), (t.has("directionX") || t.has("directionY")) && (this._placement = this.directionX === "right" && this.directionY === "down" ? "bottom-start" : this.directionX === "left" && this.directionY === "down" ? "bottom-end" : this.directionX === "right" && this.directionY === "up" ? "top-start" : "top-end"), t.has("show") && (this.show && !this._computePositionCleanup && this.buttonRef.value && this.menuRef.value ? this._computePositionCleanup = rv(this.buttonRef.value, this.menuRef.value, () => {
      requestAnimationFrame(() => {
        this.buttonRef.value && this.menuRef.value && ov(this.buttonRef.value, this.menuRef.value, {
          placement: this._placement,
          strategy: this.menuRef.value.popover ? "absolute" : "fixed",
          middleware: [
            av(),
            sv({ mainAxis: 0, alignmentAxis: -8 }),
            nv({ mainAxis: !0, crossAxis: !0, padding: 4, altBoundary: !0 })
          ]
        }).then(({ x: e, y: r }) => {
          this.menuRef.value && Object.assign(this.menuRef.value.style, {
            marginLeft: `${e}px`,
            marginTop: `${r}px`,
            top: 0,
            left: 0,
            position: this.menuRef.value.popover ? void 0 : "fixed",
            zIndex: this.menuRef.value.popover ? void 0 : 1075
          });
        });
      });
    }) : !this.show && this._computePositionCleanup && (this._computePositionCleanup(), this._computePositionCleanup = void 0)), this.show) {
      requestAnimationFrame(() => {
        document.addEventListener("click", this._documentClickHandler, { once: !0, capture: !0 });
      });
      try {
        this.menuRef.value?.showPopover();
      } catch {
      }
    } else
      try {
        this.menuRef.value?.hidePopover();
      } catch {
      }
    t.has("settings") && this.settings?.reactions && this.emojis != this.settings.reactions && (this.emojis = this.settings.reactions);
  }
  render() {
    const { data: t, isPending: e } = this.reactionListQuery.result ?? {};
    if (!this.emojis?.length)
      return v;
    const r = this.emojis?.length === 1 ? this.emojis[0] : "", s = [
      ...new Map(this.reactions?.map((u) => [u.content, u])).values()
    ], n = {
      "wy-emoji-icon": !0,
      "wy-emoji-icon-sm": this.small
    }, o = r ? h`
          ${this.reactions && this.reactions?.length > 1 ? h`<wy-button
                kind="icon-inline"
                ?active=${this.showSheet}
                ?small=${this.small}
                @click=${() => this.handleReactionsClick()}
              >
                <div part="wy-reactions">
                  <span part=${K(n)}>
                    <small part="wy-reaction-count">${this.reactions.length}</small>
                  </span>
                </div>
              </wy-button>` : v}

          <div>
            <wy-button
              part="wy-reaction-menu-button"
              color="inherit"
              kind="icon"
              ?small=${this.small}
              ?active=${this.reactedEmoji === r}
              @click=${() => {
      this.handleReaction(r);
    }}
              @keydown=${le}
              @keyup=${Me}
              title=${b("React", { desc: "Button action to react" })}
            >
              <span part=${K(n)} title=${r}>${r}</span>
            </wy-button>
          </div>
        ` : h`
          ${s.length ? h`
                <wy-button
                  kind="icon-inline"
                  ?active=${this.showSheet}
                  ?small=${this.small}
                  @click=${() => this.handleReactionsClick()}
                >
                  <div part="wy-reactions">
                    ${s.map((u) => h`<span part=${K(n)} title="">${u.content}</span>`)}
                    ${this.reactions && this.reactions?.length > 1 ? h`<small part="wy-reaction-count">${this.reactions.length}</small>` : v}
                  </div>
                </wy-button>
              ` : v}

          <div ${j(this.buttonRef)}>
            <wy-button
              part="wy-reaction-menu-button"
              color="inherit"
              kind="icon"
              ?active=${this.show}
              ?small=${this.small}
              @click=${(u) => this.handleClickToggle(u)}
              @keydown=${le}
              @keyup=${Me}
              title=${b("React", { desc: "Button action to react" })}
            >
              <wy-icon name="emoticon" size=${this.small ? 20 : 24}></wy-icon>
            </wy-button>
          </div>

          <div
            ${j(this.menuRef)}
            part="wy-reaction-menu"
            @click=${(u) => this.handleClickToggle(u)}
            @keyup=${ny}
            ?hidden=${!this.show}
            popover=${nt(Up() ? void 0 : "auto")}
          >
            <div part="wy-reaction-picker">
              ${this.emojis.split(" ").map(
      (u) => h`
                    <wy-button
                      kind="icon"
                      color="none"
                      ?active=${this.reactedEmoji === u}
                      @click=${() => {
        this.handleReaction(u);
      }}
                    >
                      <span part="wy-emoji-icon">${u}</span>
                    </wy-button>
                  `
    )}
            </div>
          </div>
        `, c = h`
      ${this.weavy && this.showSheet ? h`
            <wy-overlay type="sheet" .show=${this.showSheet} @close=${() => this.showSheet = !1}>
              <span slot="title">${b("Reactions")}</span>
              <wy-container scrollY padded>
                ${this.showSheet && t && !e ? h`
                      ${t.data?.map(
      (u) => h` <wy-reaction-item .reaction=${u}></wy-reaction-item> `
    )}
                    ` : v}
              </wy-container>
            </wy-overlay>
          ` : v}
    `, l = {
      "wy-reactions-line": !0,
      "wy-reactions-line-reverse": this.lineReverse,
      "wy-reactions-line-bottom": this.lineBottom,
      "wy-reactions-line-below": this.lineBelow
    };
    return this.line || this.lineReverse || this.lineBottom || this.lineBelow ? h`
          <div part=${K(l)}>${o}</div>
          ${c}
        ` : [o, c];
  }
  firstUpdated(t) {
    this.menuRef.value?.addEventListener(
      this.menuRef.value.popover ? "toggle" : "click",
      (e) => this.handleClose(e)
    );
  }
  disconnectedCallback() {
    this._computePositionCleanup?.(), super.disconnectedCallback();
  }
}, a(ao, "WyReactions"), ao);
jt.styles = [zt, Ox, gv, Z];
Xt([
  p()
], jt.prototype, "directionX", 2);
Xt([
  p()
], jt.prototype, "directionY", 2);
Xt([
  p({ type: Boolean })
], jt.prototype, "small", 2);
Xt([
  p({ attribute: !1 })
], jt.prototype, "reactions", 2);
Xt([
  p({ attribute: !1 })
], jt.prototype, "emojis", 2);
Xt([
  p({ type: String })
], jt.prototype, "parentType", 2);
Xt([
  p({ attribute: !0, type: Number })
], jt.prototype, "parentId", 2);
Xt([
  p({ attribute: !0, type: String })
], jt.prototype, "entityType", 2);
Xt([
  p({ attribute: !0, type: Number })
], jt.prototype, "entityId", 2);
Xt([
  p({ type: Boolean })
], jt.prototype, "line", 2);
Xt([
  p({ type: Boolean })
], jt.prototype, "lineReverse", 2);
Xt([
  p({ type: Boolean })
], jt.prototype, "lineBottom", 2);
Xt([
  p({ type: Boolean })
], jt.prototype, "lineBelow", 2);
Xt([
  F()
], jt.prototype, "_placement", 2);
Xt([
  F()
], jt.prototype, "reactedEmoji", 2);
Xt([
  F()
], jt.prototype, "show", 2);
Xt([
  F()
], jt.prototype, "showSheet", 2);
jt = Xt([
  H("wy-reactions"),
  ot()
], jt);
var oo;
let Al = (oo = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this);
  }
  render() {
    return h`
      <wy-item>
        <wy-avatar
          slot="image"
          .src=${this.reaction.created_by?.avatar_url}
          .name=${this.reaction.created_by?.name}
        ></wy-avatar>
        <span slot="title">${this.reaction.created_by?.name}</span>
        <span slot="actions" part="wy-emoji-icon">${this.reaction.content}</span>
      </wy-item>
    `;
  }
}, a(oo, "WyReactionItem"), oo);
Al.styles = [zt, gv];
Xt([
  p({ attribute: !1 })
], Al.prototype, "reaction", 2);
Al = Xt([
  H("wy-reaction-item")
], Al);
const Fx = B`[part~=wy-preview]{--wy-component-background-color: var(--wy-background, var(--wy-background-light, #f7f9ff));--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;box-sizing:border-box;align-items:stretch;justify-content:stretch;position:relative;flex:1 1 100%;min-width:calc(16*var(--wy-size, 1rem));min-height:calc(16*var(--wy-size, 1rem));max-height:100%;max-width:100%}[part~=wy-preview-layout]{width:100%;height:100%}[part~=wy-preview-main]{display:flex;height:calc(100% - var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem))))));min-height:0}@container (inline-size < 768px){[part~=wy-preview-main]{flex-direction:column}}[part~=wy-preview-swiper]{display:flex;flex-direction:row;flex:1 1 100%;align-items:center;justify-content:start;min-width:calc(16*var(--wy-size, 1rem));min-height:calc(16*var(--wy-size, 1rem));max-height:100%;max-width:100%;overflow-x:scroll;scroll-snap-type:x mandatory;scroll-behavior:auto;overscroll-behavior-x:none;scrollbar-width:none}[part~=wy-preview-swiper]::-webkit-scrollbar{display:none}[part~=wy-preview-swiper-disabled]{overflow-x:hidden}[part~=wy-preview-area]{position:relative;min-width:100%;min-height:100%;width:100%;height:100%;flex:1 1 auto;display:flex;flex-direction:column;scroll-snap-stop:always;scroll-snap-align:center}[part~=wy-nav-prev],[part~=wy-nav-next]{--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));background-color:var(--wy-component-background-color);position:absolute;top:50%;z-index:1000;border-radius:50%}[part~=wy-nav-prev]{left:calc(.5*var(--wy-size, 1rem))}[part~=wy-nav-next]{right:calc(.5*var(--wy-size, 1rem))}`, Dx = B`[part~=wy-sidebar]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background:var(--wy-component-background-color);color:var(--wy-component-color);min-width:0;min-height:0;flex-grow:0;flex-shrink:0;flex-basis:calc(22*var(--wy-size, 1rem));z-index:10;display:flex;flex-direction:column;transition:flex-basis var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));position:relative;order:9999;overflow:clip}[part~=wy-sidebar]>*{transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) - var(--wy-transition-duration-fast, .1s));min-width:calc(22*var(--wy-size, 1rem))}[part~=wy-sidebar][hidden]{display:flex!important;flex-basis:0}[part~=wy-sidebar][hidden]>*{transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));opacity:0}@container (inline-size >= 768px){[part~=wy-sidebar]>*{min-width:calc(22*var(--wy-size, 1rem))}[part~=wy-sidebar] [part~=wy-sidebar-handle]{display:none}}@container (inline-size < 768px){[part~=wy-sidebar]{transition:flex-basis var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),margin-top var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));border-top-left-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-top-right-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));flex-basis:50vh}[part~=wy-sidebar]:not([hidden]){margin-top:calc(-1*var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-sidebar]:not([hidden])[part~=wy-maximized]{flex-basis:calc(100% - var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))*.5);margin-top:calc(-50% + var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))*2.5 - var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-sidebar]:not([hidden])[part~=wy-maximized]~* [part~=wy-nav-prev],[part~=wy-sidebar]:not([hidden])[part~=wy-maximized]~* [part~=wy-nav-next]{display:none}[part~=wy-sidebar]>*{min-height:var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))}}[part~=wy-sidebar-handle]{width:calc(4*var(--wy-size, 1rem));background-clip:content-box;background-color:var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));height:calc(1*var(--wy-size, 1rem));border:calc(.375*var(--wy-size, 1rem)) solid rgba(0,0,0,0);position:absolute;top:0;z-index:2;left:50%;margin-left:calc(-2*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));cursor:pointer}`;
var Hx = Object.defineProperty, Vx = Object.getOwnPropertyDescriptor, zh = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? Vx(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && Hx(t, e, s), s;
}, "__decorateClass$T"), co;
let Ms = (co = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this);
  }
  /**
   * Dispatch `file-preview-loaded` when the fallback content is ready.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  render() {
    const t = this.icon, e = nd(this.provider);
    return h`
      <wy-icon-display fill>
        <wy-icon name=${t} .overlayName=${e}></wy-icon>
        <span slot="text">
          ${this.provider ? h`
                <p>${b("No preview available :(")} </p>
                <wy-button kind="filled" color="variant" href=${this.src} target="_blank">${b(ut`Open in ${this.provider}`)}</wy-button>
              ` : h`<div>${b("No preview available :(")}</div>`}
        </span>
      </wy-icon-display>
    `;
  }
  updated(t) {
    (t.has("icon") || t.has("src")) && (this.icon || this.src) && this.dispatchLoaded();
  }
}, a(co, "WyPreviewIcon"), co);
Ms.styles = [
  Z
];
zh([
  p()
], Ms.prototype, "src", 2);
zh([
  p()
], Ms.prototype, "icon", 2);
zh([
  p()
], Ms.prototype, "provider", 2);
Ms = zh([
  H("wy-preview-icon"),
  ot()
], Ms);
const Ux = B`[part~=wy-content-image]{min-width:0;display:flex;align-items:center;justify-content:center;position:relative;margin:auto;box-sizing:border-box;max-height:100%;max-width:100%;transition:transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform-origin var(--wy-transition-duration, .2s) step-end}[part~=wy-content-image][part~=wy-zoom]{cursor:zoom-out;transition:transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform-origin var(--wy-transition-duration, .2s) step-start}[part~=wy-content-image-img]{min-width:0;min-height:0;width:100%;height:100%}[part~=wy-content-image-img][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-content-image-img][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-content-image-img][part~=wy-loading][part~=wy-loaded]~[part~=wy-content-progress]{display:none}[part~=wy-content-image-img]~[part~=wy-content-progress]{position:absolute}`;
var Bx = Object.defineProperty, qx = Object.getOwnPropertyDescriptor, Rh = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? qx(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && Bx(t, e, s), s;
}, "__decorateClass$S"), lo;
let Ss = (lo = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this);
  }
  /**
   * Dispatches the `file-preview-loaded` event once the image has loaded.
   *
   * @internal
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  render() {
    const t = !!(this.width && this.height), e = t ? { "--width": this.width, "--height": this.height } : {};
    return h`
      <div part="wy-content-image ${K({ "wy-intrinsic-image": !t })}" style=${ml(e)}>
        <img
          part="wy-content-image-img"
          src=${this.src}
          ${j(fy)}
          @load=${(r) => {
      my(r), this.dispatchLoaded();
    }}
          width=${nt(this.width)}
          height=${nt(this.height)}
          decoding="async"
          alt=${b("Preview")}
        />
        ${t ? h`<wy-progress-circular part="wy-content-progress" indeterminate overlay></wy-progress-circular>` : v}
      </div>
    `;
  }
}, a(lo, "WyPreviewImage"), lo);
Ss.styles = [Ux, Z];
Rh([
  p()
], Ss.prototype, "src", 2);
Rh([
  p({ type: Number })
], Ss.prototype, "width", 2);
Rh([
  p({ type: Number })
], Ss.prototype, "height", 2);
Ss = Rh([
  H("wy-preview-image"),
  ot()
], Ss);
function bv(i) {
  (i.classList.contains("wy-loading") || i.part.contains("wy-loading")) && (i.classList.add("wy-loaded"), i.part.add("wy-loaded")), i.classList.add("wy-error"), i.part.add("wy-error"), i.outerHTML = i.outerHTML.replace(/<(video|audio)/, "<div").replace(/(video|audio)>/, "div>");
}
a(bv, "mediaFallback");
function Nx(i) {
  const t = i.target;
  (t.tagName === "VIDEO" || t.tagName === "AUDIO") && (t.classList.contains("wy-loading") || t.part.contains("wy-loading")) && (t.classList.add("wy-loaded"), t.part.add("wy-loaded"));
}
a(Nx, "mediaLoaded");
function uf(i) {
  const t = i.target;
  if (t.tagName === "SOURCE" && t.parentNode) {
    const e = t.parentNode, r = parseInt(e.dataset.errors || "0") + 1;
    e.dataset.errors = r.toString(), e.querySelectorAll("source").length >= r && (console.warn(e.tagName.toLowerCase() + " source error, switching to fallback"), bv(e));
  }
}
a(uf, "mediaError");
function yf(i) {
  const t = i.target;
  (t.tagName === "VIDEO" || t.tagName === "AUDIO") && (t.tagName === "VIDEO" && !t.videoWidth || t.tagName === "AUDIO" && !t.duration) && (console.warn(t.tagName.toLowerCase() + " track not available, switching to fallback"), bv(t));
}
a(yf, "codecError");
const jx = B`[part~=wy-content-video]{box-sizing:border-box}[part~=wy-content-video]:not([part~=wy-error]){min-height:0;max-width:100%;max-height:100%;flex:1 1 auto}[part~=wy-content-video],[part~=wy-content-audio]{margin:auto}[part~=wy-content-video][part~=wy-loading]:not([part~=wy-loaded]),[part~=wy-content-audio][part~=wy-loading]:not([part~=wy-loaded]){visibility:hidden}[part~=wy-content-video][part~=wy-loading][part~=wy-loaded]~[part~=wy-content-progress],[part~=wy-content-audio][part~=wy-loading][part~=wy-loaded]~[part~=wy-content-progress]{display:none}[part~=wy-content-video]:focus,[part~=wy-content-audio]:focus{outline:none}`;
var Wx = Object.defineProperty, Qx = Object.getOwnPropertyDescriptor, jc = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? Qx(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && Wx(t, e, s), s;
}, "__decorateClass$R"), ho;
let Ji = (ho = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.format = "", this.play = !1, this.name = "", this.handleLoaded = (t) => {
      Nx(t), this.dispatchLoaded();
    };
  }
  /**
   * Dispatches the `file-preview-loaded` event after the media metadata becomes available.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  /**
   * Registers load and error listeners on the provided media element.
   *
   * @internal
   * @param mediaElement - Media element to observe.
   */
  registerLoading(t) {
    this.unregisterLoading(), t && (this.mediaElement = t, t.part.add("wy-loading"), t.addEventListener("error", uf, !0), t.addEventListener("loadedmetadata", this.handleLoaded, !0), t.addEventListener("loadedmetadata", yf, !0));
  }
  /**
   * Cleans up listeners and state from the previously registered media element.
   *
   * @internal
   */
  unregisterLoading() {
    this.mediaElement && (this.mediaElement.pause(), this.mediaElement.removeAttribute("autoplay"), this.mediaElement.setAttribute("preload", "none"), this.mediaElement.removeEventListener("error", uf, !0), this.mediaElement.removeEventListener("loadedmetadata", this.handleLoaded, !0), this.mediaElement.removeEventListener("loadedmetadata", yf, !0), this.mediaElement = void 0);
  }
  render() {
    return this.format === "video" ? h`
          <video ${j((t) => this.registerLoading(t))} part="wy-content-video" controls crossorigin="use-credentials">
            <source src=${this.src} type=${nt(this.mediaType)} />
            <wy-preview-icon src=${this.src} icon="file-video"></wy-preview-icon>
          </video>
          <wy-progress-circular part="wy-content-progress" indeterminate overlay></wy-progress-circular>
        ` : h`
          <audio ${j((t) => this.registerLoading(t))} part="wy-content-audio" controls crossorigin="use-credentials">
            <source src=${this.src} type=${nt(this.mediaType)} />
          </audio>
        `;
  }
  updated(t) {
    super.updated(t), t.has("play") && this.mediaElement && (this.play ? this.mediaElement.play() : this.mediaElement.pause());
  }
  disconnectedCallback() {
    this.unregisterLoading(), super.disconnectedCallback();
  }
}, a(ho, "WyPreviewMedia"), ho);
Ji.styles = [
  jx,
  Z
];
jc([
  p()
], Ji.prototype, "format", 2);
jc([
  p()
], Ji.prototype, "src", 2);
jc([
  p({ type: Boolean })
], Ji.prototype, "play", 2);
jc([
  p()
], Ji.prototype, "name", 2);
jc([
  p()
], Ji.prototype, "mediaType", 2);
Ji = jc([
  H("wy-preview-media")
], Ji);
const Kx = B`[part~=wy-content-code]{align-self:flex-start;box-sizing:border-box;width:100%;padding:calc(2*var(--wy-size, 1rem)) calc(3.5*var(--wy-size, 1rem));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}`, Gx = B`[part~=wy-content-text],[part~=wy-content-html] pre,[part~=wy-content-html] code{word-break:break-word;white-space:pre-wrap}[part~=wy-content-html] hr{border-color:var(--wy-outline, var(--wy-outline-light, #72777f));border-width:var(--wy-border, 1px) 0 0 0;border-style:solid}[part~=wy-content-html] h1,[part~=wy-content-html] h2,[part~=wy-content-html] h3,[part~=wy-content-html] h4,[part~=wy-content-html] h5,[part~=wy-content-html] h6{font-family:var(--wy-document-headings-font-family, var(--wy-headings-font-family, var(--wy-font-family, unset)));line-height:var(--wy-document-headings-line-height, var(--wy-headings-line-height, var(--wy-line-height, 1.5)))}[part~=wy-content-html] h1{font-size:var(--wy-document-h1-font-size, calc(2 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h1-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h1-margin, 0 0 var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-content-html] h2{font-size:var(--wy-document-h2-font-size, calc(1.5 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h2-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h2-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content-html] h3{font-size:var(--wy-document-h3-font-size, calc(1.25 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h3-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h3-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content-html] h4{font-size:var(--wy-document-h4-font-size, calc(1.125 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h4-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h4-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 0)}[part~=wy-content-html] h5{font-size:var(--wy-document-h5-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-document-h5-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h5-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 0)}[part~=wy-content-html] h6{font-size:var(--wy-document-h6-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-document-h6-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h6-margin, 0)}`, Zx = B`[part~=wy-document]{--wy-component-background-color: var(--wy-background, var(--wy-background-light, #f7f9ff));--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);align-self:flex-start;padding:calc(2*var(--wy-size, 1rem)) calc(3.5*var(--wy-size, 1rem));box-sizing:border-box;width:100%;min-height:100%;flex:1 0 auto}@container (inline-size >= 768px){[part~=wy-document]{padding:calc(3*var(--wy-size, 1rem)) calc(4*var(--wy-size, 1rem));margin:calc(2*var(--wy-size, 1rem)) auto;border-radius:calc(.125*var(--wy-size, 1rem));box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));width:120ch;min-height:170ch;max-width:calc(100% - 3.5*var(--wy-size, 1rem))}}`, Yx = B`[part~=wy-code] pre,.wy-code pre{text-wrap:pretty}[part~=wy-code] .code,[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code .code,.wy-code code[class*=language-],.wy-code pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;word-wrap:break-word;line-height:1.25;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}@media print{[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code code[class*=language-],.wy-code pre[class*=language-]{text-shadow:none}}[part~=wy-code] pre[class*=language-],.wy-code pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}[part~=wy-code] :not(pre)>code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code :not(pre)>code[class*=language-],.wy-code pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));background:var(--wy-background, var(--wy-background-light, #f7f9ff))}[part~=wy-code] :not(pre)>code[class*=language-],.wy-code :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}[part~=wy-code] .token.variable,.wy-code .token.variable{color:var(--wy-code-variable, var(--wy-code-variable-light, #001080))}[part~=wy-code] .token.operator,.wy-code .token.operator{color:var(--wy-code-operator, var(--wy-code-operator-light, #000000))}[part~=wy-code] .token.prolog,.wy-code .token.prolog{color:var(--wy-code-prolog, var(--wy-code-prolog-light, #000080))}[part~=wy-code] .token.comment,.wy-code .token.comment{color:var(--wy-code-comment, var(--wy-code-comment-light, #008000))}[part~=wy-code] .token.builtin,.wy-code .token.builtin{color:var(--wy-code-builtin, var(--wy-code-builtin-light, #0070C1))}[part~=wy-code] .token.number,.wy-code .token.number{color:var(--wy-code-number, var(--wy-code-number-light, #098658))}[part~=wy-code] .token.inserted,.wy-code .token.inserted{color:var(--wy-code-inserted, var(--wy-code-inserted-light, #098658))}[part~=wy-code] .token.constant,.wy-code .token.constant{color:var(--wy-code-constant, var(--wy-code-constant-light, #811F3F))}[part~=wy-code] .token.hexcode,.wy-code .token.hexcode{color:var(--wy-code-hexcode, var(--wy-code-hexcode-light, #811F3F))}[part~=wy-code] .token.regex,.wy-code .token.regex{color:var(--wy-code-regex, var(--wy-code-regex-light, #811F3F))}[part~=wy-code] .token.char,.wy-code .token.char{color:var(--wy-code-char, var(--wy-code-char-light, #811F3F))}[part~=wy-code] .token.tag,.wy-code .token.tag{color:var(--wy-code-tag, var(--wy-code-tag-light, #800000))}[part~=wy-code] .token.attr-name,.wy-code .token.attr-name{color:var(--wy-code-attr-name, var(--wy-code-attr-name-light, #E50000))}[part~=wy-code] .token.selector,.wy-code .token.selector{color:var(--wy-code-selector, var(--wy-code-selector-light, #E50000))}[part~=wy-code] .token.property,.wy-code .token.property{color:var(--wy-code-property, var(--wy-code-property-light, #E50000))}[part~=wy-code] .token.deleted,.wy-code .token.deleted{color:var(--wy-code-deleted, var(--wy-code-deleted-light, #A31515))}[part~=wy-code] .token.string,.wy-code .token.string{color:var(--wy-code-string, var(--wy-code-string-light, #A31515))}[part~=wy-code] .token.changed,.wy-code .token.changed{color:var(--wy-code-changed, var(--wy-code-changed-light, #0451A5))}[part~=wy-code] .token.punctuation,.wy-code .token.punctuation{color:var(--wy-code-punctuation, var(--wy-code-punctuation-light, #000000))}[part~=wy-code] .token.function,.wy-code .token.function{color:var(--wy-code-function, var(--wy-code-function-light, #0000FF))}[part~=wy-code] .token.keyword,.wy-code .token.keyword{color:var(--wy-code-keyword, var(--wy-code-keyword-light, #AF00DB))}[part~=wy-code] .token.class-name,.wy-code .token.class-name{color:var(--wy-code-class-name, var(--wy-code-class-name-light, #267F99))}[part~=wy-code] .token.important,[part~=wy-code] .token.bold,.wy-code .token.important,.wy-code .token.bold{font-weight:700}[part~=wy-code] .token.italic,.wy-code .token.italic{font-style:italic}`;
var Xx = Object.defineProperty, Jx = Object.getOwnPropertyDescriptor, js = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? Jx(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && Xx(t, e, s), s;
}, "__decorateClass$Q"), po;
let Pi = (po = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.html = !1, this.code = !1, this.textOrHtmlContent = "", this.loading = !0;
  }
  /**
   * Dispatches the `file-preview-loaded` event when content becomes available.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  updated(t) {
    super.updated(t), (t.has("weavy") || t.has("src")) && this.weavy && (this.loading = !0, this.weavy.fetchOptions().then((e) => fetch(this.src, e)).then($1).then((e) => new Response(e)).then((e) => e.text()).then((e) => {
      this.loading = !1, this.textOrHtmlContent = e, this.dispatchLoaded();
    }));
  }
  render() {
    return this.loading ? h` <wy-empty><wy-progress-circular part="wy-content-progress" indeterminate></wy-progress-circular></wy-empty> ` : this.html ? this.code ? h` <div part="wy-content-code wy-code">${bs(this.textOrHtmlContent)}</div> ` : h`
            <div part="wy-document wy-light">
              <div part="wy-content-html">${bs(this.textOrHtmlContent)}</div>
            </div>
          ` : this.code ? h` <div part="wy-content-code">${this.textOrHtmlContent}</div> ` : h`
          <div part="wy-document wy-light">
            <pre part="wy-content-text">${this.textOrHtmlContent}</pre>
          </div>
        `;
  }
}, a(po, "WyPreviewText"), po);
Pi.styles = [Yt, Gx, Kx, Zx, Yx, Z];
js([
  he({ context: re, subscribe: !0 }),
  F()
], Pi.prototype, "weavy", 2);
js([
  p()
], Pi.prototype, "src", 2);
js([
  p({ type: Boolean })
], Pi.prototype, "html", 2);
js([
  p({ type: Boolean })
], Pi.prototype, "code", 2);
js([
  F()
], Pi.prototype, "textOrHtmlContent", 2);
js([
  F()
], Pi.prototype, "loading", 2);
Pi = js([
  H("wy-preview-text")
], Pi);
const t4 = B`[part~=wy-content-embed]{border:0;display:block;box-sizing:border-box;width:100%;height:100%;top:0;left:0;flex:1 1 100%}[part~=wy-content-embed][part~=wy-loaded]{--wy-component-background-color: var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}[part~=wy-content-embed][part~=wy-loaded]~[part~=wy-content-embed-fallback],[part~=wy-content-embed][part~=wy-loaded]~[part~=wy-content-progress]{display:none}[part~=wy-content-embed][part~=wy-loading]:not([part~=wy-loaded]){position:absolute;visibility:hidden;z-index:-1;pointer-events:none}[part~=wy-content-embed][part~=wy-loading]:not([part~=wy-loaded]):not([part~=wy-fallback])~[part~=wy-content-embed-fallback]{display:none}[part~=wy-content-embed][part~=wy-loading]:not([part~=wy-loaded])[part~=wy-fallback]~[part~=wy-content-progress]{display:none}`;
var e4 = Object.defineProperty, i4 = Object.getOwnPropertyDescriptor, pd = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? i4(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && e4(t, e, s), s;
}, "__decorateClass$P"), uo;
let Ir = (uo = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this);
  }
  /**
   * Emit `file-preview-loaded` once the preview has finished loading.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  /**
   * Attach load listeners and register the provided embed element.
   *
   * @internal
   * @param embedElement - Newly rendered embed element.
   */
  registerLoading(t) {
    if (this.unregisterLoading?.(), t) {
      this.embedElement = t, t.part.add("wy-loading");
      const e = window.setTimeout(() => {
        t.part.add("wy-fallback"), this.dispatchLoaded();
      }, 2500), r = /* @__PURE__ */ a((s) => {
        const n = s.target;
        n.tagName === "OBJECT" && n.part.contains("wy-loading") && !n.part.contains("wy-loaded") && (n.part.add("wy-loaded"), window.clearTimeout(e), this.dispatchLoaded());
      }, "embedLoaded");
      t.addEventListener("load", r, !0), this.unregisterLoading = () => {
        this.embedElement && (t.removeEventListener("load", r, !0), window.clearTimeout(e), this.embedElement = void 0);
      };
    }
  }
  render() {
    return h`
      <object title=${b("Preview")} ${j((t) => this.registerLoading(t))} part="wy-content-embed" data=${this.src}></object>
      <wy-progress-circular part="wy-content-progress" indeterminate overlay></wy-progress-circular>
      <wy-preview-icon
        src=${this.src}
        icon=${this.icon}
        provider=${nt(this.provider)}
        part="wy-content-embed-fallback"></wy-preview-icon>
    `;
  }
  disconnectedCallback() {
    this.unregisterLoading?.(), super.disconnectedCallback();
  }
}, a(uo, "WyPreviewEmbed"), uo);
Ir.styles = [
  t4,
  Z
];
pd([
  p()
], Ir.prototype, "src", 2);
pd([
  p()
], Ir.prototype, "name", 2);
pd([
  p()
], Ir.prototype, "icon", 2);
pd([
  p()
], Ir.prototype, "provider", 2);
Ir = pd([
  H("wy-preview-embed"),
  ot()
], Ir);
const r4 = B`.wy-pdf-container{position:absolute;width:100%;height:100%;bottom:0;left:0}.wy-pdf-container{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-pdf-container:not(body){-webkit-overflow-scrolling:touch}.wy-pdf-container{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-pdf-container{overflow-y:auto;overflow-x:auto;touch-action:pan-y,pan-x}.wy-content-pdf .textLayer{position:absolute;text-align:initial;inset:0;overflow:clip;opacity:1;line-height:1;text-size-adjust:none;forced-color-adjust:none;transform-origin:0 0;caret-color:CanvasText;z-index:0}.wy-content-pdf .textLayer.highlighting{touch-action:none}.wy-content-pdf .textLayer :is(span,br){color:#0000;position:absolute;white-space:pre;cursor:text;transform-origin:0% 0%}.wy-content-pdf .textLayer>:not(.markedContent),.wy-content-pdf .textLayer .markedContent span:not(.markedContent){z-index:1}.wy-content-pdf .textLayer span.markedContent{top:0;height:0}.wy-content-pdf .textLayer span[role=img]{-webkit-user-select:none;user-select:none;cursor:default}.wy-content-pdf .textLayer .highlight{--highlight-bg-color: rgb(180 0 170 / .25);--highlight-selected-bg-color: rgb(0 100 0 / .25);--highlight-backdrop-filter: none;--highlight-selected-backdrop-filter: none}@media screen and (forced-colors:active){.wy-content-pdf .textLayer .highlight{--highlight-bg-color: transparent;--highlight-selected-bg-color: transparent;--highlight-backdrop-filter: var(--hcm-highlight-filter);--highlight-selected-backdrop-filter: var(--hcm-highlight-selected-filter)}}.wy-content-pdf .textLayer .highlight{margin:-1px;padding:1px;background-color:var(--highlight-bg-color);-webkit-backdrop-filter:var(--highlight-backdrop-filter);backdrop-filter:var(--highlight-backdrop-filter);border-radius:4px}.wy-content-pdf .textLayer .highlight.appended{position:initial}.wy-content-pdf .textLayer .highlight.begin{border-radius:4px 0 0 4px}.wy-content-pdf .textLayer .highlight.end{border-radius:0 4px 4px 0}.wy-content-pdf .textLayer .highlight.middle{border-radius:0}.wy-content-pdf .textLayer .highlight.selected{background-color:var(--highlight-selected-bg-color);-webkit-backdrop-filter:var(--highlight-selected-backdrop-filter);backdrop-filter:var(--highlight-selected-backdrop-filter)}.wy-content-pdf .textLayer ::selection{background:#0000ff40;background:color-mix(in srgb,AccentColor,transparent 75%)}.wy-content-pdf .textLayer br::selection{background:#0000}.wy-content-pdf .textLayer .endOfContent{display:block;position:absolute;inset:100% 0 0;z-index:0;cursor:default;-webkit-user-select:none;user-select:none}.wy-content-pdf .textLayer.selecting .endOfContent{top:0}.wy-content-pdf .annotationLayer{--annotation-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\");--input-focus-border-color: Highlight;--input-focus-outline: 1px solid Canvas;--input-unfocused-border-color: transparent;--input-disabled-border-color: transparent;--input-hover-border-color: black;--link-outline: none}@media screen and (forced-colors:active){.wy-content-pdf .annotationLayer{--input-focus-border-color: CanvasText;--input-unfocused-border-color: ActiveText;--input-disabled-border-color: GrayText;--input-hover-border-color: Highlight;--link-outline: 1.5px solid LinkText}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):required,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:required,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:required{outline:1.5px solid selectedItem}.wy-content-pdf .annotationLayer .linkAnnotation{outline:var(--link-outline)}.wy-content-pdf .annotationLayer .linkAnnotation:hover{-webkit-backdrop-filter:var(--hcm-highlight-filter);backdrop-filter:var(--hcm-highlight-filter)}.wy-content-pdf .annotationLayer .linkAnnotation>a:hover{opacity:0!important;background:none!important;box-shadow:none}.wy-content-pdf .annotationLayer .popupAnnotation .popup{outline:calc(1.5px*var(--scale-factor)) solid CanvasText!important;background-color:ButtonFace!important;color:ButtonText!important}.wy-content-pdf .annotationLayer .highlightArea:hover:after{position:absolute;top:0;left:0;width:100%;height:100%;-webkit-backdrop-filter:var(--hcm-highlight-filter);backdrop-filter:var(--hcm-highlight-filter);content:\"\";pointer-events:none}.wy-content-pdf .annotationLayer .popupAnnotation.focused .popup{outline:calc(3px*var(--scale-factor)) solid Highlight!important}}.wy-content-pdf .annotationLayer{position:absolute;top:0;left:0;pointer-events:none;transform-origin:0 0}.wy-content-pdf .annotationLayer[data-main-rotation=\"90\"] .norotate{transform:rotate(270deg) translate(-100%)}.wy-content-pdf .annotationLayer[data-main-rotation=\"180\"] .norotate{transform:rotate(180deg) translate(-100%,-100%)}.wy-content-pdf .annotationLayer[data-main-rotation=\"270\"] .norotate{transform:rotate(90deg) translateY(-100%)}.wy-content-pdf .annotationLayer.disabled section,.wy-content-pdf .annotationLayer.disabled .popup{pointer-events:none}.wy-content-pdf .annotationLayer .annotationContent{position:absolute;width:100%;height:100%;pointer-events:none}.wy-content-pdf .annotationLayer .annotationContent.freetext{background:#0000;border:none;inset:0;overflow:visible;white-space:nowrap;font:10px sans-serif;line-height:1.35;-webkit-user-select:none;user-select:none}.wy-content-pdf .annotationLayer section{position:absolute;text-align:initial;pointer-events:auto;box-sizing:border-box;transform-origin:0 0}.wy-content-pdf .annotationLayer section:has(div.annotationContent) canvas.annotationContent{display:none}.textLayer.selecting~.wy-content-pdf .annotationLayer section{pointer-events:none}.wy-content-pdf .annotationLayer :is(.linkAnnotation,.buttonWidgetAnnotation.pushButton)>a{position:absolute;font-size:1em;top:0;left:0;width:100%;height:100%}.wy-content-pdf .annotationLayer :is(.linkAnnotation,.buttonWidgetAnnotation.pushButton):not(.hasBorder)>a:hover{opacity:.2;background-color:#ff0;box-shadow:0 2px 10px #ff0}.wy-content-pdf .annotationLayer .linkAnnotation.hasBorder:hover{background-color:#ff03}.wy-content-pdf .annotationLayer .hasBorder{background-size:100% 100%}.wy-content-pdf .annotationLayer .textAnnotation img{position:absolute;cursor:pointer;width:100%;height:100%;top:0;left:0}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea),.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input{background-image:var(--annotation-unfocused-field-background);border:2px solid var(--input-unfocused-border-color);box-sizing:border-box;font:calc(9px*var(--scale-factor)) sans-serif;height:100%;margin:0;vertical-align:top;width:100%}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):required,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:required,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:required{outline:1.5px solid red}.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select option{padding:0}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input{border-radius:50%}.wy-content-pdf .annotationLayer .textWidgetAnnotation textarea{resize:none}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea)[disabled],.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select[disabled],.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input[disabled]{background:none;border:2px solid var(--input-disabled-border-color);cursor:not-allowed}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):hover,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:hover,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:hover{border:2px solid var(--input-hover-border-color)}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):hover,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:hover,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:hover{border-radius:2px}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):focus,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:focus{background:none;border:2px solid var(--input-focus-border-color);border-radius:2px;outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) :focus{background-image:none;background-color:#0000}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox :focus{border:2px solid var(--input-focus-border-color);border-radius:2px;outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton :focus{border:2px solid var(--input-focus-border-color);outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{background-color:CanvasText;content:\"\";display:block;position:absolute}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{height:80%;left:45%;width:1px}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{transform:rotate(45deg)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{transform:rotate(-45deg)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{border-radius:50%;height:50%;left:25%;top:25%;width:50%}.wy-content-pdf .annotationLayer .textWidgetAnnotation input.comb{font-family:monospace;padding-left:2px;padding-right:0}.wy-content-pdf .annotationLayer .textWidgetAnnotation input.comb:focus{width:103%}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input{appearance:none}.wy-content-pdf .annotationLayer .fileAttachmentAnnotation .popupTriggerArea{height:100%;width:100%}.wy-content-pdf .annotationLayer .popupAnnotation{position:absolute;font-size:calc(9px*var(--scale-factor));pointer-events:none;width:max-content;max-width:45%;height:auto}.wy-content-pdf .annotationLayer .popup{background-color:#ff9;box-shadow:0 calc(2px*var(--scale-factor)) calc(5px*var(--scale-factor)) #888;border-radius:calc(2px*var(--scale-factor));outline:1.5px solid #ffff4a;padding:calc(6px*var(--scale-factor));cursor:pointer;font:message-box;white-space:normal;word-wrap:break-word;pointer-events:auto}.wy-content-pdf .annotationLayer .popupAnnotation.focused .popup{outline-width:3px}.wy-content-pdf .annotationLayer .popup *{font-size:calc(9px*var(--scale-factor))}.wy-content-pdf .annotationLayer .popup>.header{display:inline-block}.wy-content-pdf .annotationLayer .popup>.header h1{display:inline}.wy-content-pdf .annotationLayer .popup>.header .popupDate{display:inline-block;margin-left:calc(5px*var(--scale-factor));width:fit-content}.wy-content-pdf .annotationLayer .popupContent{border-top:1px solid #333;margin-top:calc(2px*var(--scale-factor));padding-top:calc(2px*var(--scale-factor))}.wy-content-pdf .annotationLayer .richText>*{white-space:pre-wrap;font-size:calc(9px*var(--scale-factor))}.wy-content-pdf .annotationLayer .popupTriggerArea{cursor:pointer}.wy-content-pdf .annotationLayer section svg{position:absolute;width:100%;height:100%;top:0;left:0}.wy-content-pdf .annotationLayer .annotationTextContent{position:absolute;width:100%;height:100%;opacity:0;color:#0000;-webkit-user-select:none;user-select:none;pointer-events:none}.wy-content-pdf .annotationLayer .annotationTextContent span{width:100%;display:inline-block}.wy-content-pdf .annotationLayer svg.quadrilateralsContainer{contain:strict;width:0;height:0;position:absolute;top:0;left:0;z-index:-1}:host{--xfa-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\");--xfa-focus-outline: auto}@media screen and (forced-colors:active){:host{--xfa-focus-outline: 2px solid CanvasText}.wy-content-pdf .xfaLayer *:required{outline:1.5px solid selectedItem}}.wy-content-pdf .xfaLayer{background-color:#0000}.wy-content-pdf .xfaLayer .highlight{margin:-1px;padding:1px;background-color:#efcbed;border-radius:4px}.wy-content-pdf .xfaLayer .highlight.appended{position:initial}.wy-content-pdf .xfaLayer .highlight.begin{border-radius:4px 0 0 4px}.wy-content-pdf .xfaLayer .highlight.end{border-radius:0 4px 4px 0}.wy-content-pdf .xfaLayer .highlight.middle{border-radius:0}.wy-content-pdf .xfaLayer .highlight.selected{background-color:#cbdfcb}.wy-content-pdf .xfaPage{overflow:hidden;position:relative}.wy-content-pdf .xfaContentarea{position:absolute}.wy-content-pdf .xfaPrintOnly{display:none}.wy-content-pdf .xfaLayer{position:absolute;text-align:initial;top:0;left:0;transform-origin:0 0;line-height:1.2}.wy-content-pdf .xfaLayer *{color:inherit;font:inherit;font-style:inherit;font-weight:inherit;font-kerning:inherit;letter-spacing:-.01px;text-align:inherit;text-decoration:inherit;box-sizing:border-box;background-color:#0000;padding:0;margin:0;pointer-events:auto;line-height:inherit}.wy-content-pdf .xfaLayer *:required{outline:1.5px solid red}.wy-content-pdf .xfaLayer div,.wy-content-pdf .xfaLayer svg,.wy-content-pdf .xfaLayer svg *{pointer-events:none}.wy-content-pdf .xfaLayer a{color:#00f}.wy-content-pdf .xfaRich li{margin-left:3em}.wy-content-pdf .xfaFont{color:#000;font-weight:400;font-kerning:none;font-size:10px;font-style:normal;letter-spacing:0;text-decoration:none;vertical-align:0}.wy-content-pdf .xfaCaption{overflow:hidden;flex:0 0 auto}.wy-content-pdf .xfaCaptionForCheckButton{overflow:hidden;flex:1 1 auto}.wy-content-pdf .xfaLabel{height:100%;width:100%}.wy-content-pdf .xfaLeft{display:flex;flex-direction:row;align-items:center}.wy-content-pdf .xfaRight{display:flex;flex-direction:row-reverse;align-items:center}.wy-content-pdf :is(.xfaLeft,.xfaRight)>:is(.xfaCaption,.xfaCaptionForCheckButton){max-height:100%}.wy-content-pdf .xfaTop{display:flex;flex-direction:column;align-items:flex-start}.wy-content-pdf .xfaBottom{display:flex;flex-direction:column-reverse;align-items:flex-start}.wy-content-pdf :is(.xfaTop,.xfaBottom)>:is(.xfaCaption,.xfaCaptionForCheckButton){width:100%}.wy-content-pdf .xfaBorder{background-color:#0000;position:absolute;pointer-events:none}.wy-content-pdf .xfaWrapped{width:100%;height:100%}.wy-content-pdf :is(.xfaTextfield,.xfaSelect):focus{background-image:none;background-color:#0000;outline:var(--xfa-focus-outline);outline-offset:-1px}.wy-content-pdf :is(.xfaCheckbox,.xfaRadio):focus{outline:var(--xfa-focus-outline)}.wy-content-pdf .xfaTextfield,.wy-content-pdf .xfaSelect{height:100%;width:100%;flex:1 1 auto;border:none;resize:none;background-image:var(--xfa-unfocused-field-background)}.wy-content-pdf .xfaSelect{padding-inline:2px}.wy-content-pdf :is(.xfaTop,.xfaBottom)>:is(.xfaTextfield,.xfaSelect){flex:0 1 auto}.wy-content-pdf .xfaButton{cursor:pointer;width:100%;height:100%;border:none;text-align:center}.wy-content-pdf .xfaLink{width:100%;height:100%;position:absolute;top:0;left:0}.wy-content-pdf .xfaCheckbox,.wy-content-pdf .xfaRadio{width:100%;height:100%;flex:0 0 auto;border:none}.wy-content-pdf .xfaRich{white-space:pre-wrap;width:100%;height:100%}.wy-content-pdf .xfaImage{object-position:left top;object-fit:contain;width:100%;height:100%}.wy-content-pdf .xfaLrTb,.wy-content-pdf .xfaRlTb,.wy-content-pdf .xfaTb{display:flex;flex-direction:column;align-items:stretch}.wy-content-pdf .xfaLr{display:flex;flex-direction:row;align-items:stretch}.wy-content-pdf .xfaRl{display:flex;flex-direction:row-reverse;align-items:stretch}.wy-content-pdf .xfaTb>div{justify-content:left}.wy-content-pdf .xfaPosition,.wy-content-pdf .xfaArea{position:relative}.wy-content-pdf .xfaValignMiddle{display:flex;align-items:center}.wy-content-pdf .xfaTable{display:flex;flex-direction:column;align-items:stretch}.wy-content-pdf .xfaTable .xfaRow{display:flex;flex-direction:row;align-items:stretch}.wy-content-pdf .xfaTable .xfaRlRow{display:flex;flex-direction:row-reverse;align-items:stretch;flex:1}.wy-content-pdf .xfaTable .xfaRlRow>div{flex:1}.wy-content-pdf :is(.xfaNonInteractive,.xfaDisabled,.xfaReadOnly) :is(input,textarea){background:initial}@media print{.wy-content-pdf .xfaTextfield,.wy-content-pdf .xfaSelect{background:#0000}.wy-content-pdf .xfaSelect{appearance:none;text-indent:1px;text-overflow:\"\"}}:host{--viewer-container-height: 0;--pdfViewer-padding-bottom: 0;--page-margin: 1px auto -8px;--page-border: 9px solid transparent;--spreadHorizontalWrapped-margin-LR: -3.5px;--loading-icon-delay: .4s}@media screen and (forced-colors:active){:host{--pdfViewer-padding-bottom: 9px;--page-margin: 8px auto -1px;--page-border: 1px solid CanvasText;--spreadHorizontalWrapped-margin-LR: 3.5px}}.wy-content-pdf [data-main-rotation=\"90\"]{transform:rotate(90deg) translateY(-100%)}.wy-content-pdf [data-main-rotation=\"180\"]{transform:rotate(180deg) translate(-100%,-100%)}.wy-content-pdf [data-main-rotation=\"270\"]{transform:rotate(270deg) translate(-100%)}.wy-content-pdf #hiddenCopyElement,.wy-content-pdf .hiddenCanvasElement{position:absolute;top:0;left:0;width:0;height:0;display:none}.wy-content-pdf .pdfViewer{--scale-factor: 1;--page-bg-color: unset;padding-bottom:var(--pdfViewer-padding-bottom);--hcm-highlight-filter: none;--hcm-highlight-selected-filter: none}@media screen and (forced-colors:active){.wy-content-pdf .pdfViewer{--hcm-highlight-filter: invert(100%)}}.wy-content-pdf .pdfViewer.copyAll{cursor:wait}.wy-content-pdf .pdfViewer .canvasWrapper{overflow:hidden;width:100%;height:100%}.wy-content-pdf .pdfViewer .canvasWrapper canvas{position:absolute;top:0;left:0;margin:0;display:block;width:100%;height:100%;contain:content}.wy-content-pdf .pdfViewer .canvasWrapper canvas .structTree{contain:strict}.wy-content-pdf .pdfViewer .page{--scale-round-x: 1px;--scale-round-y: 1px;direction:ltr;width:816px;height:1056px;margin:var(--page-margin);position:relative;overflow:visible;border:var(--page-border);background-clip:content-box;background-color:var(--page-bg-color, rgb(255, 255, 255))}.wy-content-pdf .pdfViewer .dummyPage{position:relative;width:0;height:var(--viewer-container-height)}.wy-content-pdf .pdfViewer.noUserSelect{-webkit-user-select:none;user-select:none}.wy-content-pdf .pdfViewer.removePageBorders .page{margin:0 auto 10px;border:none}.wy-content-pdf .pdfViewer.singlePageView{display:inline-block}.wy-content-pdf .pdfViewer.singlePageView .page{margin:0;border:none}.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped),.wy-content-pdf .spread{margin-inline:3.5px;text-align:center}.wy-content-pdf .pdfViewer.scrollHorizontal,.wy-content-pdf .spread{white-space:nowrap}.wy-content-pdf .pdfViewer.removePageBorders,.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) .spread{margin-inline:0}.wy-content-pdf .spread :is(.page,.dummyPage),.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) :is(.page,.spread){display:inline-block;vertical-align:middle}.wy-content-pdf .spread .page,.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) .page{margin-inline:var(--spreadHorizontalWrapped-margin-LR)}.wy-content-pdf .pdfViewer.removePageBorders .spread .page,.wy-content-pdf .pdfViewer.removePageBorders:is(.scrollHorizontal,.scrollWrapped) .page{margin-inline:5px}.wy-content-pdf .pdfViewer .page.loadingIcon:after{position:absolute;top:0;left:0;content:\"\";width:100%;height:100%;display:none;transition-property:display;transition-delay:var(--loading-icon-delay);z-index:5;contain:strict}.wy-content-pdf .pdfViewer .page.loading:after{display:block}.wy-content-pdf .pdfViewer .page:not(.loading):after{transition-property:none;display:none}.wy-content-pdf .pdfPresentationMode .pdfViewer{padding-bottom:0}.wy-content-pdf .pdfPresentationMode .spread{margin:0}.wy-content-pdf .pdfPresentationMode .pdfViewer .page{margin:0 auto;border:2px solid rgba(0,0,0,0)}.wy-content-pdf .pdfViewer .page{box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));background-color:var(--wy-white, var(--wy-white, #ffffff))}.wy-content-pdf .pdfViewer .page.loadingIcon:after{background:url(\"data:image/svg+xml,%3Csvg viewBox='0 0 24 24' width='24' height='24' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cstyle type='text/css'%3Eg%7Banimation:rotate 2s linear infinite;transform-origin:center center%7Dcircle%7Bstroke-dasharray:1,100;stroke-dashoffset:0;animation:dash 1.5s ease-in-out infinite,color 6s ease-in-out infinite%7D@keyframes rotate%7B100%25%7Btransform:rotate(360deg)%7D%7D@keyframes dash%7B0%25%7Bstroke-dasharray:1,100;stroke-dashoffset:0%7D50%25%7Bstroke-dasharray:44.5,100;stroke-dashoffset:-17.5px%7D100%25%7Bstroke-dasharray:44.5,100;stroke-dashoffset:-62px%7D%7D@keyframes color%7B0%25,100%25%7Bstroke:%23216eb4%7D40%25%7Bstroke:%2328b7cf%7D66%25%7Bstroke:%23216eb4%7D80%25,90%25%7Bstroke:%2328b7cf%7D%7D%3C/style%3E%3Cg%3E%3Ccircle fill='none' cx='12' cy='12' r='11' stroke-linecap='butt' stroke-width='2' /%3E%3C/g%3E%3C/svg%3E\") center no-repeat}.wy-pdf-page-number{width:calc(3*var(--wy-size, 1rem))}.wy-pdf-zoom-level{width:calc(5*var(--wy-size, 1rem))}`, xv = B`[part~=wy-toolbar]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));box-sizing:border-box;display:flex;flex-wrap:wrap;align-items:center;justify-content:flex-start;justify-items:center;min-height:var(--wy-toolbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));padding:calc(.5*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));flex:1 0 var(--wy-toolbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));column-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));line-height:var(--wy-line-height, 1.5);background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-component-border-radius)}[part~=wy-toolbar-center]{margin:0 auto;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-toolbar-buttons]{display:flex;flex:0 0 auto;align-items:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));max-width:100%}[part~=wy-toolbar-buttons-last]{margin-inline-start:auto}[part~=wy-toolbar-text]{margin-left:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-toolbar-center-text]{text-align:center}[part~=wy-toolbars-bottom]{position:absolute;z-index:1030;bottom:calc(var(--wy-footerbar-height, calc(4 * var(--wy-size, 1rem)))/2);left:0;right:0;min-height:var(--wy-toolbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;justify-content:center;justify-items:center;box-sizing:border-box}`, jr = B`[part~=wy-input]{--wy-component-background-color: var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border:var(--wy-input-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));margin:calc(-1*var(--wy-input-border-width, var(--wy-border, 1px)));display:block;max-width:100%;min-width:0;flex:1 1 auto;min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em))*1.5*var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*2 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))*2);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-input-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem))));background-clip:padding-box;appearance:none;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-input]:focus{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));color:var(--wy-component-color);border-color:var(--wy-primary, var(--wy-primary-light, #2f628c));outline:0}[part~=wy-input]::placeholder{color:var(--wy-outline, var(--wy-outline-light, #72777f));opacity:1}[part~=wy-input]:disabled{opacity:38%}[part~=wy-input]::file-selector-button,[part~=wy-input]::-webkit-file-upload-button{color:var(--wy-component-color);background-color:var(--wy-component-background-color);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));margin:calc(-1*var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) calc(-1*var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));margin-inline-end:var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));pointer-events:none;border-color:inherit;border-style:solid;border-width:0;border-inline-end-width:var(--wy-input-border-width, var(--wy-border, 1px));border-radius:0}[part~=wy-input]:hover:not(:disabled):not([readonly])::file-selector-button,[part~=wy-input]:hover:not(:disabled):not([readonly]) ::-webkit-file-upload-button{background-color:var(--wy-component-background-color)}[part~=wy-input][type=file]{overflow:hidden}[part~=wy-input][type=file]:not(:disabled):not([readonly]){cursor:pointer}[part~=wy-input]::-webkit-date-and-time-value{height:calc(var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem))))*1em)}[part~=wy-input][type=search]::-webkit-search-cancel-button{-webkit-appearance:none}[part~=wy-input-filled]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-input-filled-border-radius, var(--wy-border-radius-lg, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem)))));border-color:var(--wy-component-background-color)}[part~=wy-input-filled]:focus{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-label]{display:inline-block;font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));font-size:var(--wy-headings-font-size, var(--wy-font-size, 1em));font-style:var(--wy-headings-font-style, unset);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.5));margin-block:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-description]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));margin-top:calc(.25*var(--wy-size, 1rem))}[part~=wy-is-invalid],[part~=wy-is-invalid]:focus{border-color:var(--wy-error, var(--wy-error-light, #ba1821))}[part~=wy-invalid-feedback]{margin-top:calc(.25*var(--wy-size, 1rem));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));color:var(--wy-error, var(--wy-error-light, #ba1821))}[part~=wy-input-group]{position:relative;display:flex;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));align-items:center;flex:1 0 auto}[part~=wy-input-group-button-icon]{--wy-component-background-color: transparent}[part~=wy-input-group-input-with-overlay]{padding-right:calc(var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) + var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}[part~=wy-input-group-button-icon-overlay]{position:absolute;display:inline-flex;top:0;right:0;z-index:4;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));--wy-component-background-color: transparent}[part~=wy-input-group-input]:placeholder-shown~[part~=wy-input-group-button-icon][type=reset]{display:none}[part~=wy-input-group-input]:not(:placeholder-shown)~[part~=wy-input-group-button-icon][type=reset]+[part~=wy-input-group-button-icon]{display:none}[part~=wy-no-result]{text-align:center;padding:calc(1*var(--wy-size, 1rem))}`;
var s4 = Object.defineProperty, n4 = Object.getOwnPropertyDescriptor, Eh = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? n4(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && s4(t, e, s), s;
}, "__decorateClass$O"), yo;
let As = (yo = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.whenPdfjs = new Promise((t) => {
      this.whenPdfjsResolve = t;
    }), this.MAX_CANVAS_PIXELS = 0, this.TEXT_LAYER_MODE = 0, this.MAX_IMAGE_SIZE = -1, this.CMAP_PACKED = !0, this.DEFAULT_SCALE_DELTA = 1.1, this.MIN_SCALE = 0.25, this.MAX_SCALE = 10, this.DEFAULT_SCALE_VALUE = "auto", this.ENABLE_XFA = !0, this.DEFAULT_WORKER_URL = "/pdfjs/pdf.worker.min.mjs", this.DEFAULT_CMAPS_URL = "/pdfjs/cmaps/", this.pageNumberRef = et(), this.totalPagesRef = et(), this.zoomLevelRef = et(), this.viewerContainerRef = et(), this.resizer = new ResizeObserver(() => {
      this.pdfViewer && (this.delayedResize && (clearTimeout(this.delayedResize), this.delayedResize = void 0), this.delayedResize = window.setTimeout(() => {
        this.pdfViewer && (this.pdfViewer.currentScaleValue = this.pdfViewer._currentScaleValue);
      }, 100));
    });
  }
  /**
   * Emit `file-preview-loaded` once the viewer has initialized.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  ////////
  /**
   * Open the configured PDF source in the viewer.
   *
   * @internal
   */
  async open() {
    const { pdfjsLib: t } = await this.whenPdfjs;
    if (!this.pdfViewer || !this.pdfHistory || !this.l10n || !this.pdfLinkService)
      return;
    this.pdfLoadingTask && await this.close();
    const e = t.getDocument({
      url: this.src,
      maxImageSize: this.MAX_IMAGE_SIZE,
      enableXfa: this.ENABLE_XFA,
      cMapUrl: this.CMAP_URL?.toString() || "",
      cMapPacked: this.CMAP_PACKED
    });
    this.pdfLoadingTask = e, e.onProgress = (r) => {
    };
    try {
      const r = await e.promise;
      this.pdfDocument = r, this.pdfViewer.setDocument(r), this.pdfLinkService.setDocument(r), this.pdfHistory.initialize({
        // @ts-expect-error Type 'string | null' is not assignable to type 'string'.
        fingerprint: r.fingerprints[0]
      });
    } catch (r) {
      let s = "pdfjs-loading-error";
      r instanceof t.InvalidPDFException ? s = "pdfjs-invalid-file-error" : r instanceof t.MissingPDFException ? s = "pdfjs-missing-file-error" : r instanceof t.UnexpectedResponseException && (s = "pdfjs-unexpected-response-error"), await this.l10n.get(s, void 0, void 0).then((n) => {
        this.pdfViewError(t, n, { message: r?.message });
      });
    }
    this.dispatchLoaded();
  }
  /**
   * Close any currently loaded PDF and release resources.
   *
   * @internal
   */
  async close() {
    if (!this.pdfLoadingTask)
      return Promise.resolve();
    const t = this.pdfLoadingTask.destroy();
    return this.pdfLoadingTask = void 0, this.pdfDocument && (this.pdfDocument = void 0, this.pdfViewer?.setDocument(null), this.pdfLinkService?.setDocument(null, null), this.pdfHistory && this.pdfHistory.reset()), await t;
  }
  /**
   * Log a pdf.js related error with contextual metadata.
   *
   * @internal
   * @param pdfjsLib - pdf.js core library.
   * @param message - Human readable error.
   * @param moreInfo - Additional error metadata.
   */
  pdfViewError(t, e, r) {
    const s = [`PDF.js v${t?.version || "?"} (build: ${t?.build || "?"})`];
    r && (s.push(`Message: ${r.message}`), r.stack ? s.push(`Stack: ${r.stack}`) : (r.filename && s.push(`File: ${r.filename}`), r.lineNumber && s.push(`Line: ${r.lineNumber}`))), console.error(`${e}

${s.join(`
`)}`);
  }
  ///////
  /**
   * Navigate to the provided page number.
   *
   * @param pageNumber - One-based page index.
   */
  setPage(t) {
    this.pdfViewer && (this.pdfViewer.currentPageNumber = t);
  }
  /**
   * Increase zoom level by the configured delta.
   *
   * @param ticks - Number of zoom steps to apply.
   */
  zoomIn(t = 0) {
    if (this.pdfViewer) {
      let e = this.pdfViewer.currentScale;
      do
        e = parseFloat((e * this.DEFAULT_SCALE_DELTA).toFixed(2)), e = Math.ceil(e * 10) / 10, e = Math.min(this.MAX_SCALE, e);
      while (--t && e < this.MAX_SCALE);
      this.pdfViewer.currentScaleValue = e.toFixed(2);
    }
  }
  /**
   * Decrease zoom level by the configured delta.
   *
   * @param ticks - Number of zoom steps to apply.
   */
  zoomOut(t = 0) {
    if (this.pdfViewer) {
      let e = this.pdfViewer.currentScale;
      do
        e = parseFloat((e / this.DEFAULT_SCALE_DELTA).toFixed(2)), e = Math.floor(e * 10) / 10, e = Math.max(this.MIN_SCALE, e);
      while (--t && e > this.MIN_SCALE);
      this.pdfViewer.currentScaleValue = e.toFixed(2);
    }
  }
  /**
   * Apply an absolute zoom level or named scale preset.
   *
   * @param scale - Numeric zoom or preset name.
   */
  setScale(t) {
    this.pdfViewer && (this.pdfViewer.currentScaleValue = typeof t == "number" ? t.toFixed(2) : t);
  }
  /**
   * Validate and update the current page based on the input value.
   */
  updatePage() {
    if (this.pdfViewer && this.pageNumberRef.value) {
      const t = parseInt(this.pageNumberRef.value.value);
      isNaN(t) ? this.setPage(this.pdfViewer.currentPageNumber) : t > this.pdfViewer.pagesCount ? this.setPage(this.pdfViewer.pagesCount) : t <= 0 ? this.setPage(1) : this.setPage(t);
    }
  }
  /**
   * Select all text inside an input, aiding quick replacement.
   *
   * @param e - Input focus event.
   */
  select(t) {
    const e = t.target;
    e && e.setSelectionRange(0, e.value.length);
  }
  /**
   * Fit the PDF to the current viewport height.
   */
  fitToPage() {
    this.setScale("page-fit");
  }
  /**
   * Fit the PDF to the current viewport width.
   */
  fitToWidth() {
    this.setScale("page-width");
  }
  /**
   * Validate and persist zoom level from the input field.
   */
  updateZoom() {
    if (this.pdfViewer && this.zoomLevelRef.value) {
      const t = parseFloat(this.zoomLevelRef.value.value.replace("%", ""));
      isNaN(t) ? this.setScale(this.pdfViewer.currentScale + 1e-4) : this.setScale(t / 100);
    }
  }
  // clearDocument() {
  //   try {
  //     this.loadingTask?.destroy();
  //     //console.debug("loadingTask cleanup", loadingTask)
  //   } catch (e) {
  //     /* No worries */
  //   }
  //   try {
  //     // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  //     // @ts-ignore due to incorrect param type def?
  //     this.pdfViewer?.setDocument(null);
  //   } catch (e) {
  //     /* No worries */
  //   }
  //   try {
  //     this.pdfLinkService.setDocument(null, null);
  //   } catch (e) {
  //     /* No worries */
  //   }
  // }
  async willUpdate(t) {
    super.willUpdate(t), t.has("weavy") && this.weavy && (this.pdfjsLib || (await this.weavy.whenUrl(), this.pdfjsLib = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL("./es/pdfjs-dist/build/pdf.mjs-Bhye_tXX.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
    ), globalThis.pdfjsLib = this.pdfjsLib, this.pdfjsViewer = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL("./es/pdfjs-dist/web/pdf_viewer.mjs-bp-6p92T.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
    ), this.whenPdfjsResolve?.({
      pdfjsLib: this.pdfjsLib,
      pdfjsViewer: this.pdfjsViewer
    })), this.pdfjsLib && !this.WORKER_URL && (this.WORKER_URL = pf(this.DEFAULT_WORKER_URL, import.meta.url), this.WORKER_URL.searchParams.append("v", this.weavy.version), this.pdfjsLib.GlobalWorkerOptions.workerSrc = this.WORKER_URL.toString()), this.CMAP_URL || (this.CMAP_URL = pf(this.DEFAULT_CMAPS_URL, import.meta.url)));
  }
  update(t) {
    super.update(t), (t.has("weavy") || t.has("src") || t.has("pdfViewer")) && this.weavy && this.src && this.pdfViewer && this.open();
  }
  async updated() {
    if (this.weavy && this.viewerContainerRef.value && !this.pdfViewer) {
      const { pdfjsLib: t, pdfjsViewer: e } = await this.whenPdfjs;
      this.viewerContainerRef.value && !this.pdfViewer && (this.pdfEventBus = new e.EventBus(), this.pdfLinkService = new e.PDFLinkService({
        eventBus: this.pdfEventBus
      }), this.l10n = new e.GenericL10n(this.weavy?.locale), this.pdfViewer = new e.PDFViewer({
        container: this.viewerContainerRef.value,
        eventBus: this.pdfEventBus,
        linkService: this.pdfLinkService,
        //findController: this.pdfFindController,
        annotationEditorMode: t.AnnotationEditorType.DISABLE,
        l10n: this.l10n,
        maxCanvasPixels: this.MAX_CANVAS_PIXELS,
        textLayerMode: this.TEXT_LAYER_MODE
      }), this.pdfLinkService?.setViewer(this.pdfViewer), this.pdfHistory = new e.PDFHistory({
        eventBus: this.pdfEventBus,
        linkService: this.pdfLinkService
      }), this.pdfLinkService?.setHistory(this.pdfHistory), this.pdfEventBus?.on("scalechanging", () => {
        this.zoomLevelRef.value && this.pdfViewer ? this.zoomLevelRef.value.value = Math.round(this.pdfViewer.currentScale * 100).toFixed(0) + "%" : console.warn("Could not set zoom level");
      }), this.pdfEventBus?.on("pagechanging", () => {
        this.pageNumberRef.value && this.pdfViewer ? this.pageNumberRef.value.value = this.pdfViewer.currentPageNumber.toFixed(0) : console.warn("Could not set page number");
      }), this.pdfEventBus?.on("pagesinit", () => {
        this.isConnected && this.pdfViewer && this.pageNumberRef.value && this.totalPagesRef.value ? (this.pdfViewer.currentScaleValue = this.DEFAULT_SCALE_VALUE, this.pageNumberRef.value.value = "1", this.totalPagesRef.value.innerText = this.pdfViewer.pagesCount.toFixed(0), this.resizer.observe(this.pdfViewer.container)) : console.warn("Could not init pdf page");
      }));
    }
  }
  render() {
    return h`
      <div class="wy-content-pdf">
        <div part="wy-toolbars-bottom">
          <nav part="wy-toolbar wy-toolbar-center">
            <div part="wy-toolbar-buttons">
              <input
                type="text"
                part="wy-input wy-toolbar-center-text"
                class="wy-pdf-page-number"
                ${j(this.pageNumberRef)}
                @keydown=${Gd}
                @keyup=${Rr}
                @change=${() => this.updatePage()}
                @click=${(t) => this.select(t)}
              />
              <span part="wy-toolbar-text">/</span>
              <span part="wy-toolbar-text" ${j(this.totalPagesRef)}>1</span>
            </div>
            <div part="wy-toolbar-buttons">
              <wy-button kind="icon" class="btn-zoom-out" @click=${() => this.zoomOut()} title=${b("Zoom out")}>
                <wy-icon name="minus"></wy-icon>
              </wy-button>
              <input
                type="text"
                part="wy-input"
                class="wy-pdf-zoom-level"
                ${j(this.zoomLevelRef)}
                @keydown=${Gd}
                @keyup=${Rr}
                @change=${() => this.updateZoom()}
                @click=${(t) => this.select(t)}
                value="100%"
              />
              <wy-button kind="icon" class="btn-zoom-in" @click=${() => this.zoomIn()} title=${b("Zoom in")}>
                <wy-icon name="plus"></wy-icon>
              </wy-button>
            </div>
            <div part="wy-toolbar-buttons">
              <wy-button kind="icon" class="btn-fit-page" @click=${() => this.fitToWidth()} title=${b("Fit to width")}>
                <wy-icon name="fit-width"></wy-icon>
              </wy-button>
              <wy-button kind="icon" @click=${() => this.fitToPage()} title=${b("Fit to screen")}>
                <wy-icon name="fit-screen"></wy-icon>
              </wy-button>
            </div>
          </nav>
        </div>
        <div ${j(this.viewerContainerRef)} class="wy-pdf-container">
          <div class="pdfViewer"></div>
        </div>
      </div>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.pdfViewer && this.resizer.observe(this.pdfViewer.container);
  }
  disconnectedCallback() {
    this.resizer.unobserve(this);
    try {
      this.close(), this.pdfViewer?.cleanup();
    } catch {
    }
    this.pdfViewer = void 0, super.disconnectedCallback();
  }
}, a(yo, "WyPdfViewer"), yo);
As.styles = [
  r4,
  xv,
  jr,
  Z
];
Eh([
  he({ context: re, subscribe: !0 }),
  F()
], As.prototype, "weavy", 2);
Eh([
  p()
], As.prototype, "src", 2);
Eh([
  F()
], As.prototype, "pdfViewer", 2);
As = Eh([
  H("wy-pdf-viewer"),
  ot()
], As);
var a4 = Object.defineProperty, o4 = Object.getOwnPropertyDescriptor, by = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? o4(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && a4(t, e, s), s;
}, "__decorateClass$N"), wo;
let Mc = (wo = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.current = !1;
  }
  /**
   * Emits the `file-preview-loaded` event when the preview has finished loading.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  render() {
    const t = this.file;
    if (!t) return v;
    const { icon: e } = Ur(t.name), r = ii(t.name);
    let s = t.preview_url || t.download_url || "";
    t.preview_format === "image" && (r === ".gif" || r === ".svg") && (s = t.download_url || "");
    const o = s, c = t.external_url, l = t.is_trashed ? "none" : t.preview_format, u = t.name, f = t.width, $ = t.height, m = t.media_type, x = t.provider;
    return l === "image" ? h`<wy-preview-image
        src=${o}
        width=${nt(f)}
        height=${nt($)}
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-image>` : l === "pdf" ? h`<wy-pdf-viewer src=${o} @file-preview-loaded=${() => this.dispatchLoaded()}></wy-pdf-viewer>` : l === "video" || l === "audio" ? h`<wy-preview-media
        format=${l}
        src=${o}
        name=${u}
        mediaType=${m}
        ?play=${this.current}
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-media>` : l === "text" ? h`<wy-preview-text src=${o} @file-preview-loaded=${() => this.dispatchLoaded()}></wy-preview-text>` : l === "code" ? h`<wy-preview-text
        src=${o}
        ?html=${!/^(?:blob:|data:)/.test(o)}
        code
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-text>` : l === "html" ? h`<wy-preview-text
        src=${o}
        html
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-text>` : l === "embed" ? h`<wy-preview-embed
        src=${o}
        name=${u}
        icon=${e}
        provider=${nt(x)}
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-embed>` : l === "none" ? c ? h`<wy-preview-icon
            src=${c}
            icon=${e}
            provider=${nt(x)}
            @file-preview-loaded=${() => this.dispatchLoaded()}
          ></wy-preview-icon>` : h`<wy-preview-icon
            src=${o}
            icon=${e}
            @file-preview-loaded=${() => this.dispatchLoaded()}
          ></wy-preview-icon>` : v;
  }
}, a(wo, "WyPreviewItem"), wo);
Mc.styles = [Z];
by([
  p({ type: Object })
], Mc.prototype, "file", 2);
by([
  p({ type: Boolean })
], Mc.prototype, "current", 2);
Mc = by([
  H("wy-preview-item")
], Mc);
var c4 = Object.defineProperty, l4 = Object.getOwnPropertyDescriptor, ud = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? l4(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && c4(t, e, s), s;
}, "__decorateClass$M"), fo;
let zs = (fo = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.small = !1, this.hasEventListener = {
      "edit-name": !1,
      subscribe: !1,
      trash: !1,
      restore: !1,
      "delete-forever": !1
    };
  }
  addEventListener(t, e, r) {
    if (this.hasEventListener) {
      const s = t;
      Object.prototype.hasOwnProperty.call(this.hasEventListener, s) && Object.assign(this.hasEventListener, {
        [s]: !0
      });
    }
    super.addEventListener(t, e, r);
  }
  /**
   * Open download URL for the current file.
   * @internal
   */
  triggerDownload() {
    this.file && Wi(this.file.download_url, "_top", this.file.name, !0);
  }
  /**
   * Open external provider URL for the current file.
   * @internal
   */
  triggerExternal() {
    this.file && Wi(this.file.external_url, "_blank", this.file.name);
  }
  /**
   * Open application-specific URL for the current file.
   * @internal
   */
  triggerApplication() {
    this.file && Wi(this.file.application_url, "_top", this.file.name);
  }
  /**
   * Emit an `edit-name` event for the current file.
   * @internal
   */
  dispatchEditName() {
    const t = new CustomEvent("edit-name", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `subscribe` event toggling subscription state.
   *
   * @internal
   * @param subscribe - Desired subscription setting.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", {
      detail: {
        file: this.file,
        subscribe: t
      }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `trash` event for the current file.
   * @internal
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `restore` event for the current file.
   * @internal
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `delete-forever` event for the current file.
   * @internal
   */
  dispatchDeleteForever() {
    const t = new CustomEvent("delete-forever", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  render() {
    if (!this.file)
      return v;
    const { icon: t } = Ur(this.file.name), e = this.file.id >= 1, r = this.file.provider, s = this.file.provider || "app";
    return h`
      <wy-dropdown directionX="left" ?small=${this.small}>
        ${e && this.file.is_trashed ? h`
              ${this.hasEventListener.restore ? h`
                    <wy-dropdown-item @click=${() => this.dispatchRestore()}>
                      <wy-icon name="delete-restore"></wy-icon>
                      ${b("Restore")}
                    </wy-dropdown-item>
                  ` : v}
              ${this.hasEventListener.restore && this.hasEventListener["delete-forever"] ? h` <wy-dropdown-divider></wy-dropdown-divider> ` : v}
              ${this.hasEventListener["delete-forever"] ? h`
                    <wy-dropdown-item @click=${() => this.dispatchDeleteForever()}>
                      <wy-icon name="delete-forever"></wy-icon>
                      ${b("Delete")}
                    </wy-dropdown-item>
                  ` : v}
            ` : v}
        ${this.file.is_trashed ? v : h`
              ${this.file.external_url ? h`
                    <wy-dropdown-item @click=${() => this.triggerExternal()}>
                      <wy-icon name=${t}></wy-icon>
                      ${b(ut`Open in ${r}`)}
                    </wy-dropdown-item>
                  ` : h`
                    ${this.componentFeatures?.allowsFeature(M.WebDAV) && this.file.application_url ? h`
                          <wy-dropdown-item @click=${() => this.triggerApplication()}>
                            <wy-icon
                              name=${this.file.provider ? Vf(this.file.provider) : t}
                            ></wy-icon>
                            ${b(ut`Open in ${s}`)}
                          </wy-dropdown-item>
                        ` : v}
                    <wy-dropdown-item @click=${() => this.triggerDownload()}>
                      <wy-icon name="download"></wy-icon>
                      ${b("Download")}
                    </wy-dropdown-item>
                  `}
              ${e ? h`
                    ${this.hasEventListener["edit-name"] ? h`
                          <wy-dropdown-item @click=${() => this.dispatchEditName()}>
                            <wy-icon name="textbox"></wy-icon>
                            ${b("Rename")}
                          </wy-dropdown-item>
                        ` : v}
                    ${this.hasEventListener.subscribe ? this.file.is_subscribed ? h`
                            <wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                              <wy-icon name="bell-off"></wy-icon>
                              ${b("Unsubscribe")}
                            </wy-dropdown-item>
                          ` : h`
                            <wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                              <wy-icon name="bell"></wy-icon>
                              ${b("Subscribe")}
                            </wy-dropdown-item>
                          ` : v}
                    ${this.hasEventListener.trash ? h`
                          <wy-dropdown-divider></wy-dropdown-divider>
                          <wy-dropdown-item @click=${() => this.dispatchTrash()}>
                            <wy-icon name="delete"></wy-icon>
                            ${b("Trash")}
                          </wy-dropdown-item>
                        ` : v}
                  ` : v}
            `}
        <slot></slot>
      </wy-dropdown>
    `;
  }
}, a(fo, "WyFileMenu"), fo);
ud([
  he({ context: ph, subscribe: !0 }),
  F()
], zs.prototype, "componentFeatures", 2);
ud([
  p({ type: Object })
], zs.prototype, "file", 2);
ud([
  p({ type: Boolean })
], zs.prototype, "small", 2);
ud([
  p({ type: Object })
], zs.prototype, "hasEventListener", 2);
zs = ud([
  H("wy-file-menu"),
  ot()
], zs);
function d4(i, t, e, r = {}) {
  return {
    ...r,
    initialPageParam: 0,
    queryKey: [t, e, "comments"],
    queryFn: /* @__PURE__ */ a(async (s) => {
      const n = s.pageParam, o = "/api/" + t + "/" + e + "/comments?order_by=id&skip=" + n, l = await (await i.fetch(o)).json();
      return l.data = l.data || [], l;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ a((s) => {
      if (s.end && s.end < s.count)
        return s.end;
    }, "getNextPageParam")
  };
}
a(d4, "getCommentsOptions");
function h4(i, t) {
  return {
    mutationFn: /* @__PURE__ */ a(async (r) => await (await i.fetch("/api/comments/" + r.id, {
      method: "PATCH",
      body: JSON.stringify({
        text: r.text,
        blobs: r.blobs,
        attachments: r.attachments,
        meeting_id: r.meeting_id,
        options: r.poll_options.filter((n) => n.text.trim() !== "").map((n) => ({ id: n.id, text: n.text })),
        embed_id: r.embed_id || null
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onSuccess: /* @__PURE__ */ a((r, s) => {
      s.id && qt(i.queryClient, [s.type, s.parent_id, "comments"], s.id, (n) => {
        n.text = r.text, n.html = r.html, n.attachments = r.attachments, n.meeting = r.meeting, n.updated_at = r.updated_at, n.updated_by = r.updated_by, n.options = r.options, n.embed = r.embed;
      });
    }, "onSuccess")
  };
}
a(h4, "getUpdateCommentMutationOptions");
function p4(i) {
  const t = i.queryClient;
  return {
    mutationFn: /* @__PURE__ */ a(async (r) => await (await i.fetch("/api/" + r.type + "/" + r.parent_id + "/comments", {
      method: "POST",
      body: JSON.stringify({
        text: r.text,
        blobs: r.blobs,
        meeting_id: r.meeting_id,
        options: r.poll_options.filter((n) => n.text.trim() !== "").map((n) => ({ text: n.text })),
        embed_id: r.embed_id,
        context: r.context
      })
    })).json(), "mutationFn"),
    onMutate: /* @__PURE__ */ a(async (r) => {
      const s = [r.type, r.parent_id, "comments"];
      await t.cancelQueries({ queryKey: s });
      const n = gs(i.queryClient, s, !1);
      if (r.user) {
        const o = {
          id: n ? n.id - 1 : -1,
          app: r.type === "apps" ? { id: r.parent_id } : { id: -1 },
          is_trashed: !1,
          text: r.text,
          html: r.text,
          plain: r.text,
          created_by: r.user,
          created_at: (/* @__PURE__ */ new Date()).toUTCString(),
          attachments: { count: 0 },
          reactions: { count: 0 },
          is_subscribed: !1,
          is_starred: !1
        };
        r.type === "files" ? o.parent = { type: ve.File, id: r.parent_id } : r.type === "posts" && (o.parent = { type: ve.Post, id: r.parent_id }), Ar(t, s, o, { descending: !1 });
      }
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((r, s) => {
      const n = [s.type, r.parent?.id ?? r.app.id, "comments"];
      if (!mh(i.queryClient, n, r.id)) {
        const c = gs(i.queryClient, n, !0);
        c ? qt(i.queryClient, n, c.id, (l) => {
          l.id = r.id, l.app = r.app, l.text = r.text, l.html = r.html, l.embed = r.embed, l.meeting = r.meeting, l.attachments = r.attachments, l.options = r.options, l.created_at = r.created_at, l.created_by = r.created_by, l.updated_at = r.updated_at, l.updated_by = r.updated_by;
        }) : Ar(i.queryClient, n, r), r.parent?.type === ve.Post && qt(t, ["posts", r.app.id], r.parent.id, (l) => {
          l.comments ? l.comments.count += 1 : l.comments = { count: 1 };
        });
      }
    }, "onSuccess")
  };
}
a(p4, "getAddCommentMutationOptions");
function u4(i, t, e) {
  const r = i.queryClient, n = {
    mutationKey: [t, e, "comments"],
    mutationFn: /* @__PURE__ */ a(async ({ id: o }) => {
      if (!(await i.fetch("/api/comments/" + o + "/trash", { method: "POST" })).ok)
        throw new Error();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((o) => {
      ct(
        r,
        { queryKey: n.mutationKey, exact: !1 },
        o.id,
        (c) => Object.assign(c, { is_trashed: !0 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((o, c) => {
      ct(
        r,
        { queryKey: n.mutationKey, exact: !1 },
        c.id,
        (l) => Object.assign(l, o)
      ), qt(r, [c.type, c.appId], c.parentId, (l) => {
        l.comments.count -= 1;
      });
    }, "onSuccess")
  };
  return n;
}
a(u4, "getTrashCommentMutationOptions");
function y4(i, t, e) {
  return new $t(i.queryClient, u4(i, t, e));
}
a(y4, "getTrashCommentMutation");
function w4(i, t, e) {
  const r = i.queryClient, n = {
    mutationKey: [t, e, "comments"],
    mutationFn: /* @__PURE__ */ a(async ({ id: o }) => {
      const c = await i.fetch("/api/comments/" + o + "/restore", { method: "POST" });
      if (!c.ok) {
        const l = await c.json();
        throw new Error(l.detail || l.title, { cause: l });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((o) => {
      ct(
        r,
        { queryKey: n.mutationKey, exact: !1 },
        o.id,
        (c) => Object.assign(c, { is_trashed: !1 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((o, c) => {
      ct(
        r,
        { queryKey: n.mutationKey, exact: !1 },
        c.id,
        (l) => Object.assign(l, o)
      ), qt(r, [c.type, c.appId], c.parentId, (l) => {
        l.comments.count += 1;
      });
    }, "onSuccess")
  };
  return n;
}
a(w4, "getRestoreCommentMutationOptions");
function f4(i, t, e) {
  return new $t(i.queryClient, w4(i, t, e));
}
a(f4, "getRestoreCommentMutation");
const xy = B`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}:host(wy-comments){--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-border-radius: var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-comment-list-padded]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-comments]{display:flex;flex-direction:column}[part~=wy-comment]{display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));margin-bottom:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-comment][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-comment-reveal]{interpolate-size:allow-keywords;overflow:hidden;transition:height var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),margin-bottom var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-duration-fast, .1s);height:auto;opacity:1}@starting-style{[part~=wy-comment-reveal]{height:0;margin-bottom:0;opacity:0}}[part~=wy-comment-skeleton]{transition-delay:var(--wy-transition-reveal-delay, 1s)}[part~=wy-comment-body]{display:flex;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));min-width:0;flex:1 1 100%}[part~=wy-comment-footer]{margin-left:calc(-1*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));margin-top:calc(-1*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}::part(wy-trashed){text-decoration:line-through;color:var(--wy-outline, var(--wy-outline-light, #72777f))}wy-comment::part(wy-editor){padding-left:0;padding-right:0;margin-right:calc(-1*var(--wy-size, 1rem))}`, m4 = 1e3 * 60 * 60, Fp = m4 * 24;
function Wc(i, t, e, r = 7) {
  e ??= /* @__PURE__ */ new Date();
  const s = new Date(e.getFullYear(), e.getMonth(), e.getDate()), n = t.valueOf() - e.valueOf(), o = t.toDateString() === e.toDateString(), c = t.valueOf() > s.valueOf() - Fp * r && t.valueOf() < s.valueOf() + Fp * r;
  if (!o && c) {
    const l = Math.round(n / Fp);
    return new Intl.RelativeTimeFormat(i, { numeric: "auto" }).format(l, "days");
  } else return o ? new Intl.DateTimeFormat(i, { timeStyle: "short" }).format(t) : new Intl.DateTimeFormat(i, { dateStyle: "short" }).format(t);
}
a(Wc, "relativeTime");
const $v = B`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}`;
var v4 = Object.defineProperty, g4 = Object.getOwnPropertyDescriptor, Ws = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? g4(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && v4(t, e, s), s;
}, "__decorateClass$L"), mo;
let Mi = (mo = class extends Rt {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.location = "apps", this.highlight = !1, this.reveal = !1, this.editing = !1, this.previewAnnotationsRef = et(), this.previewAttachmentsRef = et(), this.highlightRef = et(), this.updateCommentMutation = new We(this);
  }
  /**
   * Dispatch a poll vote event for this comment.
   *
   * @internal
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", {
      detail: { optionId: t, parentId: this.comment.id, parentType: "comments" }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Dispatch a trash event for this comment.
   *
   * @internal
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.comment.id } });
    return this.dispatchEvent(t);
  }
  /**
   * Dispatch a restore event for this comment.
   *
   * @internal
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", {
      detail: { id: this.comment.id }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Submit updated comment content via mutation and exit edit mode.
   *
   * @internal
   */
  updateComment(t) {
    this.updateCommentMutation.mutate({
      id: this.comment.id,
      type: this.location,
      parent_id: this.parentId,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      attachments: t.detail.attachments,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId
    }), this.editing = !1;
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("parentId") || t.has("weavy")) && this.parentId && this.weavy && await this.updateCommentMutation.trackMutation(
      h4(this.weavy, [this.location, this.parentId, "comments"])
    ), t.has("link") && (this.highlight = !!(this.link && Mh(this.link, ve.Comment, { id: this.comment.id }))), t.has("highlight") && (this.highlight ? this.part.add("wy-highlight") : this.part.remove("wy-highlight"));
  }
  render() {
    const t = this.comment.attachments?.data?.filter((o) => o.kind === "image" && o.thumbnail_url) || [], e = this.comment.attachments?.data?.filter((o) => o.kind !== "image" || !o.thumbnail_url) || [], r = new Intl.DateTimeFormat(this.weavy?.locale, {
      dateStyle: "full",
      timeStyle: "short"
    }).format(new Date(this.comment.created_at)), s = Wc(this.weavy?.locale, new Date(this.comment.created_at)), n = this.comment.id < 0;
    return h`
      <div part="wy-comment ${K({ "wy-comment-reveal": this.reveal, "wy-comment-skeleton": n })}">
        ${n ? h`
              <wy-item align="top" part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src="${this.comment.created_by.avatar_url}"
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>
                <div slot="content" part="wy-comment-body">
                  <div part="wy-comment-title">
                    ${this.comment.created_by.name}
                    <small part="wy-meta">
                      ·
                      <time datetime=${this.comment.created_at} title=${r}>${s}</time>
                      ${this.comment.updated_at ? h`<time datetime=${this.comment.updated_at}> · ${b("edited")}</time>` : v}
                    </small>
                  </div>
                  ${this.comment.html ? h`<div part="wy-content"><wy-skeleton .text=${this.comment.text}></wy-skeleton></div>` : ""}
                </div>
              </wy-item>
            ` : this.comment.is_trashed ? h`
              <wy-item part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src="${this.comment.created_by.avatar_url}"
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>
                <span part="wy-trashed" slot="title">${b("Comment was trashed.")}</span>
                <wy-button small slot="actions" @click=${() => this.dispatchRestore()} color="variant"
                  >${b("Undo")}</wy-button
                >
              </wy-item>
            ` : this.editing ? h`
              <wy-item align="top" part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src="${this.comment.created_by.avatar_url}"
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>
                <wy-button small slot="actions" @click=${() => this.editing = !1} kind="icon">
                  <wy-icon name="close"></wy-icon>
                </wy-button>
                <div slot="content" part="wy-comment-body">
                  <div part="wy-comment-title">
                    ${this.comment.created_by.name}

                    <small part="wy-meta">
                      ·
                      <time datetime=${this.comment.created_at} title=${r}>${s}</time>
                    </small>
                  </div>
                  <wy-editor
                    editorLocation=${this.location}
                    .text=${this.comment.text}
                    .embed=${this.comment.embed}
                    .options=${this.comment.options?.data}
                    .attachments=${this.comment.attachments?.data ?? []}
                    .parentId=${this.comment.id}
                    .typing=${!1}
                    .draft=${!1}
                    placeholder=${b("Edit comment...")}
                    buttonText=${b("Update", { desc: "Button action to update" })}
                    @submit=${(o) => this.updateComment(o)}
                  ></wy-editor>
                </div>
              </wy-item>
            ` : h`
              <wy-item align="top" part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src=${this.comment.created_by.avatar_url}
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>

                ${this.user && this.user.id === this.comment.created_by.id ? h`
                      <wy-dropdown small slot="actions">
                        ${this.user.id === this.comment.created_by.id ? h`
                              <wy-dropdown-item @click=${() => this.editing = !0}>
                                <wy-icon name="pencil"></wy-icon>
                                ${b("Edit")}
                              </wy-dropdown-item>
                            ` : v}
                        ${this.user.id === this.comment.created_by.id ? h`
                              <wy-dropdown-item @click=${() => this.dispatchTrash()}>
                                <wy-icon name="trashcan"></wy-icon>
                                ${b("Trash")}
                              </wy-dropdown-item>
                            ` : v}
                      </wy-dropdown>
                    ` : v}

                <div slot="content" part="wy-comment-body">
                  <div part="wy-comment-title">
                    ${this.comment.created_by.name}
                    <small part="wy-meta">
                      ·
                      <time datetime=${this.comment.created_at} title=${r}>${s}</time>
                      ${this.comment.updated_at ? h`<time datetime=${this.comment.updated_at}> · ${b("edited")}</time>` : v}
                    </small>
                  </div>

                  <!-- image grid -->
                  ${t && t.length ? h`<wy-image-grid
                        part="wy-comment-images"
                        .images=${t}
                        @file-open=${(o) => {
      this.previewAttachmentsRef.value?.open(o.detail.fileId);
    }}
                      ></wy-image-grid>` : ""}

                  <!-- text content -->
                  ${this.comment.html ? h`<div part="wy-content">${bs(this.comment.html)}</div>` : ""}

                  <!-- annotations -->
                  ${this.comment.annotations?.data?.length ? h`<wy-annotation-list
                        .files=${this.comment.annotations.data}
                        @file-open=${(o) => {
      this.previewAnnotationsRef.value?.open(o.detail.fileId);
    }}
                      ></wy-annotation-list>` : v}

                  <!-- poll -->
                  ${this.comment.options?.data?.length ? h`
                        <wy-poll
                          .pollOptions=${this.comment.options.data}
                          @vote=${(o) => this.dispatchVote(o.detail.optionId)}
                        ></wy-poll>
                      ` : v}

                  <!-- embeds -->
                  ${this.comment.embed && this.componentFeatures?.allowsFeature(M.Embeds) ? h` <wy-embed .embed=${this.comment.embed}></wy-embed> ` : v}

                  <!-- files -->
                  ${e.length ? h`<wy-attachment-list
                        filled
                        .files=${e ?? []}
                        @file-open=${(o) => {
      this.previewAttachmentsRef.value?.open(o.detail.fileId);
    }}
                      ></wy-attachment-list>` : ""}

                  <!-- meeting -->
                  ${this.comment.meeting ? h`<wy-meeting-card .meeting=${this.comment.meeting}></wy-meeting-card>` : ""}

                  <div part="wy-comment-footer">
                    ${this.componentFeatures?.allowsFeature(M.Reactions) ? h` <wy-reactions
                          lineReverse
                          small
                          .reactions=${this.comment.reactions?.data}
                          parentType=${this.location}
                          parentId=${this.parentId}
                          entityId=${this.comment.id}
                          entityType="comments"
                        ></wy-reactions>` : v}
                    ${this.comment.annotations?.data?.length ? h`<wy-preview
                          ${j(this.previewAnnotationsRef)}
                          .files=${this.comment.annotations.data}
                          .isAttachment=${!0}
                        ></wy-preview> ` : v}
                    ${this.comment.attachments?.data?.length ? h`<wy-preview
                          ${j(this.previewAttachmentsRef)}
                          .files=${[...t, ...e]}
                          .isAttachment=${!0}
                        ></wy-preview> ` : v}
                  </div>
                </div>
              </wy-item>
            `}
      </div>
    `;
  }
  updated(t) {
    t.has("highlight") && this.highlight && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, a(mo, "WyComment"), mo);
Mi.styles = [zt, xy, Uc, $v, wy, Z];
Ws([
  p({ type: Object, attribute: !1 })
], Mi.prototype, "comment", 2);
Ws([
  p({ type: Number })
], Mi.prototype, "parentId", 2);
Ws([
  p({ attribute: !1 })
], Mi.prototype, "location", 2);
Ws([
  F()
], Mi.prototype, "highlight", 2);
Ws([
  p({ type: Boolean, reflect: !0 })
], Mi.prototype, "reveal", 2);
Ws([
  F()
], Mi.prototype, "editing", 2);
Mi = Ws([
  H("wy-comment"),
  ot()
], Mi);
const b4 = B`[part~=wy-comment-editor]{position:relative;border-radius:var(--wy-padding-outer, var(--wy-padding, 0))}[part~=wy-comment-editor-bottom]{position:sticky;bottom:0;z-index:999;background-color:var(--wy-component-background-color);padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-radius:var(--wy-component-border-radius);color:var(--wy-component-color)}[part~=wy-comment-editor-inputs]{display:flex;flex-direction:row;align-items:flex-end;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-comment-editor-text]{flex:1 1 100%;display:flex;flex-direction:column}[part~=wy-editor-parts]{padding-top:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));min-height:0}[part~=wy-comment-editor] .cm-editor{flex:1 1 100%;max-height:calc(11.25*var(--wy-size, 1rem));background-color:var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:calc(1.25*var(--wy-size, 1rem));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid rgba(0,0,0,0);margin:calc(-1*var(--wy-input-border-width, var(--wy-border, 1px)))}[part~=wy-comment-editor] .cm-editor:focus{border-color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-comment-editor] .cm-editor .cm-content{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-comment-editor] [part~=wy-is-invalid]+.cm-editor,[part~=wy-comment-editor] [part~=wy-is-invalid] .cm-editor{border-color:var(--wy-error, var(--wy-error-light, #ba1821))!important}`;
var Dp, wf;
function x4() {
  if (wf) return Dp;
  wf = 1;
  var i = "Expected a function", t = NaN, e = "[object Symbol]", r = /^\s+|\s+$/g, s = /^[-+]0x[0-9a-f]+$/i, n = /^0b[01]+$/i, o = /^0o[0-7]+$/i, c = parseInt, l = typeof _d == "object" && _d && _d.Object === Object && _d, u = typeof self == "object" && self && self.Object === Object && self, f = l || u || Function("return this")(), $ = Object.prototype, m = $.toString, x = Math.max, g = Math.min, S = /* @__PURE__ */ a(function() {
    return f.Date.now();
  }, "now");
  function I(V, N, Y) {
    var it, J, Pt, Mt, wt, pt, Ot = 0, pe = !1, kt = !1, ft = !0;
    if (typeof V != "function")
      throw new TypeError(i);
    N = R(N) || 0, E(Y) && (pe = !!Y.leading, kt = "maxWait" in Y, Pt = kt ? x(R(Y.maxWait) || 0, N) : Pt, ft = "trailing" in Y ? !!Y.trailing : ft);
    function Gt(mt) {
      var ze = it, Ct = J;
      return it = J = void 0, Ot = mt, Mt = V.apply(Ct, ze), Mt;
    }
    a(Gt, "invokeFunc");
    function rt(mt) {
      return Ot = mt, wt = setTimeout(qe, N), pe ? Gt(mt) : Mt;
    }
    a(rt, "leadingEdge");
    function gt(mt) {
      var ze = mt - pt, Ct = mt - Ot, Zt = N - ze;
      return kt ? g(Zt, Pt - Ct) : Zt;
    }
    a(gt, "remainingWait");
    function ri(mt) {
      var ze = mt - pt, Ct = mt - Ot;
      return pt === void 0 || ze >= N || ze < 0 || kt && Ct >= Pt;
    }
    a(ri, "shouldInvoke");
    function qe() {
      var mt = S();
      if (ri(mt))
        return Li(mt);
      wt = setTimeout(qe, gt(mt));
    }
    a(qe, "timerExpired");
    function Li(mt) {
      return wt = void 0, ft && it ? Gt(mt) : (it = J = void 0, Mt);
    }
    a(Li, "trailingEdge");
    function Oi() {
      wt !== void 0 && clearTimeout(wt), Ot = 0, it = pt = J = wt = void 0;
    }
    a(Oi, "cancel");
    function Xc() {
      return wt === void 0 ? Mt : Li(S());
    }
    a(Xc, "flush");
    function ui() {
      var mt = S(), ze = ri(mt);
      if (it = arguments, J = this, pt = mt, ze) {
        if (wt === void 0)
          return rt(pt);
        if (kt)
          return wt = setTimeout(qe, N), Gt(pt);
      }
      return wt === void 0 && (wt = setTimeout(qe, N)), Mt;
    }
    return a(ui, "debounced"), ui.cancel = Oi, ui.flush = Xc, ui;
  }
  a(I, "debounce");
  function A(V, N, Y) {
    var it = !0, J = !0;
    if (typeof V != "function")
      throw new TypeError(i);
    return E(Y) && (it = "leading" in Y ? !!Y.leading : it, J = "trailing" in Y ? !!Y.trailing : J), I(V, N, {
      leading: it,
      maxWait: N,
      trailing: J
    });
  }
  a(A, "throttle");
  function E(V) {
    var N = typeof V;
    return !!V && (N == "object" || N == "function");
  }
  a(E, "isObject");
  function T(V) {
    return !!V && typeof V == "object";
  }
  a(T, "isObjectLike");
  function q(V) {
    return typeof V == "symbol" || T(V) && m.call(V) == e;
  }
  a(q, "isSymbol");
  function R(V) {
    if (typeof V == "number")
      return V;
    if (q(V))
      return t;
    if (E(V)) {
      var N = typeof V.valueOf == "function" ? V.valueOf() : V;
      V = E(N) ? N + "" : N;
    }
    if (typeof V != "string")
      return V === 0 ? V : +V;
    V = V.replace(r, "");
    var Y = n.test(V);
    return Y || o.test(V) ? c(V.slice(2), Y ? 2 : 8) : s.test(V) ? t : +V;
  }
  return a(R, "toNumber"), Dp = A, Dp;
}
a(x4, "requireLodash_throttle");
var $4 = x4();
const Lu = /* @__PURE__ */ k1($4);
function C4(i, t) {
  return new $t(i.queryClient, {
    mutationFn: /* @__PURE__ */ a(async () => await i.fetch(`/api/apps/${t}/typing`, {
      method: "PUT",
      body: JSON.stringify({})
    }), "mutationFn")
  });
}
a(C4, "typingMutation");
function ff(i, t) {
  return new $t(i.queryClient, {
    mutationFn: /* @__PURE__ */ a(async () => {
      const e = await i.fetch(`/x/${t}/meetings`, { method: "POST" });
      if (!e.ok)
        throw new Error("Failed to create meeting");
      return await e.json();
    }, "mutationFn")
  });
}
a(ff, "addMeetingMutation");
async function k4(i, t) {
  const e = await i.fetch("/api/blobs/external", { method: "POST", body: JSON.stringify(t) });
  if (!e.ok) {
    const s = await e.json();
    throw new Error(s.detail || s.title, { cause: s });
  }
  return await e.json();
}
a(k4, "externalBlob");
function _4(i, t, e, r) {
  const s = i.queryClient, n = ["apps", e, "blobs", r];
  return {
    mutationFn: /* @__PURE__ */ a(async (c) => await k4(i, c.externalBlob), "mutationFn"),
    mutationKey: n,
    onMutate: /* @__PURE__ */ a(async (c) => (await s.cancelQueries({ queryKey: n, exact: !0 }), { type: "attach", file: Xu(void 0, c.externalBlob.name, c.externalBlob.size, void 0, t), status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ a((c, l, u) => {
      Ft(s, n, l, (f) => {
        f.status.state = "ok", f.status.progress = void 0, f.status.text = void 0;
      });
    }, "onSuccess"),
    onError(c, l, u) {
      const f = c.cause;
      f && f.status === 409 ? Ft(s, n, l, ($) => {
        $.status.state = "conflict", $.status.progress = void 0, $.status.text = f.detail || f.title;
      }) : Ft(s, n, l, ($) => {
        $ && ($.status.state = "error", $.status.progress = void 0, $.status.text = f.detail || f.title);
      });
    }
  };
}
a(_4, "getExternalBlobMutationOptions");
function Cv(i, t, e, r) {
  return new $t(i.queryClient, _4(i, t, e, r));
}
a(Cv, "getExternalBlobMutation");
const P4 = /(((https?|ftp):\/\/|(www|ftp)\.)[\w]+(.[\w]+)([\w\-.,@?^=%&amp;:/~+#]*[\w\-@?^=%&amp;/~+#]))/gim;
let tn = [], zl = [], ih = [], Ed = [], Ni = {};
const M4 = /* @__PURE__ */ a((i, t) => i.length === t.length && i.every((e, r) => e === t[r]), "arrayEquals");
function S4() {
  return !!Object.keys(Ni).length;
}
a(S4, "isFetchingEmbeds");
async function A4(i, t) {
  let e;
  try {
    const r = await t.fetch(`/api/embeds?url=${encodeURIComponent(i)}`);
    if (!r.ok)
      throw new Error();
    e = await r.json(), delete Ni[i], zl = [...zl, i];
  } catch {
    ih = [...ih, i], delete Ni[i];
  }
  return e;
}
a(A4, "fetchEmbed");
const z4 = /* @__PURE__ */ a(() => {
  tn = [], zl = [], ih = [], Ed = [], Ni = {};
}, "clearEmbeds"), mf = /* @__PURE__ */ a((i) => {
  zl = i;
}, "initEmbeds"), R4 = /* @__PURE__ */ a((i, t, e) => {
  let r = i.match(P4)?.map((s) => s) || null;
  if (r !== null && (r = r.map((s) => s.startsWith("//") ? "http:" + s : !s.startsWith("http://") && !s.startsWith("https://") ? "http://" + s : s)), !(r === null || r.length === 0)) {
    if (r.length !== tn.length || !M4(r, tn)) {
      tn = r, r.forEach((s) => {
        !zl.includes(s) && !ih.includes(s) && !Ed.includes(s) && typeof Ni[s] > "u" && (we(), Ni[s] = window.setTimeout(async () => {
          const n = await A4(s, e);
          n && t(n);
        }, 500));
      }), Ed = Ed.filter((s) => tn.includes(s));
      for (const s in Ni)
        tn.includes(s) || (we(), window.clearTimeout(Ni[s]), delete Ni[s]);
    }
  }
}, "getEmbeds"), Xe = Vu() ? window.navigator.userAgent : "", kv = Xe.includes("iPad") || Xe.includes("Android") && !Xe.includes("Mobi") || !1, E4 = Xe.includes("Mobi") || kv || !1, L4 = !E4 && !kv, vf = Xe.includes("Windows") ? "Windows" : Xe.includes("Macintosh") ? "Mac" : Xe.includes("iPad") || Xe.includes("iPhone") || Xe.includes("iPod") ? "iOS" : Xe.includes("Android") ? "Android" : void 0;
vf === "Android" && Xe.includes("; wv") || vf === "iOS" && Xe.includes("Safari");
const O4 = B`[part~=wy-scroll-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x-y]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;overflow-x:auto;touch-action:pan-y,pan-x}[part~=wy-scroll-x-always],[part~=wy-scroll-y-always]{overflow-y:scroll}[part~=wy-code] pre,.wy-code pre,[part~=wy-editor] .cm-content pre{text-wrap:pretty}[part~=wy-code] .code,[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code .code,.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content .code,[part~=wy-editor] .cm-content code[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;word-wrap:break-word;line-height:1.25;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}@media print{[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content code[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{text-shadow:none}}[part~=wy-code] pre[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}[part~=wy-code] :not(pre)>code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code :not(pre)>code[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content :not(pre)>code[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));background:var(--wy-background, var(--wy-background-light, #f7f9ff))}[part~=wy-code] :not(pre)>code[class*=language-],.wy-code :not(pre)>code[class*=language-],[part~=wy-editor] .cm-content :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}[part~=wy-code] .token.variable,.wy-code .token.variable,[part~=wy-editor] .cm-content .token.variable{color:var(--wy-code-variable, var(--wy-code-variable-light, #001080))}[part~=wy-code] .token.operator,.wy-code .token.operator,[part~=wy-editor] .cm-content .token.operator{color:var(--wy-code-operator, var(--wy-code-operator-light, #000000))}[part~=wy-code] .token.prolog,.wy-code .token.prolog,[part~=wy-editor] .cm-content .token.prolog{color:var(--wy-code-prolog, var(--wy-code-prolog-light, #000080))}[part~=wy-code] .token.comment,.wy-code .token.comment,[part~=wy-editor] .cm-content .token.comment{color:var(--wy-code-comment, var(--wy-code-comment-light, #008000))}[part~=wy-code] .token.builtin,.wy-code .token.builtin,[part~=wy-editor] .cm-content .token.builtin{color:var(--wy-code-builtin, var(--wy-code-builtin-light, #0070C1))}[part~=wy-code] .token.number,.wy-code .token.number,[part~=wy-editor] .cm-content .token.number{color:var(--wy-code-number, var(--wy-code-number-light, #098658))}[part~=wy-code] .token.inserted,.wy-code .token.inserted,[part~=wy-editor] .cm-content .token.inserted{color:var(--wy-code-inserted, var(--wy-code-inserted-light, #098658))}[part~=wy-code] .token.constant,.wy-code .token.constant,[part~=wy-editor] .cm-content .token.constant{color:var(--wy-code-constant, var(--wy-code-constant-light, #811F3F))}[part~=wy-code] .token.hexcode,.wy-code .token.hexcode,[part~=wy-editor] .cm-content .token.hexcode{color:var(--wy-code-hexcode, var(--wy-code-hexcode-light, #811F3F))}[part~=wy-code] .token.regex,.wy-code .token.regex,[part~=wy-editor] .cm-content .token.regex{color:var(--wy-code-regex, var(--wy-code-regex-light, #811F3F))}[part~=wy-code] .token.char,.wy-code .token.char,[part~=wy-editor] .cm-content .token.char{color:var(--wy-code-char, var(--wy-code-char-light, #811F3F))}[part~=wy-code] .token.tag,.wy-code .token.tag,[part~=wy-editor] .cm-content .token.tag{color:var(--wy-code-tag, var(--wy-code-tag-light, #800000))}[part~=wy-code] .token.attr-name,.wy-code .token.attr-name,[part~=wy-editor] .cm-content .token.attr-name{color:var(--wy-code-attr-name, var(--wy-code-attr-name-light, #E50000))}[part~=wy-code] .token.selector,.wy-code .token.selector,[part~=wy-editor] .cm-content .token.selector{color:var(--wy-code-selector, var(--wy-code-selector-light, #E50000))}[part~=wy-code] .token.property,.wy-code .token.property,[part~=wy-editor] .cm-content .token.property{color:var(--wy-code-property, var(--wy-code-property-light, #E50000))}[part~=wy-code] .token.deleted,.wy-code .token.deleted,[part~=wy-editor] .cm-content .token.deleted{color:var(--wy-code-deleted, var(--wy-code-deleted-light, #A31515))}[part~=wy-code] .token.string,.wy-code .token.string,[part~=wy-editor] .cm-content .token.string{color:var(--wy-code-string, var(--wy-code-string-light, #A31515))}[part~=wy-code] .token.changed,.wy-code .token.changed,[part~=wy-editor] .cm-content .token.changed{color:var(--wy-code-changed, var(--wy-code-changed-light, #0451A5))}[part~=wy-code] .token.punctuation,.wy-code .token.punctuation,[part~=wy-editor] .cm-content .token.punctuation{color:var(--wy-code-punctuation, var(--wy-code-punctuation-light, #000000))}[part~=wy-code] .token.function,.wy-code .token.function,[part~=wy-editor] .cm-content .token.function{color:var(--wy-code-function, var(--wy-code-function-light, #0000FF))}[part~=wy-code] .token.keyword,.wy-code .token.keyword,[part~=wy-editor] .cm-content .token.keyword{color:var(--wy-code-keyword, var(--wy-code-keyword-light, #AF00DB))}[part~=wy-code] .token.class-name,.wy-code .token.class-name,[part~=wy-editor] .cm-content .token.class-name{color:var(--wy-code-class-name, var(--wy-code-class-name-light, #267F99))}[part~=wy-code] .token.important,[part~=wy-code] .token.bold,.wy-code .token.important,.wy-code .token.bold,[part~=wy-editor] .cm-content .token.important,[part~=wy-editor] .cm-content .token.bold{font-weight:700}[part~=wy-code] .token.italic,.wy-code .token.italic,[part~=wy-editor] .cm-content .token.italic{font-style:italic}[part~=wy-editor]{box-sizing:border-box}[part~=wy-editor] .cm-scroller{font-family:unset;line-height:1.5}[part~=wy-editor] .cm-widgetBuffer{vertical-align:unset}[part~=wy-editor] .cm-placeholder{pointer-events:none;color:var(--wy-outline, var(--wy-outline-light, #72777f))}[part~=wy-editor] .cm-content{caret-color:var(--wy-on-background, var(--wy-on-background-light, #181c20))}[part~=wy-editor] .cm-content ::part(wy-link){text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-light, #2f628c))}[part~=wy-editor] .wy-mention{font-weight:700}[part~=wy-editor] .cm-editor{box-sizing:border-box;flex-direction:column;position:relative!important;display:flex!important}[part~=wy-editor] .cm-editor.cm-focused{--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));color:var(--wy-component-color);border-color:var(--wy-primary, var(--wy-primary-light, #2f628c));outline:0}[part~=wy-editor] .cm-editor .cm-scroller{overflow:auto}[part~=wy-editor] .cm-editor .cm-line{display:block;padding:0px var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) 0px var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-editor] .cm-tooltip.cm-tooltip-autocomplete>ul{font-family:unset;max-height:calc(15*var(--wy-size, 1rem))}[part~=wy-editor] .cm-tooltip.cm-tooltip-autocomplete>ul>li{padding:0}[part~=wy-editor] .cm-tooltip{border:none;background-clip:padding-box;background-color:var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));overflow:hidden;z-index:1000}[part~=wy-editor] .cm-tooltip-autocomplete ul li[aria-selected] wy-item{background:var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));color:unset}[part~=wy-editor] .cm-tooltip-autocomplete .cm-completionLabel{display:none}[part~=wy-editor] .cm-tooltip-autocomplete ::part(wy-item-interactive):hover,[part~=wy-editor] .cm-tooltip-autocomplete ::part(wy-item-interactive):focus{background:var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb))}`, I4 = B`[part~=wy-post-editor]{padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-editor-inputs]{display:flex;flex-direction:row;align-items:flex-end;justify-content:space-between;flex-wrap:wrap;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-editor-buttons]{display:flex;flex-direction:row;align-items:flex-end;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));flex:1 0 auto}[part~=wy-post-editor-text]{flex:1 1 100%;display:flex;flex-direction:column}[part~=wy-editor-parts]{display:flex;flex-direction:column;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));min-height:0}[part~=wy-post-editor] .cm-editor{flex:1 1 100%;max-height:11.25em;min-height:4em;background-color:var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid rgba(0,0,0,0);caret-color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-post-editor] .cm-editor:focus{border-color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-post-editor] .cm-editor .cm-content{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-post-editor] .cm-editor .cm-line{padding:0}[part~=wy-post-editor] [part~=wy-is-invalid]+[data-editor-target] .cm-editor,[part~=wy-post-editor] [part~=wy-is-invalid] .cm-editor{border-color:var(--wy-error, var(--wy-error-light, #ba1821))!important}`, _v = B`[part~=wy-dragging]:after{content:attr(data-drag-title);background-color:#ffffff80;display:flex;justify-content:center;align-items:center;border:calc(.125*var(--wy-size, 1rem)) dashed var(--wy-outline, var(--wy-outline-light, #72777f));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));font-size:calc(1.5*var(--wy-size, 1rem));font-weight:var(--wy-font-weight-bold, 600);z-index:10000;position:absolute;inset:0}`;
var T4 = Object.defineProperty, F4 = Object.getOwnPropertyDescriptor, Qs = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? F4(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && T4(t, e, s), s;
}, "__decorateClass$K"), vo;
let Si = (vo = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.status = {
      state: "ok"
    }, this.interactive = !1, this.rounded = !1, this.isRenaming = !1;
  }
  /**
   * Emit an `edit-name` event requesting rename mode for the provided file.
   *
   * @param file - File that should enter rename mode.
   * @returns Whether the event was not canceled.
   */
  dispatchEditName(t) {
    const e = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `rename` event with a new filename.
   *
   * @param file - File being renamed.
   * @param name - New filename to apply.
   * @returns Whether the event was not canceled.
   */
  dispatchRename(t, e) {
    const r = new CustomEvent("rename", { detail: { file: t, name: e } });
    return this.dispatchEvent(r);
  }
  /**
   * Emit a `trash` event to move the file to the recycle bin.
   *
   * @param file - File slated for trashing.
   * @returns Whether the event was not canceled.
   */
  dispatchTrash(t) {
    const e = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `restore` event to recover the provided file.
   *
   * @param file - File to restore from trash.
   * @returns Whether the event was not canceled.
   */
  dispatchRestore(t) {
    const e = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `delete-forever` event to permanently remove the file.
   *
   * @param file - File targeted for permanent deletion.
   * @returns Whether the event was not canceled.
   */
  dispatchDeleteForever(t) {
    const e = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling subscription for the file.
   *
   * @param file - File whose subscription changes.
   * @param subscribe - Desired subscription state.
   * @returns Whether the event was not canceled.
   */
  dispatchSubscribe(t, e) {
    const r = new CustomEvent("subscribe", { detail: { file: t, subscribe: e } });
    return this.dispatchEvent(r);
  }
  render() {
    const t = this.file;
    if (!t) return v;
    const { icon: e } = Ur(t.name), r = ii(t.name), s = /* @__PURE__ */ a((o) => {
      o.stopImmediatePropagation();
      const c = o.target;
      c.value && c.value !== t.name ? this.dispatchRename(t, c.value) : this.dispatchEditName({ id: NaN });
    }, "handleRename"), n = /* @__PURE__ */ a((o) => {
      const c = o.target;
      o.key === "Escape" ? (o.preventDefault(), c.value = t.name, c.blur()) : o.key === "Enter" && (o.preventDefault(), c.blur());
    }, "handleRenameKey");
    return h`
      <wy-item
        ?rounded=${this.rounded}
        ?interactive=${this.interactive && !t.is_trashed && !this.isRenaming}
        ?trashed=${t.is_trashed}
        title=${t.name}
        size="sm"
      >
        ${this.status.state === "error" ? h`<wy-icon
              slot="image"
              name="alert-octagon"
              color="error"
              title=${nt(this.status.text)}
            ></wy-icon>` : this.status.state === "conflict" ? h`<wy-icon slot="image" name="alert" color="yellow" title=${nt(this.status.text)}></wy-icon>` : h`<wy-icon slot="image" .name=${e} .size=${24} .kind=${t.kind} ext=${r}></wy-icon>`}
        ${this.isRenaming ? h`
              <input
                slot="title"
                type="text"
                maxlength="256"
                part="wy-input"
                .defaultValue=${t.name}
                @blur=${s}
                @keyup=${(o) => {
      Rr(o), n(o);
    }}
                @click=${(o) => o.preventDefault()}
                @focus=${Yu}
                ${j(Uu)}
              />
            ` : h`
              <span slot="title" title=${t.name + (this.status.text ? `: ${this.status.text}` : "")}>
                <slot name="title"
                  >${this.title || t.name}${this.status.text ? h`: <em>${this.status.text}</em>` : v}</slot
                >
              </span>
            `}

        <slot slot="actions" name="actions">
          <wy-file-menu
            .file=${t}
            @edit-name=${(o) => this.dispatchEditName(o.detail.file)}
            @trash=${(o) => this.dispatchTrash(o.detail.file)}
            @restore=${(o) => this.dispatchRestore(o.detail.file)}
            @delete-forever=${(o) => this.dispatchDeleteForever(o.detail.file)}
            @subscribe=${(o) => this.dispatchSubscribe(o.detail.file, o.detail.subscribe)}
          >
          </wy-file-menu>
        </slot>
      </wy-item>
    `;
  }
}, a(vo, "WyFileItem"), vo);
Si.styles = [jr];
Qs([
  p({ type: Object })
], Si.prototype, "file", 2);
Qs([
  p({ type: Object })
], Si.prototype, "status", 2);
Qs([
  p({ type: Boolean })
], Si.prototype, "interactive", 2);
Qs([
  p({ type: Boolean })
], Si.prototype, "rounded", 2);
Qs([
  p()
], Si.prototype, "actionType", 2);
Qs([
  F()
], Si.prototype, "isRenaming", 2);
Si = Qs([
  H("wy-file-item")
], Si);
const D4 = /* @__PURE__ */ a((i) => {
  var t, e, r, s, Ou, Pv, Iu, en, Tu, f;
  return f = class extends i {
    /**
     * @constructor
     * @hideconstructor
     */
    constructor(...x) {
      super(...x);
      O(this, s);
      O(this, t, []);
      O(this, e);
      O(this, r, /* @__PURE__ */ new Set());
    }
    get eventParent() {
      return y(this, e);
    }
    set eventParent(x) {
      x?.eventChildren && x.eventChildren.add(this), P(this, e, x);
    }
    get eventChildren() {
      return y(this, r);
    }
    /**
     * Registers one or several event listeners. All event listeners are managed and automatically unregistered on destroy.
     *
     * When listening to weavy events, you may also listen to `before:` and `after:` events by simply adding the prefix to a weavy event.
     * Event handlers listening to weavy events may return modified data that is returned to the trigger. The data is passed on to the next event in the trigger event chain. If an event handler calls `event.stopPropagation()` or `return false`, the event chain will be stopped and the value is returned.
     *
     * @example <caption>Instance event</caption>
     * myInstance.on("before:options", function(options) { ... })
     * myInstance.on("options", function(options) { ... })
     * myInstance.on("after:options", function(options) { ... })
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#on
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string|Object} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     */
    on(...x) {
      const g = st(this, s, Tu).call(this, x);
      if (x[3]) {
        const I = /* @__PURE__ */ a((...A) => {
          try {
            g.handler.apply(this, A);
          } catch {
            try {
              g.handler();
            } catch (E) {
              console.warn("Could not invoke one handler:", E);
            }
          }
          st(this, s, Iu).call(this, g.events, g.selector, null, g.handler);
        }, "attachedHandler");
        st(this, s, Ou).call(this, g.events, g.selector, I, g.handler);
      } else
        st(this, s, Ou).call(this, g.events, g.selector, g.handler, g.handler);
    }
    /**
     * Registers one or several event listeners that are executed once. All event listeners are managed and automatically unregistered on destroy.
     *
     * Similar to {@link WeavyEvents#on}.
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#one
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string|Object} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {Function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     */
    one(x, g, S) {
      this.on(x, g, S, !0);
    }
    /**
     * Unregisters event listeners. The arguments must match the arguments provided on registration using .on() or .one().
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#off
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     * @returns {boolean} Was the handler removed?
     */
    off(...x) {
      const g = st(this, s, Tu).call(this, x), S = st(this, s, Pv).call(this, g.events, g.selector, g.handler);
      return st(this, s, Iu).call(this, g.events, g.selector, S, g.handler);
    }
    /**
     * Clears all registered eventhandlers
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#clear
     */
    clearEventHandlers() {
      y(this, t).length = 0;
    }
    /**
     * Trigger a custom event. Events are per default triggered on the weavy instance using the weavy namespace.
     *
     * The trigger has an event chain that adds `before:` and `after:` events automatically for all events except when any custom `prefix:` is specified. This way you may customize the eventchain by specifying `before:`, `on:` and `after:` in your event name to fire them one at the time. The `on:` prefix will then be removed from the name when the event is fired.
     *
     * Eventhandlers listening to the event may return modified data that is returned by the trigger event. The data is passed on to the next event in the trigger event chain. If an event handler calls `event.stopPropagation()` or `return false`, the event chain will be stopped and the value is returned.
     *
     * @example
     * // Normal triggering
     * weavyEvents.triggerEvent("myevent");
     *
     * // Will trigger the following events on the root instance
     * // 1. before:myevent.event.weavy
     * // 2. myevent.event.weavy
     * // 3. after:myevent.event.weavy
     *
     * @example
     * // Custom triggering, one at the time
     * weavyEvents.triggerEvent("before:myevent");
     * weavyEvents.triggerEvent("on:myevent");
     * weavyEvents.triggerEvent("after:myevent");
     *
     * @example
     * // Advanced triggering with data handling
     *
     * function doSomething() {
     *     // Will trigger the events sequentially and check the response data in between
     *
     *     var myTriggerData = { counter: 123, label: "my label" };
     *
     *     // Custom triggering, one at the time
     *
     *     // 1. Trigger before: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("before:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("before:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     // ...
     *
     *     // 2. Continue with on: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("on:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("on:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     // ...
     *
     *     // 3. At last trigger after: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("after:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("after:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     console.log("myevent was fully executed", myTriggerData);
     *     return myTriggerData;
     * }
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#triggerEvent
     * @param {string} name - The name of the event.
     * @param {(Array/Object/JSON)} [data] - Data may be an array or plain object with data or a JSON encoded string.
     * @param {any} ...additionalData - Any raw extra data
     * @returns {data} The data passed to the event trigger including any modifications by event handlers. Returns false if the event is cancelled.
     */
    triggerEvent(x, g, ...S) {
      const I = /^(before|on|after):/.test(x), A = I ? x.split(":")[0] : "";
      x = x.replace(/^(before|on|after):/, "");
      const E = "before:" + x, T = x, q = "after:" + x;
      if (g && typeof g == "string")
        try {
          g = JSON.parse(g);
        } catch {
          console.warn("Could not parse event data", x, g);
        }
      let R;
      if (I) {
        if (A === "before" || A === "after") {
          if (y(this, e) && (R = y(this, e).triggerEvent(
            A === "before" ? E : q,
            g,
            ...S
          ), g = R || R === !1 ? R : g, g === !1) || (R = st(this, s, en).call(this, A === "before" ? E : q, g, ...S), g = R || R === !1 ? R : g, g === !1))
            return g;
        } else if (A === "on" && (R = st(this, s, en).call(this, T, g, ...S), g = R || R === !1 ? R : g, g === !1 || y(this, e) && (R = y(this, e).triggerEvent("on:" + T, g, ...S), g = R || R === !1 ? R : g, g === !1)))
          return g;
      } else {
        if (y(this, e) && (R = y(this, e).triggerEvent(E, g, ...S), g = R || R === !1 ? R : g, g === !1) || (R = st(this, s, en).call(this, E, g, ...S), g = R || R === !1 ? R : g, g === !1) || (R = st(this, s, en).call(this, T, g, ...S), g = R || R === !1 ? R : g, g === !1) || y(this, e) && (R = y(this, e).triggerEvent("on:" + T, g, ...S), g = R || R === !1 ? R : g, g === !1) || y(this, e) && (R = y(this, e).triggerEvent(q, g, ...S), g = R || R === !1 ? R : g, g === !1))
          return g;
        R = st(this, s, en).call(this, q, g, ...S), g = R || R === !1 ? R : g;
      }
      return g;
    }
  }, t = new WeakMap(), e = new WeakMap(), r = new WeakMap(), s = new WeakSet(), /**
   * Saves a single event handler.
   *
   * @internal
   * @function
   * @param {string} event - One or more events. Multiple events are currently not registered individually.
   * @param {string|Object} [selector] - Optional refinement selector
   * @param {function} handler - The handler function. may be wrapped for once-handlers
   * @param {function} originalHandler - The original non-wrapped event handler.
   */
  Ou = /* @__PURE__ */ a(function(x, g, S, I) {
    y(this, t).push({
      events: x,
      selector: g,
      handler: S,
      originalHandler: I
    });
  }, "#registerEventHandler"), /**
   * Returns the event handler or wrapped event handler. The arguments must match the registered event handler.
   *
   * @internal
   * @function
   * @param {string} events - The events registered
   * @param {string|Object} [selector] - The optional selector for the handler.
   * @param {function} handler - The registered handler
   * @param {function} [originalHandler] - The original registered handler
   */
  Pv = /* @__PURE__ */ a(function(x, g, S, I) {
    const A = {
      events: x,
      selector: g,
      handler: S,
      originalHandler: I || S
    }, E = y(this, t).filter((T) => wn(A, T, !0)).pop();
    return E && E.handler;
  }, "#getEventHandler"), /**
   * Unregister an event handler. Arguments must match the registered event handler.
   *
   * @internal
   * @function
   * @param {string} event - The events registered
   * @param {function} handler - The registered handler
   * @param {string|Object} [selector] - The optional selector for the handler.
   * @returns {boolean} - True if any handler was removed
   */
  Iu = /* @__PURE__ */ a(function(x, g, S, I) {
    const A = {
      events: x,
      selector: g,
      handler: S,
      originalHandler: I
    };
    let E = !1;
    return y(this, t).forEach((T, q) => {
      wn(A, T, !0) && (E = !0, y(this, t).splice(q, 1));
    }), E;
  }, "#unregisterEventHandler"), /**
   * Triggers any local event handlers registered. Each handler may modify the data and return it or return false to cancel the event chain. .stopPropagation() and .preventDefault() may also be used.
   *
   * @example
   * weavyEvents.on("myevent", function(e, data) { ... })
   *
   * triggerHandler(this, "myevent", { key: 1 })
   *
   * @internal
   * @function
   * @param {any} eventName - The name of the event. Event names without prefix will also trigger handlers with the "on:" prefix.
   * @param {any} data - Any data to pass to the handler
   * @param {any} ...additionalData - Any extra data
   */
  en = /* @__PURE__ */ a(function(x, g, ...S) {
    let I = !1;
    return y(this, t).forEach((A) => {
      A.events.split(" ").forEach((E) => {
        if (E = E.indexOf("on:") === 0 ? E.split("on:")[1] : E, x === E && (!A.selector || wn(A.selector, g, !0))) {
          const T = A.handler(g, ...S);
          T ? g = T : T === !1 && (I = !0);
        }
      });
    }), I ? !1 : g;
  }, "#triggerHandler"), /**
   * Extracts and normalizes all parts of the events arguments.
   *
   * @internal
   * @function
   * @param {Array.<Object>} eventArguments - The function argument list: `[context], events, [selector], handler`
   * @returns {Object}
   * @property {string} events - Event names with added namespace for local events.
   * @property {string|Object} selector - The optional selector.
   * @property {function} handler - The handler function
   * @
   */
  Tu = /* @__PURE__ */ a(function(x) {
    const g = typeof x[1] == "function" ? x[1] : x[2], S = typeof x[1] == "function" ? null : x[1];
    return { events: x[0], selector: S, handler: g };
  }, "#getEventArguments"), a(f, "WeavyEvents"), f;
}, "MixinWeavyEvents"), H4 = D4(class {
});
function gf(i) {
  let t = "";
  try {
    t = /^((?:https?:\/\/[^/]+)|(?:file:\/\/))\/?/.exec(i)?.[1] || "";
  } catch {
    console.error(
      "Unable to resolve location origin. Make sure you are using http, https or file protocol and have a valid location URL."
    );
  }
  return t;
}
a(gf, "extractOrigin");
const gw = class gw extends H4 {
  constructor(t = {}) {
    super(), this.contentWindows = /* @__PURE__ */ new Set(), this.contentWindowsMapByWeavyId = /* @__PURE__ */ new Map(), this.contentWindowOrigins = /* @__PURE__ */ new WeakMap(), this.contentWindowNames = /* @__PURE__ */ new WeakMap(), this.contentWindowWeavyIds = /* @__PURE__ */ new WeakMap(), this.contentWindowDomain = /* @__PURE__ */ new WeakMap(), this.origin = Vu() ? gf(window.location.href) : "", this.timeout = 2e3, t?.timeout && (this.timeout = t.timeout), window.addEventListener("message", (e) => {
      if (e.data.name && e.data.weavyId !== void 0) {
        if (e.data.weavyMessageId && e.data.name !== "message-receipt" && e.data.name !== "unready")
          try {
            e.source?.postMessage(
              { name: "message-receipt", weavyId: e.data.weavyId, weavyMessageId: e.data.weavyMessageId },
              { targetOrigin: e.origin }
            );
          } catch {
            console.error("could not post back message-receipt to source");
          }
        switch (e.data.name) {
          case "register-child": {
            if ((!e.source || !this.contentWindowWeavyIds.has(e.source)) && console.warn("register-child: contentWindow not pre-registered", e.source), e.source && this.contentWindowOrigins.get(e.source) !== e.origin) {
              console.error(
                "register-child: " + this.contentWindowNames.get(e.source) + " has invalid origin",
                e.origin
              );
              return;
            }
            try {
              const r = e.source ? this.contentWindowWeavyIds.get(e.source) : void 0, s = e.source ? this.contentWindowNames.get(e.source) : void 0;
              s && e.source && e.source.postMessage(
                {
                  name: "register-window",
                  windowName: s,
                  weavyId: r || !0
                },
                { targetOrigin: e.origin }
              );
            } catch (r) {
              console.error("could not register frame window", r);
            }
            break;
          }
          case "ready": {
            e.source && this.contentWindowsMapByWeavyId.has(e.data.weavyId) && this.contentWindowNames.has(e.source) && this.contentWindowsMapByWeavyId.get(e.data.weavyId)?.get(this.contentWindowNames.get(e.source)) && (this.contentWindowDomain.set(e.source, e.origin), this.distributeMessage(e));
            break;
          }
          case "unready": {
            this.contentWindowsMapByWeavyId.has(e.data.weavyId) && this.distributeMessage(e, !0);
            break;
          }
          default: {
            (e.source === window || this.contentWindowsMapByWeavyId.size) && this.distributeMessage(e);
            break;
          }
        }
      }
    });
  }
  /**
   * The weavy console logging.
   */
  get console() {
    return console;
  }
  distributeMessage(t, e = !1) {
    const r = t.source === window && t.origin === this.origin;
    if (e ||= t.source && this.contentWindowOrigins.has(t.source) && t.origin === this.contentWindowOrigins.get(t.source) || !1, r || e) {
      e && !t.data.windowName && t.source && (t.data.windowName = this.contentWindowNames.get(t.source));
      const s = t.data.name;
      s && this.triggerEvent(s, t.data, t), this.triggerEvent("message", t.data, t);
    }
  }
  /**
   * Sends the id of a frame to the frame content scripts, so that the frame gets aware of which id it has.
   * The frame needs to have a unique name attribute.
   *
   * @category panels
   * @param {string} weavyId - The id of the group or entity which the contentWindow belongs to.
   * @param {Window} contentWindow - The frame window to send the data to.
   */
  registerContentWindow(t, e, r, s) {
    try {
      if (!e) {
        console.error("registerContentWindow() No valid contentWindow to register, must be a window and have a name.");
        return;
      }
    } catch {
      console.error("registerContentWindow() cannot access contentWindowName");
    }
    t.self && (t = t.self), this.console.log("registerContentWindow", t), (!r || r === "true") && (r = !0), this.contentWindowsMapByWeavyId.has(r) || this.contentWindowsMapByWeavyId.set(r, /* @__PURE__ */ new Map()), this.contentWindowsMapByWeavyId.get(r)?.set(e, t), this.contentWindows.add(t), this.contentWindowNames.set(t, e), this.contentWindowWeavyIds.set(t, r), this.contentWindowOrigins.set(t, s);
  }
  unregisterAll(t) {
    this.contentWindowsMapByWeavyId.has(t) && (this.contentWindowsMapByWeavyId.get(t)?.forEach((e, r) => {
      this.unregisterContentWindow(r, t);
    }), this.contentWindowsMapByWeavyId.get(t), this.contentWindowsMapByWeavyId.delete(t));
  }
  unregisterContentWindow(t, e) {
    if (this.contentWindowsMapByWeavyId.has(e)) {
      if (this.contentWindowsMapByWeavyId.get(e)?.has(t)) {
        const r = this.contentWindowsMapByWeavyId.get(e)?.get(t);
        if (r)
          try {
            this.contentWindows.delete(r), this.contentWindowNames.delete(r), this.contentWindowWeavyIds.delete(r), this.contentWindowOrigins.delete(r);
          } catch {
          }
      }
      if (this.contentWindowsMapByWeavyId.get(e)?.delete(t), this.contentWindowsMapByWeavyId.get(e)?.size === 0)
        try {
          this.contentWindowsMapByWeavyId.delete(e);
        } catch {
        }
    }
  }
  async whenPostMessage(t, e, r) {
    we(), r === null && (r = void 0);
    const s = t === window.self, n = s ? gf(window.location.href) : this.contentWindowOrigins.get(t);
    if (s || t && n === this.contentWindowDomain.get(t)) {
      e.weavyMessageId || (e.weavyMessageId = ol() + ol());
      let c;
      await Promise.race([
        new Promise((l, u) => {
          c = window.setTimeout(() => {
            u(new Error("postMessage() receipt timed out: " + e.weavyMessageId + ", " + e.name));
          }, this.timeout || 2e3);
        }),
        new Promise((l) => {
          this.on("message-receipt", { weavyId: e.weavyId, weavyMessageId: e.weavyMessageId }, () => {
            clearTimeout(c), l(void 0);
          }), t.postMessage(e, { targetOrigin: n, transfer: r });
        })
      ]);
    } else
      throw new Error("postMessage() Invalid window origin: " + n + ", " + e.name);
  }
  postToChildren(t, e) {
    if (typeof t != "object" || !t.name) {
      console.error("postToChildren() Invalid message format", t);
      return;
    }
    e === null && (e = void 0), t.distributeName = t.name, t.name = "distribute", t.weavyId = t.weavyId || !0, this.contentWindows.forEach((r) => {
      const s = this.contentWindowOrigins.get(r);
      if (s === this.contentWindowDomain.get(r))
        try {
          r.postMessage(t, { targetOrigin: s, transfer: e });
        } catch {
          console.warn(
            "postToChildren() could not distribute message to " + this.contentWindowNames.get(r)
          );
        }
    });
  }
  async postToFrame(t, e, r, s) {
    if (typeof r != "object" || !r.name) {
      console.error("postToFrame() Invalid message format", r);
      return;
    }
    const n = this.contentWindowsMapByWeavyId.get(e)?.get(t);
    if (!n)
      throw new Error(`postToFrame() Window not registered: ${e}, ${t}`);
    return r.weavyId = e, await this.whenPostMessage(n, r, s);
  }
  async postToSelf(t, e) {
    if (typeof t != "object" || !t.name) {
      console.error("postToSelf() Invalid message format", t);
      return;
    }
    return t.weavyId = t.weavyId || !0, await this.whenPostMessage(window.self, t, e);
  }
  postToSource(t, e, r) {
    if (t.source && t.data.weavyId !== void 0) {
      const s = t.source === window.self && t.origin === this.origin, n = this.contentWindowOrigins.has(t.source) && t.origin === this.contentWindowOrigins.get(t.source);
      if (r === null && (r = void 0), s || n) {
        e.weavyId = t.data.weavyId;
        try {
          t.source.postMessage(e, { targetOrigin: t.origin, transfer: r });
        } catch (o) {
          console.error("postToSource() Could not post message back to source", o);
        }
      }
    }
  }
};
a(gw, "WeavyPostalParent");
let Fu = gw;
var V4 = Object.defineProperty, U4 = Object.getOwnPropertyDescriptor, Lh = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? U4(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && V4(t, e, s), s;
}, "__decorateClass$J"), go;
let Rs = (go = class extends $e {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.iframeVisible = !1, this.showOverlay = !1, this.isRegistered = !1, this.iframeElementRef = et(), this.overlayRef = et();
  }
  /**
   * Open the file picker overlay.
   */
  open() {
    this.showOverlay = !0;
  }
  /**
   * Close the file picker overlay.
   */
  close() {
    this.showOverlay = !1, this.iframeVisible = !1;
  }
  /**
   * Returns the topmost available window/frame origin used when building the iframe src.
   *
   * @internal
   */
  get origin() {
    let t = "";
    try {
      window.location.ancestorOrigins && 0 < window.location.ancestorOrigins.length ? t = window.location.ancestorOrigins[window.location.ancestorOrigins.length - 1] : window.top && (t = window.top.document.location.origin);
    } catch {
    }
    if (!t)
      try {
        t = window.self.document.location.origin;
      } catch {
        console.error("Filebrowser: Could not read current origin.");
      }
    return t;
  }
  /**
   * Trigger `external-blobs` event with any selected blobs.
   *
   * @internal
   * @param {ExternalBlobType[] | null} externalBlobs - The externally selected blobs.
   * @returns {boolean} Whether the event was successful.
   */
  dispatchExternalBlobs(t) {
    const e = new CustomEvent("external-blobs", {
      detail: { externalBlobs: t }
    });
    return this.dispatchEvent(e);
  }
  connectedCallback() {
    super.connectedCallback(), this.handleFiles = (t, e) => {
      e.source === this.iframeElementRef.value?.contentWindow?.self && (this.dispatchExternalBlobs(t.blobs), this.close());
    }, this.handleClose = (t, e) => {
      e.source === this.iframeElementRef.value?.contentWindow?.self && this.close();
    }, this.handleGoogleSelected = (t, e) => {
      e.source === this.iframeElementRef.value?.contentWindow?.self && this.overlayRef.value && (this.overlayRef.value.maximized = !0);
    }, this.weavyPostal || (this.weavyPostal = new Fu()), this.weavyPostal.on("add-external-blobs", this.handleFiles), this.weavyPostal.on("request:file-browser-close", this.handleClose), this.weavyPostal.on("google-selected", this.handleGoogleSelected);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.weavyPostal?.off("add-external-blobs", this.handleFiles), this.weavyPostal?.off("request:file-browser-close", this.handleClose), this.weavyPostal?.off("google-selected", this.handleGoogleSelected);
  }
  updated() {
    this.weavy && (this.showOverlay && !this.src && (this.src = new URL(
      "?origin=" + this.origin + "&v=X&t=" + Date.now().toString() + "&weavyId=wy-filebrowser",
      this.weavy.cloudFilePickerUrl
    )), this.weavyPostal && !this.isRegistered && this.showOverlay && this.src ? this.iframeElementRef.value?.contentWindow && (this.weavyPostal.registerContentWindow(
      this.iframeElementRef.value?.contentWindow.self,
      "weavy-filebrowser",
      "wy-filebrowser",
      this.src.origin
    ), this.isRegistered = !0) : this.weavyPostal && this.isRegistered && !this.showOverlay && this.src && (this.weavyPostal.unregisterContentWindow("weavy-filebrowser", "wy-filebrowser"), this.isRegistered = !1, this.src = void 0));
  }
  render() {
    return this.weavy ? h`
      <wy-overlay
        ?noHeader=${this.iframeVisible}
        part="wy-cloud-files-overlay"
        .show=${this.showOverlay}
        ${j(this.overlayRef)}
        @close=${() => this.close()}
      >
        ${this.showOverlay ? h`
              <wy-progress-circular
                part="wy-cloud-files-progress"
                indeterminate
                overlay
                ?hidden=${this.iframeVisible}
              ></wy-progress-circular>
              <iframe
                part="wy-cloud-picker-frame"
                ${j(this.iframeElementRef)}
                @load=${() => this.iframeVisible = !0}
                src=${nt(this.src?.toString())}
                id="weavy-filebrowser"
                name="weavy-filebrowser"
                title=${b("Cloud File Browser")}
              ></iframe>
            ` : v}
      </wy-overlay>
    ` : v;
  }
}, a(go, "WyCloudFiles"), go);
Rs.styles = [
  Z,
  B`
      [part~="wy-cloud-picker-frame"] {
        flex: 1 1 100%;
        border: 0;
      }
    `
];
Lh([
  F()
], Rs.prototype, "src", 2);
Lh([
  F()
], Rs.prototype, "iframeVisible", 2);
Lh([
  F()
], Rs.prototype, "showOverlay", 2);
Rs = Lh([
  H("wy-cloud-files"),
  ot()
], Rs);
var B4 = Object.defineProperty, q4 = Object.getOwnPropertyDescriptor, St = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? q4(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && B4(t, e, s), s;
}, "__decorateClass$I"), bo;
let vt = (bo = class extends Rt {
  constructor() {
    super(), this.exportParts = new U(this), this.storage = qf("localStorage"), this.disabled = !1, this._placeholder = "", this.text = "", this.metadata = {}, this.options = [], this.attachments = [], this.buttonText = "", this.typing = !0, this.draft = !1, this.editorType = "posts", this.editorClass = "wy-post-editor", this.editorLocation = "apps", this.editorError = !1, this.showPolls = !1, this.pollOptions = [], this._embeds = [], this.draftKey = "", this.uploadBlobMutation = new We(
      this
    ), this.mutatingFiles = new yc(this), this.fileInputRef = et(), this.cloudFilesRef = et(), this.dropZone = new Wd(this), this.keyMap = [], this.editorRef = et(), this.editorInitialized = !1, this.throttledTyping = Lu(
      async () => {
        this.weavy && this.app && !jd.has(this.app.type) && await C4(this.weavy, this.app.id).mutate();
      },
      2e3,
      { leading: !0, trailing: !1 }
    ), this.throttledDrafting = Lu(
      () => {
        this.saveDraft();
      },
      500,
      { leading: !0, trailing: !0 }
    ), this.openFileInput = () => {
      this.fileInputRef.value?.click();
    }, this.openCloudFiles = () => {
      this.cloudFilesRef.value?.open();
    }, this.createMeeting = async (t) => {
      if (this.weavy && t.source === this.authWindow && this.weavy.url.origin === t.origin && t.data && t.data.name && t.data.name.endsWith("-authorized")) {
        const e = t.data.name.slice(0, -11), s = await ff(this.weavy, e).mutate();
        s.auth_url || (this.meeting = s);
      }
    }, this.addEventListener("drop-files", (t) => this.handleDropFiles(t)), this.addEventListener("keydown", Gd), this.addEventListener("keyup", Rr);
  }
  set placeholder(t) {
    this._placeholder = t;
  }
  get placeholder() {
    return this._placeholder;
  }
  /**
   * Select all content in the editor.
   *
   * @internal
   */
  selectAllContent() {
    this.editor?.dispatch({
      selection: {
        anchor: 0,
        head: this.editor.state.doc.length
      }
    });
  }
  /**
   * Place cursor at the end of the editor content.
   *
   * @internal
   */
  setCursorLast() {
    this.editor?.dispatch({
      selection: {
        anchor: this.editor.state.doc.length,
        head: this.editor.state.doc.length
      }
    });
  }
  /**
   * Focus the editor input.
   *
   * @internal
   */
  focusInput() {
    this.editor?.focus();
  }
  set embeds(t) {
    const e = t.filter((r) => r.type !== "link" || r.title || r.description);
    this._embeds = [...e];
  }
  get embeds() {
    return this._embeds;
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("app") && (this.mutationAppId = void 0), (t.has("weavy") || t.has("app") || t.has("user") || t.has("parentId")) && this.weavy && this.app && this.user) {
      if (this.mutationAppId = this.mutationAppId ?? this.app?.id ?? Date.now() * -1, this.draftKey = `draft-${this.editorType}-${this.parentId || this.mutationAppId}`, this.uploadBlobMutation.trackMutation(
        Ju(
          this.weavy,
          this.user,
          this.mutationAppId,
          `${this.editorLocation}-${this.parentId || this.mutationAppId}`
        )
      ), this.mutatingFiles.trackMutationState(
        {
          filters: {
            mutationKey: [
              "apps",
              this.mutationAppId,
              "blobs",
              `${this.editorLocation}-${this.parentId || this.mutationAppId}`
            ],
            exact: !0
          }
        },
        this.weavy.queryClient
      ), this.externalBlobMutation = Cv(
        this.weavy,
        this.user,
        this.mutationAppId,
        `${this.editorLocation}-${this.parentId || this.mutationAppId}`
      ), this.draft && this.storage) {
        const e = this.storage.getItem(this.draftKey);
        if (e) {
          const r = JSON.parse(e);
          this.text = r.text, this.embeds = r.embeds, this.meeting = r.meeting, r.pollOptions?.length > 0 && (this.showPolls = !0, this.pollOptions = r.pollOptions), mf(this.embeds.map((s) => s.url).filter((s) => typeof s == "string"));
        } else
          this.clearEditor();
      }
      this.embed && (this.embeds = [this.embed], mf(this.embeds.map((e) => e.url).filter((e) => typeof e == "string"))), this.options && this.options.length > 0 && (this.pollOptions = this.options, this.showPolls = !0);
    }
    t.has("text") && this.editor && this.editor.state.doc.toString() !== this.text && this.editor.dispatch({ changes: { from: 0, to: this.editor.state.doc.length, insert: this.text } });
  }
  updated(t) {
    if ((t.has("weavy") || t.has("app") || t.has("user") || t.has("parentId")) && this.weavy && this.user && this.editorRef.value && this.weavy.whenUrl().then(() => {
      import(
        /* webpackIgnore: true */
        /* @vite-ignore */
        new URL("./es/editor-M1x0pxVu.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
      ).then((e) => e.editor).then(
        ({
          weavyHighlighter: e,
          syntaxHighlighting: r,
          history: s,
          dropCursor: n,
          mentions: o,
          autocompletion: c,
          placeholder: l,
          keymap: u,
          weavyKeymap: f,
          defaultKeymap: $,
          historyKeymap: m,
          markdown: x,
          languages: g,
          EditorView: S,
          EditorState: I,
          weavyEnterSendKeymap: A,
          weavyModifierEnterSendKeymap: E,
          Compartment: T
        }) => {
          this.editorInitialized || (this.editorInitialized = !0, this.editorEditable = new T(), this.editorPlaceholder = new T(), this.editorKeymap = new T(), this.EditorView = S, this.placeholderExtension = l, this.keymapFacet = u, this.keymaps = {
            weavyEnterSendKeymap: A,
            weavyModifierEnterSendKeymap: E,
            weavyKeymap: f,
            defaultKeymap: [...$],
            historyKeymap: [...m]
          }, this.editorExtensions = [
            S.contentAttributes.of({
              spellcheck: "true",
              autocorrect: "on",
              autocapitalize: "on",
              enterkeyhint: this.settings?.enterToSend === "always" ? "send" : "enter"
            }),
            s(),
            n(),
            o,
            c({
              override: this.componentFeatures?.allowsFeature(M.Mentions) ? [(q) => this.autocomplete(q)] : [],
              //showMention
              closeOnBlur: !1,
              aboveCursor: this.editorType !== "posts",
              icons: !1,
              addToOptions: [
                {
                  render: /* @__PURE__ */ a(function(q, R) {
                    const V = document.createElement("wy-item");
                    V.interactive = !1, (!q.item?.access || q.item.access === dr.None) && (V.disabled = !0);
                    const N = document.createElement("wy-avatar");
                    N.slot = "image", N.src = q.item?.avatar_url || "", N.name = q.item?.name || "";
                    const Y = document.createElement("span");
                    return Y.slot = "title", Y.innerText = q.item?.name || "", V.appendChild(N), V.appendChild(Y), V;
                  }, "render"),
                  position: 10
                }
              ]
            }),
            r(e, { fallback: !0 }),
            S.lineWrapping,
            x({ codeLanguages: g }),
            S.domEventHandlers({
              paste: /* @__PURE__ */ a((q, R) => {
                let V = [];
                const N = q.clipboardData?.items || [];
                for (const Y of N)
                  if (Y.kind === "file") {
                    const it = Y.getAsFile();
                    it && (V = [...V, it]);
                  }
                if (this.componentFeatures?.allowsFeature(M.Attachments) && V.length > 0) {
                  for (let Y = 0; Y < V.length; Y++)
                    this.handleUploadFiles(V);
                  return !0;
                }
              }, "paste"),
              keyup: /* @__PURE__ */ a((q, R) => {
                this.text = R.state.doc.toString(), this.componentFeatures?.allowsFeature(M.Typing) && this.typing && R.state.doc.toString() !== "" && this.throttledTyping(), this.draft && this.throttledDrafting(), this.componentFeatures?.allowsFeature(M.Embeds) && R.state.doc.toString() !== "" && this.handleEmbeds(R.state.doc.toString());
              }, "keyup")
            }),
            // Compartments
            this.editorEditable.of(S.editable.of(!this.disabled)),
            this.editorPlaceholder.of(this.placeholderExtension(this.placeholder)),
            this.editorKeymap.of(this.keymapFacet.of(this.getKeymaps())),
            S.updateListener.of((q) => {
              this.setPlaceHolderText();
              const R = Array.from(
                (this.editor?.state).config.compartments.keys()
              );
              this.editorEditable = R[0], this.editorPlaceholder = R[1], this.editorKeymap = R[2];
            })
          ], this.editor || (this.editor = new S({
            state: I.create({
              doc: this.text,
              extensions: this.editorExtensions
            }),
            parent: this.editorRef.value
          }), this.editorRef.value?.addEventListener("wy-submit", this.submit.bind(this))));
        }
      );
    }), t.has("disabled") && this.editor && this.editorEditable && this.EditorView && this.editor.dispatch({
      // Update readonly state
      effects: this.editorEditable.reconfigure(this.EditorView.editable.of(!this.disabled))
    }), t.has("placeholder") && this.editor && this.editorPlaceholder && this.placeholderExtension) {
      const e = this.placeholderExtension(this.placeholder);
      this.editor.dispatch({
        // Update placeholder state
        effects: this.editorPlaceholder.reconfigure(e)
      }), this.setPlaceHolderText();
    }
    t.has("settings") && this.editor && this.editorKeymap && this.keymapFacet && (this.editor.dispatch({
      // Update readonly state
      effects: this.editorKeymap.reconfigure(this.keymapFacet.of(this.getKeymaps()))
    }), this.setEnterKeyHint());
  }
  /**
   * Update the visible placeholder text within the fallback DOM copy.
   *
   * @internal
   */
  setPlaceHolderText() {
    const t = this.renderRoot.querySelector(".cm-placeholder");
    t && this.editor && (t.setAttribute("aria-label", `placeholder ${this.placeholder}`), t.innerText = this.placeholder);
  }
  /**
   * Update contentEditable attribute on the fallback editor.
   *
   * @internal
   */
  setEditable() {
    const t = this.renderRoot.querySelector(".cm-content");
    t && this.editor && (t.contentEditable = String(!this.disabled));
  }
  /**
   * Update enter key hint on the content element.
   *
   * @internal
   */
  setEnterKeyHint() {
    const t = this.renderRoot.querySelector(".cm-content");
    t && this.editor && (t.enterKeyHint = this.settings?.enterToSend === "always" ? "send" : "enter");
  }
  /**
   * Compute and return keymaps for the current settings/editor type.
   *
   * @internal
   */
  getKeymaps() {
    if (!this.keymaps)
      return [];
    const { weavyEnterSendKeymap: t, weavyModifierEnterSendKeymap: e, weavyKeymap: r, defaultKeymap: s, historyKeymap: n } = this.keymaps;
    let o = this.settings?.enterToSend === "never" ? [] : [...e];
    return ((!this.settings?.enterToSend || this.settings?.enterToSend === "auto") && this.editorType === "messages" && L4 || this.settings?.enterToSend === "always") && (o = [...t, ...o]), [...o, ...r, ...s, ...n];
  }
  connectedCallback() {
    super.connectedCallback(), window.addEventListener("message", this.createMeeting);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("message", this.createMeeting);
  }
  handleRemoveMeeting() {
    this.meeting = void 0;
  }
  /**
   * Autocomplete handler for mentions. Returns completion results or null.
   *
   * Called by the editor to resolve mention suggestions.
   *
   * @internal
   * @param context - Completion context from the editor
   * @returns Promise<CompletionResult | null>
   */
  async autocomplete(t) {
    if (!this.weavy || !this.app)
      return null;
    let e = t.matchBefore(/(?:^|\s)(?!\]\()@(?=\S)([^@]+)/);
    if (!t.explicit && !e) return null;
    e = t.matchBefore(/@[^@]+/);
    const r = e?.text.substring(1), n = await (await this.weavy.fetch(`/api/apps/${this.app.id}/members?member=null&q=${r}`)).json();
    let o = [];
    return n.data && (o = n.data.filter((c) => typeof c.name < "u").map((c) => ({
      item: c,
      label: c.name,
      apply: /* @__PURE__ */ a((l, u, f, $) => {
        const m = "[" + c.name + "](@u" + c.id.toString() + ")";
        let x = l.state.update({ changes: { from: f - 1, to: f } });
        l.dispatch(x), x = l.state.update({
          changes: { from: f - 1, to: $ - 1, insert: m }
        }), l.dispatch(x);
      }, "apply")
    }))), {
      from: e ? e.from + 1 : t.pos,
      options: o,
      filter: !1
    };
  }
  /**
   * Handle files dropped on the editor.
   *
   * @internal
   * @param e - Drop files event
   */
  handleDropFiles(t) {
    const e = t.detail;
    e.files && this.handleUploadFiles(e.files);
  }
  /**
   * Upload array of File objects via the upload blob mutation controller.
   *
   * Preserves input value if provided and saves draft after each upload.
   *
   * @internal
   * @param files - FileList or array of File objects to upload
   * @param input - Optional input element to reset after upload
   */
  async handleUploadFiles(t, e) {
    if (t) {
      for (let r = 0; r < t.length; r++) {
        const n = { file: t[r] };
        await this.uploadBlobMutation.mutate(n), this.saveDraft();
      }
      e && (e.value = "");
    }
  }
  /**
   * Handle external blob imports (cloud/external sources).
   *
   * @internal
   * @param externalBlobs - Array of external blob descriptors
   */
  handleExternalBlobs(t) {
    if (t)
      for (let e = 0; e < t.length; e++) {
        const r = t[e];
        this.externalBlobMutation?.mutate({ externalBlob: r });
      }
  }
  /**
   * Handle removal/abortion of an upload mutation and clean cache state.
   *
   * @internal
   * @param mutation - Mutation state object to remove
   */
  handleRemoveUpload(t) {
    !this.weavy || !this.mutationAppId || (t.status === "pending" && fu(t.variables) && t.variables.abort?.(), $m(
      this.weavy.queryClient,
      ["apps", this.mutationAppId, "blobs", `${this.editorLocation}-${this.parentId || this.mutationAppId}`],
      (e) => e.state.data?.id === t.data?.id
    ));
  }
  /**
   * Persist draft to storage if draft mode is enabled.
   *
   * Saves editor text, embeds, poll options and ongoing file uploads to localStorage.
   *
   * @internal
   */
  saveDraft() {
    if (!this.draft || !this.storage) return;
    const t = this.mutatingFiles.result;
    let e = this.editor?.state.doc.toString();
    if (e === void 0 && (e = this.text), (!t || !t.length) && !this.meeting && !this.embeds.length && (!this.pollOptions.length || this.pollOptions.filter((r) => r.text.trim() !== "").length === 0) && e === "")
      this.storage.removeItem(this.draftKey);
    else {
      const r = {
        meeting: this.meeting,
        text: e,
        pollOptions: this.pollOptions.filter((s) => s.text.trim() !== ""),
        embeds: this.embeds
      };
      this.storage.setItem(this.draftKey, JSON.stringify(r));
    }
  }
  /**
   * Handle removal of an attachment reference from the editor state.
   *
   * @internal
   * @param attachment - Attachment to remove
   */
  handleRemoveAttachment(t) {
    this.attachments = this.attachments.filter((e) => e.id !== t.id);
  }
  /**
   * Submit the editor content by dispatching a `submit` event.
   *
   * Validates that there is content to submit and that no uploads/embeds are still processing.
   *
   * @internal
   */
  submit() {
    const t = this.mutatingFiles.result, e = t?.some((f) => f.status === "pending"), r = this.editor?.state.doc.toString().trim() ?? "", s = this.meeting?.id, n = t?.map((f) => f.data?.id).filter((f) => f), o = this.attachments?.map((f) => f.id) || [], c = this.pollOptions.filter((f) => f.text.trim() !== "");
    if (S4() || e || !this.contextDataBlobs || !r && !s && n?.length == 0 && c.length == 0 && o.length == 0 && this.embeds.length == 0)
      return;
    const l = this.contextDataBlobs.length ? this.contextDataBlobs : void 0, u = new CustomEvent("submit", {
      detail: { text: r, meetingId: s, blobs: n, attachments: o, pollOptions: c, embedId: this.embeds[0]?.id, contextData: l },
      bubbles: !0,
      composed: !0
    });
    this.dispatchEvent(u), this.resetEditor();
  }
  /**
   * Reset the editor state after a successful submit.
   *
   * Clears editor content, removes pending uploads from the query cache and deletes the stored draft.
   *
   * @internal
   */
  resetEditor() {
    this.clearEditor(), this.weavy && this.mutationAppId && e0(this.weavy.queryClient, [
      "apps",
      this.mutationAppId,
      "blobs",
      `${this.editorLocation}-${this.parentId || this.mutationAppId}`
    ]), this.storage?.removeItem(this.draftKey);
  }
  /**
   * Clear the editor UI and internal state (text, embeds, attachments, metadata).
   *
   * @internal
   */
  clearEditor() {
    this.editor?.dispatch({ changes: { from: 0, to: this.editor.state.doc.length, insert: "" } }), this.text = "", this.meeting = void 0, this.pollOptions = [], this.showPolls = !1, this.embeds = [], this.metadata = {}, z4();
  }
  /**
   * Create or initiate a meeting for the current user.
   *
   * If the meeting requires third-party auth, opens an auth popup; otherwise stores the created meeting.
   *
   * @internal
   * @param name - Provider key for the meeting (e.g. "zoom", "google", "microsoft")
   */
  async handleMeetingClick(t) {
    if (!this.weavy || !this.user)
      return;
    const r = await ff(this.weavy, t).mutate();
    r.auth_url ? this.authWindow = window.open(r.auth_url, "oauthwin", "height=640,width=480") : this.meeting = r;
  }
  /**
   * Add a discovered embed to the editor and persist draft.
   *
   * @internal
   * @param embed - Embed object to add.
   */
  setEmbeds(t) {
    this.embeds = [t, ...this.embeds], this.saveDraft();
  }
  /**
   * Scan content for embeds and add them via setEmbeds callback.
   *
   * @internal
   * @param content - Text content to scan for embed links.
   */
  handleEmbeds(t) {
    this.weavy && R4(t, this.setEmbeds.bind(this), this.weavy);
  }
  /**
   * Remove an embed by id from the editor embeds list and persist draft.
   *
   * @internal
   * @param e - Embed remove event containing embed id.
   */
  removeEmbed(t) {
    this.embeds = this.embeds.filter((e) => e.id !== t.detail.id), this.saveDraft();
  }
  /**
   * Cycle the primary embed (move first to the end) and persist draft.
   *
   * @internal
   */
  swapEmbed() {
    const t = this.embeds.shift();
    t && (this.embeds = [...this.embeds, t]), this.saveDraft();
  }
  /**
   * Toggle the poll UI in the editor and initialize default options when opened.
   *
   * @internal
   */
  openPolls() {
    this.showPolls ? this.showPolls = !1 : (this.pollOptions.length === 0 && (this.pollOptions = Array.from({ length: 3 }, () => ({ id: null, text: "" }))), this.showPolls = !0);
  }
  /**
   * Handle change to a poll option input and persist draft.
   *
   * @internal
   * @param e - Input event
   * @param index - Index of the poll option changed
   */
  handlePollOptionChange(t, e) {
    const r = [...this.pollOptions];
    r[e].text = t.target.value, this.pollOptions = r, this.saveDraft();
  }
  /**
   * Add a new poll option when focus reaches the last option (limit 5).
   *
   * @internal
   * @param e - Focus/keyboard event
   * @param index - Index of the poll option that triggered the add
   */
  handlePollOptionAdd(t, e) {
    if (e === this.pollOptions.length - 1 && this.pollOptions.length < 5) {
      const r = { id: null, text: "" };
      this.pollOptions = [...this.pollOptions, r], this.saveDraft();
    }
  }
  /**
   * Editor loading fallback dummy.
   * Hard copy of the rendered nodes when the editor is empty. Cleaned up to not be editable.
   */
  renderEditorDummy() {
    return this.editorInitialized ? v : h`
          <div class="cm-editor">
            <div class="cm-announced"></div>
            <div tabindex="-1" class="cm-scroller">
              <div class="cm-content cm-lineWrapping">
                <div class="cm-line"
                  ><img class="cm-widgetBuffer" aria-hidden="true" /><span class="cm-placeholder"
                    >${this.placeholder}</span
                  ><br
                /></div>
              </div>
            </div>
          </div>
        `;
  }
  renderTopSlot() {
    return v;
  }
  renderMiddleSlot() {
    return h`
      <!-- Input -->
      <div part=${K({ "wy-post-editor-text": !0, "wy-is-invalid": this.editorError })} ${j(this.editorRef)}>
        ${this.renderEditorDummy()}
      </div>

      <div part="wy-post-editor-inputs">
        <div part="wy-post-editor-buttons">
          ${this.componentFeatures?.allowsFeature(M.Attachments) ? h`<wy-button
                  kind="icon"
                  @click=${this.openFileInput}
                  title=${b("From device")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon name="attachment"></wy-icon>
                </wy-button>
                <input
                  type="file"
                  ${j(this.fileInputRef)}
                  @click=${(t) => t.stopPropagation()}
                  @change=${(t) => this.handleUploadFiles(
      Array.from(t.target.files || []),
      t.target
    )}
                  multiple
                  hidden
                  tabindex="-1"
                  ?disabled=${this.disabled}
                />` : v}
          ${this.componentFeatures?.allowsFeature(M.CloudFiles) ? h`<wy-button
                kind="icon"
                @click=${this.openCloudFiles}
                title=${b("From cloud")}
                ?disabled=${this.disabled}
              >
                <wy-icon name="cloud"></wy-icon>
              </wy-button>` : v}
          ${this.componentFeatures?.allowsAnyFeature(M.Meetings, M.ZoomMeetings) ? h`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("zoom")}
                  title=${b("Zoom meeting")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="zoom-meetings"></wy-icon>
                </wy-button>
              ` : v}
          ${this.componentFeatures?.allowsAnyFeature(M.Meetings, M.GoogleMeet) ? h`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("google")}
                  title=${b("Google Meet")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="google-meet"></wy-icon>
                </wy-button>
              ` : v}
          ${this.componentFeatures?.allowsAnyFeature(M.Meetings, M.MicrosoftTeams) ? h`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("microsoft")}
                  title=${b("Microsoft Teams")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="microsoft-teams"></wy-icon>
                </wy-button>
              ` : v}
          ${this.componentFeatures?.allowsFeature(M.Polls) ? h`<wy-button
                kind="icon"
                @click=${() => this.openPolls()}
                title=${b("Poll")}
                ?disabled=${this.disabled}
              >
                <wy-icon name="poll"></wy-icon>
              </wy-button>` : v}
        </div>

        <!-- Button -->
        <wy-button @click="${() => this.submit()}" color="primary" title=${this.buttonText} ?disabled=${this.disabled}>
          ${this.buttonText}
        </wy-button>
      </div>
    `;
  }
  /**
   * Render the bottom slot which aggregates lists (polls, meetings, file uploads, attachments, embeds).
   *
   * @internal
   */
  renderBottomSlot() {
    return [this.renderLists()];
  }
  /**
   * Render the lists section (poll options, meetings, file uploads, attachments, embeds).
   *
   * @internal
   */
  renderLists() {
    const t = this.mutatingFiles.result, e = this.componentFeatures?.allowsFeature(M.Polls) && this.showPolls && this.pollOptions.length > 0 || !1, r = this.meeting?.provider === "zoom" && this.componentFeatures?.allowsAnyFeature(M.Meetings, M.ZoomMeetings) || this.meeting?.provider === "google" && this.componentFeatures?.allowsAnyFeature(M.Meetings, M.GoogleMeet) || this.meeting?.provider === "microsoft" && this.componentFeatures?.allowsAnyFeature(M.Meetings, M.MicrosoftTeams) || !1, s = t && t.length > 0 || !1, n = this.attachments && this.attachments.length > 0, o = this.componentFeatures?.allowsFeature(M.Embeds) && this.embeds.length > 0 || !1;
    return this.disabled || !(e || r || s || n || o) ? v : h` <div part="wy-editor-parts">
      <!-- polls -->
      ${e ? h`
            <div part="wy-poll-form">
              ${this.pollOptions.map((c, l) => {
      const u = l + 1;
      return h`<input
                  value="${c.text}"
                  part="wy-input"
                  type="text"
                  placeholder=${b(ut`Option ${u}`)}
                  @change=${(f) => this.handlePollOptionChange(f, l)}
                  @keyup=${Rr}
                  @focus=${(f) => this.handlePollOptionAdd(f, l)}
                />`;
    })}
            </div>
          ` : v}

      <!-- meetings -->
      ${r && this.meeting ? h`
            <wy-item size="sm">
              <wy-icon slot="image" svg="${Ru(this.meeting.provider)}"></wy-icon>
              <span slot="title">${Eu(this.meeting.provider)}</span>
              <wy-button slot="actions" kind="icon" @click=${() => this.handleRemoveMeeting()}>
                <wy-icon name="close"></wy-icon>
              </wy-button>
            </wy-item>
          ` : v}

      <!-- blobs -->
      ${s && t ? h`<div>
            ${Fe(
      t,
      (c) => "mutation" + c.submittedAt,
      (c) => {
        if (c.context?.file) {
          const l = c.context.file, u = {
            ...c.context.status
          };
          return h`
                    <wy-file-item
                      .file=${c.context.file}
                      .status=${u}
                      title="${Hf(c.context.type)}: ${l.name + (u.text ? `: ${u.text}` : "")}"
                    >
                      <span slot="title"
                        ><strong></strong> ${l.name}
                        ${u.text ? h`: <em>${u.text}</em>` : v}</span
                      >
                      ${u.state === "pending" ? h`
                            <wy-progress-circular
                              slot="actions"
                              padded
                              ?indeterminate=${!u.progress}
                              .max=${100}
                              .value=${u.progress || 0}
                            ></wy-progress-circular>
                          ` : v}
                      <wy-button
                        slot="actions"
                        kind="icon"
                        @click=${() => {
            this.handleRemoveUpload(c);
          }}
                        title=${b("Discard", { desc: "Button action to discard" })}
                      >
                        <wy-icon name="close"></wy-icon>
                      </wy-button>
                    </wy-file-item>
                  `;
        }
        return v;
      }
    )}
          </div>` : v}

      <!-- attachments -->
      ${n ? this.attachments.map(
      (c) => h`<wy-file-item .file=${c} title="${c.name}">
              <span slot="title">${c.name}</span>
              <wy-button
                slot="actions"
                kind="icon"
                @click=${() => this.handleRemoveAttachment(c)}
                title=${b("Remove", { desc: "Button action to remove" })}
              >
                <wy-icon name="close"></wy-icon>
              </wy-button>
            </wy-file-item>`
    ) : v}

      <!-- embeds -->
      ${o ? h`
            <wy-embed-select
              .embeds=${this.embeds}
              @embed-remove=${(c) => this.removeEmbed(c)}
              @embed-swap=${() => this.swapEmbed()}
            ></wy-embed-select>
          ` : v}
    </div>`;
  }
  /**
   * Render the cloud files picker if cloud files feature is enabled.
   *
   * @internal
   */
  renderCloudFiles() {
    return this.disabled ? v : h`
      <wy-cloud-files
        ${j(this.cloudFilesRef)}
        @external-blobs=${(t) => this.handleExternalBlobs(t.detail.externalBlobs)}
      ></wy-cloud-files>
    `;
  }
  render() {
    const t = this.dropZone.isDragActive;
    return h`
      <div
        part=${K({
      "wy-editor": !0,
      [this.editorClass]: !0,
      "wy-dragging": t
    })}
        data-drag-title=${b("Drop files here")}
      >
        ${this.renderTopSlot()} ${this.renderMiddleSlot()} ${this.renderBottomSlot()}
      </div>
      ${this.renderCloudFiles()}
    `;
  }
}, a(bo, "WyEditor"), bo);
vt.styles = [zt, O4, I4, vy, _v, jr];
St([
  p({ type: Boolean })
], vt.prototype, "disabled", 2);
St([
  p({ attribute: !1 })
], vt.prototype, "parentId", 2);
St([
  p()
], vt.prototype, "placeholder", 1);
St([
  p()
], vt.prototype, "text", 2);
St([
  p({ type: Object })
], vt.prototype, "metadata", 2);
St([
  p({ attribute: !1 })
], vt.prototype, "embed", 2);
St([
  p({ attribute: !1 })
], vt.prototype, "options", 2);
St([
  p({ attribute: !1 })
], vt.prototype, "attachments", 2);
St([
  p()
], vt.prototype, "buttonText", 2);
St([
  p({ type: Boolean })
], vt.prototype, "typing", 2);
St([
  p({ type: Boolean })
], vt.prototype, "draft", 2);
St([
  p()
], vt.prototype, "editorType", 2);
St([
  p()
], vt.prototype, "editorClass", 2);
St([
  p()
], vt.prototype, "editorLocation", 2);
St([
  F()
], vt.prototype, "meeting", 2);
St([
  F()
], vt.prototype, "editorError", 2);
St([
  F()
], vt.prototype, "showPolls", 2);
St([
  F()
], vt.prototype, "pollOptions", 2);
St([
  F()
], vt.prototype, "embeds", 1);
St([
  F()
], vt.prototype, "draftKey", 2);
St([
  F()
], vt.prototype, "mutationAppId", 2);
St([
  F()
], vt.prototype, "keyMap", 2);
St([
  F()
], vt.prototype, "editorExtensions", 2);
St([
  F()
], vt.prototype, "editor", 2);
vt = St([
  H("wy-editor"),
  ot()
], vt);
var N4 = Object.getOwnPropertyDescriptor, j4 = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? N4(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = o(s) || s);
  return s;
}, "__decorateClass$H"), xo;
let rh = (xo = class extends vt {
  constructor() {
    super(), this.editorType = "comments", this.editorClass = "wy-comment-editor";
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("editorLocation") && (this.editorLocation === "files" ? this.editorClass = "wy-comment-editor wy-comment-editor-bottom" : this.editorLocation === "apps" && (this.editorClass = "wy-comment-editor wy-comment-editor-bottom"));
  }
  /**
   * Render the top slot for comment editor with no content.
   *
   * @internal
   */
  renderTopSlot() {
    return v;
  }
  /**
   * Render the primary middle slot containing the add-menu, editor and send button.
   *
   * Overrides the base implementation to provide message-specific controls and layout.
   *
   * @internal
   */
  renderMiddleSlot() {
    return h`<div part="wy-comment-editor-inputs">
      <!-- Add -->
      ${this.componentFeatures?.allowsAnyFeature(
      M.Attachments,
      M.CloudFiles,
      M.Meetings,
      M.ZoomMeetings,
      M.GoogleMeet,
      M.MicrosoftTeams,
      M.Polls
    ) ? h`<wy-dropdown icon="plus" directionY="up" ?disabled=${this.disabled}>
            ${this.componentFeatures?.allowsFeature(M.Attachments) ? h`<wy-dropdown-item @click=${this.openFileInput} title=${b("From device")}>
                    <wy-icon name="attachment"></wy-icon>
                    <span>${b("From device")}</span>
                  </wy-dropdown-item>
                  <input
                    type="file"
                    ${j(this.fileInputRef)}
                    @click=${(t) => t.stopPropagation()}
                    @change=${(t) => this.handleUploadFiles(
      Array.from(t.target.files || []),
      t.target
    )}
                    multiple
                    hidden
                    tabindex="-1"
                  />` : v}
            ${this.componentFeatures?.allowsFeature(M.CloudFiles) ? h`<wy-dropdown-item @click=${this.openCloudFiles} title=${b("From cloud")}>
                  <wy-icon name="cloud"></wy-icon>
                  <span>${b("From cloud")}</span>
                </wy-dropdown-item>` : v}
            ${this.componentFeatures?.allowsAnyFeature(M.Meetings, M.ZoomMeetings) ? h`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("zoom")} title=${b("Zoom meeting")}>
                    <wy-icon svg="zoom-meetings"></wy-icon>
                    <span>${b("Zoom meeting")}</span>
                  </wy-dropdown-item>
                ` : v}
            ${this.componentFeatures?.allowsAnyFeature(M.Meetings, M.GoogleMeet) ? h`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("google")} title=${b("Google Meet")}>
                    <wy-icon svg="google-meet"></wy-icon>
                    <span>${b("Google Meet")}</span>
                  </wy-dropdown-item>
                ` : v}
            ${this.componentFeatures?.allowsAnyFeature(M.Meetings, M.MicrosoftTeams) ? h`
                  <wy-dropdown-item
                    @click=${() => this.handleMeetingClick("microsoft")}
                    title=${b("Microsoft Teams")}
                  >
                    <wy-icon svg="microsoft-teams"></wy-icon>
                    <span>${b("Microsoft Teams")}</span>
                  </wy-dropdown-item>
                ` : v}
            ${this.componentFeatures?.allowsFeature(M.Polls) ? h`<wy-dropdown-item @click=${() => this.openPolls()} title=${b("Poll")}>
                  <wy-icon name="poll"></wy-icon>
                  <span>${b("Poll")}</span>
                </wy-dropdown-item>` : v}
          </wy-dropdown>` : v}

      <!-- Input -->
      <div
        part=${K({ "wy-comment-editor-text": !0, "wy-is-invalid": this.editorError })}
        ${j(this.editorRef)}
      >
        ${this.renderEditorDummy()}
      </div>

      <!-- Button -->
      <wy-button kind="icon" @click="${() => this.submit()}" title=${this.buttonText} ?disabled=${this.disabled}>
        <wy-icon name="send"></wy-icon>
      </wy-button>
    </div>`;
  }
  /**
   * Render content that appears below the message editor.
   *
   * By default returns the same lists section used by the base editor.
   *
   * @internal
   */
  renderBottomSlot() {
    return [
      this.renderLists()
    ];
  }
}, a(xo, "WyCommentEditor"), xo);
rh.styles = [...vt.styles, b4];
rh = j4([
  H("wy-comment-editor"),
  ot()
], rh);
var W4 = Object.defineProperty, Q4 = Object.getOwnPropertyDescriptor, Mv = /* @__PURE__ */ a((i) => {
  throw TypeError(i);
}, "__typeError$9"), Qc = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? Q4(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && W4(t, e, s), s;
}, "__decorateClass$G"), Sv = /* @__PURE__ */ a((i, t, e) => t.has(i) || Mv("Cannot " + e), "__accessCheck$9"), Sd = /* @__PURE__ */ a((i, t, e) => (Sv(i, t, "read from private field"), e ? e.call(i) : t.get(i)), "__privateGet$9"), Hp = /* @__PURE__ */ a((i, t, e) => t.has(i) ? Mv("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(i) : t.set(i, e), "__privateAdd$9"), Vp = /* @__PURE__ */ a((i, t, e, r) => (Sv(i, t, "write to private field"), t.set(i, e), e), "__privateSet$8"), Ld, Du, rn, $o;
let tr = ($o = class extends Rt {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.location = "apps", this.reveal = !1, this.padded = !1, Hp(this, Ld), Hp(this, Du, new Promise((t) => {
      Vp(this, Ld, t);
    })), this.commentsQuery = new Ki(this), this.addCommentMutation = new We(this), this.infiniteScroll = new Gi(this), this.pagerRef = et(), Hp(this, rn), this.handleRealtimeCommentCreated = () => {
      this.weavy?.queryClient.invalidateQueries({ queryKey: [this.location, this.parentId, "comments"] });
    }, this.handleRealtimeReactionAdded = (t) => {
      !this.weavy || t.entity.type !== ve.Comment || qt(
        this.weavy.queryClient,
        [this.location, this.parentId, "comments"],
        t.entity.id,
        (e) => {
          Sl(e, t.reaction, t.actor);
        }
      );
    }, this.handleRealtimeReactionDeleted = (t) => {
      !this.weavy || t.entity.type !== ve.Comment || qt(
        this.weavy.queryClient,
        [this.location, this.parentId, "comments"],
        t.entity.id,
        (e) => {
          Sl(e, void 0, t.actor);
        }
      );
    };
  }
  /**
   * Resolves when `parentId` is available.
   *
   * @returns Promise<number>
   */
  async whenParentId() {
    return await Sd(this, Du);
  }
  async willUpdate(t) {
    var e, r;
    if (super.willUpdate(t), t.has("parentId") && this.parentId && ((e = Sd(this, Ld)) == null || e.call(this, this.parentId)), (t.has("parentId") || t.has("weavy") || t.has("componentFeatures")) && this.parentId && this.weavy && (await this.commentsQuery.trackInfiniteQuery(d4(this.weavy, this.location, this.parentId)), await this.addCommentMutation.trackMutation(p4(this.weavy)), this.removeCommentMutation = y4(this.weavy, this.location, this.parentId), this.restoreCommentMutation = f4(this.weavy, this.location, this.parentId)), (t.has("weavy") || t.has("app") || t.has("componentFeatures")) && this.weavy && this.app) {
      this.pollMutation = sy(this.weavy, this.app.id, [this.location, this.parentId, "comments"]), (r = Sd(this, rn)) == null || r.call(this);
      const s = `a${this.app.id}`;
      this.weavy.subscribe(s, "comment_created", this.handleRealtimeCommentCreated), this.componentFeatures?.allowsFeature(M.Reactions) && (this.weavy.subscribe(s, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(s, "reaction_removed", this.handleRealtimeReactionDeleted)), Vp(this, rn, () => {
        this.weavy?.unsubscribe(s, "comment_created", this.handleRealtimeCommentCreated), this.weavy?.unsubscribe(s, "reaction_added", this.handleRealtimeReactionAdded), this.weavy?.unsubscribe(s, "reaction_removed", this.handleRealtimeReactionDeleted), Vp(this, rn, void 0);
      });
    }
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.commentsQuery.result, this.pagerRef.value);
  }
  /**
   * Handle submit from the comment editor and trigger add comment mutation.
   *
   * @internal
   */
  async handleSubmit(t) {
    this.app && this.parentId && this.user && await this.addCommentMutation.mutate({
      app_id: this.app.id,
      parent_id: this.parentId,
      type: this.location,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      context: t.detail.contextData,
      user: this.user
    });
  }
  /**
   * Render comment items from a flattened page array.
   *
   * @internal
   */
  renderComments(t) {
    return t ? Fe(
      t,
      (e) => e.id,
      (e) => this.parentId ? h`<wy-comment
                id="comment-${e.id}"
                ?reveal=${this.reveal}
                .parentId=${this.parentId}
                .location=${this.location}
                .comment=${e}
                @trash=${async (r) => {
        const s = await this.whenApp(), n = await this.whenParentId();
        this.removeCommentMutation?.mutate({
          id: r.detail.id,
          appId: s.id,
          parentId: n,
          type: this.location
        });
      }}
                @restore=${async (r) => {
        const s = await this.whenApp(), n = await this.whenParentId();
        this.restoreCommentMutation?.mutate({
          id: r.detail.id,
          appId: s.id,
          parentId: n,
          type: this.location
        });
      }}
                @vote=${(r) => {
        r.detail.parentId && r.detail.parentType && this.pollMutation?.mutate({
          optionId: r.detail.optionId,
          parentType: r.detail.parentType,
          parentId: r.detail.parentId
        });
      }}
              ></wy-comment>` : v
    ) : v;
  }
  render() {
    const { data: t, hasNextPage: e, isPending: r } = this.commentsQuery.result ?? {}, s = Zi(t);
    return h`
      ${s && s.length ? h`
            <div part="wy-comments">
              ${this.renderComments(s)}
              ${e ? h`<div ${j(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : v}
            </div>
          ` : h`
            <wy-empty noNetwork
              ><wy-progress-circular indeterminate padded reveal ?hidden=${!r}></wy-progress-circular
            ></wy-empty>
          `}

      <wy-comment-editor
        editorLocation=${this.location}
        .parentId=${this.parentId}
        .typing=${!1}
        .draft=${!0}
        ?disabled=${!gc(ms.Create, this.app?.permissions)}
        placeholder=${this.placeholder ?? b("Create a comment...")}
        buttonText=${b("Comment", { desc: "Button action to comment" })}
        @submit=${(n) => this.handleSubmit(n)}
      ></wy-comment-editor>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = Sd(this, rn)) == null || t.call(this), super.disconnectedCallback();
  }
}, a($o, "WyCommentList"), $o);
Ld = /* @__PURE__ */ new WeakMap();
Du = /* @__PURE__ */ new WeakMap();
rn = /* @__PURE__ */ new WeakMap();
tr.styles = [xy, Br];
Qc([
  p({ type: Number })
], tr.prototype, "parentId", 2);
Qc([
  p({ attribute: !1 })
], tr.prototype, "location", 2);
Qc([
  p()
], tr.prototype, "placeholder", 2);
Qc([
  p({ type: Boolean, reflect: !0 })
], tr.prototype, "reveal", 2);
Qc([
  p({ type: Boolean, reflect: !0 })
], tr.prototype, "padded", 2);
tr = Qc([
  H("wy-comment-list"),
  ot()
], tr);
function $y(i, t) {
  return ["apps", i.id, "file", t.id, "versions"];
}
a($y, "getFileVersionsKey");
function K4(i, t, e) {
  const r = i.queryClient, s = ["apps", t.id, "files"], n = $y(t, e), o = {
    mutationKey: s,
    mutationFn: /* @__PURE__ */ a(async ({ versionFile: c }) => {
      if (c.id >= 1 && c.rev) {
        if (!(await i.fetch(`/api/files/${c.id}/versions/${c.rev}/restore`, {
          method: "POST"
        })).ok)
          throw new Error();
      } else
        throw new Error(`Could not restore ${c.name} to version ${c.rev}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((c) => (ct(
      r,
      { queryKey: o.mutationKey, exact: !1 },
      c.versionFile.id,
      (l) => Object.assign(l, c.versionFile, { status: "pending" })
    ), { type: "version", file: e, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ a((c, l) => {
      ct(
        r,
        { queryKey: o.mutationKey, exact: !1 },
        l.versionFile.id,
        (u) => Object.assign(u, c, { status: "ok" })
      ), Ft(r, o.mutationKey, l, (u) => {
        u.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ a((c, l, u) => {
      u?.file && ct(
        r,
        { queryKey: o.mutationKey, exact: !1 },
        l.versionFile.id,
        (f) => Object.assign(f, u.file, { status: "error" })
      ), Ft(r, o.mutationKey, l, (f) => {
        f.status.state = "error", f.status.text = c.message;
      });
    }, "onError"),
    onSettled: /* @__PURE__ */ a(async () => {
      await r.invalidateQueries({ queryKey: n });
    }, "onSettled")
  };
  return o;
}
a(K4, "getFileVersionRestoreMutationOptions");
function G4(i, t, e) {
  return new $t(i.queryClient, K4(i, t, e));
}
a(G4, "getFileVersionRestoreMutation");
function Z4(i, t, e) {
  const r = i.queryClient, s = $y(t, e);
  return {
    mutationKey: s,
    mutationFn: /* @__PURE__ */ a(async ({ versionFile: o }) => {
      if (o.id >= 1 && o.rev) {
        const c = await i.fetch(`/api/files/${o.id}/versions/${o.rev}`, {
          method: "DELETE"
        });
        if (!c.ok) {
          const l = await c.json();
          throw new Error(l.detail || l.title, { cause: l });
        }
      } else {
        const c = {
          status: 400,
          title: `Could not remove ${o.name} version ${o.rev}.`
        };
        throw new Error(c.detail || c.title, { cause: c });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((o) => {
      qt(
        r,
        s,
        /* @__PURE__ */ a((l) => l.id === o.versionFile.id && l.rev === o.versionFile.rev, "versionPredicate"),
        (l) => Object.assign(l, { status: "pending" })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((o, c) => {
      fh(r, s, /* @__PURE__ */ a((u) => u.id === c.versionFile.id && u.rev === c.versionFile.rev, "versionPredicate"));
    }, "onSuccess"),
    onError: /* @__PURE__ */ a((o, c) => {
      qt(
        r,
        s,
        /* @__PURE__ */ a((u) => u.id === c.versionFile.id && u.rev === c.versionFile.rev, "versionPredicate"),
        (u) => Object.assign(u, { status: void 0 })
      );
    }, "onError")
  };
}
a(Z4, "getFileVersionDeleteMutationOptions");
function Y4(i, t, e) {
  return new $t(i.queryClient, Z4(i, t, e));
}
a(Y4, "getFileVersionDeleteMutation");
var X4 = Object.defineProperty, J4 = Object.getOwnPropertyDescriptor, Cy = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? J4(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && X4(t, e, s), s;
}, "__decorateClass$F"), Co;
let Rl = (Co = class extends Rt {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.fileVersionsQuery = new Ie(this);
  }
  /**
   * Selects the provided version and emits `file-version-select`.
   *
   * @param versionFile - Version to select.
   */
  selectVersion(t) {
    this.activeVersion = t, this.dispatchFileVersionSelect(t);
  }
  /**
   * Emit a `file-version-select` event with the chosen version.
   *
   * @internal
   * @param versionFile - Version to announce.
   * @returns Whether the event was not canceled.
   */
  dispatchFileVersionSelect(t) {
    const e = new CustomEvent("file-version-select", {
      detail: { versionFile: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Revert the file to the supplied version.
   *
   * @internal
   * @param versionFile - Version to restore.
   */
  handleRevert(t) {
    this.fileVersionRestoreMutation?.mutate({ versionFile: t }), this.selectVersion(t);
  }
  /**
   * Remove the supplied version and adjust the active selection if needed.
   *
   * @internal
   * @param versionFile - Version to delete.
   */
  handleRemove(t) {
    this.fileVersionDeleteMutation?.mutate({ versionFile: t }), this.activeVersion === t && (this.activeVersion = this.file);
  }
  /**
   * Download the provided version via the browser.
   *
   * @internal
   * @param file - Version file to download.
   */
  triggerDownload(t) {
    Wi(t.download_url, "_top", t.name, !0);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("file") || t.has("app")) && this.weavy && this.file && this.app && (await this.fileVersionsQuery.trackQuery(
      sd(
        this.weavy,
        $y(this.app, this.file),
        `/api/files/${this.file.id}/versions`
      )
    ), this.fileVersionRestoreMutation = G4(this.weavy, this.app, this.file), this.fileVersionDeleteMutation = Y4(this.weavy, this.app, this.file));
  }
  render() {
    const { data: t, isPending: e } = this.fileVersionsQuery.result ?? { isPending: !0 };
    return e ? h`<wy-progress-circular indeterminate overlay></wy-progress-circular>` : t?.data ? h`
          <wy-item-list part="wy-versions">
            ${Fe(
      t.data,
      (r) => r.id,
      (r, s) => {
        const n = Ur(r.name || "").icon, o = t.data ? t.data.length - s : NaN, c = ii(r.name), l = new Date(r.updated_at || r.created_at), u = !!this.file.external_url, f = new Intl.DateTimeFormat(this.weavy?.locale, {
          dateStyle: "full",
          timeStyle: "short"
        }).format(l), $ = Wc(this.weavy?.locale, new Date(l));
        return u ? h`
                      <wy-empty noNetwork>
                        <span slot="title">${b("Versions are not available for external cloud files.")}</span>
                      </wy-empty>
                    ` : h`
                      <wy-item
                        size="lg"
                        interactive
                        ?selected=${r.rev == this.activeVersion?.rev}
                        tabindex="0"
                        @click=${() => this.selectVersion(r)}
                        @keydown=${le}
                        @keyup=${Me}
                      >
                        <wy-icon
                          slot="image"
                          name=${n}
                          size="48"
                          kind=${r.kind}
                          ext=${c}
                        ></wy-icon>
                        <span slot="title">${o}. ${r.name}</span>
                        <span slot="text">
                          <time datetime=${r.updated_at || r.created_at} title=${f}
                            >${$}</time
                          >
                          ${r.updated_by ? h`· ${r.updated_by?.name}` : v}
                        </span>

                        <wy-dropdown slot="actions" directionX="left">
                          <wy-dropdown-item @click=${() => this.triggerDownload(r)}>
                            <wy-icon name="download"></wy-icon>
                            ${b("Download")}
                          </wy-dropdown-item>

                          ${s !== 0 ? h`
                                <wy-dropdown-divider></wy-dropdown-divider>
                                <wy-dropdown-item @click=${() => this.handleRevert(r)}>
                                  <wy-icon name="restore"></wy-icon>
                                  ${"Revert"}
                                </wy-dropdown-item>
                                <wy-dropdown-item @click=${() => this.handleRemove(r)}>
                                  <wy-icon name="delete"></wy-icon>
                                  ${b("Remove", { desc: "Button action to remove" })}
                                </wy-dropdown-item>
                              ` : v}
                        </wy-dropdown>
                      </wy-item>
                    `;
      }
    )}
          </wy-item-list>
        ` : v;
  }
}, a(Co, "WyFileVersions"), Co);
Cy([
  p({ attribute: !1 })
], Rl.prototype, "file", 2);
Cy([
  p({ attribute: !1 })
], Rl.prototype, "activeVersion", 2);
Rl = Cy([
  H("wy-file-versions"),
  ot()
], Rl);
var t3 = Object.defineProperty, e3 = Object.getOwnPropertyDescriptor, ne = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? e3(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && t3(t, e, s), s;
}, "__decorateClass$E"), ko;
let Vt = (ko = class extends Rt {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.currentId = NaN, this.isAttachment = !1, this.filled = !1, this.showOverlay = !1, this.commentsOpen = !1, this.versionsOpen = !1, this.sidePanelMaximized = !1, this.persistState = new vs(this), this.swipeScroller = new _u(this), this.previewFileRef = et(), this.nextRef = et(), this.prevRef = et(), this.loadingQueue = [], this.disableSwipeScroll = !1, this.handleKeys = (t) => {
      this.showOverlay && (t.key === "ArrowLeft" ? (t.stopPropagation(), this.setPrev()) : t.key === "ArrowRight" && (t.stopPropagation(), this.setNext()));
    };
  }
  /**
   * Moves a file to the front of the loading queue.
   *
   * @internal
   * @param file - File to prioritize.
   * @param state - Optional state override.
   */
  moveFirstInQueue(t, e) {
    let r = { file: t };
    const s = this.loadingQueue.filter((n) => n.file === t ? (r = n, !1) : !0);
    this.loadingQueue = [{ ...r, ...e }, ...s];
  }
  /**
   * Updates loading metadata for the supplied file.
   *
   * @internal
   * @param file - File whose state should change.
   * @param state - State patch to merge.
   */
  updateLoadingState(t, e) {
    t && (this.loadingQueue = this.loadingQueue.map((r) => t === r.file ? { ...r, ...e } : r));
  }
  /**
   * Marks the next unloaded item as loading.
   *
   * @internal
   */
  loadNextInQueue() {
    const t = this.loadingQueue.find((e) => !e.loaded);
    t && !t?.loading && this.updateLoadingState(t.file, { loading: !0 });
  }
  /**
   * Emits `wy-preview-open` with the current preview context.
   *
   * @internal
   */
  async dispatchOpen() {
    const t = await this.whenApp(), e = await this.whenComponentFeatures(), r = this.currentId, s = this.commentsOpen ? "comments" : this.versionsOpen ? "versions" : void 0, n = this.currentFile ? [this.currentFile] : [], o = this.isAttachment, c = this.contextDataBlobs, l = new CustomEvent("wy-preview-open", {
      detail: {
        fileId: r,
        tab: s,
        files: n,
        app: t,
        features: e.allowedFeatures().join(" "),
        isAttachment: o,
        contextDataBlobs: c
      },
      cancelable: !0,
      bubbles: !1,
      composed: !0
    });
    this.dispatchEvent(l) || (this.showOverlay = !1, this.commentsOpen = !1, this.versionsOpen = !1);
  }
  /**
   * Emits the `wy-preview-close` event.
   *
   * @internal
   */
  dispatchClose() {
    const t = new CustomEvent("wy-preview-close", {
      cancelable: !1,
      bubbles: !1,
      composed: !0
    });
    this.dispatchEvent(t);
  }
  /**
   * Opens the overlay for the provided file identifier.
   *
   * @param fileId - File to display.
   * @param showTab - Optional sidebar tab to activate.
   */
  async open(t, e) {
    await this.whenApp(), await this.updateComplete, t && (this.currentId = t), e && this.toggleSidebarTab(e, !0), this.showOverlay = !0;
  }
  /**
   * Closes the preview overlay.
   */
  close() {
    this.showOverlay = !1;
  }
  /**
   * Toggles sidebar visibility for comments or versions.
   *
   * @internal
   * @param tab - Sidebar to affect.
   * @param state - Forced open state; toggles when omitted.
   */
  toggleSidebarTab(t, e) {
    t === "comments" ? (this.versionsOpen = !1, this.commentsOpen = e !== void 0 ? e : !this.commentsOpen) : t === "versions" ? (this.commentsOpen = !1, this.versionsOpen = e !== void 0 ? e : !this.versionsOpen) : (this.commentsOpen = !1, this.versionsOpen = !1);
  }
  /**
   * Handles file version selection events.
   *
   * @internal
   * @param e - Version selection event.
   */
  handleVersionFile(t) {
    this.currentVersionFile = t.detail.versionFile;
  }
  /**
   * Scrolls to the previous preview area.
   *
   * @internal
   */
  scrollToPrev() {
    this.prevRef.value && (this.unblockSwipeScroll(), this.prevRef.value.scrollIntoView({ behavior: this.weavy?.scrollBehavior }));
  }
  /**
   * Scrolls to the next preview area.
   *
   * @internal
   */
  scrollToNext() {
    this.nextRef.value && (this.unblockSwipeScroll(), this.nextRef.value.scrollIntoView({ behavior: this.weavy?.scrollBehavior }));
  }
  /**
   * Disables swipe scrolling for a short duration.
   *
   * @internal
   * @param duration - Milliseconds before re-enabling.
   */
  blockSwipeScroll(t = 20) {
    window.clearTimeout(this.disableSwipeScrollTimeout), this.disableSwipeScroll = !0, this.disableSwipeScrollTimeout = window.setTimeout(() => this.disableSwipeScroll = !1, t);
  }
  /**
   * Re-enables swipe scrolling immediately.
   *
   * @internal
   */
  unblockSwipeScroll() {
    window.clearTimeout(this.disableSwipeScrollTimeout), this.disableSwipeScroll = !1;
  }
  /**
   * Selects the previous file when available.
   *
   * @internal
   */
  setPrev() {
    this.previousFile && (this.currentId = this.previousFile.id, this.blockSwipeScroll());
  }
  /**
   * Selects the next file when available.
   *
   * @internal
   */
  setNext() {
    this.nextFile && (this.currentId = this.nextFile.id, this.blockSwipeScroll());
  }
  /**
   * Registers swipe observers on the active scroll element.
   *
   * @internal
   */
  registerSwipeScroller() {
    this.swipeScrollElement && (this.swipeScroller.whenPrev ??= () => this.setPrev(), this.swipeScroller.whenNext ??= () => this.setNext(), this.swipeScroller.createObserver(this.swipeScrollElement));
  }
  async willUpdate(t) {
    if (super.willUpdate(t), (t.has("app") || t.has("user")) && this.app && this.user && !this.isAttachment && (this.persistState.observe(
      [
        { name: "commentsOpen", override: !0 },
        { name: "versionsOpen", override: !0 }
      ],
      `a${this.app.id}-preview`,
      `u${this.user.id}`
    ), this.commentsOpen && this.versionsOpen && (this.versionsOpen = !1)), t.has("queryResult") && this.queryResult) {
      const { data: e } = this.queryResult ?? {};
      this.files = e?.filter((r) => r && !r.is_trashed);
    }
    if (t.has("infiniteQueryResult") && this.infiniteQueryResult) {
      const { data: e } = this.infiniteQueryResult ?? {};
      this.files = Zi(e).filter((r) => r && !r.is_trashed);
    }
    t.has("currentFile") && this.currentFile && this.currentFile.id !== this.currentId && (this.currentId = this.currentFile.id), (t.has("files") || t.has("currentId") || t.has("showOverlay")) && this.files && this.showOverlay && (this.currentFile = void 0, this.previousFile = void 0, this.nextFile = void 0, this.currentVersionFile = void 0, this.currentVersionFile = this.currentFile = this.files.find((e, r) => this.files && e.id === this.currentId ? (r >= 1 && (this.previousFile = this.files[r - 1]), r < this.files.length - 1 && (this.nextFile = this.files[r + 1]), this.infiniteQueryResult && r >= this.files.length - 2 && this.infiniteQueryResult.hasNextPage && !this.infiniteQueryResult.isFetchingNextPage && this.infiniteQueryResult.fetchNextPage(), this.infiniteQueryResult && r <= 1 && this.infiniteQueryResult.hasPreviousPage && !this.infiniteQueryResult.isFetchingPreviousPage && this.infiniteQueryResult.fetchPreviousPage(), !0) : !1)), t.has("currentFile") && this.currentFile && !this.files && (this.files = [this.currentFile]), t.has("previousFile") && this.previousFile && this.moveFirstInQueue(this.previousFile), t.has("nextFile") && this.nextFile && this.moveFirstInQueue(this.nextFile), t.has("currentVersionFile") && this.currentVersionFile && this.moveFirstInQueue(this.currentVersionFile, { loading: !0 }), t.has("loadingQueue") && this.loadNextInQueue(), t.has("showOverlay") && (this.showOverlay ? await this.dispatchOpen() : t.get("showOverlay") && this.dispatchClose());
  }
  /**
   * Renders the preview header for the active file.
   *
   * @internal
   * @param activeFile - File displayed in the main pane.
   */
  renderHeader(t) {
    return h`
      <wy-titlebar header ?trashed=${!!t?.is_trashed}>
        <wy-button slot="icon" kind="icon" @click=${() => this.close()}><wy-icon name="close"></wy-icon></wy-button>
        ${t ? h` <span slot="title">${t.name}</span> ` : v}
        ${t ? h`
              ${this.componentFeatures?.allowsFeature(M.Comments) && t.id >= 1 && !this.isAttachment ? h`
                    <wy-button
                      slot="actions"
                      kind="icon"
                      ?active=${this.commentsOpen}
                      @click=${() => this.toggleSidebarTab("comments")}
                      title=${b("Comments")}
                    >
                      <wy-icon-stack>
                        ${t.comments?.count && t.comments?.count > 0 ? h`<wy-icon name="comment" state ?active=${!this.commentsOpen}></wy-icon>
                              <wy-icon name="comment" layer state ?active=${this.commentsOpen}></wy-icon>` : h`<wy-icon name="comment-outline" state ?active=${!this.commentsOpen}></wy-icon>
                              <wy-icon name="comment" layer state ?active=${this.commentsOpen}></wy-icon>`}
                      </wy-icon-stack>
                    </wy-button>
                  ` : v}
              <wy-file-menu slot="actions" .file=${t}>
                ${this.componentFeatures?.allowsFeature(M.Versions) && t.id >= 1 && !this.isAttachment ? h`
                      <wy-dropdown-item ?active=${this.versionsOpen} @click=${() => this.toggleSidebarTab("versions")}>
                        <wy-icon name="backup-restore"></wy-icon>
                        ${b("Versions")}
                      </wy-dropdown-item>
                    ` : v}
              </wy-file-menu>
            ` : v}
      </wy-titlebar>
    `;
  }
  render() {
    let t = this.files === void 0;
    this.queryResult ? t = this.queryResult.isPending : this.infiniteQueryResult && (t = this.infiniteQueryResult.isPending);
    const e = [this.previousFile, this.currentVersionFile, this.nextFile].filter((s) => s);
    this.commentsOpen && this.versionsOpen && (this.versionsOpen = !1);
    const r = {
      "wy-preview-swiper-disabled": this.disableSwipeScroll
    };
    return this.weavy ? h`
      <wy-overlay
        part="wy-dark"
        maximized
        noHeader
        type=${this.filled ? "full" : "modal"}
        .show=${this.showOverlay}
        @keyup=${this.handleKeys}
        @close=${() => {
      this.showOverlay = !1;
    }}
      >
        ${this.showOverlay ? h`<div part="wy-preview-layout">
              ${this.renderHeader(this.currentFile)}

              <div part="wy-preview-main">
                ${this.isAttachment ? v : h` <aside
                        id="tab-comments"
                        part="wy-sidebar ${K({
      "wy-active": this.commentsOpen,
      "wy-maximized": this.sidePanelMaximized
    })}"
                        ?hidden=${!this.commentsOpen}
                      >
                        <nav>
                          <wy-item size="md">
                            <span slot="title" part="wy-title">${b("Comments")}</span>
                            <wy-button
                              slot="actions"
                              kind="icon"
                              @click=${() => this.toggleSidebarTab("comments", !1)}
                            >
                              <wy-icon name="close"></wy-icon>
                            </wy-button>
                          </wy-item>
                          <button
                            @click=${() => this.sidePanelMaximized = !this.sidePanelMaximized}
                            part="wy-sidebar-handle"
                            title=${this.sidePanelMaximized ? b("Restore side panel") : b("Maximize side panel")}
                          ></button>
                        </nav>
                        <div part="wy-pane wy-scroll-y">
                          ${this.commentsOpen && this.currentFile && this.currentFile.id >= 1 && this.app && this.user ? h`
                                <wy-comment-list
                                  reveal
                                  .parentId=${this.currentFile.id}
                                  .location=${"files"}
                                ></wy-comment-list>
                              ` : v}
                        </div>
                      </aside>
                      <aside
                        id="tab-versions"
                        part="wy-sidebar ${K({
      "wy-active": this.versionsOpen,
      "wy-maximized": this.sidePanelMaximized
    })}"
                        ?hidden=${!this.versionsOpen}
                      >
                        <nav>
                          <wy-item size="md">
                            <span slot="title" part="wy-title">${b("Versions")}</span>
                            <wy-button
                              slot="actions"
                              kind="icon"
                              @click=${() => this.toggleSidebarTab("versions", !1)}
                            >
                              <wy-icon name="close"></wy-icon>
                            </wy-button>
                          </wy-item>
                          <button
                            @click=${() => this.sidePanelMaximized = !this.sidePanelMaximized}
                            part="wy-sidebar-handle"
                            title=${this.sidePanelMaximized ? b("Restore side panel") : b("Maximize side panel")}
                          ></button>
                        </nav>
                        <div part="wy-pane wy-scroll-y">
                          <div part="wy-pane-body">
                            ${this.versionsOpen && this.currentFile && this.app ? h`
                                  <wy-file-versions
                                    .file=${this.currentFile}
                                    .activeVersion=${this.currentVersionFile}
                                    @file-version-select=${(s) => this.handleVersionFile(s)}
                                  ></wy-file-versions>
                                ` : v}
                          </div>
                        </div>
                      </aside>`}

                <div part="wy-preview">
                  <div
                    ${j((s) => {
      s && (this.swipeScrollElement = s);
    })}
                    part="wy-preview-swiper ${K(r)}"
                  >
                    ${Fe(
      e,
      (s) => "preview-area-" + s?.id,
      (s) => {
        const n = /* @__PURE__ */ a((l) => {
          l?.scrollIntoView(), requestAnimationFrame(() => l?.scrollIntoView());
        }, "currentPreviewFileCallback"), o = s === this.currentVersionFile ? n : s === this.nextFile ? this.nextRef : s === this.previousFile ? this.prevRef : void 0, c = this.loadingQueue.find((l) => l.file === s);
        return s ? h`
                              <div
                                id="preview-${s.id}"
                                ${j(o)}
                                part="wy-preview-area wy-scroll-x-y"
                              >
                                ${!t && (c?.loading || c?.loaded) ? h`
                                      <wy-preview-item
                                        .file=${s}
                                        ?current=${s === this.currentVersionFile}
                                        @file-preview-loaded=${(l) => this.updateLoadingState(l.detail.file, { loaded: !0 })}
                                      ></wy-preview-item>
                                    ` : h` <wy-progress-circular indeterminate overlay></wy-progress-circular> `}
                              </div>
                            ` : v;
      }
    )}
                  </div>
                  ${this.currentFile ? h`
                        ${this.previousFile ? h`
                              <nav part="wy-nav-prev">
                                <wy-button kind="icon" @click=${() => this.scrollToPrev()}>
                                  <wy-icon name="previous"></wy-icon>
                                </wy-button>
                              </nav>
                            ` : v}
                        ${this.nextFile ? h`
                              <nav part="wy-nav-next">
                                <wy-button kind="icon" @click=${() => this.scrollToNext()}>
                                  <wy-icon name="next"></wy-icon>
                                </wy-button>
                              </nav>
                            ` : v}
                      ` : v}
                </div>
              </div>
            </div> ` : v}
      </wy-overlay>
    ` : v;
  }
  updated(t) {
    t.has("swipeScrollElement") && t.get("swipeScrollElement") !== this.swipeScrollElement && this.registerSwipeScroller(), !this.disableSwipeScroll && this.swipeScroller.swipeElement === this.swipeScrollElement ? this.swipeScroller.observe(this.prevRef.value, this.nextRef.value) : this.swipeScroller.clearObserver();
  }
}, a(ko, "WyPreview"), ko);
Vt.styles = [Fx, Dx, qs, Ns, Uc, Yt];
ne([
  p({ attribute: !1 })
], Vt.prototype, "files", 2);
ne([
  p({ attribute: !1 })
], Vt.prototype, "queryResult", 2);
ne([
  p({ attribute: !1 })
], Vt.prototype, "infiniteQueryResult", 2);
ne([
  p({ type: Object })
], Vt.prototype, "user", 2);
ne([
  p({ type: Number })
], Vt.prototype, "currentId", 2);
ne([
  p({ type: Boolean })
], Vt.prototype, "isAttachment", 2);
ne([
  p({ type: Boolean })
], Vt.prototype, "filled", 2);
ne([
  F()
], Vt.prototype, "currentFile", 2);
ne([
  F()
], Vt.prototype, "currentVersionFile", 2);
ne([
  F()
], Vt.prototype, "previousFile", 2);
ne([
  F()
], Vt.prototype, "nextFile", 2);
ne([
  F()
], Vt.prototype, "showOverlay", 2);
ne([
  F()
], Vt.prototype, "commentsOpen", 2);
ne([
  F()
], Vt.prototype, "versionsOpen", 2);
ne([
  F()
], Vt.prototype, "sidePanelMaximized", 2);
ne([
  F()
], Vt.prototype, "swipeScrollElement", 2);
ne([
  F()
], Vt.prototype, "loadingQueue", 2);
ne([
  F()
], Vt.prototype, "disableSwipeScroll", 2);
Vt = ne([
  H("wy-preview"),
  ot()
], Vt);
var i3 = Object.defineProperty, r3 = Object.getOwnPropertyDescriptor, Jt = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? r3(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && i3(t, e, s), s;
}, "__decorateClass$D"), _o;
let Et = (_o = class extends Rt {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.me = !1, this.isAgent = !1, this.isPrivateChat = !1, this.name = "", this.comment = "", this.avatar = "", this.createdAt = "", this.html = "", this.text = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.seenBy = [], this.highlight = !1, this.previewAnnotationsRef = et(), this.previewAttachmentsRef = et(), this.highlightRef = et();
  }
  /**
   * Emit a `vote` event for the specified poll option.
   *
   * @internal
   * @param optionId - Identifier of the selected poll option.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", {
      detail: { optionId: t, parentId: this.messageId }
    });
    return this.dispatchEvent(e);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("link") && (this.highlight = !!(this.link && Mh(this.link, ve.Message, { id: this.messageId })));
  }
  render() {
    const t = this.attachments?.filter((o) => o.kind === "image" && o.thumbnail_url) || [], e = this.attachments?.filter((o) => o.kind !== "image" || !o.thumbnail_url) || [], r = this.createdAt ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.createdAt)
    ) : "", s = this.createdAt ? new Intl.DateTimeFormat(this.weavy?.locale, { timeStyle: "short" }).format(new Date(this.createdAt)) : "", n = !this.annotations?.length && !this.attachments?.length && !this.embed && !this.meeting && !this.pollOptions?.length && g1(this.text);
    return h`
      <div
        part=${K({ "wy-message": !0, "wy-message-me": this.me, "wy-message-agent": this.isAgent, "wy-highlight": this.highlight })}
        ${j(this.highlightRef)}
      >
        ${this.me ? "" : h`
              <div part="wy-message-author">
                <wy-avatar
                  .src=${this.avatar}
                  .size=${32}
                  .name=${this.name}
                  .description=${this.comment}
                  .isAgent=${this.isAgent}
                ></wy-avatar>
              </div>
            `}

        <div part="wy-message-content">
          <div part="wy-message-meta">
            ${!this.isPrivateChat && !this.me ? h` <span>${this.name} · </span> ` : ""}
            <time datetime=${this.createdAt} title=${r}>${s}</time>
          </div>

          <div part=${K({ "wy-message-bubble": !0, "wy-message-bubble-emoji": n })}>
            ${this.messageId < 0 ? h`<wy-skeleton .text=${this.text}></wy-skeleton>` : h`
                  ${t && t.length ? h`<wy-image-grid
                        part="wy-message-bubble-section"
                        .images=${t}
                        @file-open=${(o) => {
      this.previewAttachmentsRef.value?.open(o.detail.fileId);
    }}
                      ></wy-image-grid>` : v}


                  <!-- text -->
                  ${this.html ? h`<div part=${K({ "wy-content": !0, "wy-message-bubble-section": !0, "wy-content-emoji": n })}>${bs(this.html)}</div>` : v}

                  ${this.annotations && this.annotations.length ? h`<wy-annotation-list
                        part="wy-message-bubble-section"
                        .files=${this.annotations}
                        @file-open=${(o) => {
      this.previewAnnotationsRef.value?.open(o.detail.fileId);
    }}
                      ></wy-annotation-list>` : v}

                  ${this.pollOptions && this.pollOptions.length ? h`<wy-poll
                        .pollOptions=${this.pollOptions}
                        @vote=${(o) => this.dispatchVote(o.detail.optionId)}
                      ></wy-poll>` : v}

                  ${this.componentFeatures?.allowsFeature(M.Embeds) && this.embed ? h` <wy-embed .embed=${this.embed}></wy-embed> ` : v}

                  ${e && e.length ? h`<wy-attachment-list
                        filled
                        part="wy-message-bubble-section"
                        .files=${e}
                        @file-open=${(o) => {
      this.previewAttachmentsRef.value?.open(o.detail.fileId);
    }}
                      ></wy-attachment-list>` : v}

                  ${this.meeting ? h`<wy-meeting-card .meeting=${this.meeting}></wy-meeting-card>` : v}

                  ${this.componentFeatures?.allowsFeature(M.Reactions) && this.conversation ? h`
                        ${Rd(
      `reactions-${this.conversation.id}-${this.messageId}`,
      h`<wy-reactions
                            lineBelow
                            ?lineReverse=${!this.me}
                            small
                            directionX=${this.me ? "right" : "left"}
                            .reactions=${this.reactions}
                            parentId=${this.conversation.id}
                            parentType="apps"
                            entityId=${this.messageId}
                            entityType="messages"
                          ></wy-reactions>`
    )}
                      ` : v}
                `}
          </div>
        </div>
      </div>
      ${this.componentFeatures?.allowsFeature(M.Receipts) ? h`<div part="wy-message-seenby">
            ${this.seenBy && this.seenBy.length ? h`
                  ${this.seenBy.map((o) => {
      const c = o.marked_at ? new Intl.DateTimeFormat(this.weavy?.locale, {
        dateStyle: "full",
        timeStyle: "short"
      }).format(new Date(o.marked_at)) : "";
      return h`<wy-avatar
                      title=${b(ut`Seen by ${o.name} at ${c}`)}
                      .name=${o.name}
                      .src=${o.avatar_url}
                      size=${18}
                    ></wy-avatar>`;
    })}
                ` : v}
          </div>` : v}
      ${this.annotations ? Rd(
      `annotation-preview-message-${this.messageId}`,
      h`
              <wy-preview
                ${j(this.previewAnnotationsRef)}
                .files=${this.annotations}
                .isAttachment=${!0}
              ></wy-preview>
            `
    ) : v}
      ${this.attachments ? Rd(
      `preview-message-${this.messageId}`,
      h`
              <wy-preview
                ${j(this.previewAttachmentsRef)}
                .files=${[...t, ...e]}
                .isAttachment=${!0}
              ></wy-preview>
            `
    ) : v}
    `;
  }
  updated(t) {
    t.has("highlight") && this.highlight && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, a(_o, "WyMessage"), _o);
Et.styles = [zt, vh, wy, Z];
Jt([
  p({ attribute: !1 })
], Et.prototype, "conversation", 2);
Jt([
  p({ type: Number })
], Et.prototype, "messageId", 2);
Jt([
  p({ type: Boolean })
], Et.prototype, "me", 2);
Jt([
  p({ type: Boolean })
], Et.prototype, "isAgent", 2);
Jt([
  p({ type: Boolean })
], Et.prototype, "isPrivateChat", 2);
Jt([
  p()
], Et.prototype, "name", 2);
Jt([
  p()
], Et.prototype, "comment", 2);
Jt([
  p()
], Et.prototype, "avatar", 2);
Jt([
  p()
], Et.prototype, "createdAt", 2);
Jt([
  p()
], Et.prototype, "html", 2);
Jt([
  p()
], Et.prototype, "text", 2);
Jt([
  p({ type: Array })
], Et.prototype, "annotations", 2);
Jt([
  p({ type: Array })
], Et.prototype, "attachments", 2);
Jt([
  p({ attribute: !1 })
], Et.prototype, "meeting", 2);
Jt([
  p({ type: Array })
], Et.prototype, "pollOptions", 2);
Jt([
  p({ attribute: !1 })
], Et.prototype, "embed", 2);
Jt([
  p({ type: Array })
], Et.prototype, "reactions", 2);
Jt([
  p({ type: Array })
], Et.prototype, "seenBy", 2);
Jt([
  p({ type: Boolean })
], Et.prototype, "highlight", 2);
Et = Jt([
  H("wy-message"),
  ot()
], Et);
var s3 = Object.defineProperty, n3 = Object.getOwnPropertyDescriptor, Av = /* @__PURE__ */ a((i) => {
  throw TypeError(i);
}, "__typeError$8"), hi = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? n3(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && s3(t, e, s), s;
}, "__decorateClass$C"), zv = /* @__PURE__ */ a((i, t, e) => t.has(i) || Av("Cannot " + e), "__accessCheck$8"), bf = /* @__PURE__ */ a((i, t, e) => (zv(i, t, "read from private field"), e ? e.call(i) : t.get(i)), "__privateGet$8"), a3 = /* @__PURE__ */ a((i, t, e) => t.has(i) ? Av("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(i) : t.set(i, e), "__privateAdd$8"), xf = /* @__PURE__ */ a((i, t, e, r) => (zv(i, t, "write to private field"), t.set(i, e), e), "__privateSet$7"), sn, Po;
let De = (Po = class extends Rt {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.header = !1, this.lastReadMessagePosition = "below", this.showNewMessages = !1, this.isCreatingConversation = !1, this.showReadReceipts = !1, this.messagesQuery = new Ki(this), this.membersQuery = new Ie(this), this.addMessageMutation = new We(this), this.infiniteScroll = new Cu(this), this.pagerRef = et(), this.bottomRef = et(), this.editorRef = et(), this.shouldBeAtBottom = !0, this.isTyping = !1, this.handleRealtimeMessage = async (t) => {
      if (!this.weavy || !this.conversation || !(this.conversationId && this.conversationId > 0) || !this.user)
        return;
      await this.messagesQuery.observer?.getCurrentQuery().promise;
      const e = t.message.app.uid ?? t.message.app.id, r = ["messages", t.message.app.id];
      let s = mh(this.weavy.queryClient, r, t.message.id);
      s || (t.message.created_by.id === this.user.id && (s = gs(this.weavy.queryClient, r, !0), s && qt(this.weavy.queryClient, r, s.id, (n) => {
        n.id = t.message.id, n.app = t.message.app, n.text = t.message.text, n.html = t.message.html, n.embed = t.message.embed, n.meeting = t.message.meeting, n.attachments = t.message.attachments, n.options = t.message.options, n.created_at = t.message.created_at, n.created_by = t.message.created_by, n.updated_at = t.message.updated_at, n.updated_by = t.message.updated_by;
      })), s || Ar(this.weavy.queryClient, r, t.message)), this.weavy.queryClient.setQueryData(
        ["apps", e],
        (n) => n && { ...n, last_message: t.message }
      ), t.actor.id !== this.user.id && (this.isAtBottom ? (this.markAsRead(t.message.id), requestAnimationFrame(() => {
        this.scrollToBottom();
      })) : (this.weavy.queryClient.setQueryData(
        ["apps", e],
        (n) => n && { ...n, is_unread: !0 }
      ), this.lastReadMessagePosition = "above", this.lastReadMessageId = t.message.id, this.showNewMessages = !0), ct(
        this.weavy.queryClient,
        { queryKey: ["members", t.message.app.id], exact: !1 },
        t.actor.id,
        (n) => {
          n.marked_id = t.message.id, n.marked_at = t.message.created_at;
        }
      ));
    }, this.handleRealtimeReactionAdded = (t) => {
      !this.weavy || !this.user || !this.conversation || ct(
        this.weavy.queryClient,
        { queryKey: ["messages"], exact: !1 },
        t.entity.id,
        (e) => {
          e.reactions || (e.reactions = { count: 0 }), e.reactions.data = [
            ...(e.reactions.data || []).filter((r) => r.created_by?.id !== t.actor.id),
            { content: t.reaction, created_by: t.actor }
          ];
        }
      );
    }, this.handleRealtimeReactionDeleted = (t) => {
      !this.weavy || !this.conversation || !this.user || ct(
        this.weavy.queryClient,
        { queryKey: ["messages"], exact: !1 },
        t.entity.id,
        (e) => {
          e.reactions && e.reactions.data && (e.reactions.data = e.reactions.data.filter((r) => r.created_by?.id !== t.actor.id));
        }
      );
    }, this.handleRealtimeMarked = (t) => {
      !this.weavy || !this.conversation || ct(
        this.weavy.queryClient,
        { queryKey: ["members", this.conversation.id] },
        t.actor.id,
        (e) => {
          e.marked_id = t.marked_id, e.marked_at = t.marked_at;
        }
      );
    }, this.markAsReadHandler = () => {
      !document.hidden && this.isAtBottom && this.markAsRead();
    }, a3(this, sn);
  }
  isPrivateChat(t) {
    return (t ?? this.conversation)?.type === tt.PrivateChat;
  }
  isChatRoom(t) {
    return (t ?? this.conversation)?.type === tt.ChatRoom;
  }
  /**
   * Read-only helper returning whether the viewport is currently scrolled to the bottom.
   *
   * @internal
   */
  get isAtBottom() {
    return this.bottomRef.value ? x0(this.bottomRef.value) : !0;
  }
  /**
   * Scroll the conversation to the bottom.
   *
   * @param smooth - Whether to perform a smooth scroll.
   * @returns Promise<void>
   *
   * @internal
   */
  async scrollToBottom(t = !1) {
    this.bottomRef.value && await Bp(this.bottomRef.value), b0(this.bottomRef.value) && this.conversationId && this.conversationId > 0 && (requestAnimationFrame(() => {
      Ep(this.weavy?.queryClient, ["messages", this.conversationId], void 0, 1);
    }), await $0(this.bottomRef.value, t));
  }
  /**
   * Handle typing indicator events from child components.
   *
   * @internal
   * @param e - Typing event
   */
  handleTyping(t) {
    this.isTyping = !!t.detail.count, this.isTyping && this.isAtBottom && requestAnimationFrame(() => {
      this.scrollToBottom(!0);
    });
  }
  /**
   * Submit handler for the message editor. Adds a message and optionally creates a conversation first.
   *
   * @internal
   * @param e - Editor submit event
   * @returns Promise<MessageType>
   */
  async handleSubmit(t) {
    if (!this.user)
      throw new Error("Error submitting message. Missing user.");
    const e = {
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      blobs: t.detail.blobs,
      user: this.user,
      context: t.detail.contextData
    };
    if (this.agentInstructions && (e.metadata = {
      instructions: this.agentInstructions
    }), !this.conversation && this.weavy && this.createConversation && (this.isCreatingConversation = !0, await this.createConversation(e), await this.updateComplete), !this.conversation)
      throw new Error("Error submitting message. Missing conversation.");
    const r = await this.addMessageMutation.mutate({
      ...e,
      app_id: this.conversation.id
    });
    return this.showNewMessages = !1, requestAnimationFrame(() => {
      this.scrollToBottom();
    }), this.isCreatingConversation = !1, r;
  }
  /**
   * Set the editor text programmatically.
   *
   * @param text - Text to set in the editor.
   * @returns Promise<void>
   *
   * @internal
   */
  async setEditorText(t) {
    this.editorRef.value && (this.editorRef.value.text = t, await this.editorRef.value.updateComplete, await new Promise((e) => requestAnimationFrame(e)));
  }
  /**
   * Set metadata on the editor instance.
   *
   * @param metadata - Optional metadata object.
   * @returns Promise<void>
   *
   * @internal
   */
  async setEditorMetadata(t = {}) {
    await this.updateComplete, this.editorRef.value && (this.editorRef.value.metadata = t);
  }
  /**
   * Select all content in the editor.
   *
   * @internal
   */
  async selectAllInEditor() {
    this.editorRef.value && (await this.updateComplete, await this.editorRef.value.updateComplete, this.editorRef.value?.selectAllContent());
  }
  /**
   * Move the editor cursor to the end of the content.
   *
   * @internal
   */
  async setCursorLastInEditor() {
    this.editorRef.value && (await this.updateComplete, await this.editorRef.value.updateComplete, this.editorRef.value?.setCursorLast());
  }
  /**
   * Focus the editor input.
   *
   * @internal
   */
  focusEditor() {
    this.editorRef.value && this.editorRef.value?.focusInput();
  }
  /**
   * Sets the conversation title when the conversation is empty, based on message text.
   *
   * @internal
   * @param name - Title string to set.
   * @returns Promise<void>
   */
  async setEmptyConversationTitle(t) {
    !this.conversation || this.conversation.name || (t = Bf(t), await this.updateConversationMutation?.mutate({ appId: this.conversation.id, name: t }));
  }
  /**
   * Mark the conversation as read. Respects visibility and component lifecycle.
   *
   * @param messageId - Optional message id to mark as read.
   * @returns Promise<void>
   *
   * @internal
   */
  async markAsRead(t) {
    await i1(), await Promise.race([Bp(this), Ff(this, !1)]), !(!this.componentFeatures?.allowsFeature(M.Receipts) || !this.isConnected) && this.conversation && this.conversation.last_message && await this.markConversationMutation?.mutate({
      app: this.conversation,
      messageId: t ?? this.conversation.last_message.id,
      userId: this.user?.id
    });
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("weavy") && this.weavy && (this.updateConversationMutation = Im(this.weavy), this.markConversationMutation = Lm(this.weavy)), (t.has("weavy") || t.has("conversationId") || t.has("componentFeatures")) && this.weavy) {
      (e = bf(this, sn)) == null || e.call(this);
      const r = t.get("conversationId");
      if (r && r > 0 && requestAnimationFrame(() => {
        Ep(this.weavy?.queryClient, ["messages", r], void 0, 1);
      }), this.conversationId && this.conversationId > 0) {
        await this.messagesQuery.trackInfiniteQuery(B0(this.weavy, this.conversationId)), await this.addMessageMutation.trackMutation(
          q0(this.weavy, ["messages", this.conversationId])
        ), await this.membersQuery.trackQuery(Fm(this.weavy, this.conversationId, {})), this.pollMutation = sy(this.weavy, this.conversationId, ["messages", this.conversationId]), this.lastReadMessageId = void 0, this.showNewMessages = !1;
        const s = `a${this.conversationId}`;
        this.weavy.subscribe(s, "message_created", this.handleRealtimeMessage), this.componentFeatures?.allowsFeature(M.Reactions) && (this.weavy.subscribe(s, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(s, "reaction_removed", this.handleRealtimeReactionDeleted)), this.componentFeatures?.allowsFeature(M.Receipts) && this.weavy.subscribe(s, "app_marked", this.handleRealtimeMarked).then((n) => {
          this.showReadReceipts = n;
        }), xf(this, sn, () => {
          this.weavy?.unsubscribe(s, "message_created", this.handleRealtimeMessage), this.weavy?.unsubscribe(s, "reaction_added", this.handleRealtimeReactionAdded), this.weavy?.unsubscribe(s, "reaction_removed", this.handleRealtimeReactionDeleted), this.weavy?.unsubscribe(s, "app_marked", this.handleRealtimeMarked), this.showReadReceipts = !1, xf(this, sn, void 0);
        });
      } else
        this.messagesQuery.untrackInfiniteQuery(), this.addMessageMutation.untrackMutation(), this.membersQuery.untrackQuery();
    }
    if (t.has("showNewMessages") && this.showNewMessages && (this.shouldBeAtBottom = this.isAtBottom), t.has("conversationId") && t.get("conversationId") !== this.conversationId ? this.shouldBeAtBottom = !!this.conversationId : this.shouldBeAtBottom = this.isAtBottom, t.has("conversation")) {
      const r = t.get("conversation");
      if (r?.id !== this.conversation?.id || r?.is_unread !== this.conversation?.is_unread)
        if (this.componentFeatures?.allowsFeature(M.Receipts) && this.conversation?.is_unread) {
          const s = this.membersQuery.result.data?.data?.find(
            (n) => n.id === this.user?.id
          )?.marked_id;
          s && s < this.conversation.last_message.id && (this.lastReadMessagePosition = "below", this.lastReadMessageId = s, this.showNewMessages = !0), (r?.id !== this.conversation?.id || r?.last_message.id !== this.conversation?.last_message.id && (this.shouldBeAtBottom || this.isAtBottom)) && this.markAsRead();
        } else r?.id !== this.conversation?.id && (this.showNewMessages = !1);
    }
    if (this.conversation && !this.conversation?.name && !qw(this.messagesQuery.result.data)) {
      const s = Zi(this.messagesQuery.result.data).find((n) => n.plain);
      s && this.setEmptyConversationTitle(Uf(s.plain));
    }
  }
  renderConversationHeader() {
    if (!this.header)
      return h` <!-- Top of the conversation --> `;
    const { isPending: t, hasNextPage: e } = this.messagesQuery.result ?? {};
    if (!this.conversation || t || e)
      return v;
    const { data: r } = this.membersQuery.result ?? {}, s = this.user && this.isPrivateChat() ? (this.conversation?.members?.data || []).filter((n) => n.id !== this.user?.id)?.[0] ?? this.user : null;
    return h`
      <wy-avatar-header description=${nt(s?.comment)}>
        ${this.conversation.avatar_url ? h`<wy-avatar .size=${96} src=${this.conversation.avatar_url}></wy-avatar>` : this.isChatRoom() ? h` <wy-avatar-group
              .members=${r?.data}
              title=${this.conversation.name}
              .size=${96}
            ></wy-avatar-group>` : s?.avatar_url ? h`
              <wy-avatar
                src=${nt(s?.avatar_url)}
                name=${this.conversation.name}
                description=${nt(s?.comment)}
                ?isAgent=${s?.is_agent}
                size=${96}
              ></wy-avatar>
            ` : v}
      </wy-avatar-header>
    `;
  }
  renderMessages() {
    const { isPending: t } = this.weavy?.network ?? { isPending: !0 }, {
      data: e,
      isPending: r
      //hasNextPage,
    } = this.messagesQuery.result ?? { isPending: t }, { data: s } = this.membersQuery.result ?? {}, n = Zi(e);
    let o;
    return this.conversation && e && !qw(e) ? h`
          <div part="wy-messages">
            <div ${j(this.pagerRef)} part="wy-pager wy-pager-top"></div>

            ${n && this.conversation && this.user ? Fe(
      n,
      (c) => c.id,
      (c, l) => {
        const u = new Date(c.created_at);
        let f = h``;
        if (o?.toDateString() !== u.toDateString()) {
          const x = new Intl.DateTimeFormat(this.weavy?.locale, {
            dateStyle: "short"
          }).format(u);
          o = u, f = h`<time part="wy-message-date-separator">${x}</time>`;
        }
        let $ = h``;
        this.lastReadMessageId && this.lastReadMessageId === c.id && ($ = h`<div
                        id="unread-marker"
                        part="wy-toast wy-toast-action wy-fade ${this.showNewMessages ? "wy-show" : ""}"
                        tabindex=${this.showNewMessages ? 0 : -1}
                        @click=${() => {
          let x = `#message-${this.lastReadMessageId}`;
          this.lastReadMessagePosition === "below" && (x += "~ wy-message"), this.renderRoot.querySelector(x)?.scrollIntoView({
            block: "start",
            inline: "nearest",
            behavior: "smooth"
          });
        }}
                        @keydown=${le}
                        @keyup=${Me}
                      >
                        ${b("New messages")}
                      </div>`);
        const m = s?.data?.find((x) => x.id === c.created_by.id) || c.created_by;
        return h`${[
          h`${f}`,
          h`${this.lastReadMessagePosition === "above" ? $ : v}`,
          Rd(
            `message-${c.id}`,
            h`<wy-message
                          id="message-${c.id}"
                          .conversation=${this.conversation}
                          .messageId=${c.id}
                          .me=${m.id === this.user?.id}
                          .isAgent=${m.is_agent || !1}
                          .isPrivateChat=${this.conversation?.type === tt.PrivateChat || this.conversation?.type === tt.AgentChat}
                          .name=${m.name}
                          .comment=${m.comment}
                          .avatar=${m.avatar_url}
                          .createdAt=${c.created_at}
                          .text=${c.plain}
                          .html=${c.html}
                          .annotations=${c.annotations?.data}
                          .attachments=${c.attachments?.data}
                          .meeting=${c.meeting}
                          .pollOptions=${c.options?.data}
                          .embed=${c.embed}
                          .reactions=${c.reactions?.data}
                          .seenBy=${this.showReadReceipts && s && s.data && s.data.length > 0 ? s.data.filter((x) => x.marked_id === c.id && x.id !== this.user?.id) : []}
                          @vote=${(x) => {
              x.detail.parentId && x.detail.parentType && x.detail.parentId && this.pollMutation?.mutate({
                optionId: x.detail.optionId,
                parentType: x.detail.parentType,
                parentId: x.detail.parentId
              });
            }}
                        ></wy-message>`
          ),
          h`${this.lastReadMessagePosition === "below" ? $ : v}`
        ]}`;
      }
    ) : v}
            ${this.componentFeatures?.allowsFeature(M.Typing) ? h`
                  <wy-message-typing
                    .conversationId=${this.conversation.id}
                    .userId=${this.user?.id}
                    .isPrivateChat=${this.isPrivateChat()}
                    .members=${s?.data ?? []}
                    @typing=${(c) => this.handleTyping(c)}
                  ></wy-message-typing>
                ` : v}
          </div>
        ` : h`
          <div part="wy-messages">
            <wy-empty part="wy-pane">
              ${r && this.conversationId || this.isCreatingConversation ? h`<wy-progress-circular indeterminate overlay></wy-progress-circular>` : h` <slot name="empty">${this.conversationId ? b("Start the conversation!") : v}</slot> `}
            </wy-empty>
          </div>
        `;
  }
  render() {
    return h`
      ${this.renderConversationHeader()} ${this.renderMessages()}
      <div ${j(this.bottomRef)}></div>
      <div part="wy-footerbar wy-footerbar-sticky wy-footerbar-floating">
        <slot name="footerbar"></slot>
        <wy-message-editor
          ${j(this.editorRef)}
          .draft=${!0}
          placeholder=${this.placeholder ?? b("Type a message...")}
          ?disabled=${this.conversation && !gc(ms.Create, this.conversation?.permissions)}
          @submit=${(t) => this.handleSubmit(t)}
        ></wy-message-editor>
      </div>
    `;
  }
  updated() {
    this.shouldBeAtBottom && (Ep(this.weavy?.queryClient, ["messages", this.conversationId], void 0, 1), requestAnimationFrame(() => {
      this.scrollToBottom();
    })), this.bottomObserver || (this.bottomObserver = new IntersectionObserver((t) => {
      t.forEach((e) => {
        e.isIntersecting && !this.isTyping && this.conversation?.is_unread && this.markAsRead();
      });
    })), this.bottomRef && this.bottomRef.value && this.bottomObserver.observe(this.bottomRef.value), this.infiniteScroll.observe(this.messagesQuery.result, this.pagerRef.value);
  }
  // hook up observer
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("visibilitychange", this.markAsReadHandler), this.conversationId && this.requestUpdate("conversationId");
  }
  disconnectedCallback() {
    var t;
    (t = bf(this, sn)) == null || t.call(this), this.bottomObserver && this.bottomObserver.disconnect(), document.removeEventListener("visibilitychange", this.markAsReadHandler), this.conversation = void 0, this.shouldBeAtBottom = this.isAtBottom, super.disconnectedCallback();
  }
}, a(Po, "WyConversation"), Po);
sn = /* @__PURE__ */ new WeakMap();
De.styles = [
  vh,
  Br,
  qs,
  Hm,
  ay,
  B`
      :host {
        position: relative;
        display: flex;
        flex-direction: column;
        flex: 1 1 auto;
      }
    `
];
hi([
  Vr({ context: Qu }),
  p({ attribute: !1 })
], De.prototype, "conversation", 2);
hi([
  p({ type: Number })
], De.prototype, "conversationId", 2);
hi([
  p({ type: Boolean })
], De.prototype, "header", 2);
hi([
  p()
], De.prototype, "agentInstructions", 2);
hi([
  p()
], De.prototype, "placeholder", 2);
hi([
  F()
], De.prototype, "lastReadMessagePosition", 2);
hi([
  F()
], De.prototype, "lastReadMessageId", 2);
hi([
  F()
], De.prototype, "showNewMessages", 2);
hi([
  F()
], De.prototype, "isCreatingConversation", 2);
hi([
  F()
], De.prototype, "showReadReceipts", 2);
De = hi([
  H("wy-conversation"),
  ot()
], De);
const o3 = B`:host{--_track-height: 4px;--_track-shape: 2px;--_active-indicator-height: 2px;--_active-indicator-color: var(--wy-primary, var(--wy-primary-light, #2f628c));--_warning-color: var(--wy-warning, var(--wy-warning-light, #adb140));--_error-color: var(--wy-error, var(--wy-error-light, #ba1821));--_track-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));display:contents;position:relative}[part~=wy-progress-linear]{border-radius:var(--_track-shape);position:relative;min-width:80px;height:var(--_track-height);content-visibility:auto;contain:strict;flex:1;direction:ltr;inset:0;border-radius:inherit;overflow:hidden;display:flex;align-items:center}[part~=wy-progress-linear][part~=wy-progress-padded]{margin:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem))}[part~=wy-inactive-track],[part~=wy-bar],[part~=wy-bar-inner]{position:absolute}[part~=wy-bar]{animation:none;width:100%;height:var(--_active-indicator-height);transform-origin:left center;transition:transform .25s cubic-bezier(.4,0,.6,1)}[part~=wy-secondary-bar]{display:none}[part~=wy-bar-inner]{inset:0;animation:none;background:var(--_active-indicator-color)}[part~=wy-inactive-track]{background:var(--_track-color);inset:0;transition:transform .25s cubic-bezier(.4,0,.6,1);transform-origin:left center}[part~=wy-progress-indeterminate] [part~=wy-bar]{transition:none}[part~=wy-progress-indeterminate] [part~=wy-primary-bar]{inset-inline-start:-145.167%}[part~=wy-progress-indeterminate] [part~=wy-secondary-bar]{inset-inline-start:-54.8889%;display:block}[part~=wy-progress-indeterminate] [part~=wy-primary-bar]{animation:linear infinite 2s;animation-name:primary-indeterminate-translate}[part~=wy-progress-indeterminate] [part~=wy-primary-bar]>[part~=wy-bar-inner]{animation:linear infinite 2s primary-indeterminate-scale}[part~=wy-progress-indeterminate] [part~=wy-secondary-bar]{animation:linear infinite 2s;animation-name:secondary-indeterminate-translate}[part~=wy-progress-indeterminate] [part~=wy-secondary-bar]>[part~=wy-bar-inner]{animation:linear infinite 2s secondary-indeterminate-scale}@keyframes primary-indeterminate-scale{0%{transform:scaleX(.08)}36.65%{animation-timing-function:cubic-bezier(.334731,.12482,.785844,1);transform:scaleX(.08)}69.15%{animation-timing-function:cubic-bezier(.06,.11,.6,1);transform:scaleX(.661479)}to{transform:scaleX(.08)}}@keyframes secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(.205028,.057051,.57661,.453971);transform:scaleX(.08)}19.15%{animation-timing-function:cubic-bezier(.152313,.196432,.648374,1.00432);transform:scaleX(.457104)}44.15%{animation-timing-function:cubic-bezier(.257759,-.003163,.211762,1.38179);transform:scaleX(.72796)}to{transform:scaleX(.08)}}@keyframes primary-indeterminate-translate{0%{transform:translate(0)}20%{animation-timing-function:cubic-bezier(.5,0,.701732,.495819);transform:translate(0)}59.15%{animation-timing-function:cubic-bezier(.302435,.381352,.55,.956352);transform:translate(83.6714%)}to{transform:translate(200.611%)}}@keyframes secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(.15,0,.515058,.409685);transform:translate(0)}25%{animation-timing-function:cubic-bezier(.31033,.284058,.8,.733712);transform:translate(37.6519%)}48.35%{animation-timing-function:cubic-bezier(.4,.627035,.6,.902026);transform:translate(84.3862%)}to{transform:translate(160.278%)}}[part~=wy-progress-warning] [part~=wy-primary-bar],[part~=wy-progress-warning] [part~=wy-secondary-bar],[part~=wy-progress-warning] [part~=wy-bar-inner],[part~=wy-progress-error] [part~=wy-primary-bar],[part~=wy-progress-error] [part~=wy-secondary-bar],[part~=wy-progress-error] [part~=wy-bar-inner]{animation:none!important}[part~=wy-progress-warning] [part~=wy-secondary-bar],[part~=wy-progress-error] [part~=wy-secondary-bar]{display:none!important}[part~=wy-progress-warning] [part~=wy-primary-bar],[part~=wy-progress-error] [part~=wy-primary-bar]{transform:scaleX(1)!important}[part~=wy-progress-warning] [part~=wy-bar-inner]{background:var(--_warning-color)}[part~=wy-progress-error] [part~=wy-bar-inner]{background:var(--_error-color)}`;
var c3 = Object.defineProperty, l3 = Object.getOwnPropertyDescriptor, cr = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? l3(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && c3(t, e, s), s;
}, "__decorateClass$B"), Mo;
let ei = (Mo = class extends X {
  constructor() {
    super(...arguments), this.shadowParts = new U(this), this.padded = !1, this.overlay = !1, this.reveal = !1, this.value = 0, this.max = 1, this.indeterminate = !1, this.warning = !1, this.error = !1;
  }
  render() {
    let t;
    try {
      Number.isFinite(this.value) && Number.isFinite(this.max) && this.max > 0 && (t = this.value / this.max);
    } catch (n) {
      console.error(n);
    }
    const e = this.indeterminate || t === void 0, r = {
      transform: `scaleX(${(e ? 1 : this.value / this.max) * 100}%)`
    }, s = {
      "wy-progress": !0,
      "wy-progress-linear": !0,
      "wy-progress-indeterminate": e,
      "wy-progress-overlay": this.overlay,
      "wy-progress-padded": this.padded,
      "wy-progress-reveal": this.reveal,
      "wy-progress-warning": this.warning,
      "wy-progress-error": this.error
    };
    return h`
      <div
        part=${K(s)}
        role="progressbar"
        aria-label="${v}"
        aria-valuemin="0"
        aria-valuemax=${this.max}
        aria-valuenow=${e ? v : this.value}
      >
        <div part="wy-inactive-track"></div>
        <div part="wy-bar wy-primary-bar" style=${ml(r)}>
          <div part="wy-bar-inner"></div>
        </div>
        <div part="wy-bar wy-secondary-bar">
          <div part="wy-bar-inner"></div>
        </div>
      </div>
    `;
  }
}, a(Mo, "WyProgressLinear"), Mo);
ei.styles = [zt, Um, o3];
cr([
  p({ type: Boolean })
], ei.prototype, "padded", 2);
cr([
  p({ type: Boolean })
], ei.prototype, "overlay", 2);
cr([
  p({ type: Boolean })
], ei.prototype, "reveal", 2);
cr([
  p({ type: Number })
], ei.prototype, "value", 2);
cr([
  p({ type: Number })
], ei.prototype, "max", 2);
cr([
  p({ type: Boolean })
], ei.prototype, "indeterminate", 2);
cr([
  p({ type: Boolean })
], ei.prototype, "warning", 2);
cr([
  p({ type: Boolean })
], ei.prototype, "error", 2);
ei = cr([
  H("wy-progress-linear")
], ei);
var d3 = Object.getOwnPropertyDescriptor, Rv = /* @__PURE__ */ a((i) => {
  throw TypeError(i);
}, "__typeError$7"), h3 = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? d3(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = o(s) || s);
  return s;
}, "__decorateClass$A"), p3 = /* @__PURE__ */ a((i, t, e) => t.has(i) || Rv("Cannot " + e), "__accessCheck$7"), $f = /* @__PURE__ */ a((i, t, e) => (p3(i, t, "read from private field"), e ? e.call(i) : t.get(i)), "__privateGet$7"), u3 = /* @__PURE__ */ a((i, t, e) => t.has(i) ? Rv("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(i) : t.set(i, e), "__privateAdd$7"), Od, So;
let sh = (So = class extends Rt {
  constructor() {
    super(...arguments), this.exportParts = new U(this), u3(this, Od, new yc(this));
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("contextId") || t.has("componentFeatures")) && this.weavy && this.contextId && this.componentFeatures?.allowsFeature(M.ContextData) && await $f(this, Od).trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.contextId, "data"],
          exact: !0
        }
      },
      this.weavy.queryClient
    );
  }
  render() {
    const { result: t, isMutating: e } = $f(this, Od), r = t?.filter((o) => o.variables?.file), s = Cm(r), n = vu(r);
    return this.componentFeatures?.allowsFeature(M.ContextData) && t && t.length ? h`
          ${e || s.percent !== null && s.percent < 100 ? h`
                <wy-progress-linear
                  ?indeterminate=${s.percent === null}
                  overlay
                  reveal
                  ?warning=${n === "error"}
                  value=${s.percent ?? 0}
                  max=${100}
                ></wy-progress-linear>
              ` : v}
        ` : v;
  }
}, a(So, "WyContextDataProgress"), So);
Od = /* @__PURE__ */ new WeakMap();
sh.styles = [Z];
sh = h3([
  H("wy-context-data-progress")
], sh);
var y3 = Object.defineProperty, w3 = Object.getOwnPropertyDescriptor, ky = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? w3(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && y3(t, e, s), s;
}, "__decorateClass$z"), Ao;
let Sc = (Ao = class extends xe {
  constructor() {
    super(...arguments), this.appType = tt.Chat, this.componentFeatures = new ee({
      // All available features as enabled/disabled by default
      [M.Attachments]: !0,
      [M.ContextData]: !0,
      [M.CloudFiles]: !0,
      [M.Embeds]: !0,
      [M.GoogleMeet]: !0,
      [M.Meetings]: !0,
      [M.Mentions]: !0,
      [M.MicrosoftTeams]: !0,
      [M.Polls]: !0,
      [M.Previews]: !0,
      [M.Reactions]: !0,
      [M.Receipts]: !1,
      [M.Typing]: !1,
      [M.ZoomMeetings]: !0
    }), this.theme = new Te(this, Sc.styles);
  }
  render() {
    return h`
      <wy-buttons position="floating" reverse><slot name="actions"></slot></wy-buttons>
      <wy-conversation
        .agentInstructions=${this.instructions}
        .conversation=${this.app}
        .conversationId=${this.app?.id}
        .placeholder=${this.placeholder}
      >
        <wy-context-data-progress slot="footerbar"></wy-context-data-progress>
      </wy-conversation>
    `;
  }
}, a(Ao, "WyChat"), Ao);
Sc.styles = [Ri, Vs, Us, Yt, Se];
ky([
  p()
], Sc.prototype, "instructions", 2);
ky([
  p()
], Sc.prototype, "placeholder", 2);
Sc = ky([
  H("wy-chat"),
  ot()
], Sc);
var f3 = Object.defineProperty, m3 = Object.getOwnPropertyDescriptor, Ev = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? m3(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && f3(t, e, s), s;
}, "__decorateClass$y"), zo;
let El = (zo = class extends xe {
  constructor() {
    super(...arguments), this.appType = tt.Comments, this.componentFeatures = new ee({
      // All available features as enabled/disabled by default
      [M.Attachments]: !0,
      [M.CloudFiles]: !0,
      [M.ContextData]: !0,
      [M.Embeds]: !0,
      [M.GoogleMeet]: !1,
      [M.Meetings]: !1,
      [M.Mentions]: !0,
      [M.MicrosoftTeams]: !1,
      [M.Polls]: !0,
      [M.Previews]: !0,
      [M.Reactions]: !0,
      [M.Typing]: !1,
      // Has no effect currently
      [M.ZoomMeetings]: !1
    }), this.theme = new Te(this, El.styles);
  }
  render() {
    return h`
      <wy-buttons position="floating" reverse><slot name="actions"></slot></wy-buttons>
      <wy-comment-list .parentId=${this.app?.id} .location=${"apps"} .placeholder=${this.placeholder}></wy-comment-list>
      <wy-context-data-progress></wy-context-data-progress>
    `;
  }
}, a(zo, "WyComments"), zo);
El.styles = [Ri, Vs, Us, Yt, Se, xy];
Ev([
  p()
], El.prototype, "placeholder", 2);
El = Ev([
  H("wy-comments"),
  ot()
], El);
function v3(i) {
  if (!this.weavy || !this.app)
    return;
  const t = {
    message: i.message,
    direction: i.message.created_by.id === this.user?.id ? "outbound" : "inbound"
  };
  i.message.created_by.is_agent && (t.agent = i.message.created_by.uid);
  const e = new CustomEvent("wy-message", {
    bubbles: !1,
    cancelable: !1,
    composed: !0,
    detail: t
  });
  this.dispatchEvent(e);
}
a(v3, "triggerMessageEvent");
var g3 = Object.defineProperty, b3 = Object.getOwnPropertyDescriptor, _y = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? b3(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && g3(t, e, s), s;
}, "__decorateClass$x"), Ro;
let Ac = (Ro = class extends xe {
  constructor() {
    super(...arguments), this.appType = tt.AgentChat, this.componentFeatures = new ee({
      // All available features as enabled/disabled by default
      [M.Attachments]: !1,
      [M.ContextData]: !0,
      [M.Embeds]: !0,
      [M.Mentions]: !1,
      [M.Previews]: !0,
      [M.Reactions]: !1,
      [M.Typing]: !0
    }), this.theme = new Te(this, Ac.styles), this.conversationRef = et(), this.handleRealtimeMessage = v3.bind(this);
  }
  /**
   * Sets the editor input to a suggested text. This replaces the text content of the editor. This can be used to create any custom suggestions.
   *
   * @param {string} text - The text suggestion to place in the editor.
   */
  async setSuggestion(t) {
    await this.conversationRef.value?.setEditorText(t);
  }
  async willUpdate(t) {
    if (await super.willUpdate(t), t.has("weavy") && this.weavy && (this.addConversationMutation = _m(this.weavy)), (t.has("app") || t.has("weavy")) && this.weavy && (this.unsubscribeToRealtime?.(), this.app)) {
      const e = `a${this.app.id}`;
      this.weavy.subscribe(e, "message_created", this.handleRealtimeMessage), this.unsubscribeToRealtime = () => {
        this.weavy?.unsubscribe(e, "message_created", this.handleRealtimeMessage), this.unsubscribeToRealtime = void 0;
      };
    }
    t.has("agent") && t.get("agent") && this.agent && this.reset();
  }
  render() {
    return this.agent ? h`
          <wy-buttons position="floating" reverse>
            <slot name="actions"></slot>
          </wy-buttons>
          <wy-conversation
            ${j(this.conversationRef)}
            .conversation=${this.app}
            .conversationId=${this.app?.id}
            .placeholder=${this.placeholder ?? b("Ask anything...")}
            .agentInstructions=${this.instructions}
            .createConversation=${this.agent && this.addConversationMutation ? async (t) => {
      if (!this.agent || !this.addConversationMutation)
        throw new Error("Agent or addConversationMutation not defined");
      const e = {
        uid: `wy-copilot-${sl()}`,
        name: Bf(Uf(this.name ?? t.text)),
        members: [this.agent],
        type: ai.AgentChat
      }, r = await this.addConversationMutation.mutate(e);
      return this.app = r, await this.updateComplete, r;
    } : void 0}
          >
            <slot
              slot="empty"
              name="empty"
              @click=${async (t) => {
      t.target.matches(".suggestion") && (t.stopPropagation(), await this.setSuggestion(t.target.innerText), await this.conversationRef.value?.setCursorLastInEditor(), this.conversationRef.value?.focusEditor());
    }}
              @keydown=${le}
              @keyup=${Me}
            >
              <slot name="header">
                <wy-icon-display>
                  <slot name="icon">
                    <wy-icon name="stars"></wy-icon>
                  </slot>
                </wy-icon-display>
              </slot>
              <slot name="suggestions">
                <wy-item-list>
                  <slot name="suggestion-list">
                    <!--wy-button class="suggestion">Summarize this page</wy-button-->
                  </slot>
                </wy-item-list>
              </slot>
              <slot name="footer"></slot>
            </slot>
            <wy-context-data-progress slot="footerbar"></wy-context-data-progress>
          </wy-conversation>
        ` : h`
          <wy-empty>
            <wy-icon-display>
              <slot name="icon">
                <wy-icon name="stars"></wy-icon>
              </slot>
            </wy-icon-display>
          </wy-empty>
        `;
  }
}, a(Ro, "WyCopilot"), Ro);
Ac.styles = [Ri, Vs, Us, Yt, Se];
_y([
  p()
], Ac.prototype, "instructions", 2);
_y([
  p()
], Ac.prototype, "placeholder", 2);
Ac = _y([
  H("wy-copilot"),
  ot()
], Ac);
var x3 = Object.defineProperty, $3 = Object.getOwnPropertyDescriptor, yd = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? $3(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && x3(t, e, s), s;
}, "__decorateClass$w"), Eo;
let Tr = (Eo = class extends Rt {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.order = { by: "name", descending: !1 }, this.view = "list", this.showTrashed = !1, this.showUploadSheet = !1, this.mutatingFiles = new yc(
      this
    ), this.previousFailedFileMutations = [], this.fileInputRef = et(), this.cloudFilesRef = et(), this.openFileInput = () => {
      this.fileInputRef.value?.click();
    }, this.openCloudFiles = () => {
      this.cloudFilesRef.value?.open();
    };
  }
  // remove file attachment
  /**
   * Remove (or abort) an ongoing upload mutation.
   *
   * @internal
   * @param mutationState - Mutation state to remove.
   */
  async handleRemoveMutation(t) {
    const e = await this.whenWeavy(), r = await this.whenApp();
    t.status === "pending" && fu(t.variables) && t.variables.abort?.();
    const s = t.status === "error" && !t.variables?.blob || t.status === "pending" ? ["apps", r.id, "blobs"] : ["apps", r.id, "files"];
    $m(
      e.queryClient,
      s,
      (n) => n.state.submittedAt === t.submittedAt
    );
  }
  /**
   * Retry an upload by replacing the existing file.
   *
   * @internal
   * @param mutation - Failed mutation carrying the blob data.
   */
  handleOverwriteUpload(t) {
    const e = t.variables?.blob;
    e && this.dispatchCreateFiles([e], !0);
  }
  /**
   * Dispatch an `upload-files` event with the selected files.
   *
   * @param files - Files chosen from the native picker.
   * @returns Whether the event was not canceled.
   */
  dispatchUploadFiles(t) {
    this.weavy && this.app && (i0(this.weavy, this.app), vu(this.mutatingFiles.result) === "ok" && gu(this.weavy, this.app));
    const e = new CustomEvent("upload-files", {
      detail: { files: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit an `external-blobs` event with selected cloud blobs.
   *
   * @internal
   * @param externalBlobs - Blobs returned from the cloud picker.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchExternalBlobs(t) {
    const e = new CustomEvent("external-blobs", {
      detail: { externalBlobs: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `create-files` event for programmatic uploads.
   *
   * @internal
   * @param blobs - Blobs to create files from.
   * @param replace - When true, replace the existing file.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchCreateFiles(t, e = !1) {
    const r = new CustomEvent("create-files", {
      detail: { blobs: t, replace: e }
    });
    return this.dispatchEvent(r);
  }
  /**
   * Emit an `order` event reflecting the chosen sort order.
   *
   * @internal
   * @param order - Order to apply.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `view` event for changing layout mode.
   *
   * @internal
   * @param view - Layout to activate.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchView(t) {
    const e = new CustomEvent("view", { detail: { view: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `show-trashed` event to toggle trashed visibility.
   *
   * @internal
   * @param showTrashed - Whether to show trashed files.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchShowTrashed(t) {
    const e = new CustomEvent("show-trashed", {
      detail: { showTrashed: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event to toggle app subscription.
   *
   * @internal
   * @param subscribe - Desired subscription state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", { detail: { subscribe: t } });
    return this.dispatchEvent(e);
  }
  async willUpdate(t) {
    super.willUpdate(t), t.has("app") && this.app && this.app.id !== t.get("app")?.id && this.weavy && gu(this.weavy, this.app), (t.has("weavy") || t.has("app")) && this.weavy && this.app && await this.mutatingFiles.trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.app.id],
          exact: !1
        }
      },
      this.weavy.queryClient
    );
  }
  renderFileMutation(t) {
    if (t.context?.file) {
      const e = t.context.file, r = {
        ...t.context.status
      };
      return t.context.status.state === "conflict" && (r.text = b("Replace existing file?")), h`
        <wy-file-item
          rounded
          .file=${t.context?.file}
          .status=${r}
          .actionType=${t.context.type}
          title="${Hf(t.context.type)}: ${e.name}"
        >
          <span slot="title">${e.name}</span>
          ${t.context.status.state === "conflict" && r.text ? h`: <span slot="actions" title=${r.text}><em>${r.text}</em></span>` : v}
          ${r.state === "conflict" && t.variables?.blob ? h`
                <wy-button
                  slot="actions"
                  kind="icon"
                  @click=${() => this.handleOverwriteUpload(
        t
      )}
                  title=${b("Replace")}
                >
                  <wy-icon name="check"></wy-icon>
                </wy-button>
              ` : v}
          ${r.state === "pending" ? h`
                <wy-progress-circular
                  slot="actions"
                  padded
                  ?indeterminate=${!r.progress}
                  .max=${100}
                  .value=${r.progress || 0}
                ></wy-progress-circular>

                ${fu(t.variables) ? h`<wy-button slot="actions" kind="icon" @click=${() => this.handleRemoveMutation(t)}>
                      <wy-icon name="close"></wy-icon>
                    </wy-button>` : v}
              ` : h`<wy-button slot="actions" kind="icon" @click=${() => this.handleRemoveMutation(t)}>
                <wy-icon name="close"></wy-icon>
              </wy-button> `}
        </wy-file-item>
      `;
    }
    return v;
  }
  render() {
    const t = this.mutatingFiles.result, e = Vw(t), r = Hw(t), s = Cm(t), n = vu(t);
    return h`
      <header part="wy-files-header wy-header wy-header-outer">
        <nav part="wy-files-header-toolbar wy-toolbar">
          <div part="wy-toolbar-buttons">
            ${gc(ms.Create, this.app?.permissions) ? h`
                  <wy-dropdown title=${b("Add files")}>
                    <wy-icon slot="button-content" name="plus" first></wy-icon>
                    <span slot="button-content">${b("Add files")}</span>
                    <wy-dropdown-item @click=${this.openFileInput} title=${b("From device")}>
                      <wy-icon name="attachment"></wy-icon>
                      <span>${b("From device")}</span>
                    </wy-dropdown-item>
                    <input
                      type="file"
                      data-testid="uploadFile"
                      ${j(this.fileInputRef)}
                      @click=${(o) => o.stopPropagation()}
                      @change=${(o) => {
      this.dispatchUploadFiles(o.target.files) && (o.target.value = "");
    }}
                      multiple
                      hidden
                      tabindex="-1"
                    />
                    ${this.componentFeatures?.allowsFeature(M.CloudFiles) ? h`
                          <wy-dropdown-item @click=${this.openCloudFiles} title=${b("From cloud")}>
                            <wy-icon name="cloud"></wy-icon>
                            <span>${b("From cloud")}</span>
                          </wy-dropdown-item>
                        ` : v}
                  </wy-dropdown>
                ` : v}
            ${t?.length ? h`
                  <wy-button
                    kind="icon"
                    @click=${() => {
      this.showUploadSheet = !this.showUploadSheet;
    }}
                    title=${n === "conflict" ? b("File conflict") : n === "error" ? b("Upload error") : n === "pending" ? b("Pending") : b("All uploads finished")}
                  >
                    ${n === "conflict" ? h`<wy-icon name="alert" color="yellow"></wy-icon>` : n === "error" ? h`<wy-icon name="alert-octagon" color="error"></wy-icon>` : n === "pending" ? h`<wy-progress-circular
                          ?indeterminate=${s.percent === null}
                          .value=${s.loaded}
                          .max=${s.total}
                        ></wy-progress-circular>` : h`<wy-icon name="check"></wy-icon>`}
                  </wy-button>
                ` : v}
          </div>
          <div part="wy-toolbar-buttons wy-toolbar-buttons-last">
            <slot name="actions"></slot>

            <wy-dropdown icon="sort" title="Sort items by" directionX="left">
              <wy-dropdown-option
                ?selected=${this.order.by === "name"}
                @click=${() => this.dispatchOrder({ ...this.order, by: "name" })}
              >
                ${b("Name")}
              </wy-dropdown-option>
              <wy-dropdown-option
                ?selected=${this.order.by === "updated_at"}
                @click=${() => this.dispatchOrder({ ...this.order, by: "updated_at" })}
              >
                ${b("Modified")}
              </wy-dropdown-option>
              <wy-dropdown-option
                ?selected=${this.order.by === "size"}
                @click=${() => this.dispatchOrder({ ...this.order, by: "size" })}
              >
                ${b("Size")}
              </wy-dropdown-option>
              <wy-dropdown-divider></wy-dropdown-divider>
              <wy-dropdown-option
                ?selected=${!this.order.descending}
                @click=${() => this.dispatchOrder({ ...this.order, descending: !1 })}
              >
                ${b("Ascending")}
              </wy-dropdown-option>
              <wy-dropdown-option
                ?selected=${this.order.descending}
                @click=${() => this.dispatchOrder({ ...this.order, descending: !0 })}
              >
                ${b("Descending")}
              </wy-dropdown-option>
            </wy-dropdown>

            <wy-dropdown
              icon=${this.view === "grid" ? "view-module-outline" : "view-list-outline"}
              title="View options"
              directionX="left"
            >
              <wy-dropdown-option ?selected=${this.view === "list"} @click=${() => this.dispatchView("list")}>
                ${b("List view")}
              </wy-dropdown-option>
              <wy-dropdown-option ?selected=${this.view === "grid"} @click=${() => this.dispatchView("grid")}>
                ${b("Grid view")}
              </wy-dropdown-option>
              <wy-dropdown-divider></wy-dropdown-divider>
              <wy-dropdown-option ?selected=${!this.showTrashed} @click=${() => this.dispatchShowTrashed(!1)}>
                ${b("Hide trashed")}
              </wy-dropdown-option>
              <wy-dropdown-option ?selected=${this.showTrashed} @click=${() => this.dispatchShowTrashed(!0)}>
                ${b("Show trashed")}
              </wy-dropdown-option>
            </wy-dropdown>

            <wy-dropdown directionX="left" ?disabled=${!this.app}>
              ${this.app?.is_subscribed ? h`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                    <wy-icon name="bell-off"></wy-icon>
                    ${b("Unsubscribe")}
                  </wy-dropdown-item>` : h`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                    <wy-icon name="bell"></wy-icon>
                    ${b("Subscribe")}
                  </wy-dropdown-item>`}
              ${this.app?.archive_url ? h`<wy-dropdown-item
                    @click=${() => Wi(
      this.app?.archive_url,
      "_top",
      `${this.app?.uid ? this.app.uid : `${this.app?.type}-${this.app?.id}`}.zip`,
      !0
    )}
                  >
                    <wy-icon name="download"></wy-icon>
                    ${b("Download files")}
                  </wy-dropdown-item>` : v}
            </wy-dropdown>
          </div>
        </nav>

        <wy-context-data-progress></wy-context-data-progress>
      </header>

      ${this.weavy ? h`
            <wy-overlay
              type="sheet"
              .show=${this.showUploadSheet}
              @close=${() => {
      this.showUploadSheet = !1;
    }}
            >
              <span slot="title">${b("File actions")}</span>
              <wy-container scrollY padded>
                ${!e.length && !r.length ? h`
                      <wy-empty noNetwork><wy-container padded>${b("No pending uploads")}</wy-container></wy-empty>
                    ` : v}
                ${e.length ? h`
                      ${Fe(
      e,
      (o) => "mutation" + o.submittedAt,
      (o) => this.renderFileMutation(o)
    )}
                    ` : v}
                ${r.length ? h`
                      ${Fe(
      r,
      (o) => "mutation" + o.submittedAt,
      (o) => this.renderFileMutation(o)
    )}
                    ` : v}
              </wy-container>
            </wy-overlay>
          ` : v}

      <wy-cloud-files
        ${j(this.cloudFilesRef)}
        @external-blobs=${(o) => this.dispatchExternalBlobs(o.detail.externalBlobs)}
      ></wy-cloud-files>
    `;
  }
  updated(t) {
    super.updated(t);
    const e = Vw(this.mutatingFiles.result), r = Hw(this.mutatingFiles.result);
    e.some(
      (n) => !this.previousFailedFileMutations.includes(n)
    ) ? this.showUploadSheet = !0 : this.showUploadSheet && !e.length && !r.length && setTimeout(() => {
      !e.length && !r.length && (this.showUploadSheet = !1);
    }, 1500), this.previousFailedFileMutations = e ?? [];
  }
}, a(Eo, "WyFilesHeader"), Eo);
Tr.styles = [gy, xv, Z];
yd([
  p({ type: Object })
], Tr.prototype, "order", 2);
yd([
  p()
], Tr.prototype, "view", 2);
yd([
  p({ type: Boolean })
], Tr.prototype, "showTrashed", 2);
yd([
  F()
], Tr.prototype, "showUploadSheet", 2);
Tr = yd([
  H("wy-files-header"),
  ot()
], Tr);
function C3(i, t, e = {}, r = {}) {
  if (!i)
    throw new Error("useFileList must be used within a WeavyContext");
  return {
    ...r,
    queryKey: ["apps", t, "files", e],
    initialPageParam: 0,
    queryFn: /* @__PURE__ */ a(async (n) => {
      const o = n.pageParam, c = !!e?.trashed, l = e.order ? e.order.by + (e.order.descending ? "+desc" : "") : "";
      let u = "/api/apps/" + t + "/files?skip=" + o + "&order_by=" + l;
      return c && (u += "&trashed=null"), await (await i.fetch(u)).json();
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ a((n) => n.end && n.end < n.count ? n.end : null, "getNextPageParam")
  };
}
a(C3, "getInfiniteFileListOptions");
function k3(i, t) {
  const e = i.queryClient, s = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ a(async ({ file: n }) => {
      if (n.id >= 1) {
        if (!(await i.fetch("/api/files/" + n.id + "/trash", { method: "POST" })).ok)
          throw new Error();
      } else
        throw new Error(`Could not trash ${n.name}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((n) => (ct(
      e,
      { queryKey: s.mutationKey, exact: !1 },
      n.file.id,
      (o) => Object.assign(o, { is_trashed: !0 })
    ), { type: "trash", file: n.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ a((n, o) => {
      ct(
        e,
        { queryKey: s.mutationKey, exact: !1 },
        o.file.id,
        (c) => Object.assign(c, n)
      ), Ft(e, s.mutationKey, o, (c) => {
        c.status.state = "ok";
      });
    }, "onSuccess"),
    onError(n, o) {
      ct(
        e,
        { queryKey: s.mutationKey, exact: !1 },
        o.file.id,
        (c) => Object.assign(c, { is_trashed: !1 })
      ), Ft(e, s.mutationKey, o, (c) => {
        c.status.state = "error", c.status.text = n.message;
      });
    }
  };
  return s;
}
a(k3, "getTrashFileMutationOptions");
function _3(i, t) {
  return new $t(i.queryClient, k3(i, t));
}
a(_3, "getTrashFileMutation");
function P3(i, t) {
  const e = i.queryClient, s = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ a(async ({ file: n }) => {
      if (n.id >= 1) {
        const o = await i.fetch("/api/files/" + n.id + "/restore", { method: "POST" });
        if (!o.ok) {
          const c = await o.json();
          throw new Error(c.detail || c.title, { cause: c });
        }
      } else {
        const o = { status: 400, title: `Could not restore ${n.name}.` };
        throw new Error(o.detail || o.title, { cause: o });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((n) => (ct(
      e,
      { queryKey: s.mutationKey, exact: !1 },
      n.file.id,
      (o) => Object.assign(o, { status: "pending" })
    ), { type: "restore", file: n.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ a((n, o) => {
      ct(
        e,
        { queryKey: s.mutationKey, exact: !1 },
        o.file.id,
        (c) => Object.assign(c, { is_trashed: !1, status: "ok" })
      ), Ft(e, s.mutationKey, o, (c) => {
        c.status.state = "ok";
      });
    }, "onSuccess"),
    onError(n, o) {
      ct(
        e,
        { queryKey: s.mutationKey, exact: !1 },
        o.file.id,
        (c) => Object.assign(c, { is_trashed: !0 })
      ), Ft(e, s.mutationKey, o, (c) => {
        c.status.state = "error", c.status.text = n.message;
      });
    }
  };
  return s;
}
a(P3, "getRestoreFileMutationOptions");
function M3(i, t) {
  return new $t(i.queryClient, P3(i, t));
}
a(M3, "getRestoreFileMutation");
function S3(i, t) {
  const e = i.queryClient, s = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ a(async ({ file: n }) => {
      if (n.id >= 1 && n.is_trashed) {
        const o = await i.fetch("/api/files/" + n.id, { method: "DELETE" });
        if (!o.ok) {
          const c = await o.json();
          throw new Error(c.detail || c.title, { cause: c });
        }
      } else {
        const o = { status: 400, title: `Could not delete ${n.name} forever.` };
        throw new Error(o.detail || o.title, { cause: o });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((n) => (ct(
      e,
      { queryKey: s.mutationKey, exact: !1 },
      n.file.id,
      (o) => Object.assign(o, { status: "pending" })
    ), { type: "delete-forever", file: n.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ a((n, o) => {
      M0(e, { queryKey: s.mutationKey, exact: !1 }, o.file.id), Ft(e, s.mutationKey, o, (c) => {
        c.status.state = "ok";
      });
    }, "onSuccess"),
    onError(n, o) {
      ct(
        e,
        { queryKey: s.mutationKey, exact: !1 },
        o.file.id,
        (c) => Object.assign(c, { status: void 0 })
      ), Ft(e, s.mutationKey, o, (c) => {
        c.status.state = "error", c.status.text = n.message;
      });
    }
  };
  return s;
}
a(S3, "getDeleteForeverFileMutationOptions");
function A3(i, t) {
  return new $t(i.queryClient, S3(i, t));
}
a(A3, "getDeleteForeverFileMutation");
function z3(i, t) {
  const e = i.queryClient, r = ["apps", t.id, "files"];
  return {
    mutationKey: r,
    mutationFn: /* @__PURE__ */ a(async ({ file: n, subscribe: o }) => {
      if (n.id >= 1) {
        const c = await i.fetch(`/api/files/${n.id}/${o ? "subscribe" : "unsubscribe"}`, {
          method: "POST"
        });
        if (!c.ok) {
          const l = await c.json();
          throw new Error(l.detail || l.title, { cause: l });
        }
      } else
        throw new Error(`Could not ${o ? "subscribe" : "unsubscribe"} to ${n.name}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((n) => (ct(
      e,
      { queryKey: r, exact: !1 },
      n.file.id,
      (o) => Object.assign(o, { is_subscribed: n.subscribe, status: "pending" })
    ), {
      type: n.subscribe ? "subscribe" : "unsubscribe",
      file: n.file,
      status: { state: "pending" }
    }), "onMutate"),
    onSuccess: /* @__PURE__ */ a((n, o) => {
      ct(
        e,
        { queryKey: r, exact: !1 },
        o.file.id,
        (c) => Object.assign(c, { status: "ok" })
      ), Ft(e, r, o, (c) => {
        c.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ a((n, o) => {
      ct(
        e,
        { queryKey: r, exact: !1 },
        o.file.id,
        (c) => Object.assign(c, { is_subscribed: o.file.is_subscribed, status: "error" })
      ), Ft(e, r, o, (c) => {
        c.status.state = "error", c.status.text = n.message;
      });
    }, "onError")
  };
}
a(z3, "getSubscribeFileMutationOptions");
function R3(i, t) {
  return new $t(i.queryClient, z3(i, t));
}
a(R3, "getSubscribeFileMutation");
function E3(i, t) {
  const e = i.queryClient, s = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ a(async ({ file: n, name: o }) => {
      if (n.id >= 1) {
        const c = await i.fetch("/api/files/" + n.id, {
          method: "PATCH",
          body: JSON.stringify({
            name: o
          })
        });
        if (!c.ok) {
          const l = await c.json();
          throw new Error(l.detail || l.title, { cause: l });
        }
        return await c.json();
      } else
        throw new Error(`Could not rename ${n.name}`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((n) => (ct(
      e,
      { queryKey: s.mutationKey, exact: !1 },
      n.file.id,
      (o) => Object.assign(o, { name: n.name })
    ), { type: "rename", file: n.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ a((n, o) => {
      ct(
        e,
        { queryKey: s.mutationKey, exact: !1 },
        o.file.id,
        (c) => Object.assign(c, n)
      ), Ft(e, s.mutationKey, o, (c) => {
        c.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ a((n, o) => {
      ct(
        e,
        { queryKey: s.mutationKey, exact: !1 },
        o.file.id,
        (c) => Object.assign(c, { name: o.file.name })
      ), Ft(e, s.mutationKey, o, (c) => {
        c.status.state = "error", c.status.text = n.message;
      });
    }, "onError")
  };
  return s;
}
a(E3, "getRenameFileMutationOptions");
function L3(i, t) {
  return new $t(i.queryClient, E3(i, t));
}
a(L3, "getRenameFileMutation");
const O3 = B`[part~=wy-grid]{display:grid;grid-auto-flow:dense;grid-template-columns:repeat(auto-fill,minmax(calc(10 * var(--wy-size, 1rem)),1fr));grid-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) 0}`, I3 = B`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-card]{--wy-component-background-color: var(--wy-surface-layer-high, var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039)));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-component-border-radius);position:relative;display:flex;flex-direction:column;min-width:0;word-wrap:break-word;background-clip:border-box;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-card][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-card-primary]{--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73))}[part~=wy-trashed]{text-decoration:line-through;opacity:var(--wy-opacity-disabled, 38%)}[part~=wy-card-hover]{cursor:pointer;-webkit-user-select:none;user-select:none}[part~=wy-card-hover]:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-card-hover]:hover:before{opacity:var(--wy-opacity-state-hover, 8%)}[part~=wy-card-hover]:focus:before{opacity:var(--wy-opacity-state-focus, 12%)}[part~=wy-card-hover]:active:before,[part~=wy-card-hover][part~=wy-active]:before{opacity:var(--wy-opacity-state-active, 12%)}[part~=wy-card-actions]{position:absolute;top:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));right:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));align-items:center;display:flex}[part~=wy-card-icon]{--wy-component-icon-width: calc(6 * var(--wy-size, 1rem));--wy-component-icon-height: calc(6 * var(--wy-size, 1rem));display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;margin:auto}[part~=wy-card-image]{width:auto;height:auto;border-radius:var(--wy-component-border-radius);object-fit:cover;object-position:center;flex:1 1 100%;max-height:calc(10*var(--wy-size, 1rem))}[part~=wy-card-image][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-card-image][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-card-image-top]{object-position:top center}[part~=wy-card-title]{padding:0 var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:flex;align-items:center;justify-content:space-between;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));height:2.25rem;box-sizing:border-box}[part~=wy-input]{height:2.25rem;box-sizing:border-box;flex:0 1 auto}[part~=wy-card-text]{line-height:var(--wy-line-height, 1.5);flex:0 1 auto;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}[part~=wy-card-action]{flex:0 0 auto;white-space:nowrap}`, T3 = B`[part~=wy-badge]{display:inline-block;text-align:center;vertical-align:middle;align-self:center;font-weight:var(--wy-font-weight-bold, 600);font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));line-height:normal;color:var(--wy-on-primary, var(--wy-on-primary-light, #ffffff));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));background-color:var(--wy-primary, var(--wy-primary-light, #2f628c));padding:.333333em;min-width:1lh}[part~=wy-badge]:empty{display:none!important}[part~=wy-badge-positioned]{margin:calc(-.5*(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + .333333em*2));position:absolute}[part~=wy-badge-positioned]:not(:empty){display:block}[part~=wy-badge-top-right]{top:0;right:0}[part~=wy-badge-bottom-right]{bottom:0;right:0}[part~=wy-badge-bottom-left]{bottom:0;left:0}[part~=wy-badge-top-left]{top:0;left:0}[part~=wy-badge-compact]{padding:calc(var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))*.25);max-width:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))*3 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));height:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));line-height:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-badge-compact]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-badge-compact][part~=wy-badge-positioned]{margin:calc(-.5*(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))*.5))}[part~=wy-badge-dot]{content-visibility:hidden;line-height:0;min-width:0;height:0;width:0;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-badge-dot][part~=wy-badge-positioned]{margin:calc(-1*var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-badge-reveal]{opacity:1;transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-badge-reveal]{opacity:0}}`;
var F3 = Object.defineProperty, D3 = Object.getOwnPropertyDescriptor, Kc = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? D3(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && F3(t, e, s), s;
}, "__decorateClass$v"), Lo;
let er = (Lo = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.appearance = "count", this.position = "inline", this.reveal = !1, this.count = NaN, this.limit = 99;
  }
  render() {
    const t = Number.isInteger(this.count) ? this.count > this.limit ? `${this.limit}+` : this.count : "", e = /^(top|bottom)-(right|left)$/.test(this.position), r = {
      "wy-badge": !0,
      "wy-badge-reveal": this.reveal,
      "wy-badge-compact": this.appearance === "compact",
      "wy-badge-dot": this.appearance === "dot",
      "wy-badge-positioned": e,
      [`wy-badge-${this.position}`]: e
    };
    return this.appearance !== "none" && t ? h`<span part=${K(r)} title=${this.count}>${t}</span>` : v;
  }
}, a(Lo, "WyBadge"), Lo);
er.styles = [T3, Z];
Kc([
  p({ type: String })
], er.prototype, "appearance", 2);
Kc([
  p({ type: String })
], er.prototype, "position", 2);
Kc([
  p({ type: Boolean })
], er.prototype, "reveal", 2);
Kc([
  p({ type: Number })
], er.prototype, "count", 2);
Kc([
  p({ type: Number })
], er.prototype, "limit", 2);
er = Kc([
  H("wy-badge")
], er);
var H3 = Object.defineProperty, V3 = Object.getOwnPropertyDescriptor, Oh = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? V3(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && H3(t, e, s), s;
}, "__decorateClass$u"), Oo;
let Es = (Oo = class extends $e {
  constructor() {
    super(), this.exportParts = new U(this), this.isRenamingId = NaN, this.highlightId = NaN, this.highlightRef = et(), this.addEventListener("edit-name", (t) => {
      this.isRenamingId = t.detail.file.id;
    }), this.addEventListener("rename", () => {
      this.isRenamingId = NaN;
    });
  }
  /**
   * Emit a `file-open` event requesting preview for the given file.
   *
   * @param fileId - Identifier of the file to open.
   * @param tab - Optional preview tab to activate.
   * @returns Whether the event was not canceled.
   */
  dispatchFileOpen(t, e) {
    const r = new CustomEvent("file-open", { detail: { fileId: t, tab: e } });
    return this.dispatchEvent(r);
  }
  /**
   * Emit an `order` event with the selected sort order.
   *
   * @param order - Order to apply.
   * @returns Whether the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit an `edit-name` event to enter rename mode for the given file.
   *
   * @param file - File that should be renamed.
   * @returns Whether the event was not canceled.
   */
  dispatchEditName(t) {
    const e = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `rename` event containing the updated file name.
   *
   * @param file - File being renamed.
   * @param name - New filename.
   * @returns Whether the event was not canceled.
   */
  dispatchRename(t, e) {
    const r = new CustomEvent("rename", { detail: { file: t, name: e } });
    return this.dispatchEvent(r);
  }
  /**
   * Emit a `trash` event to move the file to the recycle bin.
   *
   * @param file - File to trash.
   * @returns Whether the event was not canceled.
   */
  dispatchTrash(t) {
    const e = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `restore` event to recover a trashed file.
   *
   * @param file - File to restore.
   * @returns Whether the event was not canceled.
   */
  dispatchRestore(t) {
    const e = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `delete-forever` event to permanently remove a file.
   *
   * @param file - File to delete.
   * @returns Whether the event was not canceled.
   */
  dispatchDeleteForever(t) {
    const e = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling file subscription.
   *
   * @param file - File to subscribe or unsubscribe.
   * @param subscribe - Desired subscription state.
   * @returns Whether the event was not canceled.
   */
  dispatchSubscribe(t, e) {
    const r = new CustomEvent("subscribe", { detail: { file: t, subscribe: e } });
    return this.dispatchEvent(r);
  }
  render() {
    return this.files && this.files.length ? h`
        <div part="wy-grid">
          ${Fe(
      this.files,
      (t) => t.id,
      (t) => {
        const e = t.size && t.size > 0 ? yh(t.size) : v, r = t.updated_at || t.created_at, s = new Intl.DateTimeFormat(this.weavy?.locale, {
          dateStyle: "full",
          timeStyle: "short"
        }).format(new Date(r)), n = !!(this.isRenamingId && this.isRenamingId === t.id), { icon: o } = Ur(t.name), c = ii(t.name), l = nd(t.provider), u = /* @__PURE__ */ a((m) => {
          m.stopImmediatePropagation();
          const x = m.target;
          x.value && x.value !== t.name ? this.dispatchRename(t, x.value) : this.dispatchEditName({ id: NaN });
        }, "handleRename"), f = /* @__PURE__ */ a((m) => {
          const x = m.target;
          m.key === "Escape" ? (m.preventDefault(), x.value = t.name, x.blur()) : m.key === "Enter" && (m.preventDefault(), x.blur());
        }, "handleRenameKey"), $ = !!(this.highlightId && this.highlightId === t.id);
        return h`
                <div
                  part=${K({
          "wy-card": !0,
          "wy-trashed": t.is_trashed,
          "wy-card-hover": !t.is_trashed && !n,
          "wy-highlight": $
        })}
                  title="${t.name} • ${e} • ${s}"
                  tabindex="0"
                  @click=${(m) => {
          dh(m) && (m.stopPropagation(), m.preventDefault(), Wi(t.download_url ?? t.external_url, "_blank")), !m.defaultPrevented && !t.is_trashed && this.dispatchFileOpen(t.id);
        }}
                  @keydown=${le}
                  @keyup=${Me}
                  ${$ && this.highlightRef ? j(this.highlightRef) : v}
                >
                  <div part="wy-card-actions">
                    <wy-file-menu
                      small
                      .file=${t}
                      @edit-name=${(m) => this.dispatchEditName(m.detail.file)}
                      @trash=${(m) => this.dispatchTrash(m.detail.file)}
                      @restore=${(m) => this.dispatchRestore(m.detail.file)}
                      @delete-forever=${(m) => this.dispatchDeleteForever(m.detail.file)}
                      @subscribe=${(m) => this.dispatchSubscribe(m.detail.file, m.detail.subscribe)}
                    ></wy-file-menu>
                  </div>
                  ${!t.is_trashed && t.thumbnail_url ? h`
                        <img
                          part="wy-card-image ${K({ "wy-card-image-top": t.kind !== "image" })}"
                          width=${nt(t.width)}
                          height=${nt(t.height)}
                          src=${t.thumbnail_url}
                          alt=${t.name}
                          ${j(fy)}
                          @load=${my}
                          loading="lazy"
                          decoding="async"
                        />
                      ` : h`
                        <div part="wy-card-icon ">
                          <wy-icon
                            name=${o}
                            .overlayName=${l}
                            size="96"
                            kind=${t.kind}
                            ext=${c}
                          ></wy-icon>
                        </div>
                      `}
                  ${n ? h`
                        <input
                          type="text"
                          name="filename"
                          maxlength="256"
                          part="wy-input"
                          .defaultValue=${t.name}
                          @blur=${u}
                          @keyup=${(m) => {
          Rr(m), f(m);
        }}
                          @click=${(m) => m.preventDefault()}
                          @focus=${Yu}
                          ${j(Uu)}
                        />
                      ` : h`<div part="wy-card-title">
                        <div part="wy-card-text">${t.name}</div> ${t.comments?.count ? h`<wy-button
                              part="wy-card-button-icon"
                              small
                              color="none"
                              kind="inline"
                              @click=${(m) => {
          !m.defaultPrevented && !t.is_trashed && (m.target.blur(), this.dispatchFileOpen(t.id, "comments"), m.stopPropagation());
        }}
                              title=${b(ut`${t.comments.count} comments`)}
                            >
                              <wy-badge count=${t.comments.count}></wy-badge>
                            </wy-button>` : v}
                      </div>`}
                </div>
              `;
      }
    )}
        </div>
      ` : v;
  }
  updated(t) {
    t.has("highlightId") && this.highlightId && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, a(Oo, "WyFileGrid"), Oo);
Es.styles = [jr, O3, I3, Z];
Oh([
  p({ attribute: !1 })
], Es.prototype, "files", 2);
Oh([
  F()
], Es.prototype, "isRenamingId", 2);
Oh([
  F()
], Es.prototype, "highlightId", 2);
Es = Oh([
  fm("wy-file-grid"),
  ot()
], Es);
const U3 = B`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-table]{table-layout:fixed;width:100%;vertical-align:top;border-collapse:collapse}[part~=wy-table] tr[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-table] th{font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600))}[part~=wy-table] th,[part~=wy-table] td{background-color:var(--wy-component-background-color);padding:var(--wy-table-cell-padding-y, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))) var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));box-shadow:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf)) 0 -1px 0 0 inset;line-height:1;vertical-align:middle;height:calc(calc(2 * var(--wy-size, 1rem)) + var(--wy-table-cell-padding-y, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*2)}[part~=wy-table]>tbody{vertical-align:inherit}[part~=wy-table]>thead{vertical-align:bottom}[part~=wy-table][part~=wy-table-interactive]>tbody>tr:hover>*{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));color:var(--wy-component-color);cursor:pointer}[part~=wy-col-icon]{vertical-align:middle;text-align:center;padding:calc(var(--wy-table-cell-padding-y, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*.5) calc(var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*.5);width:calc(calc(2 * var(--wy-size, 1rem)) + var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*2);font-size:var(--wy-font-size, var(--wy-size, 1em));font-weight:var(--wy-font-weight, unset);text-transform:none;letter-spacing:normal}[part~=wy-col-icon-content]{display:flex;justify-content:center;align-items:center}[part~=wy-trashed]{text-decoration:line-through}[part~=wy-sort-link]{display:inline-flex;align-items:center;color:var(--wy-primary, var(--wy-primary-light, #2f628c));cursor:pointer}`, B3 = B`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}table thead{text-align:left;display:none}@container (inline-size >= 576px){table thead{display:table-header-group}}[part~=wy-col-name]{width:100%}[part~=wy-col-name]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-col-name] [part~=wy-input]{width:100%;box-sizing:border-box}[part~=wy-col-time]{width:calc(8*var(--wy-size, 1rem));display:none}@container (inline-size >= 768px){[part~=wy-col-time]{display:table-cell}}[part~=wy-col-time]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-col-kind]{width:calc(8*var(--wy-size, 1rem));display:none}@container (inline-size >= 768px){[part~=wy-col-kind]{display:table-cell}}[part~=wy-col-kind]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-col-size]{width:calc(6*var(--wy-size, 1rem));text-align:right;display:none}@container (inline-size >= 576px){[part~=wy-col-size]{display:table-cell}}[part~=wy-col-size]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}`;
var q3 = Object.defineProperty, N3 = Object.getOwnPropertyDescriptor, wd = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? N3(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && q3(t, e, s), s;
}, "__decorateClass$t"), Io;
let Fr = (Io = class extends $e {
  constructor() {
    super(), this.exportParts = new U(this), this.order = { by: "name", descending: !1 }, this.isRenamingId = NaN, this.highlightId = NaN, this.highlightRef = et(), this.addEventListener("edit-name", (t) => {
      this.isRenamingId = t.detail.file.id;
    }), this.addEventListener("rename", () => {
      this.isRenamingId = NaN;
    });
  }
  /**
   * Emit a `file-open` event requesting preview for the supplied file.
   *
   * @param fileId - Identifier of the file to open.
   * @param tab - Optional preview tab to activate.
   * @returns Whether the event was not canceled.
   */
  dispatchFileOpen(t, e) {
    const r = new CustomEvent("file-open", { detail: { fileId: t, tab: e } });
    return this.dispatchEvent(r);
  }
  /**
   * Emit an `order` event with the provided sort order.
   *
   * @param order - Order to apply.
   * @returns Whether the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit an `edit-name` event to enter rename mode for the specified file.
   *
   * @param file - File that should be renamed.
   * @returns Whether the event was not canceled.
   */
  dispatchEditName(t) {
    const e = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `rename` event carrying the updated filename.
   *
   * @param file - File being renamed.
   * @param name - New filename value.
   * @returns Whether the event was not canceled.
   */
  dispatchRename(t, e) {
    const r = new CustomEvent("rename", { detail: { file: t, name: e } });
    return this.dispatchEvent(r);
  }
  /**
   * Emit a `trash` event to move the file to the recycle bin.
   *
   * @param file - File to trash.
   * @returns Whether the event was not canceled.
   */
  dispatchTrash(t) {
    const e = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `restore` event to recover a trashed file.
   *
   * @param file - File to restore.
   * @returns Whether the event was not canceled.
   */
  dispatchRestore(t) {
    const e = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `delete-forever` event to permanently remove the file.
   *
   * @param file - File targeted for permanent deletion.
   * @returns Whether the event was not canceled.
   */
  dispatchDeleteForever(t) {
    const e = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling subscription state for the file.
   *
   * @param file - File whose subscription changes.
   * @param subscribe - Desired subscription state.
   * @returns Whether the event was not canceled.
   */
  dispatchSubscribe(t, e) {
    const r = new CustomEvent("subscribe", { detail: { file: t, subscribe: e } });
    return this.dispatchEvent(r);
  }
  /**
   * Render the complete file table layout.
   *
   * @param files - Files to render.
   * @param order - Current table order.
   * @param isRenamingId - File id in rename mode.
   * @param highlightId - File id to highlight.
   * @param highlightRef - Reference for scrolling highlighted rows.
   */
  renderFileTable(t, e, r, s, n) {
    return t && t.length ? h`
          <table part="wy-table wy-table-interactive">
            <thead>${this.renderFileTableHeaders.call(this, e)}</thead>
            <tbody>
              ${Fe(
      t,
      (o) => o.id,
      (o) => this.renderFileTableRow.call(this, this.weavy, { file: o }, r, s, n)
    )}
            </tbody>
          </table>
        ` : v;
  }
  /**
   * Render table header cells with sorting affordances.
   *
   * @param order - Current sort order.
   */
  renderFileTableHeaders(t) {
    const e = [
      { col: "icon", by: void 0, title: "" },
      // File icon
      { col: "name", by: "name", title: b("Name") },
      { col: "icon", by: void 0, title: "" },
      // Comments icon
      { col: "time", by: "updated_at", title: b("Modified") },
      { col: "kind", by: void 0, title: b("Kind") },
      { col: "size", by: "size", title: b("Size") },
      { col: "icon", by: void 0, title: "" }
      // Menu
    ];
    return h`
      <tr>
        ${e.map((r) => {
      if (r.title) {
        const s = r.by === t?.by, n = /* @__PURE__ */ a((o) => {
          o.preventDefault(), r.by && this.dispatchOrder({ by: r.by, descending: s && !t?.descending });
        }, "onHeaderClick");
        return h` <th part="wy-th ${`wy-col-${r.col}`}">
              ${r.by ? h`<div
                    part="wy-sort-link"
                    tabindex="0"
                    @click=${n}
                    @keydown=${le}
                    @keyup=${Me}
                    >${r.title}
                    ${s && h`<wy-icon name=${t?.descending ? "menu-down" : "menu-up"}></wy-icon>` || v}</div
                  >` : r.title}
            </th>`;
      } else
        return h`<th part="wy-th wy-col-icon"></th>`;
    })}
      </tr>
    `;
  }
  /**
   * Render a single file table row.
   *
   * @param weavy - Current Weavy context.
   * @param row - Row data containing the file.
   * @param isRenamingId - File id in rename mode.
   * @param highlightId - File id to highlight.
   * @param highlightRef - Reference for scrolling highlighted rows.
   */
  renderFileTableRow(t, { file: e }, r, s, n) {
    const o = e.size && e.size > 0 ? yh(e.size) : v, c = e.updated_at || e.created_at, l = new Intl.DateTimeFormat(t?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(c)
    ), u = new Intl.DateTimeFormat(t?.locale, { dateStyle: "short" }).format(
      new Date(c)
    ), f = !!(r && r === e.id), { icon: $ } = Ur(e.name), m = ii(e.name), x = nd(e.provider), g = /* @__PURE__ */ a((A) => {
      A.stopImmediatePropagation();
      const E = A.target;
      E.value && E.value !== e.name ? this.dispatchRename(e, E.value) : this.dispatchEditName({ id: NaN });
    }, "handleRename"), S = /* @__PURE__ */ a((A) => {
      const E = A.target;
      A.key === "Escape" ? (A.preventDefault(), E.value = e.name, E.blur()) : A.key === "Enter" && (A.preventDefault(), E.blur());
    }, "handleRenameKey"), I = !!(s && s === e.id);
    return h`
      <tr
        part=${K({ "wy-tr": !0, "wy-highlight": I, "wy-trashed": e.is_trashed })}
        @click=${(A) => {
      dh(A) && (A.stopPropagation(), A.preventDefault(), Wi(e.download_url ?? e.external_url, "_blank")), !A.defaultPrevented && !e.is_trashed && this.dispatchFileOpen(e.id);
    }}
        ${I && n ? j(n) : v}
      >
        <td part="wy-td wy-col-icon"
          ><wy-icon part="wy-col-icon-content" name=${$} .overlayName=${x} size="24" kind=${e.kind} ext=${m}></wy-icon
        ></td>
        <td part="wy-td wy-col-name">
          ${f ? h`
                <input
                  type="text"
                  name="filename"
                  maxlength="256"
                  part="wy-input"
                  .defaultValue=${e.name}
                  @blur=${g}
                  @keyup=${(A) => {
      Rr(A), S(A);
    }}
                  @click=${(A) => A.preventDefault()}
                  @focus=${Yu}
                  ${j(Uu)}
                />
              ` : h`${e.name}`}
        </td>
        <td part="wy-td wy-col-icon"
          >${e.comments?.count ? h`<wy-button
                part="wy-col-icon-content"
                kind="inline"
                @click=${(A) => {
      !A.defaultPrevented && !e.is_trashed && (A.target.blur(), this.dispatchFileOpen(e.id, "comments"), A.stopPropagation());
    }}
                title=${b(ut`${e.comments.count} comments`)}
              >
                <wy-badge count=${e.comments.count}></wy-badge>
              </wy-button>` : v}</td
        >
        <td part="wy-td wy-col-time"
          ><time datetime="${c}" title=${l}>${u}</time></td
        >
        <td part="wy-td wy-col-kind">${e.kind}</td>
        <td part="wy-td wy-col-size">${o}</td>
        <td part="wy-td wy-col-icon">
          <wy-file-menu
            part="wy-col-icon-content"
            .file=${e}
            @edit-name=${(A) => this.dispatchEditName(A.detail.file)}
            @trash=${(A) => this.dispatchTrash(A.detail.file)}
            @restore=${(A) => this.dispatchRestore(A.detail.file)}
            @delete-forever=${(A) => this.dispatchDeleteForever(A.detail.file)}
            @subscribe=${(A) => this.dispatchSubscribe(A.detail.file, A.detail.subscribe)}
          >
          </wy-file-menu>
        </td>
      </tr>
    `;
  }
  render() {
    return this.files && this.files.length ? this.renderFileTable.call(
      this,
      this.files,
      this.order,
      this.isRenamingId,
      this.highlightId,
      this.highlightRef
    ) : v;
  }
  updated(t) {
    t.has("highlightId") && this.highlightId && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, a(Io, "WyFileTable"), Io);
Fr.styles = [jr, U3, B3, Z];
wd([
  p({ attribute: !1 })
], Fr.prototype, "files", 2);
wd([
  p({ attribute: !1 })
], Fr.prototype, "order", 2);
wd([
  F()
], Fr.prototype, "isRenamingId", 2);
wd([
  F()
], Fr.prototype, "highlightId", 2);
Fr = wd([
  fm("wy-file-table"),
  ot()
], Fr);
var j3 = Object.defineProperty, W3 = Object.getOwnPropertyDescriptor, Lv = /* @__PURE__ */ a((i) => {
  throw TypeError(i);
}, "__typeError$6"), Gc = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? W3(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && j3(t, e, s), s;
}, "__decorateClass$s"), Ov = /* @__PURE__ */ a((i, t, e) => t.has(i) || Lv("Cannot " + e), "__accessCheck$6"), Cf = /* @__PURE__ */ a((i, t, e) => (Ov(i, t, "read from private field"), e ? e.call(i) : t.get(i)), "__privateGet$6"), Q3 = /* @__PURE__ */ a((i, t, e) => t.has(i) ? Lv("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(i) : t.set(i, e), "__privateAdd$6"), kf = /* @__PURE__ */ a((i, t, e, r) => (Ov(i, t, "write to private field"), t.set(i, e), e), "__privateSet$6"), nn, To;
let ir = (To = class extends Rt {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.order = { by: "name", descending: !1 }, this.view = "list", this.showTrashed = !1, this.highlightId = NaN, this.highlightComment = !1, this.filesQuery = new Ki(this), this.previewRef = et(), this.infiniteScroll = new Gi(this), this.pagerRef = et(), this.handleRealtimeFileCreated = (t) => {
      !this.weavy || !this.app || (t.file.created_by = t.actor, this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) }));
    }, this.handleRealtimeFileUpdated = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileTrashed = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileRestored = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileDeleted = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeCommentCreated = () => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, Q3(this, nn);
  }
  /**
   * Resolve the query key used for the app file listing.
   *
   * @internal
   * @param app - App owning the files.
   */
  getFilesQueryKey(t) {
    return ["apps", t.id, "files"];
  }
  /**
   * Emit a `file-open` event requesting preview for the supplied file.
   *
   * @param fileId - Identifier of the file to open.
   * @param tab - Optional preview tab to activate.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchFileOpen(t, e) {
    const r = new CustomEvent("file-open", { detail: { fileId: t, tab: e } });
    return this.dispatchEvent(r);
  }
  /**
   * Emit an `order` event with the provided sort order.
   *
   * @param order - Order to apply.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("link") && (this.highlightId = this.link && pv(this.link, ve.File)?.id, this.highlightComment = this.link && this.highlightId ? uv(this.link, ve.File, { id: this.highlightId }, ve.Comment) : !1), t.has("highlightComment") && this.highlightComment && this.highlightId && this.dispatchFileOpen(this.highlightId, "comments"), (t.has("weavy") || t.has("app") || t.has("order") || t.has("showTrashed")) && this.weavy && this.app && await this.filesQuery.trackInfiniteQuery(
      C3(this.weavy, this.app.id, {
        order: this.order,
        trashed: this.showTrashed
      })
    ), (t.has("weavy") || t.has("app") || t.has("user")) && this.weavy && this.app && this.user) {
      this.renameFileMutation = L3(this.weavy, this.app), this.subscribeFileMutation = R3(this.weavy, this.app), this.trashFileMutation = _3(this.weavy, this.app), this.restoreFileMutation = M3(this.weavy, this.app), this.deleteForeverFileMutation = A3(this.weavy, this.app), (e = Cf(this, nn)) == null || e.call(this);
      const r = `a${this.app.id}`;
      this.weavy.subscribe(r, "file_created", this.handleRealtimeFileCreated), this.weavy.subscribe(r, "file_updated", this.handleRealtimeFileUpdated), this.weavy.subscribe(r, "file_trashed", this.handleRealtimeFileTrashed), this.weavy.subscribe(r, "file_restored", this.handleRealtimeFileRestored), this.weavy.subscribe(r, "file_deleted", this.handleRealtimeFileDeleted), this.weavy.subscribe(r, "comment_created", this.handleRealtimeCommentCreated), kf(this, nn, () => {
        this.weavy?.unsubscribe(r, "file_created", this.handleRealtimeFileCreated), this.weavy?.unsubscribe(r, "file_updated", this.handleRealtimeFileUpdated), this.weavy?.unsubscribe(r, "file_trashed", this.handleRealtimeFileTrashed), this.weavy?.unsubscribe(r, "file_restored", this.handleRealtimeFileRestored), this.weavy?.unsubscribe(r, "file_deleted", this.handleRealtimeFileDeleted), this.weavy?.unsubscribe(r, "comment_created", this.handleRealtimeCommentCreated), kf(this, nn, void 0);
      });
    }
  }
  render() {
    const { data: t, hasNextPage: e, isPending: r } = this.filesQuery.result, s = Zi(t);
    return s && s.length ? h`
        ${this.view === "grid" ? h`
              <wy-file-grid
                .files=${s}
                .highlightId=${this.highlightId}
                @file-open=${(n) => {
      this.previewRef.value?.open(n.detail.fileId, n.detail.tab);
    }}
                @order=${(n) => this.dispatchOrder(n.detail.order)}
                @rename=${(n) => {
      this.renameFileMutation?.mutate({ file: n.detail.file, name: n.detail.name });
    }}
                @subscribe=${(n) => {
      this.subscribeFileMutation?.mutate({
        file: n.detail.file,
        subscribe: n.detail.subscribe
      });
    }}
                @trash=${(n) => {
      this.trashFileMutation?.mutate({ file: n.detail.file });
    }}
                @restore=${(n) => {
      this.restoreFileMutation?.mutate({ file: n.detail.file });
    }}
                @delete-forever=${(n) => {
      this.deleteForeverFileMutation?.mutate({ file: n.detail.file });
    }}
              ></wy-file-grid>
            ` : h`
              <wy-file-table
                .files=${s}
                .order=${this.order}
                .highlightId=${this.highlightId}
                @file-open=${(n) => {
      this.previewRef.value?.open(n.detail.fileId, n.detail.tab);
    }}
                @order=${(n) => this.dispatchOrder(n.detail.order)}
                @rename=${(n) => {
      this.renameFileMutation?.mutate({ file: n.detail.file, name: n.detail.name });
    }}
                @subscribe=${(n) => {
      this.subscribeFileMutation?.mutate({
        file: n.detail.file,
        subscribe: n.detail.subscribe
      });
    }}
                @trash=${(n) => {
      this.trashFileMutation?.mutate({ file: n.detail.file });
    }}
                @restore=${(n) => {
      this.restoreFileMutation?.mutate({ file: n.detail.file });
    }}
                @delete-forever=${(n) => {
      this.deleteForeverFileMutation?.mutate({ file: n.detail.file });
    }}
              ></wy-file-table>
            `}
        ${e ? h`<div ${j(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : v}
        ${t ? h` <wy-preview ${j(this.previewRef)} .infiniteQueryResult=${this.filesQuery.result}></wy-preview> ` : v}
      ` : h`
        <wy-empty>
          ${r ? h`<wy-progress-circular indeterminate padded reveal></wy-progress-circular>` : h` <wy-icon-display>
                <wy-icon name="file-upload"></wy-icon>
                <span slot="text">${b("Add some files to get started!")}</span>
              </wy-icon-display>`}
        </wy-empty>
      `;
  }
  updated() {
    this.infiniteScroll.observe(this.filesQuery.result, this.pagerRef.value);
  }
  disconnectedCallback() {
    var t;
    (t = Cf(this, nn)) == null || t.call(this), super.disconnectedCallback();
  }
}, a(To, "WyFilesList"), To);
nn = /* @__PURE__ */ new WeakMap();
ir.styles = [Br];
Gc([
  p({ type: Object })
], ir.prototype, "order", 2);
Gc([
  p()
], ir.prototype, "view", 2);
Gc([
  p({ type: Boolean })
], ir.prototype, "showTrashed", 2);
Gc([
  F()
], ir.prototype, "highlightId", 2);
Gc([
  F()
], ir.prototype, "highlightComment", 2);
ir = Gc([
  H("wy-files-list"),
  ot()
], ir);
var K3 = Object.defineProperty, G3 = Object.getOwnPropertyDescriptor, Ih = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? G3(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && K3(t, e, s), s;
}, "__decorateClass$r"), Fo;
let Ls = (Fo = class extends xe {
  constructor() {
    super(), this.appType = tt.Files, this.componentFeatures = new ee({
      // All available features as enabled/disabled by default
      [M.Attachments]: !0,
      [M.CloudFiles]: !0,
      [M.Comments]: !0,
      [M.ContextData]: !0,
      [M.Embeds]: !0,
      [M.GoogleMeet]: !1,
      [M.Meetings]: !1,
      [M.Mentions]: !0,
      [M.MicrosoftTeams]: !1,
      [M.Polls]: !0,
      [M.Previews]: !0,
      [M.Reactions]: !0,
      [M.Typing]: !1,
      // Has no effect currently
      [M.Versions]: !0,
      [M.WebDAV]: !0,
      [M.ZoomMeetings]: !1
    }), this.theme = new Te(this, Ls.styles), this.view = "list", this.order = { by: "name", descending: !1 }, this.showTrashed = !1, this.persistState = new vs(this), this.dropZone = new Wd(this), this.uploadBlobMutation = new We(this), this.createFileMutation = new We(this), this.addEventListener("drop-files", (t) => this.handleBlobUpload(t));
  }
  /** @internal */
  handleBlobUpload(t) {
    const e = t.detail;
    if (e.files)
      for (let r = 0; r < e.files.length; r++) {
        const n = { file: e.files[r] };
        this.uploadBlobMutation.mutate(n).then((o) => this.handleCreateFile(o));
      }
  }
  /** @internal */
  handleExternalBlobs(t) {
    if (t.detail.externalBlobs)
      for (let e = 0; e < t.detail.externalBlobs.length; e++) {
        const r = t.detail.externalBlobs[e];
        this.externalBlobMutation?.mutate({ externalBlob: r }).then((s) => this.handleCreateFile(s));
      }
  }
  /** @internal */
  async handleCreateFile(t, e) {
    return await this.createFileMutation.mutate({ blob: t, replace: e });
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("uid") || t.has("weavy") || t.has("user")) && this.uid && this.weavy && this.user && this.persistState.observe(
      [
        { name: "view", override: !0 },
        { name: "order", override: !0 },
        { name: "showTrashed", override: !0 }
      ],
      this.uid.toString(),
      `u${this.user.id}`
    ), (t.has("weavy") || t.has("app") || t.has("user")) && this.weavy && this.app && this.user && (await this.uploadBlobMutation.trackMutation(Ju(this.weavy, this.user, this.app.id)), await this.createFileMutation.trackMutation(r0(this.weavy, this.user, this.app)), this.externalBlobMutation = Cv(this.weavy, this.user, this.app.id));
  }
  render() {
    const t = this.dropZone.isDragActive;
    return h`
      <div
        part="wy-files ${K({ "wy-dragging": t })}"
        data-drag-title=${b("Drop files here")}
      >
        <wy-files-header
          .order=${this.order}
          .showTrashed=${this.showTrashed}
          .view=${this.view}
          @upload-files=${(e) => this.handleBlobUpload(e)}
          @external-blobs=${(e) => this.handleExternalBlobs(e)}
          @create-files=${(e) => e.detail.blobs.forEach((r) => this.handleCreateFile(r, e.detail.replace))}
          @order=${(e) => {
      this.order = e.detail.order;
    }}
          @show-trashed=${(e) => {
      this.showTrashed = e.detail.showTrashed;
    }}
          @view=${(e) => {
      this.view = e.detail.view;
    }}
          @subscribe=${(e) => this.subscribe(e.detail.subscribe)}
        >
          <slot name="actions" slot="actions"></slot>
        </wy-files-header>

        <wy-files-list
          .view=${this.view}
          .order=${this.order}
          .showTrashed=${this.showTrashed}
          @order=${(e) => {
      this.order = e.detail.order;
    }}
        ></wy-files-list>
      </div>
    `;
  }
}, a(Fo, "WyFiles"), Fo);
Ls.styles = [
  _v,
  Yt,
  Ri,
  Vs,
  Se,
  Us
];
Ih([
  p()
], Ls.prototype, "view", 2);
Ih([
  p({ type: Object })
], Ls.prototype, "order", 2);
Ih([
  p({ type: Boolean })
], Ls.prototype, "showTrashed", 2);
Ls = Ih([
  H("wy-files"),
  ot()
], Ls);
function Z3(i, t) {
  const e = i.queryClient, s = {
    mutationKey: ["posts", t.id],
    mutationFn: /* @__PURE__ */ a(async ({ id: n }) => {
      if (!(await i.fetch("/api/posts/" + n + "/trash", { method: "POST" })).ok)
        throw new Error();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((n) => {
      ct(
        e,
        { queryKey: s.mutationKey, exact: !1 },
        n.id,
        (o) => Object.assign(o, { is_trashed: !0 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((n, o) => {
      ct(
        e,
        { queryKey: s.mutationKey, exact: !1 },
        o.id,
        (c) => Object.assign(c, n)
      );
    }, "onSuccess")
  };
  return s;
}
a(Z3, "getTrashPostMutationOptions");
function Y3(i, t) {
  return new $t(i.queryClient, Z3(i, t));
}
a(Y3, "getTrashPostMutation");
function X3(i, t) {
  const e = i.queryClient, s = {
    mutationKey: ["posts", t.id],
    mutationFn: /* @__PURE__ */ a(async ({ id: n }) => {
      const o = await i.fetch("/api/posts/" + n + "/restore", { method: "POST" });
      if (!o.ok) {
        const c = await o.json();
        throw new Error(c.detail || c.title, { cause: c });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((n) => {
      ct(
        e,
        { queryKey: s.mutationKey, exact: !1 },
        n.id,
        (o) => Object.assign(o, { is_trashed: !1 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((n, o) => {
      ct(
        e,
        { queryKey: s.mutationKey, exact: !1 },
        o.id,
        (c) => Object.assign(c, { is_trashed: !1 })
      );
    }, "onSuccess")
  };
  return s;
}
a(X3, "getRestorePostMutationOptions");
function J3(i, t) {
  return new $t(i.queryClient, X3(i, t));
}
a(J3, "getRestorePostMutation");
function t$(i, t) {
  const e = i.queryClient, r = ["posts", t.id];
  return {
    mutationKey: r,
    mutationFn: /* @__PURE__ */ a(async ({ id: n, subscribe: o }) => {
      const c = await i.fetch(
        `/api/posts/${n}/${o ? "subscribe" : "unsubscribe"}`,
        { method: "POST" }
      );
      if (!c.ok) {
        const l = await c.json();
        throw new Error(l.detail || l.title, { cause: l });
      }
      return await c.json();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ a((n) => {
      ct(
        e,
        { queryKey: r, exact: !1 },
        n.id,
        (o) => Object.assign(o, { is_subscribed: n.subscribe })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((n, o) => {
      ct(
        e,
        { queryKey: r, exact: !1 },
        o.id,
        (c) => Object.assign(c, n)
      );
    }, "onSuccess")
  };
}
a(t$, "getSubscribePostMutationOptions");
function e$(i, t) {
  return new $t(i.queryClient, t$(i, t));
}
a(e$, "getSubscribePostMutation");
function i$(i, t) {
  return {
    initialPageParam: 0,
    queryKey: ["posts", t],
    queryFn: /* @__PURE__ */ a(async (e) => {
      const r = e.pageParam, s = "/api/apps/" + t + "/posts?order_by=id+desc&skip=" + r, o = await (await i.fetch(s)).json();
      return o.data = o.data || [], o;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ a((e) => {
      if (e.end && e.end < e.count)
        return e.end;
    }, "getNextPageParam")
  };
}
a(i$, "getPostsOptions");
function r$(i, t) {
  return {
    mutationFn: /* @__PURE__ */ a(async (r) => await (await i.fetch("/api/posts/" + r.id, {
      method: "PATCH",
      body: JSON.stringify({
        text: r.text,
        blobs: r.blobs,
        attachments: r.attachments,
        meeting_id: r.meeting_id,
        options: r.poll_options.filter((n) => n.text.trim() !== "").map((n) => ({ id: n.id, text: n.text })),
        embed_id: r.embed_id || null
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ a((r) => {
      qt(i.queryClient, ["posts", r.app_id], r.id, (s) => {
        s.text = r.text, s.html = r.text;
      });
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((r, s) => {
      s.id && qt(i.queryClient, ["posts", s.app_id], s.id, (n) => {
        n.text = r.text, n.html = r.html, n.attachments = r.attachments, n.embed = r.embed, n.meeting = r.meeting, n.updated_at = r.updated_at, n.updated_by = r.updated_by, n.options = r.options;
      });
    }, "onSuccess")
  };
}
a(r$, "getUpdatePostMutationOptions");
function s$(i, t) {
  const e = i.queryClient;
  return {
    mutationFn: /* @__PURE__ */ a(async (s) => await (await i.fetch("/api/apps/" + s.app_id + "/posts", {
      method: "POST",
      body: JSON.stringify({
        text: s.text,
        blobs: s.blobs,
        meeting_id: s.meeting_id,
        options: s.poll_options.filter((o) => o.text.trim() !== "").map((o) => ({ text: o.text })),
        embed_id: s.embed_id,
        context: s.context
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ a(async (s) => {
      const n = ["posts", s.app_id];
      await e.cancelQueries({ queryKey: n });
      const o = gs(i.queryClient, n, !1);
      if (s.user) {
        const c = {
          id: o ? o.id - 1 : -1,
          app: { id: s.app_id },
          is_subscribed: !0,
          is_trashed: !1,
          text: s.text,
          html: s.text,
          plain: s.text,
          created_by: s.user,
          created_at: (/* @__PURE__ */ new Date()).toUTCString(),
          attachments: { count: 0 },
          reactions: { count: 0 },
          is_starred: !1,
          comments: { count: 0 }
        };
        Ar(e, ["posts", s.app_id], c, { descending: !0 });
      }
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ a((s) => {
      const n = ["posts", s.app.id];
      if (!mh(i.queryClient, n, s.id)) {
        const c = gs(i.queryClient, n, !0);
        c ? qt(i.queryClient, n, c.id, (l) => {
          l.id = s.id, l.app = s.app, l.text = s.text, l.html = s.html, l.embed = s.embed, l.meeting = s.meeting, l.attachments = s.attachments, l.options = s.options, l.created_at = s.created_at, l.created_by = s.created_by, l.updated_at = s.updated_at, l.updated_by = s.updated_by;
        }) : Ar(i.queryClient, n, s);
      }
    }, "onSuccess")
  };
}
a(s$, "getAddPostMutationOptions");
const Th = B`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-posts]{display:flex;flex-direction:column;gap:var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-posts-header]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));color:var(--wy-component-color);display:flex;flex-direction:column;position:relative;--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-post]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-background, var(--wy-background-light, #f7f9ff));color:var(--wy-component-color);display:flex;flex-direction:column;position:relative;clip-path:border-box;--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-component-border-radius)}[part~=wy-post][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-post-images]{display:flex;flex-direction:column;margin-top:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-header]{display:flex;flex-direction:column;padding:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) 0;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-body]{display:flex;flex-direction:column;padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) 0;gap:var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-footer]{display:flex;align-items:center;justify-content:space-between;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-content]{padding:0 var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-comments]{background-color:var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));interpolate-size:allow-keywords;padding:0 var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));height:0;visibility:hidden;transition:height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),padding var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));overflow:hidden}[part~=wy-post-comments][part~=wy-show]{height:auto;visibility:visible;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-post-trashed]{padding-bottom:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}::part(wy-trashed){text-decoration:line-through;color:var(--wy-outline, var(--wy-outline-light, #72777f))}`;
var n$ = Object.defineProperty, a$ = Object.getOwnPropertyDescriptor, Py = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? a$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && n$(t, e, s), s;
}, "__decorateClass$q"), Do;
let zc = (Do = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this);
  }
  /**
   * Emit a `restore` event requesting restoration of the trashed post.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  render() {
    return h`
      <div part="wy-post wy-post-trashed">
        <wy-item part="wy-post-header" size="md" noPadding>
          <wy-avatar
            slot="image"
            .src="${this.createdBy.avatar_url}"
            .isAgent=${this.createdBy.is_agent}
            .size=${48}
            .name=${this.createdBy.name}
          ></wy-avatar>
          <span part="wy-trashed" slot="title">${b("Post was trashed.")}</span>
          <wy-button small slot="actions" @click=${() => this.dispatchRestore()} color="variant"
            >${b("Undo")}</wy-button
          >
        </wy-item>
      </div>
    `;
  }
}, a(Do, "WyPostTrashed"), Do);
zc.styles = [Th, Z];
Py([
  p({ type: Number })
], zc.prototype, "postId", 2);
Py([
  p({ attribute: !1 })
], zc.prototype, "createdBy", 2);
zc = Py([
  H("wy-post-trashed"),
  ot()
], zc);
var o$ = Object.defineProperty, c$ = Object.getOwnPropertyDescriptor, Kt = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? c$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && o$(t, e, s), s;
}, "__decorateClass$p"), Ho;
let At = (Ho = class extends Rt {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.html = "", this.text = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.commentCount = 0, this.seenBy = [], this.highlight = !1, this.showComments = !1, this.loadComments = !1, this.isCommentLinked = !1, this.previewAnnotationsRef = et(), this.previewAttachmentsRef = et(), this.highlightRef = et();
  }
  /**
   * Emit a `vote` event for the specified poll option.
   *
   * @internal
   * @param optionId - Identifier of the selected poll option.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling post subscription state.
   *
   * @internal
   * @param subscribe - Desired subscription state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", {
      detail: { id: this.postId, subscribe: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `trash` event requesting the post to move into trash.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  /**
   * Emit an `edit` event toggling edit mode for this post.
   *
   * @internal
   * @param edit - Desired edit state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchEdit(t) {
    const e = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Toggle comment visibility and ensure comment data is loaded.
   *
   * @internal
   * @param e - Click event originating from the comment button.
   */
  handleCommentsClick(t) {
    t.preventDefault(), this.showComments = !this.showComments, this.loadComments = !0;
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("link") && (this.highlight = !!(this.link && Mh(this.link, ve.Post, { id: this.postId })), this.isCommentLinked = !!(this.link && uv(this.link, ve.Post, { id: this.postId }, ve.Comment))), t.has("isCommentLinked") && this.isCommentLinked && (this.loadComments = !0, this.showComments = !0);
  }
  render() {
    const t = this.attachments?.filter((g) => g.kind === "image" && g.thumbnail_url), e = this.attachments?.filter((g) => g.kind !== "image" || !g.thumbnail_url), r = new Intl.DateTimeFormat(this.weavy?.locale, {
      dateStyle: "full",
      timeStyle: "short"
    }).format(new Date(this.createdAt)), s = Wc(this.weavy?.locale, new Date(this.createdAt)), n = this.modifiedAt && this.weavy ? new Intl.DateTimeFormat(this.weavy.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.modifiedAt)
    ) : "", o = !!(t && t.length), c = !!this.html, l = !!(this.annotations && this.annotations.length), u = !!(this.pollOptions && this.pollOptions.length), f = !!(this.componentFeatures?.allowsFeature(M.Embeds) && this.embed), $ = e && !!e.length, m = !!this.meeting, x = c || l || u || f || $ || m;
    return this.postId < 0 ? h`
          <div part="wy-post">
            <wy-item part="wy-post-header" align="top" size="md" noPadding>
              <wy-avatar
                slot="image"
                .src="${this.createdBy.avatar_url}"
                .isAgent=${this.createdBy.is_agent}
                .size=${48}
                .name=${this.createdBy.name}
              ></wy-avatar>
              <span slot="title" part="wy-placeholder">${this.createdBy.name}</span>
              <time slot="text" part="wy-placeholder">${s}</time>
            </wy-item>
            <div part="wy-post-body">
              <div part="wy-content wy-post-content"><wy-skeleton .text=${this.text}></wy-skeleton></div>
            </div>
            <div part="wy-post-footer"></div>
          </div>
        ` : h`
          <div
            part=${K({ "wy-post": !0, "wy-highlight": this.highlight && !this.isCommentLinked })}
            ${j(this.highlightRef)}
          >
            <wy-item part="wy-post-header" align="top" size="md" noPadding>
              <wy-avatar
                slot="image"
                .src="${this.createdBy.avatar_url}"
                .isAgent=${this.createdBy.is_agent}
                .size=${48}
                .name=${this.createdBy.name}
              ></wy-avatar>
              <span slot="title">${this.createdBy.name}</span>
              <span slot="text">
                <time datetime=${this.createdAt} title=${r}>${s}</time>
                ${this.modifiedAt ? h`<time datetime="${this.modifiedAt}" title=${n}> · ${b("edited")}</time>` : v}
              </span>
              <wy-dropdown slot="actions">
                ${this.isSubscribed ? h`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                        <wy-icon name="bell-off"></wy-icon>
                        ${b("Unsubscribe")}
                      </wy-dropdown-item>` : h`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                        <wy-icon name="bell"></wy-icon>
                        ${b("Subscribe")}
                      </wy-dropdown-item>`}
                ${this.user && this.user.id === this.createdBy.id ? h`<wy-dropdown-item @click=${() => this.dispatchEdit(!0)}>
                        <wy-icon name="pencil"></wy-icon>
                        ${b("Edit")}
                      </wy-dropdown-item>` : v}
                ${this.user && this.user.id === this.createdBy.id ? h`<wy-dropdown-item @click=${() => this.dispatchTrash()}>
                        <wy-icon name="trashcan"></wy-icon>
                        ${b("Trash")}
                      </wy-dropdown-item>` : v}
              </wy-dropdown>
            </wy-item>

            <!-- image grid -->
            ${o ? h`<wy-image-grid
                    part="wy-post-images"
                    outer
                    .images=${t}
                    @file-open=${(g) => {
      this.previewAttachmentsRef.value?.open(g.detail.fileId);
    }}
                  ></wy-image-grid>` : ""}

            ${x ? h`
                    <div part="wy-post-body">
                      <!-- text content -->
                      ${c ? h`<div part="wy-content wy-post-content">${bs(this.html)}</div>` : ""}

                      <!-- annotations -->
                      ${l ? h`<wy-annotation-list
                            .files=${this.annotations}
                            @file-open=${(g) => {
      this.previewAnnotationsRef.value?.open(g.detail.fileId);
    }}
                          ></wy-annotation-list>` : v}

                      <!-- poll -->
                      ${u && this.pollOptions ? h`
                            <wy-poll
                              .pollOptions=${this.pollOptions}
                              @vote=${(g) => this.dispatchVote(g.detail.optionId)}
                            ></wy-poll>
                          ` : v}

                      <!-- embeds -->
                      ${f && this.embed ? h` <wy-embed .embed=${this.embed}></wy-embed> ` : v}

                      <!-- files -->
                      ${$ ? h`<wy-attachment-list
                            filled
                            part="wy-post-attachments"
                            .files=${e ?? []}
                            @file-open=${(g) => {
      this.previewAttachmentsRef.value?.open(g.detail.fileId);
    }}
                          ></wy-attachment-list>` : v}
                      <!-- meeting -->
                      ${m && this.meeting ? h`<wy-meeting-card .meeting=${this.meeting}></wy-meeting-card>` : v}
                    </div>
                  ` : v}
          <div part="wy-post-footer">

            <!-- comment count -->
            ${this.componentFeatures?.allowsFeature(M.Comments) ? h` <wy-button
                    small
                    kind="inline"
                    ?active=${this.showComments}
                    part="wy-meta"
                    color="inherit"
                    @click=${(g) => this.handleCommentsClick(g)}
                  >
                    ${this.commentCount !== 1 ? b(ut`${this.commentCount} comments`) : b("1 comment")}
                  </wy-button>` : v}

            <!-- reactions -->
            ${this.componentFeatures?.allowsFeature(M.Reactions) && this.app ? h`
                    <wy-reactions
                      line
                      small
                      .reactions=${this.reactions}
                      parentId=${this.app.id}
                      parentType="apps"
                      entityId=${this.postId}
                      entityType="posts"
                    ></wy-reactions>
                  ` : v}

          </div>

          <!-- comments -->
          <div part="wy-post-comments ${K({ "wy-show": this.showComments })}">
            ${this.loadComments ? h`
                    <wy-comment-list
                      reveal
                      part="wy-post-comment-list"
                      .parentId=${this.postId}
                      .location=${"posts"}
                    ></wy-comment-list>
                  ` : v}
          </div>
        </div>

            ${this.annotations?.length ? h`<wy-preview
                    ${j(this.previewAnnotationsRef)}
                    .files=${this.annotations}
                    .isAttachment=${!0}
                  ></wy-preview> ` : v}
            ${this.attachments?.length ? h`<wy-preview
                    ${j(this.previewAttachmentsRef)}
                    .files=${[...t, ...e]}
                    .isAttachment=${!0}
                  ></wy-preview> ` : v}
          </div>
        `;
  }
  updated(t) {
    t.has("highlight") && this.highlight && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, a(Ho, "WyPostView"), Ho);
At.styles = [Th, $v, wy, cv, vh, Uc, Z];
Kt([
  p({ type: Number })
], At.prototype, "postId", 2);
Kt([
  p({ attribute: !1 })
], At.prototype, "createdBy", 2);
Kt([
  p()
], At.prototype, "createdAt", 2);
Kt([
  p()
], At.prototype, "modifiedAt", 2);
Kt([
  p({ type: Boolean })
], At.prototype, "isSubscribed", 2);
Kt([
  p({ type: Boolean })
], At.prototype, "isTrashed", 2);
Kt([
  p()
], At.prototype, "html", 2);
Kt([
  p()
], At.prototype, "text", 2);
Kt([
  p({ type: Array })
], At.prototype, "annotations", 2);
Kt([
  p({ type: Array })
], At.prototype, "attachments", 2);
Kt([
  p({ type: Array })
], At.prototype, "pollOptions", 2);
Kt([
  p({ attribute: !1 })
], At.prototype, "meeting", 2);
Kt([
  p({ attribute: !1 })
], At.prototype, "embed", 2);
Kt([
  p({ type: Array })
], At.prototype, "reactions", 2);
Kt([
  p({ attribute: !1 })
], At.prototype, "commentCount", 2);
Kt([
  p({ type: Array })
], At.prototype, "seenBy", 2);
Kt([
  p({ type: Boolean })
], At.prototype, "highlight", 2);
Kt([
  F()
], At.prototype, "showComments", 2);
Kt([
  F()
], At.prototype, "loadComments", 2);
Kt([
  F()
], At.prototype, "isCommentLinked", 2);
At = Kt([
  H("wy-post-view"),
  ot()
], At);
var l$ = Object.defineProperty, d$ = Object.getOwnPropertyDescriptor, Ae = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? d$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && l$(t, e, s), s;
}, "__decorateClass$o"), Vo;
let de = (Vo = class extends Rt {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.temp = !1, this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.text = "", this.attachments = [], this.pollOptions = [], this.reactions = [], this.seenBy = [], this.updatePostMutation = new We(this);
  }
  /**
   * Emit an `edit` event toggling edit mode for the post.
   *
   * @param edit - Desired edit state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchEdit(t) {
    const e = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Handle editor submit events and trigger the post update mutation.
   *
   * @param e - Editor submit detail containing updated content.
   */
  async handleSubmit(t) {
    const e = await this.whenApp();
    this.updatePostMutation.mutate({
      id: this.postId,
      app_id: e.id,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      attachments: t.detail.attachments,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId
    }), this.dispatchEdit(!1);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && await this.updatePostMutation.trackMutation(r$(this.weavy, ["posts", this.app.id]));
  }
  render() {
    const t = Wc(this.weavy?.locale, new Date(this.createdAt));
    return h`
      <div part="wy-post">
        <wy-item part="wy-post-header" align="top" size="md" noPadding>
          <wy-avatar
            slot="image"
            .src="${this.createdBy.avatar_url}"
            .isAgent=${this.createdBy.is_agent}
            .size=${48}
            .name=${this.createdBy.name}
          ></wy-avatar>
          <span slot="title" part="wy-placeholder">${this.createdBy.name}</span>
          <time slot="text" part="wy-placeholder">${t}</time>
          <wy-button slot="actions" kind="icon" @click=${() => this.dispatchEdit(!1)}>
            <wy-icon name="close"></wy-icon>
          </wy-button>
        </wy-item>

        <wy-editor
          editorLocation="apps"
          .text=${this.text}
          .embed=${this.embed}
          .options=${this.pollOptions}
          .attachments=${this.attachments ?? []}
          .parentId=${this.postId}
          .typing=${!1}
          .draft=${!1}
          placeholder=${b("Edit post...")}
          buttonText=${b("Update", { desc: "Button action to update" })}
          @submit=${(e) => this.handleSubmit(e)}
        ></wy-editor>
      </div>
    `;
  }
}, a(Vo, "WyPostEdit"), Vo);
de.styles = [Th, Uc, Z];
Ae([
  p({ type: Number })
], de.prototype, "postId", 2);
Ae([
  p({ type: Boolean })
], de.prototype, "temp", 2);
Ae([
  p({ attribute: !1 })
], de.prototype, "createdBy", 2);
Ae([
  p()
], de.prototype, "createdAt", 2);
Ae([
  p()
], de.prototype, "modifiedAt", 2);
Ae([
  p({ type: Boolean })
], de.prototype, "isSubscribed", 2);
Ae([
  p({ type: Boolean })
], de.prototype, "isTrashed", 2);
Ae([
  p()
], de.prototype, "text", 2);
Ae([
  p({ type: Array })
], de.prototype, "attachments", 2);
Ae([
  p({ type: Array })
], de.prototype, "pollOptions", 2);
Ae([
  p({ attribute: !1 })
], de.prototype, "meeting", 2);
Ae([
  p({ attribute: !1 })
], de.prototype, "embed", 2);
Ae([
  p({ type: Array })
], de.prototype, "reactions", 2);
Ae([
  p({ type: Array })
], de.prototype, "seenBy", 2);
de = Ae([
  H("wy-post-edit"),
  ot()
], de);
var h$ = Object.defineProperty, p$ = Object.getOwnPropertyDescriptor, ae = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? p$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && h$(t, e, s), s;
}, "__decorateClass$n"), Uo;
let Ut = (Uo = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.html = "", this.text = "", this.plain = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.commentCount = 0, this.seenBy = [], this.editing = !1;
  }
  /**
   * Emit a `vote` event scoped to the post.
   *
   * @internal
   * @param optionId - Identifier of the selected poll option.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", {
      detail: { optionId: t, parentId: this.postId, parentType: "posts" }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling post subscription.
   *
   * @internal
   * @param subscribe - Desired subscription state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", {
      detail: { id: this.postId, subscribe: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `trash` event requesting the post to be trashed.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `restore` event requesting the post to be restored.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  render() {
    return h`
      ${this.isTrashed ? h`<wy-post-trashed
            postId=${this.postId}
            .createdBy=${this.createdBy}
            @restore=${() => {
      this.dispatchRestore();
    }}
          ></wy-post-trashed> ` : v}
      ${!this.isTrashed && this.editing ? h`<wy-post-edit
            .postId=${this.postId}
            .createdBy=${this.createdBy}
            .createdAt=${this.createdAt}
            .text=${this.text}
            .embed=${this.embed}
            .pollOptions=${this.pollOptions}
            .attachments=${this.attachments}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}
          ></wy-post-edit> ` : v}
      ${!this.isTrashed && !this.editing ? h`<wy-post-view
            id="${this.id}"
            .postId=${this.postId}
            .createdBy=${this.createdBy}
            .createdAt=${this.createdAt}
            .modifiedAt=${this.modifiedAt}
            .isSubscribed=${this.isSubscribed}
            .isTrashed=${this.isTrashed}
            .html=${this.html}
            .text=${this.plain}
            .annotations=${this.annotations ?? []}
            .attachments=${this.attachments ?? []}
            .meeting=${this.meeting}
            .pollOptions=${this.pollOptions}
            .embed=${this.embed}
            .reactions=${this.reactions}
            .commentCount=${this.commentCount}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}
            @subscribe=${(t) => {
      this.dispatchSubscribe(t.detail.subscribe);
    }}
            @trash=${() => {
      this.dispatchTrash();
    }}
            @vote=${(t) => {
      this.dispatchVote(t.detail.optionId);
    }}
          ></wy-post-view> ` : v}
    `;
  }
}, a(Uo, "WyPost"), Uo);
Ut.styles = [zt];
ae([
  p({ type: Number })
], Ut.prototype, "postId", 2);
ae([
  p({ attribute: !1 })
], Ut.prototype, "createdBy", 2);
ae([
  p()
], Ut.prototype, "createdAt", 2);
ae([
  p()
], Ut.prototype, "modifiedAt", 2);
ae([
  p({ type: Boolean })
], Ut.prototype, "isSubscribed", 2);
ae([
  p({ type: Boolean })
], Ut.prototype, "isTrashed", 2);
ae([
  p()
], Ut.prototype, "html", 2);
ae([
  p()
], Ut.prototype, "text", 2);
ae([
  p()
], Ut.prototype, "plain", 2);
ae([
  p({ attribute: !1 })
], Ut.prototype, "annotations", 2);
ae([
  p({ attribute: !1 })
], Ut.prototype, "attachments", 2);
ae([
  p({ type: Array })
], Ut.prototype, "pollOptions", 2);
ae([
  p({ attribute: !1 })
], Ut.prototype, "meeting", 2);
ae([
  p({ attribute: !1 })
], Ut.prototype, "embed", 2);
ae([
  p({ type: Array })
], Ut.prototype, "reactions", 2);
ae([
  p({ attribute: !1 })
], Ut.prototype, "commentCount", 2);
ae([
  p({ type: Array })
], Ut.prototype, "seenBy", 2);
ae([
  F()
], Ut.prototype, "editing", 2);
Ut = ae([
  H("wy-post")
], Ut);
var u$ = Object.defineProperty, y$ = Object.getOwnPropertyDescriptor, Iv = /* @__PURE__ */ a((i) => {
  throw TypeError(i);
}, "__typeError$5"), Tv = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? y$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && u$(t, e, s), s;
}, "__decorateClass$m"), Fv = /* @__PURE__ */ a((i, t, e) => t.has(i) || Iv("Cannot " + e), "__accessCheck$5"), _f = /* @__PURE__ */ a((i, t, e) => (Fv(i, t, "read from private field"), e ? e.call(i) : t.get(i)), "__privateGet$5"), w$ = /* @__PURE__ */ a((i, t, e) => t.has(i) ? Iv("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(i) : t.set(i, e), "__privateAdd$5"), Pf = /* @__PURE__ */ a((i, t, e, r) => (Fv(i, t, "write to private field"), t.set(i, e), e), "__privateSet$5"), an, Bo;
let Ll = (Bo = class extends Rt {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.postsQuery = new Ki(this), this.infiniteScroll = new Gi(this), this.pagerRef = et(), this.addPostMutation = new We(this), this.handleRealtimePostCreated = async (t) => {
      const e = await this.whenWeavy(), r = await this.whenApp(), s = await this.whenUser();
      t.post.app.id !== r.id || t.post.created_by?.id === s.id || (t.post.created_by = t.actor, Ar(e.queryClient, ["posts", r.id], t.post, {
        descending: !0
      }));
    }, this.handleRealtimeCommentCreated = async (t) => {
      const e = await this.whenWeavy(), r = await this.whenApp(), s = await this.whenUser();
      t.actor.id === s.id || !t.comment.parent || (qt(e.queryClient, ["posts", r.id], t.comment.parent.id, (n) => {
        n.comments ? n.comments.count += 1 : n.comments = { count: 1 };
      }), await e.queryClient.invalidateQueries({ queryKey: ["posts", t.comment.app.id, "comments"] }));
    }, this.handleRealtimeReactionAdded = async (t) => {
      const e = await this.whenWeavy(), r = await this.whenApp();
      t.entity.type === ve.Post && qt(e.queryClient, ["posts", r.id], t.entity.id, (s) => {
        Sl(s, t.reaction, t.actor);
      });
    }, this.handleRealtimeReactionDeleted = async (t) => {
      const e = await this.whenWeavy(), r = await this.whenApp();
      t.entity.type === ve.Post && qt(e.queryClient, ["posts", r.id], t.entity.id, (s) => {
        Sl(s, void 0, t.actor);
      });
    }, w$(this, an);
  }
  /**
   * Handle editor submissions by dispatching the create-post mutation.
   *
   * @param e - Submitted editor data.
   */
  async handleSubmit(t) {
    const e = await this.whenApp(), r = await this.whenUser();
    this.addPostMutation.mutate({
      app_id: e.id,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      user: r,
      context: t.detail.contextData
    });
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && this.app?.id !== t.get("app")?.id && await this.postsQuery.trackInfiniteQuery(i$(this.weavy, this.app.id)), (t.has("weavy") || t.has("app") || t.has("componentFeatures")) && this.weavy && this.app && this.app?.id !== t.get("app")?.id) {
      await this.addPostMutation.trackMutation(s$(this.weavy, ["posts", this.app.id])), this.subscribePostMutation = e$(this.weavy, this.app), this.removePostMutation = Y3(this.weavy, this.app), this.restorePostMutation = J3(this.weavy, this.app), this.pollMutation = sy(this.weavy, this.app.id, ["posts", this.app.id]), (e = _f(this, an)) == null || e.call(this);
      const r = `a${this.app.id}`;
      this.weavy.subscribe(r, "post_created", this.handleRealtimePostCreated), this.weavy.subscribe(r, "comment_created", this.handleRealtimeCommentCreated), this.componentFeatures?.allowsFeature(M.Reactions) && (this.weavy.subscribe(r, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(r, "reaction_removed", this.handleRealtimeReactionDeleted)), Pf(this, an, () => {
        this.weavy?.unsubscribe(r, "post_created", this.handleRealtimePostCreated), this.weavy?.unsubscribe(r, "comment_created", this.handleRealtimeCommentCreated), this.weavy?.unsubscribe(r, "reaction_added", this.handleRealtimeReactionAdded), this.weavy?.unsubscribe(r, "reaction_removed", this.handleRealtimeReactionDeleted), Pf(this, an, void 0);
      });
    }
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.postsQuery.result, this.pagerRef.value);
  }
  render() {
    const { data: t, isPending: e, hasNextPage: r } = this.postsQuery.result ?? {}, s = Zi(t);
    return h`
      <div part="wy-posts">
        <div part="wy-posts-header">
          <wy-editor
            editorLocation="apps"
            ?disabled=${!gc(ms.Create, this.app?.permissions)}
            .typing=${!1}
            .draft=${!0}
            placeholder=${this.placeholder ?? b("Create a post...")}
            buttonText=${b("Post")}
            @submit=${(n) => this.handleSubmit(n)}
          ></wy-editor>
        </div>

        <!-- this.user ?? -->
        ${e ? h`<wy-empty><wy-progress-circular indeterminate padded></wy-progress-circular></wy-empty> ` : h`
              ${s ? Fe(
      s,
      (n) => n.id,
      (n) => h`<wy-post
                        id="post-${n.id}"
                        .postId=${n.id}
                        .createdBy=${n.created_by}
                        .createdAt=${n.created_at}
                        .modifiedAt=${n.updated_at}
                        .isSubscribed=${n.is_subscribed}
                        .isTrashed=${n.is_trashed}
                        .html=${n.html}
                        .text=${n.text}
                        .plain=${n.plain}
                        .annotations=${n.annotations?.data}
                        .attachments=${n.attachments?.data}
                        .meeting=${n.meeting}
                        .pollOptions=${n.options?.data}
                        .embed=${n.embed}
                        .reactions=${n.reactions?.data}
                        .commentCount=${n.comments?.count || 0}
                        @subscribe=${(o) => {
        this.subscribePostMutation?.mutate({
          id: o.detail.id,
          subscribe: o.detail.subscribe
        });
      }}
                        @trash=${(o) => {
        this.removePostMutation?.mutate({ id: o.detail.id });
      }}
                        @restore=${(o) => {
        this.restorePostMutation?.mutate({ id: o.detail.id });
      }}
                        @vote=${(o) => {
        o.detail.parentType && o.detail.parentId && this.pollMutation?.mutate({
          optionId: o.detail.optionId,
          parentType: o.detail.parentType,
          parentId: o.detail.parentId
        });
      }}
                      ></wy-post>`
    ) : h`<wy-empty></wy-empty>`}
              ${r ? h`<div ${j(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : v}
            `}
      </div>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = _f(this, an)) == null || t.call(this), super.disconnectedCallback();
  }
}, a(Bo, "WyPostList"), Bo);
an = /* @__PURE__ */ new WeakMap();
Ll.styles = [Th, gy, Br, Z];
Tv([
  p()
], Ll.prototype, "placeholder", 2);
Ll = Tv([
  H("wy-post-list"),
  ot()
], Ll);
var f$ = Object.defineProperty, m$ = Object.getOwnPropertyDescriptor, Dv = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? m$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && f$(t, e, s), s;
}, "__decorateClass$l"), qo;
let Ol = (qo = class extends xe {
  constructor() {
    super(...arguments), this.appType = tt.Posts, this.componentFeatures = new ee({
      // All available features as enabled/disabled by default
      [M.Attachments]: !0,
      [M.CloudFiles]: !0,
      [M.Comments]: !0,
      [M.ContextData]: !0,
      [M.Embeds]: !0,
      [M.GoogleMeet]: !1,
      [M.Meetings]: !1,
      [M.Mentions]: !0,
      [M.MicrosoftTeams]: !1,
      [M.Polls]: !0,
      [M.Previews]: !0,
      [M.Reactions]: !0,
      [M.Typing]: !1,
      // Has no effect currently
      [M.ZoomMeetings]: !1
    }), this.theme = new Te(this, Ol.styles);
  }
  render() {
    return h`
      <wy-buttons position="floating" reverse><slot name="actions"></slot></wy-buttons>
      <wy-post-list .placeholder=${this.placeholder}></wy-post-list>
      <wy-context-data-progress></wy-context-data-progress>
    `;
  }
}, a(qo, "WyPosts"), qo);
Ol.styles = [Yt, Ri, Vs, Us, Se];
Dv([
  p()
], Ol.prototype, "placeholder", 2);
Ol = Dv([
  H("wy-posts"),
  ot()
], Ol);
const v$ = B`[part~=wy-notification] strong{font-weight:var(--wy-font-weight-bold, 600)}[part~=wy-notification] p{display:inline}[part~=wy-notification-text]{color:var(--wy-component-color)}[part~=wy-notification-text]{display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;overflow:hidden}[part~=wy-notification-text]{white-space:normal}`;
var g$ = Object.defineProperty, b$ = Object.getOwnPropertyDescriptor, fd = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? b$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && g$(t, e, s), s;
}, "__decorateClass$k"), No;
let Dr = (No = class extends $e {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.selected = !1, this.standalone = !1;
  }
  /**
   * Emit a `select` event for the current notification.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSelect(t) {
    const e = new CustomEvent("select", {
      detail: { notificationId: this.notificationId }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `mark` event toggling read status.
   *
   * @internal
   * @param e - Source event triggering the action.
   * @param markAsRead - Target read state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchMark(t, e) {
    if (t.stopPropagation(), e === !!this.notification.is_unread) {
      const r = new CustomEvent("mark", {
        detail: { notificationId: this.notificationId, markAsRead: e }
      });
      return this.dispatchEvent(r);
    }
    return !0;
  }
  /**
   * Emit a `hide` event when the toast should disappear.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchHide() {
    if (this.standalone) {
      const t = new CustomEvent("hide", {
        bubbles: !0
      });
      return this.dispatchEvent(t);
    }
    return !0;
  }
  /**
   * Emit a `close` event when the toast should close.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchClose() {
    if (this.standalone) {
      const t = new CustomEvent("close", {
        bubbles: !0
      });
      return this.dispatchEvent(t);
    }
    return !0;
  }
  /**
   * Handle click interactions and trigger navigation plus dismissal.
   *
   * @internal
   */
  async handleClick(t) {
    this.dispatchSelect(t), this.dispatchMark(t, !0), this.dispatchHide(), await yv(this, this.weavy, this.notification), this.dispatchClose();
  }
  render() {
    const t = this.notification.created_at ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.notification.created_at)
    ) : "", e = this.notification.created_at ? Wc(this.weavy?.locale, new Date(this.notification.created_at)) : "", r = this.notification.actor, { title: s, titleHtml: n, detail: o } = wv(this.notification);
    return h`
      <wy-item
        part="wy-notification"
        size="md"
        interactive
        outer
        status=${!this.standalone && !this.notification.is_unread ? "read" : void 0}
        ?selected=${!this.standalone && this.selected}
        align="top"
        actionsPosition=${this.standalone ? "end" : "bottom"}
        tabindex="0"
        @click=${(c) => this.handleClick(c)}
        @keydown=${le}
        @keyup=${Me}
      >
        <wy-avatar
          slot="image"
          src=${nt(r?.avatar_url)}
          name=${nt(r?.name)}
          description=${nt(r?.comment)}
          presence=${r?.presence || "away"}
          ?isAgent=${r?.is_agent}
          id=${nt(r?.id)}
          size=${48}
        ></wy-avatar>

        <div slot="title" part="wy-notification-text" title=${s + (o ? `: "${o}"` : "")}>
          ${n}${o ? h`: <q part="wy-quote">${o}</q> ` : v}
      </div>

        ${this.standalone ? v : h`
              <time slot="text" part="wy-meta" datetime=${this.notification.created_at.toString()} title=${t}>
                ${e}
              </time>
            `}
        ${this.standalone ? h`
              <wy-button
                slot="actions"
                kind="icon"
                @click=${(c) => this.dispatchMark(c, !!this.notification.is_unread) && this.dispatchClose()}
              >
                <wy-icon name="close"></wy-icon>
              </wy-button>
            ` : h`
              <wy-button
                small
                slot="actions"
                kind="icon"
                @click=${(c) => this.dispatchMark(c, !!this.notification.is_unread) && this.dispatchClose()}
                title=${this.notification.is_unread ? b("Mark as read") : b("Mark as unread")}
              >
                <wy-icon
                  name=${this.notification.is_unread ? "read" : "unread"}
                  color=${this.notification.is_unread ? "" : "secondary"}
                ></wy-icon>
              </wy-button>
            `}
      </wy-item>
    `;
  }
}, a(No, "WyNotificationListItem"), No);
Dr.styles = [zt, Uc, v$, Z];
fd([
  p({ type: Number })
], Dr.prototype, "notificationId", 2);
fd([
  p({ type: Boolean, reflect: !0 })
], Dr.prototype, "selected", 2);
fd([
  p({ type: Boolean })
], Dr.prototype, "standalone", 2);
fd([
  p({ attribute: !1 })
], Dr.prototype, "notification", 2);
Dr = fd([
  H("wy-notification-list-item"),
  ot()
], Dr);
var x$ = Object.defineProperty, $$ = Object.getOwnPropertyDescriptor, Hv = /* @__PURE__ */ a((i) => {
  throw TypeError(i);
}, "__typeError$4"), Ks = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? $$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && x$(t, e, s), s;
}, "__decorateClass$j"), Vv = /* @__PURE__ */ a((i, t, e) => t.has(i) || Hv("Cannot " + e), "__accessCheck$4"), Mf = /* @__PURE__ */ a((i, t, e) => (Vv(i, t, "read from private field"), e ? e.call(i) : t.get(i)), "__privateGet$4"), C$ = /* @__PURE__ */ a((i, t, e) => t.has(i) ? Hv("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(i) : t.set(i, e), "__privateAdd$4"), Sf = /* @__PURE__ */ a((i, t, e, r) => (Vv(i, t, "write to private field"), t.set(i, e), e), "__privateSet$4"), on, jo;
let Rc = (jo = class extends Rt {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.typeFilter = bt.All, this.notificationsQuery = new Ki(this), this.infiniteScroll = new Gi(this), this.pagerRef = et(), this.handleRefresh = (t) => {
      this.notificationsQuery.result.refetch();
    }, this.handlePresenceChange = (t) => {
      this.weavy && (Array.isArray(t) || (t = [parseInt(t)]), qt(this.weavy.queryClient, ["notifications", "list"], void 0, (e) => {
        const r = e.actor;
        r.presence = t.indexOf(r.id) != -1 ? "active" : "away", e.actor = r;
      }));
    }, C$(this, on);
  }
  /**
   * Mark or unmark a notification as read.
   *
   * @param notificationId - Target notification id.
   * @param markAsRead - Desired read state.
   */
  async markAsRead(t, e = !0) {
    await this.markNotificationMutation?.mutate({ notificationId: t, markAsRead: e });
  }
  /**
   * Select the provided notification and emit a `wy-action` event.
   *
   * @internal
   * @param notification - Notification to select.
   */
  selectNotification(t) {
    this.notificationId = t.id, this.dispatchAction(ge.Select, t);
  }
  /**
   * Triggers `wy-action` event.
   *
   * @internal
   * @param action - The performed action.
   * @param notification - Selected notification payload.
   * @returns Whether the event was successful.
   */
  dispatchAction(t, e) {
    const r = new CustomEvent("wy-action", {
      detail: { action: t, notification: e },
      bubbles: !0,
      composed: !0
    });
    return this.dispatchEvent(r);
  }
  async willUpdate(t) {
    var e;
    super.willUpdate(t), (t.has("weavy") || t.has("typeFilter") || t.has("app")) && this.weavy && await this.notificationsQuery.trackInfiniteQuery(
      S0(this.weavy, this.typeFilter, this.app?.id)
    ), t.has("weavy") && this.weavy && (this.markNotificationMutation = Am(this.weavy), (e = Mf(this, on)) == null || e.call(this), this.weavy.subscribe(null, "online", this.handlePresenceChange), this.weavy.subscribe(null, "notification_created", this.handleRefresh), this.weavy.subscribe(null, "notification_updated", this.handleRefresh), this.weavy.subscribe(null, "notifications_marked", this.handleRefresh), Sf(this, on, () => {
      this.weavy?.unsubscribe(null, "online", this.handlePresenceChange), this.weavy?.unsubscribe(null, "notification_created", this.handleRefresh), this.weavy?.unsubscribe(null, "notification_updated", this.handleRefresh), this.weavy?.unsubscribe(null, "notifications_marked", this.handleRefresh), Sf(this, on, void 0);
    }));
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.notificationsQuery.result, this.pagerRef.value);
  }
  /**
   * Render the notifications collection.
   *
   * @internal
   * @param user - Current user.
   * @param infiniteData - Notification pages.
   */
  renderNotifications(t, e) {
    if (e) {
      const r = Zi(e);
      return Fe(
        r,
        (s) => s?.id,
        (s) => [
          h`<wy-notification-list-item
              notificationId=${s.id}
              .notification=${s}
              .selected=${this.notificationId == s.id}
              @select=${(n) => this.selectNotification(s)}
              @mark=${(n) => this.markAsRead(n.detail.notificationId, n.detail.markAsRead)}
            ></wy-notification-list-item>`
        ]
      );
    }
    return v;
  }
  render() {
    const { data: t, hasNextPage: e, isPending: r } = this.notificationsQuery.result ?? {};
    return h`
      ${this.user ? h`
            <div class="wy-notifications">
              ${!r && this.user && t ? t.pages[0]?.count ? this.renderNotifications(this.user, t) : h`
                      <div part="wy-pane-body">
                        <div part="wy-pane-group">
                          <slot name="empty">
                            <wy-empty>${b("No updates yet.")}</wy-empty>
                          </slot>
                        </div>
                      </div>
                    ` : h`<wy-empty><wy-progress-circular indeterminate padded></wy-progress-circular></wy-empty>`}
              ${e ? h`<div ${j(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : v}
            </div>
          ` : h`<wy-empty part="wy-pane"><wy-progress-circular indeterminate overlay></wy-progress-circular></wy-empty>`}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = Mf(this, on)) == null || t.call(this), super.disconnectedCallback();
  }
}, a(jo, "WyNotificationList"), jo);
on = /* @__PURE__ */ new WeakMap();
Rc.styles = [
  qs,
  Br,
  B`
      :host {
        position: relative;
      }
    `
];
Ks([
  p({ type: Number })
], Rc.prototype, "notificationId", 2);
Ks([
  p()
], Rc.prototype, "typeFilter", 2);
Rc = Ks([
  H("wy-notification-list"),
  ot()
], Rc);
var Wo;
let Os = (Wo = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.typeFilter = bt.All, this.activeFilter = bt.All;
  }
  /**
   * Trigger `filter` event.
   *
   * @param typeFilter - Filter to emit.
   * @returns Whether the event was dispatched successfully.
   */
  dispatchFilter(t) {
    const e = new CustomEvent("filter", {
      detail: { typeFilter: t }
    });
    return this.dispatchEvent(e);
  }
  render() {
    const t = !!this._slotDefault.length;
    return h`
      <div part="wy-pane-toolbar">
        <slot @slotchange=${() => this.requestUpdate()}></slot>
        ${t ? v : h`
              <wy-buttons tabs>
                <wy-button
                  ?active=${this.typeFilter === bt.All}
                  @click=${() => {
      this.dispatchFilter(bt.All) && (this.typeFilter = bt.All);
    }}
                  kind="tab"
                  small
                >
                  ${b("All")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === bt.Activity}
                  @click=${() => {
      this.dispatchFilter(bt.Activity) && (this.typeFilter = bt.Activity);
    }}
                  kind="tab"
                  small
                >
                  ${b("Activities")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === bt.Mention}
                  @click=${() => {
      this.dispatchFilter(bt.Mention) && (this.typeFilter = bt.Mention);
    }}
                  kind="tab"
                  small
                >
                  ${b("Mentions")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === bt.Reaction}
                  @click=${() => {
      this.dispatchFilter(bt.Reaction) && (this.typeFilter = bt.Reaction);
    }}
                  kind="tab"
                  small
                >
                  ${b("Reactions")}
                </wy-button>
              </wy-buttons>
            `}

        <slot name="actions" @slotchange=${() => this.requestUpdate()}></slot>
      </div>
    `;
  }
}, a(Wo, "WyNotificationHeader"), Wo);
Os.styles = [
  qs,
  Br,
  B`
      :host {
        position: relative;
      }
    `
];
Ks([
  p()
], Os.prototype, "typeFilter", 2);
Ks([
  F()
], Os.prototype, "activeFilter", 2);
Ks([
  Hc({ flatten: !0, selector: ":not(slot)" })
], Os.prototype, "_slotDefault", 2);
Os = Ks([
  H("wy-notification-header"),
  ot()
], Os);
var k$ = Object.defineProperty, _$ = Object.getOwnPropertyDescriptor, My = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? _$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && k$(t, e, s), s;
}, "__decorateClass$i"), Qo;
let Ec = (Qo = class extends zr {
  constructor() {
    super(...arguments), this.unreadNotifications = new ul(this), this.theme = new Te(this, Ec.styles), this.currentTypeFilter = bt.All, this.typeFilter = bt.All;
  }
  /** Current unread notification count. */
  get unread() {
    return this.unreadNotifications.unread;
  }
  /** Marks all tracked notifications as read. */
  async markAllAsRead() {
    await this.unreadNotifications.markAllAsRead();
  }
  async willUpdate(t) {
    await super.willUpdate(t), t.has("typeFilter") && (this.currentTypeFilter = this.typeFilter), (t.has("typeFilter") || t.has("app")) && await this.unreadNotifications.track(this.typeFilter, this.app?.id);
  }
  render() {
    const t = this.typeFilter === bt.All;
    return h`
      ${t ? h`
            <wy-notification-header
              @filter=${(e) => {
      this.currentTypeFilter = e.detail.typeFilter;
    }}
            >
              <slot name="actions" slot="actions">
                <wy-button kind="icon" @click=${() => this.markAllAsRead()} title=${b("Mark all as read")}>
                  <wy-icon name="check-all"></wy-icon>
                </wy-button>
              </slot>
            </wy-notification-header>
          ` : v}
      ${this.user ? h` <wy-notification-list typeFilter=${this.currentTypeFilter}></wy-notification-list> ` : h`
            <wy-empty>
              <wy-progress-circular indeterminate padded reveal></wy-progress-circular>
            </wy-empty>
          `}
    `;
  }
}, a(Qo, "WyNotifications"), Qo);
Ec.styles = [Yt, Ri, Vs, Us, Se];
My([
  F()
], Ec.prototype, "currentTypeFilter", 2);
My([
  p()
], Ec.prototype, "typeFilter", 2);
Ec = My([
  H("wy-notifications"),
  ot()
], Ec);
const Uv = B`:host{display:inline-flex}`;
var P$ = Object.defineProperty, M$ = Object.getOwnPropertyDescriptor, Fh = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? M$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && P$(t, e, s), s;
}, "__decorateClass$h"), Ko;
let Lc = (Ko = class extends zr {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.unreadNotifications = new ul(this), this.badge = "count", this.badgePosition = "inline", this.typeFilter = bt.All;
  }
  /** Current unread notification count. */
  get unread() {
    return this.unreadNotifications.unread;
  }
  /** Marks all tracked notifications as read. */
  async markAllAsRead() {
    await this.unreadNotifications.markAllAsRead();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("typeFilter") || t.has("app")) && await this.unreadNotifications.track(this.typeFilter, this.app?.id);
  }
  render() {
    return this.user && this.badge !== "none" ? h`
          <wy-badge
            appearance=${this.badge}
            position=${this.badgePosition}
            .count=${this.unreadNotifications.isUnreadPending ? NaN : this.unreadNotifications.unread}
          ></wy-badge>
        ` : v;
  }
}, a(Ko, "WyNotificationBadge"), Ko);
Lc.styles = [Uv, Yt, Se];
Fh([
  p({ type: String })
], Lc.prototype, "badge", 2);
Fh([
  p({ type: String })
], Lc.prototype, "badgePosition", 2);
Fh([
  p()
], Lc.prototype, "typeFilter", 2);
Lc = Fh([
  H("wy-notification-badge")
], Lc);
var S$ = Object.defineProperty, A$ = Object.getOwnPropertyDescriptor, Wr = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? A$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && S$(t, e, s), s;
}, "__decorateClass$g"), Go;
let Ai = (Go = class extends zr {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.unreadNotifications = new ul(this), this.overlay = "sheet", this.badge = "compact", this.badgePosition = "top-right", this.typeFilter = bt.All, this.currentTypeFilter = bt.All, this.showNotificationList = !1;
  }
  set list(t) {
    console.warn(`.list is deprecated. Use .overlay = "${t}"; instead`), this.overlay = t;
  }
  get list() {
    return this.overlay;
  }
  /** Current unread notification count. */
  get unread() {
    return this.unreadNotifications.unread;
  }
  /** Marks all tracked notifications as read. */
  async markAllAsRead() {
    await this.unreadNotifications.markAllAsRead();
  }
  async willUpdate(t) {
    await super.willUpdate(t), t.has("typeFilter") && (this.currentTypeFilter = this.typeFilter), (t.has("typeFilter") || t.has("app")) && await this.unreadNotifications.track(this.typeFilter, this.app?.id);
  }
  render() {
    const t = this.typeFilter === bt.All;
    return h`
      <wy-button
        kind="icon"
        ?active=${this.showNotificationList}
        @click=${() => this.showNotificationList = !this.showNotificationList}
      >
        <wy-icon name="bell">
          ${this.user && this.badge !== "none" ? h`
                <wy-badge
                  appearance=${this.badge}
                  position=${this.badgePosition}
                  .count=${this.unreadNotifications.isUnreadPending ? NaN : this.unreadNotifications.unread}
                ></wy-badge>
              ` : v}
        </wy-icon>
      </wy-button>

      ${this.overlay !== "none" ? h`<wy-overlay
            type=${this.overlay}
            .show=${this.showNotificationList}
            @close=${() => this.showNotificationList = !1}
          >
            <slot name="actions" slot="actions">
              <wy-button kind="icon" @click=${() => this.markAllAsRead()} title=${b("Mark all as read")}>
                <wy-icon name="check-all"></wy-icon>
              </wy-button>
              ${this.app ? h`
                    <wy-dropdown>
                      ${this.app?.is_subscribed ? h`
                            <wy-dropdown-item @click=${() => this.subscribe(!1)}>
                              <wy-icon name="bell-off"></wy-icon>
                              ${b("Unsubscribe")}
                            </wy-dropdown-item>
                          ` : h`
                            <wy-dropdown-item @click=${() => this.subscribe(!0)}>
                              <wy-icon name="bell"></wy-icon>
                              ${b("Subscribe")}
                            </wy-dropdown-item>
                          `}
                    </wy-dropdown>
                  ` : v}
            </slot>
            <slot slot="title">${b("Notifications")}</slot>
            <wy-container scrollY>
              ${this.showNotificationList ? h`
                    ${t ? h`
                          <wy-notification-header
                            @filter=${(e) => {
      this.currentTypeFilter = e.detail.typeFilter;
    }}
                          ></wy-notification-header>
                        ` : v}
                    <wy-notification-list typeFilter=${this.currentTypeFilter}>
                      ${this.app && !this.app?.is_subscribed ? h`
                            <wy-empty slot="empty">
                              <div>${b("You are not subscribed to updates yet.")}</div>
                              <wy-button color="primary" @click=${() => this.subscribe(!0)}
                                >${b("Subscribe")}</wy-button
                              >
                            </wy-empty>
                          ` : v}
                    </wy-notification-list>
                  ` : v}
            </wy-container>
          </wy-overlay>` : v}
    `;
  }
}, a(Go, "WyNotificationButton"), Go);
Ai.styles = [Z, Yt, Se];
Wr([
  p({ type: String })
], Ai.prototype, "overlay", 2);
Wr([
  p({ type: String })
], Ai.prototype, "list", 1);
Wr([
  p({ type: String })
], Ai.prototype, "badge", 2);
Wr([
  p({ type: String })
], Ai.prototype, "badgePosition", 2);
Wr([
  p()
], Ai.prototype, "typeFilter", 2);
Wr([
  F()
], Ai.prototype, "currentTypeFilter", 2);
Wr([
  F()
], Ai.prototype, "showNotificationList", 2);
Ai = Wr([
  H("wy-notification-button"),
  ot()
], Ai);
var z$ = Object.defineProperty, R$ = Object.getOwnPropertyDescriptor, md = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? R$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && z$(t, e, s), s;
}, "__decorateClass$f"), Zo;
let Il = (Zo = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.show = !1, this.viewportRef = et();
  }
  /**
   * Close the popover layer.
   */
  close() {
    this.show = !1;
    try {
      this.viewportRef.value?.hidePopover();
    } catch {
    }
  }
  /**
   * Handler when popover is toggled.
   * @internal
   */
  handleClose(t) {
    if (t.type === "toggle" && t.newState === "closed" || t.type === "click") {
      this.show = !1;
      const e = new CustomEvent("hide");
      this.dispatchEvent(e);
    }
  }
  render() {
    return h`
      <div part="wy-toasts" tabindex="0" ${j(this.viewportRef)} ?hidden=${!this.show} popover="auto">
        <slot></slot>
      </div>
    `;
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("show"))
      try {
        this.show ? this.viewportRef.value?.showPopover() : this.viewportRef.value?.hidePopover();
      } catch {
      }
    t.has("show") && this.show && this.viewportRef.value?.focus();
  }
  firstUpdated(t) {
    this.viewportRef.value?.addEventListener(this.viewportRef.value.popover ? "toggle" : "click", (e) => {
      this.handleClose(e);
    }), this.show && this.viewportRef.value?.showPopover();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
  }
}, a(Zo, "WyToasts"), Zo);
Il.styles = [
  ay,
  Z
];
md([
  p({ type: Boolean })
], Il.prototype, "show", 2);
Il = md([
  H("wy-toasts")
], Il);
var Yo;
let rr = (Yo = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.toastRef = et(), this.show = !1, this.duration = rr.defaultDuration;
  }
  /**
   * Hide the toast.
   */
  hide() {
    this.show = !1;
  }
  /**
   * Hide and close the toast.
   * 
   * @param silent - Indicates that the toast should close silently.
   * @fires {ClosedEventType} closed - When the toast has been hidden and closed.
   */
  async close(t = !1) {
    this.show = !1, await new Promise((r) => requestAnimationFrame(r)), this.toastRef.value && await Bp(this.toastRef.value, !1);
    const e = new CustomEvent("closed", { detail: { silent: t } });
    this.dispatchEvent(e);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("show") && (this.timeout && (window.clearTimeout(this.timeout), this.timeout = void 0), this.show && this.duration > 0 && this.duration < 1 / 0 && (this.timeout = window.setTimeout(() => this.close(!0), this.duration)));
  }
  render() {
    return h`
      <div
        ${j(this.toastRef)}
        part="wy-toast wy-fade ${this.show ? "wy-show" : ""}"
        @hide=${(t) => {
      t.stopPropagation(), this.hide();
    }}
        @close=${() => this.close()}
        @keyup=${ny}
      >
        <slot></slot>
      </div>
    `;
  }
  firstUpdated() {
    requestAnimationFrame(() => {
      this.show = !0;
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.timeout && (window.clearTimeout(this.timeout), this.timeout = void 0);
  }
}, a(Yo, "WyToast"), Yo);
rr.styles = [
  ay,
  Z
];
rr.defaultDuration = 5e3;
md([
  F()
], rr.prototype, "show", 2);
md([
  p({ type: Number })
], rr.prototype, "duration", 2);
rr = md([
  H("wy-toast")
], rr);
var E$ = Object.defineProperty, L$ = Object.getOwnPropertyDescriptor, Bv = /* @__PURE__ */ a((i) => {
  throw TypeError(i);
}, "__typeError$3"), Zc = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? L$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && E$(t, e, s), s;
}, "__decorateClass$e"), qv = /* @__PURE__ */ a((i, t, e) => t.has(i) || Bv("Cannot " + e), "__accessCheck$3"), Af = /* @__PURE__ */ a((i, t, e) => (qv(i, t, "read from private field"), e ? e.call(i) : t.get(i)), "__privateGet$3"), O$ = /* @__PURE__ */ a((i, t, e) => t.has(i) ? Bv("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(i) : t.set(i, e), "__privateAdd$3"), zf = /* @__PURE__ */ a((i, t, e, r) => (qv(i, t, "write to private field"), t.set(i, e), e), "__privateSet$3"), cn, Xo;
let sr = (Xo = class extends zr {
  constructor() {
    super(...arguments), this.theme = new Te(this, sr.styles), this.typeFilter = bt.All, this.appearance = "internal", this.requestUserPermission = !1, this.duration = rr.defaultDuration, this._notifications = [], this._nativeNotifications = [], this.handleEvent = async (t) => {
      if (this.typeFilter === bt.All || this.typeFilter === t.notification.type)
        if (t.action === "notification_deleted")
          this.removeNotification(t.notification.id), this.closeNativeNotification(t.notification.id);
        else {
          const { title: e, detail: r } = wv(t.notification), s = {
            ...t.notification,
            title: e,
            detail: r,
            lang: this.weavy?.locale
          }, n = new CustomEvent("wy-notification", {
            bubbles: !0,
            composed: !0,
            cancelable: !0,
            detail: s
          });
          (!this.requestUserPermission && this.appearance !== "native" || await this.hasUserPermission() ? this.dispatchEvent(n) : !1) && (t.action === "notification_created" && t.notification.is_unread ? await this.addOrUpdateNotification(t.notification) : await this.updateNotification(t.notification), await this.addOrUpdateNativeNotification(s));
        }
    }, O$(this, cn);
  }
  /** @internal */
  async addOrUpdateNotification(t) {
    if (!this.requestUserPermission || await this.hasUserPermission()) {
      const e = [...this._notifications], r = e.findIndex((s) => s.id === t.id);
      r !== -1 ? (e.splice(r, 1, t), this._notifications = e) : (e.push(t), this._notifications = e);
    }
  }
  /** @internal */
  async updateNotification(t) {
    if (!this.requestUserPermission || await this.hasUserPermission()) {
      const e = [...this._notifications], r = e.findIndex((s) => s.id === t.id);
      r !== -1 && (e.splice(r, 1, t), this._notifications = e);
    }
  }
  /** @internal */
  removeNotification(t) {
    const e = [...this._notifications], r = e.findIndex((s) => s.id === t);
    r !== -1 && (e.splice(r, 1), this._notifications = e);
  }
  /** @internal */
  async addOrUpdateNativeNotification(t) {
    if (this.appearance === "native" && await this.hasUserPermission()) {
      const e = this.removeNativeNotification(t.id), r = t.actor, s = new Notification(t.title, {
        tag: `wy-${t.id}`,
        lang: t.lang,
        body: t.detail,
        icon: r.avatar_url,
        // @ts-expect-error Property `renotify` not available in ts types yet
        renotify: e && t.is_unread
      });
      s.onclick = async () => {
        await this.markAsRead(t.id, !0), await yv(this, this.weavy, t);
      }, s.onclose = () => {
        this.removeNativeNotification(t.id);
      }, this._nativeNotifications = [...this._nativeNotifications, s];
    }
  }
  /** @internal */
  removeNativeNotification(t) {
    const e = [...this._nativeNotifications], r = e.findIndex(
      (s) => s.tag === `wy-${t}`
    );
    return r ? (e.splice(r, 1), this._nativeNotifications = e, !0) : !1;
  }
  /** @internal */
  closeNativeNotification(t) {
    const e = this._nativeNotifications.findIndex(
      (r) => r.tag === `wy-${t}`
    );
    return e ? (this._nativeNotifications[e].close(), !0) : !1;
  }
  /** Checks if the user has granted permission for desktop notifications. A request will be made if permission has not yet been granted. */
  async hasUserPermission() {
    if (!("Notification" in window))
      console.error("This browser does not support desktop notifications");
    else if (!window.isSecureContext)
      console.error(
        `Desktop notifications can only be used in secure contexts. 
        See https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts`
      );
    else {
      if (Notification.permission === "granted")
        return !0;
      if (Notification.permission !== "denied")
        return await Notification.requestPermission() === "granted";
    }
    return !1;
  }
  /** Clears queued internal toast notifications. */
  clearNotifications() {
    this._notifications = [];
  }
  /**
   * Marks a notification as read or unread.
   * @param notificationId - The ID of the notification to mark.
   * @param [markAsRead=true] - Whether to mark the notification as read (true) or unread (false).
   */
  async markAsRead(t, e = !0) {
    await this.markNotificationMutation?.mutate({ notificationId: t, markAsRead: e });
  }
  async willUpdate(t) {
    var e;
    await super.willUpdate(t), t.has("weavy") && this.weavy && (this.markNotificationMutation = Am(this.weavy), (e = Af(this, cn)) == null || e.call(this), this.weavy.subscribe(null, "notification_created", this.handleEvent), this.weavy.subscribe(null, "notification_updated", this.handleEvent), zf(this, cn, () => {
      this.weavy?.unsubscribe(null, "notification_created", this.handleEvent), this.weavy?.unsubscribe(null, "notification_updated", this.handleEvent), zf(this, cn, void 0);
    })), (t.has("requestUserPermission") && this.requestUserPermission || t.has("appearance") && this.appearance === "native") && this.hasUserPermission();
  }
  render() {
    return h`
      ${this.user && this.appearance === "internal" ? h`
            <wy-toasts ?show=${!!this._notifications.length} @hide=${() => this.clearNotifications()}>
              ${Fe(
      this._notifications,
      (t) => t.id,
      (t) => h`
                    <wy-toast
                      duration=${this.duration}
                      @closed=${(e) => {
        e.detail.silent || this.markAsRead(t.id, !0), this.removeNotification(t.id);
      }}
                    >
                      <wy-notification-list-item standalone .notification=${t}></wy-notification-list-item>
                    </wy-toast>
                  `
    )}
            </wy-toasts>
          ` : v}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = Af(this, cn)) == null || t.call(this), super.disconnectedCallback();
  }
}, a(Xo, "WyNotificationToasts"), Xo);
cn = /* @__PURE__ */ new WeakMap();
sr.styles = [Yt, Z, Se];
Zc([
  p()
], sr.prototype, "typeFilter", 2);
Zc([
  p()
], sr.prototype, "appearance", 2);
Zc([
  p({ type: Boolean })
], sr.prototype, "requestUserPermission", 2);
Zc([
  p({ type: Number })
], sr.prototype, "duration", 2);
Zc([
  F()
], sr.prototype, "_notifications", 2);
sr = Zc([
  H("wy-notification-toasts"),
  ot()
], sr);
const m9 = new Map(
  Object.entries({
    [ai.ChatRoom]: tt.ChatRoom,
    [ai.PrivateChat]: tt.PrivateChat,
    [tt.ChatRoom]: ai.ChatRoom,
    [tt.PrivateChat]: ai.PrivateChat
  })
), v9 = new Map(
  Object.entries({
    [ai.AgentChat]: tt.AgentChat,
    [tt.AgentChat]: ai.AgentChat
  })
), Oc = {
  // All available features as enabled/disabled by default
  [M.Attachments]: !0,
  [M.CloudFiles]: !0,
  [M.ContextData]: !0,
  [M.Embeds]: !0,
  [M.GoogleMeet]: !0,
  [M.Meetings]: !0,
  [M.Mentions]: !0,
  [M.MicrosoftTeams]: !0,
  [M.Polls]: !0,
  [M.Previews]: !0,
  [M.Reactions]: !0,
  [M.Receipts]: !0,
  [M.Typing]: !0,
  [M.ZoomMeetings]: !0
}, Sy = {
  // All available features as enabled/disabled by default
  [M.Attachments]: !0,
  [M.ContextData]: !0,
  [M.Embeds]: !0,
  [M.Previews]: !0,
  [M.Reactions]: !1,
  [M.Receipts]: !0,
  [M.Typing]: !0
}, Ay = B`[part~=wy-messenger-layout]{display:flex;flex:1;align-items:stretch;position:relative;container-type:inline-size;align-self:stretch;min-height:0;min-width:0;box-sizing:border-box}[part~=wy-messenger-overlay-container]{--wy-padding-outer: var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));--wy-component-offset-top: calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem))))))}[part~=wy-messenger-conversation-list]{flex:0 1 100%;min-width:0;max-width:none;display:flex;flex-direction:column;padding:var(--wy-padding-outer, var(--wy-padding, 0));gap:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-messenger-conversation]{display:flex;flex-direction:column;overflow-anchor:none;height:100%;width:100%;flex:0 1 100%;box-sizing:border-box;padding:var(--wy-padding-outer, var(--wy-padding, 0));--wy-component-offset-top: var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))}[part~=wy-close-conversation]{display:contents}@container (inline-size < 768px){[part~=wy-messenger-conversation-list]:not([data-conversation-id=\"\"]){display:none}[part~=wy-messenger-conversation][data-conversation-id=\"\"]{display:none}}@container (inline-size >= 768px){[part~=wy-messenger-conversation-list]{flex:0 1 50%;max-width:calc(24*var(--wy-size, 1rem));padding-right:var(--wy-padding-outer, calc(.5 * var(--wy-size, 1rem)));border-right:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-messenger-conversation]{min-width:max(50%,calc(16 * var(--wy-size, 1rem)));padding-left:var(--wy-padding-outer, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-close-conversation]{display:none}}`;
var I$ = Object.defineProperty, T$ = Object.getOwnPropertyDescriptor, zy = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? T$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && I$(t, e, s), s;
}, "__decorateClass$d"), Jo;
let Ic = (Jo = class extends $e {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.uploadBlobMutation = new We(this), this.fileInputRef = et(), this.openFileInput = () => {
      this.fileInputRef.value?.click();
    };
  }
  /**
   * Uploads the first selected file and resets the input.
   *
   * @internal
   */
  async handleBlobChange(t, e) {
    if (t && this.weavy) {
      const s = { file: t[0] };
      await this.uploadBlobMutation.trackMutation(n0(this.weavy));
      const n = await this.uploadBlobMutation.mutate(s);
      e && (e.value = "");
      const o = new CustomEvent("blob-uploaded", { detail: { blob: n } });
      this.dispatchEvent(o);
    }
  }
  render() {
    return h`
      <div part="wy-upload">
        <slot
          part="wy-upload-placeholder"
          name="placeholder"
          @click=${this.openFileInput}
          @keydown=${le}
          @keyup=${Me}
        ></slot>
        <input
          accept=${nt(this.accept)}
          type="file"
          ${j(this.fileInputRef)}
          @click=${(t) => t.stopPropagation()}
          @change=${(t) => this.handleBlobChange(t.target.files, t.target)}
          hidden
        />
        <slot part="wy-upload-action" name="action">
          ${this.label ? h`<wy-button part="wy-upload-button" @click=${this.openFileInput}>${this.label}</wy-button>` : v}
        </slot>
      </div>
    `;
  }
}, a(Jo, "WyUpload"), Jo);
Ic.styles = [
  B`
      :host {
        display: contents;
      }

      [part~="wy-upload"] {
        text-align: center;
      }

      [part~="wy-upload-placeholder"] {
        cursor: pointer;
      }
    `
];
zy([
  p({ attribute: !1 })
], Ic.prototype, "label", 2);
zy([
  p({ attribute: !1 })
], Ic.prototype, "accept", 2);
Ic = zy([
  H("wy-upload")
], Ic);
var F$ = Object.defineProperty, D$ = Object.getOwnPropertyDescriptor, Dh = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? D$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && F$(t, e, s), s;
}, "__decorateClass$c"), tc;
let Is = (tc = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.inputRef = et(), this.compact = !1, this.query = "", this.throttledSearch = Lu(
      () => {
        this.query = this.inputRef.value?.value || "";
      },
      250,
      { leading: !1, trailing: !0 }
    );
  }
  /**
   * Put focus on the input field.
   */
  focusInput() {
    this.inputRef.value?.focus();
  }
  /**
   * Clear the input field.
   */
  clear() {
    this.query = "";
  }
  willUpdate(t) {
    if (t.has("query")) {
      const e = new CustomEvent("search", {
        bubbles: !0,
        composed: !1,
        detail: { query: this.query }
      });
      this.dispatchEvent(e);
    }
  }
  render() {
    const t = {
      "wy-input": !0,
      "wy-input-group-input": !0,
      "wy-input-filled": !0,
      "wy-input-group-input-with-overlay": this.compact
    }, e = {
      "wy-input-group-button-icon": !0,
      "wy-input-group-button-icon-overlay": this.compact
    };
    return h`
      <div part="wy-input-group">
        <input
          part=${K(t)}
          name="text"
          .value=${this.query || ""}
          ${j(this.inputRef)}
          @input=${() => this.throttledSearch()}
          @keydown=${mb}
          @keyup=${Rr}
          placeholder=${this.placeholder || b("Search...")}
          size="4"
        />
        <wy-button type="reset" @click=${() => this.clear()} kind="icon" part=${K(e)}>
          <wy-icon name="close-circle"></wy-icon>
        </wy-button>
        <wy-button kind="icon" part=${K(e)}>
          <wy-icon name="magnify"></wy-icon>
        </wy-button>
      </div>
    `;
  }
}, a(tc, "WySearch"), tc);
Is.styles = [jr, Z];
Dh([
  p()
], Is.prototype, "placeholder", 2);
Dh([
  p({ type: Boolean })
], Is.prototype, "compact", 2);
Dh([
  F()
], Is.prototype, "query", 2);
Is = Dh([
  H("wy-search"),
  ot()
], Is);
var H$ = Object.defineProperty, V$ = Object.getOwnPropertyDescriptor, Qr = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? V$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && H$(t, e, s), s;
}, "__decorateClass$b"), ec;
let di = (ec = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.agentFilter = void 0, this.selected = [], this.select = [], this.text = "", this.peopleQuery = new Ki(this), this.searchRef = et(), this.infiniteScroll = new Gi(this), this.pagerRef = et();
  }
  /**
   * Emits the selected members via the `submit` event.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchSubmit() {
    this.selected = [...this.selected, ...this.select];
    const t = new CustomEvent("submit", {
      detail: { members: this.selected }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Checks whether a member is currently selected.
   *
   * @internal
   */
  isChecked(t) {
    return this.select.find((e) => e.id === t) != null;
  }
  /**
   * Toggles selection state for the provided member.
   *
   * @internal
   */
  handleSelected(t, e) {
    e ? this.select = [...this.select, t] : (this.select = this.select.filter((r) => r.id !== t.id), this.selected = this.selected.filter((r) => r.id !== t.id));
  }
  /**
   * Renders the list of currently selected members.
   *
   * @internal
   */
  getSelected() {
    return this.selected.length > 0 ? h`
        ${this.selected.map((t) => h`
            <wy-item
              interactive
              @click=${() => this.handleSelected(t, !1)}
              @keydown=${le}
              @keyup=${le}
            >
              <wy-avatar
                slot="image"
                id=${t.id}
                .src=${t.avatar_url}
                .name=${t.name}
                .description=${t.comment}
                .presence=${t.presence}
                .isAgent=${t.is_agent}
                size=${32}
              ></wy-avatar>
              <span slot="title"> ${t.name} </span>
              <wy-button slot="actions" kind="icon" .active=${!1}
                ><wy-icon name="checkbox-marked"></wy-icon
              ></wy-button>
            </wy-item>
          `)}
      ` : v;
  }
  /**
   * Renders search results for the current query and filter.
   *
   * @internal
   */
  getSearchResult() {
    const { data: t, hasNextPage: e, isPending: r } = this.peopleQuery.result ?? { data: [], isPending: !0 }, s = Zi(t), n = !!s.length, o = [];
    return r ? o.push(h`<wy-progress-circular indeterminate overlay></wy-progress-circular>`) : n || o.push(h`<div part="wy-pane-group">
        <div part="wy-no-result">
          ${this.text ? b("Your search did not match any people.") : b("No more users found.")}
        </div>
      </div>`), n && o.push(
      h` ${s.filter((c) => this.selected.find((l) => l.id === c.id) === void 0).map((c) => h` <wy-item
              interactive
              @click=${() => this.handleSelected(c, !this.isChecked(c.id))}
              @keydown=${le}
              @keyup=${le}
            >
              <wy-avatar
                slot="image"
                id=${c.id}
                .src=${c.avatar_url}
                .name=${c.name}
                .description=${c.comment}
                .presence=${c.presence}
                .isAgent=${c.is_agent}
                size=${32}
              ></wy-avatar>
              <span slot="title"> ${c.name} </span>
              <wy-button slot="actions" kind="icon" .active=${!1}
                ><wy-icon name="${this.isChecked(c.id) ? "checkbox-marked" : "checkbox-blank"}"></wy-icon
              ></wy-button>
            </wy-item>`) ?? v}`
    ), e && o.push(h`<div ${j(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>`), o;
  }
  render() {
    return h`<div part="wy-pane wy-scroll-y wy-scroll-y-always">
      <div part="wy-pane-body">
        <div part="wy-pane-group wy-pane-group-fixed-size">
          <wy-search ${j(this.searchRef)} @search=${(t) => this.text = t.detail.query}></wy-search>
        </div>
        <div>
          <wy-buttons tabs>
            <wy-button
              ?active=${this.agentFilter === void 0}
              @click=${() => this.agentFilter = void 0}
              kind="tab"
              small
              >${b("All")}</wy-button
            >
            <wy-button ?active=${this.agentFilter === !1} @click=${() => this.agentFilter = !1} kind="tab" small
              >${b("People")}</wy-button
            >
            <wy-button ?active=${this.agentFilter === !0} @click=${() => this.agentFilter = !0} kind="tab" small
              >${b("Agents")}</wy-button
            >
          </wy-buttons>
        </div>
        <div part="wy-pane-body"> ${this.getSelected()} ${this.getSearchResult()} </div>
      </div>
      <div part="wy-footerbar wy-footerbar-sticky">
        <div part="wy-pane-group">
          <wy-buttons reverse>
            <wy-button
              color="primary"
              @click=${() => this.dispatchSubmit()}
              ?disabled=${this.selected.length === 0 && this.select.length === 0 ? !0 : void 0}
              >${this.buttonTitle ?? b("Create")}</wy-button
            >
          </wy-buttons>
        </div>
      </div>
    </div>`;
  }
  async willUpdate(t) {
    super.willUpdate(t), t.has("weavy") && this.weavy && await this.peopleQuery.trackInfiniteQuery(
      yb(
        this.weavy,
        () => this.text,
        this.appId,
        () => this.agentFilter
      )
    );
  }
  async updated(t) {
    this.infiniteScroll.observe(this.peopleQuery.result, this.pagerRef.value), (t.has("text") || t.has("agentFilter")) && (this.select.length > 0 && (this.selected = [...this.selected, ...this.select], this.select = []), await this.peopleQuery.result?.refetch?.(), this.searchRef.value?.focusInput());
  }
}, a(ec, "WyUsersSearch"), ec);
di.styles = [Ns, Hm, jr, Br, Z, qs];
Qr([
  he({ context: re, subscribe: !0 }),
  F()
], di.prototype, "weavy", 2);
Qr([
  p({ attribute: !1 })
], di.prototype, "appId", 2);
Qr([
  p({ attribute: !1 })
], di.prototype, "buttonTitle", 2);
Qr([
  F()
], di.prototype, "agentFilter", 2);
Qr([
  F()
], di.prototype, "selected", 2);
Qr([
  F()
], di.prototype, "select", 2);
Qr([
  F()
], di.prototype, "text", 2);
di = Qr([
  H("wy-users-search"),
  ot()
], di);
var U$ = Object.defineProperty, B$ = Object.getOwnPropertyDescriptor, Nv = /* @__PURE__ */ a((i) => {
  throw TypeError(i);
}, "__typeError$2"), Gs = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? B$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && U$(t, e, s), s;
}, "__decorateClass$a"), jv = /* @__PURE__ */ a((i, t, e) => t.has(i) || Nv("Cannot " + e), "__accessCheck$2"), Rf = /* @__PURE__ */ a((i, t, e) => (jv(i, t, "read from private field"), e ? e.call(i) : t.get(i)), "__privateGet$2"), q$ = /* @__PURE__ */ a((i, t, e) => t.has(i) ? Nv("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(i) : t.set(i, e), "__privateAdd$2"), Ef = /* @__PURE__ */ a((i, t, e, r) => (jv(i, t, "write to private field"), t.set(i, e), e), "__privateSet$2"), ln, ic;
let zi = (ic = class extends $e {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.showDetails = !1, this.showAddMembers = !1, this.conversationTitle = "", this.conversationTitleInput = "", this.membersQuery = new Ie(this), this.handleRealtimeAppUpdated = (t) => {
      !this.conversationId || t.app.id !== this.conversationId || (this.conversationTitle = this.conversationTitleInput = t.app.name);
    }, this.handlePresenceChange = (t) => {
      if (!this.weavy)
        return;
      Array.isArray(t) || (t = [parseInt(t)]);
      const e = /* @__PURE__ */ a((r = []) => (r.forEach((s) => {
        s.presence = t.indexOf(s.id) != -1 ? "active" : "away";
      }), r), "updateMembersInApps");
      this.weavy.queryClient.setQueryData(["apps", this.conversationId], (r) => (r.members.data = e(r.members.data), r)), this.weavy.queryClient.setQueryData(["members", this.conversationId], (r) => e(r));
    }, q$(this, ln);
  }
  /** Checks whether the current or provided conversation is an agent chat. */
  isAgentChat(t) {
    return (t ?? this.conversation)?.type === tt.AgentChat;
  }
  /** Checks whether the current or provided conversation is a chat room. */
  isChatRoom(t) {
    return (t ?? this.conversation)?.type === tt.ChatRoom;
  }
  /** Checks whether the current or provided conversation is a private chat. */
  isPrivateChat(t) {
    return (t ?? this.conversation)?.type === tt.PrivateChat;
  }
  /**
   * Adds a list of members to the conversation.
   *
   * @internal
   */
  async addMembers(t) {
    this.showAddMembers = !1, this.showDetails = !0, !(!this.weavy || !this.conversationId) && (await this.addMembersMutation?.mutate({ appId: this.conversationId, members: t.map((e) => e.id) }), await this.membersQuery.result.refetch(), await this.weavy.queryClient.invalidateQueries({ queryKey: ["apps"] }));
  }
  /**
   * Handles saving the conversation name from the conversation name input.
   *
   * @internal
   */
  async handleSaveConversationName() {
    if (!this.weavy || !this.conversationId)
      return;
    const t = this.conversationTitleInput.trim() === "" ? null : this.conversationTitleInput.trim();
    await this.updateConversationMutation?.mutate({ appId: this.conversationId, name: t });
  }
  /**
   * Updates the avatar with an uploaded blob picture.
   *
   * @internal
   */
  async handleAvatarUploaded(t) {
    !this.weavy || !this.conversationId || await this.updateConversationMutation?.mutate({
      appId: this.conversationId,
      blobId: t.id,
      thumbnailUrl: t.thumbnail_url
    });
  }
  /**
   * Clears the set avatar for the conversation.
   *
   * @internal
   */
  async clearAvatar() {
    !this.weavy || !this.conversationId || await this.updateConversationMutation?.mutate({ appId: this.conversationId, blobId: null, thumbnailUrl: null });
  }
  /**
   * Updates the access for a member in the conversation.
   *
   * @internal
   */
  async updateMember(t, e) {
    !this.weavy || !this.conversationId || (await this.updateMemberMutation?.mutate({
      appId: this.conversationId,
      userId: t,
      access: e
    }), await this.membersQuery.result.refetch());
  }
  /**
   * Removes the current or provided member from the conversation.
   *
   * If no memberId is provided, the current user leaves the conversation and the component state is cleared.
   *
   * @internal
   */
  async leaveConversation(t) {
    !this.weavy || !this.conversationId || !this.user || (t && await this.leaveConversationMutation?.mutate({
      appId: this.conversationId,
      members: [t]
    }), !t || t === this.user.id ? (this.showDetails = !1, this.conversation = void 0, this.conversationId = void 0, this.dispatchAction(ge.Select, null)) : await this.membersQuery.result.refetch(), await this.weavy.queryClient.invalidateQueries({ queryKey: ["apps"] }));
  }
  /**
   * Triggers `wy-action` event.
   *
   * @param action - The performed action.
   * @param conversation - The conversation to select or `null` to clear.
   * @returns Whether the event was successful.
   *
   * @internal
   */
  dispatchAction(t, e) {
    this.conversationId = e?.id;
    const r = new CustomEvent("wy-action", { detail: { action: t, app: e }, bubbles: !0, composed: !0 });
    return this.dispatchEvent(r);
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("weavy") && this.weavy && (this.leaveConversationMutation = Om(this.weavy), this.addMembersMutation = pb(this.weavy), this.updateConversationMutation = Im(this.weavy), this.updateMemberMutation = hb(this.weavy)), t.has("conversationId") && (this.showDetails = !1), (t.has("weavy") || t.has("conversationId")) && this.weavy)
      if ((e = Rf(this, ln)) == null || e.call(this), this.conversationId) {
        await this.membersQuery.trackQuery(
          Fm(this.weavy, this.conversationId, {
            initialData: /* @__PURE__ */ a(() => {
              if (this.conversationId)
                return this.weavy?.queryClient.getQueryData(["apps", this.conversationId])?.members;
            }, "initialData")
          })
        );
        const r = `a${this.conversationId}`;
        this.weavy.subscribe(r, "app_updated", this.handleRealtimeAppUpdated), this.weavy.subscribe(null, "online", this.handlePresenceChange), Ef(this, ln, () => {
          this.weavy?.unsubscribe(r, "app_updated", this.handleRealtimeAppUpdated), this.weavy?.unsubscribe(null, "online", this.handlePresenceChange), Ef(this, ln, void 0);
        });
      } else
        this.membersQuery.untrackQuery();
    t.has("conversation") && this.conversation && (this.conversationTitleInput = this.conversationTitle = this.conversation.name);
  }
  render() {
    const { data: t } = this.membersQuery.result ?? {}, e = (t?.data || []).filter((s) => s.access === dr.Admin).length, r = this.user && this.isPrivateChat() ? (this.conversation?.members?.data || []).filter((s) => s.id !== this.user?.id)?.[0] ?? this.user : null;
    return this.conversationId ? h`
          <wy-titlebar outer header floating part="wy-conversation-titlebar">
            <slot slot="icon" name="icon"><span></span></slot>
            ${this.conversation && this.user ? h`
                  ${this.conversation.type === tt.PrivateChat ? h`<wy-presence
                        slot="title-section"
                        placement="text"
                        .status=${r?.presence}
                        id=${nt(r?.id)}
                      ></wy-presence>` : v}
                  <wy-titlebar-text slot="title-section">${this.conversationTitle}</wy-titlebar-text>
                ` : v}
            ${this.isChatRoom() ? h`<wy-button
                  slot="actions"
                  kind="icon"
                  @click=${() => this.showDetails = !0}
                  title="${b("Details")}"
                >
                  <wy-icon name="information"></wy-icon>
                </wy-button>` : v}
          </wy-titlebar>

          <!-- details modal -->
          ${this.weavy ? h`
                <wy-overlay
                  part="wy-conversation-details"
                  .show=${this.showDetails}
                  @close=${() => {
      this.showDetails = !1;
    }}
                >
                  <wy-titlebar header slot="header">
                    <wy-button
                      slot="icon"
                      kind="icon"
                      @click=${() => {
      this.showDetails = !1;
    }}
                    >
                      <wy-icon name="close"></wy-icon>
                    </wy-button>
                    <span slot="title">${this.conversationTitle}</span>
                  </wy-titlebar>
                  <div part="wy-scroll-y">
                    ${this.showDetails && this.conversation && this.user ? h`
                          <wy-avatar-header>
                            ${this.isChatRoom() ? h`
                                  <wy-upload
                                    @blob-uploaded=${(s) => this.handleAvatarUploaded(s.detail.blob)}
                                    .accept=${"image/*"}
                                    .label=${b("Select picture")}
                                  >
                                    <div slot="placeholder">
                                      ${this.conversation.avatar_url ? h`<wy-avatar .size=${96} src=${this.conversation.avatar_url}></wy-avatar>` : h`<wy-avatar-group
                                            .members=${t?.data}
                                            title=${this.conversation.name}
                                            .size=${96}
                                          ></wy-avatar-group>`}
                                    </div>
                                    ${this.conversation.avatar_url ? h`<div slot="action"
                                          ><wy-button @click=${() => this.clearAvatar()}
                                            >${b("Remove picture")}</wy-button
                                          ></div
                                        >` : v}
                                  </wy-upload>
                                ` : h`
                                  <wy-avatar
                                    src=${nt(r?.avatar_url)}
                                    name=${nt(r?.name)}
                                    presence=${r?.presence || "away"}
                                    ?isAgent=${r?.is_agent}
                                    id=${nt(r?.id)}
                                    size=${96}
                                  ></wy-avatar>
                                `}
                          </wy-avatar-header>
                          ${this.isChatRoom() ? h`
                                <div part="wy-pane-group">
                                  <label part="wy-label" for="roomName">${b("Room name")}</label>

                                  <input
                                    id="roomName"
                                    part="wy-input"
                                    .value=${this.conversationTitleInput}
                                    @input=${(s) => {
      this.conversationTitleInput = s.target.value;
    }}
                                    @keyup=${fb}
                                    @blur=${() => this.handleSaveConversationName()}
                                  />

                                  <div part="wy-description">
                                    ${b("Changing the name of a group chat changes it for everyone.")}
                                  </div>
                                  <br />
                                  <label part="wy-label">${b("Members")}</label>
                                  ${t ? h`
                                        <wy-item-list>
                                          ${t.data?.map(
      (s) => h`
                                              <wy-item>
                                                <wy-avatar
                                                  slot="image"
                                                  .src=${s.avatar_url}
                                                  .name=${s.name}
                                                  .description=${s.comment}
                                                  .isAgent=${s.is_agent}
                                                  size=${32}
                                                ></wy-avatar>
                                                <span slot="title">
                                                  ${s.name}
                                                  ${s.access === dr.Admin ? h` <wy-icon
                                                        size="20"
                                                        inline
                                                        name="shield-star"
                                                        title=${b("Admin")}
                                                      ></wy-icon>` : v}
                                                </span>
                                                ${this.user && this.user.id === s.id && !gc(ms.Admin, this.conversation?.permissions) ? h` <wy-button
                                                      slot="actions"
                                                      @click=${() => this.leaveConversation(s.id)}
                                                      title=${b("Leave conversation")}
                                                      kind="icon"
                                                    >
                                                      <wy-icon name="close"></wy-icon>
                                                    </wy-button>` : gc(ms.Admin, this.conversation?.permissions) ? h`<wy-dropdown slot="actions">
                                                      <wy-dropdown-item
                                                        @click=${() => this.leaveConversation(s.id)}
                                                      >
                                                        <wy-icon name="account-minus"></wy-icon>
                                                        ${this.user && this.user.id === s.id ? b("Leave conversation") : b("Remove member")}
                                                      </wy-dropdown-item>
                                                      ${e > 1 && s.access === dr.Admin ? h`<wy-dropdown-item
                                                            @click=${() => this.updateMember(s.id, dr.Write)}
                                                          >
                                                            <wy-icon name="shield-star-outline"></wy-icon>
                                                            ${b("Remove as admin")}
                                                          </wy-dropdown-item>` : s.access !== dr.Admin ? h`<wy-dropdown-item
                                                            @click=${() => this.updateMember(s.id, dr.Admin)}
                                                          >
                                                            <wy-icon name="shield-star"></wy-icon>
                                                            ${b("Make admin")}
                                                          </wy-dropdown-item>` : v}
                                                    </wy-dropdown>` : v}
                                              </wy-item>
                                            `
    ) ?? v}
                                        </wy-item-list>
                                      ` : v}
                                  <div>
                                    <wy-button
                                      part="wy-conversation-details-add-members-button"
                                      kind="filled"
                                      color="primary"
                                      @click=${() => {
      this.showDetails = !1, this.showAddMembers = !0;
    }}
                                      title=${b("Add members")}
                                    >
                                      ${b("Add members")}
                                    </wy-button>
                                  </div>
                                </div>
                              ` : v}
                        ` : v}
                  </div>
                </wy-overlay>
              ` : v}

          <!-- add members modal -->
          ${this.weavy ? h`
                <wy-overlay
                  part="wy-conversation-add-members"
                  .show=${this.showAddMembers}
                  @close=${() => {
      this.showAddMembers = !1;
    }}
                >
                  <wy-titlebar header>
                    <wy-button
                      slot="icon"
                      kind="icon"
                      @click=${() => {
      this.showAddMembers = !1;
    }}
                    >
                      <wy-icon name="close"></wy-icon>
                    </wy-button>
                    <span slot="title">${b("Add members")}</span>
                  </wy-titlebar>
                  ${this.showAddMembers ? h`
                        <wy-users-search
                          .buttonTitle=${b("Add members")}
                          .appId=${this.conversationId}
                          @submit=${(s) => this.addMembers(s.detail.members)}
                        ></wy-users-search>
                      ` : v}
                </wy-overlay>
              ` : v}
        ` : v;
  }
  disconnectedCallback() {
    var t;
    (t = Rf(this, ln)) == null || t.call(this), super.disconnectedCallback();
  }
}, a(ic, "WyConversationHeader"), ic);
ln = /* @__PURE__ */ new WeakMap();
zi.styles = [jr, qs, Ns, Z];
Gs([
  p({ attribute: !1 })
], zi.prototype, "conversationId", 2);
Gs([
  p({ attribute: !1 })
], zi.prototype, "conversation", 2);
Gs([
  F()
], zi.prototype, "showDetails", 2);
Gs([
  F()
], zi.prototype, "showAddMembers", 2);
Gs([
  F()
], zi.prototype, "conversationTitle", 2);
Gs([
  F()
], zi.prototype, "conversationTitleInput", 2);
zi = Gs([
  H("wy-conversation-header"),
  ot()
], zi);
var N$ = Object.defineProperty, j$ = Object.getOwnPropertyDescriptor, Yc = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? j$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && N$(t, e, s), s;
}, "__decorateClass$9"), rc;
let nr = (rc = class extends Dt {
  constructor() {
    super(...arguments), this.componentFeatures = new ee(Oc), this.theme = new Te(this, nr.styles), this.unreadConversationsController = new mc(this), this.createConversationController = new fc(this), this.componentTypes = [tt.ChatRoom, tt.PrivateChat], this.conversationId = null, this.conversationQuery = new Ie(this), this.persistState = new vs(this), this.conversationListRef = et(), this.conversationNewRef = et();
  }
  set agent(t) {
    super.agent = t, this._agentUid ? (this.componentTypes = [tt.AgentChat], this.componentFeatures = new ee(
      Sy,
      this.componentFeatures.allowedFeatures()
    )) : (this.componentTypes = [tt.ChatRoom, tt.PrivateChat], this.componentFeatures = new ee(
      Oc,
      this.componentFeatures.allowedFeatures()
    )), this.conversationId = null;
  }
  get agent() {
    return super.agent;
  }
  /** Current unread conversation count. */
  get unread() {
    return this.unreadConversationsController.unread;
  }
  /**
   * Creates a new conversation.
   *
   * When in agent mode, a conversation is created instantly.
   *
   * @param members - Optional array of member ids or member uids.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select member dialog to let the user select members for creating a conversation.
   *
   * @returns Promise resolving to any selected member ids or uids.
   */
  async selectMembers() {
    return await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("weavy") || t.has("agent") || t.has("user")) && this.weavy && this.user && this.persistState.observe(
      [{ name: "conversationId", override: !1 }],
      this.agent || "messenger",
      `u${this.user?.id}`,
      (e) => {
        if (e.has("conversationId") && this.conversationId) {
          const r = new CustomEvent("wy-action", {
            detail: {
              action: ge.Select,
              app: { id: this.conversationId }
            },
            bubbles: !0,
            composed: !0
          });
          this.dispatchEvent(r);
        }
      }
    ), t.has("link") && this.link?.app && (this.conversationId = this.link.app.id), (t.has("conversationId") || t.has("weavy")) && this.weavy && (this.conversationId ? this.conversationQuery.trackQuery(
      Tm(this.weavy, this.conversationId, this.componentTypes)
    ) : this.conversationQuery.untrackQuery()), t.has("agent") && (this.createConversationController.agent = this.agent), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversationsController.track(this.componentTypes, this.agent);
  }
  render() {
    const { isPending: t } = this.weavy?.network ?? { isPending: !0 }, { data: e } = this.conversationQuery.result ?? {}, r = this.conversationListRef.value?.conversationsQuery.result.data?.pages[0].count || 0;
    return h`
      <div part="wy-messenger-layout">
        <div
          part="wy-messenger-conversation-list"
          data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
        >
          <wy-container padded outer scrollY>
            <slot name="header"></slot>
            <wy-conversation-list
              ${j(this.conversationListRef)}
              .conversationTypes=${this.componentTypes}
              .agent=${this.agent}
              conversationId=${nt(this.conversationId !== null ? this.conversationId : void 0)}
              @wy-action=${(s) => {
      !s.defaultPrevented && s.detail.action === ge.Select && s.detail.app !== void 0 && (this.conversationId = s.detail.app?.id);
    }}
            >
              <wy-conversation-new
                slot="actions"
                .agent=${this.agent}
                @create=${async (s) => {
      const n = await this.createConversationController.create(s.detail.members);
      n && (this.conversationId = n.id);
    }}
                ${j(this.conversationNewRef)}
              >
                <slot name="conversation-new"></slot>
              </wy-conversation-new>
              <slot name="actions" slot="actions"></slot>
            </wy-conversation-list>
          </wy-container>
        </div>

        <div
          part="wy-messenger-conversation wy-scroll-y"
          data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
        >
          <wy-conversation-header
            .conversationId=${this.conversationId || void 0}
            .conversation=${e}
            @wy-action=${(s) => {
      !s.defaultPrevented && s.detail.action === ge.Select && s.detail.app !== void 0 && (this.conversationId = s.detail.app?.id);
    }}
            ?hidden=${!this.conversationId}
          >
            <span slot="icon" part="wy-close-conversation">
              <wy-button kind="icon" @click=${() => this.conversationId = null}>
                <wy-icon name="back"></wy-icon>
              </wy-button>
              <wy-badge
                reveal
                .count=${this.unreadConversationsController.isUnreadPending ? NaN : this.unreadConversationsController.unread}
              ></wy-badge>
            </span>
          </wy-conversation-header>

          ${this.conversationId ? h`<wy-conversation
                .conversationId=${this.conversationId}
                .conversation=${e}
                .agentInstructions=${this.instructions}
                .placeholder=${this.placeholder ?? (this.agent ? b("Ask anything...") : void 0)}
                .header=${!this.agent}
              ></wy-conversation>` : r ? h`<wy-empty noNetwork>${b("Select a conversation")}</wy-empty>` : v}
        </div>

        <wy-context-data-progress></wy-context-data-progress>
      </div>
    `;
  }
}, a(rc, "WyMessenger"), rc);
nr.styles = [Yt, Ns, Ay, Ri, Se];
Yc([
  p({ attribute: !1 })
], nr.prototype, "componentTypes", 2);
Yc([
  p({ type: String })
], nr.prototype, "agent", 1);
Yc([
  p()
], nr.prototype, "instructions", 2);
Yc([
  p()
], nr.prototype, "placeholder", 2);
Yc([
  p({ type: Number })
], nr.prototype, "conversationId", 2);
nr = Yc([
  H("wy-messenger"),
  ot()
], nr);
var W$ = Object.defineProperty, Q$ = Object.getOwnPropertyDescriptor, pi = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? Q$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && W$(t, e, s), s;
}, "__decorateClass$8"), sc;
let He = (sc = class extends Dt {
  constructor() {
    super(...arguments), this.componentFeatures = new ee(Oc), this.theme = new Te(this, He.styles), this.unreadConversationsController = new mc(this), this.createConversationController = new fc(this), this.overlay = "drawer", this.badge = "compact", this.badgePosition = "top-right", this.componentTypes = [tt.ChatRoom, tt.PrivateChat], this.conversationId = null, this.show = !1, this.maximized = !1, this.conversationQuery = new Ie(this), this.persistState = new vs(this), this.conversationListRef = et(), this.conversationNewRef = et();
  }
  set agent(t) {
    super.agent = t, this._agentUid ? (this.componentTypes = [tt.AgentChat], this.componentFeatures = new ee(
      Sy,
      this.componentFeatures.allowedFeatures()
    )) : (this.componentTypes = [tt.ChatRoom, tt.PrivateChat], this.componentFeatures = new ee(
      Oc,
      this.componentFeatures.allowedFeatures()
    )), this.conversationId = null;
  }
  get agent() {
    return super.agent;
  }
  /** Current unread conversation count. */
  get unread() {
    return this.unreadConversationsController.unread;
  }
  /**
   * Creates a new conversation.
   *
   * - When in agent mode, a conversation is created instantly.
   *
   * @param members {(number|string)[] | undefined} - Optional array of member id or member uid.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select member dialog to let the user select members for creating a conversation.
   *
   * @returns Any selected member ids or uids.
   */
  async selectMembers() {
    return await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("weavy") || t.has("agent") || t.has("user")) && this.weavy && this.user && this.persistState.observe(
      [{ name: "conversationId", override: !1 }],
      this.agent || "messenger",
      `u${this.user?.id}`,
      (e) => {
        if (e.has("conversationId") && this.conversationId) {
          const r = new CustomEvent("wy-action", {
            detail: {
              action: ge.Select,
              app: { id: this.conversationId }
            },
            bubbles: !0,
            composed: !0
          });
          this.dispatchEvent(r);
        }
      }
    ), t.has("link") && this.link?.app && (this.conversationId = this.link.app.id), (t.has("conversationId") || t.has("weavy")) && this.weavy && (this.conversationId ? this.conversationQuery.trackQuery(Tm(this.weavy, this.conversationId, this.componentTypes)) : this.conversationQuery.untrackQuery()), t.has("agent") && (this.createConversationController.agent = this.agent), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversationsController.track(this.componentTypes, this.agent);
  }
  render() {
    const { isPending: t } = this.weavy?.network ?? { isPending: !0 }, { data: e } = this.conversationQuery.result ?? {}, r = this.conversationListRef.value?.conversationsQuery.result.data?.pages[0].count || 0;
    return h`
      <wy-button kind="icon" ?active=${this.show} @click=${() => this.show = !this.show}>
        <wy-icon name="message-text">
          ${this.user && this.badge !== "none" ? h`
                <wy-badge
                  appearance=${this.badge}
                  position=${this.badgePosition}
                  .count=${this.unreadConversationsController.isUnreadPending ? NaN : this.unreadConversationsController.unread}
                ></wy-badge>
              ` : v}
        </wy-icon>
      </wy-button>

      ${this.overlay !== "none" ? h`<wy-overlay
            type=${this.overlay}
            .show=${this.show}
            .maximized=${this.maximized}
            @close=${() => this.show = !1}
            noHeader
          >
            <div part="wy-messenger-layout wy-messenger-overlay-container">
              <div
                part="wy-messenger-conversation-list wy-scroll-y"
                data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
              >
                <slot name="header">
                  <wy-titlebar floating header outer>
                    <wy-button kind="icon" slot="icon" @click=${() => this.show = !1}
                      ><wy-icon name="close"></wy-icon
                    ></wy-button>
                    <slot name="title" slot="title">${b("Conversations")}</slot>
                    <slot name="actions" slot="actions"></slot>
                    <wy-button kind="icon" slot="actions" @click=${() => this.maximized = !this.maximized}
                      ><wy-icon name=${this.maximized ? "arrow-collapse" : "arrow-expand"}></wy-icon
                    ></wy-button>
                  </wy-titlebar>
                </slot>

                <wy-conversation-list
                  ${j(this.conversationListRef)}
                  .conversationTypes=${this.componentTypes}
                  .agent=${this.agent}
                  conversationId=${nt(this.conversationId !== null ? this.conversationId : void 0)}
                  @wy-action=${(s) => {
      !s.defaultPrevented && s.detail.action === ge.Select && s.detail.app !== void 0 && (this.conversationId = s.detail.app?.id);
    }}
                >
                  <wy-conversation-new
                    slot="actions"
                    .agent=${this.agent}
                    @create=${async (s) => {
      const n = await this.createConversationController.create(s.detail.members);
      n && (this.conversationId = n.id);
    }}
                    ${j(this.conversationNewRef)}
                  >
                    <slot name="conversation-new"></slot>
                  </wy-conversation-new>
                </wy-conversation-list>
              </div>

              <div
                part="wy-messenger-conversation wy-scroll-y"
                data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
              >
                <wy-conversation-header
                  .conversationId=${this.conversationId || void 0}
                  .conversation=${e}
                  @wy-action=${(s) => {
      !s.defaultPrevented && s.detail.action === ge.Select && s.detail.app !== void 0 && (this.conversationId = s.detail.app?.id);
    }}
                  ?hidden=${!this.conversationId}
                >
                  <span slot="icon" part="wy-close-conversation">
                    <wy-button kind="icon" @click=${() => this.conversationId = null}>
                      <wy-icon name="back"></wy-icon>
                    </wy-button>
                    <wy-badge
                      reveal
                      .count=${this.unreadConversationsController.isUnreadPending ? NaN : this.unreadConversationsController.unread}
                    ></wy-badge>
                  </span>
                </wy-conversation-header>

                ${this.conversationId ? h`<wy-conversation
                      .conversationId=${this.conversationId}
                      .conversation=${e}
                      .agentInstructions=${this.instructions}
                      .placeholder=${this.placeholder ?? (this.agent ? b("Ask anything...") : void 0)}
                      .header=${!this.agent}
                    ></wy-conversation>` : r ? h`<wy-empty noNetwork>${b("Select a conversation")}</wy-empty>` : v}
              </div>

              <wy-context-data-progress></wy-context-data-progress>
            </div>
          </wy-overlay> ` : v}
    `;
  }
}, a(sc, "WyMessengerButton"), sc);
He.styles = [Yt, Ns, Ay, Ri, Se];
pi([
  p({ type: String })
], He.prototype, "overlay", 2);
pi([
  p({ type: String })
], He.prototype, "badge", 2);
pi([
  p({ type: String })
], He.prototype, "badgePosition", 2);
pi([
  p({ attribute: !1 })
], He.prototype, "componentTypes", 2);
pi([
  p({ type: String })
], He.prototype, "agent", 1);
pi([
  p()
], He.prototype, "instructions", 2);
pi([
  p()
], He.prototype, "placeholder", 2);
pi([
  p({ type: Number })
], He.prototype, "conversationId", 2);
pi([
  F()
], He.prototype, "show", 2);
pi([
  F()
], He.prototype, "maximized", 2);
He = pi([
  H("wy-messenger-button"),
  ot()
], He);
var K$ = Object.getOwnPropertyDescriptor, G$ = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? K$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = o(s) || s);
  return s;
}, "__decorateClass$7"), nc;
let nh = (nc = class extends Dt {
  constructor() {
    super(...arguments), this.theme = new Te(this, nh.styles), this.createConversationController = new fc(this), this.conversationNewRef = et();
  }
  /**
   * Creates a new conversation.
   *
   * When in agent mode, the conversation is created instantly.
   *
   * @param members - Optional array of member ids or member uids.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select-member dialog.
   *
   * @returns Promise resolving to the selected member ids or uids.
   */
  async selectMembers() {
    return await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), t.has("agent") && (this.createConversationController.agent = this.agent);
  }
  render() {
    return h`
      <wy-conversation-new
        .agent=${this.agent}
        @create=${async (t) => {
      await this.createConversationController.create(t.detail.members);
    }}
        ${j(this.conversationNewRef)}
      ></wy-conversation-new>
    `;
  }
}, a(nc, "WyMessengerNew"), nc);
nh.styles = [Yt, Ns, Ay, Ri, Se];
nh = G$([
  H("wy-messenger-new")
], nh);
var Z$ = Object.defineProperty, Y$ = Object.getOwnPropertyDescriptor, vd = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? Y$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && Z$(t, e, s), s;
}, "__decorateClass$6"), ac;
let Ts = (ac = class extends Dt {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.unreadConversations = new mc(this), this.componentTypes = [tt.ChatRoom, tt.PrivateChat], this.badge = "count", this.badgePosition = "inline";
  }
  set agent(t) {
    super.agent = t, this._agentUid ? this.componentTypes = [tt.AgentChat] : this.componentTypes = [tt.ChatRoom, tt.PrivateChat];
  }
  get agent() {
    return super.agent;
  }
  /**
   * Current unread conversation count.
   */
  get unread() {
    return this.unreadConversations.unread;
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversations.track(this.componentTypes, this.agent);
  }
  render() {
    return this.user && this.badge !== "none" ? h`
          <wy-badge
            appearance=${this.badge}
            position=${this.badgePosition}
            .count=${this.unreadConversations.isUnreadPending ? NaN : this.unreadConversations.unread}
          ></wy-badge>
        ` : v;
  }
}, a(ac, "WyMessengerBadge"), ac);
Ts.styles = [Uv, Yt, Se];
vd([
  p({ attribute: !1 })
], Ts.prototype, "componentTypes", 2);
vd([
  p({ type: String })
], Ts.prototype, "badge", 2);
vd([
  p({ type: String })
], Ts.prototype, "badgePosition", 2);
vd([
  p({ type: String })
], Ts.prototype, "agent", 1);
Ts = vd([
  H("wy-messenger-badge")
], Ts);
const Wv = B`[part~=wy-conversations]{position:relative;display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-conversation-list]{display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}`;
var X$ = Object.defineProperty, J$ = Object.getOwnPropertyDescriptor, Hh = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? J$(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && X$(t, e, s), s;
}, "__decorateClass$5"), oc;
let Tc = (oc = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.typing = new Qd(this);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("appId") && (this.typing.appId = this.appId), t.has("userId") && (this.typing.userId = this.userId);
  }
  render() {
    const { names: t, ellipsis: e } = this.typing;
    let r;
    if (t.length === 1) {
      const s = t[0];
      r = b(ut`${s} is typing${e}`, { desc: "A is typing..." });
    } else if (t.length > 1) {
      const s = new Intl.ListFormat(this.weavy?.locale, { style: "long", type: "conjunction" }).format(
        t
      );
      r = b(ut`${s} are typing${e}`, {
        desc: "A, B and C are typing..."
      });
    }
    return r ? h`<span>${r}</span>` : h`<slot></slot>`;
  }
}, a(oc, "WyTyping"), oc);
Hh([
  he({ context: re, subscribe: !0 }),
  F()
], Tc.prototype, "weavy", 2);
Hh([
  p({ attribute: !0, type: Number })
], Tc.prototype, "appId", 2);
Hh([
  p({ attribute: !0, type: Number })
], Tc.prototype, "userId", 2);
Tc = Hh([
  H("wy-typing"),
  ot()
], Tc);
var t9 = Object.defineProperty, e9 = Object.getOwnPropertyDescriptor, Qv = /* @__PURE__ */ a((i) => {
  throw TypeError(i);
}, "__typeError$1"), Be = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? e9(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && t9(t, e, s), s;
}, "__decorateClass$4"), Kv = /* @__PURE__ */ a((i, t, e) => t.has(i) || Qv("Cannot " + e), "__accessCheck$1"), Lf = /* @__PURE__ */ a((i, t, e) => (Kv(i, t, "read from private field"), e ? e.call(i) : t.get(i)), "__privateGet$1"), i9 = /* @__PURE__ */ a((i, t, e) => t.has(i) ? Qv("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(i) : t.set(i, e), "__privateAdd$1"), Of = /* @__PURE__ */ a((i, t, e, r) => (Kv(i, t, "write to private field"), t.set(i, e), e), "__privateSet$1"), dn, cc;
let fe = (cc = class extends X {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.unread = !1, this.avatarUrl = "", this.hideAvatar = !1, this.name = "", this.type = tt.PrivateChat, this.selected = !1, this.starred = !1, this.pinned = !1, this.handleMessageCreated = (t) => {
      !this.user || !this.weavy || (qt(this.weavy.queryClient, ["apps", t.message.app.id], void 0, (e) => {
        e.last_message = t.message, e.is_unread = t.message.created_by.id !== this.user?.id;
      }), ct(
        this.weavy.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.message.app.id,
        (e) => {
          e.last_message = t.message, e.is_unread = t.message.created_by.id !== this.user?.id;
        }
      ));
    }, this.handleConversationUpdated = () => {
      this.weavy?.queryClient.invalidateQueries({ queryKey: ["apps"], exact: !1 });
    }, this.handleConversationMarked = (t) => {
      this.user && t.actor.id === this.user.id && this.weavy?.queryClient.invalidateQueries({ queryKey: ["apps"], exact: !1 });
    }, i9(this, dn);
  }
  /**
   * Trigger `selected` event.
   *
   * @returns Whether the event was dispatched successfully.
   */
  dispatchSelected() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("selected", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Trigger `star` event.
   *
   * @param star - Whether the conversation should be starred.
   * @returns Whether the event was dispatched successfully.
   */
  dispatchStar(t) {
    if (!this.conversationId)
      return;
    const e = new CustomEvent("star", {
      detail: { id: this.conversationId, star: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Trigger `pin` event.
   *
   * @param pin - Whether the conversation should be pinned.
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchPin(t) {
    if (!this.conversationId)
      return;
    const e = new CustomEvent("pin", {
      detail: { id: this.conversationId, pin: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Trigger `mark` event for marking the conversation as read/unread.
   *
   * @param mark - Whether the conversation should be marked as read.
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchMarked(t) {
    if (!this.conversationId)
      return;
    const e = new CustomEvent("mark", {
      detail: { id: this.conversationId, messageId: t ? this.lastMessage?.id : null }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Triggers `leave` event when the current user is leaving the conversation.
   *
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchLeaveConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("leave", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Triggers `remove` when the conversation should be removed.
   *
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchRemoveConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("remove", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Triggers `trash` event when the conversation should be trashed.
   *
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchTrashConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("trash", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  willUpdate(t) {
    var e;
    if (super.willUpdate(t), (t.has("weavy") || t.has("conversationId")) && this.weavy && this.conversationId) {
      (e = Lf(this, dn)) == null || e.call(this);
      const r = `a${this.conversationId}`;
      this.weavy.subscribe(r, "app_updated", this.handleConversationUpdated), this.weavy.subscribe(r, "member_added", this.handleConversationUpdated), this.weavy.subscribe(r, "message_created", this.handleMessageCreated), this.weavy.subscribe(r, "app_marked", this.handleConversationMarked), Of(this, dn, () => {
        this.weavy?.unsubscribe(r, "app_updated", this.handleConversationUpdated), this.weavy?.unsubscribe(r, "member_added", this.handleConversationUpdated), this.weavy?.unsubscribe(r, "message_created", this.handleMessageCreated), this.weavy?.unsubscribe(r, "app_marked", this.handleConversationMarked), Of(this, dn, void 0);
      });
    }
  }
  render() {
    const t = this.lastMessage?.created_at ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.lastMessage.created_at)
    ) : "", e = this.lastMessage?.created_at ? Wc(this.weavy?.locale, new Date(this.lastMessage.created_at)) : "", r = this.type === tt.PrivateChat && this.user ? (this.members?.data || []).filter((s) => s.id !== this.user?.id)?.[0] ?? this.user : null;
    return h`
      <wy-item
        part="wy-conversation-item"
        size="lg"
        interactive
        outer
        status=${this.unread ? "unread" : void 0}
        ?selected=${this.selected}
        tabindex="0"
        actionsPosition="bottom"
        @click=${(s) => (s.preventDefault(), this.dispatchSelected())}
        @keydown=${le}
        @keyup=${Me}
      >
        ${this.type !== tt.AgentChat ? this.avatarUrl ? h`<wy-avatar slot="image" .size=${48} src=${this.avatarUrl}></wy-avatar>` : this.type == tt.ChatRoom ? h` <wy-avatar-group
                slot="image"
                .members=${this.members?.data}
                title=${this.name}
                .size=${48}
              ></wy-avatar-group>` : h`
                <wy-avatar
                  slot="image"
                  src=${nt(r?.avatar_url)}
                  name=${nt(r?.name)}
                  description=${nt(r?.comment)}
                  presence=${r?.presence || "away"}
                  ?isAgent=${r?.is_agent}
                  id=${nt(r?.id)}
                  size=${48}
                ></wy-avatar>
              ` : v}

        <span slot="title">${this.name || this.lastMessage?.plain || b("Untitled conversation")}</span>
        ${this.lastMessage ? h`
              <time slot="meta" datetime=${this.lastMessage.created_at.toString()} title=${t}
                >${e}</time
              >
            ` : v}
        <span slot="text">
          ${this.user ? h`
                <wy-typing appId=${this.conversationId} userId=${this.user.id}>
                  ${this.lastMessage ? h`
                        ${this.user.id === this.lastMessage.created_by.id ? h`${b("You")}: ` : v}
                        ${this.members.count > 2 && this.user.id !== this.lastMessage?.created_by.id ? h`${this.lastMessage?.created_by.name}: ` : v}
                      ` : v}
                  ${this.lastMessage?.text ? h`<span>${this.lastMessage.plain}</span>` : v}
                  ${!this.lastMessage?.text && (this.lastMessage?.attachments?.count || 0) > 0 ? h`<wy-icon kind="text-icon" name="attachment"></wy-icon>` : v}
                  ${!this.lastMessage?.text && this.lastMessage?.meeting?.id ? h`<wy-icon kind="text-icon" name="video"></wy-icon>` : v}
                  ${!this.lastMessage?.text && (this.lastMessage?.options?.count || 0) > 0 ? h`<wy-icon kind="text-icon" name="poll"></wy-icon>` : v}
                  ${this.lastMessage ? v : h`&nbsp;`}
                </wy-typing>
              ` : v}
        </span>

        ${this.starred ? h`<wy-button
              small
              slot="actions"
              kind="icon"
              @click=${(s) => {
      s.stopPropagation(), this.dispatchStar(!1);
    }}
            >
              <wy-icon name="star" size=${24} color="yellow"></wy-icon>
            </wy-button>` : v}
        ${this.pinned ? h`<wy-button
              small
              slot="actions"
              kind="icon"
              @click=${(s) => {
      s.stopPropagation(), this.dispatchPin(!1);
    }}
            >
              <wy-icon name="pin" size=${20} color=""></wy-icon>
            </wy-button>` : v}
 
        <wy-dropdown small slot="actions" directionX="left">
          <wy-dropdown-item @click=${() => this.dispatchMarked(this.unread)}>
            <wy-icon name=${this.unread ? "read" : "unread"}></wy-icon>
            ${this.unread ? b("Mark as read") : b("Mark as unread")}
          </wy-dropdown-item>
          <wy-dropdown-item @click=${() => this.dispatchPin(!this.pinned)}>
            <wy-icon name=${this.pinned ? "unpin" : "pin"}></wy-icon>
            ${this.pinned ? b("Unpin") : b("Pin")}
          </wy-dropdown-item>
          <wy-dropdown-item @click=${() => this.dispatchStar(!this.starred)}>
            <wy-icon name=${this.starred ? "unstar" : "star"}></wy-icon>
            ${this.starred ? b("Unstar") : b("Star")}
          </wy-dropdown-item>
          ${this.type === tt.PrivateChat ? h`<wy-dropdown-item @click=${() => this.dispatchRemoveConversation()}>
                <wy-icon name="trashcan"></wy-icon>
                ${b("Delete")}
              </wy-dropdown-item>` : v}
          ${this.type === tt.ChatRoom ? h`<wy-dropdown-item @click=${() => this.dispatchLeaveConversation()}>
                <wy-icon name="account-minus"></wy-icon>
                ${b("Leave")}
              </wy-dropdown-item>` : v}
          ${this.type === tt.AgentChat ? h`
                <wy-dropdown-item @click=${() => this.dispatchTrashConversation()}>
                  <wy-icon name="trashcan"></wy-icon>
                  ${b("Delete")}
                </wy-dropdown-item>
              ` : v}
        </wy-dropdown>
      </wy-item>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.weavy && this.requestUpdate("weavy");
  }
  disconnectedCallback() {
    var t;
    (t = Lf(this, dn)) == null || t.call(this), super.disconnectedCallback();
  }
}, a(cc, "WyConversationItem"), cc);
dn = /* @__PURE__ */ new WeakMap();
fe.styles = [Wv];
Be([
  he({ context: re, subscribe: !0 }),
  F()
], fe.prototype, "weavy", 2);
Be([
  he({ context: uh, subscribe: !0 }),
  F()
], fe.prototype, "user", 2);
Be([
  p({ attribute: !0, type: Number })
], fe.prototype, "conversationId", 2);
Be([
  p({ attribute: !0, type: Boolean, reflect: !0 })
], fe.prototype, "unread", 2);
Be([
  p({ attribute: !0 })
], fe.prototype, "avatarUrl", 2);
Be([
  p({ attribute: !0, type: Boolean, reflect: !0 })
], fe.prototype, "hideAvatar", 2);
Be([
  p({ attribute: !0 })
], fe.prototype, "name", 2);
Be([
  p({ attribute: !0, type: String })
], fe.prototype, "type", 2);
Be([
  p({ attribute: !0, type: Boolean, reflect: !0 })
], fe.prototype, "selected", 2);
Be([
  p({ attribute: !0, type: Boolean, reflect: !0 })
], fe.prototype, "starred", 2);
Be([
  p({ attribute: !0, type: Boolean, reflect: !0 })
], fe.prototype, "pinned", 2);
Be([
  p({ attribute: !1 })
], fe.prototype, "members", 2);
Be([
  p({ attribute: !1 })
], fe.prototype, "lastMessage", 2);
fe = Be([
  H("wy-conversation-item"),
  ot()
], fe);
var r9 = Object.defineProperty, s9 = Object.getOwnPropertyDescriptor, Gv = /* @__PURE__ */ a((i) => {
  throw TypeError(i);
}, "__typeError"), gd = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? s9(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && r9(t, e, s), s;
}, "__decorateClass$3"), Zv = /* @__PURE__ */ a((i, t, e) => t.has(i) || Gv("Cannot " + e), "__accessCheck"), If = /* @__PURE__ */ a((i, t, e) => (Zv(i, t, "read from private field"), e ? e.call(i) : t.get(i)), "__privateGet"), n9 = /* @__PURE__ */ a((i, t, e) => t.has(i) ? Gv("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(i) : t.set(i, e), "__privateAdd"), Tf = /* @__PURE__ */ a((i, t, e, r) => (Zv(i, t, "write to private field"), t.set(i, e), e), "__privateSet"), hn, lc;
let Hr = (lc = class extends $e {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this.conversationTypes = [tt.ChatRoom, tt.PrivateChat], this.searchText = "", this.conversationsQuery = new Ki(this), this.infiniteScroll = new Gi(this), this.pagerRef = et(), this.handleRefresh = () => {
      this.conversationsQuery.result.refetch();
    }, this.handlePresenceChange = (t) => {
      if (!this.weavy)
        return;
      Array.isArray(t) || (t = [parseInt(t)]);
      const e = /* @__PURE__ */ a((r) => {
        const s = r.members.data ?? [];
        s.forEach((n) => {
          n.presence = t.indexOf(n.id) != -1 ? "active" : "away";
        }), r.members.data = s;
      }, "updateMembersInApps");
      ct(
        this.weavy.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        void 0,
        e
      );
    }, n9(this, hn);
  }
  /**
   * Selects a conversation and triggers an action event.
   *
   * @param conversation - The conversation to select.
   */
  selectConversation(t) {
    this.conversationId = t?.id, this.dispatchAction(ge.Select, t);
  }
  /**
   * Triggers `wy-action` event.
   * @param action - The performed action.
   * @param app - The conversation to select.
   * @returns Whether the event was successful.
   */
  dispatchAction(t, e) {
    const r = new CustomEvent("wy-action", {
      detail: { action: t, app: e },
      bubbles: !0,
      composed: !0
    });
    return this.dispatchEvent(r);
  }
  /**
   * Marks a conversation as read.
   *
   * @param appId - The id of the conversation to mark.
   * @param messageId - Optional message id to set the marker to.
   */
  async handleMark(t, e) {
    await this.markConversationMutation?.mutate({ app: t, messageId: e, userId: this.user?.id });
  }
  /**
   * Sets a conversation as starred.
   *
   * @param appId -  The id of the conversation to star.
   * @param star - Whether to make the conversation starred.
   */
  async handleStar(t, e) {
    await this.starConversationMutation?.mutate({ appId: t, star: e });
  }
  /**
   * Sets a conversation as pinned.
   *
   * @param appId - The id of the conversation to pin.
   * @param pin - Whether to make the conversation pinned.
   */
  async handlePin(t, e) {
    await this.pinConversationMutation?.mutate({ appId: t, pin: e });
  }
  /**
   * Leave a conversation (for the current user).
   *
   * @param appId - The id of the conversation to leave.
   */
  async handleLeaveConversation(t) {
    this.conversationId === t && this.selectConversation(null);
    const e = await this.whenUser();
    await this.leaveConversationMutation?.mutate({ appId: t, members: [e.id] }), this.conversationsQuery.result.refetch();
  }
  /**
   * Remove a conversation.
   *
   * @param appId - The id of the conversation to remove.
   */
  async handleRemoveConversation(t) {
    this.conversationId === t && this.selectConversation(null), await this.removeConversationMutation?.mutate({ appId: t }), this.conversationsQuery.result.refetch();
  }
  /**
   * Trash a conversation.
   *
   * @param appId - The id of the conversation to trash.
   */
  async handleTrashConversation(t) {
    this.conversationId === t && this.selectConversation(null), await this.trashConversationMutation?.mutate({ appId: t }), this.conversationsQuery.result.refetch();
  }
  async willUpdate(t) {
    var e;
    super.willUpdate(t), (t.has("weavy") || t.has("conversationTypes")) && this.weavy && (await this.conversationsQuery.trackInfiniteQuery(
      m0(
        this.weavy,
        {},
        this.conversationTypes,
        this.agent,
        () => this.searchText,
        "pinned_at desc,rev desc",
        !1
      )
    ), this.markConversationMutation = Lm(this.weavy), this.starConversationMutation = cb(this.weavy), this.pinConversationMutation = lb(this.weavy), this.leaveConversationMutation = Om(this.weavy), this.removeConversationMutation = db(this.weavy), this.trashConversationMutation = ub(this.weavy), (e = If(this, hn)) == null || e.call(this), this.weavy.subscribe(null, "app_created", this.handleRefresh), this.weavy.subscribe(null, "message_created", this.handleRefresh), this.weavy.subscribe(null, "member_added", this.handleRefresh), this.weavy.subscribe(null, "online", this.handlePresenceChange), Tf(this, hn, () => {
      this.weavy?.unsubscribe(null, "app_created", this.handleRefresh), this.weavy?.unsubscribe(null, "message_created", this.handleRefresh), this.weavy?.unsubscribe(null, "member_added", this.handleRefresh), this.weavy?.unsubscribe(null, "online", this.handlePresenceChange), Tf(this, hn, void 0);
    }));
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.conversationsQuery.result, this.pagerRef.value);
  }
  async updated(t) {
    t.has("searchText") && t.get("searchText") !== void 0 && this.conversationsQuery.result && await this.conversationsQuery.result.refetch?.();
  }
  renderConversations(t) {
    if (t) {
      const e = Zi(t);
      return Fe(
        e,
        (r) => r?.id,
        (r) => [
          h`<wy-conversation-item
              conversationId=${r?.id}
              .avatarUrl=${r?.avatar_url}
              .hideAvatar=${!!this.agent}
              .name=${r.name}
              .lastMessage=${r.last_message}
              .members=${r.members}
              .unread=${r.is_unread}
              .starred=${r.is_starred}
              .pinned=${r.is_pinned}
              .type=${r.type}
              .selected=${this.conversationId == r.id}
              @selected=${() => this.selectConversation(r)}
              @mark=${(s) => this.handleMark(r, s.detail.messageId)}
              @star=${(s) => this.handleStar(s.detail.id, s.detail.star)}
              @pin=${(s) => this.handlePin(s.detail.id, s.detail.pin)}
              @leave=${(s) => this.handleLeaveConversation(s.detail.id)}
              @remove=${(s) => this.handleRemoveConversation(s.detail.id)}
              @trash=${(s) => this.handleTrashConversation(s.detail.id)}
            ></wy-conversation-item>`
        ]
      );
    }
    return v;
  }
  render() {
    const { data: t, isPending: e, hasNextPage: r } = this.conversationsQuery.result ?? {};
    return h`
      <div part="wy-conversations">
        <wy-buttons part="wy-conversations-toolbar" position=${this.agent ? "floating" : "sticky"} ?reverse=${!!this.agent}>
          <slot name="navigation"></slot>
          ${this.agent ? v : h`
                <wy-search
                  compact
                  placeholder=${b("Search for conversations...")}
                  @search=${(s) => this.searchText = s.detail.query}
                ></wy-search>
              `}
          <slot name="actions"></slot>
        </wy-buttons>

        <div part="wy-conversation-list">
          ${!e && this.user && t ? t.pages[0]?.count || this.searchText ? this.renderConversations(t) : h`
                  <div part="wy-pane-body">
                    <div part="wy-pane-group">
                      <wy-empty noNetwork>${b("Create a conversation to get started.")}</wy-empty>
                    </div>
                  </div>
                ` : h`<wy-empty><wy-progress-circular indeterminate padded></wy-progress-circular></wy-empty>`}
          ${r ? h`<div ${j(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : v}
        </div>
      </div>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = If(this, hn)) == null || t.call(this), super.disconnectedCallback();
  }
}, a(lc, "WyConversationList"), lc);
hn = /* @__PURE__ */ new WeakMap();
Hr.styles = [Wv, qs, Z, Br];
gd([
  p({ type: Number })
], Hr.prototype, "conversationId", 2);
gd([
  p({ type: Array })
], Hr.prototype, "conversationTypes", 2);
gd([
  p()
], Hr.prototype, "agent", 2);
gd([
  F()
], Hr.prototype, "searchText", 2);
Hr = gd([
  H("wy-conversation-list"),
  ot()
], Hr);
var a9 = Object.defineProperty, o9 = Object.getOwnPropertyDescriptor, Vh = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? o9(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && a9(t, e, s), s;
}, "__decorateClass$2"), dc;
let Fs = (dc = class extends Dt {
  constructor() {
    super(...arguments), this.componentFeatures = new ee(Oc), this.theme = new Te(this, Fs.styles), this.unreadConversations = new mc(this), this.createConversationController = new fc(this), this.componentTypes = [tt.ChatRoom, tt.PrivateChat], this.conversationId = null, this.conversationQuery = new Ie(this), this.persistState = new vs(this), this.conversationNewRef = et();
  }
  set agent(t) {
    super.agent = t, this._agentUid ? (this.componentTypes = [tt.AgentChat], this.componentFeatures = new ee(
      Sy,
      this.componentFeatures.allowedFeatures()
    )) : (this.componentTypes = [tt.ChatRoom, tt.PrivateChat], this.componentFeatures = new ee(
      Oc,
      this.componentFeatures.allowedFeatures()
    )), this.conversationId = null;
  }
  get agent() {
    return super.agent;
  }
  /** Current unread conversation count. */
  get unread() {
    return this.unreadConversations.unread;
  }
  /**
   * Creates a new conversation.
   *
   * When in agent mode, a conversation is created instantly.
   *
   * @param members - Optional array of member id or member uid.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select member dialog to let the user choose members.
   *
   * @returns Promise resolving to any selected member ids or uids.
   */
  async selectMembers() {
    return await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("weavy") || t.has("agent") || t.has("user")) && this.weavy && this.user && this.persistState.observe(
      [{ name: "conversationId", override: !1 }],
      this.agent || "messenger",
      `u${this.user?.id}`,
      (e) => {
        if (e.has("conversationId") && this.conversationId) {
          const r = new CustomEvent("wy-action", {
            detail: {
              action: ge.Select,
              app: { id: this.conversationId }
            },
            bubbles: !0,
            composed: !0
          });
          this.dispatchEvent(r);
        }
      }
    ), t.has("agent") && (this.createConversationController.agent = this.agent), t.has("link") && this.link?.app && (this.conversationId = this.link.app.id), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversations.track(this.componentTypes, this.agent);
  }
  render() {
    return h`
      <wy-conversation-list
        .conversationTypes=${this.componentTypes}
        .agent=${this.agent}
        conversationId=${nt(this.conversationId !== null ? this.conversationId : void 0)}
        @wy-action=${(t) => {
      !t.defaultPrevented && t.detail.action === ge.Select && t.detail.app !== void 0 && (this.conversationId = t.detail.app?.id);
    }}
      >
        <wy-conversation-new
          slot="actions"
          .agent=${this.agent}
          @wy-action=${(t) => {
      !t.defaultPrevented && t.detail.action === ge.Select && t.detail.app !== void 0 && (this.conversationId = t.detail.app?.id);
    }}
          ${j(this.conversationNewRef)}
        >
          <slot name="conversation-new"></slot>
        </wy-conversation-new>
        <slot name="actions" slot="actions"></slot>
      </wy-conversation-list>
    `;
  }
}, a(dc, "WyMessengerConversations"), dc);
Fs.styles = [Yt, Ri, Se, Vs, Us];
Vh([
  p({ attribute: !1 })
], Fs.prototype, "componentTypes", 2);
Vh([
  p({ type: String })
], Fs.prototype, "agent", 1);
Vh([
  p({ type: Number })
], Fs.prototype, "conversationId", 2);
Fs = Vh([
  H("wy-messenger-conversations"),
  ot()
], Fs);
var c9 = Object.defineProperty, l9 = Object.getOwnPropertyDescriptor, Uh = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? l9(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = (r ? o(t, e, s) : o(s)) || s);
  return r && s && c9(t, e, s), s;
}, "__decorateClass$1"), hc;
let Ds = (hc = class extends $e {
  constructor() {
    super(...arguments), this.exportParts = new U(this), this._whenMembers = this.createMembersPromise(), this.show = !1;
  }
  /**
   * Resolves when members are selected from the modal.
   *
   * @returns Promise<MemberIdType[]>
   */
  async whenMembers() {
    return this._whenMembers;
  }
  /**
   * Create an internal members promise and store resolve/reject handlers.
   *
   * @internal
   */
  createMembersPromise() {
    const t = new Promise((e, r) => {
      this._resolveMembers = e, this._rejectMembers = r;
    });
    return this._whenMembers = t, t;
  }
  /**
   * Open the new conversation dialog and return selected members.
   *
   * @returns Promise<MemberIdType[]>
   */
  async selectMembers() {
    return this.show = !0, await this.whenMembers();
  }
  /**
   * Close the new conversation dialog and resolve or reject the selection promise.
   *
   * @internal
   * @param members - Optional selected member ids to resolve the promise with.
   */
  close(t) {
    this.show = !1, t ? this._resolveMembers?.(t) : this._rejectMembers?.();
  }
  /**
   * Create a conversation by dispatching a `create` event and closing the dialog.
   *
   * @param members - Array of members by id/uid for a new conversation.
   */
  async submit(t = []) {
    await this.whenUser(), this.close(t);
    const e = new CustomEvent("create", {
      detail: { members: t }
    });
    this.dispatchEvent(e), this.createMembersPromise();
  }
  render() {
    return h`
      ${this.slotElements.length ? v : h`
            <wy-button
              part="wy-conversation-new-button"
              kind="icon"
              @click=${() => this.agent ? this.submit() : this.selectMembers()}
            >
              <wy-icon name="plus"></wy-icon>
            </wy-button>
          `}
      <slot></slot>

      ${!this.agent && this.weavy && this.user ? h`<wy-overlay
            part="wy-conversation-new-dialog"
            .show=${this.show}
            @close=${() => {
      this.show = !1;
    }}
          >
            <wy-titlebar header slot="header">
              <wy-button slot="icon" kind="icon" @click=${() => this.close()}>
                <wy-icon name="close"></wy-icon>
              </wy-button>
              <span slot="title">${b("New conversation")}</span>
            </wy-titlebar>
            ${this.show ? h`
                  <wy-users-search
                    @submit=${(t) => this.submit(t.detail.members.map((e) => e.id))}
                  ></wy-users-search>
                ` : v}
          </wy-overlay>` : v}
    `;
  }
}, a(hc, "WyConversationNew"), hc);
Ds.styles = [Z];
Uh([
  p()
], Ds.prototype, "agent", 2);
Uh([
  F()
], Ds.prototype, "show", 2);
Uh([
  Hc({ flatten: !0, selector: ":not(slot)" })
], Ds.prototype, "slotElements", 2);
Ds = Uh([
  H("wy-conversation-new"),
  ot()
], Ds);
const d9 = B`[part~=wy-message-editor-inputs]{display:flex;flex-direction:row;align-items:flex-end;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em))*1.5*var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*2 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))*2)}[part~=wy-message-editor-text]{flex:1 1 100%;display:flex;flex-direction:column;margin-inline:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-editor-parts]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));min-height:0}[part~=wy-message-editor] .cm-editor{flex:1 1 100%;max-height:11.25em;background-color:var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:var(--wy-input-filled-border-radius, var(--wy-border-radius-lg, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem)))));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid rgba(0,0,0,0);margin:calc(-1*var(--wy-input-border-width, var(--wy-border, 1px)))}[part~=wy-message-editor] .cm-editor:focus{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-message-editor] .cm-editor.cm-focused{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-message-editor] .cm-editor .cm-content{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)), inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em))*1.5*var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*2 - var(--wy-input-border-width, var(--wy-border, 1px)));line-height:calc(1.5*var(--wy-size, 1rem))}[part~=wy-message-editor] [part~=wy-is-invalid]+[data-editor-target] .cm-editor,[part~=wy-message-editor] [part~=wy-is-invalid] .cm-editor{border-color:var(--wy-error, var(--wy-error-light, #ba1821))!important}`;
var h9 = Object.getOwnPropertyDescriptor, p9 = /* @__PURE__ */ a((i, t, e, r) => {
  for (var s = r > 1 ? void 0 : r ? h9(t, e) : t, n = i.length - 1, o; n >= 0; n--)
    (o = i[n]) && (s = o(s) || s);
  return s;
}, "__decorateClass"), pc;
let ah = (pc = class extends vt {
  constructor() {
    super(), this.editorType = "messages", this.editorClass = "wy-message-editor";
  }
  /**
   * Render content that appears above the message editor.
   *
   * By default returns the same lists section used by the base editor.
   *
   * @internal
   */
  renderTopSlot() {
    return [
      this.renderLists()
    ];
  }
  /**
   * Render the primary middle slot containing the add-menu, editor and send button.
   *
   * Overrides the base implementation to provide message-specific controls and layout.
   *
   * @internal
   */
  renderMiddleSlot() {
    return h` <div part="wy-message-editor-inputs">
      <!-- Add -->
      ${this.componentFeatures?.allowsAnyFeature(
      M.Attachments,
      M.CloudFiles,
      M.Polls,
      M.Meetings,
      M.ZoomMeetings,
      M.GoogleMeet,
      M.MicrosoftTeams
    ) ? h`<wy-dropdown icon="plus" directionY="up" ?disabled=${this.disabled}>
            ${this.componentFeatures?.allowsFeature(M.Attachments) ? h`
                  <wy-dropdown-item @click=${this.openFileInput} title=${b("From device")}>
                    <wy-icon name="attachment"></wy-icon>
                    <span>${b("From device")}</span>
                  </wy-dropdown-item>
                  <input
                    type="file"
                    ${j(this.fileInputRef)}
                    @click=${(t) => t.stopPropagation()}
                    @change=${(t) => this.handleUploadFiles(
      Array.from(t.target.files || []),
      t.target
    )}
                    multiple
                    hidden
                    tabindex="-1"
                  />
                ` : v}
            ${this.componentFeatures?.allowsFeature(M.CloudFiles) ? h`
                  <wy-dropdown-item @click=${this.openCloudFiles} title=${b("From cloud")}>
                    <wy-icon name="cloud"></wy-icon>
                    <span>${b("From cloud")}</span>
                  </wy-dropdown-item>
                ` : v}
            ${this.componentFeatures?.allowsFeature(M.Polls) ? h`
                  <wy-dropdown-item @click=${() => this.openPolls()} title=${b("Poll")}>
                    <wy-icon name="poll"></wy-icon>
                    <span>${b("Poll")}</span>
                  </wy-dropdown-item>
                ` : v}
            ${this.componentFeatures?.allowsAnyFeature(M.Meetings, M.ZoomMeetings) ? h`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("zoom")} title=${b("Zoom meeting")}>
                    <wy-icon svg="zoom-meetings"></wy-icon>
                    <span>${b("Zoom meeting")}</span>
                  </wy-dropdown-item>
                ` : v}
            ${this.componentFeatures?.allowsAnyFeature(M.Meetings, M.GoogleMeet) ? h`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("google")} title=${b("Google Meet")}>
                    <wy-icon svg="google-meet"></wy-icon>
                    <span>${b("Google Meet")}</span>
                  </wy-dropdown-item>
                ` : v}
            ${this.componentFeatures?.allowsAnyFeature(M.Meetings, M.MicrosoftTeams) ? h`
                  <wy-dropdown-item
                    @click=${() => this.handleMeetingClick("microsoft")}
                    title=${b("Microsoft Teams")}
                  >
                    <wy-icon svg="microsoft-teams"></wy-icon>
                    <span>${b("Microsoft Teams")}</span>
                  </wy-dropdown-item>
                ` : v}
          </wy-dropdown>` : v}

      <!-- Input -->
      <div part="wy-message-editor-text" ${j(this.editorRef)}> ${this.renderEditorDummy()} </div>

      <!-- Button -->
      <wy-button
        kind="icon"
        color="primary-text"
        title=${b("Send", { desc: "Button action to send" })}
        @click="${() => this.submit()}"
        ?disabled=${this.disabled}
      >
        <wy-icon name="send"></wy-icon>
      </wy-button>
    </div>`;
  }
  /**
   * Render the bottom slot for message editor with no content.
   *
   * @internal
   */
  renderBottomSlot() {
    return v;
  }
}, a(pc, "WyMessageEditor"), pc);
ah.styles = [...vt.styles, d9];
ah = p9([
  H("wy-message-editor"),
  ot()
], ah);
const g9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get WyAnnotation() {
    return $l;
  },
  get WyAnnotationList() {
    return Cl;
  },
  get WyAttachment() {
    return xl;
  },
  get WyAttachmentList() {
    return _c;
  },
  get WyAvatar() {
    return ki;
  },
  get WyAvatarGroup() {
    return xs;
  },
  get WyAvatarHeader() {
    return fl;
  },
  get WyBadge() {
    return er;
  },
  get WyButton() {
    return Qe;
  },
  get WyButtons() {
    return $s;
  },
  get WyCloudFiles() {
    return Rs;
  },
  get WyComment() {
    return Mi;
  },
  get WyCommentEditor() {
    return rh;
  },
  get WyCommentList() {
    return tr;
  },
  get WyContainer() {
    return Xi;
  },
  get WyContextDataProgress() {
    return sh;
  },
  get WyConversation() {
    return De;
  },
  get WyConversationHeader() {
    return zi;
  },
  get WyConversationItem() {
    return fe;
  },
  get WyConversationList() {
    return Hr;
  },
  get WyConversationNew() {
    return Ds;
  },
  get WyDropdown() {
    return Ke;
  },
  get WyDropdownDivider() {
    return eh;
  },
  get WyDropdownItem() {
    return gl;
  },
  get WyDropdownOption() {
    return kc;
  },
  get WyEditor() {
    return vt;
  },
  get WyEmbed() {
    return Pc;
  },
  get WyEmbedSelect() {
    return kl;
  },
  get WyEmpty() {
    return $c;
  },
  get WyFileGrid() {
    return Es;
  },
  get WyFileItem() {
    return Si;
  },
  get WyFileMenu() {
    return zs;
  },
  get WyFileTable() {
    return Fr;
  },
  get WyFileVersions() {
    return Rl;
  },
  get WyFilesHeader() {
    return Tr;
  },
  get WyFilesList() {
    return ir;
  },
  get WyIcon() {
    return Ht;
  },
  get WyIconDisplay() {
    return wl;
  },
  get WyIconStack() {
    return Zd;
  },
  get WyImageGrid() {
    return _s;
  },
  get WyItem() {
    return ie;
  },
  get WyItemList() {
    return Er;
  },
  get WyMeetingCard() {
    return _l;
  },
  get WyMessage() {
    return Et;
  },
  get WyMessageEditor() {
    return ah;
  },
  get WyMessageTyping() {
    return ti;
  },
  get WyNotificationHeader() {
    return Os;
  },
  get WyNotificationList() {
    return Rc;
  },
  get WyNotificationListItem() {
    return Dr;
  },
  get WyOverlay() {
    return Or;
  },
  get WyPdfViewer() {
    return As;
  },
  get WyPoll() {
    return Ml;
  },
  get WyPollOption() {
    return Ps;
  },
  get WyPost() {
    return Ut;
  },
  get WyPostEdit() {
    return de;
  },
  get WyPostList() {
    return Ll;
  },
  get WyPostTrashed() {
    return zc;
  },
  get WyPostView() {
    return At;
  },
  get WyPresence() {
    return bc;
  },
  get WyPreview() {
    return Vt;
  },
  get WyPreviewEmbed() {
    return Ir;
  },
  get WyPreviewIcon() {
    return Ms;
  },
  get WyPreviewImage() {
    return Ss;
  },
  get WyPreviewItem() {
    return Mc;
  },
  get WyPreviewMedia() {
    return Ji;
  },
  get WyPreviewText() {
    return Pi;
  },
  get WyProgressCircular() {
    return oi;
  },
  get WyProgressLinear() {
    return ei;
  },
  get WyReactionItem() {
    return Al;
  },
  get WyReactions() {
    return jt;
  },
  get WySearch() {
    return Is;
  },
  get WySkeleton() {
    return bl;
  },
  get WyTitlebar() {
    return Yi;
  },
  get WyTitlebarText() {
    return Pl;
  },
  get WyToast() {
    return rr;
  },
  get WyToasts() {
    return Il;
  },
  get WyTyping() {
    return Tc;
  },
  get WyUpload() {
    return Ic;
  },
  get WyUsersSearch() {
    return di;
  }
}, Symbol.toStringTag, { value: "Module" }));
export {
  jd as AgentAppTypeGuids,
  f9 as AgentAppTypeStrings,
  Qu as AppContext,
  l0 as AppTypeGuids,
  d0 as AppTypeStrings,
  ee as ComponentFeatures,
  Fw as ContextController,
  om as ContextIdContext,
  fc as CreateConversationController,
  cm as DataBlobsContext,
  Sy as DefaultMessengerAgentFeatures,
  Oc as DefaultMessengerFeatures,
  Wd as DropZoneController,
  M as Feature,
  ph as FeaturePolicyContext,
  Uw as HistoryController,
  Ki as InfiniteQueryController,
  Gi as InfiniteScrollController,
  dm as LinkContext,
  v9 as MessengerAgentTypes,
  m9 as MessengerTypes,
  We as MutationController,
  yc as MutationStateController,
  vs as PersistStateController,
  Ie as QueryController,
  Bw as ResizeController,
  Cu as ReverseInfiniteScrollController,
  U as ShadowPartsController,
  _u as SwipeScrollController,
  Te as ThemeController,
  Qd as TypingController,
  Mr as UnknownApp,
  mc as UnreadConversationsController,
  ul as UnreadNotificationsController,
  uh as UserContext,
  Bt as Weavy,
  xe as WeavyAppComponent,
  te as WeavyClient,
  wc as WeavyComponent,
  Nd as WeavyComponentSettings,
  hm as WeavyComponentSettingsContext,
  g9 as WeavyComponents,
  re as WeavyContext,
  zr as WeavyOptionalAppComponent,
  Rt as WeavySubAppComponent,
  $e as WeavySubComponent,
  Dt as WeavyTypeComponent,
  Sc as WyChat,
  El as WyComments,
  vc as WyComponent,
  Nt as WyContext,
  Ac as WyCopilot,
  Ls as WyFiles,
  nr as WyMessenger,
  Ts as WyMessengerBadge,
  He as WyMessengerButton,
  Fs as WyMessengerConversations,
  nh as WyMessengerNew,
  Lc as WyNotificationBadge,
  Ai as WyNotificationButton,
  sr as WyNotificationToasts,
  Ec as WyNotifications,
  Ol as WyPosts,
  yu as allFeatures,
  Vg as createWeavyContextProvider,
  Ku as featureConfigFromList,
  lm as featureListFromString,
  tl as globalContextProvider,
  fu as hasAbort
};
