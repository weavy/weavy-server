var Pf = Object.defineProperty;
var Np = (r) => {
  throw TypeError(r);
};
var c = (r, t) => Pf(r, "name", { value: t, configurable: !0 });
var bd = (r, t, i) => t.has(r) || Np("Cannot " + i);
var b = (r, t, i) => (bd(r, t, "read from private field"), i ? i.call(r) : t.get(r)), T = (r, t, i) => t.has(r) ? Np("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(r) : t.set(r, i), I = (r, t, i, s) => (bd(r, t, "write to private field"), s ? s.call(r, i) : t.set(r, i), i), tt = (r, t, i) => (bd(r, t, "access private method"), i);
var Pc = (r, t, i, s) => ({
  set _(n) {
    I(r, t, n, i);
  },
  get _() {
    return b(r, t, s);
  }
});
import { observeConnected as Mf, throwOnDomNotAvailable as Se, isDomAvailable as Ph, whenConnected as ly, whenParentsDefined as oo, defaultVisibilityCheckOptions as zf, isInShadowDom as jp, isPopoverPolyfilled as Ed, autofocusRef as Mh, whenElementVisible as Od, whenDocumentVisible as Sf } from "./es/editor.js";
import { configureLocalization as Ef, e as Of, i as Z, h as j, b as Af, y as Lf, ke as p, r as Rf, S as If, si as Tf, D as C, R as dc, Oe as Wp, msg as $, localized as st, str as pt, Q as Ff } from "./es/locales/sv-SE.js";
function Lc(r) {
  return Object.prototype.toString.call(r) === "[object Object]";
}
c(Lc, "isObject$1");
function Rc(r) {
  if (Lc(r) === !1) return !1;
  const t = r.constructor;
  if (t === void 0) return !0;
  const i = t.prototype;
  return !(Lc(i) === !1 || Object.prototype.hasOwnProperty.call(i, "isPrototypeOf") === !1);
}
c(Rc, "isPlainObject$1");
function Ec(r, t, i = !1) {
  r = r || {}, t = t || {};
  const s = {};
  for (const n in r)
    Object.prototype.hasOwnProperty.call(r, n) && (s[n] = r[n]);
  for (const n in t)
    Object.prototype.hasOwnProperty.call(t, n) && (i && s[n] && Rc(s[n]) && Rc(t[n]) ? s[n] = Ec(
      s[n],
      t[n],
      i
    ) : s[n] = t[n]);
  return s;
}
c(Ec, "assign");
function ko(r, t, i = !1, s = !1) {
  if (!s && (!Rc(r) || !Rc(t)) || s && (!Lc(r) || !Lc(t)))
    return !1;
  const n = Object.getOwnPropertyNames(r), a = Object.getOwnPropertyNames(t);
  if (!i && n.length !== a.length)
    return !1;
  for (let o = 0; o < n.length; o++) {
    const l = n[o], d = r[l], u = t[l];
    if (d !== u && !ko(d, u, i))
      return !1;
  }
  return !0;
}
c(ko, "eqObjects");
function dy(r) {
  return Object.entries(r);
}
c(dy, "objectAsIterable");
function hy(r) {
  return r.charAt(0).toUpperCase() + r.substring(1).toLowerCase();
}
c(hy, "toUpperCaseFirst");
const Df = '\\s,.:;"', Hf = new RegExp(`^|[${Df}]|$`, "g");
function py(r) {
  return r.length > 0 ? r.replace(/([a-z\d])([A-Z]+)/g, "$1-$2").replace(/_|\s+/g, "-").toLowerCase() : r;
}
c(py, "toKebabCase");
function Vf(r, t = 2) {
  if (!r)
    return null;
  let i = "";
  const s = r.split(Hf).filter((n) => n);
  return s.length == 1 ? i = s[0] : s.forEach((n) => {
    i += n.charAt(0);
  }), i.substring(0, t).toUpperCase();
}
c(Vf, "getInitials");
const Bf = {
  //mode: 'cors', // no-cors, *cors, same-origin
  // cache: 'default' means the server is in control of the caching which is preferred instead of using 'reload'
  //cache: 'default', // *default, no-cache, reload, force-cache, only-if-cached
  credentials: "omit",
  // include, *same-origin, omit
  headers: {
    // https://stackoverflow.com/questions/8163703/cross-domain-ajax-doesnt-send-x-requested-with-header
    "X-Requested-With": "XMLHttpRequest"
  },
  redirect: "manual"
  // manual, *follow, error
  //referrerPolicy: 'no-referrer-when-downgrade', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
};
function So() {
  return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
}
c(So, "S4");
function Uf(r) {
  if (r && r.ok && r.body) {
    const t = r.body.getReader();
    return new ReadableStream({
      start(i) {
        const s = /* @__PURE__ */ c(() => t.read().then(({ done: n, value: a }) => {
          if (n) {
            i.close();
            return;
          }
          return i.enqueue(a), s();
        }), "pump");
        return s();
      }
    });
  } else
    throw new Error("Could not parse text stream");
}
c(Uf, "getTextStreamFromResponse");
function qf(r) {
  let t;
  try {
    if (t = window[r], t) {
      const i = "__storage_test__";
      t.setItem(i, i), t.removeItem(i);
    }
  } catch (i) {
    i instanceof DOMException && i.name === "QuotaExceededError" && // acknowledge QuotaExceededError only if there's something already stored
    t && t.length !== 0 && console.error("Storage not available:", r);
  }
  return t;
}
c(qf, "getStorage");
const hp = class hp extends Error {
  constructor() {
    super("Instance destroyed"), this.name = "DestroyError";
  }
};
c(hp, "DestroyError");
let At = hp;
var Ar, co = (Ar = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, c(Ar, "Subscribable"), Ar), qa = typeof window > "u" || "Deno" in globalThis;
function Ve() {
}
c(Ve, "noop$1");
function Nf(r, t) {
  return typeof r == "function" ? r(t) : r;
}
c(Nf, "functionalUpdate");
function Ad(r) {
  return typeof r == "number" && r >= 0 && r !== 1 / 0;
}
c(Ad, "isValidTimeout");
function uy(r, t) {
  return Math.max(r + (t || 0) - Date.now(), 0);
}
c(uy, "timeUntilStale");
function Sr(r, t) {
  return typeof r == "function" ? r(t) : r;
}
c(Sr, "resolveStaleTime");
function Ge(r, t) {
  return typeof r == "function" ? r(t) : r;
}
c(Ge, "resolveEnabled");
function Qp(r, t) {
  const {
    type: i = "all",
    exact: s,
    fetchStatus: n,
    predicate: a,
    queryKey: o,
    stale: l
  } = r;
  if (o) {
    if (s) {
      if (t.queryHash !== zh(o, t.options))
        return !1;
    } else if (!Eo(t.queryKey, o))
      return !1;
  }
  if (i !== "all") {
    const d = t.isActive();
    if (i === "active" && !d || i === "inactive" && d)
      return !1;
  }
  return !(typeof l == "boolean" && t.isStale() !== l || n && n !== t.state.fetchStatus || a && !a(t));
}
c(Qp, "matchQuery");
function Kp(r, t) {
  const { exact: i, status: s, predicate: n, mutationKey: a } = r;
  if (a) {
    if (!t.options.mutationKey)
      return !1;
    if (i) {
      if (Vs(t.options.mutationKey) !== Vs(a))
        return !1;
    } else if (!Eo(t.options.mutationKey, a))
      return !1;
  }
  return !(s && t.state.status !== s || n && !n(t));
}
c(Kp, "matchMutation");
function zh(r, t) {
  return ((t == null ? void 0 : t.queryKeyHashFn) || Vs)(r);
}
c(zh, "hashQueryKeyByOptions");
function Vs(r) {
  return JSON.stringify(
    r,
    (t, i) => Ld(i) ? Object.keys(i).sort().reduce((s, n) => (s[n] = i[n], s), {}) : i
  );
}
c(Vs, "hashKey");
function Eo(r, t) {
  return r === t ? !0 : typeof r != typeof t ? !1 : r && t && typeof r == "object" && typeof t == "object" ? !Object.keys(t).some((i) => !Eo(r[i], t[i])) : !1;
}
c(Eo, "partialMatchKey");
function hc(r, t) {
  if (r === t)
    return r;
  const i = Gp(r) && Gp(t);
  if (i || Ld(r) && Ld(t)) {
    const s = i ? r : Object.keys(r), n = s.length, a = i ? t : Object.keys(t), o = a.length, l = i ? [] : {};
    let d = 0;
    for (let u = 0; u < o; u++) {
      const y = i ? u : a[u];
      (!i && s.includes(y) || i) && r[y] === void 0 && t[y] === void 0 ? (l[y] = void 0, d++) : (l[y] = hc(r[y], t[y]), l[y] === r[y] && r[y] !== void 0 && d++);
    }
    return n === o && d === n ? r : l;
  }
  return t;
}
c(hc, "replaceEqualDeep");
function Ic(r, t) {
  if (!t || Object.keys(r).length !== Object.keys(t).length)
    return !1;
  for (const i in r)
    if (r[i] !== t[i])
      return !1;
  return !0;
}
c(Ic, "shallowEqualObjects");
function Gp(r) {
  return Array.isArray(r) && r.length === Object.keys(r).length;
}
c(Gp, "isPlainArray");
function Ld(r) {
  if (!Yp(r))
    return !1;
  const t = r.constructor;
  if (t === void 0)
    return !0;
  const i = t.prototype;
  return !(!Yp(i) || !i.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(r) !== Object.prototype);
}
c(Ld, "isPlainObject");
function Yp(r) {
  return Object.prototype.toString.call(r) === "[object Object]";
}
c(Yp, "hasObjectPrototype");
function jf(r) {
  return new Promise((t) => {
    setTimeout(t, r);
  });
}
c(jf, "sleep");
function Rd(r, t, i) {
  return typeof i.structuralSharing == "function" ? i.structuralSharing(r, t) : i.structuralSharing !== !1 ? hc(r, t) : t;
}
c(Rd, "replaceData");
function Wf(r, t, i = 0) {
  const s = [...r, t];
  return i && s.length > i ? s.slice(1) : s;
}
c(Wf, "addToEnd");
function Qf(r, t, i = 0) {
  const s = [t, ...r];
  return i && s.length > i ? s.slice(0, -1) : s;
}
c(Qf, "addToStart");
var Sh = Symbol();
function yy(r, t) {
  return !r.queryFn && (t != null && t.initialPromise) ? () => t.initialPromise : !r.queryFn || r.queryFn === Sh ? () => Promise.reject(new Error(`Missing queryFn: '${r.queryHash}'`)) : r.queryFn;
}
c(yy, "ensureQueryFn");
var Ms, Ki, Lr, Rr, Kf = (Rr = class extends co {
  constructor() {
    super();
    T(this, Ms);
    T(this, Ki);
    T(this, Lr);
    I(this, Lr, (i) => {
      if (!qa && window.addEventListener) {
        const s = /* @__PURE__ */ c(() => i(), "listener");
        return window.addEventListener("visibilitychange", s, !1), () => {
          window.removeEventListener("visibilitychange", s);
        };
      }
    });
  }
  onSubscribe() {
    b(this, Ki) || this.setEventListener(b(this, Lr));
  }
  onUnsubscribe() {
    var i;
    this.hasListeners() || ((i = b(this, Ki)) == null || i.call(this), I(this, Ki, void 0));
  }
  setEventListener(i) {
    var s;
    I(this, Lr, i), (s = b(this, Ki)) == null || s.call(this), I(this, Ki, i((n) => {
      typeof n == "boolean" ? this.setFocused(n) : this.onFocus();
    }));
  }
  setFocused(i) {
    b(this, Ms) !== i && (I(this, Ms, i), this.onFocus());
  }
  onFocus() {
    const i = this.isFocused();
    this.listeners.forEach((s) => {
      s(i);
    });
  }
  isFocused() {
    var i;
    return typeof b(this, Ms) == "boolean" ? b(this, Ms) : ((i = globalThis.document) == null ? void 0 : i.visibilityState) !== "hidden";
  }
}, Ms = new WeakMap(), Ki = new WeakMap(), Lr = new WeakMap(), c(Rr, "FocusManager"), Rr), Eh = new Kf(), Ir, Gi, Tr, Fr, Gf = (Fr = class extends co {
  constructor() {
    super();
    T(this, Ir, !0);
    T(this, Gi);
    T(this, Tr);
    I(this, Tr, (i) => {
      if (!qa && window.addEventListener) {
        const s = /* @__PURE__ */ c(() => i(!0), "onlineListener"), n = /* @__PURE__ */ c(() => i(!1), "offlineListener");
        return window.addEventListener("online", s, !1), window.addEventListener("offline", n, !1), () => {
          window.removeEventListener("online", s), window.removeEventListener("offline", n);
        };
      }
    });
  }
  onSubscribe() {
    b(this, Gi) || this.setEventListener(b(this, Tr));
  }
  onUnsubscribe() {
    var i;
    this.hasListeners() || ((i = b(this, Gi)) == null || i.call(this), I(this, Gi, void 0));
  }
  setEventListener(i) {
    var s;
    I(this, Tr, i), (s = b(this, Gi)) == null || s.call(this), I(this, Gi, i(this.setOnline.bind(this)));
  }
  setOnline(i) {
    b(this, Ir) !== i && (I(this, Ir, i), this.listeners.forEach((n) => {
      n(i);
    }));
  }
  isOnline() {
    return b(this, Ir);
  }
}, Ir = new WeakMap(), Gi = new WeakMap(), Tr = new WeakMap(), c(Fr, "OnlineManager"), Fr), Tc = new Gf();
function Id() {
  let r, t;
  const i = new Promise((n, a) => {
    r = n, t = a;
  });
  i.status = "pending", i.catch(() => {
  });
  function s(n) {
    Object.assign(i, n), delete i.resolve, delete i.reject;
  }
  return c(s, "finalize"), i.resolve = (n) => {
    s({
      status: "fulfilled",
      value: n
    }), r(n);
  }, i.reject = (n) => {
    s({
      status: "rejected",
      reason: n
    }), t(n);
  }, i;
}
c(Id, "pendingThenable");
function Yf(r) {
  return Math.min(1e3 * 2 ** r, 3e4);
}
c(Yf, "defaultRetryDelay");
function wy(r) {
  return (r ?? "online") === "online" ? Tc.isOnline() : !0;
}
c(wy, "canFetch");
var Dr, fy = (Dr = class extends Error {
  constructor(t) {
    super("CancelledError"), this.revert = t == null ? void 0 : t.revert, this.silent = t == null ? void 0 : t.silent;
  }
}, c(Dr, "CancelledError"), Dr);
function xd(r) {
  return r instanceof fy;
}
c(xd, "isCancelledError");
function my(r) {
  let t = !1, i = 0, s = !1, n;
  const a = Id(), o = /* @__PURE__ */ c((k) => {
    var S;
    s || (f(new fy(k)), (S = r.abort) == null || S.call(r));
  }, "cancel"), l = /* @__PURE__ */ c(() => {
    t = !0;
  }, "cancelRetry"), d = /* @__PURE__ */ c(() => {
    t = !1;
  }, "continueRetry"), u = /* @__PURE__ */ c(() => Eh.isFocused() && (r.networkMode === "always" || Tc.isOnline()) && r.canRun(), "canContinue"), y = /* @__PURE__ */ c(() => wy(r.networkMode) && r.canRun(), "canStart"), m = /* @__PURE__ */ c((k) => {
    var S;
    s || (s = !0, (S = r.onSuccess) == null || S.call(r, k), n == null || n(), a.resolve(k));
  }, "resolve"), f = /* @__PURE__ */ c((k) => {
    var S;
    s || (s = !0, (S = r.onError) == null || S.call(r, k), n == null || n(), a.reject(k));
  }, "reject"), g = /* @__PURE__ */ c(() => new Promise((k) => {
    var S;
    n = /* @__PURE__ */ c((P) => {
      (s || u()) && k(P);
    }, "continueFn"), (S = r.onPause) == null || S.call(r);
  }).then(() => {
    var k;
    n = void 0, s || (k = r.onContinue) == null || k.call(r);
  }), "pause"), x = /* @__PURE__ */ c(() => {
    if (s)
      return;
    let k;
    const S = i === 0 ? r.initialPromise : void 0;
    try {
      k = S ?? r.fn();
    } catch (P) {
      k = Promise.reject(P);
    }
    Promise.resolve(k).then(m).catch((P) => {
      var V;
      if (s)
        return;
      const E = r.retry ?? (qa ? 0 : 3), z = r.retryDelay ?? Yf, U = typeof z == "function" ? z(i, P) : z, O = E === !0 || typeof E == "number" && i < E || typeof E == "function" && E(i, P);
      if (t || !O) {
        f(P);
        return;
      }
      i++, (V = r.onFail) == null || V.call(r, i, P), jf(U).then(() => u() ? void 0 : g()).then(() => {
        t ? f(P) : x();
      });
    });
  }, "run");
  return {
    promise: a,
    cancel: o,
    continue: /* @__PURE__ */ c(() => (n == null || n(), a), "continue"),
    cancelRetry: l,
    continueRetry: d,
    canStart: y,
    start: /* @__PURE__ */ c(() => (y() ? x() : g().then(x), a), "start")
  };
}
c(my, "createRetryer");
function Zf() {
  let r = [], t = 0, i = /* @__PURE__ */ c((l) => {
    l();
  }, "notifyFn"), s = /* @__PURE__ */ c((l) => {
    l();
  }, "batchNotifyFn"), n = /* @__PURE__ */ c((l) => setTimeout(l, 0), "scheduleFn");
  const a = /* @__PURE__ */ c((l) => {
    t ? r.push(l) : n(() => {
      i(l);
    });
  }, "schedule"), o = /* @__PURE__ */ c(() => {
    const l = r;
    r = [], l.length && n(() => {
      s(() => {
        l.forEach((d) => {
          i(d);
        });
      });
    });
  }, "flush");
  return {
    batch: /* @__PURE__ */ c((l) => {
      let d;
      t++;
      try {
        d = l();
      } finally {
        t--, t || o();
      }
      return d;
    }, "batch"),
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: /* @__PURE__ */ c((l) => (...d) => {
      a(() => {
        l(...d);
      });
    }, "batchCalls"),
    schedule: a,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: /* @__PURE__ */ c((l) => {
      i = l;
    }, "setNotifyFunction"),
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: /* @__PURE__ */ c((l) => {
      s = l;
    }, "setBatchNotifyFunction"),
    setScheduler: /* @__PURE__ */ c((l) => {
      n = l;
    }, "setScheduler")
  };
}
c(Zf, "createNotifyManager");
var ae = Zf(), zs, Hr, vy = (Hr = class {
  constructor() {
    T(this, zs);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), Ad(this.gcTime) && I(this, zs, setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t ?? (qa ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    b(this, zs) && (clearTimeout(b(this, zs)), I(this, zs, void 0));
  }
}, zs = new WeakMap(), c(Hr, "Removable"), Hr), Vr, Br, He, ue, Qo, Ss, Qe, Mi, Ur, Xf = (Ur = class extends vy {
  constructor(i) {
    super();
    T(this, Qe);
    T(this, Vr);
    T(this, Br);
    T(this, He);
    T(this, ue);
    T(this, Qo);
    T(this, Ss);
    I(this, Ss, !1), I(this, Qo, i.defaultOptions), this.setOptions(i.options), this.observers = [], I(this, He, i.cache), this.queryKey = i.queryKey, this.queryHash = i.queryHash, I(this, Vr, Jf(this.options)), this.state = i.state ?? b(this, Vr), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var i;
    return (i = b(this, ue)) == null ? void 0 : i.promise;
  }
  setOptions(i) {
    this.options = { ...b(this, Qo), ...i }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && b(this, He).remove(this);
  }
  setData(i, s) {
    const n = Rd(this.state.data, i, this.options);
    return tt(this, Qe, Mi).call(this, {
      data: n,
      type: "success",
      dataUpdatedAt: s == null ? void 0 : s.updatedAt,
      manual: s == null ? void 0 : s.manual
    }), n;
  }
  setState(i, s) {
    tt(this, Qe, Mi).call(this, { type: "setState", state: i, setStateOptions: s });
  }
  cancel(i) {
    var n, a;
    const s = (n = b(this, ue)) == null ? void 0 : n.promise;
    return (a = b(this, ue)) == null || a.cancel(i), s ? s.then(Ve).catch(Ve) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(b(this, Vr));
  }
  isActive() {
    return this.observers.some(
      (i) => Ge(i.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === Sh || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStale() {
    return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some(
      (i) => i.getCurrentResult().isStale
    ) : this.state.data === void 0;
  }
  isStaleByTime(i = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !uy(this.state.dataUpdatedAt, i);
  }
  onFocus() {
    var s;
    const i = this.observers.find((n) => n.shouldFetchOnWindowFocus());
    i == null || i.refetch({ cancelRefetch: !1 }), (s = b(this, ue)) == null || s.continue();
  }
  onOnline() {
    var s;
    const i = this.observers.find((n) => n.shouldFetchOnReconnect());
    i == null || i.refetch({ cancelRefetch: !1 }), (s = b(this, ue)) == null || s.continue();
  }
  addObserver(i) {
    this.observers.includes(i) || (this.observers.push(i), this.clearGcTimeout(), b(this, He).notify({ type: "observerAdded", query: this, observer: i }));
  }
  removeObserver(i) {
    this.observers.includes(i) && (this.observers = this.observers.filter((s) => s !== i), this.observers.length || (b(this, ue) && (b(this, Ss) ? b(this, ue).cancel({ revert: !0 }) : b(this, ue).cancelRetry()), this.scheduleGc()), b(this, He).notify({ type: "observerRemoved", query: this, observer: i }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || tt(this, Qe, Mi).call(this, { type: "invalidate" });
  }
  fetch(i, s) {
    var u, y, m;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (s != null && s.cancelRefetch))
        this.cancel({ silent: !0 });
      else if (b(this, ue))
        return b(this, ue).continueRetry(), b(this, ue).promise;
    }
    if (i && this.setOptions(i), !this.options.queryFn) {
      const f = this.observers.find((g) => g.options.queryFn);
      f && this.setOptions(f.options);
    }
    const n = new AbortController(), a = /* @__PURE__ */ c((f) => {
      Object.defineProperty(f, "signal", {
        enumerable: !0,
        get: /* @__PURE__ */ c(() => (I(this, Ss, !0), n.signal), "get")
      });
    }, "addSignalProperty"), o = /* @__PURE__ */ c(() => {
      const f = yy(this.options, s), g = {
        queryKey: this.queryKey,
        meta: this.meta
      };
      return a(g), I(this, Ss, !1), this.options.persister ? this.options.persister(
        f,
        g,
        this
      ) : f(g);
    }, "fetchFn"), l = {
      fetchOptions: s,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn: o
    };
    a(l), (u = this.options.behavior) == null || u.onFetch(
      l,
      this
    ), I(this, Br, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((y = l.fetchOptions) == null ? void 0 : y.meta)) && tt(this, Qe, Mi).call(this, { type: "fetch", meta: (m = l.fetchOptions) == null ? void 0 : m.meta });
    const d = /* @__PURE__ */ c((f) => {
      var g, x, k, S;
      xd(f) && f.silent || tt(this, Qe, Mi).call(this, {
        type: "error",
        error: f
      }), xd(f) || ((x = (g = b(this, He).config).onError) == null || x.call(
        g,
        f,
        this
      ), (S = (k = b(this, He).config).onSettled) == null || S.call(
        k,
        this.state.data,
        f,
        this
      )), this.scheduleGc();
    }, "onError");
    return I(this, ue, my({
      initialPromise: s == null ? void 0 : s.initialPromise,
      fn: l.fetchFn,
      abort: n.abort.bind(n),
      onSuccess: /* @__PURE__ */ c((f) => {
        var g, x, k, S;
        if (f === void 0) {
          d(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(f);
        } catch (P) {
          d(P);
          return;
        }
        (x = (g = b(this, He).config).onSuccess) == null || x.call(g, f, this), (S = (k = b(this, He).config).onSettled) == null || S.call(
          k,
          f,
          this.state.error,
          this
        ), this.scheduleGc();
      }, "onSuccess"),
      onError: d,
      onFail: /* @__PURE__ */ c((f, g) => {
        tt(this, Qe, Mi).call(this, { type: "failed", failureCount: f, error: g });
      }, "onFail"),
      onPause: /* @__PURE__ */ c(() => {
        tt(this, Qe, Mi).call(this, { type: "pause" });
      }, "onPause"),
      onContinue: /* @__PURE__ */ c(() => {
        tt(this, Qe, Mi).call(this, { type: "continue" });
      }, "onContinue"),
      retry: l.options.retry,
      retryDelay: l.options.retryDelay,
      networkMode: l.options.networkMode,
      canRun: /* @__PURE__ */ c(() => !0, "canRun")
    })), b(this, ue).start();
  }
}, Vr = new WeakMap(), Br = new WeakMap(), He = new WeakMap(), ue = new WeakMap(), Qo = new WeakMap(), Ss = new WeakMap(), Qe = new WeakSet(), Mi = /* @__PURE__ */ c(function(i) {
  const s = /* @__PURE__ */ c((n) => {
    switch (i.type) {
      case "failed":
        return {
          ...n,
          fetchFailureCount: i.failureCount,
          fetchFailureReason: i.error
        };
      case "pause":
        return {
          ...n,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...n,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...n,
          ...gy(n.data, this.options),
          fetchMeta: i.meta ?? null
        };
      case "success":
        return {
          ...n,
          data: i.data,
          dataUpdateCount: n.dataUpdateCount + 1,
          dataUpdatedAt: i.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: !1,
          status: "success",
          ...!i.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const a = i.error;
        return xd(a) && a.revert && b(this, Br) ? { ...b(this, Br), fetchStatus: "idle" } : {
          ...n,
          error: a,
          errorUpdateCount: n.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: n.fetchFailureCount + 1,
          fetchFailureReason: a,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...n,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...n,
          ...i.state
        };
    }
  }, "reducer");
  this.state = s(this.state), ae.batch(() => {
    this.observers.forEach((n) => {
      n.onQueryUpdate();
    }), b(this, He).notify({ query: this, type: "updated", action: i });
  });
}, "#dispatch"), c(Ur, "Query"), Ur);
function gy(r, t) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: wy(t.networkMode) ? "fetching" : "paused",
    ...r === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
c(gy, "fetchState");
function Jf(r) {
  const t = typeof r.initialData == "function" ? r.initialData() : r.initialData, i = t !== void 0, s = i ? typeof r.initialDataUpdatedAt == "function" ? r.initialDataUpdatedAt() : r.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: i ? s ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: i ? "success" : "pending",
    fetchStatus: "idle"
  };
}
c(Jf, "getDefaultState$1");
var ci, qr, t1 = (qr = class extends co {
  constructor(i = {}) {
    super();
    T(this, ci);
    this.config = i, I(this, ci, /* @__PURE__ */ new Map());
  }
  build(i, s, n) {
    const a = s.queryKey, o = s.queryHash ?? zh(a, s);
    let l = this.get(o);
    return l || (l = new Xf({
      cache: this,
      queryKey: a,
      queryHash: o,
      options: i.defaultQueryOptions(s),
      state: n,
      defaultOptions: i.getQueryDefaults(a)
    }), this.add(l)), l;
  }
  add(i) {
    b(this, ci).has(i.queryHash) || (b(this, ci).set(i.queryHash, i), this.notify({
      type: "added",
      query: i
    }));
  }
  remove(i) {
    const s = b(this, ci).get(i.queryHash);
    s && (i.destroy(), s === i && b(this, ci).delete(i.queryHash), this.notify({ type: "removed", query: i }));
  }
  clear() {
    ae.batch(() => {
      this.getAll().forEach((i) => {
        this.remove(i);
      });
    });
  }
  get(i) {
    return b(this, ci).get(i);
  }
  getAll() {
    return [...b(this, ci).values()];
  }
  find(i) {
    const s = { exact: !0, ...i };
    return this.getAll().find(
      (n) => Qp(s, n)
    );
  }
  findAll(i = {}) {
    const s = this.getAll();
    return Object.keys(i).length > 0 ? s.filter((n) => Qp(i, n)) : s;
  }
  notify(i) {
    ae.batch(() => {
      this.listeners.forEach((s) => {
        s(i);
      });
    });
  }
  onFocus() {
    ae.batch(() => {
      this.getAll().forEach((i) => {
        i.onFocus();
      });
    });
  }
  onOnline() {
    ae.batch(() => {
      this.getAll().forEach((i) => {
        i.onOnline();
      });
    });
  }
}, ci = new WeakMap(), c(qr, "QueryCache"), qr), li, ve, Es, di, ji, Nr, e1 = (Nr = class extends vy {
  constructor(i) {
    super();
    T(this, di);
    T(this, li);
    T(this, ve);
    T(this, Es);
    this.mutationId = i.mutationId, I(this, ve, i.mutationCache), I(this, li, []), this.state = i.state || by(), this.setOptions(i.options), this.scheduleGc();
  }
  setOptions(i) {
    this.options = i, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(i) {
    b(this, li).includes(i) || (b(this, li).push(i), this.clearGcTimeout(), b(this, ve).notify({
      type: "observerAdded",
      mutation: this,
      observer: i
    }));
  }
  removeObserver(i) {
    I(this, li, b(this, li).filter((s) => s !== i)), this.scheduleGc(), b(this, ve).notify({
      type: "observerRemoved",
      mutation: this,
      observer: i
    });
  }
  optionalRemove() {
    b(this, li).length || (this.state.status === "pending" ? this.scheduleGc() : b(this, ve).remove(this));
  }
  continue() {
    var i;
    return ((i = b(this, Es)) == null ? void 0 : i.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(i) {
    var a, o, l, d, u, y, m, f, g, x, k, S, P, E, z, U, O, V, q, N;
    I(this, Es, my({
      fn: /* @__PURE__ */ c(() => this.options.mutationFn ? this.options.mutationFn(i) : Promise.reject(new Error("No mutationFn found")), "fn"),
      onFail: /* @__PURE__ */ c((H, W) => {
        tt(this, di, ji).call(this, { type: "failed", failureCount: H, error: W });
      }, "onFail"),
      onPause: /* @__PURE__ */ c(() => {
        tt(this, di, ji).call(this, { type: "pause" });
      }, "onPause"),
      onContinue: /* @__PURE__ */ c(() => {
        tt(this, di, ji).call(this, { type: "continue" });
      }, "onContinue"),
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: /* @__PURE__ */ c(() => b(this, ve).canRun(this), "canRun")
    }));
    const s = this.state.status === "pending", n = !b(this, Es).canStart();
    try {
      if (!s) {
        tt(this, di, ji).call(this, { type: "pending", variables: i, isPaused: n }), await ((o = (a = b(this, ve).config).onMutate) == null ? void 0 : o.call(
          a,
          i,
          this
        ));
        const W = await ((d = (l = this.options).onMutate) == null ? void 0 : d.call(l, i));
        W !== this.state.context && tt(this, di, ji).call(this, {
          type: "pending",
          context: W,
          variables: i,
          isPaused: n
        });
      }
      const H = await b(this, Es).start();
      return await ((y = (u = b(this, ve).config).onSuccess) == null ? void 0 : y.call(
        u,
        H,
        i,
        this.state.context,
        this
      )), await ((f = (m = this.options).onSuccess) == null ? void 0 : f.call(m, H, i, this.state.context)), await ((x = (g = b(this, ve).config).onSettled) == null ? void 0 : x.call(
        g,
        H,
        null,
        this.state.variables,
        this.state.context,
        this
      )), await ((S = (k = this.options).onSettled) == null ? void 0 : S.call(k, H, null, i, this.state.context)), tt(this, di, ji).call(this, { type: "success", data: H }), H;
    } catch (H) {
      try {
        throw await ((E = (P = b(this, ve).config).onError) == null ? void 0 : E.call(
          P,
          H,
          i,
          this.state.context,
          this
        )), await ((U = (z = this.options).onError) == null ? void 0 : U.call(
          z,
          H,
          i,
          this.state.context
        )), await ((V = (O = b(this, ve).config).onSettled) == null ? void 0 : V.call(
          O,
          void 0,
          H,
          this.state.variables,
          this.state.context,
          this
        )), await ((N = (q = this.options).onSettled) == null ? void 0 : N.call(
          q,
          void 0,
          H,
          i,
          this.state.context
        )), H;
      } finally {
        tt(this, di, ji).call(this, { type: "error", error: H });
      }
    } finally {
      b(this, ve).runNext(this);
    }
  }
}, li = new WeakMap(), ve = new WeakMap(), Es = new WeakMap(), di = new WeakSet(), ji = /* @__PURE__ */ c(function(i) {
  const s = /* @__PURE__ */ c((n) => {
    switch (i.type) {
      case "failed":
        return {
          ...n,
          failureCount: i.failureCount,
          failureReason: i.error
        };
      case "pause":
        return {
          ...n,
          isPaused: !0
        };
      case "continue":
        return {
          ...n,
          isPaused: !1
        };
      case "pending":
        return {
          ...n,
          context: i.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: i.isPaused,
          status: "pending",
          variables: i.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...n,
          data: i.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...n,
          data: void 0,
          error: i.error,
          failureCount: n.failureCount + 1,
          failureReason: i.error,
          isPaused: !1,
          status: "error"
        };
    }
  }, "reducer");
  this.state = s(this.state), ae.batch(() => {
    b(this, li).forEach((n) => {
      n.onMutationUpdate(i);
    }), b(this, ve).notify({
      mutation: this,
      type: "updated",
      action: i
    });
  });
}, "#dispatch"), c(Nr, "Mutation"), Nr);
function by() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
c(by, "getDefaultState");
var zi, Ke, Ko, jr, i1 = (jr = class extends co {
  constructor(i = {}) {
    super();
    T(this, zi);
    T(this, Ke);
    T(this, Ko);
    this.config = i, I(this, zi, /* @__PURE__ */ new Set()), I(this, Ke, /* @__PURE__ */ new Map()), I(this, Ko, 0);
  }
  build(i, s, n) {
    const a = new e1({
      mutationCache: this,
      mutationId: ++Pc(this, Ko)._,
      options: i.defaultMutationOptions(s),
      state: n
    });
    return this.add(a), a;
  }
  add(i) {
    b(this, zi).add(i);
    const s = Mc(i);
    if (typeof s == "string") {
      const n = b(this, Ke).get(s);
      n ? n.push(i) : b(this, Ke).set(s, [i]);
    }
    this.notify({ type: "added", mutation: i });
  }
  remove(i) {
    if (b(this, zi).delete(i)) {
      const s = Mc(i);
      if (typeof s == "string") {
        const n = b(this, Ke).get(s);
        if (n)
          if (n.length > 1) {
            const a = n.indexOf(i);
            a !== -1 && n.splice(a, 1);
          } else n[0] === i && b(this, Ke).delete(s);
      }
    }
    this.notify({ type: "removed", mutation: i });
  }
  canRun(i) {
    const s = Mc(i);
    if (typeof s == "string") {
      const n = b(this, Ke).get(s), a = n == null ? void 0 : n.find(
        (o) => o.state.status === "pending"
      );
      return !a || a === i;
    } else
      return !0;
  }
  runNext(i) {
    var n;
    const s = Mc(i);
    if (typeof s == "string") {
      const a = (n = b(this, Ke).get(s)) == null ? void 0 : n.find((o) => o !== i && o.state.isPaused);
      return (a == null ? void 0 : a.continue()) ?? Promise.resolve();
    } else
      return Promise.resolve();
  }
  clear() {
    ae.batch(() => {
      b(this, zi).forEach((i) => {
        this.notify({ type: "removed", mutation: i });
      }), b(this, zi).clear(), b(this, Ke).clear();
    });
  }
  getAll() {
    return Array.from(b(this, zi));
  }
  find(i) {
    const s = { exact: !0, ...i };
    return this.getAll().find(
      (n) => Kp(s, n)
    );
  }
  findAll(i = {}) {
    return this.getAll().filter((s) => Kp(i, s));
  }
  notify(i) {
    ae.batch(() => {
      this.listeners.forEach((s) => {
        s(i);
      });
    });
  }
  resumePausedMutations() {
    const i = this.getAll().filter((s) => s.state.isPaused);
    return ae.batch(
      () => Promise.all(
        i.map((s) => s.continue().catch(Ve))
      )
    );
  }
}, zi = new WeakMap(), Ke = new WeakMap(), Ko = new WeakMap(), c(jr, "MutationCache"), jr);
function Mc(r) {
  var t;
  return (t = r.options.scope) == null ? void 0 : t.id;
}
c(Mc, "scopeFor");
function Fc(r) {
  return {
    onFetch: /* @__PURE__ */ c((t, i) => {
      var y, m, f, g, x;
      const s = t.options, n = (f = (m = (y = t.fetchOptions) == null ? void 0 : y.meta) == null ? void 0 : m.fetchMore) == null ? void 0 : f.direction, a = ((g = t.state.data) == null ? void 0 : g.pages) || [], o = ((x = t.state.data) == null ? void 0 : x.pageParams) || [];
      let l = { pages: [], pageParams: [] }, d = 0;
      const u = /* @__PURE__ */ c(async () => {
        let k = !1;
        const S = /* @__PURE__ */ c((z) => {
          Object.defineProperty(z, "signal", {
            enumerable: !0,
            get: /* @__PURE__ */ c(() => (t.signal.aborted ? k = !0 : t.signal.addEventListener("abort", () => {
              k = !0;
            }), t.signal), "get")
          });
        }, "addSignalProperty"), P = yy(t.options, t.fetchOptions), E = /* @__PURE__ */ c(async (z, U, O) => {
          if (k)
            return Promise.reject();
          if (U == null && z.pages.length)
            return Promise.resolve(z);
          const V = {
            queryKey: t.queryKey,
            pageParam: U,
            direction: O ? "backward" : "forward",
            meta: t.options.meta
          };
          S(V);
          const q = await P(
            V
          ), { maxPages: N } = t.options, H = O ? Qf : Wf;
          return {
            pages: H(z.pages, q, N),
            pageParams: H(z.pageParams, U, N)
          };
        }, "fetchPage");
        if (n && a.length) {
          const z = n === "backward", U = z ? xy : Td, O = {
            pages: a,
            pageParams: o
          }, V = U(s, O);
          l = await E(O, V, z);
        } else {
          const z = r ?? a.length;
          do {
            const U = d === 0 ? o[0] ?? s.initialPageParam : Td(s, l);
            if (d > 0 && U == null)
              break;
            l = await E(l, U), d++;
          } while (d < z);
        }
        return l;
      }, "fetchFn");
      t.options.persister ? t.fetchFn = () => {
        var k, S;
        return (S = (k = t.options).persister) == null ? void 0 : S.call(
          k,
          u,
          {
            queryKey: t.queryKey,
            meta: t.options.meta,
            signal: t.signal
          },
          i
        );
      } : t.fetchFn = u;
    }, "onFetch")
  };
}
c(Fc, "infiniteQueryBehavior");
function Td(r, { pages: t, pageParams: i }) {
  const s = t.length - 1;
  return t.length > 0 ? r.getNextPageParam(
    t[s],
    t,
    i[s],
    i
  ) : void 0;
}
c(Td, "getNextPageParam");
function xy(r, { pages: t, pageParams: i }) {
  var s;
  return t.length > 0 ? (s = r.getPreviousPageParam) == null ? void 0 : s.call(r, t[0], t, i[0], i) : void 0;
}
c(xy, "getPreviousPageParam");
function s1(r, t) {
  return t ? Td(r, t) != null : !1;
}
c(s1, "hasNextPage");
function r1(r, t) {
  return !t || !r.getPreviousPageParam ? !1 : xy(r, t) != null;
}
c(r1, "hasPreviousPage");
var Ot, Yi, Zi, Wr, Qr, Xi, Kr, Gr, Yr, n1 = (Yr = class {
  constructor(t = {}) {
    T(this, Ot);
    T(this, Yi);
    T(this, Zi);
    T(this, Wr);
    T(this, Qr);
    T(this, Xi);
    T(this, Kr);
    T(this, Gr);
    I(this, Ot, t.queryCache || new t1()), I(this, Yi, t.mutationCache || new i1()), I(this, Zi, t.defaultOptions || {}), I(this, Wr, /* @__PURE__ */ new Map()), I(this, Qr, /* @__PURE__ */ new Map()), I(this, Xi, 0);
  }
  mount() {
    Pc(this, Xi)._++, b(this, Xi) === 1 && (I(this, Kr, Eh.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), b(this, Ot).onFocus());
    })), I(this, Gr, Tc.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), b(this, Ot).onOnline());
    })));
  }
  unmount() {
    var t, i;
    Pc(this, Xi)._--, b(this, Xi) === 0 && ((t = b(this, Kr)) == null || t.call(this), I(this, Kr, void 0), (i = b(this, Gr)) == null || i.call(this), I(this, Gr, void 0));
  }
  isFetching(t) {
    return b(this, Ot).findAll({ ...t, fetchStatus: "fetching" }).length;
  }
  isMutating(t) {
    return b(this, Yi).findAll({ ...t, status: "pending" }).length;
  }
  getQueryData(t) {
    var s;
    const i = this.defaultQueryOptions({ queryKey: t });
    return (s = b(this, Ot).get(i.queryHash)) == null ? void 0 : s.state.data;
  }
  ensureQueryData(t) {
    const i = this.defaultQueryOptions(t), s = b(this, Ot).build(this, i), n = s.state.data;
    return n === void 0 ? this.fetchQuery(t) : (t.revalidateIfStale && s.isStaleByTime(Sr(i.staleTime, s)) && this.prefetchQuery(i), Promise.resolve(n));
  }
  getQueriesData(t) {
    return b(this, Ot).findAll(t).map(({ queryKey: i, state: s }) => {
      const n = s.data;
      return [i, n];
    });
  }
  setQueryData(t, i, s) {
    const n = this.defaultQueryOptions({ queryKey: t }), a = b(this, Ot).get(
      n.queryHash
    ), o = a == null ? void 0 : a.state.data, l = Nf(i, o);
    if (l !== void 0)
      return b(this, Ot).build(this, n).setData(l, { ...s, manual: !0 });
  }
  setQueriesData(t, i, s) {
    return ae.batch(
      () => b(this, Ot).findAll(t).map(({ queryKey: n }) => [
        n,
        this.setQueryData(n, i, s)
      ])
    );
  }
  getQueryState(t) {
    var s;
    const i = this.defaultQueryOptions({ queryKey: t });
    return (s = b(this, Ot).get(
      i.queryHash
    )) == null ? void 0 : s.state;
  }
  removeQueries(t) {
    const i = b(this, Ot);
    ae.batch(() => {
      i.findAll(t).forEach((s) => {
        i.remove(s);
      });
    });
  }
  resetQueries(t, i) {
    const s = b(this, Ot), n = {
      type: "active",
      ...t
    };
    return ae.batch(() => (s.findAll(t).forEach((a) => {
      a.reset();
    }), this.refetchQueries(n, i)));
  }
  cancelQueries(t, i = {}) {
    const s = { revert: !0, ...i }, n = ae.batch(
      () => b(this, Ot).findAll(t).map((a) => a.cancel(s))
    );
    return Promise.all(n).then(Ve).catch(Ve);
  }
  invalidateQueries(t, i = {}) {
    return ae.batch(() => {
      if (b(this, Ot).findAll(t).forEach((n) => {
        n.invalidate();
      }), (t == null ? void 0 : t.refetchType) === "none")
        return Promise.resolve();
      const s = {
        ...t,
        type: (t == null ? void 0 : t.refetchType) ?? (t == null ? void 0 : t.type) ?? "active"
      };
      return this.refetchQueries(s, i);
    });
  }
  refetchQueries(t, i = {}) {
    const s = {
      ...i,
      cancelRefetch: i.cancelRefetch ?? !0
    }, n = ae.batch(
      () => b(this, Ot).findAll(t).filter((a) => !a.isDisabled()).map((a) => {
        let o = a.fetch(void 0, s);
        return s.throwOnError || (o = o.catch(Ve)), a.state.fetchStatus === "paused" ? Promise.resolve() : o;
      })
    );
    return Promise.all(n).then(Ve);
  }
  fetchQuery(t) {
    const i = this.defaultQueryOptions(t);
    i.retry === void 0 && (i.retry = !1);
    const s = b(this, Ot).build(this, i);
    return s.isStaleByTime(
      Sr(i.staleTime, s)
    ) ? s.fetch(i) : Promise.resolve(s.state.data);
  }
  prefetchQuery(t) {
    return this.fetchQuery(t).then(Ve).catch(Ve);
  }
  fetchInfiniteQuery(t) {
    return t.behavior = Fc(t.pages), this.fetchQuery(t);
  }
  prefetchInfiniteQuery(t) {
    return this.fetchInfiniteQuery(t).then(Ve).catch(Ve);
  }
  ensureInfiniteQueryData(t) {
    return t.behavior = Fc(t.pages), this.ensureQueryData(t);
  }
  resumePausedMutations() {
    return Tc.isOnline() ? b(this, Yi).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return b(this, Ot);
  }
  getMutationCache() {
    return b(this, Yi);
  }
  getDefaultOptions() {
    return b(this, Zi);
  }
  setDefaultOptions(t) {
    I(this, Zi, t);
  }
  setQueryDefaults(t, i) {
    b(this, Wr).set(Vs(t), {
      queryKey: t,
      defaultOptions: i
    });
  }
  getQueryDefaults(t) {
    const i = [...b(this, Wr).values()], s = {};
    return i.forEach((n) => {
      Eo(t, n.queryKey) && Object.assign(s, n.defaultOptions);
    }), s;
  }
  setMutationDefaults(t, i) {
    b(this, Qr).set(Vs(t), {
      mutationKey: t,
      defaultOptions: i
    });
  }
  getMutationDefaults(t) {
    const i = [...b(this, Qr).values()];
    let s = {};
    return i.forEach((n) => {
      Eo(t, n.mutationKey) && (s = { ...s, ...n.defaultOptions });
    }), s;
  }
  defaultQueryOptions(t) {
    if (t._defaulted)
      return t;
    const i = {
      ...b(this, Zi).queries,
      ...this.getQueryDefaults(t.queryKey),
      ...t,
      _defaulted: !0
    };
    return i.queryHash || (i.queryHash = zh(
      i.queryKey,
      i
    )), i.refetchOnReconnect === void 0 && (i.refetchOnReconnect = i.networkMode !== "always"), i.throwOnError === void 0 && (i.throwOnError = !!i.suspense), !i.networkMode && i.persister && (i.networkMode = "offlineFirst"), i.queryFn === Sh && (i.enabled = !1), i;
  }
  defaultMutationOptions(t) {
    return t != null && t._defaulted ? t : {
      ...b(this, Zi).mutations,
      ...(t == null ? void 0 : t.mutationKey) && this.getMutationDefaults(t.mutationKey),
      ...t,
      _defaulted: !0
    };
  }
  clear() {
    b(this, Ot).clear(), b(this, Yi).clear();
  }
}, Ot = new WeakMap(), Yi = new WeakMap(), Zi = new WeakMap(), Wr = new WeakMap(), Qr = new WeakMap(), Xi = new WeakMap(), Kr = new WeakMap(), Gr = new WeakMap(), c(Yr, "QueryClient"), Yr), Pe, ht, Go, ge, Os, Zr, Ji, hi, Yo, Xr, Jr, As, Ls, ts, tn, mt, $o, Fd, Dd, Hd, Vd, Bd, Ud, qd, ky, en, $y = (en = class extends co {
  constructor(i, s) {
    super();
    T(this, mt);
    T(this, Pe);
    T(this, ht);
    T(this, Go);
    T(this, ge);
    T(this, Os);
    T(this, Zr);
    T(this, Ji);
    T(this, hi);
    T(this, Yo);
    T(this, Xr);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    T(this, Jr);
    T(this, As);
    T(this, Ls);
    T(this, ts);
    T(this, tn, /* @__PURE__ */ new Set());
    this.options = s, I(this, Pe, i), I(this, hi, null), I(this, Ji, Id()), this.options.experimental_prefetchInRender || b(this, Ji).reject(
      new Error("experimental_prefetchInRender feature flag is not enabled")
    ), this.bindMethods(), this.setOptions(s);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (b(this, ht).addObserver(this), Zp(b(this, ht), this.options) ? tt(this, mt, $o).call(this) : this.updateResult(), tt(this, mt, Vd).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return Nd(
      b(this, ht),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return Nd(
      b(this, ht),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), tt(this, mt, Bd).call(this), tt(this, mt, Ud).call(this), b(this, ht).removeObserver(this);
  }
  setOptions(i, s) {
    const n = this.options, a = b(this, ht);
    if (this.options = b(this, Pe).defaultQueryOptions(i), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof Ge(this.options.enabled, b(this, ht)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    tt(this, mt, qd).call(this), b(this, ht).setOptions(this.options), n._defaulted && !Ic(this.options, n) && b(this, Pe).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: b(this, ht),
      observer: this
    });
    const o = this.hasListeners();
    o && Xp(
      b(this, ht),
      a,
      this.options,
      n
    ) && tt(this, mt, $o).call(this), this.updateResult(s), o && (b(this, ht) !== a || Ge(this.options.enabled, b(this, ht)) !== Ge(n.enabled, b(this, ht)) || Sr(this.options.staleTime, b(this, ht)) !== Sr(n.staleTime, b(this, ht))) && tt(this, mt, Fd).call(this);
    const l = tt(this, mt, Dd).call(this);
    o && (b(this, ht) !== a || Ge(this.options.enabled, b(this, ht)) !== Ge(n.enabled, b(this, ht)) || l !== b(this, ts)) && tt(this, mt, Hd).call(this, l);
  }
  getOptimisticResult(i) {
    const s = b(this, Pe).getQueryCache().build(b(this, Pe), i), n = this.createResult(s, i);
    return o1(this, n) && (I(this, ge, n), I(this, Zr, this.options), I(this, Os, b(this, ht).state)), n;
  }
  getCurrentResult() {
    return b(this, ge);
  }
  trackResult(i, s) {
    const n = {};
    return Object.keys(i).forEach((a) => {
      Object.defineProperty(n, a, {
        configurable: !1,
        enumerable: !0,
        get: /* @__PURE__ */ c(() => (this.trackProp(a), s == null || s(a), i[a]), "get")
      });
    }), n;
  }
  trackProp(i) {
    b(this, tn).add(i);
  }
  getCurrentQuery() {
    return b(this, ht);
  }
  refetch({ ...i } = {}) {
    return this.fetch({
      ...i
    });
  }
  fetchOptimistic(i) {
    const s = b(this, Pe).defaultQueryOptions(i), n = b(this, Pe).getQueryCache().build(b(this, Pe), s);
    return n.fetch().then(() => this.createResult(n, s));
  }
  fetch(i) {
    return tt(this, mt, $o).call(this, {
      ...i,
      cancelRefetch: i.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), b(this, ge)));
  }
  createResult(i, s) {
    var H;
    const n = b(this, ht), a = this.options, o = b(this, ge), l = b(this, Os), d = b(this, Zr), y = i !== n ? i.state : b(this, Go), { state: m } = i;
    let f = { ...m }, g = !1, x;
    if (s._optimisticResults) {
      const W = this.hasListeners(), ft = !W && Zp(i, s), wt = W && Xp(i, n, s, a);
      (ft || wt) && (f = {
        ...f,
        ...gy(m.data, i.options)
      }), s._optimisticResults === "isRestoring" && (f.fetchStatus = "idle");
    }
    let { error: k, errorUpdatedAt: S, status: P } = f;
    if (s.select && f.data !== void 0)
      if (o && f.data === (l == null ? void 0 : l.data) && s.select === b(this, Yo))
        x = b(this, Xr);
      else
        try {
          I(this, Yo, s.select), x = s.select(f.data), x = Rd(o == null ? void 0 : o.data, x, s), I(this, Xr, x), I(this, hi, null);
        } catch (W) {
          I(this, hi, W);
        }
    else
      x = f.data;
    if (s.placeholderData !== void 0 && x === void 0 && P === "pending") {
      let W;
      if (o != null && o.isPlaceholderData && s.placeholderData === (d == null ? void 0 : d.placeholderData))
        W = o.data;
      else if (W = typeof s.placeholderData == "function" ? s.placeholderData(
        (H = b(this, Jr)) == null ? void 0 : H.state.data,
        b(this, Jr)
      ) : s.placeholderData, s.select && W !== void 0)
        try {
          W = s.select(W), I(this, hi, null);
        } catch (ft) {
          I(this, hi, ft);
        }
      W !== void 0 && (P = "success", x = Rd(
        o == null ? void 0 : o.data,
        W,
        s
      ), g = !0);
    }
    b(this, hi) && (k = b(this, hi), x = b(this, Xr), S = Date.now(), P = "error");
    const E = f.fetchStatus === "fetching", z = P === "pending", U = P === "error", O = z && E, V = x !== void 0, N = {
      status: P,
      fetchStatus: f.fetchStatus,
      isPending: z,
      isSuccess: P === "success",
      isError: U,
      isInitialLoading: O,
      isLoading: O,
      data: x,
      dataUpdatedAt: f.dataUpdatedAt,
      error: k,
      errorUpdatedAt: S,
      failureCount: f.fetchFailureCount,
      failureReason: f.fetchFailureReason,
      errorUpdateCount: f.errorUpdateCount,
      isFetched: f.dataUpdateCount > 0 || f.errorUpdateCount > 0,
      isFetchedAfterMount: f.dataUpdateCount > y.dataUpdateCount || f.errorUpdateCount > y.errorUpdateCount,
      isFetching: E,
      isRefetching: E && !z,
      isLoadingError: U && !V,
      isPaused: f.fetchStatus === "paused",
      isPlaceholderData: g,
      isRefetchError: U && V,
      isStale: Oh(i, s),
      refetch: this.refetch,
      promise: b(this, Ji)
    };
    if (this.options.experimental_prefetchInRender) {
      const W = /* @__PURE__ */ c((ut) => {
        N.status === "error" ? ut.reject(N.error) : N.data !== void 0 && ut.resolve(N.data);
      }, "finalizeThenableIfPossible"), ft = /* @__PURE__ */ c(() => {
        const ut = I(this, Ji, N.promise = Id());
        W(ut);
      }, "recreateThenable"), wt = b(this, Ji);
      switch (wt.status) {
        case "pending":
          i.queryHash === n.queryHash && W(wt);
          break;
        case "fulfilled":
          (N.status === "error" || N.data !== wt.value) && ft();
          break;
        case "rejected":
          (N.status !== "error" || N.error !== wt.reason) && ft();
          break;
      }
    }
    return N;
  }
  updateResult(i) {
    const s = b(this, ge), n = this.createResult(b(this, ht), this.options);
    if (I(this, Os, b(this, ht).state), I(this, Zr, this.options), b(this, Os).data !== void 0 && I(this, Jr, b(this, ht)), Ic(n, s))
      return;
    I(this, ge, n);
    const a = {}, o = /* @__PURE__ */ c(() => {
      if (!s)
        return !0;
      const { notifyOnChangeProps: l } = this.options, d = typeof l == "function" ? l() : l;
      if (d === "all" || !d && !b(this, tn).size)
        return !0;
      const u = new Set(
        d ?? b(this, tn)
      );
      return this.options.throwOnError && u.add("error"), Object.keys(b(this, ge)).some((y) => {
        const m = y;
        return b(this, ge)[m] !== s[m] && u.has(m);
      });
    }, "shouldNotifyListeners");
    (i == null ? void 0 : i.listeners) !== !1 && o() && (a.listeners = !0), tt(this, mt, ky).call(this, { ...a, ...i });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && tt(this, mt, Vd).call(this);
  }
}, Pe = new WeakMap(), ht = new WeakMap(), Go = new WeakMap(), ge = new WeakMap(), Os = new WeakMap(), Zr = new WeakMap(), Ji = new WeakMap(), hi = new WeakMap(), Yo = new WeakMap(), Xr = new WeakMap(), Jr = new WeakMap(), As = new WeakMap(), Ls = new WeakMap(), ts = new WeakMap(), tn = new WeakMap(), mt = new WeakSet(), $o = /* @__PURE__ */ c(function(i) {
  tt(this, mt, qd).call(this);
  let s = b(this, ht).fetch(
    this.options,
    i
  );
  return i != null && i.throwOnError || (s = s.catch(Ve)), s;
}, "#executeFetch"), Fd = /* @__PURE__ */ c(function() {
  tt(this, mt, Bd).call(this);
  const i = Sr(
    this.options.staleTime,
    b(this, ht)
  );
  if (qa || b(this, ge).isStale || !Ad(i))
    return;
  const n = uy(b(this, ge).dataUpdatedAt, i) + 1;
  I(this, As, setTimeout(() => {
    b(this, ge).isStale || this.updateResult();
  }, n));
}, "#updateStaleTimeout"), Dd = /* @__PURE__ */ c(function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(b(this, ht)) : this.options.refetchInterval) ?? !1;
}, "#computeRefetchInterval"), Hd = /* @__PURE__ */ c(function(i) {
  tt(this, mt, Ud).call(this), I(this, ts, i), !(qa || Ge(this.options.enabled, b(this, ht)) === !1 || !Ad(b(this, ts)) || b(this, ts) === 0) && I(this, Ls, setInterval(() => {
    (this.options.refetchIntervalInBackground || Eh.isFocused()) && tt(this, mt, $o).call(this);
  }, b(this, ts)));
}, "#updateRefetchInterval"), Vd = /* @__PURE__ */ c(function() {
  tt(this, mt, Fd).call(this), tt(this, mt, Hd).call(this, tt(this, mt, Dd).call(this));
}, "#updateTimers"), Bd = /* @__PURE__ */ c(function() {
  b(this, As) && (clearTimeout(b(this, As)), I(this, As, void 0));
}, "#clearStaleTimeout"), Ud = /* @__PURE__ */ c(function() {
  b(this, Ls) && (clearInterval(b(this, Ls)), I(this, Ls, void 0));
}, "#clearRefetchInterval"), qd = /* @__PURE__ */ c(function() {
  const i = b(this, Pe).getQueryCache().build(b(this, Pe), this.options);
  if (i === b(this, ht))
    return;
  const s = b(this, ht);
  I(this, ht, i), I(this, Go, i.state), this.hasListeners() && (s == null || s.removeObserver(this), i.addObserver(this));
}, "#updateQuery"), ky = /* @__PURE__ */ c(function(i) {
  ae.batch(() => {
    i.listeners && this.listeners.forEach((s) => {
      s(b(this, ge));
    }), b(this, Pe).getQueryCache().notify({
      query: b(this, ht),
      type: "observerResultsUpdated"
    });
  });
}, "#notify"), c(en, "QueryObserver"), en);
function a1(r, t) {
  return Ge(t.enabled, r) !== !1 && r.state.data === void 0 && !(r.state.status === "error" && t.retryOnMount === !1);
}
c(a1, "shouldLoadOnMount");
function Zp(r, t) {
  return a1(r, t) || r.state.data !== void 0 && Nd(r, t, t.refetchOnMount);
}
c(Zp, "shouldFetchOnMount");
function Nd(r, t, i) {
  if (Ge(t.enabled, r) !== !1) {
    const s = typeof i == "function" ? i(r) : i;
    return s === "always" || s !== !1 && Oh(r, t);
  }
  return !1;
}
c(Nd, "shouldFetchOn");
function Xp(r, t, i, s) {
  return (r !== t || Ge(s.enabled, r) === !1) && (!i.suspense || r.state.status !== "error") && Oh(r, i);
}
c(Xp, "shouldFetchOptionally");
function Oh(r, t) {
  return Ge(t.enabled, r) !== !1 && r.isStaleByTime(Sr(t.staleTime, r));
}
c(Oh, "isStale");
function o1(r, t) {
  return !Ic(r.getCurrentResult(), t);
}
c(o1, "shouldAssignObserverCurrentProperties");
var sn, c1 = (sn = class extends $y {
  constructor(t, i) {
    super(t, i);
  }
  bindMethods() {
    super.bindMethods(), this.fetchNextPage = this.fetchNextPage.bind(this), this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
  }
  setOptions(t, i) {
    super.setOptions(
      {
        ...t,
        behavior: Fc()
      },
      i
    );
  }
  getOptimisticResult(t) {
    return t.behavior = Fc(), super.getOptimisticResult(t);
  }
  fetchNextPage(t) {
    return this.fetch({
      ...t,
      meta: {
        fetchMore: { direction: "forward" }
      }
    });
  }
  fetchPreviousPage(t) {
    return this.fetch({
      ...t,
      meta: {
        fetchMore: { direction: "backward" }
      }
    });
  }
  createResult(t, i) {
    var k, S;
    const { state: s } = t, n = super.createResult(t, i), { isFetching: a, isRefetching: o, isError: l, isRefetchError: d } = n, u = (S = (k = s.fetchMeta) == null ? void 0 : k.fetchMore) == null ? void 0 : S.direction, y = l && u === "forward", m = a && u === "forward", f = l && u === "backward", g = a && u === "backward";
    return {
      ...n,
      fetchNextPage: this.fetchNextPage,
      fetchPreviousPage: this.fetchPreviousPage,
      hasNextPage: s1(i, s.data),
      hasPreviousPage: r1(i, s.data),
      isFetchNextPageError: y,
      isFetchingNextPage: m,
      isFetchPreviousPageError: f,
      isFetchingPreviousPage: g,
      isRefetchError: d && !y && !f,
      isRefetching: o && !m && !g
    };
  }
}, c(sn, "InfiniteQueryObserver"), sn), es, is, Me, Si, Li, Oc, jd, rn, bt = (rn = class extends co {
  constructor(i, s) {
    super();
    T(this, Li);
    T(this, es);
    T(this, is);
    T(this, Me);
    T(this, Si);
    I(this, es, i), this.setOptions(s), this.bindMethods(), tt(this, Li, Oc).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);
  }
  setOptions(i) {
    var n;
    const s = this.options;
    this.options = b(this, es).defaultMutationOptions(i), Ic(this.options, s) || b(this, es).getMutationCache().notify({
      type: "observerOptionsUpdated",
      mutation: b(this, Me),
      observer: this
    }), s != null && s.mutationKey && this.options.mutationKey && Vs(s.mutationKey) !== Vs(this.options.mutationKey) ? this.reset() : ((n = b(this, Me)) == null ? void 0 : n.state.status) === "pending" && b(this, Me).setOptions(this.options);
  }
  onUnsubscribe() {
    var i;
    this.hasListeners() || (i = b(this, Me)) == null || i.removeObserver(this);
  }
  onMutationUpdate(i) {
    tt(this, Li, Oc).call(this), tt(this, Li, jd).call(this, i);
  }
  getCurrentResult() {
    return b(this, is);
  }
  reset() {
    var i;
    (i = b(this, Me)) == null || i.removeObserver(this), I(this, Me, void 0), tt(this, Li, Oc).call(this), tt(this, Li, jd).call(this);
  }
  mutate(i, s) {
    var n;
    return I(this, Si, s), (n = b(this, Me)) == null || n.removeObserver(this), I(this, Me, b(this, es).getMutationCache().build(b(this, es), this.options)), b(this, Me).addObserver(this), b(this, Me).execute(i);
  }
}, es = new WeakMap(), is = new WeakMap(), Me = new WeakMap(), Si = new WeakMap(), Li = new WeakSet(), Oc = /* @__PURE__ */ c(function() {
  var s;
  const i = ((s = b(this, Me)) == null ? void 0 : s.state) ?? by();
  I(this, is, {
    ...i,
    isPending: i.status === "pending",
    isSuccess: i.status === "success",
    isError: i.status === "error",
    isIdle: i.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, "#updateResult"), jd = /* @__PURE__ */ c(function(i) {
  ae.batch(() => {
    var s, n, a, o, l, d, u, y;
    if (b(this, Si) && this.hasListeners()) {
      const m = b(this, is).variables, f = b(this, is).context;
      (i == null ? void 0 : i.type) === "success" ? ((n = (s = b(this, Si)).onSuccess) == null || n.call(s, i.data, m, f), (o = (a = b(this, Si)).onSettled) == null || o.call(a, i.data, null, m, f)) : (i == null ? void 0 : i.type) === "error" && ((d = (l = b(this, Si)).onError) == null || d.call(l, i.error, m, f), (y = (u = b(this, Si)).onSettled) == null || y.call(
        u,
        void 0,
        i.error,
        m,
        f
      ));
    }
    this.listeners.forEach((m) => {
      m(b(this, is));
    });
  });
}, "#notify"), c(rn, "MutationObserver"), rn);
function Cy(r) {
  return r;
}
c(Cy, "defaultTransformerFn");
function l1(r) {
  return {
    mutationKey: r.options.mutationKey,
    state: r.state,
    ...r.options.scope && { scope: r.options.scope },
    ...r.meta && { meta: r.meta }
  };
}
c(l1, "dehydrateMutation");
function d1(r, t) {
  var i;
  return {
    state: {
      ...r.state,
      ...r.state.data !== void 0 && {
        data: t(r.state.data)
      }
    },
    queryKey: r.queryKey,
    queryHash: r.queryHash,
    ...r.state.status === "pending" && {
      promise: (i = r.promise) == null ? void 0 : i.then(t).catch((s) => Promise.reject(new Error("redacted")))
    },
    ...r.meta && { meta: r.meta }
  };
}
c(d1, "dehydrateQuery");
function h1(r) {
  return r.state.isPaused;
}
c(h1, "defaultShouldDehydrateMutation");
function p1(r) {
  return r.state.status === "success";
}
c(p1, "defaultShouldDehydrateQuery");
function u1(r, t = {}) {
  var l, d, u;
  const i = t.shouldDehydrateMutation ?? ((l = r.getDefaultOptions().dehydrate) == null ? void 0 : l.shouldDehydrateMutation) ?? h1, s = r.getMutationCache().getAll().flatMap(
    (y) => i(y) ? [l1(y)] : []
  ), n = t.shouldDehydrateQuery ?? ((d = r.getDefaultOptions().dehydrate) == null ? void 0 : d.shouldDehydrateQuery) ?? p1, a = t.serializeData ?? ((u = r.getDefaultOptions().dehydrate) == null ? void 0 : u.serializeData) ?? Cy, o = r.getQueryCache().getAll().flatMap(
    (y) => n(y) ? [d1(y, a)] : []
  );
  return { mutations: s, queries: o };
}
c(u1, "dehydrate");
function y1(r, t, i) {
  var d, u;
  if (typeof t != "object" || t === null)
    return;
  const s = r.getMutationCache(), n = r.getQueryCache(), a = ((d = i == null ? void 0 : i.defaultOptions) == null ? void 0 : d.deserializeData) ?? ((u = r.getDefaultOptions().hydrate) == null ? void 0 : u.deserializeData) ?? Cy, o = t.mutations || [], l = t.queries || [];
  o.forEach(({ state: y, ...m }) => {
    var f, g;
    s.build(
      r,
      {
        ...(f = r.getDefaultOptions().hydrate) == null ? void 0 : f.mutations,
        ...(g = i == null ? void 0 : i.defaultOptions) == null ? void 0 : g.mutations,
        ...m
      },
      y
    );
  }), l.forEach(({ queryKey: y, state: m, queryHash: f, meta: g, promise: x }) => {
    var P, E;
    let k = n.get(f);
    const S = m.data === void 0 ? m.data : a(m.data);
    if (k) {
      if (k.state.dataUpdatedAt < m.dataUpdatedAt) {
        const { fetchStatus: z, ...U } = m;
        k.setState({
          ...U,
          data: S
        });
      }
    } else
      k = n.build(
        r,
        {
          ...(P = r.getDefaultOptions().hydrate) == null ? void 0 : P.queries,
          ...(E = i == null ? void 0 : i.defaultOptions) == null ? void 0 : E.queries,
          queryKey: y,
          queryHash: f,
          meta: g
        },
        // Reset fetch status to idle to avoid
        // query being stuck in fetching state upon hydration
        {
          ...m,
          data: S,
          fetchStatus: "idle"
        }
      );
    if (x) {
      const z = Promise.resolve(x).then(a);
      k.fetch(void 0, { initialPromise: z });
    }
  });
}
c(y1, "hydrate");
var ct = /* @__PURE__ */ ((r) => (r.Chat = "d65dd4bc-418e-403c-9f56-f9cf4da931ed", r.Comments = "88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd", r.Files = "523edd88-4bbf-4547-b60f-2859a6d2ddc1", r.Posts = "5ebfa152-de85-48da-82dd-30a1b560c313", r.ChatRoom = "edb400ac-839b-45a7-b2a8-6a01820d1c44", r.PrivateChat = "7e14f418-8f15-46f4-b182-f619b671e470", r.BotChat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", r))(ct || {}), ze = /* @__PURE__ */ ((r) => (r.Chat = "chat", r.Comments = "comments", r.Files = "files", r.Posts = "posts", r.ChatRoom = "chat_room", r.PrivateChat = "private_chat", r.BotChat = "bot_chat", r))(ze || {}), _y = /* @__PURE__ */ ((r) => (r["d65dd4bc-418e-403c-9f56-f9cf4da931ed"] = "chat", r["88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd"] = "comments", r["523edd88-4bbf-4547-b60f-2859a6d2ddc1"] = "files", r["5ebfa152-de85-48da-82dd-30a1b560c313"] = "posts", r["edb400ac-839b-45a7-b2a8-6a01820d1c44"] = "chat_room", r["7e14f418-8f15-46f4-b182-f619b671e470"] = "private_chat", r["2352a1c6-abc6-420e-8b85-ca7d5aed8779"] = "bot_chat", r))(_y || {}), Py = /* @__PURE__ */ ((r) => (r.chat = "d65dd4bc-418e-403c-9f56-f9cf4da931ed", r.comments = "88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd", r.files = "523edd88-4bbf-4547-b60f-2859a6d2ddc1", r.posts = "5ebfa152-de85-48da-82dd-30a1b560c313", r.chat_room = "edb400ac-839b-45a7-b2a8-6a01820d1c44", r.private_chat = "7e14f418-8f15-46f4-b182-f619b671e470", r.bot_chat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", r))(Py || {}), My = /* @__PURE__ */ ((r) => (r["2352a1c6-abc6-420e-8b85-ca7d5aed8779"] = "bot_chat", r))(My || {}), zy = /* @__PURE__ */ ((r) => (r.bot_chat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", r))(zy || {}), qe = /* @__PURE__ */ ((r) => (r.Unknown = "unknown", r))(qe || {}), Wi = /* @__PURE__ */ ((r) => (r.None = "none", r.Read = "read", r.Write = "write", r.Admin = "admin", r))(Wi || {}), ns = /* @__PURE__ */ ((r) => (r.List = "list", r.Read = "read", r.Create = "create", r.Update = "update", r.Delete = "delete", r.Admin = "admin", r))(ns || {}), Ne = /* @__PURE__ */ ((r) => (r.App = "app", r.File = "file", r.Message = "message", r.User = "user", r.Comment = "comment", r.Post = "post", r))(Ne || {});
function yi(r, t, i, s, n, a = "GET") {
  return {
    // eslint-disable-next-line @tanstack/query/exhaustive-deps
    queryKey: t,
    queryFn: /* @__PURE__ */ c(async () => {
      const o = await r.fetch(i || "/api/" + t.join("/"), { method: a, body: n });
      if (o.ok)
        return await o.json();
      throw new Error(`Error calling ${i || "/api/" + t.join("/")}`);
    }, "queryFn"),
    ...s
  };
}
c(yi, "getApiOptions");
async function Wd(r, t, i, s, n, a = "GET", o = !1) {
  const l = r.queryClient, d = yi(r, t, i, s, n, a);
  return o ? (d.staleTime = 1, await l.fetchQuery(d)) : await l.ensureQueryData(d);
}
c(Wd, "getApi");
function w1(r, t, i = qe.Unknown, s) {
  return i === qe.Unknown ? yi(r, ["apps", t]) : yi(r, ["apps", t], void 0, void 0, JSON.stringify({ type: i, ...s }), "PUT");
}
c(w1, "getAppOptions");
function f1(r, t, i = qe.Unknown, s) {
  return i === qe.Unknown ? Wd(r, ["apps", t]) : Wd(r, ["apps", t], void 0, void 0, JSON.stringify({ type: i, ...s }), "PUT");
}
c(f1, "getApp");
function Sy(r, t) {
  const i = r.queryClient, s = ["apps", t.uid];
  return {
    mutationFn: /* @__PURE__ */ c(async ({ subscribe: a }) => {
      if (t.id >= 1) {
        const o = await r.fetch(`/api/apps/${t.id}/${a ? "subscribe" : "unsubscribe"}`, {
          method: "POST"
        });
        if (!o.ok)
          throw await o.json();
      } else
        throw new Error(`Could not subscribe to app ${t.uid}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (a) => {
      let o;
      return i.setQueryData(s, (d) => (o = d.is_subscribed, { ...d, is_subscribed: a.subscribe })), {
        previousSubscribe: o,
        subscribe: a.subscribe
      };
    }, "onMutate"),
    onError(a, o, l) {
      l && l.previousSubscribe !== void 0 && i.setQueryData(s, (d) => ({ ...d, is_subscribed: l == null ? void 0 : l.previousSubscribe }));
    }
  };
}
c(Sy, "getAppSubscribeMutationOptions");
function m1(r, t = [ct.ChatRoom, ct.PrivateChat], i, s = {}) {
  const n = new URLSearchParams({
    count_only: "true",
    unread: "true"
  });
  i && n.append("member", i), t == null || t.forEach((l) => n.append("type", l));
  const a = `/api/apps?${n.toString()}`;
  return yi(r, ["apps", "badge", t], a, s);
}
c(m1, "getBadgeOptions$1");
function v1(r) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ members: i, type: s }) => await (await r.fetch("/api/apps", {
      method: "POST",
      body: JSON.stringify({
        members: i,
        type: s
      })
    })).json(), "mutationFn"),
    onSettled: /* @__PURE__ */ c(async () => {
      await r.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
c(v1, "getAddAppMutationOptions");
function g1(r) {
  return new bt(r.queryClient, v1(r));
}
c(g1, "getAddAppMutation");
function b1(r, t = {}, i, s, n, a) {
  return {
    ...t,
    initialPageParam: 0,
    queryKey: ["apps", "list", i, s, a],
    queryFn: /* @__PURE__ */ c(async (o) => {
      var f;
      const l = new URLSearchParams();
      s && l.append("member", s), o.pageParam && l.append("skip", (f = o.pageParam) == null ? void 0 : f.toString()), i == null || i.forEach((g) => l.append("type", g)), l.append("order_by", a);
      const d = n == null ? void 0 : n();
      d && l.append("q", d);
      const u = `/api/apps?${l.toString()}`, m = await (await r.fetch(u)).json();
      return m.data = m.data || [], m;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ c((o) => {
      if (o.end && (o == null ? void 0 : o.end) < (o == null ? void 0 : o.count))
        return o.end;
    }, "getNextPageParam")
  };
}
c(b1, "getAppListOptions");
const x1 = /* @__PURE__ */ c((r) => {
  var t;
  return t = class extends r {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s);
      const n = this;
      this.api = {
        apps: {
          async getApp(a) {
            return await f1(n, a);
          }
        }
      };
    }
  }, c(t, "WeavyApi"), t;
}, "WeavyApiMixin"), $1 = /* @__PURE__ */ c((r) => {
  var t;
  return t = class extends r {
    // AUTHENTICATION
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this._whenTokenFactory = new Promise((n) => {
        this._resolveTokenFactory = n;
      }), this._whenUrlAndTokenFactory = new Promise((n) => {
        this._resolveUrlAndTokenFactory = n;
      }), this._whenTokenIsValid = new Promise((n) => {
        this._resolveTokenIsValid = n;
      }), this._tokenPromise = null, this._token = "", this._validTokenFromFactory = async (n = !1) => {
        var l, d;
        const a = [this.whenTokenFactory()];
        this.tokenFactoryRetryDelay !== 1 / 0 && a.push(new Promise((u) => setTimeout(u, this.tokenFactoryRetryDelay))), await Promise.race(a);
        const o = await ((l = this.tokenFactory) == null ? void 0 : l.call(this, n)) ?? "";
        if (this._validateToken(o)) {
          if (n && o === this._token && this.tokenFactoryRetryDelay !== 1 / 0)
            return await new Promise((u) => setTimeout(u, this.tokenFactoryRetryDelay)), await this._validTokenFromFactory(!0);
        } else if (this._whenTokenFactory = new Promise((u) => {
          this._resolveTokenFactory = u;
        }), !n)
          return await this._validTokenFromFactory(!1);
        if (!o)
          throw new TypeError("Could not get a valid token from tokenFactory.");
        return (d = this._resolveTokenFactory) == null || d.call(this, !0), this.whenUrl().then(this._resolveUrlAndTokenFactory), o;
      }, Promise.all([this.whenUrl(), this.whenTokenFactory()]).then(() => {
        var n;
        this.url && this.tokenFactory && ((n = this._resolveUrlAndTokenFactory) == null || n.call(this, !0));
      });
    }
    async whenTokenFactory() {
      await this._whenTokenFactory;
    }
    async whenUrlAndTokenFactory() {
      await this._whenUrlAndTokenFactory;
    }
    async whenTokenIsValid() {
      await this._whenTokenIsValid;
    }
    /**
     * Async function returning an `access_token` string for _your_ authenticated user. A boolean `refresh` parameter is provided to let you now if a fresh token is needed from Weavy.
     */
    get tokenFactory() {
      return this._tokenFactory;
    }
    set tokenFactory(s) {
      if (this.isDestroyed)
        throw new At();
      this._tokenFactory && this._tokenFactory !== s && this.whenTokenFactory().then(() => {
        this.queryClient.refetchQueries({ stale: !0 });
      }), this._tokenFactory = s ?? void 0, this._tokenFactory && queueMicrotask(() => {
        var n;
        (n = this._resolveTokenFactory) == null || n.call(this, !0);
      });
    }
    /**
     * An URL to an endpoint returning an JSON data containing an `access_token` string property for _your_ authenticated user. A boolean `refresh=true` query parameter is provided in the request to let you now if when a fresh token is needed from Weavy.
     */
    get tokenUrl() {
      return this._tokenUrl;
    }
    set tokenUrl(s) {
      if (this.isDestroyed)
        throw new At();
      try {
        if (typeof s == "string")
          s && (this._tokenUrl = new URL(s, window.location.toString()));
        else if (s instanceof URL)
          this._tokenUrl = s;
        else if (s == null)
          this._tokenUrl = void 0;
        else
          throw -1;
      } catch (n) {
        throw new Error("Invalid url", n);
      }
      this._tokenUrl && !this.tokenFactory && (this.tokenFactory = async (n) => {
        if (!this.tokenUrl)
          throw new Error("tokenURL property is not valid");
        const a = new URL(this.tokenUrl);
        n ? a.searchParams.set("refresh", "true") : a.searchParams.delete("refresh");
        const o = await fetch(a);
        if (o.ok) {
          const l = await o.json();
          if (l.access_token === void 0)
            throw new Error("Token response does not contain required property: access_token");
          return l.access_token;
        } else
          throw new Error("Could not get access token from server!");
      });
    }
    _validateToken(s) {
      var n;
      if (!s)
        return !1;
      if (typeof s != "string")
        throw new TypeError(`You have provided an invalid string access token of type ${typeof s}.`);
      if (typeof s == "string" && !s.startsWith("wyu_"))
        throw s.startsWith("wys_") ? new TypeError("You have provided an API key for authentication. Provide a user access token instead.") : new TypeError("You have provided an invalid string as access token.");
      return (n = this._resolveTokenIsValid) == null || n.call(this, s), !0;
    }
    async getToken(s = !1) {
      if (this.isDestroyed)
        throw new At();
      if (this._token && !s)
        return this._token;
      if (this._tokenPromise)
        return await this._tokenPromise;
      this._tokenPromise = new Promise((n, a) => {
        this._validTokenFromFactory(s).then(n).catch(a), this.tokenFactoryTimeout !== 1 / 0 && setTimeout(() => a(new Error("Token factory timeout.")), this.tokenFactoryTimeout), window.addEventListener("offline", () => a(new Error("Network changed.")), { once: !0 }), window.addEventListener("online", () => a(new Error("Network changed.")), { once: !0 });
      });
      try {
        const n = await this._tokenPromise;
        return this._tokenPromise = null, this._token = n, this._token;
      } catch (n) {
        throw this._tokenPromise = null, n;
      }
    }
  }, c(t, "WeavyAuthentication"), t;
}, "WeavyAuthenticationMixin");
var zc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function k1(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
c(k1, "getDefaultExportFromCjs");
function $d(r) {
  throw new Error('Could not dynamically require "' + r + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
c($d, "commonjsRequire");
var Ey = { exports: {} };
(function(r, t) {
  var i;
  i = /* @__PURE__ */ c(() => (() => {
    var s = { d: /* @__PURE__ */ c((F, h) => {
      for (var v in h) s.o(h, v) && !s.o(F, v) && Object.defineProperty(F, v, { enumerable: !0, get: h[v] });
    }, "d") };
    s.g = function() {
      if (typeof globalThis == "object") return globalThis;
      try {
        return this || new Function("return this")();
      } catch {
        if (typeof window == "object") return window;
      }
    }(), s.o = (F, h) => Object.prototype.hasOwnProperty.call(F, h), s.r = (F) => {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(F, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(F, "t", { value: !0 });
    };
    var n, a = {};
    s.r(a), s.d(a, { AbortError: /* @__PURE__ */ c(() => d, "AbortError"), DefaultHttpClient: /* @__PURE__ */ c(() => Bt, "DefaultHttpClient"), HttpClient: /* @__PURE__ */ c(() => k, "HttpClient"), HttpError: /* @__PURE__ */ c(() => o, "HttpError"), HttpResponse: /* @__PURE__ */ c(() => x, "HttpResponse"), HttpTransportType: /* @__PURE__ */ c(() => Et, "HttpTransportType"), HubConnection: /* @__PURE__ */ c(() => $s, "HubConnection"), HubConnectionBuilder: /* @__PURE__ */ c(() => Bl, "HubConnectionBuilder"), HubConnectionState: /* @__PURE__ */ c(() => gt, "HubConnectionState"), JsonHubProtocol: /* @__PURE__ */ c(() => kc, "JsonHubProtocol"), LogLevel: /* @__PURE__ */ c(() => n, "LogLevel"), MessageType: /* @__PURE__ */ c(() => et, "MessageType"), NullLogger: /* @__PURE__ */ c(() => S, "NullLogger"), Subject: /* @__PURE__ */ c(() => qi, "Subject"), TimeoutError: /* @__PURE__ */ c(() => l, "TimeoutError"), TransferFormat: /* @__PURE__ */ c(() => re, "TransferFormat"), VERSION: /* @__PURE__ */ c(() => P, "VERSION") });
    const Ul = class Ul extends Error {
      constructor(h, v) {
        const _ = new.target.prototype;
        super(`${h}: Status code '${v}'`), this.statusCode = v, this.__proto__ = _;
      }
    };
    c(Ul, "i");
    let o = Ul;
    const ql = class ql extends Error {
      constructor(h = "A timeout occurred.") {
        const v = new.target.prototype;
        super(h), this.__proto__ = v;
      }
    };
    c(ql, "n");
    let l = ql;
    const Nl = class Nl extends Error {
      constructor(h = "An abort occurred.") {
        const v = new.target.prototype;
        super(h), this.__proto__ = v;
      }
    };
    c(Nl, "r");
    let d = Nl;
    const jl = class jl extends Error {
      constructor(h, v) {
        const _ = new.target.prototype;
        super(h), this.transport = v, this.errorType = "UnsupportedTransportError", this.__proto__ = _;
      }
    };
    c(jl, "o");
    let u = jl;
    const Wl = class Wl extends Error {
      constructor(h, v) {
        const _ = new.target.prototype;
        super(h), this.transport = v, this.errorType = "DisabledTransportError", this.__proto__ = _;
      }
    };
    c(Wl, "h");
    let y = Wl;
    const Ql = class Ql extends Error {
      constructor(h, v) {
        const _ = new.target.prototype;
        super(h), this.transport = v, this.errorType = "FailedToStartTransportError", this.__proto__ = _;
      }
    };
    c(Ql, "c");
    let m = Ql;
    const Kl = class Kl extends Error {
      constructor(h) {
        const v = new.target.prototype;
        super(h), this.errorType = "FailedToNegotiateWithServerError", this.__proto__ = v;
      }
    };
    c(Kl, "a");
    let f = Kl;
    const Gl = class Gl extends Error {
      constructor(h, v) {
        const _ = new.target.prototype;
        super(h), this.innerErrors = v, this.__proto__ = _;
      }
    };
    c(Gl, "l");
    let g = Gl;
    const Yl = class Yl {
      constructor(h, v, _) {
        this.statusCode = h, this.statusText = v, this.content = _;
      }
    };
    c(Yl, "u");
    let x = Yl;
    const Zl = class Zl {
      get(h, v) {
        return this.send({ ...v, method: "GET", url: h });
      }
      post(h, v) {
        return this.send({ ...v, method: "POST", url: h });
      }
      delete(h, v) {
        return this.send({ ...v, method: "DELETE", url: h });
      }
      getCookieString(h) {
        return "";
      }
    };
    c(Zl, "d");
    let k = Zl;
    (function(F) {
      F[F.Trace = 0] = "Trace", F[F.Debug = 1] = "Debug", F[F.Information = 2] = "Information", F[F.Warning = 3] = "Warning", F[F.Error = 4] = "Error", F[F.Critical = 5] = "Critical", F[F.None = 6] = "None";
    })(n || (n = {}));
    const Xl = class Xl {
      constructor() {
      }
      log(h, v) {
      }
    };
    c(Xl, "f");
    let S = Xl;
    S.instance = new S();
    const P = "8.0.7", Jl = class Jl {
      static isRequired(h, v) {
        if (h == null) throw new Error(`The '${v}' argument is required.`);
      }
      static isNotEmpty(h, v) {
        if (!h || h.match(/^\s*$/)) throw new Error(`The '${v}' argument should not be empty.`);
      }
      static isIn(h, v, _) {
        if (!(h in v)) throw new Error(`Unknown ${_} value: ${h}.`);
      }
    };
    c(Jl, "w");
    let E = Jl;
    const hr = class hr {
      static get isBrowser() {
        return !hr.isNode && typeof window == "object" && typeof window.document == "object";
      }
      static get isWebWorker() {
        return !hr.isNode && typeof self == "object" && "importScripts" in self;
      }
      static get isReactNative() {
        return !hr.isNode && typeof window == "object" && window.document === void 0;
      }
      static get isNode() {
        return typeof process < "u" && process.release && process.release.name === "node";
      }
    };
    c(hr, "g");
    let z = hr;
    function U(F, h) {
      let v = "";
      return O(F) ? (v = `Binary data of length ${F.byteLength}`, h && (v += `. Content: '${function(_) {
        const M = new Uint8Array(_);
        let A = "";
        return M.forEach((R) => {
          A += `0x${R < 16 ? "0" : ""}${R.toString(16)} `;
        }), A.substr(0, A.length - 1);
      }(F)}'`)) : typeof F == "string" && (v = `String data of length ${F.length}`, h && (v += `. Content: '${F}'`)), v;
    }
    c(U, "m");
    function O(F) {
      return F && typeof ArrayBuffer < "u" && (F instanceof ArrayBuffer || F.constructor && F.constructor.name === "ArrayBuffer");
    }
    c(O, "y");
    async function V(F, h, v, _, M, A) {
      const R = {}, [K, Y] = H();
      R[K] = Y, F.log(n.Trace, `(${h} transport) sending data. ${U(M, A.logMessageContent)}.`);
      const ot = O(M) ? "arraybuffer" : "text", $t = await v.post(_, { content: M, headers: { ...R, ...A.headers }, responseType: ot, timeout: A.timeout, withCredentials: A.withCredentials });
      F.log(n.Trace, `(${h} transport) request complete. Response status: ${$t.statusCode}.`);
    }
    c(V, "b");
    const td = class td {
      constructor(h, v) {
        this.i = h, this.h = v;
      }
      dispose() {
        const h = this.i.observers.indexOf(this.h);
        h > -1 && this.i.observers.splice(h, 1), this.i.observers.length === 0 && this.i.cancelCallback && this.i.cancelCallback().catch((v) => {
        });
      }
    };
    c(td, "v");
    let q = td;
    const ed = class ed {
      constructor(h) {
        this.l = h, this.out = console;
      }
      log(h, v) {
        if (h >= this.l) {
          const _ = `[${(/* @__PURE__ */ new Date()).toISOString()}] ${n[h]}: ${v}`;
          switch (h) {
            case n.Critical:
            case n.Error:
              this.out.error(_);
              break;
            case n.Warning:
              this.out.warn(_);
              break;
            case n.Information:
              this.out.info(_);
              break;
            default:
              this.out.log(_);
          }
        }
      }
    };
    c(ed, "E");
    let N = ed;
    function H() {
      let F = "X-SignalR-User-Agent";
      return z.isNode && (F = "User-Agent"), [F, W(P, ft(), z.isNode ? "NodeJS" : "Browser", wt())];
    }
    c(H, "$");
    function W(F, h, v, _) {
      let M = "Microsoft SignalR/";
      const A = F.split(".");
      return M += `${A[0]}.${A[1]}`, M += ` (${F}; `, M += h && h !== "" ? `${h}; ` : "Unknown OS; ", M += `${v}`, M += _ ? `; ${_}` : "; Unknown Runtime Version", M += ")", M;
    }
    c(W, "C");
    function ft() {
      if (!z.isNode) return "";
      switch (process.platform) {
        case "win32":
          return "Windows NT";
        case "darwin":
          return "macOS";
        case "linux":
          return "Linux";
        default:
          return process.platform;
      }
    }
    c(ft, "S");
    function wt() {
      if (z.isNode) return process.versions.node;
    }
    c(wt, "k");
    function ut(F) {
      return F.stack ? F.stack : F.message ? F.message : `${F}`;
    }
    c(ut, "P");
    const id = class id extends k {
      constructor(h) {
        if (super(), this.u = h, typeof fetch > "u" || z.isNode) {
          const v = $d;
          this.p = new (v("tough-cookie")).CookieJar(), typeof fetch > "u" ? this.m = v("node-fetch") : this.m = fetch, this.m = v("fetch-cookie")(this.m, this.p);
        } else this.m = fetch.bind(function() {
          if (typeof globalThis < "u") return globalThis;
          if (typeof self < "u") return self;
          if (typeof window < "u") return window;
          if (s.g !== void 0) return s.g;
          throw new Error("could not find global");
        }());
        if (typeof AbortController > "u") {
          const v = $d;
          this.v = v("abort-controller");
        } else this.v = AbortController;
      }
      async send(h) {
        if (h.abortSignal && h.abortSignal.aborted) throw new d();
        if (!h.method) throw new Error("No method defined.");
        if (!h.url) throw new Error("No url defined.");
        const v = new this.v();
        let _;
        h.abortSignal && (h.abortSignal.onabort = () => {
          v.abort(), _ = new d();
        });
        let M, A = null;
        if (h.timeout) {
          const Y = h.timeout;
          A = setTimeout(() => {
            v.abort(), this.u.log(n.Warning, "Timeout from HTTP request."), _ = new l();
          }, Y);
        }
        h.content === "" && (h.content = void 0), h.content && (h.headers = h.headers || {}, O(h.content) ? h.headers["Content-Type"] = "application/octet-stream" : h.headers["Content-Type"] = "text/plain;charset=UTF-8");
        try {
          M = await this.m(h.url, { body: h.content, cache: "no-cache", credentials: h.withCredentials === !0 ? "include" : "same-origin", headers: { "X-Requested-With": "XMLHttpRequest", ...h.headers }, method: h.method, mode: "cors", redirect: "follow", signal: v.signal });
        } catch (Y) {
          throw _ || (this.u.log(n.Warning, `Error from HTTP request. ${Y}.`), Y);
        } finally {
          A && clearTimeout(A), h.abortSignal && (h.abortSignal.onabort = null);
        }
        if (!M.ok) {
          const Y = await he(M, "text");
          throw new o(Y || M.statusText, M.status);
        }
        const R = he(M, h.responseType), K = await R;
        return new x(M.status, M.statusText, K);
      }
      getCookieString(h) {
        let v = "";
        return z.isNode && this.p && this.p.getCookies(h, (_, M) => v = M.join("; ")), v;
      }
    };
    c(id, "T");
    let vt = id;
    function he(F, h) {
      let v;
      switch (h) {
        case "arraybuffer":
          v = F.arrayBuffer();
          break;
        case "text":
        default:
          v = F.text();
          break;
        case "blob":
        case "document":
        case "json":
          throw new Error(`${h} is not supported.`);
      }
      return v;
    }
    c(he, "I");
    const sd = class sd extends k {
      constructor(h) {
        super(), this.u = h;
      }
      send(h) {
        return h.abortSignal && h.abortSignal.aborted ? Promise.reject(new d()) : h.method ? h.url ? new Promise((v, _) => {
          const M = new XMLHttpRequest();
          M.open(h.method, h.url, !0), M.withCredentials = h.withCredentials === void 0 || h.withCredentials, M.setRequestHeader("X-Requested-With", "XMLHttpRequest"), h.content === "" && (h.content = void 0), h.content && (O(h.content) ? M.setRequestHeader("Content-Type", "application/octet-stream") : M.setRequestHeader("Content-Type", "text/plain;charset=UTF-8"));
          const A = h.headers;
          A && Object.keys(A).forEach((R) => {
            M.setRequestHeader(R, A[R]);
          }), h.responseType && (M.responseType = h.responseType), h.abortSignal && (h.abortSignal.onabort = () => {
            M.abort(), _(new d());
          }), h.timeout && (M.timeout = h.timeout), M.onload = () => {
            h.abortSignal && (h.abortSignal.onabort = null), M.status >= 200 && M.status < 300 ? v(new x(M.status, M.statusText, M.response || M.responseText)) : _(new o(M.response || M.responseText || M.statusText, M.status));
          }, M.onerror = () => {
            this.u.log(n.Warning, `Error from HTTP request. ${M.status}: ${M.statusText}.`), _(new o(M.statusText, M.status));
          }, M.ontimeout = () => {
            this.u.log(n.Warning, "Timeout from HTTP request."), _(new l());
          }, M.send(h.content);
        }) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."));
      }
    };
    c(sd, "_");
    let ke = sd;
    const rd = class rd extends k {
      constructor(h) {
        if (super(), typeof fetch < "u" || z.isNode) this.$ = new vt(h);
        else {
          if (typeof XMLHttpRequest > "u") throw new Error("No usable HttpClient found.");
          this.$ = new ke(h);
        }
      }
      send(h) {
        return h.abortSignal && h.abortSignal.aborted ? Promise.reject(new d()) : h.method ? h.url ? this.$.send(h) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."));
      }
      getCookieString(h) {
        return this.$.getCookieString(h);
      }
    };
    c(rd, "H");
    let Bt = rd;
    const pr = class pr {
      static write(h) {
        return `${h}${pr.RecordSeparator}`;
      }
      static parse(h) {
        if (h[h.length - 1] !== pr.RecordSeparator) throw new Error("Message is incomplete.");
        const v = h.split(pr.RecordSeparator);
        return v.pop(), v;
      }
    };
    c(pr, "D");
    let Ct = pr;
    Ct.RecordSeparatorCode = 30, Ct.RecordSeparator = String.fromCharCode(Ct.RecordSeparatorCode);
    const nd = class nd {
      writeHandshakeRequest(h) {
        return Ct.write(JSON.stringify(h));
      }
      parseHandshakeResponse(h) {
        let v, _;
        if (O(h)) {
          const R = new Uint8Array(h), K = R.indexOf(Ct.RecordSeparatorCode);
          if (K === -1) throw new Error("Message is incomplete.");
          const Y = K + 1;
          v = String.fromCharCode.apply(null, Array.prototype.slice.call(R.slice(0, Y))), _ = R.byteLength > Y ? R.slice(Y).buffer : null;
        } else {
          const R = h, K = R.indexOf(Ct.RecordSeparator);
          if (K === -1) throw new Error("Message is incomplete.");
          const Y = K + 1;
          v = R.substring(0, Y), _ = R.length > Y ? R.substring(Y) : null;
        }
        const M = Ct.parse(v), A = JSON.parse(M[0]);
        if (A.type) throw new Error("Expected a handshake response from the server.");
        return [_, A];
      }
    };
    c(nd, "R");
    let pe = nd;
    var et, gt;
    (function(F) {
      F[F.Invocation = 1] = "Invocation", F[F.StreamItem = 2] = "StreamItem", F[F.Completion = 3] = "Completion", F[F.StreamInvocation = 4] = "StreamInvocation", F[F.CancelInvocation = 5] = "CancelInvocation", F[F.Ping = 6] = "Ping", F[F.Close = 7] = "Close", F[F.Ack = 8] = "Ack", F[F.Sequence = 9] = "Sequence";
    })(et || (et = {}));
    const ad = class ad {
      constructor() {
        this.observers = [];
      }
      next(h) {
        for (const v of this.observers) v.next(h);
      }
      error(h) {
        for (const v of this.observers) v.error && v.error(h);
      }
      complete() {
        for (const h of this.observers) h.complete && h.complete();
      }
      subscribe(h) {
        return this.observers.push(h), new q(this, h);
      }
    };
    c(ad, "U");
    let qi = ad;
    const od = class od {
      constructor(h, v, _) {
        this.C = 1e5, this.S = [], this.k = 0, this.P = !1, this.T = 1, this.I = 0, this._ = 0, this.H = !1, this.D = h, this.R = v, this.C = _;
      }
      async A(h) {
        const v = this.D.writeMessage(h);
        let _ = Promise.resolve();
        if (this.U(h)) {
          this.k++;
          let M = /* @__PURE__ */ c(() => {
          }, "t"), A = /* @__PURE__ */ c(() => {
          }, "i");
          O(v) ? this._ += v.byteLength : this._ += v.length, this._ >= this.C && (_ = new Promise((R, K) => {
            M = R, A = K;
          })), this.S.push(new cr(v, this.k, M, A));
        }
        try {
          this.H || await this.R.send(v);
        } catch {
          this.L();
        }
        await _;
      }
      N(h) {
        let v = -1;
        for (let _ = 0; _ < this.S.length; _++) {
          const M = this.S[_];
          if (M.q <= h.sequenceId) v = _, O(M.M) ? this._ -= M.M.byteLength : this._ -= M.M.length, M.j();
          else {
            if (!(this._ < this.C)) break;
            M.j();
          }
        }
        v !== -1 && (this.S = this.S.slice(v + 1));
      }
      W(h) {
        if (this.P) return h.type === et.Sequence && (this.P = !1, !0);
        if (!this.U(h)) return !0;
        const v = this.T;
        return this.T++, v <= this.I ? (v === this.I && this.O(), !1) : (this.I = v, this.O(), !0);
      }
      F(h) {
        h.sequenceId > this.T ? this.R.stop(new Error("Sequence ID greater than amount of messages we've received.")) : this.T = h.sequenceId;
      }
      L() {
        this.H = !0, this.P = !0;
      }
      async B() {
        const h = this.S.length !== 0 ? this.S[0].q : this.k + 1;
        await this.R.send(this.D.writeMessage({ type: et.Sequence, sequenceId: h }));
        const v = this.S;
        for (const _ of v) await this.R.send(_.M);
        this.H = !1;
      }
      X(h) {
        h != null || (h = new Error("Unable to reconnect to server."));
        for (const v of this.S) v.J(h);
      }
      U(h) {
        switch (h.type) {
          case et.Invocation:
          case et.StreamItem:
          case et.Completion:
          case et.StreamInvocation:
          case et.CancelInvocation:
            return !0;
          case et.Close:
          case et.Sequence:
          case et.Ping:
          case et.Ack:
            return !1;
        }
      }
      O() {
        this.V === void 0 && (this.V = setTimeout(async () => {
          try {
            this.H || await this.R.send(this.D.writeMessage({ type: et.Ack, sequenceId: this.I }));
          } catch {
          }
          clearTimeout(this.V), this.V = void 0;
        }, 1e3));
      }
    };
    c(od, "L");
    let Ni = od;
    const cd = class cd {
      constructor(h, v, _, M) {
        this.M = h, this.q = v, this.j = _, this.J = M;
      }
    };
    c(cd, "N");
    let cr = cd;
    (function(F) {
      F.Disconnected = "Disconnected", F.Connecting = "Connecting", F.Connected = "Connected", F.Disconnecting = "Disconnecting", F.Reconnecting = "Reconnecting";
    })(gt || (gt = {}));
    const Cc = class Cc {
      static create(h, v, _, M, A, R, K) {
        return new Cc(h, v, _, M, A, R, K);
      }
      constructor(h, v, _, M, A, R, K) {
        this.K = 0, this.G = () => {
          this.u.log(n.Warning, "The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep");
        }, E.isRequired(h, "connection"), E.isRequired(v, "logger"), E.isRequired(_, "protocol"), this.serverTimeoutInMilliseconds = A ?? 3e4, this.keepAliveIntervalInMilliseconds = R ?? 15e3, this.Y = K ?? 1e5, this.u = v, this.D = _, this.connection = h, this.Z = M, this.tt = new pe(), this.connection.onreceive = (Y) => this.et(Y), this.connection.onclose = (Y) => this.st(Y), this.it = {}, this.nt = {}, this.rt = [], this.ot = [], this.ht = [], this.ct = 0, this.lt = !1, this.ut = gt.Disconnected, this.dt = !1, this.ft = this.D.writeMessage({ type: et.Ping });
      }
      get state() {
        return this.ut;
      }
      get connectionId() {
        return this.connection && this.connection.connectionId || null;
      }
      get baseUrl() {
        return this.connection.baseUrl || "";
      }
      set baseUrl(h) {
        if (this.ut !== gt.Disconnected && this.ut !== gt.Reconnecting) throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");
        if (!h) throw new Error("The HubConnection url must be a valid url.");
        this.connection.baseUrl = h;
      }
      start() {
        return this.wt = this.gt(), this.wt;
      }
      async gt() {
        if (this.ut !== gt.Disconnected) return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));
        this.ut = gt.Connecting, this.u.log(n.Debug, "Starting HubConnection.");
        try {
          await this.yt(), z.isBrowser && window.document.addEventListener("freeze", this.G), this.ut = gt.Connected, this.dt = !0, this.u.log(n.Debug, "HubConnection connected successfully.");
        } catch (h) {
          return this.ut = gt.Disconnected, this.u.log(n.Debug, `HubConnection failed to start successfully because of error '${h}'.`), Promise.reject(h);
        }
      }
      async yt() {
        this.bt = void 0, this.lt = !1;
        const h = new Promise((v, _) => {
          this.vt = v, this.Et = _;
        });
        await this.connection.start(this.D.transferFormat);
        try {
          let v = this.D.version;
          this.connection.features.reconnect || (v = 1);
          const _ = { protocol: this.D.name, version: v };
          if (this.u.log(n.Debug, "Sending handshake request."), await this.$t(this.tt.writeHandshakeRequest(_)), this.u.log(n.Information, `Using HubProtocol '${this.D.name}'.`), this.Ct(), this.St(), this.kt(), await h, this.bt) throw this.bt;
          this.connection.features.reconnect && (this.Pt = new Ni(this.D, this.connection, this.Y), this.connection.features.disconnected = this.Pt.L.bind(this.Pt), this.connection.features.resend = () => {
            if (this.Pt) return this.Pt.B();
          }), this.connection.features.inherentKeepAlive || await this.$t(this.ft);
        } catch (v) {
          throw this.u.log(n.Debug, `Hub handshake failed with error '${v}' during start(). Stopping HubConnection.`), this.Ct(), this.Tt(), await this.connection.stop(v), v;
        }
      }
      async stop() {
        const h = this.wt;
        this.connection.features.reconnect = !1, this.It = this._t(), await this.It;
        try {
          await h;
        } catch {
        }
      }
      _t(h) {
        if (this.ut === gt.Disconnected) return this.u.log(n.Debug, `Call to HubConnection.stop(${h}) ignored because it is already in the disconnected state.`), Promise.resolve();
        if (this.ut === gt.Disconnecting) return this.u.log(n.Debug, `Call to HttpConnection.stop(${h}) ignored because the connection is already in the disconnecting state.`), this.It;
        const v = this.ut;
        return this.ut = gt.Disconnecting, this.u.log(n.Debug, "Stopping HubConnection."), this.Ht ? (this.u.log(n.Debug, "Connection stopped during reconnect delay. Done reconnecting."), clearTimeout(this.Ht), this.Ht = void 0, this.Dt(), Promise.resolve()) : (v === gt.Connected && this.Rt(), this.Ct(), this.Tt(), this.bt = h || new d("The connection was stopped before the hub handshake could complete."), this.connection.stop(h));
      }
      async Rt() {
        try {
          await this.xt(this.At());
        } catch {
        }
      }
      stream(h, ...v) {
        const [_, M] = this.Ut(v), A = this.Lt(h, v, M);
        let R;
        const K = new qi();
        return K.cancelCallback = () => {
          const Y = this.Nt(A.invocationId);
          return delete this.it[A.invocationId], R.then(() => this.xt(Y));
        }, this.it[A.invocationId] = (Y, ot) => {
          ot ? K.error(ot) : Y && (Y.type === et.Completion ? Y.error ? K.error(new Error(Y.error)) : K.complete() : K.next(Y.item));
        }, R = this.xt(A).catch((Y) => {
          K.error(Y), delete this.it[A.invocationId];
        }), this.qt(_, R), K;
      }
      $t(h) {
        return this.kt(), this.connection.send(h);
      }
      xt(h) {
        return this.Pt ? this.Pt.A(h) : this.$t(this.D.writeMessage(h));
      }
      send(h, ...v) {
        const [_, M] = this.Ut(v), A = this.xt(this.Mt(h, v, !0, M));
        return this.qt(_, A), A;
      }
      invoke(h, ...v) {
        const [_, M] = this.Ut(v), A = this.Mt(h, v, !1, M);
        return new Promise((R, K) => {
          this.it[A.invocationId] = (ot, $t) => {
            $t ? K($t) : ot && (ot.type === et.Completion ? ot.error ? K(new Error(ot.error)) : R(ot.result) : K(new Error(`Unexpected message type: ${ot.type}`)));
          };
          const Y = this.xt(A).catch((ot) => {
            K(ot), delete this.it[A.invocationId];
          });
          this.qt(_, Y);
        });
      }
      on(h, v) {
        h && v && (h = h.toLowerCase(), this.nt[h] || (this.nt[h] = []), this.nt[h].indexOf(v) === -1 && this.nt[h].push(v));
      }
      off(h, v) {
        if (!h) return;
        h = h.toLowerCase();
        const _ = this.nt[h];
        if (_) if (v) {
          const M = _.indexOf(v);
          M !== -1 && (_.splice(M, 1), _.length === 0 && delete this.nt[h]);
        } else delete this.nt[h];
      }
      onclose(h) {
        h && this.rt.push(h);
      }
      onreconnecting(h) {
        h && this.ot.push(h);
      }
      onreconnected(h) {
        h && this.ht.push(h);
      }
      et(h) {
        if (this.Ct(), this.lt || (h = this.jt(h), this.lt = !0), h) {
          const v = this.D.parseMessages(h, this.u);
          for (const _ of v) if (!this.Pt || this.Pt.W(_)) switch (_.type) {
            case et.Invocation:
              this.Wt(_).catch((M) => {
                this.u.log(n.Error, `Invoke client method threw error: ${ut(M)}`);
              });
              break;
            case et.StreamItem:
            case et.Completion: {
              const M = this.it[_.invocationId];
              if (M) {
                _.type === et.Completion && delete this.it[_.invocationId];
                try {
                  M(_);
                } catch (A) {
                  this.u.log(n.Error, `Stream callback threw error: ${ut(A)}`);
                }
              }
              break;
            }
            case et.Ping:
              break;
            case et.Close: {
              this.u.log(n.Information, "Close message received from server.");
              const M = _.error ? new Error("Server returned an error on close: " + _.error) : void 0;
              _.allowReconnect === !0 ? this.connection.stop(M) : this.It = this._t(M);
              break;
            }
            case et.Ack:
              this.Pt && this.Pt.N(_);
              break;
            case et.Sequence:
              this.Pt && this.Pt.F(_);
              break;
            default:
              this.u.log(n.Warning, `Invalid message type: ${_.type}.`);
          }
        }
        this.St();
      }
      jt(h) {
        let v, _;
        try {
          [_, v] = this.tt.parseHandshakeResponse(h);
        } catch (M) {
          const A = "Error parsing handshake response: " + M;
          this.u.log(n.Error, A);
          const R = new Error(A);
          throw this.Et(R), R;
        }
        if (v.error) {
          const M = "Server returned handshake error: " + v.error;
          this.u.log(n.Error, M);
          const A = new Error(M);
          throw this.Et(A), A;
        }
        return this.u.log(n.Debug, "Server handshake complete."), this.vt(), _;
      }
      kt() {
        this.connection.features.inherentKeepAlive || (this.K = (/* @__PURE__ */ new Date()).getTime() + this.keepAliveIntervalInMilliseconds, this.Tt());
      }
      St() {
        if (!(this.connection.features && this.connection.features.inherentKeepAlive || (this.Ot = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds), this.Ft !== void 0))) {
          let h = this.K - (/* @__PURE__ */ new Date()).getTime();
          h < 0 && (h = 0), this.Ft = setTimeout(async () => {
            if (this.ut === gt.Connected) try {
              await this.$t(this.ft);
            } catch {
              this.Tt();
            }
          }, h);
        }
      }
      serverTimeout() {
        this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."));
      }
      async Wt(h) {
        const v = h.target.toLowerCase(), _ = this.nt[v];
        if (!_) return this.u.log(n.Warning, `No client method with the name '${v}' found.`), void (h.invocationId && (this.u.log(n.Warning, `No result given for '${v}' method and invocation ID '${h.invocationId}'.`), await this.xt(this.Bt(h.invocationId, "Client didn't provide a result.", null))));
        const M = _.slice(), A = !!h.invocationId;
        let R, K, Y;
        for (const ot of M) try {
          const $t = R;
          R = await ot.apply(this, h.arguments), A && R && $t && (this.u.log(n.Error, `Multiple results provided for '${v}'. Sending error to server.`), Y = this.Bt(h.invocationId, "Client provided multiple results.", null)), K = void 0;
        } catch ($t) {
          K = $t, this.u.log(n.Error, `A callback for the method '${v}' threw error '${$t}'.`);
        }
        Y ? await this.xt(Y) : A ? (K ? Y = this.Bt(h.invocationId, `${K}`, null) : R !== void 0 ? Y = this.Bt(h.invocationId, null, R) : (this.u.log(n.Warning, `No result given for '${v}' method and invocation ID '${h.invocationId}'.`), Y = this.Bt(h.invocationId, "Client didn't provide a result.", null)), await this.xt(Y)) : R && this.u.log(n.Error, `Result given for '${v}' method but server is not expecting a result.`);
      }
      st(h) {
        this.u.log(n.Debug, `HubConnection.connectionClosed(${h}) called while in state ${this.ut}.`), this.bt = this.bt || h || new d("The underlying connection was closed before the hub handshake could complete."), this.vt && this.vt(), this.Xt(h || new Error("Invocation canceled due to the underlying connection being closed.")), this.Ct(), this.Tt(), this.ut === gt.Disconnecting ? this.Dt(h) : this.ut === gt.Connected && this.Z ? this.Jt(h) : this.ut === gt.Connected && this.Dt(h);
      }
      Dt(h) {
        if (this.dt) {
          this.ut = gt.Disconnected, this.dt = !1, this.Pt && (this.Pt.X(h ?? new Error("Connection closed.")), this.Pt = void 0), z.isBrowser && window.document.removeEventListener("freeze", this.G);
          try {
            this.rt.forEach((v) => v.apply(this, [h]));
          } catch (v) {
            this.u.log(n.Error, `An onclose callback called with error '${h}' threw error '${v}'.`);
          }
        }
      }
      async Jt(h) {
        const v = Date.now();
        let _ = 0, M = h !== void 0 ? h : new Error("Attempting to reconnect due to a unknown error."), A = this.zt(_++, 0, M);
        if (A === null) return this.u.log(n.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."), void this.Dt(h);
        if (this.ut = gt.Reconnecting, h ? this.u.log(n.Information, `Connection reconnecting because of error '${h}'.`) : this.u.log(n.Information, "Connection reconnecting."), this.ot.length !== 0) {
          try {
            this.ot.forEach((R) => R.apply(this, [h]));
          } catch (R) {
            this.u.log(n.Error, `An onreconnecting callback called with error '${h}' threw error '${R}'.`);
          }
          if (this.ut !== gt.Reconnecting) return void this.u.log(n.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.");
        }
        for (; A !== null; ) {
          if (this.u.log(n.Information, `Reconnect attempt number ${_} will start in ${A} ms.`), await new Promise((R) => {
            this.Ht = setTimeout(R, A);
          }), this.Ht = void 0, this.ut !== gt.Reconnecting) return void this.u.log(n.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting.");
          try {
            if (await this.yt(), this.ut = gt.Connected, this.u.log(n.Information, "HubConnection reconnected successfully."), this.ht.length !== 0) try {
              this.ht.forEach((R) => R.apply(this, [this.connection.connectionId]));
            } catch (R) {
              this.u.log(n.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${R}'.`);
            }
            return;
          } catch (R) {
            if (this.u.log(n.Information, `Reconnect attempt failed because of error '${R}'.`), this.ut !== gt.Reconnecting) return this.u.log(n.Debug, `Connection moved to the '${this.ut}' from the reconnecting state during reconnect attempt. Done reconnecting.`), void (this.ut === gt.Disconnecting && this.Dt());
            M = R instanceof Error ? R : new Error(R.toString()), A = this.zt(_++, Date.now() - v, M);
          }
        }
        this.u.log(n.Information, `Reconnect retries have been exhausted after ${Date.now() - v} ms and ${_} failed attempts. Connection disconnecting.`), this.Dt();
      }
      zt(h, v, _) {
        try {
          return this.Z.nextRetryDelayInMilliseconds({ elapsedMilliseconds: v, previousRetryCount: h, retryReason: _ });
        } catch (M) {
          return this.u.log(n.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${h}, ${v}) threw error '${M}'.`), null;
        }
      }
      Xt(h) {
        const v = this.it;
        this.it = {}, Object.keys(v).forEach((_) => {
          const M = v[_];
          try {
            M(null, h);
          } catch (A) {
            this.u.log(n.Error, `Stream 'error' callback called with '${h}' threw error: ${ut(A)}`);
          }
        });
      }
      Tt() {
        this.Ft && (clearTimeout(this.Ft), this.Ft = void 0);
      }
      Ct() {
        this.Ot && clearTimeout(this.Ot);
      }
      Mt(h, v, _, M) {
        if (_) return M.length !== 0 ? { arguments: v, streamIds: M, target: h, type: et.Invocation } : { arguments: v, target: h, type: et.Invocation };
        {
          const A = this.ct;
          return this.ct++, M.length !== 0 ? { arguments: v, invocationId: A.toString(), streamIds: M, target: h, type: et.Invocation } : { arguments: v, invocationId: A.toString(), target: h, type: et.Invocation };
        }
      }
      qt(h, v) {
        if (h.length !== 0) {
          v || (v = Promise.resolve());
          for (const _ in h) h[_].subscribe({ complete: /* @__PURE__ */ c(() => {
            v = v.then(() => this.xt(this.Bt(_)));
          }, "complete"), error: /* @__PURE__ */ c((M) => {
            let A;
            A = M instanceof Error ? M.message : M && M.toString ? M.toString() : "Unknown error", v = v.then(() => this.xt(this.Bt(_, A)));
          }, "error"), next: /* @__PURE__ */ c((M) => {
            v = v.then(() => this.xt(this.Vt(_, M)));
          }, "next") });
        }
      }
      Ut(h) {
        const v = [], _ = [];
        for (let M = 0; M < h.length; M++) {
          const A = h[M];
          if (this.Kt(A)) {
            const R = this.ct;
            this.ct++, v[R] = A, _.push(R.toString()), h.splice(M, 1);
          }
        }
        return [v, _];
      }
      Kt(h) {
        return h && h.subscribe && typeof h.subscribe == "function";
      }
      Lt(h, v, _) {
        const M = this.ct;
        return this.ct++, _.length !== 0 ? { arguments: v, invocationId: M.toString(), streamIds: _, target: h, type: et.StreamInvocation } : { arguments: v, invocationId: M.toString(), target: h, type: et.StreamInvocation };
      }
      Nt(h) {
        return { invocationId: h, type: et.CancelInvocation };
      }
      Vt(h, v) {
        return { invocationId: h, item: v, type: et.StreamItem };
      }
      Bt(h, v, _) {
        return v ? { error: v, invocationId: h, type: et.Completion } : { invocationId: h, result: _, type: et.Completion };
      }
      At() {
        return { type: et.Close };
      }
    };
    c(Cc, "q");
    let $s = Cc;
    const Il = [0, 2e3, 1e4, 3e4, null], ld = class ld {
      constructor(h) {
        this.Gt = h !== void 0 ? [...h, null] : Il;
      }
      nextRetryDelayInMilliseconds(h) {
        return this.Gt[h.previousRetryCount];
      }
    };
    c(ld, "j");
    let lr = ld;
    const dd = class dd {
    };
    c(dd, "W");
    let Te = dd;
    Te.Authorization = "Authorization", Te.Cookie = "Cookie";
    const hd = class hd extends k {
      constructor(h, v) {
        super(), this.Qt = h, this.Yt = v;
      }
      async send(h) {
        let v = !0;
        this.Yt && (!this.Zt || h.url && h.url.indexOf("/negotiate?") > 0) && (v = !1, this.Zt = await this.Yt()), this.te(h);
        const _ = await this.Qt.send(h);
        return v && _.statusCode === 401 && this.Yt ? (this.Zt = await this.Yt(), this.te(h), await this.Qt.send(h)) : _;
      }
      te(h) {
        h.headers || (h.headers = {}), this.Zt ? h.headers[Te.Authorization] = `Bearer ${this.Zt}` : this.Yt && h.headers[Te.Authorization] && delete h.headers[Te.Authorization];
      }
      getCookieString(h) {
        return this.Qt.getCookieString(h);
      }
    };
    c(hd, "O");
    let bo = hd;
    var Et, re;
    (function(F) {
      F[F.None = 0] = "None", F[F.WebSockets = 1] = "WebSockets", F[F.ServerSentEvents = 2] = "ServerSentEvents", F[F.LongPolling = 4] = "LongPolling";
    })(Et || (Et = {})), function(F) {
      F[F.Text = 1] = "Text", F[F.Binary = 2] = "Binary";
    }(re || (re = {}));
    const pd = class pd {
      constructor() {
        this.ee = !1, this.onabort = null;
      }
      abort() {
        this.ee || (this.ee = !0, this.onabort && this.onabort());
      }
      get signal() {
        return this;
      }
      get aborted() {
        return this.ee;
      }
    };
    c(pd, "X");
    let Tl = pd;
    const ud = class ud {
      get pollAborted() {
        return this.se.aborted;
      }
      constructor(h, v, _) {
        this.$ = h, this.u = v, this.se = new Tl(), this.ie = _, this.ne = !1, this.onreceive = null, this.onclose = null;
      }
      async connect(h, v) {
        if (E.isRequired(h, "url"), E.isRequired(v, "transferFormat"), E.isIn(v, re, "transferFormat"), this.re = h, this.u.log(n.Trace, "(LongPolling transport) Connecting."), v === re.Binary && typeof XMLHttpRequest < "u" && typeof new XMLHttpRequest().responseType != "string") throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");
        const [_, M] = H(), A = { [_]: M, ...this.ie.headers }, R = { abortSignal: this.se.signal, headers: A, timeout: 1e5, withCredentials: this.ie.withCredentials };
        v === re.Binary && (R.responseType = "arraybuffer");
        const K = `${h}&_=${Date.now()}`;
        this.u.log(n.Trace, `(LongPolling transport) polling: ${K}.`);
        const Y = await this.$.get(K, R);
        Y.statusCode !== 200 ? (this.u.log(n.Error, `(LongPolling transport) Unexpected response code: ${Y.statusCode}.`), this.oe = new o(Y.statusText || "", Y.statusCode), this.ne = !1) : this.ne = !0, this.he = this.ce(this.re, R);
      }
      async ce(h, v) {
        try {
          for (; this.ne; ) try {
            const _ = `${h}&_=${Date.now()}`;
            this.u.log(n.Trace, `(LongPolling transport) polling: ${_}.`);
            const M = await this.$.get(_, v);
            M.statusCode === 204 ? (this.u.log(n.Information, "(LongPolling transport) Poll terminated by server."), this.ne = !1) : M.statusCode !== 200 ? (this.u.log(n.Error, `(LongPolling transport) Unexpected response code: ${M.statusCode}.`), this.oe = new o(M.statusText || "", M.statusCode), this.ne = !1) : M.content ? (this.u.log(n.Trace, `(LongPolling transport) data received. ${U(M.content, this.ie.logMessageContent)}.`), this.onreceive && this.onreceive(M.content)) : this.u.log(n.Trace, "(LongPolling transport) Poll timed out, reissuing.");
          } catch (_) {
            this.ne ? _ instanceof l ? this.u.log(n.Trace, "(LongPolling transport) Poll timed out, reissuing.") : (this.oe = _, this.ne = !1) : this.u.log(n.Trace, `(LongPolling transport) Poll errored after shutdown: ${_.message}`);
          }
        } finally {
          this.u.log(n.Trace, "(LongPolling transport) Polling complete."), this.pollAborted || this.ae();
        }
      }
      async send(h) {
        return this.ne ? V(this.u, "LongPolling", this.$, this.re, h, this.ie) : Promise.reject(new Error("Cannot send until the transport is connected"));
      }
      async stop() {
        this.u.log(n.Trace, "(LongPolling transport) Stopping polling."), this.ne = !1, this.se.abort();
        try {
          await this.he, this.u.log(n.Trace, `(LongPolling transport) sending DELETE request to ${this.re}.`);
          const h = {}, [v, _] = H();
          h[v] = _;
          const M = { headers: { ...h, ...this.ie.headers }, timeout: this.ie.timeout, withCredentials: this.ie.withCredentials };
          let A;
          try {
            await this.$.delete(this.re, M);
          } catch (R) {
            A = R;
          }
          A ? A instanceof o && (A.statusCode === 404 ? this.u.log(n.Trace, "(LongPolling transport) A 404 response was returned from sending a DELETE request.") : this.u.log(n.Trace, `(LongPolling transport) Error sending a DELETE request: ${A}`)) : this.u.log(n.Trace, "(LongPolling transport) DELETE request accepted.");
        } finally {
          this.u.log(n.Trace, "(LongPolling transport) Stop finished."), this.ae();
        }
      }
      ae() {
        if (this.onclose) {
          let h = "(LongPolling transport) Firing onclose event.";
          this.oe && (h += " Error: " + this.oe), this.u.log(n.Trace, h), this.onclose(this.oe);
        }
      }
    };
    c(ud, "J");
    let $c = ud;
    const yd = class yd {
      constructor(h, v, _, M) {
        this.$ = h, this.Zt = v, this.u = _, this.ie = M, this.onreceive = null, this.onclose = null;
      }
      async connect(h, v) {
        return E.isRequired(h, "url"), E.isRequired(v, "transferFormat"), E.isIn(v, re, "transferFormat"), this.u.log(n.Trace, "(SSE transport) Connecting."), this.re = h, this.Zt && (h += (h.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(this.Zt)}`), new Promise((_, M) => {
          let A, R = !1;
          if (v === re.Text) {
            if (z.isBrowser || z.isWebWorker) A = new this.ie.EventSource(h, { withCredentials: this.ie.withCredentials });
            else {
              const K = this.$.getCookieString(h), Y = {};
              Y.Cookie = K;
              const [ot, $t] = H();
              Y[ot] = $t, A = new this.ie.EventSource(h, { withCredentials: this.ie.withCredentials, headers: { ...Y, ...this.ie.headers } });
            }
            try {
              A.onmessage = (K) => {
                if (this.onreceive) try {
                  this.u.log(n.Trace, `(SSE transport) data received. ${U(K.data, this.ie.logMessageContent)}.`), this.onreceive(K.data);
                } catch (Y) {
                  return void this.le(Y);
                }
              }, A.onerror = (K) => {
                R ? this.le() : M(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled."));
              }, A.onopen = () => {
                this.u.log(n.Information, `SSE connected to ${this.re}`), this.ue = A, R = !0, _();
              };
            } catch (K) {
              return void M(K);
            }
          } else M(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));
        });
      }
      async send(h) {
        return this.ue ? V(this.u, "SSE", this.$, this.re, h, this.ie) : Promise.reject(new Error("Cannot send until the transport is connected"));
      }
      stop() {
        return this.le(), Promise.resolve();
      }
      le(h) {
        this.ue && (this.ue.close(), this.ue = void 0, this.onclose && this.onclose(h));
      }
    };
    c(yd, "z");
    let Fl = yd;
    const wd = class wd {
      constructor(h, v, _, M, A, R) {
        this.u = _, this.Yt = v, this.de = M, this.fe = A, this.$ = h, this.onreceive = null, this.onclose = null, this.pe = R;
      }
      async connect(h, v) {
        let _;
        return E.isRequired(h, "url"), E.isRequired(v, "transferFormat"), E.isIn(v, re, "transferFormat"), this.u.log(n.Trace, "(WebSockets transport) Connecting."), this.Yt && (_ = await this.Yt()), new Promise((M, A) => {
          let R;
          h = h.replace(/^http/, "ws");
          const K = this.$.getCookieString(h);
          let Y = !1;
          if (z.isNode || z.isReactNative) {
            const ot = {}, [$t, ur] = H();
            ot[$t] = ur, _ && (ot[Te.Authorization] = `Bearer ${_}`), K && (ot[Te.Cookie] = K), R = new this.fe(h, void 0, { headers: { ...ot, ...this.pe } });
          } else _ && (h += (h.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(_)}`);
          R || (R = new this.fe(h)), v === re.Binary && (R.binaryType = "arraybuffer"), R.onopen = (ot) => {
            this.u.log(n.Information, `WebSocket connected to ${h}.`), this.we = R, Y = !0, M();
          }, R.onerror = (ot) => {
            let $t = null;
            $t = typeof ErrorEvent < "u" && ot instanceof ErrorEvent ? ot.error : "There was an error with the transport", this.u.log(n.Information, `(WebSockets transport) ${$t}.`);
          }, R.onmessage = (ot) => {
            if (this.u.log(n.Trace, `(WebSockets transport) data received. ${U(ot.data, this.de)}.`), this.onreceive) try {
              this.onreceive(ot.data);
            } catch ($t) {
              return void this.le($t);
            }
          }, R.onclose = (ot) => {
            if (Y) this.le(ot);
            else {
              let $t = null;
              $t = typeof ErrorEvent < "u" && ot instanceof ErrorEvent ? ot.error : "WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.", A(new Error($t));
            }
          };
        });
      }
      send(h) {
        return this.we && this.we.readyState === this.fe.OPEN ? (this.u.log(n.Trace, `(WebSockets transport) sending data. ${U(h, this.de)}.`), this.we.send(h), Promise.resolve()) : Promise.reject("WebSocket is not in the OPEN state");
      }
      stop() {
        return this.we && this.le(void 0), Promise.resolve();
      }
      le(h) {
        this.we && (this.we.onclose = () => {
        }, this.we.onmessage = () => {
        }, this.we.onerror = () => {
        }, this.we.close(), this.we = void 0), this.u.log(n.Trace, "(WebSockets transport) socket closed."), this.onclose && (!this.ge(h) || h.wasClean !== !1 && h.code === 1e3 ? h instanceof Error ? this.onclose(h) : this.onclose() : this.onclose(new Error(`WebSocket closed with status code: ${h.code} (${h.reason || "no reason given"}).`)));
      }
      ge(h) {
        return h && typeof h.wasClean == "boolean" && typeof h.code == "number";
      }
    };
    c(wd, "V");
    let Dl = wd;
    const fd = class fd {
      constructor(h, v = {}) {
        var _;
        if (this.me = () => {
        }, this.features = {}, this.ye = 1, E.isRequired(h, "url"), this.u = (_ = v.logger) === void 0 ? new N(n.Information) : _ === null ? S.instance : _.log !== void 0 ? _ : new N(_), this.baseUrl = this.be(h), (v = v || {}).logMessageContent = v.logMessageContent !== void 0 && v.logMessageContent, typeof v.withCredentials != "boolean" && v.withCredentials !== void 0) throw new Error("withCredentials option was not a 'boolean' or 'undefined' value");
        v.withCredentials = v.withCredentials === void 0 || v.withCredentials, v.timeout = v.timeout === void 0 ? 1e5 : v.timeout;
        let M = null, A = null;
        if (z.isNode) {
          const R = $d;
          M = R("ws"), A = R("eventsource");
        }
        z.isNode || typeof WebSocket > "u" || v.WebSocket ? z.isNode && !v.WebSocket && M && (v.WebSocket = M) : v.WebSocket = WebSocket, z.isNode || typeof EventSource > "u" || v.EventSource ? z.isNode && !v.EventSource && A !== void 0 && (v.EventSource = A) : v.EventSource = EventSource, this.$ = new bo(v.httpClient || new Bt(this.u), v.accessTokenFactory), this.ut = "Disconnected", this.dt = !1, this.ie = v, this.onreceive = null, this.onclose = null;
      }
      async start(h) {
        if (h = h || re.Binary, E.isIn(h, re, "transferFormat"), this.u.log(n.Debug, `Starting connection with transfer format '${re[h]}'.`), this.ut !== "Disconnected") return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."));
        if (this.ut = "Connecting", this.ve = this.yt(h), await this.ve, this.ut === "Disconnecting") {
          const v = "Failed to start the HttpConnection before stop() was called.";
          return this.u.log(n.Error, v), await this.It, Promise.reject(new d(v));
        }
        if (this.ut !== "Connected") {
          const v = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";
          return this.u.log(n.Error, v), Promise.reject(new d(v));
        }
        this.dt = !0;
      }
      send(h) {
        return this.ut !== "Connected" ? Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State.")) : (this.Ee || (this.Ee = new Vl(this.transport)), this.Ee.send(h));
      }
      async stop(h) {
        return this.ut === "Disconnected" ? (this.u.log(n.Debug, `Call to HttpConnection.stop(${h}) ignored because the connection is already in the disconnected state.`), Promise.resolve()) : this.ut === "Disconnecting" ? (this.u.log(n.Debug, `Call to HttpConnection.stop(${h}) ignored because the connection is already in the disconnecting state.`), this.It) : (this.ut = "Disconnecting", this.It = new Promise((v) => {
          this.me = v;
        }), await this._t(h), void await this.It);
      }
      async _t(h) {
        this.$e = h;
        try {
          await this.ve;
        } catch {
        }
        if (this.transport) {
          try {
            await this.transport.stop();
          } catch (v) {
            this.u.log(n.Error, `HttpConnection.transport.stop() threw error '${v}'.`), this.Ce();
          }
          this.transport = void 0;
        } else this.u.log(n.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.");
      }
      async yt(h) {
        let v = this.baseUrl;
        this.Yt = this.ie.accessTokenFactory, this.$.Yt = this.Yt;
        try {
          if (this.ie.skipNegotiation) {
            if (this.ie.transport !== Et.WebSockets) throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");
            this.transport = this.Se(Et.WebSockets), await this.ke(v, h);
          } else {
            let _ = null, M = 0;
            do {
              if (_ = await this.Pe(v), this.ut === "Disconnecting" || this.ut === "Disconnected") throw new d("The connection was stopped during negotiation.");
              if (_.error) throw new Error(_.error);
              if (_.ProtocolVersion) throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");
              if (_.url && (v = _.url), _.accessToken) {
                const A = _.accessToken;
                this.Yt = () => A, this.$.Zt = A, this.$.Yt = void 0;
              }
              M++;
            } while (_.url && M < 100);
            if (M === 100 && _.url) throw new Error("Negotiate redirection limit exceeded.");
            await this.Te(v, this.ie.transport, _, h);
          }
          this.transport instanceof $c && (this.features.inherentKeepAlive = !0), this.ut === "Connecting" && (this.u.log(n.Debug, "The HttpConnection connected successfully."), this.ut = "Connected");
        } catch (_) {
          return this.u.log(n.Error, "Failed to start the connection: " + _), this.ut = "Disconnected", this.transport = void 0, this.me(), Promise.reject(_);
        }
      }
      async Pe(h) {
        const v = {}, [_, M] = H();
        v[_] = M;
        const A = this.Ie(h);
        this.u.log(n.Debug, `Sending negotiation request: ${A}.`);
        try {
          const R = await this.$.post(A, { content: "", headers: { ...v, ...this.ie.headers }, timeout: this.ie.timeout, withCredentials: this.ie.withCredentials });
          if (R.statusCode !== 200) return Promise.reject(new Error(`Unexpected status code returned from negotiate '${R.statusCode}'`));
          const K = JSON.parse(R.content);
          return (!K.negotiateVersion || K.negotiateVersion < 1) && (K.connectionToken = K.connectionId), K.useStatefulReconnect && this.ie._e !== !0 ? Promise.reject(new f("Client didn't negotiate Stateful Reconnect but the server did.")) : K;
        } catch (R) {
          let K = "Failed to complete negotiation with the server: " + R;
          return R instanceof o && R.statusCode === 404 && (K += " Either this is not a SignalR endpoint or there is a proxy blocking the connection."), this.u.log(n.Error, K), Promise.reject(new f(K));
        }
      }
      He(h, v) {
        return v ? h + (h.indexOf("?") === -1 ? "?" : "&") + `id=${v}` : h;
      }
      async Te(h, v, _, M) {
        let A = this.He(h, _.connectionToken);
        if (this.De(v)) return this.u.log(n.Debug, "Connection was provided an instance of ITransport, using that directly."), this.transport = v, await this.ke(A, M), void (this.connectionId = _.connectionId);
        const R = [], K = _.availableTransports || [];
        let Y = _;
        for (const ot of K) {
          const $t = this.Re(ot, v, M, (Y == null ? void 0 : Y.useStatefulReconnect) === !0);
          if ($t instanceof Error) R.push(`${ot.transport} failed:`), R.push($t);
          else if (this.De($t)) {
            if (this.transport = $t, !Y) {
              try {
                Y = await this.Pe(h);
              } catch (ur) {
                return Promise.reject(ur);
              }
              A = this.He(h, Y.connectionToken);
            }
            try {
              return await this.ke(A, M), void (this.connectionId = Y.connectionId);
            } catch (ur) {
              if (this.u.log(n.Error, `Failed to start the transport '${ot.transport}': ${ur}`), Y = void 0, R.push(new m(`${ot.transport} failed: ${ur}`, Et[ot.transport])), this.ut !== "Connecting") {
                const qp = "Failed to select transport before stop() was called.";
                return this.u.log(n.Debug, qp), Promise.reject(new d(qp));
              }
            }
          }
        }
        return R.length > 0 ? Promise.reject(new g(`Unable to connect to the server with any of the available transports. ${R.join(" ")}`, R)) : Promise.reject(new Error("None of the transports supported by the client are supported by the server."));
      }
      Se(h) {
        switch (h) {
          case Et.WebSockets:
            if (!this.ie.WebSocket) throw new Error("'WebSocket' is not supported in your environment.");
            return new Dl(this.$, this.Yt, this.u, this.ie.logMessageContent, this.ie.WebSocket, this.ie.headers || {});
          case Et.ServerSentEvents:
            if (!this.ie.EventSource) throw new Error("'EventSource' is not supported in your environment.");
            return new Fl(this.$, this.$.Zt, this.u, this.ie);
          case Et.LongPolling:
            return new $c(this.$, this.u, this.ie);
          default:
            throw new Error(`Unknown transport: ${h}.`);
        }
      }
      ke(h, v) {
        return this.transport.onreceive = this.onreceive, this.features.reconnect ? this.transport.onclose = async (_) => {
          let M = !1;
          if (this.features.reconnect) {
            try {
              this.features.disconnected(), await this.transport.connect(h, v), await this.features.resend();
            } catch {
              M = !0;
            }
            M && this.Ce(_);
          } else this.Ce(_);
        } : this.transport.onclose = (_) => this.Ce(_), this.transport.connect(h, v);
      }
      Re(h, v, _, M) {
        const A = Et[h.transport];
        if (A == null) return this.u.log(n.Debug, `Skipping transport '${h.transport}' because it is not supported by this client.`), new Error(`Skipping transport '${h.transport}' because it is not supported by this client.`);
        if (!function(R, K) {
          return !R || (K & R) != 0;
        }(v, A)) return this.u.log(n.Debug, `Skipping transport '${Et[A]}' because it was disabled by the client.`), new y(`'${Et[A]}' is disabled by the client.`, A);
        if (!(h.transferFormats.map((R) => re[R]).indexOf(_) >= 0)) return this.u.log(n.Debug, `Skipping transport '${Et[A]}' because it does not support the requested transfer format '${re[_]}'.`), new Error(`'${Et[A]}' does not support ${re[_]}.`);
        if (A === Et.WebSockets && !this.ie.WebSocket || A === Et.ServerSentEvents && !this.ie.EventSource) return this.u.log(n.Debug, `Skipping transport '${Et[A]}' because it is not supported in your environment.'`), new u(`'${Et[A]}' is not supported in your environment.`, A);
        this.u.log(n.Debug, `Selecting transport '${Et[A]}'.`);
        try {
          return this.features.reconnect = A === Et.WebSockets ? M : void 0, this.Se(A);
        } catch (R) {
          return R;
        }
      }
      De(h) {
        return h && typeof h == "object" && "connect" in h;
      }
      Ce(h) {
        if (this.u.log(n.Debug, `HttpConnection.stopConnection(${h}) called while in state ${this.ut}.`), this.transport = void 0, h = this.$e || h, this.$e = void 0, this.ut !== "Disconnected") {
          if (this.ut === "Connecting") throw this.u.log(n.Warning, `Call to HttpConnection.stopConnection(${h}) was ignored because the connection is still in the connecting state.`), new Error(`HttpConnection.stopConnection(${h}) was called while the connection is still in the connecting state.`);
          if (this.ut === "Disconnecting" && this.me(), h ? this.u.log(n.Error, `Connection disconnected with error '${h}'.`) : this.u.log(n.Information, "Connection disconnected."), this.Ee && (this.Ee.stop().catch((v) => {
            this.u.log(n.Error, `TransportSendQueue.stop() threw error '${v}'.`);
          }), this.Ee = void 0), this.connectionId = void 0, this.ut = "Disconnected", this.dt) {
            this.dt = !1;
            try {
              this.onclose && this.onclose(h);
            } catch (v) {
              this.u.log(n.Error, `HttpConnection.onclose(${h}) threw error '${v}'.`);
            }
          }
        } else this.u.log(n.Debug, `Call to HttpConnection.stopConnection(${h}) was ignored because the connection is already in the disconnected state.`);
      }
      be(h) {
        if (h.lastIndexOf("https://", 0) === 0 || h.lastIndexOf("http://", 0) === 0) return h;
        if (!z.isBrowser) throw new Error(`Cannot resolve '${h}'.`);
        const v = window.document.createElement("a");
        return v.href = h, this.u.log(n.Information, `Normalizing '${h}' to '${v.href}'.`), v.href;
      }
      Ie(h) {
        const v = new URL(h);
        v.pathname.endsWith("/") ? v.pathname += "negotiate" : v.pathname += "/negotiate";
        const _ = new URLSearchParams(v.searchParams);
        return _.has("negotiateVersion") || _.append("negotiateVersion", this.ye.toString()), _.has("useStatefulReconnect") ? _.get("useStatefulReconnect") === "true" && (this.ie._e = !0) : this.ie._e === !0 && _.append("useStatefulReconnect", "true"), v.search = _.toString(), v.toString();
      }
    };
    c(fd, "K");
    let Hl = fd;
    const _c = class _c {
      constructor(h) {
        this.xe = h, this.Ae = [], this.Ue = !0, this.Le = new dr(), this.Ne = new dr(), this.qe = this.Me();
      }
      send(h) {
        return this.je(h), this.Ne || (this.Ne = new dr()), this.Ne.promise;
      }
      stop() {
        return this.Ue = !1, this.Le.resolve(), this.qe;
      }
      je(h) {
        if (this.Ae.length && typeof this.Ae[0] != typeof h) throw new Error(`Expected data to be of type ${typeof this.Ae} but was of type ${typeof h}`);
        this.Ae.push(h), this.Le.resolve();
      }
      async Me() {
        for (; ; ) {
          if (await this.Le.promise, !this.Ue) {
            this.Ne && this.Ne.reject("Connection stopped.");
            break;
          }
          this.Le = new dr();
          const h = this.Ne;
          this.Ne = void 0;
          const v = typeof this.Ae[0] == "string" ? this.Ae.join("") : _c.We(this.Ae);
          this.Ae.length = 0;
          try {
            await this.xe.send(v), h.resolve();
          } catch (_) {
            h.reject(_);
          }
        }
      }
      static We(h) {
        const v = h.map((A) => A.byteLength).reduce((A, R) => A + R), _ = new Uint8Array(v);
        let M = 0;
        for (const A of h) _.set(new Uint8Array(A), M), M += A.byteLength;
        return _.buffer;
      }
    };
    c(_c, "G");
    let Vl = _c;
    const md = class md {
      constructor() {
        this.promise = new Promise((h, v) => [this.j, this.Oe] = [h, v]);
      }
      resolve() {
        this.j();
      }
      reject(h) {
        this.Oe(h);
      }
    };
    c(md, "Q");
    let dr = md;
    const vd = class vd {
      constructor() {
        this.name = "json", this.version = 2, this.transferFormat = re.Text;
      }
      parseMessages(h, v) {
        if (typeof h != "string") throw new Error("Invalid input for JSON hub protocol. Expected a string.");
        if (!h) return [];
        v === null && (v = S.instance);
        const _ = Ct.parse(h), M = [];
        for (const A of _) {
          const R = JSON.parse(A);
          if (typeof R.type != "number") throw new Error("Invalid payload.");
          switch (R.type) {
            case et.Invocation:
              this.U(R);
              break;
            case et.StreamItem:
              this.Fe(R);
              break;
            case et.Completion:
              this.Be(R);
              break;
            case et.Ping:
            case et.Close:
              break;
            case et.Ack:
              this.Xe(R);
              break;
            case et.Sequence:
              this.Je(R);
              break;
            default:
              v.log(n.Information, "Unknown message type '" + R.type + "' ignored.");
              continue;
          }
          M.push(R);
        }
        return M;
      }
      writeMessage(h) {
        return Ct.write(JSON.stringify(h));
      }
      U(h) {
        this.ze(h.target, "Invalid payload for Invocation message."), h.invocationId !== void 0 && this.ze(h.invocationId, "Invalid payload for Invocation message.");
      }
      Fe(h) {
        if (this.ze(h.invocationId, "Invalid payload for StreamItem message."), h.item === void 0) throw new Error("Invalid payload for StreamItem message.");
      }
      Be(h) {
        if (h.result && h.error) throw new Error("Invalid payload for Completion message.");
        !h.result && h.error && this.ze(h.error, "Invalid payload for Completion message."), this.ze(h.invocationId, "Invalid payload for Completion message.");
      }
      Xe(h) {
        if (typeof h.sequenceId != "number") throw new Error("Invalid SequenceId for Ack message.");
      }
      Je(h) {
        if (typeof h.sequenceId != "number") throw new Error("Invalid SequenceId for Sequence message.");
      }
      ze(h, v) {
        if (typeof h != "string" || h === "") throw new Error(v);
      }
    };
    c(vd, "Y");
    let kc = vd;
    const _f = { trace: n.Trace, debug: n.Debug, info: n.Information, information: n.Information, warn: n.Warning, warning: n.Warning, error: n.Error, critical: n.Critical, none: n.None }, gd = class gd {
      configureLogging(h) {
        if (E.isRequired(h, "logging"), h.log !== void 0) this.logger = h;
        else if (typeof h == "string") {
          const v = function(_) {
            const M = _f[_.toLowerCase()];
            if (M !== void 0) return M;
            throw new Error(`Unknown log level: ${_}`);
          }(h);
          this.logger = new N(v);
        } else this.logger = new N(h);
        return this;
      }
      withUrl(h, v) {
        return E.isRequired(h, "url"), E.isNotEmpty(h, "url"), this.url = h, this.httpConnectionOptions = typeof v == "object" ? { ...this.httpConnectionOptions, ...v } : { ...this.httpConnectionOptions, transport: v }, this;
      }
      withHubProtocol(h) {
        return E.isRequired(h, "protocol"), this.protocol = h, this;
      }
      withAutomaticReconnect(h) {
        if (this.reconnectPolicy) throw new Error("A reconnectPolicy has already been set.");
        return h ? Array.isArray(h) ? this.reconnectPolicy = new lr(h) : this.reconnectPolicy = h : this.reconnectPolicy = new lr(), this;
      }
      withServerTimeout(h) {
        return E.isRequired(h, "milliseconds"), this.Ve = h, this;
      }
      withKeepAliveInterval(h) {
        return E.isRequired(h, "milliseconds"), this.Ke = h, this;
      }
      withStatefulReconnect(h) {
        return this.httpConnectionOptions === void 0 && (this.httpConnectionOptions = {}), this.httpConnectionOptions._e = !0, this.Y = h == null ? void 0 : h.bufferSize, this;
      }
      build() {
        const h = this.httpConnectionOptions || {};
        if (h.logger === void 0 && (h.logger = this.logger), !this.url) throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");
        const v = new Hl(this.url, h);
        return $s.create(v, this.logger || S.instance, this.protocol || new kc(), this.reconnectPolicy, this.Ve, this.Ke, this.Y);
      }
    };
    c(gd, "tt");
    let Bl = gd;
    return Uint8Array.prototype.indexOf || Object.defineProperty(Uint8Array.prototype, "indexOf", { value: Array.prototype.indexOf, writable: !0 }), Uint8Array.prototype.slice || Object.defineProperty(Uint8Array.prototype, "slice", { value: /* @__PURE__ */ c(function(F, h) {
      return new Uint8Array(Array.prototype.slice.call(this, F, h));
    }, "value"), writable: !0 }), Uint8Array.prototype.forEach || Object.defineProperty(Uint8Array.prototype, "forEach", { value: Array.prototype.forEach, writable: !0 }), a;
  })(), "e"), r.exports = i();
})(Ey);
var Jp = Ey.exports;
const C1 = /* @__PURE__ */ c((r) => {
  var t;
  return t = class extends r {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this._whenConnectionRequested = new Promise((n) => {
        this._resolveConnectionRequested = n;
      }), this._whenConnectionCreated = new Promise((n) => {
        this._resolveConnectionCreated = n;
      }), this._connectionEventListeners = [], this.signalRAccessTokenRefresh = !1, this._whenConnectionStarted = new Promise((n, a) => {
        this._whenConnectionStartedResolve = n, this._whenConnectionStartedReject = a;
      }), this.whenConnectionRequested().then(() => {
        this.isDestroyed || this.createConnection();
      });
    }
    async whenConnectionRequested() {
      await this._whenConnectionRequested;
    }
    async whenConnectionCreated() {
      return await this._whenConnectionCreated;
    }
    get rtmConnection() {
      return this._connection;
    }
    async whenConnectionStarted() {
      return await this._whenConnectionStarted;
    }
    async createConnection() {
      var s;
      if (this.isDestroyed)
        throw new At();
      if (this.networkStateIsPending = !0, await this.whenUrlAndTokenFactory(), this._connection) {
        const n = new URL("/hubs/rtm", this.url);
        this._connection.baseUrl !== n.toString() && (this.connectionState = "reconnecting", console.info(
          this.weavyId,
          "Reconnecting due to changed url.",
          this._connection.baseUrl,
          "=>",
          n.toString()
        ), await this.disconnect(), this._connection.baseUrl = n.toString(), this.connect());
      } else {
        this.connectionState = "connecting";
        const n = new URL("/hubs/rtm", this.url);
        this._connection = new Jp.HubConnectionBuilder().configureLogging(Jp.LogLevel.None).withUrl(n.toString(), {
          accessTokenFactory: /* @__PURE__ */ c(async () => {
            try {
              if (this.signalRAccessTokenRefresh) {
                const a = await this.getToken(!0);
                return this.signalRAccessTokenRefresh = !1, a;
              } else
                return await this.getToken();
            } catch (a) {
              throw console.error(a), a;
            }
          }, "accessTokenFactory")
        }).withAutomaticReconnect({
          nextRetryDelayInMilliseconds: /* @__PURE__ */ c((a) => !this.isDestroyed && window.navigator.onLine && (document == null ? void 0 : document.visibilityState) !== "hidden" && a.elapsedMilliseconds < 6e4 ? [0, 2e3, 1e4][a.previousRetryCount] || 1e4 : null, "nextRetryDelayInMilliseconds")
        }).build(), this._connection.onclose(async () => {
          console.info(this.weavyId, "SignalR closed."), this.connectionState = "disconnected", !this.isDestroyed && (this.networkStateIsPending = !0, this._whenConnectionStarted = new Promise((a, o) => {
            this._whenConnectionStartedResolve = a, this._whenConnectionStartedReject = o;
          }), this.connect());
        }), this._connection.onreconnecting(() => {
          console.info(this.weavyId, "SignalR reconnecting..."), this.connectionState = "reconnecting";
        }), this._connection.onreconnected(() => {
          var a;
          console.info(this.weavyId, "SignalR reconnected."), this.connectionState = "connected", this.networkStateIsPending = !1;
          for (let o = 0; o < this._connectionEventListeners.length; o++)
            (a = this._connection) == null || a.invoke("Subscribe", this._connectionEventListeners[o].name);
        }), (s = this._resolveConnectionCreated) == null || s.call(this, this._connection), this.connect();
      }
      return this._connection;
    }
    async disconnect() {
      this._connection && (await this._connection.stop(), this.connectionState = "disconnected");
    }
    async connect() {
      var n;
      if (this.isDestroyed)
        throw new At();
      let s;
      this._connection ? s = this._connection : s = await this.whenConnectionCreated(), console.info(this.weavyId, "Connecting SignalR...");
      try {
        if (!window.navigator.onLine)
          throw new Error();
        await Promise.race([s.start(), this.whenConnectionStarted()]), this.signalRAccessTokenRefresh = !1, this.networkStateIsPending = !1, this.connectionState = "connected", (n = this._whenConnectionStartedResolve) == null || n.call(this, s), console.info(this.weavyId, "SignalR connected.");
      } catch (a) {
        if (a instanceof At)
          return console.warn(this.weavyId, "SignalR connection aborted."), s;
        window.navigator.onLine ? !this.signalRAccessTokenRefresh && window.document.visibilityState !== "hidden" && a.toString().includes("Unauthorized") ? (console.info(this.weavyId, "Retrying SignalR connect with fresh token."), this.signalRAccessTokenRefresh = !0) : (console.info(
          this.weavyId,
          "Server is probably down, retrying SignalR connect after a delay or when window regains focus."
        ), this.connectionState = "reconnecting", await new Promise((o) => {
          setTimeout(o, 5e3), window.addEventListener("visibilitychange", o, { once: !0 }), window.addEventListener("offline", o, { once: !0 }), window.addEventListener("online", o, { once: !0 });
        })) : (this.networkStateIsPending = !1, console.info(this.weavyId, "Offline, reconnecting SignalR when online."), await new Promise((o) => {
          window.addEventListener("online", o, { once: !0 });
        })), window.navigator.onLine && (document == null ? void 0 : document.visibilityState) !== "hidden" && await new Promise((o) => setTimeout(o, 1e3)), this.checkVersion(), this.networkStateIsPending = !0, await this.connect();
      }
      return s;
    }
    async subscribe(s, n, a) {
      var o;
      if (this.isDestroyed)
        throw new At();
      (o = this._resolveConnectionRequested) == null || o.call(this, !0);
      try {
        const l = s ? s + ":" + n : n;
        if (this._connectionEventListeners || await new Promise((d) => queueMicrotask(() => d(!0))), this._connectionEventListeners.some((d) => d.name === l && d.callback === a))
          throw new Error("Duplicate subscribe: " + l);
        if (this._connectionEventListeners.push({ name: l, callback: a }), await this.whenConnectionStarted(), !this._connection)
          throw new Error("Connection not created");
        this._connection.on(l, a), await this._connection.invoke("Subscribe", l);
      } catch (l) {
        l instanceof At || console.error(this.weavyId, "Error in Subscribe:", l);
      }
    }
    async unsubscribe(s, n, a) {
      var o;
      if (this.isDestroyed)
        throw new At();
      try {
        const l = s ? s + ":" + n : n, d = this._connectionEventListeners.findIndex((u) => u.name === l && u.callback === a);
        if (d !== -1) {
          if (this._connectionEventListeners.splice(d, 1), await this.whenConnectionStarted(), !this._connection)
            throw new Error("Connection not created");
          (o = this._connection) == null || o.off(l, a), this._connectionEventListeners.some((u) => u.name === l) || await this._connection.invoke("Unsubscribe", l);
        }
      } catch (l) {
        l instanceof At || console.error(this.weavyId, "Error in Unsubscribe:", l);
      }
    }
    destroy() {
      super.destroy(), this.disconnect(), this._whenConnectionStartedReject && (this._whenConnectionStarted.catch(() => {
      }), this._whenConnectionStartedReject(new At()));
    }
  }, c(t, "WeavyConnection"), t;
}, "WeavyConnectionMixin");
var Dc = /* @__PURE__ */ ((r) => (r.JSON = "application/json;charset=utf-8", r.FormData = "multipart/form-data;charset=utf-8", r.URLEncoded = "application/x-www-form-urlencoded;charset=utf-8", r.Text = "text/plain;charset=utf-8", r.Auto = "", r))(Dc || {});
const _1 = /* @__PURE__ */ c((r) => {
  var t;
  return t = class extends r {
    // FETCH
    async fetchOptions(s = {}, n = !0) {
      if (this.isDestroyed)
        throw new At();
      const a = {
        headers: {
          "X-Weavy-Source": `${Ze.sourceName}@${Ze.version}`,
          "Content-Type": Dc.JSON
        },
        method: "GET"
      }, o = Ec(Ec(Bf, a, !0), s, !0);
      return n ? Ec(
        o,
        {
          headers: {
            Authorization: "Bearer " + await this.getToken()
          }
        },
        !0
      ) : o;
    }
    async fetch(s, n, a = !0) {
      if (this.isDestroyed)
        throw new At();
      const o = await this.fetchOptions(n);
      this.networkStateIsPending = !0;
      const l = await fetch(new URL(s, this.url), o);
      if (l.ok)
        this.networkStateIsPending = !1, this.serverState = "ok";
      else if (l.status === 401 || l.status === 403) {
        if (a)
          return await this.getToken(!0), await this.fetch(s, n, !1);
        this.networkStateIsPending = !1, this.serverState = "unauthorized";
      } else
        this.networkStateIsPending = !1;
      return l;
    }
    async upload(s, n, a, o = Dc.JSON, l, d = !0) {
      if (this.isDestroyed)
        throw new At();
      const u = await this.getToken();
      return await new Promise((y, m) => {
        const f = new XMLHttpRequest();
        f.open(n, new URL(s, this.url), !0), f.setRequestHeader("Authorization", "Bearer " + u), f.setRequestHeader("X-Weavy-Source", `${Ze.sourceName}@${Ze.version}`), o && f.setRequestHeader("Content-Type", o), l && f.upload.addEventListener("progress", (g) => {
          l(g.loaded / g.total * 100 || 100);
        }), f.onload = (g) => {
          d && (f.status === 401 || f.status === 401) ? this.getToken(!0).then(() => this.upload(s, n, a, o, l, !1)).then(y).catch(m) : y(new Response(f.response, { status: f.status, statusText: f.statusText }));
        }, f.onerror = m, f.send(a);
      });
    }
    // DEPRECATED
    async get(s) {
      return console.warn(`weavy.get() is deprecated, use weavy.fetch("${s}") instead.`), this.fetch(s);
    }
    // DEPRECATED
    async post(s, n, a, o) {
      console.warn(
        `weavy.post() is deprecated, use weavy.fetch("${s}", { method: "${n}"}) instead.`
      );
      const l = o ? { "Content-Type": o } : void 0;
      return this.fetch(s, { method: n, body: a, headers: l });
    }
  }, c(t, "WeavyFetch"), t;
}, "WeavyFetchMixin"), Oy = "en", P1 = /* @__PURE__ */ c((r) => {
  var t;
  return t = class extends r {
    constructor() {
      super(...arguments), this._locales = /* @__PURE__ */ new Map([
        ["sv-SE", () => import(
          /* webpackIgnore: true */
          /* @vite-ignore */
          new URL("./es/locales/sv-SE.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
        ).then((s) => s.svSE)]
      ]), this._locale = t.sourceLocale;
    }
    /**
     * The locale used in the Weavy source.
     */
    static get sourceLocale() {
      try {
        return Oy;
      } catch {
        return "";
      }
    }
    get locales() {
      return Array.from(this._locales.entries());
    }
    set locales(s) {
      if (this.isDestroyed)
        throw new At();
      if (this.localization)
        throw new Error("Locales may only be configured once");
      if (s) {
        if (!Array.isArray(s))
          throw new TypeError("Provided locales have invalid format.");
        s.forEach((n) => {
          if (!Array.isArray(n) || n.length !== 2 || typeof n[0] != "string")
            throw new TypeError("Invalid locale provided: " + n[0]);
          this._locales.set(...n);
        }), this.configureLocalization();
      }
    }
    get localization() {
      return this._localization;
    }
    /**
     * Selected locale. The locale must be pre configured in `.locales`.
     */
    get locale() {
      return this._locale;
    }
    set locale(s) {
      if (this.isDestroyed)
        throw new At();
      !this.locale && !s || (s || (s = t.sourceLocale), this._locale = s, this.localization ? this.localization.setLocale(this.locale) : queueMicrotask(() => {
        this.localization ? this.localization.setLocale(this.locale) : this.locale !== t.sourceLocale && (this._locales.has(this.locale) && this.configureLocalization(), this.localization ? this.localization.setLocale(this.locale) : console.error(
          this.weavyId,
          `You need to configure additional languages in config to use '${s}'.`
        ));
      }));
    }
    async loadLocale(s) {
      var n;
      if (this.isDestroyed)
        throw new At();
      if ((n = this._locales) != null && n.has(s)) {
        const a = this._locales.get(s);
        return console.info(
          this.weavyId,
          typeof a == "function" ? "loading locale" : "preloaded locale",
          s
        ), await (typeof a == "function" ? a() : a);
      } else
        throw new Error("The requested locale is not configured");
    }
    configureLocalization() {
      var s;
      if (this.isDestroyed)
        throw new At();
      if ((s = this._locales) != null && s.size && !this.localization) {
        const n = this._locales.keys();
        console.info(this.weavyId, "Configuring locales", n);
        const { getLocale: a, setLocale: o } = Ef({
          sourceLocale: t.sourceLocale,
          targetLocales: n,
          loadLocale: /* @__PURE__ */ c((l) => this.loadLocale(l), "loadLocale")
        });
        this._localization = {
          getLocale: a,
          setLocale: o
        };
      }
    }
  }, c(t, "WeavyLocalization"), t;
}, "WeavyLocalizationMixin"), M1 = /* @__PURE__ */ c((r) => {
  var t;
  return t = class extends r {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this._networkEvents = /* @__PURE__ */ new Set(), this._connectionState = "connecting", this._serverState = "ok", this._networkState = window.navigator.onLine ? "online" : "offline", this._networkStateIsPending = !1, window.addEventListener("online", () => {
        this.networkState = "online";
      }), window.addEventListener("offline", () => {
        this.networkState = "offline", this.networkStateIsPending = !1;
      });
    }
    get networkState() {
      return this._networkState;
    }
    set networkState(s) {
      this._networkState = s, this.triggerNetworkChange();
    }
    get serverState() {
      return this._serverState;
    }
    set serverState(s) {
      this._serverState = s, this.triggerNetworkChange();
    }
    get connectionState() {
      return this._connectionState;
    }
    set connectionState(s) {
      this._connectionState = s, this.triggerNetworkChange();
    }
    get networkStateIsPending() {
      return this._networkStateIsPending;
    }
    set networkStateIsPending(s) {
      this._networkStateIsPending = s, this.triggerNetworkChange();
    }
    get network() {
      return {
        state: this._networkState === "online" ? this._connectionState === "connected" || this._serverState === "ok" ? "online" : "unreachable" : "offline",
        isPending: this._networkStateIsPending
      };
    }
    triggerNetworkChange() {
      const s = this.network;
      this._networkEvents.forEach((n) => {
        n(s);
      });
    }
    addNetworkListener(s) {
      this._networkEvents.add(s);
    }
    removeNetworkListener(s) {
      this._networkEvents.delete(s);
    }
  }, c(t, "WeavyNetwork"), t;
}, "WeavyNetworkMixin");
function kd() {
}
c(kd, "noop");
function z1({
  storage: r,
  key: t = "REACT_QUERY_OFFLINE_CACHE",
  throttleTime: i = 1e3,
  serialize: s = JSON.stringify,
  deserialize: n = JSON.parse,
  retry: a
}) {
  if (r) {
    const o = /* @__PURE__ */ c((l) => {
      try {
        r.setItem(t, s(l));
        return;
      } catch (d) {
        return d;
      }
    }, "trySave");
    return {
      persistClient: S1((l) => {
        let d = l, u = o(d), y = 0;
        for (; u && d; )
          y++, d = a == null ? void 0 : a({
            persistedClient: d,
            error: u,
            errorCount: y
          }), d && (u = o(d));
      }, i),
      restoreClient: /* @__PURE__ */ c(() => {
        const l = r.getItem(t);
        if (l)
          return n(l);
      }, "restoreClient"),
      removeClient: /* @__PURE__ */ c(() => {
        r.removeItem(t);
      }, "removeClient")
    };
  }
  return {
    persistClient: kd,
    restoreClient: kd,
    removeClient: kd
  };
}
c(z1, "createSyncStoragePersister");
function S1(r, t = 100) {
  let i = null, s;
  return function(...n) {
    s = n, i === null && (i = setTimeout(() => {
      r(...s), i = null;
    }, t));
  };
}
c(S1, "throttle$2");
var E1 = ["added", "removed", "updated"];
function tu(r) {
  return E1.includes(r);
}
c(tu, "isCacheEventType");
async function O1({
  queryClient: r,
  persister: t,
  maxAge: i = 1e3 * 60 * 60 * 24,
  buster: s = "",
  hydrateOptions: n
}) {
  try {
    const a = await t.restoreClient();
    if (a)
      if (a.timestamp) {
        const o = Date.now() - a.timestamp > i, l = a.buster !== s;
        o || l ? t.removeClient() : y1(r, a.clientState, n);
      } else
        t.removeClient();
  } catch {
    t.removeClient();
  }
}
c(O1, "persistQueryClientRestore");
async function eu({
  queryClient: r,
  persister: t,
  buster: i = "",
  dehydrateOptions: s
}) {
  const n = {
    buster: i,
    timestamp: Date.now(),
    clientState: u1(r, s)
  };
  await t.persistClient(n);
}
c(eu, "persistQueryClientSave");
function A1(r) {
  const t = r.queryClient.getQueryCache().subscribe((s) => {
    tu(s.type) && eu(r);
  }), i = r.queryClient.getMutationCache().subscribe((s) => {
    tu(s.type) && eu(r);
  });
  return () => {
    t(), i();
  };
}
c(A1, "persistQueryClientSubscribe");
const L1 = /* @__PURE__ */ c((r) => {
  var t;
  return t = class extends r {
    // QUERY CLIENT
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this._queryClient = new n1({
        defaultOptions: {
          queries: {
            staleTime: this.staleTime,
            gcTime: this.gcTime
          }
        }
      }), this.initQueryClient();
    }
    get queryClient() {
      return this._queryClient;
    }
    async initQueryClient() {
      if (this.isDestroyed)
        throw new At();
      await this.whenUrl();
      try {
        this._sessionStoragePersister = z1({
          key: "WEAVY_QUERY_OFFLINE_CACHE",
          storage: window.sessionStorage,
          throttleTime: this.staleTime
        });
        const s = {
          queryClient: this._queryClient,
          persister: this._sessionStoragePersister,
          maxAge: this.gcTime,
          // 24h - should match gcTime
          buster: this.cachePrefix,
          // Cache busting parameter (build hash or similar)
          hydrateOptions: void 0,
          dehydrateOptions: {
            shouldDehydrateMutation: /* @__PURE__ */ c((n) => {
              var o, l;
              const a = ((l = (o = n.state.context) == null ? void 0 : o.status) == null ? void 0 : l.state) === "pending";
              return !!(n.state.context && !a || n.state.isPaused);
            }, "shouldDehydrateMutation")
          }
        };
        await O1(s), this._unsubscribeQueryClient = A1(s);
      } catch {
        console.warn(this.weavyId, "Query cache persister not available.");
      }
      this.host.isConnected && this._queryClient.mount(), this._hostIsConnectedObserver = Mf(this.host, (s) => {
        this.isDestroyed || (s ? (console.info(this.weavyId, "Query client mounted"), this._queryClient.mount()) : (console.info(this.weavyId, "Query client unmounted"), this._queryClient.unmount()));
      });
    }
    async disconnectQueryClient() {
      var s, n;
      console.info(this.weavyId, "Query client disconnected"), await this._queryClient.cancelQueries(), this.queryClient.setQueriesData({}, void 0), this.queryClient.resetQueries(), (s = this._sessionStoragePersister) == null || s.removeClient(), (n = this._unsubscribeQueryClient) == null || n.call(this), this._queryClient.unmount(), this._queryClient.clear();
    }
    destroy() {
      var s;
      super.destroy(), (s = this._hostIsConnectedObserver) == null || s.disconnect(), this.disconnectQueryClient();
    }
  }, c(t, "WeavyQuery"), t;
}, "WeavyQueryMixin"), R1 = /* @__PURE__ */ c((r) => {
  var t;
  return t = class extends r {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this._notificationEvents = Ze.defaults.notificationEvents ?? !1, this.dispatchRealtimeEvent = (n) => {
        Se();
        const a = this.host !== document.documentElement ? { composed: !0 } : { bubbles: !0 };
        switch (n.action) {
          case "notification_created":
          case "notification_updated":
          case "notification_deleted":
          case "notifications_marked": {
            const o = new CustomEvent("wy-notifications", {
              ...a,
              detail: n
            });
            this.host.dispatchEvent(o);
          }
        }
      };
    }
    get notificationEvents() {
      return this._notificationEvents;
    }
    set notificationEvents(s) {
      this.realtimeUnsubscribe(), this._notificationEvents = s ?? !1, this.realtimeSubscribe();
    }
    async realtimeSubscribe() {
      const s = this;
      this.notificationEvents && (s.subscribe(null, "notification_created", this.dispatchRealtimeEvent), s.subscribe(null, "notification_updated", this.dispatchRealtimeEvent), s.subscribe(null, "notifications_marked", this.dispatchRealtimeEvent));
    }
    realtimeUnsubscribe() {
      const s = this;
      this.notificationEvents && (s.unsubscribe(null, "notification_created", this.dispatchRealtimeEvent), s.unsubscribe(null, "notification_updated", this.dispatchRealtimeEvent), s.unsubscribe(null, "notifications_marked", this.dispatchRealtimeEvent));
    }
    destroy() {
      this.realtimeUnsubscribe(), super.destroy();
    }
  }, c(t, "WeavyRealtime"), t;
}, "WeavyRealtimeMixin");
function Ce(r) {
  return r < 0 ? -1 : r === 0 ? 0 : 1;
}
c(Ce, "signum");
function Co(r, t, i) {
  return (1 - i) * r + i * t;
}
c(Co, "lerp");
function I1(r, t, i) {
  return i < r ? r : i > t ? t : i;
}
c(I1, "clampInt");
function Hc(r, t, i) {
  return i < r ? r : i > t ? t : i;
}
c(Hc, "clampDouble");
function Ah(r) {
  return r = r % 360, r < 0 && (r = r + 360), r;
}
c(Ah, "sanitizeDegreesDouble");
function T1(r, t) {
  return Ah(t - r) <= 180 ? 1 : -1;
}
c(T1, "rotationDirection");
function F1(r, t) {
  return 180 - Math.abs(Math.abs(r - t) - 180);
}
c(F1, "differenceDegrees");
function Qd(r, t) {
  const i = r[0] * t[0][0] + r[1] * t[0][1] + r[2] * t[0][2], s = r[0] * t[1][0] + r[1] * t[1][1] + r[2] * t[1][2], n = r[0] * t[2][0] + r[1] * t[2][1] + r[2] * t[2][2];
  return [i, s, n];
}
c(Qd, "matrixMultiply");
const D1 = [
  [0.41233895, 0.35762064, 0.18051042],
  [0.2126, 0.7152, 0.0722],
  [0.01932141, 0.11916382, 0.95034478]
], H1 = [
  [
    3.2413774792388685,
    -1.5376652402851851,
    -0.49885366846268053
  ],
  [
    -0.9691452513005321,
    1.8758853451067872,
    0.04156585616912061
  ],
  [
    0.05562093689691305,
    -0.20395524564742123,
    1.0571799111220335
  ]
], V1 = [95.047, 100, 108.883];
function Lh(r, t, i) {
  return (255 << 24 | (r & 255) << 16 | (t & 255) << 8 | i & 255) >>> 0;
}
c(Lh, "argbFromRgb");
function iu(r) {
  const t = Ds(r[0]), i = Ds(r[1]), s = Ds(r[2]);
  return Lh(t, i, s);
}
c(iu, "argbFromLinrgb");
function Ay(r) {
  return r >> 16 & 255;
}
c(Ay, "redFromArgb");
function Ly(r) {
  return r >> 8 & 255;
}
c(Ly, "greenFromArgb");
function Ry(r) {
  return r & 255;
}
c(Ry, "blueFromArgb");
function B1(r, t, i) {
  const s = H1, n = s[0][0] * r + s[0][1] * t + s[0][2] * i, a = s[1][0] * r + s[1][1] * t + s[1][2] * i, o = s[2][0] * r + s[2][1] * t + s[2][2] * i, l = Ds(n), d = Ds(a), u = Ds(o);
  return Lh(l, d, u);
}
c(B1, "argbFromXyz");
function U1(r) {
  const t = Er(Ay(r)), i = Er(Ly(r)), s = Er(Ry(r));
  return Qd([t, i, s], D1);
}
c(U1, "xyzFromArgb");
function q1(r) {
  const t = rs(r), i = Ds(t);
  return Lh(i, i, i);
}
c(q1, "argbFromLstar");
function Kd(r) {
  const t = U1(r)[1];
  return 116 * Iy(t / 100) - 16;
}
c(Kd, "lstarFromArgb");
function rs(r) {
  return 100 * j1((r + 16) / 116);
}
c(rs, "yFromLstar");
function Gd(r) {
  return Iy(r / 100) * 116 - 16;
}
c(Gd, "lstarFromY");
function Er(r) {
  const t = r / 255;
  return t <= 0.040449936 ? t / 12.92 * 100 : Math.pow((t + 0.055) / 1.055, 2.4) * 100;
}
c(Er, "linearized");
function Ds(r) {
  const t = r / 100;
  let i = 0;
  return t <= 31308e-7 ? i = t * 12.92 : i = 1.055 * Math.pow(t, 1 / 2.4) - 0.055, I1(0, 255, Math.round(i * 255));
}
c(Ds, "delinearized");
function N1() {
  return V1;
}
c(N1, "whitePointD65");
function Iy(r) {
  const t = 0.008856451679035631, i = 24389 / 27;
  return r > t ? Math.pow(r, 1 / 3) : (i * r + 16) / 116;
}
c(Iy, "labF");
function j1(r) {
  const t = 0.008856451679035631, i = 24389 / 27, s = r * r * r;
  return s > t ? s : (116 * r - 16) / i;
}
c(j1, "labInvf");
const pl = class pl {
  /**
   * Create ViewingConditions from a simple, physically relevant, set of
   * parameters.
   *
   * @param whitePoint White point, measured in the XYZ color space.
   *     default = D65, or sunny day afternoon
   * @param adaptingLuminance The luminance of the adapting field. Informally,
   *     how bright it is in the room where the color is viewed. Can be
   *     calculated from lux by multiplying lux by 0.0586. default = 11.72,
   *     or 200 lux.
   * @param backgroundLstar The lightness of the area surrounding the color.
   *     measured by L* in L*a*b*. default = 50.0
   * @param surround A general description of the lighting surrounding the
   *     color. 0 is pitch dark, like watching a movie in a theater. 1.0 is a
   *     dimly light room, like watching TV at home at night. 2.0 means there
   *     is no difference between the lighting on the color and around it.
   *     default = 2.0
   * @param discountingIlluminant Whether the eye accounts for the tint of the
   *     ambient lighting, such as knowing an apple is still red in green light.
   *     default = false, the eye does not perform this process on
   *       self-luminous objects like displays.
   */
  static make(t = N1(), i = 200 / Math.PI * rs(50) / 100, s = 50, n = 2, a = !1) {
    const o = t, l = o[0] * 0.401288 + o[1] * 0.650173 + o[2] * -0.051461, d = o[0] * -0.250268 + o[1] * 1.204414 + o[2] * 0.045854, u = o[0] * -2079e-6 + o[1] * 0.048952 + o[2] * 0.953127, y = 0.8 + n / 10, m = y >= 0.9 ? Co(0.59, 0.69, (y - 0.9) * 10) : Co(0.525, 0.59, (y - 0.8) * 10);
    let f = a ? 1 : y * (1 - 1 / 3.6 * Math.exp((-i - 42) / 92));
    f = f > 1 ? 1 : f < 0 ? 0 : f;
    const g = y, x = [
      f * (100 / l) + 1 - f,
      f * (100 / d) + 1 - f,
      f * (100 / u) + 1 - f
    ], k = 1 / (5 * i + 1), S = k * k * k * k, P = 1 - S, E = S * i + 0.1 * P * P * Math.cbrt(5 * i), z = rs(s) / t[1], U = 1.48 + Math.sqrt(z), O = 0.725 / Math.pow(z, 0.2), V = O, q = [
      Math.pow(E * x[0] * l / 100, 0.42),
      Math.pow(E * x[1] * d / 100, 0.42),
      Math.pow(E * x[2] * u / 100, 0.42)
    ], N = [
      400 * q[0] / (q[0] + 27.13),
      400 * q[1] / (q[1] + 27.13),
      400 * q[2] / (q[2] + 27.13)
    ], H = (2 * N[0] + N[1] + 0.05 * N[2]) * O;
    return new pl(z, H, O, V, m, g, x, E, Math.pow(E, 0.25), U);
  }
  /**
   * Parameters are intermediate values of the CAM16 conversion process. Their
   * names are shorthand for technical color science terminology, this class
   * would not benefit from documenting them individually. A brief overview
   * is available in the CAM16 specification, and a complete overview requires
   * a color science textbook, such as Fairchild's Color Appearance Models.
   */
  constructor(t, i, s, n, a, o, l, d, u, y) {
    this.n = t, this.aw = i, this.nbb = s, this.ncb = n, this.c = a, this.nc = o, this.rgbD = l, this.fl = d, this.fLRoot = u, this.z = y;
  }
};
c(pl, "ViewingConditions");
let Ye = pl;
Ye.DEFAULT = Ye.make();
const oi = class oi {
  /**
   * All of the CAM16 dimensions can be calculated from 3 of the dimensions, in
   * the following combinations:
   *      -  {j or q} and {c, m, or s} and hue
   *      - jstar, astar, bstar
   * Prefer using a static method that constructs from 3 of those dimensions.
   * This constructor is intended for those methods to use to return all
   * possible dimensions.
   *
   * @param hue
   * @param chroma informally, colorfulness / color intensity. like saturation
   *     in HSL, except perceptually accurate.
   * @param j lightness
   * @param q brightness; ratio of lightness to white point's lightness
   * @param m colorfulness
   * @param s saturation; ratio of chroma to white point's chroma
   * @param jstar CAM16-UCS J coordinate
   * @param astar CAM16-UCS a coordinate
   * @param bstar CAM16-UCS b coordinate
   */
  constructor(t, i, s, n, a, o, l, d, u) {
    this.hue = t, this.chroma = i, this.j = s, this.q = n, this.m = a, this.s = o, this.jstar = l, this.astar = d, this.bstar = u;
  }
  /**
   * CAM16 instances also have coordinates in the CAM16-UCS space, called J*,
   * a*, b*, or jstar, astar, bstar in code. CAM16-UCS is included in the CAM16
   * specification, and is used to measure distances between colors.
   */
  distance(t) {
    const i = this.jstar - t.jstar, s = this.astar - t.astar, n = this.bstar - t.bstar, a = Math.sqrt(i * i + s * s + n * n);
    return 1.41 * Math.pow(a, 0.63);
  }
  /**
   * @param argb ARGB representation of a color.
   * @return CAM16 color, assuming the color was viewed in default viewing
   *     conditions.
   */
  static fromInt(t) {
    return oi.fromIntInViewingConditions(t, Ye.DEFAULT);
  }
  /**
   * @param argb ARGB representation of a color.
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   * @return CAM16 color.
   */
  static fromIntInViewingConditions(t, i) {
    const s = (t & 16711680) >> 16, n = (t & 65280) >> 8, a = t & 255, o = Er(s), l = Er(n), d = Er(a), u = 0.41233895 * o + 0.35762064 * l + 0.18051042 * d, y = 0.2126 * o + 0.7152 * l + 0.0722 * d, m = 0.01932141 * o + 0.11916382 * l + 0.95034478 * d, f = 0.401288 * u + 0.650173 * y - 0.051461 * m, g = -0.250268 * u + 1.204414 * y + 0.045854 * m, x = -2079e-6 * u + 0.048952 * y + 0.953127 * m, k = i.rgbD[0] * f, S = i.rgbD[1] * g, P = i.rgbD[2] * x, E = Math.pow(i.fl * Math.abs(k) / 100, 0.42), z = Math.pow(i.fl * Math.abs(S) / 100, 0.42), U = Math.pow(i.fl * Math.abs(P) / 100, 0.42), O = Ce(k) * 400 * E / (E + 27.13), V = Ce(S) * 400 * z / (z + 27.13), q = Ce(P) * 400 * U / (U + 27.13), N = (11 * O + -12 * V + q) / 11, H = (O + V - 2 * q) / 9, W = (20 * O + 20 * V + 21 * q) / 20, ft = (40 * O + 20 * V + q) / 20, ut = Math.atan2(H, N) * 180 / Math.PI, vt = ut < 0 ? ut + 360 : ut >= 360 ? ut - 360 : ut, he = vt * Math.PI / 180, ke = ft * i.nbb, Bt = 100 * Math.pow(ke / i.aw, i.c * i.z), Ct = 4 / i.c * Math.sqrt(Bt / 100) * (i.aw + 4) * i.fLRoot, pe = vt < 20.14 ? vt + 360 : vt, et = 0.25 * (Math.cos(pe * Math.PI / 180 + 2) + 3.8), qi = 5e4 / 13 * et * i.nc * i.ncb * Math.sqrt(N * N + H * H) / (W + 0.305), Ni = Math.pow(qi, 0.9) * Math.pow(1.64 - Math.pow(0.29, i.n), 0.73), cr = Ni * Math.sqrt(Bt / 100), $s = cr * i.fLRoot, Il = 50 * Math.sqrt(Ni * i.c / (i.aw + 4)), lr = (1 + 100 * 7e-3) * Bt / (1 + 7e-3 * Bt), Te = 1 / 0.0228 * Math.log(1 + 0.0228 * $s), bo = Te * Math.cos(he), Et = Te * Math.sin(he);
    return new oi(vt, cr, Bt, Ct, $s, Il, lr, bo, Et);
  }
  /**
   * @param j CAM16 lightness
   * @param c CAM16 chroma
   * @param h CAM16 hue
   */
  static fromJch(t, i, s) {
    return oi.fromJchInViewingConditions(t, i, s, Ye.DEFAULT);
  }
  /**
   * @param j CAM16 lightness
   * @param c CAM16 chroma
   * @param h CAM16 hue
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   */
  static fromJchInViewingConditions(t, i, s, n) {
    const a = 4 / n.c * Math.sqrt(t / 100) * (n.aw + 4) * n.fLRoot, o = i * n.fLRoot, l = i / Math.sqrt(t / 100), d = 50 * Math.sqrt(l * n.c / (n.aw + 4)), u = s * Math.PI / 180, y = (1 + 100 * 7e-3) * t / (1 + 7e-3 * t), m = 1 / 0.0228 * Math.log(1 + 0.0228 * o), f = m * Math.cos(u), g = m * Math.sin(u);
    return new oi(s, i, t, a, o, d, y, f, g);
  }
  /**
   * @param jstar CAM16-UCS lightness.
   * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the Y axis.
   * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the X axis.
   */
  static fromUcs(t, i, s) {
    return oi.fromUcsInViewingConditions(t, i, s, Ye.DEFAULT);
  }
  /**
   * @param jstar CAM16-UCS lightness.
   * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the Y axis.
   * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the X axis.
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   */
  static fromUcsInViewingConditions(t, i, s, n) {
    const a = i, o = s, l = Math.sqrt(a * a + o * o), u = (Math.exp(l * 0.0228) - 1) / 0.0228 / n.fLRoot;
    let y = Math.atan2(o, a) * (180 / Math.PI);
    y < 0 && (y += 360);
    const m = t / (1 - (t - 100) * 7e-3);
    return oi.fromJchInViewingConditions(m, u, y, n);
  }
  /**
   *  @return ARGB representation of color, assuming the color was viewed in
   *     default viewing conditions, which are near-identical to the default
   *     viewing conditions for sRGB.
   */
  toInt() {
    return this.viewed(Ye.DEFAULT);
  }
  /**
   * @param viewingConditions Information about the environment where the color
   *     will be viewed.
   * @return ARGB representation of color
   */
  viewed(t) {
    const i = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100), s = Math.pow(i / Math.pow(1.64 - Math.pow(0.29, t.n), 0.73), 1 / 0.9), n = this.hue * Math.PI / 180, a = 0.25 * (Math.cos(n + 2) + 3.8), o = t.aw * Math.pow(this.j / 100, 1 / t.c / t.z), l = a * (5e4 / 13) * t.nc * t.ncb, d = o / t.nbb, u = Math.sin(n), y = Math.cos(n), m = 23 * (d + 0.305) * s / (23 * l + 11 * s * y + 108 * s * u), f = m * y, g = m * u, x = (460 * d + 451 * f + 288 * g) / 1403, k = (460 * d - 891 * f - 261 * g) / 1403, S = (460 * d - 220 * f - 6300 * g) / 1403, P = Math.max(0, 27.13 * Math.abs(x) / (400 - Math.abs(x))), E = Ce(x) * (100 / t.fl) * Math.pow(P, 1 / 0.42), z = Math.max(0, 27.13 * Math.abs(k) / (400 - Math.abs(k))), U = Ce(k) * (100 / t.fl) * Math.pow(z, 1 / 0.42), O = Math.max(0, 27.13 * Math.abs(S) / (400 - Math.abs(S))), V = Ce(S) * (100 / t.fl) * Math.pow(O, 1 / 0.42), q = E / t.rgbD[0], N = U / t.rgbD[1], H = V / t.rgbD[2], W = 1.86206786 * q - 1.01125463 * N + 0.14918677 * H, ft = 0.38752654 * q + 0.62144744 * N - 897398e-8 * H, wt = -0.0158415 * q - 0.03412294 * N + 1.04996444 * H;
    return B1(W, ft, wt);
  }
  /// Given color expressed in XYZ and viewed in [viewingConditions], convert to
  /// CAM16.
  static fromXyzInViewingConditions(t, i, s, n) {
    const a = 0.401288 * t + 0.650173 * i - 0.051461 * s, o = -0.250268 * t + 1.204414 * i + 0.045854 * s, l = -2079e-6 * t + 0.048952 * i + 0.953127 * s, d = n.rgbD[0] * a, u = n.rgbD[1] * o, y = n.rgbD[2] * l, m = Math.pow(n.fl * Math.abs(d) / 100, 0.42), f = Math.pow(n.fl * Math.abs(u) / 100, 0.42), g = Math.pow(n.fl * Math.abs(y) / 100, 0.42), x = Ce(d) * 400 * m / (m + 27.13), k = Ce(u) * 400 * f / (f + 27.13), S = Ce(y) * 400 * g / (g + 27.13), P = (11 * x + -12 * k + S) / 11, E = (x + k - 2 * S) / 9, z = (20 * x + 20 * k + 21 * S) / 20, U = (40 * x + 20 * k + S) / 20, V = Math.atan2(E, P) * 180 / Math.PI, q = V < 0 ? V + 360 : V >= 360 ? V - 360 : V, N = q * Math.PI / 180, H = U * n.nbb, W = 100 * Math.pow(H / n.aw, n.c * n.z), ft = 4 / n.c * Math.sqrt(W / 100) * (n.aw + 4) * n.fLRoot, wt = q < 20.14 ? q + 360 : q, ut = 1 / 4 * (Math.cos(wt * Math.PI / 180 + 2) + 3.8), he = 5e4 / 13 * ut * n.nc * n.ncb * Math.sqrt(P * P + E * E) / (z + 0.305), ke = Math.pow(he, 0.9) * Math.pow(1.64 - Math.pow(0.29, n.n), 0.73), Bt = ke * Math.sqrt(W / 100), Ct = Bt * n.fLRoot, pe = 50 * Math.sqrt(ke * n.c / (n.aw + 4)), et = (1 + 100 * 7e-3) * W / (1 + 7e-3 * W), gt = Math.log(1 + 0.0228 * Ct) / 0.0228, qi = gt * Math.cos(N), Ni = gt * Math.sin(N);
    return new oi(q, Bt, W, ft, Ct, pe, et, qi, Ni);
  }
  /// XYZ representation of CAM16 seen in [viewingConditions].
  xyzInViewingConditions(t) {
    const i = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100), s = Math.pow(i / Math.pow(1.64 - Math.pow(0.29, t.n), 0.73), 1 / 0.9), n = this.hue * Math.PI / 180, a = 0.25 * (Math.cos(n + 2) + 3.8), o = t.aw * Math.pow(this.j / 100, 1 / t.c / t.z), l = a * (5e4 / 13) * t.nc * t.ncb, d = o / t.nbb, u = Math.sin(n), y = Math.cos(n), m = 23 * (d + 0.305) * s / (23 * l + 11 * s * y + 108 * s * u), f = m * y, g = m * u, x = (460 * d + 451 * f + 288 * g) / 1403, k = (460 * d - 891 * f - 261 * g) / 1403, S = (460 * d - 220 * f - 6300 * g) / 1403, P = Math.max(0, 27.13 * Math.abs(x) / (400 - Math.abs(x))), E = Ce(x) * (100 / t.fl) * Math.pow(P, 1 / 0.42), z = Math.max(0, 27.13 * Math.abs(k) / (400 - Math.abs(k))), U = Ce(k) * (100 / t.fl) * Math.pow(z, 1 / 0.42), O = Math.max(0, 27.13 * Math.abs(S) / (400 - Math.abs(S))), V = Ce(S) * (100 / t.fl) * Math.pow(O, 1 / 0.42), q = E / t.rgbD[0], N = U / t.rgbD[1], H = V / t.rgbD[2], W = 1.86206786 * q - 1.01125463 * N + 0.14918677 * H, ft = 0.38752654 * q + 0.62144744 * N - 897398e-8 * H, wt = -0.0158415 * q - 0.03412294 * N + 1.04996444 * H;
    return [W, ft, wt];
  }
};
c(oi, "Cam16");
let Ue = oi;
const it = class it {
  /**
   * Sanitizes a small enough angle in radians.
   *
   * @param angle An angle in radians; must not deviate too much
   * from 0.
   * @return A coterminal angle between 0 and 2pi.
   */
  static sanitizeRadians(t) {
    return (t + Math.PI * 8) % (Math.PI * 2);
  }
  /**
   * Delinearizes an RGB component, returning a floating-point
   * number.
   *
   * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents
   * linear R/G/B channel
   * @return 0.0 <= output <= 255.0, color channel converted to
   * regular RGB space
   */
  static trueDelinearized(t) {
    const i = t / 100;
    let s = 0;
    return i <= 31308e-7 ? s = i * 12.92 : s = 1.055 * Math.pow(i, 1 / 2.4) - 0.055, s * 255;
  }
  static chromaticAdaptation(t) {
    const i = Math.pow(Math.abs(t), 0.42);
    return Ce(t) * 400 * i / (i + 27.13);
  }
  /**
   * Returns the hue of a linear RGB color in CAM16.
   *
   * @param linrgb The linear RGB coordinates of a color.
   * @return The hue of the color in CAM16, in radians.
   */
  static hueOf(t) {
    const i = Qd(t, it.SCALED_DISCOUNT_FROM_LINRGB), s = it.chromaticAdaptation(i[0]), n = it.chromaticAdaptation(i[1]), a = it.chromaticAdaptation(i[2]), o = (11 * s + -12 * n + a) / 11, l = (s + n - 2 * a) / 9;
    return Math.atan2(l, o);
  }
  static areInCyclicOrder(t, i, s) {
    const n = it.sanitizeRadians(i - t), a = it.sanitizeRadians(s - t);
    return n < a;
  }
  /**
   * Solves the lerp equation.
   *
   * @param source The starting number.
   * @param mid The number in the middle.
   * @param target The ending number.
   * @return A number t such that lerp(source, target, t) = mid.
   */
  static intercept(t, i, s) {
    return (i - t) / (s - t);
  }
  static lerpPoint(t, i, s) {
    return [
      t[0] + (s[0] - t[0]) * i,
      t[1] + (s[1] - t[1]) * i,
      t[2] + (s[2] - t[2]) * i
    ];
  }
  /**
   * Intersects a segment with a plane.
   *
   * @param source The coordinates of point A.
   * @param coordinate The R-, G-, or B-coordinate of the plane.
   * @param target The coordinates of point B.
   * @param axis The axis the plane is perpendicular with. (0: R, 1:
   * G, 2: B)
   * @return The intersection point of the segment AB with the plane
   * R=coordinate, G=coordinate, or B=coordinate
   */
  static setCoordinate(t, i, s, n) {
    const a = it.intercept(t[n], i, s[n]);
    return it.lerpPoint(t, a, s);
  }
  static isBounded(t) {
    return 0 <= t && t <= 100;
  }
  /**
   * Returns the nth possible vertex of the polygonal intersection.
   *
   * @param y The Y value of the plane.
   * @param n The zero-based index of the point. 0 <= n <= 11.
   * @return The nth possible vertex of the polygonal intersection
   * of the y plane and the RGB cube, in linear RGB coordinates, if
   * it exists. If this possible vertex lies outside of the cube,
   * [-1.0, -1.0, -1.0] is returned.
   */
  static nthVertex(t, i) {
    const s = it.Y_FROM_LINRGB[0], n = it.Y_FROM_LINRGB[1], a = it.Y_FROM_LINRGB[2], o = i % 4 <= 1 ? 0 : 100, l = i % 2 === 0 ? 0 : 100;
    if (i < 4) {
      const d = o, u = l, y = (t - d * n - u * a) / s;
      return it.isBounded(y) ? [y, d, u] : [-1, -1, -1];
    } else if (i < 8) {
      const d = o, u = l, y = (t - u * s - d * a) / n;
      return it.isBounded(y) ? [u, y, d] : [-1, -1, -1];
    } else {
      const d = o, u = l, y = (t - d * s - u * n) / a;
      return it.isBounded(y) ? [d, u, y] : [-1, -1, -1];
    }
  }
  /**
   * Finds the segment containing the desired color.
   *
   * @param y The Y value of the color.
   * @param targetHue The hue of the color.
   * @return A list of two sets of linear RGB coordinates, each
   * corresponding to an endpoint of the segment containing the
   * desired color.
   */
  static bisectToSegment(t, i) {
    let s = [-1, -1, -1], n = s, a = 0, o = 0, l = !1, d = !0;
    for (let u = 0; u < 12; u++) {
      const y = it.nthVertex(t, u);
      if (y[0] < 0)
        continue;
      const m = it.hueOf(y);
      if (!l) {
        s = y, n = y, a = m, o = m, l = !0;
        continue;
      }
      (d || it.areInCyclicOrder(a, m, o)) && (d = !1, it.areInCyclicOrder(a, i, m) ? (n = y, o = m) : (s = y, a = m));
    }
    return [s, n];
  }
  static midpoint(t, i) {
    return [
      (t[0] + i[0]) / 2,
      (t[1] + i[1]) / 2,
      (t[2] + i[2]) / 2
    ];
  }
  static criticalPlaneBelow(t) {
    return Math.floor(t - 0.5);
  }
  static criticalPlaneAbove(t) {
    return Math.ceil(t - 0.5);
  }
  /**
   * Finds a color with the given Y and hue on the boundary of the
   * cube.
   *
   * @param y The Y value of the color.
   * @param targetHue The hue of the color.
   * @return The desired color, in linear RGB coordinates.
   */
  static bisectToLimit(t, i) {
    const s = it.bisectToSegment(t, i);
    let n = s[0], a = it.hueOf(n), o = s[1];
    for (let l = 0; l < 3; l++)
      if (n[l] !== o[l]) {
        let d = -1, u = 255;
        n[l] < o[l] ? (d = it.criticalPlaneBelow(it.trueDelinearized(n[l])), u = it.criticalPlaneAbove(it.trueDelinearized(o[l]))) : (d = it.criticalPlaneAbove(it.trueDelinearized(n[l])), u = it.criticalPlaneBelow(it.trueDelinearized(o[l])));
        for (let y = 0; y < 8 && !(Math.abs(u - d) <= 1); y++) {
          const m = Math.floor((d + u) / 2), f = it.CRITICAL_PLANES[m], g = it.setCoordinate(n, f, o, l), x = it.hueOf(g);
          it.areInCyclicOrder(a, i, x) ? (o = g, u = m) : (n = g, a = x, d = m);
        }
      }
    return it.midpoint(n, o);
  }
  static inverseChromaticAdaptation(t) {
    const i = Math.abs(t), s = Math.max(0, 27.13 * i / (400 - i));
    return Ce(t) * Math.pow(s, 1 / 0.42);
  }
  /**
   * Finds a color with the given hue, chroma, and Y.
   *
   * @param hueRadians The desired hue in radians.
   * @param chroma The desired chroma.
   * @param y The desired Y.
   * @return The desired color as a hexadecimal integer, if found; 0
   * otherwise.
   */
  static findResultByJ(t, i, s) {
    let n = Math.sqrt(s) * 11;
    const a = Ye.DEFAULT, o = 1 / Math.pow(1.64 - Math.pow(0.29, a.n), 0.73), d = 0.25 * (Math.cos(t + 2) + 3.8) * (5e4 / 13) * a.nc * a.ncb, u = Math.sin(t), y = Math.cos(t);
    for (let m = 0; m < 5; m++) {
      const f = n / 100, g = i === 0 || n === 0 ? 0 : i / Math.sqrt(f), x = Math.pow(g * o, 1 / 0.9), S = a.aw * Math.pow(f, 1 / a.c / a.z) / a.nbb, P = 23 * (S + 0.305) * x / (23 * d + 11 * x * y + 108 * x * u), E = P * y, z = P * u, U = (460 * S + 451 * E + 288 * z) / 1403, O = (460 * S - 891 * E - 261 * z) / 1403, V = (460 * S - 220 * E - 6300 * z) / 1403, q = it.inverseChromaticAdaptation(U), N = it.inverseChromaticAdaptation(O), H = it.inverseChromaticAdaptation(V), W = Qd([q, N, H], it.LINRGB_FROM_SCALED_DISCOUNT);
      if (W[0] < 0 || W[1] < 0 || W[2] < 0)
        return 0;
      const ft = it.Y_FROM_LINRGB[0], wt = it.Y_FROM_LINRGB[1], ut = it.Y_FROM_LINRGB[2], vt = ft * W[0] + wt * W[1] + ut * W[2];
      if (vt <= 0)
        return 0;
      if (m === 4 || Math.abs(vt - s) < 2e-3)
        return W[0] > 100.01 || W[1] > 100.01 || W[2] > 100.01 ? 0 : iu(W);
      n = n - (vt - s) * n / (2 * vt);
    }
    return 0;
  }
  /**
   * Finds an sRGB color with the given hue, chroma, and L*, if
   * possible.
   *
   * @param hueDegrees The desired hue, in degrees.
   * @param chroma The desired chroma.
   * @param lstar The desired L*.
   * @return A hexadecimal representing the sRGB color. The color
   * has sufficiently close hue, chroma, and L* to the desired
   * values, if possible; otherwise, the hue and L* will be
   * sufficiently close, and chroma will be maximized.
   */
  static solveToInt(t, i, s) {
    if (i < 1e-4 || s < 1e-4 || s > 99.9999)
      return q1(s);
    t = Ah(t);
    const n = t / 180 * Math.PI, a = rs(s), o = it.findResultByJ(n, i, a);
    if (o !== 0)
      return o;
    const l = it.bisectToLimit(a, n);
    return iu(l);
  }
  /**
   * Finds an sRGB color with the given hue, chroma, and L*, if
   * possible.
   *
   * @param hueDegrees The desired hue, in degrees.
   * @param chroma The desired chroma.
   * @param lstar The desired L*.
   * @return An CAM16 object representing the sRGB color. The color
   * has sufficiently close hue, chroma, and L* to the desired
   * values, if possible; otherwise, the hue and L* will be
   * sufficiently close, and chroma will be maximized.
   */
  static solveToCam(t, i, s) {
    return Ue.fromInt(it.solveToInt(t, i, s));
  }
};
c(it, "HctSolver");
let ui = it;
ui.SCALED_DISCOUNT_FROM_LINRGB = [
  [
    0.001200833568784504,
    0.002389694492170889,
    2795742885861124e-19
  ],
  [
    5891086651375999e-19,
    0.0029785502573438758,
    3270666104008398e-19
  ],
  [
    10146692491640572e-20,
    5364214359186694e-19,
    0.0032979401770712076
  ]
];
ui.LINRGB_FROM_SCALED_DISCOUNT = [
  [
    1373.2198709594231,
    -1100.4251190754821,
    -7.278681089101213
  ],
  [
    -271.815969077903,
    559.6580465940733,
    -32.46047482791194
  ],
  [
    1.9622899599665666,
    -57.173814538844006,
    308.7233197812385
  ]
];
ui.Y_FROM_LINRGB = [0.2126, 0.7152, 0.0722];
ui.CRITICAL_PLANES = [
  0.015176349177441876,
  0.045529047532325624,
  0.07588174588720938,
  0.10623444424209313,
  0.13658714259697685,
  0.16693984095186062,
  0.19729253930674434,
  0.2276452376616281,
  0.2579979360165119,
  0.28835063437139563,
  0.3188300904430532,
  0.350925934958123,
  0.3848314933096426,
  0.42057480301049466,
  0.458183274052838,
  0.4976837250274023,
  0.5391024159806381,
  0.5824650784040898,
  0.6277969426914107,
  0.6751227633498623,
  0.7244668422128921,
  0.775853049866786,
  0.829304845476233,
  0.8848452951698498,
  0.942497089126609,
  1.0022825574869039,
  1.0642236851973577,
  1.1283421258858297,
  1.1946592148522128,
  1.2631959812511864,
  1.3339731595349034,
  1.407011200216447,
  1.4823302800086415,
  1.5599503113873272,
  1.6398909516233677,
  1.7221716113234105,
  1.8068114625156377,
  1.8938294463134073,
  1.9832442801866852,
  2.075074464868551,
  2.1693382909216234,
  2.2660538449872063,
  2.36523901573795,
  2.4669114995532007,
  2.5710888059345764,
  2.6777882626779785,
  2.7870270208169257,
  2.898822059350997,
  3.0131901897720907,
  3.1301480604002863,
  3.2497121605402226,
  3.3718988244681087,
  3.4967242352587946,
  3.624204428461639,
  3.754355295633311,
  3.887192587735158,
  4.022731918402185,
  4.160988767090289,
  4.301978482107941,
  4.445716283538092,
  4.592217266055746,
  4.741496401646282,
  4.893568542229298,
  5.048448422192488,
  5.20615066083972,
  5.3666897647573375,
  5.5300801301023865,
  5.696336044816294,
  5.865471690767354,
  6.037501145825082,
  6.212438385869475,
  6.390297286737924,
  6.571091626112461,
  6.7548350853498045,
  6.941541251256611,
  7.131223617812143,
  7.323895587840543,
  7.5195704746346665,
  7.7182615035334345,
  7.919981813454504,
  8.124744458384042,
  8.332562408825165,
  8.543448553206703,
  8.757415699253682,
  8.974476575321063,
  9.194643831691977,
  9.417930041841839,
  9.644347703669503,
  9.873909240696694,
  10.106627003236781,
  10.342513269534024,
  10.58158024687427,
  10.8238400726681,
  11.069304815507364,
  11.317986476196008,
  11.569896988756009,
  11.825048221409341,
  12.083451977536606,
  12.345119996613247,
  12.610063955123938,
  12.878295467455942,
  13.149826086772048,
  13.42466730586372,
  13.702830557985108,
  13.984327217668513,
  14.269168601521828,
  14.55736596900856,
  14.848930523210871,
  15.143873411576273,
  15.44220572664832,
  15.743938506781891,
  16.04908273684337,
  16.35764934889634,
  16.66964922287304,
  16.985093187232053,
  17.30399201960269,
  17.62635644741625,
  17.95219714852476,
  18.281524751807332,
  18.614349837764564,
  18.95068293910138,
  19.290534541298456,
  19.633915083172692,
  19.98083495742689,
  20.331304511189067,
  20.685334046541502,
  21.042933821039977,
  21.404114048223256,
  21.76888489811322,
  22.137256497705877,
  22.50923893145328,
  22.884842241736916,
  23.264076429332462,
  23.6469514538663,
  24.033477234264016,
  24.42366364919083,
  24.817520537484558,
  25.21505769858089,
  25.61628489293138,
  26.021211842414342,
  26.429848230738664,
  26.842203703840827,
  27.258287870275353,
  27.678110301598522,
  28.10168053274597,
  28.529008062403893,
  28.96010235337422,
  29.39497283293396,
  29.83362889318845,
  30.276079891419332,
  30.722335150426627,
  31.172403958865512,
  31.62629557157785,
  32.08401920991837,
  32.54558406207592,
  33.010999283389665,
  33.4802739966603,
  33.953417292456834,
  34.430438229418264,
  34.911345834551085,
  35.39614910352207,
  35.88485700094671,
  36.37747846067349,
  36.87402238606382,
  37.37449765026789,
  37.87891309649659,
  38.38727753828926,
  38.89959975977785,
  39.41588851594697,
  39.93615253289054,
  40.460400508064545,
  40.98864111053629,
  41.520882981230194,
  42.05713473317016,
  42.597404951718396,
  43.141702194811224,
  43.6900349931913,
  44.24241185063697,
  44.798841244188324,
  45.35933162437017,
  45.92389141541209,
  46.49252901546552,
  47.065252796817916,
  47.64207110610409,
  48.22299226451468,
  48.808024568002054,
  49.3971762874833,
  49.9904556690408,
  50.587870934119984,
  51.189430279724725,
  51.79514187861014,
  52.40501387947288,
  53.0190544071392,
  53.637271562750364,
  54.259673423945976,
  54.88626804504493,
  55.517063457223934,
  56.15206766869424,
  56.79128866487574,
  57.43473440856916,
  58.08241284012621,
  58.734331877617365,
  59.39049941699807,
  60.05092333227251,
  60.715611475655585,
  61.38457167773311,
  62.057811747619894,
  62.7353394731159,
  63.417162620860914,
  64.10328893648692,
  64.79372614476921,
  65.48848194977529,
  66.18756403501224,
  66.89098006357258,
  67.59873767827808,
  68.31084450182222,
  69.02730813691093,
  69.74813616640164,
  70.47333615344107,
  71.20291564160104,
  71.93688215501312,
  72.67524319850172,
  73.41800625771542,
  74.16517879925733,
  74.9167682708136,
  75.67278210128072,
  76.43322770089146,
  77.1981124613393,
  77.96744375590167,
  78.74122893956174,
  79.51947534912904,
  80.30219030335869,
  81.08938110306934,
  81.88105503125999,
  82.67721935322541,
  83.4778813166706,
  84.28304815182372,
  85.09272707154808,
  85.90692527145302,
  86.72564993000343,
  87.54890820862819,
  88.3767072518277,
  89.2090541872801,
  90.04595612594655,
  90.88742016217518,
  91.73345337380438,
  92.58406282226491,
  93.43925555268066,
  94.29903859396902,
  95.16341895893969,
  96.03240364439274,
  96.9059996312159,
  97.78421388448044,
  98.6670533535366,
  99.55452497210776
];
const zr = class zr {
  static from(t, i, s) {
    return new zr(ui.solveToInt(t, i, s));
  }
  /**
   * @param argb ARGB representation of a color.
   * @return HCT representation of a color in default viewing conditions
   */
  static fromInt(t) {
    return new zr(t);
  }
  toInt() {
    return this.argb;
  }
  /**
   * A number, in degrees, representing ex. red, orange, yellow, etc.
   * Ranges from 0 <= hue < 360.
   */
  get hue() {
    return this.internalHue;
  }
  /**
   * @param newHue 0 <= newHue < 360; invalid values are corrected.
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set hue(t) {
    this.setInternalState(ui.solveToInt(t, this.internalChroma, this.internalTone));
  }
  get chroma() {
    return this.internalChroma;
  }
  /**
   * @param newChroma 0 <= newChroma < ?
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set chroma(t) {
    this.setInternalState(ui.solveToInt(this.internalHue, t, this.internalTone));
  }
  /** Lightness. Ranges from 0 to 100. */
  get tone() {
    return this.internalTone;
  }
  /**
   * @param newTone 0 <= newTone <= 100; invalid valids are corrected.
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set tone(t) {
    this.setInternalState(ui.solveToInt(this.internalHue, this.internalChroma, t));
  }
  constructor(t) {
    this.argb = t;
    const i = Ue.fromInt(t);
    this.internalHue = i.hue, this.internalChroma = i.chroma, this.internalTone = Kd(t), this.argb = t;
  }
  setInternalState(t) {
    const i = Ue.fromInt(t);
    this.internalHue = i.hue, this.internalChroma = i.chroma, this.internalTone = Kd(t), this.argb = t;
  }
  /**
   * Translates a color into different [ViewingConditions].
   *
   * Colors change appearance. They look different with lights on versus off,
   * the same color, as in hex code, on white looks different when on black.
   * This is called color relativity, most famously explicated by Josef Albers
   * in Interaction of Color.
   *
   * In color science, color appearance models can account for this and
   * calculate the appearance of a color in different settings. HCT is based on
   * CAM16, a color appearance model, and uses it to make these calculations.
   *
   * See [ViewingConditions.make] for parameters affecting color appearance.
   */
  inViewingConditions(t) {
    const s = Ue.fromInt(this.toInt()).xyzInViewingConditions(t), n = Ue.fromXyzInViewingConditions(s[0], s[1], s[2], Ye.make());
    return zr.from(n.hue, n.chroma, Gd(s[1]));
  }
};
c(zr, "Hct");
let ye = zr;
const ul = class ul {
  /**
   * Blend the design color's HCT hue towards the key color's HCT
   * hue, in a way that leaves the original color recognizable and
   * recognizably shifted towards the key color.
   *
   * @param designColor ARGB representation of an arbitrary color.
   * @param sourceColor ARGB representation of the main theme color.
   * @return The design color with a hue shifted towards the
   * system's color, a slightly warmer/cooler variant of the design
   * color's hue.
   */
  static harmonize(t, i) {
    const s = ye.fromInt(t), n = ye.fromInt(i), a = F1(s.hue, n.hue), o = Math.min(a * 0.5, 15), l = Ah(s.hue + o * T1(s.hue, n.hue));
    return ye.from(l, s.chroma, s.tone).toInt();
  }
  /**
   * Blends hue from one color into another. The chroma and tone of
   * the original color are maintained.
   *
   * @param from ARGB representation of color
   * @param to ARGB representation of color
   * @param amount how much blending to perform; 0.0 >= and <= 1.0
   * @return from, with a hue blended towards to. Chroma and tone
   * are constant.
   */
  static hctHue(t, i, s) {
    const n = ul.cam16Ucs(t, i, s), a = Ue.fromInt(n), o = Ue.fromInt(t);
    return ye.from(a.hue, o.chroma, Kd(t)).toInt();
  }
  /**
   * Blend in CAM16-UCS space.
   *
   * @param from ARGB representation of color
   * @param to ARGB representation of color
   * @param amount how much blending to perform; 0.0 >= and <= 1.0
   * @return from, blended towards to. Hue, chroma, and tone will
   * change.
   */
  static cam16Ucs(t, i, s) {
    const n = Ue.fromInt(t), a = Ue.fromInt(i), o = n.jstar, l = n.astar, d = n.bstar, u = a.jstar, y = a.astar, m = a.bstar, f = o + (u - o) * s, g = l + (y - l) * s, x = d + (m - d) * s;
    return Ue.fromUcs(f, g, x).toInt();
  }
};
c(ul, "Blend");
let De = ul;
const Qi = class Qi {
  /**
   * Returns a contrast ratio, which ranges from 1 to 21.
   *
   * @param toneA Tone between 0 and 100. Values outside will be clamped.
   * @param toneB Tone between 0 and 100. Values outside will be clamped.
   */
  static ratioOfTones(t, i) {
    return t = Hc(0, 100, t), i = Hc(0, 100, i), Qi.ratioOfYs(rs(t), rs(i));
  }
  static ratioOfYs(t, i) {
    const s = t > i ? t : i, n = s === i ? t : i;
    return (s + 5) / (n + 5);
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns -1 if ratio cannot be achieved with tone parameter.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in -1 being returned.
   * @param ratio Contrast ratio of return value and tone.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static lighter(t, i) {
    if (t < 0 || t > 100)
      return -1;
    const s = rs(t), n = i * (s + 5) - 5, a = Qi.ratioOfYs(n, s), o = Math.abs(a - i);
    if (a < i && o > 0.04)
      return -1;
    const l = Gd(n) + 0.4;
    return l < 0 || l > 100 ? -1 : l;
  }
  /**
   * Returns a tone <= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns -1 if ratio cannot be achieved with tone parameter.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in -1 being returned.
   * @param ratio Contrast ratio of return value and tone.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static darker(t, i) {
    if (t < 0 || t > 100)
      return -1;
    const s = rs(t), n = (s + 5) / i - 5, a = Qi.ratioOfYs(s, n), o = Math.abs(a - i);
    if (a < i && o > 0.04)
      return -1;
    const l = Gd(n) - 0.4;
    return l < 0 || l > 100 ? -1 : l;
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns 100 if ratio cannot be achieved with tone parameter.
   *
   * This method is unsafe because the returned value is guaranteed to be in
   * bounds for tone, i.e. between 0 and 100. However, that value may not reach
   * the ratio with tone. For example, there is no color lighter than T100.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in 100 being returned.
   * @param ratio Desired contrast ratio of return value and tone parameter.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static lighterUnsafe(t, i) {
    const s = Qi.lighter(t, i);
    return s < 0 ? 100 : s;
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns 100 if ratio cannot be achieved with tone parameter.
   *
   * This method is unsafe because the returned value is guaranteed to be in
   * bounds for tone, i.e. between 0 and 100. However, that value may not reach
   * the [ratio with [tone]. For example, there is no color darker than T0.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in 0 being returned.
   * @param ratio Desired contrast ratio of return value and tone parameter.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static darkerUnsafe(t, i) {
    const s = Qi.darker(t, i);
    return s < 0 ? 0 : s;
  }
};
c(Qi, "Contrast");
let _e = Qi;
const yl = class yl {
  /**
   * Returns true if a color is disliked.
   *
   * @param hct A color to be judged.
   * @return Whether the color is disliked.
   *
   * Disliked is defined as a dark yellow-green that is not neutral.
   */
  static isDisliked(t) {
    const i = Math.round(t.hue) >= 90 && Math.round(t.hue) <= 111, s = Math.round(t.chroma) > 16, n = Math.round(t.tone) < 65;
    return i && s && n;
  }
  /**
   * If a color is disliked, lighten it to make it likable.
   *
   * @param hct A color to be judged.
   * @return A new color if the original color is disliked, or the original
   *   color if it is acceptable.
   */
  static fixIfDisliked(t) {
    return yl.isDisliked(t) ? ye.from(t.hue, t.chroma, 70) : t;
  }
};
c(yl, "DislikeAnalyzer");
let Yd = yl;
const me = class me {
  /**
   * Create a DynamicColor defined by a TonalPalette and HCT tone.
   *
   * @param args Functions with DynamicScheme as input. Must provide a palette
   * and tone. May provide a background DynamicColor and ToneDeltaConstraint.
   */
  static fromPalette(t) {
    return new me(t.name ?? "", t.palette, t.tone, t.isBackground ?? !1, t.background, t.secondBackground, t.contrastCurve, t.toneDeltaPair);
  }
  /**
   * The base constructor for DynamicColor.
   *
   * _Strongly_ prefer using one of the convenience constructors. This class is
   * arguably too flexible to ensure it can support any scenario. Functional
   * arguments allow  overriding without risks that come with subclasses.
   *
   * For example, the default behavior of adjust tone at max contrast
   * to be at a 7.0 ratio with its background is principled and
   * matches accessibility guidance. That does not mean it's the desired
   * approach for _every_ design system, and every color pairing,
   * always, in every case.
   *
   * @param name The name of the dynamic color. Defaults to empty.
   * @param palette Function that provides a TonalPalette given
   * DynamicScheme. A TonalPalette is defined by a hue and chroma, so this
   * replaces the need to specify hue/chroma. By providing a tonal palette, when
   * contrast adjustments are made, intended chroma can be preserved.
   * @param tone Function that provides a tone, given a DynamicScheme.
   * @param isBackground Whether this dynamic color is a background, with
   * some other color as the foreground. Defaults to false.
   * @param background The background of the dynamic color (as a function of a
   *     `DynamicScheme`), if it exists.
   * @param secondBackground A second background of the dynamic color (as a
   *     function of a `DynamicScheme`), if it
   * exists.
   * @param contrastCurve A `ContrastCurve` object specifying how its contrast
   * against its background should behave in various contrast levels options.
   * @param toneDeltaPair A `ToneDeltaPair` object specifying a tone delta
   * constraint between two colors. One of them must be the color being
   * constructed.
   */
  constructor(t, i, s, n, a, o, l, d) {
    if (this.name = t, this.palette = i, this.tone = s, this.isBackground = n, this.background = a, this.secondBackground = o, this.contrastCurve = l, this.toneDeltaPair = d, this.hctCache = /* @__PURE__ */ new Map(), !a && o)
      throw new Error(`Color ${t} has secondBackgrounddefined, but background is not defined.`);
    if (!a && l)
      throw new Error(`Color ${t} has contrastCurvedefined, but background is not defined.`);
    if (a && !l)
      throw new Error(`Color ${t} has backgrounddefined, but contrastCurve is not defined.`);
  }
  /**
   * Return a ARGB integer (i.e. a hex code).
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getArgb(t) {
    return this.getHct(t).toInt();
  }
  /**
   * Return a color, expressed in the HCT color space, that this
   * DynamicColor is under the conditions in scheme.
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getHct(t) {
    const i = this.hctCache.get(t);
    if (i != null)
      return i;
    const s = this.getTone(t), n = this.palette(t).getHct(s);
    return this.hctCache.size > 4 && this.hctCache.clear(), this.hctCache.set(t, n), n;
  }
  /**
   * Return a tone, T in the HCT color space, that this DynamicColor is under
   * the conditions in scheme.
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getTone(t) {
    const i = t.contrastLevel < 0;
    if (this.toneDeltaPair) {
      const s = this.toneDeltaPair(t), n = s.roleA, a = s.roleB, o = s.delta, l = s.polarity, d = s.stayTogether, y = this.background(t).getTone(t), m = l === "nearer" || l === "lighter" && !t.isDark || l === "darker" && t.isDark, f = m ? n : a, g = m ? a : n, x = this.name === f.name, k = t.isDark ? 1 : -1, S = f.contrastCurve.getContrast(t.contrastLevel), P = g.contrastCurve.getContrast(t.contrastLevel), E = f.tone(t);
      let z = _e.ratioOfTones(y, E) >= S ? E : me.foregroundTone(y, S);
      const U = g.tone(t);
      let O = _e.ratioOfTones(y, U) >= P ? U : me.foregroundTone(y, P);
      return i && (z = me.foregroundTone(y, S), O = me.foregroundTone(y, P)), (O - z) * k >= o || (O = Hc(0, 100, z + o * k), (O - z) * k >= o || (z = Hc(0, 100, O - o * k))), 50 <= z && z < 60 ? k > 0 ? (z = 60, O = Math.max(O, z + o * k)) : (z = 49, O = Math.min(O, z + o * k)) : 50 <= O && O < 60 && (d ? k > 0 ? (z = 60, O = Math.max(O, z + o * k)) : (z = 49, O = Math.min(O, z + o * k)) : k > 0 ? O = 60 : O = 49), x ? z : O;
    } else {
      let s = this.tone(t);
      if (this.background == null)
        return s;
      const n = this.background(t).getTone(t), a = this.contrastCurve.getContrast(t.contrastLevel);
      if (_e.ratioOfTones(n, s) >= a || (s = me.foregroundTone(n, a)), i && (s = me.foregroundTone(n, a)), this.isBackground && 50 <= s && s < 60 && (_e.ratioOfTones(49, n) >= a ? s = 49 : s = 60), this.secondBackground) {
        const [o, l] = [this.background, this.secondBackground], [d, u] = [o(t).getTone(t), l(t).getTone(t)], [y, m] = [Math.max(d, u), Math.min(d, u)];
        if (_e.ratioOfTones(y, s) >= a && _e.ratioOfTones(m, s) >= a)
          return s;
        const f = _e.lighter(y, a), g = _e.darker(m, a), x = [];
        return f !== -1 && x.push(f), g !== -1 && x.push(g), me.tonePrefersLightForeground(d) || me.tonePrefersLightForeground(u) ? f < 0 ? 100 : f : x.length === 1 ? x[0] : g < 0 ? 0 : g;
      }
      return s;
    }
  }
  /**
   * Given a background tone, find a foreground tone, while ensuring they reach
   * a contrast ratio that is as close to [ratio] as possible.
   *
   * @param bgTone Tone in HCT. Range is 0 to 100, undefined behavior when it
   *     falls outside that range.
   * @param ratio The contrast ratio desired between bgTone and the return
   *     value.
   */
  static foregroundTone(t, i) {
    const s = _e.lighterUnsafe(t, i), n = _e.darkerUnsafe(t, i), a = _e.ratioOfTones(s, t), o = _e.ratioOfTones(n, t);
    if (me.tonePrefersLightForeground(t)) {
      const d = Math.abs(a - o) < 0.1 && a < i && o < i;
      return a >= i || a >= o || d ? s : n;
    } else
      return o >= i || o >= a ? n : s;
  }
  /**
   * Returns whether [tone] prefers a light foreground.
   *
   * People prefer white foregrounds on ~T60-70. Observed over time, and also
   * by Andrew Somers during research for APCA.
   *
   * T60 used as to create the smallest discontinuity possible when skipping
   * down to T49 in order to ensure light foregrounds.
   * Since `tertiaryContainer` in dark monochrome scheme requires a tone of
   * 60, it should not be adjusted. Therefore, 60 is excluded here.
   */
  static tonePrefersLightForeground(t) {
    return Math.round(t) < 60;
  }
  /**
   * Returns whether [tone] can reach a contrast ratio of 4.5 with a lighter
   * color.
   */
  static toneAllowsLightForeground(t) {
    return Math.round(t) <= 49;
  }
  /**
   * Adjust a tone such that white has 4.5 contrast, if the tone is
   * reasonably close to supporting it.
   */
  static enableLightForeground(t) {
    return me.tonePrefersLightForeground(t) && !me.toneAllowsLightForeground(t) ? 49 : t;
  }
};
c(me, "DynamicColor");
let G = me;
var Oo;
(function(r) {
  r[r.MONOCHROME = 0] = "MONOCHROME", r[r.NEUTRAL = 1] = "NEUTRAL", r[r.TONAL_SPOT = 2] = "TONAL_SPOT", r[r.VIBRANT = 3] = "VIBRANT", r[r.EXPRESSIVE = 4] = "EXPRESSIVE", r[r.FIDELITY = 5] = "FIDELITY", r[r.CONTENT = 6] = "CONTENT", r[r.RAINBOW = 7] = "RAINBOW", r[r.FRUIT_SALAD = 8] = "FRUIT_SALAD";
})(Oo || (Oo = {}));
const pp = class pp {
  /**
   * Creates a `ContrastCurve` object.
   *
   * @param low Contrast requirement for contrast level -1.0
   * @param normal Contrast requirement for contrast level 0.0
   * @param medium Contrast requirement for contrast level 0.5
   * @param high Contrast requirement for contrast level 1.0
   */
  constructor(t, i, s, n) {
    this.low = t, this.normal = i, this.medium = s, this.high = n;
  }
  /**
   * Returns the contrast ratio at a given contrast level.
   *
   * @param contrastLevel The contrast level. 0.0 is the default (normal);
   * -1.0 is the lowest; 1.0 is the highest.
   * @return The contrast ratio, a number between 1.0 and 21.0.
   */
  getContrast(t) {
    return t <= -1 ? this.low : t < 0 ? Co(this.low, this.normal, (t - -1) / 1) : t < 0.5 ? Co(this.normal, this.medium, (t - 0) / 0.5) : t < 1 ? Co(this.medium, this.high, (t - 0.5) / 0.5) : this.high;
  }
};
c(pp, "ContrastCurve");
let dt = pp;
const up = class up {
  /**
   * Documents a constraint in tone distance between two DynamicColors.
   *
   * The polarity is an adjective that describes "A", compared to "B".
   *
   * For instance, ToneDeltaPair(A, B, 15, 'darker', stayTogether) states that
   * A's tone should be at least 15 darker than B's.
   *
   * 'nearer' and 'farther' describes closeness to the surface roles. For
   * instance, ToneDeltaPair(A, B, 10, 'nearer', stayTogether) states that A
   * should be 10 lighter than B in light mode, and 10 darker than B in dark
   * mode.
   *
   * @param roleA The first role in a pair.
   * @param roleB The second role in a pair.
   * @param delta Required difference between tones. Absolute value, negative
   * values have undefined behavior.
   * @param polarity The relative relation between tones of roleA and roleB,
   * as described above.
   * @param stayTogether Whether these two roles should stay on the same side of
   * the "awkward zone" (T50-59). This is necessary for certain cases where
   * one role has two backgrounds.
   */
  constructor(t, i, s, n, a) {
    this.roleA = t, this.roleB = i, this.delta = s, this.polarity = n, this.stayTogether = a;
  }
};
c(up, "ToneDeltaPair");
let we = up;
function lo(r) {
  return r.variant === Oo.FIDELITY || r.variant === Oo.CONTENT;
}
c(lo, "isFidelity");
function Ht(r) {
  return r.variant === Oo.MONOCHROME;
}
c(Ht, "isMonochrome");
function W1(r, t, i, s) {
  let n = i, a = ye.from(r, t, i);
  if (a.chroma < t) {
    let o = a.chroma;
    for (; a.chroma < t; ) {
      n += s ? -1 : 1;
      const l = ye.from(r, t, n);
      if (o > l.chroma || Math.abs(l.chroma - t) < 0.4)
        break;
      const d = Math.abs(l.chroma - t), u = Math.abs(a.chroma - t);
      d < u && (a = l), o = Math.max(o, l.chroma);
    }
  }
  return n;
}
c(W1, "findDesiredChromaByTone");
function Q1(r) {
  return Ye.make(
    /*whitePoint=*/
    void 0,
    /*adaptingLuminance=*/
    void 0,
    /*backgroundLstar=*/
    r.isDark ? 30 : 80,
    /*surround=*/
    void 0,
    /*discountingIlluminant=*/
    void 0
  );
}
c(Q1, "viewingConditionsForAlbers");
function Rh(r, t) {
  const i = r.inViewingConditions(Q1(t));
  return G.tonePrefersLightForeground(r.tone) && !G.toneAllowsLightForeground(i.tone) ? G.enableLightForeground(r.tone) : G.enableLightForeground(i.tone);
}
c(Rh, "performAlbers");
const zo = class zo {
  static highestSurface(t) {
    return t.isDark ? zo.surfaceBright : zo.surfaceDim;
  }
};
c(zo, "MaterialDynamicColors");
let L = zo;
L.contentAccentToneDelta = 15;
L.primaryPaletteKeyColor = G.fromPalette({
  name: "primary_palette_key_color",
  palette: /* @__PURE__ */ c((r) => r.primaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.primaryPalette.keyColor.tone, "tone")
});
L.secondaryPaletteKeyColor = G.fromPalette({
  name: "secondary_palette_key_color",
  palette: /* @__PURE__ */ c((r) => r.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.secondaryPalette.keyColor.tone, "tone")
});
L.tertiaryPaletteKeyColor = G.fromPalette({
  name: "tertiary_palette_key_color",
  palette: /* @__PURE__ */ c((r) => r.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.tertiaryPalette.keyColor.tone, "tone")
});
L.neutralPaletteKeyColor = G.fromPalette({
  name: "neutral_palette_key_color",
  palette: /* @__PURE__ */ c((r) => r.neutralPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.neutralPalette.keyColor.tone, "tone")
});
L.neutralVariantPaletteKeyColor = G.fromPalette({
  name: "neutral_variant_palette_key_color",
  palette: /* @__PURE__ */ c((r) => r.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.neutralVariantPalette.keyColor.tone, "tone")
});
L.background = G.fromPalette({
  name: "background",
  palette: /* @__PURE__ */ c((r) => r.neutralPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 6 : 98, "tone"),
  isBackground: !0
});
L.onBackground = G.fromPalette({
  name: "on_background",
  palette: /* @__PURE__ */ c((r) => r.neutralPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ c((r) => L.background, "background"),
  contrastCurve: new dt(3, 3, 4.5, 7)
});
L.surface = G.fromPalette({
  name: "surface",
  palette: /* @__PURE__ */ c((r) => r.neutralPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 6 : 98, "tone"),
  isBackground: !0
});
L.surfaceDim = G.fromPalette({
  name: "surface_dim",
  palette: /* @__PURE__ */ c((r) => r.neutralPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 6 : 87, "tone"),
  isBackground: !0
});
L.surfaceBright = G.fromPalette({
  name: "surface_bright",
  palette: /* @__PURE__ */ c((r) => r.neutralPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 24 : 98, "tone"),
  isBackground: !0
});
L.surfaceContainerLowest = G.fromPalette({
  name: "surface_container_lowest",
  palette: /* @__PURE__ */ c((r) => r.neutralPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 4 : 100, "tone"),
  isBackground: !0
});
L.surfaceContainerLow = G.fromPalette({
  name: "surface_container_low",
  palette: /* @__PURE__ */ c((r) => r.neutralPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 10 : 96, "tone"),
  isBackground: !0
});
L.surfaceContainer = G.fromPalette({
  name: "surface_container",
  palette: /* @__PURE__ */ c((r) => r.neutralPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 12 : 94, "tone"),
  isBackground: !0
});
L.surfaceContainerHigh = G.fromPalette({
  name: "surface_container_high",
  palette: /* @__PURE__ */ c((r) => r.neutralPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 17 : 92, "tone"),
  isBackground: !0
});
L.surfaceContainerHighest = G.fromPalette({
  name: "surface_container_highest",
  palette: /* @__PURE__ */ c((r) => r.neutralPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 22 : 90, "tone"),
  isBackground: !0
});
L.onSurface = G.fromPalette({
  name: "on_surface",
  palette: /* @__PURE__ */ c((r) => r.neutralPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ c((r) => L.highestSurface(r), "background"),
  contrastCurve: new dt(4.5, 7, 11, 21)
});
L.surfaceVariant = G.fromPalette({
  name: "surface_variant",
  palette: /* @__PURE__ */ c((r) => r.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 30 : 90, "tone"),
  isBackground: !0
});
L.onSurfaceVariant = G.fromPalette({
  name: "on_surface_variant",
  palette: /* @__PURE__ */ c((r) => r.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 80 : 30, "tone"),
  background: /* @__PURE__ */ c((r) => L.highestSurface(r), "background"),
  contrastCurve: new dt(3, 4.5, 7, 11)
});
L.inverseSurface = G.fromPalette({
  name: "inverse_surface",
  palette: /* @__PURE__ */ c((r) => r.neutralPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 90 : 20, "tone")
});
L.inverseOnSurface = G.fromPalette({
  name: "inverse_on_surface",
  palette: /* @__PURE__ */ c((r) => r.neutralPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 20 : 95, "tone"),
  background: /* @__PURE__ */ c((r) => L.inverseSurface, "background"),
  contrastCurve: new dt(4.5, 7, 11, 21)
});
L.outline = G.fromPalette({
  name: "outline",
  palette: /* @__PURE__ */ c((r) => r.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 60 : 50, "tone"),
  background: /* @__PURE__ */ c((r) => L.highestSurface(r), "background"),
  contrastCurve: new dt(1.5, 3, 4.5, 7)
});
L.outlineVariant = G.fromPalette({
  name: "outline_variant",
  palette: /* @__PURE__ */ c((r) => r.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 30 : 80, "tone"),
  background: /* @__PURE__ */ c((r) => L.highestSurface(r), "background"),
  contrastCurve: new dt(1, 1, 3, 7)
});
L.shadow = G.fromPalette({
  name: "shadow",
  palette: /* @__PURE__ */ c((r) => r.neutralPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => 0, "tone")
});
L.scrim = G.fromPalette({
  name: "scrim",
  palette: /* @__PURE__ */ c((r) => r.neutralPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => 0, "tone")
});
L.surfaceTint = G.fromPalette({
  name: "surface_tint",
  palette: /* @__PURE__ */ c((r) => r.primaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 80 : 40, "tone"),
  isBackground: !0
});
L.primary = G.fromPalette({
  name: "primary",
  palette: /* @__PURE__ */ c((r) => r.primaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => Ht(r) ? r.isDark ? 100 : 0 : r.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ c((r) => L.highestSurface(r), "background"),
  contrastCurve: new dt(3, 4.5, 7, 11),
  toneDeltaPair: /* @__PURE__ */ c((r) => new we(L.primaryContainer, L.primary, 15, "nearer", !1), "toneDeltaPair")
});
L.onPrimary = G.fromPalette({
  name: "on_primary",
  palette: /* @__PURE__ */ c((r) => r.primaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => Ht(r) ? r.isDark ? 10 : 90 : r.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ c((r) => L.primary, "background"),
  contrastCurve: new dt(4.5, 7, 11, 21)
});
L.primaryContainer = G.fromPalette({
  name: "primary_container",
  palette: /* @__PURE__ */ c((r) => r.primaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => lo(r) ? Rh(r.sourceColorHct, r) : Ht(r) ? r.isDark ? 85 : 25 : r.isDark ? 30 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ c((r) => L.highestSurface(r), "background"),
  contrastCurve: new dt(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ c((r) => new we(L.primaryContainer, L.primary, 15, "nearer", !1), "toneDeltaPair")
});
L.onPrimaryContainer = G.fromPalette({
  name: "on_primary_container",
  palette: /* @__PURE__ */ c((r) => r.primaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => lo(r) ? G.foregroundTone(L.primaryContainer.tone(r), 4.5) : Ht(r) ? r.isDark ? 0 : 100 : r.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ c((r) => L.primaryContainer, "background"),
  contrastCurve: new dt(4.5, 7, 11, 21)
});
L.inversePrimary = G.fromPalette({
  name: "inverse_primary",
  palette: /* @__PURE__ */ c((r) => r.primaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 40 : 80, "tone"),
  background: /* @__PURE__ */ c((r) => L.inverseSurface, "background"),
  contrastCurve: new dt(3, 4.5, 7, 11)
});
L.secondary = G.fromPalette({
  name: "secondary",
  palette: /* @__PURE__ */ c((r) => r.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ c((r) => L.highestSurface(r), "background"),
  contrastCurve: new dt(3, 4.5, 7, 11),
  toneDeltaPair: /* @__PURE__ */ c((r) => new we(L.secondaryContainer, L.secondary, 15, "nearer", !1), "toneDeltaPair")
});
L.onSecondary = G.fromPalette({
  name: "on_secondary",
  palette: /* @__PURE__ */ c((r) => r.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => Ht(r) ? r.isDark ? 10 : 100 : r.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ c((r) => L.secondary, "background"),
  contrastCurve: new dt(4.5, 7, 11, 21)
});
L.secondaryContainer = G.fromPalette({
  name: "secondary_container",
  palette: /* @__PURE__ */ c((r) => r.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => {
    const t = r.isDark ? 30 : 90;
    if (Ht(r))
      return r.isDark ? 30 : 85;
    if (!lo(r))
      return t;
    let i = W1(r.secondaryPalette.hue, r.secondaryPalette.chroma, t, !r.isDark);
    return i = Rh(r.secondaryPalette.getHct(i), r), i;
  }, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ c((r) => L.highestSurface(r), "background"),
  contrastCurve: new dt(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ c((r) => new we(L.secondaryContainer, L.secondary, 15, "nearer", !1), "toneDeltaPair")
});
L.onSecondaryContainer = G.fromPalette({
  name: "on_secondary_container",
  palette: /* @__PURE__ */ c((r) => r.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => lo(r) ? G.foregroundTone(L.secondaryContainer.tone(r), 4.5) : r.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ c((r) => L.secondaryContainer, "background"),
  contrastCurve: new dt(4.5, 7, 11, 21)
});
L.tertiary = G.fromPalette({
  name: "tertiary",
  palette: /* @__PURE__ */ c((r) => r.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => Ht(r) ? r.isDark ? 90 : 25 : r.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ c((r) => L.highestSurface(r), "background"),
  contrastCurve: new dt(3, 4.5, 7, 11),
  toneDeltaPair: /* @__PURE__ */ c((r) => new we(L.tertiaryContainer, L.tertiary, 15, "nearer", !1), "toneDeltaPair")
});
L.onTertiary = G.fromPalette({
  name: "on_tertiary",
  palette: /* @__PURE__ */ c((r) => r.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => Ht(r) ? r.isDark ? 10 : 90 : r.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ c((r) => L.tertiary, "background"),
  contrastCurve: new dt(4.5, 7, 11, 21)
});
L.tertiaryContainer = G.fromPalette({
  name: "tertiary_container",
  palette: /* @__PURE__ */ c((r) => r.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => {
    if (Ht(r))
      return r.isDark ? 60 : 49;
    if (!lo(r))
      return r.isDark ? 30 : 90;
    const t = Rh(r.tertiaryPalette.getHct(r.sourceColorHct.tone), r), i = r.tertiaryPalette.getHct(t);
    return Yd.fixIfDisliked(i).tone;
  }, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ c((r) => L.highestSurface(r), "background"),
  contrastCurve: new dt(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ c((r) => new we(L.tertiaryContainer, L.tertiary, 15, "nearer", !1), "toneDeltaPair")
});
L.onTertiaryContainer = G.fromPalette({
  name: "on_tertiary_container",
  palette: /* @__PURE__ */ c((r) => r.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => Ht(r) ? r.isDark ? 0 : 100 : lo(r) ? G.foregroundTone(L.tertiaryContainer.tone(r), 4.5) : r.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ c((r) => L.tertiaryContainer, "background"),
  contrastCurve: new dt(4.5, 7, 11, 21)
});
L.error = G.fromPalette({
  name: "error",
  palette: /* @__PURE__ */ c((r) => r.errorPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ c((r) => L.highestSurface(r), "background"),
  contrastCurve: new dt(3, 4.5, 7, 11),
  toneDeltaPair: /* @__PURE__ */ c((r) => new we(L.errorContainer, L.error, 15, "nearer", !1), "toneDeltaPair")
});
L.onError = G.fromPalette({
  name: "on_error",
  palette: /* @__PURE__ */ c((r) => r.errorPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ c((r) => L.error, "background"),
  contrastCurve: new dt(4.5, 7, 11, 21)
});
L.errorContainer = G.fromPalette({
  name: "error_container",
  palette: /* @__PURE__ */ c((r) => r.errorPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 30 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ c((r) => L.highestSurface(r), "background"),
  contrastCurve: new dt(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ c((r) => new we(L.errorContainer, L.error, 15, "nearer", !1), "toneDeltaPair")
});
L.onErrorContainer = G.fromPalette({
  name: "on_error_container",
  palette: /* @__PURE__ */ c((r) => r.errorPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => r.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ c((r) => L.errorContainer, "background"),
  contrastCurve: new dt(4.5, 7, 11, 21)
});
L.primaryFixed = G.fromPalette({
  name: "primary_fixed",
  palette: /* @__PURE__ */ c((r) => r.primaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => Ht(r) ? 40 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ c((r) => L.highestSurface(r), "background"),
  contrastCurve: new dt(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ c((r) => new we(L.primaryFixed, L.primaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
L.primaryFixedDim = G.fromPalette({
  name: "primary_fixed_dim",
  palette: /* @__PURE__ */ c((r) => r.primaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => Ht(r) ? 30 : 80, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ c((r) => L.highestSurface(r), "background"),
  contrastCurve: new dt(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ c((r) => new we(L.primaryFixed, L.primaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
L.onPrimaryFixed = G.fromPalette({
  name: "on_primary_fixed",
  palette: /* @__PURE__ */ c((r) => r.primaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => Ht(r) ? 100 : 10, "tone"),
  background: /* @__PURE__ */ c((r) => L.primaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ c((r) => L.primaryFixed, "secondBackground"),
  contrastCurve: new dt(4.5, 7, 11, 21)
});
L.onPrimaryFixedVariant = G.fromPalette({
  name: "on_primary_fixed_variant",
  palette: /* @__PURE__ */ c((r) => r.primaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => Ht(r) ? 90 : 30, "tone"),
  background: /* @__PURE__ */ c((r) => L.primaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ c((r) => L.primaryFixed, "secondBackground"),
  contrastCurve: new dt(3, 4.5, 7, 11)
});
L.secondaryFixed = G.fromPalette({
  name: "secondary_fixed",
  palette: /* @__PURE__ */ c((r) => r.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => Ht(r) ? 80 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ c((r) => L.highestSurface(r), "background"),
  contrastCurve: new dt(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ c((r) => new we(L.secondaryFixed, L.secondaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
L.secondaryFixedDim = G.fromPalette({
  name: "secondary_fixed_dim",
  palette: /* @__PURE__ */ c((r) => r.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => Ht(r) ? 70 : 80, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ c((r) => L.highestSurface(r), "background"),
  contrastCurve: new dt(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ c((r) => new we(L.secondaryFixed, L.secondaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
L.onSecondaryFixed = G.fromPalette({
  name: "on_secondary_fixed",
  palette: /* @__PURE__ */ c((r) => r.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => 10, "tone"),
  background: /* @__PURE__ */ c((r) => L.secondaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ c((r) => L.secondaryFixed, "secondBackground"),
  contrastCurve: new dt(4.5, 7, 11, 21)
});
L.onSecondaryFixedVariant = G.fromPalette({
  name: "on_secondary_fixed_variant",
  palette: /* @__PURE__ */ c((r) => r.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => Ht(r) ? 25 : 30, "tone"),
  background: /* @__PURE__ */ c((r) => L.secondaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ c((r) => L.secondaryFixed, "secondBackground"),
  contrastCurve: new dt(3, 4.5, 7, 11)
});
L.tertiaryFixed = G.fromPalette({
  name: "tertiary_fixed",
  palette: /* @__PURE__ */ c((r) => r.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => Ht(r) ? 40 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ c((r) => L.highestSurface(r), "background"),
  contrastCurve: new dt(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ c((r) => new we(L.tertiaryFixed, L.tertiaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
L.tertiaryFixedDim = G.fromPalette({
  name: "tertiary_fixed_dim",
  palette: /* @__PURE__ */ c((r) => r.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => Ht(r) ? 30 : 80, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ c((r) => L.highestSurface(r), "background"),
  contrastCurve: new dt(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ c((r) => new we(L.tertiaryFixed, L.tertiaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
L.onTertiaryFixed = G.fromPalette({
  name: "on_tertiary_fixed",
  palette: /* @__PURE__ */ c((r) => r.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => Ht(r) ? 100 : 10, "tone"),
  background: /* @__PURE__ */ c((r) => L.tertiaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ c((r) => L.tertiaryFixed, "secondBackground"),
  contrastCurve: new dt(4.5, 7, 11, 21)
});
L.onTertiaryFixedVariant = G.fromPalette({
  name: "on_tertiary_fixed_variant",
  palette: /* @__PURE__ */ c((r) => r.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ c((r) => Ht(r) ? 90 : 30, "tone"),
  background: /* @__PURE__ */ c((r) => L.tertiaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ c((r) => L.tertiaryFixed, "secondBackground"),
  contrastCurve: new dt(3, 4.5, 7, 11)
});
const Ps = class Ps {
  /**
   * @param argb ARGB representation of a color
   * @return Tones matching that color's hue and chroma.
   */
  static fromInt(t) {
    const i = ye.fromInt(t);
    return Ps.fromHct(i);
  }
  /**
   * @param hct Hct
   * @return Tones matching that color's hue and chroma.
   */
  static fromHct(t) {
    return new Ps(t.hue, t.chroma, t);
  }
  /**
   * @param hue HCT hue
   * @param chroma HCT chroma
   * @return Tones matching hue and chroma.
   */
  static fromHueAndChroma(t, i) {
    return new Ps(t, i, Ps.createKeyColor(t, i));
  }
  constructor(t, i, s) {
    this.hue = t, this.chroma = i, this.keyColor = s, this.cache = /* @__PURE__ */ new Map();
  }
  static createKeyColor(t, i) {
    let n = ye.from(t, i, 50), a = Math.abs(n.chroma - i);
    for (let o = 1; o < 50; o += 1) {
      if (Math.round(i) === Math.round(n.chroma))
        return n;
      const l = ye.from(t, i, 50 + o), d = Math.abs(l.chroma - i);
      d < a && (a = d, n = l);
      const u = ye.from(t, i, 50 - o), y = Math.abs(u.chroma - i);
      y < a && (a = y, n = u);
    }
    return n;
  }
  /**
   * @param tone HCT tone, measured from 0 to 100.
   * @return ARGB representation of a color with that tone.
   */
  tone(t) {
    let i = this.cache.get(t);
    return i === void 0 && (i = ye.from(this.hue, this.chroma, t).toInt(), this.cache.set(t, i)), i;
  }
  /**
   * @param tone HCT tone.
   * @return HCT representation of a color with that tone.
   */
  getHct(t) {
    return ye.fromInt(this.tone(t));
  }
};
c(Ps, "TonalPalette");
let kt = Ps;
function su(r) {
  const t = Ay(r), i = Ly(r), s = Ry(r), n = [t.toString(16), i.toString(16), s.toString(16)];
  for (const [a, o] of n.entries())
    o.length === 1 && (n[a] = "0" + o);
  return "#" + n.join("");
}
c(su, "hexFromArgb");
function K1(r) {
  r = r.replace("#", "");
  const t = r.length === 3, i = r.length === 6, s = r.length === 8;
  if (!t && !i && !s)
    throw new Error("unexpected hex " + r);
  let n = 0, a = 0, o = 0;
  return t ? (n = Pi(r.slice(0, 1).repeat(2)), a = Pi(r.slice(1, 2).repeat(2)), o = Pi(r.slice(2, 3).repeat(2))) : i ? (n = Pi(r.slice(0, 2)), a = Pi(r.slice(2, 4)), o = Pi(r.slice(4, 6))) : s && (n = Pi(r.slice(2, 4)), a = Pi(r.slice(4, 6)), o = Pi(r.slice(6, 8))), (255 << 24 | (n & 255) << 16 | (a & 255) << 8 | o & 255) >>> 0;
}
c(K1, "argbFromHex");
function Pi(r) {
  return parseInt(r, 16);
}
c(Pi, "parseIntHex");
function G1(r, t = !1) {
  var l;
  const i = (l = r.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+\.{0,1}\d*))?\)$/)) == null ? void 0 : l.slice(1).map((d, u) => u === 3 ? Math.round(parseFloat(d) * 255) : parseFloat(d));
  if (!i)
    throw new Error("Could not parse rgba color.");
  const [s, n, a, o] = i;
  return ((t ? 255 : o & 255) << 24 | (s & 255) << 16 | (n & 255) << 8 | a & 255) >>> 0;
}
c(G1, "argbFromRgba");
function Y1(r) {
  Se();
  const t = document.createElement("wy-compute-styles");
  t.setAttribute("style", `color: ${r} !important;`), document.documentElement.append(t);
  const i = window.getComputedStyle(t).color;
  return t.remove(), i;
}
c(Y1, "getComputedColor");
function Zd(r) {
  return getComputedStyle(r).getPropertyValue("--wy-theme-color") || void 0;
}
c(Zd, "getCSSThemeColor");
function Z1(r, t) {
  let i = Zd(r);
  const s = new MutationObserver(() => {
    const o = Zd(r);
    o !== i && (i = o, t(o));
  }), n = {
    attributes: !0,
    attributeFilter: ["class", "style"]
  };
  let a = r;
  for (; a && a !== document; )
    s.observe(a, n), a = a.parentNode;
  return () => s.disconnect();
}
c(Z1, "observeCSSThemeColor");
function Xd() {
  var i;
  return Se(), ((i = Array.from(document.head.querySelectorAll("meta[name='theme-color']")).filter((s) => {
    var a;
    const n = s.getAttribute("media");
    return !n || ((a = window.matchMedia(n)) == null ? void 0 : a.matches);
  }).pop()) == null ? void 0 : i.getAttribute("content")) || void 0;
}
c(Xd, "getMetaThemeColor");
function X1(r) {
  Se();
  const t = Array.from(document.head.querySelectorAll("meta[name='theme-color']"));
  if (!t)
    return () => {
    };
  let i = Xd();
  const s = /* @__PURE__ */ c(() => {
    const l = Xd();
    l !== i && (i = l, r(l));
  }, "checkChangedColor"), n = new MutationObserver(s), a = {
    attributes: !0,
    attributeFilter: ["content"]
  }, o = [];
  return t.forEach((l) => {
    n.observe(l, a);
    const d = l.getAttribute("media");
    if (d) {
      const u = window.matchMedia(d);
      u.addEventListener("change", s), o.push(u);
    }
  }), () => {
    n.disconnect(), o.forEach((l) => l.removeEventListener("change", s));
  };
}
c(X1, "observeMetaThemeColor");
const xo = [], J1 = 16;
function tm(r, t = !1) {
  var O;
  if (xo.some((V) => V.seedColor === r)) {
    const V = (O = xo.find((q) => q.seedColor === r)) == null ? void 0 : O.colors;
    if (V)
      return V;
  }
  const i = [];
  t && i.push(`--wy-theme-color:${r};`);
  let s = r;
  !r.startsWith("#") && !r.startsWith("rgb") && (s = Y1(r));
  const n = r.startsWith("#") ? K1(s) : G1(s), a = ye.fromInt(n), o = a.hue, l = a.chroma, d = Math.max(48, l), u = Math.min(d, 84), m = 360 / 16, f = 27.4, g = -8, x = (o + 360 - f - g + m / 2) % m + f + g - m / 2, k = {
    primary: kt.fromHueAndChroma(o, d),
    secondary: kt.fromHueAndChroma(o, d / 3),
    tertiary: kt.fromHueAndChroma(o + 60, d / 2),
    neutral: kt.fromHueAndChroma(o, Math.min(l / 12, 4)),
    "neutral-variant": kt.fromHueAndChroma(o, Math.min(l / 6, 8)),
    error: kt.fromHueAndChroma(x, 84),
    warning: kt.fromHueAndChroma(x + 4 * m, u),
    // Same as yellow
    red: kt.fromHueAndChroma(x, u),
    "deep-orange": kt.fromHueAndChroma(x + 1 * m, u),
    orange: kt.fromHueAndChroma(x + 2 * m, u),
    amber: kt.fromHueAndChroma(x + 3 * m, u),
    yellow: kt.fromHueAndChroma(x + 4 * m, u),
    lime: kt.fromHueAndChroma(x + 5 * m, u),
    "light-green": kt.fromHueAndChroma(x + 6 * m, u),
    green: kt.fromHueAndChroma(x + 7 * m, u),
    teal: kt.fromHueAndChroma(x + 8 * m, u),
    cyan: kt.fromHueAndChroma(x + 9 * m, u),
    "light-blue": kt.fromHueAndChroma(x + 10 * m, u),
    blue: kt.fromHueAndChroma(x + 11 * m, u),
    indigo: kt.fromHueAndChroma(x + 12 * m, u),
    "deep-purple": kt.fromHueAndChroma(x + 13 * m, u),
    purple: kt.fromHueAndChroma(x + 14 * m, u),
    pink: kt.fromHueAndChroma(x + 15 * m, u),
    gray: kt.fromHueAndChroma(o, 4)
  }, S = {
    //"100": 100,
    99: 99,
    95: 95,
    90: 90,
    80: 80,
    70: 70,
    60: 60,
    50: 50,
    40: 40,
    30: 30,
    20: 20,
    10: 10
    //"0": 0
  }, P = {
    primary: S,
    secondary: S,
    tertiary: S,
    neutral: S,
    "neutral-variant": S,
    error: S,
    warning: S,
    blue: { light: 70, dark: 80 },
    indigo: { light: 60, dark: 60 },
    purple: { light: 60, dark: 70 },
    pink: { light: 60, dark: 70 },
    red: { light: 60, dark: 60 },
    orange: { light: 70, dark: 70 },
    yellow: { light: 70, dark: 80 },
    green: { light: 60, dark: 60 },
    teal: { light: 60, dark: 60 },
    cyan: { light: 50, dark: 60 },
    gray: { light: 50, dark: 60 }
  };
  for (const V in P) {
    const q = P[V];
    for (const N in q) {
      const H = su(k[V].tone(q[N]));
      i.push(`--wy-${V}-${N}:${H};`);
    }
  }
  const E = {
    light: k.primary.tone(40),
    dark: k.primary.tone(80)
  }, z = {
    light: k.neutral.tone(99),
    dark: k.neutral.tone(10)
  }, U = {
    "surface-1": {
      light: De.cam16Ucs(z.light, E.light, 0.05),
      dark: De.cam16Ucs(z.dark, E.dark, 0.05)
    },
    "surface-2": {
      light: De.cam16Ucs(z.light, E.light, 0.08),
      dark: De.cam16Ucs(z.dark, E.dark, 0.08)
    },
    "surface-3": {
      light: De.cam16Ucs(z.light, E.light, 0.11),
      dark: De.cam16Ucs(z.dark, E.dark, 0.11)
    },
    "surface-4": {
      light: De.cam16Ucs(z.light, E.light, 0.12),
      dark: De.cam16Ucs(z.dark, E.dark, 0.12)
    },
    "surface-5": {
      light: De.cam16Ucs(z.light, E.light, 0.14),
      dark: De.cam16Ucs(z.dark, E.dark, 0.14)
    }
  };
  for (const V in U) {
    const q = U[V];
    for (const N in q) {
      const H = su(q[N]);
      i.push(`--wy-${V}-${N}:${H};`);
    }
  }
  return xo.unshift({ seedColor: r, colors: i }), xo.length = Math.min(xo.length, J1), i;
}
c(tm, "generateThemeColors");
const em = /* @__PURE__ */ c((r) => {
  if (Se(), Of)
    document.adoptedStyleSheets = r.map(
      (t) => t instanceof CSSStyleSheet ? t : t.styleSheet
    );
  else
    for (const t of r) {
      const i = document.createElement("style"), s = global.litNonce;
      s !== void 0 && i.setAttribute("nonce", s), i.textContent = t.cssText, (document.head || document.documentElement).appendChild(i);
    }
}, "adoptGlobalStyles"), We = Z`.wy-light :where(wy-chat),.wy-light :where(wy-comments),.wy-light :where(wy-files),.wy-light :where(wy-messenger),.wy-light :where(wy-notifications),.wy-light :where(wy-posts),:host(.wy-light),:host .wy-light,::slotted(.wy-light){color-scheme:light;--wy-primary: var(--wy-primary-40, #006399);--wy-on-primary: var(--wy-white, #ffffff);--wy-primary-container: var(--wy-primary-90, #cde5ff);--wy-on-primary-container: var(--wy-primary-10, #001d32);--wy-secondary: var(--wy-secondary-40, #3b6a1c);--wy-on-secondary: var(--wy-white, #ffffff);--wy-secondary-container: var(--wy-secondary-90, #bbf294);--wy-on-secondary-container: var(--wy-secondary-10, #0a2100);--wy-tertiary: var(--wy-tertiary-40, #3b6a1c);--wy-on-tertiary: var(--wy-white, #ffffff);--wy-tertiary-container: var(--wy-tertiary-90, #bbf294);--wy-on-tertiary-container: var(--wy-tertiary-10, #0a2100);--wy-error: var(--wy-error-40, #ba1824);--wy-on-error: var(--wy-white, #ffffff);--wy-error-container: var(--wy-error-90, #ffdad7);--wy-on-error-container: var(--wy-error-10, #410004);--wy-warning: var(--wy-warning-70, #afb140);--wy-on-warning: var(--wy-black, #000000);--wy-warning-container: var(--wy-warning-90, #e7e971);--wy-on-warning-container: var(--wy-warning-10, #1c1d00);--wy-background: var(--wy-neutral-99, #fcfcff);--wy-on-background: var(--wy-neutral-10, #1a1c1e);--wy-surface: var(--wy-neutral-99, #fcfcff);--wy-on-surface: var(--wy-neutral-10, #1a1c1e);--wy-surface-variant: var(--wy-neutral-variant-90, #dee3eb);--wy-on-surface-variant: var(--wy-neutral-variant-30, #42474e);--wy-outline: var(--wy-neutral-variant-50, #72777e);--wy-outline-variant: var(--wy-neutral-variant-80, #c2c7ce);--wy-inverse-surface: var(--wy-neutral-20, #2f3033);--wy-on-inverse-surface: var(--wy-neutral-95, #f0f0f4);--wy-inverse-primary: var(--wy-primary-80, #95ccff);--wy-surface-1: var(--wy-surface-1-light, #f1f2f7);--wy-surface-2: var(--wy-surface-2-light, #eaedf3);--wy-surface-3: var(--wy-surface-3-light, #e3e7ee);--wy-surface-4: var(--wy-surface-4-light, #e1e6ed);--wy-surface-5: var(--wy-surface-5-light, #dce2ea);--wy-highlight: var(--wy-primary-95, #e8f2ff);--wy-on-highlight: var(--wy-primary-10, #001d32);--wy-link: var(--wy-primary-40, #006399);--wy-presence-active: var(--wy-green-light, #00a38b);--wy-blue: var(--wy-blue-light, #89a9fc);--wy-indigo: var(--wy-indigo-light, #9185de);--wy-purple: var(--wy-purple-light, #c675b7);--wy-pink: var(--wy-pink-light, #d57194);--wy-red: var(--wy-red-light, #db726c);--wy-orange: var(--wy-orange-light, #e89a3a);--wy-yellow: var(--wy-yellow-light, #afb140);--wy-green: var(--wy-green-light, #00a38b);--wy-teal: var(--wy-teal-light, #00a0a8);--wy-cyan: var(--wy-cyan-light, #0082a1);--wy-gray: var(--wy-gray-light, #76777a);--wy-code-text: var(--wy-code-text-light, #3b3b3b);--wy-code-variable: var(--wy-code-variable-light, #001080);--wy-code-operator: var(--wy-code-operator-light, #000000);--wy-code-prolog: var(--wy-code-prolog-light, #000080);--wy-code-comment: var(--wy-code-comment-light, #008000);--wy-code-builtin: var(--wy-code-builtin-light, #0070C1);--wy-code-number: var(--wy-code-number-light, #098658);--wy-code-inserted: var(--wy-code-inserted-light, #098658);--wy-code-constant: var(--wy-code-constant-light, #811F3F);--wy-code-hexcode: var(--wy-code-hexcode-light, #811F3F);--wy-code-regex: var(--wy-code-regex-light, #811F3F);--wy-code-char: var(--wy-code-char-light, #811F3F);--wy-code-tag: var(--wy-code-tag-light, #800000);--wy-code-attr-name: var(--wy-code-attr-name-light, #E50000);--wy-code-selector: var(--wy-code-selector-light, #E50000);--wy-code-property: var(--wy-code-property-light, #E50000);--wy-code-deleted: var(--wy-code-deleted-light, #A31515);--wy-code-string: var(--wy-code-string-light, #A31515);--wy-code-changed: var(--wy-code-changed-light, #0451A5);--wy-code-punctuation: var(--wy-code-punctuation-light, #000000);--wy-code-function: var(--wy-code-function-light, #0000FF);--wy-code-keyword: var(--wy-code-keyword-light, #AF00DB);--wy-code-class-name: var(--wy-code-class-name-light, #267F99)}.wy-dark:not(.wy-light) :where(wy-chat),.wy-dark:not(.wy-light) :where(wy-comments),.wy-dark:not(.wy-light) :where(wy-files),.wy-dark:not(.wy-light) :where(wy-messenger),.wy-dark:not(.wy-light) :where(wy-notifications),.wy-dark:not(.wy-light) :where(wy-posts),:host(.wy-dark:not(.wy-light)),:host .wy-dark:not(.wy-light),::slotted(.wy-dark:not(.wy-light)){color-scheme:dark;--wy-primary: var(--wy-primary-80, #95ccff);--wy-on-primary: var(--wy-primary-20, #003352);--wy-primary-container: var(--wy-primary-30, #004a75);--wy-on-primary-container: var(--wy-primary-90, #cde5ff);--wy-secondary: var(--wy-secondary-80, #a0d57b);--wy-on-secondary: var(--wy-secondary-20, #163800);--wy-secondary-container: var(--wy-secondary-30, #245103);--wy-on-secondary-container: var(--wy-secondary-90, #bbf294);--wy-tertiary: var(--wy-tertiary-80, #a0d57b);--wy-on-tertiary: var(--wy-tertiary-20, #163800);--wy-tertiary-container: var(--wy-tertiary-30, #245103);--wy-on-tertiary-container: var(--wy-tertiary-90, #bbf294);--wy-error: var(--wy-error-80, #ffb3ae);--wy-on-error: var(--wy-error-20, #68000b);--wy-error-container: var(--wy-error-30, #930014);--wy-on-error-container: var(--wy-error-90, #ffdad7);--wy-warning: var(--wy-warning-90, #e7e971);--wy-on-warning: var(--wy-warning-30, #484a00);--wy-warning-container: var(--wy-warning-50, #7a7c05);--wy-on-warning-container: var(--wy-warning-95, #f5f77d);--wy-background: var(--wy-neutral-10, #1a1c1e);--wy-on-background: var(--wy-neutral-90, #e2e2e5);--wy-surface: var(--wy-neutral-10, #1a1c1e);--wy-on-surface: var(--wy-neutral-90, #e2e2e5);--wy-surface-variant: var(--wy-neutral-variant-30, #42474e);--wy-on-surface-variant: var(--wy-neutral-variant-80, #c2c7ce);--wy-outline: var(--wy-neutral-variant-60, #8c9198);--wy-outline-variant: var(--wy-neutral-variant-30, #42474e);--wy-inverse-surface: var(--wy-neutral-90, #e2e2e5);--wy-on-inverse-surface: var(--wy-neutral-20, #2f3033);--wy-inverse-primary: var(--wy-primary-40, #006399);--wy-surface-1: var(--wy-surface-1-dark, #212427);--wy-surface-2: var(--wy-surface-2-dark, #25292d);--wy-surface-3: var(--wy-surface-3-dark, #292e33);--wy-surface-4: var(--wy-surface-4-dark, #2b3035);--wy-surface-5: var(--wy-surface-5-dark, #2d3338);--wy-highlight: var(--wy-primary-20, #003352);--wy-on-highlight: var(--wy-primary-90, #cde5ff);--wy-link: var(--wy-primary-80, #95ccff);--wy-presence-active: var(--wy-green-dark, #00a38b);--wy-blue: var(--wy-blue-dark, #b1c5ff);--wy-indigo: var(--wy-indigo-dark, #9185de);--wy-purple: var(--wy-purple-dark, #e38fd3);--wy-pink: var(--wy-pink-dark, #f48bae);--wy-red: var(--wy-red-dark, #db726c);--wy-orange: var(--wy-orange-dark, #e89a3a);--wy-yellow: var(--wy-yellow-dark, #cacc58);--wy-green: var(--wy-green-dark, #00a38b);--wy-teal: var(--wy-teal-dark, #00a0a8);--wy-cyan: var(--wy-cyan-dark, #009dc3);--wy-gray: var(--wy-gray-dark, #909194);--wy-code-text: var(--wy-code-text-dark, #cccccc);--wy-code-variable: var(--wy-code-variable-dark, #9CDCFE);--wy-code-operator: var(--wy-code-operator-dark, #d4d4d4);--wy-code-prolog: var(--wy-code-prolog-dark, #569CD6);--wy-code-comment: var(--wy-code-comment-dark, #6a9955);--wy-code-builtin: var(--wy-code-builtin-dark, #4fc1ff);--wy-code-number: var(--wy-code-number-dark, #b5cea8);--wy-code-inserted: var(--wy-code-inserted-dark, #b5cea8);--wy-code-constant: var(--wy-code-constant-dark, #646695);--wy-code-hexcode: var(--wy-code-hexcode-dark, #646695);--wy-code-regex: var(--wy-code-regex-dark, #d16969);--wy-code-char: var(--wy-code-char-dark, #d16969);--wy-code-tag: var(--wy-code-tag-dark, #569cd6);--wy-code-attr-name: var(--wy-code-attr-name-dark, #9cdcfe);--wy-code-selector: var(--wy-code-selector-dark, #9cdcfe);--wy-code-property: var(--wy-code-property-dark, #9cdcfe);--wy-code-deleted: var(--wy-code-deleted-dark, #ce9178);--wy-code-string: var(--wy-code-string-dark, #ce9178);--wy-code-changed: var(--wy-code-changed-dark, #569cd6);--wy-code-punctuation: var(--wy-code-punctuation-dark, #D4D4D4);--wy-code-function: var(--wy-code-function-dark, #569cd6);--wy-code-keyword: var(--wy-code-keyword-dark, #C586C0);--wy-code-class-name: var(--wy-code-class-name-dark, #4ec9b0)}`, im = Z`@property --wy-component-color{syntax: \"<color>\"; inherits: true; initial-value: currentColor;}@property --wy-component-background-color{syntax: \"<color>\"; inherits: true; initial-value: transparent;}`, sm = /* @__PURE__ */ c((r) => {
  var t;
  return t = class extends r {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), em([im, We]);
    }
  }, c(t, "WeavyStyles"), t;
}, "WeavyStylesMixin"), rm = /* @__PURE__ */ c((r) => {
  var t;
  return t = class extends r {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this.version = Ze.version, this.whenUrl().then(() => {
        this.isDestroyed || this.checkVersion();
      });
    }
    /**
     * Checks the version of the Weavy Context against the Weavy Environment version.
     *
     * @param {string} [version] - Optional version to check against the environment version.
     */
    async checkVersion(s = this.version) {
      var o, l;
      await this.whenUrl(), this.networkStateIsPending = !0;
      let n;
      try {
        if (n = await fetch(new URL("/version", this.url), await this.fetchOptions({}, !1)), !n.ok)
          throw new Error("Could not verify environment version.");
        this.networkStateIsPending = !1, this.serverState = "ok";
      } catch (d) {
        this.networkStateIsPending = !1, this.serverState = "unreachable", console.warn("Could not check version: " + d.toString());
        return;
      }
      const a = await n.text();
      if (a.startsWith("v") && (!s || !a || s !== a))
        try {
          const d = s.split(".").slice(0, 2), u = a.split(".").slice(0, 2);
          if (d[0] !== u[0])
            throw new Error();
          d[1] !== u[1] && console.warn(
            `Version inconsistency: ${Ze.sourceName}@${this.version} ≠ ${(o = this.url) == null ? void 0 : o.hostname}@${a}`
          );
        } catch {
          throw new Error(
            `Version mismatch! ${Ze.sourceName}@${this.version} ≠ ${(l = this.url) == null ? void 0 : l.hostname}@${a}`
          );
        }
    }
  }, c(t, "WeavyVersion"), t;
}, "WeavyVersionMixin");
var nn;
let Ty = (nn = class extends Event {
  constructor(t, i, s) {
    super("context-request", { bubbles: !0, composed: !0 }), this.context = t, this.callback = i, this.subscribe = s ?? !1;
  }
}, c(nn, "s"), nn);
var an;
let as = (an = class {
  constructor(t, i, s, n) {
    if (this.subscribe = !1, this.provided = !1, this.value = void 0, this.t = (a, o) => {
      this.unsubscribe && (this.unsubscribe !== o && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = a, this.host.requestUpdate(), this.provided && !this.subscribe || (this.provided = !0, this.callback && this.callback(a, o)), this.unsubscribe = o;
    }, this.host = t, i.context !== void 0) {
      const a = i;
      this.context = a.context, this.callback = a.callback, this.subscribe = a.subscribe ?? !1;
    } else this.context = i, this.callback = s, this.subscribe = n ?? !1;
    this.host.addController(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.host.dispatchEvent(new Ty(this.context, this.t, this.subscribe));
  }
}, c(an, "s"), an);
const yp = class yp {
  get value() {
    return this.o;
  }
  set value(t) {
    this.setValue(t);
  }
  setValue(t, i = !1) {
    const s = i || !Object.is(t, this.o);
    this.o = t, s && this.updateObservers();
  }
  constructor(t) {
    this.subscriptions = /* @__PURE__ */ new Map(), this.updateObservers = () => {
      for (const [i, { disposer: s }] of this.subscriptions) i(this.o, s);
    }, t !== void 0 && (this.value = t);
  }
  addCallback(t, i, s) {
    if (!s) return void t(this.value);
    this.subscriptions.has(t) || this.subscriptions.set(t, { disposer: /* @__PURE__ */ c(() => {
      this.subscriptions.delete(t);
    }, "disposer"), consumerHost: i });
    const { disposer: n } = this.subscriptions.get(t);
    t(this.value, n);
  }
  clearCallbacks() {
    this.subscriptions.clear();
  }
};
c(yp, "s");
let Jd = yp;
var on;
let nm = (on = class extends Event {
  constructor(t) {
    super("context-provider", { bubbles: !0, composed: !0 }), this.context = t;
  }
}, c(on, "e"), on);
var cn;
let th = (cn = class extends Jd {
  constructor(t, i, s) {
    var n, a;
    super(i.context !== void 0 ? i.initialValue : s), this.onContextRequest = (o) => {
      const l = o.composedPath()[0];
      o.context === this.context && l !== this.host && (o.stopPropagation(), this.addCallback(o.callback, l, o.subscribe));
    }, this.onProviderRequest = (o) => {
      const l = o.composedPath()[0];
      if (o.context !== this.context || l === this.host) return;
      const d = /* @__PURE__ */ new Set();
      for (const [u, { consumerHost: y }] of this.subscriptions) d.has(u) || (d.add(u), y.dispatchEvent(new Ty(this.context, u, !0)));
      o.stopPropagation();
    }, this.host = t, i.context !== void 0 ? this.context = i.context : this.context = i, this.attachListeners(), (a = (n = this.host).addController) == null || a.call(n, this);
  }
  attachListeners() {
    this.host.addEventListener("context-request", this.onContextRequest), this.host.addEventListener("context-provider", this.onProviderRequest);
  }
  hostConnected() {
    this.host.dispatchEvent(new nm(this.context));
  }
}, c(cn, "i"), cn);
function er({ context: r }) {
  return (t, i) => {
    const s = /* @__PURE__ */ new WeakMap();
    if (typeof i == "object") return i.addInitializer(function() {
      s.set(this, new th(this, { context: r }));
    }), { get() {
      return t.get.call(this);
    }, set(n) {
      var a;
      return (a = s.get(this)) == null || a.setValue(n), t.set.call(this, n);
    }, init(n) {
      var a;
      return (a = s.get(this)) == null || a.setValue(n), n;
    } };
    {
      t.constructor.addInitializer((o) => {
        s.set(o, new th(o, { context: r }));
      });
      const n = Object.getOwnPropertyDescriptor(t, i);
      let a;
      if (n === void 0) {
        const o = /* @__PURE__ */ new WeakMap();
        a = { get() {
          return o.get(this);
        }, set(l) {
          s.get(this).setValue(l), o.set(this, l);
        }, configurable: !0, enumerable: !0 };
      } else {
        const o = n.set;
        a = { ...n, set(l) {
          s.get(this).setValue(l), o == null || o.call(this, l);
        } };
      }
      return void Object.defineProperty(t, i, a);
    }
  };
}
c(er, "e$3");
function Qt({ context: r, subscribe: t }) {
  return (i, s) => {
    typeof s == "object" ? s.addInitializer(function() {
      new as(this, { context: r, callback: /* @__PURE__ */ c((n) => {
        i.set.call(this, n);
      }, "callback"), subscribe: t });
    }) : i.constructor.addInitializer((n) => {
      new as(n, { context: r, callback: /* @__PURE__ */ c((a) => {
        n[s] = a;
      }, "callback"), subscribe: t });
    });
  };
}
c(Qt, "c");
const wp = class wp extends Event {
  /**
   *
   * @param context the context key to request
   * @param callback the callback that should be invoked when the context with the specified key is available
   * @param subscribe when, true indicates we want to subscribe to future updates
   */
  constructor(t, i, s) {
    super("context-request", { bubbles: !0, composed: !0 }), this.context = t, this.callback = i, this.subscribe = s ?? !1;
  }
};
c(wp, "ContextRequestEvent");
let eh = wp;
const fp = class fp extends Event {
  /**
   *
   * @param context the context which this provider can provide
   */
  constructor(t) {
    super("context-provider", { bubbles: !0, composed: !0 }), this.context = t;
  }
};
c(fp, "ContextProviderEvent");
let ih = fp;
const mp = class mp extends th {
  constructor(t, i, s) {
    i.context !== void 0 ? super(t, i) : super(t, i, s), i.context !== void 0 ? this._context = i.context : this._context = i, this.isAttached = !0, this.host instanceof j || this.dispatchWhenConnected();
  }
  dispatchWhenConnected() {
    this.isAttached && (this.host.isConnected ? this.host.dispatchEvent(new ih(this._context)) : requestAnimationFrame(this.dispatchWhenConnected));
  }
  detachListeners() {
    this.isAttached = !1, this.host.removeEventListener("context-request", this.onContextRequest), this.host.removeEventListener("context-provider", this.onProviderRequest);
  }
};
c(mp, "WyContextProvider");
let Vc = mp;
const Xt = Symbol.for("weavy-client");
function am(r, t) {
  return Se(), new Vc(r, { context: Xt, initialValue: t });
}
c(am, "createWeavyContextProvider");
const Fe = Ph() ? am(document.documentElement) : void 0, om = /* @__PURE__ */ c((r) => {
  var t, i;
  return i = class extends r {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...a) {
      super(...a);
      // CONTEXT PROVIDER
      // SHOULD BE APPLIED LAST TO ENSURE EVERYTHING IS SET BEFORE CONTEXT GETS PROVIDED
      T(this, t);
      this.host !== document.documentElement ? (Fe == null || Fe.detachListeners(), I(this, t, new Vc(this.host, {
        context: Xt,
        initialValue: this
      }))) : Fe == null || Fe.setValue(this);
    }
    destroy() {
      var a;
      super.destroy(), this.host !== document.documentElement ? (a = b(this, t)) == null || a.detachListeners() : (Fe == null ? void 0 : Fe.value) === this && (Fe == null || Fe.setValue(void 0));
    }
  }, t = new WeakMap(), c(i, "WeavyContextProvider"), i;
}, "WeavyContextProviderMixin");
var Zo, Xo, Ei, ln;
const Gt = class Gt {
  // CONSTRUCTOR
  constructor(t) {
    // Promises
    // whenUrl
    T(this, Zo);
    T(this, Xo);
    // Reactive options
    T(this, Ei);
    T(this, ln);
    this.weavySid = So(), this.weavyId = `${Gt.sourceName}#${this.weavySid}`, this.cloudFilePickerUrl = Gt.defaults.cloudFilePickerUrl, this.disableEnvironmentImports = Gt.defaults.disableEnvironmentImports, this.gcTime = Gt.defaults.gcTime, this.reactions = Gt.defaults.reactions, this.scrollBehavior = Gt.defaults.scrollBehavior, this.staleTime = Gt.defaults.staleTime, this.tokenFactoryRetryDelay = Gt.defaults.tokenFactoryRetryDelay, this.tokenFactoryTimeout = Gt.defaults.tokenFactoryTimeout, I(this, Xo, new Promise((s) => {
      I(this, Zo, s);
    })), I(this, ln, !1), console.info(`${Gt.sourceName}@${Gt.version} #${this.weavySid}`), Se(), this.host = document.documentElement;
    const i = {};
    for (const s in t) {
      const n = s;
      t[n] !== void 0 && Object.assign(i, { [n]: t[n] });
    }
    i != null && i.host && (this.host = i.host, delete i.host), i && Object.assign(this, i);
  }
  async whenUrl() {
    await b(this, Xo);
  }
  /**
   * The URL to the weavy environment.
   */
  get url() {
    return b(this, Ei);
  }
  set url(t) {
    var i;
    if (this.isDestroyed)
      throw new At();
    try {
      if (typeof t == "string")
        t && I(this, Ei, new URL(t, window.location.toString()));
      else if (t instanceof URL)
        I(this, Ei, t || void 0);
      else if (t == null)
        I(this, Ei, void 0);
      else
        throw -1;
    } catch {
      throw new TypeError("Invalid url");
    }
    t && !this.disableEnvironmentImports && globalThis.WEAVY_IMPORT_URL === void 0 && (globalThis.WEAVY_IMPORT_URL = new URL(
      "./uikit-web/",
      t
    ).href), b(this, Ei) && ((i = b(this, Zo)) == null || i.call(this, b(this, Ei)));
  }
  /**
   * Prefix to use for caches.
   */
  get cachePrefix() {
    return `${Gt.version}:${this.url}`;
  }
  get isDestroyed() {
    return b(this, ln);
  }
  destroy() {
    I(this, ln, !0), console.info(this.weavyId, "was destroyed");
  }
};
Zo = new WeakMap(), Xo = new WeakMap(), Ei = new WeakMap(), ln = new WeakMap(), c(Gt, "WeavyClient"), Gt.version = "26.0.1", Gt.sourceName = "@weavy/uikit-web", Gt.defaults = {
  cloudFilePickerUrl: "https://filebrowser.weavy.io/v14/",
  disableEnvironmentImports: !1,
  gcTime: 1e3 * 60 * 60 * 24,
  // 24h,
  locale: Oy,
  reactions: ["😍", "😎", "😉", "😜", "👍"],
  notificationEvents: !1,
  scrollBehavior: "auto",
  staleTime: 1e3 * 1,
  // 1s
  tokenFactoryRetryDelay: 2e3,
  tokenFactoryTimeout: 2e4
};
let Ze = Gt;
const vp = class vp extends om(
  x1(
    R1(
      P1(
        C1(
          M1(
            $1(
              L1(rm(_1(sm(Ze))))
            )
          )
        )
      )
    )
  )
) {
};
c(vp, "Weavy");
let _o = vp;
const gp = class gp {
  constructor(t, i, s, n, a) {
    var o, l;
    if (this.subscribe = !1, this.provided = !1, this.value = void 0, this._callback = (d, u) => {
      this.unsubscribe && (this.unsubscribe !== u && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = d, this.host.requestUpdate(), (!this.provided || this.subscribe) && (this.provided = !0, this.callback && this.callback(d, u)), this.unsubscribe = u;
    }, this.host = t, i.context !== void 0) {
      const d = i;
      this.context = d.context, this.callback = d.callback, this.subscribe = d.subscribe ?? !1, this.ref = d.ref ?? t;
    } else
      this.context = i, this.callback = s, this.subscribe = n ?? !1, this.ref = a ?? t;
    (l = (o = this.host).addController) == null || l.call(o, this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.ref.dispatchEvent(
      new eh(this.context, this._callback, this.subscribe)
    );
  }
};
c(gp, "ContextConsumer");
let sh = gp;
const bp = class bp {
  /**
   * @param host - The host element
   * @param context - The Context to use. Should be constructed using createContext().
   */
  constructor(t, i, s) {
    this.whenRef = new Promise((n) => this.resolveRef = n), t.addController(this), this.host = t, this.ref = s, this.setContext(i);
  }
  /**
   * The DOM connected element that can subscribe to a context
   */
  get ref() {
    return this._ref;
  }
  set ref(t) {
    var i;
    this._ref = t, t && ((i = this.resolveRef) == null || i.call(this, t));
  }
  async setContext(t) {
    this.whenContext = new Promise((s) => this.resolveContext = s);
    const i = await this.whenRef;
    this.context = new sh(this.host, {
      context: t,
      subscribe: !0,
      callback: /* @__PURE__ */ c((s, n) => {
        var a;
        (a = this.resolveContext) == null || a.call(this, s), this.host.requestUpdate();
      }, "callback"),
      ref: i
    }), await ly(i), this.context.dispatchRequest();
  }
  hostUpdate() {
    var t, i;
    (t = this.context) != null && t.value && ((i = this.resolveContext) == null || i.call(this, this.context.value));
  }
};
c(bp, "ContextController");
let ru = bp;
const cm = { attribute: !0, type: String, converter: Af, reflect: !1, hasChanged: Lf }, lm = /* @__PURE__ */ c((r = cm, t, i) => {
  const { kind: s, metadata: n } = i;
  let a = globalThis.litPropertyMetadata.get(n);
  if (a === void 0 && globalThis.litPropertyMetadata.set(n, a = /* @__PURE__ */ new Map()), a.set(i.name, r), s === "accessor") {
    const { name: o } = i;
    return { set(l) {
      const d = t.get.call(this);
      t.set.call(this, l), this.requestUpdate(o, d, r);
    }, init(l) {
      return l !== void 0 && this.P(o, void 0, r), l;
    } };
  }
  if (s === "setter") {
    const { name: o } = i;
    return function(l) {
      const d = this[o];
      t.call(this, l), this.requestUpdate(o, d, r);
    };
  }
  throw Error("Unsupported decorator location: " + s);
}, "r$1");
function w(r) {
  return (t, i) => typeof i == "object" ? lm(r, t, i) : ((s, n, a) => {
    const o = n.hasOwnProperty(a);
    return n.constructor.createProperty(a, o ? { ...s, wrapped: !0 } : s), o ? Object.getOwnPropertyDescriptor(n, a) : void 0;
  })(r, t, i);
}
c(w, "n");
function D(r) {
  return w({ ...r, state: !0, attribute: !1 });
}
c(D, "r");
const dm = /* @__PURE__ */ c((r, t, i) => (i.configurable = !0, i.enumerable = !0, Reflect.decorate && typeof t != "object" && Object.defineProperty(r, t, i), i), "e$2");
function hm(r) {
  return (t, i) => {
    const { slot: s, selector: n } = r ?? {}, a = "slot" + (s ? `[name=${s}]` : ":not([name])");
    return dm(t, i, { get() {
      var d;
      const o = (d = this.renderRoot) == null ? void 0 : d.querySelector(a), l = (o == null ? void 0 : o.assignedElements(r)) ?? [];
      return n === void 0 ? l : l.filter((u) => u.matches(n));
    } });
  };
}
c(hm, "o");
var Jo;
const xp = class xp {
  //notificationsToasts: NotificationsToastsType = "browser";
  // PROPERTY INIT
  constructor(t) {
    T(this, Jo);
    this.notifications = "button-list", this.notificationsBadge = "count", I(this, Jo, t), Object.keys(this).forEach((s) => {
      s in t && Object.assign(this, { [s]: t[s] });
    });
  }
  /**
   * Provides a reference to the host.
   */
  get component() {
    return b(this, Jo);
  }
};
Jo = new WeakMap(), c(xp, "WeavyComponentSettings");
let Bc = xp;
const Fy = Symbol.for("weavy-component-settings");
var ho = /* @__PURE__ */ ((r) => (r.Chat = "chat", r.Comments = "comments", r.Feeds = "feeds", r.Files = "files", r.Messenger = "messenger", r))(ho || {});
const nu = {
  attachments: "attachments",
  bots: "bots",
  cloud_files: "cloudFiles",
  comments: "comments",
  embeds: "embeds",
  google_meet: "googleMeet",
  meetings: "meetings",
  mentions: "mentions",
  microsoft_teams: "microsoftTeams",
  polls: "polls",
  previews: "previews",
  reactions: "reactions",
  receipts: "receipts",
  thumbnails: "thumbnails",
  typing: "typing",
  versions: "versions",
  web_dav: "webDAV",
  webhooks: "webhooks",
  zoom_meetings: "zoomMeetings"
}, pm = {
  attachments: "noAttachments",
  cloud_files: "noCloudFiles",
  comments: "noComments",
  embeds: "noEmbeds",
  google_meet: "noGoogleMeet",
  mentions: "noMentions",
  microsoft_teams: "noMicrosoftTeams",
  polls: "noPolls",
  previews: "noPreviews",
  reactions: "noReactions",
  receipts: "noReceipts",
  thumbnails: "noThumbnails",
  typing: "noTyping",
  versions: "noVersions",
  web_dav: "noWebDAV",
  zoom_meetings: "noZoomMeetings"
}, $p = class $p {
  get result() {
    return this._result && this.observer ? this.observer.trackResult(this._result) : { isPending: !0 };
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((i) => this.resolveContext = i), this.whenQueryClient = new Promise((i) => this.resolveQueryClient = i), this.setContext();
  }
  async setContext() {
    await oo(this.host), this.context = new as(this.host, {
      context: Xt,
      subscribe: !0,
      callback: /* @__PURE__ */ c((t) => {
        var i, s;
        t && ((i = this.resolveContext) == null || i.call(this, t), this.queryClient = t.queryClient, (s = this.resolveQueryClient) == null || s.call(this, t.queryClient));
      }, "callback")
    });
  }
  async trackQuery(t, i = !0) {
    var a;
    const s = await this.whenQueryClient;
    if (!s)
      throw new Error("No QueryClient provided");
    (a = this.observerUnsubscribe) == null || a.call(this);
    const n = new $y(s, t);
    this.observer = n, this.observerSubscribe(i);
  }
  observerSubscribe(t = !0) {
    var i;
    if (this.queryClient && this.observer) {
      t ? this._result = this.observer.getOptimisticResult(this.observer.options) : this._result = this.observer.getCurrentResult(), this.observerUnsubscribe = this.observer.subscribe(() => {
        if (this.observer) {
          const n = hc(this.result, this.observer.getCurrentResult());
          n !== this._result && (this._result = n, this.host.requestUpdate());
        }
      }), this.observer.updateResult(), this.host.requestUpdate();
      let s;
      t ? s = this.observer.fetchOptimistic(this.observer.options) : s = (i = this.queryClient.getQueryCache().get(this.observer.options.queryHash)) == null ? void 0 : i.promise, s == null || s.catch(() => {
      }).finally(() => {
        var n;
        (n = this.observer) == null || n.updateResult();
      });
    }
  }
  untrackQuery() {
    var t;
    (t = this.observerUnsubscribe) == null || t.call(this), this.observerUnsubscribe = void 0, this._result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    var t;
    (t = this.observerUnsubscribe) == null || t.call(this);
  }
};
c($p, "QueryController");
let be = $p;
const Ih = Symbol.for("weavy-app"), wl = Symbol.for("weavy-user"), Th = Symbol.for("weavy-product-features"), Dy = Symbol.for("weavy-link"), Hy = Symbol.for("weavy-bot-user");
var um = Object.defineProperty, ym = Object.getOwnPropertyDescriptor, yt = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? ym(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && um(t, i, n), n;
}, "__decorateClass$18"), dn, hn, tc, ec, ic, sc, pn, un, rc, nc, ac, oc, cc, lc, ss, Rs, Is, pi;
const kp = class kp extends j {
  // PROPERTY INIT
  constructor() {
    super();
    // PROMISES
    // TODO: Switch to Promise.withResolvers() when allowed by typescript
    T(this, dn);
    T(this, hn);
    T(this, tc);
    T(this, ec);
    T(this, ic);
    T(this, sc);
    T(this, pn);
    T(this, un);
    T(this, rc);
    T(this, nc);
    T(this, ac);
    T(this, oc);
    T(this, cc);
    T(this, lc);
    T(this, ss);
    T(this, Rs);
    T(this, Is);
    T(this, pi);
    this.storage = qf("localStorage"), this.storageLinkHandler = (i) => {
      i.storageArea === this.storage && i.key === "wy-link" && i.newValue && this.readStorageLink();
    }, this.linkEventHandler = async (i) => {
      i.defaultPrevented || (this.link && this.link.id === i.detail.link.id && (this.link = void 0, await this.updateComplete), this.link = i.detail.link, this.link || this.provideStorageLink(i.detail.link));
    }, this.notificationEventHandler = (i) => {
      i.stopPropagation(), i.defaultPrevented || this.isConnected && this.checkVisibility(zf) && this.matchesLink(i.detail.link) && i.preventDefault();
    }, this.notifications = "button-list", this.notificationsBadge = "count", this.noAttachments = !1, this.noCloudFiles = !1, this.noComments = !1, this.noEmbeds = !1, this.noGoogleMeet = !1, this.noMentions = !1, this.noMicrosoftTeams = !1, this.noPolls = !1, this.noPreviews = !1, this.noReactions = !1, this.noReceipts = !1, this.noThumbnails = !1, this.noTyping = !1, this.noVersions = !1, this.noWebDAV = !1, this.noZoomMeetings = !1, I(this, hn, new Promise((i) => {
      I(this, dn, i);
    })), I(this, ec, new Promise((i) => {
      I(this, tc, i);
    })), I(this, sc, new Promise((i) => {
      I(this, ic, i);
    })), I(this, un, new Promise((i) => {
      I(this, pn, i);
    })), I(this, nc, new Promise((i) => {
      I(this, rc, i);
    })), I(this, oc, new Promise((i) => {
      I(this, ac, i);
    })), I(this, lc, new Promise((i) => {
      I(this, cc, i);
    })), I(this, ss, new be(this)), I(this, Rs, new be(this)), I(this, Is, new be(this)), I(this, pi, new be(this)), this.settings = new Bc(this);
  }
  /**
   * Checks if an Entity is matching the component.
   *
   * @param {EntityType} link Entity to check for match
   * @returns { boolean } True if the entity is matching the component
   */
  matchesLink(i) {
    var s, n, a;
    return (
      // Messenger conversation
      (s = i == null ? void 0 : i.app) != null && s.type && !this.componentType && ((n = this.appTypes) != null && n.includes(i.app.type)) ? i.bot ? i.bot === this.bot : !0 : (
        // Normal contextual app
        !!(i && i.app && this.componentType !== qe.Unknown && this.uid && ((a = i.app) == null ? void 0 : a.uid) === this.uid)
      )
    );
  }
  get link() {
    return this._link;
  }
  set link(i) {
    const s = this._link;
    !this.uid && this.componentType && this.componentType !== qe.Unknown ? this.whenApp().then(() => {
      this._link = this.matchesLink(i) ? i : void 0, this.requestUpdate("link", s);
    }) : (this._link = this.matchesLink(i) ? i : void 0, this.requestUpdate("link", s));
  }
  /**
   * Clears the link and resets the promise.
   */
  clearLink() {
    this.link && (I(this, un, new Promise((i) => {
      I(this, pn, i);
    })), this.link = void 0);
  }
  /**
   * Shares a link with other blocks that may consume it automatically.
   *
   * @param {LinkType} link - The entity to provide
   */
  provideStorageLink(i) {
    var s;
    (s = this.storage) == null || s.setItem("wy-link", btoa(JSON.stringify(i)));
  }
  /**
   * Reads a link from storage provides it in the .link property/context.
   */
  readStorageLink() {
    if (!this.storage) {
      console.error("Storage not available");
      return;
    }
    const i = this.storage.getItem("wy-link");
    if (i)
      try {
        const s = JSON.parse(atob(i));
        s && (this.link = s);
      } catch (s) {
        console.error("Error parsing link", s);
      }
  }
  /**
   * Consumes a link in the storage. Make sure to consume it after it has been used.
   */
  consumeStorageLink() {
    var i;
    (i = this.storage) == null || i.removeItem("wy-link");
  }
  get bot() {
    return this._bot;
  }
  set bot(i) {
    this._bot = i || void 0;
  }
  set name(i) {
    this._initialAppName ?? (this._initialAppName = i), this._appName = i;
  }
  get name() {
    return this._appName;
  }
  async whenApp() {
    return await b(this, hn);
  }
  async whenBotUser() {
    return await b(this, ec);
  }
  async whenHasFeatures() {
    return await b(this, sc);
  }
  async whenLink() {
    return await b(this, un);
  }
  async whenSettings() {
    return await b(this, nc);
  }
  async whenUser() {
    return await b(this, oc);
  }
  async whenWeavy() {
    return await b(this, lc);
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("wy-link", this.linkEventHandler), window.addEventListener("storage", this.storageLinkHandler), this.app && this.requestUpdate("app"), this.botUser && this.requestUpdate("botUser"), this.hasFeatures && this.requestUpdate("hasFeatures"), this.link && this.requestUpdate("link"), this.settings && this.requestUpdate("settings"), this.user && this.requestUpdate("user"), this.weavy && this.requestUpdate("weavy");
  }
  disconnectedCallback() {
    var i;
    super.disconnectedCallback(), document.removeEventListener("wy-link", this.linkEventHandler), window.removeEventListener("storage", this.storageLinkHandler), (i = this.weavy) == null || i.host.removeEventListener("wy-notification", this.notificationEventHandler, { capture: !0 });
  }
  async scheduleUpdate() {
    await oo(this), super.scheduleUpdate();
  }
  willUpdate(i) {
    var n, a, o, l, d, u, y, m, f, g, x, k, S, P, E, z, U, O, V, q, N;
    if (super.willUpdate(i), this.weavyContextConsumer ?? (this.weavyContextConsumer = new as(this, { context: Xt, subscribe: !0 })), (n = this.weavyContextConsumer) != null && n.value && this.weavy !== ((a = this.weavyContextConsumer) == null ? void 0 : a.value) && (this.weavy = (o = this.weavyContextConsumer) == null ? void 0 : o.value), Object.keys(this.settings).find((H) => i.has(H)) && (this.settings = new Bc(this)), i.has("weavy") && this.weavy && b(this, pi).trackQuery(yi(this.weavy, ["user"])), (l = b(this, pi).result) != null && l.isPending || this.user && b(this, pi).result.data && this.user.id !== b(this, pi).result.data.id && (console.warn("User changed, invalidating cache"), (d = this.weavy) == null || d.queryClient.invalidateQueries()), (u = b(this, pi).result) != null && u.isPending || (this.user = (y = b(this, pi).result) == null ? void 0 : y.data), (i.has("productType") || i.has("weavy")) && this.productType && this.weavy && b(this, Is).trackQuery(
      yi(this.weavy, ["features", this.productType])
    ), !((m = b(this, Is).result) != null && m.isPending)) {
      const H = (f = b(this, Is).result) == null ? void 0 : f.data;
      if (H) {
        const W = {};
        H.forEach((wt) => {
          const ut = this[pm[wt]];
          nu[wt] ? W[nu[wt]] = !ut : console.warn("Unknown feature provided:", wt);
        });
        const ft = this.hasFeatures;
        this.hasFeatures = W, this.requestUpdate("features", ft);
      }
    }
    if (i.has("componentType") || i.has("uid") || i.has("name") || i.has("weavy"))
      if (I(this, hn, new Promise((H) => {
        I(this, dn, H);
      })), this.componentType && this.uid && this.weavy) {
        const H = this.name ? { name: this.name } : void 0;
        b(this, ss).trackQuery(w1(this.weavy, this.uid, this.componentType, H));
      } else
        b(this, ss).untrackQuery(), this.app = void 0, this.name = this._initialAppName;
    (g = b(this, ss).result) != null && g.isPending || (this.app = (x = b(this, ss).result) == null ? void 0 : x.data, (k = this.app) != null && k.name && (this.name = this.app.name)), (i.has("weavy") || i.has("bot")) && this.weavy && this.bot && b(this, Rs).trackQuery(yi(this.weavy, ["users", this.bot])), (S = b(this, Rs).result) != null && S.isPending || (this.botUser = (P = b(this, Rs).result) == null ? void 0 : P.data), i.has("uid") && (this.uid || i.get("uid")) && this.uid !== i.get("uid") && this.clearLink(), (!this.link && (i.has("uid") && this.uid || i.has("app") && this.app) && this.componentType && this.componentType !== qe.Unknown || (i.has("appTypes") || i.has("bot")) && this.appTypes) && this.readStorageLink(), i.has("link") && this.link && (console.info(`Opening notification link in ${this.uid ?? this.componentType ?? this.productType}`), this.consumeStorageLink()), i.has("app") && this.app && ((E = b(this, dn)) == null || E.call(this, this.app)), i.has("botUser") && this.botUser && ((z = b(this, tc)) == null || z.call(this, this.botUser)), i.has("hasFeatures") && this.hasFeatures && ((U = b(this, ic)) == null || U.call(this, this.hasFeatures)), i.has("link") && this.link && ((O = b(this, pn)) == null || O.call(this, this.link)), i.has("settings") && this.settings && ((V = b(this, rc)) == null || V.call(this, this.settings)), i.has("user") && this.user && ((q = b(this, ac)) == null || q.call(this, this.user)), i.has("weavy") && this.weavy && (this.weavy.host.addEventListener("wy-notification", this.notificationEventHandler, { capture: !0 }), (N = b(this, cc)) == null || N.call(this, this.weavy));
  }
};
dn = new WeakMap(), hn = new WeakMap(), tc = new WeakMap(), ec = new WeakMap(), ic = new WeakMap(), sc = new WeakMap(), pn = new WeakMap(), un = new WeakMap(), rc = new WeakMap(), nc = new WeakMap(), ac = new WeakMap(), oc = new WeakMap(), cc = new WeakMap(), lc = new WeakMap(), ss = new WeakMap(), Rs = new WeakMap(), Is = new WeakMap(), pi = new WeakMap(), c(kp, "WeavyComponent");
let at = kp;
yt([
  D()
], at.prototype, "weavy", 2);
yt([
  er({ context: Ih }),
  D()
], at.prototype, "app", 2);
yt([
  er({ context: Hy }),
  D()
], at.prototype, "botUser", 2);
yt([
  er({ context: Th }),
  D()
], at.prototype, "hasFeatures", 2);
yt([
  er({ context: Fy }),
  D()
], at.prototype, "settings", 2);
yt([
  er({ context: wl }),
  D()
], at.prototype, "user", 2);
yt([
  er({ context: Dy })
], at.prototype, "_link", 2);
yt([
  w({ type: Object })
], at.prototype, "link", 1);
yt([
  D()
], at.prototype, "productType", 2);
yt([
  D()
], at.prototype, "componentType", 2);
yt([
  D()
], at.prototype, "appTypes", 2);
yt([
  w({ type: String })
], at.prototype, "bot", 1);
yt([
  w({ type: String })
], at.prototype, "uid", 2);
yt([
  w({ type: String })
], at.prototype, "name", 1);
yt([
  w({ type: String })
], at.prototype, "notifications", 2);
yt([
  w({ type: String })
], at.prototype, "notificationsBadge", 2);
yt([
  w({ type: Boolean })
], at.prototype, "noAttachments", 2);
yt([
  w({ type: Boolean })
], at.prototype, "noCloudFiles", 2);
yt([
  w({ type: Boolean })
], at.prototype, "noComments", 2);
yt([
  w({ type: Boolean })
], at.prototype, "noEmbeds", 2);
yt([
  w({ type: Boolean })
], at.prototype, "noGoogleMeet", 2);
yt([
  w({ type: Boolean })
], at.prototype, "noMentions", 2);
yt([
  w({ type: Boolean })
], at.prototype, "noMicrosoftTeams", 2);
yt([
  w({ type: Boolean })
], at.prototype, "noPolls", 2);
yt([
  w({ type: Boolean })
], at.prototype, "noPreviews", 2);
yt([
  w({ type: Boolean })
], at.prototype, "noReactions", 2);
yt([
  w({ type: Boolean })
], at.prototype, "noReceipts", 2);
yt([
  w({ type: Boolean })
], at.prototype, "noThumbnails", 2);
yt([
  w({ type: Boolean })
], at.prototype, "noTyping", 2);
yt([
  w({ type: Boolean })
], at.prototype, "noVersions", 2);
yt([
  w({ type: Boolean })
], at.prototype, "noWebDAV", 2);
yt([
  w({ type: Boolean })
], at.prototype, "noZoomMeetings", 2);
const wm = new Map(dy(_y)), s3 = new Map(dy(Py)), fm = new Map(Object.entries(My)), r3 = new Map(Object.entries(zy));
var mm = Object.defineProperty, ks = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = void 0, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = o(t, i, n) || n);
  return n && mm(t, i, n), n;
}, "__decorateClass$17");
const zt = /* @__PURE__ */ c((r) => {
  var i, s, n, a, o, l, d, u, y, m, f, g, x, k;
  const S = class S extends r {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...z) {
      super(...z);
      // PROMISES
      // TODO: Switch to Promise.withResolvers() when allowed by typescript
      T(this, i);
      T(this, s, new Promise((z) => {
        I(this, i, z);
      }));
      T(this, n);
      T(this, a, new Promise((z) => {
        I(this, n, z);
      }));
      T(this, o);
      T(this, l, new Promise((z) => {
        I(this, o, z);
      }));
      T(this, d);
      T(this, u, new Promise((z) => {
        I(this, d, z);
      }));
      T(this, y);
      T(this, m, new Promise((z) => {
        I(this, y, z);
      }));
      T(this, f);
      T(this, g, new Promise((z) => {
        I(this, f, z);
      }));
      T(this, x);
      T(this, k, new Promise((z) => {
        I(this, x, z);
      }));
    }
    async whenApp() {
      return await b(this, s);
    }
    async whenBotUser() {
      return await b(this, a);
    }
    async whenHasFeatures() {
      return await b(this, l);
    }
    async whenLink() {
      return await b(this, u);
    }
    async whenSettings() {
      return await b(this, m);
    }
    async whenUser() {
      return await b(this, g);
    }
    async whenWeavy() {
      return await b(this, k);
    }
    willUpdate(z) {
      var U, O, V, q, N, H, W;
      super.willUpdate(z), z.has("app") && this.app && ((U = b(this, i)) == null || U.call(this, this.app)), z.has("botUser") && this.botUser && ((O = b(this, n)) == null || O.call(this, this.botUser)), z.has("hasFeatures") && this.hasFeatures && ((V = b(this, o)) == null || V.call(this, this.hasFeatures)), z.has("link") && this.link && ((q = b(this, d)) == null || q.call(this, this.link)), z.has("settings") && this.settings && ((N = b(this, y)) == null || N.call(this, this.settings)), z.has("user") && this.user && ((H = b(this, f)) == null || H.call(this, this.user)), z.has("weavy") && this.weavy && ((W = b(this, x)) == null || W.call(this, this.weavy));
    }
    connectedCallback() {
      super.connectedCallback(), this.app && this.requestUpdate("app"), this.botUser && this.requestUpdate("botUser"), this.hasFeatures && this.requestUpdate("hasFeatures"), this.link && this.requestUpdate("link"), this.settings && this.requestUpdate("settings"), this.user && this.requestUpdate("user"), this.weavy && this.requestUpdate("weavy");
    }
  };
  i = new WeakMap(), s = new WeakMap(), n = new WeakMap(), a = new WeakMap(), o = new WeakMap(), l = new WeakMap(), d = new WeakMap(), u = new WeakMap(), y = new WeakMap(), m = new WeakMap(), f = new WeakMap(), g = new WeakMap(), x = new WeakMap(), k = new WeakMap(), c(S, "WeavyComponentConsumer");
  let t = S;
  return ks([
    Qt({ context: Ih, subscribe: !0 }),
    D()
  ], t.prototype, "app"), ks([
    Qt({ context: Hy, subscribe: !0 }),
    D()
  ], t.prototype, "botUser"), ks([
    Qt({ context: Th, subscribe: !0 }),
    D()
  ], t.prototype, "hasFeatures"), ks([
    Qt({ context: Dy, subscribe: !0 }),
    D()
  ], t.prototype, "link"), ks([
    Qt({ context: Fy, subscribe: !0 }),
    D()
  ], t.prototype, "settings"), ks([
    Qt({ context: wl, subscribe: !0 }),
    D()
  ], t.prototype, "user"), ks([
    Qt({ context: Xt, subscribe: !0 }),
    D()
  ], t.prototype, "weavy"), t;
}, "WeavyComponentConsumerMixin");
function vm(r) {
  return typeof r == "string" && r ? r = eval == null ? void 0 : (0, eval)(`"use strict";(${r})`) : r = void 0, r;
}
c(vm, "indirectEvalObject");
function fl(r) {
  if (r)
    try {
      return new URL(r, window.location.toString());
    } catch {
      console.warn("Invalid url: ", r);
    }
}
c(fl, "toUrl");
const B = /* @__PURE__ */ c((r) => (t, i) => {
  i !== void 0 ? i.addInitializer(() => {
    !customElements.get(r) && customElements.define(
      r,
      t
    );
  }) : !customElements.get(r) && customElements.define(r, t);
}, "customElement"), J = Z`@charset \"UTF-8\";:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]){box-sizing:border-box;text-align:initial;font-size:var(--wy-font-size, var(--wy-size, 1em))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:before,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:after{box-sizing:inherit}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a){text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-40, #006399))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):hover{text-decoration:var(--wy-link-hover-decoration, unset)}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])):hover{text-decoration:none}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(p),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(p){margin-top:0;margin-bottom:calc(1 * var(--wy-size, 1rem))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(label),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(label){cursor:inherit}:where(:host([hidden])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"])[hidden],:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *[hidden]{display:none!important}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where([role=button]),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where([role=button]){cursor:pointer}.wy-scroll-y{scroll-padding-top:var(--wy-scrollbar-adjust-top, 0);scroll-padding-bottom:var(--wy-scrollbar-adjust-bottom, 0)}.wy-scroll-y{overflow-y:auto;max-height:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-scroll-y:not(body){-webkit-overflow-scrolling:touch}.wy-scroll-y:not(.wy-scroll-x){overflow-x:hidden;touch-action:pan-y}.wy-scroll-x{overflow-x:auto;max-width:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-scroll-x:not(.wy-scroll-y){overflow-y:hidden;touch-action:pan-x}.wy-appbars{--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));background-color:var(--wy-component-background-color);box-shadow:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) 0 calc(-1 * var(--wy-border, 1px)) 0 0 inset}@supports (position: sticky){.wy-appbars{position:sticky;top:0;z-index:1020}}.wy-appbars>.wy-appbar,.wy-appbars>.wy-toolbar{background-color:transparent;box-shadow:none}.wy-appbar{--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));display:grid;align-items:center;justify-content:space-between;justify-items:center;height:var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem)))));padding:calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));flex:0 0 var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem)))));grid-template-columns:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) minmax(0,max-content) var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));column-gap:calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))) + var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));line-height:var(--wy-line-height, 1.5);background-color:var(--wy-component-background-color);color:var(--wy-component-color);box-shadow:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) 0 calc(-1 * var(--wy-border, 1px)) 0 0 inset}.wy-appbar .wy-badge{align-self:center}.wy-appbar .wy-button{max-height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}.wy-appbar-buttons,.wy-toolbar-buttons,.wy-appbar-section{display:flex;flex:0 0 auto;align-items:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));max-width:100%}.wy-appbar-buttons-first{justify-content:flex-start}.wy-appbar-buttons-last{justify-content:flex-end}.wy-toolbar-buttons-last{margin-inline-start:auto}.wy-appbar-text{max-width:100%;display:block;color:inherit!important;-webkit-user-select:none;user-select:none}.wy-appbar-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-appbar-text a,.wy-appbar-text a:hover{color:inherit}.wy-appbar-text-trashed{text-decoration:line-through}.wy-toolbars-bottom{position:absolute;z-index:1030;bottom:calc(var(--wy-footerbar-height, calc(4 * var(--wy-size, 1rem))) / 2);left:0;right:0;min-height:var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;justify-content:center;justify-items:center}.wy-toolbar{--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));display:flex;flex-wrap:wrap;align-items:center;justify-content:flex-start;justify-items:center;min-height:var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem)))));padding:calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));flex:1 0 var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem)))));column-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));line-height:var(--wy-line-height, 1.5);background-color:var(--wy-component-background-color);color:var(--wy-component-color);box-shadow:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) 0 calc(-1 * var(--wy-border, 1px)) 0 0 inset}.wy-toolbar-center{margin:0 auto;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)))}.wy-toolbar-center .wy-input{text-align:center}.wy-toolbar-text{margin-left:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}.wy-footerbar{--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));position:absolute;bottom:0;left:0;right:0;z-index:1020}.wy-footerbar:after{content:\"\";background-color:var(--wy-component-background-color);color:var(--wy-component-color);box-shadow:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) 0 var(--wy-border, 1px) 0 0 inset;position:absolute;width:100%;left:0;bottom:0;height:100%;z-index:-1}.wy-footerbar-sticky{position:sticky}[part~=wy-button]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399));color:var(--wy-component-color);background:var(--wy-component-background-color, transparent);height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;font-size:var(--wy-button-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-button-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));text-align:center;text-decoration:none;vertical-align:middle;cursor:pointer;-webkit-user-select:none;user-select:none;border:var(--wy-button-border-width, var(--wy-border-outline, 0)) solid var(--wy-outline, var(--wy-neutral-variant-50, #72777e));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));display:inline-flex;align-items:center;justify-content:center;gap:var(--wy-button-gap, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));position:relative}[part~=wy-button][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .8);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .5)}[part~=wy-button]:disabled{opacity:var(--wy-opacity-disabled, 38%);cursor:unset;pointer-events:none}[part~=wy-button-state-layer]>*{z-index:3}[part~=wy-button-state-layer]:before{content:\"\";z-index:2;position:absolute;top:0;left:0;right:0;bottom:0;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-button-state-layer]:hover:before{opacity:8%}[part~=wy-button-state-layer]:focus:before,[part~=wy-button-state-layer]:active:before,[part~=wy-button-state-layer][part~=wy-active]:before{opacity:12%}[part~=wy-button-icon]{--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));line-height:1;align-items:center;justify-content:center}[part~=wy-button-icon][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);padding:0;margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .5)}[part~=wy-button-icon][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * -.1)}[part~=wy-button-icon][part~=wy-active]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-button-icon-inline]{height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));width:auto;min-width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));background:var(--wy-component-background-color);color:currentColor;display:flex;padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-button-icon-inline][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);min-width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .25);margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .5)}[part~=wy-button-icon-inline][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * -.1)}[part~=wy-button-inline]{border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:calc(.5 * var(--wy-size, 1rem)) calc(.75 * var(--wy-size, 1rem));margin-inline:calc(-.25 * var(--wy-size, 1rem))}[part~=wy-button-primary]{--wy-component-background-color: var(--wy-primary, var(--wy-primary-40, #006399));--wy-component-color: var(--wy-on-primary, var(--wy-white, #ffffff))}[part~=wy-button-variant]{--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}[part~=wy-button-primary-text]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-button-inherit-color]{--wy-component-color: currentColor}[part~=wy-button-no-color]{--wy-component-color: unset}[part=wy-button-link]{padding:0;color:var(--wy-link-color, var(--wy-primary, var(--wy-primary-40, #006399)));text-decoration:var(--wy-link-decoration, none)}[part=wy-button-link]:hover,[part=wy-button-link]:focus{text-decoration:var(--wy-link-hover-decoration, unset)}[part~=wy-buttons]{display:flex;align-items:center;flex-wrap:wrap;gap:calc(.5 * var(--wy-size, 1rem))}[part~=wy-buttons-reverse]{flex-direction:row-reverse}[part~=wy-buttons-floating]{position:sticky;padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) 0;top:0;height:0;margin-bottom:calc(-1 * var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));z-index:1030;--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}.wy-code pre,.wy-editor .cm-content pre,.wy-content pre{text-wrap:pretty}.wy-code .code,.wy-code code[class*=language-],.wy-code pre[class*=language-],.wy-editor .cm-content .code,.wy-content .code,.wy-editor .cm-content code[class*=language-],.wy-content code[class*=language-],.wy-editor .cm-content pre[class*=language-],.wy-content pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));font-family:var(--wy-font-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace);text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;word-wrap:break-word;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}@media print{.wy-code code[class*=language-],.wy-code pre[class*=language-],.wy-editor .cm-content code[class*=language-],.wy-content code[class*=language-],.wy-editor .cm-content pre[class*=language-],.wy-content pre[class*=language-]{text-shadow:none}}.wy-code pre[class*=language-],.wy-editor .cm-content pre[class*=language-],.wy-content pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}.wy-code :not(pre)>code[class*=language-],.wy-code pre[class*=language-],.wy-editor .cm-content :not(pre)>code[class*=language-],.wy-content :not(pre)>code[class*=language-],.wy-editor .cm-content pre[class*=language-],.wy-content pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));background:var(--wy-background, var(--wy-neutral-99, #fcfcff))}.wy-code :not(pre)>code[class*=language-],.wy-editor .cm-content :not(pre)>code[class*=language-],.wy-content :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.wy-code .token.variable,.wy-editor .cm-content .token.variable,.wy-content .token.variable{color:var(--wy-code-variable, var(--wy-code-variable-light, #001080))}.wy-code .token.operator,.wy-editor .cm-content .token.operator,.wy-content .token.operator{color:var(--wy-code-operator, var(--wy-code-operator-light, #000000))}.wy-code .token.prolog,.wy-editor .cm-content .token.prolog,.wy-content .token.prolog{color:var(--wy-code-prolog, var(--wy-code-prolog-light, #000080))}.wy-code .token.comment,.wy-editor .cm-content .token.comment,.wy-content .token.comment{color:var(--wy-code-comment, var(--wy-code-comment-light, #008000))}.wy-code .token.builtin,.wy-editor .cm-content .token.builtin,.wy-content .token.builtin{color:var(--wy-code-builtin, var(--wy-code-builtin-light, #0070C1))}.wy-code .token.number,.wy-editor .cm-content .token.number,.wy-content .token.number{color:var(--wy-code-number, var(--wy-code-number-light, #098658))}.wy-code .token.inserted,.wy-editor .cm-content .token.inserted,.wy-content .token.inserted{color:var(--wy-code-inserted, var(--wy-code-inserted-light, #098658))}.wy-code .token.constant,.wy-editor .cm-content .token.constant,.wy-content .token.constant{color:var(--wy-code-constant, var(--wy-code-constant-light, #811F3F))}.wy-code .token.hexcode,.wy-editor .cm-content .token.hexcode,.wy-content .token.hexcode{color:var(--wy-code-hexcode, var(--wy-code-hexcode-light, #811F3F))}.wy-code .token.regex,.wy-editor .cm-content .token.regex,.wy-content .token.regex{color:var(--wy-code-regex, var(--wy-code-regex-light, #811F3F))}.wy-code .token.char,.wy-editor .cm-content .token.char,.wy-content .token.char{color:var(--wy-code-char, var(--wy-code-char-light, #811F3F))}.wy-code .token.tag,.wy-editor .cm-content .token.tag,.wy-content .token.tag{color:var(--wy-code-tag, var(--wy-code-tag-light, #800000))}.wy-code .token.attr-name,.wy-editor .cm-content .token.attr-name,.wy-content .token.attr-name{color:var(--wy-code-attr-name, var(--wy-code-attr-name-light, #E50000))}.wy-code .token.selector,.wy-editor .cm-content .token.selector,.wy-content .token.selector{color:var(--wy-code-selector, var(--wy-code-selector-light, #E50000))}.wy-code .token.property,.wy-editor .cm-content .token.property,.wy-content .token.property{color:var(--wy-code-property, var(--wy-code-property-light, #E50000))}.wy-code .token.deleted,.wy-editor .cm-content .token.deleted,.wy-content .token.deleted{color:var(--wy-code-deleted, var(--wy-code-deleted-light, #A31515))}.wy-code .token.string,.wy-editor .cm-content .token.string,.wy-content .token.string{color:var(--wy-code-string, var(--wy-code-string-light, #A31515))}.wy-code .token.changed,.wy-editor .cm-content .token.changed,.wy-content .token.changed{color:var(--wy-code-changed, var(--wy-code-changed-light, #0451A5))}.wy-code .token.punctuation,.wy-editor .cm-content .token.punctuation,.wy-content .token.punctuation{color:var(--wy-code-punctuation, var(--wy-code-punctuation-light, #000000))}.wy-code .token.function,.wy-editor .cm-content .token.function,.wy-content .token.function{color:var(--wy-code-function, var(--wy-code-function-light, #0000FF))}.wy-code .token.keyword,.wy-editor .cm-content .token.keyword,.wy-content .token.keyword{color:var(--wy-code-keyword, var(--wy-code-keyword-light, #AF00DB))}.wy-code .token.class-name,.wy-editor .cm-content .token.class-name,.wy-content .token.class-name{color:var(--wy-code-class-name, var(--wy-code-class-name-light, #267F99))}.wy-code .token.important,.wy-code .token.bold,.wy-editor .cm-content .token.important,.wy-content .token.important,.wy-editor .cm-content .token.bold,.wy-content .token.bold{font-weight:700}.wy-code .token.italic,.wy-editor .cm-content .token.italic,.wy-content .token.italic{font-style:italic}.wy-content{overflow-wrap:break-word;min-width:0}.wy-content :not(pre)>code{font-family:var(--wy-font-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace);overflow-wrap:inherit}.wy-content pre,.wy-content pre>code[class*=language-]{white-space:pre-wrap}.wy-content :first-child{margin-top:0}.wy-content :last-child{margin-bottom:0}.wy-content:empty{display:none}.wy-hashtag{color:var(--wy-primary, var(--wy-primary-40, #006399))}.wy-mention{font-weight:700}.wy-emoji-icon{display:inline-flex;justify-content:center;align-items:center;line-height:1;width:1em;height:1em;font-size:calc(1.25 * var(--wy-size, 1rem))}.wy-emoji-icon-sm{width:calc(1.125 * var(--wy-size, 1rem));height:calc(1.125 * var(--wy-size, 1rem));font-size:calc(1.125 * var(--wy-size, 1rem))}.wy-empty{display:flex;align-items:center;justify-content:center;flex:1;min-width:0;position:relative;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-icon]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-icon][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon-first]{margin-left:calc(-.5 * var(--wy-size, 1rem))}[part~=wy-icon-last]{margin-right:calc(-.5 * var(--wy-size, 1rem))}[part~=wy-icon-padded]{margin:16.66666667%}[part~=wy-icon-inline]{vertical-align:-.25em}[part~=wy-icon-overlay]{position:absolute;bottom:0;right:0;border-radius:50%}:host(wy-icon-stack),[part~=wy-icon-stack]{display:inline-flex;position:relative;line-height:1}[part~=wy-icon-stack-layer]{position:absolute}[part~=wy-icon-stack-overlay]{position:absolute;bottom:0;right:0;border-radius:50%;width:calc(var(--wy-component-icon-width) / 2);height:calc(var(--wy-component-icon-height) / 2)}[part~=wy-icon-current-color]{fill:currentColor}[part~=wy-icon-state]{transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));align-self:center;justify-self:center;margin:auto;opacity:0}[part~=wy-icon-state][part~=wy-active]{opacity:1}[part~=wy-icon-display]{color:var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));border-radius:var(--wy-component-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem));margin:auto}[part~=wy-icon-display-icon]{color:var(--wy-component-color);--wy-component-icon-width: calc(4 * var(--wy-size, 1rem));--wy-component-icon-height: calc(4 * var(--wy-size, 1rem));padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem))}[part~=wy-icon-display-text],[part~=wy-icon-display-meta]{color:var(--wy-component-color);padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem));text-align:center}[part~=wy-icon-color-primary]{fill:var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-icon-color-secondary]{fill:var(--wy-secondary, var(--wy-secondary-40, #3b6a1c))}[part~=wy-icon-color-tertiary]{fill:var(--wy-tertiary, var(--wy-tertiary-40, #3b6a1c))}[part~=wy-icon-color-surface]{fill:var(--wy-surface, var(--wy-neutral-99, #fcfcff))}[part~=wy-icon-color-surface-variant]{fill:var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb))}[part~=wy-icon-color-error]{fill:var(--wy-error, var(--wy-error-40, #ba1824))}[part~=wy-icon-color-warning]{fill:var(--wy-warning, var(--wy-warning-70, #afb140))}[part~=wy-icon-color-blue]{fill:var(--wy-blue, var(--wy-blue-light, #89a9fc))}[part~=wy-icon-color-indigo]{fill:var(--wy-indigo, var(--wy-indigo-light, #9185de))}[part~=wy-icon-color-purple]{fill:var(--wy-purple, var(--wy-purple-light, #c675b7))}[part~=wy-icon-color-pink]{fill:var(--wy-pink, var(--wy-pink-light, #d57194))}[part~=wy-icon-color-red]{fill:var(--wy-red, var(--wy-red-light, #db726c))}[part~=wy-icon-color-orange]{fill:var(--wy-orange, var(--wy-orange-light, #e89a3a))}[part~=wy-icon-color-yellow]{fill:var(--wy-yellow, var(--wy-yellow-light, #afb140))}[part~=wy-icon-color-green]{fill:var(--wy-green, var(--wy-green-light, #00a38b))}[part~=wy-icon-color-teal]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a8))}[part~=wy-icon-color-cyan]{fill:var(--wy-cyan, var(--wy-cyan-light, #0082a1))}[part~=wy-icon-color-gray]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-icon-color-black]{fill:var(--wy-black, var(--wy-black, #000000))}[part~=wy-icon-color-white]{fill:var(--wy-white, var(--wy-white, #ffffff))}[part*=wy-kind-]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-kind-archive]{fill:var(--wy-orange, var(--wy-orange-light, #e89a3a))}[part~=wy-kind-audio]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a8))}[part~=wy-kind-code]{fill:var(--wy-green, var(--wy-green-light, #00a38b))}[part~=wy-kind-document]{fill:var(--wy-blue, var(--wy-blue-light, #89a9fc))}[part~=wy-kind-email]{fill:var(--wy-red, var(--wy-red-light, #db726c))}[part~=wy-kind-presentation]{fill:var(--wy-orange, var(--wy-orange-light, #e89a3a))}[part~=wy-kind-spreadsheet]{fill:var(--wy-green, var(--wy-green-light, #00a38b))}[part~=wy-kind-image]{fill:var(--wy-pink, var(--wy-pink-light, #d57194))}[part~=wy-kind-text]{fill:var(--wy-cyan, var(--wy-cyan-light, #0082a1))}[part~=wy-kind-video]{fill:var(--wy-purple, var(--wy-purple-light, #c675b7))}[part~=wy-ext-pdf]{fill:var(--wy-red, var(--wy-red-light, #db726c))}[part~=wy-kind-text-icon]{width:calc(1.25 * var(--wy-size, 1rem));height:calc(1.25 * var(--wy-size, 1rem));vertical-align:calc(-.3125 * var(--wy-size, 1rem))}.wy-image-grid{display:flex;flex-wrap:wrap;justify-content:space-evenly;position:relative;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));overflow:hidden;column-gap:1px;row-gap:1px}.wy-image-grid .wy-image{padding:0;width:50%;position:relative;flex:auto;background-color:inherit;background-clip:content-box}.wy-image-grid .wy-image:first-of-type:not(:nth-last-of-type(2)){flex-basis:100%!important}.wy-image-grid .wy-image-area{display:block;height:100%;cursor:pointer}.wy-image-grid .wy-image-area img{position:absolute;height:100%;width:100%;object-fit:contain}.wy-image-grid .wy-image-area img.wy-loading{transition:opacity .15s ease-out;opacity:0}.wy-image-grid .wy-image-area img.wy-loading.wy-loaded{opacity:1;transition:opacity .15s ease-out}.wy-image-grid .wy-image-area img.wy-loading.wy-loaded~img{transition-delay:.15s;opacity:0}.wy-image-grid .wy-more{position:absolute;line-height:100%;color:var(--wy-white, #ffffff);top:0;left:0;bottom:0;right:0;display:flex;align-items:center;justify-content:center;font-size:calc(1.5 * var(--wy-size, 1rem));background:rgba(0,0,0,var(--wy-opacity-disabled, 38%))}.wy-title{font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));font-size:var(--wy-headings-font-size, 1.25em);font-style:var(--wy-headings-font-style, unset);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, bolder));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.5));margin-block:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}.wy-input{--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border:var(--wy-input-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));display:block;width:100%;min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em)) * 1.5 * var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * 2 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) * 2);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-input-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem))));background-clip:padding-box;-webkit-appearance:none;-moz-appearance:none;appearance:none;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}.wy-input:focus{--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));color:var(--wy-component-color);border-color:var(--wy-primary, var(--wy-primary-40, #006399));outline:0}.wy-input::placeholder{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));opacity:1}.wy-input:disabled{opacity:38%}.wy-input::file-selector-button,.wy-input::-webkit-file-upload-button{color:var(--wy-component-color);background-color:var(--wy-component-background-color);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));margin:calc(-1 * var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) calc(-1 * var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));margin-inline-end:var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));pointer-events:none;border-color:inherit;border-style:solid;border-width:0;border-inline-end-width:var(--wy-input-border-width, var(--wy-border, 1px));border-radius:0}.wy-input:hover:not(:disabled):not([readonly])::file-selector-button,.wy-input:hover:not(:disabled):not([readonly]) ::-webkit-file-upload-button{background-color:var(--wy-component-background-color)}.wy-input[type=file]{overflow:hidden}.wy-input[type=file]:not(:disabled):not([readonly]){cursor:pointer}.wy-input::-webkit-date-and-time-value{height:calc(var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem)))) * 1em)}.wy-input[type=search]::-webkit-search-cancel-button{-webkit-appearance:none}.wy-input-filled{--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-input-filled-border-radius, var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem)))));border-color:var(--wy-component-background-color)}.wy-input-filled:focus{border-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-label{display:inline-block;margin-bottom:calc(.5 * var(--wy-size, 1rem))}.wy-description{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));margin-top:calc(.25 * var(--wy-size, 1rem))}.wy-is-invalid,.wy-is-invalid:focus{border-color:var(--wy-error, var(--wy-error-40, #ba1824))}.wy-invalid-feedback{margin-top:calc(.25 * var(--wy-size, 1rem));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));color:var(--wy-error, var(--wy-error-40, #ba1824))}.wy-input-group{position:relative;display:flex;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));align-items:center}.wy-input-group-button-icon{position:absolute;top:0;right:0;z-index:4;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));--wy-component-background-color: transparent}.wy-input-group-input:placeholder-shown~.wy-input-group-button-icon[type=reset]{display:none}.wy-input-group-input:not(:placeholder-shown)~.wy-input-group-button-icon[type=reset]+.wy-input-group-button-icon{display:none}.wy-item{--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));position:relative;display:flex;align-items:center;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));text-decoration:none}.wy-list-item{min-height:calc(3 * var(--wy-size, 1rem))}.wy-list-item-lg{min-height:calc(4.5 * var(--wy-size, 1rem))}.wy-item-inner{display:flex;align-items:center;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));flex:1 1 100%}.wy-item-body{width:100%;min-width:0}.wy-item-rows{display:flex;flex-direction:column;width:100%;row-gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));min-width:0}.wy-item-rows:only-child{margin-inline-start:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-item-rows-compact{row-gap:0}.wy-item-rows-single{margin-inline-start:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-item-title{color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset))}.wy-item-title{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-item-title-lg{color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset))}.wy-item-title-lg{display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;overflow:hidden}.wy-item-text{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}.wy-item-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-item-text .wy-icon{width:calc(1.25 * var(--wy-size, 1rem));height:calc(1.25 * var(--wy-size, 1rem));vertical-align:calc(-.3125 * var(--wy-size, 1rem))}.wy-item-quote{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e))}.wy-item-quote:before,.wy-item-quote:after{content:'\"'}.wy-item-actions{--wy-component-background-color: transparent;display:flex;align-items:center;justify-items:flex-end;flex:0 0 auto;margin:calc(-.25 * var(--wy-size, 1rem))}.wy-item-top{align-self:flex-start}.wy-item-actions-bottom{align-self:flex-start;margin-block:calc(-.5 * var(--wy-size, 1rem))}.wy-item-row{display:flex;align-items:center;column-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}.wy-item-row .wy-item-title,.wy-item-row .wy-item-text{margin-right:auto}.wy-item-row .wy-meta{white-space:nowrap}.wy-item-right{margin-left:auto}.wy-item-hover{-webkit-user-select:none;user-select:none;cursor:pointer}.wy-item-hover:hover,.wy-item-hover:focus{--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);text-decoration:none}.wy-item-hover:active{--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-item-hover.wy-disabled,.wy-item-hover:disabled{opacity:var(--wy-opacity-disabled, 38%);pointer-events:none}.wy-item-hover.wy-active{--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-90, #cde5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-primary-10, #001d32));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-color:var(--wy-component-background-color)}.wy-item-trashed{text-decoration:line-through;opacity:var(--wy-opacity-disabled, 38%)}.wy-item-trashed.wy-item-hover:hover{opacity:1}.wy-list{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;gap:var(--wy-border);min-width:0}.wy-list .wy-item:not(.wy-item-hover){--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-list .wy-item:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.wy-list .wy-item:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.wy-list-bordered{border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));gap:0}.wy-list-bordered .wy-item{border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));border-left:none;border-right:none}.wy-list-bordered .wy-item:first-child{border-top:none}.wy-list-bordered .wy-item:last-child{border-bottom:none}.wy-list-bordered .wy-item+.wy-list-bordered .wy-item{border-top-width:0}@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-primary-95, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-primary-10, #001d32))}}.wy-messages{padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));flex:1 1 100%}.wy-message-placeholder{opacity:.5}.wy-date-separator{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));pointer-events:none;margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));text-align:center;position:sticky;top:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));z-index:10}.wy-date-separator time{background:var(--wy-surface-3, var(--wy-surface-3-light, #e3e7ee));color:var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:inline-block}.wy-message{display:flex;flex-direction:row;align-items:flex-start;margin-bottom:calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + .5 * var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));scroll-margin-block:6rem;--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}.wy-message[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}.wy-message .wy-image-grid,.wy-message .wy-attachments{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-message-meta{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:0 0 calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));color:var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}.wy-message-bubble{background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));display:flex;flex-direction:column;padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));max-width:min(32 * var(--wy-size, 1rem),100% - 2 * var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}.wy-message-bubble>div{flex:1 1 100%}.wy-message-author{margin:calc(1.375 * var(--wy-size, 1rem)) calc(.5 * var(--wy-size, 1rem)) 0 0}.wy-message-content{display:flex;flex-direction:column;width:100%;align-items:flex-start;flex-wrap:wrap;min-width:0;position:relative}.wy-message-content-row{display:flex;flex-direction:row;align-items:center;max-width:100%}.wy-message-bot{--wy-component-background-color: var(--wy-tertiary-container, var(--wy-tertiary-90, #bbf294));--wy-component-color: var(--wy-on-tertiary-container, var(--wy-tertiary-10, #0a2100))}.wy-message-me{margin-right:0;margin-left:calc(2.5 * var(--wy-size, 1rem));align-items:flex-end;--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-90, #cde5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-primary-10, #001d32))}.wy-message-me .wy-message-meta{margin:0 calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) 0}.wy-message-me .wy-message-content{align-items:flex-end}.wy-message-me .wy-message-content-row{flex-direction:row-reverse}.wy-message-emoji .wy-message-bubble{background:none;padding:0 0 var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}.wy-message-emoji .wy-content .wy-emoji{width:calc(3 * var(--wy-size, 1rem));height:calc(3 * var(--wy-size, 1rem));margin:0}.wy-message-emoji.wy-message-me .wy-content{text-align:end}.wy-readby-status{display:flex;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));height:calc(1.125 * var(--wy-size, 1rem));justify-content:flex-end;margin-top:calc(-.125 * var(--wy-size, 1rem))}.wy-message-readmore{justify-self:center;text-align:center}.wy-meta{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}.wy-meta-sm{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))}.wy-dialog{background:none;border:none;padding:0;margin:0}.wy-dialog[popover]{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1055}.wy-overlay-dialog{width:100%;height:100%;align-items:center;justify-content:center;overflow:visible;max-width:100%;max-height:100%}.wy-overlay-dialog[open]{display:flex}.wy-overlay-dialog:popover-open{display:flex}.wy-overlay-dialog:focus-visible{outline:none}.wy-overlay{--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column}.wy-overlay.wy-modal{width:100%;height:100%;overflow:hidden;border-radius:0}@media (min-width: 768px){.wy-overlay.wy-modal-padded{border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level4, 0 calc(1 * var(--wy-size, 1rem)) calc(2.25 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .14), 0 calc(.375 * var(--wy-size, 1rem)) calc(1.875 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .12), 0 calc(.5 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) calc(-.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));margin-left:calc(4 * var(--wy-size, 1rem));margin-top:auto;margin-right:calc(4 * var(--wy-size, 1rem));margin-bottom:auto;width:calc(32 * var(--wy-size, 1rem));max-height:calc(32 * var(--wy-size, 1rem))}}@media (min-width: 768px){.wy-overlay.wy-modal-full{margin:0;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level4, 0 calc(1 * var(--wy-size, 1rem)) calc(2.25 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .14), 0 calc(.375 * var(--wy-size, 1rem)) calc(1.875 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .12), 0 calc(.5 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) calc(-.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));max-width:calc(100% - 2 * var(--wy-size, 1rem));max-height:calc(100% - 2 * var(--wy-size, 1rem))}}.wy-overlay{opacity:0;visibility:hidden;transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) .01s,transform var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) .01s,visibility .01s step-end var(--wy-transition-duration-fast, .1s)}.wy-overlay.wy-open{transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),visibility var(--wy-transition-duration, .2s) step-start;visibility:visible}.wy-overlay.wy-open.wy-transition{opacity:1;transform:none}.wy-pane{display:flex;flex-direction:column;position:relative;min-height:0;height:100%;flex:1 1 auto}.wy-pane-body{display:flex;flex-direction:column;flex:1}.wy-pane-group{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}.wy-pane-background{--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-pane-toolbar{display:flex;flex:1;justify-content:space-evenly;align-items:center;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-picker-list{background:var(--wy-component-background-color);color:var(--wy-component-color);border:none}.wy-picker-list>.wy-picker-list-item:first-child,.wy-picker-list>:first-child .wy-picker-list-item{border-top:none}.wy-picker-list>.wy-picker-list-item:last-child,.wy-picker-list>:last-child .wy-picker-list-item{border-bottom:none}.wy-picker-list-item{display:flex;align-items:center;padding:calc(.25 * var(--wy-size, 1rem)) calc(.5 * var(--wy-size, 1rem))}.wy-picker-list-item>wy-icon{margin-left:calc(.25 * var(--wy-size, 1rem));margin-right:calc(.25 * var(--wy-size, 1rem));flex:0 0 auto}.wy-picker-list-item>button{margin-block-start:auto;flex:0 0 auto}.wy-picker-list-item-title{flex-grow:1}.wy-picker-list-item-title{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-main{display:flex;height:calc(100% - var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem))))));min-height:0}@media (max-width: 767.98px){.wy-main{flex-direction:column}}.wy-preview{--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;align-items:stretch;justify-content:stretch;position:relative;flex:1 1 100%;min-width:calc(16 * var(--wy-size, 1rem));min-height:calc(16 * var(--wy-size, 1rem));max-height:100%;max-width:100%}.wy-preview-layout{width:100%;height:100%}.wy-preview-swiper{display:flex;flex-direction:row;flex:1 1 100%;align-items:center;justify-content:start;min-width:calc(16 * var(--wy-size, 1rem));min-height:calc(16 * var(--wy-size, 1rem));max-height:100%;max-width:100%;overflow-x:scroll;scroll-snap-type:x mandatory;scroll-behavior:auto;overscroll-behavior-x:none;scrollbar-width:none}.wy-preview-swiper::-webkit-scrollbar{display:none}.wy-preview-swiper-disabled{overflow-x:hidden}.wy-preview-area{position:relative;min-width:100%;min-height:100%;width:100%;height:100%;flex:1 1 auto;display:flex;flex-direction:column;scroll-snap-stop:always;scroll-snap-align:center}.wy-nav-prev,.wy-nav-next{--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));background-color:var(--wy-component-background-color);position:absolute;top:50%;z-index:1000;border-radius:50%}.wy-nav-prev{left:calc(.5 * var(--wy-size, 1rem))}.wy-nav-next{right:calc(.5 * var(--wy-size, 1rem))}.wy-document{--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);align-self:flex-start;padding:calc(2 * var(--wy-size, 1rem)) calc(3.5 * var(--wy-size, 1rem));width:100%;min-height:100%;flex:1 0 auto}@media (min-width: 768px){.wy-document{padding:calc(3 * var(--wy-size, 1rem)) calc(4 * var(--wy-size, 1rem));margin:calc(2 * var(--wy-size, 1rem)) auto;border-radius:calc(.125 * var(--wy-size, 1rem));box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));width:120ch;min-height:170ch;max-width:calc(100% - 3.5 * var(--wy-size, 1rem))}}.wy-content-code{align-self:flex-start;width:100%;padding:calc(2 * var(--wy-size, 1rem)) calc(3.5 * var(--wy-size, 1rem))}.wy-content-iframe{border:0;display:block;width:100%;height:100%;top:0;left:0;flex:1 1 100%}.wy-content-iframe.wy-loaded{--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-content-iframe.wy-loaded~.wy-content-iframe-fallback,.wy-content-iframe.wy-loaded~.wy-spinner,.wy-content-iframe.wy-loaded~wy-spinner{display:none}.wy-content-iframe.wy-loading:not(.wy-loaded){position:absolute;visibility:hidden;z-index:-1;pointer-events:none}.wy-content-iframe.wy-loading:not(.wy-loaded):not(.wy-fallback)~.wy-content-iframe-fallback{display:none}.wy-content-iframe.wy-loading:not(.wy-loaded).wy-fallback~.wy-spinner,.wy-content-iframe.wy-loading:not(.wy-loaded).wy-fallback~wy-spinner{display:none}.wy-content-iframe~.wy-spinner,.wy-content-iframe~wy-spinner{margin:auto}.wy-content-html pre,.wy-content-html code{word-break:break-word;white-space:pre-wrap}.wy-content-image{min-width:0;display:flex;align-items:center;justify-content:center;position:relative;margin:auto;max-height:100%;max-width:100%;transition:transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform-origin var(--wy-transition-duration, .2s) step-end}.wy-content-image.wy-zoom{cursor:zoom-out;transition:transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform-origin var(--wy-transition-duration, .2s) step-start}.wy-content-image img{min-width:0;min-height:0;width:100%;height:100%}.wy-content-image img:not(.wy-loading-transition):not([data-controller~=image])~.wy-spinner,.wy-content-image img:not(.wy-loading-transition):not([data-controller~=image])~wy-spinner{display:none}.wy-content-image img.wy-loading,.wy-content-image img[data-controller~=image]{transition:opacity .15s ease-out;opacity:0}.wy-content-image img.wy-loading.wy-loaded,.wy-content-image img[data-controller~=image].wy-loaded{opacity:1;transition:opacity .15s ease-out}.wy-content-image img.wy-loading.wy-loaded~img,.wy-content-image img[data-controller~=image].wy-loaded~img{transition-delay:.15s;opacity:0}.wy-content-image img.wy-loading.wy-loaded~.wy-spinner,.wy-content-image img.wy-loading.wy-loaded~wy-spinner,.wy-content-image img[data-controller~=image].wy-loaded~.wy-spinner,.wy-content-image img[data-controller~=image].wy-loaded~wy-spinner{display:none}.wy-content-image img.wy-responsive-image-thumb{position:absolute;z-index:-1}.wy-content-image img~.wy-spinner,.wy-content-image img~wy-spinner{position:absolute}.wy-content-video:not(.wy-error){min-height:0;max-width:100%;max-height:100%;flex:1 1 auto}.wy-content-video,.wy-content-audio{margin:auto}.wy-content-video.wy-loading:not(.wy-loaded),.wy-content-video[data-controller~=media]:not(.wy-loaded),.wy-content-audio.wy-loading:not(.wy-loaded),.wy-content-audio[data-controller~=media]:not(.wy-loaded){visibility:hidden}.wy-content-video.wy-loading.wy-loaded~.wy-spinner,.wy-content-video.wy-loading.wy-loaded~wy-spinner,.wy-content-video[data-controller~=media].wy-loaded~.wy-spinner,.wy-content-video[data-controller~=media].wy-loaded~wy-spinner,.wy-content-audio.wy-loading.wy-loaded~.wy-spinner,.wy-content-audio.wy-loading.wy-loaded~wy-spinner,.wy-content-audio[data-controller~=media].wy-loaded~.wy-spinner,.wy-content-audio[data-controller~=media].wy-loaded~wy-spinner{display:none}.wy-content-video:focus,.wy-content-audio:focus{outline:none}.wy-pdf-container{position:absolute;width:100%;height:100%;bottom:0;left:0}.wy-pdf-container{overflow-y:auto;max-height:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-pdf-container:not(body){-webkit-overflow-scrolling:touch}.wy-pdf-container{overflow-x:auto;max-width:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-content-pdf .textLayer{position:absolute;text-align:initial;top:0;right:0;bottom:0;left:0;overflow:clip;opacity:1;line-height:1;text-size-adjust:none;forced-color-adjust:none;transform-origin:0 0;caret-color:CanvasText;z-index:0}.wy-content-pdf .textLayer.highlighting{touch-action:none}.wy-content-pdf .textLayer :is(span,br){color:transparent;position:absolute;white-space:pre;cursor:text;transform-origin:0% 0%}.wy-content-pdf .textLayer>:not(.markedContent),.wy-content-pdf .textLayer .markedContent span:not(.markedContent){z-index:1}.wy-content-pdf .textLayer span.markedContent{top:0;height:0}.wy-content-pdf .textLayer span[role=img]{-webkit-user-select:none;user-select:none;cursor:default}.wy-content-pdf .textLayer .highlight{--highlight-bg-color: rgb(180 0 170 / .25);--highlight-selected-bg-color: rgb(0 100 0 / .25);--highlight-backdrop-filter: none;--highlight-selected-backdrop-filter: none}@media screen and (forced-colors: active){.wy-content-pdf .textLayer .highlight{--highlight-bg-color: transparent;--highlight-selected-bg-color: transparent;--highlight-backdrop-filter: var(--hcm-highlight-filter);--highlight-selected-backdrop-filter: var(--hcm-highlight-selected-filter)}}.wy-content-pdf .textLayer .highlight{margin:-1px;padding:1px;background-color:var(--highlight-bg-color);-webkit-backdrop-filter:var(--highlight-backdrop-filter);backdrop-filter:var(--highlight-backdrop-filter);border-radius:4px}.wy-content-pdf .textLayer .highlight.appended{position:initial}.wy-content-pdf .textLayer .highlight.begin{border-radius:4px 0 0 4px}.wy-content-pdf .textLayer .highlight.end{border-radius:0 4px 4px 0}.wy-content-pdf .textLayer .highlight.middle{border-radius:0}.wy-content-pdf .textLayer .highlight.selected{background-color:var(--highlight-selected-bg-color);-webkit-backdrop-filter:var(--highlight-selected-backdrop-filter);backdrop-filter:var(--highlight-selected-backdrop-filter)}.wy-content-pdf .textLayer ::selection{background:#0000ff40;background:color-mix(in srgb,AccentColor,transparent 75%)}.wy-content-pdf .textLayer br::selection{background:transparent}.wy-content-pdf .textLayer .endOfContent{display:block;position:absolute;top:100%;right:0;bottom:0;left:0;z-index:0;cursor:default;-webkit-user-select:none;user-select:none}.wy-content-pdf .textLayer.selecting .endOfContent{top:0}.wy-content-pdf .annotationLayer{--annotation-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\");--input-focus-border-color: Highlight;--input-focus-outline: 1px solid Canvas;--input-unfocused-border-color: transparent;--input-disabled-border-color: transparent;--input-hover-border-color: black;--link-outline: none}@media screen and (forced-colors: active){.wy-content-pdf .annotationLayer{--input-focus-border-color: CanvasText;--input-unfocused-border-color: ActiveText;--input-disabled-border-color: GrayText;--input-hover-border-color: Highlight;--link-outline: 1.5px solid LinkText}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):required,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:required,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:required{outline:1.5px solid selectedItem}.wy-content-pdf .annotationLayer .linkAnnotation{outline:var(--link-outline)}.wy-content-pdf .annotationLayer .linkAnnotation:hover{-webkit-backdrop-filter:var(--hcm-highlight-filter);backdrop-filter:var(--hcm-highlight-filter)}.wy-content-pdf .annotationLayer .linkAnnotation>a:hover{opacity:0!important;background:none!important;box-shadow:none}.wy-content-pdf .annotationLayer .popupAnnotation .popup{outline:calc(1.5px * var(--scale-factor)) solid CanvasText!important;background-color:ButtonFace!important;color:ButtonText!important}.wy-content-pdf .annotationLayer .highlightArea:hover:after{position:absolute;top:0;left:0;width:100%;height:100%;-webkit-backdrop-filter:var(--hcm-highlight-filter);backdrop-filter:var(--hcm-highlight-filter);content:\"\";pointer-events:none}.wy-content-pdf .annotationLayer .popupAnnotation.focused .popup{outline:calc(3px * var(--scale-factor)) solid Highlight!important}}.wy-content-pdf .annotationLayer{position:absolute;top:0;left:0;pointer-events:none;transform-origin:0 0}.wy-content-pdf .annotationLayer[data-main-rotation=\"90\"] .norotate{transform:rotate(270deg) translate(-100%)}.wy-content-pdf .annotationLayer[data-main-rotation=\"180\"] .norotate{transform:rotate(180deg) translate(-100%,-100%)}.wy-content-pdf .annotationLayer[data-main-rotation=\"270\"] .norotate{transform:rotate(90deg) translateY(-100%)}.wy-content-pdf .annotationLayer.disabled section,.wy-content-pdf .annotationLayer.disabled .popup{pointer-events:none}.wy-content-pdf .annotationLayer .annotationContent{position:absolute;width:100%;height:100%;pointer-events:none}.wy-content-pdf .annotationLayer .annotationContent.freetext{background:transparent;border:none;top:0;right:0;bottom:0;left:0;overflow:visible;white-space:nowrap;font:10px sans-serif;line-height:1.35;-webkit-user-select:none;user-select:none}.wy-content-pdf .annotationLayer section{position:absolute;text-align:initial;pointer-events:auto;box-sizing:border-box;transform-origin:0 0}.wy-content-pdf .annotationLayer section:has(div.annotationContent) canvas.annotationContent{display:none}.textLayer.selecting~.wy-content-pdf .annotationLayer section{pointer-events:none}.wy-content-pdf .annotationLayer :is(.linkAnnotation,.buttonWidgetAnnotation.pushButton)>a{position:absolute;font-size:1em;top:0;left:0;width:100%;height:100%}.wy-content-pdf .annotationLayer :is(.linkAnnotation,.buttonWidgetAnnotation.pushButton):not(.hasBorder)>a:hover{opacity:.2;background-color:#ff0;box-shadow:0 2px 10px #ff0}.wy-content-pdf .annotationLayer .linkAnnotation.hasBorder:hover{background-color:#ff03}.wy-content-pdf .annotationLayer .hasBorder{background-size:100% 100%}.wy-content-pdf .annotationLayer .textAnnotation img{position:absolute;cursor:pointer;width:100%;height:100%;top:0;left:0}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea),.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input{background-image:var(--annotation-unfocused-field-background);border:2px solid var(--input-unfocused-border-color);box-sizing:border-box;font:calc(9px * var(--scale-factor)) sans-serif;height:100%;margin:0;vertical-align:top;width:100%}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):required,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:required,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:required{outline:1.5px solid red}.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select option{padding:0}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input{border-radius:50%}.wy-content-pdf .annotationLayer .textWidgetAnnotation textarea{resize:none}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea)[disabled],.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select[disabled],.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input[disabled]{background:none;border:2px solid var(--input-disabled-border-color);cursor:not-allowed}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):hover,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:hover,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:hover{border:2px solid var(--input-hover-border-color)}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):hover,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:hover,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:hover{border-radius:2px}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):focus,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:focus{background:none;border:2px solid var(--input-focus-border-color);border-radius:2px;outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) :focus{background-image:none;background-color:transparent}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox :focus{border:2px solid var(--input-focus-border-color);border-radius:2px;outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton :focus{border:2px solid var(--input-focus-border-color);outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{background-color:CanvasText;content:\"\";display:block;position:absolute}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{height:80%;left:45%;width:1px}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{transform:rotate(45deg)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{transform:rotate(-45deg)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{border-radius:50%;height:50%;left:25%;top:25%;width:50%}.wy-content-pdf .annotationLayer .textWidgetAnnotation input.comb{font-family:monospace;padding-left:2px;padding-right:0}.wy-content-pdf .annotationLayer .textWidgetAnnotation input.comb:focus{width:103%}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input{-webkit-appearance:none;-moz-appearance:none;appearance:none}.wy-content-pdf .annotationLayer .fileAttachmentAnnotation .popupTriggerArea{height:100%;width:100%}.wy-content-pdf .annotationLayer .popupAnnotation{position:absolute;font-size:calc(9px * var(--scale-factor));pointer-events:none;width:max-content;max-width:45%;height:auto}.wy-content-pdf .annotationLayer .popup{background-color:#ff9;box-shadow:0 calc(2px * var(--scale-factor)) calc(5px * var(--scale-factor)) #888;border-radius:calc(2px * var(--scale-factor));outline:1.5px solid rgb(255,255,74);padding:calc(6px * var(--scale-factor));cursor:pointer;font:message-box;white-space:normal;word-wrap:break-word;pointer-events:auto}.wy-content-pdf .annotationLayer .popupAnnotation.focused .popup{outline-width:3px}.wy-content-pdf .annotationLayer .popup *{font-size:calc(9px * var(--scale-factor))}.wy-content-pdf .annotationLayer .popup>.header{display:inline-block}.wy-content-pdf .annotationLayer .popup>.header h1{display:inline}.wy-content-pdf .annotationLayer .popup>.header .popupDate{display:inline-block;margin-left:calc(5px * var(--scale-factor));width:fit-content}.wy-content-pdf .annotationLayer .popupContent{border-top:1px solid rgb(51,51,51);margin-top:calc(2px * var(--scale-factor));padding-top:calc(2px * var(--scale-factor))}.wy-content-pdf .annotationLayer .richText>*{white-space:pre-wrap;font-size:calc(9px * var(--scale-factor))}.wy-content-pdf .annotationLayer .popupTriggerArea{cursor:pointer}.wy-content-pdf .annotationLayer section svg{position:absolute;width:100%;height:100%;top:0;left:0}.wy-content-pdf .annotationLayer .annotationTextContent{position:absolute;width:100%;height:100%;opacity:0;color:transparent;-webkit-user-select:none;user-select:none;pointer-events:none}.wy-content-pdf .annotationLayer .annotationTextContent span{width:100%;display:inline-block}.wy-content-pdf .annotationLayer svg.quadrilateralsContainer{contain:strict;width:0;height:0;position:absolute;top:0;left:0;z-index:-1}:host{--xfa-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\");--xfa-focus-outline: auto}@media screen and (forced-colors: active){:host{--xfa-focus-outline: 2px solid CanvasText}.wy-content-pdf .xfaLayer *:required{outline:1.5px solid selectedItem}}.wy-content-pdf .xfaLayer{background-color:transparent}.wy-content-pdf .xfaLayer .highlight{margin:-1px;padding:1px;background-color:#efcbed;border-radius:4px}.wy-content-pdf .xfaLayer .highlight.appended{position:initial}.wy-content-pdf .xfaLayer .highlight.begin{border-radius:4px 0 0 4px}.wy-content-pdf .xfaLayer .highlight.end{border-radius:0 4px 4px 0}.wy-content-pdf .xfaLayer .highlight.middle{border-radius:0}.wy-content-pdf .xfaLayer .highlight.selected{background-color:#cbdfcb}.wy-content-pdf .xfaPage{overflow:hidden;position:relative}.wy-content-pdf .xfaContentarea{position:absolute}.wy-content-pdf .xfaPrintOnly{display:none}.wy-content-pdf .xfaLayer{position:absolute;text-align:initial;top:0;left:0;transform-origin:0 0;line-height:1.2}.wy-content-pdf .xfaLayer *{color:inherit;font:inherit;font-style:inherit;font-weight:inherit;font-kerning:inherit;letter-spacing:-.01px;text-align:inherit;text-decoration:inherit;box-sizing:border-box;background-color:transparent;padding:0;margin:0;pointer-events:auto;line-height:inherit}.wy-content-pdf .xfaLayer *:required{outline:1.5px solid red}.wy-content-pdf .xfaLayer div,.wy-content-pdf .xfaLayer svg,.wy-content-pdf .xfaLayer svg *{pointer-events:none}.wy-content-pdf .xfaLayer a{color:#00f}.wy-content-pdf .xfaRich li{margin-left:3em}.wy-content-pdf .xfaFont{color:#000;font-weight:400;font-kerning:none;font-size:10px;font-style:normal;letter-spacing:0;text-decoration:none;vertical-align:0}.wy-content-pdf .xfaCaption{overflow:hidden;flex:0 0 auto}.wy-content-pdf .xfaCaptionForCheckButton{overflow:hidden;flex:1 1 auto}.wy-content-pdf .xfaLabel{height:100%;width:100%}.wy-content-pdf .xfaLeft{display:flex;flex-direction:row;align-items:center}.wy-content-pdf .xfaRight{display:flex;flex-direction:row-reverse;align-items:center}.wy-content-pdf :is(.xfaLeft,.xfaRight)>:is(.xfaCaption,.xfaCaptionForCheckButton){max-height:100%}.wy-content-pdf .xfaTop{display:flex;flex-direction:column;align-items:flex-start}.wy-content-pdf .xfaBottom{display:flex;flex-direction:column-reverse;align-items:flex-start}.wy-content-pdf :is(.xfaTop,.xfaBottom)>:is(.xfaCaption,.xfaCaptionForCheckButton){width:100%}.wy-content-pdf .xfaBorder{background-color:transparent;position:absolute;pointer-events:none}.wy-content-pdf .xfaWrapped{width:100%;height:100%}.wy-content-pdf :is(.xfaTextfield,.xfaSelect):focus{background-image:none;background-color:transparent;outline:var(--xfa-focus-outline);outline-offset:-1px}.wy-content-pdf :is(.xfaCheckbox,.xfaRadio):focus{outline:var(--xfa-focus-outline)}.wy-content-pdf .xfaTextfield,.wy-content-pdf .xfaSelect{height:100%;width:100%;flex:1 1 auto;border:none;resize:none;background-image:var(--xfa-unfocused-field-background)}.wy-content-pdf .xfaSelect{padding-inline:2px}.wy-content-pdf :is(.xfaTop,.xfaBottom)>:is(.xfaTextfield,.xfaSelect){flex:0 1 auto}.wy-content-pdf .xfaButton{cursor:pointer;width:100%;height:100%;border:none;text-align:center}.wy-content-pdf .xfaLink{width:100%;height:100%;position:absolute;top:0;left:0}.wy-content-pdf .xfaCheckbox,.wy-content-pdf .xfaRadio{width:100%;height:100%;flex:0 0 auto;border:none}.wy-content-pdf .xfaRich{white-space:pre-wrap;width:100%;height:100%}.wy-content-pdf .xfaImage{object-position:left top;object-fit:contain;width:100%;height:100%}.wy-content-pdf .xfaLrTb,.wy-content-pdf .xfaRlTb,.wy-content-pdf .xfaTb{display:flex;flex-direction:column;align-items:stretch}.wy-content-pdf .xfaLr{display:flex;flex-direction:row;align-items:stretch}.wy-content-pdf .xfaRl{display:flex;flex-direction:row-reverse;align-items:stretch}.wy-content-pdf .xfaTb>div{justify-content:left}.wy-content-pdf .xfaPosition,.wy-content-pdf .xfaArea{position:relative}.wy-content-pdf .xfaValignMiddle{display:flex;align-items:center}.wy-content-pdf .xfaTable{display:flex;flex-direction:column;align-items:stretch}.wy-content-pdf .xfaTable .xfaRow{display:flex;flex-direction:row;align-items:stretch}.wy-content-pdf .xfaTable .xfaRlRow{display:flex;flex-direction:row-reverse;align-items:stretch;flex:1}.wy-content-pdf .xfaTable .xfaRlRow>div{flex:1}.wy-content-pdf :is(.xfaNonInteractive,.xfaDisabled,.xfaReadOnly) :is(input,textarea){background:initial}@media print{.wy-content-pdf .xfaTextfield,.wy-content-pdf .xfaSelect{background:transparent}.wy-content-pdf .xfaSelect{-webkit-appearance:none;-moz-appearance:none;appearance:none;text-indent:1px;text-overflow:\"\"}}:host{--viewer-container-height: 0;--pdfViewer-padding-bottom: 0;--page-margin: 1px auto -8px;--page-border: 9px solid transparent;--spreadHorizontalWrapped-margin-LR: -3.5px;--loading-icon-delay: .4s}@media screen and (forced-colors: active){:host{--pdfViewer-padding-bottom: 9px;--page-margin: 8px auto -1px;--page-border: 1px solid CanvasText;--spreadHorizontalWrapped-margin-LR: 3.5px}}.wy-content-pdf [data-main-rotation=\"90\"]{transform:rotate(90deg) translateY(-100%)}.wy-content-pdf [data-main-rotation=\"180\"]{transform:rotate(180deg) translate(-100%,-100%)}.wy-content-pdf [data-main-rotation=\"270\"]{transform:rotate(270deg) translate(-100%)}.wy-content-pdf #hiddenCopyElement,.wy-content-pdf .hiddenCanvasElement{position:absolute;top:0;left:0;width:0;height:0;display:none}.wy-content-pdf .pdfViewer{--scale-factor: 1;--page-bg-color: unset;padding-bottom:var(--pdfViewer-padding-bottom);--hcm-highlight-filter: none;--hcm-highlight-selected-filter: none}@media screen and (forced-colors: active){.wy-content-pdf .pdfViewer{--hcm-highlight-filter: invert(100%)}}.wy-content-pdf .pdfViewer.copyAll{cursor:wait}.wy-content-pdf .pdfViewer .canvasWrapper{overflow:hidden;width:100%;height:100%}.wy-content-pdf .pdfViewer .canvasWrapper canvas{position:absolute;top:0;left:0;margin:0;display:block;width:100%;height:100%;contain:content}.wy-content-pdf .pdfViewer .canvasWrapper canvas .structTree{contain:strict}.wy-content-pdf .pdfViewer .page{--scale-round-x: 1px;--scale-round-y: 1px;direction:ltr;width:816px;height:1056px;margin:var(--page-margin);position:relative;overflow:visible;border:var(--page-border);background-clip:content-box;background-color:var(--page-bg-color, rgb(255, 255, 255))}.wy-content-pdf .pdfViewer .dummyPage{position:relative;width:0;height:var(--viewer-container-height)}.wy-content-pdf .pdfViewer.noUserSelect{-webkit-user-select:none;user-select:none}.wy-content-pdf .pdfViewer.removePageBorders .page{margin:0 auto 10px;border:none}.wy-content-pdf .pdfViewer.singlePageView{display:inline-block}.wy-content-pdf .pdfViewer.singlePageView .page{margin:0;border:none}.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped),.wy-content-pdf .spread{margin-inline:3.5px;text-align:center}.wy-content-pdf .pdfViewer.scrollHorizontal,.wy-content-pdf .spread{white-space:nowrap}.wy-content-pdf .pdfViewer.removePageBorders,.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) .spread{margin-inline:0}.wy-content-pdf .spread :is(.page,.dummyPage),.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) :is(.page,.spread){display:inline-block;vertical-align:middle}.wy-content-pdf .spread .page,.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) .page{margin-inline:var(--spreadHorizontalWrapped-margin-LR)}.wy-content-pdf .pdfViewer.removePageBorders .spread .page,.wy-content-pdf .pdfViewer.removePageBorders:is(.scrollHorizontal,.scrollWrapped) .page{margin-inline:5px}.wy-content-pdf .pdfViewer .page.loadingIcon:after{position:absolute;top:0;left:0;content:\"\";width:100%;height:100%;display:none;transition-property:display;transition-delay:var(--loading-icon-delay);z-index:5;contain:strict}.wy-content-pdf .pdfViewer .page.loading:after{display:block}.wy-content-pdf .pdfViewer .page:not(.loading):after{transition-property:none;display:none}.wy-content-pdf .pdfPresentationMode .pdfViewer{padding-bottom:0}.wy-content-pdf .pdfPresentationMode .spread{margin:0}.wy-content-pdf .pdfPresentationMode .pdfViewer .page{margin:0 auto;border:2px solid transparent}.wy-content-pdf .pdfViewer .page{box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));background-color:var(--wy-white, var(--wy-white, #ffffff))}.wy-content-pdf .pdfViewer .page.loadingIcon:after{background:url(\"data:image/svg+xml,%3Csvg viewBox='0 0 24 24' width='24' height='24' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cstyle type='text/css'%3Eg%7Banimation:rotate 2s linear infinite;transform-origin:center center%7Dcircle%7Bstroke-dasharray:1,100;stroke-dashoffset:0;animation:dash 1.5s ease-in-out infinite,color 6s ease-in-out infinite%7D@keyframes rotate%7B100%25%7Btransform:rotate(360deg)%7D%7D@keyframes dash%7B0%25%7Bstroke-dasharray:1,100;stroke-dashoffset:0%7D50%25%7Bstroke-dasharray:44.5,100;stroke-dashoffset:-17.5px%7D100%25%7Bstroke-dasharray:44.5,100;stroke-dashoffset:-62px%7D%7D@keyframes color%7B0%25,100%25%7Bstroke:%23216eb4%7D40%25%7Bstroke:%2328b7cf%7D66%25%7Bstroke:%23216eb4%7D80%25,90%25%7Bstroke:%2328b7cf%7D%7D%3C/style%3E%3Cg%3E%3Ccircle fill='none' cx='12' cy='12' r='11' stroke-linecap='butt' stroke-width='2' /%3E%3C/g%3E%3C/svg%3E\") center no-repeat}.wy-pdf-page-number{width:calc(3 * var(--wy-size, 1rem))}.wy-pdf-zoom-level{width:calc(5 * var(--wy-size, 1rem))}.wy-content-text{word-break:break-word;white-space:pre-wrap}[part~=wy-reaction]{font-size:calc(1.125 * var(--wy-size, 1rem))}[part~=wy-reactions]{display:inline-flex;align-items:center;column-gap:calc(.25 * var(--wy-size, 1rem))}[part~=wy-reactions] :first-child:not(:only-child){margin-left:calc(.25 * var(--wy-size, 1rem))}[part~=wy-reactions] :last-child:not(:only-child){margin-right:calc(.25 * var(--wy-size, 1rem))}[part~=wy-reaction-count]{margin:0 calc(.25 * var(--wy-size, 1rem)) 0;line-height:1;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-reaction-menu]{width:max-content;position:absolute;z-index:1000;border:none;--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;margin:0;text-align:left;background-clip:padding-box;box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));overflow:hidden;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));font-size:calc(1.25 * var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))))}[part~=wy-reaction-picker]{display:flex;flex-direction:row;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-reactions-line]{display:flex;align-items:center;padding-left:calc(.1875 * var(--wy-size, 1rem));padding-right:calc(.1875 * var(--wy-size, 1rem));gap:calc(.1875 * var(--wy-size, 1rem));justify-content:end}[part~=wy-reactions-line-reverse]{flex-direction:row-reverse;justify-content:start}[part~=wy-reactions-line-bottom]{position:absolute;bottom:calc(-1 * var(--wy-size, 1rem));right:calc(.25 * var(--wy-size, 1rem));z-index:1}[part~=wy-reactions-line-below]{position:relative;height:0;min-height:0;max-height:0;margin:calc(var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) - var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(-1 * var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))) calc(-1 * var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));padding-left:calc(.125 * var(--wy-size, 1rem));padding-right:calc(.125 * var(--wy-size, 1rem));gap:calc(.125 * var(--wy-size, 1rem));flex:1 0 auto;justify-content:flex-end}.wy-sheet{--wy-scrollbar-adjust-top: 0;--wy-scrollbar-adjust-bottom: 0;--wy-component-background-color: var(--wy-surface-3, var(--wy-surface-3-light, #e3e7ee));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);position:fixed;z-index:1055;display:flex;flex-direction:column;overflow:hidden;bottom:calc(.5 * var(--wy-size, 1rem));left:calc(.5 * var(--wy-size, 1rem));right:calc(.5 * var(--wy-size, 1rem));max-height:max(50vh,50%);min-height:calc(3 * var(--wy-size, 1rem));margin:calc(.5 * var(--wy-size, 1rem)) auto;max-width:calc(32 * var(--wy-size, 1rem));transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12))}.wy-sheet>.wy-appbars,.wy-sheet>.wy-appbar{border-top-left-radius:inherit;border-top-right-radius:inherit}.wy-sheet-body{overflow:hidden;padding:calc(.5 * var(--wy-size, 1rem));position:relative;min-height:calc(3 * var(--wy-size, 1rem))}.wy-sheet-body.wy-scroll-y{overflow-y:auto}.wy-sheet-no-padding{padding:0}.wy-sheet:not(.wy-show){opacity:0;transform:translateY(calc(32 * var(--wy-size, 1rem)))}.wy-sheet.wy-show{opacity:1;transform:none;transition:transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));pointer-events:auto}@starting-style{.wy-sheet.wy-show{opacity:0;transform:translateY(calc(32 * var(--wy-size, 1rem)))}}.wy-toasts{background:none;border:none;padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin:0;width:100%;height:100%;display:flex;flex-direction:column;flex-wrap:wrap;align-content:flex-end;align-items:flex-end;justify-content:flex-end;pointer-events:none}.wy-toasts[popover]{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1070}.wy-toasts>::slotted(*){pointer-events:auto}.wy-toast{--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background:var(--wy-component-background-color);color:var(--wy-component-color);gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));margin-top:0;margin-bottom:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));display:flex;cursor:pointer;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));padding:0;-webkit-user-select:none;user-select:none;box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));position:relative;overflow:hidden;min-height:calc(4.5 * var(--wy-size, 1rem));max-width:calc(32 * var(--wy-size, 1rem))}.wy-toast.wy-fade{transition-property:opacity,min-height,padding-top,padding-bottom,margin-top,margin-bottom,height;transition-duration:var(--wy-transition-duration, .2s);transition-timing-function:var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))}.wy-toast.wy-fade:not(.wy-show){opacity:0;min-height:0;height:0;padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;pointer-events:none}.wy-toast-action{position:sticky;top:calc(4.5 * var(--wy-size, 1rem));bottom:calc(4.5 * var(--wy-size, 1rem));z-index:990;background-color:var(--wy-primary, var(--wy-primary-40, #006399));color:var(--wy-on-primary, var(--wy-white, #ffffff));padding:calc(.5 * var(--wy-size, 1rem)) calc(1 * var(--wy-size, 1rem));margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:calc(.5 * var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));width:max-content;min-height:0;max-width:calc(100% - 3 * var(--wy-size, 1rem));height:auto;align-self:center;text-align:center;box-shadow:none}.wy-toast-primary{background:var(--wy-on-primary-container, var(--wy-primary-10, #001d32));color:var(--wy-primary-container, var(--wy-primary-90, #cde5ff))}.wy-placeholder{cursor:wait;color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));background:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));opacity:.5;animation:wy-placeholder-glow 2s ease-in-out infinite}@keyframes wy-placeholder-glow{50%{opacity:.2}}.wy-meeting .wy-item-title{font-weight:700}.wy-meeting .wy-item-text{font-size:var(--wy-font-size, var(--wy-size, 1em))}.wy-meeting.wy-disabled .wy-item-title{font-weight:400}.wy-dragging:after{content:attr(data-drag-title);background-color:#ffffff80;display:flex;justify-content:center;align-items:center;border:calc(.125 * var(--wy-size, 1rem)) dashed var(--wy-primary, var(--wy-primary-40, #006399));font-weight:var(--wy-font-weight-bold, bolder);z-index:10000;position:absolute;top:0;left:0;bottom:0;right:0}.wy-message-editor-top{background-color:var(--wy-component-background-color);color:var(--wy-component-color)}@supports (position: sticky){.wy-message-editor-top{position:sticky;top:0;z-index:1020}}.wy-message-editor-bottom{background-color:var(--wy-component-background-color);color:var(--wy-component-color)}@supports (position: sticky){.wy-message-editor-bottom{position:sticky;bottom:0;z-index:1020}}.wy-message-form .wy-spinner{display:none}.wy-message-form.wy-uploading .wy-spinner{display:block}.wy-message-form.wy-uploading [data-icon=plus]{display:none}.wy-message-form .wy-picker-list:not(:empty){border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-message-editor-inputs{display:flex;flex-direction:row;align-items:flex-end;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em)) * 1.5 * var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * 2 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) * 2);gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-message-editor-buttons{flex:1 0 auto}.wy-message-editor-text{flex:1 1 100%;display:flex;flex-direction:column}.wy-message-editor-mention,.wy-message-editor-link{background:#00f;color:#fff}.wy-message-editor .cm-editor,.wy-message-editor-grow:after,.wy-message-editor-grow>textarea,.wy-message-editor-textfield{flex:1 1 100%;max-height:11.25em;background-color:var(--wy-background, var(--wy-neutral-99, #fcfcff));color:var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));border-radius:var(--wy-input-filled-border-radius, var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem)))));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid var(--wy-background, var(--wy-neutral-99, #fcfcff))}.wy-message-editor .cm-editor:focus,.wy-message-editor-grow:focus:after,.wy-message-editor-grow>textarea:focus,.wy-message-editor-textfield:focus{border-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-message-editor .cm-editor .cm-content,.wy-message-editor-textcontent{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)), inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em)) * 1.5 * var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * 2 - var(--wy-input-border-width, var(--wy-border, 1px)));line-height:calc(1.5 * var(--wy-size, 1rem))}.wy-message-editor-grow{display:grid}.wy-message-editor-grow:after,.wy-message-editor-grow>textarea{grid-area:1/1/2/2}.wy-message-editor-grow:after{content:attr(data-replicated-value) \" \";white-space:pre-wrap;visibility:hidden}.wy-message-editor-grow>textarea{resize:none;overflow:hidden}.wy-editor .cm-scroller{font-family:unset;line-height:1.5}.wy-editor .cm-widgetBuffer{vertical-align:unset}.wy-editor .cm-placeholder{pointer-events:none;color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e))}.wy-editor .cm-content{caret-color:var(--wy-on-background, var(--wy-neutral-10, #1a1c1e))}.wy-editor .cm-content .wy-link{text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-40, #006399))}.wy-editor .cm-editor{box-sizing:border-box;flex-direction:column;position:relative!important;display:flex!important}.wy-editor .cm-editor.cm-focused{--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));color:var(--wy-component-color);border-color:var(--wy-primary, var(--wy-primary-40, #006399));outline:0}.wy-editor .cm-editor .cm-scroller{overflow:auto}.wy-editor .cm-editor .cm-line{display:block;padding:0px var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) 0px var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-editor .cm-tooltip.cm-tooltip-autocomplete>ul{font-family:unset;max-height:calc(15 * var(--wy-size, 1rem))}.wy-editor .cm-tooltip.cm-tooltip-autocomplete>ul>li{padding:0}.wy-editor .cm-tooltip{border:none;background-clip:padding-box;background-color:var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));color:var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));overflow:hidden;z-index:1000}.wy-editor .cm-tooltip-autocomplete ul li[aria-selected]{background:var(--wy-primary-container, var(--wy-primary-90, #cde5ff));color:unset}.wy-editor .cm-tooltip-autocomplete .cm-completionLabel{display:none}.wy-editor .cm-tooltip-autocomplete .wy-item-hover:hover,.wy-editor .cm-tooltip-autocomplete .wy-item-hover:focus{background:var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb))}.wy-message-editor .cm-editor.cm-focused{border-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-message-editor .wy-is-invalid+[data-editor-target] .cm-editor,.wy-message-editor .wy-is-invalid .cm-editor{border-color:var(--wy-error, var(--wy-error-40, #ba1824))!important}.wy-chat-conversation{overflow-anchor:none;display:flex;flex-direction:column;flex:1 0 min-content;height:100%;width:100%;min-height:0;min-width:0}.wy-truncated-text-and-icon{display:flex;align-items:center;gap:.25rem}.wy-truncated-text-and-icon>:first-child{line-height:var(--wy-line-height, 1.5);flex:0 1 auto;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.wy-truncated-text-and-icon>:last-child:not(:first-child){flex:0 0 auto;white-space:nowrap}[part~=wy-filename]{font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);display:flex;flex-direction:column;justify-content:center}[part~=wy-filename] .wy-truncated-text-and-icon{justify-content:space-between}.wy-files{position:relative;display:flex;flex-direction:column;flex:1;min-height:0;container-type:inline-size}@supports (position: sticky){wy-files-appbar{position:sticky;top:0;z-index:1020}}.wy-table-files thead{text-align:left;display:none}@container (inline-size >= 576px){.wy-table-files thead{display:table-header-group}}.wy-table-files tr[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}.wy-table-files tr>:nth-child(2){width:100%}.wy-table-files tr>:nth-child(2) td{padding:0 var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}.wy-table-files tr>:nth-child(4){width:calc(7 * var(--wy-size, 1rem));display:none}@container (inline-size >= 768px){.wy-table-files tr>:nth-child(4){display:table-cell}}.wy-table-files tr>:nth-child(4){overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-table-files tr>:nth-child(5){width:calc(7.5 * var(--wy-size, 1rem));text-align:right;display:none}@container (inline-size >= 768px){.wy-table-files tr>:nth-child(5){display:table-cell}}.wy-table-files tr>:nth-child(5){overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-table-files tr>:nth-child(6){width:calc(7 * var(--wy-size, 1rem));text-align:right;display:none}@container (inline-size >= 576px){.wy-table-files tr>:nth-child(6){display:table-cell}}.wy-table-files tr>:nth-child(6){overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-sidebar{--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background:var(--wy-component-background-color);color:var(--wy-component-color);min-width:0;min-height:0;flex-grow:0;flex-shrink:0;flex-basis:calc(18 * var(--wy-size, 1rem));z-index:10;display:flex;flex-direction:column;transition:flex-basis var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));position:relative;order:9999}.wy-sidebar>*{transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) - var(--wy-transition-duration-fast, .1s));min-width:calc(18 * var(--wy-size, 1rem))}.wy-sidebar[hidden]{display:flex!important;flex-basis:0}.wy-sidebar[hidden]>*{transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));opacity:0}@media (min-width: 768px){.wy-sidebar>*{min-width:calc(18 * var(--wy-size, 1rem))}.wy-sidebar .wy-sidebar-handle{display:none}}@media (max-width: 767.98px){.wy-sidebar{transition:flex-basis var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),margin-top var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));border-top-left-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-top-right-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));flex-basis:50vh}.wy-sidebar:not([hidden]){margin-top:calc(-1 * var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}.wy-sidebar:not([hidden]).wy-maximized{flex-basis:calc(100% - var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem))))) * .5);margin-top:calc(-50% + var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem))))) * 2.5 - var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}.wy-sidebar:not([hidden]).wy-maximized~* .wy-nav-prev,.wy-sidebar:not([hidden]).wy-maximized~* .wy-nav-next{display:none}.wy-sidebar>*{min-height:var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem)))))}}.wy-sidebar-handle{width:calc(4 * var(--wy-size, 1rem));background-clip:content-box;background-color:var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));height:calc(1 * var(--wy-size, 1rem));border:calc(.375 * var(--wy-size, 1rem)) solid transparent;position:absolute;top:0;z-index:2;left:50%;margin-left:calc(-2 * var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));cursor:pointer}.wy-table{table-layout:fixed;width:100%;vertical-align:top;border-collapse:collapse}.wy-table th,.wy-table td{background-color:var(--wy-component-background-color);padding:var(--wy-table-cell-padding-y, var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));box-shadow:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) 0 -1px 0 0 inset;line-height:1;vertical-align:middle;height:calc(2.5 * var(--wy-size, 1rem))}.wy-table th:first-child,.wy-table td:first-child{padding-left:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}.wy-table th:last-child,.wy-table td:last-child{padding-right:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}.wy-table>tbody{vertical-align:inherit}.wy-table>thead{vertical-align:bottom}.wy-table .wy-table-cell-icon{vertical-align:middle;text-align:center;padding:calc(var(--wy-table-cell-padding-y, var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .5) var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));width:calc(calc(2.5 * var(--wy-size, 1rem)) + var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))) * 2);font-size:var(--wy-font-size, var(--wy-size, 1em));font-weight:var(--wy-font-weight, unset);text-transform:none;letter-spacing:normal}.wy-table .wy-table-cell-text{width:100%}.wy-table .wy-table-cell-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-table-hover>tbody>tr:hover>*{--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));color:var(--wy-component-color);cursor:pointer}.wy-table-row-trashed th,.wy-table-row-trashed td{text-decoration:line-through}.wy-table-row-trashed th:not(:last-child)>*,.wy-table-row-trashed td:not(:last-child)>*{opacity:var(--wy-opacity-disabled, 38%)}.wy-table-row-trashed th>a,.wy-table-row-trashed td>a{color:var(--wy-component-color)}.wy-table-row-trashed:hover th,.wy-table-row-trashed:hover td{opacity:1}.wy-table-no-result{text-align:center;padding:calc(1 * var(--wy-size, 1rem))}.wy-table-sort-link{display:inline-flex;align-items:center;color:var(--wy-link, var(--wy-primary-40, #006399));cursor:pointer}.wy-posts{display:flex;flex-direction:column;gap:calc(1 * var(--wy-size, 1rem))}.wy-post{--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;position:relative;--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-component-border-radius)}.wy-post[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}.wy-post .wy-image-grid{border-radius:0}.wy-post wy-comment-list{border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-post-body{display:flex;flex-direction:column;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-post-body:empty{display:none}.wy-post-footer{display:flex;align-items:center;justify-content:space-between;padding:0 calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) * .75) calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) * .75)}.wy-post-footer .wy-meta{margin-right:calc(.5 * var(--wy-size, 1rem))}.wy-post-comments:not(:empty){padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}.wy-post-dragging:after{content:attr(data-drag-title,\"Drop files here to upload.\");background-color:#ffffff80;display:flex;justify-content:center;align-items:center;border:calc(.125 * var(--wy-size, 1rem)) dashed var(--wy-primary, var(--wy-primary-40, #006399));font-weight:var(--wy-font-weight-bold, bolder);z-index:10000;position:absolute;top:0;left:0;bottom:0;right:0}.wy-poll{flex:1 1 100%;min-width:0;display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-poll-form{background:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-poll-form:empty{display:none}.wy-poll-option{overflow:hidden;position:relative;background-color:var(--wy-background, var(--wy-neutral-99, #fcfcff));border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));min-height:calc(2.5 * var(--wy-size, 1rem));cursor:pointer}.wy-poll-option .wy-progress{position:absolute;top:0;left:0;bottom:0;background-color:var(--wy-surface-5, var(--wy-surface-5-light, #dce2ea))}.wy-poll-option>:not(.wy-progress){z-index:1}.wy-embed{display:flex;flex-direction:column;word-wrap:break-word;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));clip-path:border-box;overflow:hidden}.wy-embed-photo a{display:flex}.wy-embed-photo img{width:100%;height:auto}.wy-embed-photo-sm a{padding:0 calc(1 * var(--wy-size, 1rem))}.wy-embed-photo-sm img{display:block;margin:0 auto;width:auto;max-width:100%;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-embed-video{position:relative;display:block;width:100%;padding:0;overflow:hidden}.wy-embed-video:before{display:block;content:\"\";padding-top:56.25%}.wy-embed-video iframe,.wy-embed-video embed,.wy-embed-video object,.wy-embed-video video{position:absolute;top:0;bottom:0;left:0;width:100%;height:100%;border:0}.wy-embed-caption{--wy-component-background-color: var(--wy-surface-3, var(--wy-surface-3-light, #e3e7ee));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);padding:calc(.5 * var(--wy-size, 1rem)) calc(1 * var(--wy-size, 1rem)) calc(1 * var(--wy-size, 1rem));position:relative}.wy-embed-link{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));text-transform:uppercase;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}.wy-embed-link:after{position:absolute;top:0;right:0;bottom:0;left:0;z-index:1;content:\"\"}.wy-embed-title{font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, bolder));margin-bottom:calc(.5 * var(--wy-size, 1rem))}.wy-embed-description{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e))}.wy-embed-preview a[target=_blank]{pointer-events:none}.wy-embed-preview .wy-embed{border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));display:none}.wy-embed-preview .wy-embed:first-child{display:block}.wy-embed-preview .wy-embed-caption{border-bottom-left-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-bottom-right-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)))}.wy-embed-preview .wy-embed-actions{display:flex}.wy-embed-actions{display:none;justify-content:space-between;padding:calc(.5 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem))}.wy-embed-cycle{visibility:hidden}.wy-embed-show-cycle .wy-embed-cycle{visibility:visible}.wy-post-editor{padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-post-editor.wy-uploading .wy-icon-active-stack>:first-child{opacity:0}.wy-post-editor.wy-uploading .wy-icon-active-stack>:last-child{opacity:1}.wy-post-editor .wy-picker-list:not(:empty){margin-top:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-post-editor-inputs{display:flex;flex-direction:row;align-items:flex-end;justify-content:space-between;flex-wrap:wrap;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-post-editor-buttons{display:flex;flex-direction:row;align-items:flex-end;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));flex:1 0 auto}.wy-post-editor-text{flex:1 1 100%;display:flex;flex-direction:column}.wy-post-editor-mention,.wy-post-editor-link{background:#00f;color:#fff}.wy-post-editor .cm-editor,.wy-post-editor-grow:after,.wy-post-editor-grow>textarea,.wy-post-editor-textfield{flex:1 1 100%;max-height:11.25em;min-height:4em;background-color:var(--wy-background, var(--wy-neutral-99, #fcfcff));color:var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));caret-color:var(--wy-primary, var(--wy-primary-40, #006399))}.wy-post-editor .cm-editor:focus,.wy-post-editor-grow:focus:after,.wy-post-editor-grow>textarea:focus,.wy-post-editor-textfield:focus{border-color:var(--wy-primary, var(--wy-primary-40, #006399))}.wy-post-editor .cm-editor .cm-content,.wy-post-editor-textcontent{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}.wy-post-editor-grow{display:grid}.wy-post-editor-grow:after,.wy-post-editor-grow>textarea{grid-area:1/1/2/2}.wy-post-editor-grow:after{content:attr(data-replicated-value) \" \";white-space:pre-wrap;visibility:hidden}.wy-post-editor-grow>textarea{resize:none;overflow:hidden}.wy-post-editor .cm-editor .cm-line{padding:0}.wy-post-editor .wy-is-invalid+[data-editor-target] .cm-editor,.wy-post-editor .wy-is-invalid .cm-editor{border-color:var(--wy-error, var(--wy-error-40, #ba1824))!important}.wy-comments{display:flex;flex-direction:column;gap:var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-comment{--wy-component-background-color: var(--wy-surface-3, var(--wy-surface-3-light, #e3e7ee));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-component-border-radius);background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));position:relative}.wy-comment[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}.wy-comment-body{flex:1 0 auto;z-index:1}.wy-comment-content{padding:0 var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));display:flex;flex-direction:column;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}.wy-comment-editor .wy-spinner{display:none}.wy-comment-editor.wy-uploading .wy-spinner{display:block}.wy-comment-editor.wy-uploading [data-icon=plus]{display:none}.wy-comment-editor .wy-picker-list:not(:empty){border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-comment-editor.wy-comment-editor-bottom{position:sticky;bottom:0;z-index:999;background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-comment-editor-inputs{display:flex;flex-direction:row;align-items:flex-end;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));min-height:calc(3.5 * var(--wy-size, 1rem));gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-comment-editor-buttons{flex:1 0 auto}.wy-comment-editor-text{flex:1 1 100%;display:flex;flex-direction:column}.wy-comment-editor-mention,.wy-comment-editor-link{background:#00f;color:#fff}.wy-comment-editor .cm-editor,.wy-comment-editor-grow:after,.wy-comment-editor-grow>textarea,.wy-comment-editor-textfield{flex:1 1 100%;max-height:calc(11.25 * var(--wy-size, 1rem));background-color:var(--wy-background, var(--wy-neutral-99, #fcfcff));color:var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));border-radius:calc(1.25 * var(--wy-size, 1rem));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-comment-editor .cm-editor:focus,.wy-comment-editor-grow:focus:after,.wy-comment-editor-grow>textarea:focus,.wy-comment-editor-textfield:focus{border-color:var(--wy-primary, var(--wy-primary-40, #006399))}.wy-comment-editor .cm-editor .cm-content,.wy-comment-editor-textcontent{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}.wy-comment-editor-grow{display:grid}.wy-comment-editor-grow:after,.wy-comment-editor-grow>textarea{grid-area:1/1/2/2}.wy-comment-editor-grow:after{content:attr(data-replicated-value) \" \";white-space:pre-wrap;visibility:hidden}.wy-comment-editor-grow>textarea{resize:none;overflow:hidden}.wy-comment-editor{position:relative}.wy-comment-editor .wy-is-invalid+.cm-editor,.wy-comment-editor .wy-is-invalid .cm-editor{border-color:var(--wy-error, var(--wy-error-40, #ba1824))!important}.wy-badge{display:inline-block;padding:.35em .65em;font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));font-weight:var(--wy-font-weight-bold, bolder);line-height:1;color:var(--wy-on-primary, var(--wy-white, #ffffff));text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));background-color:var(--wy-primary, var(--wy-primary-40, #006399))}.wy-badge:empty{display:none}.wy-badge-reveal{opacity:1;transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{.wy-badge-reveal{opacity:0}}.wy-button-badge{position:absolute;right:0;top:0;margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .5);padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));min-width:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));max-width:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) * 3 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) * 2);height:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));line-height:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) - var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));display:block;text-align:center}.wy-button-badge{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-button-badge:empty{display:none}.wy-button-dot{position:absolute;right:0;top:0;content-visibility:hidden;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));line-height:0;min-width:0;height:0}.wy-button-dot:empty{display:none}[part~=wy-tabs]{display:flex;overflow-y:hidden;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));flex:1 1 auto}[part~=wy-tabs]{overflow-x:auto;max-width:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-tabs]{scrollbar-width:thin;scrollbar-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) transparent}[part~=wy-tabs]::-webkit-scrollbar{height:.375rem;width:.375rem;background:transparent;z-index:999}[part~=wy-tabs]::-webkit-scrollbar-track{background:transparent}[part~=wy-tabs]::-webkit-scrollbar-thumb{background-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));opacity:75%;border:0 solid transparent;border-radius:0;background-clip:padding-box}[part~=wy-tabs]::-webkit-scrollbar-thumb:hover{background-color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));opacity:75%}[part~=wy-tabs]::-webkit-scrollbar-thumb:window-inactive{background-color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));opacity:50%}[part~=wy-tab]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399));--wy-component-background-color: transparent;color:var(--wy-component-color);background:var(--wy-component-background-color);border:none;border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));display:inline-flex;flex-direction:column;align-items:center;justify-content:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));position:relative;text-align:center;text-decoration:none;cursor:pointer;-webkit-user-select:none;user-select:none}[part~=wy-tab] .wy-tab-icon{position:relative;padding:calc(.25 * var(--wy-size, 1rem)) calc(1 * var(--wy-size, 1rem));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));display:inline-flex}[part~=wy-tab] .wy-tab-icon:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-tab]:hover .wy-tab-icon:before{opacity:8%}[part~=wy-tab]:focus .wy-tab-icon:before,[part~=wy-tab]:active .wy-tab-icon:before,[part~=wy-tab].wy-active .wy-tab-icon:before{opacity:12%}[part~=wy-tab] .wy-tab-label{font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));font-weight:var(--wy-font-weight, unset)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]{padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .5);margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) auto;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]:before{margin:calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * -.25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * 0)}.wy-conversations{position:relative}.wy-conversation{display:flex;position:relative}.wy-conversation .wy-item-title{font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset));font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em))}.wy-conversation.wy-unread .wy-item-title{font-weight:var(--wy-font-weight-bold, bolder)}.wy-conversation.wy-unread .wy-item-text,.wy-conversation.wy-unread .wy-meta{color:var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));font-weight:var(--wy-font-weight-bold, bolder)}.wy-conversation .wy-item-text .wy-typing-show{font-weight:var(--wy-font-weight, unset)}.wy-conversation .wy-item-text .wy-typing-show{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}`;
var gm = Object.defineProperty, bm = Object.getOwnPropertyDescriptor, Jt = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? bm(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && gm(t, i, n), n;
}, "__decorateClass$16");
function au(r) {
  return r != null && r !== !1;
}
c(au, "acceptedValue");
const xm = "wy-context";
var yn;
let Ut = (yn = class extends j {
  constructor() {
    super(), this.provider = !1, this.childElementCount && (this.provider = !0), this.weavy ?? (this.weavy = new _o({ host: this.provider ? this : void 0 }));
  }
  /**
   * The semver version of the package.
   */
  get version() {
    return _o.version;
  }
  /**
   * The Weavy source name; package name.
   */
  get sourceName() {
    return _o.sourceName;
  }
  willUpdate(t) {
    if (super.willUpdate(t), this.weavy) {
      const i = {};
      Array.from(t.keys()).forEach((s) => {
        s !== "weavy" && (au(this[s]) || au(t.get(s))) && Object.assign(i, { [s]: this[s] });
      }), Object.assign(this.weavy, i);
    }
  }
  render() {
    return p` <slot></slot> `;
  }
}, c(yn, "WyContext"), yn);
Ut.styles = [
  J,
  We,
  Z`
      :host {
        display: contents;
      }
    `
];
Jt([
  w({ attribute: !0, type: Boolean })
], Ut.prototype, "provider", 2);
Jt([
  w({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ c((r) => fl(r), "fromAttribute")
    }
  })
], Ut.prototype, "cloudFilePickerUrl", 2);
Jt([
  w({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ c((r) => fl(r), "fromAttribute")
    }
  }),
  w({ type: Boolean })
], Ut.prototype, "disableEnvironmentImports", 2);
Jt([
  w({ attribute: !0 })
], Ut.prototype, "locale", 2);
Jt([
  w({ attribute: !0, type: Array })
], Ut.prototype, "locales", 2);
Jt([
  w({ attribute: !0, type: Number })
], Ut.prototype, "gcTime", 2);
Jt([
  w({ attribute: !0, type: Array })
], Ut.prototype, "reactions", 2);
Jt([
  w({ type: Boolean })
], Ut.prototype, "notificationEvents", 2);
Jt([
  w({ type: Boolean })
], Ut.prototype, "notificationToasts", 2);
Jt([
  w({ attribute: !0 })
], Ut.prototype, "scrollBehavior", 2);
Jt([
  w({ attribute: !0, type: Number })
], Ut.prototype, "staleTime", 2);
Jt([
  w({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ c((r) => vm(r), "fromAttribute")
    }
  })
], Ut.prototype, "tokenFactory", 2);
Jt([
  w({ attribute: !0, type: Number })
], Ut.prototype, "tokenFactoryRetryDelay", 2);
Jt([
  w({ attribute: !0, type: Number })
], Ut.prototype, "tokenFactoryTimeout", 2);
Jt([
  w({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ c((r) => fl(r), "fromAttribute")
    }
  })
], Ut.prototype, "tokenUrl", 2);
Jt([
  w({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ c((r) => fl(r), "fromAttribute")
    }
  })
], Ut.prototype, "url", 2);
Jt([
  D()
], Ut.prototype, "weavy", 2);
Ut = Jt([
  B(xm)
], Ut);
const Cp = class Cp {
  constructor(t, i) {
    this.firstUpdate = !0, this.styles = [], t.addController(this), this.host = t, i && (this.styles = i);
  }
  checkThemeUpdate() {
    const t = this.themeColor || Zd(this.host) || Xd();
    if (t && t !== this._resolvedThemeColor) {
      this._resolvedThemeColor = t, console.info("Configuring theme", this._resolvedThemeColor);
      const i = tm(this._resolvedThemeColor).join(""), s = Z`
        :host {
          ${Rf(i)};
        }
      `, n = this.host.renderRoot;
      If(n, [...this.styles, s]);
    }
  }
  hostUpdate() {
    this.firstUpdate && (this.checkThemeUpdate(), this.firstUpdate = !1);
  }
  hostConnected() {
    this.cssObserverDisconnect = Z1(this.host, () => this.checkThemeUpdate()), this.metaObserverDisconnect = X1(() => this.checkThemeUpdate());
  }
  hostDisconnected() {
    var t, i;
    (t = this.cssObserverDisconnect) == null || t.call(this), (i = this.metaObserverDisconnect) == null || i.call(this);
  }
};
c(Cp, "ThemeController");
let fi = Cp;
const Fh = Z`:host{display:contents}`, fs = Z`:host{font-family:var(--wy-font-family, unset)}`;
var $m = Object.defineProperty, km = Object.getOwnPropertyDescriptor, Dh = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? km(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && $m(t, i, n), n;
}, "__decorateClass$15");
const Cm = "wy-component";
var wn;
let Na = (wn = class extends at {
  constructor() {
    super(), this.componentType = qe.Unknown, new fi(this, Na.styles);
  }
  render() {
    return p`<slot></slot>`;
  }
}, c(wn, "WyComponent"), wn);
Na.styles = [We, Fh, fs];
Dh([
  w()
], Na.prototype, "componentType", 2);
Dh([
  w()
], Na.prototype, "productType", 2);
Na = Dh([
  B(Cm)
], Na);
const po = Z`:host{position:relative;display:flex;flex-direction:column;flex:1;min-height:3rem;min-width:16rem;isolation:isolate}`, pc = Z`.wy-scroll-y{scroll-padding-top:var(--wy-scrollbar-adjust-top, 0);scroll-padding-bottom:var(--wy-scrollbar-adjust-bottom, 0)}.wy-scroll-y{overflow-y:auto;max-height:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-scroll-y:not(body){-webkit-overflow-scrolling:touch}.wy-scroll-y:not(.wy-scroll-x){overflow-x:hidden;touch-action:pan-y}.wy-scroll-x{overflow-x:auto;max-width:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-scroll-x:not(.wy-scroll-y){overflow-y:hidden;touch-action:pan-x}:host{overflow-y:auto;max-height:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}:host:not(body){-webkit-overflow-scrolling:touch}`;
function _m(r, t, i = {}, s) {
  var n, a;
  if (r) {
    if (r = JSON.parse(JSON.stringify(r)), r != null && r.pages) {
      let o = -1;
      return {
        pages: [...r.pages.map((d, u) => {
          if (o >= 0)
            return d;
          const y = d.data || [], m = y.filter(
            (f) => f.id !== t.id && !s
          );
          return i && i.by ? (o = m.findIndex((f) => {
            let g = i.by && f[i.by], x = i.by && t[i.by];
            if (i.by === "updated_at" && (g ?? (g = f.created_at), x ?? (x = t.created_at)), typeof g == "string" && typeof x == "string") {
              const k = g.localeCompare(x, void 0, {
                sensitivity: "base",
                numeric: !0
              });
              return i.descending ? k < 0 : k > 0;
            }
            return g && x && (i.descending ? g < x : g > x);
          }), o >= 0 ? (m.splice(o, 0, t), d.data = [...m], d.end && (d.end += 1 + m.length - y.length)) : r && u == r.pages.length - 1 && d.end === d.count ? (d.data = [...m, t], d.end && (d.end += 1 + m.length - y.length)) : d.data = [...m]) : u === 0 && (i.descending ? d.data = [t, ...m] : d.data = [...m, t], d.end && (d.end += 1 + m.length - y.length)), d;
        }) ?? []],
        pageParams: [...r.pageParams]
      };
    } else if ((n = r == null ? void 0 : r.data) != null && n.length) {
      let o = -1;
      const l = [
        ...((a = r.data) == null ? void 0 : a.filter(
          (u) => u.id !== t.id && !s
        )) || []
      ];
      let d = r.count;
      return i && i.by ? (o = l.findIndex((u) => {
        let y = u[i.by], m = t[i.by];
        if (i.by === "updated_at" && (y ?? (y = u.created_at), m ?? (m = t.created_at)), typeof y == "string" && typeof m == "string") {
          const f = y.localeCompare(m, void 0, {
            sensitivity: "base",
            numeric: !0
          });
          return i.descending ? f < 0 : f > 0;
        }
        return y && m && (i.descending ? y < m : y > m);
      }), o >= 0 ? l.splice(o, 0, t) : (l.push(t), d++)) : (i.descending ? l.unshift(t) : l.push(t), d++), {
        data: l,
        count: d
      };
    }
  }
  return r;
}
c(_m, "addToQueryData");
function Vy(r, t, i) {
  var n, a;
  const s = t === void 0 ? () => !0 : t instanceof Function ? t : (o) => o.id === t;
  return r && (r = JSON.parse(JSON.stringify(r)), r.pages ? {
    pages: r.pages.map((l) => (l.data && (l.data = [
      ...l.data.map((d) => (s(d) && (d = { ...d }, i(d)), d))
    ]), l)) ?? [],
    pageParams: r.pageParams
  } : (n = r.data) != null && n.length ? {
    ...r,
    data: [
      ...((a = r.data) == null ? void 0 : a.map((o) => (s(o) && (o = { ...o }, i(o)), o))) || []
    ]
  } : r.data ? {
    data: [
      ...r.data.map((l) => (s(l) && (l = { ...l }, i(l)), l))
    ],
    count: r.count
  } : r);
}
c(Vy, "updateQueryData");
function By(r, t) {
  var i, s, n;
  if (t !== void 0) {
    const a = t instanceof Function ? t : (o) => o.id === t;
    if (r) {
      if (r = JSON.parse(JSON.stringify(r)), r.pages)
        return {
          pages: r.pages.map((l) => (l.data && (l.data = [...l.data.filter((d) => !a(d))]), l)) ?? [],
          pageParams: r.pageParams
        };
      if ((i = r.data) != null && i.length) {
        const o = (s = r.data) == null ? void 0 : s.length;
        let l = r.count;
        const d = [...((n = r.data) == null ? void 0 : n.filter((u) => !a(u))) || []];
        return o !== d.length && l--, {
          data: d,
          count: l
        };
      }
    }
  }
  return r;
}
c(By, "removeQueryData");
const os = /* @__PURE__ */ c((r, t, i, s) => r.setQueryData(t, (n) => _m(n, i, s)), "addCacheItem"), _t = /* @__PURE__ */ c((r, t, i, s) => r.setQueryData(t, (n) => Vy(
  n,
  i,
  s
)), "updateCacheItem"), nt = /* @__PURE__ */ c((r, t, i, s) => {
  r.setQueriesData(t, (n) => Vy(
    n,
    i,
    s
  ));
}, "updateCacheItems"), Hh = /* @__PURE__ */ c((r, t, i) => r.setQueryData(t, (s) => By(
  s,
  i
)), "removeCacheItem"), Pm = /* @__PURE__ */ c((r, t, i) => {
  r.setQueriesData(t, (s) => By(s, i));
}, "removeCacheItems"), Uc = /* @__PURE__ */ c((r, t, i) => {
  r.setQueriesData(t, (s) => {
    const { count: n } = s;
    return { count: i(n) };
  });
}, "updateCacheItemsCount");
function ou(r, t, i, s = 1) {
  var a;
  if (!r)
    return;
  const n = r.getQueryData(t);
  (a = n == null ? void 0 : n.pages) != null && a.length && n.pages.length > 1 && r.setQueryData(
    t,
    (o) => ({
      pages: o.pages.slice(0, s),
      pageParams: o.pageParams.slice(0, s)
    }),
    i
  );
}
c(ou, "keepPages");
function Bs(r, t, i) {
  const s = r.getQueryCache().find({ queryKey: t });
  if (s && s.state.data) {
    const n = s.state.data.pages.flatMap((a) => a.data).filter((a) => a && a.id < 0).sort((a, o) => a && o ? a.id - o.id : 0);
    return n.length ? i ? n[n.length - 1] : n[0] : null;
  }
  return null;
}
c(Bs, "getPendingCacheItem");
function ml(r, t, i) {
  const s = r.getQueryCache().find({ queryKey: t });
  return s && s.state.data ? s.state.data.pages.flatMap((n) => n.data).find((n) => (n == null ? void 0 : n.id) === i) : null;
}
c(ml, "getCacheItem");
function ms(r) {
  return ((r == null ? void 0 : r.pages.flatMap((t) => t.data)) || []).filter((t) => t);
}
c(ms, "getFlatInfiniteResultData");
function Mm(r, t, i = {}) {
  return {
    ...i,
    initialPageParam: 0,
    queryKey: ["messages", t],
    queryFn: /* @__PURE__ */ c(async (s) => {
      var d;
      const n = s.pageParam, a = "/api/apps/" + t + "/messages?order_by=id+desc&skip=" + n, l = await (await r.fetch(a)).json();
      return l.data = ((d = l.data) == null ? void 0 : d.reverse()) || [], l;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ c((s) => {
      if (s != null && s.end && (s == null ? void 0 : s.end) < (s == null ? void 0 : s.count))
        return s.end;
    }, "getNextPageParam"),
    select: /* @__PURE__ */ c((s) => ({
      // reverse scroll
      pages: [...s.pages].reverse(),
      pageParams: [...s.pageParams].reverse()
    }), "select")
  };
}
c(Mm, "getMessagesOptions");
function zm(r, t) {
  return {
    mutationFn: /* @__PURE__ */ c(async (s) => (await r.fetch("/api/apps/" + s.app_id + "/messages", {
      method: "POST",
      body: JSON.stringify({
        text: s.text,
        blobs: s.blobs,
        embed_id: s.embed_id || null,
        meeting_id: s.meeting_id,
        options: s.poll_options.filter((a) => a.text.trim() !== "").map((a) => ({ text: a.text }))
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ c(async (s) => {
      const n = ["messages", s.app_id];
      await r.queryClient.cancelQueries({ queryKey: n });
      const a = Bs(r.queryClient, n, !1), o = {
        id: a ? a.id - 1 : -1,
        app: { id: s.app_id },
        text: s.text,
        html: s.text,
        plain: s.text,
        created_by: s.user,
        created_at: (/* @__PURE__ */ new Date()).toUTCString(),
        attachments: { count: 0 },
        reactions: { count: 0 },
        is_starred: !1,
        is_subscribed: !0,
        is_trashed: !1
      };
      os(r.queryClient, n, o);
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((s) => {
      _t(
        r.queryClient,
        ["members", s.app.id],
        s.created_by.id,
        (o) => {
          o.marked_id = s.id, o.marked_at = s.created_at;
        }
      );
      const n = ["messages", s.app.id];
      if (!ml(r.queryClient, n, s.id)) {
        const o = Bs(r.queryClient, n, !0);
        o ? _t(r.queryClient, n, o.id, (l) => {
          l.id = s.id, l.app = s.app, l.text = s.text, l.html = s.html, l.embed = s.embed, l.meeting = s.meeting, l.attachments = s.attachments, l.options = s.options, l.created_at = s.created_at, l.created_by = s.created_by, l.updated_at = s.updated_at, l.updated_by = s.updated_by;
        }) : os(r.queryClient, n, s);
      }
    }, "onSuccess")
  };
}
c(zm, "getAddMessageMutationOptions");
const _p = class _p {
  get result() {
    return this._result && this.observer ? this.observer.trackResult(this._result) : { isPending: !0 };
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((i) => this.resolveContext = i), this.whenQueryClient = new Promise((i) => this.resolveQueryClient = i), this.setContext();
  }
  async setContext() {
    await oo(this.host), this.context = new as(this.host, {
      context: Xt,
      subscribe: !0,
      callback: /* @__PURE__ */ c((t) => {
        var i, s;
        t && ((i = this.resolveContext) == null || i.call(this, t), this.queryClient = t.queryClient, (s = this.resolveQueryClient) == null || s.call(this, t.queryClient));
      }, "callback")
    });
  }
  async trackInfiniteQuery(t, i = !0) {
    var a;
    const s = await this.whenQueryClient;
    if (!s)
      throw new Error("No QueryClient provided");
    (a = this.observerUnsubscribe) == null || a.call(this);
    const n = new c1(s, t);
    this.observer = n, this.observerSubscribe(i);
  }
  observerSubscribe(t = !0) {
    var i;
    if (this.queryClient && this.observer) {
      t ? this._result = this.observer.getOptimisticResult(
        this.observer.options
      ) : this._result = this.observer.getCurrentResult(), this.observerUnsubscribe = this.observer.subscribe(() => {
        if (this.observer) {
          const n = hc(this.result, this.observer.getCurrentResult());
          n !== this._result && (this._result = n, this.host.requestUpdate());
        }
      }), this.observer.updateResult(), this.host.requestUpdate();
      let s;
      t ? s = this.observer.fetchOptimistic(this.observer.options) : s = (i = this.queryClient.getQueryCache().get(
        this.observer.options.queryHash
      )) == null ? void 0 : i.promise, s == null || s.catch(() => {
      }).finally(() => {
        var n;
        (n = this.observer) == null || n.updateResult();
      });
    }
  }
  untrackInfiniteQuery() {
    var t;
    (t = this.observerUnsubscribe) == null || t.call(this), this.observerUnsubscribe = void 0, this._result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    var t;
    (t = this.observerUnsubscribe) == null || t.call(this);
  }
};
c(_p, "InfiniteQueryController");
let Ri = _p;
function Sm(r) {
  for (; r; )
    if (r = r.nextElementSibling, r instanceof HTMLElement && /absolute|sticky|fixed/.test(getComputedStyle(r).position) === !1)
      return r;
  return null;
}
c(Sm, "getNextPositionedChild");
function vl(r, t = !1) {
  if (Se(), r) {
    let i = getComputedStyle(r);
    const s = i.position === "absolute", n = t ? /(auto|scroll|overlay|hidden)/ : /(auto|overlay|scroll)/;
    if (i.position === "fixed" && document.scrollingElement)
      return document.scrollingElement;
    for (let a = r; a = a.parentElement || a.parentNode || a.host; )
      if (a instanceof Element && (i = getComputedStyle(a), !(s && i.position === "static") && n.test(i.overflow + i.overflowY + i.overflowX)))
        return a;
  }
  return document.scrollingElement || r;
}
c(vl, "getScrollParent");
function Em(r) {
  if (r && r.isConnected) {
    const t = vl(r);
    return t.clientHeight !== t.scrollHeight;
  }
  return !1;
}
c(Em, "hasScroll");
function Om(r, t = 32) {
  if (r) {
    const i = vl(r);
    return Math.abs(i.scrollTop + i.clientHeight - i.scrollHeight) < t;
  }
  return !1;
}
c(Om, "isParentAtBottom");
async function Am(r, t = !1) {
  if (r) {
    const i = vl(r);
    Math.abs(i.scrollTop + i.clientHeight - i.scrollHeight) > 1 && (t ? i.scrollTo({
      top: i.scrollHeight,
      left: 0,
      behavior: "smooth"
    }) : i.scrollTop = i.scrollHeight), await new Promise((s) => {
      let n = i.scrollTop;
      const a = /* @__PURE__ */ c(() => {
        t && i.scrollTop === n && (i.scrollTop = i.scrollHeight), n = i.scrollTop, Math.abs(i.scrollTop + i.clientHeight - i.scrollHeight) > 1 ? requestAnimationFrame(a) : s(void 0);
      }, "scrollCheck");
      requestAnimationFrame(a);
    });
  }
}
c(Am, "scrollParentToBottom");
const Lm = 0, Rm = void 0;
function Im(r, t, i = !1) {
  Se(), t ?? (t = /* @__PURE__ */ c(() => Promise.reject(new Error("No scroll function defined")), "whenNext"));
  const s = i ? vl(r) : document.documentElement, n = s === document.documentElement ? document : s;
  let a = !1;
  const o = new IntersectionObserver(
    (l) => {
      l.forEach((d) => {
        if (d.isIntersecting && !a)
          if (a = !0, i && s && n instanceof HTMLElement) {
            const u = Sm(d.target) || d.target, y = s.scrollHeight, m = u.offsetTop, f = /* @__PURE__ */ c(() => {
              queueMicrotask(() => {
                if (y !== s.scrollHeight) {
                  if (u != null && u.isConnected) {
                    const g = u.offsetTop - m;
                    s.scrollTop += g;
                  }
                  requestAnimationFrame(() => a = !1);
                } else
                  queueMicrotask(() => {
                    if (y !== s.scrollHeight) {
                      if (u != null && u.isConnected) {
                        const g = u.offsetTop - m;
                        s.scrollTop += g;
                      }
                      requestAnimationFrame(() => a = !1);
                    } else
                      requestAnimationFrame(() => {
                        if (o.takeRecords().length && (u != null && u.isConnected)) {
                          const g = u.offsetTop - m;
                          s.scrollTop += g;
                        }
                        requestAnimationFrame(() => a = !1);
                      });
                  });
              });
            }, "afterNext");
            t().then(f);
          } else
            t().then(() => {
              requestAnimationFrame(() => a = !1);
            });
      });
    },
    { root: n, threshold: Lm, rootMargin: Rm }
  );
  return o.observe(r), o;
}
c(Im, "createScroller");
const Pp = class Pp {
  constructor(t, i = !1) {
    this.reverse = !1, this.isObservePending = !1, t.addController(this), this.host = t, this.reverse = i;
  }
  observe(t, i) {
    t && i && !t.isLoading && !this.isObservePending && (this.isObservePending = !0, requestAnimationFrame(() => {
      var s;
      this.loadMoreRefElement = i, (s = this.scroller) == null || s.disconnect(), this.scroller = Im(
        i,
        async () => {
          t.hasNextPage && !t.isFetching && (await t.fetchNextPage({ cancelRefetch: !1 }), this.reverse && await this.host.updateComplete);
        },
        this.reverse
      ), this.isObservePending = !1;
    }));
  }
  hostConnected() {
    var t;
    this.loadMoreRefElement && ((t = this.scroller) == null || t.observe(this.loadMoreRefElement));
  }
  hostDisconnected() {
    var t;
    (t = this.scroller) == null || t.disconnect();
  }
};
c(Pp, "InfiniteScrollController");
let Ii = Pp;
const Mp = class Mp extends Ii {
  constructor(t) {
    super(t, !0);
  }
};
c(Mp, "ReverseInfiniteScrollController");
let rh = Mp;
const zp = class zp {
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((i) => this.resolveContext = i), this.whenObserver = new Promise((i) => this.resolveObserver = i), this.setContext();
  }
  async setContext() {
    await oo(this.host), this.context = new as(this.host, { context: Xt, subscribe: !0 });
  }
  hostUpdate() {
    var t, i;
    (t = this.context) != null && t.value && ((i = this.resolveContext) == null || i.call(this));
  }
  async trackMutation(t, i) {
    var s, n, a, o;
    if (i || (await this.whenContext, i = (n = (s = this.context) == null ? void 0 : s.value) == null ? void 0 : n.queryClient), !i)
      throw new Error("No QueryClient provided");
    return (a = this.observerUnsubscribe) == null || a.call(this), this.observer && (this.whenObserver = new Promise((l) => this.resolveObserver = l)), this.observer = new bt(i, { ...t }), this.observerSubscribe(), (o = this.resolveObserver) == null || o.call(this, this.observer), this.observer;
  }
  observerSubscribe() {
    this.observer && (this.result = this.observer.getCurrentResult(), this.observerUnsubscribe ?? (this.observerUnsubscribe = this.observer.subscribe(() => {
      if (this.observer) {
        const t = hc(this.result, this.observer.getCurrentResult());
        this.result !== t && (this.result = t, this.host.requestUpdate());
      }
    })), this.host.requestUpdate());
  }
  untrackMutation() {
    var t;
    (t = this.observerUnsubscribe) == null || t.call(this), this.observerUnsubscribe = void 0, this.result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  async mutate(t, i) {
    return (await this.whenObserver).mutate(t, i);
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    var t;
    (t = this.observerUnsubscribe) == null || t.call(this);
  }
};
c(zp, "MutationController");
let Ae = zp;
const { I: Tm } = Tf, cu = /* @__PURE__ */ c((r, t) => (r == null ? void 0 : r._$litType$) !== void 0, "nt"), Fm = /* @__PURE__ */ c((r) => {
  var t;
  return ((t = r == null ? void 0 : r._$litType$) == null ? void 0 : t.h) != null;
}, "ot"), Dm = /* @__PURE__ */ c((r) => r.strings === void 0, "rt"), lu = /* @__PURE__ */ c(() => document.createComment(""), "lt"), _s = /* @__PURE__ */ c((r, t, i) => {
  var a;
  const s = r._$AA.parentNode, n = t === void 0 ? r._$AB : t._$AA;
  if (i === void 0) {
    const o = s.insertBefore(lu(), n), l = s.insertBefore(lu(), n);
    i = new Tm(o, l, r, r.options);
  } else {
    const o = i._$AB.nextSibling, l = i._$AM, d = l !== r;
    if (d) {
      let u;
      (a = i._$AQ) == null || a.call(i, r), i._$AM = r, i._$AP !== void 0 && (u = r._$AU) !== l._$AU && i._$AP(u);
    }
    if (o !== n || d) {
      let u = i._$AA;
      for (; u !== o; ) {
        const y = u.nextSibling;
        s.insertBefore(u, n), u = y;
      }
    }
  }
  return i;
}, "at"), Cs = /* @__PURE__ */ c((r, t, i = r) => (r._$AI(t, i), r), "ct"), Hm = {}, qc = /* @__PURE__ */ c((r, t = Hm) => r._$AH = t, "dt"), nh = /* @__PURE__ */ c((r) => r._$AH, "ut"), Cd = /* @__PURE__ */ c((r) => {
  var s;
  (s = r._$AP) == null || s.call(r, !1, !0);
  let t = r._$AA;
  const i = r._$AB.nextSibling;
  for (; t !== i; ) {
    const n = t.nextSibling;
    t.remove(), t = n;
  }
}, "pt"), Vm = /* @__PURE__ */ c((r) => {
  r._$AR();
}, "ft");
const uo = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, Ui = /* @__PURE__ */ c((r) => (...t) => ({ _$litDirective$: r, values: t }), "e$1"), Sp = class Sp {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, i, s) {
    this.t = t, this._$AM = i, this.i = s;
  }
  _$AS(t, i) {
    return this.update(t, i);
  }
  update(t, i) {
    return this.render(...i);
  }
};
c(Sp, "i");
let mi = Sp;
const Po = /* @__PURE__ */ c((r, t) => {
  var s;
  const i = r._$AN;
  if (i === void 0) return !1;
  for (const n of i) (s = n._$AO) == null || s.call(n, t, !1), Po(n, t);
  return !0;
}, "mt"), Nc = /* @__PURE__ */ c((r) => {
  let t, i;
  do {
    if ((t = r._$AM) === void 0) break;
    i = t._$AN, i.delete(r), r = t;
  } while ((i == null ? void 0 : i.size) === 0);
}, "_t"), Uy = /* @__PURE__ */ c((r) => {
  for (let t; t = r._$AM; r = t) {
    let i = t._$AN;
    if (i === void 0) t._$AN = i = /* @__PURE__ */ new Set();
    else if (i.has(r)) break;
    i.add(r), qm(t);
  }
}, "wt");
function Bm(r) {
  this._$AN !== void 0 ? (Nc(this), this._$AM = r, Uy(this)) : this._$AM = r;
}
c(Bm, "bt");
function Um(r, t = !1, i = 0) {
  const s = this._$AH, n = this._$AN;
  if (n !== void 0 && n.size !== 0) if (t) if (Array.isArray(s)) for (let a = i; a < s.length; a++) Po(s[a], !1), Nc(s[a]);
  else s != null && (Po(s, !1), Nc(s));
  else Po(this, r);
}
c(Um, "yt");
const qm = /* @__PURE__ */ c((r) => {
  r.type == uo.CHILD && (r._$AP ?? (r._$AP = Um), r._$AQ ?? (r._$AQ = Bm));
}, "gt"), Ep = class Ep extends mi {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, i, s) {
    super._$AT(t, i, s), Uy(this), this.isConnected = t._$AU;
  }
  _$AO(t, i = !0) {
    var s, n;
    t !== this.isConnected && (this.isConnected = t, t ? (s = this.reconnected) == null || s.call(this) : (n = this.disconnected) == null || n.call(this)), i && (Po(this, t), Nc(this));
  }
  setValue(t) {
    if (Dm(this.t)) this.t._$AI(t, this);
    else {
      const i = [...this.t._$AH];
      i[this.i] = t, this.t._$AI(i, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};
c(Ep, "$t");
let ah = Ep;
const rt = /* @__PURE__ */ c(() => new oh(), "ii"), Op = class Op {
};
c(Op, "Zt");
let oh = Op;
const _d = /* @__PURE__ */ new WeakMap(), X = Ui(class extends ah {
  render(r) {
    return C;
  }
  update(r, [t]) {
    var s;
    const i = t !== this.Y;
    return i && this.Y !== void 0 && this.rt(void 0), (i || this.lt !== this.ct) && (this.Y = t, this.ht = (s = r.options) == null ? void 0 : s.host, this.rt(this.ct = r.element)), C;
  }
  rt(r) {
    if (this.isConnected || (r = void 0), typeof this.Y == "function") {
      const t = this.ht ?? globalThis;
      let i = _d.get(t);
      i === void 0 && (i = /* @__PURE__ */ new WeakMap(), _d.set(t, i)), i.get(this.Y) !== void 0 && this.Y.call(this.ht, void 0), i.set(this.Y, r), r !== void 0 && this.Y.call(this.ht, r);
    } else this.Y.value = r;
  }
  get lt() {
    var r, t;
    return typeof this.Y == "function" ? (r = _d.get(this.ht ?? globalThis)) == null ? void 0 : r.get(this.Y) : (t = this.Y) == null ? void 0 : t.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
function Nm(r, t) {
  const i = r.queryClient, s = t;
  return {
    mutationKey: s,
    mutationFn: /* @__PURE__ */ c(async ({ optionId: a }) => {
      const o = await r.fetch(`/api/options/${a}/vote`, { method: "POST" });
      if (!o.ok) {
        const l = await o.json();
        throw new Error(l.detail || l.title, { cause: l });
      }
      return o.json();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (a) => (nt(i, { queryKey: s }, a.parentId, (o) => {
      var l, d;
      (l = o.options) != null && l.data && (o.options.data = (d = o.options.data) == null ? void 0 : d.map((u) => {
        var y, m;
        if (u.has_voted) {
          u.has_voted = !1;
          const f = ((y = u.votes) == null ? void 0 : y.count) || 1;
          u.votes ? u.votes.count = f - 1 : u.votes = { count: f - 1 };
        } else if (!u.has_voted && u.id === a.optionId) {
          u.has_voted = !0;
          const f = ((m = u.votes) == null ? void 0 : m.count) || 0;
          u.votes ? u.votes.count = f + 1 : u.votes = { count: f + 1 };
        }
        return u;
      }));
    }), { id: a.optionId }), "onMutate"),
    onSuccess: /* @__PURE__ */ c(async (a, o) => {
      const d = await (await r.fetch("/api/" + o.parentType + "/" + o.parentId)).json();
      nt(
        i,
        { queryKey: s, exact: !1 },
        o.parentId,
        (u) => Object.assign(u, d)
      );
    }, "onSuccess")
    /*onError(error: Error, variables: MutatePollVariables) {
      updateCacheItems(queryClient, { queryKey: postsKey, exact: false }, variables.id, (existingPost: PostType) => Object.assign(existingPost, { is_subscribed: variables..is_subscribed }));
    },*/
  };
}
c(Nm, "getPollMutationOptions");
function Vh(r, t) {
  return new bt(r.queryClient, Nm(r, t));
}
c(Vh, "getPollMutation");
function jm(r, t) {
  return {
    queryKey: ["votes", t],
    enabled: !1,
    queryFn: /* @__PURE__ */ c(async () => await (await r.fetch(`/api/options/${t}`)).json(), "queryFn")
  };
}
c(jm, "getVotesOptions");
const Us = /* @__PURE__ */ c((r, t) => !!(r && t && t.indexOf(r) !== -1), "hasPermission");
function Wm(r) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ appId: i, messageId: s }) => {
      const n = s ? `/api/apps/${i}/mark?messageId=${s}` : `/api/apps/${i}/mark`;
      await r.fetch(n, { method: s ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (i) => {
      await r.queryClient.cancelQueries({ queryKey: ["apps", i.appId] }), await r.queryClient.cancelQueries({ queryKey: ["apps", "list"], exact: !1 }), await r.queryClient.cancelQueries({ queryKey: ["members", i.appId] }), r.queryClient.setQueryData(
        ["apps", i.appId],
        (s) => s && { ...s, is_unread: !i.messageId || i.messageId < s.last_message.id }
      ), nt(
        r.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        i.appId,
        (s) => {
          s.is_unread = !i.messageId || i.messageId < s.last_message.id;
        }
      ), i.userId && _t(r.queryClient, ["members", i.appId], i.userId, (s) => {
        i.messageId ? (s.marked_at = (/* @__PURE__ */ new Date()).toISOString(), s.marked_id = i.messageId) : (s.marked_at = void 0, s.marked_id = void 0);
      });
    }, "onMutate"),
    onError: /* @__PURE__ */ c((i, s) => {
      console.error(i.message), nt(
        r.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        s.appId,
        (n) => {
          n.is_unread = !n.is_unread;
        }
      );
    }, "onError"),
    onSettled: /* @__PURE__ */ c((i, s, n) => {
      r.queryClient.invalidateQueries({ queryKey: ["apps", n.appId] }), r.queryClient.invalidateQueries({ queryKey: ["apps", "list"], exact: !1 }), r.queryClient.invalidateQueries({ queryKey: ["members", n.appId] });
    }, "onSettled")
  };
}
c(Wm, "getMarkConversationMutationOptions");
function Qm(r) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ appId: i, star: s }) => {
      await r.fetch(`/api/apps/${i}/stars`, { method: s ? "POST" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (i) => {
      nt(
        r.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        i.appId,
        (s) => {
          s.is_starred = i.star;
        }
      );
    }, "onMutate"),
    onError: /* @__PURE__ */ c((i, s) => {
      console.error(i.message), nt(
        r.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        s.appId,
        (n) => {
          n.is_starred = !s.star;
        }
      );
    }, "onError")
  };
}
c(Qm, "getStarConversationMutationOptions");
function Km(r) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ appId: i, pin: s }) => {
      await r.fetch(`/api/apps/${i}/pin`, { method: s ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (i) => {
      nt(
        r.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        i.appId,
        (s) => {
          s.is_pinned = i.pin;
        }
      );
    }, "onMutate"),
    onSettled: /* @__PURE__ */ c(async () => {
      await r.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
c(Km, "getPinConversationMutationOptions");
function Gm(r) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ appId: i, members: s }) => {
      await r.fetch(`/api/apps/${i}/members/${s.join(",")}`, { method: "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (i) => {
      Hh(r.queryClient, ["apps", "list"], i.appId);
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((i, s) => {
      r.queryClient.removeQueries({ queryKey: ["apps", s.appId] }), r.queryClient.removeQueries({ queryKey: ["members", s.appId] });
    }, "onSuccess"),
    onSettled: /* @__PURE__ */ c(() => {
      r.queryClient.invalidateQueries({ queryKey: ["apps"] }), r.queryClient.invalidateQueries({ queryKey: ["members"] });
    }, "onSettled")
  };
}
c(Gm, "getLeaveConversationMutationOptions");
function Ym(r) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ appId: i, userId: s, access: n }) => {
      await r.fetch(`/api/apps/${i}/members/${s}`, { method: "PUT", body: JSON.stringify({ access: n }) });
    }, "mutationFn"),
    onSettled: /* @__PURE__ */ c((i, s, n) => {
      r.queryClient.invalidateQueries({ queryKey: ["apps"] }), r.queryClient.invalidateQueries({ queryKey: ["members", n.appId] });
    }, "onSettled")
  };
}
c(Ym, "getUpdateMemberMutationOptions");
function Zm(r) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ appId: i, members: s }) => {
      await r.fetch(`/api/apps/${i}/members`, {
        method: "PUT",
        body: JSON.stringify(
          s.map((n) => ({ id: n, access: "write" }))
        )
      });
    }, "mutationFn"),
    onSettled: /* @__PURE__ */ c((i, s, n) => {
      r.queryClient.invalidateQueries({ queryKey: ["apps"] }), r.queryClient.invalidateQueries({ queryKey: ["members", n.appId] });
    }, "onSettled")
  };
}
c(Zm, "getAddMembersToConversationMutationOptions");
function Xm(r) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ appId: i, name: s, blobId: n }) => (await r.fetch(`/api/apps/${i}`, {
      method: "PATCH",
      body: JSON.stringify({
        name: s,
        picture: n
      })
    })).json(), "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (i) => {
      const s = /* @__PURE__ */ c((n) => {
        typeof i.name == "string" && (n.display_name = i.name), typeof (i == null ? void 0 : i.thumbnailUrl) == "string" && (n.avatar_url = i.thumbnailUrl);
      }, "modifyAppItem");
      _t(r.queryClient, ["apps", i.appId], void 0, s), nt(r.queryClient, { queryKey: ["apps", "list"], exact: !1 }, i.appId, s);
    }, "onMutate")
  };
}
c(Xm, "getUpdateConversationMutationOptions");
function Jm(r) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ appId: i }) => {
      await r.fetch(`/api/apps/${i}/trash`, { method: "POST" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (i) => {
      Hh(r.queryClient, ["apps", "list"], i.appId);
    }, "onMutate"),
    onSettled: /* @__PURE__ */ c(() => {
      r.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
c(Jm, "getTrashConversationMutationOptions");
function qy(r) {
  return new bt(r.queryClient, Wm(r));
}
c(qy, "getMarkConversationMutation");
function tv(r) {
  return new bt(r.queryClient, Qm(r));
}
c(tv, "getStarConversationMutation");
function ev(r) {
  return new bt(r.queryClient, Km(r));
}
c(ev, "getPinConversationMutation");
function Ny(r) {
  return new bt(r.queryClient, Gm(r));
}
c(Ny, "getLeaveConversationMutation");
function iv(r) {
  return new bt(r.queryClient, Ym(r));
}
c(iv, "getUpdateMemberMutation");
function sv(r) {
  return new bt(r.queryClient, Zm(r));
}
c(sv, "getAddMembersToConversationMutation");
function jy(r) {
  return new bt(r.queryClient, Xm(r));
}
c(jy, "getUpdateConversationMutation");
function rv(r) {
  return new bt(r.queryClient, Jm(r));
}
c(rv, "getTrashConversationMutation");
function nv(r, t, i = [ct.ChatRoom, ct.PrivateChat], s) {
  return yi(r, ["apps", t], void 0, {
    initialData: /* @__PURE__ */ c(() => {
      var n;
      return (n = r == null ? void 0 : r.queryClient.getQueryData(["apps", "list", i, s])) == null ? void 0 : n.pages.flatMap((a) => a.data).find((a) => (a == null ? void 0 : a.id) === t);
    }, "initialData")
  });
}
c(nv, "getConversationOptions");
function du(r, t, i = [ct.ChatRoom, ct.PrivateChat], s) {
  return Wd(r, ["apps", t], void 0, {
    initialData: /* @__PURE__ */ c(() => {
      var n;
      return (n = r == null ? void 0 : r.queryClient.getQueryData(["apps", "list", i, s])) == null ? void 0 : n.pages.flatMap((a) => a.data).find((a) => (a == null ? void 0 : a.id) === t);
    }, "initialData")
  });
}
c(du, "getConversation");
async function av(r, t, i, s) {
  let n;
  if (typeof t == "number")
    n = await du(r, t, i, s);
  else if (typeof t.id == "number" && !t.type)
    n = await du(r, t.id, i, s);
  else if (typeof t.type == "string")
    n = t;
  else
    return;
  return i.includes(n.type) ? n : void 0;
}
c(av, "resolveAppWithType");
const Ap = class Ap {
  constructor(t, i) {
    this.additionalTargets = /* @__PURE__ */ new Set(), this.setExportParts = (s) => {
      (!this.host.hasAttribute("exportparts") || this.shadowParts) && (this.shadowParts ?? (this.shadowParts = /* @__PURE__ */ new Set()), s.forEach((n) => {
        var a;
        n.part.forEach((o) => {
          var l;
          return (l = this.shadowParts) == null ? void 0 : l.add(o);
        }), (a = n.getAttribute("exportparts")) == null || a.split(", ").forEach((o) => {
          var l;
          return (l = this.shadowParts) == null ? void 0 : l.add(o);
        });
      }), this.shadowParts.size && this.host.setAttribute("exportparts", Array.from(this.shadowParts.values()).join(", ")));
    }, t.addController(this), this.host = t, this.addLocalName = i;
  }
  addPartsFrom(t) {
    var i;
    t && !this.additionalTargets.has(t) && (this.setExportParts([t]), (i = this.observer) == null || i.observe(t, {
      attributeFilter: ["part", "exportparts"]
    }), this.additionalTargets.add(t));
  }
  async hostConnected() {
    if (await this.host.updateComplete, jp(this.host) && this.host.shadowRoot) {
      const t = Array.from(this.host.shadowRoot.querySelectorAll("[part], [exportparts]"));
      this.setExportParts(t), this.observer = new MutationObserver((i) => {
        const s = i.filter((n) => n.target instanceof Element).map((n) => n.target);
        this.setExportParts(s);
      }), this.observer.observe(this.host.shadowRoot, {
        subtree: !0,
        childList: !0,
        attributeFilter: ["part", "exportparts"]
      }), Array.from(this.additionalTargets).forEach((i) => {
        var s;
        (s = this.observer) == null || s.observe(i, {
          attributeFilter: ["part", "exportparts"]
        });
      });
    }
  }
  hostUpdated() {
    jp(this.host) && this.addLocalName !== !1 && !this.host.part.contains(this.host.localName) && (this.addLocalName || getComputedStyle(this.host).display !== "contents") && this.host.part.add(this.host.localName);
  }
  hostDisconnected() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
};
c(Ap, "ShadowPartsController");
let Q = Ap;
function Wy(r, t, i) {
  return {
    queryKey: ["members", t],
    queryFn: /* @__PURE__ */ c(async () => await (await r.fetch("/api/apps/" + t + "/members")).json(), "queryFn"),
    ...i
  };
}
c(Wy, "getMemberOptions");
function ov(r, t, i, s) {
  return {
    queryKey: ["searchmembers"],
    initialPageParam: 0,
    enabled: !0,
    queryFn: /* @__PURE__ */ c(async (n) => {
      const a = t(), o = n.pageParam;
      let l;
      i ? l = await r.fetch(`/api/apps/${i}/members?member=false&q=${a}&skip=${o}${s() !== void 0 ? `&bot=${!!s()}` : ""}`) : l = await r.fetch(`/api/users?q=${a}&skip=${o}${s() !== void 0 ? `&bot=${!!s()}` : ""}`);
      const d = await l.json();
      return d.data = d.data || [], d;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ c((n) => {
      if (n.end && n.end < n.count)
        return n.end;
    }, "getNextPageParam")
  };
}
c(ov, "getInfiniteSearchMemberOptions");
const ir = Z`[part~=wy-pager]{position:relative;align-self:center;justify-self:center}[part~=wy-pager-bottom]{width:16px;height:256px;max-height:100%;margin-top:-256px;margin-inline:auto;pointer-events:none}[part~=wy-pager-top]{width:16px;height:256px;max-height:100%;margin-bottom:-256px;margin-inline:auto;pointer-events:none}`;
var cv = "M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M1,10V12H9V10M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12Z", lv = "M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M6,10V7H4V10H1V12H4V15H6V12H9V10M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12Z", dv = "M13 14H11V9H13M13 18H11V16H13M1 21H23L12 2L1 21Z", hv = "M13,13H11V7H13M13,17H11V15H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", pv = "M13 13H11V7H13M11 15H13V17H11M15.73 3H8.27L3 8.27V15.73L8.27 21H15.73L21 15.73V8.27L15.73 3Z", hu = "M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z", uv = "M4,11V13H16L10.5,18.5L11.92,19.92L19.84,12L11.92,4.08L10.5,5.5L16,11H4Z", Qy = "M7.5,18A5.5,5.5 0 0,1 2,12.5A5.5,5.5 0 0,1 7.5,7H18A4,4 0 0,1 22,11A4,4 0 0,1 18,15H9.5A2.5,2.5 0 0,1 7,12.5A2.5,2.5 0 0,1 9.5,10H17V11.5H9.5A1,1 0 0,0 8.5,12.5A1,1 0 0,0 9.5,13.5H18A2.5,2.5 0 0,0 20.5,11A2.5,2.5 0 0,0 18,8.5H7.5A4,4 0 0,0 3.5,12.5A4,4 0 0,0 7.5,16.5H17V18H7.5Z", yv = "M12,3A9,9 0 0,0 3,12H0L4,16L8,12H5A7,7 0 0,1 12,5A7,7 0 0,1 19,12A7,7 0 0,1 12,19C10.5,19 9.09,18.5 7.94,17.7L6.5,19.14C8.04,20.3 9.94,21 12,21A9,9 0 0,0 21,12A9,9 0 0,0 12,3M14,12A2,2 0 0,0 12,10A2,2 0 0,0 10,12A2,2 0 0,0 12,14A2,2 0 0,0 14,12Z", Ky = "M21,19V20H3V19L5,17V11C5,7.9 7.03,5.17 10,4.29C10,4.19 10,4.1 10,4A2,2 0 0,1 12,2A2,2 0 0,1 14,4C14,4.1 14,4.19 14,4.29C16.97,5.17 19,7.9 19,11V17L21,19M14,21A2,2 0 0,1 12,23A2,2 0 0,1 10,21", Gy = "M20.84,22.73L18.11,20H3V19L5,17V11C5,9.86 5.29,8.73 5.83,7.72L1.11,3L2.39,1.73L22.11,21.46L20.84,22.73M19,15.8V11C19,7.9 16.97,5.17 14,4.29C14,4.19 14,4.1 14,4A2,2 0 0,0 12,2A2,2 0 0,0 10,4C10,4.1 10,4.19 10,4.29C9.39,4.47 8.8,4.74 8.26,5.09L19,15.8M12,23A2,2 0 0,0 14,21H10A2,2 0 0,0 12,23Z", wv = "M15.39,14.04V14.04C15.39,12.62 14.24,11.47 12.82,11.47C11.41,11.47 10.26,12.62 10.26,14.04V14.04C10.26,15.45 11.41,16.6 12.82,16.6C14.24,16.6 15.39,15.45 15.39,14.04M17.1,14.04C17.1,16.4 15.18,18.31 12.82,18.31C11.19,18.31 9.77,17.39 9.05,16.04C8.33,17.39 6.91,18.31 5.28,18.31C2.94,18.31 1.04,16.43 1,14.11V14.11H1V7H1V7C1,6.56 1.39,6.18 1.86,6.18C2.33,6.18 2.7,6.56 2.71,7V7H2.71V10.62C3.43,10.08 4.32,9.76 5.28,9.76C6.91,9.76 8.33,10.68 9.05,12.03C9.77,10.68 11.19,9.76 12.82,9.76C15.18,9.76 17.1,11.68 17.1,14.04V14.04M7.84,14.04V14.04C7.84,12.62 6.69,11.47 5.28,11.47C3.86,11.47 2.71,12.62 2.71,14.04V14.04C2.71,15.45 3.86,16.6 5.28,16.6C6.69,16.6 7.84,15.45 7.84,14.04M22.84,16.96V16.96C22.95,17.12 23,17.3 23,17.47C23,17.73 22.88,18 22.66,18.15C22.5,18.26 22.33,18.32 22.15,18.32C21.9,18.32 21.65,18.21 21.5,18L19.59,15.47L17.7,18V18C17.53,18.21 17.28,18.32 17.03,18.32C16.85,18.32 16.67,18.26 16.5,18.15C16.29,18 16.17,17.72 16.17,17.46C16.17,17.29 16.23,17.11 16.33,16.96V16.96H16.33V16.96L18.5,14.04L16.33,11.11V11.11H16.33V11.11C16.22,10.96 16.17,10.79 16.17,10.61C16.17,10.35 16.29,10.1 16.5,9.93C16.89,9.65 17.41,9.72 17.7,10.09V10.09L19.59,12.61L21.5,10.09C21.76,9.72 22.29,9.65 22.66,9.93C22.89,10.1 23,10.36 23,10.63C23,10.8 22.95,10.97 22.84,11.11V11.11H22.84V11.11L20.66,14.04L22.84,16.96V16.96H22.84Z", fv = "M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3M9 17H7V10H9V17M13 17H11V7H13V17M17 17H15V13H17V17Z", Pd = "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z", mv = "M0.41,13.41L6,19L7.41,17.58L1.83,12M22.24,5.58L11.66,16.17L7.5,12L6.07,13.41L11.66,19L23.66,7M18,7L16.59,5.58L10.24,11.93L11.66,13.34L18,7Z", vv = "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41 10.59L10 14.17L17.59 6.58L19 8L10 17Z", gv = "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M12 20C7.59 20 4 16.41 4 12S7.59 4 12 4 20 7.59 20 12 16.41 20 12 20M16.59 7.58L10 14.17L7.41 11.59L6 13L10 17L18 9L16.59 7.58Z", bv = "M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3M19,5V19H5V5H19Z", xv = "M19,19H5V5H15V3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V11H19M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z", $v = "M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", kv = "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z", Cv = "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z", _v = "M6.5 20Q4.22 20 2.61 18.43 1 16.85 1 14.58 1 12.63 2.17 11.1 3.35 9.57 5.25 9.15 5.88 6.85 7.75 5.43 9.63 4 12 4 14.93 4 16.96 6.04 19 8.07 19 11 20.73 11.2 21.86 12.5 23 13.78 23 15.5 23 17.38 21.69 18.69 20.38 20 18.5 20Z", Pv = "M9,22A1,1 0 0,1 8,21V18H4A2,2 0 0,1 2,16V4C2,2.89 2.9,2 4,2H20A2,2 0 0,1 22,4V16A2,2 0 0,1 20,18H13.9L10.2,21.71C10,21.9 9.75,22 9.5,22V22H9Z", Mv = "M9,22A1,1 0 0,1 8,21V18H4A2,2 0 0,1 2,16V4C2,2.89 2.9,2 4,2H20A2,2 0 0,1 22,4V16A2,2 0 0,1 20,18H13.9L10.2,21.71C10,21.9 9.75,22 9.5,22V22H9M10,16V19.08L13.08,16H20V4H4V16H10Z", zv = "M15,9H5V5H15M12,19A3,3 0 0,1 9,16A3,3 0 0,1 12,13A3,3 0 0,1 15,16A3,3 0 0,1 12,19M17,3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V7L17,3Z", Sv = "M13,19A1,1 0 0,0 14,20H16V22H13.5C12.95,22 12,21.55 12,21C12,21.55 11.05,22 10.5,22H8V20H10A1,1 0 0,0 11,19V5A1,1 0 0,0 10,4H8V2H10.5C11.05,2 12,2.45 12,3C12,2.45 12.95,2 13.5,2H16V4H14A1,1 0 0,0 13,5V19Z", Yy = "M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z", Zy = "M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19M8.46,11.88L9.87,10.47L12,12.59L14.12,10.47L15.53,11.88L13.41,14L15.53,16.12L14.12,17.53L12,15.41L9.88,17.53L8.47,16.12L10.59,14L8.46,11.88M15.5,4L14.5,3H9.5L8.5,4H5V6H19V4H15.5Z", Ev = "M14,14H16L12,10L8,14H10V18H14V14M6,7H18V19C18,19.5 17.8,20 17.39,20.39C17,20.8 16.5,21 16,21H8C7.5,21 7,20.8 6.61,20.39C6.2,20 6,19.5 6,19V7M19,4V6H5V4H8.5L9.5,3H14.5L15.5,4H19Z", Ov = "M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z", Av = "M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z", Lv = "M3 6.2L8 9.39L13 6.2L8 3L3 6.2M13 6.2L18 9.39L23 6.2L18 3L13 6.2M3 12.55L8 15.74L13 12.55L8 9.35L3 12.55M18 9.35L13 12.55L18 15.74L23 12.55L18 9.35M8.03 16.8L13.04 20L18.04 16.8L13.04 13.61L8.03 16.8Z", Rv = "M17.9,17.39C17.64,16.59 16.89,16 16,16H15V13A1,1 0 0,0 14,12H8V10H10A1,1 0 0,0 11,9V7H13A2,2 0 0,0 15,5V4.59C17.93,5.77 20,8.64 20,12C20,14.08 19.2,15.97 17.9,17.39M11,19.93C7.05,19.44 4,16.08 4,12C4,11.38 4.08,10.78 4.21,10.21L9,15V16A2,2 0 0,0 11,18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", Iv = "M20,8L12,13L4,8V6L12,11L20,6M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C22,4.89 21.1,4 20,4Z", Tv = "M13,9V3.5L18.5,9M6,2C4.89,2 4,2.89 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2H6Z", pu = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M6.12,15.5L9.86,19.24L11.28,17.83L8.95,15.5L11.28,13.17L9.86,11.76L6.12,15.5M17.28,15.5L13.54,11.76L12.12,13.17L14.45,15.5L12.12,17.83L13.54,19.24L17.28,15.5Z", uu = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M15,18V16H6V18H15M18,14V12H6V14H18Z", Fv = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.8,20H14L12,16.6L10,20H8.2L11.1,15.5L8.2,11H10L12,14.4L14,11H15.8L12.9,15.5L15.8,20M13,9V3.5L18.5,9H13Z", Dv = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M6,20H15L18,20V12L14,16L12,14L6,20M8,9A2,2 0 0,0 6,11A2,2 0 0,0 8,13A2,2 0 0,0 10,11A2,2 0 0,0 8,9Z", Hv = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M13,13H11V18A2,2 0 0,1 9,20A2,2 0 0,1 7,18A2,2 0 0,1 9,16C9.4,16 9.7,16.1 10,16.3V11H13V13M13,9V3.5L18.5,9H13Z", Vv = "M12.6,12.3H10.6V15.5H12.7C13.3,15.5 13.6,15.3 13.9,15C14.2,14.7 14.3,14.4 14.3,13.9C14.3,13.4 14.2,13.1 13.9,12.8C13.6,12.5 13.2,12.3 12.6,12.3M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.2,16C14.6,16.5 14.1,16.7 12.8,16.7H10.6V20H9V11H12.8C14.1,11 14.7,11.3 15.2,11.8C15.8,12.4 16,13 16,13.9C16,14.8 15.8,15.5 15.2,16M13,9V3.5L18.5,9H13Z", Bv = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M13.5,16V19H10.5V16H8L12,12L16,16H13.5M13,9V3.5L18.5,9H13Z", Uv = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M17,19V13L14,15.2V13H7V19H14V16.8L17,19Z", qv = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.2,20H13.8L12,13.2L10.2,20H8.8L6.6,11H8.1L9.5,17.8L11.3,11H12.6L14.4,17.8L15.8,11H17.3L15.2,20M13,9V3.5L18.5,9H13Z", Nv = "M20,2H4C2.89,2 2,2.89 2,4V20C2,21.11 2.89,22 4,22H20C21.11,22 22,21.11 22,20V4C22,2.89 21.11,2 20,2M12,4L15,7H13V9H11V7H9M7,15L4,12L7,9V11H9V13H7M12,20L9,17H11V15H13V17H15M17,15V13H15V11H17V9L20,12", jv = "M17 4H20C21.1 4 22 4.9 22 6V8H20V6H17V4M4 8V6H7V4H4C2.9 4 2 4.9 2 6V8H4M20 16V18H17V20H20C21.1 20 22 19.1 22 18V16H20M7 18H4V16H2V18C2 19.1 2.9 20 4 20H7V18M18 8H6V16H18V8Z", Wv = "M20 6H12L10 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V8C22 6.9 21.1 6 20 6M18 12H16V14H18V16H16V18H14V16H16V14H14V12H16V10H14V8H16V10H18V12Z", Qv = "M17,7H22V17H17V19A1,1 0 0,0 18,20H20V22H17.5C16.95,22 16,21.55 16,21C16,21.55 15.05,22 14.5,22H12V20H14A1,1 0 0,0 15,19V5A1,1 0 0,0 14,4H12V2H14.5C15.05,2 16,2.45 16,3C16,2.45 16.95,2 17.5,2H20V4H18A1,1 0 0,0 17,5V7M2,7H13V9H4V15H13V17H2V7M20,15V9H17V15H20Z", Kv = "M7.71,3.5L1.15,15L4.58,21L11.13,9.5M9.73,15L6.3,21H19.42L22.85,15M22.28,14L15.42,2H8.58L8.57,2L15.43,14H22.28Z", Gv = "M15.07,11.25L14.17,12.17C13.45,12.89 13,13.5 13,15H11V14.5C11,13.39 11.45,12.39 12.17,11.67L13.41,10.41C13.78,10.05 14,9.55 14,9C14,7.89 13.1,7 12,7A2,2 0 0,0 10,9H8A4,4 0 0,1 12,5A4,4 0 0,1 16,9C16,9.88 15.64,10.67 15.07,11.25M13,19H11V17H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12C22,6.47 17.5,2 12,2Z", Yv = "M13.5,8H12V13L16.28,15.54L17,14.33L13.5,12.25V8M13,3A9,9 0 0,0 4,12H1L4.96,16.03L9,12H6A7,7 0 0,1 13,5A7,7 0 0,1 20,12A7,7 0 0,1 13,19C11.07,19 9.32,18.21 8.06,16.94L6.64,18.36C8.27,20 10.5,21 13,21A9,9 0 0,0 22,12A9,9 0 0,0 13,3", Zv = "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M11,17H13V11H11V17Z", Xv = "M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z", Jv = "M17,17H7V7H17M21,11V9H19V7C19,5.89 18.1,5 17,5H15V3H13V5H11V3H9V5H7C5.89,5 5,5.89 5,7V9H3V11H5V13H3V15H5V17A2,2 0 0,0 7,19H9V21H11V19H13V21H15V19H17A2,2 0 0,0 19,17V15H21V13H19V11M13,13H11V11H13M15,9H9V15H15V9Z", tg = "M7,10L12,15L17,10H7Z", eg = "M7,15L12,10L17,15H7Z", ig = "M18.21 10.29Q19 10.34 19.7 10.68 20.39 11 20.9 11.57 21.41 12.12 21.71 12.83 22 13.54 22 14.34 22 15.18 21.68 15.92 21.36 16.66 20.8 17.21 20.25 17.76 19.5 18.08 18.78 18.41 17.94 18.41H7Q5.97 18.41 5.06 18 4.15 17.61 3.47 16.94 2.79 16.26 2.4 15.35 2 14.44 2 13.41 2 12.59 2.26 11.83 2.5 11.08 3 10.45 3.44 9.82 4.08 9.35 4.72 8.88 5.5 8.63 5.87 8.5 6.21 8.5 6.56 8.43 6.93 8.41H6.94Q7.37 7.75 7.95 7.23 8.5 6.71 9.2 6.34 9.87 6 10.62 5.78 11.37 5.59 12.16 5.59 13.22 5.59 14.2 5.94 15.18 6.29 16 6.91 16.8 7.53 17.37 8.39 17.95 9.26 18.21 10.29M12.16 6.84Q11.05 6.84 10.06 7.3 9.06 7.75 8.36 8.6 8.73 8.7 9.07 8.85 9.4 9 9.73 9.2L13.71 11.58L16 10.62Q16.21 10.53 16.44 10.45 16.67 10.38 16.92 10.33 16.68 9.55 16.21 8.91 15.74 8.27 15.11 7.81 14.5 7.35 13.73 7.1 13 6.84 12.16 6.84M4 15.66L12.27 12.18L9.08 10.26Q8.59 9.97 8.06 9.81 7.5 9.66 6.95 9.66 6.19 9.66 5.5 9.96 4.84 10.26 4.34 10.77 3.84 11.29 3.54 11.97 3.25 12.65 3.25 13.41 3.25 14 3.45 14.59 3.64 15.19 4 15.66M17.94 17.16Q18.41 17.16 18.84 17 19.27 16.86 19.64 16.58L13.61 13L5.03 16.59Q5.47 16.86 5.97 17 6.47 17.16 7 17.16M20.45 15.61Q20.75 15 20.75 14.34 20.75 13.7 20.5 13.17 20.26 12.65 19.85 12.28 19.43 11.91 18.88 11.71 18.32 11.5 17.7 11.5 17.35 11.5 17 11.6 16.66 11.68 16.33 11.81 16 11.93 15.67 12.08 15.35 12.23 15.04 12.37Z", sg = "M19,13H5V11H19V13Z", rg = "M21 2C22.05 2 22.92 2.81 23 3.85L23 4V16C23 17.05 22.18 17.92 21.15 18L21 18H14V20H16V22H8V20H10V18H3C1.95 18 1.08 17.18 1 16.15L1 16V4C1 2.94 1.81 2.08 2.85 2L3 2H21M21 4H3V16H21V4M12 11C14.21 11 16 11.9 16 13V14H8V13C8 11.9 9.79 11 12 11M12 6C13.11 6 14 6.9 14 8S13.11 10 12 10 10 9.11 10 8 10.9 6 12 6Z", ng = "M14,3V5H17.59L7.76,14.83L9.17,16.24L19,6.41V10H21V3M19,19H5V5H12V3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V12H19V19Z", ch = "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z", ag = "M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z", og = "M2,5.27L3.28,4L20,20.72L18.73,22L12.8,16.07V22H11.2V16H6V14L8,12V11.27L2,5.27M16,12L18,14V16H17.82L8,6.18V4H7V2H17V4H16V12Z", Xy = "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z", cg = "M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M13,7H11V11H7V13H11V17H13V13H17V11H13V7Z", Jy = "M13,3A9,9 0 0,0 4,12H1L4.89,15.89L4.96,16.03L9,12H6A7,7 0 0,1 13,5A7,7 0 0,1 20,12A7,7 0 0,1 13,19C11.07,19 9.32,18.21 8.06,16.94L6.64,18.36C8.27,20 10.5,21 13,21A9,9 0 0,0 22,12A9,9 0 0,0 13,3Z", lg = "M4,3H5V5H3V4A1,1 0 0,1 4,3M20,3A1,1 0 0,1 21,4V5H19V3H20M15,5V3H17V5H15M11,5V3H13V5H11M7,5V3H9V5H7M21,20A1,1 0 0,1 20,21H19V19H21V20M15,21V19H17V21H15M11,21V19H13V21H11M7,21V19H9V21H7M4,21A1,1 0 0,1 3,20V19H5V21H4M3,15H5V17H3V15M21,15V17H19V15H21M3,11H5V13H3V11M21,11V13H19V11H21M3,7H5V9H3V7M21,7V9H19V7H21Z", dg = "M2,21L23,12L2,3V10L17,12L2,14V21Z", hg = "M13,19H14A1,1 0 0,1 15,20H15.73L13,17.27V19M22,20V21.18L20.82,20H22M21,22.72L19.73,24L17.73,22H15A1,1 0 0,1 14,23H10A1,1 0 0,1 9,22H2V20H9A1,1 0 0,1 10,19H11V17H4A1,1 0 0,1 3,16V12A1,1 0 0,1 4,11H6.73L4.73,9H4A1,1 0 0,1 3,8V7.27L1,5.27L2.28,4L21,22.72M4,3H20A1,1 0 0,1 21,4V8A1,1 0 0,1 20,9H9.82L7,6.18V5H5.82L3.84,3C3.89,3 3.94,3 4,3M20,11A1,1 0 0,1 21,12V16A1,1 0 0,1 20,17H17.82L11.82,11H20M9,7H10V5H9V7M9,15H10V14.27L9,13.27V15M5,13V15H7V13H5Z", pg = "M12 1L3 5V11C3 16.55 6.84 21.74 12 23C17.16 21.74 21 16.55 21 11V5L12 1M15.08 16L12 14.15L8.93 16L9.74 12.5L7.03 10.16L10.61 9.85L12 6.55L13.39 9.84L16.97 10.15L14.26 12.5L15.08 16Z", ug = "M21 11C21 16.55 17.16 21.74 12 23C6.84 21.74 3 16.55 3 11V5L12 1L21 5V11M12 21C15.75 20 19 15.54 19 11.22V6.3L12 3.18L5 6.3V11.22C5 15.54 8.25 20 12 21M15.05 16L11.97 14.15L8.9 16L9.71 12.5L7 10.16L10.58 9.85L11.97 6.55L13.37 9.84L16.95 10.15L14.23 12.5L15.05 16", yg = "M18 21L14 17H17V7H14L18 3L22 7H19V17H22M2 19V17H12V19M2 13V11H9V13M2 7V5H6V7H2Z", wg = "M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z", fg = "M20.8 22.7L17.9 19.8L18.2 21L12 17.3L5.8 21L7.4 14L2 9.2L6.9 8.8L1.1 3L2.4 1.7L22.1 21.4L20.8 22.7M22 9.2L14.8 8.6L12 2L10 6.8L16.9 13.7L22 9.2Z", mg = "M21,9L17,5V8H10V10H17V13M7,11L3,15L7,19V16H14V14H7V11Z", vg = "M9,3L5,7H8V14H10V7H13M16,17V10H14V17H11L15,21L19,17H16Z", gg = "M23,10C23,8.89 22.1,8 21,8H14.68L15.64,3.43C15.66,3.33 15.67,3.22 15.67,3.11C15.67,2.7 15.5,2.32 15.23,2.05L14.17,1L7.59,7.58C7.22,7.95 7,8.45 7,9V19A2,2 0 0,0 9,21H18C18.83,21 19.54,20.5 19.84,19.78L22.86,12.73C22.95,12.5 23,12.26 23,12V10M1,21H5V9H1V21Z", bg = "M5,9V21H1V9H5M9,21A2,2 0 0,1 7,19V9C7,8.45 7.22,7.95 7.59,7.59L14.17,1L15.23,2.06C15.5,2.33 15.67,2.7 15.67,3.11L15.64,3.43L14.69,8H21C22.11,8 23,8.9 23,10V12C23,12.26 22.95,12.5 22.86,12.73L19.84,19.78C19.54,20.5 18.83,21 18,21H9M9,19H18.03L21,12V10H12.21L13.34,4.68L9,9.03V19Z", xg = "M9,3V4H4V6H5V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V6H20V4H15V3H9M9,8H11V17H9V8M13,8H15V17H13V8Z", $g = "M9,16V10H5L12,3L19,10H15V16H9M5,20V18H19V20H5Z", kg = "M17,10.5V7A1,1 0 0,0 16,6H4A1,1 0 0,0 3,7V17A1,1 0 0,0 4,18H16A1,1 0 0,0 17,17V13.5L21,17.5V6.5L17,10.5Z", Cg = "M3 5V19H20V5H3M7 7V9H5V7H7M5 13V11H7V13H5M5 15H7V17H5V15M18 17H9V15H18V17M18 13H9V11H18V13M18 9H9V7H18V9Z", _g = "M4 5V18H21V5H4M14 7V10.5H11V7H14M6 7H9V10.5H6V7M6 16V12.5H9V16H6M11 16V12.5H14V16H11M19 16H16V12.5H19V16M16 10.5V7H19V10.5H16Z", Pg = "M2.28,3L1,4.27L2.47,5.74C2.04,6 1.61,6.29 1.2,6.6L3,9C3.53,8.6 4.08,8.25 4.66,7.93L6.89,10.16C6.15,10.5 5.44,10.91 4.8,11.4L6.6,13.8C7.38,13.22 8.26,12.77 9.2,12.47L11.75,15C10.5,15.07 9.34,15.5 8.4,16.2L12,21L14.46,17.73L17.74,21L19,19.72M12,3C9.85,3 7.8,3.38 5.9,4.07L8.29,6.47C9.5,6.16 10.72,6 12,6C15.38,6 18.5,7.11 21,9L22.8,6.6C19.79,4.34 16.06,3 12,3M12,9C11.62,9 11.25,9 10.88,9.05L14.07,12.25C15.29,12.53 16.43,13.07 17.4,13.8L19.2,11.4C17.2,9.89 14.7,9 12,9Z";
const yu = lg, wu = {
  "zoom-meetings": '<path d="M21.5 12.5c0 .96-.08 1.91-.23 2.83a7.198 7.198 0 01-5.95 5.95 17.527 17.527 0 01-5.66 0 7.198 7.198 0 01-5.95-5.95 17.527 17.527 0 010-5.66c.49-3.05 2.9-5.46 5.95-5.95a17.527 17.527 0 015.66 0c3.05.49 5.46 2.9 5.95 5.95.15.92.23 1.86.23 2.83z" fill="#0b5cff"/><path d="M14.43 14.75c0 .53-.43.96-.96.96H9.29c-1.07 0-1.93-.86-1.93-1.93v-3.54c0-.53.43-.96.96-.96h4.18c1.07 0 1.93.86 1.93 1.93v3.54zM16.87 9.86l-1.41 1.06c-.24.18-.39.47-.39.77v1.61c0 .3.14.59.39.77l1.41 1.06c.32.24.77.01.77-.39v-4.5c0-.4-.45-.62-.77-.39z" fill="#fff"/>',
  "google-meet": '<path fill="#1e88e5" d="M3.5 9.07v5.86l2.09.42 2.1-.42V9.07l-2.1-.42-2.09.42z"/><path d="M17.73 12v5.86c0 .69-.56 1.26-1.26 1.26H7.69l-.42-2.09.42-2.09h5.86v-2.93l2.09-.42 2.09.42z" fill="#4caf50"/><path d="M17.73 6.14V12h-4.19V9.07H7.68l-.42-2.09.42-2.09h8.79c.69 0 1.26.56 1.26 1.26z" fill="#fbc02d"/><path d="M7.69 14.93v4.19H4.76c-.69 0-1.26-.56-1.26-1.26v-2.93h4.19z" fill="#1565c0"/><path fill="#e53935" d="M7.69 4.88v4.19H3.5l4.19-4.19z"/><path fill="#2e7d32" d="M18.15 12l-.42 3.54L13.55 12l4.18-3.54.42 3.54z"/><path d="M21.5 6.19v11.63c0 .35-.41.55-.68.33l-3.09-2.6V8.48l3.09-2.6c.27-.22.68-.03.68.33z" fill="#4caf50"/>',
  "webex-meetings": '<defs><radialGradient id="prefix__b" cx="-951.63" cy="549.04" fx="-951.63" fy="549.04" r=".05" gradientTransform="matrix(-87.16473 -146.04628 -122.52671 73.12756 -15652.44 -179117.85)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#007383"/><stop offset=".41" stop-color="#00717e" stop-opacity=".75"/><stop offset=".87" stop-color="#007281" stop-opacity="0"/></radialGradient><radialGradient id="prefix__c" cx="-952.67" cy="549.07" fx="-952.67" fy="549.07" r=".05" gradientTransform="rotate(-126.7 -53497.341 -58162.752) scale(138.69 -91.09)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#218970"/><stop offset=".46" stop-color="#267e6a"/><stop offset="1" stop-color="#026c51" stop-opacity="0"/></radialGradient><radialGradient id="prefix__d" cx="-952.61" cy="541.2" fx="-952.61" fy="541.2" r=".05" gradientTransform="matrix(-33.8827 -107.79009 -56.09397 17.63256 -1902.72 -112216.84)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#178697"/><stop offset=".41" stop-color="#17838f" stop-opacity=".79"/><stop offset=".87" stop-color="#007281" stop-opacity="0"/></radialGradient><radialGradient id="prefix__e" cx="-949.76" cy="547.24" fx="-949.76" fy="547.24" r=".05" gradientTransform="matrix(-146.98086 -246.36712 -75.94201 45.30646 -98045.43 -258761.67)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#25342f" stop-opacity=".3"/><stop offset="1" stop-color="#25342f" stop-opacity="0"/></radialGradient><radialGradient id="prefix__f" cx="-942.87" cy="563.62" fx="-942.87" fy="563.62" r=".05" gradientTransform="rotate(85.1 -69752.427 38265.017) scale(108.08 -61.22)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#056d4f"/><stop offset=".23" stop-color="#056c4e" stop-opacity=".75"/><stop offset=".6" stop-color="#056c4e" stop-opacity=".3"/><stop offset=".87" stop-color="#056c4f" stop-opacity="0"/></radialGradient><radialGradient id="prefix__g" cx="-940.36" cy="556.77" fx="-940.36" fy="556.77" r=".05" gradientTransform="matrix(68.96997 106.65216 55.9082 -36.1548 33735.1 120422.29)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#22b67b"/><stop offset=".41" stop-color="#24be82"/><stop offset="1" stop-color="#24be82" stop-opacity=".07"/></radialGradient><radialGradient id="prefix__i" cx="-940.77" cy="554.96" fx="-940.77" fy="554.96" r=".05" gradientTransform="rotate(49.69 -177135.555 122596.9) scale(165.85 -165.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></radialGradient><radialGradient id="prefix__j" cx="-944.1" cy="553.18" fx="-944.1" fy="553.18" r=".05" gradientTransform="rotate(48.05 -367132.581 263331.898) scale(336.36 -335.78)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00b8ff"/><stop offset=".75" stop-color="#00b9fc" stop-opacity="0"/></radialGradient><radialGradient id="prefix__k" cx="-951.17" cy="546.23" fx="-951.17" fy="546.23" r=".05" gradientTransform="matrix(-48.64247 -154.74493 -107.10322 33.66679 12252.88 -165563.53)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00bcff" stop-opacity=".76"/><stop offset=".57" stop-color="#00bafc" stop-opacity="0"/></radialGradient><radialGradient id="prefix__l" cx="-953.78" cy="550.07" fx="-953.78" fy="550.07" r=".05" gradientTransform="matrix(-72.9418 -88.45403 -61.91396 51.05608 -35502.54 -112443.2)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5fec50"/><stop offset="1" stop-color="#3cc08e" stop-opacity="0"/></radialGradient><radialGradient id="prefix__m" cx="-954.59" cy="523.18" fx="-954.59" fy="523.18" r=".05" gradientTransform="rotate(-79.11 -8961.313 -26349.067) scale(34.73 -23.99)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#28855b"/><stop offset="1" stop-color="#14795c" stop-opacity="0"/></radialGradient><radialGradient id="prefix__n" cx="-955.7" cy="534.72" fx="-955.7" fy="534.72" r=".05" gradientTransform="matrix(6.00138 -27.99393 -39.07222 -8.37636 26647.75 -22260.21)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#28855b"/><stop offset="1" stop-color="#14795c" stop-opacity="0"/></radialGradient><radialGradient id="prefix__o" cx="-954.99" cy="550.19" fx="-954.99" fy="550.19" r=".05" gradientTransform="matrix(-64.43177 -69.7019 -48.95728 45.25565 -34575.21 -91452.74)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5ff05b"/><stop offset=".81" stop-color="#5de955" stop-opacity="0"/></radialGradient><radialGradient id="prefix__p" cx="-938.28" cy="553.05" fx="-938.28" fy="553.05" r=".05" gradientTransform="matrix(66.96005 51.3617 71.4219 -93.11248 23342.15 99701.75)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".97" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__q" cx="-940.1" cy="550.5" fx="-940.1" fy="550.5" r=".05" gradientTransform="matrix(98.43675 14.71147 21.98813 -147.126 80455.97 94829.3)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".59" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__r" cx="-938.38" cy="551.97" fx="-938.38" fy="551.97" r=".05" gradientTransform="rotate(24.69 -231174.852 140478.806) scale(85.04 -151.66)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".76" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__s" cx="-945.2" cy="560.82" fx="-945.2" fy="560.82" r=".05" gradientTransform="rotate(95.79 -93552.04 41883.384) scale(153.04 -83.75)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".59" stop-color="#123aa8" stop-opacity="0"/><stop offset="1" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__t" cx="-945.05" cy="562.66" fx="-945.05" fy="562.66" r=".05" gradientTransform="rotate(93.66 -104350.43 63182.76) scale(184.18 -65.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__u" cx="-942.29" cy="567.94" fx="-942.29" fy="567.94" r=".05" gradientTransform="matrix(8.78957 97.33394 51.50044 -4.65066 -20951.98 94373.6)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__v" cx="-942.85" cy="562.23" fx="-942.85" fy="562.23" r=".05" gradientTransform="matrix(4.89377 101.88254 84.00315 -4.03496 -42611.94 98338.06)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__w" cx="-941.74" cy="549.74" fx="-941.74" fy="549.74" r=".05" gradientTransform="rotate(-23.2 244205.91 -321749.854) scale(113.62 -222.29)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".71" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__x" cx="-959.91" cy="553.32" fx="-959.91" fy="553.32" r=".05" gradientTransform="matrix(-70.50332 -26.36011 -45.18376 120.84945 -42670.87 -92159.05)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#1a3da0"/><stop offset=".71" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__y" cx="-940.3" cy="551.63" fx="-940.3" fy="551.63" r=".05" gradientTransform="matrix(137.44492 41.41855 41.86 -138.90985 106154.62 115588.85)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#1e3882"/><stop offset=".76" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__A" cx="-940.77" cy="554.96" fx="-940.77" fy="554.96" r=".05" gradientTransform="rotate(49.69 -177135.55 122596.884) scale(165.85 -165.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></radialGradient><radialGradient id="prefix__D" cx="-951.17" cy="546.23" fx="-951.17" fy="546.23" r=".05" gradientTransform="matrix(-48.64247 -154.74493 -107.10322 33.66679 12252.88 -165563.53)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00bcff" stop-opacity=".76"/><stop offset=".57" stop-color="#00bafc" stop-opacity="0"/></radialGradient><linearGradient id="prefix__a" x1="76.14" y1="-95.89" x2="64.37" y2="-99.75" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5cee64"/><stop offset="1" stop-color="#0bf"/></linearGradient><linearGradient id="prefix__h" x1="56.74" y1="-98.36" x2="65.09" y2="-98.43" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient><linearGradient id="prefix__z" x1="61.48" y1="-92.95" x2="67.9" y2="-97.04" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset=".23" stop-color="#1dc4ff"/><stop offset="1" stop-color="#1cc1ff" stop-opacity="0"/></linearGradient><linearGradient id="prefix__B" x1="63.13" y1="-92.11" x2="64.93" y2="-93.74" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#26fbff"/><stop offset=".64" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient><linearGradient id="prefix__C" x1="60.36" y1="-97.78" x2="62.85" y2="-97.95" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#26fbff"/><stop offset=".64" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient></defs><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__a)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__b)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__c)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__d)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__e)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__f)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__g)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__h)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__i)"/><path d="M15.37 5.44c-1.34 0-2.88.45-3.9 2.4-.59 1.12-.89 2.38-1.16 3.63-.09.41-.18.83-.28 1.22v5.66c.51-.14 1.05-.42 1.57-.95 1.96-1.99 2.28-7.2 3.26-8.19.11-.11.23-.18.36-.18.39 0 .7.5.99 1.1.32.67.71 1.43 1.84 1.43.52 0 1.72-.38 1.72-1.85 0-.88-1.47-4.28-4.39-4.28z" fill="url(#prefix__j)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__k)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__l)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__m)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__n)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__o)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="#316aff"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__p)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__q)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__r)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__s)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__t)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__u)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__v)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__w)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__x)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__y)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__z)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__A)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__B)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__C)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__D)"/>',
  "microsoft-teams": '<path d="M15.56 9.91h4.65c.44 0 .8.36.8.8v4.24c0 1.61-1.31 2.92-2.92 2.92h-.01c-1.61 0-2.92-1.31-2.92-2.92v-4.62c0-.23.19-.42.42-.42z" fill="#5059c9"/><circle cx="18.7" cy="7.19" r="1.88" fill="#5059c9"/><circle cx="12.84" cy="6.35" r="2.72" fill="#7b83eb"/><path d="M16.47 9.91H8.8a.79.79 0 00-.77.8v4.83c-.06 2.6 2 4.77 4.6 4.83 2.6-.06 4.67-2.23 4.6-4.83v-4.83a.783.783 0 00-.77-.8z" fill="#7b83eb"/><path d="M3.77 7.4h7.67c.42 0 .77.34.77.77v7.67c0 .42-.34.77-.77.77H3.77a.77.77 0 01-.77-.77V8.17c0-.42.34-.77.77-.77z" fill="#5a62c3"/><path d="M9.62 10.32H8.09v4.18h-.98v-4.18H5.58v-.81h4.04v.81z" fill="#fff"/>'
}, fu = {
  "account-minus": cv,
  "account-plus": lv,
  alert: dv,
  "alert-circle": hv,
  "alert-octagon": pv,
  attachment: Qy,
  back: hu,
  "backup-restore": yv,
  bell: Ky,
  "bell-off": Gy,
  bot: Jv,
  check: Pd,
  "check-all": mv,
  "check-circle-outline": gv,
  "checkbox-blank": bv,
  "checkbox-marked": xv,
  "circle-outline": $v,
  "check-circle": vv,
  close: kv,
  "close-circle": Cv,
  comment: Pv,
  "comment-outline": Mv,
  "content-save": zv,
  delete: Yy,
  "delete-restore": Ev,
  "delete-forever": Zy,
  "dots-vertical": Ov,
  download: Av,
  earth: Rv,
  "emoticon-plus": "M 19 0 L 19 3 L 16 3 L 16 5 L 19 5 L 19 8 L 21 8 L 21 5 L 24 5 L 24 3 L 21 3 L 21 0 L 19 0 z M 12 2 C 6.5 2 2 6.5 2 12 C 2 17.5 6.5 22 12 22 C 17.5 22 22 17.5 22 12 L 20 12 C 20 16.4 16.4 20 12 20 C 7.6 20 4 16.4 4 12 C 4 7.6 7.6 4 12 4 L 12 2 z M 8.5 8 C 7.7 8 7 8.7 7 9.5 C 7 10.3 7.7 11 8.5 11 C 9.3 11 10 10.3 10 9.5 C 10 8.7 9.3 8 8.5 8 z M 15.5 8 C 14.7 8 14 8.7 14 9.5 C 14 10.3 14.7 11 15.5 11 C 16.3 11 17 10.3 17 9.5 C 17 8.7 16.3 8 15.5 8 z M 6.9 14 C 7.7 16 9.7 17.5 12 17.5 C 14.3 17.5 16.3 16 17.1 14 L 6.9 14 z",
  "fit-screen": jv,
  "fit-width": Nv,
  "help-circle": Gv,
  information: Zv,
  magnify: Xv,
  "menu-down": tg,
  "menu-up": eg,
  minus: sg,
  next: uv,
  "open-in-new": ng,
  pencil: ch,
  pin: ag,
  unpin: og,
  plus: Xy,
  "plus-circle-outline": cg,
  poll: fv,
  previous: hu,
  read: Pd,
  restore: Jy,
  unread: Pd,
  send: dg,
  "server-network-off": hg,
  "shield-star": pg,
  "shield-star-outline": ug,
  sort: yg,
  star: wg,
  unstar: fg,
  "swap-horizontal": mg,
  textbox: Qv,
  "thumb-up": gg,
  "thumb-up-outline": bg,
  trashcan: xg,
  video: kg,
  "view-list-outline": Cg,
  "view-module-outline": _g,
  "wifi-off": Pg,
  // Files
  email: Iv,
  file: Tv,
  "file-upload": Bv,
  "file-music": Hv,
  "file-image": Dv,
  "file-video": Uv,
  "file-code": pu,
  "file-xml": pu,
  "file-document": uu,
  "file-word": qv,
  "file-excel": Fv,
  "file-pdf": uu,
  "file-powerpoint": Vv,
  "file-compressed": Wv,
  // Integrations
  meeting: rg,
  box: wv,
  cloud: _v,
  dropbox: Lv,
  "google-drive": Kv,
  onedrive: ig
}, mu = {
  attach: Qy,
  create: Xy,
  "delete-forever": Zy,
  edit: ch,
  modify: ch,
  rename: Sv,
  replace: vg,
  restore: Jy,
  subscribe: Ky,
  trash: Yy,
  unsubscribe: Gy,
  upload: $g,
  version: Yv
}, vu = {
  dropbox: "#0061fe",
  onedrive: "#0078d4",
  box: "#0161d5",
  "google-drive": "#1a73e8",
  zoom: "#4a8cff"
};
function gu(r) {
  return r && r in fu ? fu[r] : "";
}
c(gu, "getIconMapping");
function Mg(r) {
  return r && r in wu ? wu[r] : "";
}
c(Mg, "getSvgMapping");
function zg(r) {
  return r && r in mu ? mu[r] : "";
}
c(zg, "getFileActionIconMapping");
const lt = /* @__PURE__ */ c((r) => r ?? C, "to"), Lp = class Lp extends mi {
  constructor(t) {
    var i;
    if (super(t), t.type !== uo.ATTRIBUTE || t.name !== "part" || ((i = t.strings) == null ? void 0 : i.length) > 2)
      throw new Error(
        "`partMap()` can only be used in the `part` attribute and must be the only section in the attribute."
      );
  }
  render(t) {
    return " " + Object.keys(t).filter((i) => t[i]).join(" ") + " ";
  }
  update(t, [i]) {
    var n, a;
    if (this._previousShadowParts === void 0) {
      this._previousShadowParts = /* @__PURE__ */ new Set(), t.strings !== void 0 && (this._staticShadowParts = new Set(
        t.strings.join(" ").split(/\s/).filter((o) => o !== "")
      ));
      for (const o in i)
        i[o] && !((n = this._staticShadowParts) != null && n.has(o)) && this._previousShadowParts.add(o);
      return this.render(i);
    }
    const s = t.element.part;
    for (const o of this._previousShadowParts)
      o in i || (s.remove(o), this._previousShadowParts.delete(o));
    for (const o in i) {
      const l = !!i[o];
      l !== this._previousShadowParts.has(o) && !((a = this._staticShadowParts) != null && a.has(o)) && (l ? (s.add(o), this._previousShadowParts.add(o)) : (s.remove(o), this._previousShadowParts.delete(o)));
    }
    return dc;
  }
};
c(Lp, "ShadowPartMapDirective");
let lh = Lp;
const Yt = Ui(lh);
const Rp = class Rp extends mi {
  constructor(t) {
    if (super(t), this.it = C, t.type !== uo.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(t) {
    if (t === C || t == null) return this._t = void 0, this.it = t;
    if (t === dc) return t;
    if (typeof t != "string") throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (t === this.it) return this._t;
    this.it = t;
    const i = [t];
    return i.raw = i, this._t = { _$litType$: this.constructor.resultType, strings: i, values: [] };
  }
};
c(Rp, "le");
let ja = Rp;
ja.directiveName = "unsafeHTML", ja.resultType = 1;
const qs = Ui(ja);
const Ip = class Ip extends ja {
};
c(Ip, "pe");
let Ao = Ip;
Ao.directiveName = "unsafeSVG", Ao.resultType = 2;
const bu = Ui(Ao), te = Z`:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]){box-sizing:border-box;text-align:initial;font-size:var(--wy-font-size, var(--wy-size, 1em))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:before,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:after{box-sizing:inherit}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a){text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-40, #006399))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):hover{text-decoration:var(--wy-link-hover-decoration, unset)}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])):hover{text-decoration:none}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(p),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(p){margin-top:0;margin-bottom:calc(1 * var(--wy-size, 1rem))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(label),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(label){cursor:inherit}:where(:host([hidden])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"])[hidden],:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *[hidden]{display:none!important}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where([role=button]),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where([role=button]){cursor:pointer}`, Bh = Z`[part~=wy-icon]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-icon][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon-first]{margin-left:calc(-.5 * var(--wy-size, 1rem))}[part~=wy-icon-last]{margin-right:calc(-.5 * var(--wy-size, 1rem))}[part~=wy-icon-padded]{margin:16.66666667%}[part~=wy-icon-inline]{vertical-align:-.25em}[part~=wy-icon-overlay]{position:absolute;bottom:0;right:0;border-radius:50%}:host(wy-icon-stack),[part~=wy-icon-stack]{display:inline-flex;position:relative;line-height:1}[part~=wy-icon-stack-layer]{position:absolute}[part~=wy-icon-stack-overlay]{position:absolute;bottom:0;right:0;border-radius:50%;width:calc(var(--wy-component-icon-width) / 2);height:calc(var(--wy-component-icon-height) / 2)}[part~=wy-icon-current-color]{fill:currentColor}[part~=wy-icon-state]{transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));align-self:center;justify-self:center;margin:auto;opacity:0}[part~=wy-icon-state][part~=wy-active]{opacity:1}[part~=wy-icon-display]{color:var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));border-radius:var(--wy-component-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem));margin:auto}[part~=wy-icon-display-icon]{color:var(--wy-component-color);--wy-component-icon-width: calc(4 * var(--wy-size, 1rem));--wy-component-icon-height: calc(4 * var(--wy-size, 1rem));padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem))}[part~=wy-icon-display-text],[part~=wy-icon-display-meta]{color:var(--wy-component-color);padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem));text-align:center}[part~=wy-icon-color-primary]{fill:var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-icon-color-secondary]{fill:var(--wy-secondary, var(--wy-secondary-40, #3b6a1c))}[part~=wy-icon-color-tertiary]{fill:var(--wy-tertiary, var(--wy-tertiary-40, #3b6a1c))}[part~=wy-icon-color-surface]{fill:var(--wy-surface, var(--wy-neutral-99, #fcfcff))}[part~=wy-icon-color-surface-variant]{fill:var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb))}[part~=wy-icon-color-error]{fill:var(--wy-error, var(--wy-error-40, #ba1824))}[part~=wy-icon-color-warning]{fill:var(--wy-warning, var(--wy-warning-70, #afb140))}[part~=wy-icon-color-blue]{fill:var(--wy-blue, var(--wy-blue-light, #89a9fc))}[part~=wy-icon-color-indigo]{fill:var(--wy-indigo, var(--wy-indigo-light, #9185de))}[part~=wy-icon-color-purple]{fill:var(--wy-purple, var(--wy-purple-light, #c675b7))}[part~=wy-icon-color-pink]{fill:var(--wy-pink, var(--wy-pink-light, #d57194))}[part~=wy-icon-color-red]{fill:var(--wy-red, var(--wy-red-light, #db726c))}[part~=wy-icon-color-orange]{fill:var(--wy-orange, var(--wy-orange-light, #e89a3a))}[part~=wy-icon-color-yellow]{fill:var(--wy-yellow, var(--wy-yellow-light, #afb140))}[part~=wy-icon-color-green]{fill:var(--wy-green, var(--wy-green-light, #00a38b))}[part~=wy-icon-color-teal]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a8))}[part~=wy-icon-color-cyan]{fill:var(--wy-cyan, var(--wy-cyan-light, #0082a1))}[part~=wy-icon-color-gray]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-icon-color-black]{fill:var(--wy-black, var(--wy-black, #000000))}[part~=wy-icon-color-white]{fill:var(--wy-white, var(--wy-white, #ffffff))}[part*=wy-kind-]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-kind-archive]{fill:var(--wy-orange, var(--wy-orange-light, #e89a3a))}[part~=wy-kind-audio]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a8))}[part~=wy-kind-code]{fill:var(--wy-green, var(--wy-green-light, #00a38b))}[part~=wy-kind-document]{fill:var(--wy-blue, var(--wy-blue-light, #89a9fc))}[part~=wy-kind-email]{fill:var(--wy-red, var(--wy-red-light, #db726c))}[part~=wy-kind-presentation]{fill:var(--wy-orange, var(--wy-orange-light, #e89a3a))}[part~=wy-kind-spreadsheet]{fill:var(--wy-green, var(--wy-green-light, #00a38b))}[part~=wy-kind-image]{fill:var(--wy-pink, var(--wy-pink-light, #d57194))}[part~=wy-kind-text]{fill:var(--wy-cyan, var(--wy-cyan-light, #0082a1))}[part~=wy-kind-video]{fill:var(--wy-purple, var(--wy-purple-light, #c675b7))}[part~=wy-ext-pdf]{fill:var(--wy-red, var(--wy-red-light, #db726c))}[part~=wy-kind-text-icon]{width:calc(1.25 * var(--wy-size, 1rem));height:calc(1.25 * var(--wy-size, 1rem));vertical-align:calc(-.3125 * var(--wy-size, 1rem))}`;
var Sg = Object.defineProperty, Eg = Object.getOwnPropertyDescriptor, Vt = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? Eg(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && Sg(t, i, n), n;
}, "__decorateClass$14"), fn;
let Pt = (fn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.color = "", this.size = 24, this.path = yu, this.inline = !1, this.first = !1, this.last = !1, this.padded = !1, this.layer = !1, this.state = !1, this.active = !1, this.uniqueId = `wy-icon-${So()}`;
  }
  willUpdate(t) {
    t.has("name") && this.name && (this.path = gu(this.name) || yu, this.overlayPath = gu(this.overlayName) || this.overlayPath, this.nativeIconColor = this.color === "native" && vu[this.name] || void 0, this.nativeOverlayColor = this.overlayName && vu[this.overlayName] || void 0);
  }
  render() {
    var d;
    const t = this.kind ? py(this.kind) : this.kind, i = (d = this.ext) != null && d.startsWith(".") ? this.ext.substring(1) : this.ext, s = {
      "wy-icon": !0,
      "wy-icon-current-color": !t && !this.color,
      ["wy-kind-" + t]: !!t,
      ["wy-ext-" + i]: !!i,
      ["wy-icon-color-" + this.color]: !!this.color,
      "wy-icon-first": this.first,
      "wy-icon-last": this.last,
      "wy-icon-padded": this.padded,
      "wy-icon-inline": this.inline,
      "wy-icon-stack-layer": this.layer,
      "wy-icon-state": this.state,
      "wy-active": this.active
    }, n = this.size !== 24, a = this.size / 16, o = n ? `width: var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem))); height: var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem)));` : "", l = this.svg && Mg(this.svg);
    return this.overlayPath ? [
      p`
          <style>
            .icon-mask-bg {
              width: var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem)));
              height: var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem)));
              fill: white;
            }

            .icon-mask {
              width: calc(var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem))));
              height: calc(var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem))));
              ry: calc(var(--wy-border-radius-pill, var(--wy-border-radius, 50%)) * 2);
              x: calc(var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem))) / 2);
              y: calc(var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem))) / 2);
              stroke: black;
              stroke-width: 4px;
              fill: black;
            }
          </style>
        `,
      p`
          <wy-icon-stack style="${o}">
            <svg
              part=${Yt(s)}
              viewBox="0 0 24 24"
              width="${this.size}"
              height="${this.size}"
              style="mask-image: url(#${this.uniqueId}-mask); -webkit-mask-image: url(#${this.uniqueId}-mask);"
            >
              <defs>
                <mask id="${this.uniqueId}-mask">
                  <rect class="icon-mask-bg" />
                  <rect class="icon-mask" />
                </mask>
              </defs>
              ${l ? bu(l) : Wp`
          <path d="${this.path}" style="fill: ${lt(this.nativeIconColor)}" />
        `}
              <!--rect width="24" height="24" fill="transparent" /-->
            </svg>
            <svg part="wy-icon-stack-overlay" viewBox="0 0 24 24" width="${this.size / 2}" height="${this.size / 2}">
              <path d="${this.overlayPath}" style="fill: ${lt(this.nativeOverlayColor)}" />
              <!--rect width="24" height="24" fill="transparent" /-->
            </svg>
          </wy-icon-stack>
        `
    ] : p`
      <svg
        part=${Yt(s)}
        style="${o}"
        viewBox="0 0 24 24"
        width="${this.size}"
        height="${this.size}"
      >
        ${l ? bu(l) : Wp`
          <path d="${this.path}" style="fill: ${lt(this.nativeIconColor)}" />
        `}
        <!--rect width="24" height="24" fill="transparent" /-->
      </svg>
    `;
  }
}, c(fn, "WyIcon"), fn);
Pt.styles = [
  te,
  Bh,
  Z`
      :host {
        display: contents;
      }
    `
];
Vt([
  w()
], Pt.prototype, "name", 2);
Vt([
  w()
], Pt.prototype, "overlayName", 2);
Vt([
  w()
], Pt.prototype, "svg", 2);
Vt([
  w()
], Pt.prototype, "color", 2);
Vt([
  w({ type: Number })
], Pt.prototype, "size", 2);
Vt([
  w()
], Pt.prototype, "kind", 2);
Vt([
  w()
], Pt.prototype, "ext", 2);
Vt([
  w({ attribute: !1 })
], Pt.prototype, "path", 2);
Vt([
  w({ attribute: !1 })
], Pt.prototype, "overlayPath", 2);
Vt([
  w({ type: Boolean })
], Pt.prototype, "inline", 2);
Vt([
  w({ type: Boolean })
], Pt.prototype, "first", 2);
Vt([
  w({ type: Boolean })
], Pt.prototype, "last", 2);
Vt([
  w({ type: Boolean })
], Pt.prototype, "padded", 2);
Vt([
  w({ type: Boolean })
], Pt.prototype, "layer", 2);
Vt([
  w({ type: Boolean })
], Pt.prototype, "state", 2);
Vt([
  w({ type: Boolean })
], Pt.prototype, "active", 2);
Vt([
  D()
], Pt.prototype, "nativeIconColor", 2);
Vt([
  D()
], Pt.prototype, "nativeOverlayColor", 2);
Pt = Vt([
  B("wy-icon")
], Pt);
var mn;
let dh = (mn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this);
  }
  render() {
    return p`<slot></slot>`;
  }
}, c(mn, "WyIconStack"), mn);
dh.styles = [te, Bh];
dh = Vt([
  B("wy-icon-stack")
], dh);
var vn;
let hh = (vn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this);
  }
  render() {
    return p`
      <div part="wy-icon-display-icon">
        <slot></slot>
      </div>
      <div part="wy-icon-display-text">
        <slot name="text"></slot>
      </div>
      <div part="wy-icon-display-meta">
        <slot name="meta"></slot>
      </div>
    `;
  }
}, c(vn, "WyIconDisplay"), vn);
hh.styles = [te, Bh];
hh = Vt([
  B("wy-icon-display")
], hh);
const Og = Z`[part~=wy-progress]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-progress]:not([width]),[part~=wy-progress][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress]:not([height]),[part~=wy-progress][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress-padded]{margin:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem))}[part~=wy-progress-reveal]{opacity:1;transition:width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),margin var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-progress-reveal]{width:0;height:0;opacity:0;margin:0}}[part~=wy-progress][part~=wy-primary]{color:var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-progress-remaining]{fill:none;stroke:var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb))}[part~=wy-progress-done]{fill:none;stroke:currentColor}[part~=wy-spinner]{align-self:center;justify-self:center;margin:auto}[part~=wy-spinner-padded]{margin:calc(1 * var(--wy-size, 1rem))}[part~=wy-spinner-overlay]{position:absolute;left:0;right:0;top:0;bottom:0;margin:auto}[part~=wy-spinner-reveal]{opacity:1;transition:width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),margin var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-spinner-reveal]{width:0;height:0;opacity:0;margin:0}}[part~=wy-spinner-circle]{stroke-dasharray:1,100;stroke-dashoffset:0;transform-origin:center;fill:none!important}[part~=wy-spinner][part~=wy-spin]{animation:wy-rotate 1.4s linear infinite}[part~=wy-spinner-circle][part~=wy-spin]{animation:wy-dash 1.4s ease-in-out infinite,wy-color 2.8s ease-in-out infinite}@keyframes wy-rotate{to{transform:rotate(360deg)}}@keyframes wy-dash{0%{stroke-dasharray:1,100;stroke-dashoffset:0}50%{stroke-dasharray:44.5,100;stroke-dashoffset:-17.5}to{stroke-dasharray:44.5,100;stroke-dashoffset:-62}}@keyframes wy-color{0%,to{stroke:var(--wy-primary, var(--wy-primary-40, #006399))}25%{stroke:var(--wy-primary, var(--wy-primary-40, #006399))}50%{stroke:transparent}75%{stroke:var(--wy-primary, var(--wy-primary-40, #006399))}}`, Ag = Z`[part~=wy-progress]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-progress]:not([width]),[part~=wy-progress][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress]:not([height]),[part~=wy-progress][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress-padded]{margin:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem))}[part~=wy-progress-reveal]{opacity:1;transition:width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),margin var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-progress-reveal]{width:0;height:0;opacity:0;margin:0}}[part~=wy-progress][part~=wy-primary]{color:var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-progress-remaining]{fill:none;stroke:var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb))}[part~=wy-progress-done]{fill:none;stroke:currentColor}`;
var Lg = Object.defineProperty, Rg = Object.getOwnPropertyDescriptor, sr = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? Rg(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && Lg(t, i, n), n;
}, "__decorateClass$13"), gn;
let vi = (gn = class extends j {
  constructor() {
    super(...arguments), this.shadowParts = new Q(this), this.size = 24, this.noSpin = !1, this.padded = !1, this.overlay = !1, this.progress = NaN, this.reveal = !1;
  }
  render() {
    const t = this.noSpin && this.progress && 100 - this.progress || void 0;
    if (t !== void 0) {
      const s = Math.PI * 20, n = {
        "wy-progress": !0,
        "wy-primary": !0,
        "wy-progress-padded": this.padded,
        "wy-progress-reveal": this.reveal
      };
      return p`<svg
        part="${Yt(n)}"
        viewBox="0 0 24 24"
        width=${this.size}
        height=${this.size}
        transform="rotate(-90)"
      >
        <circle
          part="wy-progress-circle wy-progress-remaining"
          cx="12"
          cy="12"
          r=${10}
          stroke-linecap="butt"
          stroke-width="2"
          fill="none"
          stroke="#eee"
        ></circle>
        <circle
          part="wy-progress-circle wy-progress-done"
          cx="12"
          cy="12"
          r=${10}
          stroke-dasharray=${s}
          stroke-dashoffset=${s * t / 100}
          stroke-linecap="butt"
          stroke-width="2"
          fill="none"
          stroke="currentColor"
          path-length="200"
        ></circle>
      </svg>`;
    } else {
      const i = {
        "wy-spinner": !0,
        "wy-spin": !this.noSpin,
        "wy-spinner-overlay": this.overlay,
        "wy-spinner-padded": this.padded,
        "wy-spinner-reveal": this.reveal
      }, s = {
        "wy-spinner-circle": !0,
        "wy-spin": !this.noSpin
      };
      return p`<svg
        part="${Yt(i)}"
        width=${this.size}
        height=${this.size}
        viewBox="0 0 24 24"
        xmlns="http://www.w3.org/2000/svg"
      >
        <circle
          part="${Yt(s)}"
          fill="none"
          cx="12"
          cy="12"
          r="11"
          stroke-linecap="butt"
          stroke-width="2"
        />
      </svg>`;
    }
  }
}, c(gn, "WySpinner"), gn);
vi.styles = [
  te,
  Og,
  Ag,
  Z`
      :host {
        display: contents;
      }
    `
];
sr([
  w({ type: Number })
], vi.prototype, "size", 2);
sr([
  w({ type: Boolean })
], vi.prototype, "noSpin", 2);
sr([
  w({ type: Boolean })
], vi.prototype, "padded", 2);
sr([
  w({ type: Boolean })
], vi.prototype, "overlay", 2);
sr([
  w({ type: Number })
], vi.prototype, "progress", 2);
sr([
  w({ type: Boolean })
], vi.prototype, "reveal", 2);
vi = sr([
  B("wy-spinner")
], vi);
var Ig = Object.defineProperty, Tg = Object.getOwnPropertyDescriptor, Uh = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? Tg(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && Ig(t, i, n), n;
}, "__decorateClass$12"), bn;
let Wa = (bn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.noNetwork = !1, this.handleUpdate = () => this.requestUpdate();
  }
  willUpdate(t) {
    if (t.has("weavy")) {
      const i = t.get("weavy");
      i && i !== this.weavy && i.removeNetworkListener(this.handleUpdate), this.weavy && i !== this.weavy && this.weavy.addNetworkListener(this.handleUpdate);
    }
  }
  render() {
    var t, i, s, n;
    return p`
      <div class="wy-empty">
        ${this.weavy && !this.noNetwork && ((t = this.weavy) == null ? void 0 : t.network.state) === "unreachable" ? p`
              <wy-icon-display>
                <wy-icon name="server-network-off"></wy-icon>
                <span slot="text">${$("The server is offline, try again in a few minutes...")}</span>
                <wy-spinner slot="meta" ?hidden=${!((i = this.weavy) != null && i.network.isPending)}></wy-spinner>
              </wy-icon-display>
            ` : !this.noNetwork && ((s = this.weavy) == null ? void 0 : s.network.state) === "offline" ? p`
              <wy-icon-display>
                <wy-icon name="wifi-off"></wy-icon>
                <span slot="text">${$("You are currently offline.")}</span>
                <wy-spinner slot="meta" ?hidden=${!((n = this.weavy) != null && n.network.isPending)}></wy-spinner>
              </wy-icon-display>
            ` : p`
              <slot>
                <wy-icon-display>
                  <wy-icon name="information"></wy-icon>
                  <slot slot="text" name="title">
                    <span>${$("Nothing to see here yet.")}</span>
                  </slot>
                </wy-icon-display>
              </slot>
            `}
      </div>
    `;
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this.weavy) == null || t.addNetworkListener(this.handleUpdate);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this.weavy) == null || t.removeNetworkListener(this.handleUpdate);
  }
}, c(bn, "WyEmpty"), bn);
Wa.styles = [
  J,
  Z`
      :host {
        display: contents;
      }
    `
];
Uh([
  Qt({ context: Xt, subscribe: !0 }),
  D()
], Wa.prototype, "weavy", 2);
Uh([
  w({ type: Boolean })
], Wa.prototype, "noNetwork", 2);
Wa = Uh([
  B("wy-empty"),
  st()
], Wa);
const xu = /* @__PURE__ */ c((r, t, i) => {
  const s = /* @__PURE__ */ new Map();
  for (let n = t; n <= i; n++) s.set(r[n], n);
  return s;
}, "Jt"), Re = Ui(class extends mi {
  constructor(r) {
    if (super(r), r.type !== uo.CHILD) throw Error("repeat() can only be used in text expressions");
  }
  dt(r, t, i) {
    let s;
    i === void 0 ? i = t : t !== void 0 && (s = t);
    const n = [], a = [];
    let o = 0;
    for (const l of r) n[o] = s ? s(l, o) : o, a[o] = i(l, o), o++;
    return { values: a, keys: n };
  }
  render(r, t, i) {
    return this.dt(r, t, i).values;
  }
  update(r, [t, i, s]) {
    const n = nh(r), { values: a, keys: o } = this.dt(t, i, s);
    if (!Array.isArray(n)) return this.ut = o, a;
    const l = this.ut ?? (this.ut = []), d = [];
    let u, y, m = 0, f = n.length - 1, g = 0, x = a.length - 1;
    for (; m <= f && g <= x; ) if (n[m] === null) m++;
    else if (n[f] === null) f--;
    else if (l[m] === o[g]) d[g] = Cs(n[m], a[g]), m++, g++;
    else if (l[f] === o[x]) d[x] = Cs(n[f], a[x]), f--, x--;
    else if (l[m] === o[x]) d[x] = Cs(n[m], a[x]), _s(r, d[x + 1], n[m]), m++, x--;
    else if (l[f] === o[g]) d[g] = Cs(n[f], a[g]), _s(r, n[m], n[f]), f--, g++;
    else if (u === void 0 && (u = xu(o, g, x), y = xu(l, m, f)), u.has(l[m])) if (u.has(l[f])) {
      const k = y.get(o[g]), S = k !== void 0 ? n[k] : null;
      if (S === null) {
        const P = _s(r, n[m]);
        Cs(P, a[g]), d[g] = P;
      } else d[g] = Cs(S, a[g]), _s(r, n[m], S), n[k] = null;
      g++;
    } else Cd(n[f]), f--;
    else Cd(n[m]), m++;
    for (; g <= x; ) {
      const k = _s(r, d[x + 1]);
      Cs(k, a[g]), d[g++] = k;
    }
    for (; m <= f; ) {
      const k = n[m++];
      k !== null && Cd(k);
    }
    return this.ut = o, qc(r, d), dc;
  }
});
const ph = Ui(class extends mi {
  constructor() {
    super(...arguments), this.key = C;
  }
  render(r, t) {
    return this.key = r, t;
  }
  update(r, [t, i]) {
    return t !== this.key && (qc(r), this.key = t), i;
  }
});
function Ti(r) {
  r.stopPropagation();
}
c(Ti, "inputConsume");
function Fg(r) {
  r.key === "Escape" && (r.preventDefault(), r.stopPropagation(), r.target.value = "", r.target.dispatchEvent(new InputEvent("input", { data: "", inputType: "deleteContent" })));
}
c(Fg, "inputClearOnEscape");
function jc(r) {
  r.key === "Escape" && (r.preventDefault(), r.stopPropagation(), r.target.blur(), r.target.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 })));
}
c(jc, "inputBlurOnEscape");
function Dg(r) {
  r.key === "Enter" && r.target.blur();
}
c(Dg, "inputBlurOnEnter");
function tw(r) {
  r.target.value ? Fg(r) : jc(r);
}
c(tw, "inputClearAndBlurOnEscape");
function ew(r) {
  r.key === "Enter" && (r.preventDefault(), r.stopPropagation(), r.target.click());
}
c(ew, "clickOnEnter");
function Hg(r) {
  r.key === " " && (r.preventDefault(), r.stopPropagation());
}
c(Hg, "consumeOnSpace");
function xe(r) {
  ew(r), Hg(r);
}
c(xe, "clickOnEnterAndConsumeOnSpace");
function je(r) {
  r.key === " " && (r.preventDefault(), r.stopPropagation(), r.target.click());
}
c(je, "clickOnSpace");
function qh(r) {
  ew(r), je(r);
}
c(qh, "clickOnEnterAndSpace");
const Rt = Ui(class extends mi {
  constructor(r) {
    var t;
    if (super(r), r.type !== uo.ATTRIBUTE || r.name !== "class" || ((t = r.strings) == null ? void 0 : t.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(r) {
    return " " + Object.keys(r).filter((t) => r[t]).join(" ") + " ";
  }
  update(r, [t]) {
    var s, n;
    if (this.st === void 0) {
      this.st = /* @__PURE__ */ new Set(), r.strings !== void 0 && (this.nt = new Set(r.strings.join(" ").split(/\s/).filter((a) => a !== "")));
      for (const a in t) t[a] && !((s = this.nt) != null && s.has(a)) && this.st.add(a);
      return this.render(t);
    }
    const i = r.element.classList;
    for (const a of this.st) a in t || (i.remove(a), this.st.delete(a));
    for (const a in t) {
      const o = !!t[a];
      o === this.st.has(a) || (n = this.nt) != null && n.has(a) || (o ? (i.add(a), this.st.add(a)) : (i.remove(a), this.st.delete(a)));
    }
    return dc;
  }
});
function iw(r) {
  const t = [r];
  for (; r && r.parent; )
    r = r.parent, t.push(r);
  return t;
}
c(iw, "getEntityChain");
function sw(r, t, i) {
  return r.type === t && (!i || r.id === i.id);
}
c(sw, "isEntityMatch");
function gl(r, t, i) {
  return iw(r).some((n) => n && sw(n, t, i));
}
c(gl, "isEntityChainMatch");
function rw(r, t, i) {
  return iw(r).find((n) => n && sw(n, t, i));
}
c(rw, "getEntityChainMatch");
function nw(r, t, i, s) {
  const n = rw(r, s);
  return n && n.parent ? gl(n.parent, t, i) : !1;
}
c(nw, "hasEntityChildType");
async function aw(r, t, i) {
  var a, o, l;
  let s;
  if (t && ((a = i.link.app) != null && a.id)) {
    const d = await t.fetch(`/api/apps/${i.link.app.id}`);
    d.ok && (s = (await d.json()).metadata);
  }
  const n = new CustomEvent("wy-link", {
    bubbles: !0,
    composed: !0,
    cancelable: !0,
    detail: {
      link: {
        ...i.link,
        bot: ow(i)
      },
      app_type: ((o = i.link.app) == null ? void 0 : o.type) && wm.get((l = i.link.app) == null ? void 0 : l.type) || qe.Unknown,
      source_name: s == null ? void 0 : s.source_name,
      source_url: s == null ? void 0 : s.source_url,
      source_data: s == null ? void 0 : s.source_data
    }
  });
  return r.dispatchEvent(n);
}
c(aw, "dispatchLinkEvent");
function ow(r) {
  var t, i;
  return (t = r.link.app) != null && t.type && fm.has((i = r.link.app) == null ? void 0 : i.type) && r.actor.is_bot ? r.actor.uid : void 0;
}
c(ow, "getBotName");
function cw(r) {
  const t = r.args;
  switch (r.template) {
    case "**{0}** added *{1}* to **{2}**": {
      const [i, s, n] = t;
      return {
        title: $(pt`${i} added ${s} to ${n}`),
        titleHtml: $(p`<strong>${i}</strong> added <em>${s}</em> to <strong>${n}</strong>`)
      };
    }
    case "**{0}** edited *{1}*": {
      const [i, s] = t;
      return {
        title: $(pt`${i} edited ${s}`),
        titleHtml: $(p`<strong>${i}</strong> edited <em>${s}</em>`)
      };
    }
    case '**{0}** commented on *{1}*: "{2}"': {
      const [i, s, n] = t;
      return {
        title: $(pt`${i} commented on ${s}`),
        titleHtml: $(p`<strong>${i}</strong> commented on <em>${s}</em>`),
        detail: n
      };
    }
    case '**{0}** commented on **{1}**: "{2}"': {
      const [i, s, n] = t;
      return {
        title: $(pt`${i} commented on ${s}`),
        titleHtml: $(p`<strong>${i}</strong> commented on <strong>${s}</strong>`),
        detail: n
      };
    }
    case '**{0}** replied to your post: "{1}"': {
      const [i, s] = t;
      return {
        title: $(pt`${i} replied to your post`),
        titleHtml: $(p`<strong>${i}</strong> replied to your post`),
        detail: s
      };
    }
    case '**{0}** replied to a post: "{1}"': {
      const [i, s] = t;
      return {
        title: $(pt`${i} replied to a post`),
        titleHtml: $(p`<strong>${i}</strong> replied to a post`),
        detail: s
      };
    }
    case '**{0}** mentioned you in a comment: "{1}"': {
      const [i, s] = t;
      return {
        title: $(pt`${i} mentioned you in a comment`),
        titleHtml: $(p`<strong>${i}</strong> mentioned you in a comment`),
        detail: s
      };
    }
    case '**{0}** posted in **{1}**: "{2}"': {
      const [i, s, n] = t;
      return {
        title: $(pt`${i} posted in ${s}`),
        titleHtml: $(p`<strong>${i}</strong> posted in <strong>${s}</strong>`),
        detail: n
      };
    }
    case '**{0}** mentioned you in a post: "{1}"': {
      const [i, s] = t;
      return {
        title: $(pt`${i} mentioned you in a post`),
        titleHtml: $(p`<strong>${i}</strong> mentioned you in a post`),
        detail: s
      };
    }
    case 'New message from **{0}**: "{1}"': {
      const [i, s] = t;
      return {
        title: $(pt`New message from ${i}`),
        titleHtml: $(p`New message from <strong>${i}</strong>`),
        detail: s
      };
    }
    case '**{0}** sent a message in **{1}**: "{2}"': {
      const [i, s, n] = t;
      return {
        title: $(pt`${i} sent a message in ${s}`),
        titleHtml: $(p`<strong>${i}</strong> sent a message in <strong>${s}</strong>`),
        detail: n
      };
    }
    case '**{0}** mentioned you in a message: "{1}"': {
      const [i, s] = t;
      return {
        title: $(pt`${i} mentioned you in a message`),
        titleHtml: $(p`<strong>${i}</strong> mentioned you in a message`),
        detail: s
      };
    }
    case '**{0}** edited a post: "{1}"': {
      const [i, s] = t;
      return {
        title: $(pt`${i} edited a post`),
        titleHtml: $(p`<strong>${i}</strong> edited a post`),
        detail: s
      };
    }
    case "**{0}** liked *{1}*": {
      const [i, s] = t;
      return {
        title: $(pt`${i} liked ${s}`),
        titleHtml: $(p`<strong>${i}</strong> liked <em>${s}</em>`)
      };
    }
    case "**{0}** reacted {2} to *{1}*": {
      const [i, s, n] = t;
      return {
        title: $(pt`${i} reacted ${s} to ${n}`),
        titleHtml: $(p`<strong>${i}</strong> reacted ${s} to <em>${n}</em>`)
      };
    }
    case '**{0}** liked your comment: "{1}"': {
      const [i, s] = t;
      return {
        title: $(pt`${i} liked your comment`),
        titleHtml: $(p`<strong>${i}</strong> liked your comment`),
        detail: s
      };
    }
    case '**{0}** reacted {1} to your comment: "{2}"': {
      const [i, s, n] = t;
      return {
        title: $(pt`${i} reacted ${s} to your comment`),
        titleHtml: $(p`<strong>${i}</strong> reacted ${s} to your comment`),
        detail: n
      };
    }
    case '**{0}** liked your message: "{1}"': {
      const [i, s] = t;
      return {
        title: $(pt`${i} liked your message`),
        titleHtml: $(p`<strong>${i}</strong> liked your message`),
        detail: s
      };
    }
    case '**{0}** reacted {1} to your message: "{2}"': {
      const [i, s, n] = t;
      return {
        title: $(pt`${i} reacted ${s} to your message`),
        titleHtml: $(p`<strong>${i}</strong> reacted ${s} to your message`),
        detail: n
      };
    }
    case '**{0}** liked your post: "{1}"': {
      const [i, s] = t;
      return {
        title: $(pt`${i} liked your post`),
        titleHtml: $(p`<strong>${i}</strong> liked your post`),
        detail: s
      };
    }
    case '**{0}** reacted {1} to your post: "{2}"': {
      const [i, s, n] = t;
      return {
        title: $(pt`${i} reacted ${s} to your post`),
        titleHtml: $(p`<strong>${i}</strong> reacted ${s} to your post`),
        detail: n
      };
    }
    case "**{0}** voted on your poll": {
      const [i] = t;
      return {
        title: $(pt`${i} voted on your poll`),
        titleHtml: $(p`<strong>${i}</strong> voted on your poll`)
      };
    }
    case "**{0}** and **{1}** voted on your poll": {
      const [i, s] = t;
      return {
        title: $(pt`${i} and ${s} voted on your poll`),
        titleHtml: $(p`<strong>${i}</strong> and <strong>${s}</strong> voted on your poll`)
      };
    }
    case "**{0}**, **{1}** and **{2}** voted on your poll": {
      const [i, s, n] = t;
      return {
        title: $(pt`${i}, ${s} and ${n} voted on your poll`),
        titleHtml: $(
          p`<strong>${i}</strong>, <strong>${s}</strong> and <strong>${n}</strong> voted on your poll`
        )
      };
    }
    case "**{0}** and {1} others voted on your poll": {
      const [i, s] = t;
      return {
        title: $(pt`${i} and ${s} others voted on your poll`),
        titleHtml: $(p`<strong>${i}</strong> and ${s} others voted on your poll`)
      };
    }
    default:
      return console.error(`Notification template not found! '${r.template}'`), { title: "", titleHtml: C };
  }
}
c(cw, "getNotificationText");
var Nh = /* @__PURE__ */ ((r) => (r.Active = "active", r.Away = "away", r))(Nh || {});
const jh = Z`:host(wy-avatar){position:relative;display:inline-flex}[part~=wy-avatar-shape]{border-radius:var(--wy-avatar-border-radius, var(--wy-border-radius-pill, var(--wy-border-radius, 50%)))}[part~=wy-avatar-img]{width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));object-fit:cover}[part~=wy-avatar-initials]{background-color:var(--wy-component-avatar-background-color, var(--wy-primary, var(--wy-primary-40, #006399)));color:var(--wy-component-avatar-color, var(--wy-on-primary, var(--wy-white, #ffffff)));width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));display:flex;align-items:center;align-content:center;justify-content:center;justify-items:center;font-size:calc(var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem))))}[part~=wy-avatar-initials-text]{font-size:max(8px,var(--wy-avatar-font-size, .382em));font-weight:var(--wy-avatar-font-weight, var(--wy-font-weight-bold, unset));line-height:1}[part~=wy-avatar-type]{display:flex;position:absolute;z-index:1;bottom:0;right:-8.3333333333%;border-radius:50%;background-color:var(--wy-primary, var(--wy-primary-40, #006399));color:var(--wy-on-primary, var(--wy-white, #ffffff))}:host(wy-avatar-group){position:relative;display:inline-flex;flex-shrink:0;width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)))}[part~=wy-avatar-back]{position:absolute;top:0;left:0}[part~=wy-avatar-front]{position:absolute;bottom:0;right:0}:host(wy-avatar-header){padding:calc(1.5 * var(--wy-size, 1rem));margin-left:auto;margin-right:auto;text-align:center;display:flex;flex-direction:column;justify-content:center;align-items:center}`, lw = Z`[part~=wy-presence]{width:calc(.75 * var(--wy-size, 1rem));height:calc(.75 * var(--wy-size, 1rem));border-radius:50%;position:absolute;bottom:0;right:-5%;box-sizing:border-box}[part~=wy-presence]:not([part~=wy-presence-active]){display:none}[part~=wy-presence]:after{content:\"\";position:absolute;width:100%;height:100%;top:0;left:0;border-radius:inherit;background-color:var(--wy-presence-active, var(--wy-green-light, #00a38b));background-clip:content-box;padding:calc(.125 * var(--wy-size, 1rem));box-sizing:border-box}[part~=wy-presence-mask]{-webkit-mask-image:radial-gradient(circle calc(.75 * var(--wy-size, 1rem)) at bottom calc(.375 * var(--wy-size, 1rem)) right calc(.375 * var(--wy-size, 1rem) - 5%),rgba(0,0,0,0) calc(.375 * var(--wy-size, 1rem)),rgb(0,0,0) calc(.375 * var(--wy-size, 1rem) + 1px));mask-image:radial-gradient(circle calc(.75 * var(--wy-size, 1rem)) at bottom calc(.375 * var(--wy-size, 1rem)) right calc(.375 * var(--wy-size, 1rem) - 5%),#0000 calc(.375 * var(--wy-size, 1rem)),#000 calc(.375 * var(--wy-size, 1rem) + 1px))}[part~=wy-presence-in-text]{position:absolute;bottom:unset;right:unset}[part~=wy-presence-in-text]:after{left:calc(-1 * var(--wy-size, 1rem))}`;
var Vg = Object.defineProperty, Bg = Object.getOwnPropertyDescriptor, Wh = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? Bg(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && Vg(t, i, n), n;
}, "__decorateClass$11"), xn;
let Qa = (xn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.placement = "avatar";
  }
  render() {
    const t = {
      "wy-presence": !0,
      "wy-presence-active": this.status === Nh.Active,
      "wy-presence-in-text": this.placement === "text"
    };
    return p` <span part=${Yt(t)} data-presence-id=${this.id}></span> `;
  }
}, c(xn, "WyPresence"), xn);
Qa.styles = [
  te,
  lw,
  Z`
      :host {
        display: contents;
      }
    `
];
Wh([
  w()
], Qa.prototype, "placement", 2);
Wh([
  w()
], Qa.prototype, "status", 2);
Qa = Wh([
  B("wy-presence")
], Qa);
var Ug = Object.defineProperty, qg = Object.getOwnPropertyDescriptor, ri = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? qg(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && Ug(t, i, n), n;
}, "__decorateClass$10"), $n;
let Fi = ($n = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.size = 32, this.src = "", this.name = "", this.isBot = !1;
  }
  render() {
    const t = this.size / 16;
    let i;
    !this.src && this.name && (i = Vf(this.name));
    const s = {
      "wy-avatar-shape": !0,
      "wy-avatar-img": !!this.src,
      "wy-avatar-initials": !this.src,
      "wy-presence-mask": this.presence === Nh.Active
    };
    return p`
      ${this.src ? p`
            <img
              alt=""
              title="${lt(this.title || this.name)}"
              part=${Yt(s)}
              style="--wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));"
              height="${this.size}"
              width="${this.size}"
              src="${this.src}"
              decoding="async"
              loading="lazy"
            />
          ` : p`
            <div
              part=${Yt(s)}
              style="--wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));"
              title="${lt(this.title || this.name)}"
            >
              <span part="wy-avatar-initials-text">${i}</span>
            </div>
          `}
      ${this.isBot ? p`<wy-icon part="wy-avatar-type" name="bot" size="${this.size / 3 * 1.25}"></wy-icon>` : C}
      ${this.presence && !this.isBot ? p`<wy-presence .status=${this.presence} id=${this.id}></wy-presence>` : C}
    `;
  }
}, c($n, "WyAvatar"), $n);
Fi.styles = [te, jh, lw];
ri([
  w({ type: Number })
], Fi.prototype, "size", 2);
ri([
  w()
], Fi.prototype, "src", 2);
ri([
  w()
], Fi.prototype, "name", 2);
ri([
  w({ type: Boolean, reflect: !0 })
], Fi.prototype, "isBot", 2);
ri([
  w()
], Fi.prototype, "presence", 2);
Fi = ri([
  B("wy-avatar")
], Fi);
var kn;
let Ns = (kn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.size = 32, this.uniqueId = `wy-avatar-${So()}`;
  }
  render() {
    if (!this.user)
      return C;
    const t = this.size / 16, i = (this.members || []).filter((a) => {
      var o;
      return a.id !== ((o = this.user) == null ? void 0 : o.id);
    }).slice(0, 2).reverse(), s = (i == null ? void 0 : i.shift()) || this.user, n = (i == null ? void 0 : i.shift()) || (s !== this.user ? this.user : void 0);
    return [
      p`
        <style>
          :host {
            --wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));
          }

          .avatar-mask-bg {
            width: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            height: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            fill: white;
          }

          .avatar-mask {
            width: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            height: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            ry: var(--wy-avatar-border-radius, var(--wy-border-radius-pill, var(--wy-border-radius, 50%)));
            x: calc(${t / 3} * var(--wy-size, 1rem));
            y: calc(${t / 3} * var(--wy-size, 1rem));
            stroke: black;
            stroke-width: 4px;
            fill: black;
          }
        </style>
      `,
      p`
        <svg>
          <defs>
            <mask id="${this.uniqueId}-mask">
              <rect class="avatar-mask-bg" />
              <rect class="avatar-mask" />
            </mask>
          </defs>
        </svg>
      `,
      p`
        <wy-avatar
          part="wy-avatar-back"
          style="mask-image: url(#${this.uniqueId}-mask); -webkit-mask-image: url(#${this.uniqueId}-mask);"
          .src=${n == null ? void 0 : n.avatar_url}
          .name=${n == null ? void 0 : n.display_name}
          size=${this.size * 2 / 3}
        ></wy-avatar>
        <wy-avatar
          part="wy-avatar-front"
          .src=${s.avatar_url}
          .name=${s.display_name}
          .isBot=${s.is_bot}
          size=${this.size * 2 / 3}
        ></wy-avatar>
      `
    ];
  }
}, c(kn, "WyAvatarGroup"), kn);
Ns.styles = [
  te,
  jh,
  Z`
      :host {
        display: contents;
      }
    `
];
ri([
  w({ type: Number })
], Ns.prototype, "size", 2);
ri([
  w({
    type: Array,
    attribute: !1
  })
], Ns.prototype, "members", 2);
ri([
  Qt({ context: wl, subscribe: !0 }),
  D()
], Ns.prototype, "user", 2);
Ns = ri([
  B("wy-avatar-group")
], Ns);
var Cn;
let uh = (Cn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this);
  }
  render() {
    return p`<slot></slot>`;
  }
}, c(Cn, "WyAvatarHeader"), Cn);
uh.styles = [te, jh];
uh = ri([
  B("wy-avatar-header")
], uh);
const dw = Z`[part~=wy-button]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399));color:var(--wy-component-color);background:var(--wy-component-background-color, transparent);height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;font-size:var(--wy-button-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-button-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));text-align:center;text-decoration:none;vertical-align:middle;cursor:pointer;-webkit-user-select:none;user-select:none;border:var(--wy-button-border-width, var(--wy-border-outline, 0)) solid var(--wy-outline, var(--wy-neutral-variant-50, #72777e));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));display:inline-flex;align-items:center;justify-content:center;gap:var(--wy-button-gap, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));position:relative}[part~=wy-button][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .8);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .5)}[part~=wy-button]:disabled{opacity:var(--wy-opacity-disabled, 38%);cursor:unset;pointer-events:none}[part~=wy-button-state-layer]>*{z-index:3}[part~=wy-button-state-layer]:before{content:\"\";z-index:2;position:absolute;top:0;left:0;right:0;bottom:0;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-button-state-layer]:hover:before{opacity:8%}[part~=wy-button-state-layer]:focus:before,[part~=wy-button-state-layer]:active:before,[part~=wy-button-state-layer][part~=wy-active]:before{opacity:12%}[part~=wy-button-icon]{--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));line-height:1;align-items:center;justify-content:center}[part~=wy-button-icon][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);padding:0;margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .5)}[part~=wy-button-icon][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * -.1)}[part~=wy-button-icon][part~=wy-active]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-button-icon-inline]{height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));width:auto;min-width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));background:var(--wy-component-background-color);color:currentColor;display:flex;padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-button-icon-inline][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);min-width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .25);margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .5)}[part~=wy-button-icon-inline][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * -.1)}[part~=wy-button-inline]{border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:calc(.5 * var(--wy-size, 1rem)) calc(.75 * var(--wy-size, 1rem));margin-inline:calc(-.25 * var(--wy-size, 1rem))}[part~=wy-button-primary]{--wy-component-background-color: var(--wy-primary, var(--wy-primary-40, #006399));--wy-component-color: var(--wy-on-primary, var(--wy-white, #ffffff))}[part~=wy-button-variant]{--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}[part~=wy-button-primary-text]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-button-inherit-color]{--wy-component-color: currentColor}[part~=wy-button-no-color]{--wy-component-color: unset}[part=wy-button-link]{padding:0;color:var(--wy-link-color, var(--wy-primary, var(--wy-primary-40, #006399)));text-decoration:var(--wy-link-decoration, none)}[part=wy-button-link]:hover,[part=wy-button-link]:focus{text-decoration:var(--wy-link-hover-decoration, unset)}[part~=wy-buttons]{display:flex;align-items:center;flex-wrap:wrap;gap:calc(.5 * var(--wy-size, 1rem))}[part~=wy-buttons-reverse]{flex-direction:row-reverse}[part~=wy-buttons-floating]{position:sticky;padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) 0;top:0;height:0;margin-bottom:calc(-1 * var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));z-index:1030;--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}`, hw = Z`.wy-scroll-y{scroll-padding-top:var(--wy-scrollbar-adjust-top, 0);scroll-padding-bottom:var(--wy-scrollbar-adjust-bottom, 0)}.wy-scroll-y{overflow-y:auto;max-height:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-scroll-y:not(body){-webkit-overflow-scrolling:touch}.wy-scroll-y:not(.wy-scroll-x){overflow-x:hidden;touch-action:pan-y}.wy-scroll-x{overflow-x:auto;max-width:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-scroll-x:not(.wy-scroll-y){overflow-y:hidden;touch-action:pan-x}[part~=wy-tabs]{display:flex;overflow-y:hidden;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));flex:1 1 auto}[part~=wy-tabs]{overflow-x:auto;max-width:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-tabs]{scrollbar-width:thin;scrollbar-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) transparent}[part~=wy-tabs]::-webkit-scrollbar{height:.375rem;width:.375rem;background:transparent;z-index:999}[part~=wy-tabs]::-webkit-scrollbar-track{background:transparent}[part~=wy-tabs]::-webkit-scrollbar-thumb{background-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));opacity:75%;border:0 solid transparent;border-radius:0;background-clip:padding-box}[part~=wy-tabs]::-webkit-scrollbar-thumb:hover{background-color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));opacity:75%}[part~=wy-tabs]::-webkit-scrollbar-thumb:window-inactive{background-color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));opacity:50%}[part~=wy-tab]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399));--wy-component-background-color: transparent;color:var(--wy-component-color);background:var(--wy-component-background-color);border:none;border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));display:inline-flex;flex-direction:column;align-items:center;justify-content:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));position:relative;text-align:center;text-decoration:none;cursor:pointer;-webkit-user-select:none;user-select:none}[part~=wy-tab] .wy-tab-icon{position:relative;padding:calc(.25 * var(--wy-size, 1rem)) calc(1 * var(--wy-size, 1rem));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));display:inline-flex}[part~=wy-tab] .wy-tab-icon:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-tab]:hover .wy-tab-icon:before{opacity:8%}[part~=wy-tab]:focus .wy-tab-icon:before,[part~=wy-tab]:active .wy-tab-icon:before,[part~=wy-tab].wy-active .wy-tab-icon:before{opacity:12%}[part~=wy-tab] .wy-tab-label{font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));font-weight:var(--wy-font-weight, unset)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]{padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .5);margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) auto;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]:before{margin:calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * -.25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * 0)}`;
var Ng = Object.defineProperty, jg = Object.getOwnPropertyDescriptor, ni = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? jg(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && Ng(t, i, n), n;
}, "__decorateClass$$"), _n;
let gi = (_n = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this, !1), this.kind = "filled", this.active = !1, this.small = !1, this.disabled = !1;
  }
  render() {
    const t = {
      "wy-button": !0,
      "wy-active": !!this.active,
      "wy-disabled": !!this.disabled,
      "wy-button-inline": this.kind === "inline",
      "wy-button-icon": this.kind === "icon",
      "wy-button-icon-inline": this.kind === "icon-inline",
      "wy-button-link": this.kind === "link",
      "wy-button-primary": this.color === "primary",
      "wy-button-primary-text": this.color === "primary-text",
      "wy-button-inherit-color": this.color === "inherit",
      "wy-button-no-color": this.color === "none",
      "wy-button-variant": this.color === "variant",
      "wy-button-type-submit": this.type === "submit",
      "wy-button-type-reset": this.type === "reset",
      "wy-button-state-layer": this.kind !== "link" && !this.disabled,
      "wy-button-sm": !!this.small,
      "wy-tab": this.kind === "tab",
      "wy-tab-sm": this.kind === "tab" && !!this.small
    };
    return p`
      <button part=${Yt(t)} type=${lt(this.type)} ?disabled=${this.disabled}>
        <slot></slot>
      </button>
    `;
  }
}, c(_n, "WyButton"), _n);
gi.styles = [
  te,
  dw,
  hw,
  Z`
      :host {
        display: contents;
        position: relative;
      }
    `
];
ni([
  w()
], gi.prototype, "type", 2);
ni([
  w()
], gi.prototype, "kind", 2);
ni([
  w({ type: Boolean })
], gi.prototype, "active", 2);
ni([
  w()
], gi.prototype, "color", 2);
ni([
  w({ type: Boolean })
], gi.prototype, "small", 2);
ni([
  w({ type: Boolean, reflect: !0 })
], gi.prototype, "disabled", 2);
gi = ni([
  B("wy-button")
], gi);
var Pn;
let js = (Pn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.tabs = !1, this.floating = !1, this.reverse = !1;
  }
  render() {
    const t = {
      "wy-buttons": !this.tabs,
      "wy-buttons-reverse": this.reverse,
      "wy-tabs": this.tabs,
      "wy-buttons-floating": this.floating
    };
    return p`<div part=${Yt(t)}><slot></slot></div>`;
  }
}, c(Pn, "WyButtons"), Pn);
js.styles = [
  te,
  dw,
  hw,
  Z`
      :host {
        display: contents;
      }
    `
];
ni([
  w({ type: Boolean })
], js.prototype, "tabs", 2);
ni([
  w({ type: Boolean })
], js.prototype, "floating", 2);
ni([
  w({ type: Boolean })
], js.prototype, "reverse", 2);
js = ni([
  B("wy-buttons")
], js);
var Wg = Object.defineProperty, Qg = Object.getOwnPropertyDescriptor, Qh = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? Qg(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && Wg(t, i, n), n;
}, "__decorateClass$_"), Mn;
let Ka = (Mn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.enableSwap = !1;
  }
  createRenderRoot() {
    return this;
  }
  dispatchRemove(t) {
    const i = new CustomEvent("embed-remove", { detail: { id: t } });
    return this.dispatchEvent(i);
  }
  dispatchSwap() {
    const t = new CustomEvent("embed-swap", { detail: {} });
    return this.dispatchEvent(t);
  }
  render() {
    const t = this.embed.type === "photo" && this.embed.provider_name.toLocaleLowerCase() === "giphy", i = !this.embed.html && !t;
    return p`
      <div class="wy-embed-actions">
        ${this.enableSwap ? p`<wy-button kind="icon" @click=${() => this.dispatchSwap()}
              ><wy-icon name="swap-horizontal"></wy-icon
            ></wy-button>` : p`<wy-button class="wy-embed-cycle"></wy-button>`}

        <wy-button kind="icon" @click=${() => this.dispatchRemove(this.embed.id)}
          ><wy-icon name="close-circle"></wy-icon
        ></wy-button>
      </div>

      ${this.embed.type === "audio" ? p`<div class="wy-embed-audio"></div>` : C}
      ${this.embed.type === "video" && this.embed.html ? p`<div class="wy-embed-video"><div>${qs(this.embed.html)}</div></div>` : C}
      ${this.embed.type === "rich" ? p`<div class="wy-embed-rich"></div>` : C}
      ${this.embed.type === "photo" && this.embed.thumbnail_url ? p`
            <div
              class=${Rt({
      "wy-embed-photo": !0,
      "wy-embed-photo-sm": (this.embed.thumbnail_width || 0) < 250
    })}>
              <a href=${this.embed.original_url} target="_blank">
                <img
                  src=${this.embed.thumbnail_url}
                  width=${lt(this.embed.thumbnail_width)}
                  height=${lt(this.embed.thumbnail_height)}
                  alt="" />
              </a>
            </div>
          ` : C}
      ${this.embed.type !== "audio" && this.embed.type !== "video" && this.embed.type !== "rich" && this.embed.type !== "photo" && this.embed.thumbnail_url ? p`
            <div
              class=${Rt({
      "wy-embed-photo": !0,
      "wy-embed-photo-sm": (this.embed.thumbnail_width || 0) < 250
    })}>
              <a href=${this.embed.original_url} target="_blank">
                <img
                  src=${this.embed.thumbnail_url}
                  width=${lt(this.embed.thumbnail_width)}
                  height=${lt(this.embed.thumbnail_height)}
                  alt="" />
              </a>
            </div>
          ` : C}
      ${i ? p` <div class="wy-embed-caption">
            <a class="wy-embed-link" href=${this.embed.original_url} target="_blank">${this.embed.host}</a>
            ${this.embed.title ? p`<div class="wy-embed-title">${this.embed.title}</div>` : C}
            ${this.embed.description ? p`<div class="wy-embed-description">${this.embed.description}</div>` : C}
          </div>` : C}
    `;
  }
}, c(Mn, "WyEmbed"), Mn);
Ka.styles = J;
Qh([
  w({ attribute: !1 })
], Ka.prototype, "embed", 2);
Qh([
  w({ type: Boolean, attribute: !1 })
], Ka.prototype, "enableSwap", 2);
Ka = Qh([
  B("wy-embed")
], Ka);
const bl = /* @__PURE__ */ c((r, t = 3) => {
  const i = [" B", " KB", " MB", " GB", " TB", " PB", " EB", " ZB", " YB"];
  let s = r, n = 0;
  for (; n < i.length - 1 && s >= 1024; )
    s = 100 * s / 1024 / 100, n++;
  return s.toLocaleString(void 0, { maximumSignificantDigits: t }) + i[n];
}, "fileSizeAsString");
function ai(r) {
  return r.lastIndexOf(".") === -1 ? "." : (r.substring(r.lastIndexOf("."), r.length) || r).toLowerCase();
}
c(ai, "getExtension");
function pw(r) {
  switch (r) {
    case ".aac":
    case ".aif":
    case ".aiff":
    case ".au":
    case ".gsm":
    case ".m4a":
    case ".mid":
    case ".midi":
    case ".mka":
    case ".mp3":
    case ".oga":
    case ".ogg":
    case ".ra":
    case ".ram":
    case ".snd":
    case ".spx":
    case ".wav":
    case ".wma":
      return !0;
    default:
      return !1;
  }
}
c(pw, "isAudio");
function Kg(r) {
  switch (r) {
    case ".ai":
    case ".apng":
    case ".bmp":
    case ".emf":
    case ".eps":
    case ".gif":
    case ".heic":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".psd":
    case ".svg":
    case ".tif":
    case ".tiff":
    case ".webp":
    case ".wmf":
      return !0;
    default:
      return !1;
  }
}
c(Kg, "isImage");
function Gg(r) {
  switch (ai(r)) {
    case ".apng":
    case ".bmp":
    case ".gif":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".svg":
    case ".webp":
      return !0;
    default:
      return !1;
  }
}
c(Gg, "isWebImage");
function uw(r) {
  switch (r) {
    case ".3g2":
    case ".asx":
    case ".asf":
    case ".avi":
    case ".flv":
    case ".mk3d":
    case ".mkv":
    case ".mov":
    case ".mp4":
    case ".mpeg":
    case ".mpg":
    case ".ogm":
    case ".ogv":
    case ".ogx":
    case ".qt":
    case ".rm":
    case ".rv":
    case ".smi":
    case ".smil":
    case ".swf":
    case ".webm":
    case ".wmv":
    case ".xaml":
      return !0;
    default:
      return !1;
  }
}
c(uw, "isVideo");
function Yg(r) {
  switch (r) {
    case ".markdown":
    case ".md":
      return !0;
    default:
      return !1;
  }
}
c(Yg, "isMarkdown");
function yw(r) {
  switch (r) {
    case ".htm":
    case ".html":
    case ".xhtml":
    case ".xml":
      return !0;
    default:
      return !1;
  }
}
c(yw, "isMarkup");
function Kh(r) {
  if (yw(r))
    return !0;
  switch (r) {
    case ".as":
    case ".as3":
    case ".asm":
    case ".aspx":
    case ".bat":
    case ".c":
    case ".cc":
    case ".cmake":
    case ".coffee":
    case ".cpp":
    case ".cs":
    case ".css":
    case ".cxx":
    case ".diff":
    case ".erb":
    case ".erl":
    case ".groovy":
    case ".gvy":
    case ".h":
    case ".haml":
    case ".hh":
    case ".hpp":
    case ".hxx":
    case ".java":
    case ".js":
    case ".json":
    case ".jsx":
    case ".less":
    case ".lst":
    case ".m":
    case ".make":
    case ".ml":
    case ".mm":
    case ".out":
    case ".patch":
    case ".php":
    case ".pl":
    case ".plist":
    case ".properties":
    case ".py":
    case ".rb":
    case ".sass":
    case ".scala":
    case ".scm":
    case ".script":
    case ".scss":
    case ".sh":
    case ".sml":
    case ".sql":
    case ".vb":
    case ".vi":
    case ".vim":
    case ".xsd":
    case ".xsl":
    case ".yaml":
    case ".yml":
      return !0;
    default:
      return !1;
  }
}
c(Kh, "isCode");
function ww(r) {
  if (Kh(r) || Yg(r))
    return !0;
  switch (r) {
    case ".txt":
      return !0;
    default:
      return !1;
  }
}
c(ww, "isText");
function vs(r) {
  const t = ai(r);
  if (t === "") return { icon: "file" };
  if (pw(t))
    return { icon: "file-music", color: "indigo" };
  if (Kg(t))
    return { icon: "file-image", color: "cyan" };
  if (uw(t))
    return { icon: "file-video", color: "pink" };
  if (yw(t))
    return { icon: "file-xml", color: "purple" };
  if (Kh(t))
    return { icon: "file-code", color: "purple" };
  if (ww(t))
    return { icon: "file-document" };
  switch (t) {
    case ".7z":
    case ".zip":
      return { icon: "file-compressed", color: "orange" };
    case ".doc":
    case ".docm":
    case ".docx":
    case ".dotm":
    case ".dotx":
      return { icon: "file-word", color: "native" };
    case ".eml":
    case ".msg":
      return { icon: "email", color: "" };
    case ".xls":
    case ".xlsm":
    case ".xlsx":
    case ".xltx":
      return { icon: "file-excel", color: "native" };
    case ".pdf":
      return { icon: "file-pdf", color: "native" };
    case ".ppt":
    case ".pptm":
    case ".pptx":
    case ".potx":
      return { icon: "file-powerpoint", color: "native" };
    case ".pages":
      return { icon: "file", color: "orange" };
    case ".numbers":
      return { icon: "file", color: "green" };
    case ".keynote":
      return { icon: "file", color: "blue" };
  }
  return { icon: "file" };
}
c(vs, "getIcon");
function Zg(r) {
  const t = ai(r);
  return t === "" ? "none" : Gg(t) ? "image" : Kh(t) ? "code" : ww(t) ? "text" : pw(t) ? "audio" : uw(t) ? "video" : "none";
}
c(Zg, "getWebPreviewFormat");
function yo(r) {
  switch (r) {
    case "Google Drive":
      return "google-drive";
    case "Dropbox":
      return "dropbox";
    case "OneDrive":
      return "onedrive";
    case "Box":
      return "box";
    default:
      return "";
  }
}
c(yo, "getProvider");
function Gh(r) {
  let t = "file";
  switch (ai(r)) {
    case ".7z":
    case ".zip":
      t = "archive";
      break;
    case ".aac":
    case ".aif":
    case ".aiff":
    case ".au":
    case ".gsm":
    case ".m4a":
    case ".mid":
    case ".midi":
    case ".mka":
    case ".mp3":
    case ".oga":
    case ".ogg":
    case ".ra":
    case ".ram":
    case ".snd":
    case ".spx":
    case ".wav":
    case ".wma":
      t = "audio";
      break;
    case ".c":
    case ".cgi":
    case ".cpp":
    case ".cs":
    case ".cshtml":
    case ".css":
    case ".html":
    case ".java":
    case ".js":
    case ".json":
    case ".less":
    case ".php":
    case ".pl":
    case ".ps1":
    case ".py":
    case ".rb":
    case ".rs":
    case ".scss":
    case ".sh":
    case ".swift":
    case ".sql":
    case ".ts":
    case ".xml":
    case ".yaml":
    case ".yml":
      t = "code";
      break;
    case ".doc":
    case ".docm":
    case ".docx":
    case ".dotm":
    case ".dotx":
    case ".gdoc":
    case ".pages":
    case ".pdf":
      t = "document";
      break;
    case ".eml":
    case ".msg":
      t = "email";
      break;
    case ".gslides":
    case ".keynote":
    case ".ppt":
    case ".pptm":
    case ".pptx":
    case ".potx":
      t = "presentation";
      break;
    case ".gsheet":
    case ".numbers":
    case ".xls":
    case ".xlsm":
    case ".xlsx":
    case ".xltx":
      t = "spreadsheet";
      break;
    case ".ai":
    case ".apng":
    case ".bmp":
    case ".emf":
    case ".eps":
    case ".gif":
    case ".heic":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".psd":
    case ".svg":
    case ".tif":
    case ".tiff":
    case ".webp":
    case ".wmf":
      t = "image";
      break;
    case ".md":
    case ".markdown":
    case ".txt":
      t = "text";
      break;
    case ".3g2":
    case ".asx":
    case ".asf":
    case ".avi":
    case ".flv":
    case ".mk3d":
    case ".mkv":
    case ".mov":
    case ".mp4":
    case ".mpeg":
    case ".mpg":
    case ".ogm":
    case ".ogv":
    case ".ogx":
    case ".qt":
    case ".rm":
    case ".rv":
    case ".smi":
    case ".smil":
    case ".swf":
    case ".webm":
    case ".wmv":
    case ".xaml":
      t = "video";
      break;
  }
  return t;
}
c(Gh, "getKind");
function Yh(r) {
  const t = r.target, i = t == null ? void 0 : t.value.lastIndexOf(".");
  i === -1 ? t == null || t.select() : i !== void 0 && (t == null || t.setSelectionRange(0, i));
}
c(Yh, "handleSelectFilename");
var Xg = Object.defineProperty, Jg = Object.getOwnPropertyDescriptor, wo = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? Jg(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && Xg(t, i, n), n;
}, "__decorateClass$Z"), zn;
let Di = (zn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.name = "", this.previewUrl = "", this.url = "", this.size = 0;
  }
  render() {
    const t = this.size && this.size > 0 ? bl(this.size) : null, i = ai(this.name), { icon: s } = vs(this.name), n = Gh(this.name), a = yo(this.provider);
    return p`
      <a href=${this.previewUrl || this.url} class="wy-item wy-list-item-lg" target="_blank" title=${this.name}>
        <wy-icon name=${s} .overlayName=${a} size="48" kind=${n} ext=${i}></wy-icon>
        <div class="wy-item-body ">
          <div class="wy-item-title">${this.name}</div>
          ${t ? p`<div class="wy-item-text" title="${t}">${t}</div>` : ""}
        </div>
      </a>
    `;
  }
}, c(zn, "WyAttachment"), zn);
Di.styles = J;
wo([
  w()
], Di.prototype, "name", 2);
wo([
  w()
], Di.prototype, "previewUrl", 2);
wo([
  w()
], Di.prototype, "url", 2);
wo([
  w()
], Di.prototype, "provider", 2);
wo([
  w({ type: Number })
], Di.prototype, "size", 2);
Di = wo([
  B("wy-attachment")
], Di);
const fw = "important", t0 = " !" + fw, Wc = Ui(class extends mi {
  constructor(r) {
    var t;
    if (super(r), r.type !== uo.ATTRIBUTE || r.name !== "style" || ((t = r.strings) == null ? void 0 : t.length) > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(r) {
    return Object.keys(r).reduce((t, i) => {
      const s = r[i];
      return s == null ? t : t + `${i = i.includes("-") ? i : i.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s};`;
    }, "");
  }
  update(r, [t]) {
    const { style: i } = r.element;
    if (this.ft === void 0) return this.ft = new Set(Object.keys(t)), this.render(t);
    for (const s of this.ft) t[s] == null && (this.ft.delete(s), s.includes("-") ? i.removeProperty(s) : i[s] = null);
    for (const s in t) {
      const n = t[s];
      if (n != null) {
        this.ft.add(s);
        const a = typeof n == "string" && n.endsWith(t0);
        s.includes("-") || a ? i.setProperty(s, a ? n.slice(0, -11) : n, a ? fw : "") : i[s] = n;
      }
    }
    return dc;
  }
});
function Qc(r) {
  const t = r;
  t && (t.complete && t.naturalHeight !== 0 ? t.classList.contains("wy-loading") ? t.decode().then(() => {
    t.classList.add("wy-loaded"), t.part.add("wy-loaded");
  }) : (t.classList.add("wy-loading", "wy-loaded"), t.part.add("wy-loading", "wy-loaded")) : (t.classList.add("wy-loading"), t.part.add("wy-loading")));
}
c(Qc, "checkImageLoad");
function Kc(r) {
  const t = r.target;
  t.tagName === "IMG" && t.classList.contains("wy-loading") && !t.classList.contains("wy-loaded") && (t.classList.add("wy-loaded"), t.part.add("wy-loaded"));
}
c(Kc, "imageLoaded");
var e0 = Object.defineProperty, i0 = Object.getOwnPropertyDescriptor, Zh = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? i0(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && e0(t, i, n), n;
}, "__decorateClass$Y"), Sn;
let Ga = (Sn = class extends j {
  constructor() {
    super(...arguments), this.images = [], this.limit = 3;
  }
  //protected exportParts = new ShadowPartsController(this);
  createRenderRoot() {
    return this;
  }
  dispatchFileOpen(t, i) {
    if (t.preventDefault(), !i.is_trashed) {
      const s = new CustomEvent("file-open", { detail: { fileId: i.id } });
      this.dispatchEvent(s);
    }
  }
  render() {
    const t = this.images.length > this.limit ? this.images.length - this.limit : 0, i = this.images.slice(0, this.limit);
    return p`
      <div class="wy-image-grid">
        ${i.map((s, n) => {
      const a = s.width && s.height ? s.width / s.height : 1, o = 64, l = 2, d = a.toPrecision(5), u = (a * o).toPrecision(5) + "px", y = (100 / a).toPrecision(5) + "%", m = s.width + "px", f = s.width && s.width > 0 ? l * s.width + "px" : "none";
      return s.preview_url ? p`
            <a
              href="#"
              @click=${(g) => {
        !g.defaultPrevented && this.dispatchFileOpen(g, s);
      }}
              class="wy-image"
              style=${Wc({
        flexBasis: u,
        flexGrow: d,
        flexShrink: d,
        width: m,
        maxWidth: f
      })}>
              <div class="wy-image-area" style=${Wc({ paddingBottom: y })}>
                <img
                  src=${s.preview_url}
                  ${X(Qc)}
                  @load=${Kc}
                  alt=""
                  loading="lazy"
                  decoding="async" />
                ${n === i.length - 1 && t ? p`<span class="wy-more">+${t}</span>` : ""}
              </div>
            </a>
          ` : C;
    })}
      </div>
    `;
  }
}, c(Sn, "WyImageGrid"), Sn);
Ga.styles = J;
Zh([
  w({ attribute: !1 })
], Ga.prototype, "images", 2);
Zh([
  w({ type: Number })
], Ga.prototype, "limit", 2);
Ga = Zh([
  B("wy-image-grid")
], Ga);
var s0 = Object.defineProperty, r0 = Object.getOwnPropertyDescriptor, Xh = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? r0(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && s0(t, i, n), n;
}, "__decorateClass$X"), En;
let Ya = (En = class extends j {
  constructor() {
    super(...arguments), this.files = [], this.limit = 3;
  }
  //protected exportParts = new ShadowPartsController(this);
  createRenderRoot() {
    return this;
  }
  dispatchFileOpen(t, i) {
    t.preventDefault();
    const s = new CustomEvent("file-open", { detail: { fileId: i.id } });
    return this.dispatchEvent(s);
  }
  render() {
    return p`
      <div class="wy-list wy-list-bordered">
        ${this.files.map((t) => {
      const i = t.size && t.size > 0 ? bl(t.size) : null, s = ai(t.name), { icon: n } = vs(t.name), a = Gh(t.name), o = yo(t.provider);
      return p`
            <a
              @click=${(l) => {
        !l.defaultPrevented && !t.is_trashed && this.dispatchFileOpen(l, t);
      }}
              class="wy-item wy-list-item"
              href="${lt(t.download_url)}"
              title=${t.name}>
              <wy-icon name=${n} .overlayName=${o} size="48" kind=${a} ext=${s}></wy-icon>
              <div class="wy-item-body ">
                <div class="wy-item-title">${t.name}</div>
                ${i ? p`<div class="wy-item-text" title="${i}">${i}</div>` : ""}
              </div>
            </a>
          `;
    })}
      </div>
    `;
  }
}, c(En, "WyAttachmentsList"), En);
Ya.styles = J;
Xh([
  w({ attribute: !1 })
], Ya.prototype, "files", 2);
Xh([
  w({ type: Number })
], Ya.prototype, "limit", 2);
Ya = Xh([
  B("wy-attachments-list")
], Ya);
const Gc = Math.min, Hs = Math.max, Yc = Math.round, Sc = Math.floor, wi = /* @__PURE__ */ c((r) => ({
  x: r,
  y: r
}), "createCoords"), n0 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, a0 = {
  start: "end",
  end: "start"
};
function $u(r, t, i) {
  return Hs(r, Gc(t, i));
}
c($u, "clamp");
function xl(r, t) {
  return typeof r == "function" ? r(t) : r;
}
c(xl, "evaluate");
function Ws(r) {
  return r.split("-")[0];
}
c(Ws, "getSide");
function $l(r) {
  return r.split("-")[1];
}
c($l, "getAlignment");
function mw(r) {
  return r === "x" ? "y" : "x";
}
c(mw, "getOppositeAxis");
function vw(r) {
  return r === "y" ? "height" : "width";
}
c(vw, "getAxisLength");
function Za(r) {
  return ["top", "bottom"].includes(Ws(r)) ? "y" : "x";
}
c(Za, "getSideAxis");
function gw(r) {
  return mw(Za(r));
}
c(gw, "getAlignmentAxis");
function o0(r, t, i) {
  i === void 0 && (i = !1);
  const s = $l(r), n = gw(r), a = vw(n);
  let o = n === "x" ? s === (i ? "end" : "start") ? "right" : "left" : s === "start" ? "bottom" : "top";
  return t.reference[a] > t.floating[a] && (o = Zc(o)), [o, Zc(o)];
}
c(o0, "getAlignmentSides");
function c0(r) {
  const t = Zc(r);
  return [yh(r), t, yh(t)];
}
c(c0, "getExpandedPlacements");
function yh(r) {
  return r.replace(/start|end/g, (t) => a0[t]);
}
c(yh, "getOppositeAlignmentPlacement");
function l0(r, t, i) {
  const s = ["left", "right"], n = ["right", "left"], a = ["top", "bottom"], o = ["bottom", "top"];
  switch (r) {
    case "top":
    case "bottom":
      return i ? t ? n : s : t ? s : n;
    case "left":
    case "right":
      return t ? a : o;
    default:
      return [];
  }
}
c(l0, "getSideList");
function d0(r, t, i, s) {
  const n = $l(r);
  let a = l0(Ws(r), i === "start", s);
  return n && (a = a.map((o) => o + "-" + n), t && (a = a.concat(a.map(yh)))), a;
}
c(d0, "getOppositeAxisPlacements");
function Zc(r) {
  return r.replace(/left|right|bottom|top/g, (t) => n0[t]);
}
c(Zc, "getOppositePlacement");
function h0(r) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...r
  };
}
c(h0, "expandPaddingObject");
function p0(r) {
  return typeof r != "number" ? h0(r) : {
    top: r,
    right: r,
    bottom: r,
    left: r
  };
}
c(p0, "getPaddingObject");
function Xc(r) {
  const {
    x: t,
    y: i,
    width: s,
    height: n
  } = r;
  return {
    width: s,
    height: n,
    top: i,
    left: t,
    right: t + s,
    bottom: i + n,
    x: t,
    y: i
  };
}
c(Xc, "rectToClientRect");
function ku(r, t, i) {
  let {
    reference: s,
    floating: n
  } = r;
  const a = Za(t), o = gw(t), l = vw(o), d = Ws(t), u = a === "y", y = s.x + s.width / 2 - n.width / 2, m = s.y + s.height / 2 - n.height / 2, f = s[l] / 2 - n[l] / 2;
  let g;
  switch (d) {
    case "top":
      g = {
        x: y,
        y: s.y - n.height
      };
      break;
    case "bottom":
      g = {
        x: y,
        y: s.y + s.height
      };
      break;
    case "right":
      g = {
        x: s.x + s.width,
        y: m
      };
      break;
    case "left":
      g = {
        x: s.x - n.width,
        y: m
      };
      break;
    default:
      g = {
        x: s.x,
        y: s.y
      };
  }
  switch ($l(t)) {
    case "start":
      g[o] -= f * (i && u ? -1 : 1);
      break;
    case "end":
      g[o] += f * (i && u ? -1 : 1);
      break;
  }
  return g;
}
c(ku, "computeCoordsFromPlacement");
const u0 = /* @__PURE__ */ c(async (r, t, i) => {
  const {
    placement: s = "bottom",
    strategy: n = "absolute",
    middleware: a = [],
    platform: o
  } = i, l = a.filter(Boolean), d = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let u = await o.getElementRects({
    reference: r,
    floating: t,
    strategy: n
  }), {
    x: y,
    y: m
  } = ku(u, s, d), f = s, g = {}, x = 0;
  for (let k = 0; k < l.length; k++) {
    const {
      name: S,
      fn: P
    } = l[k], {
      x: E,
      y: z,
      data: U,
      reset: O
    } = await P({
      x: y,
      y: m,
      initialPlacement: s,
      placement: f,
      strategy: n,
      middlewareData: g,
      rects: u,
      platform: o,
      elements: {
        reference: r,
        floating: t
      }
    });
    y = E ?? y, m = z ?? m, g = {
      ...g,
      [S]: {
        ...g[S],
        ...U
      }
    }, O && x <= 50 && (x++, typeof O == "object" && (O.placement && (f = O.placement), O.rects && (u = O.rects === !0 ? await o.getElementRects({
      reference: r,
      floating: t,
      strategy: n
    }) : O.rects), {
      x: y,
      y: m
    } = ku(u, f, d)), k = -1);
  }
  return {
    x: y,
    y: m,
    placement: f,
    strategy: n,
    middlewareData: g
  };
}, "computePosition$1");
async function bw(r, t) {
  var i;
  t === void 0 && (t = {});
  const {
    x: s,
    y: n,
    platform: a,
    rects: o,
    elements: l,
    strategy: d
  } = r, {
    boundary: u = "clippingAncestors",
    rootBoundary: y = "viewport",
    elementContext: m = "floating",
    altBoundary: f = !1,
    padding: g = 0
  } = xl(t, r), x = p0(g), S = l[f ? m === "floating" ? "reference" : "floating" : m], P = Xc(await a.getClippingRect({
    element: (i = await (a.isElement == null ? void 0 : a.isElement(S))) == null || i ? S : S.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(l.floating)),
    boundary: u,
    rootBoundary: y,
    strategy: d
  })), E = m === "floating" ? {
    x: s,
    y: n,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, z = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(l.floating)), U = await (a.isElement == null ? void 0 : a.isElement(z)) ? await (a.getScale == null ? void 0 : a.getScale(z)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, O = Xc(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: l,
    rect: E,
    offsetParent: z,
    strategy: d
  }) : E);
  return {
    top: (P.top - O.top + x.top) / U.y,
    bottom: (O.bottom - P.bottom + x.bottom) / U.y,
    left: (P.left - O.left + x.left) / U.x,
    right: (O.right - P.right + x.right) / U.x
  };
}
c(bw, "detectOverflow");
const y0 = /* @__PURE__ */ c(function(r) {
  return r === void 0 && (r = {}), {
    name: "flip",
    options: r,
    async fn(t) {
      var i, s;
      const {
        placement: n,
        middlewareData: a,
        rects: o,
        initialPlacement: l,
        platform: d,
        elements: u
      } = t, {
        mainAxis: y = !0,
        crossAxis: m = !0,
        fallbackPlacements: f,
        fallbackStrategy: g = "bestFit",
        fallbackAxisSideDirection: x = "none",
        flipAlignment: k = !0,
        ...S
      } = xl(r, t);
      if ((i = a.arrow) != null && i.alignmentOffset)
        return {};
      const P = Ws(n), E = Za(l), z = Ws(l) === l, U = await (d.isRTL == null ? void 0 : d.isRTL(u.floating)), O = f || (z || !k ? [Zc(l)] : c0(l)), V = x !== "none";
      !f && V && O.push(...d0(l, k, x, U));
      const q = [l, ...O], N = await bw(t, S), H = [];
      let W = ((s = a.flip) == null ? void 0 : s.overflows) || [];
      if (y && H.push(N[P]), m) {
        const vt = o0(n, o, U);
        H.push(N[vt[0]], N[vt[1]]);
      }
      if (W = [...W, {
        placement: n,
        overflows: H
      }], !H.every((vt) => vt <= 0)) {
        var ft, wt;
        const vt = (((ft = a.flip) == null ? void 0 : ft.index) || 0) + 1, he = q[vt];
        if (he)
          return {
            data: {
              index: vt,
              overflows: W
            },
            reset: {
              placement: he
            }
          };
        let ke = (wt = W.filter((Bt) => Bt.overflows[0] <= 0).sort((Bt, Ct) => Bt.overflows[1] - Ct.overflows[1])[0]) == null ? void 0 : wt.placement;
        if (!ke)
          switch (g) {
            case "bestFit": {
              var ut;
              const Bt = (ut = W.filter((Ct) => {
                if (V) {
                  const pe = Za(Ct.placement);
                  return pe === E || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  pe === "y";
                }
                return !0;
              }).map((Ct) => [Ct.placement, Ct.overflows.filter((pe) => pe > 0).reduce((pe, et) => pe + et, 0)]).sort((Ct, pe) => Ct[1] - pe[1])[0]) == null ? void 0 : ut[0];
              Bt && (ke = Bt);
              break;
            }
            case "initialPlacement":
              ke = l;
              break;
          }
        if (n !== ke)
          return {
            reset: {
              placement: ke
            }
          };
      }
      return {};
    }
  };
}, "flip$1");
async function w0(r, t) {
  const {
    placement: i,
    platform: s,
    elements: n
  } = r, a = await (s.isRTL == null ? void 0 : s.isRTL(n.floating)), o = Ws(i), l = $l(i), d = Za(i) === "y", u = ["left", "top"].includes(o) ? -1 : 1, y = a && d ? -1 : 1, m = xl(t, r);
  let {
    mainAxis: f,
    crossAxis: g,
    alignmentAxis: x
  } = typeof m == "number" ? {
    mainAxis: m,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...m
  };
  return l && typeof x == "number" && (g = l === "end" ? x * -1 : x), d ? {
    x: g * y,
    y: f * u
  } : {
    x: f * u,
    y: g * y
  };
}
c(w0, "convertValueToCoords");
const f0 = /* @__PURE__ */ c(function(r) {
  return r === void 0 && (r = 0), {
    name: "offset",
    options: r,
    async fn(t) {
      var i, s;
      const {
        x: n,
        y: a,
        placement: o,
        middlewareData: l
      } = t, d = await w0(t, r);
      return o === ((i = l.offset) == null ? void 0 : i.placement) && (s = l.arrow) != null && s.alignmentOffset ? {} : {
        x: n + d.x,
        y: a + d.y,
        data: {
          ...d,
          placement: o
        }
      };
    }
  };
}, "offset$1"), m0 = /* @__PURE__ */ c(function(r) {
  return r === void 0 && (r = {}), {
    name: "shift",
    options: r,
    async fn(t) {
      const {
        x: i,
        y: s,
        placement: n
      } = t, {
        mainAxis: a = !0,
        crossAxis: o = !1,
        limiter: l = {
          fn: /* @__PURE__ */ c((S) => {
            let {
              x: P,
              y: E
            } = S;
            return {
              x: P,
              y: E
            };
          }, "fn")
        },
        ...d
      } = xl(r, t), u = {
        x: i,
        y: s
      }, y = await bw(t, d), m = Za(Ws(n)), f = mw(m);
      let g = u[f], x = u[m];
      if (a) {
        const S = f === "y" ? "top" : "left", P = f === "y" ? "bottom" : "right", E = g + y[S], z = g - y[P];
        g = $u(E, g, z);
      }
      if (o) {
        const S = m === "y" ? "top" : "left", P = m === "y" ? "bottom" : "right", E = x + y[S], z = x - y[P];
        x = $u(E, x, z);
      }
      const k = l.fn({
        ...t,
        [f]: g,
        [m]: x
      });
      return {
        ...k,
        data: {
          x: k.x - i,
          y: k.y - s
        }
      };
    }
  };
}, "shift$1");
function kl() {
  return typeof window < "u";
}
c(kl, "hasWindow");
function fo(r) {
  return xw(r) ? (r.nodeName || "").toLowerCase() : "#document";
}
c(fo, "getNodeName");
function Le(r) {
  var t;
  return (r == null || (t = r.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
c(Le, "getWindow");
function Ci(r) {
  var t;
  return (t = (xw(r) ? r.ownerDocument : r.document) || window.document) == null ? void 0 : t.documentElement;
}
c(Ci, "getDocumentElement");
function xw(r) {
  return kl() ? r instanceof Node || r instanceof Le(r).Node : !1;
}
c(xw, "isNode");
function Xe(r) {
  return kl() ? r instanceof Element || r instanceof Le(r).Element : !1;
}
c(Xe, "isElement");
function bi(r) {
  return kl() ? r instanceof HTMLElement || r instanceof Le(r).HTMLElement : !1;
}
c(bi, "isHTMLElement");
function Cu(r) {
  return !kl() || typeof ShadowRoot > "u" ? !1 : r instanceof ShadowRoot || r instanceof Le(r).ShadowRoot;
}
c(Cu, "isShadowRoot");
function uc(r) {
  const {
    overflow: t,
    overflowX: i,
    overflowY: s,
    display: n
  } = Je(r);
  return /auto|scroll|overlay|hidden|clip/.test(t + s + i) && !["inline", "contents"].includes(n);
}
c(uc, "isOverflowElement");
function v0(r) {
  return ["table", "td", "th"].includes(fo(r));
}
c(v0, "isTableElement");
function Cl(r) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return r.matches(t);
    } catch {
      return !1;
    }
  });
}
c(Cl, "isTopLayer");
function Jh(r) {
  const t = tp(), i = Xe(r) ? Je(r) : r;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((s) => i[s] ? i[s] !== "none" : !1) || (i.containerType ? i.containerType !== "normal" : !1) || !t && (i.backdropFilter ? i.backdropFilter !== "none" : !1) || !t && (i.filter ? i.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((s) => (i.willChange || "").includes(s)) || ["paint", "layout", "strict", "content"].some((s) => (i.contain || "").includes(s));
}
c(Jh, "isContainingBlock");
function g0(r) {
  let t = cs(r);
  for (; bi(t) && !Xa(t); ) {
    if (Jh(t))
      return t;
    if (Cl(t))
      return null;
    t = cs(t);
  }
  return null;
}
c(g0, "getContainingBlock");
function tp() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
c(tp, "isWebKit");
function Xa(r) {
  return ["html", "body", "#document"].includes(fo(r));
}
c(Xa, "isLastTraversableNode");
function Je(r) {
  return Le(r).getComputedStyle(r);
}
c(Je, "getComputedStyle$1");
function _l(r) {
  return Xe(r) ? {
    scrollLeft: r.scrollLeft,
    scrollTop: r.scrollTop
  } : {
    scrollLeft: r.scrollX,
    scrollTop: r.scrollY
  };
}
c(_l, "getNodeScroll");
function cs(r) {
  if (fo(r) === "html")
    return r;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    r.assignedSlot || // DOM Element detected.
    r.parentNode || // ShadowRoot detected.
    Cu(r) && r.host || // Fallback.
    Ci(r)
  );
  return Cu(t) ? t.host : t;
}
c(cs, "getParentNode");
function $w(r) {
  const t = cs(r);
  return Xa(t) ? r.ownerDocument ? r.ownerDocument.body : r.body : bi(t) && uc(t) ? t : $w(t);
}
c($w, "getNearestOverflowAncestor");
function Lo(r, t, i) {
  var s;
  t === void 0 && (t = []), i === void 0 && (i = !0);
  const n = $w(r), a = n === ((s = r.ownerDocument) == null ? void 0 : s.body), o = Le(n);
  if (a) {
    const l = wh(o);
    return t.concat(o, o.visualViewport || [], uc(n) ? n : [], l && i ? Lo(l) : []);
  }
  return t.concat(n, Lo(n, [], i));
}
c(Lo, "getOverflowAncestors");
function wh(r) {
  return r.parent && Object.getPrototypeOf(r.parent) ? r.frameElement : null;
}
c(wh, "getFrameElement");
function kw(r) {
  const t = Je(r);
  let i = parseFloat(t.width) || 0, s = parseFloat(t.height) || 0;
  const n = bi(r), a = n ? r.offsetWidth : i, o = n ? r.offsetHeight : s, l = Yc(i) !== a || Yc(s) !== o;
  return l && (i = a, s = o), {
    width: i,
    height: s,
    $: l
  };
}
c(kw, "getCssDimensions");
function ep(r) {
  return Xe(r) ? r : r.contextElement;
}
c(ep, "unwrapElement");
function Or(r) {
  const t = ep(r);
  if (!bi(t))
    return wi(1);
  const i = t.getBoundingClientRect(), {
    width: s,
    height: n,
    $: a
  } = kw(t);
  let o = (a ? Yc(i.width) : i.width) / s, l = (a ? Yc(i.height) : i.height) / n;
  return (!o || !Number.isFinite(o)) && (o = 1), (!l || !Number.isFinite(l)) && (l = 1), {
    x: o,
    y: l
  };
}
c(Or, "getScale");
const b0 = /* @__PURE__ */ wi(0);
function Cw(r) {
  const t = Le(r);
  return !tp() || !t.visualViewport ? b0 : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
c(Cw, "getVisualOffsets");
function x0(r, t, i) {
  return t === void 0 && (t = !1), !i || t && i !== Le(r) ? !1 : t;
}
c(x0, "shouldAddVisualOffsets");
function Qs(r, t, i, s) {
  t === void 0 && (t = !1), i === void 0 && (i = !1);
  const n = r.getBoundingClientRect(), a = ep(r);
  let o = wi(1);
  t && (s ? Xe(s) && (o = Or(s)) : o = Or(r));
  const l = x0(a, i, s) ? Cw(a) : wi(0);
  let d = (n.left + l.x) / o.x, u = (n.top + l.y) / o.y, y = n.width / o.x, m = n.height / o.y;
  if (a) {
    const f = Le(a), g = s && Xe(s) ? Le(s) : s;
    let x = f, k = wh(x);
    for (; k && s && g !== x; ) {
      const S = Or(k), P = k.getBoundingClientRect(), E = Je(k), z = P.left + (k.clientLeft + parseFloat(E.paddingLeft)) * S.x, U = P.top + (k.clientTop + parseFloat(E.paddingTop)) * S.y;
      d *= S.x, u *= S.y, y *= S.x, m *= S.y, d += z, u += U, x = Le(k), k = wh(x);
    }
  }
  return Xc({
    width: y,
    height: m,
    x: d,
    y: u
  });
}
c(Qs, "getBoundingClientRect");
function ip(r, t) {
  const i = _l(r).scrollLeft;
  return t ? t.left + i : Qs(Ci(r)).left + i;
}
c(ip, "getWindowScrollBarX");
function _w(r, t, i) {
  i === void 0 && (i = !1);
  const s = r.getBoundingClientRect(), n = s.left + t.scrollLeft - (i ? 0 : (
    // RTL <body> scrollbar.
    ip(r, s)
  )), a = s.top + t.scrollTop;
  return {
    x: n,
    y: a
  };
}
c(_w, "getHTMLOffset");
function $0(r) {
  let {
    elements: t,
    rect: i,
    offsetParent: s,
    strategy: n
  } = r;
  const a = n === "fixed", o = Ci(s), l = t ? Cl(t.floating) : !1;
  if (s === o || l && a)
    return i;
  let d = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = wi(1);
  const y = wi(0), m = bi(s);
  if ((m || !m && !a) && ((fo(s) !== "body" || uc(o)) && (d = _l(s)), bi(s))) {
    const g = Qs(s);
    u = Or(s), y.x = g.x + s.clientLeft, y.y = g.y + s.clientTop;
  }
  const f = o && !m && !a ? _w(o, d, !0) : wi(0);
  return {
    width: i.width * u.x,
    height: i.height * u.y,
    x: i.x * u.x - d.scrollLeft * u.x + y.x + f.x,
    y: i.y * u.y - d.scrollTop * u.y + y.y + f.y
  };
}
c($0, "convertOffsetParentRelativeRectToViewportRelativeRect");
function k0(r) {
  return Array.from(r.getClientRects());
}
c(k0, "getClientRects");
function C0(r) {
  const t = Ci(r), i = _l(r), s = r.ownerDocument.body, n = Hs(t.scrollWidth, t.clientWidth, s.scrollWidth, s.clientWidth), a = Hs(t.scrollHeight, t.clientHeight, s.scrollHeight, s.clientHeight);
  let o = -i.scrollLeft + ip(r);
  const l = -i.scrollTop;
  return Je(s).direction === "rtl" && (o += Hs(t.clientWidth, s.clientWidth) - n), {
    width: n,
    height: a,
    x: o,
    y: l
  };
}
c(C0, "getDocumentRect");
function _0(r, t) {
  const i = Le(r), s = Ci(r), n = i.visualViewport;
  let a = s.clientWidth, o = s.clientHeight, l = 0, d = 0;
  if (n) {
    a = n.width, o = n.height;
    const u = tp();
    (!u || u && t === "fixed") && (l = n.offsetLeft, d = n.offsetTop);
  }
  return {
    width: a,
    height: o,
    x: l,
    y: d
  };
}
c(_0, "getViewportRect");
function P0(r, t) {
  const i = Qs(r, !0, t === "fixed"), s = i.top + r.clientTop, n = i.left + r.clientLeft, a = bi(r) ? Or(r) : wi(1), o = r.clientWidth * a.x, l = r.clientHeight * a.y, d = n * a.x, u = s * a.y;
  return {
    width: o,
    height: l,
    x: d,
    y: u
  };
}
c(P0, "getInnerBoundingClientRect");
function _u(r, t, i) {
  let s;
  if (t === "viewport")
    s = _0(r, i);
  else if (t === "document")
    s = C0(Ci(r));
  else if (Xe(t))
    s = P0(t, i);
  else {
    const n = Cw(r);
    s = {
      x: t.x - n.x,
      y: t.y - n.y,
      width: t.width,
      height: t.height
    };
  }
  return Xc(s);
}
c(_u, "getClientRectFromClippingAncestor");
function Pw(r, t) {
  const i = cs(r);
  return i === t || !Xe(i) || Xa(i) ? !1 : Je(i).position === "fixed" || Pw(i, t);
}
c(Pw, "hasFixedPositionAncestor");
function M0(r, t) {
  const i = t.get(r);
  if (i)
    return i;
  let s = Lo(r, [], !1).filter((l) => Xe(l) && fo(l) !== "body"), n = null;
  const a = Je(r).position === "fixed";
  let o = a ? cs(r) : r;
  for (; Xe(o) && !Xa(o); ) {
    const l = Je(o), d = Jh(o);
    !d && l.position === "fixed" && (n = null), (a ? !d && !n : !d && l.position === "static" && !!n && ["absolute", "fixed"].includes(n.position) || uc(o) && !d && Pw(r, o)) ? s = s.filter((y) => y !== o) : n = l, o = cs(o);
  }
  return t.set(r, s), s;
}
c(M0, "getClippingElementAncestors");
function z0(r) {
  let {
    element: t,
    boundary: i,
    rootBoundary: s,
    strategy: n
  } = r;
  const o = [...i === "clippingAncestors" ? Cl(t) ? [] : M0(t, this._c) : [].concat(i), s], l = o[0], d = o.reduce((u, y) => {
    const m = _u(t, y, n);
    return u.top = Hs(m.top, u.top), u.right = Gc(m.right, u.right), u.bottom = Gc(m.bottom, u.bottom), u.left = Hs(m.left, u.left), u;
  }, _u(t, l, n));
  return {
    width: d.right - d.left,
    height: d.bottom - d.top,
    x: d.left,
    y: d.top
  };
}
c(z0, "getClippingRect");
function S0(r) {
  const {
    width: t,
    height: i
  } = kw(r);
  return {
    width: t,
    height: i
  };
}
c(S0, "getDimensions");
function E0(r, t, i) {
  const s = bi(t), n = Ci(t), a = i === "fixed", o = Qs(r, !0, a, t);
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const d = wi(0);
  if (s || !s && !a)
    if ((fo(t) !== "body" || uc(n)) && (l = _l(t)), s) {
      const f = Qs(t, !0, a, t);
      d.x = f.x + t.clientLeft, d.y = f.y + t.clientTop;
    } else n && (d.x = ip(n));
  const u = n && !s && !a ? _w(n, l) : wi(0), y = o.left + l.scrollLeft - d.x - u.x, m = o.top + l.scrollTop - d.y - u.y;
  return {
    x: y,
    y: m,
    width: o.width,
    height: o.height
  };
}
c(E0, "getRectRelativeToOffsetParent");
function Md(r) {
  return Je(r).position === "static";
}
c(Md, "isStaticPositioned");
function Pu(r, t) {
  if (!bi(r) || Je(r).position === "fixed")
    return null;
  if (t)
    return t(r);
  let i = r.offsetParent;
  return Ci(r) === i && (i = i.ownerDocument.body), i;
}
c(Pu, "getTrueOffsetParent");
function Mw(r, t) {
  const i = Le(r);
  if (Cl(r))
    return i;
  if (!bi(r)) {
    let n = cs(r);
    for (; n && !Xa(n); ) {
      if (Xe(n) && !Md(n))
        return n;
      n = cs(n);
    }
    return i;
  }
  let s = Pu(r, t);
  for (; s && v0(s) && Md(s); )
    s = Pu(s, t);
  return s && Xa(s) && Md(s) && !Jh(s) ? i : s || g0(r) || i;
}
c(Mw, "getOffsetParent");
const O0 = /* @__PURE__ */ c(async function(r) {
  const t = this.getOffsetParent || Mw, i = this.getDimensions, s = await i(r.floating);
  return {
    reference: E0(r.reference, await t(r.floating), r.strategy),
    floating: {
      x: 0,
      y: 0,
      width: s.width,
      height: s.height
    }
  };
}, "getElementRects");
function A0(r) {
  return Je(r).direction === "rtl";
}
c(A0, "isRTL");
const L0 = {
  convertOffsetParentRelativeRectToViewportRelativeRect: $0,
  getDocumentElement: Ci,
  getClippingRect: z0,
  getOffsetParent: Mw,
  getElementRects: O0,
  getClientRects: k0,
  getDimensions: S0,
  getScale: Or,
  isElement: Xe,
  isRTL: A0
};
function zw(r, t) {
  return r.x === t.x && r.y === t.y && r.width === t.width && r.height === t.height;
}
c(zw, "rectsAreEqual");
function R0(r, t) {
  let i = null, s;
  const n = Ci(r);
  function a() {
    var l;
    clearTimeout(s), (l = i) == null || l.disconnect(), i = null;
  }
  c(a, "cleanup");
  function o(l, d) {
    l === void 0 && (l = !1), d === void 0 && (d = 1), a();
    const u = r.getBoundingClientRect(), {
      left: y,
      top: m,
      width: f,
      height: g
    } = u;
    if (l || t(), !f || !g)
      return;
    const x = Sc(m), k = Sc(n.clientWidth - (y + f)), S = Sc(n.clientHeight - (m + g)), P = Sc(y), z = {
      rootMargin: -x + "px " + -k + "px " + -S + "px " + -P + "px",
      threshold: Hs(0, Gc(1, d)) || 1
    };
    let U = !0;
    function O(V) {
      const q = V[0].intersectionRatio;
      if (q !== d) {
        if (!U)
          return o();
        q ? o(!1, q) : s = setTimeout(() => {
          o(!1, 1e-7);
        }, 1e3);
      }
      q === 1 && !zw(u, r.getBoundingClientRect()) && o(), U = !1;
    }
    c(O, "handleObserve");
    try {
      i = new IntersectionObserver(O, {
        ...z,
        // Handle <iframe>s
        root: n.ownerDocument
      });
    } catch {
      i = new IntersectionObserver(O, z);
    }
    i.observe(r);
  }
  return c(o, "refresh"), o(!0), a;
}
c(R0, "observeMove");
function Sw(r, t, i, s) {
  s === void 0 && (s = {});
  const {
    ancestorScroll: n = !0,
    ancestorResize: a = !0,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: l = typeof IntersectionObserver == "function",
    animationFrame: d = !1
  } = s, u = ep(r), y = n || a ? [...u ? Lo(u) : [], ...Lo(t)] : [];
  y.forEach((P) => {
    n && P.addEventListener("scroll", i, {
      passive: !0
    }), a && P.addEventListener("resize", i);
  });
  const m = u && l ? R0(u, i) : null;
  let f = -1, g = null;
  o && (g = new ResizeObserver((P) => {
    let [E] = P;
    E && E.target === u && g && (g.unobserve(t), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var z;
      (z = g) == null || z.observe(t);
    })), i();
  }), u && !d && g.observe(u), g.observe(t));
  let x, k = d ? Qs(r) : null;
  d && S();
  function S() {
    const P = Qs(r);
    k && !zw(k, P) && i(), k = P, x = requestAnimationFrame(S);
  }
  return c(S, "frameLoop"), i(), () => {
    var P;
    y.forEach((E) => {
      n && E.removeEventListener("scroll", i), a && E.removeEventListener("resize", i);
    }), m == null || m(), (P = g) == null || P.disconnect(), g = null, d && cancelAnimationFrame(x);
  };
}
c(Sw, "autoUpdate");
const Ew = f0, Ow = m0, Aw = y0, Lw = /* @__PURE__ */ c((r, t, i) => {
  const s = /* @__PURE__ */ new Map(), n = {
    platform: L0,
    ...i
  }, a = {
    ...n.platform,
    _c: s
  };
  return u0(r, t, {
    ...n,
    platform: a
  });
}, "computePosition");
function I0(r, t, i, s, n, a, o) {
  return new bt(r.queryClient, {
    mutationFn: /* @__PURE__ */ c(async () => await r.fetch(`/api/${n}/${s}/reactions`, {
      method: a ? "POST" : "DELETE",
      body: JSON.stringify({ content: a })
    }), "mutationFn"),
    onMutate: /* @__PURE__ */ c(() => {
      const l = i === "apps" && n === "posts" ? [n, t] : [i, t, n];
      _t(r.queryClient, l, s, (d) => {
        Ro(d, a, o);
      });
    }, "onMutate")
  });
}
c(I0, "reactionMutation");
function T0(r, t, i) {
  return {
    queryKey: [t, i, "reactions"],
    enabled: !1,
    queryFn: /* @__PURE__ */ c(async () => await (await r.fetch("/api/" + t + "/" + i + "/reactions")).json(), "queryFn")
  };
}
c(T0, "getReactionListOptions");
function Ro(r, t, i) {
  var s;
  return !t && !((s = r.reactions) != null && s.data) || (r.reactions || (r.reactions = { count: 0, data: [] }), r.reactions.data || (r.reactions.data = []), t ? r.reactions.data = [
    ...r.reactions.data.filter((n) => {
      var a;
      return ((a = n.created_by) == null ? void 0 : a.id) !== i.id;
    }),
    { content: t, created_by: i }
  ] : r.reactions.data && (r.reactions.data = [...r.reactions.data.filter((n) => {
    var a;
    return ((a = n.created_by) == null ? void 0 : a.id) !== i.id;
  })])), r;
}
c(Ro, "updateReaction");
var F0 = Object.defineProperty, D0 = Object.getOwnPropertyDescriptor, sp = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? D0(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && F0(t, i, n), n;
}, "__decorateClass$W"), On;
let Ja = (On = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.noPadding = !1, this.show = !1, this.viewportRef = rt();
  }
  close() {
    var t, i, s;
    this.show = !1;
    try {
      (t = this.viewportRef.value) != null && t.popover ? (i = this.viewportRef.value) == null || i.hidePopover() : (s = this.viewportRef.value) == null || s.close();
    } catch {
    }
  }
  handleClose(t) {
    (t.type === "toggle" && t.newState === "closed" || t.type === "close") && (this.show = !1, this.dispatchEvent(new CustomEvent("close")), this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 })));
  }
  willUpdate(t) {
    super.willUpdate(t);
  }
  render() {
    return p`
      <dialog class="wy-dialog" tabindex="0" ${X(this.viewportRef)} popover>
        <div class="wy-sheet ${this.show ? "wy-show" : ""}">
          <slot name="header">
            <header class="wy-appbars">
              <nav class="wy-appbar">
                <wy-button kind="icon" @click=${() => this.close()}>
                  <wy-icon name="close"></wy-icon>
                </wy-button>
                <slot name="appbar-text" class="wy-appbar-text"></slot>
                <slot name="appbar-buttons" class="wy-appbar-buttons wy-appbar-buttons-last"></slot>
              </nav>
            </header>
          </slot>
          <div class="wy-sheet-body wy-scroll-y ${this.noPadding ? "wy-sheet-no-padding" : ""}">
            <slot></slot>
          </div>
        </div>
      </dialog>
    `;
  }
  updated(t) {
    var i, s, n, a, o, l, d;
    if (t.has("show"))
      try {
        this.show ? (i = this.viewportRef.value) != null && i.popover ? (s = this.viewportRef.value) == null || s.showPopover() : (n = this.viewportRef.value) == null || n.show() : (a = this.viewportRef.value) != null && a.popover ? (o = this.viewportRef.value) == null || o.hidePopover() : (l = this.viewportRef.value) == null || l.close();
      } catch {
      }
    t.has("show") && this.show && ((d = this.viewportRef.value) == null || d.focus());
  }
  firstUpdated(t) {
    var i;
    (i = this.viewportRef.value) == null || i.addEventListener(
      this.viewportRef.value.popover ? "toggle" : "close",
      (s) => this.handleClose(s)
    );
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.close();
  }
}, c(On, "WySheet"), On);
Ja.styles = [
  J,
  Z`
      :host {
        display: contents;
      }
    `
];
sp([
  w({ type: Boolean })
], Ja.prototype, "noPadding", 2);
sp([
  w({ type: Boolean })
], Ja.prototype, "show", 2);
Ja = sp([
  B("wy-sheet")
], Ja);
const H0 = Z`[part~=wy-reaction]{font-size:calc(1.125 * var(--wy-size, 1rem))}[part~=wy-reactions]{display:inline-flex;align-items:center;column-gap:calc(.25 * var(--wy-size, 1rem))}[part~=wy-reactions] :first-child:not(:only-child){margin-left:calc(.25 * var(--wy-size, 1rem))}[part~=wy-reactions] :last-child:not(:only-child){margin-right:calc(.25 * var(--wy-size, 1rem))}[part~=wy-reaction-count]{margin:0 calc(.25 * var(--wy-size, 1rem)) 0;line-height:1;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-reaction-menu]{width:max-content;position:absolute;z-index:1000;border:none;--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;margin:0;text-align:left;background-clip:padding-box;box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));overflow:hidden;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));font-size:calc(1.25 * var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))))}[part~=wy-reaction-picker]{display:flex;flex-direction:row;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-reactions-line]{display:flex;align-items:center;padding-left:calc(.1875 * var(--wy-size, 1rem));padding-right:calc(.1875 * var(--wy-size, 1rem));gap:calc(.1875 * var(--wy-size, 1rem));justify-content:end}[part~=wy-reactions-line-reverse]{flex-direction:row-reverse;justify-content:start}[part~=wy-reactions-line-bottom]{position:absolute;bottom:calc(-1 * var(--wy-size, 1rem));right:calc(.25 * var(--wy-size, 1rem));z-index:1}[part~=wy-reactions-line-below]{position:relative;height:0;min-height:0;max-height:0;margin:calc(var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) - var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(-1 * var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))) calc(-1 * var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));padding-left:calc(.125 * var(--wy-size, 1rem));padding-right:calc(.125 * var(--wy-size, 1rem));gap:calc(.125 * var(--wy-size, 1rem));flex:1 0 auto;justify-content:flex-end}`, Rw = Z`.wy-item{--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));position:relative;display:flex;align-items:center;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));text-decoration:none}.wy-list-item{min-height:calc(3 * var(--wy-size, 1rem))}.wy-list-item-lg{min-height:calc(4.5 * var(--wy-size, 1rem))}.wy-item-inner{display:flex;align-items:center;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));flex:1 1 100%}.wy-item-body{width:100%;min-width:0}.wy-item-rows{display:flex;flex-direction:column;width:100%;row-gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));min-width:0}.wy-item-rows:only-child{margin-inline-start:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-item-rows-compact{row-gap:0}.wy-item-rows-single{margin-inline-start:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-item-title{color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset))}.wy-item-title{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-item-title-lg{color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset))}.wy-item-title-lg{display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;overflow:hidden}.wy-item-text{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}.wy-item-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-item-text .wy-icon{width:calc(1.25 * var(--wy-size, 1rem));height:calc(1.25 * var(--wy-size, 1rem));vertical-align:calc(-.3125 * var(--wy-size, 1rem))}.wy-item-quote{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e))}.wy-item-quote:before,.wy-item-quote:after{content:'\"'}.wy-item-actions{--wy-component-background-color: transparent;display:flex;align-items:center;justify-items:flex-end;flex:0 0 auto;margin:calc(-.25 * var(--wy-size, 1rem))}.wy-item-top{align-self:flex-start}.wy-item-actions-bottom{align-self:flex-start;margin-block:calc(-.5 * var(--wy-size, 1rem))}.wy-item-row{display:flex;align-items:center;column-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}.wy-item-row .wy-item-title,.wy-item-row .wy-item-text{margin-right:auto}.wy-item-row .wy-meta{white-space:nowrap}.wy-item-right{margin-left:auto}.wy-item-hover{-webkit-user-select:none;user-select:none;cursor:pointer}.wy-item-hover:hover,.wy-item-hover:focus{--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);text-decoration:none}.wy-item-hover:active{--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-item-hover.wy-disabled,.wy-item-hover:disabled{opacity:var(--wy-opacity-disabled, 38%);pointer-events:none}.wy-item-hover.wy-active{--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-90, #cde5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-primary-10, #001d32));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-color:var(--wy-component-background-color)}.wy-item-trashed{text-decoration:line-through;opacity:var(--wy-opacity-disabled, 38%)}.wy-item-trashed.wy-item-hover:hover{opacity:1}`, Iw = Z`.wy-emoji-icon{display:inline-flex;justify-content:center;align-items:center;line-height:1;width:1em;height:1em;font-size:calc(1.25 * var(--wy-size, 1rem))}.wy-emoji-icon-sm{width:calc(1.125 * var(--wy-size, 1rem));height:calc(1.125 * var(--wy-size, 1rem));font-size:calc(1.125 * var(--wy-size, 1rem))}`;
var V0 = Object.defineProperty, B0 = Object.getOwnPropertyDescriptor, jt = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? B0(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && V0(t, i, n), n;
}, "__decorateClass$V"), An;
let It = (An = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.directionX = "left", this.directionY = "up", this.small = !1, this.reactions = [], this.emojis = [], this.parentType = "apps", this.entityType = "messages", this.line = !1, this.lineReverse = !1, this.lineBottom = !1, this.lineBelow = !1, this._placement = "bottom-start", this.show = !1, this.showSheet = !1, this.buttonRef = rt(), this.menuRef = rt(), this.reactionListQuery = new be(this), this._documentClickHandler = (t) => {
      var i;
      this.show && (t.preventDefault(), (i = this.menuRef.value) != null && i.popover || (this.show = !1));
    }, this.handleReaction = async (t) => {
      var s;
      if (!this.weavy || !this.parentId || !this.user)
        return;
      const i = I0(
        this.weavy,
        this.parentId,
        this.parentType,
        this.entityId,
        this.entityType,
        this.reactedEmoji === t ? void 0 : t,
        this.user
      );
      this.reactedEmoji = t, await i.mutate(), (s = this.reactionListQuery.observer) == null || s.refetch();
    };
  }
  handleClose(t) {
    (t.type === "toggle" && t.newState === "closed" || t.type === "click") && (this.show = !1, this.dispatchEvent(new CustomEvent("close")), this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 })));
  }
  handleClickToggle(t) {
    t.stopPropagation(), this.show = !this.show;
  }
  handleReactionsClick() {
    var t;
    (t = this.reactionListQuery.observer) == null || t.refetch(), this.showSheet = !this.showSheet, this.show = !1;
  }
  willUpdate(t) {
    var i, s, n, a, o;
    if (super.willUpdate(t), (t.has("weavy") || t.has("entityId") || t.has("showSheet")) && this.weavy && this.entityId && this.showSheet && this.reactionListQuery.trackQuery(T0(this.weavy, this.entityType, this.entityId)), (t.has("reactions") || t.has("user")) && this.user && (this.reactedEmoji = (s = (i = this.reactions) == null ? void 0 : i.find((l) => {
      var d, u;
      return ((d = l.created_by) == null ? void 0 : d.id) === ((u = this.user) == null ? void 0 : u.id);
    })) == null ? void 0 : s.content), (t.has("directionX") || t.has("directionY")) && (this._placement = this.directionX === "right" && this.directionY === "down" ? "bottom-start" : this.directionX === "left" && this.directionY === "down" ? "bottom-end" : this.directionX === "right" && this.directionY === "up" ? "top-start" : "top-end"), t.has("show") && (this.show && !this._computePositionCleanup && this.buttonRef.value && this.menuRef.value ? this._computePositionCleanup = Sw(this.buttonRef.value, this.menuRef.value, () => {
      requestAnimationFrame(() => {
        this.buttonRef.value && this.menuRef.value && Lw(this.buttonRef.value, this.menuRef.value, {
          placement: this._placement,
          strategy: this.menuRef.value.popover ? "absolute" : "fixed",
          middleware: [
            Aw(),
            Ew({ mainAxis: 0, alignmentAxis: -8 }),
            Ow({ mainAxis: !0, crossAxis: !0, padding: 4, altBoundary: !0 })
          ]
        }).then(({ x: l, y: d }) => {
          this.menuRef.value && Object.assign(this.menuRef.value.style, {
            marginLeft: `${l}px`,
            marginTop: `${d}px`,
            top: 0,
            left: 0,
            position: this.menuRef.value.popover ? void 0 : "fixed",
            zIndex: this.menuRef.value.popover ? void 0 : 1075
          });
        });
      });
    }) : !this.show && this._computePositionCleanup && (this._computePositionCleanup(), this._computePositionCleanup = void 0)), this.show) {
      requestAnimationFrame(() => {
        document.addEventListener("click", this._documentClickHandler, { once: !0, capture: !0 });
      });
      try {
        (n = this.menuRef.value) == null || n.showPopover();
      } catch {
      }
    } else
      try {
        (a = this.menuRef.value) == null || a.hidePopover();
      } catch {
      }
    t.has("weavy") && ((o = this.weavy) != null && o.reactions) && this.emojis != this.weavy.reactions && (this.emojis = this.weavy.reactions);
  }
  render() {
    var l, d, u;
    const { data: t, isPending: i } = this.reactionListQuery.result ?? {}, s = [
      ...new Map((l = this.reactions) == null ? void 0 : l.map((y) => [y.content, y])).values()
    ], n = p`
      ${s.length ? p`
            <wy-button
              kind="icon-inline"
              ?active=${this.showSheet}
              ?small=${this.small}
              @click=${this.handleReactionsClick}
            >
              <div part="wy-reactions">
                ${s.map((y) => {
      const m = {
        "wy-emoji-icon": !0,
        "wy-emoji-icon-sm": this.small
      };
      return p`<span class=${Rt(m)} title="">${y.content}</span>`;
    })}
                ${this.reactions && ((d = this.reactions) == null ? void 0 : d.length) > 1 ? p`<small part="wy-reaction-count">${this.reactions.length}</small>` : C}
              </div>
            </wy-button>
          ` : C}

      <div ${X(this.buttonRef)}>
        <wy-button
          part="wy-reaction-menu-button"
          kind="icon"
          ?active=${this.show}
          ?small=${this.small}
          @click=${this.handleClickToggle}
          @keydown=${xe}
          @keyup=${je}
          title=${$("React", { desc: "Button action to react" })}
        >
          <wy-icon name="emoticon-plus" size=${this.small ? 18 : 20}></wy-icon>
        </wy-button>
      </div>

      <div
        ${X(this.menuRef)}
        part="wy-reaction-menu"
        @click=${this.handleClickToggle}
        @keyup=${qh}
        ?hidden=${!this.show}
        ?popover=${!Ed()}
      >
        <div part="wy-reaction-picker">
          ${this.emojis.map(
      (y) => p`
                <wy-button
                  kind="icon"
                  color="none"
                  ?active=${this.reactedEmoji === y}
                  @click=${() => {
        this.handleReaction(y);
      }}
                >
                  <span class="wy-emoji-icon">${y}</span>
                </wy-button>
              `
    )}
        </div>
      </div>
    `, a = p`
      ${this.weavy && this.showSheet ? p`
            <wy-sheet
              .show=${this.showSheet}
              @close=${() => this.showSheet = !1}
              @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
            >
              <span slot="appbar-text">${$("Reactions")}</span>
              <!-- <wy-spinner></wy-spinner> -->
              ${this.showSheet && t && !i ? p`
                    ${(u = t.data) == null ? void 0 : u.map((y) => p` <wy-reaction-item .reaction=${y}></wy-reaction-item> `)}
                  ` : C}
            </wy-sheet>
          ` : C}
    `, o = {
      "wy-reactions-line": !0,
      "wy-reactions-line-reverse": this.lineReverse,
      "wy-reactions-line-bottom": this.lineBottom,
      "wy-reactions-line-below": this.lineBelow
    };
    return this.line || this.lineReverse || this.lineBottom || this.lineBelow ? p`
          <div part=${Yt(o)}>${n}</div>
          ${a}
        ` : [n, a];
  }
  firstUpdated(t) {
    var i;
    (i = this.menuRef.value) == null || i.addEventListener(
      this.menuRef.value.popover ? "toggle" : "click",
      (s) => this.handleClose(s)
    );
  }
  disconnectedCallback() {
    var t;
    (t = this._computePositionCleanup) == null || t.call(this), super.disconnectedCallback();
  }
}, c(An, "WyReactions"), An);
It.styles = [
  te,
  H0,
  Iw,
  Z`
      :host {
        display: contents;
      }
    `
];
jt([
  w()
], It.prototype, "directionX", 2);
jt([
  w()
], It.prototype, "directionY", 2);
jt([
  w({ type: Boolean })
], It.prototype, "small", 2);
jt([
  w({ attribute: !1 })
], It.prototype, "reactions", 2);
jt([
  w({ attribute: !1 })
], It.prototype, "emojis", 2);
jt([
  w({ type: String })
], It.prototype, "parentType", 2);
jt([
  w({ attribute: !0, type: Number })
], It.prototype, "parentId", 2);
jt([
  w({ attribute: !0, type: String })
], It.prototype, "entityType", 2);
jt([
  w({ attribute: !0, type: Number })
], It.prototype, "entityId", 2);
jt([
  w({ type: Boolean })
], It.prototype, "line", 2);
jt([
  w({ type: Boolean })
], It.prototype, "lineReverse", 2);
jt([
  w({ type: Boolean })
], It.prototype, "lineBottom", 2);
jt([
  w({ type: Boolean })
], It.prototype, "lineBelow", 2);
jt([
  D()
], It.prototype, "_placement", 2);
jt([
  D()
], It.prototype, "reactedEmoji", 2);
jt([
  D()
], It.prototype, "show", 2);
jt([
  D()
], It.prototype, "showSheet", 2);
It = jt([
  B("wy-reactions"),
  st()
], It);
var Ln;
let Io = (Ln = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this);
  }
  render() {
    var t, i, s;
    return p`
      <div class="wy-item wy-list-item">
        <wy-avatar
          .src=${(t = this.reaction.created_by) == null ? void 0 : t.avatar_url}
          .name=${(i = this.reaction.created_by) == null ? void 0 : i.display_name}
        ></wy-avatar>
        <div class="wy-item-body">${(s = this.reaction.created_by) == null ? void 0 : s.display_name}</div>
        <span class="wy-emoji-icon">${this.reaction.content}</span>
      </div>
    `;
  }
}, c(Ln, "WyReactionItem"), Ln);
Io.styles = [te, Rw, Iw];
jt([
  w({ attribute: !1 })
], Io.prototype, "reaction", 2);
Io = jt([
  B("wy-reaction-item")
], Io);
function fh(r) {
  switch (r) {
    case "zoom":
      return "zoom-meetings";
    case "microsoft":
      return "microsoft-teams";
    case "google":
      return "google-meet";
  }
}
c(fh, "getMeetingIconName");
function mh(r) {
  switch (r) {
    case "zoom":
      return $("Zoom meeting");
    case "microsoft":
      return $("Teams meeting");
    case "google":
      return $("Google Meet");
  }
}
c(mh, "getMeetingTitle");
var U0 = Object.defineProperty, q0 = Object.getOwnPropertyDescriptor, Tw = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? q0(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && U0(t, i, n), n;
}, "__decorateClass$U"), Rn;
let To = (Rn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this);
  }
  render() {
    const t = ((/* @__PURE__ */ new Date()).getTime() - new Date(this.meeting.created_at).getTime()) / 36e5 > 2;
    return p`
      <div class="wy-list">
        ${t ? p`<div class="wy-item wy-list-item wy-meeting wy-disabled" title="${$("Meeting ended")}">
                <wy-icon svg="${fh(this.meeting.provider)}" size="48" ></wy-icon>                
                <div class="wy-item-body">
                  <div class="wy-item-title">${mh(this.meeting.provider)}</div>
                  <div class="wy-item-text">${this.meeting.code}</div>
                </div> 
              </div>` : p`<a class="wy-item wy-list-item wy-meeting" href=${this.meeting.join_url} target="_blank"  title="${$("Join meeting")}">
              <wy-icon svg="${fh(this.meeting.provider)}" size="48" color="native"></wy-icon>
              <div class="wy-item-body">
                <div class="wy-item-title">${mh(this.meeting.provider)}</div>
                <div class="wy-item-text">${this.meeting.code}</div>                
              </div>
            </a>`}
      </div>
    `;
  }
}, c(Rn, "WyMeetingCard"), Rn);
To.styles = J;
Tw([
  w({ attribute: !1 })
], To.prototype, "meeting", 2);
To = Tw([
  B("wy-meeting-card"),
  st()
], To);
var N0 = Object.defineProperty, j0 = Object.getOwnPropertyDescriptor, Fw = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? j0(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && N0(t, i, n), n;
}, "__decorateClass$T"), In;
let Fo = (In = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.text = "";
  }
  render() {
    const t = this.text.trim();
    let i = "";
    return t.length && (i = t.split(/(\n+)/).map((n) => `<div>${n.split(/(\s+)/).map((o) => `<span class="wy-placeholder">${this.escapeHTML(o)}</span>`).join(" ")}</div>`).join(" ")), p`
      <div>${qs(i)}</div>
    `;
  }
  escapeHTML(t) {
    const i = document.createElement("div");
    return i.textContent = t, i.innerHTML;
  }
}, c(In, "WySkeleton"), In);
Fo.styles = J;
Fw([
  w()
], Fo.prototype, "text", 2);
Fo = Fw([
  B("wy-skeleton")
], Fo);
const Tp = class Tp {
  constructor(t) {
    this.delay = NaN, this.sleep = !1, t.addController(this), this.host = t;
  }
  createObserver(t) {
    var i;
    (i = this.scrollObserver) == null || i.disconnect(), this.swipeElement = t, this.scrollObserver = new IntersectionObserver(
      (s) => {
        s.forEach(async (n) => {
          n.isIntersecting && !this.sleep && n.intersectionRatio >= 1 && (this.sleep = !0, Number.isNaN(this.delay) || await new Promise((a) => {
            setTimeout(a, this.delay);
          }), n.target === this.prevElement && this.whenPrev && await this.whenPrev(), n.target === this.nextElement && this.whenNext && await this.whenNext(), await this.host.updateComplete);
        });
      },
      { root: t, threshold: 1, rootMargin: "0px" }
    );
  }
  observe(t, i) {
    var s, n, a, o;
    this.prevElement && ((s = this.scrollObserver) == null || s.unobserve(this.prevElement), this.prevElement = void 0), this.nextElement && ((n = this.scrollObserver) == null || n.unobserve(this.nextElement), this.nextElement = void 0), t && ((a = this.scrollObserver) == null || a.observe(t), this.prevElement = t), i && ((o = this.scrollObserver) == null || o.observe(i), this.nextElement = i), this.sleep = !1;
  }
  clearObserver() {
    var t;
    this.prevElement = void 0, this.nextElement = void 0, (t = this.scrollObserver) == null || t.disconnect(), this.sleep = !1;
  }
  hostConnected() {
    this.scrollObserver && (this.prevElement && this.scrollObserver.observe(this.prevElement), this.nextElement && this.scrollObserver.observe(this.nextElement), this.sleep = !1);
  }
  hostDisconnected() {
    var t;
    (t = this.scrollObserver) == null || t.disconnect();
  }
};
c(Tp, "SwipeScrollController");
let vh = Tp;
var Oi, Ts;
const Fp = class Fp {
  constructor(t) {
    T(this, Oi);
    T(this, Ts);
    if (I(this, Oi, /* @__PURE__ */ new Map()), this.keyPrefix = "WEAVY_OFFLINE_CACHE", t)
      I(this, Ts, t);
    else
      try {
        Se(), I(this, Ts, window.sessionStorage);
      } catch {
        console.warn("Session storage not available.");
      }
  }
  resetPersistPropertiesCache() {
    b(this, Oi).clear();
  }
  async getStorageItem(t, i) {
    var n;
    const s = (n = b(this, Ts)) == null ? void 0 : n.getItem(`${t}-${i.toString()}`);
    if (s)
      return JSON.parse(s);
  }
  async setStorageItem(t, i, s) {
    var a;
    const n = JSON.stringify(s);
    n && ((a = b(this, Ts)) == null || a.setItem(`${t}-${i.toString()}`, n));
  }
  async persistProperties(t, i, s, n) {
    const a = `${this.keyPrefix}:${n ? `${n}:` : ""}${typeof t}:${i}`;
    s.forEach(async (o) => {
      if (!b(this, Oi).has(o)) {
        const l = await this.getStorageItem(a, o);
        l && (t[o] = l), b(this, Oi).set(o, l);
      }
      if (t[o] !== b(this, Oi).get(o)) {
        const l = t[o];
        b(this, Oi).set(o, l), this.setStorageItem(a, o, l);
      }
    });
  }
};
Oi = new WeakMap(), Ts = new WeakMap(), c(Fp, "PersistStorageCache");
let gh = Fp;
var Fs, Tn;
const Dp = class Dp {
  constructor(t) {
    T(this, Fs);
    T(this, Tn);
    I(this, Fs, ""), this.properties = [], this.persistStorageCache = new gh(), t.addController(this), this.host = t;
  }
  get prefixKey() {
    return b(this, Fs);
  }
  set prefixKey(t) {
    t !== b(this, Fs) && (this.persistStorageCache.resetPersistPropertiesCache(), I(this, Fs, t), this.host.requestUpdate());
  }
  get cachePrefix() {
    return b(this, Tn);
  }
  set cachePrefix(t) {
    t !== b(this, Tn) && (this.persistStorageCache.resetPersistPropertiesCache(), I(this, Tn, t), this.host.requestUpdate());
  }
  observe(t, i, s) {
    this.properties = t, i && (this.prefixKey = i), s && (this.cachePrefix = s);
  }
  hostUpdate() {
    this.prefixKey && this.properties && this.host.weavy && this.persistStorageCache.persistProperties(this.host, this.prefixKey, this.properties, this.cachePrefix ? `${this.host.weavy.cachePrefix}:${this.cachePrefix}` : this.host.weavy.cachePrefix);
  }
};
Fs = new WeakMap(), Tn = new WeakMap(), c(Dp, "PersistStateController");
let Do = Dp;
var W0 = Object.defineProperty, Q0 = Object.getOwnPropertyDescriptor, yc = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? Q0(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && W0(t, i, n), n;
}, "__decorateClass$S"), Fn;
let ls = (Fn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.show = !0, this.maximized = !1, this.filled = !1, this.header = !1, this.viewportRef = rt();
  }
  close() {
    var t;
    (t = this.viewportRef.value) == null || t.close(), this.show = !1;
  }
  handleClose(t) {
    this.show = !1, this.dispatchEvent(new CustomEvent("close")), this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }));
  }
  willUpdate(t) {
    var i, s;
    super.willUpdate(t), t.has("show") && (this.show ? (i = this.viewportRef.value) == null || i.showModal() : (s = this.viewportRef.value) == null || s.close());
  }
  render() {
    const t = {
      "wy-open": this.show,
      "wy-modal-padded": !this.filled && !this.maximized,
      "wy-modal-full": this.maximized && !this.filled
    };
    return p`
      <dialog class="wy-dialog wy-overlay-dialog" ${X(this.viewportRef)}>
        <div class="wy-overlay wy-transition wy-modal ${Rt(t)}">
          ${this.header ? p`
                <slot name="header">
                  <header class="wy-appbars">
                    <nav class="wy-appbar">
                      <wy-button kind="icon" @click=${() => this.close()}><wy-icon name="close"></wy-icon></wy-button>
                      <slot name="appbar-text" class="wy-appbar-text"></slot>
                      <slot name="appbar-buttons" class="wy-appbar-buttons wy-appbar-buttons-last"></slot>
                    </nav>
                  </header>
                </slot>
              ` : C}
          <slot></slot>
        </div>
      </dialog>
    `;
  }
  updated(t) {
    var i;
    t.has("show") && this.show && ((i = this.viewportRef.value) == null || i.focus());
  }
  firstUpdated(t) {
    var i;
    (i = this.viewportRef.value) == null || i.addEventListener("close", (s) => this.handleClose(s));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.close();
  }
}, c(Fn, "WyOverlay"), Fn);
ls.styles = [
  J,
  We
];
yc([
  w({ type: Boolean })
], ls.prototype, "show", 2);
yc([
  w({ type: Boolean })
], ls.prototype, "maximized", 2);
yc([
  w({ type: Boolean })
], ls.prototype, "filled", 2);
yc([
  w({ type: Boolean })
], ls.prototype, "header", 2);
ls = yc([
  B("wy-overlay")
], ls);
const Pl = Z`.wy-dropdown{position:relative}.wy-dropdown-toggle{white-space:nowrap}.wy-dropdown-menu{width:max-content;position:absolute;z-index:1000;min-width:calc(10 * var(--wy-size, 1rem));border:none;padding:0;--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);font-size:var(--wy-font-size, var(--wy-size, 1em));text-align:left;background-clip:padding-box;border-radius:var(--wy-dropdown-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));box-shadow:var(--wy-dropdown-shadow, var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12)));overflow:hidden}.wy-dropdown-menu:not([popover]){display:block}.wy-dropdown-item{background-color:transparent;color:var(--wy-component-color, var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e)));width:100%;padding:var(--wy-dropdown-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-dropdown-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));clear:both;font-family:var(--wy-font-family, unset),inherit;font-size:inherit;font-weight:var(--wy-font-weight, unset);line-height:1;text-align:inherit;text-decoration:none;white-space:nowrap;border:0;gap:var(--wy-dropdown-gap, var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));cursor:pointer;display:flex;align-items:center}.wy-dropdown-item:hover,.wy-dropdown-item:focus{--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));color:var(--wy-component-color);background-color:var(--wy-component-background-color);text-decoration:none}.wy-dropdown-item.wy-active,.wy-dropdown-item:active{--wy-component-color: var(--wy-on-primary-container, var(--wy-primary-10, #001d32));--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-90, #cde5ff));color:var(--wy-component-color);background-color:var(--wy-component-background-color);text-decoration:none}.wy-dropdown-item.wy-disabled,.wy-dropdown-item:disabled{color:var(--wy-component-color);background-color:var(--wy-component-background-color);pointer-events:none;opacity:var(--wy-opacity-disabled, 38%)}.wy-dropdown-item>img,.wy-dropdown-item>wy-icon{margin-right:calc(.5 * var(--wy-size, 1rem))}.wy-dropdown-item>img,.wy-dropdown-item>img .wy-icon,.wy-dropdown-item>wy-icon,.wy-dropdown-item>wy-icon .wy-icon{color:inherit}.wy-dropdown-item:active>wy-icon,.wy-dropdown-item:active>wy-icon .wy-icon{color:inherit}.wy-dropdown-item.wy-option wy-icon{visibility:hidden}.wy-dropdown-item.wy-option.wy-selected wy-icon{visibility:visible}.wy-dropdown-divider{height:0;margin:0;overflow:hidden;border:none;border-top:var(--wy-dropdown-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}`;
var K0 = Object.defineProperty, G0 = Object.getOwnPropertyDescriptor, ce = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? G0(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && K0(t, i, n), n;
}, "__decorateClass$R"), Dn;
let Ee = (Dn = class extends j {
  constructor() {
    super(), this.exportParts = new Q(this), this.directionX = "right", this.directionY = "down", this.icon = "dots-vertical", this.small = !1, this.noWrapper = !1, this.disabled = !1, this._placement = "bottom-start", this.showMenu = !1, this.buttonRef = rt(), this.menuRef = rt(), this._documentClickHandler = (t) => {
      var i;
      this.showMenu && (t.preventDefault(), (i = this.menuRef.value) != null && i.popover || (this.showMenu = !1));
    }, this.addEventListener("click", (t) => {
      t.preventDefault();
    });
  }
  handleClose(t) {
    (t.type === "toggle" && t.newState === "closed" || t.type === "click") && (this.showMenu = !1, this.dispatchEvent(new CustomEvent("close")), this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 })));
  }
  handleClickToggle(t) {
    t.stopPropagation(), this.showMenu = !this.showMenu;
  }
  willUpdate(t) {
    var i, s, n;
    if ((t.has("directionX") || t.has("directionY")) && (this._placement = this.directionX === "right" && this.directionY === "down" ? "bottom-start" : this.directionX === "left" && this.directionY === "down" ? "bottom-end" : this.directionX === "right" && this.directionY === "up" ? "top-start" : "top-end"), t.has("showMenu") && (this.showMenu && !this.computePositionCleanup && this.buttonRef.value && this.menuRef.value ? this.computePositionCleanup = Sw(this.buttonRef.value, this.menuRef.value, () => {
      this.buttonRef.value && this.menuRef.value && Lw(this.buttonRef.value, this.menuRef.value, {
        placement: this._placement,
        strategy: this.menuRef.value.popover ? "absolute" : "fixed",
        middleware: [
          Aw(),
          Ew(({ placement: a }) => a.includes("top") ? 9 : 13),
          Ow({ mainAxis: !0, crossAxis: !0, padding: 4, altBoundary: !0 })
        ]
      }).then(({ x: a, y: o }) => {
        this.menuRef.value && Object.assign(this.menuRef.value.style, {
          marginLeft: `${a}px`,
          marginTop: `${o}px`,
          top: 0,
          left: 0,
          position: this.menuRef.value.popover ? void 0 : "fixed",
          zIndex: this.menuRef.value.popover ? void 0 : 1075
        });
      });
    }) : !this.showMenu && this.computePositionCleanup && ((i = this.computePositionCleanup) == null || i.call(this), this.computePositionCleanup = void 0)), this.showMenu) {
      requestAnimationFrame(() => {
        document.addEventListener("click", this._documentClickHandler, { once: !0, capture: !0 });
      });
      try {
        (s = this.menuRef.value) == null || s.showPopover();
      } catch {
      }
    } else
      try {
        (n = this.menuRef.value) == null || n.hidePopover();
      } catch {
      }
  }
  render() {
    const t = this._slotButton.length === 0 || this._slotButton.length === 1 && this._slotButton[0] instanceof Pt;
    return p`
      <span>
        <span
          ${X(this.buttonRef)}
          @click=${this.handleClickToggle}
          @keydown=${xe}
          @keyup=${je}
        >
          <wy-button
            .kind=${t ? "icon" : void 0}
            ?small=${this.small}
            title=${this.title}
            ?active=${this.showMenu}
            ?disabled=${this.disabled}
          >
            <slot name="button" @slotchange=${() => this.requestUpdate()}>
              <wy-icon name=${this.icon}></wy-icon>
            </slot>
          </wy-button>
        </span>

        <div
          ${X(this.menuRef)}
          @click=${this.handleClickToggle}
          @keyup=${qh}
          class="wy-dropdown-menu"
          ?hidden=${Ed() && !this.showMenu}
          ?popover=${!Ed()}
        >
          <slot></slot>
        </div>
      </span>
    `;
  }
  firstUpdated(t) {
    var i;
    (i = this.menuRef.value) == null || i.addEventListener(this.menuRef.value.popover ? "toggle" : "click", (s) => this.handleClose(s));
  }
  disconnectedCallback() {
    var t;
    (t = this.computePositionCleanup) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Dn, "WyDropdown"), Dn);
Ee.styles = [
  te,
  Pl,
  Z`
      /*:host {
        position: relative;
      }*/
    `
];
ce([
  w()
], Ee.prototype, "directionX", 2);
ce([
  w()
], Ee.prototype, "directionY", 2);
ce([
  w()
], Ee.prototype, "icon", 2);
ce([
  w({ type: Boolean })
], Ee.prototype, "small", 2);
ce([
  w({ type: Boolean })
], Ee.prototype, "noWrapper", 2);
ce([
  w({ type: Boolean })
], Ee.prototype, "disabled", 2);
ce([
  D()
], Ee.prototype, "_placement", 2);
ce([
  D()
], Ee.prototype, "showMenu", 2);
ce([
  hm({ slot: "button" })
], Ee.prototype, "_slotButton", 2);
ce([
  D()
], Ee.prototype, "computePositionCleanup", 2);
Ee = ce([
  B("wy-dropdown")
], Ee);
var Hn;
let Ho = (Hn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.active = !1;
  }
  render() {
    return p`<div class="wy-dropdown-item ${Rt({ "wy-active": this.active })}" tabindex="0"
      ><slot></slot
    ></div>`;
  }
}, c(Hn, "WyDropdownItem"), Hn);
Ho.styles = [
  te,
  Pl,
  Z`
      :host {
        display: contents;
      }
    `
];
ce([
  w({ type: Boolean })
], Ho.prototype, "active", 2);
Ho = ce([
  B("wy-dropdown-item")
], Ho);
var Vn;
let to = (Vn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.active = !1, this.selected = !1;
  }
  render() {
    const t = {
      visibility: this.selected ? null : "hidden"
    };
    return p`
      <div
        class="wy-dropdown-item wy-option ${Rt({ "wy-active": this.active, "wy-selected": this.selected })}"
        tabindex="0"
      >
        <slot name="icon" style=${Wc(t)}><wy-icon name="check"></wy-icon></slot>
        <slot></slot>
      </div>
    `;
  }
}, c(Vn, "WyDropdownOption"), Vn);
to.styles = [
  te,
  Pl,
  Z`
      :host {
        display: contents;
      }
    `
];
ce([
  w({ type: Boolean })
], to.prototype, "active", 2);
ce([
  w({ type: Boolean })
], to.prototype, "selected", 2);
to = ce([
  B("wy-dropdown-option")
], to);
var Bn;
let Jc = (Bn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this);
  }
  render() {
    return p`<hr class="wy-dropdown-divider" />`;
  }
}, c(Bn, "WyDropdownDivider"), Bn);
Jc.styles = [
  te,
  Pl,
  Z`
      :host {
        display: contents;
      }
    `
];
Jc = ce([
  B("wy-dropdown-divider")
], Jc);
var Y0 = Object.defineProperty, Z0 = Object.getOwnPropertyDescriptor, Ml = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? Z0(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && Y0(t, i, n), n;
}, "__decorateClass$Q"), Un;
let Ks = (Un = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this);
  }
  render() {
    const t = this.icon, i = yo(this.provider);
    return p`
      <wy-icon-display>
        <wy-icon name=${t} .overlayName=${i}></wy-icon>
        <span slot="text">
          ${this.provider ? p`
                <span>${$("No preview available :(")} </span>
                <a href=${this.src} target="_blank">${$(pt`Open in ${this.provider}?`)}</a>
              ` : p`<span>${$("No preview available :(")}</span>`}
        </span>
      </wy-icon-display>
    `;
  }
}, c(Un, "WyPreviewIcon"), Un);
Ks.styles = [
  J,
  Z`
      :host {
        display: contents;
      }
      `
];
Ml([
  w()
], Ks.prototype, "src", 2);
Ml([
  w()
], Ks.prototype, "icon", 2);
Ml([
  w()
], Ks.prototype, "provider", 2);
Ks = Ml([
  B("wy-preview-icon"),
  st()
], Ks);
var X0 = Object.defineProperty, J0 = Object.getOwnPropertyDescriptor, zl = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? J0(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && X0(t, i, n), n;
}, "__decorateClass$P"), qn;
let Gs = (qn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this);
  }
  render() {
    if (this.width && this.height) {
      const t = { "--width": this.width, "--height": this.height };
      return p`
        <div class="wy-content-image wy-responsive-image" style=${Wc(t)}>
          <img
            class="wy-loading-transition"
            src=${this.src}
            ${X(Qc)}
            @load=${Kc}
            width=${this.width}
            height=${this.height}
            decoding="async"
            alt=${$("Preview")} />
          <wy-spinner></wy-spinner>
        </div>
      `;
    } else
      return p`
        <div class="wy-content-image wy-responsive-image wy-intrinsic-image">
          <img src=${this.src} ${X(Qc)} @load=${Kc} decoding="async" alt=${$("Preview")} />
        </div>
      `;
  }
}, c(qn, "WyPreviewImage"), qn);
Gs.styles = [
  J,
  Z`
      :host {
        display: contents;
      }
    `
];
zl([
  w()
], Gs.prototype, "src", 2);
zl([
  w({ type: Number })
], Gs.prototype, "width", 2);
zl([
  w({ type: Number })
], Gs.prototype, "height", 2);
Gs = zl([
  B("wy-preview-image"),
  st()
], Gs);
function Dw(r) {
  r.classList.contains("wy-loading") && r.classList.add("wy-loaded"), r.classList.add("wy-error"), r.outerHTML = r.outerHTML.replace(/<(video|audio)/, "<div").replace(/(video|audio)>/, "div>");
}
c(Dw, "mediaFallback");
function Mu(r) {
  const t = r.target;
  (t.tagName === "VIDEO" || t.tagName === "AUDIO") && t.classList.contains("wy-loading") && t.classList.add("wy-loaded");
}
c(Mu, "mediaLoaded");
function zu(r) {
  const t = r.target;
  if (t.tagName === "SOURCE" && t.parentNode) {
    const i = t.parentNode, s = parseInt(i.dataset.errors || "0") + 1;
    i.dataset.errors = s.toString(), i.querySelectorAll("source").length >= s && (console.warn(i.tagName.toLowerCase() + " source error, switching to fallback"), Dw(i));
  }
}
c(zu, "mediaError");
function Su(r) {
  const t = r.target;
  (t.tagName === "VIDEO" || t.tagName === "AUDIO") && (t.tagName === "VIDEO" && !t.videoWidth || t.tagName === "AUDIO" && !t.duration) && (console.warn(t.tagName.toLowerCase() + " track not available, switching to fallback"), Dw(t));
}
c(Su, "codecError");
var tb = Object.defineProperty, eb = Object.getOwnPropertyDescriptor, wc = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? eb(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && tb(t, i, n), n;
}, "__decorateClass$O"), Nn;
let ds = (Nn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.format = "", this.name = "";
  }
  registerLoading(t) {
    this.unregisterLoading(), t && (this.mediaElement = t, t.classList.add("wy-loading"), t.addEventListener("error", zu, !0), t.addEventListener("loadedmetadata", Mu, !0), t.addEventListener("loadedmetadata", Su, !0));
  }
  unregisterLoading() {
    this.mediaElement && (this.mediaElement.pause(), this.mediaElement.removeAttribute("autoplay"), this.mediaElement.setAttribute("preload", "none"), this.mediaElement.removeEventListener("error", zu, !0), this.mediaElement.removeEventListener("loadedmetadata", Mu, !0), this.mediaElement.removeEventListener("loadedmetadata", Su, !0), this.mediaElement = void 0);
  }
  render() {
    return this.format === "video" ? p`
          <video ${X(this.registerLoading)} class="wy-content-video" controls crossorigin="use-credentials" autoplay>
            <source src=${this.src} type=${lt(this.mediaType)} />
            <wy-preview-icon src=${this.src} icon="file-video"></wy-preview-icon>
          </video>
          <wy-spinner></wy-spinner>
        ` : p`
          <audio ${X(this.registerLoading)} class="wy-content-audio" controls crossorigin="use-credentials" autoplay>
            <source src=${this.src} type=${lt(this.mediaType)} />
          </audio>
        `;
  }
  disconnectedCallback() {
    this.unregisterLoading(), super.disconnectedCallback();
  }
}, c(Nn, "WyPreviewMedia"), Nn);
ds.styles = [
  J,
  Z`
      :host {
        display: contents;
      }
    `
];
wc([
  w()
], ds.prototype, "format", 2);
wc([
  w()
], ds.prototype, "src", 2);
wc([
  w()
], ds.prototype, "name", 2);
wc([
  w()
], ds.prototype, "mediaType", 2);
ds = wc([
  B("wy-preview-media")
], ds);
var ib = Object.defineProperty, sb = Object.getOwnPropertyDescriptor, rr = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? sb(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && ib(t, i, n), n;
}, "__decorateClass$N"), jn;
let xi = (jn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.html = !1, this.code = !1, this.textOrHtmlContent = "", this.loading = !0;
  }
  async updated(t) {
    (t.has("weavy") || t.has("src")) && this.weavy && (this.loading = !0, fetch(this.src, await this.weavy.fetchOptions()).then(Uf).then((i) => new Response(i)).then((i) => i.text()).then((i) => {
      this.loading = !1, this.textOrHtmlContent = i;
    }));
  }
  render() {
    return this.loading ? p`
      <wy-empty><wy-spinner></wy-spinner></wy-empty>
    ` : this.html ? this.code ? p` <div class="wy-content-code wy-code">${qs(this.textOrHtmlContent)}</div> ` : p`
            <div class="wy-document wy-light">
              <div class="wy-content-html">${qs(this.textOrHtmlContent)}</div>
            </div>
          ` : this.code ? p` <div class="wy-content-code">${this.textOrHtmlContent}</div> ` : p`
          <div class="wy-document wy-light">
            <pre class="wy-content-text">${this.textOrHtmlContent}</pre>
          </div>
        `;
  }
}, c(jn, "WyPreviewText"), jn);
xi.styles = [
  J,
  We,
  Z`
      :host {
        display: contents;
      }
    `
];
rr([
  Qt({ context: Xt, subscribe: !0 }),
  D()
], xi.prototype, "weavy", 2);
rr([
  w()
], xi.prototype, "src", 2);
rr([
  w({ type: Boolean })
], xi.prototype, "html", 2);
rr([
  w({ type: Boolean })
], xi.prototype, "code", 2);
rr([
  D()
], xi.prototype, "textOrHtmlContent", 2);
rr([
  D()
], xi.prototype, "loading", 2);
xi = rr([
  B("wy-preview-text")
], xi);
var rb = Object.defineProperty, nb = Object.getOwnPropertyDescriptor, fc = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? nb(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && rb(t, i, n), n;
}, "__decorateClass$M"), Wn;
let hs = (Wn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this);
  }
  registerLoading(t) {
    var i;
    if ((i = this.unregisterLoading) == null || i.call(this), t) {
      this.embedElement = t, t.classList.add("wy-loading");
      const s = window.setTimeout(() => {
        t.classList.add("wy-fallback");
      }, 2500), n = /* @__PURE__ */ c((a) => {
        const o = a.target;
        o.tagName === "OBJECT" && o.classList.contains("wy-loading") && !o.classList.contains("wy-loaded") && (o.classList.add("wy-loaded"), window.clearTimeout(s));
      }, "embedLoaded");
      t.addEventListener("load", n, !0), this.unregisterLoading = () => {
        this.embedElement && (t.removeEventListener("load", n, !0), window.clearTimeout(s), this.embedElement = void 0);
      };
    }
  }
  render() {
    return p`
      <object title=${$("Preview")} ${X(this.registerLoading)} class="wy-content-iframe" data=${this.src}></object>
      <wy-spinner overlay></wy-spinner>
      <wy-preview-icon
        src=${this.src}
        icon=${this.icon}
        provider=${lt(this.provider)}
        class="wy-content-iframe-fallback"></wy-preview-icon>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = this.unregisterLoading) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Wn, "WyPreviewEmbed"), Wn);
hs.styles = [
  J,
  Z`
      :host {
        display: contents;
      }
    `
];
fc([
  w()
], hs.prototype, "src", 2);
fc([
  w()
], hs.prototype, "name", 2);
fc([
  w()
], hs.prototype, "icon", 2);
fc([
  w()
], hs.prototype, "provider", 2);
hs = fc([
  B("wy-preview-embed"),
  st()
], hs);
function Mo(r = "", t = "", i = "", s = !1) {
  if (Se(), r) {
    const n = document.createElement("a");
    s && (/^(data:|blob:)/.test(r) ? n.download = i || "download" : r = r.includes("?d=1") || r.includes("&d=1") ? r : r.includes("?") ? r + "&d=1" : r + "?d=1"), t && (n.target = t), n.href = r, document.body.appendChild(n);
    try {
      n.click();
    } catch {
      if (console.warn("Could not open link normally, trying fallback"), /^(?:blob:|data:)/.test(r))
        console.error(`Could not ${s ? "download" : "open"} ${i}`);
      else
        try {
          window.open(r, t);
        } catch {
          console.error(`Could not ${s ? "download" : "open"} ${i}`);
        }
    }
    document.body.removeChild(n);
  }
}
c(Mo, "openUrl");
function Eu(r, t) {
  return new URL(
    r,
    typeof WEAVY_IMPORT_URL == "string" && (!t || !new URL(t).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : t
  );
}
c(Eu, "environmentUrl");
var ab = Object.defineProperty, ob = Object.getOwnPropertyDescriptor, Sl = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? ob(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && ab(t, i, n), n;
}, "__decorateClass$L"), Qn;
let Ys = (Qn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.whenPdfjs = new Promise((t) => {
      this.whenPdfjsResolve = t;
    }), this.MAX_CANVAS_PIXELS = 0, this.TEXT_LAYER_MODE = 0, this.MAX_IMAGE_SIZE = -1, this.CMAP_PACKED = !0, this.DEFAULT_SCALE_DELTA = 1.1, this.MIN_SCALE = 0.25, this.MAX_SCALE = 10, this.DEFAULT_SCALE_VALUE = "auto", this.ENABLE_XFA = !0, this.DEFAULT_WORKER_URL = "/pdfjs/pdf.worker.min.mjs", this.DEFAULT_CMAPS_URL = "/pdfjs/cmaps/", this.pageNumberRef = rt(), this.totalPagesRef = rt(), this.zoomLevelRef = rt(), this.viewerContainerRef = rt(), this.resizer = new ResizeObserver(() => {
      this.pdfViewer && (this.delayedResize && (clearTimeout(this.delayedResize), this.delayedResize = void 0), this.delayedResize = window.setTimeout(() => {
        this.pdfViewer && (this.pdfViewer.currentScaleValue = this.pdfViewer._currentScaleValue);
      }, 100));
    });
  }
  ////////
  async open() {
    var s;
    const { pdfjsLib: t } = await this.whenPdfjs;
    if (!this.pdfViewer || !this.pdfHistory || !this.l10n || !this.pdfLinkService)
      return;
    this.pdfLoadingTask && await this.close();
    const i = t.getDocument({
      url: this.src,
      maxImageSize: this.MAX_IMAGE_SIZE,
      enableXfa: this.ENABLE_XFA,
      cMapUrl: ((s = this.CMAP_URL) == null ? void 0 : s.toString()) || "",
      cMapPacked: this.CMAP_PACKED
    });
    this.pdfLoadingTask = i, i.onProgress = (n) => {
    };
    try {
      const n = await i.promise;
      this.pdfDocument = n, this.pdfViewer.setDocument(n), this.pdfLinkService.setDocument(n), this.pdfHistory.initialize({
        // @ts-expect-error Type 'string | null' is not assignable to type 'string'.
        fingerprint: n.fingerprints[0]
      });
    } catch (n) {
      let a = "pdfjs-loading-error";
      n instanceof t.InvalidPDFException ? a = "pdfjs-invalid-file-error" : n instanceof t.MissingPDFException ? a = "pdfjs-missing-file-error" : n instanceof t.UnexpectedResponseException && (a = "pdfjs-unexpected-response-error"), this.l10n.get(a, void 0, void 0).then((o) => {
        this.pdfViewError(t, o, { message: n == null ? void 0 : n.message });
      });
    }
  }
  async close() {
    var i, s;
    if (!this.pdfLoadingTask)
      return Promise.resolve();
    const t = this.pdfLoadingTask.destroy();
    return this.pdfLoadingTask = void 0, this.pdfDocument && (this.pdfDocument = void 0, (i = this.pdfViewer) == null || i.setDocument(null), (s = this.pdfLinkService) == null || s.setDocument(null, null), this.pdfHistory && this.pdfHistory.reset()), await t;
  }
  pdfViewError(t, i, s) {
    const n = [`PDF.js v${(t == null ? void 0 : t.version) || "?"} (build: ${(t == null ? void 0 : t.build) || "?"})`];
    s && (n.push(`Message: ${s.message}`), s.stack ? n.push(`Stack: ${s.stack}`) : (s.filename && n.push(`File: ${s.filename}`), s.lineNumber && n.push(`Line: ${s.lineNumber}`))), console.error(`${i}

${n.join(`
`)}`);
  }
  ///////
  setPage(t) {
    this.pdfViewer && (this.pdfViewer.currentPageNumber = t);
  }
  zoomIn(t) {
    if (this.pdfViewer) {
      let i = this.pdfViewer.currentScale;
      do
        i = parseFloat((i * this.DEFAULT_SCALE_DELTA).toFixed(2)), i = Math.ceil(i * 10) / 10, i = Math.min(this.MAX_SCALE, i);
      while (--t && i < this.MAX_SCALE);
      this.pdfViewer.currentScaleValue = i.toFixed(2);
    }
  }
  zoomOut(t) {
    if (this.pdfViewer) {
      let i = this.pdfViewer.currentScale;
      do
        i = parseFloat((i / this.DEFAULT_SCALE_DELTA).toFixed(2)), i = Math.floor(i * 10) / 10, i = Math.max(this.MIN_SCALE, i);
      while (--t && i > this.MIN_SCALE);
      this.pdfViewer.currentScaleValue = i.toFixed(2);
    }
  }
  setScale(t) {
    this.pdfViewer && (this.pdfViewer.currentScaleValue = typeof t == "number" ? t.toFixed(2) : t);
  }
  updatePage() {
    if (this.pdfViewer && this.pageNumberRef.value) {
      const t = parseInt(this.pageNumberRef.value.value);
      isNaN(t) ? this.setPage(this.pdfViewer.currentPageNumber) : t > this.pdfViewer.pagesCount ? this.setPage(this.pdfViewer.pagesCount) : t <= 0 ? this.setPage(1) : this.setPage(t);
    }
  }
  select(t) {
    const i = t.target;
    i && i.setSelectionRange(0, i.value.length);
  }
  fitToPage() {
    this.setScale("page-fit");
  }
  fitToWidth() {
    this.setScale("page-width");
  }
  updateZoom() {
    if (this.pdfViewer && this.zoomLevelRef.value) {
      const t = parseFloat(this.zoomLevelRef.value.value.replace("%", ""));
      isNaN(t) ? this.setScale(this.pdfViewer.currentScale + 1e-4) : this.setScale(t / 100);
    }
  }
  // clearDocument() {
  //   try {
  //     this.loadingTask?.destroy();
  //     //console.debug("loadingTask cleanup", loadingTask)
  //   } catch (e) {
  //     /* No worries */
  //   }
  //   try {
  //     // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  //     // @ts-ignore due to incorrect param type def?
  //     this.pdfViewer?.setDocument(null);
  //   } catch (e) {
  //     /* No worries */
  //   }
  //   try {
  //     this.pdfLinkService.setDocument(null, null);
  //   } catch (e) {
  //     /* No worries */
  //   }
  // }
  async willUpdate(t) {
    var i;
    t.has("weavy") && this.weavy && (this.pdfjsLib || (await this.weavy.whenUrl(), this.pdfjsLib = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL("./es/pdfjs-dist/build/pdf.mjs.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
    ), globalThis.pdfjsLib = this.pdfjsLib, this.pdfjsViewer = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL("./es/pdfjs-dist/web/pdf_viewer.mjs.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
    ), (i = this.whenPdfjsResolve) == null || i.call(this, {
      pdfjsLib: this.pdfjsLib,
      pdfjsViewer: this.pdfjsViewer
    })), this.pdfjsLib && !this.WORKER_URL && (this.WORKER_URL = Eu(this.DEFAULT_WORKER_URL, import.meta.url), this.WORKER_URL.searchParams.append("v", this.weavy.version), this.pdfjsLib.GlobalWorkerOptions.workerSrc = this.WORKER_URL.toString()), this.CMAP_URL || (this.CMAP_URL = Eu(this.DEFAULT_CMAPS_URL, import.meta.url)));
  }
  update(t) {
    super.update(t), (t.has("weavy") || t.has("src") || t.has("pdfViewer")) && this.weavy && this.src && this.pdfViewer && this.open();
  }
  async updated() {
    var t, i, s, n, a, o;
    if (this.weavy && this.viewerContainerRef.value && !this.pdfViewer) {
      const { pdfjsLib: l, pdfjsViewer: d } = await this.whenPdfjs;
      this.viewerContainerRef.value && !this.pdfViewer && (this.pdfEventBus = new d.EventBus(), this.pdfLinkService = new d.PDFLinkService({
        eventBus: this.pdfEventBus
      }), this.l10n = new d.GenericL10n((t = this.weavy) == null ? void 0 : t.locale), this.pdfViewer = new d.PDFViewer({
        container: this.viewerContainerRef.value,
        eventBus: this.pdfEventBus,
        linkService: this.pdfLinkService,
        //findController: this.pdfFindController,
        annotationEditorMode: l.AnnotationEditorType.DISABLE,
        l10n: this.l10n,
        maxCanvasPixels: this.MAX_CANVAS_PIXELS,
        textLayerMode: this.TEXT_LAYER_MODE
      }), (i = this.pdfLinkService) == null || i.setViewer(this.pdfViewer), this.pdfHistory = new d.PDFHistory({
        eventBus: this.pdfEventBus,
        linkService: this.pdfLinkService
      }), (s = this.pdfLinkService) == null || s.setHistory(this.pdfHistory), (n = this.pdfEventBus) == null || n.on("scalechanging", () => {
        this.zoomLevelRef.value && this.pdfViewer ? this.zoomLevelRef.value.value = Math.round(this.pdfViewer.currentScale * 100).toFixed(0) + "%" : console.warn("Could not set zoom level");
      }), (a = this.pdfEventBus) == null || a.on("pagechanging", () => {
        this.pageNumberRef.value && this.pdfViewer ? this.pageNumberRef.value.value = this.pdfViewer.currentPageNumber.toFixed(0) : console.warn("Could not set page number");
      }), (o = this.pdfEventBus) == null || o.on("pagesinit", () => {
        this.isConnected && this.pdfViewer && this.pageNumberRef.value && this.totalPagesRef.value ? (this.pdfViewer.currentScaleValue = this.DEFAULT_SCALE_VALUE, this.pageNumberRef.value.value = "1", this.totalPagesRef.value.innerText = this.pdfViewer.pagesCount.toFixed(0), this.resizer.observe(this.pdfViewer.container)) : console.warn("Could not init pdf page");
      }));
    }
  }
  render() {
    return p`
      <div class="wy-content-pdf">
        <div class="wy-toolbars-bottom">
          <nav class="wy-toolbar wy-toolbar-center">
            <div class="wy-toolbar-buttons">
              <input
                type="text"
                class="wy-input wy-pdf-page-number"
                ${X(this.pageNumberRef)}
                @keydown=${jc}
                @keyup=${Ti}
                @change=${this.updatePage}
                @click=${this.select}
              />
              <span class="wy-toolbar-text">/</span>
              <span class="wy-toolbar-text" ${X(this.totalPagesRef)}>1</span>
            </div>
            <div class="wy-toolbar-buttons">
              <wy-button kind="icon" class="btn-zoom-out" @click=${this.zoomOut} title=${$("Zoom out")}>
                <wy-icon name="minus"></wy-icon>
              </wy-button>
              <input
                type="text"
                class="wy-input wy-pdf-zoom-level"
                ${X(this.zoomLevelRef)}
                @keydown=${jc}
                @keyup=${Ti}
                @change=${this.updateZoom}
                @click=${this.select}
                value="100%"
              />
              <wy-button kind="icon" class="btn-zoom-in" @click=${this.zoomIn} title=${$("Zoom in")}>
                <wy-icon name="plus"></wy-icon>
              </wy-button>
            </div>
            <div class="wy-toolbar-buttons">
              <wy-button kind="icon" class="btn-fit-page" @click=${this.fitToWidth} title=${$("Fit to width")}>
                <wy-icon name="fit-width"></wy-icon>
              </wy-button>
              <wy-button kind="icon" @click=${this.fitToPage} title=${$("Fit to screen")}>
                <wy-icon name="fit-screen"></wy-icon>
              </wy-button>
            </div>
          </nav>
        </div>
        <div ${X(this.viewerContainerRef)} class="wy-pdf-container">
          <div class="pdfViewer"></div>
        </div>
      </div>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.pdfViewer && this.resizer.observe(this.pdfViewer.container);
  }
  disconnectedCallback() {
    var t;
    this.resizer.unobserve(this);
    try {
      this.close(), (t = this.pdfViewer) == null || t.cleanup();
    } catch {
    }
    this.pdfViewer = void 0, super.disconnectedCallback();
  }
}, c(Qn, "WyPdfViewer"), Qn);
Ys.styles = [
  J,
  Z`
      :host {
        display: contents;
      }
    `
];
Sl([
  Qt({ context: Xt, subscribe: !0 }),
  D()
], Ys.prototype, "weavy", 2);
Sl([
  w()
], Ys.prototype, "src", 2);
Sl([
  D()
], Ys.prototype, "pdfViewer", 2);
Ys = Sl([
  B("wy-pdf-viewer"),
  st()
], Ys);
var cb = Object.defineProperty, lb = Object.getOwnPropertyDescriptor, Hw = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? lb(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && cb(t, i, n), n;
}, "__decorateClass$K"), Kn;
let Vo = (Kn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this);
  }
  render() {
    const t = this.file;
    if (!t) return C;
    const { icon: i } = vs(t.name), s = ai(t.name);
    let n = t.preview_url || t.download_url || "";
    t.preview_format === "image" && (s === ".gif" || s === ".svg") && (n = t.download_url || "");
    const o = n, l = t.external_url, d = t.is_trashed ? "none" : t.preview_format, u = t.name, y = t.width, m = t.height, f = t.media_type, g = t.provider;
    return d === "image" ? p`<wy-preview-image
        src=${o}
        width=${lt(y)}
        height=${lt(m)}
      ></wy-preview-image>` : d === "pdf" ? p`<wy-pdf-viewer src=${o}></wy-pdf-viewer>` : d === "video" || d === "audio" ? p`<wy-preview-media
        format=${d}
        src=${o}
        name=${u}
        mediaType=${f}
      ></wy-preview-media>` : d === "text" ? p`<wy-preview-text src=${o}></wy-preview-text>` : d === "code" ? p`<wy-preview-text src=${o} ?html=${!/^(?:blob:|data:)/.test(o)} code></wy-preview-text>` : d === "html" ? p`<wy-preview-text src=${o} html></wy-preview-text>` : d === "embed" ? p`<wy-preview-embed
        src=${o}
        name=${u}
        icon=${i}
        provider=${lt(g)}
      ></wy-preview-embed>` : d === "none" ? l ? p`<wy-preview-icon src=${l} icon=${i} provider=${lt(g)}></wy-preview-icon>` : p`<wy-preview-icon src=${o} icon=${i}></wy-preview-icon>` : C;
  }
}, c(Kn, "WyPreviewItem"), Kn);
Vo.styles = [
  J,
  Z`
      :host {
        display: contents;
      }
    `
];
Hw([
  w({ type: Object })
], Vo.prototype, "file", 2);
Vo = Hw([
  B("wy-preview-item")
], Vo);
var db = Object.defineProperty, hb = Object.getOwnPropertyDescriptor, mo = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? hb(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && db(t, i, n), n;
}, "__decorateClass$J"), Gn;
let ps = (Gn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.noWrapper = !1, this.small = !1, this.hasEventListener = {
      "edit-name": !1,
      subscribe: !1,
      trash: !1,
      restore: !1,
      "delete-forever": !1
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  addEventListener(t, i, s) {
    if (this.hasEventListener) {
      const n = t;
      Object.prototype.hasOwnProperty.call(this.hasEventListener, n) && Object.assign(this.hasEventListener, {
        [n]: !0
      });
    }
    super.addEventListener(t, i, s);
  }
  triggerDownload() {
    this.file && Mo(this.file.download_url, "_top", this.file.name, !0);
  }
  triggerExternal() {
    this.file && Mo(this.file.external_url, "_blank", this.file.name);
  }
  triggerApplication() {
    this.file && Mo(this.file.application_url, "_top", this.file.name);
  }
  dispatchEditName() {
    const t = new CustomEvent("edit-name", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  dispatchSubscribe(t) {
    const i = new CustomEvent("subscribe", {
      detail: {
        file: this.file,
        subscribe: t
      }
    });
    return this.dispatchEvent(i);
  }
  dispatchTrash() {
    const t = new CustomEvent("trash", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  dispatchRestore() {
    const t = new CustomEvent("restore", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  dispatchDeleteForever() {
    const t = new CustomEvent("delete-forever", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  render() {
    var a;
    if (!this.file)
      return C;
    const { icon: t } = vs(this.file.name), i = this.file.id >= 1, s = this.file.provider, n = this.file.provider || "app";
    return p`
      <wy-dropdown directionX="left" ?noWrapper=${this.noWrapper} ?small=${this.small}>
        ${i && this.file.is_trashed ? p`
              ${this.hasEventListener.restore ? p`
                    <wy-dropdown-item @click=${() => this.dispatchRestore()}>
                      <wy-icon name="delete-restore"></wy-icon>
                      ${$("Restore")}
                    </wy-dropdown-item>
                  ` : C}
              ${this.hasEventListener.restore && this.hasEventListener["delete-forever"] ? p` <wy-dropdown-divider></wy-dropdown-divider> ` : C}
              ${this.hasEventListener["delete-forever"] ? p`
                    <wy-dropdown-item @click=${() => this.dispatchDeleteForever()}>
                      <wy-icon name="delete-forever"></wy-icon>
                      ${$("Delete")}
                    </wy-dropdown-item>
                  ` : C}
            ` : C}
        ${this.file.is_trashed ? C : p`
              ${this.file.external_url ? p`
                    <wy-dropdown-item @click=${() => this.triggerExternal()}>
                      <wy-icon name=${t}></wy-icon>
                      ${$(pt`Open in ${s}`)}
                    </wy-dropdown-item>
                  ` : p`
                    ${this.file.application_url && ((a = this.hasFeatures) != null && a.webDAV) ? p`
                          <wy-dropdown-item @click=${() => this.triggerApplication()}>
                            <wy-icon name=${this.file.provider ? py(this.file.provider) : t}></wy-icon>
                            ${$(pt`Open in ${n}`)}
                          </wy-dropdown-item>
                        ` : C}
                    <wy-dropdown-item @click=${() => this.triggerDownload()}>
                      <wy-icon name="download"></wy-icon>
                      ${$("Download")}
                    </wy-dropdown-item>
                  `}
              ${i ? p`
                    ${this.hasEventListener["edit-name"] ? p`
                          <wy-dropdown-item @click=${() => this.dispatchEditName()}>
                            <wy-icon name="textbox"></wy-icon>
                            ${$("Rename")}
                          </wy-dropdown-item>
                        ` : C}
                    ${this.hasEventListener.subscribe ? this.file.is_subscribed ? p`
                            <wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                              <wy-icon name="bell-off"></wy-icon>
                              ${$("Unsubscribe")}
                            </wy-dropdown-item>
                          ` : p`
                            <wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                              <wy-icon name="bell"></wy-icon>
                              ${$("Subscribe")}
                            </wy-dropdown-item>
                          ` : C}
                    ${this.hasEventListener.trash ? p`
                          <wy-dropdown-divider></wy-dropdown-divider>
                          <wy-dropdown-item @click=${() => this.dispatchTrash()}>
                            <wy-icon name="delete"></wy-icon>
                            ${$("Trash")}
                          </wy-dropdown-item>
                        ` : C}
                  ` : C}
            `}
        <slot></slot>
      </wy-dropdown>
    `;
  }
}, c(Gn, "WyFileMenu"), Gn);
mo([
  Qt({ context: Th, subscribe: !0 }),
  D()
], ps.prototype, "hasFeatures", 2);
mo([
  w({ type: Object })
], ps.prototype, "file", 2);
mo([
  w({ type: Boolean })
], ps.prototype, "noWrapper", 2);
mo([
  w({ type: Boolean })
], ps.prototype, "small", 2);
mo([
  w({ type: Object })
], ps.prototype, "hasEventListener", 2);
ps = mo([
  B("wy-file-menu"),
  st()
], ps);
function pb(r, t, i, s = {}) {
  return {
    ...s,
    initialPageParam: 0,
    queryKey: [t, i, "comments"],
    queryFn: /* @__PURE__ */ c(async (n) => {
      const a = n.pageParam, o = "/api/" + t + "/" + i + "/comments?order_by=id&skip=" + a, d = await (await r.fetch(o)).json();
      return d.data = d.data || [], d;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ c((n) => {
      if (n.end && n.end < n.count)
        return n.end;
    }, "getNextPageParam")
  };
}
c(pb, "getCommentsOptions");
function ub(r, t) {
  return {
    mutationFn: /* @__PURE__ */ c(async (s) => (await r.fetch("/api/comments/" + s.id, {
      method: "PATCH",
      body: JSON.stringify({
        text: s.text,
        blobs: s.blobs,
        attachments: s.attachments,
        meeting_id: s.meetingId,
        options: s.pollOptions.filter((a) => a.text.trim() !== "").map((a) => ({ id: a.id, text: a.text })),
        embed_id: s.embedId || null
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onSuccess: /* @__PURE__ */ c((s, n) => {
      n.id && _t(r.queryClient, [n.type, n.parentId, "comments"], n.id, (a) => {
        a.text = s.text, a.html = s.html, a.attachments = s.attachments, a.meeting = s.meeting, a.updated_at = s.updated_at, a.updated_by = s.updated_by, a.options = s.options, a.embed = s.embed;
      });
    }, "onSuccess")
  };
}
c(ub, "getUpdateCommentMutationOptions");
function yb(r) {
  const t = r.queryClient;
  return {
    mutationFn: /* @__PURE__ */ c(async (s) => (await r.fetch("/api/" + s.type + "/" + s.parentId + "/comments", {
      method: "POST",
      body: JSON.stringify({
        text: s.text,
        blobs: s.blobs,
        meeting_id: s.meetingId,
        options: s.pollOptions.filter((a) => a.text.trim() !== "").map((a) => ({ text: a.text })),
        embed_id: s.embedId
      })
    })).json(), "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (s) => {
      const n = [s.type, s.parentId, "comments"];
      await t.cancelQueries({ queryKey: n });
      const a = Bs(r.queryClient, n, !1);
      if (s.user) {
        const o = {
          id: a ? a.id - 1 : -1,
          app: s.type === "apps" ? { id: s.parentId } : { id: -1 },
          is_trashed: !1,
          text: s.text,
          html: s.text,
          plain: s.text,
          created_by: s.user,
          created_at: (/* @__PURE__ */ new Date()).toUTCString(),
          attachments: { count: 0 },
          reactions: { count: 0 },
          is_subscribed: !1,
          is_starred: !1
        };
        s.type === "files" ? o.parent = { type: Ne.File, id: s.parentId } : s.type === "posts" && (o.parent = { type: Ne.Post, id: s.parentId }), os(t, n, o, { descending: !1 });
      }
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((s, n) => {
      var l, d;
      const a = [n.type, ((l = s.parent) == null ? void 0 : l.id) ?? s.app.id, "comments"];
      if (!ml(r.queryClient, a, s.id)) {
        const u = Bs(r.queryClient, a, !0);
        u ? _t(r.queryClient, a, u.id, (y) => {
          y.id = s.id, y.app = s.app, y.text = s.text, y.html = s.html, y.embed = s.embed, y.meeting = s.meeting, y.attachments = s.attachments, y.options = s.options, y.created_at = s.created_at, y.created_by = s.created_by, y.updated_at = s.updated_at, y.updated_by = s.updated_by;
        }) : os(r.queryClient, a, s), ((d = s.parent) == null ? void 0 : d.type) === Ne.Post && _t(t, ["posts", s.app.id], s.parent.id, (y) => {
          y.comments ? y.comments.count += 1 : y.comments = { count: 1 };
        });
      }
    }, "onSuccess")
  };
}
c(yb, "getAddCommentMutationOptions");
function wb(r, t, i) {
  const s = r.queryClient, a = {
    mutationKey: [t, i, "comments"],
    mutationFn: /* @__PURE__ */ c(async ({ id: o }) => {
      if (!(await r.fetch("/api/comments/" + o + "/trash", { method: "POST" })).ok)
        throw new Error();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (o) => {
      nt(
        s,
        { queryKey: a.mutationKey, exact: !1 },
        o.id,
        (l) => Object.assign(l, { is_trashed: !0 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((o, l) => {
      nt(
        s,
        { queryKey: a.mutationKey, exact: !1 },
        l.id,
        (d) => Object.assign(d, o)
      ), _t(s, [l.type, l.appId], l.parentId, (d) => {
        d.comments.count -= 1;
      });
    }, "onSuccess")
  };
  return a;
}
c(wb, "getTrashCommentMutationOptions");
function fb(r, t, i) {
  return new bt(r.queryClient, wb(r, t, i));
}
c(fb, "getTrashCommentMutation");
function mb(r, t, i) {
  const s = r.queryClient, a = {
    mutationKey: [t, i, "comments"],
    mutationFn: /* @__PURE__ */ c(async ({ id: o }) => {
      const l = await r.fetch("/api/comments/" + o + "/restore", { method: "POST" });
      if (!l.ok) {
        const d = await l.json();
        throw new Error(d.detail || d.title, { cause: d });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (o) => {
      nt(
        s,
        { queryKey: a.mutationKey, exact: !1 },
        o.id,
        (l) => Object.assign(l, { is_trashed: !1 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((o, l) => {
      nt(
        s,
        { queryKey: a.mutationKey, exact: !1 },
        l.id,
        (d) => Object.assign(d, o)
      ), _t(s, [l.type, l.appId], l.parentId, (d) => {
        d.comments.count += 1;
      });
    }, "onSuccess")
  };
  return a;
}
c(mb, "getRestoreCommentMutationOptions");
function vb(r, t, i) {
  return new bt(r.queryClient, mb(r, t, i));
}
c(vb, "getRestoreCommentMutation");
var gb = Object.defineProperty, bb = Object.getOwnPropertyDescriptor, Vw = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? bb(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && gb(t, i, n), n;
}, "__decorateClass$I"), Yn;
let Bo = (Yn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this);
  }
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: { id: this.commentId } });
    return this.dispatchEvent(t);
  }
  render() {
    return p`
      <div class="wy-item">
        <div class="wy-item-body">${$("Comment was trashed.")}</div>
        <wy-button @click=${() => this.dispatchRestore()} class="wy-button-variant">${$("Undo")}</wy-button>
      </div>
    `;
  }
}, c(Yn, "WyCommentTrashed"), Yn);
Bo.styles = J;
Vw([
  w({ type: Number })
], Bo.prototype, "commentId", 2);
Bo = Vw([
  B("wy-comment-trashed"),
  st()
], Bo);
const xb = 1e3 * 60 * 60, zd = xb * 24;
function mc(r, t, i, s = 7) {
  i ?? (i = /* @__PURE__ */ new Date());
  const n = new Date(i.getFullYear(), i.getMonth(), i.getDate()), a = t.valueOf() - i.valueOf(), o = t.toDateString() === i.toDateString(), l = t.valueOf() > n.valueOf() - zd * s && t.valueOf() < n.valueOf() + zd * s;
  if (!o && l) {
    const d = Math.round(a / zd);
    return new Intl.RelativeTimeFormat(r, { numeric: "auto" }).format(d, "days");
  } else return o ? new Intl.DateTimeFormat(r, { timeStyle: "short" }).format(t) : new Intl.DateTimeFormat(r, { dateStyle: "short" }).format(t);
}
c(mc, "relativeTime");
var $b = Object.defineProperty, kb = Object.getOwnPropertyDescriptor, El = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? kb(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && $b(t, i, n), n;
}, "__decorateClass$H"), Zn;
let Zs = (Zn = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.totalVotes = 0, this.showSheet = !1, this.getVotesQuery = new be(this);
  }
  updated(t) {
    t.has("weavy") && this.weavy && this.option && this.option.id && this.getVotesQuery.trackQuery(jm(this.weavy, this.option.id));
  }
  dispatchVote(t) {
    if (!t)
      return;
    const i = new CustomEvent("vote", { detail: { id: t } });
    return this.dispatchEvent(i);
  }
  openSheet(t) {
    var i;
    t.preventDefault(), t.stopPropagation(), (i = this.getVotesQuery.observer) == null || i.refetch(), this.showSheet = !this.showSheet;
  }
  render() {
    var n, a;
    if (!this.option || !this.option.id)
      return C;
    const { data: t, isLoading: i } = this.getVotesQuery.result ?? {}, s = this.totalVotes > 0 ? Math.round((((n = this.option.votes) == null ? void 0 : n.count) || 0) / this.totalVotes * 100) : 0;
    return p`
      <div
        class="wy-item wy-list-item wy-poll-option"
        tabindex="0"
        @click=${() => {
      var o;
      return this.dispatchVote((o = this.option) == null ? void 0 : o.id);
    }}
        @keydown=${xe}
        @keyup=${je}
      >
        <div class="wy-progress" style="width: ${s + "%"}"></div>
        ${this.option.has_voted ? p`<wy-icon name="check-circle"></wy-icon>` : p`<wy-icon name="circle-outline"></wy-icon>`}
        <div class="wy-item-body">${this.option.text}</div>
        ${s > 0 ? p`<span
              class="wy-facepile"
              tabindex="0"
              @click=${(o) => this.openSheet(o)}
              @keydown=${xe}
              @keyup=${je}
            >
              ${s + "%"}
            </span>` : C}
      </div>

      ${this.weavy ? p`
            <wy-sheet
              .show=${this.showSheet}
              @close=${() => this.showSheet = !1}
              @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
            >
              <span slot="appbar-text">${$(pt`Votes on ${this.option.text}`)}</span>
              <!-- <wy-spinner></wy-spinner> -->
              ${this.showSheet && t && !i ? p`
                    ${(a = t.votes) != null && a.data ? t.votes.data.map(
      (o) => p`
                        <div class="wy-item wy-list-item">
                          <wy-avatar .size=${32} .src=${o.avatar_url} .name=${o.display_name}></wy-avatar>
                          <div class="wy-item-body">${o.display_name}</div>
                        </div>
                      `
    ) : C}
                  ` : C}
            </wy-sheet>
          ` : C}
    `;
  }
}, c(Zn, "WyPollOption"), Zn);
Zs.styles = J;
El([
  w({ type: Number, attribute: !1 })
], Zs.prototype, "totalVotes", 2);
El([
  w({ attribute: !1 })
], Zs.prototype, "option", 2);
El([
  D()
], Zs.prototype, "showSheet", 2);
Zs = El([
  B("wy-poll-option"),
  st()
], Zs);
var Cb = Object.defineProperty, _b = Object.getOwnPropertyDescriptor, Bw = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? _b(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && Cb(t, i, n), n;
}, "__decorateClass$G"), Xn;
let Uo = (Xn = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.pollOptions = [];
  }
  dispatchVote(t) {
    const i = new CustomEvent("vote", { detail: { id: t } });
    return this.dispatchEvent(i);
  }
  render() {
    const t = this.pollOptions.reduce((i, s) => {
      var n;
      return i + (((n = s.votes) == null ? void 0 : n.count) || 0);
    }, 0);
    return p`
      <div class="wy-poll">
        ${this.pollOptions.map(
      (i) => p`<wy-poll-option
              @vote=${(s) => this.dispatchVote(s.detail.id)}
              .option=${i}
              .totalVotes=${t}></wy-poll-option>`
    )}
      </div>
    `;
  }
}, c(Xn, "WyPoll"), Xn);
Uo.styles = [
  J,
  Z`
      :host {
        display: grid;
      }
    `
];
Bw([
  w({ type: Array, attribute: !1 })
], Uo.prototype, "pollOptions", 2);
Uo = Bw([
  B("wy-poll")
], Uo);
var Pb = Object.defineProperty, Mb = Object.getOwnPropertyDescriptor, fe = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? Mb(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && Pb(t, i, n), n;
}, "__decorateClass$F"), Jn;
let Kt = (Jn = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.location = "apps", this.createdAt = "", this.modifiedAt = void 0, this.isTrashed = !1, this.text = "", this.html = "", this.attachments = [], this.pollOptions = [], this.reactions = [], this.previewRef = rt(), this.highlightRef = rt(), this.highlight = !1;
  }
  dispatchVote(t) {
    const i = new CustomEvent("vote", { detail: { id: t } });
    return this.dispatchEvent(i);
  }
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.commentId } });
    return this.dispatchEvent(t);
  }
  dispatchEdit(t) {
    const i = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(i);
  }
  willUpdate(t) {
    t.has("link") && (this.highlight = !!(this.link && gl(this.link, Ne.Comment, { id: this.commentId }))), t.has("highlight") && (this.highlight ? this.part.add("wy-highlight") : this.part.remove("wy-highlight"));
  }
  render() {
    var a, o, l, d, u, y, m;
    const t = (a = this.attachments) == null ? void 0 : a.filter((f) => f.kind === "image" && f.thumbnail_url), i = (o = this.attachments) == null ? void 0 : o.filter((f) => f.kind !== "image" || !f.thumbnail_url), s = new Intl.DateTimeFormat((l = this.weavy) == null ? void 0 : l.locale, {
      dateStyle: "full",
      timeStyle: "short"
    }).format(new Date(this.createdAt)), n = mc((d = this.weavy) == null ? void 0 : d.locale, new Date(this.createdAt));
    return this.commentId < 0 ? p`<div class="wy-item wy-item-sm wy-comment-header">
            <wy-avatar
              .src="${this.createdBy.avatar_url}"
              .size=${32}
              .name=${this.createdBy.display_name}
              .isBot=${this.createdBy.is_bot}
            ></wy-avatar>
            <div class="wy-item-body">
              <div class="wy-item-title"><span class="wy-placeholder">${this.createdBy.display_name}</span></div>
              <div class="wy-item-text">
                <time class="wy-placeholder">${n}</time>
              </div>
            </div>
          </div>
          <div class="wy-comment-body">
            <div class="wy-comment-content">
              ${this.html ? p`<div class="wy-content"><wy-skeleton .text=${this.text}></wy-skeleton></div>` : ""}
            </div>
          </div>` : p`<div class="wy-item wy-comment-header" ${X(this.highlightRef)}>
            <wy-avatar
              .src=${this.createdBy.avatar_url}
              .size=${32}
              .name=${this.createdBy.display_name}
              .isBot=${this.createdBy.is_bot}
            ></wy-avatar>
            <div class="wy-item-body">
              <div class="wy-item-title">${this.createdBy.display_name}</div>
              <div class="wy-item-text">
                <time datetime=${this.createdAt} title=${s}>${n}</time>
                ${this.modifiedAt ? p`<time datetime=${this.modifiedAt}> · ${$("edited")}</time>` : C}
              </div>
            </div>

            ${this.user && this.user.id === this.createdBy.id ? p`
                  <div class="wy-item-actions wy-item-top">
                    <wy-dropdown>
                      ${this.user.id === this.createdBy.id ? p`<wy-dropdown-item @click=${() => this.dispatchEdit(!0)}>
                            <wy-icon name="pencil"></wy-icon>
                            ${$("Edit")}
                          </wy-dropdown-item>` : C}
                      ${this.user.id === this.createdBy.id ? p`<wy-dropdown-item @click=${() => this.dispatchTrash()}>
                            <wy-icon name="trashcan"></wy-icon>
                            ${$("Trash")}
                          </wy-dropdown-item>` : C}
                    </wy-dropdown>
                  </div>
                ` : C}
          </div>
          <div class="wy-comment-body">
            <div class="wy-comment-content">
              <!-- image grid -->
              ${t && t.length ? p`<wy-image-grid
                    .images=${t}
                    @file-open=${(f) => {
      var g;
      (g = this.previewRef.value) == null || g.open(f.detail.fileId);
    }}
                  ></wy-image-grid>` : ""}

              <!-- embeds -->
              ${this.embed && ((u = this.hasFeatures) != null && u.embeds) ? p` <wy-embed class="wy-embed" .embed=${this.embed}></wy-embed> ` : C}
              ${this.html ? p`<div class="wy-content">${qs(this.html)}</div>` : ""}

              <!-- poll -->
              ${this.pollOptions && this.pollOptions.length > 0 ? p`
                    <wy-poll
                      .pollOptions=${this.pollOptions}
                      @vote=${(f) => this.dispatchVote(f.detail.id)}
                    ></wy-poll>
                  ` : C}

              <!-- files -->
              ${i && i.length ? p`<wy-attachments-list
                    .files=${i ?? []}
                    @file-open=${(f) => {
      var g;
      (g = this.previewRef.value) == null || g.open(f.detail.fileId);
    }}
                  ></wy-attachments-list>` : ""}

              <!-- meeting -->
              ${this.meeting ? p`<wy-meeting-card .meeting=${this.meeting}></wy-meeting-card>` : ""}
            </div>
          </div>

          ${(y = this.hasFeatures) != null && y.reactions ? p` <wy-reactions
                lineBottom
                small
                .reactions=${this.reactions}
                parentType=${this.location}
                parentId=${this.parentId}
                entityId=${this.commentId}
                entityType="comments"
              ></wy-reactions>` : C}
          ${(m = this.attachments) != null && m.length ? p`<wy-preview ${X(this.previewRef)} .files=${this.attachments} .isAttachment=${!0}></wy-preview> ` : C} `;
  }
  updated(t) {
    var i;
    t.has("highlight") && this.highlight && ((i = this.highlightRef.value) == null || i.scrollIntoView({ block: "nearest" }));
  }
}, c(Jn, "WyCommentView"), Jn);
Kt.styles = J;
fe([
  w({ type: Number })
], Kt.prototype, "commentId", 2);
fe([
  w({ type: Number })
], Kt.prototype, "parentId", 2);
fe([
  w({ attribute: !1 })
], Kt.prototype, "location", 2);
fe([
  w({ attribute: !1 })
], Kt.prototype, "createdBy", 2);
fe([
  w()
], Kt.prototype, "createdAt", 2);
fe([
  w()
], Kt.prototype, "modifiedAt", 2);
fe([
  w({ type: Boolean })
], Kt.prototype, "isTrashed", 2);
fe([
  w()
], Kt.prototype, "text", 2);
fe([
  w()
], Kt.prototype, "html", 2);
fe([
  w({ type: Array })
], Kt.prototype, "attachments", 2);
fe([
  w({ attribute: !1 })
], Kt.prototype, "embed", 2);
fe([
  w({ type: Array })
], Kt.prototype, "pollOptions", 2);
fe([
  w({ attribute: !1 })
], Kt.prototype, "meeting", 2);
fe([
  w({ type: Array })
], Kt.prototype, "reactions", 2);
fe([
  w({ type: Boolean })
], Kt.prototype, "highlight", 2);
Kt = fe([
  B("wy-comment-view"),
  st()
], Kt);
var Uw = "Expected a function", Ou = NaN, zb = "[object Symbol]", Sb = /^\s+|\s+$/g, Eb = /^[-+]0x[0-9a-f]+$/i, Ob = /^0b[01]+$/i, Ab = /^0o[0-7]+$/i, Lb = parseInt, Rb = typeof zc == "object" && zc && zc.Object === Object && zc, Ib = typeof self == "object" && self && self.Object === Object && self, Tb = Rb || Ib || Function("return this")(), Fb = Object.prototype, Db = Fb.toString, Hb = Math.max, Vb = Math.min, Sd = /* @__PURE__ */ c(function() {
  return Tb.Date.now();
}, "now");
function Bb(r, t, i) {
  var s, n, a, o, l, d, u = 0, y = !1, m = !1, f = !0;
  if (typeof r != "function")
    throw new TypeError(Uw);
  t = Au(t) || 0, tl(i) && (y = !!i.leading, m = "maxWait" in i, a = m ? Hb(Au(i.maxWait) || 0, t) : a, f = "trailing" in i ? !!i.trailing : f);
  function g(V) {
    var q = s, N = n;
    return s = n = void 0, u = V, o = r.apply(N, q), o;
  }
  c(g, "invokeFunc");
  function x(V) {
    return u = V, l = setTimeout(P, t), y ? g(V) : o;
  }
  c(x, "leadingEdge");
  function k(V) {
    var q = V - d, N = V - u, H = t - q;
    return m ? Vb(H, a - N) : H;
  }
  c(k, "remainingWait");
  function S(V) {
    var q = V - d, N = V - u;
    return d === void 0 || q >= t || q < 0 || m && N >= a;
  }
  c(S, "shouldInvoke");
  function P() {
    var V = Sd();
    if (S(V))
      return E(V);
    l = setTimeout(P, k(V));
  }
  c(P, "timerExpired");
  function E(V) {
    return l = void 0, f && s ? g(V) : (s = n = void 0, o);
  }
  c(E, "trailingEdge");
  function z() {
    l !== void 0 && clearTimeout(l), u = 0, s = d = n = l = void 0;
  }
  c(z, "cancel");
  function U() {
    return l === void 0 ? o : E(Sd());
  }
  c(U, "flush");
  function O() {
    var V = Sd(), q = S(V);
    if (s = arguments, n = this, d = V, q) {
      if (l === void 0)
        return x(d);
      if (m)
        return l = setTimeout(P, t), g(d);
    }
    return l === void 0 && (l = setTimeout(P, t)), o;
  }
  return c(O, "debounced"), O.cancel = z, O.flush = U, O;
}
c(Bb, "debounce");
function Ub(r, t, i) {
  var s = !0, n = !0;
  if (typeof r != "function")
    throw new TypeError(Uw);
  return tl(i) && (s = "leading" in i ? !!i.leading : s, n = "trailing" in i ? !!i.trailing : n), Bb(r, t, {
    leading: s,
    maxWait: t,
    trailing: n
  });
}
c(Ub, "throttle");
function tl(r) {
  var t = typeof r;
  return !!r && (t == "object" || t == "function");
}
c(tl, "isObject");
function qb(r) {
  return !!r && typeof r == "object";
}
c(qb, "isObjectLike");
function Nb(r) {
  return typeof r == "symbol" || qb(r) && Db.call(r) == zb;
}
c(Nb, "isSymbol");
function Au(r) {
  if (typeof r == "number")
    return r;
  if (Nb(r))
    return Ou;
  if (tl(r)) {
    var t = typeof r.valueOf == "function" ? r.valueOf() : r;
    r = tl(t) ? t + "" : t;
  }
  if (typeof r != "string")
    return r === 0 ? r : +r;
  r = r.replace(Sb, "");
  var i = Ob.test(r);
  return i || Ab.test(r) ? Lb(r.slice(2), i ? 2 : 8) : Eb.test(r) ? Ou : +r;
}
c(Au, "toNumber");
var jb = Ub;
const el = /* @__PURE__ */ k1(jb);
function Wb(r, t) {
  return new bt(r.queryClient, {
    mutationFn: /* @__PURE__ */ c(async () => await r.fetch(`/api/apps/${t}/typing`, {
      method: "PUT",
      body: JSON.stringify({})
    }), "mutationFn")
  });
}
c(Wb, "typingMutation");
function Lu(r, t) {
  return new bt(r.queryClient, {
    mutationFn: /* @__PURE__ */ c(async () => {
      const i = await r.fetch(`/x/${t}/meetings`, { method: "POST" });
      if (!i.ok)
        throw new Error("Failed to create meeting");
      return await i.json();
    }, "mutationFn")
  });
}
c(Lu, "addMeetingMutation");
function Lt(r, t, i, s) {
  const n = r.getMutationCache(), a = n.find({
    mutationKey: t,
    predicate: /* @__PURE__ */ c((o) => o.state.variables === i, "predicate")
  });
  if (a && a.state.context) {
    const o = { ...a.state.context };
    s(o);
    const l = { ...a.state, context: o };
    a.state = l, n.notify({
      mutation: a,
      type: "updated",
      action: {
        type: "pending",
        context: a.state.context,
        variables: a.state.variables,
        isPaused: !1
      }
    });
  }
}
c(Lt, "updateMutationContext");
function qw(r, t, i) {
  const s = r.getMutationCache().find({ mutationKey: t, exact: !0, predicate: i });
  s && r.getMutationCache().remove(s);
}
c(qw, "removeMutation");
function Qb(r, t) {
  const i = r.getMutationCache();
  i.findAll({ mutationKey: t, exact: !0 }).forEach((n) => {
    i.remove(n);
  });
}
c(Qb, "removeMutations");
const rp = /* @__PURE__ */ c((r, t, i = 0, s = "application/octet-stream", n, a = Date.now()) => {
  const o = r && (r instanceof URL ? r.toString() : URL.createObjectURL(r));
  return {
    id: a,
    app: { id: -1 },
    refId: a,
    name: t,
    kind: Gh(t),
    size: i,
    media_type: s,
    embed_url: "",
    preview_format: Zg(t),
    thumbnail_url: o,
    preview_url: o,
    download_url: o,
    rev: -1,
    created_by: n,
    created_at: (/* @__PURE__ */ new Date()).toUTCString(),
    is_subscribed: !1,
    is_trashed: !1,
    is_starred: !1
  };
}, "getTempFile");
function Kb(r) {
  const t = r ? r.reduce(
    (i, s) => {
      var a, o;
      const n = (a = s.context) == null ? void 0 : a.file;
      return n && ((o = s.context) != null && o.status.progress) && n.size ? {
        loaded: i.loaded + s.context.status.progress * n.size,
        total: i.total + n.size
      } : i;
    },
    { loaded: 0, total: 0 }
  ) : { loaded: 0, total: 0 };
  return {
    loaded: t.loaded,
    total: t.total,
    percent: t.total > 0 ? t.loaded / t.total : null
  };
}
c(Kb, "getFileMutationsTotalProgress");
function Gb(r) {
  return r ? r.some((t) => {
    var i;
    return ((i = t.context) == null ? void 0 : i.status.state) === "conflict";
  }) ? "conflict" : r.some((t) => t.status === "error") ? "error" : r.every((t) => t.status === "success") ? "ok" : "pending" : "ok";
}
c(Gb, "getFileMutationsTotalStatus");
function Yb(r) {
  return (r == null ? void 0 : r.filter((t) => {
    var i;
    return ((i = t.context) == null ? void 0 : i.status.state) === "conflict" || t.status === "error";
  })) || [];
}
c(Yb, "getFileMutationsByConflictOrError");
function Zb(r, t, i) {
  const s = r.queryClient;
  s.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "files"],
    exact: !0,
    predicate: /* @__PURE__ */ c((n) => {
      var a, o;
      return /error|success/.test(n.state.status) && ((o = (a = n.state.variables) == null ? void 0 : a.blob) == null ? void 0 : o.name) === i;
    }, "predicate")
  }).forEach((n) => {
    s.getMutationCache().remove(n);
  });
}
c(Zb, "removeSettledFileMutations");
function Xb(r, t, i) {
  const s = r.queryClient, n = ["apps", i.id, "files"];
  return {
    mutationFn: /* @__PURE__ */ c(async ({ blob: o, replace: l = !1 }) => {
      const d = await r.fetch("/api/apps/" + i.id + "/files", {
        method: "POST",
        body: JSON.stringify({ blob_id: o.id, replace: l })
      });
      if (!d.ok) {
        const u = await d.json();
        throw new Error(u.detail || u.title, { cause: u });
      }
      return await d.json();
    }, "mutationFn"),
    mutationKey: n,
    onMutate: /* @__PURE__ */ c(async (o) => {
      await s.cancelQueries({ queryKey: n, exact: !0 }), Jb(r, i, o.blob.name), Zb(r, i, o.blob.name);
      let l;
      try {
        l = o.blob.thumbnail_url && new URL(o.blob.thumbnail_url) || void 0;
      } catch {
      }
      const d = rp(l, o.blob.name, o.blob.size, o.blob.media_type, t);
      return {
        type: o.replace ? "replace" : "create",
        file: d,
        status: { state: "pending" }
      };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((o, l, d) => (Lt(s, n, l, (u) => {
      u && (u.status.state = "ok", u.status.progress = void 0, u.status.text = void 0);
    }), s.invalidateQueries({ queryKey: n })), "onSuccess"),
    onError(o, l, d) {
      var u, y, m;
      ((u = o == null ? void 0 : o.cause) == null ? void 0 : u.status) === 409 ? Lt(s, n, l, (f) => {
        f && (f.status.progress = void 0, f.status.state = "conflict", f.status.text = o.message);
      }) : ((y = d == null ? void 0 : d.file) != null && y.refId || ((m = d == null ? void 0 : d.file) == null || m.id), Lt(s, n, l, (f) => {
        f && (f.status.state = "error", f.status.progress = void 0, f.status.text = o.message);
      }));
    }
  };
}
c(Xb, "getCreateFileMutationOptions");
function Jb(r, t, i, s) {
  const n = r.queryClient;
  n.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "blobs", s],
    exact: !0,
    status: "success",
    predicate: /* @__PURE__ */ c((a) => {
      var o;
      return ((o = a.state.data) == null ? void 0 : o.name) === i;
    }, "predicate")
  }).forEach((a) => {
    n.getMutationCache().remove(a);
  });
}
c(Jb, "removeSuccessfulUploadBlobMutations");
async function Nw(r, t, i) {
  const s = new FormData();
  s.append("blob", t);
  const n = await r.upload("/api/blobs", "POST", s, Dc.Auto, (o) => {
    i && i({ progress: o });
  });
  if (!n.ok) {
    const o = await n.json();
    throw new Error(o.detail || o.title, { cause: o });
  }
  return await n.json();
}
c(Nw, "uploadBlob");
function t2(r) {
  return {
    mutationFn: /* @__PURE__ */ c(async (i) => await Nw(r, i.file, i.onProgress), "mutationFn")
    // TODO: implement onmutate, onsuccess, onerror...
  };
}
c(t2, "getSimpleUploadBlobMutationOptions");
function jw(r, t, i, s) {
  const n = r.queryClient, a = ["apps", i.id, "blobs", s];
  return {
    mutationFn: /* @__PURE__ */ c(async (l) => await Nw(r, l.file, l.onProgress), "mutationFn"),
    mutationKey: a,
    onMutate: /* @__PURE__ */ c(async (l) => {
      await n.cancelQueries({ queryKey: a, exact: !0 });
      const d = rp(l.file, l.file.name, l.file.size, l.file.type, t);
      return l.onProgress = ({ progress: u }) => {
        Lt(n, a, l, (y) => {
          y.status.state = "pending", y.status.progress = u;
        });
      }, { type: "upload", file: d, status: { state: "pending" } };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((l, d, u) => {
      Lt(n, a, d, (y) => {
        y.status.state = "ok", y.status.progress = void 0, y.status.text = void 0;
      });
    }, "onSuccess"),
    onError(l, d, u) {
      const y = l.cause;
      y && y.status === 409 ? Lt(n, a, d, (m) => {
        m.status.state = "conflict", m.status.progress = void 0, m.status.text = y.detail || y.title;
      }) : Lt(n, a, d, (m) => {
        m && (m.status.state = "error", m.status.progress = void 0, m.status.text = y.detail || y.title);
      });
    }
  };
}
c(jw, "getUploadBlobMutationOptions");
function Ru(r, t) {
  return r.findAll(t.filters).map(
    (i) => t.select ? t.select(i) : i.state
  );
}
c(Ru, "getResult");
const Hp = class Hp {
  constructor(t) {
    this.alwaysUpdate = !1, t.addController(this), this.host = t, this.setContext();
  }
  async setContext() {
    this.whenContext = new Promise((t) => this.resolveContext = t), await oo(this.host), this.context = new as(this.host, { context: Xt, subscribe: !0 });
  }
  hostUpdate() {
    var t, i;
    (t = this.context) != null && t.value && ((i = this.resolveContext) == null || i.call(this));
  }
  async trackMutationState(t, i) {
    var s, n, a;
    if (i || (await this.whenContext, i = (n = (s = this.context) == null ? void 0 : s.value) == null ? void 0 : n.queryClient), !i)
      throw new Error("No QueryClient provided");
    return (a = this.mutationCacheUnsubscribe) == null || a.call(this), this.options = t, this.mutationCache = i.getMutationCache(), this.mutationCacheSubscribe(), this.result;
  }
  mutationCacheSubscribe() {
    this.mutationCache && this.options && (this.result = Ru(this.mutationCache, this.options), this.mutationCacheUnsubscribe = this.mutationCache.subscribe((t) => {
      if (this.mutationCache && this.options && /added|removed|updated/.test(t.type)) {
        const i = Ru(this.mutationCache, this.options);
        (this.result !== i || ko(this.result, i)) && (this.result = i, this.host.requestUpdate());
      }
    }), this.host.requestUpdate());
  }
  untrackMutationState() {
    var t;
    (t = this.mutationCacheUnsubscribe) == null || t.call(this), this.mutationCacheUnsubscribe = void 0, this.result = void 0, this.options = void 0, this.mutationCache = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.mutationCacheSubscribe();
  }
  hostDisconnected() {
    var t;
    (t = this.mutationCacheUnsubscribe) == null || t.call(this);
  }
};
c(Hp, "MutationStateController");
let il = Hp;
async function e2(r, t) {
  const i = await r.fetch("/api/blobs/external", { method: "POST", body: JSON.stringify(t) });
  if (!i.ok) {
    const n = await i.json();
    throw new Error(n.detail || n.title, { cause: n });
  }
  return await i.json();
}
c(e2, "externalBlob");
function i2(r, t, i, s) {
  const n = r.queryClient, a = ["apps", i.id, "blobs", s];
  return {
    mutationFn: /* @__PURE__ */ c(async (l) => await e2(r, l.externalBlob), "mutationFn"),
    mutationKey: a,
    onMutate: /* @__PURE__ */ c(async (l) => (await n.cancelQueries({ queryKey: a, exact: !0 }), { type: "attach", file: rp(void 0, l.externalBlob.name, l.externalBlob.size, void 0, t), status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ c((l, d, u) => {
      Lt(n, a, d, (y) => {
        y.status.state = "ok", y.status.progress = void 0, y.status.text = void 0;
      });
    }, "onSuccess"),
    onError(l, d, u) {
      const y = l.cause;
      y && y.status === 409 ? Lt(n, a, d, (m) => {
        m.status.state = "conflict", m.status.progress = void 0, m.status.text = y.detail || y.title;
      }) : Lt(n, a, d, (m) => {
        m && (m.status.state = "error", m.status.progress = void 0, m.status.text = y.detail || y.title);
      });
    }
  };
}
c(i2, "getExternalBlobMutationOptions");
function Ww(r, t, i, s) {
  return new bt(r.queryClient, i2(r, t, i, s));
}
c(Ww, "getExternalBlobMutation");
const s2 = /(((https?|ftp):\/\/|(www|ftp)\.)[\w]+(.[\w]+)([\w\-.,@?^=%&amp;:/~+#]*[\w\-@?^=%&amp;/~+#]))/gim;
let yr = [], qo = [], sl = [], Ac = [], Ai = {};
const r2 = /* @__PURE__ */ c((r, t) => r.length === t.length && r.every((i, s) => i === t[s]), "arrayEquals");
function n2() {
  return !!Object.keys(Ai).length;
}
c(n2, "isFetchingEmbeds");
async function a2(r, t) {
  new FormData().append("url", r);
  let s;
  try {
    const n = await t.fetch("/api/embeds", { method: "POST", body: JSON.stringify({ url: r }) });
    if (!n.ok)
      throw new Error();
    s = await n.json(), delete Ai[r], qo = [...qo, r];
  } catch {
    sl = [...sl, r], delete Ai[r];
  }
  return s;
}
c(a2, "fetchEmbed");
const o2 = /* @__PURE__ */ c(() => {
  yr = [], qo = [], sl = [], Ac = [], Ai = {};
}, "clearEmbeds"), Iu = /* @__PURE__ */ c((r) => {
  qo = r;
}, "initEmbeds"), c2 = /* @__PURE__ */ c(async (r, t, i) => {
  var n;
  let s = ((n = r.match(s2)) == null ? void 0 : n.map((a) => a)) || null;
  if (s !== null && (s = s.map((a) => a.startsWith("//") ? "http:" + a : !a.startsWith("http://") && !a.startsWith("https://") ? "http://" + a : a)), !(s === null || s.length === 0)) {
    if (s.length !== yr.length || !r2(s, yr)) {
      yr = s, s.forEach((a) => {
        !qo.includes(a) && !sl.includes(a) && !Ac.includes(a) && typeof Ai[a] > "u" && (Se(), Ai[a] = window.setTimeout(async () => {
          const o = await a2(a, i);
          o && t(o);
        }, 500));
      }), Ac = Ac.filter((a) => yr.includes(a));
      for (const a in Ai)
        yr.includes(a) || (Se(), window.clearTimeout(Ai[a]), delete Ai[a]);
    }
  }
}, "getEmbeds");
var ta;
const Vp = class Vp {
  constructor(t) {
    T(this, ta, !1);
    t.addController(this), this.host = t, t.addEventListener("dragstart", () => this.isDragActive = !0), t.addEventListener("dragenter", () => this.isDragActive = !0), t.addEventListener("dragover", (i) => {
      i.preventDefault(), this.isDragActive = !0;
    }), t.addEventListener("dragleave", () => this.isDragActive = !1), t.addEventListener("dragend", () => this.isDragActive = !1), t.addEventListener("drop", (i) => this.handleDrop(i));
  }
  get isDragActive() {
    return b(this, ta);
  }
  set isDragActive(t) {
    b(this, ta) !== t && (I(this, ta, t), this.host.requestUpdate());
  }
  handleDrop(t) {
    var s, n;
    t.preventDefault();
    const i = [];
    (s = t.dataTransfer) != null && s.items ? [...t.dataTransfer.items].forEach((a) => {
      if (a.kind === "file") {
        const o = a.getAsFile();
        o ? i.push(o) : console.error("Could not add file");
      }
    }) : (n = t.dataTransfer) != null && n.files && [...t.dataTransfer.files].forEach((a) => {
      i.push(a);
    }), i.length && this.dispatchUploadFiles(i), this.isDragActive = !1;
  }
  dispatchUploadFiles(t) {
    const i = new CustomEvent("drop-files", { detail: { files: t } });
    return this.host.dispatchEvent(i);
  }
  hostDisconnected() {
  }
};
ta = new WeakMap(), c(Vp, "DropZoneController");
let rl = Vp;
const Be = Ph() ? window.navigator.userAgent : "", Qw = Be.includes("iPad") || Be.includes("Android") && !Be.includes("Mobi") || !1, l2 = Be.includes("Mobi") || Qw || !1, d2 = !l2 && !Qw, Tu = Be.includes("Windows") ? "Windows" : Be.includes("Macintosh") ? "Mac" : Be.includes("iPad") || Be.includes("iPhone") || Be.includes("iPod") ? "iOS" : Be.includes("Android") ? "Android" : void 0;
Tu === "Android" && Be.includes("; wv") || Tu === "iOS" && Be.includes("Safari");
var h2 = Object.defineProperty, p2 = Object.getOwnPropertyDescriptor, vo = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? p2(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && h2(t, i, n), n;
}, "__decorateClass$E"), ea;
let Hi = (ea = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.status = {
      state: "ok"
    }, this.hasHover = !0, this.isRenaming = !1;
  }
  dispatchEditName(t) {
    const i = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(i);
  }
  dispatchRename(t, i) {
    const s = new CustomEvent("rename", { detail: { file: t, name: i } });
    return this.dispatchEvent(s);
  }
  dispatchTrash(t) {
    const i = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(i);
  }
  dispatchRestore(t) {
    const i = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(i);
  }
  dispatchDeleteForever(t) {
    const i = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(i);
  }
  dispatchSubscribe(t, i) {
    const s = new CustomEvent("subscribe", { detail: { file: t, subscribe: i } });
    return this.dispatchEvent(s);
  }
  render() {
    const t = this.file;
    if (!t) return C;
    const { icon: i } = vs(t.name), s = zg(this.actionType), n = ai(t.name), a = yo(t.provider), o = /* @__PURE__ */ c((d) => {
      d.stopImmediatePropagation();
      const u = d.target;
      u.value && u.value !== t.name ? this.dispatchRename(t, u.value) : this.dispatchEditName({ id: NaN });
    }, "handleRename"), l = /* @__PURE__ */ c((d) => {
      const u = d.target;
      d.key === "Escape" ? (d.preventDefault(), u.value = t.name, u.blur()) : d.key === "Enter" && (d.preventDefault(), u.blur());
    }, "handleRenameKey");
    return p`
      <div
        class="wy-item wy-list-item ${Rt({
      "wy-item-trashed": t.is_trashed,
      "wy-item-hover": this.hasHover && !t.is_trashed && !this.isRenaming
    })}"
        title=${t.name}>
        ${this.status.state === "error" ? p`<wy-icon name="alert-octagon" color="error" title=${lt(this.status.text)}></wy-icon>` : this.status.state === "conflict" ? p`<wy-icon name="alert" color="yellow" title=${lt(this.status.text)}></wy-icon>` : this.status.state === "pending" ? p`<wy-spinner ?nospin=${!!this.status.progress} .progress=${this.status.progress}></wy-spinner>` : p`<wy-icon .name=${i} .overlayName=${a} .overlayPath=${s} .size=${24} .kind=${t.kind} ext=${n}></wy-icon>`}
        <div class="wy-item-body">
          ${this.isRenaming ? p`
                <input
                  type="text"
                  maxlength="256"
                  class="wy-input"
                  .defaultValue=${t.name}
                  @blur=${o}
                  @keyup=${(d) => {
      Ti(d), l(d);
    }}
                  @click=${(d) => d.preventDefault()}
                  @focus=${Yh}
                  ${X(Mh)} />
              ` : p`
                <span title=${t.name + (this.status.text ? `: ${this.status.text}` : "")}
                  ><slot name="title"
                    >${this.title || t.name}${this.status.text ? p`: <em>${this.status.text}</em>` : C}</slot
                  ></span
                >
              `}
        </div>
        <div class="wy-item-actions">
          <slot name="actions">
            <wy-file-menu
              .file=${t}
              @edit-name=${(d) => this.dispatchEditName(d.detail.file)}
              @trash=${(d) => this.dispatchTrash(d.detail.file)}
              @restore=${(d) => this.dispatchRestore(d.detail.file)}
              @delete-forever=${(d) => this.dispatchDeleteForever(d.detail.file)}
              @subscribe=${(d) => this.dispatchSubscribe(d.detail.file, d.detail.subscribe)}>
            </wy-file-menu>
          </slot>
        </div>
      </div>
    `;
  }
}, c(ea, "WyFileItem"), ea);
Hi.styles = J;
vo([
  w({ type: Object })
], Hi.prototype, "file", 2);
vo([
  w({ type: Object })
], Hi.prototype, "status", 2);
vo([
  w({ type: Boolean })
], Hi.prototype, "hasHover", 2);
vo([
  w()
], Hi.prototype, "actionType", 2);
vo([
  D()
], Hi.prototype, "isRenaming", 2);
Hi = vo([
  B("wy-file-item")
], Hi);
var u2 = Object.defineProperty, y2 = Object.getOwnPropertyDescriptor, St = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? y2(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && u2(t, i, n), n;
}, "__decorateClass$D"), ia;
let xt = (ia = class extends zt(j) {
  constructor() {
    super(), this.exportParts = new Q(this), this.disabled = !1, this._placeholder = "", this.text = "", this.options = [], this.attachments = [], this.buttonText = "", this.typing = !0, this.draft = !1, this.editorType = "posts", this.editorClass = "wy-post-editor", this.editorLocation = "apps", this.editorError = !1, this.showPolls = !1, this.pollOptions = [], this.embeds = [], this.draftKey = "", this.uploadBlobMutation = new Ae(
      this
    ), this.mutatingFiles = new il(this), this.fileInputRef = rt(), this.cloudFilesRef = rt(), this.dropZone = new rl(this), this.keyMap = [], this.editorRef = rt(), this.editorInitialized = !1, this.throttledTyping = el(
      async () => {
        this.weavy && this.app && (this.app.type === ct.ChatRoom || this.app.type === ct.PrivateChat) && await (await Wb(this.weavy, this.app.id)).mutate();
      },
      2e3,
      { leading: !0, trailing: !1 }
    ), this.throttledDrafting = el(
      async () => {
        this.saveDraft();
      },
      500,
      { leading: !0, trailing: !0 }
    ), this.openFileInput = () => {
      var t;
      (t = this.fileInputRef.value) == null || t.click();
    }, this.openCloudFiles = () => {
      var t;
      (t = this.cloudFilesRef.value) == null || t.open();
    }, this.createMeeting = async (t) => {
      if (this.weavy && t.source === this.authWindow && this.weavy.url.origin === t.origin && t.data && t.data.name && t.data.name.endsWith("-authorized")) {
        const i = t.data.name.slice(0, -11), n = await Lu(this.weavy, i).mutate();
        n.auth_url || (this.meeting = n);
      }
    }, this.addEventListener("drop-files", this.handleDropFiles), this.addEventListener("keydown", jc), this.addEventListener("keyup", Ti);
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(t) {
    this._placeholder = t;
  }
  willUpdate(t) {
    var i;
    if (super.willUpdate(t), (t.has("weavy") || t.has("app") || t.has("user") || t.has("parentId")) && this.weavy && this.app && this.user) {
      this.draftKey = `draft-${this.editorType}-${this.parentId || this.app.id}`, this.uploadBlobMutation.trackMutation(
        jw(
          this.weavy,
          this.user,
          this.app,
          `${this.editorLocation}-${this.parentId || this.app.id}`
        )
      );
      const s = [
        "apps",
        this.app.id,
        "blobs",
        `${this.editorLocation}-${this.parentId || this.app.id}`
      ];
      if (this.mutatingFiles.trackMutationState(
        { filters: { mutationKey: s, exact: !0 } },
        this.weavy.queryClient
      ), this.externalBlobMutation = Ww(
        this.weavy,
        this.user,
        this.app,
        `${this.editorLocation}-${this.parentId || this.app.id}`
      ), this.draft) {
        const n = localStorage.getItem(this.draftKey);
        if (n) {
          const a = JSON.parse(n);
          this.text = a.text, this.embeds = a.embeds, this.meeting = a.meeting, ((i = a.pollOptions) == null ? void 0 : i.length) > 0 && (this.showPolls = !0, this.pollOptions = a.pollOptions), Iu(this.embeds.map((o) => o.original_url));
        } else
          this.clearEditor();
      }
      this.embed && (this.embeds = [this.embed], Iu(this.embeds.map((n) => n.original_url))), this.options && this.options.length > 0 && (this.pollOptions = this.options, this.showPolls = !0);
    }
    t.has("text") && this.editor && this.editor.dispatch({ changes: { from: 0, to: this.editor.state.doc.length, insert: this.text } });
  }
  updated(t) {
    if ((t.has("weavy") || t.has("app") || t.has("user") || t.has("parentId")) && this.weavy && this.app && this.user && this.editorRef.value && this.weavy.whenUrl().then(() => {
      import(
        /* webpackIgnore: true */
        /* @vite-ignore */
        new URL("./es/editor.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
      ).then((i) => i.editor).then(
        ({
          weavyHighlighter: i,
          syntaxHighlighting: s,
          history: n,
          dropCursor: a,
          mentions: o,
          autocompletion: l,
          placeholder: d,
          keymap: u,
          weavyKeymap: y,
          defaultKeymap: m,
          historyKeymap: f,
          markdown: g,
          languages: x,
          EditorView: k,
          EditorState: S,
          weavyDesktopMessageKeymap: P,
          Compartment: E
        }) => {
          var U, O, V;
          this.editorInitialized = !0, this.editorRef.value && !this.editor && (this.editorRef.value.innerHTML = ""), this.editorEditable = new E(), this.EditorView = k;
          const z = this.editorType === "messages" && d2 && P ? [...P] : [];
          this.editorExtensions = [
            k.contentAttributes.of({
              spellcheck: "true",
              autocorrect: "on",
              autocapitalize: "on"
            }),
            n(),
            a(),
            o,
            l({
              override: (U = this.hasFeatures) != null && U.mentions ? [(q) => this.autocomplete(q)] : null,
              //showMention
              closeOnBlur: !1,
              aboveCursor: this.editorType !== "posts",
              icons: !1,
              addToOptions: [
                {
                  render: /* @__PURE__ */ c(function(q, N) {
                    var wt, ut, vt, he;
                    const H = document.createElement("div");
                    H.classList.add("wy-item"), H.classList.add("wy-list-item"), H.classList.add("wy-item-hover"), (!((wt = q.item) != null && wt.access) || q.item.access === Wi.None) && H.classList.add("wy-disabled");
                    const W = document.createElement("wy-avatar");
                    W.src = ((ut = q.item) == null ? void 0 : ut.avatar_url) || "", W.name = ((vt = q.item) == null ? void 0 : vt.display_name) || "";
                    const ft = document.createElement("div");
                    return ft.classList.add("wy-item-body"), ft.innerText = ((he = q.item) == null ? void 0 : he.display_name) || "", H.appendChild(W), H.appendChild(ft), H;
                  }, "render"),
                  position: 10
                }
              ]
            }),
            d(this.placeholder),
            s(i, { fallback: !0 }),
            k.lineWrapping,
            u.of([...z, ...y, ...m, ...f]),
            g({ codeLanguages: x }),
            k.domEventHandlers({
              paste: /* @__PURE__ */ c((q, N) => {
                var ft, wt;
                let H = [];
                const W = ((ft = q.clipboardData) == null ? void 0 : ft.items) || [];
                for (const ut in W) {
                  const vt = W[ut];
                  if (vt.kind === "file") {
                    const he = vt.getAsFile();
                    he && (H = [...H, he]);
                  }
                }
                if (H.length > 0 && ((wt = this.hasFeatures) != null && wt.attachments)) {
                  for (let ut = 0; ut < H.length; ut++)
                    this.handleUploadFiles(H);
                  return !0;
                }
              }, "paste"),
              keyup: /* @__PURE__ */ c((q, N) => {
                var H, W;
                this.typing && N.state.doc.toString() !== "" && ((H = this.hasFeatures) != null && H.typing) && this.throttledTyping(), this.draft && this.throttledDrafting(), (W = this.hasFeatures) != null && W.embeds && N.state.doc.toString() !== "" && this.handleEmbeds(N.state.doc.toString());
              }, "keyup")
            }),
            k.updateListener.of((q) => {
            }),
            this.editorEditable.of(k.editable.of(!this.disabled))
          ], this.editor ? this.editor.dispatch({
            // Update readonly state
            effects: this.editorEditable.reconfigure(k.editable.of(!this.disabled))
          }) : (this.editor = new k({
            state: S.create({
              doc: this.text,
              extensions: this.editorExtensions
            }),
            parent: this.editorRef.value
          }), (V = (O = this.editorRef.value) == null ? void 0 : O.querySelector(".cm-editor")) == null || V.addEventListener("Weavy-SoftSubmit", this.submit.bind(this)));
        }
      );
    }), t.has("disabled") && this.editor && this.editorEditable && this.EditorView && this.editor.dispatch({
      // Update readonly state
      effects: this.editorEditable.reconfigure(this.EditorView.editable.of(!this.disabled))
    }), t.has("placeholder")) {
      const i = this.renderRoot.querySelector(".cm-placeholder");
      i && this.editor && (i.setAttribute("aria-label", `placeholder ${this.placeholder}`), i.innerText = this.placeholder);
    }
  }
  connectedCallback() {
    super.connectedCallback(), window.addEventListener("message", this.createMeeting);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("message", this.createMeeting);
  }
  handleRemoveMeeting() {
    this.meeting = void 0;
  }
  async autocomplete(t) {
    if (!this.weavy || !this.app)
      return null;
    let i = t.matchBefore(/(?!\]\(@)(^[^@]{0,1}|[^@]{2})@([^@]+)/);
    if (!t.explicit && !i) return null;
    i = t.matchBefore(/@[^@]+/);
    const s = i == null ? void 0 : i.text.substring(1), n = await this.weavy.fetch(`/api/apps/${this.app.id}/members?member=null&q=${s}`), a = await (n == null ? void 0 : n.json());
    let o = [];
    return a.data && (o = a.data.filter((l) => typeof l.display_name < "u").map((l) => ({
      item: l,
      label: l.display_name,
      apply: /* @__PURE__ */ c((d, u, y, m) => {
        const f = "[" + l.display_name + "](@u" + l.id.toString() + ")";
        let g = d.state.update({ changes: { from: y - 1, to: y } });
        d.dispatch(g), g = d.state.update({
          changes: { from: y - 1, to: m - 1, insert: f }
        }), d.dispatch(g);
      }, "apply")
    }))), {
      from: i ? i.from + 1 : t.pos,
      options: o,
      filter: !1
    };
  }
  handleDropFiles(t) {
    const i = t.detail;
    i.files && this.handleUploadFiles(i.files);
  }
  async handleUploadFiles(t, i) {
    if (t) {
      for (let s = 0; s < t.length; s++) {
        const a = { file: t[s] };
        await this.uploadBlobMutation.mutate(a), this.saveDraft();
      }
      i && (i.value = "");
    }
  }
  handleExternalBlobs(t) {
    var i;
    if (t)
      for (let s = 0; s < t.length; s++) {
        const n = t[s];
        (i = this.externalBlobMutation) == null || i.mutate({ externalBlob: n });
      }
  }
  handleRemoveUpload(t) {
    !this.weavy || !this.app || qw(
      this.weavy.queryClient,
      ["apps", this.app.id, "blobs", `${this.editorLocation}-${this.parentId || this.app.id}`],
      (i) => {
        var s, n;
        return ((s = i.state.data) == null ? void 0 : s.id) === ((n = t.data) == null ? void 0 : n.id);
      }
    );
  }
  saveDraft() {
    var s;
    if (!this.draft) return;
    const t = this.mutatingFiles.result;
    let i = (s = this.editor) == null ? void 0 : s.state.doc.toString();
    i === void 0 && (i = this.text), (!t || !t.length) && !this.meeting && !this.embeds.length && (!this.pollOptions.length || this.pollOptions.filter((n) => n.text.trim() !== "").length === 0) && i === "" ? localStorage.removeItem(this.draftKey) : localStorage.setItem(
      this.draftKey,
      JSON.stringify({
        meeting: this.meeting,
        text: i,
        pollOptions: this.pollOptions.filter((n) => n.text.trim() !== ""),
        embeds: this.embeds
      })
    );
  }
  handleRemoveAttachment(t) {
    this.attachments = this.attachments.filter((i) => i.id !== t.id);
  }
  async submit() {
    var u, y, m, f;
    const t = this.mutatingFiles.result, i = t == null ? void 0 : t.some((g) => g.status === "pending"), s = (u = this.editor) == null ? void 0 : u.state.doc.toString().trim(), n = (y = this.meeting) == null ? void 0 : y.id, a = t == null ? void 0 : t.map((g) => {
      var x;
      return (x = g.data) == null ? void 0 : x.id;
    }), o = ((m = this.attachments) == null ? void 0 : m.map((g) => g.id)) || [], l = this.pollOptions.filter((g) => g.text.trim() !== "");
    if (n2() || i || !s && !n && (a == null ? void 0 : a.length) == 0 && l.length == 0 && o.length == 0 && this.embeds.length == 0)
      return;
    const d = {
      detail: { text: s, meetingId: n, blobs: a, attachments: o, pollOptions: l, embed: (f = this.embeds[0]) == null ? void 0 : f.id },
      bubbles: !0,
      composed: !0
    };
    this.dispatchEvent(new CustomEvent("submit", d)), this.resetEditor();
  }
  resetEditor() {
    this.clearEditor(), this.weavy && this.app && Qb(this.weavy.queryClient, [
      "apps",
      this.app.id,
      "blobs",
      `${this.editorLocation}-${this.parentId || this.app.id}`
    ]), localStorage.removeItem(this.draftKey);
  }
  clearEditor() {
    var t;
    (t = this.editor) == null || t.dispatch({ changes: { from: 0, to: this.editor.state.doc.length, insert: "" } }), this.text = "", this.meeting = void 0, this.pollOptions = [], this.showPolls = !1, this.embeds = [], o2();
  }
  async handleMeetingClick(t) {
    if (!this.weavy || !this.user)
      return;
    const s = await Lu(this.weavy, t).mutate();
    s.auth_url ? this.authWindow = window.open(s.auth_url, "oauthwin", "height=640,width=480") : this.meeting = s;
  }
  setEmbeds(t) {
    this.embeds = [t, ...this.embeds], this.saveDraft();
  }
  async handleEmbeds(t) {
    this.weavy && await c2(t, this.setEmbeds.bind(this), this.weavy);
  }
  removeEmbed(t) {
    this.embeds = this.embeds.filter((i) => i.id !== t.detail.id), this.saveDraft();
  }
  swapEmbed() {
    const t = this.embeds.shift();
    t && (this.embeds = [...this.embeds, t]), this.saveDraft();
  }
  openPolls() {
    if (this.showPolls)
      this.showPolls = !1;
    else {
      if (this.pollOptions.length === 0) {
        const t = { id: null, text: "" };
        this.pollOptions = [...this.pollOptions, t];
      }
      this.showPolls = !0;
    }
  }
  handlePollOptionChange(t, i) {
    const s = [...this.pollOptions];
    s[i].text = t.target.value, this.pollOptions = s, this.saveDraft();
  }
  handlePollOptionAdd(t, i) {
    if (i === this.pollOptions.length - 1 && this.pollOptions.length < 5) {
      const s = { id: null, text: "" };
      this.pollOptions = [...this.pollOptions, s], this.saveDraft();
    }
  }
  /**
   * Editor loading fallback dummy.
   * Hard copy of the rendered nodes when the editor is empty. Cleaned up to not be editable.
   */
  renderEditorDummy() {
    return this.editorInitialized ? C : p`
      <div class="cm-editor">
        <div class="cm-announced"></div>
        <div tabindex="-1" class="cm-scroller">
          <div class="cm-content cm-lineWrapping">
            <div class="cm-line"
              ><img class="cm-widgetBuffer" aria-hidden="true" /><span class="cm-placeholder">${this.placeholder}</span
              ><br
            /></div>
          </div>
        </div>
      </div>
    `;
  }
  renderTopSlot() {
    return C;
  }
  renderMiddleSlot() {
    var t, i, s, n, a, o;
    return p`
      <!-- Input -->
      <div class=${Rt({ "wy-post-editor-text": !0, "wy-is-invalid": this.editorError })} ${X(this.editorRef)}>
        ${this.renderEditorDummy()}
      </div>

      <div class="wy-post-editor-inputs">
        <div class="wy-post-editor-buttons">
          ${(t = this.hasFeatures) != null && t.attachments ? p`<wy-button
                  kind="icon"
                  @click=${this.openFileInput}
                  title=${$("From device")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon name="attachment"></wy-icon>
                </wy-button>
                <input
                  type="file"
                  ${X(this.fileInputRef)}
                  @click=${(l) => l.stopPropagation()}
                  @change=${(l) => this.handleUploadFiles(
      Array.from(l.target.files || []),
      l.target
    )}
                  multiple
                  hidden
                  tabindex="-1"
                  ?disabled=${this.disabled}
                />` : C}
          ${(i = this.hasFeatures) != null && i.cloudFiles ? p`<wy-button
                kind="icon"
                @click=${this.openCloudFiles}
                title=${$("From cloud")}
                ?disabled=${this.disabled}
              >
                <wy-icon name="cloud"></wy-icon>
              </wy-button>` : C}
          ${(s = this.hasFeatures) != null && s.zoomMeetings ? p`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("zoom")}
                  title=${$("Zoom meeting")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="zoom-meetings"></wy-icon>
                </wy-button>
              ` : C}
          ${(n = this.hasFeatures) != null && n.googleMeet ? p`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("google")}
                  title=${$("Google Meet")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="google-meet"></wy-icon>
                </wy-button>
              ` : C}
          ${(a = this.hasFeatures) != null && a.microsoftTeams ? p`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("microsoft")}
                  title=${$("Microsoft Teams")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="microsoft-teams"></wy-icon>
                </wy-button>
              ` : C}
          ${(o = this.hasFeatures) != null && o.polls ? p`<wy-button kind="icon" @click=${this.openPolls} title=${$("Poll")} ?disabled=${this.disabled}>
                <wy-icon name="poll"></wy-icon>
              </wy-button>` : C}
        </div>

        <!-- Button -->
        <wy-button @click="${this.submit}" color="primary" title=${this.buttonText} ?disabled=${this.disabled}>
          ${this.buttonText}
        </wy-button>
      </div>
    `;
  }
  renderBottomSlot() {
    return this.renderLists();
  }
  renderLists() {
    var i, s, n, a, o, l, d, u;
    const t = this.mutatingFiles.result;
    return this.disabled ? C : p`
      <!-- polls -->
      ${(i = this.hasFeatures) != null && i.polls && this.showPolls && this.pollOptions.length > 0 ? p`
            <div class="wy-poll-form">
              ${this.pollOptions.map((y, m) => p`<input
                  value=${y.text}
                  @change=${(f) => this.handlePollOptionChange(f, m)}
                  @keyup=${Ti}
                  class="wy-input"
                  type="text"
                  placeholder=${$("+ add an option")}
                  @focus=${(f) => this.handlePollOptionAdd(f, m)}
                />`)}
            </div>
          ` : C}

      <!-- meetings -->
      ${((s = this.meeting) == null ? void 0 : s.provider) === "zoom" && ((n = this.hasFeatures) != null && n.zoomMeetings) || ((a = this.meeting) == null ? void 0 : a.provider) === "google" && ((o = this.hasFeatures) != null && o.googleMeet) || ((l = this.meeting) == null ? void 0 : l.provider) === "microsoft" && ((d = this.hasFeatures) != null && d.microsoftTeams) ? p`
            <div class="wy-item wy-list-item">
              <wy-icon svg="${fh(this.meeting.provider)}"></wy-icon>
              <div class="wy-item-body">${mh(this.meeting.provider)}</div>
              <wy-button kind="icon" @click=${this.handleRemoveMeeting}>
                <wy-icon name="close-circle"></wy-icon>
              </wy-button>
            </div>
          ` : C}

      <!-- blobs -->
      ${t && t.length ? Re(
      t,
      (y) => "mutation" + y.submittedAt,
      (y) => {
        var m;
        if ((m = y.context) != null && m.file) {
          const f = y.context.file, g = {
            ...y.context.status
          };
          return p`
                  <wy-file-item
                    .file=${y.context.file}
                    .status=${g}
                    title="${hy(y.context.type)}: ${f.name + (g.text ? `: ${g.text}` : "")}"
                  >
                    <span slot="title"
                      ><strong></strong> ${f.name}
                      ${g.text ? p`: <em>${g.text}</em>` : C}</span
                    >
                    <wy-button
                      slot="actions"
                      kind="icon"
                      @click=${() => this.handleRemoveUpload(y)}
                      title=${$("Discard", { desc: "Button action to discard" })}
                    >
                      <wy-icon name="close"></wy-icon>
                    </wy-button>
                  </wy-file-item>
                `;
        }
        return C;
      }
    ) : C}

      <!-- attachments -->
      ${this.attachments && this.attachments.map(
      (y) => p`<wy-file-item .file=${y} title="${y.name}">
          <span slot="title">${y.name}</span>
          <wy-button
            slot="actions"
            kind="icon"
            @click=${() => this.handleRemoveAttachment(y)}
            title=${$("Remove", { desc: "Button action to remove" })}
          >
            <wy-icon name="close"></wy-icon>
          </wy-button>
        </wy-file-item>`
    )}

      <!-- embeds -->
      ${(u = this.hasFeatures) != null && u.embeds && this.embeds.length > 0 ? p`<div class="wy-embed-preview">
            ${this.embeds.map(
      (y) => p`
                <wy-embed
                  class="wy-embed"
                  .embed=${y}
                  @embed-remove=${this.removeEmbed}
                  @embed-swap=${this.swapEmbed}
                  .enableSwap=${this.embeds.length > 1}
                ></wy-embed>
              `
    )}
          </div> ` : C}
    `;
  }
  renderCloudFiles() {
    return this.disabled ? C : p`
      <wy-cloud-files
        ${X(this.cloudFilesRef)}
        @external-blobs=${(t) => this.handleExternalBlobs(t.detail.externalBlobs)}
      ></wy-cloud-files>
    `;
  }
  render() {
    const t = this.dropZone.isDragActive;
    return p`
      <div
        class=${Rt({
      "wy-editor": !0,
      [this.editorClass]: !0,
      "wy-dragging": t
    })}
        data-drag-title=${$("Drop files here to upload.")}
      >
        ${this.renderTopSlot()} ${this.renderMiddleSlot()} ${this.renderBottomSlot()}
      </div>
      ${this.renderCloudFiles()}
    `;
  }
}, c(ia, "WyEditor"), ia);
xt.styles = J;
St([
  w({ type: Boolean })
], xt.prototype, "disabled", 2);
St([
  w({ attribute: !1 })
], xt.prototype, "parentId", 2);
St([
  w()
], xt.prototype, "placeholder", 1);
St([
  w()
], xt.prototype, "text", 2);
St([
  w({ attribute: !1 })
], xt.prototype, "embed", 2);
St([
  w({ attribute: !1 })
], xt.prototype, "options", 2);
St([
  w({ attribute: !1 })
], xt.prototype, "attachments", 2);
St([
  w()
], xt.prototype, "buttonText", 2);
St([
  w({ type: Boolean })
], xt.prototype, "typing", 2);
St([
  w({ type: Boolean })
], xt.prototype, "draft", 2);
St([
  w()
], xt.prototype, "editorType", 2);
St([
  w()
], xt.prototype, "editorClass", 2);
St([
  w()
], xt.prototype, "editorLocation", 2);
St([
  D()
], xt.prototype, "meeting", 2);
St([
  D()
], xt.prototype, "editorError", 2);
St([
  D()
], xt.prototype, "showPolls", 2);
St([
  D()
], xt.prototype, "pollOptions", 2);
St([
  D()
], xt.prototype, "embeds", 2);
St([
  D()
], xt.prototype, "draftKey", 2);
St([
  D()
], xt.prototype, "keyMap", 2);
St([
  D()
], xt.prototype, "editorExtensions", 2);
St([
  D()
], xt.prototype, "editor", 2);
xt = St([
  B("wy-editor"),
  st()
], xt);
var w2 = Object.defineProperty, f2 = Object.getOwnPropertyDescriptor, le = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? f2(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && w2(t, i, n), n;
}, "__decorateClass$C"), sa;
let qt = (sa = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.location = "apps", this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.text = "", this.attachments = [], this.pollOptions = [], this.reactions = [], this.seenBy = [], this.updateCommentMutation = new Ae(this);
  }
  dispatchEdit(t) {
    const i = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(i);
  }
  handleSubmit(t) {
    this.updateCommentMutation.mutate({
      id: this.commentId,
      type: this.location,
      parentId: this.parentId,
      text: t.detail.text,
      meetingId: t.detail.meetingId,
      blobs: t.detail.blobs,
      attachments: t.detail.attachments,
      pollOptions: t.detail.pollOptions,
      embedId: t.detail.embed
    }), this.dispatchEdit(!1);
  }
  async willUpdate(t) {
    (t.has("parentId") || t.has("weavy")) && this.parentId && this.weavy && this.updateCommentMutation.trackMutation(
      ub(this.weavy, [this.location, this.parentId, "comments"])
    );
  }
  render() {
    return p`
      <nav class="wy-item">
        <div class="wy-item-body">
          <div class="wy-item-title">${$("Edit comment")}</div>
        </div>

        <wy-button @click=${() => this.dispatchEdit(!1)} kind="icon">
          <wy-icon name="close"></wy-icon>
        </wy-button>
      </nav>
      <wy-editor
        editorLocation=${this.location}
        .text=${this.text}
        .embed=${this.embed}
        .options=${this.pollOptions}
        .attachments=${this.attachments ?? []}
        .parentId=${this.commentId}
        .typing=${!1}
        .draft=${!1}
        placeholder=${$("Edit comment...")}
        buttonText=${$("Update", { desc: "Button action to update" })}
        @submit=${(t) => this.handleSubmit(t)}></wy-editor>
    `;
  }
}, c(sa, "WyCommentEdit"), sa);
qt.styles = J;
le([
  Qt({ context: Xt, subscribe: !0 }),
  D()
], qt.prototype, "weavy", 2);
le([
  w({ type: Number })
], qt.prototype, "parentId", 2);
le([
  w({ attribute: !1 })
], qt.prototype, "location", 2);
le([
  w({ type: Number })
], qt.prototype, "commentId", 2);
le([
  w({ attribute: !1 })
], qt.prototype, "createdBy", 2);
le([
  w()
], qt.prototype, "createdAt", 2);
le([
  w()
], qt.prototype, "modifiedAt", 2);
le([
  w({ type: Boolean })
], qt.prototype, "isSubscribed", 2);
le([
  w({ type: Boolean })
], qt.prototype, "isTrashed", 2);
le([
  w()
], qt.prototype, "text", 2);
le([
  w({ type: Array })
], qt.prototype, "attachments", 2);
le([
  w({ type: Array })
], qt.prototype, "pollOptions", 2);
le([
  w({ attribute: !1 })
], qt.prototype, "meeting", 2);
le([
  w({ attribute: !1 })
], qt.prototype, "embed", 2);
le([
  w({ type: Array })
], qt.prototype, "reactions", 2);
le([
  w({ type: Array })
], qt.prototype, "seenBy", 2);
qt = le([
  B("wy-comment-edit"),
  st()
], qt);
var m2 = Object.defineProperty, v2 = Object.getOwnPropertyDescriptor, ee = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? v2(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && m2(t, i, n), n;
}, "__decorateClass$B"), ra;
let Tt = (ra = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.location = "apps", this.createdAt = "", this.modifiedAt = void 0, this.isTrashed = !1, this.html = "", this.text = "", this.attachments = [], this.pollOptions = [], this.reactions = [], this.commentCount = 0, this.seenBy = [], this.editing = !1;
  }
  dispatchVote(t) {
    const i = new CustomEvent("vote", { detail: { id: t, parentId: this.commentId, parentType: "comments" } });
    return this.dispatchEvent(i);
  }
  dispatchSubscribe(t) {
    const i = new CustomEvent("subscribe", { detail: { id: this.commentId, subscribe: t } });
    return this.dispatchEvent(i);
  }
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.commentId } });
    return this.dispatchEvent(t);
  }
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: { id: this.commentId } });
    return this.dispatchEvent(t);
  }
  render() {
    return p`
      ${this.isTrashed ? p`<wy-comment-trashed
            class="wy-comment"
            commentId=${this.commentId}
            @restore=${() => {
      this.dispatchRestore();
    }}></wy-comment-trashed> ` : C}
      ${!this.isTrashed && this.editing ? p`<wy-comment-edit
            class="wy-comment"
            .commentId=${this.commentId}
            .parentId=${this.parentId}
            .location=${this.location}
            .text=${this.text}
            .pollOptions=${this.pollOptions}
            .attachments=${this.attachments}
            .embed=${this.embed}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}></wy-comment-edit> ` : C}
      ${!this.isTrashed && !this.editing ? p`<wy-comment-view
            class="wy-comment"
            id="comment-view-${this.commentId}"
            .commentId=${this.commentId}
            .parentId=${this.parentId}
            .location=${this.location}
            .createdBy=${this.createdBy}
            .createdAt=${this.createdAt}
            .modifiedAt=${this.modifiedAt}
            .isTrashed=${this.isTrashed}
            .text=${this.text}
            .html=${this.html}            
            .attachments=${this.attachments}
            .embed=${this.embed}
            .meeting=${this.meeting}
            .pollOptions=${this.pollOptions}
            .reactions=${this.reactions}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}
            @subscribe=${(t) => {
      this.dispatchSubscribe(t.detail.subscribe);
    }}
            @trash=${() => {
      this.dispatchTrash();
    }}
            @vote=${(t) => {
      this.dispatchVote(t.detail.id);
    }}></wy-comment-view> ` : C}
    `;
  }
}, c(ra, "WyComment"), ra);
Tt.styles = [J, Z`:host { display: contents; }`];
ee([
  w({ type: Number })
], Tt.prototype, "commentId", 2);
ee([
  w({ type: Number })
], Tt.prototype, "parentId", 2);
ee([
  w({ attribute: !1 })
], Tt.prototype, "location", 2);
ee([
  w({ attribute: !1 })
], Tt.prototype, "createdBy", 2);
ee([
  w()
], Tt.prototype, "createdAt", 2);
ee([
  w()
], Tt.prototype, "modifiedAt", 2);
ee([
  w({ type: Boolean })
], Tt.prototype, "isTrashed", 2);
ee([
  w()
], Tt.prototype, "html", 2);
ee([
  w()
], Tt.prototype, "text", 2);
ee([
  w({ attribute: !1 })
], Tt.prototype, "attachments", 2);
ee([
  w({ type: Array })
], Tt.prototype, "pollOptions", 2);
ee([
  w({ attribute: !1 })
], Tt.prototype, "meeting", 2);
ee([
  w({ attribute: !1 })
], Tt.prototype, "embed", 2);
ee([
  w({ type: Array })
], Tt.prototype, "reactions", 2);
ee([
  w({ attribute: !1 })
], Tt.prototype, "commentCount", 2);
ee([
  w({ type: Array })
], Tt.prototype, "seenBy", 2);
ee([
  D()
], Tt.prototype, "editing", 2);
Tt = ee([
  B("wy-comment")
], Tt);
var g2 = Object.defineProperty, b2 = Object.getOwnPropertyDescriptor, x2 = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? b2(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && g2(t, i, n), n;
}, "__decorateClass$A"), na;
let bh = (na = class extends xt {
  constructor() {
    super(), this.editorType = "comments", this.editorClass = "wy-comment-editor";
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("editorLocation") && this.editorLocation === "files" && (this.editorClass = "wy-comment-editor wy-comment-editor-bottom");
  }
  renderTopSlot() {
    return C;
  }
  renderMiddleSlot() {
    var t, i, s, n, a, o, l, d, u, y, m;
    return p`<div class="wy-comment-editor-inputs">
      <!-- Add -->
      ${(t = this.hasFeatures) != null && t.attachments || (i = this.hasFeatures) != null && i.cloudFiles || (s = this.hasFeatures) != null && s.zoomMeetings || (n = this.hasFeatures) != null && n.googleMeet || (a = this.hasFeatures) != null && a.microsoftTeams ? p`<wy-dropdown icon="plus" directionY="up" ?disabled=${this.disabled}>
            ${(o = this.hasFeatures) != null && o.attachments ? p`<wy-dropdown-item @click=${this.openFileInput} title=${$("From device")}>
                    <wy-icon name="attachment"></wy-icon>
                    <span>${$("From device")}</span>
                  </wy-dropdown-item>
                  <input
                    type="file"
                    ${X(this.fileInputRef)}
                    @click=${(f) => f.stopPropagation()}
                    @change=${(f) => this.handleUploadFiles(
      Array.from(f.target.files || []),
      f.target
    )}
                    multiple
                    hidden
                    tabindex="-1"
                  />` : C}
            ${(l = this.hasFeatures) != null && l.cloudFiles ? p`<wy-dropdown-item @click=${this.openCloudFiles} title=${$("From cloud")}>
                  <wy-icon name="cloud"></wy-icon>
                  <span>${$("From cloud")}</span>
                </wy-dropdown-item>` : C}
            ${(d = this.hasFeatures) != null && d.zoomMeetings ? p`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("zoom")} title=${$("Zoom meeting")}>
                    <wy-icon svg="zoom-meetings"></wy-icon>
                    <span>${$("Zoom meeting")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${(u = this.hasFeatures) != null && u.googleMeet ? p`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("google")} title=${$("Google Meet")}>
                    <wy-icon svg="google-meet"></wy-icon>
                    <span>${$("Google Meet")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${(y = this.hasFeatures) != null && y.microsoftTeams ? p`
                  <wy-dropdown-item
                    @click=${() => this.handleMeetingClick("microsoft")}
                    title=${$("Microsoft Teams")}
                  >
                    <wy-icon svg="microsoft-teams"></wy-icon>
                    <span>${$("Microsoft Teams")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${(m = this.hasFeatures) != null && m.polls ? p`<wy-dropdown-item @click=${this.openPolls} title=${$("Poll")}>
                  <wy-icon name="poll"></wy-icon>
                  <span>${$("Poll")}</span>
                </wy-dropdown-item>` : C}
          </wy-dropdown>` : C}

      <!-- Input -->
      <div
        class=${Rt({ "wy-comment-editor-text": !0, "wy-is-invalid": this.editorError })}
        ${X(this.editorRef)}
      >
        ${this.renderEditorDummy()}
      </div>

      <!-- Button -->
      <wy-button kind="icon" @click="${this.submit}" title=${this.buttonText} ?disabled=${this.disabled}>
        <wy-icon name="send"></wy-icon>
      </wy-button>
    </div>`;
  }
  renderBottomSlot() {
    return this.renderLists();
  }
}, c(na, "WyCommentEditor"), na);
bh = x2([
  B("wy-comment-editor"),
  st()
], bh);
var $2 = Object.defineProperty, k2 = Object.getOwnPropertyDescriptor, Kw = /* @__PURE__ */ c((r) => {
  throw TypeError(r);
}, "__typeError$b"), np = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? k2(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && $2(t, i, n), n;
}, "__decorateClass$z"), Gw = /* @__PURE__ */ c((r, t, i) => t.has(r) || Kw("Cannot " + i), "__accessCheck$b"), Fu = /* @__PURE__ */ c((r, t, i) => (Gw(r, t, "read from private field"), i ? i.call(r) : t.get(r)), "__privateGet$b"), C2 = /* @__PURE__ */ c((r, t, i) => t.has(r) ? Kw("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(r) : t.set(r, i), "__privateAdd$b"), Du = /* @__PURE__ */ c((r, t, i, s) => (Gw(r, t, "write to private field"), t.set(r, i), i), "__privateSet$b"), wr, aa;
let eo = (aa = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.location = "apps", this.commentsQuery = new Ri(this), this.addCommentMutation = new Ae(this), this.infiniteScroll = new Ii(this), this.pagerRef = rt(), C2(this, wr), this.handleRealtimeCommentCreated = () => {
      var t;
      (t = this.weavy) == null || t.queryClient.invalidateQueries({ queryKey: [this.location, this.parentId, "comments"] });
    }, this.handleRealtimeReactionAdded = (t) => {
      !this.weavy || t.entity.type !== "comment" || _t(
        this.weavy.queryClient,
        [this.location, this.parentId, "comments"],
        t.entity.id,
        (i) => {
          Ro(i, t.reaction, t.actor);
        }
      );
    }, this.handleRealtimeReactionDeleted = (t) => {
      !this.weavy || t.entity.type !== "comment" || _t(
        this.weavy.queryClient,
        [this.location, this.parentId, "comments"],
        t.entity.id,
        (i) => {
          Ro(i, void 0, t.actor);
        }
      );
    };
  }
  async willUpdate(t) {
    var i;
    if (super.willUpdate(t), (t.has("parentId") || t.has("weavy")) && this.parentId && this.weavy && (this.commentsQuery.trackInfiniteQuery(pb(this.weavy, this.location, this.parentId)), this.addCommentMutation.trackMutation(yb(this.weavy)), this.removeCommentMutation = fb(this.weavy, this.location, this.parentId), this.restoreCommentMutation = vb(this.weavy, this.location, this.parentId), this.pollMutation = Vh(this.weavy, [this.location, this.parentId, "comments"])), (t.has("weavy") || t.has("app")) && this.weavy && this.app) {
      (i = Fu(this, wr)) == null || i.call(this);
      const s = `a${this.app.id}`;
      this.weavy.subscribe(s, "comment_created", this.handleRealtimeCommentCreated), this.weavy.subscribe(s, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(s, "reaction_removed", this.handleRealtimeReactionDeleted), Du(this, wr, () => {
        var n, a, o;
        (n = this.weavy) == null || n.unsubscribe(s, "comment_created", this.handleRealtimeCommentCreated), (a = this.weavy) == null || a.unsubscribe(s, "reaction_added", this.handleRealtimeReactionAdded), (o = this.weavy) == null || o.unsubscribe(s, "reaction_removed", this.handleRealtimeReactionDeleted), Du(this, wr, void 0);
      });
    }
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.commentsQuery.result, this.pagerRef.value);
  }
  async handleSubmit(t) {
    this.app && this.user && await this.addCommentMutation.mutate({
      appId: this.app.id,
      parentId: this.parentId,
      type: this.location,
      text: t.detail.text,
      meetingId: t.detail.meetingId,
      blobs: t.detail.blobs,
      pollOptions: t.detail.pollOptions,
      embedId: t.detail.embed,
      user: this.user
    });
  }
  renderComments(t) {
    if (t) {
      const i = ms(t);
      return Re(
        i,
        (s) => s.id,
        (s) => {
          var n, a, o;
          return [
            p`<wy-comment
              id="comment-${s.id}"
              .commentId=${s.id}
              .parentId=${this.parentId}
              .location=${this.location}
              .createdBy=${s.created_by}
              .createdAt=${s.created_at}
              .modifiedAt=${s.updated_at}
              .isTrashed=${s.is_trashed}
              .html=${s.html}
              .text=${s.text}
              .attachments=${(n = s.attachments) == null ? void 0 : n.data}
              .embed=${s.embed}
              .meeting=${s.meeting}
              .pollOptions=${(a = s.options) == null ? void 0 : a.data}
              .reactions=${(o = s.reactions) == null ? void 0 : o.data}
              @trash=${async (l) => {
              var u;
              const d = await this.whenApp();
              (u = this.removeCommentMutation) == null || u.mutate({
                id: l.detail.id,
                appId: d.id,
                parentId: this.parentId,
                type: this.location
              });
            }}
              @restore=${async (l) => {
              var u;
              const d = await this.whenApp();
              (u = this.restoreCommentMutation) == null || u.mutate({
                id: l.detail.id,
                appId: d.id,
                parentId: this.parentId,
                type: this.location
              });
            }}
              @vote=${(l) => {
              var d;
              (d = this.pollMutation) == null || d.mutate({
                optionId: l.detail.id,
                parentType: l.detail.parentType,
                parentId: l.detail.parentId
              });
            }}
            ></wy-comment>`
          ];
        }
      );
    }
    return C;
  }
  render() {
    var n;
    const { data: t, hasNextPage: i, isPending: s } = this.commentsQuery.result ?? {};
    return p`
      <div class="wy-comments">
        ${t ? this.renderComments(t) : s ? p`<wy-spinner padded reveal></wy-spinner>` : C}
        ${i ? p`<div ${X(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
      </div>

      <wy-comment-editor
        editorLocation=${this.location}
        .parentId=${this.parentId}
        .typing=${!1}
        .draft=${!0}
        ?disabled=${!Us(ns.Create, (n = this.app) == null ? void 0 : n.permissions)}
        placeholder=${$("Create a comment...")}
        buttonText=${$("Comment", { desc: "Button action to comment" })}
        @submit=${(a) => this.handleSubmit(a)}
      ></wy-comment-editor>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = Fu(this, wr)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(aa, "WyCommentList"), aa);
wr = /* @__PURE__ */ new WeakMap();
eo.styles = [J, ir];
np([
  w({ type: Number })
], eo.prototype, "parentId", 2);
np([
  w({ attribute: !1 })
], eo.prototype, "location", 2);
eo = np([
  B("wy-comment-list"),
  st()
], eo);
function ap(r, t) {
  return ["apps", r.id, "file", t.id, "versions"];
}
c(ap, "getFileVersionsKey");
function _2(r, t, i) {
  const s = r.queryClient, n = ["apps", t.id, "files"], a = ap(t, i), o = {
    mutationKey: n,
    mutationFn: /* @__PURE__ */ c(async ({ versionFile: l }) => {
      if (l.id >= 1 && l.rev) {
        if (!(await r.fetch(`/api/files/${l.id}/versions/${l.rev}/restore`, {
          method: "POST"
        })).ok)
          throw new Error();
      } else
        throw new Error(`Could not restore ${l.name} to version ${l.rev}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (l) => (nt(
      s,
      { queryKey: o.mutationKey, exact: !1 },
      l.versionFile.id,
      (d) => Object.assign(d, l.versionFile, { status: "pending" })
    ), { type: "version", file: i, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ c((l, d) => {
      nt(
        s,
        { queryKey: o.mutationKey, exact: !1 },
        d.versionFile.id,
        (u) => Object.assign(u, l, { status: "ok" })
      ), Lt(s, o.mutationKey, d, (u) => {
        u.status.state = "ok";
      });
    }, "onSuccess"),
    onError(l, d, u) {
      u != null && u.file && nt(
        s,
        { queryKey: o.mutationKey, exact: !1 },
        d.versionFile.id,
        (y) => Object.assign(y, u.file, { status: "error" })
      ), Lt(s, o.mutationKey, d, (y) => {
        y.status.state = "error", y.status.text = l.message;
      });
    },
    onSettled() {
      s.invalidateQueries({ queryKey: a });
    }
  };
  return o;
}
c(_2, "getFileVersionRestoreMutationOptions");
function P2(r, t, i) {
  return new bt(r.queryClient, _2(r, t, i));
}
c(P2, "getFileVersionRestoreMutation");
function M2(r, t, i) {
  const s = r.queryClient, n = ap(t, i);
  return {
    mutationKey: n,
    mutationFn: /* @__PURE__ */ c(async ({ versionFile: o }) => {
      if (o.id >= 1 && o.rev) {
        const l = await r.fetch(`/api/files/${o.id}/versions/${o.rev}`, {
          method: "DELETE"
        });
        if (!l.ok) {
          const d = await l.json();
          throw new Error(d.detail || d.title, { cause: d });
        }
      } else {
        const l = {
          status: 400,
          title: `Could not remove ${o.name} version ${o.rev}.`
        };
        throw new Error(l.detail || l.title, { cause: l });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (o) => {
      _t(
        s,
        n,
        /* @__PURE__ */ c((d) => d.id === o.versionFile.id && d.rev === o.versionFile.rev, "versionPredicate"),
        (d) => Object.assign(d, { status: "pending" })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((o, l) => {
      Hh(s, n, /* @__PURE__ */ c((u) => u.id === l.versionFile.id && u.rev === l.versionFile.rev, "versionPredicate"));
    }, "onSuccess"),
    onError(o, l) {
      _t(
        s,
        n,
        /* @__PURE__ */ c((u) => u.id === l.versionFile.id && u.rev === l.versionFile.rev, "versionPredicate"),
        (u) => Object.assign(u, { status: void 0 })
      );
    }
  };
}
c(M2, "getFileVersionDeleteMutationOptions");
function z2(r, t, i) {
  return new bt(r.queryClient, M2(r, t, i));
}
c(z2, "getFileVersionDeleteMutation");
var S2 = Object.defineProperty, E2 = Object.getOwnPropertyDescriptor, op = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? E2(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && S2(t, i, n), n;
}, "__decorateClass$y"), oa;
let io = (oa = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.fileVersionsQuery = new be(this);
  }
  selectVersion(t) {
    this.activeVersion = t, this.dispatchFileVersionSelect(t);
  }
  dispatchFileVersionSelect(t) {
    const i = new CustomEvent("file-version-select", { detail: { versionFile: t } });
    return this.dispatchEvent(i);
  }
  handleRevert(t) {
    var i;
    (i = this.fileVersionRestoreMutation) == null || i.mutate({ versionFile: t }), this.selectVersion(t);
  }
  handleRemove(t) {
    var i;
    (i = this.fileVersionDeleteMutation) == null || i.mutate({ versionFile: t }), this.activeVersion === t && (this.activeVersion = this.file);
  }
  triggerDownload(t) {
    Mo(t.download_url, "_top", t.name, !0);
  }
  willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("file") || t.has("app")) && this.weavy && this.file && this.app && (this.fileVersionsQuery.trackQuery(
      yi(
        this.weavy,
        ap(this.app, this.file),
        `/api/files/${this.file.id}/versions`
      )
    ), this.fileVersionRestoreMutation = P2(this.weavy, this.app, this.file), this.fileVersionDeleteMutation = z2(this.weavy, this.app, this.file));
  }
  render() {
    const { data: t, isPending: i } = this.fileVersionsQuery.result ?? { isPending: !0 };
    return i ? p`<wy-spinner overlay></wy-spinner>` : t != null && t.data ? p`
          <div class="wy-list wy-versions">
            ${Re(
      t.data,
      (s) => s.id,
      (s, n) => {
        var f, g, x, k;
        const a = vs(s.name || "").icon, o = t.data ? t.data.length - n : NaN, l = ai(s.name), d = new Date(s.updated_at || s.created_at), u = !!this.file.external_url, y = new Intl.DateTimeFormat((f = this.weavy) == null ? void 0 : f.locale, {
          dateStyle: "full",
          timeStyle: "short"
        }).format(d), m = mc((g = this.weavy) == null ? void 0 : g.locale, new Date(d));
        return u ? p`
                      <wy-empty noNetwork>
                        <span slot="title">${$("Versions are not available for external cloud files.")}</span>
                      </wy-empty>
                    ` : p`
                      <div
                        class="wy-item wy-list-item-lg wy-item-hover ${Rt({
          "wy-active": s.rev == ((x = this.activeVersion) == null ? void 0 : x.rev)
        })}"
                        tabindex="0"
                        @click=${() => this.selectVersion(s)}
                        @keydown=${xe}
                        @keyup=${je}
                      >
                        <wy-icon name=${a} size="48" kind=${s.kind} ext=${l}></wy-icon>
                        <div class="wy-item-body">
                          <div class="wy-item-title">${o}. ${s.name}</div>
                          <div class="wy-item-text">
                            <time datetime=${s.updated_at || s.created_at} title=${y}
                              >${m}</time
                            >
                            · ${(k = s.updated_by) == null ? void 0 : k.display_name}</div
                          >
                        </div>

                        <wy-dropdown directionX="left">
                          <wy-dropdown-item @click=${() => this.triggerDownload(s)}>
                            <wy-icon name="download"></wy-icon>
                            ${$("Download")}
                          </wy-dropdown-item>                          

                          ${n !== 0 ? p`
                                <wy-dropdown-divider></wy-dropdown-divider>
                                <wy-dropdown-item @click=${() => this.handleRevert(s)}>
                                  <wy-icon name="restore"></wy-icon>
                                  ${"Revert"}
                                </wy-dropdown-item>
                                <wy-dropdown-item @click=${() => this.handleRemove(s)}>
                                  <wy-icon name="delete"></wy-icon>
                                  ${$("Remove", { desc: "Button action to remove" })}
                                </wy-dropdown-item>
                              ` : C}
                        </wy-dropdown>
                      </div>
                    `;
      }
    )}
          </div>
        ` : C;
  }
}, c(oa, "WyFileVersions"), oa);
io.styles = J;
op([
  w({ attribute: !1 })
], io.prototype, "file", 2);
op([
  w({ attribute: !1 })
], io.prototype, "activeVersion", 2);
io = op([
  B("wy-file-versions"),
  st()
], io);
var O2 = Object.defineProperty, A2 = Object.getOwnPropertyDescriptor, de = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? A2(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && O2(t, i, n), n;
}, "__decorateClass$x"), ca;
let Nt = (ca = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.currentId = NaN, this.isAttachment = !1, this.filled = !1, this.showOverlay = !1, this.commentsOpen = !1, this.versionsOpen = !1, this.sidePanelMaximized = !1, this.persistState = new Do(this), this.previewFileRef = rt(), this.swipeScrollRef = rt(), this.prevRef = rt(), this.nextRef = rt(), this.swipeScroller = new vh(this), this.disableSwipeScroll = !1, this.handleKeys = (t) => {
      this.showOverlay && (t.key === "ArrowLeft" ? (t.stopPropagation(), this.setPrev()) : t.key === "ArrowRight" && (t.stopPropagation(), this.setNext()));
    };
  }
  async dispatchOpen() {
    const t = await this.whenApp(), i = await this.whenHasFeatures(), s = this.currentId, n = this.commentsOpen ? "comments" : this.versionsOpen ? "versions" : void 0, a = this.currentFile ? [this.currentFile] : [], o = this.isAttachment, l = new CustomEvent("wy-preview-open", {
      detail: { fileId: s, tab: n, files: a, app: t, hasFeatures: i, isAttachment: o },
      cancelable: !0,
      bubbles: !1,
      composed: !0
    });
    this.dispatchEvent(l) || (this.showOverlay = !1, this.commentsOpen = !1, this.versionsOpen = !1);
  }
  async dispatchClose() {
    const t = new CustomEvent("wy-preview-close", { cancelable: !1, bubbles: !1, composed: !0 });
    this.dispatchEvent(t);
  }
  async open(t, i) {
    await this.whenApp(), await this.updateComplete, t && (this.currentId = t), i && this.toggleSidebarTab(i, !0), this.showOverlay = !0;
  }
  close() {
    this.showOverlay = !1;
  }
  toggleSidebarTab(t, i) {
    t === "comments" ? (this.versionsOpen = !1, this.commentsOpen = i !== void 0 ? i : !this.commentsOpen) : t === "versions" ? (this.commentsOpen = !1, this.versionsOpen = i !== void 0 ? i : !this.versionsOpen) : (this.commentsOpen = !1, this.versionsOpen = !1);
  }
  handleVersionFile(t) {
    this.versionFile = t.detail.versionFile;
  }
  scrollToPrev() {
    var t;
    this.prevRef.value && (this.unblockSwipeScroll(), this.prevRef.value.scrollIntoView({ behavior: (t = this.weavy) == null ? void 0 : t.scrollBehavior }));
  }
  scrollToNext() {
    var t;
    this.nextRef.value && (this.unblockSwipeScroll(), this.nextRef.value.scrollIntoView({ behavior: (t = this.weavy) == null ? void 0 : t.scrollBehavior }));
  }
  blockSwipeScroll(t = 20) {
    window.clearTimeout(this.disableSwipeScrollTimeout), this.disableSwipeScroll = !0, this.disableSwipeScrollTimeout = window.setTimeout(() => this.disableSwipeScroll = !1, t);
  }
  unblockSwipeScroll() {
    window.clearTimeout(this.disableSwipeScrollTimeout), this.disableSwipeScroll = !1;
  }
  setPrev() {
    this.previousFile && (this.currentId = this.previousFile.id, this.blockSwipeScroll());
  }
  setNext() {
    this.nextFile && (this.currentId = this.nextFile.id, this.blockSwipeScroll());
  }
  currentPreviewFileCallback(t) {
    t == null || t.scrollIntoView(), requestAnimationFrame(() => t == null ? void 0 : t.scrollIntoView());
  }
  async willUpdate(t) {
    if (await super.willUpdate(t), (t.has("app") || t.has("user")) && this.app && this.user && !this.isAttachment && (this.persistState.observe(["commentsOpen", "versionsOpen"], `a${this.app.id}-preview`, `u${this.user.id}`), this.commentsOpen && this.versionsOpen && (this.versionsOpen = !1)), t.has("queryResult") && this.queryResult) {
      const { data: i } = this.queryResult ?? {};
      this.files = i == null ? void 0 : i.filter((s) => s && !s.is_trashed);
    }
    if (t.has("infiniteQueryResult") && this.infiniteQueryResult) {
      const { data: i } = this.infiniteQueryResult ?? {};
      this.files = ms(i).filter((s) => s && !s.is_trashed);
    }
    t.has("currentFile") && this.currentFile && this.currentFile.id !== this.currentId && (this.currentId = this.currentFile.id), (t.has("files") || t.has("currentId") || t.has("showOverlay")) && this.files && this.showOverlay && (this.currentFile = void 0, this.previousFile = void 0, this.nextFile = void 0, this.versionFile = void 0, this.currentFile = this.files.find((i, s) => this.files && i.id === this.currentId ? (s >= 1 && (this.previousFile = this.files[s - 1]), s < this.files.length - 1 && (this.nextFile = this.files[s + 1]), this.infiniteQueryResult && s >= this.files.length - 2 && this.infiniteQueryResult.hasNextPage && !this.infiniteQueryResult.isFetchingNextPage && this.infiniteQueryResult.fetchNextPage(), this.infiniteQueryResult && s <= 1 && this.infiniteQueryResult.hasPreviousPage && !this.infiniteQueryResult.isFetchingPreviousPage && this.infiniteQueryResult.fetchPreviousPage(), !0) : !1)), t.has("currentFile") && this.currentFile && !this.files && (this.files = [this.currentFile]), t.has("showOverlay") && (this.showOverlay ? await this.dispatchOpen() : t.get("showOverlay") && await this.dispatchClose());
  }
  renderHeader(t) {
    var s, n, a, o;
    const i = {
      "wy-appbar-text-trashed": !!(t != null && t.is_trashed)
    };
    return p` <header class="wy-appbars">
      <nav class="wy-appbar">
        <wy-button kind="icon" @click=${() => this.close()}><wy-icon name="close"></wy-icon></wy-button>
        <div class="wy-appbar-text ${Rt(i)}">
          ${t ? p` <span>${t.name}</span> ` : C}
        </div>
        <div class="wy-appbar-buttons wy-appbar-buttons-last">
          ${t ? p`
                ${t.id >= 1 && !this.isAttachment && ((s = this.hasFeatures) != null && s.comments) ? p`
                      <wy-button
                        kind="icon"
                        ?active=${this.commentsOpen}
                        @click=${() => this.toggleSidebarTab("comments")}
                        title=${$("Comments")}
                      >
                        <wy-icon-stack>
                          ${(n = t.comments) != null && n.count && ((a = t.comments) == null ? void 0 : a.count) > 0 ? p`<wy-icon name="comment" state ?active=${!this.commentsOpen}></wy-icon>
                                <wy-icon name="comment" layer state ?active=${this.commentsOpen}></wy-icon>` : p`<wy-icon name="comment-outline" state ?active=${!this.commentsOpen}></wy-icon>
                                <wy-icon name="comment" layer state ?active=${this.commentsOpen}></wy-icon>`}
                        </wy-icon-stack>
                      </wy-button>
                    ` : C}
                <wy-file-menu .file=${t}>
                  ${t.id >= 1 && !this.isAttachment && ((o = this.hasFeatures) != null && o.versions) ? p`
                        <wy-dropdown-item
                          ?active=${this.versionsOpen}
                          @click=${() => this.toggleSidebarTab("versions")}
                        >
                          <wy-icon name="backup-restore"></wy-icon>
                          ${$("Versions")}
                        </wy-dropdown-item>
                      ` : C}
                </wy-file-menu>
              ` : C}
        </div>
      </nav>
    </header>`;
  }
  render() {
    let t = this.files === void 0;
    this.queryResult ? t = this.queryResult.isPending : this.infiniteQueryResult && (t = this.infiniteQueryResult.isPending);
    const i = this.versionFile || this.currentFile, s = [this.previousFile, i, this.nextFile].filter((a) => a);
    this.commentsOpen && this.versionsOpen && (this.versionsOpen = !1);
    const n = {
      "wy-preview-swiper-disabled": this.disableSwipeScroll
    };
    return this.weavy ? p`
      <wy-overlay
        class="wy-dark"
        maximized
        ?filled=${this.filled}
        .show=${this.showOverlay}
        @keyup=${this.handleKeys}
        @close=${() => {
      this.showOverlay = !1;
    }}
        @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
      >
        ${this.showOverlay ? p`<div class="wy-preview-layout">
              ${this.renderHeader(this.currentFile)}

              <div class="wy-main">
                ${this.isAttachment ? C : p` <aside
                        id="tab-comments"
                        class="wy-sidebar ${Rt({
      "wy-active": this.commentsOpen,
      "wy-maximized": this.sidePanelMaximized
    })}"
                        ?hidden=${!this.commentsOpen}
                      >
                        <nav class="wy-item">
                          <div class="wy-item-body">
                            <div class="wy-item-title">${$("Comments")}</div>
                          </div>
                          <wy-button kind="icon" @click=${() => this.toggleSidebarTab("comments", !1)}>
                            <wy-icon name="close"></wy-icon>
                          </wy-button>
                          <button
                            @click=${() => this.sidePanelMaximized = !this.sidePanelMaximized}
                            class="wy-sidebar-handle"
                            title=${this.sidePanelMaximized ? $("Restore side panel") : $("Maximize side panel")}
                          ></button>
                        </nav>
                        <div class="wy-pane wy-scroll-y">
                          ${this.commentsOpen && this.currentFile && this.currentFile.id >= 1 && this.app && this.user ? p`
                                <wy-comment-list
                                  .parentId=${this.currentFile.id}
                                  .location=${"files"}
                                ></wy-comment-list>
                              ` : C}
                        </div>
                      </aside>
                      <aside
                        id="tab-versions"
                        class="wy-sidebar ${Rt({
      "wy-active": this.versionsOpen,
      "wy-maximized": this.sidePanelMaximized
    })}"
                        ?hidden=${!this.versionsOpen}
                      >
                        <nav class="wy-item">
                          <div class="wy-item-body">
                            <div class="wy-item-title">${$("Versions")}</div>
                          </div>
                          <wy-button kind="icon" @click=${() => this.toggleSidebarTab("versions", !1)}>
                            <wy-icon name="close"></wy-icon>
                          </wy-button>
                          <button
                            @click=${() => this.sidePanelMaximized = !this.sidePanelMaximized}
                            class="wy-sidebar-handle"
                            title=${this.sidePanelMaximized ? $("Restore side panel") : $("Maximize side panel")}
                          ></button>
                        </nav>
                        <div class="wy-pane wy-scroll-y">
                          <div class="wy-pane-body">
                            ${this.versionsOpen && this.currentFile && this.app ? p`
                                  <wy-file-versions
                                    .file=${this.currentFile}
                                    .activeVersion=${this.versionFile || this.currentFile}
                                    @file-version-select=${(a) => this.handleVersionFile(a)}
                                  ></wy-file-versions>
                                ` : C}
                          </div>
                        </div>
                      </aside>`}

                <div class="wy-preview">
                  <div ${X(this.swipeScrollRef)} class="wy-preview-swiper ${Rt(n)}">
                    ${Re(
      s,
      (a) => "preview-area-" + (a == null ? void 0 : a.id),
      (a) => {
        const o = a === i ? this.currentPreviewFileCallback : a === this.nextFile ? this.nextRef : a === this.previousFile ? this.prevRef : void 0;
        return a ? p`
                              <div
                                id="preview-${a.id}"
                                ${X(o)}
                                class="wy-preview-area wy-scroll-y wy-scroll-x"
                              >
                                ${t ? p` <wy-spinner overlay></wy-spinner> ` : p` <wy-preview-item .file=${a}></wy-preview-item> `}
                              </div>
                            ` : C;
      }
    )}
                  </div>
                  ${this.currentFile ? p`
                        ${this.previousFile ? p`
                              <nav class="wy-nav-prev">
                                <wy-button kind="icon" @click=${() => this.scrollToPrev()}>
                                  <wy-icon name="previous"></wy-icon>
                                </wy-button>
                              </nav>
                            ` : C}
                        ${this.nextFile ? p`
                              <nav class="wy-nav-next">
                                <wy-button kind="icon" @click=${() => this.scrollToNext()}>
                                  <wy-icon name="next"></wy-icon>
                                </wy-button>
                              </nav>
                            ` : C}
                      ` : C}
                </div>
              </div>
            </div> ` : C}
      </wy-overlay>
    ` : C;
  }
  updated() {
    requestAnimationFrame(
      () => requestAnimationFrame(() => {
        var t, i;
        this.swipeScrollRef.value ? ((t = this.swipeScroller).whenPrev ?? (t.whenPrev = async () => this.setPrev()), (i = this.swipeScroller).whenNext ?? (i.whenNext = async () => this.setNext()), this.swipeScroller.createObserver(this.swipeScrollRef.value), this.swipeScroller.observe(this.prevRef.value, this.nextRef.value)) : this.swipeScroller.clearObserver();
      })
    );
  }
}, c(ca, "WyPreview"), ca);
Nt.styles = [J];
de([
  w({ attribute: !1 })
], Nt.prototype, "files", 2);
de([
  w({ attribute: !1 })
], Nt.prototype, "queryResult", 2);
de([
  w({ attribute: !1 })
], Nt.prototype, "infiniteQueryResult", 2);
de([
  w({ type: Object })
], Nt.prototype, "user", 2);
de([
  w({ type: Number })
], Nt.prototype, "currentId", 2);
de([
  w({ type: Boolean })
], Nt.prototype, "isAttachment", 2);
de([
  w({ type: Boolean })
], Nt.prototype, "filled", 2);
de([
  D()
], Nt.prototype, "currentFile", 2);
de([
  D()
], Nt.prototype, "previousFile", 2);
de([
  D()
], Nt.prototype, "nextFile", 2);
de([
  D()
], Nt.prototype, "showOverlay", 2);
de([
  D()
], Nt.prototype, "commentsOpen", 2);
de([
  D()
], Nt.prototype, "versionsOpen", 2);
de([
  D()
], Nt.prototype, "versionFile", 2);
de([
  D()
], Nt.prototype, "sidePanelMaximized", 2);
de([
  D()
], Nt.prototype, "disableSwipeScroll", 2);
Nt = de([
  B("wy-preview"),
  st()
], Nt);
var L2 = Object.defineProperty, R2 = Object.getOwnPropertyDescriptor, ie = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? R2(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && L2(t, i, n), n;
}, "__decorateClass$w"), la;
let Ft = (la = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.me = !1, this.isBot = !1, this.isPrivateChat = !1, this.displayName = "", this.avatar = "", this.createdAt = "", this.html = "", this.text = "", this.attachments = [], this.pollOptions = [], this.reactions = [], this.seenBy = [], this.highlight = !1, this.previewRef = rt(), this.highlightRef = rt();
  }
  dispatchVote(t) {
    const i = new CustomEvent("vote", { detail: { id: t, parentId: this.messageId } });
    return this.dispatchEvent(i);
  }
  willUpdate(t) {
    t.has("link") && (this.highlight = !!(this.link && gl(this.link, Ne.Message, { id: this.messageId })));
  }
  render() {
    var a, o, l, d, u, y, m;
    const t = ((a = this.attachments) == null ? void 0 : a.filter((f) => f.kind === "image" && f.thumbnail_url)) || [], i = ((o = this.attachments) == null ? void 0 : o.filter((f) => f.kind !== "image" || !f.thumbnail_url)) || [], s = this.createdAt ? new Intl.DateTimeFormat((l = this.weavy) == null ? void 0 : l.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.createdAt)
    ) : "", n = this.createdAt ? new Intl.DateTimeFormat((d = this.weavy) == null ? void 0 : d.locale, { timeStyle: "short" }).format(new Date(this.createdAt)) : "";
    return p`
      <div
        class=${Rt({ "wy-message": !0, "wy-message-me": this.me, "wy-message-bot": this.isBot })}
        part=${Yt({ "wy-highlight": this.highlight })}
        ${X(this.highlightRef)}
      >
        ${this.me ? "" : p`
              <div class="wy-message-author">
                <wy-avatar
                  .src="${this.avatar}"
                  .size=${32}
                  .name="${this.displayName}"
                  .isBot=${this.isBot}
                ></wy-avatar>
              </div>
            `}

        <div class="wy-message-content">
          <div class="wy-message-meta">
            ${!this.isPrivateChat && !this.me ? p` <span>${this.displayName} · </span> ` : ""}
            <time datetime=${this.createdAt} title=${s}>${n}</time>
          </div>

          <div class="wy-message-bubble">
            ${this.messageId < 0 ? p`<wy-skeleton .text=${this.text}></wy-skeleton>` : p`
                  <!-- image grid -->
                  ${t && t.length ? p`<wy-image-grid
                        .images=${t}
                        @file-open=${(f) => {
      var g;
      (g = this.previewRef.value) == null || g.open(f.detail.fileId);
    }}
                      ></wy-image-grid>` : ""}

                  <!-- embeds -->
                  ${this.embed && ((u = this.hasFeatures) != null && u.embeds) ? p` <wy-embed class="wy-embed" .embed=${this.embed}></wy-embed> ` : C}

                  <!-- text -->
                  ${this.html ? p`<div class="wy-content">${qs(this.html)}</div>` : ""}

                  <!-- poll -->
                  ${this.pollOptions && this.pollOptions.length > 0 ? p`
                        <wy-poll
                          .pollOptions=${this.pollOptions}
                          @vote=${(f) => this.dispatchVote(f.detail.id)}
                        ></wy-poll>
                      ` : C}

                  <!-- meeting -->
                  ${this.meeting ? p`<wy-meeting-card .meeting=${this.meeting}></wy-meeting-card>` : ""}

                  <!-- files -->
                  ${i && i.length ? p`<wy-attachments-list
                        .files=${i}
                        @file-open=${(f) => {
      var g;
      (g = this.previewRef.value) == null || g.open(f.detail.fileId);
    }}
                      ></wy-attachments-list>` : ""}

                  <!-- reactions -->
                  ${(y = this.hasFeatures) != null && y.reactions && this.conversation ? p`
                        ${ph(
      `reactions-${this.conversation.id}-${this.messageId}`,
      p`
                            <wy-reactions
                              lineBelow
                              ?lineReverse=${!this.me}
                              small
                              directionX=${this.me ? "right" : "left"}
                              .reactions=${this.reactions}
                              parentId=${this.conversation.id}
                              parentType="apps"
                              entityId=${this.messageId}
                              entityType="messages"
                            ></wy-reactions>
                          `
    )}
                      ` : C}
                `}
          </div>
        </div>
      </div>
      ${(m = this.hasFeatures) != null && m.receipts ? p`<div class="wy-readby-status">
            ${this.seenBy && this.seenBy.length ? p`
                  ${this.seenBy.map((f) => {
      var x;
      const g = f.marked_at ? new Intl.DateTimeFormat((x = this.weavy) == null ? void 0 : x.locale, {
        dateStyle: "full",
        timeStyle: "short"
      }).format(new Date(f.marked_at)) : "";
      return p`<wy-avatar
                      title=${$(pt`Seen by ${f.display_name} at ${g}`)}
                      .name=${f.display_name}
                      .src=${f.avatar_url}
                      size=${18}
                    ></wy-avatar>`;
    })}
                ` : C}
          </div>` : C}
      ${this.attachments ? ph(
      `preview-message-${this.messageId}`,
      p`
              <wy-preview
                ${X(this.previewRef)}
                .files=${[...t, ...i]}
                .isAttachment=${!0}
              ></wy-preview>
            `
    ) : C}
    `;
  }
  updated(t) {
    var i;
    t.has("highlight") && this.highlight && ((i = this.highlightRef.value) == null || i.scrollIntoView({ block: "nearest" }));
  }
}, c(la, "WyMessage"), la);
Ft.styles = J;
ie([
  w({ attribute: !1 })
], Ft.prototype, "conversation", 2);
ie([
  w({ type: Number })
], Ft.prototype, "messageId", 2);
ie([
  w({ type: Boolean })
], Ft.prototype, "me", 2);
ie([
  w({ type: Boolean })
], Ft.prototype, "isBot", 2);
ie([
  w({ type: Boolean })
], Ft.prototype, "isPrivateChat", 2);
ie([
  w()
], Ft.prototype, "displayName", 2);
ie([
  w()
], Ft.prototype, "avatar", 2);
ie([
  w()
], Ft.prototype, "createdAt", 2);
ie([
  w()
], Ft.prototype, "html", 2);
ie([
  w()
], Ft.prototype, "text", 2);
ie([
  w({ type: Array })
], Ft.prototype, "attachments", 2);
ie([
  w({ attribute: !1 })
], Ft.prototype, "meeting", 2);
ie([
  w({ type: Array })
], Ft.prototype, "pollOptions", 2);
ie([
  w({ attribute: !1 })
], Ft.prototype, "embed", 2);
ie([
  w({ type: Array })
], Ft.prototype, "reactions", 2);
ie([
  w({ type: Array })
], Ft.prototype, "seenBy", 2);
ie([
  w({ type: Boolean })
], Ft.prototype, "highlight", 2);
Ft = ie([
  B("wy-message"),
  st()
], Ft);
var I2 = Object.defineProperty, T2 = Object.getOwnPropertyDescriptor, gs = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? T2(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && I2(t, i, n), n;
}, "__decorateClass$v"), da;
let ti = (da = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.dataUpdatedAt = NaN, this.unreadMarkerShow = !0;
  }
  dispatchVote(t, i) {
    const s = new CustomEvent("vote", { detail: { id: t, parentId: i, parentType: "messages" } });
    return this.dispatchEvent(s);
  }
  render() {
    const t = ms(this.infiniteMessages);
    let i;
    return p`
      <div class="wy-messages">
        <slot name="start"></slot>
        <!-- this.user ?? -->
        ${t && this.conversation && this.user ? Re(
      t,
      (s) => s.id,
      (s, n) => {
        var d, u, y, m, f, g, x;
        const a = new Date(s.created_at);
        let o = p``;
        if ((i == null ? void 0 : i.toDateString()) !== a.toDateString()) {
          const k = new Intl.DateTimeFormat((d = this.weavy) == null ? void 0 : d.locale, {
            dateStyle: "short"
          }).format(a);
          i = a, o = p`<div class="wy-date-separator"><time>${k}</time></div>`;
        }
        let l = p``;
        return this.unreadMarkerId && this.unreadMarkerId === s.id && (l = p`<div
                    id="unread-marker"
                    class="wy-toast wy-toast-action wy-fade ${this.unreadMarkerShow ? "wy-show" : ""}"
                    tabindex=${this.unreadMarkerShow ? 0 : -1}
                    @click=${() => {
          var S;
          let k = `#message-${this.unreadMarkerId}`;
          this.unreadMarkerPosition === "below" && (k += "~ wy-message"), (S = this.renderRoot.querySelector(k)) == null || S.scrollIntoView({
            block: "start",
            inline: "nearest",
            behavior: "smooth"
          });
        }}
                    @keydown=${xe}
                    @keyup=${je}
                  >
                    ${$("New messages")}
                  </div>`), p`${[
          p`${o}`,
          p`${this.unreadMarkerPosition === "above" ? l : C}`,
          ph(
            `message-${s.id}`,
            p`<wy-message
                      id="message-${s.id}"
                      .conversation=${this.conversation}
                      .messageId=${s.id}
                      .me=${s.created_by.id === ((u = this.user) == null ? void 0 : u.id)}
                      .isBot=${s.created_by.is_bot || !1}
                      .isPrivateChat=${((y = this.conversation) == null ? void 0 : y.type) === ct.PrivateChat || ((m = this.conversation) == null ? void 0 : m.type) === ct.BotChat}
                      .displayName=${s.created_by.display_name}
                      .avatar=${s.created_by.avatar_url}
                      .createdAt=${s.created_at}
                      .text=${s.plain}
                      .html=${s.html}
                      .attachments=${(f = s.attachments) == null ? void 0 : f.data}
                      .meeting=${s.meeting}
                      .pollOptions=${(g = s.options) == null ? void 0 : g.data}
                      .embed=${s.embed}
                      .reactions=${(x = s.reactions) == null ? void 0 : x.data}
                      .seenBy=${this.members && this.members.data && this.members.data.length > 0 ? this.members.data.filter((k) => {
              var S;
              return k.marked_id === s.id && k.id !== ((S = this.user) == null ? void 0 : S.id);
            }) : []}
                      @vote=${(k) => {
              this.dispatchVote(k.detail.id, k.detail.parentId);
            }}
                    ></wy-message>`
          ),
          p`${this.unreadMarkerPosition === "below" ? l : C}`
        ]}`;
      }
    ) : C}
        <slot name="end"></slot>
      </div>
    `;
  }
}, c(da, "WyMessages"), da);
ti.styles = [
  J,
  Z`
      :host(wy-messages) {
        display: contents;
      }
      wy-message {
        scroll-margin-block: 6rem;
      }
    `
];
gs([
  w({ attribute: !1 })
], ti.prototype, "conversation", 2);
gs([
  w({ attribute: !1 })
], ti.prototype, "infiniteMessages", 2);
gs([
  w({ type: Number })
], ti.prototype, "dataUpdatedAt", 2);
gs([
  w({ attribute: !1 })
], ti.prototype, "members", 2);
gs([
  w({ attribute: !1 })
], ti.prototype, "unreadMarkerId", 2);
gs([
  w({ attribute: !1 })
], ti.prototype, "unreadMarkerPosition", 2);
gs([
  w({ attribute: !1 })
], ti.prototype, "unreadMarkerShow", 2);
ti = gs([
  B("wy-messages"),
  st()
], ti);
var F2 = Object.defineProperty, D2 = Object.getOwnPropertyDescriptor, H2 = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? D2(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && F2(t, i, n), n;
}, "__decorateClass$u"), ha;
let xh = (ha = class extends xt {
  constructor() {
    super(), this.editorType = "messages", this.editorClass = "wy-message-editor";
  }
  renderTopSlot() {
    return this.renderLists();
  }
  renderMiddleSlot() {
    var t, i, s, n, a, o, l, d, u, y, m, f;
    return p` <div class="wy-message-editor-inputs">
      <!-- Add -->
      ${(t = this.hasFeatures) != null && t.attachments || (i = this.hasFeatures) != null && i.cloudFiles || (s = this.hasFeatures) != null && s.polls || (n = this.hasFeatures) != null && n.zoomMeetings || (a = this.hasFeatures) != null && a.googleMeet || (o = this.hasFeatures) != null && o.microsoftTeams ? p`<wy-dropdown icon="plus" directionY="up" ?disabled=${this.disabled}>
            ${(l = this.hasFeatures) != null && l.attachments ? p`
                  <wy-dropdown-item @click=${this.openFileInput} title=${$("From device")}>
                    <wy-icon name="attachment"></wy-icon>
                    <span>${$("From device")}</span>
                  </wy-dropdown-item>
                  <input
                    type="file"
                    ${X(this.fileInputRef)}
                    @click=${(g) => g.stopPropagation()}
                    @change=${(g) => this.handleUploadFiles(
      Array.from(g.target.files || []),
      g.target
    )}
                    multiple
                    hidden
                    tabindex="-1"
                  />
                ` : C}
            ${(d = this.hasFeatures) != null && d.cloudFiles ? p`
                  <wy-dropdown-item @click=${this.openCloudFiles} title=${$("From cloud")}>
                    <wy-icon name="cloud"></wy-icon>
                    <span>${$("From cloud")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${(u = this.hasFeatures) != null && u.polls ? p`
                  <wy-dropdown-item @click=${this.openPolls} title=${$("Poll")}>
                    <wy-icon name="poll"></wy-icon>
                    <span>${$("Poll")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${(y = this.hasFeatures) != null && y.zoomMeetings ? p`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("zoom")} title=${$("Zoom meeting")}>
                    <wy-icon svg="zoom-meetings"></wy-icon>
                    <span>${$("Zoom meeting")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${(m = this.hasFeatures) != null && m.googleMeet ? p`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("google")} title=${$("Google Meet")}>
                    <wy-icon svg="google-meet"></wy-icon>
                    <span>${$("Google Meet")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${(f = this.hasFeatures) != null && f.microsoftTeams ? p`
                  <wy-dropdown-item
                    @click=${() => this.handleMeetingClick("microsoft")}
                    title=${$("Microsoft Teams")}
                  >
                    <wy-icon svg="microsoft-teams"></wy-icon>
                    <span>${$("Microsoft Teams")}</span>
                  </wy-dropdown-item>
                ` : C}
          </wy-dropdown>` : C}

      <!-- Input -->
      <div class="wy-message-editor-text" ${X(this.editorRef)}> ${this.renderEditorDummy()} </div>

      <!-- Button -->
      <wy-button
        kind="icon"
        color="primary-text"
        title=${$("Send", { desc: "Button action to send" })}
        @click="${this.submit}"
        ?disabled=${this.disabled}
      >
        <wy-icon name="send"></wy-icon>
      </wy-button>
    </div>`;
  }
  renderBottomSlot() {
    return C;
  }
}, c(ha, "WyMessageEditor"), ha);
xh = H2([
  B("wy-message-editor"),
  st()
], xh);
const Bp = class Bp {
  constructor(t) {
    this.typingTimeout = null, this.discardTime = 5 * 1e3, this.typingMembers = [], this.names = [], this.ellipsis = "", this.handleRealtimeTyping = (i) => {
      i.entity.id === this.appId && i.actor.id !== this.userId && (this.setTypers(i.actor), this.updateTyping());
    }, this.handleRealtimeStopTyping = (i) => {
      this.typingMembers.forEach((s, n) => {
        s.id === i.actor.id && this.typingMembers.splice(n, 1);
      }), this.updateTyping();
    }, t.addController(this), this.host = t, this.setContext();
  }
  get weavy() {
    var t;
    return (t = this.context) == null ? void 0 : t.value;
  }
  get appId() {
    return this._appId;
  }
  set appId(t) {
    t !== this._appId && (this.typingMembers = [], this.unregisterRealtime(), this._appId = t, this.registerRealtime());
  }
  get userId() {
    return this._userId;
  }
  set userId(t) {
    t !== this._userId && (this.typingMembers = [], this.unregisterRealtime(), this._userId = t, this.registerRealtime());
  }
  async setContext() {
    this.whenContext = new Promise((t) => this.resolveContext = t), await oo(this.host), this.context = new as(this.host, { context: Xt, subscribe: !0 });
  }
  hostUpdate() {
    var t, i, s;
    (t = this.context) != null && t.value && ((s = this.resolveContext) == null || s.call(this, (i = this.context) == null ? void 0 : i.value));
  }
  async registerRealtime() {
    var t, i;
    this.appId && this._userId && (await this.whenContext, (t = this.weavy) == null || t.subscribe(`a${this.appId}`, "typing", this.handleRealtimeTyping), (i = this.weavy) == null || i.subscribe(`a${this.appId}`, "message_created", this.handleRealtimeStopTyping));
  }
  async unregisterRealtime() {
    var t, i;
    this.appId && this.userId && (await this.whenContext, (t = this.weavy) == null || t.unsubscribe(`a${this.appId}`, "typing", this.handleRealtimeTyping), (i = this.weavy) == null || i.unsubscribe(`a${this.appId}`, "message_created", this.handleRealtimeStopTyping));
  }
  /**
   * @fires typing
   */
  updateTyping() {
    this.typingTimeout && (clearTimeout(this.typingTimeout), this.typingTimeout = null);
    const t = Date.now();
    if (this.typingMembers.forEach((i, s) => {
      t - i.time > this.discardTime && this.typingMembers.splice(s, 1);
    }), this.typingMembers.length) {
      const i = Date.now(), s = Math.round(
        (i - Math.max.apply(
          null,
          this.typingMembers.map((n) => n.time)
        )) / 1e3
      ) % 3 + 1;
      this.ellipsis = ".".repeat(s), this.names = this.typingMembers.map((n) => n.display_name).sort(), this.typingTimeout = window.setTimeout(() => this.updateTyping(), 1e3);
    } else
      this.names = [];
    this.host.requestUpdate(), this.host.dispatchEvent(new CustomEvent("typing", { bubbles: !0, composed: !1, detail: { count: this.typingMembers.length } }));
  }
  setTypers(t) {
    this.typingMembers.forEach((s, n) => {
      s.id === t.id && this.typingMembers.splice(n, 1);
    });
    const i = { ...t, time: Date.now() };
    this.typingMembers.push(i);
  }
};
c(Bp, "TypingController");
let nl = Bp;
const V2 = Z`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-primary-95, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-primary-10, #001d32))}}.wy-messages{padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));flex:1 1 100%}.wy-message-placeholder{opacity:.5}.wy-date-separator{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));pointer-events:none;margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));text-align:center;position:sticky;top:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));z-index:10}.wy-date-separator time{background:var(--wy-surface-3, var(--wy-surface-3-light, #e3e7ee));color:var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:inline-block}.wy-message{display:flex;flex-direction:row;align-items:flex-start;margin-bottom:calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + .5 * var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));scroll-margin-block:6rem;--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}.wy-message[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}.wy-message .wy-image-grid,.wy-message .wy-attachments{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-message-meta{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:0 0 calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));color:var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}.wy-message-bubble{background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));display:flex;flex-direction:column;padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));max-width:min(32 * var(--wy-size, 1rem),100% - 2 * var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}.wy-message-bubble>div{flex:1 1 100%}.wy-message-author{margin:calc(1.375 * var(--wy-size, 1rem)) calc(.5 * var(--wy-size, 1rem)) 0 0}.wy-message-content{display:flex;flex-direction:column;width:100%;align-items:flex-start;flex-wrap:wrap;min-width:0;position:relative}.wy-message-content-row{display:flex;flex-direction:row;align-items:center;max-width:100%}.wy-message-bot{--wy-component-background-color: var(--wy-tertiary-container, var(--wy-tertiary-90, #bbf294));--wy-component-color: var(--wy-on-tertiary-container, var(--wy-tertiary-10, #0a2100))}.wy-message-me{margin-right:0;margin-left:calc(2.5 * var(--wy-size, 1rem));align-items:flex-end;--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-90, #cde5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-primary-10, #001d32))}.wy-message-me .wy-message-meta{margin:0 calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) 0}.wy-message-me .wy-message-content{align-items:flex-end}.wy-message-me .wy-message-content-row{flex-direction:row-reverse}.wy-message-emoji .wy-message-bubble{background:none;padding:0 0 var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}.wy-message-emoji .wy-content .wy-emoji{width:calc(3 * var(--wy-size, 1rem));height:calc(3 * var(--wy-size, 1rem));margin:0}.wy-message-emoji.wy-message-me .wy-content{text-align:end}.wy-readby-status{display:flex;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));height:calc(1.125 * var(--wy-size, 1rem));justify-content:flex-end;margin-top:calc(-.125 * var(--wy-size, 1rem))}.wy-message-readmore{justify-self:center;text-align:center}`, B2 = Z`@keyframes wy-bouncing{to{transform:translate3d(0,calc(-.25 * var(--wy-size, 1rem)),0)}}@keyframes wy-bouncing-fade{to{opacity:.2}}[part~=wy-bouncer]{width:calc(1.5 * var(--wy-size, 1rem));height:calc(.75 * var(--wy-size, 1rem))}[part~=wy-bouncer-dot]{position:relative;animation:wy-bouncing .6s infinite alternate,wy-bouncing-fade .6s infinite alternate;fill:currentColor}[part~=wy-bouncer-dot-start]{animation-delay:0s,.6s}[part~=wy-bouncer-dot-middle]{animation-delay:.3s,.3s}[part~=wy-bouncer-dot-end]{animation-delay:.6s,0s}`;
var U2 = Object.defineProperty, q2 = Object.getOwnPropertyDescriptor, _i = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? q2(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && U2(t, i, n), n;
}, "__decorateClass$t"), pa;
let Ie = (pa = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.typing = new nl(this), this.isBot = !1, this.isPrivateChat = !1, this.typingMembers = [], this.names = [];
  }
  willUpdate(t) {
    t.has("conversationId") && (this.typing.appId = this.conversationId), t.has("userId") && (this.typing.userId = this.userId);
    const { typingMembers: i, names: s } = this.typing;
    this.typingMembers = i, this.names = s, i.length ? this.typingTime || (this.typingTime = /* @__PURE__ */ new Date()) : this.typingTime = void 0;
  }
  render() {
    var o, l, d, u, y;
    const t = this.typingMembers.map(
      (m) => {
        var f;
        return (f = this.members) == null ? void 0 : f.find((g) => g.id === m.id);
      }
    ), i = new Intl.ListFormat((o = this.weavy) == null ? void 0 : o.locale, { style: "long", type: "conjunction" }).format(
      this.names
    ), s = this.typingTime ? new Intl.DateTimeFormat((l = this.weavy) == null ? void 0 : l.locale, { dateStyle: "full", timeStyle: "short" }).format(this.typingTime) : "", n = this.typingTime ? new Intl.DateTimeFormat((d = this.weavy) == null ? void 0 : d.locale, { timeStyle: "short" }).format(this.typingTime) : "", a = p`
      <svg part="wy-bouncer" viewBox="0 0 32 16" xmlns="http://www.w3.org/2000/svg">
        <circle part="wy-bouncer-dot wy-bouncer-dot-start" cx="4" cy="10" r="4" />
        <circle part="wy-bouncer-dot wy-bouncer-dot-middle" cx="16" cy="10" r="4" />
        <circle part="wy-bouncer-dot wy-bouncer-dot-end" cx="28" cy="10" r="4" />
      </svg>
    `;
    return t.length ? p`
          <div class=${Rt({ "wy-message": !0, "wy-message-bot": this.isBot })}>
            <div class="wy-message-author">
              ${t.length > 1 ? p`
                    <wy-avatar-group
                      .size=${32}
                      .members=${t}
                      title=${i}
                    ></wy-avatar-group>
                  ` : p`
                    <wy-avatar
                      .size=${32}
                      .src=${(u = t[0]) == null ? void 0 : u.avatar_url}
                      .name=${i}
                      .isBot=${this.isBot}
                    ></wy-avatar>
                  `}
            </div>

            <div class="wy-message-content">
              <div class="wy-message-meta">
                ${this.isPrivateChat ? p`
                      <time datetime=${lt((y = this.typingTime) == null ? void 0 : y.toISOString())} title=${s}>${n}</time>
                    ` : i}
              </div>
              <div class="wy-message-bubble"> ${a} </div>
            </div>
          </div>
        ` : C;
  }
}, c(pa, "WyMessageTyping"), pa);
Ie.styles = [te, B2, V2];
_i([
  Qt({ context: Xt, subscribe: !0 }),
  D()
], Ie.prototype, "weavy", 2);
_i([
  w({ attribute: !0, type: Number })
], Ie.prototype, "conversationId", 2);
_i([
  w({ attribute: !0, type: Number })
], Ie.prototype, "userId", 2);
_i([
  w({ type: Boolean })
], Ie.prototype, "isBot", 2);
_i([
  w({ type: Boolean })
], Ie.prototype, "isPrivateChat", 2);
_i([
  w({ attribute: !1 })
], Ie.prototype, "members", 2);
_i([
  D()
], Ie.prototype, "typingMembers", 2);
_i([
  D()
], Ie.prototype, "names", 2);
_i([
  D()
], Ie.prototype, "typingTime", 2);
Ie = _i([
  B("wy-message-typing")
], Ie);
var N2 = Object.defineProperty, j2 = Object.getOwnPropertyDescriptor, Yw = /* @__PURE__ */ c((r) => {
  throw TypeError(r);
}, "__typeError$a"), nr = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? j2(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && N2(t, i, n), n;
}, "__decorateClass$s"), Zw = /* @__PURE__ */ c((r, t, i) => t.has(r) || Yw("Cannot " + i), "__accessCheck$a"), Hu = /* @__PURE__ */ c((r, t, i) => (Zw(r, t, "read from private field"), i ? i.call(r) : t.get(r)), "__privateGet$a"), W2 = /* @__PURE__ */ c((r, t, i) => t.has(r) ? Yw("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(r) : t.set(r, i), "__privateAdd$a"), Vu = /* @__PURE__ */ c((r, t, i, s) => (Zw(r, t, "write to private field"), t.set(r, i), i), "__privateSet$a"), fr, ua;
let ei = (ua = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.lastReadMessagePosition = "below", this.showNewMessages = !1, this.releaseFocusEvent = () => new CustomEvent("release-focus", { bubbles: !0, composed: !0 }), this.messagesQuery = new Ri(this), this.membersQuery = new be(this), this.addMessageMutation = new Ae(this), this.infiniteScroll = new rh(this), this.pagerRef = rt(), this.bottomRef = rt(), this.shouldBeAtBottom = !0, this.isTyping = !1, this.handleRealtimeMessage = (t) => {
      if (!this.weavy || !this.conversation || !this.conversationId || !this.user)
        return;
      const i = ["messages", t.message.app.id];
      let s = ml(this.weavy.queryClient, i, t.message.id);
      s || (t.message.created_by.id === this.user.id && (s = Bs(this.weavy.queryClient, i, !0), s && _t(this.weavy.queryClient, i, s.id, (n) => {
        n.id = t.message.id, n.app = t.message.app, n.text = t.message.text, n.html = t.message.html, n.embed = t.message.embed, n.meeting = t.message.meeting, n.attachments = t.message.attachments, n.options = t.message.options, n.created_at = t.message.created_at, n.created_by = t.message.created_by, n.updated_at = t.message.updated_at, n.updated_by = t.message.updated_by;
      })), s || os(this.weavy.queryClient, i, t.message)), this.weavy.queryClient.setQueryData(
        ["apps", t.message.app.id],
        (n) => n && { ...n, last_message: t.message }
      ), !this.conversation.display_name && t.message.plain && this.setEmptyConversationTitle(t.message.plain), t.actor.id !== this.user.id && (this.isAtBottom ? (this.markAsRead(t.message.id), requestAnimationFrame(() => {
        this.scrollToBottom();
      })) : (this.weavy.queryClient.setQueryData(
        ["apps", t.message.app.id],
        (n) => n && { ...n, is_unread: !0 }
      ), this.lastReadMessagePosition = "above", this.lastReadMessageId = t.message.id, this.showNewMessages = !0), _t(
        this.weavy.queryClient,
        ["members", t.message.app.id],
        t.actor.id,
        (n) => {
          n.marked_id = t.message.id, n.marked_at = t.message.created_at;
        }
      ));
    }, this.handleRealtimeReactionAdded = (t) => {
      !this.weavy || !this.user || !this.conversation || nt(
        this.weavy.queryClient,
        { queryKey: ["messages"], exact: !1 },
        t.entity.id,
        (i) => {
          i.reactions || (i.reactions = { count: 0 }), i.reactions.data = [
            ...(i.reactions.data || []).filter((s) => {
              var n;
              return ((n = s.created_by) == null ? void 0 : n.id) !== t.actor.id;
            }),
            { content: t.reaction, created_by: t.actor }
          ];
        }
      );
    }, this.handleRealtimeReactionDeleted = (t) => {
      !this.weavy || !this.conversation || !this.user || nt(
        this.weavy.queryClient,
        { queryKey: ["messages"], exact: !1 },
        t.entity.id,
        (i) => {
          i.reactions && i.reactions.data && (i.reactions.data = i.reactions.data.filter((s) => {
            var n;
            return ((n = s.created_by) == null ? void 0 : n.id) !== t.actor.id;
          }));
        }
      );
    }, this.markAsReadHandler = () => {
      !document.hidden && this.isAtBottom && this.markAsRead();
    }, W2(this, fr);
  }
  isPrivateChat(t) {
    var i;
    return ((i = t ?? this.conversation) == null ? void 0 : i.type) === ct.PrivateChat;
  }
  isChatRoom(t) {
    var i;
    return ((i = t ?? this.conversation) == null ? void 0 : i.type) === ct.ChatRoom;
  }
  async handleTyping(t) {
    this.isTyping = !!t.detail.count, this.isTyping && this.isAtBottom && requestAnimationFrame(() => {
      this.scrollToBottom(!0);
    });
  }
  async handleSubmit(t) {
    if (!this.conversation || !this.user)
      throw new Error("Error submitting message. Missing user or conversation.");
    const i = await this.addMessageMutation.mutate({
      app_id: this.conversation.id,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embed,
      blobs: t.detail.blobs,
      user: this.user
    });
    return this.showNewMessages = !1, requestAnimationFrame(() => {
      this.scrollToBottom();
    }), i;
  }
  async setEmptyConversationTitle(t) {
    var i;
    !this.conversation || this.conversation.display_name || await ((i = this.updateConversationMutation) == null ? void 0 : i.mutate({ appId: this.conversation.id, name: t }));
  }
  get isAtBottom() {
    return this.bottomRef.value ? Om(this.bottomRef.value) : !0;
  }
  async scrollToBottom(t = !1) {
    this.bottomRef.value && await Od(this.bottomRef.value), Em(this.bottomRef.value) && this.conversationId && (requestAnimationFrame(() => {
      var i;
      ou((i = this.weavy) == null ? void 0 : i.queryClient, ["messages", this.conversationId], void 0, 1);
    }), Am(this.bottomRef.value, t));
  }
  async markAsRead(t) {
    var i, s;
    await Sf(), await Promise.race([Od(this), ly(this, !1)]), this.isConnected && this.conversation && this.conversation.last_message && ((s = this.markConversationMutation) == null || s.mutate({
      appId: this.conversation.id,
      messageId: t ?? this.conversation.last_message.id,
      userId: (i = this.user) == null ? void 0 : i.id
    }));
  }
  willUpdate(t) {
    var s, n, a, o, l, d, u, y, m;
    var i;
    if (super.willUpdate(t), t.has("weavy") && this.weavy && (this.updateConversationMutation = jy(this.weavy), this.markConversationMutation = qy(this.weavy)), (t.has("weavy") || t.has("conversationId")) && this.weavy) {
      (i = Hu(this, fr)) == null || i.call(this);
      const f = t.get("conversationId");
      if (f && requestAnimationFrame(() => {
        var g;
        ou((g = this.weavy) == null ? void 0 : g.queryClient, ["messages", f], void 0, 1);
      }), this.conversationId) {
        this.membersQuery.trackQuery(Wy(this.weavy, this.conversationId, {})), this.messagesQuery.trackInfiniteQuery(Mm(this.weavy, this.conversationId)), this.addMessageMutation.trackMutation(
          zm(this.weavy, ["messages", this.conversationId])
        ), this.pollMutation = Vh(this.weavy, ["messages", this.conversationId]), this.lastReadMessageId = void 0, this.showNewMessages = !1;
        const g = `a${this.conversationId}`;
        this.weavy.subscribe(g, "message_created", this.handleRealtimeMessage), this.weavy.subscribe(g, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(g, "reaction_removed", this.handleRealtimeReactionDeleted), Vu(this, fr, () => {
          var x, k, S;
          (x = this.weavy) == null || x.unsubscribe(g, "message_created", this.handleRealtimeMessage), (k = this.weavy) == null || k.unsubscribe(g, "reaction_added", this.handleRealtimeReactionAdded), (S = this.weavy) == null || S.unsubscribe(g, "reaction_removed", this.handleRealtimeReactionDeleted), Vu(this, fr, void 0);
        });
      } else
        this.messagesQuery.untrackInfiniteQuery(), this.addMessageMutation.untrackMutation(), this.membersQuery.untrackQuery();
    }
    if (t.has("showNewMessages") && this.showNewMessages && (this.shouldBeAtBottom = this.isAtBottom), t.has("conversationId") && t.get("conversationId") !== this.conversationId ? this.shouldBeAtBottom = !!this.conversationId : this.shouldBeAtBottom = this.isAtBottom, t.has("conversation")) {
      const f = t.get("conversation");
      if ((f == null ? void 0 : f.id) !== ((s = this.conversation) == null ? void 0 : s.id) || (f == null ? void 0 : f.is_unread) !== ((n = this.conversation) == null ? void 0 : n.is_unread))
        if ((a = this.conversation) != null && a.is_unread) {
          const g = (d = (l = (o = this.membersQuery.result.data) == null ? void 0 : o.data) == null ? void 0 : l.find(
            (x) => {
              var k;
              return x.id === ((k = this.user) == null ? void 0 : k.id);
            }
          )) == null ? void 0 : d.marked_id;
          g && g < this.conversation.last_message.id && (this.lastReadMessagePosition = "below", this.lastReadMessageId = g, this.showNewMessages = !0), ((f == null ? void 0 : f.id) !== ((u = this.conversation) == null ? void 0 : u.id) || (f == null ? void 0 : f.last_message.id) !== ((y = this.conversation) == null ? void 0 : y.last_message.id) && (this.shouldBeAtBottom || this.isAtBottom)) && this.markAsRead();
        } else (f == null ? void 0 : f.id) !== ((m = this.conversation) == null ? void 0 : m.id) && (this.showNewMessages = !1);
    }
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.messagesQuery.result, this.pagerRef.value);
  }
  render() {
    var a, o, l;
    const { isPending: t } = ((a = this.weavy) == null ? void 0 : a.network) ?? { isPending: !0 }, { data: i, isPending: s, hasNextPage: n } = this.messagesQuery.result ?? { isPending: t };
    return p`
      ${this.conversation && i ? p`
            ${!n && !s ? p` <!-- Top of the conversation --> ` : C}
            <wy-messages
              .conversation=${this.conversation}
              .infiniteMessages=${i}
              .unreadMarkerId=${this.lastReadMessageId}
              .unreadMarkerPosition=${this.lastReadMessagePosition}
              .unreadMarkerShow=${this.showNewMessages}
              @vote=${(d) => {
      var u;
      (u = this.pollMutation) == null || u.mutate({
        optionId: d.detail.id,
        parentType: d.detail.parentType,
        parentId: d.detail.parentId
      });
    }}
            >
              ${n ? p`<div slot="start" ${X(this.pagerRef)} part="wy-pager wy-pager-top"></div>` : C}
              <wy-message-typing
                slot="end"
                .conversationId=${this.conversation.id}
                .userId=${(o = this.user) == null ? void 0 : o.id}
                .isPrivateChat=${this.isPrivateChat()}
                .members=${this.conversation.members.data}
                @typing=${(d) => this.handleTyping(d)}
              ></wy-message-typing>
            </wy-messages>
          ` : p`
            <div class="wy-messages">
              <wy-empty class="wy-pane">
                ${s || !this.conversation ? p`<wy-spinner overlay></wy-spinner>` : $("Start the conversation!")}
              </wy-empty>
            </div>
          `}
      ${this.conversation ? p`
            <div ${X(this.bottomRef)}></div>
            <div class="wy-footerbar wy-footerbar-sticky">
              <wy-message-editor
                .draft=${!0}
                placeholder=${$("Type a message...")}
                ?disabled=${!Us(ns.Create, (l = this.conversation) == null ? void 0 : l.permissions)}
                @submit=${(d) => this.handleSubmit(d)}
              ></wy-message-editor>
            </div>
          ` : C}
    `;
  }
  updated() {
    this.shouldBeAtBottom && requestAnimationFrame(() => {
      this.scrollToBottom();
    }), this.bottomObserver || (this.bottomObserver = new IntersectionObserver((t) => {
      t.forEach((i) => {
        var s;
        i.isIntersecting && !this.isTyping && (s = this.conversation) != null && s.is_unread && this.markAsRead();
      });
    })), this.bottomRef && this.bottomRef.value && this.bottomObserver.observe(this.bottomRef.value);
  }
  // hook up observer
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("visibilitychange", this.markAsReadHandler), this.conversationId && this.requestUpdate("conversationId");
  }
  disconnectedCallback() {
    var t;
    (t = Hu(this, fr)) == null || t.call(this), this.bottomObserver && this.bottomObserver.disconnect(), document.removeEventListener("visibilitychange", this.markAsReadHandler), this.conversation = void 0, this.shouldBeAtBottom = this.isAtBottom, super.disconnectedCallback();
  }
}, c(ua, "WyConversation"), ua);
fr = /* @__PURE__ */ new WeakMap();
ei.styles = [
  J,
  ir,
  Z`
      :host {
        position: relative;
        display: flex;
        flex-direction: column;
        flex: 1 1 auto;
      }

      wy-messages {
        display: contents;
      }

      wy-message {
        scroll-margin-block: 6rem;
      }
    `
];
nr([
  er({ context: Ih }),
  w({ attribute: !1 })
], ei.prototype, "conversation", 2);
nr([
  w({ type: Number })
], ei.prototype, "conversationId", 2);
nr([
  w()
], ei.prototype, "cssClass", 2);
nr([
  D()
], ei.prototype, "lastReadMessagePosition", 2);
nr([
  D()
], ei.prototype, "lastReadMessageId", 2);
nr([
  D()
], ei.prototype, "showNewMessages", 2);
ei = nr([
  B("wy-conversation"),
  st()
], ei);
var ne = /* @__PURE__ */ ((r) => (r.All = "", r.Activity = "activity", r.Mention = "mention", r.Reaction = "reaction", r))(ne || {});
function Q2(r, t = ne.All, i, s = {}) {
  return {
    ...s,
    initialPageParam: 0,
    queryKey: ["notifications", "list", i, t],
    queryFn: /* @__PURE__ */ c(async (n) => {
      var u;
      const a = new URLSearchParams({
        skip: ((u = n.pageParam) == null ? void 0 : u.toString()) || "0",
        type: t
      }), o = `/api/${i ? `apps/${i.toString()}/` : ""}notifications?${a.toString()}`, d = await (await r.fetch(o)).json();
      return d.data = d.data || [], d;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ c((n) => {
      if (n.end && n.end < n.count)
        return n.end;
    }, "getNextPageParam")
  };
}
c(Q2, "getNotificationsOptions");
function K2(r, t = ne.All, i) {
  var a;
  const s = (a = r.queryClient.getQueryData(["notifications", "list", i, t])) == null ? void 0 : a.pages.flatMap((o) => o.data);
  let n;
  return s == null || s.forEach((o) => {
    n = n && o && n.id > o.id ? n : o;
  }), n;
}
c(K2, "getLastNotification");
function G2(r, t) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ notificationId: s }) => {
      const n = new URL(`/api/${t ? `apps/${t.toString()}/` : ""}notifications/mark`, r.url);
      s && n.searchParams.append("id", s.toString()), await r.fetch(n, { method: "PUT" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (s) => {
      const n = [];
      return nt(
        r.queryClient,
        { queryKey: t ? ["notifications", "list", t] : ["notifications", "list"], exact: !1 },
        void 0,
        (a) => {
          n.push({ id: a.id, is_unread: a.is_unread }), a.is_unread = !1;
        }
      ), t && n.length && nt(
        r.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        (a) => !!n.find((o) => o.id === a.id && a.is_unread),
        (a) => {
          a.is_unread = !1;
        }
      ), t || Uc(
        r.queryClient,
        { queryKey: ["notifications", "badge"], exact: !1 },
        () => 0
      ), Uc(
        r.queryClient,
        {
          queryKey: t ? ["apps", "notifications", "badge", t] : ["apps", "notifications", "badge"],
          exact: !1
        },
        () => 0
      ), { changedNotifications: n };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c(() => {
      t && r.queryClient.invalidateQueries({ queryKey: ["notifications", "badge"], exact: !1 });
    }, "onSuccess"),
    onSettled: /* @__PURE__ */ c(() => {
      r.queryClient.invalidateQueries({ queryKey: ["notifications", "list"], exact: !1 }), r.queryClient.invalidateQueries({ queryKey: ["notifications", "badge"], exact: !1 }), r.queryClient.invalidateQueries({ queryKey: ["apps", "notifications", "badge"], exact: !1 });
    }, "onSettled"),
    onError: /* @__PURE__ */ c((s, n, a) => {
      console.error(s.message);
    }, "onError")
  };
}
c(G2, "getMarkNotificationsMutationOptions");
function Y2(r, t) {
  return new bt(r.queryClient, G2(r, t));
}
c(Y2, "getMarkNotificationsMutation");
function Z2(r) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ markAsRead: i, notificationId: s }) => {
      const n = `/api/notifications/${s}/mark`;
      await r.fetch(n, { method: i ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (i) => {
      const s = /* @__PURE__ */ new Map();
      nt(
        r.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        i.notificationId,
        (n) => {
          !!n.is_unread === i.markAsRead && s.set(n.id, n), n.is_unread = !i.markAsRead;
        }
      ), s.size && (Uc(
        r.queryClient,
        { queryKey: ["notifications", "badge"], exact: !1 },
        (n) => Math.max(0, n + (i.markAsRead ? -1 : 1))
      ), s.forEach((n) => {
        n.link.app && Uc(
          r.queryClient,
          {
            queryKey: ["apps", "notifications", "badge"],
            predicate: /* @__PURE__ */ c((a) => {
              var o, l;
              return a.queryKey[3] === ((o = n.link.app) == null ? void 0 : o.id) || a.queryKey[3] === ((l = n.link.app) == null ? void 0 : l.uid);
            }, "predicate"),
            exact: !1
          },
          (a) => Math.max(0, a + (i.markAsRead ? -1 : 1))
        );
      }));
    }, "onMutate"),
    onError: /* @__PURE__ */ c((i, s) => {
      nt(
        r.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        s.notificationId,
        (n) => {
          n.is_unread = s.markAsRead;
        }
      ), r.queryClient.invalidateQueries({ queryKey: ["notifications", "badge"], exact: !1 }), r.queryClient.invalidateQueries({ queryKey: ["apps", "notifications", "badge"], exact: !1 });
    }, "onError")
  };
}
c(Z2, "getMarkNotificationMutationOptions");
function Xw(r) {
  return new bt(r.queryClient, Z2(r));
}
c(Xw, "getMarkNotificationMutation");
function X2(r, t = ne.All, i, s = {}) {
  const n = new URLSearchParams({
    type: t,
    count_only: "true",
    unread: "true"
  }), a = `/api/${i ? `apps/${i.toString()}/` : ""}notifications?${n.toString()}`;
  return yi(r, i ? ["apps", "notifications", "badge", i, t] : ["notifications", "badge", t], a, s);
}
c(X2, "getBadgeOptions");
var J2 = Object.defineProperty, t5 = Object.getOwnPropertyDescriptor, Jw = /* @__PURE__ */ c((r) => {
  throw TypeError(r);
}, "__typeError$9"), tf = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? t5(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && J2(t, i, n), n;
}, "__decorateClass$r"), ef = /* @__PURE__ */ c((r, t, i) => t.has(r) || Jw("Cannot " + i), "__accessCheck$9"), Bu = /* @__PURE__ */ c((r, t, i) => (ef(r, t, "read from private field"), i ? i.call(r) : t.get(r)), "__privateGet$9"), e5 = /* @__PURE__ */ c((r, t, i) => t.has(r) ? Jw("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(r) : t.set(r, i), "__privateAdd$9"), Uu = /* @__PURE__ */ c((r, t, i, s) => (ef(r, t, "write to private field"), t.set(r, i), i), "__privateSet$9"), mr, ya;
let No = (ya = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.typeFilter = ne.All, this.badgeQuery = new be(this), this.handleRefresh = () => {
      this.badgeQuery.result.refetch();
    }, e5(this, mr);
  }
  async willUpdate(t) {
    var s;
    var i;
    super.willUpdate(t), (t.has("weavy") || t.has("typeFilter") || t.has("app")) && this.weavy && this.badgeQuery.trackQuery(X2(this.weavy, this.typeFilter, (s = this.app) == null ? void 0 : s.id), !0), t.has("weavy") && this.weavy && ((i = Bu(this, mr)) == null || i.call(this), this.weavy.subscribe(null, "notification_created", this.handleRefresh), this.weavy.subscribe(null, "notification_updated", this.handleRefresh), this.weavy.subscribe(null, "notifications_marked", this.handleRefresh), Uu(this, mr, () => {
      var n, a, o;
      (n = this.weavy) == null || n.unsubscribe(null, "notification_created", this.handleRefresh), (a = this.weavy) == null || a.unsubscribe(null, "notification_updated", this.handleRefresh), (o = this.weavy) == null || o.unsubscribe(null, "notifications_marked", this.handleRefresh), Uu(this, mr, void 0);
    }));
  }
  render() {
    var n;
    const { data: t, isPending: i } = this.badgeQuery.result ?? {}, s = t != null && t.count ? t.count >= 100 ? "99+" : t.count : "";
    return p`
      ${this.user && !i && (t != null && t.count) ? p`
          <span class="wy-badge ${((n = this.settings) == null ? void 0 : n.notificationsBadge) === "count" ? "wy-button-badge" : "wy-button-dot"}" title=${t == null ? void 0 : t.count}>${s}</span> 
        ` : C}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = Bu(this, mr)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(ya, "WyNotificationBadge"), ya);
mr = /* @__PURE__ */ new WeakMap();
No.styles = [
  J,
  Fh
];
tf([
  w()
], No.prototype, "typeFilter", 2);
No = tf([
  B("wy-notification-badge"),
  st()
], No);
var i5 = Object.defineProperty, s5 = Object.getOwnPropertyDescriptor, sf = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? s5(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && i5(t, i, n), n;
}, "__decorateClass$q"), wa;
let al = (wa = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.showNotifications = !1, this.notificationsRef = rt(), this.appSubscribeMutation = new Ae(this);
  }
  handleSubscribe(t) {
    var i;
    (i = this.app) != null && i.id && this.appSubscribeMutation.mutate({ subscribe: t });
  }
  willUpdate(t) {
    (t.has("weavy") || t.has("app")) && this.weavy && this.app && this.appSubscribeMutation.trackMutation(Sy(this.weavy, this.app));
  }
  render() {
    var t, i, s, n;
    return ((t = this.settings) == null ? void 0 : t.notifications) === "none" ? C : p`
      <wy-button
        kind="icon"
        ?active=${this.showNotifications}
        @click=${() => this.showNotifications = !this.showNotifications}
      >
        <wy-icon name="bell"></wy-icon>
        ${((i = this.settings) == null ? void 0 : i.notificationsBadge) !== "none" ? p` <wy-notification-badge></wy-notification-badge> ` : C}
      </wy-button>

      <wy-sheet
        noPadding
        .show=${this.showNotifications}
        @close=${() => this.showNotifications = !1}
        @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
      >
        <wy-dropdown slot="appbar-buttons" ?disabled=${!this.app}>
          ${(s = this.app) != null && s.is_subscribed ? p`<wy-dropdown-item @click=${() => this.handleSubscribe(!1)}>
                <wy-icon name="bell-off"></wy-icon>
                ${$("Unsubscribe")}
              </wy-dropdown-item>` : p`<wy-dropdown-item @click=${() => this.handleSubscribe(!0)}>
                <wy-icon name="bell"></wy-icon>
                ${$("Subscribe")}
              </wy-dropdown-item>`}
        </wy-dropdown>
        <span slot="appbar-text">${$("Notifications")}</span>
        ${this.showNotifications ? p`
              <wy-notification-list ${X(this.notificationsRef)}>
                ${(n = this.app) != null && n.is_subscribed ? C : p`
                      <wy-empty slot="empty">
                          <div>${$("You are not subscribed to updates yet.")}</div>
                          <wy-button color="primary" @click=${() => this.handleSubscribe(!0)}>${$("Subscribe")}</wy-button>
                      </wy-empty>
                    `}
              </wy-notification-list>
            ` : C}
      </wy-sheet>
    `;
  }
}, c(wa, "WyNotificationButtonList"), wa);
sf([
  D()
], al.prototype, "showNotifications", 2);
al = sf([
  B("wy-notification-button-list"),
  st()
], al);
var r5 = Object.defineProperty, n5 = Object.getOwnPropertyDescriptor, a5 = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? n5(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && r5(t, i, n), n;
}, "__decorateClass$p");
const o5 = "wy-chat";
var fa;
let ol = (fa = class extends at {
  constructor() {
    super(), this.productType = ho.Chat, this.componentType = ze.Chat, new fi(this, ol.styles);
  }
  render() {
    return this.app ? p`
          <wy-buttons floating reverse>
            <wy-notification-button-list></wy-notification-button-list>
          </wy-buttons>
          <wy-conversation .conversation=${this.app} .conversationId=${this.app.id}></wy-conversation>
        ` : p` <wy-empty><wy-spinner padded reveal></wy-spinner></wy-empty> `;
  }
}, c(fa, "WyChat"), fa);
ol.styles = [J, po, pc, We, fs];
ol = a5([
  B(o5),
  st()
], ol);
var c5 = Object.defineProperty, l5 = Object.getOwnPropertyDescriptor, d5 = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? l5(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && c5(t, i, n), n;
}, "__decorateClass$o");
const h5 = "wy-comments";
var ma;
let cl = (ma = class extends at {
  constructor() {
    super(), this.productType = ho.Comments, this.componentType = ze.Comments, new fi(this, cl.styles);
  }
  render() {
    return this.app ? p`
          <wy-buttons floating reverse>
            <wy-notification-button-list></wy-notification-button-list>
          </wy-buttons>
          <wy-comment-list parentId=${this.app.id} .location=${"apps"}></wy-comment-list>
        ` : p`
          <wy-empty>
            <wy-spinner padded reveal></wy-spinner>
          </wy-empty>
        `;
  }
}, c(ma, "WyComments"), ma);
cl.styles = [J, po, pc, We, fs];
cl = d5([
  B(h5),
  st()
], cl);
function p5(r, t, i = {}, s = {}) {
  if (!r)
    throw new Error("useFileList must be used within a WeavyContext");
  return {
    ...s,
    queryKey: ["apps", t, "files", i],
    initialPageParam: 0,
    queryFn: /* @__PURE__ */ c(async (a) => {
      const o = a.pageParam, l = !!(i != null && i.trashed), d = i.order ? i.order.by + (i.order.descending ? "+desc" : "") : "";
      let u = "/api/apps/" + t + "/files?skip=" + o + "&order_by=" + d;
      return l && (u += "&trashed=null"), await (await r.fetch(u)).json();
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ c((a) => a.end && a.end < a.count ? a.end : null, "getNextPageParam")
  };
}
c(p5, "getInfiniteFileListOptions");
function u5(r, t) {
  const i = r.queryClient, n = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ c(async ({ file: a, name: o }) => {
      if (a.id >= 1) {
        const l = await r.fetch("/api/files/" + a.id, {
          method: "PATCH",
          body: JSON.stringify({
            name: o
          })
        });
        if (!l.ok) {
          const d = await l.json();
          throw new Error(d.detail || d.title, { cause: d });
        }
        return l.json();
      } else
        throw new Error(`Could not rename ${a.name}`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((a) => (nt(
      i,
      { queryKey: n.mutationKey, exact: !1 },
      a.file.id,
      (o) => Object.assign(o, { name: a.name })
    ), { type: "rename", file: a.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ c((a, o) => {
      nt(
        i,
        { queryKey: n.mutationKey, exact: !1 },
        o.file.id,
        (l) => Object.assign(l, a)
      ), Lt(i, n.mutationKey, o, (l) => {
        l.status.state = "ok";
      });
    }, "onSuccess"),
    onError(a, o) {
      nt(
        i,
        { queryKey: n.mutationKey, exact: !1 },
        o.file.id,
        (l) => Object.assign(l, { name: o.file.name })
      ), Lt(i, n.mutationKey, o, (l) => {
        l.status.state = "error", l.status.text = a.message;
      });
    }
  };
  return n;
}
c(u5, "getRenameFileMutationOptions");
function y5(r, t) {
  return new bt(r.queryClient, u5(r, t));
}
c(y5, "getRenameFileMutation");
function w5(r, t) {
  const i = r.queryClient, n = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ c(async ({ file: a }) => {
      if (a.id >= 1) {
        if (!(await r.fetch("/api/files/" + a.id + "/trash", { method: "POST" })).ok)
          throw new Error();
      } else
        throw new Error(`Could not trash ${a.name}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (a) => (nt(
      i,
      { queryKey: n.mutationKey, exact: !1 },
      a.file.id,
      (o) => Object.assign(o, { is_trashed: !0 })
    ), { type: "trash", file: a.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ c((a, o) => {
      nt(
        i,
        { queryKey: n.mutationKey, exact: !1 },
        o.file.id,
        (l) => Object.assign(l, a)
      ), Lt(i, n.mutationKey, o, (l) => {
        l.status.state = "ok";
      });
    }, "onSuccess"),
    onError(a, o) {
      nt(
        i,
        { queryKey: n.mutationKey, exact: !1 },
        o.file.id,
        (l) => Object.assign(l, { is_trashed: !1 })
      ), Lt(i, n.mutationKey, o, (l) => {
        l.status.state = "error", l.status.text = a.message;
      });
    }
  };
  return n;
}
c(w5, "getTrashFileMutationOptions");
function f5(r, t) {
  return new bt(r.queryClient, w5(r, t));
}
c(f5, "getTrashFileMutation");
function m5(r, t) {
  const i = r.queryClient, n = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ c(async ({ file: a }) => {
      if (a.id >= 1) {
        const o = await r.fetch("/api/files/" + a.id + "/restore", { method: "POST" });
        if (!o.ok) {
          const l = await o.json();
          throw new Error(l.detail || l.title, { cause: l });
        }
      } else {
        const o = { status: 400, title: `Could not restore ${a.name}.` };
        throw new Error(o.detail || o.title, { cause: o });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (a) => (nt(
      i,
      { queryKey: n.mutationKey, exact: !1 },
      a.file.id,
      (o) => Object.assign(o, { status: "pending" })
    ), { type: "restore", file: a.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ c((a, o) => {
      nt(
        i,
        { queryKey: n.mutationKey, exact: !1 },
        o.file.id,
        (l) => Object.assign(l, { is_trashed: !1, status: "ok" })
      ), Lt(i, n.mutationKey, o, (l) => {
        l.status.state = "ok";
      });
    }, "onSuccess"),
    onError(a, o) {
      nt(
        i,
        { queryKey: n.mutationKey, exact: !1 },
        o.file.id,
        (l) => Object.assign(l, { is_trashed: !0 })
      ), Lt(i, n.mutationKey, o, (l) => {
        l.status.state = "error", l.status.text = a.message;
      });
    }
  };
  return n;
}
c(m5, "getRestoreFileMutationOptions");
function v5(r, t) {
  return new bt(r.queryClient, m5(r, t));
}
c(v5, "getRestoreFileMutation");
function g5(r, t) {
  const i = r.queryClient, n = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ c(async ({ file: a }) => {
      if (a.id >= 1 && a.is_trashed) {
        const o = await r.fetch("/api/files/" + a.id, { method: "DELETE" });
        if (!o.ok) {
          const l = await o.json();
          throw new Error(l.detail || l.title, { cause: l });
        }
      } else {
        const o = { status: 400, title: `Could not delete ${a.name} forever.` };
        throw new Error(o.detail || o.title, { cause: o });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (a) => (nt(
      i,
      { queryKey: n.mutationKey, exact: !1 },
      a.file.id,
      (o) => Object.assign(o, { status: "pending" })
    ), { type: "delete-forever", file: a.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ c((a, o) => {
      Pm(i, { queryKey: n.mutationKey, exact: !1 }, o.file.id), Lt(i, n.mutationKey, o, (l) => {
        l.status.state = "ok";
      });
    }, "onSuccess"),
    onError(a, o) {
      nt(
        i,
        { queryKey: n.mutationKey, exact: !1 },
        o.file.id,
        (l) => Object.assign(l, { status: void 0 })
      ), Lt(i, n.mutationKey, o, (l) => {
        l.status.state = "error", l.status.text = a.message;
      });
    }
  };
  return n;
}
c(g5, "getDeleteForeverFileMutationOptions");
function b5(r, t) {
  return new bt(r.queryClient, g5(r, t));
}
c(b5, "getDeleteForeverFileMutation");
function x5(r, t) {
  const i = r.queryClient, s = ["apps", t.id, "files"];
  return {
    mutationKey: s,
    mutationFn: /* @__PURE__ */ c(async ({ file: a, subscribe: o }) => {
      if (a.id >= 1) {
        const l = await r.fetch(`/api/files/${a.id}/${o ? "subscribe" : "unsubscribe"}`, {
          method: "POST"
        });
        if (!l.ok) {
          const d = await l.json();
          throw new Error(d.detail || d.title, { cause: d });
        }
      } else
        throw new Error(`Could not ${o ? "subscribe" : "unsubscribe"} to ${a.name}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (a) => (nt(
      i,
      { queryKey: s, exact: !1 },
      a.file.id,
      (o) => Object.assign(o, { is_subscribed: a.subscribe, status: "pending" })
    ), {
      type: a.subscribe ? "subscribe" : "unsubscribe",
      file: a.file,
      status: { state: "pending" }
    }), "onMutate"),
    onSuccess: /* @__PURE__ */ c((a, o) => {
      nt(
        i,
        { queryKey: s, exact: !1 },
        o.file.id,
        (l) => Object.assign(l, { status: "ok" })
      ), Lt(i, s, o, (l) => {
        l.status.state = "ok";
      });
    }, "onSuccess"),
    onError(a, o) {
      nt(
        i,
        { queryKey: s, exact: !1 },
        o.file.id,
        (l) => Object.assign(l, { is_subscribed: o.file.is_subscribed, status: "error" })
      ), Lt(i, s, o, (l) => {
        l.status.state = "error", l.status.text = a.message;
      });
    }
  };
}
c(x5, "getSubscribeFileMutationOptions");
function $5(r, t) {
  return new bt(r.queryClient, x5(r, t));
}
c($5, "getSubscribeFileMutation");
const k5 = /* @__PURE__ */ c((r) => {
  var t, i, s, n, $h, rf, kh, vr, Ch, y;
  return y = class extends r {
    /**
     * @constructor
     * @hideconstructor
     */
    constructor(...g) {
      super(...g);
      T(this, n);
      T(this, t, []);
      T(this, i);
      T(this, s, /* @__PURE__ */ new Set());
    }
    get eventParent() {
      return b(this, i);
    }
    set eventParent(g) {
      g != null && g.eventChildren && g.eventChildren.add(this), I(this, i, g);
    }
    get eventChildren() {
      return b(this, s);
    }
    /**
     * Registers one or several event listeners. All event listeners are managed and automatically unregistered on destroy.
     *
     * When listening to weavy events, you may also listen to `before:` and `after:` events by simply adding the prefix to a weavy event.
     * Event handlers listening to weavy events may return modified data that is returned to the trigger. The data is passed on to the next event in the trigger event chain. If an event handler calls `event.stopPropagation()` or `return false`, the event chain will be stopped and the value is returned.
     *
     * @example <caption>Instance event</caption>
     * myInstance.on("before:options", function(options) { ... })
     * myInstance.on("options", function(options) { ... })
     * myInstance.on("after:options", function(options) { ... })
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#on
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string|Object} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     */
    on(...g) {
      const x = tt(this, n, Ch).call(this, g);
      if (g[3]) {
        const S = /* @__PURE__ */ c((...P) => {
          try {
            x.handler.apply(this, P);
          } catch {
            try {
              x.handler();
            } catch (E) {
              console.warn("Could not invoke one handler:", E);
            }
          }
          tt(this, n, kh).call(this, x.events, x.selector, null, x.handler);
        }, "attachedHandler");
        tt(this, n, $h).call(this, x.events, x.selector, S, x.handler);
      } else
        tt(this, n, $h).call(this, x.events, x.selector, x.handler, x.handler);
    }
    /**
     * Registers one or several event listeners that are executed once. All event listeners are managed and automatically unregistered on destroy.
     *
     * Similar to {@link WeavyEvents#on}.
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#one
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string|Object} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {Function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     */
    one(g, x, k) {
      this.on(g, x, k, !0);
    }
    /**
     * Unregisters event listeners. The arguments must match the arguments provided on registration using .on() or .one().
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#off
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     * @returns {boolean} Was the handler removed?
     */
    off(...g) {
      const x = tt(this, n, Ch).call(this, g), k = tt(this, n, rf).call(this, x.events, x.selector, x.handler);
      return tt(this, n, kh).call(this, x.events, x.selector, k, x.handler);
    }
    /**
     * Clears all registered eventhandlers
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#clear
     */
    clearEventHandlers() {
      b(this, t).length = 0;
    }
    /**
     * Trigger a custom event. Events are per default triggered on the weavy instance using the weavy namespace.
     *
     * The trigger has an event chain that adds `before:` and `after:` events automatically for all events except when any custom `prefix:` is specified. This way you may customize the eventchain by specifying `before:`, `on:` and `after:` in your event name to fire them one at the time. The `on:` prefix will then be removed from the name when the event is fired.
     *
     * Eventhandlers listening to the event may return modified data that is returned by the trigger event. The data is passed on to the next event in the trigger event chain. If an event handler calls `event.stopPropagation()` or `return false`, the event chain will be stopped and the value is returned.
     *
     * @example
     * // Normal triggering
     * weavyEvents.triggerEvent("myevent");
     *
     * // Will trigger the following events on the root instance
     * // 1. before:myevent.event.weavy
     * // 2. myevent.event.weavy
     * // 3. after:myevent.event.weavy
     *
     * @example
     * // Custom triggering, one at the time
     * weavyEvents.triggerEvent("before:myevent");
     * weavyEvents.triggerEvent("on:myevent");
     * weavyEvents.triggerEvent("after:myevent");
     *
     * @example
     * // Advanced triggering with data handling
     *
     * function doSomething() {
     *     // Will trigger the events sequentially and check the response data in between
     *
     *     var myTriggerData = { counter: 123, label: "my label" };
     *
     *     // Custom triggering, one at the time
     *
     *     // 1. Trigger before: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("before:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("before:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     // ...
     *
     *     // 2. Continue with on: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("on:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("on:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     // ...
     *
     *     // 3. At last trigger after: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("after:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("after:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     console.log("myevent was fully executed", myTriggerData);
     *     return myTriggerData;
     * }
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#triggerEvent
     * @param {string} name - The name of the event.
     * @param {(Array/Object/JSON)} [data] - Data may be an array or plain object with data or a JSON encoded string.
     * @param {any} ...additionalData - Any raw extra data
     * @returns {data} The data passed to the event trigger including any modifications by event handlers. Returns false if the event is cancelled.
     */
    triggerEvent(g, x, ...k) {
      const S = /^(before|on|after):/.test(g), P = S ? g.split(":")[0] : "";
      g = g.replace(/^(before|on|after):/, "");
      const E = "before:" + g, z = g, U = "after:" + g;
      if (x && typeof x == "string")
        try {
          x = JSON.parse(x);
        } catch {
          console.warn("Could not parse event data", g, x);
        }
      let O;
      if (S) {
        if (P === "before" || P === "after") {
          if (b(this, i) && (O = b(this, i).triggerEvent(
            P === "before" ? E : U,
            x,
            ...k
          ), x = O || O === !1 ? O : x, x === !1) || (O = tt(this, n, vr).call(this, P === "before" ? E : U, x, ...k), x = O || O === !1 ? O : x, x === !1))
            return x;
        } else if (P === "on" && (O = tt(this, n, vr).call(this, z, x, ...k), x = O || O === !1 ? O : x, x === !1 || b(this, i) && (O = b(this, i).triggerEvent("on:" + z, x, ...k), x = O || O === !1 ? O : x, x === !1)))
          return x;
      } else {
        if (b(this, i) && (O = b(this, i).triggerEvent(E, x, ...k), x = O || O === !1 ? O : x, x === !1) || (O = tt(this, n, vr).call(this, E, x, ...k), x = O || O === !1 ? O : x, x === !1) || (O = tt(this, n, vr).call(this, z, x, ...k), x = O || O === !1 ? O : x, x === !1) || b(this, i) && (O = b(this, i).triggerEvent("on:" + z, x, ...k), x = O || O === !1 ? O : x, x === !1) || b(this, i) && (O = b(this, i).triggerEvent(U, x, ...k), x = O || O === !1 ? O : x, x === !1))
          return x;
        O = tt(this, n, vr).call(this, U, x, ...k), x = O || O === !1 ? O : x;
      }
      return x;
    }
  }, t = new WeakMap(), i = new WeakMap(), s = new WeakMap(), n = new WeakSet(), /**
   * Saves a single event handler.
   *
   * @internal
   * @function
   * @param {string} event - One or more events. Multiple events are currently not registered individually.
   * @param {string|Object} [selector] - Optional refinement selector
   * @param {function} handler - The handler function. may be wrapped for once-handlers
   * @param {function} originalHandler - The original non-wrapped event handler.
   */
  $h = /* @__PURE__ */ c(function(g, x, k, S) {
    b(this, t).push({
      events: g,
      selector: x,
      handler: k,
      originalHandler: S
    });
  }, "#registerEventHandler"), /**
   * Returns the event handler or wrapped event handler. The arguments must match the registered event handler.
   *
   * @internal
   * @function
   * @param {string} events - The events registered
   * @param {string|Object} [selector] - The optional selector for the handler.
   * @param {function} handler - The registered handler
   * @param {function} [originalHandler] - The original registered handler
   */
  rf = /* @__PURE__ */ c(function(g, x, k, S) {
    const P = {
      events: g,
      selector: x,
      handler: k,
      originalHandler: S || k
    }, E = b(this, t).filter((z) => ko(P, z, !0)).pop();
    return E && E.handler;
  }, "#getEventHandler"), /**
   * Unregister an event handler. Arguments must match the registered event handler.
   *
   * @internal
   * @function
   * @param {string} event - The events registered
   * @param {function} handler - The registered handler
   * @param {string|Object} [selector] - The optional selector for the handler.
   * @returns {boolean} - True if any handler was removed
   */
  kh = /* @__PURE__ */ c(function(g, x, k, S) {
    const P = {
      events: g,
      selector: x,
      handler: k,
      originalHandler: S
    };
    let E = !1;
    return b(this, t).forEach((z, U) => {
      ko(P, z, !0) && (E = !0, b(this, t).splice(U, 1));
    }), E;
  }, "#unregisterEventHandler"), /**
   * Triggers any local event handlers registered. Each handler may modify the data and return it or return false to cancel the event chain. .stopPropagation() and .preventDefault() may also be used.
   *
   * @example
   * weavyEvents.on("myevent", function(e, data) { ... })
   *
   * triggerHandler(this, "myevent", { key: 1 })
   *
   * @internal
   * @function
   * @param {any} eventName - The name of the event. Event names without prefix will also trigger handlers with the "on:" prefix.
   * @param {any} data - Any data to pass to the handler
   * @param {any} ...additionalData - Any extra data
   */
  vr = /* @__PURE__ */ c(function(g, x, ...k) {
    let S = !1;
    return b(this, t).forEach((P) => {
      P.events.split(" ").forEach((E) => {
        if (E = E.indexOf("on:") === 0 ? E.split("on:")[1] : E, g === E && (!P.selector || ko(P.selector, x, !0))) {
          const z = P.handler(x, ...k);
          z ? x = z : z === !1 && (S = !0);
        }
      });
    }), S ? !1 : x;
  }, "#triggerHandler"), /**
   * Extracts and normalizes all parts of the events arguments.
   *
   * @internal
   * @function
   * @param {Array.<Object>} eventArguments - The function argument list: `[context], events, [selector], handler`
   * @returns {Object}
   * @property {string} events - Event names with added namespace for local events.
   * @property {string|Object} selector - The optional selector.
   * @property {function} handler - The handler function
   * @
   */
  Ch = /* @__PURE__ */ c(function(g) {
    const x = typeof g[1] == "function" ? g[1] : g[2], k = typeof g[1] == "function" ? null : g[1];
    return { events: g[0], selector: k, handler: x };
  }, "#getEventArguments"), c(y, "WeavyEvents"), y;
}, "MixinWeavyEvents"), C5 = k5(class {
});
function qu(r) {
  var i;
  let t = "";
  try {
    t = ((i = /^((?:https?:\/\/[^/]+)|(?:file:\/\/))\/?/.exec(r)) == null ? void 0 : i[1]) || "";
  } catch {
    console.error(
      "Unable to resolve location origin. Make sure you are using http, https or file protocol and have a valid location URL."
    );
  }
  return t;
}
c(qu, "extractOrigin");
const Up = class Up extends C5 {
  constructor(t = {}) {
    super(), this.contentWindows = /* @__PURE__ */ new Set(), this.contentWindowsMapByWeavyId = /* @__PURE__ */ new Map(), this.contentWindowOrigins = /* @__PURE__ */ new WeakMap(), this.contentWindowNames = /* @__PURE__ */ new WeakMap(), this.contentWindowWeavyIds = /* @__PURE__ */ new WeakMap(), this.contentWindowDomain = /* @__PURE__ */ new WeakMap(), this.origin = Ph() ? qu(window.location.href) : "", this.timeout = 2e3, t != null && t.timeout && (this.timeout = t.timeout), window.addEventListener("message", (i) => {
      var s, n;
      if (i.data.name && i.data.weavyId !== void 0) {
        if (i.data.weavyMessageId && i.data.name !== "message-receipt" && i.data.name !== "unready")
          try {
            (s = i.source) == null || s.postMessage(
              { name: "message-receipt", weavyId: i.data.weavyId, weavyMessageId: i.data.weavyMessageId },
              { targetOrigin: i.origin }
            );
          } catch {
            console.error("could not post back message-receipt to source");
          }
        switch (i.data.name) {
          case "register-child": {
            if ((!i.source || !this.contentWindowWeavyIds.has(i.source)) && console.warn("register-child: contentWindow not pre-registered", i.source), i.source && this.contentWindowOrigins.get(i.source) !== i.origin) {
              console.error(
                "register-child: " + this.contentWindowNames.get(i.source) + " has invalid origin",
                i.origin
              );
              return;
            }
            try {
              const a = i.source ? this.contentWindowWeavyIds.get(i.source) : void 0, o = i.source ? this.contentWindowNames.get(i.source) : void 0;
              o && i.source && i.source.postMessage(
                {
                  name: "register-window",
                  windowName: o,
                  weavyId: a || !0
                },
                { targetOrigin: i.origin }
              );
            } catch (a) {
              console.error("could not register frame window", a);
            }
            break;
          }
          case "ready": {
            i.source && this.contentWindowsMapByWeavyId.has(i.data.weavyId) && this.contentWindowNames.has(i.source) && ((n = this.contentWindowsMapByWeavyId.get(i.data.weavyId)) != null && n.get(this.contentWindowNames.get(i.source))) && (this.contentWindowDomain.set(i.source, i.origin), this.distributeMessage(i));
            break;
          }
          case "unready": {
            this.contentWindowsMapByWeavyId.has(i.data.weavyId) && this.distributeMessage(i, !0);
            break;
          }
          default: {
            (i.source === window || this.contentWindowsMapByWeavyId.size) && this.distributeMessage(i);
            break;
          }
        }
      }
    });
  }
  /**
   * The weavy console logging.
   */
  get console() {
    return console;
  }
  distributeMessage(t, i = !1) {
    const s = t.source === window && t.origin === this.origin;
    if (i || (i = t.source && this.contentWindowOrigins.has(t.source) && t.origin === this.contentWindowOrigins.get(t.source) || !1), s || i) {
      i && !t.data.windowName && t.source && (t.data.windowName = this.contentWindowNames.get(t.source));
      const n = t.data.name;
      this.triggerEvent(n, t.data, t), this.triggerEvent("message", t.data, t);
    }
  }
  /**
   * Sends the id of a frame to the frame content scripts, so that the frame gets aware of which id it has.
   * The frame needs to have a unique name attribute.
   *
   * @category panels
   * @param {string} weavyId - The id of the group or entity which the contentWindow belongs to.
   * @param {Window} contentWindow - The frame window to send the data to.
   */
  registerContentWindow(t, i, s, n) {
    var a;
    try {
      if (!i) {
        console.error("registerContentWindow() No valid contentWindow to register, must be a window and have a name.");
        return;
      }
    } catch {
      console.error("registerContentWindow() cannot access contentWindowName");
    }
    t.self && (t = t.self), this.console.log("registerContentWindow", t), (!s || s === "true") && (s = !0), this.contentWindowsMapByWeavyId.has(s) || this.contentWindowsMapByWeavyId.set(s, /* @__PURE__ */ new Map()), (a = this.contentWindowsMapByWeavyId.get(s)) == null || a.set(i, t), this.contentWindows.add(t), this.contentWindowNames.set(t, i), this.contentWindowWeavyIds.set(t, s), this.contentWindowOrigins.set(t, n);
  }
  unregisterAll(t) {
    var i;
    this.contentWindowsMapByWeavyId.has(t) && ((i = this.contentWindowsMapByWeavyId.get(t)) == null || i.forEach((s, n) => {
      this.unregisterContentWindow(n, t);
    }), this.contentWindowsMapByWeavyId.get(t), this.contentWindowsMapByWeavyId.delete(t));
  }
  unregisterContentWindow(t, i) {
    var s, n, a, o;
    if (this.contentWindowsMapByWeavyId.has(i)) {
      if ((s = this.contentWindowsMapByWeavyId.get(i)) != null && s.has(t)) {
        const l = (n = this.contentWindowsMapByWeavyId.get(i)) == null ? void 0 : n.get(t);
        if (l)
          try {
            this.contentWindows.delete(l), this.contentWindowNames.delete(l), this.contentWindowWeavyIds.delete(l), this.contentWindowOrigins.delete(l);
          } catch {
          }
      }
      if ((a = this.contentWindowsMapByWeavyId.get(i)) == null || a.delete(t), ((o = this.contentWindowsMapByWeavyId.get(i)) == null ? void 0 : o.size) === 0)
        try {
          this.contentWindowsMapByWeavyId.delete(i);
        } catch {
        }
    }
  }
  async whenPostMessage(t, i, s) {
    Se(), s === null && (s = void 0);
    const n = t === window.self, a = n ? qu(window.location.href) : this.contentWindowOrigins.get(t);
    if (n || t && a === this.contentWindowDomain.get(t)) {
      i.weavyMessageId || (i.weavyMessageId = So() + So());
      let l;
      await Promise.race([
        new Promise((d, u) => {
          l = window.setTimeout(() => {
            u(new Error("postMessage() receipt timed out: " + i.weavyMessageId + ", " + i.name));
          }, this.timeout || 2e3);
        }),
        new Promise((d) => {
          this.on("message-receipt", { weavyId: i.weavyId, weavyMessageId: i.weavyMessageId }, () => {
            clearTimeout(l), d(void 0);
          }), t.postMessage(i, { targetOrigin: a, transfer: s });
        })
      ]);
    } else
      throw new Error("postMessage() Invalid window origin: " + a + ", " + i.name);
  }
  postToChildren(t, i) {
    if (typeof t != "object" || !t.name) {
      console.error("postToChildren() Invalid message format", t);
      return;
    }
    i === null && (i = void 0), t.distributeName = t.name, t.name = "distribute", t.weavyId = t.weavyId || !0, this.contentWindows.forEach((s) => {
      const n = this.contentWindowOrigins.get(s);
      if (n === this.contentWindowDomain.get(s))
        try {
          s.postMessage(t, { targetOrigin: n, transfer: i });
        } catch {
          console.warn(
            "postToChildren() could not distribute message to " + this.contentWindowNames.get(s)
          );
        }
    });
  }
  async postToFrame(t, i, s, n) {
    var o;
    if (typeof s != "object" || !s.name) {
      console.error("postToFrame() Invalid message format", s);
      return;
    }
    const a = (o = this.contentWindowsMapByWeavyId.get(i)) == null ? void 0 : o.get(t);
    if (!a)
      throw new Error(`postToFrame() Window not registered: ${i}, ${t}`);
    return s.weavyId = i, await this.whenPostMessage(a, s, n);
  }
  async postToSelf(t, i) {
    if (typeof t != "object" || !t.name) {
      console.error("postToSelf() Invalid message format", t);
      return;
    }
    return t.weavyId = t.weavyId || !0, await this.whenPostMessage(window.self, t, i);
  }
  postToSource(t, i, s) {
    if (t.source && t.data.weavyId !== void 0) {
      const n = t.source === window.self && t.origin === this.origin, a = this.contentWindowOrigins.has(t.source) && t.origin === this.contentWindowOrigins.get(t.source);
      if (s === null && (s = void 0), n || a) {
        i.weavyId = t.data.weavyId;
        try {
          t.source.postMessage(i, { targetOrigin: t.origin, transfer: s });
        } catch (o) {
          console.error("postToSource() Could not post message back to source", o);
        }
      }
    }
  }
};
c(Up, "WeavyPostalParent");
let _h = Up;
var _5 = Object.defineProperty, P5 = Object.getOwnPropertyDescriptor, Ol = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? P5(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && _5(t, i, n), n;
}, "__decorateClass$n"), va;
let Xs = (va = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.iframeVisible = !1, this.showOverlay = !1, this.isRegistered = !1, this.iframeElementRef = rt(), this.overlayRef = rt();
  }
  open() {
    this.showOverlay = !0;
  }
  close() {
    this.showOverlay = !1, this.iframeVisible = !1;
  }
  get origin() {
    let t = "";
    try {
      window.location.ancestorOrigins && 0 < window.location.ancestorOrigins.length ? t = window.location.ancestorOrigins[window.location.ancestorOrigins.length - 1] : window.top && (t = window.top.document.location.origin);
    } catch {
    }
    if (!t)
      try {
        t = window.self.document.location.origin;
      } catch {
        console.error("Filebrowser: Could not read current origin.");
      }
    return t;
  }
  dispatchExternalBlobs(t) {
    const i = new CustomEvent("external-blobs", { detail: { externalBlobs: t } });
    return this.dispatchEvent(i);
  }
  connectedCallback() {
    super.connectedCallback(), this.handleFiles = (t, i) => {
      var s, n;
      i.source === ((n = (s = this.iframeElementRef.value) == null ? void 0 : s.contentWindow) == null ? void 0 : n.self) && (this.dispatchExternalBlobs(t.blobs), this.close());
    }, this.handleClose = (t, i) => {
      var s, n;
      i.source === ((n = (s = this.iframeElementRef.value) == null ? void 0 : s.contentWindow) == null ? void 0 : n.self) && this.close();
    }, this.handleGoogleSelected = (t, i) => {
      var s, n;
      i.source === ((n = (s = this.iframeElementRef.value) == null ? void 0 : s.contentWindow) == null ? void 0 : n.self) && this.overlayRef.value && (this.overlayRef.value.maximized = !0);
    }, this.weavyPostal || (this.weavyPostal = new _h()), this.weavyPostal.on("add-external-blobs", this.handleFiles), this.weavyPostal.on("request:file-browser-close", this.handleClose), this.weavyPostal.on("google-selected", this.handleGoogleSelected);
  }
  disconnectedCallback() {
    var t, i, s;
    super.disconnectedCallback(), (t = this.weavyPostal) == null || t.off("add-external-blobs", this.handleFiles), (i = this.weavyPostal) == null || i.off("request:file-browser-close", this.handleClose), (s = this.weavyPostal) == null || s.off("google-selected", this.handleGoogleSelected);
  }
  updated() {
    var t, i;
    this.weavy && (this.showOverlay && !this.src && (this.src = new URL(
      "?origin=" + this.origin + "&v=X&t=" + Date.now().toString() + "&weavyId=wy-filebrowser",
      this.weavy.cloudFilePickerUrl
    )), this.weavyPostal && !this.isRegistered && this.showOverlay && this.src ? (t = this.iframeElementRef.value) != null && t.contentWindow && (this.weavyPostal.registerContentWindow(
      (i = this.iframeElementRef.value) == null ? void 0 : i.contentWindow.self,
      "weavy-filebrowser",
      "wy-filebrowser",
      this.src.origin
    ), this.isRegistered = !0) : this.weavyPostal && this.isRegistered && !this.showOverlay && this.src && (this.weavyPostal.unregisterContentWindow("weavy-filebrowser", "wy-filebrowser"), this.isRegistered = !1, this.src = void 0));
  }
  render() {
    var t;
    return this.weavy ? p`
      <wy-overlay
        .show=${this.showOverlay}
        ${X(this.overlayRef)}
        @close=${() => this.close()}
        @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
      >
        ${this.showOverlay ? p`
              <wy-spinner overlay ?hidden=${this.iframeVisible}></wy-spinner>
              <iframe
                ${X(this.iframeElementRef)}
                @load=${() => this.iframeVisible = !0}
                src=${lt((t = this.src) == null ? void 0 : t.toString())}
                style="flex: 1 1 100%; border: 0;"
                id="weavy-filebrowser"
                name="weavy-filebrowser"
                title=${$("Cloud File Browser")}
              ></iframe>
            ` : C}
      </wy-overlay>
    ` : C;
  }
}, c(va, "WyCloudFiles"), va);
Xs.styles = J;
Ol([
  D()
], Xs.prototype, "src", 2);
Ol([
  D()
], Xs.prototype, "iframeVisible", 2);
Ol([
  D()
], Xs.prototype, "showOverlay", 2);
Xs = Ol([
  B("wy-cloud-files"),
  st()
], Xs);
var M5 = Object.defineProperty, z5 = Object.getOwnPropertyDescriptor, vc = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? z5(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && M5(t, i, n), n;
}, "__decorateClass$m"), ga;
let us = (ga = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.order = { by: "name", descending: !1 }, this.view = "list", this.showTrashed = !1, this.showUploadSheet = !1, this.mutatingFiles = new il(
      this
    ), this.fileInputRef = rt(), this.cloudFilesRef = rt(), this.openFileInput = () => {
      var t;
      (t = this.fileInputRef.value) == null || t.click();
    }, this.openCloudFiles = () => {
      var t;
      (t = this.cloudFilesRef.value) == null || t.open();
    };
  }
  // remove file attachment
  async handleRemoveMutation(t) {
    var a;
    const i = await this.whenWeavy(), s = await this.whenApp(), n = t.status === "error" && !((a = t.variables) != null && a.blob) ? ["apps", s.id, "blobs", void 0] : ["apps", s.id, "files"];
    qw(
      i.queryClient,
      n,
      (o) => o.state.submittedAt === t.submittedAt
    );
  }
  handleOverwriteUpload(t) {
    var s;
    const i = (s = t.variables) == null ? void 0 : s.blob;
    i && this.dispatchCreateFiles([i], !0);
  }
  dispatchUploadFiles(t, i) {
    const s = new CustomEvent("upload-files", { detail: { files: t, input: i } });
    return this.dispatchEvent(s);
  }
  dispatchExternalBlobs(t) {
    const i = new CustomEvent("external-blobs", { detail: { externalBlobs: t } });
    return this.dispatchEvent(i);
  }
  dispatchCreateFiles(t, i = !1) {
    const s = new CustomEvent("create-files", { detail: { blobs: t, replace: i } });
    return this.dispatchEvent(s);
  }
  dispatchOrder(t) {
    const i = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(i);
  }
  dispatchView(t) {
    const i = new CustomEvent("view", { detail: { view: t } });
    return this.dispatchEvent(i);
  }
  dispatchShowTrashed(t) {
    const i = new CustomEvent("show-trashed", { detail: { showTrashed: t } });
    return this.dispatchEvent(i);
  }
  dispatchSubscribe(t) {
    const i = new CustomEvent("subscribe", { detail: { subscribe: t } });
    return this.dispatchEvent(i);
  }
  willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && this.mutatingFiles.trackMutationState(
      { filters: { mutationKey: ["apps", this.app.id], exact: !1 } },
      this.weavy.queryClient
    );
  }
  renderFileMutation(t) {
    var i, s, n;
    if ((i = t.context) != null && i.file) {
      const a = t.context.file, o = {
        ...t.context.status
      };
      return t.context.status.state === "conflict" && (o.text = $("Replace existing file?")), p`
        <wy-file-item
          .file=${(s = t.context) == null ? void 0 : s.file}
          .status=${o}
          .actionType=${t.context.type}
          title="${hy(t.context.type)}: ${a.name}"
        >
          <span slot="title">${a.name}</span>
          ${o.text ? p`: <span slot="actions" title=${o.text}><em>${o.text}</em></span>` : C}
          ${o.state === "conflict" && ((n = t.variables) != null && n.blob) ? p`
                <wy-button
                  slot="actions"
                  kind="icon"
                  @click=${() => this.handleOverwriteUpload(
        t
      )}
                  title=${$("Replace")}
                >
                  <wy-icon name="check"></wy-icon>
                </wy-button>
              ` : C}
          <wy-button
            slot="actions"
            kind="icon"
            @click=${() => this.handleRemoveMutation(t)}
            title=${$("Discard", { desc: "Button action to discard" })}
          >
            <wy-icon name="close"></wy-icon>
          </wy-button>
        </wy-file-item>
      `;
    }
    return C;
  }
  render() {
    var o, l, d, u;
    const t = this.mutatingFiles.result, i = Yb(t), s = t != null && t.length ? t.filter((y) => {
      var m;
      return ((m = y.context) == null ? void 0 : m.file) && !i.includes(y);
    }) : [], n = Kb(t), a = Gb(t);
    return p`
      <nav class="wy-toolbar">
        <div class="wy-toolbar-buttons">
          ${Us(ns.Create, (o = this.app) == null ? void 0 : o.permissions) ? p`
                <wy-dropdown title=${$("Add files")}>
                  <span slot="button">${$("Add files")}</span>
                  <wy-icon slot="button" name="plus" last></wy-icon>
                  <wy-dropdown-item @click=${this.openFileInput} title=${$("From device")}>
                    <wy-icon name="attachment"></wy-icon>
                    <span>${$("From device")}</span>
                  </wy-dropdown-item>
                  <input
                    type="file"
                    data-testid="uploadFile"
                    ${X(this.fileInputRef)}
                    @click=${(y) => y.stopPropagation()}
                    @change=${(y) => this.dispatchUploadFiles(y.target.files, y.target)}
                    multiple
                    hidden
                    tabindex="-1"
                  />
                  ${(l = this.hasFeatures) != null && l.cloudFiles ? p`
                        <wy-dropdown-item @click=${this.openCloudFiles} title=${$("From cloud")}>
                          <wy-icon name="cloud"></wy-icon>
                          <span>${$("From cloud")}</span>
                        </wy-dropdown-item>
                      ` : C}
                </wy-dropdown>
              ` : C}
        </div>
        <div class="wy-toolbar-buttons wy-toolbar-buttons-last">
          ${t != null && t.length ? p`
                <wy-button
                  kind="icon"
                  @click=${() => {
      this.showUploadSheet = !this.showUploadSheet;
    }}
                  title=${a === "conflict" ? $("File conflict") : a === "error" ? $("Upload error") : a === "pending" ? $("Pending") : $("All uploads finished")}
                >
                  ${a === "conflict" ? p`<wy-icon name="alert" color="yellow" title=${$("File conflict")}></wy-icon>` : a === "error" ? p`<wy-icon name="alert-octagon" color="error" title=${$("Upload error")}></wy-icon>` : a === "pending" ? p`<wy-spinner
                        ?nospin=${n !== void 0 && n.percent !== null}
                        progress=${lt(n.percent !== null ? n.percent : void 0)}
                        title=${$("Pending")}
                      ></wy-spinner>` : p`<wy-icon name="check" title=${$("All uploads finished")}></wy-icon>`}
                </wy-button>
              ` : C}
          ${this.app ? p` <wy-notification-button-list></wy-notification-button-list> ` : C}

          <wy-dropdown icon="sort" title="Sort items by" directionX="left">
            <wy-dropdown-option
              ?selected=${this.order.by === "name"}
              @click=${() => this.dispatchOrder({ ...this.order, by: "name" })}
            >
              ${$("Name")}
            </wy-dropdown-option>
            <wy-dropdown-option
              ?selected=${this.order.by === "updated_at"}
              @click=${() => this.dispatchOrder({ ...this.order, by: "updated_at" })}
            >
              ${$("Modified")}
            </wy-dropdown-option>
            <wy-dropdown-option
              ?selected=${this.order.by === "size"}
              @click=${() => this.dispatchOrder({ ...this.order, by: "size" })}
            >
              ${$("Size")}
            </wy-dropdown-option>
            <wy-dropdown-divider></wy-dropdown-divider>
            <wy-dropdown-option
              ?selected=${!this.order.descending}
              @click=${() => this.dispatchOrder({ ...this.order, descending: !1 })}
            >
              ${$("Ascending")}
            </wy-dropdown-option>
            <wy-dropdown-option
              ?selected=${this.order.descending}
              @click=${() => this.dispatchOrder({ ...this.order, descending: !0 })}
            >
              ${$("Descending")}
            </wy-dropdown-option>
          </wy-dropdown>

          <wy-dropdown
            icon=${this.view === "grid" ? "view-module-outline" : "view-list-outline"}
            title="View options"
            directionX="left"
          >
            <wy-dropdown-option ?selected=${this.view === "list"} @click=${() => this.dispatchView("list")}>
              ${$("List view")}
            </wy-dropdown-option>
            <wy-dropdown-option ?selected=${this.view === "grid"} @click=${() => this.dispatchView("grid")}>
              ${$("Grid view")}
            </wy-dropdown-option>
            <wy-dropdown-divider></wy-dropdown-divider>
            <wy-dropdown-option ?selected=${!this.showTrashed} @click=${() => this.dispatchShowTrashed(!1)}>
              ${$("Hide trashed")}
            </wy-dropdown-option>
            <wy-dropdown-option ?selected=${this.showTrashed} @click=${() => this.dispatchShowTrashed(!0)}>
              ${$("Show trashed")}
            </wy-dropdown-option>
          </wy-dropdown>

          <wy-dropdown directionX="left" ?disabled=${!this.app}>
            ${(d = this.app) != null && d.is_subscribed ? p`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                  <wy-icon name="bell-off"></wy-icon>
                  ${$("Unsubscribe")}
                </wy-dropdown-item>` : p`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                  <wy-icon name="bell"></wy-icon>
                  ${$("Subscribe")}
                </wy-dropdown-item>`}
            ${(u = this.app) != null && u.archive_url ? p`<wy-dropdown-item
                  @click=${() => {
      var y, m;
      return Mo((y = this.app) == null ? void 0 : y.archive_url, "_top", `${(m = this.app) == null ? void 0 : m.uid}.zip`, !0);
    }}
                >
                  <wy-icon name="download"></wy-icon>
                  ${$("Download files")}
                </wy-dropdown-item>` : C}
          </wy-dropdown>
        </div>
      </nav>

      ${this.weavy ? p`
            <wy-sheet
              .show=${this.showUploadSheet}
              @close=${() => this.showUploadSheet = !1}
              @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
            >
              <wy-button
                kind="icon"
                slot="appbar-buttons"
                @click=${() => {
      t == null || t.forEach((y) => this.handleRemoveMutation(y));
    }}
                title=${$("Remove all", { desc: "Button action to remove all" })}
              >
                <wy-icon name="trashcan"></wy-icon>
              </wy-button>
              <span slot="appbar-text">${$("File actions")}</span>
              ${i.length ? p`
                    ${Re(
      i,
      (y) => "mutation" + y.submittedAt,
      (y) => this.renderFileMutation(y)
    )}
                    ${s.length ? p`<hr />` : C}
                  ` : C}
              ${s.length ? p`
                    ${Re(
      s,
      (y) => "mutation" + y.submittedAt,
      (y) => this.renderFileMutation(y)
    )}
                  ` : C}
            </wy-sheet>
          ` : C}

      <wy-cloud-files
        ${X(this.cloudFilesRef)}
        @external-blobs=${(y) => this.dispatchExternalBlobs(y.detail.externalBlobs)}
      ></wy-cloud-files>
    `;
  }
}, c(ga, "WyFilesAppbar"), ga);
us.styles = [J];
vc([
  w({ type: Object })
], us.prototype, "order", 2);
vc([
  w()
], us.prototype, "view", 2);
vc([
  w({ type: Boolean })
], us.prototype, "showTrashed", 2);
vc([
  D()
], us.prototype, "showUploadSheet", 2);
us = vc([
  B("wy-files-appbar"),
  st()
], us);
const S5 = Z`[part~=wy-grid]{display:grid;grid-auto-flow:dense;grid-template-columns:repeat(auto-fill,minmax(calc(10 * var(--wy-size, 1rem)),1fr));grid-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}`, E5 = Z`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-primary-95, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-primary-10, #001d32))}}[part~=wy-card]{--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-component-border-radius);position:relative;display:flex;flex-direction:column;min-width:0;word-wrap:break-word;background-clip:border-box}[part~=wy-card][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-card-primary]{--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-90, #cde5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-primary-10, #001d32))}[part~=wy-card-hover]{cursor:pointer;-webkit-user-select:none;user-select:none}[part~=wy-card-hover]:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-card-hover]:hover:before{opacity:var(--wy-opacity-state-hover, 8%)}[part~=wy-card-hover]:focus:before{opacity:var(--wy-opacity-state-focus, 12%)}[part~=wy-card-hover]:active:before,[part~=wy-card-hover][part~=wy-active]:before{opacity:var(--wy-opacity-state-active, 12%)}[part~=wy-card-actions]{position:absolute;top:calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + .5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));right:calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + .5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));align-items:center;display:flex}[part~=wy-card-content]{flex:1 0 auto;padding-block-end:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));padding-inline-start:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));padding-inline-end:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-card-content][part~=wy-card-top]{padding-block-start:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-card-top]{border-radius:var(--wy-component-border-radius);object-fit:cover;object-position:top center;flex:1 1 100%;max-height:calc(10 * var(--wy-size, 1rem))}[part~=wy-card-icon]{--wy-component-icon-width: calc(6 * var(--wy-size, 1rem));--wy-component-icon-height: calc(6 * var(--wy-size, 1rem));display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem));margin:auto}[part~=wy-card-image]{width:auto;height:auto}[part~=wy-card-image][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-card-image][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-card-top-image]{object-position:50% 38%}[part~=wy-trashed]{opacity:var(--wy-opacity-disabled, 38%);text-decoration:line-through}`;
function O5(r, t, i, s, n) {
  return r && r.length ? p`
        <table class="wy-table wy-table-hover wy-table-files">
          <thead>${A5.call(this, t)}</thead>
          <tbody>
            ${Re(
    r,
    (a) => a.id,
    (a) => L5.call(this, this.weavy, { file: a }, i, s, n)
  )}
          </tbody>
        </table>
        <slot name="end"></slot>
      ` : C;
}
c(O5, "renderFileTable");
function A5(r) {
  const t = [
    { by: void 0, title: "" },
    // File icon
    { by: "name", title: $("Name") },
    { by: void 0, title: "" },
    // Comments icon
    { by: "updated_at", title: $("Modified") },
    { by: void 0, title: $("Kind") },
    { by: "size", title: $("Size") },
    { by: void 0, title: "" }
    // Menu
  ];
  return p`
    <tr>
      ${t.map((i) => {
    if (i.title) {
      const s = i.by === (r == null ? void 0 : r.by), n = /* @__PURE__ */ c((a) => {
        a.preventDefault(), i.by && this.dispatchOrder({ by: i.by, descending: s && !(r != null && r.descending) });
      }, "onHeaderClick");
      return p` <th>
            ${i.by ? p`<div
                  class="wy-table-sort-link"
                  tabindex="0"
                  @click=${n}
                  @keydown=${xe}
                  @keyup=${je}
                  >${i.title}
                  ${s && p`<wy-icon name=${r != null && r.descending ? "menu-down" : "menu-up"}></wy-icon>` || C}</div
                >` : i.title}
          </th>`;
    } else
      return p`<th class="wy-table-cell-icon"></th>`;
  })}
    </tr>
  `;
}
c(A5, "renderFileTableHeaders");
function L5(r, { file: t }, i, s, n) {
  var S;
  const a = t.size && t.size > 0 ? bl(t.size) : C, o = t.updated_at || t.created_at, l = new Intl.DateTimeFormat(r == null ? void 0 : r.locale, { dateStyle: "full", timeStyle: "short" }).format(
    new Date(o)
  ), d = new Intl.DateTimeFormat(r == null ? void 0 : r.locale, { dateStyle: "short" }).format(new Date(o)), u = !!(i && i === t.id), { icon: y } = vs(t.name), m = ai(t.name), f = yo(t.provider), g = /* @__PURE__ */ c((P) => {
    P.stopImmediatePropagation();
    const E = P.target;
    E.value && E.value !== t.name ? this.dispatchRename(t, E.value) : this.dispatchEditName({ id: NaN });
  }, "handleRename"), x = /* @__PURE__ */ c((P) => {
    const E = P.target;
    P.key === "Escape" ? (P.preventDefault(), E.value = t.name, E.blur()) : P.key === "Enter" && (P.preventDefault(), E.blur());
  }, "handleRenameKey"), k = !!(s && s === t.id);
  return p`
    <tr
      class=${Rt({ "wy-table-row-trashed": t.is_trashed })}
      part=${Yt({ "wy-highlight": k })}
      @click=${(P) => {
    !P.defaultPrevented && !t.is_trashed && this.dispatchFileOpen(t.id);
  }}
      ${k && n ? X(n) : C}
    >
      <td class="wy-table-cell-icon"
        ><wy-icon name=${y} .overlayName=${f} size="24" kind=${t.kind} ext=${m}></wy-icon
      ></td>
      <td class="wy-table-cell-text">
        ${u ? p`
              <input
                type="text"
                maxlength="256"
                class="wy-input"
                .defaultValue=${t.name}
                @blur=${g}
                @keyup=${(P) => {
    Ti(P), x(P);
  }}
                @click=${(P) => P.preventDefault()}
                @focus=${Yh}
                ${X(Mh)}
              />
            ` : p`${t.name}`}
      </td>
      <td class="wy-table-cell-icon"
        >${(S = t.comments) != null && S.count ? p`<wy-button
              kind="icon"
              @click=${(P) => {
    !P.defaultPrevented && !t.is_trashed && (P.target.blur(), this.dispatchFileOpen(t.id, "comments"), P.stopPropagation());
  }}
              title=${$(pt`${t.comments.count} comments`)}
            >
              <span class="wy-badge">${t.comments.count}</span>
            </wy-button>` : C}</td
      >
      <td><time datetime="${o}" title=${l}>${d}</time></td>
      <td>${t.kind}</td>
      <td>${a}</td>
      <td class="wy-table-cell-icon">
        <wy-file-menu
          .file=${t}
          @edit-name=${(P) => this.dispatchEditName(P.detail.file)}
          @trash=${(P) => this.dispatchTrash(P.detail.file)}
          @restore=${(P) => this.dispatchRestore(P.detail.file)}
          @delete-forever=${(P) => this.dispatchDeleteForever(P.detail.file)}
          @subscribe=${(P) => this.dispatchSubscribe(P.detail.file, P.detail.subscribe)}
        >
        </wy-file-menu>
      </td>
    </tr>
  `;
}
c(L5, "renderFileTableRow");
function R5(r, t, i, s) {
  var k, S;
  const n = r.size && r.size > 0 ? bl(r.size) : C, a = r.updated_at || r.created_at, o = new Intl.DateTimeFormat((k = this.weavy) == null ? void 0 : k.locale, { dateStyle: "full", timeStyle: "short" }).format(
    new Date(a)
  ), l = !!(t && t === r.id), { icon: d } = vs(r.name), u = ai(r.name), y = yo(r.provider), m = /* @__PURE__ */ c((P) => {
    P.stopImmediatePropagation();
    const E = P.target;
    E.value && E.value !== r.name ? this.dispatchRename(r, E.value) : this.dispatchEditName({ id: NaN });
  }, "handleRename"), f = /* @__PURE__ */ c((P) => {
    const E = P.target;
    P.key === "Escape" ? (P.preventDefault(), E.value = r.name, E.blur()) : P.key === "Enter" && (P.preventDefault(), E.blur());
  }, "handleRenameKey"), g = {
    "wy-trashed": r.is_trashed
  }, x = !!(i && i === r.id);
  return p`
    <div
      part=${Yt({
    "wy-card": !0,
    "wy-card-trashed": r.is_trashed,
    "wy-card-hover": !r.is_trashed && !l,
    "wy-highlight": x
  })}
      title="${r.name} • ${n} • ${o}"
      tabindex="0"
      @click=${(P) => {
    !P.defaultPrevented && !r.is_trashed && this.dispatchFileOpen(r.id);
  }}
      @keydown=${xe}
      @keyup=${je}
      ${x && s ? X(s) : C}
    >
      <div part="wy-card-actions">
        <wy-file-menu
          small
          .file=${r}
          @edit-name=${(P) => this.dispatchEditName(P.detail.file)}
          @trash=${(P) => this.dispatchTrash(P.detail.file)}
          @restore=${(P) => this.dispatchRestore(P.detail.file)}
          @delete-forever=${(P) => this.dispatchDeleteForever(P.detail.file)}
          @subscribe=${(P) => this.dispatchSubscribe(P.detail.file, P.detail.subscribe)}
        ></wy-file-menu>
      </div>
      ${!r.is_trashed && r.thumbnail_url ? p`
            <img
              part="wy-card-top wy-card-content wy-card-image ${Yt({
    "wy-card-top-image": r.kind === "image",
    ...g
  })}"
              width=${lt(r.width)}
              height=${lt(r.height)}
              src=${r.thumbnail_url}
              alt=${r.name}
              ${X(Qc)}
              @load=${Kc}
              loading="lazy"
              decoding="async"
            />
          ` : p`
            <div part="wy-card-top wy-card-content wy-card-icon ${Yt(g)}">
              <wy-icon name=${d} .overlayName=${y} size="96" kind=${r.kind} ext=${u}></wy-icon>
            </div>
          `}
      <div part="wy-card-content wy-filename ${Yt(g)}">
        ${l ? p`
              <input
                type="text"
                maxlength="256"
                class="wy-input"
                .defaultValue=${r.name}
                @blur=${m}
                @keyup=${(P) => {
    Ti(P), f(P);
  }}
                @click=${(P) => P.preventDefault()}
                @focus=${Yh}
                ${X(Mh)}
              />
            ` : p`<div class="wy-truncated-text-and-icon"
              ><div>${r.name}</div> ${(S = r.comments) != null && S.count ? p`<wy-button
                    small
                    kind="icon"
                    @click=${(P) => {
    !P.defaultPrevented && !r.is_trashed && (P.target.blur(), this.dispatchFileOpen(r.id, "comments"), P.stopPropagation());
  }}
                    title=${$(pt`${r.comments.count} comments`)}
                  >
                    <span class="wy-badge">${r.comments.count}</span>
                  </wy-button>` : C}</div
            >`}
      </div>
    </div>
  `;
}
c(R5, "renderFileCard");
var I5 = Object.defineProperty, T5 = Object.getOwnPropertyDescriptor, bs = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? T5(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && I5(t, i, n), n;
}, "__decorateClass$l"), ba;
let ii = (ba = class extends zt(j) {
  constructor() {
    super(), this.exportParts = new Q(this), this.order = { by: "name", descending: !1 }, this.view = "list", this.isRenamingId = NaN, this.highlightId = NaN, this.highlightComment = !1, this.highlightRef = rt(), this.addEventListener("edit-name", (t) => {
      this.isRenamingId = t.detail.file.id;
    }), this.addEventListener("rename", () => {
      this.isRenamingId = NaN;
    });
  }
  dispatchFileOpen(t, i) {
    const s = new CustomEvent("file-open", { detail: { fileId: t, tab: i } });
    return this.dispatchEvent(s);
  }
  dispatchOrder(t) {
    const i = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(i);
  }
  dispatchEditName(t) {
    const i = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(i);
  }
  dispatchRename(t, i) {
    const s = new CustomEvent("rename", { detail: { file: t, name: i } });
    return this.dispatchEvent(s);
  }
  dispatchTrash(t) {
    const i = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(i);
  }
  dispatchRestore(t) {
    const i = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(i);
  }
  dispatchDeleteForever(t) {
    const i = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(i);
  }
  dispatchSubscribe(t, i) {
    const s = new CustomEvent("subscribe", { detail: { file: t, subscribe: i } });
    return this.dispatchEvent(s);
  }
  willUpdate(t) {
    var i;
    t.has("link") && (this.highlightId = this.link && ((i = rw(this.link, Ne.File)) == null ? void 0 : i.id), this.highlightComment = this.link && this.highlightId ? nw(this.link, Ne.File, { id: this.highlightId }, Ne.Comment) : !1), t.has("highlightComment") && this.highlightComment && this.highlightId && this.dispatchFileOpen(this.highlightId, "comments");
  }
  render() {
    return this.files && this.files.length ? this.view === "grid" ? p`
          <div part="wy-grid">
            ${Re(
      this.files,
      (t) => t.id,
      (t) => R5.call(this, t, this.isRenamingId, this.highlightId, this.highlightRef)
    )}
          </div>
          <slot name="end"></slot>
        ` : O5.call(this, this.files, this.order, this.isRenamingId, this.highlightId, this.highlightRef) : C;
  }
  updated(t) {
    var i;
    t.has("highlightId") && this.highlightId && ((i = this.highlightRef.value) == null || i.scrollIntoView({ block: "nearest" }));
  }
}, c(ba, "WyFilesList"), ba);
ii.styles = [J, pc, S5, E5];
bs([
  w({ attribute: !1 })
], ii.prototype, "files", 2);
bs([
  w({ type: Number })
], ii.prototype, "dataUpdatedAt", 2);
bs([
  w({ attribute: !1 })
], ii.prototype, "order", 2);
bs([
  w()
], ii.prototype, "view", 2);
bs([
  D()
], ii.prototype, "isRenamingId", 2);
bs([
  D()
], ii.prototype, "highlightId", 2);
bs([
  D()
], ii.prototype, "highlightComment", 2);
ii = bs([
  B("wy-files-list"),
  st()
], ii);
var F5 = Object.defineProperty, D5 = Object.getOwnPropertyDescriptor, nf = /* @__PURE__ */ c((r) => {
  throw TypeError(r);
}, "__typeError$8"), Al = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? D5(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && F5(t, i, n), n;
}, "__decorateClass$k"), af = /* @__PURE__ */ c((r, t, i) => t.has(r) || nf("Cannot " + i), "__accessCheck$8"), Nu = /* @__PURE__ */ c((r, t, i) => (af(r, t, "read from private field"), i ? i.call(r) : t.get(r)), "__privateGet$8"), H5 = /* @__PURE__ */ c((r, t, i) => t.has(r) ? nf("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(r) : t.set(r, i), "__privateAdd$8"), ju = /* @__PURE__ */ c((r, t, i, s) => (af(r, t, "write to private field"), t.set(r, i), i), "__privateSet$8"), gr;
const V5 = "wy-files";
var xa;
let Js = (xa = class extends at {
  constructor() {
    super(), this.productType = ho.Files, this.componentType = ze.Files, this.view = "list", this.order = { by: "name", descending: !1 }, this.showTrashed = !1, this.filesQuery = new Ri(this), this.persistState = new Do(this), this.infiniteScroll = new Ii(this), this.pagerRef = rt(), this.previewRef = rt(), this.dropZone = new rl(this), this.appSubscribeMutation = new Ae(this), this.uploadBlobMutation = new Ae(this), this.createFileMutation = new Ae(this), this.handleRealtimeFileCreated = (t) => {
      !this.weavy || !this.app || (t.file.created_by = t.actor, this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) }));
    }, this.handleRealtimeFileUpdated = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileTrashed = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileRestored = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileDeleted = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeCommentCreated = () => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, H5(this, gr), this.addEventListener("drop-files", this.handleBlobUpload), new fi(this, Js.styles);
  }
  // upload files
  handleBlobUpload(t) {
    const i = t.detail;
    if (i.files) {
      for (let s = 0; s < i.files.length; s++) {
        const a = { file: i.files[s] };
        this.uploadBlobMutation.mutate(a).then((o) => this.handleCreateFile(o));
      }
      i.input && (i.input.value = "");
    }
  }
  // upload files
  handleExternalBlobs(t) {
    var i;
    if (t.detail.externalBlobs)
      for (let s = 0; s < t.detail.externalBlobs.length; s++) {
        const n = t.detail.externalBlobs[s];
        (i = this.externalBlobMutation) == null || i.mutate({ externalBlob: n }).then((a) => this.handleCreateFile(a));
      }
  }
  // add uploaded files
  async handleCreateFile(t, i) {
    return await this.createFileMutation.mutate({ blob: t, replace: i });
  }
  handleSubscribe(t) {
    var i;
    (i = this.app) != null && i.id && this.appSubscribeMutation.mutate({ subscribe: t });
  }
  getFilesQueryKey(t) {
    return ["apps", t.id, "files"];
  }
  willUpdate(t) {
    var i;
    if (super.willUpdate(t), (t.has("uid") || t.has("weavy") || t.has("user")) && this.uid && this.weavy && this.user && this.persistState.observe(["view", "order", "showTrashed"], this.uid, `u${this.user.id}`), (t.has("weavy") || t.has("app") || t.has("order") || t.has("showTrashed")) && this.weavy && this.app && this.filesQuery.trackInfiniteQuery(
      p5(this.weavy, this.app.id, {
        order: this.order,
        trashed: this.showTrashed
      })
    ), (t.has("weavy") || t.has("app") || t.has("user")) && this.weavy && this.app && this.user) {
      this.appSubscribeMutation.trackMutation(Sy(this.weavy, this.app)), this.uploadBlobMutation.trackMutation(jw(this.weavy, this.user, this.app)), this.createFileMutation.trackMutation(Xb(this.weavy, this.user, this.app)), this.externalBlobMutation = Ww(this.weavy, this.user, this.app), this.renameFileMutation = y5(this.weavy, this.app), this.subscribeFileMutation = $5(this.weavy, this.app), this.trashFileMutation = f5(this.weavy, this.app), this.restoreFileMutation = v5(this.weavy, this.app), this.deleteForeverFileMutation = b5(this.weavy, this.app), (i = Nu(this, gr)) == null || i.call(this);
      const s = `a${this.app.id}`;
      this.weavy.subscribe(s, "file_created", this.handleRealtimeFileCreated), this.weavy.subscribe(s, "file_updated", this.handleRealtimeFileUpdated), this.weavy.subscribe(s, "file_trashed", this.handleRealtimeFileTrashed), this.weavy.subscribe(s, "file_restored", this.handleRealtimeFileRestored), this.weavy.subscribe(s, "file_deleted", this.handleRealtimeFileDeleted), this.weavy.subscribe(s, "comment_created", this.handleRealtimeCommentCreated), ju(this, gr, () => {
        var n, a, o, l, d, u;
        (n = this.weavy) == null || n.unsubscribe(s, "file_created", this.handleRealtimeFileCreated), (a = this.weavy) == null || a.unsubscribe(s, "file_updated", this.handleRealtimeFileUpdated), (o = this.weavy) == null || o.unsubscribe(s, "file_trashed", this.handleRealtimeFileTrashed), (l = this.weavy) == null || l.unsubscribe(s, "file_restored", this.handleRealtimeFileRestored), (d = this.weavy) == null || d.unsubscribe(s, "file_deleted", this.handleRealtimeFileDeleted), (u = this.weavy) == null || u.unsubscribe(s, "comment_created", this.handleRealtimeCommentCreated), ju(this, gr, void 0);
      });
    }
  }
  updated() {
    this.infiniteScroll.observe(this.filesQuery.result, this.pagerRef.value);
  }
  render() {
    const { data: t, dataUpdatedAt: i, hasNextPage: s, isPending: n } = this.filesQuery.result, a = this.dropZone.isDragActive, o = ms(t);
    return [
      p`
        <wy-files-appbar
          .order=${this.order}
          .showTrashed=${this.showTrashed}
          .view=${this.view}
          @upload-files=${this.handleBlobUpload}
          @external-blobs=${this.handleExternalBlobs}
          @create-files=${(l) => l.detail.blobs.forEach((d) => this.handleCreateFile(d, l.detail.replace))}
          @order=${(l) => {
        this.order = l.detail.order;
      }}
          @show-trashed=${(l) => {
        this.showTrashed = l.detail.showTrashed;
      }}
          @view=${(l) => {
        this.view = l.detail.view;
      }}
          @subscribe=${(l) => this.handleSubscribe(l.detail.subscribe)}
        >
        </wy-files-appbar>
      `,
      this.app ? p`
            <div
              class="wy-files ${Rt({ "wy-dragging": a })}"
              data-drag-title=${$("Drop files here to upload.")}
            >
              ${o.length ? p`
                    <wy-files-list
                      .view=${this.view}
                      .files=${o}
                      .dataUpdatedAt=${i}
                      .order=${this.order}
                      @file-open=${(l) => {
        var d;
        (d = this.previewRef.value) == null || d.open(l.detail.fileId, l.detail.tab);
      }}
                      @order=${(l) => {
        this.order = l.detail.order;
      }}
                      @rename=${(l) => {
        var d;
        (d = this.renameFileMutation) == null || d.mutate({ file: l.detail.file, name: l.detail.name });
      }}
                      @subscribe=${(l) => {
        var d;
        (d = this.subscribeFileMutation) == null || d.mutate({
          file: l.detail.file,
          subscribe: l.detail.subscribe
        });
      }}
                      @trash=${(l) => {
        var d;
        (d = this.trashFileMutation) == null || d.mutate({ file: l.detail.file });
      }}
                      @restore=${(l) => {
        var d;
        (d = this.restoreFileMutation) == null || d.mutate({ file: l.detail.file });
      }}
                      @delete-forever=${(l) => {
        var d;
        (d = this.deleteForeverFileMutation) == null || d.mutate({ file: l.detail.file });
      }}
                    >
                      ${s ? p`<div slot="end" ${X(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
                    </wy-files-list>
                  ` : p`
                    <wy-empty>
                      ${n ? p`<wy-spinner padded reveal></wy-spinner>` : p` <wy-icon-display>
                            <wy-icon name="file-upload"></wy-icon>
                            <span slot="text">${$("Add some files to get started!")}</span>
                          </wy-icon-display>`}
                    </wy-empty>
                  `}
            </div>
            ${t ? p` <wy-preview ${X(this.previewRef)} .infiniteQueryResult=${this.filesQuery.result}></wy-preview> ` : C}
          ` : p`<wy-empty><wy-spinner padded reveal></wy-spinner></wy-empty>`
    ];
  }
  disconnectedCallback() {
    var t;
    (t = Nu(this, gr)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(xa, "WyFiles"), xa);
gr = /* @__PURE__ */ new WeakMap();
Js.styles = [We, J, po, fs, ir];
Al([
  w()
], Js.prototype, "view", 2);
Al([
  w({ type: Object })
], Js.prototype, "order", 2);
Al([
  w({ type: Boolean })
], Js.prototype, "showTrashed", 2);
Js = Al([
  B(V5),
  st()
], Js);
const Wu = /* @__PURE__ */ c((r) => Fm(r) ? r._$litType$.h : r.strings, "Pt"), B5 = Ui(class extends mi {
  constructor(r) {
    super(r), this.et = /* @__PURE__ */ new WeakMap();
  }
  render(r) {
    return [r];
  }
  update(r, [t]) {
    const i = cu(this.it) ? Wu(this.it) : null, s = cu(t) ? Wu(t) : null;
    if (i !== null && (s === null || i !== s)) {
      const n = nh(r).pop();
      let a = this.et.get(i);
      if (a === void 0) {
        const o = document.createDocumentFragment();
        a = Ff(C, o), a.setConnected(!1), this.et.set(i, a);
      }
      qc(a, [n]), _s(a, void 0, n);
    }
    if (s !== null) {
      if (i === null || i !== s) {
        const n = this.et.get(s);
        if (n !== void 0) {
          const a = nh(n).pop();
          Vm(r), _s(r, void 0, a), qc(r, [a]);
        }
      }
      this.it = t;
    } else this.it = void 0;
    return this.render(t);
  }
}), U5 = Z`.wy-messenger-layout{display:flex;flex:1;align-items:stretch;position:relative;container-type:inline-size;align-self:stretch;min-height:0;min-width:0}wy-conversation-list{flex:0 1 50%;min-width:0;max-width:24rem;border-right:1px solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c1c7ce))}.wy-messenger-conversation{display:flex;flex-direction:column;overflow-anchor:none;height:100%;width:100%;flex:0 1 100%;min-width:max(50%,16rem)}.wy-close-conversation{display:none}@container (max-width: 768px){wy-conversation-list{flex:0 1 100%;min-width:0;max-width:none;border-right:none}wy-conversation-list[conversationid]{display:none}.wy-messenger-conversation[data-conversation-id=\"\"]{display:none}.wy-close-conversation{display:contents}wy-empty{display:none}}`;
var q5 = Object.defineProperty, N5 = Object.getOwnPropertyDescriptor, xs = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? N5(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && q5(t, i, n), n;
}, "__decorateClass$j"), $a;
let si = ($a = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.botFilter = void 0, this.selected = [], this.select = [], this.text = "", this.peopleQuery = new Ri(this), this.inputRef = rt(), this.infiniteScroll = new Ii(this), this.pagerRef = rt(), this.throttledSearch = el(
      async () => {
        var t;
        this.text = ((t = this.inputRef.value) == null ? void 0 : t.value) || "";
      },
      250,
      { leading: !1, trailing: !0 }
    );
  }
  dispatchSubmit() {
    this.selected = [...this.selected, ...this.select];
    const t = new CustomEvent("submit", { detail: { members: this.selected } });
    return this.dispatchEvent(t);
  }
  isChecked(t) {
    return this.select.find((i) => i.id === t) != null;
  }
  handleSelected(t, i) {
    i ? this.select = [...this.select, t] : (this.select = this.select.filter((s) => s.id !== t.id), this.selected = this.selected.filter((s) => s.id !== t.id));
  }
  async clear() {
    this.text = "";
  }
  getSelected() {
    return this.selected.length > 0 ? p`
        ${this.selected.map((t) => p`
            <div
              class="wy-item wy-list-item wy-item-hover"
              @click=${() => this.handleSelected(t, !1)}
              @keydown=${xe}
              @keyup=${xe}
            >
              <wy-avatar
                id=${t.id}
                .src=${t.avatar_url}
                .name=${t.display_name}
                .presence=${t.presence}
                .isBot=${t.is_bot}
                size=${32}
              ></wy-avatar>
              <div class="wy-item-body"> ${t.display_name} </div>
              <wy-icon name="checkbox-marked"></wy-icon>
            </div>
          `)}
      ` : C;
  }
  getSearchResult() {
    const { data: t, hasNextPage: i, isPending: s } = this.peopleQuery.result ?? { data: [], isPending: !0 }, n = ms(t), a = !!n.length, o = [];
    return s ? o.push(p`<wy-spinner overlay></wy-spinner>`) : a || o.push(p`<div class="wy-pane-group">
        <div class="wy-table-no-result">
          ${this.text ? $("Your search did not match any people.") : $("No more users found.")}
        </div>
      </div>`), a && o.push(
      p` ${n.filter((l) => this.selected.find((d) => d.id === l.id) === void 0).map((l) => p`<div
              class="wy-item wy-list-item wy-item-hover"
              @click=${() => this.handleSelected(l, !this.isChecked(l.id))}
              @keydown=${xe}
              @keyup=${xe}
            >
              <wy-avatar
                id=${l.id}
                .src=${l.avatar_url}
                .name=${l.display_name}
                .presence=${l.presence}
                .isBot=${l.is_bot}
                size=${32}
              ></wy-avatar>
              <div class="wy-item-body"> ${l.display_name} </div>
              <wy-icon name="${this.isChecked(l.id) ? "checkbox-marked" : "checkbox-blank"}"></wy-icon>
            </div>`) ?? C}`
    ), i && o.push(p`<div ${X(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>`), o;
  }
  render() {
    return p`<div class="wy-pane wy-scroll-y">
      <div class="wy-pane-body">
        <div class="wy-pane-group">
          <div class="wy-input-group">
            <input
              class="wy-input wy-input-group-input wy-input-filled"
              name="search"
              .value=${this.text || ""}
              ${X(this.inputRef)}
              @input=${() => this.throttledSearch()}
              @keydown=${tw}
              @keyup=${Ti}
              placeholder=${$("Search...")}
            />
            <wy-button type="reset" @click=${this.clear} kind="icon" class="wy-input-group-button-icon">
              <wy-icon name="close-circle"></wy-icon>
            </wy-button>
            <wy-button kind="icon" class="wy-input-group-button-icon">
              <wy-icon name="magnify"></wy-icon>
            </wy-button>
          </div>
        </div>
        <div>
          <wy-buttons tabs>
            <wy-button
              ?active=${this.botFilter === void 0}
              @click=${() => this.botFilter = void 0}
              kind="tab"
              small
              >${$("All")}</wy-button
            >
            <wy-button ?active=${this.botFilter === !1} @click=${() => this.botFilter = !1} kind="tab" small
              >${$("People")}</wy-button
            >
            <wy-button ?active=${this.botFilter === !0} @click=${() => this.botFilter = !0} kind="tab" small
              >${$("Bots")}</wy-button
            >
          </wy-buttons>
        </div>
        <div class="wy-pane-body">
          ${this.getSelected()} ${this.getSearchResult()}
        </div>
      </div>
      <div class="wy-footerbar wy-footerbar-sticky">
        <div class="wy-pane-group">
          <wy-buttons reverse>
            <wy-button
              color="primary"
              @click=${this.dispatchSubmit}
              ?disabled=${this.selected.length === 0 && this.select.length === 0 ? !0 : void 0}
              >${this.buttonTitle ?? $("Create")}</wy-button
            >
          </wy-buttons>
        </div>
      </div>
    </div>`;
  }
  async willUpdate(t) {
    t.has("weavy") && this.weavy && this.peopleQuery.trackInfiniteQuery(
      ov(
        this.weavy,
        () => this.text,
        this.appId,
        () => this.botFilter
      )
    );
  }
  async updated(t) {
    var i, s, n;
    this.infiniteScroll.observe(this.peopleQuery.result, this.pagerRef.value), (t.has("text") || t.has("botFilter")) && (this.select.length > 0 && (this.selected = [...this.selected, ...this.select], this.select = []), await ((s = (i = this.peopleQuery.result) == null ? void 0 : i.refetch) == null ? void 0 : s.call(i)), (n = this.inputRef.value) == null || n.focus());
  }
}, c($a, "WyUsersSearch"), $a);
si.styles = [
  J,
  ir,
  Z`
      :host {
        display: contents;
      }
    `
];
xs([
  Qt({ context: Xt, subscribe: !0 }),
  D()
], si.prototype, "weavy", 2);
xs([
  w({ attribute: !1 })
], si.prototype, "appId", 2);
xs([
  w({ attribute: !1 })
], si.prototype, "buttonTitle", 2);
xs([
  D()
], si.prototype, "botFilter", 2);
xs([
  D()
], si.prototype, "selected", 2);
xs([
  D()
], si.prototype, "select", 2);
xs([
  D()
], si.prototype, "text", 2);
si = xs([
  B("wy-users-search"),
  st()
], si);
var j5 = Object.defineProperty, W5 = Object.getOwnPropertyDescriptor, cp = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? W5(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && j5(t, i, n), n;
}, "__decorateClass$i"), ka;
let so = (ka = class extends zt(j) {
  constructor() {
    super(...arguments), this.uploadBlobMutation = new Ae(this), this.fileInputRef = rt(), this.openFileInput = () => {
      var t;
      (t = this.fileInputRef.value) == null || t.click();
    };
  }
  async handleBlobChange(t, i) {
    if (t && this.weavy) {
      const n = { file: t[0] };
      this.uploadBlobMutation.trackMutation(t2(this.weavy));
      const a = await this.uploadBlobMutation.mutate(n);
      i && (i.value = "");
      const o = new CustomEvent("blob-uploaded", { detail: { blob: a } });
      this.dispatchEvent(o);
    }
  }
  render() {
    return p` <slot
        name="placeholder"
        @click=${this.openFileInput}
        @keydown=${xe}
        @keyup=${je}
      ></slot>
      <input
        accept=${lt(this.accept)}
        type="file"
        ${X(this.fileInputRef)}
        @click=${(t) => t.stopPropagation()}
        @change=${(t) => this.handleBlobChange(t.target.files, t.target)}
        hidden
      />
      <slot name="label">
        ${this.label ? p`<wy-button @click=${this.openFileInput}>${this.label}</wy-button>` : C}
      </slot>`;
  }
}, c(ka, "WyBlobUpload"), ka);
so.styles = [
  Z`
      :host {
        text-align: center;
      }
      slot[name="placeholder"] {
        cursor: pointer;
      }
    `
];
cp([
  w({ attribute: !1 })
], so.prototype, "label", 2);
cp([
  w({ attribute: !1 })
], so.prototype, "accept", 2);
so = cp([
  B("wy-blob-upload"),
  st()
], so);
var Q5 = Object.defineProperty, K5 = Object.getOwnPropertyDescriptor, of = /* @__PURE__ */ c((r) => {
  throw TypeError(r);
}, "__typeError$7"), ar = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? K5(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && Q5(t, i, n), n;
}, "__decorateClass$h"), cf = /* @__PURE__ */ c((r, t, i) => t.has(r) || of("Cannot " + i), "__accessCheck$7"), Qu = /* @__PURE__ */ c((r, t, i) => (cf(r, t, "read from private field"), i ? i.call(r) : t.get(r)), "__privateGet$7"), G5 = /* @__PURE__ */ c((r, t, i) => t.has(r) ? of("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(r) : t.set(r, i), "__privateAdd$7"), Ku = /* @__PURE__ */ c((r, t, i, s) => (cf(r, t, "write to private field"), t.set(r, i), i), "__privateSet$7"), br, Ca;
let $i = (Ca = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.showDetails = !1, this.showAddMembers = !1, this.conversationTitle = "", this.conversationTitleInput = "", this.releaseFocusEvent = () => new CustomEvent("release-focus", { bubbles: !0, composed: !0 }), this.membersQuery = new be(this), this.handleRealtimeAppUpdated = (t) => {
      !this.conversationId || t.app.id !== this.conversationId || (this.conversationTitle = this.conversationTitleInput = t.app.display_name);
    }, this.handlePresenceChange = (t) => {
      if (!this.weavy)
        return;
      Array.isArray(t) || (t = [parseInt(t)]);
      const i = /* @__PURE__ */ c((s) => {
        const n = s.members.data ?? [];
        return n.forEach((a) => {
          a.presence = t.indexOf(a.id) != -1 ? "active" : "away";
        }), s.members.data = n, s;
      }, "updateMembersInApps");
      this.weavy.queryClient.setQueryData(["apps", this.conversationId], i);
    }, G5(this, br);
  }
  isBotChat(t) {
    var i;
    return ((i = t ?? this.conversation) == null ? void 0 : i.type) === ct.BotChat;
  }
  isChatRoom(t) {
    var i;
    return ((i = t ?? this.conversation) == null ? void 0 : i.type) === ct.ChatRoom;
  }
  isPrivateChat(t) {
    var i;
    return ((i = t ?? this.conversation) == null ? void 0 : i.type) === ct.PrivateChat;
  }
  async addMembers(t) {
    var i;
    this.showAddMembers = !1, this.showDetails = !0, !(!this.weavy || !this.conversationId) && (await ((i = this.addMembersMutation) == null ? void 0 : i.mutate({ appId: this.conversationId, members: t.map((s) => s.id) })), await this.membersQuery.result.refetch(), await this.weavy.queryClient.invalidateQueries({ queryKey: ["apps"] }));
  }
  async handleSaveConversationName() {
    var i;
    if (!this.weavy || !this.conversationId)
      return;
    const t = this.conversationTitleInput.trim() === "" ? null : this.conversationTitleInput.trim();
    await ((i = this.updateConversationMutation) == null ? void 0 : i.mutate({ appId: this.conversationId, name: t }));
  }
  async handleAvatarUploaded(t) {
    var i;
    !this.weavy || !this.conversationId || await ((i = this.updateConversationMutation) == null ? void 0 : i.mutate({
      appId: this.conversationId,
      blobId: t.id,
      thumbnailUrl: t.thumbnail_url
    }));
  }
  async clearAvatar() {
    var t;
    !this.weavy || !this.conversationId || await ((t = this.updateConversationMutation) == null ? void 0 : t.mutate({ appId: this.conversationId, blobId: null, thumbnailUrl: null }));
  }
  async updateMember(t, i) {
    var s;
    !this.weavy || !this.conversationId || (await ((s = this.updateMemberMutation) == null ? void 0 : s.mutate({
      appId: this.conversationId,
      userId: t,
      access: i
    })), await this.membersQuery.result.refetch());
  }
  async leaveConversation(t) {
    var i;
    !this.weavy || !this.conversationId || !this.user || (t && await ((i = this.leaveConversationMutation) == null ? void 0 : i.mutate({
      appId: this.conversationId,
      members: [t]
    })), t ? await this.membersQuery.result.refetch() : (this.showDetails = !1, this.conversation = void 0, this.conversationId = void 0), await this.weavy.queryClient.invalidateQueries({ queryKey: ["apps"] }));
  }
  willUpdate(t) {
    var i;
    if (super.willUpdate(t), t.has("weavy") && this.weavy && (this.leaveConversationMutation = Ny(this.weavy), this.addMembersMutation = sv(this.weavy), this.updateConversationMutation = jy(this.weavy), this.updateMemberMutation = iv(this.weavy)), t.has("conversationId") && (this.showDetails = !1), (t.has("weavy") || t.has("conversationId")) && this.weavy)
      if ((i = Qu(this, br)) == null || i.call(this), this.conversationId) {
        this.membersQuery.trackQuery(
          Wy(this.weavy, this.conversationId, {
            initialData: /* @__PURE__ */ c(() => {
              var n, a;
              if (this.conversationId)
                return (a = (n = this.weavy) == null ? void 0 : n.queryClient.getQueryData(["apps", this.conversationId])) == null ? void 0 : a.members;
            }, "initialData")
          })
        );
        const s = `a${this.conversationId}`;
        this.weavy.subscribe(s, "app_updated", this.handleRealtimeAppUpdated), this.weavy.subscribe(null, "online", this.handlePresenceChange), Ku(this, br, () => {
          var n, a;
          (n = this.weavy) == null || n.unsubscribe(s, "app_updated", this.handleRealtimeAppUpdated), (a = this.weavy) == null || a.unsubscribe(null, "online", this.handlePresenceChange), Ku(this, br, void 0);
        });
      } else
        this.membersQuery.untrackQuery();
    t.has("conversation") && this.conversation && (this.conversationTitleInput = this.conversationTitle = this.conversation.display_name);
  }
  render() {
    var n, a, o, l;
    const { data: t } = this.membersQuery.result ?? {}, i = ((t == null ? void 0 : t.data) || []).filter((d) => d.access === Wi.Admin).length, s = this.user && this.isPrivateChat() ? ((o = (((a = (n = this.conversation) == null ? void 0 : n.members) == null ? void 0 : a.data) || []).filter((d) => {
      var u;
      return d.id !== ((u = this.user) == null ? void 0 : u.id);
    })) == null ? void 0 : o[0]) ?? this.user : null;
    return p`
      <header class="wy-appbars">
        <nav class="wy-appbar">
          <slot class="wy-appbar-buttons wy-appbar-buttons-first" name="action"></slot>
          ${this.conversation && this.user ? p`
                <div class="wy-appbar-section">
                  ${this.conversation.type === ct.PrivateChat ? p`<wy-presence
                        placement="text"
                        .status=${s == null ? void 0 : s.presence}
                        id=${lt(s == null ? void 0 : s.id)}
                      ></wy-presence>` : C}
                  <span class="wy-appbar-text">${this.conversationTitle}</span>
                </div>
              ` : p`<span></span>`}
          ${this.isChatRoom() ? p`<wy-button kind="icon" @click=${() => this.showDetails = !0} title="${$("Details")}">
                <wy-icon name="information"></wy-icon>
              </wy-button>` : C}
        </nav>
      </header>

      <!-- details modal -->
      ${this.weavy ? p`
            <wy-overlay
              .show=${this.showDetails}
              @close=${() => {
      this.showDetails = !1;
    }}
              @release-focus=${() => this.dispatchEvent(this.releaseFocusEvent())}
            >
              <header class="wy-appbars">
                <nav class="wy-appbar">
                  <wy-button
                    kind="icon"
                    @click=${() => {
      this.showDetails = !1;
    }}
                  >
                    <wy-icon name="close"></wy-icon>
                  </wy-button>
                  <div class="wy-appbar-text">${this.conversationTitle}</div>
                </nav>
              </header>
              <div class="wy-scroll-y">
                ${this.showDetails && this.conversation && this.user ? p`
                      <wy-avatar-header>
                        ${this.isChatRoom() ? p`
                              <wy-blob-upload
                                @blob-uploaded=${(d) => this.handleAvatarUploaded(d.detail.blob)}
                                .accept=${"image/*"}
                                .label=${$("Select picture")}
                              >
                                <div slot="placeholder">
                                  ${this.conversation.avatar_url ? p`<wy-avatar .size=${96} src=${this.conversation.avatar_url}></wy-avatar>` : p`<wy-avatar-group
                                        .members=${t == null ? void 0 : t.data}
                                        title=${this.conversation.display_name}
                                        .size=${96}
                                      ></wy-avatar-group>`}
                                </div>
                                ${this.conversation.avatar_url ? p`<div slot="label"
                                      ><wy-button @click=${() => this.clearAvatar()}
                                        >${$("Remove picture")}</wy-button
                                      ></div
                                    >` : C}
                              </wy-blob-upload>
                            ` : p`
                              <wy-avatar
                                src=${lt(s == null ? void 0 : s.avatar_url)}
                                name=${lt(s == null ? void 0 : s.display_name)}
                                presence=${(s == null ? void 0 : s.presence) || "away"}
                                ?isBot=${s == null ? void 0 : s.is_bot}
                                id=${lt(s == null ? void 0 : s.id)}
                                size=${96}
                              ></wy-avatar>
                            `}
                      </wy-avatar-header>
                      ${this.isChatRoom() ? p`
                            <div class="wy-pane-group">
                              <label class="wy-label" for="roomName">${$("Room name")}</label>

                              <input
                                id="roomName"
                                class="wy-input"
                                .value=${this.conversationTitleInput}
                                @input=${(d) => {
      this.conversationTitleInput = d.target.value;
    }}
                                @keyup=${Dg}
                                @blur=${() => this.handleSaveConversationName()}
                              />

                              <div class="wy-description">
                                ${$("Changing the name of a group chat changes it for everyone.")}
                              </div>
                              <br />
                              <label class="wy-label">${$("Members")}</label>
                              ${t ? p`
                                    <div class="wy-list">
                                      ${((l = t.data) == null ? void 0 : l.map(
      (d) => {
        var u, y;
        return p`
                                          <div class="wy-item wy-list-item">
                                            <wy-avatar
                                              .src=${d.avatar_url}
                                              .name=${d.display_name}
                                              .isBot=${d.is_bot}
                                              size=${32}
                                            ></wy-avatar>
                                            <div class="wy-item-body">
                                              ${d.display_name}
                                              ${d.access === Wi.Admin ? p` <wy-icon
                                                    size="20"
                                                    inline
                                                    name="shield-star"
                                                    title=${$("Admin")}
                                                  ></wy-icon>` : C}
                                            </div>
                                            ${this.user && this.user.id === d.id && !Us(ns.Admin, (u = this.conversation) == null ? void 0 : u.permissions) ? p` <wy-button
                                                  @click=${() => this.leaveConversation(d.id)}
                                                  title=${$("Leave conversation")}
                                                  kind="icon"
                                                >
                                                  <wy-icon name="close"></wy-icon>
                                                </wy-button>` : Us(ns.Admin, (y = this.conversation) == null ? void 0 : y.permissions) ? p`<wy-dropdown>
                                                  <wy-dropdown-item @click=${() => this.leaveConversation(d.id)}>
                                                    <wy-icon name="account-minus"></wy-icon>
                                                    ${this.user && this.user.id === d.id ? $("Leave conversation") : $("Remove member")}
                                                  </wy-dropdown-item>
                                                  ${i > 1 && d.access === Wi.Admin ? p`<wy-dropdown-item
                                                        @click=${() => this.updateMember(d.id, Wi.Write)}
                                                      >
                                                        <wy-icon name="shield-star-outline"></wy-icon>
                                                        ${$("Remove as admin")}
                                                      </wy-dropdown-item>` : d.access !== Wi.Admin ? p`<wy-dropdown-item
                                                        @click=${() => this.updateMember(d.id, Wi.Admin)}
                                                      >
                                                        <wy-icon name="shield-star"></wy-icon>
                                                        ${$("Make admin")}
                                                      </wy-dropdown-item>` : C}
                                                </wy-dropdown>` : C}
                                          </div>
                                        `;
      }
    )) ?? C}
                                    </div>
                                  ` : C}
                              <wy-button
                                kind="filled"
                                color="primary"
                                @click=${() => {
      this.showDetails = !1, this.showAddMembers = !0;
    }}
                                title=${$("Add members")}
                              >
                                ${$("Add members")}
                              </wy-button>
                            </div>
                          ` : C}
                    ` : C}
              </div>
            </wy-overlay>
          ` : C}

      <!-- add members modal -->
      ${this.weavy ? p`
            <wy-overlay
              .show=${this.showAddMembers}
              @close=${() => {
      this.showAddMembers = !1;
    }}
              @release-focus=${() => this.dispatchEvent(this.releaseFocusEvent())}
            >
              <header class="wy-appbars">
                <nav class="wy-appbar">
                  <wy-button
                    kind="icon"
                    @click=${() => {
      this.showAddMembers = !1;
    }}
                  >
                    <wy-icon name="close"></wy-icon>
                  </wy-button>
                  <div class="wy-appbar-text">${$("Add members")}</div>
                </nav>
              </header>
              ${this.showAddMembers ? p`
                    <wy-users-search
                      .buttonTitle=${$("Add members")}
                      .appId=${this.conversationId}
                      @submit=${(d) => this.addMembers(d.detail.members)}
                    ></wy-users-search>
                  ` : C}
            </wy-overlay>
          ` : C}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = Qu(this, br)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Ca, "WyConversationAppbar"), Ca);
br = /* @__PURE__ */ new WeakMap();
$i.styles = [
  J,
  Z`
      :host {
        display: contents;
      }
    `
];
ar([
  w({ attribute: !1 })
], $i.prototype, "conversationId", 2);
ar([
  w({ attribute: !1 })
], $i.prototype, "conversation", 2);
ar([
  w({ type: Boolean })
], $i.prototype, "showDetails", 2);
ar([
  w({ type: Boolean })
], $i.prototype, "showAddMembers", 2);
ar([
  w({ type: String })
], $i.prototype, "conversationTitle", 2);
ar([
  D()
], $i.prototype, "conversationTitleInput", 2);
$i = ar([
  B("wy-conversation-appbar"),
  st()
], $i);
var Y5 = Object.defineProperty, Z5 = Object.getOwnPropertyDescriptor, Ll = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? Z5(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && Y5(t, i, n), n;
}, "__decorateClass$g"), _a;
let ro = (_a = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.typing = new nl(this);
  }
  willUpdate(t) {
    t.has("appId") && (this.typing.appId = this.appId), t.has("userId") && (this.typing.userId = this.userId);
  }
  render() {
    var n;
    const { names: t, ellipsis: i } = this.typing;
    let s;
    if (t.length === 1) {
      const a = t[0];
      s = $(pt`${a} is typing${i}`, { desc: "A is typing..." });
    } else if (t.length > 1) {
      const a = new Intl.ListFormat((n = this.weavy) == null ? void 0 : n.locale, { style: "long", type: "conjunction" }).format(
        t
      );
      s = $(pt`${a} are typing${i}`, {
        desc: "A, B and C are typing..."
      });
    }
    return s ? p`<span>${s}</span>` : p`<slot></slot>`;
  }
}, c(_a, "WyTyping"), _a);
Ll([
  Qt({ context: Xt, subscribe: !0 }),
  D()
], ro.prototype, "weavy", 2);
Ll([
  w({ attribute: !0, type: Number })
], ro.prototype, "appId", 2);
Ll([
  w({ attribute: !0, type: Number })
], ro.prototype, "userId", 2);
ro = Ll([
  B("wy-typing"),
  st()
], ro);
var X5 = Object.defineProperty, J5 = Object.getOwnPropertyDescriptor, lf = /* @__PURE__ */ c((r) => {
  throw TypeError(r);
}, "__typeError$6"), Oe = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? J5(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && X5(t, i, n), n;
}, "__decorateClass$f"), df = /* @__PURE__ */ c((r, t, i) => t.has(r) || lf("Cannot " + i), "__accessCheck$6"), Gu = /* @__PURE__ */ c((r, t, i) => (df(r, t, "read from private field"), i ? i.call(r) : t.get(r)), "__privateGet$6"), t4 = /* @__PURE__ */ c((r, t, i) => t.has(r) ? lf("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(r) : t.set(r, i), "__privateAdd$6"), Yu = /* @__PURE__ */ c((r, t, i, s) => (df(r, t, "write to private field"), t.set(r, i), i), "__privateSet$6"), xr, Pa;
let oe = (Pa = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.unread = !1, this.avatarUrl = "", this.hideAvatar = !1, this.displayName = "", this.type = ct.PrivateChat, this.selected = !1, this.starred = !1, this.pinned = !1, this.handleMessageCreated = (t) => {
      !this.user || !this.weavy || (_t(
        this.weavy.queryClient,
        ["apps", t.message.app.id],
        void 0,
        (i) => {
          var s;
          i.last_message = t.message, i.is_unread = t.message.created_by.id !== ((s = this.user) == null ? void 0 : s.id);
        }
      ), nt(
        this.weavy.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.message.app.id,
        (i) => {
          var s;
          i.last_message = t.message, i.is_unread = t.message.created_by.id !== ((s = this.user) == null ? void 0 : s.id);
        }
      ));
    }, this.handleConversationUpdated = () => {
      var t;
      (t = this.weavy) == null || t.queryClient.invalidateQueries({ queryKey: ["apps"], exact: !1 });
    }, this.handleConversationMarked = (t) => {
      var i;
      this.user && t.actor.id === this.user.id && ((i = this.weavy) == null || i.queryClient.invalidateQueries({ queryKey: ["apps"], exact: !1 }));
    }, t4(this, xr);
  }
  dispatchSelected(t, i) {
    t.preventDefault();
    const s = new CustomEvent("selected", { detail: { id: i } });
    return this.dispatchEvent(s);
  }
  handleStar(t, i) {
    const s = new CustomEvent("star", {
      detail: { id: this.conversationId, star: i }
    });
    return this.dispatchEvent(s);
  }
  handlePin(t, i) {
    const s = new CustomEvent("pin", {
      detail: { id: this.conversationId, pin: i }
    });
    return this.dispatchEvent(s);
  }
  dispatchMarked(t) {
    var s;
    const i = new CustomEvent("mark", {
      detail: { id: this.conversationId, messageId: t ? (s = this.lastMessage) == null ? void 0 : s.id : null }
    });
    return this.dispatchEvent(i);
  }
  handleLeaveConversation() {
    const t = new CustomEvent("leave", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  handleTrashConversation() {
    const t = new CustomEvent("trash", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  willUpdate(t) {
    var i;
    if (t.has("weavy") && this.weavy) {
      (i = Gu(this, xr)) == null || i.call(this);
      const s = `a${this.conversationId}`;
      this.weavy.subscribe(s, "app_updated", this.handleConversationUpdated), this.weavy.subscribe(s, "member_added", this.handleConversationUpdated), this.weavy.subscribe(s, "message_created", this.handleMessageCreated), this.weavy.subscribe(s, "app_marked", this.handleConversationMarked), Yu(this, xr, () => {
        var n, a, o, l;
        (n = this.weavy) == null || n.unsubscribe(s, "app_updated", this.handleConversationUpdated), (a = this.weavy) == null || a.unsubscribe(s, "member_added", this.handleConversationUpdated), (o = this.weavy) == null || o.unsubscribe(s, "message_created", this.handleMessageCreated), (l = this.weavy) == null || l.unsubscribe(s, "app_marked", this.handleConversationMarked), Yu(this, xr, void 0);
      });
    }
  }
  render() {
    var n, a, o, l, d, u, y, m, f, g, x, k, S, P, E, z, U;
    const t = (n = this.lastMessage) != null && n.created_at ? new Intl.DateTimeFormat((a = this.weavy) == null ? void 0 : a.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.lastMessage.created_at)
    ) : "", i = (o = this.lastMessage) != null && o.created_at ? mc((l = this.weavy) == null ? void 0 : l.locale, new Date(this.lastMessage.created_at)) : "", s = this.type === ct.PrivateChat && this.user ? ((u = (((d = this.members) == null ? void 0 : d.data) || []).filter((O) => {
      var V;
      return O.id !== ((V = this.user) == null ? void 0 : V.id);
    })) == null ? void 0 : u[0]) ?? this.user : null;
    return p`
      <div
        class=${Rt({
      "wy-item wy-list-item-lg wy-item-hover wy-conversation": !0,
      "wy-unread": this.unread,
      "wy-active": this.selected
    })}
        tabindex="0"
        @click=${(O) => this.dispatchSelected(O, this.conversationId)}
        @keydown=${xe}
        @keyup=${je}
      >
        ${this.type !== ct.BotChat ? this.avatarUrl ? p`<wy-avatar .size=${48} src=${this.avatarUrl}></wy-avatar>` : this.type == ct.ChatRoom ? p` <wy-avatar-group
                .members=${(y = this.members) == null ? void 0 : y.data}
                title=${this.displayName}
                .size=${48}
              ></wy-avatar-group>` : p`
                <wy-avatar
                  src=${lt(s == null ? void 0 : s.avatar_url)}
                  name=${lt(s == null ? void 0 : s.display_name)}
                  presence=${(s == null ? void 0 : s.presence) || "away"}
                  ?isBot=${s == null ? void 0 : s.is_bot}
                  id=${lt(s == null ? void 0 : s.id)}
                  size=${48}
                ></wy-avatar>
              ` : C}

        <div class="wy-item-rows">
          <div class="wy-item-row">
            <div class="wy-item-title"
              >${this.displayName || ((m = this.lastMessage) == null ? void 0 : m.plain) || $("Untitled conversation")}</div
            >
            ${this.lastMessage ? p`<time class="wy-meta" datetime=${this.lastMessage.created_at.toString()} title=${t}
                  >${i}</time
                >` : C}
          </div>
          <div class="wy-item-row">
            <div class="wy-item-text">
              ${this.user ? p`
                    <wy-typing appId=${this.conversationId} userId=${this.user.id}>
                      ${this.lastMessage ? p`
                            ${this.user.id === this.lastMessage.created_by.id ? p`${$("You")}: ` : C}
                            ${this.members.count > 2 && this.user.id !== ((f = this.lastMessage) == null ? void 0 : f.created_by.id) ? p`${(g = this.lastMessage) == null ? void 0 : g.created_by.display_name}: ` : C}
                          ` : C}
                      ${(x = this.lastMessage) != null && x.text ? p`<span>${this.lastMessage.plain}</span>` : C}
                      ${!((k = this.lastMessage) != null && k.text) && (((P = (S = this.lastMessage) == null ? void 0 : S.attachments) == null ? void 0 : P.count) || 0) > 0 ? p`<wy-icon kind="text-icon" name="attachment"></wy-icon>` : C}
                      ${!((E = this.lastMessage) != null && E.text) && ((U = (z = this.lastMessage) == null ? void 0 : z.meeting) != null && U.id) ? p`<wy-icon kind="text-icon" name="video"></wy-icon>` : C}
                      ${this.lastMessage ? C : p`&nbsp;`}
                    </wy-typing>
                  ` : C}
            </div>

            <div class="wy-item-actions wy-item-actions-bottom">
              ${this.starred ? p`<wy-button
                    kind="icon"
                    @click=${(O) => {
      O.stopPropagation(), this.handleStar(O, !1);
    }}
                  >
                    <wy-icon name="star" size=${24} color="yellow"></wy-icon>
                  </wy-button>` : C}
              ${this.pinned ? p`<wy-button
                    kind="icon"
                    @click=${(O) => {
      O.stopPropagation(), this.handlePin(O, !1);
    }}
                  >
                    <wy-icon name="pin" size=${24} color=""></wy-icon>
                  </wy-button>` : C}

              <wy-dropdown directionX="left">
                <wy-dropdown-item @click=${() => this.dispatchMarked(this.unread)}>
                  <wy-icon name=${this.unread ? "read" : "unread"}></wy-icon>
                  ${this.unread ? $("Mark as read") : $("Mark as unread")}
                </wy-dropdown-item>
                <wy-dropdown-item @click=${(O) => this.handlePin(O, !this.pinned)}>
                  <wy-icon name=${this.pinned ? "unpin" : "pin"}></wy-icon>
                  ${this.pinned ? $("Unpin") : $("Pin")}
                </wy-dropdown-item>
                <wy-dropdown-item @click=${(O) => this.handleStar(O, !this.starred)}>
                  <wy-icon name=${this.starred ? "unstar" : "star"}></wy-icon>
                  ${this.starred ? $("Unstar") : $("Star")}
                </wy-dropdown-item>
                ${this.type === ct.ChatRoom ? p`<wy-dropdown-item @click=${() => this.handleLeaveConversation()}>
                      <wy-icon name="account-minus"></wy-icon>
                      ${$("Leave conversation")}
                    </wy-dropdown-item>` : C}
                ${this.type === ct.BotChat ? p`
                      <wy-dropdown-item @click=${() => this.handleTrashConversation()}>
                        <wy-icon name="trashcan"></wy-icon>
                        ${$("Trash")}
                      </wy-dropdown-item>
                    ` : C}
              </wy-dropdown>
            </div>
          </div>
        </div>
      </div>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.weavy && this.requestUpdate("weavy");
  }
  disconnectedCallback() {
    var t;
    (t = Gu(this, xr)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Pa, "WyConversationListItem"), Pa);
xr = /* @__PURE__ */ new WeakMap();
oe.styles = J;
Oe([
  Qt({ context: Xt, subscribe: !0 }),
  D()
], oe.prototype, "weavy", 2);
Oe([
  w({ attribute: !0, type: Number })
], oe.prototype, "conversationId", 2);
Oe([
  w({ attribute: !0, type: Boolean })
], oe.prototype, "unread", 2);
Oe([
  w({ attribute: !0 })
], oe.prototype, "avatarUrl", 2);
Oe([
  w({ attribute: !0, type: Boolean })
], oe.prototype, "hideAvatar", 2);
Oe([
  w({ attribute: !0 })
], oe.prototype, "displayName", 2);
Oe([
  w({ attribute: !0, type: String, reflect: !0 })
], oe.prototype, "type", 2);
Oe([
  w({ attribute: !0, type: Boolean, reflect: !0 })
], oe.prototype, "selected", 2);
Oe([
  w({ attribute: !0, type: Boolean, reflect: !0 })
], oe.prototype, "starred", 2);
Oe([
  w({ attribute: !0, type: Boolean, reflect: !0 })
], oe.prototype, "pinned", 2);
Oe([
  w({ attribute: !1 })
], oe.prototype, "members", 2);
Oe([
  w({ attribute: !1 })
], oe.prototype, "lastMessage", 2);
Oe([
  Qt({ context: wl, subscribe: !0 }),
  D()
], oe.prototype, "user", 2);
oe = Oe([
  B("wy-conversation-list-item"),
  st()
], oe);
var e4 = Object.defineProperty, i4 = Object.getOwnPropertyDescriptor, lp = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? i4(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && e4(t, i, n), n;
}, "__decorateClass$e"), Ma;
let no = (Ma = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.show = !1;
  }
  open() {
    this.show = !0;
  }
  close() {
    this.show = !1;
  }
  async submit(t = []) {
    var a;
    const i = this.bot ? { members: [this.bot], type: ze.BotChat } : { members: t == null ? void 0 : t.map((o) => o.id), type: t.length === 1 ? ze.PrivateChat : ze.ChatRoom }, s = await ((a = this.addConversationMutation) == null ? void 0 : a.mutate(i));
    this.close();
    const n = new CustomEvent("selected", { detail: { id: s == null ? void 0 : s.id } });
    return this.dispatchEvent(n);
  }
  updated(t) {
    t.has("weavy") && this.weavy && (this.addConversationMutation = g1(this.weavy));
  }
  render() {
    return p`
      <wy-button kind="icon" @click=${() => this.bot ? this.submit() : this.open()}>
        <wy-icon name="plus"></wy-icon>
      </wy-button>

      ${!this.bot && this.weavy ? p`<wy-overlay
            .show=${this.show}
            @close=${() => {
      this.show = !1;
    }}
            @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
          >
            <header class="wy-appbars">
              <nav class="wy-appbar">
                <wy-button kind="icon" @click=${() => this.close()}>
                  <wy-icon name="close"></wy-icon>
                </wy-button>
                <div class="wy-appbar-text">${$("New conversation")}</div>
              </nav>
            </header>
            ${this.show ? p` <wy-users-search @submit=${(t) => this.submit(t.detail.members)}></wy-users-search> ` : C}
          </wy-overlay>` : C}
    `;
  }
}, c(Ma, "WyConversationNew"), Ma);
no.styles = [J];
lp([
  w()
], no.prototype, "bot", 2);
lp([
  D()
], no.prototype, "show", 2);
no = lp([
  B("wy-conversation-new"),
  st()
], no);
var s4 = Object.defineProperty, r4 = Object.getOwnPropertyDescriptor, hf = /* @__PURE__ */ c((r) => {
  throw TypeError(r);
}, "__typeError$5"), or = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? r4(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && s4(t, i, n), n;
}, "__decorateClass$d"), pf = /* @__PURE__ */ c((r, t, i) => t.has(r) || hf("Cannot " + i), "__accessCheck$5"), Zu = /* @__PURE__ */ c((r, t, i) => (pf(r, t, "read from private field"), i ? i.call(r) : t.get(r)), "__privateGet$5"), n4 = /* @__PURE__ */ c((r, t, i) => t.has(r) ? hf("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(r) : t.set(r, i), "__privateAdd$5"), Xu = /* @__PURE__ */ c((r, t, i, s) => (pf(r, t, "write to private field"), t.set(r, i), i), "__privateSet$5"), $r, za;
let ki = (za = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.conversationTypes = [ct.ChatRoom, ct.PrivateChat], this.searchText = "", this.inputRef = rt(), this.conversationsQuery = new Ri(this), this.infiniteScroll = new Ii(this), this.pagerRef = rt(), this.handleRefresh = () => {
      this.conversationsQuery.result.refetch();
    }, this.handlePresenceChange = (t) => {
      if (!this.weavy)
        return;
      Array.isArray(t) || (t = [parseInt(t)]);
      const i = /* @__PURE__ */ c((s) => {
        const n = s.members.data ?? [];
        n.forEach((a) => {
          a.presence = t.indexOf(a.id) != -1 ? "active" : "away";
        }), s.members.data = n;
      }, "updateMembersInApps");
      nt(
        this.weavy.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        void 0,
        i
      );
    }, this.throttledSearch = el(
      async () => {
        var t;
        this.searchText = ((t = this.inputRef.value) == null ? void 0 : t.value) || "";
      },
      250,
      { leading: !1, trailing: !0 }
    ), n4(this, $r);
  }
  dispatchSelected(t) {
    this.conversationId = t;
    const i = new CustomEvent("conversation-selected", { detail: { id: t } });
    return this.dispatchEvent(i);
  }
  async handleMark(t, i) {
    var s, n;
    await ((n = this.markConversationMutation) == null ? void 0 : n.mutate({ appId: t, messageId: i, userId: (s = this.user) == null ? void 0 : s.id }));
  }
  async handleStar(t, i) {
    var s;
    await ((s = this.starConversationMutation) == null ? void 0 : s.mutate({ appId: t, star: i }));
  }
  async handlePin(t, i) {
    var s;
    await ((s = this.pinConversationMutation) == null ? void 0 : s.mutate({ appId: t, pin: i }));
  }
  async handleLeaveConversation(t) {
    var s;
    const i = await this.whenUser();
    await ((s = this.leaveConversationMutation) == null ? void 0 : s.mutate({ appId: t, members: [i.id] })), this.dispatchSelected(void 0), this.conversationsQuery.result.refetch();
  }
  async handleTrashConversation(t) {
    var i;
    await ((i = this.trashConversationMutation) == null ? void 0 : i.mutate({ appId: t })), this.dispatchSelected(void 0), this.conversationsQuery.result.refetch();
  }
  async clear() {
    this.searchText = "";
  }
  async willUpdate(t) {
    var i;
    super.willUpdate(t), (t.has("weavy") || t.has("conversationTypes")) && this.weavy && (this.conversationsQuery.trackInfiniteQuery(
      b1(this.weavy, {}, this.conversationTypes, this.bot, () => this.searchText, "pinned_at desc,rev desc")
    ), this.markConversationMutation = qy(this.weavy), this.starConversationMutation = tv(this.weavy), this.pinConversationMutation = ev(this.weavy), this.leaveConversationMutation = Ny(this.weavy), this.trashConversationMutation = rv(this.weavy), (i = Zu(this, $r)) == null || i.call(this), this.weavy.subscribe(null, "app_created", this.handleRefresh), this.weavy.subscribe(null, "message_created", this.handleRefresh), this.weavy.subscribe(null, "member_added", this.handleRefresh), this.weavy.subscribe(null, "online", this.handlePresenceChange), Xu(this, $r, () => {
      var s, n, a, o;
      (s = this.weavy) == null || s.unsubscribe(null, "app_created", this.handleRefresh), (n = this.weavy) == null || n.unsubscribe(null, "message_created", this.handleRefresh), (a = this.weavy) == null || a.unsubscribe(null, "member_added", this.handleRefresh), (o = this.weavy) == null || o.unsubscribe(null, "online", this.handlePresenceChange), Xu(this, $r, void 0);
    })), t.has("user") && this.user && (this.bot || (this.avatarUser ?? (this.avatarUser = this.user)));
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.conversationsQuery.result, this.pagerRef.value);
  }
  async updated(t) {
    var i, s;
    t.has("searchText") && t.get("searchText") && this.conversationsQuery.result && await ((s = (i = this.conversationsQuery.result).refetch) == null ? void 0 : s.call(i));
  }
  renderConversations(t, i) {
    if (i) {
      const s = ms(i);
      return Re(
        s,
        (n) => n == null ? void 0 : n.id,
        (n) => [
          p`<wy-conversation-list-item
              .conversationId=${n == null ? void 0 : n.id}
              .avatarUrl=${n == null ? void 0 : n.avatar_url}
              .hideAvatar=${!!this.bot}
              .displayName=${n.display_name}
              .lastMessage=${n.last_message}
              .members=${n.members}
              .unread=${n.is_unread}
              .starred=${n.is_starred}
              .pinned=${n.is_pinned}
              .type=${n.type}
              .selected=${this.conversationId == n.id}
              @selected=${(a) => this.dispatchSelected(a.detail.id)}
              @mark=${(a) => this.handleMark(a.detail.id, a.detail.messageId)}
              @star=${(a) => this.handleStar(a.detail.id, a.detail.star)}
              @pin=${(a) => this.handlePin(a.detail.id, a.detail.pin)}
              @leave=${(a) => this.handleLeaveConversation(a.detail.id)}
              @trash=${(a) => this.handleTrashConversation(a.detail.id)}
            ></wy-conversation-list-item>`
        ]
      );
    }
    return C;
  }
  render() {
    var a, o, l, d;
    const { data: t, isPending: i, hasNextPage: s } = this.conversationsQuery.result ?? {}, n = !this.avatarUser;
    return p`
      ${this.user ? p`
            <header class="wy-appbars">
              <nav class="wy-appbar">
                ${n ? p` <wy-spinner></wy-spinner> ` : p`
                      <wy-avatar
                        .src=${(a = this.avatarUser) == null ? void 0 : a.avatar_url}
                        .name=${(o = this.avatarUser) == null ? void 0 : o.display_name}
                        .size=${24}
                      ></wy-avatar>
                    `}
                <div class="wy-appbar-text"
                  >${this.name ?? (this.bot ? (l = this.avatarUser) == null ? void 0 : l.display_name : $("Messenger"))}</div
                >
                <wy-conversation-new
                  .bot=${this.bot}
                  @selected=${(u) => this.dispatchSelected(u.detail.id)}
                ></wy-conversation-new>
              </nav>
            </header>
            ${this.bot ? C : p`
                  <div class="wy-pane-body">
                    <div class="wy-pane-group">
                      <div class="wy-input-group">
                        <input
                          class="wy-input wy-input-group-input wy-input-filled"
                          name="text"
                          .value=${this.searchText || ""}
                          ${X(this.inputRef)}
                          @input=${() => this.throttledSearch()}
                          @keydown=${tw}
                          @keyup=${Ti}
                          placeholder=${$("Search for conversations...")}
                        />
                        <wy-button type="reset" @click=${this.clear} kind="icon" class="wy-input-group-button-icon">
                          <wy-icon name="close-circle"></wy-icon>
                        </wy-button>
                        <wy-button kind="icon" class="wy-input-group-button-icon">
                          <wy-icon name="magnify"></wy-icon>
                        </wy-button>
                      </div>
                    </div>
                  </div>
                `}
            <div class="wy-conversations">
              ${!i && this.user && t ? (d = t.pages[0]) != null && d.count || this.searchText ? this.renderConversations(this.user, t) : p`
                      <div class="wy-pane-body">
                        <div class="wy-pane-group">
                          <wy-empty noNetwork>${$("Create a conversation to get started.")}</wy-empty>
                        </div>
                      </div>
                    ` : p`<wy-empty><wy-spinner padded></wy-spinner></wy-empty>`}
              ${s ? p`<div ${X(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
            </div>
          ` : p`<wy-empty class="wy-pane"><wy-spinner overlay></wy-spinner></wy-empty>`}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = Zu(this, $r)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(za, "WeavyConversationList"), za);
$r = /* @__PURE__ */ new WeakMap();
ki.styles = [
  J,
  Z`
      :host {
        position: relative;
      }
    `,
  ir
];
or([
  w({ type: Object })
], ki.prototype, "avatarUser", 2);
or([
  w({ type: String })
], ki.prototype, "name", 2);
or([
  w({ type: Number })
], ki.prototype, "conversationId", 2);
or([
  w({ type: Array })
], ki.prototype, "conversationTypes", 2);
or([
  w()
], ki.prototype, "bot", 2);
or([
  D()
], ki.prototype, "searchText", 2);
ki = or([
  B("wy-conversation-list"),
  st()
], ki);
var a4 = Object.defineProperty, o4 = Object.getOwnPropertyDescriptor, uf = /* @__PURE__ */ c((r) => {
  throw TypeError(r);
}, "__typeError$4"), yf = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? o4(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && a4(t, i, n), n;
}, "__decorateClass$c"), wf = /* @__PURE__ */ c((r, t, i) => t.has(r) || uf("Cannot " + i), "__accessCheck$4"), Ju = /* @__PURE__ */ c((r, t, i) => (wf(r, t, "read from private field"), i ? i.call(r) : t.get(r)), "__privateGet$4"), c4 = /* @__PURE__ */ c((r, t, i) => t.has(r) ? uf("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(r) : t.set(r, i), "__privateAdd$4"), ty = /* @__PURE__ */ c((r, t, i, s) => (wf(r, t, "write to private field"), t.set(r, i), i), "__privateSet$4"), kr, Sa;
let ll = (Sa = class extends ei {
  constructor() {
    super(...arguments), this.conversationTitle = "", this.handleRealtimeAppUpdated = (t) => {
      !this.conversation || t.app.id !== this.conversation.id || (this.conversationTitle = t.app.display_name);
    }, this.handleRealtimeMarked = (t) => {
      !this.weavy || !this.conversation || _t(
        this.weavy.queryClient,
        ["members", this.conversation.id],
        t.actor.id,
        (i) => {
          i.marked_id = t.marked_id, i.marked_at = t.marked_at;
        }
      );
    }, c4(this, kr);
  }
  willUpdate(t) {
    var i;
    if (super.willUpdate(t), (t.has("weavy") || t.has("conversation")) && this.weavy && t.has("conversation") && this.conversation && (this.conversationTitle = this.conversation.display_name), (t.has("weavy") || t.has("conversationId")) && this.weavy && this.conversationId !== t.get("conversationId") && ((i = Ju(this, kr)) == null || i.call(this), this.conversationId)) {
      const s = `a${this.conversationId}`;
      this.weavy.subscribe(s, "app_updated", this.handleRealtimeAppUpdated), this.weavy.subscribe(s, "app_marked", this.handleRealtimeMarked), ty(this, kr, () => {
        var n, a;
        (n = this.weavy) == null || n.unsubscribe(s, "app_marked", this.handleRealtimeMarked), (a = this.weavy) == null || a.unsubscribe(s, "app_updated", this.handleRealtimeAppUpdated), ty(this, kr, void 0);
      });
    }
  }
  render() {
    var l, d, u, y, m;
    const { data: t, isPending: i, hasNextPage: s } = this.messagesQuery.result ?? {}, { data: n, isPending: a } = this.membersQuery.result ?? {}, o = this.user && this.isPrivateChat() ? ((u = (((d = (l = this.conversation) == null ? void 0 : l.members) == null ? void 0 : d.data) || []).filter((f) => {
      var g;
      return f.id !== ((g = this.user) == null ? void 0 : g.id);
    })) == null ? void 0 : u[0]) ?? this.user : null;
    return p`
      ${this.conversation && t ? p`
            ${!s && !i ? p`
                  <wy-avatar-header>
                    ${this.conversation.avatar_url ? p`<wy-avatar .size=${96} src=${this.conversation.avatar_url}></wy-avatar>` : this.isChatRoom() ? p` <wy-avatar-group
                          .members=${n == null ? void 0 : n.data}
                          title=${this.conversation.display_name}
                          .size=${96}
                        ></wy-avatar-group>` : o != null && o.avatar_url ? p`
                          <wy-avatar
                            src=${lt(o == null ? void 0 : o.avatar_url)}
                            name=${this.conversation.display_name}
                            ?isBot=${o == null ? void 0 : o.is_bot}
                            size=${96}
                          ></wy-avatar>
                        ` : C}
                  </wy-avatar-header>
                ` : C}
            <wy-messages
              .conversation=${this.conversation}
              .infiniteMessages=${t}
              .members=${n}
              .unreadMarkerId=${this.lastReadMessageId}
              .unreadMarkerPosition=${this.lastReadMessagePosition}
              .unreadMarkerShow=${this.showNewMessages}
              @vote=${(f) => {
      var g;
      (g = this.pollMutation) == null || g.mutate({
        optionId: f.detail.id,
        parentType: f.detail.parentType,
        parentId: f.detail.parentId
      });
    }}
            >
              ${s ? p`<div slot="start" ${X(this.pagerRef)} part="wy-pager wy-pager-top"></div>` : C}
              <wy-message-typing
                slot="end"
                .conversationId=${this.conversation.id}
                .userId=${(y = this.user) == null ? void 0 : y.id}
                .isPrivateChat=${this.isPrivateChat()}
                .members=${this.conversation.members.data}
                @typing=${(f) => this.handleTyping(f)}
              ></wy-message-typing>
            </wy-messages>
          ` : p`
            <div class="wy-messages">
              <wy-empty class="wy-pane">
                ${i || a || !this.conversation ? p`<wy-spinner overlay></wy-spinner>` : $("Start the conversation!")}
              </wy-empty>
            </div>
          `}
      ${this.conversation ? p`
            <div ${X(this.bottomRef)}></div>
            <div class="wy-footerbar wy-footerbar-sticky">
              <wy-message-editor
                .app=${this.conversation}
                .draft=${!0}
                placeholder=${$("Type a message...")}
                ?disabled=${!Us(ns.Create, (m = this.conversation) == null ? void 0 : m.permissions)}
                @submit=${(f) => this.handleSubmit(f)}
              ></wy-message-editor>
            </div>
          ` : C}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = Ju(this, kr)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Sa, "WyConversationExtended"), Sa);
kr = /* @__PURE__ */ new WeakMap();
yf([
  D()
], ll.prototype, "conversationTitle", 2);
ll = yf([
  B("wy-conversation-extended"),
  st()
], ll);
var l4 = Object.defineProperty, d4 = Object.getOwnPropertyDescriptor, ff = /* @__PURE__ */ c((r) => {
  throw TypeError(r);
}, "__typeError$3"), gc = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? d4(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && l4(t, i, n), n;
}, "__decorateClass$b"), mf = /* @__PURE__ */ c((r, t, i) => t.has(r) || ff("Cannot " + i), "__accessCheck$3"), ey = /* @__PURE__ */ c((r, t, i) => (mf(r, t, "read from private field"), i ? i.call(r) : t.get(r)), "__privateGet$3"), h4 = /* @__PURE__ */ c((r, t, i) => t.has(r) ? ff("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(r) : t.set(r, i), "__privateAdd$3"), iy = /* @__PURE__ */ c((r, t, i, s) => (mf(r, t, "write to private field"), t.set(r, i), i), "__privateSet$3"), Cr, Ea;
let ys = (Ea = class extends j {
  constructor() {
    super(...arguments), this.private = !0, this.rooms = !0, this.badgeQuery = new be(this), this.handleBadgeRefresh = async () => {
      this.badgeQuery.result.isRefetching || await this.badgeQuery.result.refetch();
    }, this.handleRealtimeMessage = (t) => {
      this.handleBadgeRefresh();
    }, this.handleRealtimeSeenBy = (t) => {
      this.handleBadgeRefresh();
    }, h4(this, Cr);
  }
  async willUpdate(t) {
    var i;
    if (t.has("weavy") && this.weavy) {
      const s = [];
      this.rooms && s.push(ct.ChatRoom), this.private && s.push(ct.PrivateChat), this.bot && s.push(ct.BotChat), this.badgeQuery.trackQuery(m1(this.weavy, s, this.bot), !0), (i = ey(this, Cr)) == null || i.call(this), this.weavy.subscribe(null, "message_created", this.handleRealtimeMessage), this.weavy.subscribe(null, "app_marked", this.handleBadgeRefresh), iy(this, Cr, () => {
        var n, a;
        (n = this.weavy) == null || n.unsubscribe(null, "message_created", this.handleRealtimeMessage), (a = this.weavy) == null || a.unsubscribe(null, "app_marked", this.handleBadgeRefresh), iy(this, Cr, void 0);
      });
    }
  }
  render() {
    const { data: t, isPending: i } = this.badgeQuery.result ?? {}, s = t ? t.count : 0;
    return p`
      ${!i && s > 0 ? p` <span class="wy-badge wy-badge-danger wy-badge-reveal">${s}</span> ` : C}
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.weavy && this.requestUpdate("weavy");
  }
  disconnectedCallback() {
    var t;
    (t = ey(this, Cr)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Ea, "WyMessengerBadge"), Ea);
Cr = /* @__PURE__ */ new WeakMap();
ys.styles = J;
gc([
  Qt({ context: Xt, subscribe: !0 }),
  D()
], ys.prototype, "weavy", 2);
gc([
  w({ attribute: !1, type: Boolean })
], ys.prototype, "private", 2);
gc([
  w({ attribute: !1, type: Boolean })
], ys.prototype, "rooms", 2);
gc([
  w()
], ys.prototype, "bot", 2);
ys = gc([
  B("wy-messenger-badge")
], ys);
var p4 = Object.defineProperty, u4 = Object.getOwnPropertyDescriptor, Rl = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? u4(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && p4(t, i, n), n;
}, "__decorateClass$a");
const n3 = new Map(
  Object.entries({
    [ze.ChatRoom]: ct.ChatRoom,
    [ze.PrivateChat]: ct.PrivateChat,
    [ct.ChatRoom]: ze.ChatRoom,
    [ct.PrivateChat]: ze.PrivateChat
  })
), a3 = new Map(
  Object.entries({
    [ze.BotChat]: ct.BotChat,
    [ct.BotChat]: ze.BotChat
  })
), y4 = "wy-messenger";
var Oa;
let tr = (Oa = class extends at {
  constructor() {
    super(), this.productType = ho.Messenger, this.appTypes = [ct.ChatRoom, ct.PrivateChat], this.conversationId = null, this.conversationQuery = new be(this), this.botQuery = new be(this), this.persistState = new Do(this), this.releaseFocusEvent = () => new CustomEvent("release-focus", { bubbles: !0, composed: !0 }), new fi(this, tr.styles);
  }
  get bot() {
    return super.bot;
  }
  set bot(t) {
    super.bot = t, this._bot ? this.appTypes = [ct.BotChat] : this.appTypes = [ct.ChatRoom, ct.PrivateChat], this.conversationId = null;
  }
  /**
   * Checks if a conversation belongs to Messenger.
   *
   * @param conversation {AppRef | AppType | number} - The conversation or id to check if it belongs to Messenger.
   * @returns Promise<Boolean>
   */
  async conversationBelongsToMessenger(t) {
    return this.weavy ? !!await av(this.weavy, t, this.appTypes, this.bot) : !1;
  }
  /**
   * Deselects any active conversation.
   */
  clearConversation() {
    this.conversationId = null;
  }
  async willUpdate(t) {
    var i, s;
    if (super.willUpdate(t), (t.has("weavy") || t.has("bot") || t.has("user")) && this.weavy && this.user && this.persistState.observe(["conversationId"], this.bot || "messenger", `u${(i = this.user) == null ? void 0 : i.id}`), t.has("link") && (s = this.link) != null && s.app)
      if (await this.conversationBelongsToMessenger(this.link.app))
        this.conversationId = this.link.app.id;
      else
        throw new Error("Not a conversation");
  }
  update(t) {
    super.update(t), (t.has("conversationId") || t.has("weavy")) && this.weavy && (this.conversationId ? this.conversationQuery.trackQuery(nv(this.weavy, this.conversationId, this.appTypes)) : this.conversationQuery.untrackQuery());
  }
  render() {
    var n;
    const { isPending: t } = ((n = this.weavy) == null ? void 0 : n.network) ?? { isPending: !0 }, { data: i, isPending: s } = this.conversationQuery.result ?? { isPending: t };
    return p`
      <div class="wy-messenger-layout">
        <wy-conversation-list
          class="wy-scroll-y"
          .conversationTypes=${this.appTypes}
          .bot=${this.bot}
          .avatarUser=${this.botUser}
          .name=${this.name}
          conversationId=${lt(this.conversationId !== null ? this.conversationId : void 0)}
          @conversation-selected=${(a) => this.conversationId = a.detail.id}
        ></wy-conversation-list>

        <div
          class="wy-messenger-conversation wy-scroll-y"
          data-conversation-id=${this.conversationId !== null ? this.conversationId : ""}
        >
          <wy-conversation-appbar
            .conversationId=${this.conversationId || void 0}
            .conversation=${i}
            @release-focus=${() => this.dispatchEvent(this.releaseFocusEvent())}
          >
            <span slot="action" class="wy-close-conversation">
              <wy-button kind="icon" @click=${() => this.conversationId = null}>
                <wy-icon name="back"></wy-icon>
              </wy-button>
              <wy-messenger-badge slot="badge" .bot=${this.bot}></wy-messenger-badge>
            </span>
          </wy-conversation-appbar>

          ${B5(
      this.conversationId ? s ? p`<wy-empty><wy-spinner reveal></wy-spinner></wy-empty>` : this.bot ? p`<wy-conversation
                      .conversationId=${this.conversationId}
                      .conversation=${i}
                    ></wy-conversation>` : p`<wy-conversation-extended
                      .conversationId=${this.conversationId}
                      .conversation=${i}
                    ></wy-conversation-extended>` : p`<wy-empty noNetwork>${$("Select a conversation")}</wy-empty>`
    )}
        </div>
      </div>
    `;
  }
}, c(Oa, "WyMessenger"), Oa);
tr.styles = [We, J, U5, po, fs];
Rl([
  D()
], tr.prototype, "appTypes", 2);
Rl([
  w({ type: String })
], tr.prototype, "bot", 1);
Rl([
  D()
], tr.prototype, "conversationId", 2);
tr = Rl([
  B(y4),
  st()
], tr);
const w4 = Z`.wy-meta{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}.wy-meta-sm{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))}`, f4 = Z`.wy-notification.wy-read{opacity:var(--wy-opacity-muted, 60%);--wy-component-color: var(--wy-outline, var(--wy-neutral-variant-50, #72777e))}`;
var m4 = Object.defineProperty, v4 = Object.getOwnPropertyDescriptor, bc = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? v4(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && m4(t, i, n), n;
}, "__decorateClass$9"), Aa;
let ws = (Aa = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.selected = !1, this.standalone = !1;
  }
  dispatchSelect(t) {
    const i = new CustomEvent("select", {
      detail: { notificationId: this.notificationId }
    });
    return this.dispatchEvent(i);
  }
  async dispatchLink(t) {
    return await aw(this, this.weavy, this.notification);
  }
  dispatchMark(t, i) {
    if (t.stopPropagation(), i === !!this.notification.is_unread) {
      const s = new CustomEvent("mark", {
        detail: { notificationId: this.notificationId, markAsRead: i }
      });
      return this.dispatchEvent(s);
    }
    return !0;
  }
  dispatchClose() {
    if (this.standalone) {
      const t = new CustomEvent("close", {
        bubbles: !0
      });
      return this.dispatchEvent(t);
    }
    return !0;
  }
  render() {
    var u, y;
    const t = this.notification.created_at ? new Intl.DateTimeFormat((u = this.weavy) == null ? void 0 : u.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.notification.created_at)
    ) : "", i = this.notification.created_at ? mc((y = this.weavy) == null ? void 0 : y.locale, new Date(this.notification.created_at)) : "", s = this.notification.actor, { title: n, titleHtml: a, detail: o } = cw(this.notification), l = this.standalone ? C : p`
          <div class="wy-item-actions wy-item-right">
            <wy-button
              kind="icon-inline"
              @click=${(m) => this.dispatchMark(m, !!this.notification.is_unread) && this.dispatchClose()}
              title=${this.notification.is_unread ? $("Mark as read") : $("Mark as unread")}
            >
              <wy-icon
                name=${this.notification.is_unread ? "read" : "unread"}
                color=${this.notification.is_unread ? "" : "secondary"}
              ></wy-icon>
            </wy-button>
          </div>
        `, d = this.standalone ? C : p`
          <time class="wy-meta" datetime=${this.notification.created_at.toString()} title=${t}>
            ${i}
          </time>
        `;
    return p`
      <div
        class=${Rt({
      "wy-item wy-list-item-lg wy-item-hover wy-notification": !0,
      "wy-unread": !this.standalone && !!this.notification.is_unread,
      "wy-read": !this.standalone && !this.notification.is_unread,
      "wy-active": !this.standalone && this.selected
    })}
        tabindex="0"
        @click=${(m) => this.dispatchSelect(m) && this.dispatchMark(m, !0) && this.dispatchClose() && this.dispatchLink(m)}
        @keydown=${xe}
        @keyup=${je}
      >
        <div class="wy-item-inner">
          <wy-avatar
            class="wy-item-top"
            src=${lt(s == null ? void 0 : s.avatar_url)}
            name=${lt(s == null ? void 0 : s.display_name)}
            presence=${(s == null ? void 0 : s.presence) || "away"}
            ?isBot=${s == null ? void 0 : s.is_bot}
            id=${lt(s == null ? void 0 : s.id)}
            size=${48}
          ></wy-avatar>

          <div class="wy-item-rows wy-item-rows-compact">
            <div class="wy-item-row">
              <div class="wy-item-title-lg" title=${n + (o ? `: "${o}"` : "")}>
                ${a}${o ? p`: <q class="wy-item-quote">${o}</q> ` : C}
              </div>
            </div>
            <div class="wy-item-row"> ${d} ${l} </div>
          </div>

          ${this.standalone ? p`
                <wy-button
                  kind="icon"
                  @click=${(m) => this.dispatchMark(m, !!this.notification.is_unread) && this.dispatchClose()}
                >
                  <wy-icon name="close"></wy-icon>
                </wy-button>
              ` : C}
        </div>
      </div>
    `;
  }
}, c(Aa, "WyNotificationListItem"), Aa);
ws.styles = [te, Rw, w4, f4];
bc([
  w({ type: Number })
], ws.prototype, "notificationId", 2);
bc([
  w({ type: Boolean, reflect: !0 })
], ws.prototype, "selected", 2);
bc([
  w({ type: Boolean })
], ws.prototype, "standalone", 2);
bc([
  w({ attribute: !1 })
], ws.prototype, "notification", 2);
ws = bc([
  B("wy-notification-list-item"),
  st()
], ws);
var g4 = Object.defineProperty, b4 = Object.getOwnPropertyDescriptor, vf = /* @__PURE__ */ c((r) => {
  throw TypeError(r);
}, "__typeError$2"), dp = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? b4(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && g4(t, i, n), n;
}, "__decorateClass$8"), gf = /* @__PURE__ */ c((r, t, i) => t.has(r) || vf("Cannot " + i), "__accessCheck$2"), sy = /* @__PURE__ */ c((r, t, i) => (gf(r, t, "read from private field"), i ? i.call(r) : t.get(r)), "__privateGet$2"), x4 = /* @__PURE__ */ c((r, t, i) => t.has(r) ? vf("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(r) : t.set(r, i), "__privateAdd$2"), ry = /* @__PURE__ */ c((r, t, i, s) => (gf(r, t, "write to private field"), t.set(r, i), i), "__privateSet$2"), _r, La;
let ao = (La = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.typeFilter = ne.All, this.notificationsQuery = new Ri(this), this.infiniteScroll = new Ii(this), this.pagerRef = rt(), this.handleRefresh = (t) => {
      this.notificationsQuery.result.refetch();
    }, this.handlePresenceChange = (t) => {
      this.weavy && (Array.isArray(t) || (t = [parseInt(t)]), _t(this.weavy.queryClient, ["notifications", "list"], void 0, (i) => {
        const s = i.actor;
        s.presence = t.indexOf(s.id) != -1 ? "active" : "away", i.actor = s;
      }));
    }, x4(this, _r);
  }
  async markAllAsRead() {
    var s, n, a;
    const t = await this.whenWeavy(), i = (n = K2(t, ne.All, (s = this.app) == null ? void 0 : s.id)) == null ? void 0 : n.id;
    await ((a = this.markNotificationsMutation) == null ? void 0 : a.mutate({ notificationId: i }));
  }
  async handleMark(t, i) {
    var s;
    await ((s = this.markNotificationMutation) == null ? void 0 : s.mutate({ markAsRead: t, notificationId: i }));
  }
  handleSelect(t) {
    this.notificationId = t.id;
  }
  async willUpdate(t) {
    var s, n;
    var i;
    super.willUpdate(t), (t.has("weavy") || t.has("typeFilter") || t.has("app")) && this.weavy && this.notificationsQuery.trackInfiniteQuery(Q2(this.weavy, this.typeFilter, (s = this.app) == null ? void 0 : s.id)), (t.has("weavy") || t.has("app")) && this.weavy && (this.markNotificationsMutation = Y2(this.weavy, (n = this.app) == null ? void 0 : n.id)), t.has("weavy") && this.weavy && (this.markNotificationMutation = Xw(this.weavy), (i = sy(this, _r)) == null || i.call(this), this.weavy.subscribe(null, "online", this.handlePresenceChange), this.weavy.subscribe(null, "notification_created", this.handleRefresh), this.weavy.subscribe(null, "notification_updated", this.handleRefresh), this.weavy.subscribe(null, "notifications_marked", this.handleRefresh), ry(this, _r, () => {
      var a, o, l, d;
      (a = this.weavy) == null || a.unsubscribe(null, "online", this.handlePresenceChange), (o = this.weavy) == null || o.unsubscribe(null, "notification_created", this.handleRefresh), (l = this.weavy) == null || l.unsubscribe(null, "notification_updated", this.handleRefresh), (d = this.weavy) == null || d.unsubscribe(null, "notifications_marked", this.handleRefresh), ry(this, _r, void 0);
    }));
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.notificationsQuery.result, this.pagerRef.value);
  }
  renderNotifications(t, i) {
    if (i) {
      const s = ms(i);
      return Re(
        s,
        (n) => n == null ? void 0 : n.id,
        (n) => [
          p`<wy-notification-list-item
              notificationId=${n.id}
              .notification=${n}
              .selected=${this.notificationId == n.id}
              @select=${(a) => this.handleSelect(n)}
              @mark=${(a) => this.handleMark(a.detail.markAsRead, a.detail.notificationId)}
            ></wy-notification-list-item>`
        ]
      );
    }
    return C;
  }
  render() {
    var n;
    const { data: t, hasNextPage: i, isPending: s } = this.notificationsQuery.result ?? {};
    return p`
      ${this.user ? p`
            <div class="wy-pane-toolbar">
              <wy-buttons tabs>
                <wy-button
                  ?active=${this.typeFilter === ne.All}
                  @click=${() => this.typeFilter = ne.All}
                  kind="tab"
                  small
                >
                  ${$("All")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === ne.Activity}
                  @click=${() => this.typeFilter = ne.Activity}
                  kind="tab"
                  small
                >
                  ${$("Activities")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === ne.Mention}
                  @click=${() => this.typeFilter = ne.Mention}
                  kind="tab"
                  small
                >
                  ${$("Mentions")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === ne.Reaction}
                  @click=${() => this.typeFilter = ne.Reaction}
                  kind="tab"
                  small
                >
                  ${$("Reactions")}
                </wy-button>
              </wy-buttons>
              <wy-button
                slot="buttons"
                kind="icon"
                @click=${() => this.markAllAsRead()}
                title=${$("Mark all as read")}
              >
                <wy-icon name="check-all"></wy-icon>
              </wy-button>
              <slot name="buttons"></slot>
            </div>

            <div class="wy-notifications">
              ${!s && this.user && t ? (n = t.pages[0]) != null && n.count ? this.renderNotifications(this.user, t) : p`
                      <div class="wy-pane-body">
                        <div class="wy-pane-group">
                          <slot name="empty">
                            <wy-empty>${$("No updates yet.")}</wy-empty>
                          </slot>
                        </div>
                      </div>
                    ` : p`<wy-empty><wy-spinner padded></wy-spinner></wy-empty>`}
              ${i ? p`<div ${X(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
            </div>
          ` : p`<wy-empty class="wy-pane"><wy-spinner overlay></wy-spinner></wy-empty>`}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = sy(this, _r)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(La, "WyNotificationList"), La);
_r = /* @__PURE__ */ new WeakMap();
ao.styles = [
  J,
  ir,
  Z`
      :host {
        position: relative;
      }
    `
];
dp([
  w({ type: Number })
], ao.prototype, "notificationId", 2);
dp([
  w()
], ao.prototype, "typeFilter", 2);
ao = dp([
  B("wy-notification-list"),
  st()
], ao);
var $4 = Object.defineProperty, k4 = Object.getOwnPropertyDescriptor, C4 = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? k4(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && $4(t, i, n), n;
}, "__decorateClass$7");
const _4 = "wy-notifications";
var Ra;
let dl = (Ra = class extends at {
  constructor() {
    super(), this.componentType = qe.Unknown, this.notificationsRef = rt(), new fi(this, dl.styles);
  }
  /**
   * Mark all events as read.
   */
  markAllAsRead() {
    var t;
    (t = this.notificationsRef.value) == null || t.markAllAsRead();
  }
  render() {
    return p`
      ${this.user ? p` <wy-notification-list ${X(this.notificationsRef)}></wy-notification-list> ` : p`
            <wy-empty>
              <wy-spinner padded reveal></wy-spinner>
            </wy-empty>
          `}
    `;
  }
}, c(Ra, "WyNotifications"), Ra);
dl.styles = [We, J, po, pc, fs];
dl = C4([
  B(_4),
  st()
], dl);
var P4 = Object.defineProperty, M4 = Object.getOwnPropertyDescriptor, xc = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? M4(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && P4(t, i, n), n;
}, "__decorateClass$6"), Ia;
let jo = (Ia = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.show = !1, this.viewportRef = rt();
  }
  close() {
    var t;
    this.show = !1;
    try {
      (t = this.viewportRef.value) == null || t.hidePopover();
    } catch {
    }
  }
  handleClose(t) {
    (t.type === "toggle" && t.newState === "closed" || t.type === "click") && (this.show = !1, this.dispatchEvent(new CustomEvent("hide")), this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 })));
  }
  render() {
    return p`
      <div class="wy-toasts" tabindex="0" ${X(this.viewportRef)} ?hidden=${!this.show} popover>
        <slot></slot>
      </div>
    `;
  }
  willUpdate(t) {
    var i, s, n;
    if (t.has("show"))
      try {
        this.show ? (i = this.viewportRef.value) == null || i.showPopover() : (s = this.viewportRef.value) == null || s.hidePopover();
      } catch {
      }
    t.has("show") && this.show && ((n = this.viewportRef.value) == null || n.focus());
  }
  firstUpdated(t) {
    var i, s;
    (i = this.viewportRef.value) == null || i.addEventListener(this.viewportRef.value.popover ? "toggle" : "click", (n) => {
      this.handleClose(n);
    }), this.show && ((s = this.viewportRef.value) == null || s.showPopover());
  }
  disconnectedCallback() {
    super.disconnectedCallback();
  }
}, c(Ia, "WyToasts"), Ia);
jo.styles = [
  J,
  Z`
      :host {
        display: contents;
      }
    `
];
xc([
  w({ type: Boolean })
], jo.prototype, "show", 2);
jo = xc([
  B("wy-toasts")
], jo);
var Ta;
let Vi = (Ta = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.toastRef = rt(), this.show = !1, this.duration = Vi.defaultDuration;
  }
  async close(t = !1) {
    this.show = !1, await new Promise((i) => requestAnimationFrame(i)), this.toastRef.value && await Od(this.toastRef.value, !1), this.dispatchEvent(new CustomEvent("closed", { detail: { silent: t } })), this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }));
  }
  async willUpdate(t) {
    t.has("show") && (this.timeout && (window.clearTimeout(this.timeout), this.timeout = void 0), this.show && this.duration > 0 && this.duration < 1 / 0 && (this.timeout = window.setTimeout(() => this.close(!0), this.duration)));
  }
  render() {
    return p`
      <div
        ${X(this.toastRef)}
        class="wy-toast wy-fade ${this.show ? "wy-show" : ""}"
        @close=${() => this.close()}
        @keyup=${qh}
      >
        <slot></slot>
      </div>
    `;
  }
  firstUpdated() {
    requestAnimationFrame(() => {
      this.show = !0;
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.timeout && (window.clearTimeout(this.timeout), this.timeout = void 0);
  }
}, c(Ta, "WyToast"), Ta);
Vi.styles = [
  J,
  Z`
      :host {
        display: contents;
      }
    `
];
Vi.defaultDuration = 5e4;
xc([
  D()
], Vi.prototype, "show", 2);
xc([
  w({ type: Number })
], Vi.prototype, "duration", 2);
Vi = xc([
  B("wy-toast")
], Vi);
var z4 = Object.defineProperty, S4 = Object.getOwnPropertyDescriptor, bf = /* @__PURE__ */ c((r) => {
  throw TypeError(r);
}, "__typeError$1"), go = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? S4(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && z4(t, i, n), n;
}, "__decorateClass$5"), xf = /* @__PURE__ */ c((r, t, i) => t.has(r) || bf("Cannot " + i), "__accessCheck$1"), ny = /* @__PURE__ */ c((r, t, i) => (xf(r, t, "read from private field"), i ? i.call(r) : t.get(r)), "__privateGet$1"), E4 = /* @__PURE__ */ c((r, t, i) => t.has(r) ? bf("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(r) : t.set(r, i), "__privateAdd$1"), ay = /* @__PURE__ */ c((r, t, i, s) => (xf(r, t, "write to private field"), t.set(r, i), i), "__privateSet$1"), Pr;
const O4 = "wy-notification-toasts";
var Fa;
let Bi = (Fa = class extends at {
  constructor() {
    super(), this.componentType = qe.Unknown, this.typeFilter = ne.All, this.appearance = "internal", this.requestUserPermission = !1, this.duration = Vi.defaultDuration, this._notifications = [], this._nativeNotifications = [], this.handleEvent = async (t) => {
      var i;
      if (this.typeFilter === ne.All || this.typeFilter === t.notification.type)
        if (t.action === "notification_deleted")
          this.removeNotification(t.notification.id), this.closeNativeNotification(t.notification.id);
        else {
          const { title: s, detail: n } = cw(t.notification), a = {
            ...t.notification,
            title: s,
            detail: n,
            lang: (i = this.weavy) == null ? void 0 : i.locale
          };
          a.link.bot = ow(a);
          const o = new CustomEvent("wy-notification", {
            bubbles: !0,
            composed: !0,
            cancelable: !0,
            detail: a
          });
          (!this.requestUserPermission && this.appearance !== "native" || await this.hasUserPermission() ? this.dispatchEvent(o) : !1) && (t.action === "notification_created" && t.notification.is_unread ? await this.addOrUpdateNotification(t.notification) : await this.updateNotification(t.notification), await this.addOrUpdateNativeNotification(a));
        }
    }, E4(this, Pr), new fi(this, Bi.styles);
  }
  async addOrUpdateNotification(t) {
    if (!this.requestUserPermission || await this.hasUserPermission()) {
      const i = [...this._notifications], s = i.findIndex((n) => n.id === t.id);
      s !== -1 ? (i.splice(s, 1, t), this._notifications = i) : (i.push(t), this._notifications = i);
    }
  }
  async updateNotification(t) {
    if (!this.requestUserPermission || await this.hasUserPermission()) {
      const i = [...this._notifications], s = i.findIndex((n) => n.id === t.id);
      s !== -1 && (i.splice(s, 1, t), this._notifications = i);
    }
  }
  removeNotification(t) {
    const i = [...this._notifications], s = i.findIndex((n) => n.id === t);
    s !== -1 && (i.splice(s, 1), this._notifications = i);
  }
  async addOrUpdateNativeNotification(t) {
    if (this.appearance === "native" && await this.hasUserPermission()) {
      const i = this.removeNativeNotification(t.id), s = t.actor, n = new Notification(t.title, {
        tag: `wy-${t.id}`,
        lang: t.lang,
        body: t.detail,
        icon: s.avatar_url,
        // @ts-expect-error Property `renotify` not available in ts types yet
        renotify: i && e.notification.is_unread
      });
      n.onclick = async () => {
        this.handleMark(!0, t.id), await aw(this, this.weavy, t);
      }, n.onclose = () => {
        this.removeNativeNotification(t.id);
      }, this._nativeNotifications = [...this._nativeNotifications, n];
    }
  }
  removeNativeNotification(t) {
    const i = [...this._nativeNotifications], s = i.findIndex(
      (n) => n.tag === `wy-${t}`
    );
    return s ? (i.splice(s, 1), this._nativeNotifications = i, !0) : !1;
  }
  closeNativeNotification(t) {
    const i = this._nativeNotifications.findIndex(
      (s) => s.tag === `wy-${t}`
    );
    return i ? (this._nativeNotifications[i].close(), !0) : !1;
  }
  async hasUserPermission() {
    if (!("Notification" in window))
      console.error("This browser does not support desktop notifications");
    else if (!window.isSecureContext)
      console.error(
        `Desktop notifications can only be used in secure contexts. 
        See https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts`
      );
    else {
      if (Notification.permission === "granted")
        return !0;
      if (Notification.permission !== "denied")
        return await Notification.requestPermission() === "granted";
    }
    return !1;
  }
  clearNotifications() {
    this._notifications = [];
  }
  async handleMark(t, i) {
    var s;
    await ((s = this.markNotificationMutation) == null ? void 0 : s.mutate({ markAsRead: t, notificationId: i }));
  }
  async willUpdate(t) {
    var i;
    super.willUpdate(t), t.has("weavy") && this.weavy && (this.markNotificationMutation = Xw(this.weavy), (i = ny(this, Pr)) == null || i.call(this), this.weavy.subscribe(null, "notification_created", this.handleEvent), this.weavy.subscribe(null, "notification_updated", this.handleEvent), ay(this, Pr, () => {
      var s, n;
      (s = this.weavy) == null || s.unsubscribe(null, "notification_created", this.handleEvent), (n = this.weavy) == null || n.unsubscribe(null, "notification_updated", this.handleEvent), ay(this, Pr, void 0);
    })), (t.has("requestUserPermission") && this.requestUserPermission || t.has("appearance") && this.appearance === "native") && this.hasUserPermission();
  }
  render() {
    return p`
      ${this.user && this.appearance === "internal" ? p`
            <wy-toasts ?show=${!!this._notifications.length} @hide=${this.clearNotifications}>
              ${Re(
      this._notifications,
      (t) => t.id,
      (t) => p`
                    <wy-toast
                      duration=${this.duration}
                      @closed=${(i) => {
        i.detail.silent || this.handleMark(!0, t.id), this.removeNotification(t.id);
      }}
                    >
                      <wy-notification-list-item standalone .notification=${t}></wy-notification-list-item>
                    </wy-toast>
                  `
    )}
            </wy-toasts>
          ` : C}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = ny(this, Pr)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Fa, "WyNotificationToasts"), Fa);
Pr = /* @__PURE__ */ new WeakMap();
Bi.styles = [We, Fh, fs];
go([
  w()
], Bi.prototype, "typeFilter", 2);
go([
  w()
], Bi.prototype, "appearance", 2);
go([
  w({ type: Boolean })
], Bi.prototype, "requestUserPermission", 2);
go([
  w({ type: Number })
], Bi.prototype, "duration", 2);
go([
  D()
], Bi.prototype, "_notifications", 2);
Bi = go([
  B(O4),
  st()
], Bi);
function A4(r, t) {
  const i = r.queryClient, n = {
    mutationKey: ["posts", t.id],
    mutationFn: /* @__PURE__ */ c(async ({ id: a }) => {
      if (!(await r.fetch("/api/posts/" + a + "/trash", { method: "POST" })).ok)
        throw new Error();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (a) => {
      nt(
        i,
        { queryKey: n.mutationKey, exact: !1 },
        a.id,
        (o) => Object.assign(o, { is_trashed: !0 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((a, o) => {
      nt(
        i,
        { queryKey: n.mutationKey, exact: !1 },
        o.id,
        (l) => Object.assign(l, a)
      );
    }, "onSuccess")
  };
  return n;
}
c(A4, "getTrashPostMutationOptions");
function L4(r, t) {
  return new bt(r.queryClient, A4(r, t));
}
c(L4, "getTrashPostMutation");
function R4(r, t) {
  const i = r.queryClient, n = {
    mutationKey: ["posts", t.id],
    mutationFn: /* @__PURE__ */ c(async ({ id: a }) => {
      const o = await r.fetch("/api/posts/" + a + "/restore", { method: "POST" });
      if (!o.ok) {
        const l = await o.json();
        throw new Error(l.detail || l.title, { cause: l });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (a) => {
      nt(
        i,
        { queryKey: n.mutationKey, exact: !1 },
        a.id,
        (o) => Object.assign(o, { is_trashed: !1 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((a, o) => {
      nt(
        i,
        { queryKey: n.mutationKey, exact: !1 },
        o.id,
        (l) => Object.assign(l, { is_trashed: !1 })
      );
    }, "onSuccess")
  };
  return n;
}
c(R4, "getRestorePostMutationOptions");
function I4(r, t) {
  return new bt(r.queryClient, R4(r, t));
}
c(I4, "getRestorePostMutation");
function T4(r, t) {
  const i = r.queryClient, s = ["posts", t.id];
  return {
    mutationKey: s,
    mutationFn: /* @__PURE__ */ c(async ({ id: a, subscribe: o }) => {
      const l = await r.fetch(
        `/api/posts/${a}/${o ? "subscribe" : "unsubscribe"}`,
        { method: "POST" }
      );
      if (!l.ok) {
        const d = await l.json();
        throw new Error(d.detail || d.title, { cause: d });
      }
      return l.json();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (a) => {
      nt(
        i,
        { queryKey: s, exact: !1 },
        a.id,
        (o) => Object.assign(o, { is_subscribed: a.subscribe })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((a, o) => {
      nt(
        i,
        { queryKey: s, exact: !1 },
        o.id,
        (l) => Object.assign(l, a)
      );
    }, "onSuccess")
  };
}
c(T4, "getSubscribePostMutationOptions");
function F4(r, t) {
  return new bt(r.queryClient, T4(r, t));
}
c(F4, "getSubscribePostMutation");
function D4(r, t) {
  return {
    initialPageParam: 0,
    queryKey: ["posts", t],
    queryFn: /* @__PURE__ */ c(async (i) => {
      const s = i.pageParam, n = "/api/apps/" + t + "/posts?order_by=id+desc&skip=" + s, o = await (await r.fetch(n)).json();
      return o.data = o.data || [], o;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ c((i) => {
      if (i.end && i.end < i.count)
        return i.end;
    }, "getNextPageParam")
  };
}
c(D4, "getPostsOptions");
function H4(r, t) {
  return {
    mutationFn: /* @__PURE__ */ c(async (s) => (await r.fetch("/api/posts/" + s.id, {
      method: "PATCH",
      body: JSON.stringify({
        text: s.text,
        blobs: s.blobs,
        attachments: s.attachments,
        meeting_id: s.meetingId,
        options: s.pollOptions.filter((a) => a.text.trim() !== "").map((a) => ({ id: a.id, text: a.text })),
        embed_id: s.embed || null
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ c(async (s) => {
      _t(r.queryClient, ["posts", s.appId], s.id, (n) => {
        n.text = s.text, n.html = s.text;
      });
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((s, n) => {
      n.id && _t(r.queryClient, ["posts", n.appId], n.id, (a) => {
        a.text = s.text, a.html = s.html, a.attachments = s.attachments, a.embed = s.embed, a.meeting = s.meeting, a.updated_at = s.updated_at, a.updated_by = s.updated_by, a.options = s.options;
      });
    }, "onSuccess")
  };
}
c(H4, "getUpdatePostMutationOptions");
function V4(r, t) {
  const i = r.queryClient;
  return {
    mutationFn: /* @__PURE__ */ c(async (n) => (await r.fetch("/api/apps/" + n.appId + "/posts", {
      method: "POST",
      body: JSON.stringify({
        text: n.text,
        blobs: n.blobs,
        meeting_id: n.meetingId,
        options: n.pollOptions.filter((o) => o.text.trim() !== "").map((o) => ({ text: o.text })),
        embed_id: n.embed
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ c(async (n) => {
      const a = ["posts", n.appId];
      await i.cancelQueries({ queryKey: a });
      const o = Bs(r.queryClient, a, !1);
      if (n.user) {
        const l = {
          id: o ? o.id - 1 : -1,
          app: { id: n.appId },
          is_subscribed: !0,
          is_trashed: !1,
          text: n.text,
          html: n.text,
          plain: n.text,
          created_by: n.user,
          created_at: (/* @__PURE__ */ new Date()).toUTCString(),
          attachments: { count: 0 },
          reactions: { count: 0 },
          is_starred: !1,
          comments: { count: 0 }
        };
        os(i, ["posts", n.appId], l, { descending: !0 });
      }
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((n) => {
      const a = ["posts", n.app.id];
      if (!ml(r.queryClient, a, n.id)) {
        const l = Bs(r.queryClient, a, !0);
        l ? _t(r.queryClient, a, l.id, (d) => {
          d.id = n.id, d.app = n.app, d.text = n.text, d.html = n.html, d.embed = n.embed, d.meeting = n.meeting, d.attachments = n.attachments, d.options = n.options, d.created_at = n.created_at, d.created_by = n.created_by, d.updated_at = n.updated_at, d.updated_by = n.updated_by;
        }) : os(r.queryClient, a, n);
      }
    }, "onSuccess")
  };
}
c(V4, "getAddPostMutationOptions");
var B4 = Object.defineProperty, U4 = Object.getOwnPropertyDescriptor, $f = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? U4(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && B4(t, i, n), n;
}, "__decorateClass$4"), Da;
let Wo = (Da = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this);
  }
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: {} });
    return this.dispatchEvent(t);
  }
  render() {
    return p`
      <div class="wy-item">
        <div class="wy-item-body">${$("Post was trashed.")}</div>
        <wy-button @click=${() => this.dispatchRestore()} class="wy-button-variant">${$("Undo")}</wy-button>
      </div>
    `;
  }
}, c(Da, "WyPostTrashed"), Da);
Wo.styles = J;
$f([
  w({ type: Number })
], Wo.prototype, "postId", 2);
Wo = $f([
  B("wy-post-trashed"),
  st()
], Wo);
var q4 = Object.defineProperty, N4 = Object.getOwnPropertyDescriptor, Wt = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? N4(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && q4(t, i, n), n;
}, "__decorateClass$3"), Ha;
let Mt = (Ha = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.html = "", this.text = "", this.attachments = [], this.pollOptions = [], this.reactions = [], this.commentCount = 0, this.seenBy = [], this.showComments = !1, this.loadComments = !1, this.highlight = !1, this.isCommentLinked = !1, this.previewRef = rt(), this.highlightRef = rt();
  }
  dispatchVote(t) {
    const i = new CustomEvent("vote", { detail: { id: t } });
    return this.dispatchEvent(i);
  }
  dispatchSubscribe(t) {
    const i = new CustomEvent("subscribe", { detail: { id: this.postId, subscribe: t } });
    return this.dispatchEvent(i);
  }
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  dispatchEdit(t) {
    const i = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(i);
  }
  handleCommentsClick(t) {
    t.preventDefault(), this.showComments = !this.showComments, this.loadComments = !0;
  }
  willUpdate(t) {
    t.has("link") && (this.highlight = !!(this.link && gl(this.link, Ne.Post, { id: this.postId })), this.isCommentLinked = !!(this.link && nw(this.link, Ne.Post, { id: this.postId }, Ne.Comment))), t.has("isCommentLinked") && this.isCommentLinked && (this.loadComments = !0, this.showComments = !0);
  }
  render() {
    var o, l, d, u, y, m, f, g;
    const t = (o = this.attachments) == null ? void 0 : o.filter((x) => x.kind === "image" && x.thumbnail_url), i = (l = this.attachments) == null ? void 0 : l.filter((x) => x.kind !== "image" || !x.thumbnail_url), s = new Intl.DateTimeFormat((d = this.weavy) == null ? void 0 : d.locale, {
      dateStyle: "full",
      timeStyle: "short"
    }).format(new Date(this.createdAt)), n = mc((u = this.weavy) == null ? void 0 : u.locale, new Date(this.createdAt)), a = this.modifiedAt && this.weavy ? new Intl.DateTimeFormat(this.weavy.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.modifiedAt)
    ) : "";
    return this.postId < 0 ? p`<div class="wy-post">
          <div class="wy-item">
            <wy-avatar
              .src="${this.createdBy.avatar_url}"
              .isBot=${this.createdBy.is_bot}
              .size=${48}
              .name=${this.createdBy.display_name}
            ></wy-avatar>
            <div class="wy-item-rows">
              <div class="wy-item-row">
                <div class="wy-item-title"><span class="wy-placeholder">${this.createdBy.display_name}</span></div>
              </div>
              <div class="wy-item-row">
                <div class="wy-item-text">
                  <time class="wy-placeholder">${n}</time>
                </div>
              </div>
            </div>
          </div>
          <div class="wy-post-body">
            <div class="wy-content"><wy-skeleton .text=${this.text}></wy-skeleton></div>
          </div>
        </div>` : p`
          <div class="wy-post" part=${Yt({ "wy-highlight": this.highlight && !this.isCommentLinked })} ${X(
      this.highlightRef
    )}>
            <div class="wy-item">
              <wy-avatar .src="${this.createdBy.avatar_url}" .isBot=${this.createdBy.is_bot} .size=${48} .name=${this.createdBy.display_name}></wy-avatar>
              <div class="wy-item-rows">
                <div class="wy-item-row">
                  <div class="wy-item-title">${this.createdBy.display_name}</div>
                </div>
                <div class="wy-item-row">
                  <div class="wy-item-text">
                    <time datetime=${this.createdAt} title=${s}>${n}</time>
                    ${this.modifiedAt ? p`<time datetime="${this.modifiedAt}" title=${a}> · ${$("edited")}</time>` : C}
                  </div>
                  </div>
                </div>

                <div class="wy-item-actions wy-item-top">
                  <wy-dropdown>
                    ${this.isSubscribed ? p`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                            <wy-icon name="bell-off"></wy-icon>
                            ${$("Unsubscribe")}
                          </wy-dropdown-item>` : p`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                            <wy-icon name="bell"></wy-icon>
                            ${$("Subscribe")}
                          </wy-dropdown-item>`}
                    ${this.user && this.user.id === this.createdBy.id ? p`<wy-dropdown-item @click=${() => this.dispatchEdit(!0)}>
                            <wy-icon name="pencil"></wy-icon>
                            ${$("Edit")}
                          </wy-dropdown-item>` : C}
                    ${this.user && this.user.id === this.createdBy.id ? p`<wy-dropdown-item @click=${() => this.dispatchTrash()}>
                            <wy-icon name="trashcan"></wy-icon>
                            ${$("Trash")}
                          </wy-dropdown-item>` : C}
                  </wy-dropdown>
                </div>
              </div>
              <!-- image grid -->
              ${t && t.length ? p`<wy-image-grid
                      .images=${t}
                      @file-open=${(x) => {
      var k;
      (k = this.previewRef.value) == null || k.open(x.detail.fileId);
    }}
                    ></wy-image-grid>` : ""}

              <!-- embeds -->
              ${this.embed && ((y = this.hasFeatures) != null && y.embeds) ? p` <wy-embed class="wy-embed" .embed=${this.embed}></wy-embed> ` : C}

              <div class="wy-post-body">
                ${this.html ? p`<div class="wy-content">${qs(this.html)}</div>` : ""}

                <!-- poll -->
                ${this.pollOptions && this.pollOptions.length > 0 ? p`
                        <wy-poll
                          .pollOptions=${this.pollOptions}
                          @vote=${(x) => this.dispatchVote(x.detail.id)}
                        ></wy-poll>
                      ` : C}

                <!-- files -->
                ${i && i.length ? p`<wy-attachments-list
                        .files=${i ?? []}
                        @file-open=${(x) => {
      var k;
      (k = this.previewRef.value) == null || k.open(x.detail.fileId);
    }}
                      ></wy-attachments-list>` : ""}

                <!-- meeting -->
                ${this.meeting ? p`<wy-meeting-card .meeting=${this.meeting}></wy-meeting-card>` : ""}
              </div>

              <div class="wy-post-footer">
                <div>
                  <!-- comment count -->
                  ${(m = this.hasFeatures) != null && m.comments ? p` <wy-button
                          small
                          kind="inline"
                          ?active=${this.showComments}
                          class="wy-meta"
                          color="inherit"
                          @click=${(x) => this.handleCommentsClick(x)}
                        >
                          ${this.commentCount !== 1 ? $(pt`${this.commentCount} comments`) : $("1 comment")}
                        </wy-button>` : C}
                </div>
                ${(f = this.hasFeatures) != null && f.reactions && this.app ? p`
                        <wy-reactions
                          line
                          small
                          .reactions=${this.reactions}
                          parentId=${this.app.id}
                          parentType="apps"
                          entityId=${this.postId}
                          entityType="posts"
                        ></wy-reactions>
                      ` : C}
              </div>

              <!-- comments -->
              ${this.loadComments ? p`
                      <div class="wy-post-comments" ?hidden=${!this.showComments}>
                        <wy-comment-list .parentId=${this.postId} .location=${"posts"}></wy-comment-list>
                      </div>
                    ` : C}
            </div>
          
            ${(g = this.attachments) != null && g.length ? p`<wy-preview
                    ${X(this.previewRef)}
                    .files=${this.attachments}
                    .isAttachment=${!0}
                  ></wy-preview> ` : C}
           
          </div>
        `;
  }
  updated(t) {
    var i;
    t.has("highlight") && this.highlight && ((i = this.highlightRef.value) == null || i.scrollIntoView({ block: "nearest" }));
  }
}, c(Ha, "WyPostView"), Ha);
Mt.styles = [
  J,
  Z`
      :host {
        display: contents;
      }
    `
];
Wt([
  w({ type: Number })
], Mt.prototype, "postId", 2);
Wt([
  w({ attribute: !1 })
], Mt.prototype, "createdBy", 2);
Wt([
  w()
], Mt.prototype, "createdAt", 2);
Wt([
  w()
], Mt.prototype, "modifiedAt", 2);
Wt([
  w({ type: Boolean })
], Mt.prototype, "isSubscribed", 2);
Wt([
  w({ type: Boolean })
], Mt.prototype, "isTrashed", 2);
Wt([
  w()
], Mt.prototype, "html", 2);
Wt([
  w()
], Mt.prototype, "text", 2);
Wt([
  w({ type: Array })
], Mt.prototype, "attachments", 2);
Wt([
  w({ type: Array })
], Mt.prototype, "pollOptions", 2);
Wt([
  w({ attribute: !1 })
], Mt.prototype, "meeting", 2);
Wt([
  w({ attribute: !1 })
], Mt.prototype, "embed", 2);
Wt([
  w({ type: Array })
], Mt.prototype, "reactions", 2);
Wt([
  w({ attribute: !1 })
], Mt.prototype, "commentCount", 2);
Wt([
  w({ type: Array })
], Mt.prototype, "seenBy", 2);
Wt([
  D()
], Mt.prototype, "showComments", 2);
Wt([
  D()
], Mt.prototype, "loadComments", 2);
Wt([
  w({ type: Boolean })
], Mt.prototype, "highlight", 2);
Wt([
  D()
], Mt.prototype, "isCommentLinked", 2);
Mt = Wt([
  B("wy-post-view"),
  st()
], Mt);
var j4 = Object.defineProperty, W4 = Object.getOwnPropertyDescriptor, $e = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? W4(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && j4(t, i, n), n;
}, "__decorateClass$2"), Va;
let Zt = (Va = class extends zt(j) {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.temp = !1, this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.text = "", this.attachments = [], this.pollOptions = [], this.reactions = [], this.seenBy = [], this.updatePostMutation = new Ae(this);
  }
  dispatchEdit(t) {
    const i = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(i);
  }
  async handleSubmit(t) {
    const i = await this.whenApp();
    this.updatePostMutation.mutate({
      id: this.postId,
      appId: i.id,
      text: t.detail.text,
      meetingId: t.detail.meetingId,
      blobs: t.detail.blobs,
      attachments: t.detail.attachments,
      pollOptions: t.detail.pollOptions,
      embed: t.detail.embed
    }), this.dispatchEdit(!1);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && this.updatePostMutation.trackMutation(H4(this.weavy, ["posts", this.app.id]));
  }
  render() {
    return p`
      <nav class="wy-item">
        <div class="wy-item-body">
          <div class="wy-item-title">${$("Edit post")}</div>
        </div>

        <wy-button kind="icon" @click=${() => this.dispatchEdit(!1)}>
          <wy-icon name="close"></wy-icon>
        </wy-button>
      </nav>
      <wy-editor
        editorLocation="apps"
        .text=${this.text}
        .embed=${this.embed}
        .options=${this.pollOptions}
        .attachments=${this.attachments ?? []}
        .parentId=${this.postId}
        .typing=${!1}
        .draft=${!1}
        placeholder=${$("Edit post...")}
        buttonText=${$("Update", { desc: "Button action to update" })}
        @submit=${(t) => this.handleSubmit(t)}></wy-editor>
    `;
  }
}, c(Va, "WyPostEdit"), Va);
Zt.styles = J;
$e([
  w({ type: Number })
], Zt.prototype, "postId", 2);
$e([
  w({ type: Boolean })
], Zt.prototype, "temp", 2);
$e([
  w({ attribute: !1 })
], Zt.prototype, "createdBy", 2);
$e([
  w()
], Zt.prototype, "createdAt", 2);
$e([
  w()
], Zt.prototype, "modifiedAt", 2);
$e([
  w({ type: Boolean })
], Zt.prototype, "isSubscribed", 2);
$e([
  w({ type: Boolean })
], Zt.prototype, "isTrashed", 2);
$e([
  w()
], Zt.prototype, "text", 2);
$e([
  w({ type: Array })
], Zt.prototype, "attachments", 2);
$e([
  w({ type: Array })
], Zt.prototype, "pollOptions", 2);
$e([
  w({ attribute: !1 })
], Zt.prototype, "meeting", 2);
$e([
  w({ attribute: !1 })
], Zt.prototype, "embed", 2);
$e([
  w({ type: Array })
], Zt.prototype, "reactions", 2);
$e([
  w({ type: Array })
], Zt.prototype, "seenBy", 2);
Zt = $e([
  B("wy-post-edit"),
  st()
], Zt);
var Q4 = Object.defineProperty, K4 = Object.getOwnPropertyDescriptor, se = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? K4(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && Q4(t, i, n), n;
}, "__decorateClass$1"), Ba;
let Dt = (Ba = class extends j {
  constructor() {
    super(...arguments), this.exportParts = new Q(this), this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.html = "", this.text = "", this.plain = "", this.attachments = [], this.pollOptions = [], this.reactions = [], this.commentCount = 0, this.seenBy = [], this.editing = !1;
  }
  dispatchVote(t) {
    const i = new CustomEvent("vote", { detail: { id: t, parentId: this.postId, parentType: "posts" } });
    return this.dispatchEvent(i);
  }
  dispatchSubscribe(t) {
    const i = new CustomEvent("subscribe", { detail: { id: this.postId, subscribe: t } });
    return this.dispatchEvent(i);
  }
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  render() {
    return p`
      ${this.isTrashed ? p`<wy-post-trashed
            class="wy-post"
            postId=${this.postId}
            @restore=${() => {
      this.dispatchRestore();
    }}></wy-post-trashed> ` : C}
      ${!this.isTrashed && this.editing ? p`<wy-post-edit
            class="wy-post"
            .postId=${this.postId}
            .text=${this.text}
            .embed=${this.embed}
            .pollOptions=${this.pollOptions}
            .attachments=${this.attachments}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}></wy-post-edit> ` : C}
      ${!this.isTrashed && !this.editing ? p`<wy-post-view
            id="${this.id}"
            .postId=${this.postId}
            .createdBy=${this.createdBy}
            .createdAt=${this.createdAt}
            .modifiedAt=${this.modifiedAt}
            .isSubscribed=${this.isSubscribed}
            .isTrashed=${this.isTrashed}
            .html=${this.html}
            .text=${this.plain}
            .attachments=${this.attachments ?? []}
            .meeting=${this.meeting}
            .pollOptions=${this.pollOptions}
            .embed=${this.embed}
            .reactions=${this.reactions}
            .commentCount=${this.commentCount}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}
            @subscribe=${(t) => {
      this.dispatchSubscribe(t.detail.subscribe);
    }}
            @trash=${() => {
      this.dispatchTrash();
    }}
            @vote=${(t) => {
      this.dispatchVote(t.detail.id);
    }}></wy-post-view> ` : C}
    `;
  }
}, c(Ba, "WyPost"), Ba);
Dt.styles = J;
se([
  w({ type: Number })
], Dt.prototype, "postId", 2);
se([
  w({ attribute: !1 })
], Dt.prototype, "createdBy", 2);
se([
  w()
], Dt.prototype, "createdAt", 2);
se([
  w()
], Dt.prototype, "modifiedAt", 2);
se([
  w({ type: Boolean })
], Dt.prototype, "isSubscribed", 2);
se([
  w({ type: Boolean })
], Dt.prototype, "isTrashed", 2);
se([
  w()
], Dt.prototype, "html", 2);
se([
  w()
], Dt.prototype, "text", 2);
se([
  w()
], Dt.prototype, "plain", 2);
se([
  w({ attribute: !1 })
], Dt.prototype, "attachments", 2);
se([
  w({ type: Array })
], Dt.prototype, "pollOptions", 2);
se([
  w({ attribute: !1 })
], Dt.prototype, "meeting", 2);
se([
  w({ attribute: !1 })
], Dt.prototype, "embed", 2);
se([
  w({ type: Array })
], Dt.prototype, "reactions", 2);
se([
  w({ attribute: !1 })
], Dt.prototype, "commentCount", 2);
se([
  w({ type: Array })
], Dt.prototype, "seenBy", 2);
se([
  D()
], Dt.prototype, "editing", 2);
Dt = se([
  B("wy-post")
], Dt);
var G4 = Object.defineProperty, Y4 = Object.getOwnPropertyDescriptor, kf = /* @__PURE__ */ c((r) => {
  throw TypeError(r);
}, "__typeError"), Z4 = /* @__PURE__ */ c((r, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? Y4(t, i) : t, a = r.length - 1, o; a >= 0; a--)
    (o = r[a]) && (n = (s ? o(t, i, n) : o(n)) || n);
  return s && n && G4(t, i, n), n;
}, "__decorateClass"), Cf = /* @__PURE__ */ c((r, t, i) => t.has(r) || kf("Cannot " + i), "__accessCheck"), oy = /* @__PURE__ */ c((r, t, i) => (Cf(r, t, "read from private field"), i ? i.call(r) : t.get(r)), "__privateGet"), X4 = /* @__PURE__ */ c((r, t, i) => t.has(r) ? kf("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(r) : t.set(r, i), "__privateAdd"), cy = /* @__PURE__ */ c((r, t, i, s) => (Cf(r, t, "write to private field"), t.set(r, i), i), "__privateSet"), Mr;
const J4 = "wy-posts";
var Ua;
let hl = (Ua = class extends at {
  constructor() {
    super(), this.productType = ho.Feeds, this.componentType = ze.Posts, this.postsQuery = new Ri(this), this.infiniteScroll = new Ii(this), this.pagerRef = rt(), this.addPostMutation = new Ae(this), this.handleRealtimePostCreated = async (t) => {
      var a;
      const i = await this.whenWeavy(), s = await this.whenApp(), n = await this.whenUser();
      t.post.app.id !== s.id || ((a = t.post.created_by) == null ? void 0 : a.id) === n.id || (t.post.created_by = t.actor, os(i.queryClient, ["posts", s.id], t.post, {
        descending: !0
      }));
    }, this.handleRealtimeCommentCreated = async (t) => {
      const i = await this.whenWeavy(), s = await this.whenApp(), n = await this.whenUser();
      t.actor.id === n.id || !t.comment.parent || (_t(i.queryClient, ["posts", s.id], t.comment.parent.id, (a) => {
        a.comments ? a.comments.count += 1 : a.comments = { count: 1 };
      }), i.queryClient.invalidateQueries({ queryKey: ["posts", t.comment.app.id, "comments"] }));
    }, this.handleRealtimeReactionAdded = async (t) => {
      const i = await this.whenWeavy(), s = await this.whenApp();
      t.entity.type === "post" && _t(i.queryClient, ["posts", s.id], t.entity.id, (n) => {
        Ro(n, t.reaction, t.actor);
      });
    }, this.handleRealtimeReactionDeleted = async (t) => {
      const i = await this.whenWeavy(), s = await this.whenApp();
      t.entity.type === "post" && _t(i.queryClient, ["posts", s.id], t.entity.id, (n) => {
        Ro(n, void 0, t.actor);
      });
    }, X4(this, Mr), new fi(this, hl.styles);
  }
  async handleSubmit(t) {
    const i = await this.whenApp(), s = await this.whenUser();
    this.addPostMutation.mutate({
      appId: i.id,
      text: t.detail.text,
      meetingId: t.detail.meetingId,
      blobs: t.detail.blobs,
      pollOptions: t.detail.pollOptions,
      embed: t.detail.embed,
      user: s
    });
  }
  willUpdate(t) {
    var i;
    if (super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && this.postsQuery.trackInfiniteQuery(D4(this.weavy, this.app.id)), (t.has("weavy") || t.has("app")) && this.weavy && this.app) {
      this.addPostMutation.trackMutation(V4(this.weavy, ["posts", this.app.id])), this.subscribePostMutation = F4(this.weavy, this.app), this.removePostMutation = L4(this.weavy, this.app), this.restorePostMutation = I4(this.weavy, this.app), this.pollMutation = Vh(this.weavy, ["posts", this.app.id]), (i = oy(this, Mr)) == null || i.call(this);
      const s = `a${this.app.id}`;
      this.weavy.subscribe(s, "post_created", this.handleRealtimePostCreated), this.weavy.subscribe(s, "comment_created", this.handleRealtimeCommentCreated), this.weavy.subscribe(s, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(s, "reaction_removed", this.handleRealtimeReactionDeleted), cy(this, Mr, () => {
        var n, a, o, l;
        (n = this.weavy) == null || n.unsubscribe(s, "post_created", this.handleRealtimePostCreated), (a = this.weavy) == null || a.unsubscribe(s, "comment_created", this.handleRealtimeCommentCreated), (o = this.weavy) == null || o.unsubscribe(s, "reaction_added", this.handleRealtimeReactionAdded), (l = this.weavy) == null || l.unsubscribe(s, "reaction_removed", this.handleRealtimeReactionDeleted), cy(this, Mr, void 0);
      });
    }
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.postsQuery.result, this.pagerRef.value);
  }
  render() {
    const { data: t, isPending: i, hasNextPage: s } = this.postsQuery.result ?? {}, n = ms(t);
    return this.app ? p`
          <wy-buttons floating reverse>
            <wy-notification-button-list></wy-notification-button-list>
          </wy-buttons>

          <div class="wy-posts">
            <div class="wy-post">
              <wy-editor
                editorLocation="apps"
                ?disabled=${!Us(ns.Create, this.app.permissions)}
                .typing=${!1}
                .draft=${!0}
                placeholder=${$("Create a post...")}
                buttonText=${$("Post")}
                @submit=${(a) => this.handleSubmit(a)}
              ></wy-editor>
            </div>

            <!-- this.user ?? -->
            ${i ? p`<wy-empty><wy-spinner padded reveal></wy-spinner></wy-empty> ` : p`
                  ${this.app && this.user && n ? Re(
      n,
      (a) => a.id,
      (a) => {
        var o, l, d, u;
        return this.app && this.user ? p`<wy-post
                                id="post-${a.id}"
                                .postId=${a.id}
                                .createdBy=${a.created_by}
                                .createdAt=${a.created_at}
                                .modifiedAt=${a.updated_at}
                                .isSubscribed=${a.is_subscribed}
                                .isTrashed=${a.is_trashed}
                                .html=${a.html}
                                .text=${a.text}
                                .plain=${a.plain}
                                .attachments=${(o = a.attachments) == null ? void 0 : o.data}
                                .meeting=${a.meeting}
                                .pollOptions=${(l = a.options) == null ? void 0 : l.data}
                                .embed=${a.embed}
                                .reactions=${(d = a.reactions) == null ? void 0 : d.data}
                                .commentCount=${((u = a.comments) == null ? void 0 : u.count) || 0}
                                @subscribe=${(y) => {
          var m;
          (m = this.subscribePostMutation) == null || m.mutate({
            id: y.detail.id,
            subscribe: y.detail.subscribe
          });
        }}
                                @trash=${(y) => {
          var m;
          (m = this.removePostMutation) == null || m.mutate({ id: y.detail.id });
        }}
                                @restore=${(y) => {
          var m;
          (m = this.restorePostMutation) == null || m.mutate({ id: y.detail.id });
        }}
                                @vote=${(y) => {
          var m;
          (m = this.pollMutation) == null || m.mutate({
            optionId: y.detail.id,
            parentType: y.detail.parentType,
            parentId: y.detail.parentId
          });
        }}
                              ></wy-post>` : C;
      }
    ) : p`<wy-empty><wy-spinner padded reveal></wy-spinner></wy-empty>`}
                  ${s ? p`<div ${X(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
                `}
          </div>
        ` : p`<wy-empty><wy-spinner padded reveal></wy-spinner></wy-empty>`;
  }
  disconnectedCallback() {
    var t;
    (t = oy(this, Mr)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Ua, "WyPosts"), Ua);
Mr = /* @__PURE__ */ new WeakMap();
hl.styles = [We, J, po, pc, fs, ir];
hl = Z4([
  B(J4),
  st()
], hl);
const o3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get WyAttachment() {
    return Di;
  },
  get WyAttachmentsList() {
    return Ya;
  },
  get WyAvatar() {
    return Fi;
  },
  get WyAvatarGroup() {
    return Ns;
  },
  get WyBlobUpload() {
    return so;
  },
  get WyButton() {
    return gi;
  },
  get WyButtons() {
    return js;
  },
  get WyCloudFiles() {
    return Xs;
  },
  get WyComment() {
    return Tt;
  },
  get WyCommentEdit() {
    return qt;
  },
  get WyCommentEditor() {
    return bh;
  },
  get WyCommentList() {
    return eo;
  },
  get WyCommentTrashed() {
    return Bo;
  },
  get WyCommentView() {
    return Kt;
  },
  get WyConversation() {
    return ei;
  },
  get WyConversationAppbar() {
    return $i;
  },
  get WyConversationExtended() {
    return ll;
  },
  get WyConversationList() {
    return ki;
  },
  get WyConversationListItem() {
    return oe;
  },
  get WyConversationNew() {
    return no;
  },
  get WyDropdown() {
    return Ee;
  },
  get WyDropdownDivider() {
    return Jc;
  },
  get WyDropdownItem() {
    return Ho;
  },
  get WyDropdownOption() {
    return to;
  },
  get WyEditor() {
    return xt;
  },
  get WyEmbed() {
    return Ka;
  },
  get WyEmpty() {
    return Wa;
  },
  get WyFileItem() {
    return Hi;
  },
  get WyFileMenu() {
    return ps;
  },
  get WyFileVersions() {
    return io;
  },
  get WyFilesAppbar() {
    return us;
  },
  get WyFilesList() {
    return ii;
  },
  get WyIcon() {
    return Pt;
  },
  get WyImageGrid() {
    return Ga;
  },
  get WyMeetingCard() {
    return To;
  },
  get WyMessage() {
    return Ft;
  },
  get WyMessageEditor() {
    return xh;
  },
  get WyMessageTyping() {
    return Ie;
  },
  get WyMessages() {
    return ti;
  },
  get WyMessengerBadge() {
    return ys;
  },
  get WyNotificationBadge() {
    return No;
  },
  get WyNotificationButtonList() {
    return al;
  },
  get WyNotificationList() {
    return ao;
  },
  get WyNotificationListItem() {
    return ws;
  },
  get WyOverlay() {
    return ls;
  },
  get WyPdfViewer() {
    return Ys;
  },
  get WyPoll() {
    return Uo;
  },
  get WyPollOption() {
    return Zs;
  },
  get WyPost() {
    return Dt;
  },
  get WyPostEdit() {
    return Zt;
  },
  get WyPostTrashed() {
    return Wo;
  },
  get WyPostView() {
    return Mt;
  },
  get WyPresence() {
    return Qa;
  },
  get WyPreview() {
    return Nt;
  },
  get WyPreviewEmbed() {
    return hs;
  },
  get WyPreviewIcon() {
    return Ks;
  },
  get WyPreviewImage() {
    return Gs;
  },
  get WyPreviewItem() {
    return Vo;
  },
  get WyPreviewMedia() {
    return ds;
  },
  get WyPreviewText() {
    return xi;
  },
  get WyReactionItem() {
    return Io;
  },
  get WyReactions() {
    return It;
  },
  get WySheet() {
    return Ja;
  },
  get WySkeleton() {
    return Fo;
  },
  get WySpinner() {
    return vi;
  },
  get WyToast() {
    return Vi;
  },
  get WyToasts() {
    return jo;
  },
  get WyTyping() {
    return ro;
  },
  get WyUsersSearch() {
    return si;
  }
}, Symbol.toStringTag, { value: "Module" }));
export {
  wm as AppTypeGuids,
  s3 as AppTypeStrings,
  fm as BotAppTypeGuids,
  r3 as BotAppTypeStrings,
  ru as ContextController,
  a3 as MessengerBotTypes,
  n3 as MessengerTypes,
  o5 as WY_CHAT_TAGNAME,
  h5 as WY_COMMENTS_TAGNAME,
  Cm as WY_COMPONENT_TAGNAME,
  xm as WY_CONTEXT_TAGNAME,
  V5 as WY_FILES_TAGNAME,
  y4 as WY_MESSENGER_TAGNAME,
  _4 as WY_NOTIFICATIONS_TAGNAME,
  O4 as WY_NOTIFICATION_TOASTS_TAGNAME,
  J4 as WY_POSTS_TAGNAME,
  _o as Weavy,
  Ze as WeavyClient,
  at as WeavyComponent,
  zt as WeavyComponentConsumerMixin,
  o3 as WeavyComponents,
  Xt as WeavyContext,
  ol as WyChat,
  cl as WyComments,
  Na as WyComponent,
  Ut as WyContext,
  Js as WyFiles,
  tr as WyMessenger,
  Bi as WyNotificationToasts,
  dl as WyNotifications,
  hl as WyPosts,
  am as createWeavyContextProvider,
  Fe as globalContextProvider
};
