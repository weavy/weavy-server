"use client";
var DW = Object.defineProperty;
var h = (s, t) => DW(s, "name", { value: t, configurable: !0 });
import j, { createContext as VW, useState as q3, useMemo as Z3, useEffect as bk, useRef as WW } from "react";
var FW = Object.defineProperty, m = /* @__PURE__ */ h((s, t) => FW(s, "name", { value: t, configurable: !0 }), "f");
const BS = /* @__PURE__ */ m((s) => {
  s && requestAnimationFrame(() => s?.focus?.());
}, "autofocusRef");
async function ks(s, t = "wy-") {
  const e = [];
  for (let i = s; i = i.parentElement; )
    i.matches(":not(:defined)") && i.localName.startsWith(t) && e.push(customElements.whenDefined(i.localName));
  await Promise.all(e);
}
h(ks, "yx$1");
m(ks, "whenParentsDefined");
const r8 = /* @__PURE__ */ m((s, t) => {
  let e;
  const i = new ResizeObserver(() => {
    const { isConnected: r } = s;
    r !== e && (e = r, t(r, s));
  });
  return i.observe(s), i;
}, "observeConnected");
async function NS(s, t = !0) {
  if (s.isConnected === t)
    return t;
  {
    let e;
    const i = new Promise((n) => e = n), r = r8(s, (n) => {
      n === t && e?.(t);
    });
    return await i, r.disconnect(), t;
  }
}
h(NS, "Sx$1");
m(NS, "whenConnected");
async function s8() {
  Se(), document.hidden && await new Promise((s) => {
    window.addEventListener(
      "visibilitychange",
      () => {
        document.hidden || s(!0);
      },
      { once: !0 }
    );
  });
}
h(s8, "bx$1");
m(s8, "whenDocumentVisible");
const XS = {
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  /* @ts-ignore */
  opacityProperty: !0,
  visibilityProperty: !0,
  // Legacy compatibility
  checkOpacity: !0,
  checkVisibilityCSS: !0
};
function jS(s, t = !0, e = XS, i) {
  s.checkVisibility(e) === t ? i(t) : requestAnimationFrame(() => jS(s, t, e, i));
}
h(jS, "td$1");
m(jS, "untilVisibility");
async function yO(s, t = !0, e = XS) {
  s.checkVisibility(e) !== t && await new Promise((i) => {
    jS(s, t, e, i);
  });
}
h(yO, "wx$1");
m(yO, "whenElementVisible");
function g1(s) {
  return s.ctrlKey || s.metaKey || s.button === 1;
}
h(g1, "xx$1");
m(g1, "isModifiedClick");
function $k(s) {
  return s.getRootNode() instanceof ShadowRoot;
}
h($k, "kx$1");
m($k, "isInShadowDom");
function gO() {
  return !!(document.body?.showPopover && !/native code/i.test(document.body.showPopover.toString()));
}
h(gO, "Px$1");
m(gO, "isPopoverPolyfilled");
function V0() {
  return typeof window < "u";
}
h(V0, "$x$1");
m(V0, "isDomAvailable");
function Se() {
  if (typeof window > "u")
    throw Error("DOM not available");
}
h(Se, "ah$1");
m(Se, "throwOnDomNotAvailable");
function n8(s, t) {
  if (Se(), s) {
    for (let e = s; e = e.parentElement || e.parentNode || e.host; )
      if (e instanceof Element && t(e))
        return e;
  }
}
h(n8, "Eg$1");
m(n8, "getParent");
function a8(s) {
  return n8(s, (t) => {
    const e = getComputedStyle(t);
    return !!(t instanceof HTMLElement && (t.localName === "wy-overlay" || t.popover || e.position === "fixed" || // @ts-expect-error overlay not in CSSStyleDeclaration
    e.overlay === "auto"));
  });
}
h(a8, "Rx$1");
m(a8, "inOverlay");
let xk = [], o8 = [];
(() => {
  let s = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t) => t ? parseInt(t, 36) : 1);
  for (let t = 0, e = 0; t < s.length; t++)
    (t % 2 ? o8 : xk).push(e = e + s[t]);
})();
function l8(s) {
  if (s < 768) return !1;
  for (let t = 0, e = xk.length; ; ) {
    let i = t + e >> 1;
    if (s < xk[i]) e = i;
    else if (s >= o8[i]) t = i + 1;
    else return !0;
    if (t == e) return !1;
  }
}
h(l8, "Yg$1");
m(l8, "isExtendingChar");
function kk(s) {
  return s >= 127462 && s <= 127487;
}
h(kk, "Jc$1");
m(kk, "isRegionalIndicator");
const B3 = 8205;
function c8(s, t, e = !0, i = !0) {
  return (e ? US : h8)(s, t, i);
}
h(c8, "Wg$1");
m(c8, "findClusterBreak$1");
function US(s, t, e) {
  if (t == s.length) return t;
  t && HS(s.charCodeAt(t)) && YS(s.charCodeAt(t - 1)) && t--;
  let i = kv(s, t);
  for (t += Sk(i); t < s.length; ) {
    let r = kv(s, t);
    if (i == B3 || r == B3 || e && l8(r))
      t += Sk(r), i = r;
    else if (kk(r)) {
      let n = 0, a = t - 2;
      for (; a >= 0 && kk(kv(s, a)); )
        n++, a -= 2;
      if (n % 2 == 0) break;
      t += 2;
    } else
      break;
  }
  return t;
}
h(US, "rd$1");
m(US, "nextClusterBreak");
function h8(s, t, e) {
  for (; t > 0; ) {
    let i = US(s, t - 2, e);
    if (i < t) return i;
    t--;
  }
  return 0;
}
h(h8, "Vg$1");
m(h8, "prevClusterBreak");
function kv(s, t) {
  let e = s.charCodeAt(t);
  if (!YS(e) || t + 1 == s.length) return e;
  let i = s.charCodeAt(t + 1);
  return HS(i) ? (e - 55296 << 10) + (i - 56320) + 65536 : e;
}
h(kv, "Ro$1");
m(kv, "codePointAt$1");
function HS(s) {
  return s >= 56320 && s < 57344;
}
h(HS, "nd$1");
m(HS, "surrogateLow$1");
function YS(s) {
  return s >= 55296 && s < 56320;
}
h(YS, "sd$1");
m(YS, "surrogateHigh$1");
function Sk(s) {
  return s < 65536 ? 1 : 2;
}
h(Sk, "tu");
m(Sk, "codePointSize$1");
var bo;
const d8 = (bo = class {
  /**
  Get the line description around the given position.
  */
  lineAt(t) {
    if (t < 0 || t > this.length)
      throw new RangeError(`Invalid position ${t} in document of length ${this.length}`);
    return this.lineInner(t, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(t) {
    if (t < 1 || t > this.lines)
      throw new RangeError(`Invalid line number ${t} in ${this.lines}-line document`);
    return this.lineInner(t, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(t, e, i) {
    [t, e] = ll(this, t, e);
    let r = [];
    return this.decompose(
      0,
      t,
      r,
      2
      /* Open.To */
    ), i.length && i.decompose(
      0,
      i.length,
      r,
      3
      /* Open.To */
    ), this.decompose(
      e,
      this.length,
      r,
      1
      /* Open.From */
    ), Sv.from(r, this.length - (e - t) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(t) {
    return this.replace(this.length, this.length, t);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(t, e = this.length) {
    [t, e] = ll(this, t, e);
    let i = [];
    return this.decompose(t, e, i, 0), Sv.from(i, e - t);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(t) {
    if (t == this)
      return !0;
    if (t.length != this.length || t.lines != this.lines)
      return !1;
    let e = this.scanIdentical(t, 1), i = this.length - this.scanIdentical(t, -1), r = new ww(this), n = new ww(t);
    for (let a = e, o = e; ; ) {
      if (r.next(a), n.next(a), a = 0, r.lineBreak != n.lineBreak || r.done != n.done || r.value != n.value)
        return !1;
      if (o += r.value.length, r.done || o >= i)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(t = 1) {
    return new ww(this, t);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(t, e = this.length) {
    return new g8(this, t, e);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(t, e) {
    let i;
    if (t == null)
      i = this.iter();
    else {
      e == null && (e = this.lines + 1);
      let r = this.line(t).from;
      i = this.iterRange(r, Math.max(r, e == this.lines + 1 ? this.length : e <= 1 ? 0 : this.line(e - 1).to));
    }
    return new v8(i);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let t = [];
    return this.flatten(t), t;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(t) {
    if (t.length == 0)
      throw new RangeError("A document must have at least one line");
    return t.length == 1 && !t[0] ? bo.empty : t.length <= 32 ? new _r(t) : Sv.from(_r.split(t, []));
  }
}, h(bo, "Xs"), bo);
m(d8, "Text");
let Ht = d8;
var Si;
const u8 = (Si = class extends Ht {
  constructor(t, e = f8(t)) {
    super(), this.text = t, this.length = e;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(t, e, i, r) {
    for (let n = 0; ; n++) {
      let a = this.text[n], o = r + a.length;
      if ((e ? i : o) >= t)
        return new qW(r, o, i, a);
      r = o + 1, i++;
    }
  }
  decompose(t, e, i, r) {
    let n = t <= 0 && e >= this.length ? this : new Si(Ck(this.text, t, e), Math.min(e, this.length) - Math.max(0, t));
    if (r & 1) {
      let a = i.pop(), o = gw(n.text, a.text.slice(), 0, n.length);
      if (o.length <= 32)
        i.push(new Si(o, a.length + n.length));
      else {
        let l = o.length >> 1;
        i.push(new Si(o.slice(0, l)), new Si(o.slice(l)));
      }
    } else
      i.push(n);
  }
  replace(t, e, i) {
    if (!(i instanceof Si))
      return super.replace(t, e, i);
    [t, e] = ll(this, t, e);
    let r = gw(this.text, gw(i.text, Ck(this.text, 0, t)), e), n = this.length + i.length - (e - t);
    return r.length <= 32 ? new Si(r, n) : Sv.from(Si.split(r, []), n);
  }
  sliceString(t, e = this.length, i = `
`) {
    [t, e] = ll(this, t, e);
    let r = "";
    for (let n = 0, a = 0; n <= e && a < this.text.length; a++) {
      let o = this.text[a], l = n + o.length;
      n > t && a && (r += i), t < l && e > n && (r += o.slice(Math.max(0, t - n), e - n)), n = l + 1;
    }
    return r;
  }
  flatten(t) {
    for (let e of this.text)
      t.push(e);
  }
  scanIdentical() {
    return 0;
  }
  static split(t, e) {
    let i = [], r = -1;
    for (let n of t)
      i.push(n), r += n.length + 1, i.length == 32 && (e.push(new Si(i, r)), i = [], r = -1);
    return r > -1 && e.push(new Si(i, r)), e;
  }
}, h(Si, "Ae"), Si);
m(u8, "TextLeaf");
let _r = u8;
var Rr;
const p8 = (Rr = class extends Ht {
  constructor(t, e) {
    super(), this.children = t, this.length = e, this.lines = 0;
    for (let i of t)
      this.lines += i.lines;
  }
  lineInner(t, e, i, r) {
    for (let n = 0; ; n++) {
      let a = this.children[n], o = r + a.length, l = i + a.lines - 1;
      if ((e ? l : o) >= t)
        return a.lineInner(t, e, i, r);
      r = o + 1, i = l + 1;
    }
  }
  decompose(t, e, i, r) {
    for (let n = 0, a = 0; a <= e && n < this.children.length; n++) {
      let o = this.children[n], l = a + o.length;
      if (t <= l && e >= a) {
        let d = r & ((a <= t ? 1 : 0) | (l >= e ? 2 : 0));
        a >= t && l <= e && !d ? i.push(o) : o.decompose(t - a, e - a, i, d);
      }
      a = l + 1;
    }
  }
  replace(t, e, i) {
    if ([t, e] = ll(this, t, e), i.lines < this.lines)
      for (let r = 0, n = 0; r < this.children.length; r++) {
        let a = this.children[r], o = n + a.length;
        if (t >= n && e <= o) {
          let l = a.replace(t - n, e - n, i), d = this.lines - a.lines + l.lines;
          if (l.lines < d >> 4 && l.lines > d >> 6) {
            let u = this.children.slice();
            return u[r] = l, new Rr(u, this.length - (e - t) + i.length);
          }
          return super.replace(n, o, l);
        }
        n = o + 1;
      }
    return super.replace(t, e, i);
  }
  sliceString(t, e = this.length, i = `
`) {
    [t, e] = ll(this, t, e);
    let r = "";
    for (let n = 0, a = 0; n < this.children.length && a <= e; n++) {
      let o = this.children[n], l = a + o.length;
      a > t && n && (r += i), t < l && e > a && (r += o.sliceString(t - a, e - a, i)), a = l + 1;
    }
    return r;
  }
  flatten(t) {
    for (let e of this.children)
      e.flatten(t);
  }
  scanIdentical(t, e) {
    if (!(t instanceof Rr))
      return 0;
    let i = 0, [r, n, a, o] = e > 0 ? [0, 0, this.children.length, t.children.length] : [this.children.length - 1, t.children.length - 1, -1, -1];
    for (; ; r += e, n += e) {
      if (r == a || n == o)
        return i;
      let l = this.children[r], d = t.children[n];
      if (l != d)
        return i + l.scanIdentical(d, e);
      i += l.length + 1;
    }
  }
  static from(t, e = t.reduce((i, r) => i + r.length + 1, -1)) {
    let i = 0;
    for (let y of t)
      i += y.lines;
    if (i < 32) {
      let y = [];
      for (let g of t)
        g.flatten(y);
      return new _r(y, e);
    }
    let r = Math.max(
      32,
      i >> 5
      /* Tree.BranchShift */
    ), n = r << 1, a = r >> 1, o = [], l = 0, d = -1, u = [];
    function p(y) {
      let g;
      if (y.lines > n && y instanceof Rr)
        for (let O of y.children)
          p(O);
      else y.lines > a && (l > a || !l) ? (f(), o.push(y)) : y instanceof _r && l && (g = u[u.length - 1]) instanceof _r && y.lines + g.lines <= 32 ? (l += y.lines, d += y.length + 1, u[u.length - 1] = new _r(g.text.concat(y.text), g.length + 1 + y.length)) : (l + y.lines > r && f(), l += y.lines, d += y.length + 1, u.push(y));
    }
    h(p, "u"), m(p, "add");
    function f() {
      l != 0 && (o.push(u.length == 1 ? u[0] : Rr.from(u, d)), d = -1, l = u.length = 0);
    }
    h(f, "O"), m(f, "flush");
    for (let y of t)
      p(y);
    return f(), o.length == 1 ? o[0] : new Rr(o, e);
  }
}, h(Rr, "yt"), Rr);
m(p8, "TextNode");
let Sv = p8;
Ht.empty = /* @__PURE__ */ new _r([""], 0);
function f8(s) {
  let t = -1;
  for (let e of s)
    t += e.length + 1;
  return t;
}
h(f8, "Ug$1");
m(f8, "textLength");
function gw(s, t, e = 0, i = 1e9) {
  for (let r = 0, n = 0, a = !0; n < s.length && r <= i; n++) {
    let o = s[n], l = r + o.length;
    l >= e && (l > i && (o = o.slice(0, i - r)), r < e && (o = o.slice(e - r)), a ? (t[t.length - 1] += o, a = !1) : t.push(o)), r = l + 1;
  }
  return t;
}
h(gw, "qn$1");
m(gw, "appendText");
function Ck(s, t, e) {
  return gw(s, [""], t, e);
}
h(Ck, "iu");
m(Ck, "sliceText");
var Mh;
const m8 = (Mh = class {
  constructor(t, e = 1) {
    this.dir = e, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [t], this.offsets = [e > 0 ? 1 : (t instanceof _r ? t.text.length : t.children.length) << 1];
  }
  nextInner(t, e) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, r = this.nodes[i], n = this.offsets[i], a = n >> 1, o = r instanceof _r ? r.text.length : r.children.length;
      if (a == (e > 0 ? o : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        e > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((n & 1) == (e > 0 ? 0 : 1)) {
        if (this.offsets[i] += e, t == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        t--;
      } else if (r instanceof _r) {
        let l = r.text[a + (e < 0 ? -1 : 0)];
        if (this.offsets[i] += e, l.length > Math.max(0, t))
          return this.value = t == 0 ? l : e > 0 ? l.slice(t) : l.slice(0, l.length - t), this;
        t -= l.length;
      } else {
        let l = r.children[a + (e < 0 ? -1 : 0)];
        t > l.length ? (t -= l.length, this.offsets[i] += e) : (e < 0 && this.offsets[i]--, this.nodes.push(l), this.offsets.push(e > 0 ? 1 : (l instanceof _r ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(t = 0) {
    return t < 0 && (this.nextInner(-t, -this.dir), t = this.value.length), this.nextInner(t, this.dir);
  }
}, h(Mh, "Nh"), Mh);
m(m8, "RawTextCursor");
let ww = m8;
var Ah;
const y8 = (Ah = class {
  constructor(t, e, i) {
    this.value = "", this.done = !1, this.cursor = new ww(t, e > i ? -1 : 1), this.pos = e > i ? t.length : 0, this.from = Math.min(e, i), this.to = Math.max(e, i);
  }
  nextInner(t, e) {
    if (e < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    t += Math.max(0, e < 0 ? this.pos - this.to : this.from - this.pos);
    let i = e < 0 ? this.pos - this.from : this.to - this.pos;
    t > i && (t = i), i -= t;
    let { value: r } = this.cursor.next(t);
    return this.pos += (r.length + t) * e, this.value = r.length <= i ? r : e < 0 ? r.slice(r.length - i) : r.slice(0, i), this.done = !this.value, this;
  }
  next(t = 0) {
    return t < 0 ? t = Math.max(t, this.from - this.pos) : t > 0 && (t = Math.min(t, this.to - this.pos)), this.nextInner(t, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}, h(Ah, "Gh"), Ah);
m(y8, "PartialTextCursor");
let g8 = y8;
var Rh;
const w8 = (Rh = class {
  constructor(t) {
    this.inner = t, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(t = 0) {
    let { done: e, lineBreak: i, value: r } = this.inner.next(t);
    return e && this.afterBreak ? (this.value = "", this.afterBreak = !1) : e ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = r, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}, h(Rh, "Fh"), Rh);
m(w8, "LineCursor");
let v8 = w8;
typeof Symbol < "u" && (Ht.prototype[Symbol.iterator] = function() {
  return this.iter();
}, ww.prototype[Symbol.iterator] = g8.prototype[Symbol.iterator] = v8.prototype[Symbol.iterator] = function() {
  return this;
});
var d2, Eh;
let qW = (d2 = (Eh = class {
  /**
  @internal
  */
  constructor(t, e, i, r) {
    this.from = t, this.to = e, this.number = i, this.text = r;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}, h(Eh, "$i$1"), Eh), m(d2, "Line"), d2);
function ll(s, t, e) {
  return t = Math.max(0, Math.min(s.length, t)), [t, Math.max(t, Math.min(s.length, e))];
}
h(ll, "Zi$1");
m(ll, "clip");
function nr(s, t, e = !0, i = !0) {
  return c8(s, t, e, i);
}
h(nr, "oe$2");
m(nr, "findClusterBreak");
function O8(s) {
  return s >= 56320 && s < 57344;
}
h(O8, "zg$1");
m(O8, "surrogateLow");
function b8(s) {
  return s >= 55296 && s < 56320;
}
h(b8, "jg$1");
m(b8, "surrogateHigh");
function Rn(s, t) {
  let e = s.charCodeAt(t);
  if (!b8(e) || t + 1 == s.length)
    return e;
  let i = s.charCodeAt(t + 1);
  return O8(i) ? (e - 55296 << 10) + (i - 56320) + 65536 : e;
}
h(Rn, "Vt$2");
m(Rn, "codePointAt");
function $8(s) {
  return s <= 65535 ? String.fromCharCode(s) : (s -= 65536, String.fromCharCode((s >> 10) + 55296, (s & 1023) + 56320));
}
h($8, "qg$1");
m($8, "fromCodePoint");
function oo(s) {
  return s < 65536 ? 1 : 2;
}
h(oo, "ci$1");
m(oo, "codePointSize");
const Pk = /\r\n?|\n/;
var Ti = /* @__PURE__ */ (function(s) {
  return s[s.Simple = 0] = "Simple", s[s.TrackDel = 1] = "TrackDel", s[s.TrackBefore = 2] = "TrackBefore", s[s.TrackAfter = 3] = "TrackAfter", s;
})(Ti || (Ti = {})), js;
const x8 = (js = class {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(t) {
    this.sections = t;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let t = 0;
    for (let e = 0; e < this.sections.length; e += 2)
      t += this.sections[e];
    return t;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let t = 0;
    for (let e = 0; e < this.sections.length; e += 2) {
      let i = this.sections[e + 1];
      t += i < 0 ? this.sections[e] : i;
    }
    return t;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(t) {
    for (let e = 0, i = 0, r = 0; e < this.sections.length; ) {
      let n = this.sections[e++], a = this.sections[e++];
      a < 0 ? (t(i, r, n), r += n) : r += a, i += n;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(t, e = !1) {
    wO(this, t, e);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let t = [];
    for (let e = 0; e < this.sections.length; ) {
      let i = this.sections[e++], r = this.sections[e++];
      r < 0 ? t.push(i, r) : t.push(r, i);
    }
    return new js(t);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(t) {
    return this.empty ? t : t.empty ? this : GS(this, t);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(t, e = !1) {
    return t.empty ? this : vO(this, t, e);
  }
  mapPos(t, e = -1, i = Ti.Simple) {
    let r = 0, n = 0;
    for (let a = 0; a < this.sections.length; ) {
      let o = this.sections[a++], l = this.sections[a++], d = r + o;
      if (l < 0) {
        if (d > t)
          return n + (t - r);
        n += o;
      } else {
        if (i != Ti.Simple && d >= t && (i == Ti.TrackDel && r < t && d > t || i == Ti.TrackBefore && r < t || i == Ti.TrackAfter && d > t))
          return null;
        if (d > t || d == t && e < 0 && !o)
          return t == r || e < 0 ? n : n + l;
        n += l;
      }
      r = d;
    }
    if (t > r)
      throw new RangeError(`Position ${t} is out of range for changeset of length ${r}`);
    return n;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(t, e = t) {
    for (let i = 0, r = 0; i < this.sections.length && r <= e; ) {
      let n = this.sections[i++], a = this.sections[i++], o = r + n;
      if (a >= 0 && r <= e && o >= t)
        return r < t && o > e ? "cover" : !0;
      r = o;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let t = "";
    for (let e = 0; e < this.sections.length; ) {
      let i = this.sections[e++], r = this.sections[e++];
      t += (t ? " " : "") + i + (r >= 0 ? ":" + r : "");
    }
    return t;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2 || t.some((e) => typeof e != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new js(t);
  }
  /**
  @internal
  */
  static create(t) {
    return new js(t);
  }
}, h(js, "mi"), js);
m(x8, "ChangeDesc");
let fh = x8;
var ir;
const k8 = (ir = class extends fh {
  constructor(t, e) {
    super(t), this.inserted = e;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(t) {
    if (this.length != t.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return wO(this, (e, i, r, n, a) => t = t.replace(r, r + (i - e), a), !1), t;
  }
  mapDesc(t, e = !1) {
    return vO(this, t, e, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(t) {
    let e = this.sections.slice(), i = [];
    for (let r = 0, n = 0; r < e.length; r += 2) {
      let a = e[r], o = e[r + 1];
      if (o >= 0) {
        e[r] = o, e[r + 1] = a;
        let l = r >> 1;
        for (; i.length < l; )
          i.push(Ht.empty);
        i.push(a ? t.slice(n, n + a) : Ht.empty);
      }
      n += a;
    }
    return new ir(e, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(t) {
    return this.empty ? t : t.empty ? this : GS(this, t, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(t, e = !1) {
    return t.empty ? this : vO(this, t, e, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(t, e = !1) {
    wO(this, t, e);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return fh.create(this.sections);
  }
  /**
  @internal
  */
  filter(t) {
    let e = [], i = [], r = [], n = new Cw(this);
    t: for (let a = 0, o = 0; ; ) {
      let l = a == t.length ? 1e9 : t[a++];
      for (; o < l || o == l && n.len == 0; ) {
        if (n.done)
          break t;
        let u = Math.min(n.len, l - o);
        li(r, u, -1);
        let p = n.ins == -1 ? -1 : n.off == 0 ? n.ins : 0;
        li(e, u, p), p > 0 && Ws(i, e, n.text), n.forward(u), o += u;
      }
      let d = t[a++];
      for (; o < d; ) {
        if (n.done)
          break t;
        let u = Math.min(n.len, d - o);
        li(e, u, -1), li(r, u, n.ins == -1 ? -1 : n.off == 0 ? n.ins : 0), n.forward(u), o += u;
      }
    }
    return {
      changes: new ir(e, i),
      filtered: fh.create(r)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let t = [];
    for (let e = 0; e < this.sections.length; e += 2) {
      let i = this.sections[e], r = this.sections[e + 1];
      r < 0 ? t.push(i) : r == 0 ? t.push([i]) : t.push([i].concat(this.inserted[e >> 1].toJSON()));
    }
    return t;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(t, e, i) {
    let r = [], n = [], a = 0, o = null;
    function l(u = !1) {
      if (!u && !r.length)
        return;
      a < e && li(r, e - a, -1);
      let p = new ir(r, n);
      o = o ? o.compose(p.map(o)) : p, r = [], n = [], a = 0;
    }
    h(l, "a"), m(l, "flush");
    function d(u) {
      if (Array.isArray(u))
        for (let p of u)
          d(p);
      else if (u instanceof ir) {
        if (u.length != e)
          throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${e})`);
        l(), o = o ? o.compose(u.map(o)) : u;
      } else {
        let { from: p, to: f = p, insert: y } = u;
        if (p > f || p < 0 || f > e)
          throw new RangeError(`Invalid change range ${p} to ${f} (in doc of length ${e})`);
        let g = y ? typeof y == "string" ? Ht.of(y.split(i || Pk)) : y : Ht.empty, O = g.length;
        if (p == f && O == 0)
          return;
        p < a && l(), p > a && li(r, p - a, -1), li(r, f - p, O), Ws(n, r, g), a = f;
      }
    }
    return h(d, "h"), m(d, "process"), d(t), l(!o), o;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(t) {
    return new ir(t ? [t, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(t) {
    if (!Array.isArray(t))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let e = [], i = [];
    for (let r = 0; r < t.length; r++) {
      let n = t[r];
      if (typeof n == "number")
        e.push(n, -1);
      else {
        if (!Array.isArray(n) || typeof n[0] != "number" || n.some((a, o) => o && typeof a != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (n.length == 1)
          e.push(n[0], 0);
        else {
          for (; i.length < r; )
            i.push(Ht.empty);
          i[r] = Ht.of(n.slice(1)), e.push(n[0], i[r].length);
        }
      }
    }
    return new ir(e, i);
  }
  /**
  @internal
  */
  static createSet(t, e) {
    return new ir(t, e);
  }
}, h(ir, "it"), ir);
m(k8, "ChangeSet");
let Dr = k8;
function li(s, t, e, i = !1) {
  if (t == 0 && e <= 0)
    return;
  let r = s.length - 2;
  r >= 0 && e <= 0 && e == s[r + 1] ? s[r] += t : r >= 0 && t == 0 && s[r] == 0 ? s[r + 1] += e : i ? (s[r] += t, s[r + 1] += e) : s.push(t, e);
}
h(li, "ae$2");
m(li, "addSection");
function Ws(s, t, e) {
  if (e.length == 0)
    return;
  let i = t.length - 2 >> 1;
  if (i < s.length)
    s[s.length - 1] = s[s.length - 1].append(e);
  else {
    for (; s.length < i; )
      s.push(Ht.empty);
    s.push(e);
  }
}
h(Ws, "bt$2");
m(Ws, "addInsert");
function wO(s, t, e) {
  let i = s.inserted;
  for (let r = 0, n = 0, a = 0; a < s.sections.length; ) {
    let o = s.sections[a++], l = s.sections[a++];
    if (l < 0)
      r += o, n += o;
    else {
      let d = r, u = n, p = Ht.empty;
      for (; d += o, u += l, l && i && (p = p.append(i[a - 2 >> 1])), !(e || a == s.sections.length || s.sections[a + 1] < 0); )
        o = s.sections[a++], l = s.sections[a++];
      t(r, d, n, u, p), r = d, n = u;
    }
  }
}
h(wO, "ll$1");
m(wO, "iterChanges");
function vO(s, t, e, i = !1) {
  let r = [], n = i ? [] : null, a = new Cw(s), o = new Cw(t);
  for (let l = -1; ; ) {
    if (a.done && o.len || o.done && a.len)
      throw new Error("Mismatched change set lengths");
    if (a.ins == -1 && o.ins == -1) {
      let d = Math.min(a.len, o.len);
      li(r, d, -1), a.forward(d), o.forward(d);
    } else if (o.ins >= 0 && (a.ins < 0 || l == a.i || a.off == 0 && (o.len < a.len || o.len == a.len && !e))) {
      let d = o.len;
      for (li(r, o.ins, -1); d; ) {
        let u = Math.min(a.len, d);
        a.ins >= 0 && l < a.i && a.len <= u && (li(r, 0, a.ins), n && Ws(n, r, a.text), l = a.i), a.forward(u), d -= u;
      }
      o.next();
    } else if (a.ins >= 0) {
      let d = 0, u = a.len;
      for (; u; )
        if (o.ins == -1) {
          let p = Math.min(u, o.len);
          d += p, u -= p, o.forward(p);
        } else if (o.ins == 0 && o.len < u)
          u -= o.len, o.next();
        else
          break;
      li(r, d, l < a.i ? a.ins : 0), n && l < a.i && Ws(n, r, a.text), l = a.i, a.forward(a.len - u);
    } else {
      if (a.done && o.done)
        return n ? Dr.createSet(r, n) : fh.create(r);
      throw new Error("Mismatched change set lengths");
    }
  }
}
h(vO, "al$1");
m(vO, "mapSet");
function GS(s, t, e = !1) {
  let i = [], r = e ? [] : null, n = new Cw(s), a = new Cw(t);
  for (let o = !1; ; ) {
    if (n.done && a.done)
      return r ? Dr.createSet(i, r) : fh.create(i);
    if (n.ins == 0)
      li(i, n.len, 0, o), n.next();
    else if (a.len == 0 && !a.done)
      li(i, 0, a.ins, o), r && Ws(r, i, a.text), a.next();
    else {
      if (n.done || a.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(n.len2, a.len), d = i.length;
        if (n.ins == -1) {
          let u = a.ins == -1 ? -1 : a.off ? 0 : a.ins;
          li(i, l, u, o), r && u && Ws(r, i, a.text);
        } else a.ins == -1 ? (li(i, n.off ? 0 : n.len, l, o), r && Ws(r, i, n.textBit(l))) : (li(i, n.off ? 0 : n.len, a.off ? 0 : a.ins, o), r && !a.off && Ws(r, i, a.text));
        o = (n.ins > l || a.ins >= 0 && a.len > l) && (o || i.length > d), n.forward2(l), a.forward(l);
      }
    }
  }
}
h(GS, "od$1");
m(GS, "composeSets");
var _h;
const S8 = (_h = class {
  constructor(t) {
    this.set = t, this.i = 0, this.next();
  }
  next() {
    let { sections: t } = this.set;
    this.i < t.length ? (this.len = t[this.i++], this.ins = t[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: t } = this.set, e = this.i - 2 >> 1;
    return e >= t.length ? Ht.empty : t[e];
  }
  textBit(t) {
    let { inserted: e } = this.set, i = this.i - 2 >> 1;
    return i >= e.length && !t ? Ht.empty : e[i].slice(this.off, t == null ? void 0 : this.off + t);
  }
  forward(t) {
    t == this.len ? this.next() : (this.len -= t, this.off += t);
  }
  forward2(t) {
    this.ins == -1 ? this.forward(t) : t == this.ins ? this.next() : (this.ins -= t, this.off += t);
  }
}, h(_h, "Hh"), _h);
m(S8, "SectionIter");
let Cw = S8;
var Xn;
const C8 = (Xn = class {
  constructor(t, e, i) {
    this.from = t, this.to = e, this.flags = i;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let t = this.flags & 7;
    return t == 7 ? null : t;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let t = this.flags >> 6;
    return t == 16777215 ? void 0 : t;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(t, e = -1) {
    let i, r;
    return this.empty ? i = r = t.mapPos(this.from, e) : (i = t.mapPos(this.from, 1), r = t.mapPos(this.to, -1)), i == this.from && r == this.to ? this : new Xn(i, r, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(t, e = t) {
    if (t <= this.anchor && e >= this.anchor)
      return nt.range(t, e);
    let i = Math.abs(t - this.anchor) > Math.abs(e - this.anchor) ? t : e;
    return nt.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(t, e = !1) {
    return this.anchor == t.anchor && this.head == t.head && this.goalColumn == t.goalColumn && (!e || !this.empty || this.assoc == t.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(t) {
    if (!t || typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return nt.range(t.anchor, t.head);
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new Xn(t, e, i);
  }
}, h(Xn, "Tr"), Xn);
m(C8, "SelectionRange");
let G1 = C8;
var Ye;
const P8 = (Ye = class {
  constructor(t, e) {
    this.ranges = t, this.mainIndex = e;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(t, e = -1) {
    return t.empty ? this : Ye.create(this.ranges.map((i) => i.map(t, e)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(t, e = !1) {
    if (this.ranges.length != t.ranges.length || this.mainIndex != t.mainIndex)
      return !1;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(t.ranges[i], e))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new Ye([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(t, e = !0) {
    return Ye.create([t].concat(this.ranges), e ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(t, e = this.mainIndex) {
    let i = this.ranges.slice();
    return i[e] = t, Ye.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((t) => t.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(t) {
    if (!t || !Array.isArray(t.ranges) || typeof t.main != "number" || t.main >= t.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new Ye(t.ranges.map((e) => G1.fromJSON(e)), t.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(t, e = t) {
    return new Ye([Ye.range(t, e)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(t, e = 0) {
    if (t.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, r = 0; r < t.length; r++) {
      let n = t[r];
      if (n.empty ? n.from <= i : n.from < i)
        return Ye.normalized(t.slice(), e);
      i = n.to;
    }
    return new Ye(t, e);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(t, e = 0, i, r) {
    return G1.create(t, t, (e == 0 ? 0 : e < 0 ? 8 : 16) | (i == null ? 7 : Math.min(6, i)) | (r ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(t, e, i, r) {
    let n = (i ?? 16777215) << 6 | (r == null ? 7 : Math.min(6, r));
    return e < t ? G1.create(e, t, 48 | n) : G1.create(t, e, (e > t ? 8 : 0) | n);
  }
  /**
  @internal
  */
  static normalized(t, e = 0) {
    let i = t[e];
    t.sort((r, n) => r.from - n.from), e = t.indexOf(i);
    for (let r = 1; r < t.length; r++) {
      let n = t[r], a = t[r - 1];
      if (n.empty ? n.from <= a.to : n.from < a.to) {
        let o = a.from, l = Math.max(n.to, a.to);
        r <= e && e--, t.splice(--r, 2, n.anchor > n.head ? Ye.range(l, o) : Ye.range(o, l));
      }
    }
    return new Ye(t, e);
  }
}, h(Ye, "fe"), Ye);
m(P8, "EditorSelection");
let nt = P8;
function KS(s, t) {
  for (let e of s.ranges)
    if (e.to > t)
      throw new RangeError("Selection points outside of document");
}
h(KS, "ld$1");
m(KS, "checkSelection");
let JS = 0;
var $o;
const Q8 = ($o = class {
  constructor(t, e, i, r, n) {
    this.combine = t, this.compareInput = e, this.compare = i, this.isStatic = r, this.id = JS++, this.default = t([]), this.extensions = typeof n == "function" ? n(this) : n;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(t = {}) {
    return new $o(t.combine || ((e) => e), t.compareInput || ((e, i) => e === i), t.compare || (t.combine ? (e, i) => e === i : W0), !!t.static, t.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(t) {
    return new Cv([], this, 0, t);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(t, e) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Cv(t, this, 1, e);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(t, e) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Cv(t, this, 2, e);
  }
  from(t, e) {
    return e || (e = /* @__PURE__ */ m((i) => i, "get")), this.compute([t], (i) => e(i.field(t)));
  }
}, h($o, "Es"), $o);
m(Q8, "Facet");
let Ct = Q8;
function W0(s, t) {
  return s == t || s.length == t.length && s.every((e, i) => e === t[i]);
}
h(W0, "fh$1");
m(W0, "sameArray$1");
var Lh;
const T8 = (Lh = class {
  constructor(t, e, i, r) {
    this.dependencies = t, this.facet = e, this.type = i, this.value = r, this.id = JS++;
  }
  dynamicSlot(t) {
    var e;
    let i = this.value, r = this.facet.compareInput, n = this.id, a = t[n] >> 1, o = this.type == 2, l = !1, d = !1, u = [];
    for (let p of this.dependencies)
      p == "doc" ? l = !0 : p == "selection" ? d = !0 : (((e = t[p.id]) !== null && e !== void 0 ? e : 1) & 1) == 0 && u.push(t[p.id]);
    return {
      create(p) {
        return p.values[a] = i(p), 1;
      },
      update(p, f) {
        if (l && f.docChanged || d && (f.docChanged || f.selection) || OO(p, u)) {
          let y = i(p);
          if (o ? !Qk(y, p.values[a], r) : !r(y, p.values[a]))
            return p.values[a] = y, 1;
        }
        return 0;
      },
      reconfigure: /* @__PURE__ */ m((p, f) => {
        let y, g = f.config.address[n];
        if (g != null) {
          let O = Pw(f, g);
          if (this.dependencies.every((k) => k instanceof Ct ? f.facet(k) === p.facet(k) : k instanceof mn ? f.field(k, !1) == p.field(k, !1) : !0) || (o ? Qk(y = i(p), O, r) : r(y = i(p), O)))
            return p.values[a] = O, 0;
        } else
          y = i(p);
        return p.values[a] = y, 1;
      }, "reconfigure")
    };
  }
}, h(Lh, "Kh"), Lh);
m(T8, "FacetProvider");
let Cv = T8;
function Qk(s, t, e) {
  if (s.length != t.length)
    return !1;
  for (let i = 0; i < s.length; i++)
    if (!e(s[i], t[i]))
      return !1;
  return !0;
}
h(Qk, "ru");
m(Qk, "compareArray");
function OO(s, t) {
  let e = !1;
  for (let i of t)
    mh(s, i) & 1 && (e = !0);
  return e;
}
h(OO, "hl$1");
m(OO, "ensureAll");
function M8(s, t, e) {
  let i = e.map((l) => s[l.id]), r = e.map((l) => l.type), n = i.filter((l) => !(l & 1)), a = s[t.id] >> 1;
  function o(l) {
    let d = [];
    for (let u = 0; u < i.length; u++) {
      let p = Pw(l, i[u]);
      if (r[u] == 2)
        for (let f of p)
          d.push(f);
      else
        d.push(p);
    }
    return t.combine(d);
  }
  return h(o, "l"), m(o, "get"), {
    create(l) {
      for (let d of i)
        mh(l, d);
      return l.values[a] = o(l), 1;
    },
    update(l, d) {
      if (!OO(l, n))
        return 0;
      let u = o(l);
      return t.compare(u, l.values[a]) ? 0 : (l.values[a] = u, 1);
    },
    reconfigure(l, d) {
      let u = OO(l, i), p = d.config.facets[t.id], f = d.facet(t);
      if (p && !u && W0(e, p))
        return l.values[a] = f, 0;
      let y = o(l);
      return t.compare(y, f) ? (l.values[a] = f, 0) : (l.values[a] = y, 1);
    }
  };
}
h(M8, "Bg$1");
m(M8, "dynamicFacetSlot");
const K1 = /* @__PURE__ */ Ct.define({ static: !0 });
var xo;
const A8 = (xo = class {
  constructor(t, e, i, r, n) {
    this.id = t, this.createF = e, this.updateF = i, this.compareF = r, this.spec = n, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(t) {
    let e = new xo(JS++, t.create, t.update, t.compare || ((i, r) => i === r), t);
    return t.provide && (e.provides = t.provide(e)), e;
  }
  create(t) {
    return (t.facet(K1).find((i) => i.field == this)?.create || this.createF)(t);
  }
  /**
  @internal
  */
  slot(t) {
    let e = t[this.id] >> 1;
    return {
      create: /* @__PURE__ */ m((i) => (i.values[e] = this.create(i), 1), "create"),
      update: /* @__PURE__ */ m((i, r) => {
        let n = i.values[e], a = this.updateF(n, r);
        return this.compareF(n, a) ? 0 : (i.values[e] = a, 1);
      }, "update"),
      reconfigure: /* @__PURE__ */ m((i, r) => {
        let n = i.facet(K1), a = r.facet(K1), o;
        return (o = n.find((l) => l.field == this)) && o != a.find((l) => l.field == this) ? (i.values[e] = o.create(i), 1) : r.config.address[this.id] != null ? (i.values[e] = r.field(this), 0) : (i.values[e] = this.create(i), 1);
      }, "reconfigure")
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(t) {
    return [this, K1.of({ field: this, create: t })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}, h(xo, "Ys"), xo);
m(A8, "StateField");
let mn = A8;
const lo = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Bc(s) {
  return (t) => new E8(t, s);
}
h(Bc, "nr$1");
m(Bc, "prec");
const Ll = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Bc(lo.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Bc(lo.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Bc(lo.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Bc(lo.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Bc(lo.lowest)
};
var zh;
const R8 = (zh = class {
  constructor(t, e) {
    this.inner = t, this.prec = e;
  }
}, h(zh, "Jh"), zh);
m(R8, "PrecExtension");
let E8 = R8;
var ko;
const _8 = (ko = class {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(t) {
    return new Tk(this, t);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(t) {
    return ko.reconfigure.of({ compartment: this, extension: t });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(t) {
    return t.config.compartments.get(this);
  }
}, h(ko, "Ws"), ko);
m(_8, "Compartment");
let L8 = _8;
var Ih;
const z8 = (Ih = class {
  constructor(t, e) {
    this.compartment = t, this.inner = e;
  }
}, h(Ih, "ef"), Ih);
m(z8, "CompartmentInstance");
let Tk = z8;
var So;
const I8 = (So = class {
  constructor(t, e, i, r, n, a) {
    for (this.base = t, this.compartments = e, this.dynamicSlots = i, this.address = r, this.staticValues = n, this.facets = a, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(t) {
    let e = this.address[t.id];
    return e == null ? t.default : this.staticValues[e >> 1];
  }
  static resolve(t, e, i) {
    let r = [], n = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ new Map();
    for (let f of D8(t, e, a))
      f instanceof mn ? r.push(f) : (n[f.facet.id] || (n[f.facet.id] = [])).push(f);
    let o = /* @__PURE__ */ Object.create(null), l = [], d = [];
    for (let f of r)
      o[f.id] = d.length << 1, d.push((y) => f.slot(y));
    let u = i?.config.facets;
    for (let f in n) {
      let y = n[f], g = y[0].facet, O = u && u[f] || [];
      if (y.every(
        (k) => k.type == 0
        /* Provider.Static */
      ))
        if (o[g.id] = l.length << 1 | 1, W0(O, y))
          l.push(i.facet(g));
        else {
          let k = g.combine(y.map(($) => $.value));
          l.push(i && g.compare(k, i.facet(g)) ? i.facet(g) : k);
        }
      else {
        for (let k of y)
          k.type == 0 ? (o[k.id] = l.length << 1 | 1, l.push(k.value)) : (o[k.id] = d.length << 1, d.push(($) => k.dynamicSlot($)));
        o[g.id] = d.length << 1, d.push((k) => M8(k, g, y));
      }
    }
    let p = d.map((f) => f(o));
    return new So(t, a, p, o, l, n);
  }
}, h(So, "Vs"), So);
m(I8, "Configuration");
let N3 = I8;
function D8(s, t, e) {
  let i = [[], [], [], [], []], r = /* @__PURE__ */ new Map();
  function n(a, o) {
    let l = r.get(a);
    if (l != null) {
      if (l <= o)
        return;
      let d = i[l].indexOf(a);
      d > -1 && i[l].splice(d, 1), a instanceof Tk && e.delete(a.compartment);
    }
    if (r.set(a, o), Array.isArray(a))
      for (let d of a)
        n(d, o);
    else if (a instanceof Tk) {
      if (e.has(a.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let d = t.get(a.compartment) || a.inner;
      e.set(a.compartment, d), n(d, o);
    } else if (a instanceof E8)
      n(a.inner, a.prec);
    else if (a instanceof mn)
      i[o].push(a), a.provides && n(a.provides, o);
    else if (a instanceof Cv)
      i[o].push(a), a.facet.extensions && n(a.facet.extensions, lo.default);
    else {
      let d = a.extension;
      if (!d)
        throw new Error(`Unrecognized extension value in extension set (${a}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      n(d, o);
    }
  }
  return h(n, "s"), m(n, "inner"), n(s, lo.default), i.reduce((a, o) => a.concat(o));
}
h(D8, "Dg$1");
m(D8, "flatten");
function mh(s, t) {
  if (t & 1)
    return 2;
  let e = t >> 1, i = s.status[e];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  s.status[e] = 4;
  let r = s.computeSlot(s, s.config.dynamicSlots[e]);
  return s.status[e] = 2 | r;
}
h(mh, "mr$1");
m(mh, "ensureAddr");
function Pw(s, t) {
  return t & 1 ? s.config.staticValues[t >> 1] : s.values[t >> 1];
}
h(Pw, "es$2");
m(Pw, "getAddr");
const V8 = /* @__PURE__ */ Ct.define(), Mk = /* @__PURE__ */ Ct.define({
  combine: /* @__PURE__ */ m((s) => s.some((t) => t), "combine"),
  static: !0
}), W8 = /* @__PURE__ */ Ct.define({
  combine: /* @__PURE__ */ m((s) => s.length ? s[0] : void 0, "combine"),
  static: !0
}), F8 = /* @__PURE__ */ Ct.define(), q8 = /* @__PURE__ */ Ct.define(), Z8 = /* @__PURE__ */ Ct.define(), B8 = /* @__PURE__ */ Ct.define({
  combine: /* @__PURE__ */ m((s) => s.length ? s[0] : !1, "combine")
});
var Dh;
const N8 = (Dh = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.type = t, this.value = e;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new ZW();
  }
}, h(Dh, "tf"), Dh);
m(N8, "Annotation");
let yn = N8;
var Vh;
const X8 = (Vh = class {
  /**
  Create an instance of this annotation.
  */
  of(t) {
    return new yn(this, t);
  }
}, h(Vh, "rf"), Vh);
m(X8, "AnnotationType");
let ZW = X8;
var Wh;
const j8 = (Wh = class {
  /**
  @internal
  */
  constructor(t) {
    this.map = t;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(t) {
    return new te(this, t);
  }
}, h(Wh, "nf"), Wh);
m(j8, "StateEffectType");
let BW = j8;
var Co;
const U8 = (Co = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.type = t, this.value = e;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(t) {
    let e = this.type.map(this.value, t);
    return e === void 0 ? void 0 : e == this.value ? this : new Co(this.type, e);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(t) {
    return this.type == t;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(t = {}) {
    return new BW(t.map || ((e) => e));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(t, e) {
    if (!t.length)
      return t;
    let i = [];
    for (let r of t) {
      let n = r.map(e);
      n && i.push(n);
    }
    return i;
  }
}, h(Co, "Us"), Co);
m(U8, "StateEffect");
let te = U8;
te.reconfigure = /* @__PURE__ */ te.define();
te.appendConfig = /* @__PURE__ */ te.define();
var ns;
const H8 = (ns = class {
  constructor(t, e, i, r, n, a) {
    this.startState = t, this.changes = e, this.selection = i, this.effects = r, this.annotations = n, this.scrollIntoView = a, this._doc = null, this._state = null, i && KS(i, e.newLength), n.some((o) => o.type == ns.time) || (this.annotations = n.concat(ns.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(t, e, i, r, n, a) {
    return new ns(t, e, i, r, n, a);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(t) {
    for (let e of this.annotations)
      if (e.type == t)
        return e.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(t) {
    let e = this.annotation(ns.userEvent);
    return !!(e && (e == t || e.length > t.length && e.slice(0, t.length) == t && e[t.length] == "."));
  }
}, h(ns, "qt"), ns);
m(H8, "Transaction");
let Mi = H8;
Mi.time = /* @__PURE__ */ yn.define();
Mi.userEvent = /* @__PURE__ */ yn.define();
Mi.addToHistory = /* @__PURE__ */ yn.define();
Mi.remote = /* @__PURE__ */ yn.define();
function Y8(s, t) {
  let e = [];
  for (let i = 0, r = 0; ; ) {
    let n, a;
    if (i < s.length && (r == t.length || t[r] >= s[i]))
      n = s[i++], a = s[i++];
    else if (r < t.length)
      n = t[r++], a = t[r++];
    else
      return e;
    !e.length || e[e.length - 1] < n ? e.push(n, a) : e[e.length - 1] < a && (e[e.length - 1] = a);
  }
}
h(Y8, "Ng$1");
m(Y8, "joinRanges");
function tC(s, t, e) {
  var i;
  let r, n, a;
  return e ? (r = t.changes, n = Dr.empty(t.changes.length), a = s.changes.compose(t.changes)) : (r = t.changes.map(s.changes), n = s.changes.mapDesc(t.changes, !0), a = s.changes.compose(r)), {
    changes: a,
    selection: t.selection ? t.selection.map(n) : (i = s.selection) === null || i === void 0 ? void 0 : i.map(r),
    effects: te.mapEffects(s.effects, r).concat(te.mapEffects(t.effects, n)),
    annotations: s.annotations.length ? s.annotations.concat(t.annotations) : t.annotations,
    scrollIntoView: s.scrollIntoView || t.scrollIntoView
  };
}
h(tC, "dd$1");
m(tC, "mergeTransaction");
function bO(s, t, e) {
  let i = t.selection, r = fo(t.annotations);
  return t.userEvent && (r = r.concat(Mi.userEvent.of(t.userEvent))), {
    changes: t.changes instanceof Dr ? t.changes : Dr.of(t.changes || [], e, s.facet(W8)),
    selection: i && (i instanceof nt ? i : nt.single(i.anchor, i.head)),
    effects: fo(t.effects),
    annotations: r,
    scrollIntoView: !!t.scrollIntoView
  };
}
h(bO, "Ol$1");
m(bO, "resolveTransactionInner");
function eC(s, t, e) {
  let i = bO(s, t.length ? t[0] : {}, s.doc.length);
  t.length && t[0].filter === !1 && (e = !1);
  for (let n = 1; n < t.length; n++) {
    t[n].filter === !1 && (e = !1);
    let a = !!t[n].sequential;
    i = tC(i, bO(s, t[n], a ? i.changes.newLength : s.doc.length), a);
  }
  let r = Mi.create(s, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return K8(e ? G8(r) : r);
}
h(eC, "pd$1");
m(eC, "resolveTransaction");
function G8(s) {
  let t = s.startState, e = !0;
  for (let r of t.facet(F8)) {
    let n = r(s);
    if (n === !1) {
      e = !1;
      break;
    }
    Array.isArray(n) && (e = e === !0 ? n : Y8(e, n));
  }
  if (e !== !0) {
    let r, n;
    if (e === !1)
      n = s.changes.invertedDesc, r = Dr.empty(t.doc.length);
    else {
      let a = s.changes.filter(e);
      r = a.changes, n = a.filtered.mapDesc(a.changes).invertedDesc;
    }
    s = Mi.create(t, r, s.selection && s.selection.map(n), te.mapEffects(s.effects, n), s.annotations, s.scrollIntoView);
  }
  let i = t.facet(q8);
  for (let r = i.length - 1; r >= 0; r--) {
    let n = i[r](s);
    n instanceof Mi ? s = n : Array.isArray(n) && n.length == 1 && n[0] instanceof Mi ? s = n[0] : s = eC(t, fo(n), !1);
  }
  return s;
}
h(G8, "Gg$1");
m(G8, "filterTransaction");
function K8(s) {
  let t = s.startState, e = t.facet(Z8), i = s;
  for (let r = e.length - 1; r >= 0; r--) {
    let n = e[r](s);
    n && Object.keys(n).length && (i = tC(i, bO(t, n, s.changes.newLength), !0));
  }
  return i == s ? s : Mi.create(t, s.changes, s.selection, i.effects, i.annotations, i.scrollIntoView);
}
h(K8, "Fg$1");
m(K8, "extendTransaction");
const NW = [];
function fo(s) {
  return s == null ? NW : Array.isArray(s) ? s : [s];
}
h(fo, "wi$1");
m(fo, "asArray");
var Fs = /* @__PURE__ */ (function(s) {
  return s[s.Word = 0] = "Word", s[s.Space = 1] = "Space", s[s.Other = 2] = "Other", s;
})(Fs || (Fs = {}));
const XW = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let Ak;
try {
  Ak = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function J8(s) {
  if (Ak)
    return Ak.test(s);
  for (let t = 0; t < s.length; t++) {
    let e = s[t];
    if (/\w/.test(e) || e > "" && (e.toUpperCase() != e.toLowerCase() || XW.test(e)))
      return !0;
  }
  return !1;
}
h(J8, "Jg$1");
m(J8, "hasWordChar");
function t7(s) {
  return (t) => {
    if (!/\S/.test(t))
      return Fs.Space;
    if (J8(t))
      return Fs.Word;
    for (let e = 0; e < s.length; e++)
      if (t.indexOf(s[e]) > -1)
        return Fs.Word;
    return Fs.Other;
  };
}
h(t7, "e0$1");
m(t7, "makeCategorizer");
var mi;
const e7 = (mi = class {
  constructor(t, e, i, r, n, a) {
    this.config = t, this.doc = e, this.selection = i, this.values = r, this.status = t.statusTemplate.slice(), this.computeSlot = n, a && (a._state = this);
    for (let o = 0; o < this.config.dynamicSlots.length; o++)
      mh(this, o << 1);
    this.computeSlot = null;
  }
  field(t, e = !0) {
    let i = this.config.address[t.id];
    if (i == null) {
      if (e)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return mh(this, i), Pw(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...t) {
    return eC(this, t, !0);
  }
  /**
  @internal
  */
  applyTransaction(t) {
    let e = this.config, { base: i, compartments: r } = e;
    for (let o of t.effects)
      o.is(L8.reconfigure) ? (e && (r = /* @__PURE__ */ new Map(), e.compartments.forEach((l, d) => r.set(d, l)), e = null), r.set(o.value.compartment, o.value.extension)) : o.is(te.reconfigure) ? (e = null, i = o.value) : o.is(te.appendConfig) && (e = null, i = fo(i).concat(o.value));
    let n;
    e ? n = t.startState.values.slice() : (e = N3.resolve(i, r, this), n = new mi(e, this.doc, this.selection, e.dynamicSlots.map(() => null), (o, l) => l.reconfigure(o, this), null).values);
    let a = t.startState.facet(Mk) ? t.newSelection : t.newSelection.asSingle();
    new mi(e, t.newDoc, a, n, (o, l) => l.update(o, t), t);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(t) {
    return typeof t == "string" && (t = this.toText(t)), this.changeByRange((e) => ({
      changes: { from: e.from, to: e.to, insert: t },
      range: nt.cursor(e.from + t.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(t) {
    let e = this.selection, i = t(e.ranges[0]), r = this.changes(i.changes), n = [i.range], a = fo(i.effects);
    for (let o = 1; o < e.ranges.length; o++) {
      let l = t(e.ranges[o]), d = this.changes(l.changes), u = d.map(r);
      for (let f = 0; f < o; f++)
        n[f] = n[f].map(u);
      let p = r.mapDesc(d, !0);
      n.push(l.range.map(p)), r = r.compose(u), a = te.mapEffects(a, u).concat(te.mapEffects(fo(l.effects), p));
    }
    return {
      changes: r,
      selection: nt.create(n, e.mainIndex),
      effects: a
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(t = []) {
    return t instanceof Dr ? t : Dr.of(t, this.doc.length, this.facet(mi.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(t) {
    return Ht.of(t.split(this.facet(mi.lineSeparator) || Pk));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(t = 0, e = this.doc.length) {
    return this.doc.sliceString(t, e, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(t) {
    let e = this.config.address[t.id];
    return e == null ? t.default : (mh(this, e), Pw(this, e));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(t) {
    let e = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (t)
      for (let i in t) {
        let r = t[i];
        r instanceof mn && this.config.address[r.id] != null && (e[i] = r.spec.toJSON(this.field(t[i]), this));
      }
    return e;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(t, e = {}, i) {
    if (!t || typeof t.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let r = [];
    if (i) {
      for (let n in i)
        if (Object.prototype.hasOwnProperty.call(t, n)) {
          let a = i[n], o = t[n];
          r.push(a.init((l) => a.spec.fromJSON(o, l)));
        }
    }
    return mi.create({
      doc: t.doc,
      selection: nt.fromJSON(t.selection),
      extensions: e.extensions ? r.concat([e.extensions]) : r
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(t = {}) {
    let e = N3.resolve(t.extensions || [], /* @__PURE__ */ new Map()), i = t.doc instanceof Ht ? t.doc : Ht.of((t.doc || "").split(e.staticFacet(mi.lineSeparator) || Pk)), r = t.selection ? t.selection instanceof nt ? t.selection : nt.single(t.selection.anchor, t.selection.head) : nt.single(0);
    return KS(r, i.length), e.staticFacet(Mk) || (r = r.asSingle()), new mi(e, i, r, e.dynamicSlots.map(() => null), (n, a) => a.create(n), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(mi.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(mi.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(B8);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(t, ...e) {
    for (let i of this.facet(mi.phrases))
      if (Object.prototype.hasOwnProperty.call(i, t)) {
        t = i[t];
        break;
      }
    return e.length && (t = t.replace(/\$(\$|\d*)/g, (i, r) => {
      if (r == "$")
        return "$";
      let n = +(r || 1);
      return !n || n > e.length ? i : e[n - 1];
    })), t;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(t, e, i = -1) {
    let r = [];
    for (let n of this.facet(V8))
      for (let a of n(this, e, i))
        Object.prototype.hasOwnProperty.call(a, t) && r.push(a[t]);
    return r;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(t) {
    let e = this.languageDataAt("wordChars", t);
    return t7(e.length ? e[0] : "");
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(t) {
    let { text: e, from: i, length: r } = this.doc.lineAt(t), n = this.charCategorizer(t), a = t - i, o = t - i;
    for (; a > 0; ) {
      let l = nr(e, a, !1);
      if (n(e.slice(l, a)) != Fs.Word)
        break;
      a = l;
    }
    for (; o < r; ) {
      let l = nr(e, o);
      if (n(e.slice(o, l)) != Fs.Word)
        break;
      o = l;
    }
    return a == o ? null : nt.range(a + i, o + i);
  }
}, h(mi, "xe"), mi);
m(e7, "EditorState");
let Be = e7;
Be.allowMultipleSelections = Mk;
Be.tabSize = /* @__PURE__ */ Ct.define({
  combine: /* @__PURE__ */ m((s) => s.length ? s[0] : 4, "combine")
});
Be.lineSeparator = W8;
Be.readOnly = B8;
Be.phrases = /* @__PURE__ */ Ct.define({
  compare(s, t) {
    let e = Object.keys(s), i = Object.keys(t);
    return e.length == i.length && e.every((r) => s[r] == t[r]);
  }
});
Be.languageData = V8;
Be.changeFilter = F8;
Be.transactionFilter = q8;
Be.transactionExtender = Z8;
L8.reconfigure = /* @__PURE__ */ te.define();
function iC(s, t, e = {}) {
  let i = {};
  for (let r of s)
    for (let n of Object.keys(r)) {
      let a = r[n], o = i[n];
      if (o === void 0)
        i[n] = a;
      else if (!(o === a || a === void 0)) if (Object.hasOwnProperty.call(e, n))
        i[n] = e[n](o, a);
      else
        throw new Error("Config merge conflict for field " + n);
    }
  for (let r in t)
    i[r] === void 0 && (i[r] = t[r]);
  return i;
}
h(iC, "md$1");
m(iC, "combineConfig");
var Fh;
const i7 = (Fh = class {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(t) {
    return this == t;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(t, e = t) {
    return Rk.create(t, e, this);
  }
}, h(Fh, "sf"), Fh);
m(i7, "RangeValue");
let da = i7;
da.prototype.startSide = da.prototype.endSide = 0;
da.prototype.point = !1;
da.prototype.mapMode = Ti.TrackDel;
function F0(s, t) {
  return s == t || s.constructor == t.constructor && s.eq(t);
}
h(F0, "ch$1");
m(F0, "cmpVal");
var J1, qh;
let Rk = (J1 = (qh = class {
  constructor(t, e, i) {
    this.from = t, this.to = e, this.value = i;
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new J1(t, e, i);
  }
}, h(qh, "ti$1"), qh), m(J1, "Range"), J1);
function $O(s, t) {
  return s.from - t.from || s.value.startSide - t.value.startSide;
}
h($O, "ml$1");
m($O, "cmpRange");
var Po;
const r7 = (Po = class {
  constructor(t, e, i, r) {
    this.from = t, this.to = e, this.value = i, this.maxPoint = r;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(t, e, i, r = 0) {
    let n = i ? this.to : this.from;
    for (let a = r, o = n.length; ; ) {
      if (a == o)
        return a;
      let l = a + o >> 1, d = n[l] - t || (i ? this.value[l].endSide : this.value[l].startSide) - e;
      if (l == a)
        return d >= 0 ? a : o;
      d >= 0 ? o = l : a = l + 1;
    }
  }
  between(t, e, i, r) {
    for (let n = this.findIndex(e, -1e9, !0), a = this.findIndex(i, 1e9, !1, n); n < a; n++)
      if (r(this.from[n] + t, this.to[n] + t, this.value[n]) === !1)
        return !1;
  }
  map(t, e) {
    let i = [], r = [], n = [], a = -1, o = -1;
    for (let l = 0; l < this.value.length; l++) {
      let d = this.value[l], u = this.from[l] + t, p = this.to[l] + t, f, y;
      if (u == p) {
        let g = e.mapPos(u, d.startSide, d.mapMode);
        if (g == null || (f = y = g, d.startSide != d.endSide && (y = e.mapPos(u, d.endSide), y < f)))
          continue;
      } else if (f = e.mapPos(u, d.startSide), y = e.mapPos(p, d.endSide), f > y || f == y && d.startSide > 0 && d.endSide <= 0)
        continue;
      (y - f || d.endSide - d.startSide) < 0 || (a < 0 && (a = f), d.point && (o = Math.max(o, y - f)), i.push(d), r.push(f - a), n.push(y - a));
    }
    return { mapped: i.length ? new Po(r, n, i, o) : null, pos: a };
  }
}, h(Po, "Is"), Po);
m(r7, "Chunk");
let jW = r7;
var Vi;
const s7 = (Vi = class {
  constructor(t, e, i, r) {
    this.chunkPos = t, this.chunk = e, this.nextLayer = i, this.maxPoint = r;
  }
  /**
  @internal
  */
  static create(t, e, i, r) {
    return new Vi(t, e, i, r);
  }
  /**
  @internal
  */
  get length() {
    let t = this.chunk.length - 1;
    return t < 0 ? 0 : Math.max(this.chunkEnd(t), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let t = this.nextLayer.size;
    for (let e of this.chunk)
      t += e.value.length;
    return t;
  }
  /**
  @internal
  */
  chunkEnd(t) {
    return this.chunkPos[t] + this.chunk[t].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(t) {
    let { add: e = [], sort: i = !1, filterFrom: r = 0, filterTo: n = this.length } = t, a = t.filter;
    if (e.length == 0 && !a)
      return this;
    if (i && (e = e.slice().sort($O)), this.isEmpty)
      return e.length ? Vi.of(e) : this;
    let o = new l7(this, null, -1).goto(0), l = 0, d = [], u = new xO();
    for (; o.value || l < e.length; )
      if (l < e.length && (o.from - e[l].from || o.startSide - e[l].value.startSide) >= 0) {
        let p = e[l++];
        u.addInner(p.from, p.to, p.value) || d.push(p);
      } else o.rangeIndex == 1 && o.chunkIndex < this.chunk.length && (l == e.length || this.chunkEnd(o.chunkIndex) < e[l].from) && (!a || r > this.chunkEnd(o.chunkIndex) || n < this.chunkPos[o.chunkIndex]) && u.addChunk(this.chunkPos[o.chunkIndex], this.chunk[o.chunkIndex]) ? o.nextChunk() : ((!a || r > o.to || n < o.from || a(o.from, o.to, o.value)) && (u.addInner(o.from, o.to, o.value) || d.push(Rk.create(o.from, o.to, o.value))), o.next());
    return u.finishInner(this.nextLayer.isEmpty && !d.length ? Vi.empty : this.nextLayer.update({ add: d, filter: a, filterFrom: r, filterTo: n }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(t) {
    if (t.empty || this.isEmpty)
      return this;
    let e = [], i = [], r = -1;
    for (let a = 0; a < this.chunk.length; a++) {
      let o = this.chunkPos[a], l = this.chunk[a], d = t.touchesRange(o, o + l.length);
      if (d === !1)
        r = Math.max(r, l.maxPoint), e.push(l), i.push(t.mapPos(o));
      else if (d === !0) {
        let { mapped: u, pos: p } = l.map(o, t);
        u && (r = Math.max(r, u.maxPoint), e.push(u), i.push(p));
      }
    }
    let n = this.nextLayer.map(t);
    return e.length == 0 ? n : new Vi(i, e, n || Vi.empty, r);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(t, e, i) {
    if (!this.isEmpty) {
      for (let r = 0; r < this.chunk.length; r++) {
        let n = this.chunkPos[r], a = this.chunk[r];
        if (e >= n && t <= n + a.length && a.between(n, t - n, e - n, i) === !1)
          return;
      }
      this.nextLayer.between(t, e, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(t = 0) {
    return _k.from([this]).goto(t);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(t, e = 0) {
    return _k.from(t).goto(e);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(t, e, i, r, n = -1) {
    let a = t.filter((p) => p.maxPoint > 0 || !p.isEmpty && p.maxPoint >= n), o = e.filter((p) => p.maxPoint > 0 || !p.isEmpty && p.maxPoint >= n), l = Ek(a, o, i), d = new eg(a, l, n), u = new eg(o, l, n);
    i.iterGaps((p, f, y) => Lk(d, p, u, f, y, r)), i.empty && i.length == 0 && Lk(d, 0, u, 0, 0, r);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(t, e, i = 0, r) {
    r == null && (r = 999999999);
    let n = t.filter((u) => !u.isEmpty && e.indexOf(u) < 0), a = e.filter((u) => !u.isEmpty && t.indexOf(u) < 0);
    if (n.length != a.length)
      return !1;
    if (!n.length)
      return !0;
    let o = Ek(n, a), l = new eg(n, o, 0).goto(i), d = new eg(a, o, 0).goto(i);
    for (; ; ) {
      if (l.to != d.to || !kO(l.active, d.active) || l.point && (!d.point || !F0(l.point, d.point)))
        return !1;
      if (l.to > r)
        return !0;
      l.next(), d.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(t, e, i, r, n = -1) {
    let a = new eg(t, null, n).goto(e), o = e, l = a.openStart;
    for (; ; ) {
      let d = Math.min(a.to, i);
      if (a.point) {
        let u = a.activeForPoint(a.to), p = a.pointFrom < e ? u.length + 1 : a.point.startSide < 0 ? u.length : Math.min(u.length, l);
        r.point(o, d, a.point, u, p, a.pointRank), l = Math.min(a.openEnd(d), u.length);
      } else d > o && (r.span(o, d, a.active, l), l = a.openEnd(d));
      if (a.to > i)
        return l + (a.point && a.to > i ? 1 : 0);
      o = a.to, a.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(t, e = !1) {
    let i = new xO();
    for (let r of t instanceof Rk ? [t] : e ? n7(t) : t)
      i.add(r.from, r.to, r.value);
    return i.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(t) {
    if (!t.length)
      return Vi.empty;
    let e = t[t.length - 1];
    for (let i = t.length - 2; i >= 0; i--)
      for (let r = t[i]; r != Vi.empty; r = r.nextLayer)
        e = new Vi(r.chunkPos, r.chunk, e, Math.max(r.maxPoint, e.maxPoint));
    return e;
  }
}, h(Vi, "Ve"), Vi);
m(s7, "RangeSet");
let ze = s7;
ze.empty = /* @__PURE__ */ new ze([], [], null, -1);
function n7(s) {
  if (s.length > 1)
    for (let t = s[0], e = 1; e < s.length; e++) {
      let i = s[e];
      if ($O(t, i) > 0)
        return s.slice().sort($O);
      t = i;
    }
  return s;
}
h(n7, "t0$1");
m(n7, "lazySort");
ze.empty.nextLayer = ze.empty;
var Qo;
const a7 = (Qo = class {
  finishChunk(t) {
    this.chunks.push(new jW(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, t && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(t, e, i) {
    this.addInner(t, e, i) || (this.nextLayer || (this.nextLayer = new Qo())).add(t, e, i);
  }
  /**
  @internal
  */
  addInner(t, e, i) {
    let r = t - this.lastTo || i.startSide - this.last.endSide;
    if (r <= 0 && (t - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return r < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = t), this.from.push(t - this.chunkStart), this.to.push(e - this.chunkStart), this.last = i, this.lastFrom = t, this.lastTo = e, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, e - t)), !0);
  }
  /**
  @internal
  */
  addChunk(t, e) {
    if ((t - this.lastTo || e.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, e.maxPoint), this.chunks.push(e), this.chunkPos.push(t);
    let i = e.value.length - 1;
    return this.last = e.value[i], this.lastFrom = e.from[i] + t, this.lastTo = e.to[i] + t, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(ze.empty);
  }
  /**
  @internal
  */
  finishInner(t) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return t;
    let e = ze.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(t) : t, this.setMaxPoint);
    return this.from = null, e;
  }
}, h(Qo, "zs"), Qo);
m(a7, "RangeSetBuilder");
let xO = a7;
function Ek(s, t, e) {
  let i = /* @__PURE__ */ new Map();
  for (let n of s)
    for (let a = 0; a < n.chunk.length; a++)
      n.chunk[a].maxPoint <= 0 && i.set(n.chunk[a], n.chunkPos[a]);
  let r = /* @__PURE__ */ new Set();
  for (let n of t)
    for (let a = 0; a < n.chunk.length; a++) {
      let o = i.get(n.chunk[a]);
      o != null && (e ? e.mapPos(o) : o) == n.chunkPos[a] && !e?.touchesRange(o, o + n.chunk[a].length) && r.add(n.chunk[a]);
    }
  return r;
}
h(Ek, "nu");
m(Ek, "findSharedChunks");
var Zh;
const o7 = (Zh = class {
  constructor(t, e, i, r = 0) {
    this.layer = t, this.skip = e, this.minPoint = i, this.rank = r;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(t, e = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(t, e, !1), this;
  }
  gotoInner(t, e, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let r = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(r) || this.layer.chunkEnd(this.chunkIndex) < t || r.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let r = this.layer.chunk[this.chunkIndex].findIndex(t - this.layer.chunkPos[this.chunkIndex], e, !0);
      (!i || this.rangeIndex < r) && this.setRangeIndex(r);
    }
    this.next();
  }
  forward(t, e) {
    (this.to - t || this.endSide - e) < 0 && this.gotoInner(t, e, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let t = this.layer.chunkPos[this.chunkIndex], e = this.layer.chunk[this.chunkIndex], i = t + e.from[this.rangeIndex];
        if (this.from = i, this.to = t + e.to[this.rangeIndex], this.value = e.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(t) {
    if (t == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = t;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(t) {
    return this.from - t.from || this.startSide - t.startSide || this.rank - t.rank || this.to - t.to || this.endSide - t.endSide;
  }
}, h(Zh, "of"), Zh);
m(o7, "LayerCursor");
let l7 = o7;
var To;
const c7 = (To = class {
  constructor(t) {
    this.heap = t;
  }
  static from(t, e = null, i = -1) {
    let r = [];
    for (let n = 0; n < t.length; n++)
      for (let a = t[n]; !a.isEmpty; a = a.nextLayer)
        a.maxPoint >= i && r.push(new l7(a, e, i, n));
    return r.length == 1 ? r[0] : new To(r);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(t, e = -1e9) {
    for (let i of this.heap)
      i.goto(t, e);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Pv(this.heap, i);
    return this.next(), this;
  }
  forward(t, e) {
    for (let i of this.heap)
      i.forward(t, e);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Pv(this.heap, i);
    (this.to - t || this.value.endSide - e) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let t = this.heap[0];
      this.from = t.from, this.to = t.to, this.value = t.value, this.rank = t.rank, t.value && t.next(), Pv(this.heap, 0);
    }
  }
}, h(To, "js"), To);
m(c7, "HeapCursor");
let _k = c7;
function Pv(s, t) {
  for (let e = s[t]; ; ) {
    let i = (t << 1) + 1;
    if (i >= s.length)
      break;
    let r = s[i];
    if (i + 1 < s.length && r.compare(s[i + 1]) >= 0 && (r = s[i + 1], i++), e.compare(r) < 0)
      break;
    s[i] = e, s[t] = r, t = i;
  }
}
h(Pv, "vo$1");
m(Pv, "heapBubble");
var Bh;
const h7 = (Bh = class {
  constructor(t, e, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = _k.from(t, e, i);
  }
  goto(t, e = -1e9) {
    return this.cursor.goto(t, e), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = t, this.endSide = e, this.openStart = -1, this.next(), this;
  }
  forward(t, e) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - t || this.active[this.minActive].endSide - e) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(t, e);
  }
  removeActive(t) {
    Cg(this.active, t), Cg(this.activeTo, t), Cg(this.activeRank, t), this.minActive = zk(this.active, this.activeTo);
  }
  addActive(t) {
    let e = 0, { value: i, to: r, rank: n } = this.cursor;
    for (; e < this.activeRank.length && (n - this.activeRank[e] || r - this.activeTo[e]) > 0; )
      e++;
    Pg(this.active, e, i), Pg(this.activeTo, e, r), Pg(this.activeRank, e, n), t && Pg(t, e, this.cursor.from), this.minActive = zk(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let t = this.to, e = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let r = this.minActive;
      if (r > -1 && (this.activeTo[r] - this.cursor.from || this.active[r].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[r] > t) {
          this.to = this.activeTo[r], this.endSide = this.active[r].endSide;
          break;
        }
        this.removeActive(r), i && Cg(i, r);
      } else if (this.cursor.value)
        if (this.cursor.from > t) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let n = this.cursor.value;
          if (!n.point)
            this.addActive(i), this.cursor.next();
          else if (e && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = n, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = n.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let r = i.length - 1; r >= 0 && i[r] < t; r--)
        this.openStart++;
    }
  }
  activeForPoint(t) {
    if (!this.active.length)
      return this.active;
    let e = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > t || this.activeTo[i] == t && this.active[i].endSide >= this.point.endSide) && e.push(this.active[i]);
    return e.reverse();
  }
  openEnd(t) {
    let e = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > t; i--)
      e++;
    return e;
  }
}, h(Bh, "lf"), Bh);
m(h7, "SpanCursor");
let eg = h7;
function Lk(s, t, e, i, r, n) {
  s.goto(t), e.goto(i);
  let a = i + r, o = i, l = i - t, d = !!n.boundChange;
  for (let u = !1; ; ) {
    let p = s.to + l - e.to, f = p || s.endSide - e.endSide, y = f < 0 ? s.to + l : e.to, g = Math.min(y, a);
    if (s.point || e.point ? (s.point && e.point && F0(s.point, e.point) && kO(s.activeForPoint(s.to), e.activeForPoint(e.to)) || n.comparePoint(o, g, s.point, e.point), u = !1) : (u && n.boundChange(o), g > o && !kO(s.active, e.active) && n.compareRange(o, g, s.active, e.active), d && g < a && (p || s.openEnd(y) != e.openEnd(y)) && (u = !0)), y > a)
      break;
    o = y, f <= 0 && s.next(), f >= 0 && e.next();
  }
}
h(Lk, "su");
m(Lk, "compare");
function kO(s, t) {
  if (s.length != t.length)
    return !1;
  for (let e = 0; e < s.length; e++)
    if (s[e] != t[e] && !F0(s[e], t[e]))
      return !1;
  return !0;
}
h(kO, "Ql$1");
m(kO, "sameValues");
function Cg(s, t) {
  for (let e = t, i = s.length - 1; e < i; e++)
    s[e] = s[e + 1];
  s.pop();
}
h(Cg, "$n$1");
m(Cg, "remove");
function Pg(s, t, e) {
  for (let i = s.length - 1; i >= t; i--)
    s[i + 1] = s[i];
  s[t] = e;
}
h(Pg, "Rn$1");
m(Pg, "insert");
function zk(s, t) {
  let e = -1, i = 1e9;
  for (let r = 0; r < t.length; r++)
    (t[r] - i || s[r].endSide - s[e].endSide) < 0 && (e = r, i = t[r]);
  return e;
}
h(zk, "ou");
m(zk, "findMinIndex");
function ua(s, t, e = s.length) {
  let i = 0;
  for (let r = 0; r < e && r < s.length; )
    s.charCodeAt(r) == 9 ? (i += t - i % t, r++) : (i++, r = nr(s, r));
  return i;
}
h(ua, "ut$2");
m(ua, "countColumn");
function d7(s, t, e, i) {
  for (let r = 0, n = 0; ; ) {
    if (n >= t)
      return r;
    if (r == s.length)
      break;
    n += s.charCodeAt(r) == 9 ? e - n % e : 1, r = nr(s, r);
  }
  return s.length;
}
h(d7, "i0$1");
m(d7, "findColumn");
const Ik = "ͼ", X3 = typeof Symbol > "u" ? "__" + Ik : Symbol.for(Ik), Dk = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), j3 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
var Nh;
const u7 = (Nh = class {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(t, e) {
    this.rules = [];
    let { finish: i } = e || {};
    function r(a) {
      return /^@/.test(a) ? [a] : a.split(/,\s*/);
    }
    h(r, "n"), m(r, "splitSelector");
    function n(a, o, l, d) {
      let u = [], p = /^@(\w+)\b/.exec(a[0]), f = p && p[1] == "keyframes";
      if (p && o == null) return l.push(a[0] + ";");
      for (let y in o) {
        let g = o[y];
        if (/&/.test(y))
          n(
            y.split(/,\s*/).map((O) => a.map((k) => O.replace(/&/, k))).reduce((O, k) => O.concat(k)),
            g,
            l
          );
        else if (g && typeof g == "object") {
          if (!p) throw new RangeError("The value of a property (" + y + ") should be a primitive value.");
          n(r(y), g, u, f);
        } else g != null && u.push(y.replace(/_.*/, "").replace(/[A-Z]/g, (O) => "-" + O.toLowerCase()) + ": " + g + ";");
      }
      (u.length || f) && l.push((i && !p && !d ? a.map(i) : a).join(", ") + " {" + u.join(" ") + "}");
    }
    h(n, "s"), m(n, "render");
    for (let a in t) n(r(a), t[a], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let t = j3[X3] || 1;
    return j3[X3] = t + 1, Ik + t.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(t, e, i) {
    let r = t[Dk], n = i && i.nonce;
    r ? n && r.setNonce(n) : r = new UW(t, n), r.mount(Array.isArray(e) ? e : [e], t);
  }
}, h(Nh, "af"), Nh);
m(u7, "StyleModule");
let pa = u7, U3 = /* @__PURE__ */ new Map();
var Xh;
const p7 = (Xh = class {
  constructor(t, e) {
    let i = t.ownerDocument || t, r = i.defaultView;
    if (!t.head && t.adoptedStyleSheets && r.CSSStyleSheet) {
      let n = U3.get(i);
      if (n) return t[Dk] = n;
      this.sheet = new r.CSSStyleSheet(), U3.set(i, this);
    } else
      this.styleTag = i.createElement("style"), e && this.styleTag.setAttribute("nonce", e);
    this.modules = [], t[Dk] = this;
  }
  mount(t, e) {
    let i = this.sheet, r = 0, n = 0;
    for (let a = 0; a < t.length; a++) {
      let o = t[a], l = this.modules.indexOf(o);
      if (l < n && l > -1 && (this.modules.splice(l, 1), n--, l = -1), l == -1) {
        if (this.modules.splice(n++, 0, o), i) for (let d = 0; d < o.rules.length; d++)
          i.insertRule(o.rules[d], r++);
      } else {
        for (; n < l; ) r += this.modules[n++].rules.length;
        r += o.rules.length, n++;
      }
    }
    if (i)
      e.adoptedStyleSheets.indexOf(this.sheet) < 0 && (e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets]);
    else {
      let a = "";
      for (let l = 0; l < this.modules.length; l++)
        a += this.modules[l].getRules() + `
`;
      this.styleTag.textContent = a;
      let o = e.head || e;
      this.styleTag.parentNode != o && o.insertBefore(this.styleTag, o.firstChild);
    }
  }
  setNonce(t) {
    this.styleTag && this.styleTag.getAttribute("nonce") != t && this.styleTag.setAttribute("nonce", t);
  }
}, h(Xh, "hf"), Xh);
m(p7, "StyleSet");
let UW = p7;
var fa = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Qw = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, HW = typeof navigator < "u" && /Mac/.test(navigator.platform), YW = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var ci = 0; ci < 10; ci++) fa[48 + ci] = fa[96 + ci] = String(ci);
for (var ci = 1; ci <= 24; ci++) fa[ci + 111] = "F" + ci;
for (var ci = 65; ci <= 90; ci++)
  fa[ci] = String.fromCharCode(ci + 32), Qw[ci] = String.fromCharCode(ci);
for (var u2 in fa) Qw.hasOwnProperty(u2) || (Qw[u2] = fa[u2]);
function f7(s) {
  var t = HW && s.metaKey && s.shiftKey && !s.ctrlKey && !s.altKey || YW && s.shiftKey && s.key && s.key.length == 1 || s.key == "Unidentified", e = !t && s.key || (s.shiftKey ? Qw : fa)[s.keyCode] || s.key || "Unidentified";
  return e == "Esc" && (e = "Escape"), e == "Del" && (e = "Delete"), e == "Left" && (e = "ArrowLeft"), e == "Up" && (e = "ArrowUp"), e == "Right" && (e = "ArrowRight"), e == "Down" && (e = "ArrowDown"), e;
}
h(f7, "s0$1");
m(f7, "keyName");
let Ci = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, Vk = typeof document < "u" ? document : { documentElement: { style: {} } };
const Wk = /* @__PURE__ */ /Edge\/(\d+)/.exec(Ci.userAgent), m7 = /* @__PURE__ */ /MSIE \d/.test(Ci.userAgent), Fk = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Ci.userAgent), q0 = !!(m7 || Fk || Wk), H3 = !q0 && /* @__PURE__ */ /gecko\/(\d+)/i.test(Ci.userAgent), p2 = !q0 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Ci.userAgent), GW = "webkitFontSmoothing" in Vk.documentElement.style, qk = !q0 && /* @__PURE__ */ /Apple Computer/.test(Ci.vendor), Y3 = qk && (/* @__PURE__ */ /Mobile\/\w+/.test(Ci.userAgent) || Ci.maxTouchPoints > 2);
var at = {
  mac: Y3 || /* @__PURE__ */ /Mac/.test(Ci.platform),
  windows: /* @__PURE__ */ /Win/.test(Ci.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Ci.platform),
  ie: q0,
  ie_version: m7 ? Vk.documentMode || 6 : Fk ? +Fk[1] : Wk ? +Wk[1] : 0,
  gecko: H3,
  gecko_version: H3 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Ci.userAgent) || [0, 0])[1] : 0,
  chrome: !!p2,
  chrome_version: p2 ? +p2[1] : 0,
  ios: Y3,
  android: /* @__PURE__ */ /Android\b/.test(Ci.userAgent),
  webkit_version: GW ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(Ci.userAgent) || [0, 0])[1] : 0,
  safari: qk,
  safari_version: qk ? +(/* @__PURE__ */ /\bVersion\/(\d+(\.\d+)?)/.exec(Ci.userAgent) || [0, 0])[1] : 0,
  tabSize: Vk.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
function Z0(s, t) {
  for (let e in s)
    e == "class" && t.class ? t.class += " " + s.class : e == "style" && t.style ? t.style += ";" + s.style : t[e] = s[e];
  return t;
}
h(Z0, "uh$1");
m(Z0, "combineAttrs");
const SO = /* @__PURE__ */ Object.create(null);
function B0(s, t, e) {
  if (s == t)
    return !0;
  s || (s = SO), t || (t = SO);
  let i = Object.keys(s), r = Object.keys(t);
  if (i.length - 0 != r.length - 0)
    return !1;
  for (let n of i)
    if (n != e && (r.indexOf(n) == -1 || s[n] !== t[n]))
      return !1;
  return !0;
}
h(B0, "Oh$1");
m(B0, "attrsEq");
function y7(s, t) {
  for (let e = s.attributes.length - 1; e >= 0; e--) {
    let i = s.attributes[e].name;
    t[i] == null && s.removeAttribute(i);
  }
  for (let e in t) {
    let i = t[e];
    e == "style" ? s.style.cssText = i : s.getAttribute(e) != i && s.setAttribute(e, i);
  }
}
h(y7, "l0$1");
m(y7, "setAttrs");
function Zk(s, t, e) {
  let i = !1;
  if (t)
    for (let r in t)
      e && r in e || (i = !0, r == "style" ? s.style.cssText = "" : s.removeAttribute(r));
  if (e)
    for (let r in e)
      t && t[r] == e[r] || (i = !0, r == "style" ? s.style.cssText = e[r] : s.setAttribute(r, e[r]));
  return i;
}
h(Zk, "uu");
m(Zk, "updateAttrs");
function g7(s) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let e = 0; e < s.attributes.length; e++) {
    let i = s.attributes[e];
    t[i.name] = i.value;
  }
  return t;
}
h(g7, "a0$1");
m(g7, "getAttrs$1");
var jh;
const w7 = (jh = class {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(t) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(t, e) {
    return !1;
  }
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(t) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(t, e, i) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(t) {
  }
}, h(jh, "ff"), jh);
m(w7, "WidgetType");
let zl = w7;
var vr = /* @__PURE__ */ (function(s) {
  return s[s.Text = 0] = "Text", s[s.WidgetBefore = 1] = "WidgetBefore", s[s.WidgetAfter = 2] = "WidgetAfter", s[s.WidgetRange = 3] = "WidgetRange", s;
})(vr || (vr = {})), Uh;
const v7 = (Uh = class extends da {
  constructor(t, e, i, r) {
    super(), this.startSide = t, this.endSide = e, this.widget = i, this.spec = r;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(t) {
    return new rC(t);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(t) {
    let e = Math.max(-1e4, Math.min(1e4, t.side || 0)), i = !!t.block;
    return e += i && !t.inlineOrder ? e > 0 ? 3e8 : -4e8 : e > 0 ? 1e8 : -1e8, new Tw(t, e, e, i, t.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(t) {
    let e = !!t.block, i, r;
    if (t.isBlockGap)
      i = -5e8, r = 4e8;
    else {
      let { start: n, end: a } = nC(t, e);
      i = (n ? e ? -3e8 : -1 : 5e8) - 1, r = (a ? e ? 2e8 : 1 : -6e8) + 1;
    }
    return new Tw(t, i, r, e, t.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(t) {
    return new sC(t);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(t, e = !1) {
    return ze.of(t, e);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}, h(Uh, "cf"), Uh);
m(v7, "Decoration");
let se = v7;
se.none = ze.empty;
var Mo;
const O7 = (Mo = class extends se {
  constructor(t) {
    let { start: e, end: i } = nC(t);
    super(e ? -1 : 5e8, i ? 1 : -6e8, null, t), this.tagName = t.tagName || "span", this.attrs = t.class && t.attributes ? Z0(t.attributes, { class: t.class }) : t.class ? { class: t.class } : t.attributes || SO;
  }
  eq(t) {
    return this == t || t instanceof Mo && this.tagName == t.tagName && B0(this.attrs, t.attrs);
  }
  range(t, e = t) {
    if (t >= e)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(t, e);
  }
}, h(Mo, "qs"), Mo);
m(O7, "MarkDecoration");
let rC = O7;
rC.prototype.point = !1;
var Ao;
const b7 = (Ao = class extends se {
  constructor(t) {
    super(-2e8, -2e8, null, t);
  }
  eq(t) {
    return t instanceof Ao && this.spec.class == t.spec.class && B0(this.spec.attributes, t.spec.attributes);
  }
  range(t, e = t) {
    if (e != t)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(t, e);
  }
}, h(Ao, "Bs"), Ao);
m(b7, "LineDecoration");
let sC = b7;
sC.prototype.mapMode = Ti.TrackBefore;
sC.prototype.point = !0;
var Ro;
const $7 = (Ro = class extends se {
  constructor(t, e, i, r, n, a) {
    super(e, i, n, t), this.block = r, this.isReplace = a, this.mapMode = r ? e <= 0 ? Ti.TrackBefore : Ti.TrackAfter : Ti.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? vr.WidgetRange : this.startSide <= 0 ? vr.WidgetBefore : vr.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(t) {
    return t instanceof Ro && x7(this.widget, t.widget) && this.block == t.block && this.startSide == t.startSide && this.endSide == t.endSide;
  }
  range(t, e = t) {
    if (this.isReplace && (t > e || t == e && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && e != t)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(t, e);
  }
}, h(Ro, "Ds"), Ro);
m($7, "PointDecoration");
let Tw = $7;
Tw.prototype.point = !0;
function nC(s, t = !1) {
  let { inclusiveStart: e, inclusiveEnd: i } = s;
  return e == null && (e = s.inclusive), i == null && (i = s.inclusive), { start: e ?? t, end: i ?? t };
}
h(nC, "Qd$1");
m(nC, "getInclusive");
function x7(s, t) {
  return s == t || !!(s && t && s.compare(t));
}
h(x7, "h0$1");
m(x7, "widgetsEq");
function mo(s, t, e, i = 0) {
  let r = e.length - 1;
  r >= 0 && e[r] + i >= s ? e[r] = Math.max(e[r], t) : e.push(s, t);
}
h(mo, "xi$1");
m(mo, "addRange");
var jn;
const k7 = (jn = class extends da {
  constructor(t, e) {
    super(), this.tagName = t, this.attributes = e;
  }
  eq(t) {
    return t == this || t instanceof jn && this.tagName == t.tagName && B0(this.attributes, t.attributes);
  }
  /**
  Create a block wrapper object with the given tag name and
  attributes.
  */
  static create(t) {
    return new jn(t.tagName, t.attributes || SO);
  }
  /**
  Create a range set from the given block wrapper ranges.
  */
  static set(t, e = !1) {
    return ze.of(t, e);
  }
}, h(jn, "Ar"), jn);
m(k7, "BlockWrapper");
let G3 = k7;
G3.prototype.startSide = G3.prototype.endSide = -1;
function cl(s) {
  let t;
  return s.nodeType == 11 ? t = s.getSelection ? s : s.ownerDocument : t = s, t.getSelection();
}
h(cl, "Xi$1");
m(cl, "getSelection");
function CO(s, t) {
  return t ? s == t || s.contains(t.nodeType != 1 ? t.parentNode : t) : !1;
}
h(CO, "$l$1");
m(CO, "contains");
function yh(s, t) {
  if (!t.anchorNode)
    return !1;
  try {
    return CO(s, t.anchorNode);
  } catch {
    return !1;
  }
}
h(yh, "gr$1");
m(yh, "hasSelection");
function gh(s) {
  return s.nodeType == 3 ? oy(s, 0, s.nodeValue.length).getClientRects() : s.nodeType == 1 ? s.getClientRects() : [];
}
h(gh, "Qr$1");
m(gh, "clientRectsFor");
function wh(s, t, e, i) {
  return e ? Bk(s, t, e, i, -1) || Bk(s, t, e, i, 1) : !1;
}
h(wh, "yr");
m(wh, "isEquivalentPosition");
function en(s) {
  for (var t = 0; ; t++)
    if (s = s.previousSibling, !s)
      return t;
}
h(en, "At$1");
m(en, "domIndex");
function Mw(s) {
  return s.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(s.nodeName);
}
h(Mw, "ns$2");
m(Mw, "isBlockElement");
function Bk(s, t, e, i, r) {
  for (; ; ) {
    if (s == e && t == i)
      return !0;
    if (t == (r < 0 ? 0 : fs(s))) {
      if (s.nodeName == "DIV")
        return !1;
      let n = s.parentNode;
      if (!n || n.nodeType != 1)
        return !1;
      t = en(s) + (r < 0 ? 0 : 1), s = n;
    } else if (s.nodeType == 1) {
      if (s = s.childNodes[t + (r < 0 ? -1 : 0)], s.nodeType == 1 && s.contentEditable == "false")
        return !1;
      t = r < 0 ? fs(s) : 0;
    } else
      return !1;
  }
}
h(Bk, "Ou$1");
m(Bk, "scanFor");
function fs(s) {
  return s.nodeType == 3 ? s.nodeValue.length : s.childNodes.length;
}
h(fs, "dt$2");
m(fs, "maxOffset");
function ay(s, t) {
  let e = t ? s.left : s.right;
  return { left: e, right: e, top: s.top, bottom: s.bottom };
}
h(ay, "Jr$1");
m(ay, "flattenRect");
function S7(s) {
  let t = s.visualViewport;
  return t ? {
    left: 0,
    right: t.width,
    top: 0,
    bottom: t.height
  } : {
    left: 0,
    right: s.innerWidth,
    top: 0,
    bottom: s.innerHeight
  };
}
h(S7, "f0$1");
m(S7, "windowRect");
function aC(s, t) {
  let e = t.width / s.offsetWidth, i = t.height / s.offsetHeight;
  return (e > 0.995 && e < 1.005 || !isFinite(e) || Math.abs(t.width - s.offsetWidth) < 1) && (e = 1), (i > 0.995 && i < 1.005 || !isFinite(i) || Math.abs(t.height - s.offsetHeight) < 1) && (i = 1), { scaleX: e, scaleY: i };
}
h(aC, "yd$1");
m(aC, "getScale");
function C7(s, t, e, i, r, n, a, o) {
  let l = s.ownerDocument, d = l.defaultView || window;
  for (let u = s, p = !1; u && !p; )
    if (u.nodeType == 1) {
      let f, y = u == l.body, g = 1, O = 1;
      if (y)
        f = S7(d);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (p = !0), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
          u = u.assignedSlot || u.parentNode;
          continue;
        }
        let T = u.getBoundingClientRect();
        ({ scaleX: g, scaleY: O } = aC(u, T)), f = {
          left: T.left,
          right: T.left + u.clientWidth * g,
          top: T.top,
          bottom: T.top + u.clientHeight * O
        };
      }
      let k = 0, $ = 0;
      if (r == "nearest")
        t.top < f.top ? ($ = t.top - (f.top + a), e > 0 && t.bottom > f.bottom + $ && ($ = t.bottom - f.bottom + a)) : t.bottom > f.bottom && ($ = t.bottom - f.bottom + a, e < 0 && t.top - $ < f.top && ($ = t.top - (f.top + a)));
      else {
        let T = t.bottom - t.top, _ = f.bottom - f.top;
        $ = (r == "center" && T <= _ ? t.top + T / 2 - _ / 2 : r == "start" || r == "center" && e < 0 ? t.top - a : t.bottom - _ + a) - f.top;
      }
      if (i == "nearest" ? t.left < f.left ? (k = t.left - (f.left + n), e > 0 && t.right > f.right + k && (k = t.right - f.right + n)) : t.right > f.right && (k = t.right - f.right + n, e < 0 && t.left < f.left + k && (k = t.left - (f.left + n))) : k = (i == "center" ? t.left + (t.right - t.left) / 2 - (f.right - f.left) / 2 : i == "start" == o ? t.left - n : t.right - (f.right - f.left) + n) - f.left, k || $)
        if (y)
          d.scrollBy(k, $);
        else {
          let T = 0, _ = 0;
          if ($) {
            let D = u.scrollTop;
            u.scrollTop += $ / O, _ = (u.scrollTop - D) * O;
          }
          if (k) {
            let D = u.scrollLeft;
            u.scrollLeft += k / g, T = (u.scrollLeft - D) * g;
          }
          t = {
            left: t.left - T,
            top: t.top - _,
            right: t.right - T,
            bottom: t.bottom - _
          }, T && Math.abs(T - k) < 1 && (i = "nearest"), _ && Math.abs(_ - $) < 1 && (r = "nearest");
        }
      if (y)
        break;
      (t.top < f.top || t.bottom > f.bottom || t.left < f.left || t.right > f.right) && (t = {
        left: Math.max(t.left, f.left),
        right: Math.min(t.right, f.right),
        top: Math.max(t.top, f.top),
        bottom: Math.min(t.bottom, f.bottom)
      }), u = u.assignedSlot || u.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
}
h(C7, "c0$1");
m(C7, "scrollRectIntoView");
function P7(s) {
  let t = s.ownerDocument, e, i;
  for (let r = s.parentNode; r && !(r == t.body || e && i); )
    if (r.nodeType == 1)
      !i && r.scrollHeight > r.clientHeight && (i = r), !e && r.scrollWidth > r.clientWidth && (e = r), r = r.assignedSlot || r.parentNode;
    else if (r.nodeType == 11)
      r = r.host;
    else
      break;
  return { x: e, y: i };
}
h(P7, "u0$1");
m(P7, "scrollableParents");
var Hh;
const Q7 = (Hh = class {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(t) {
    return this.anchorNode == t.anchorNode && this.anchorOffset == t.anchorOffset && this.focusNode == t.focusNode && this.focusOffset == t.focusOffset;
  }
  setRange(t) {
    let { anchorNode: e, focusNode: i } = t;
    this.set(e, Math.min(t.anchorOffset, e ? fs(e) : 0), i, Math.min(t.focusOffset, i ? fs(i) : 0));
  }
  set(t, e, i, r) {
    this.anchorNode = t, this.anchorOffset = e, this.focusNode = i, this.focusOffset = r;
  }
}, h(Hh, "uf"), Hh);
m(Q7, "DOMSelectionState");
let KW = Q7, eo = null;
at.safari && at.safari_version >= 26 && (eo = !1);
function oC(s) {
  if (s.setActive)
    return s.setActive();
  if (eo)
    return s.focus(eo);
  let t = [];
  for (let e = s; e && (t.push(e, e.scrollTop, e.scrollLeft), e != e.ownerDocument); e = e.parentNode)
    ;
  if (s.focus(eo == null ? {
    get preventScroll() {
      return eo = { preventScroll: !0 }, !0;
    }
  } : void 0), !eo) {
    eo = !1;
    for (let e = 0; e < t.length; ) {
      let i = t[e++], r = t[e++], n = t[e++];
      i.scrollTop != r && (i.scrollTop = r), i.scrollLeft != n && (i.scrollLeft = n);
    }
  }
}
h(oC, "Sd");
m(oC, "focusPreventScroll");
let K3;
function oy(s, t, e = t) {
  let i = K3 || (K3 = document.createRange());
  return i.setEnd(s, e), i.setStart(s, t), i;
}
h(oy, "en$1");
m(oy, "textRange");
function yo(s, t, e, i) {
  let r = { key: t, code: t, keyCode: e, which: e, cancelable: !0 };
  i && ({ altKey: r.altKey, ctrlKey: r.ctrlKey, shiftKey: r.shiftKey, metaKey: r.metaKey } = i);
  let n = new KeyboardEvent("keydown", r);
  n.synthetic = !0, s.dispatchEvent(n);
  let a = new KeyboardEvent("keyup", r);
  return a.synthetic = !0, s.dispatchEvent(a), n.defaultPrevented || a.defaultPrevented;
}
h(yo, "ki$1");
m(yo, "dispatchKey");
function T7(s) {
  for (; s; ) {
    if (s && (s.nodeType == 9 || s.nodeType == 11 && s.host))
      return s;
    s = s.assignedSlot || s.parentNode;
  }
  return null;
}
h(T7, "O0$1");
m(T7, "getRoot");
function M7(s, t) {
  let e = t.focusNode, i = t.focusOffset;
  if (!e || t.anchorNode != e || t.anchorOffset != i)
    return !1;
  for (i = Math.min(i, fs(e)); ; )
    if (i) {
      if (e.nodeType != 1)
        return !1;
      let r = e.childNodes[i - 1];
      r.contentEditable == "false" ? i-- : (e = r, i = fs(e));
    } else {
      if (e == s)
        return !0;
      i = en(e), e = e.parentNode;
    }
}
h(M7, "d0$1");
m(M7, "atElementStart");
function lC(s) {
  return s.scrollTop > Math.max(1, s.scrollHeight - s.clientHeight - 4);
}
h(lC, "bd$1");
m(lC, "isScrolledToBottom");
function cC(s, t) {
  for (let e = s, i = t; ; ) {
    if (e.nodeType == 3 && i > 0)
      return { node: e, offset: i };
    if (e.nodeType == 1 && i > 0) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[i - 1], i = fs(e);
    } else if (e.parentNode && !Mw(e))
      i = en(e), e = e.parentNode;
    else
      return null;
  }
}
h(cC, "wd$1");
m(cC, "textNodeBefore");
function hC(s, t) {
  for (let e = s, i = t; ; ) {
    if (e.nodeType == 3 && i < e.nodeValue.length)
      return { node: e, offset: i };
    if (e.nodeType == 1 && i < e.childNodes.length) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[i], i = 0;
    } else if (e.parentNode && !Mw(e))
      i = en(e) + 1, e = e.parentNode;
    else
      return null;
  }
}
h(hC, "xd$1");
m(hC, "textNodeAfter");
var Un;
const A7 = (Un = class {
  constructor(t, e, i = !0) {
    this.node = t, this.offset = e, this.precise = i;
  }
  static before(t, e) {
    return new Un(t.parentNode, en(t), e);
  }
  static after(t, e) {
    return new Un(t.parentNode, en(t) + 1, e);
  }
}, h(Un, "Lr"), Un);
m(A7, "DOMPos");
let Dn = A7;
var me = /* @__PURE__ */ (function(s) {
  return s[s.LTR = 0] = "LTR", s[s.RTL = 1] = "RTL", s;
})(me || (me = {}));
const hl = me.LTR, dC = me.RTL;
function uC(s) {
  let t = [];
  for (let e = 0; e < s.length; e++)
    t.push(1 << +s[e]);
  return t;
}
h(uC, "kd$1");
m(uC, "dec");
const JW = /* @__PURE__ */ uC("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), tF = /* @__PURE__ */ uC("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Nk = /* @__PURE__ */ Object.create(null), jr = [];
for (let s of ["()", "[]", "{}"]) {
  let t = /* @__PURE__ */ s.charCodeAt(0), e = /* @__PURE__ */ s.charCodeAt(1);
  Nk[t] = e, Nk[e] = -t;
}
function pC(s) {
  return s <= 247 ? JW[s] : 1424 <= s && s <= 1524 ? 2 : 1536 <= s && s <= 1785 ? tF[s - 1536] : 1774 <= s && s <= 2220 ? 4 : 8192 <= s && s <= 8204 ? 256 : 64336 <= s && s <= 65023 ? 4 : 1;
}
h(pC, "Pd$1");
m(pC, "charType");
const eF = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
var Yh;
const R7 = (Yh = class {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? dC : hl;
  }
  /**
  @internal
  */
  constructor(t, e, i) {
    this.from = t, this.to = e, this.level = i;
  }
  /**
  @internal
  */
  side(t, e) {
    return this.dir == e == t ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(t, e) {
    return t == (this.dir == e);
  }
  /**
  @internal
  */
  static find(t, e, i, r) {
    let n = -1;
    for (let a = 0; a < t.length; a++) {
      let o = t[a];
      if (o.from <= e && o.to >= e) {
        if (o.level == i)
          return a;
        (n < 0 || (r != 0 ? r < 0 ? o.from < e : o.to > e : t[n].level > o.level)) && (n = a);
      }
    }
    if (n < 0)
      throw new RangeError("Index out of range");
    return n;
  }
}, h(Yh, "Of"), Yh);
m(R7, "BidiSpan");
let qs = R7;
function fC(s, t) {
  if (s.length != t.length)
    return !1;
  for (let e = 0; e < s.length; e++) {
    let i = s[e], r = t[e];
    if (i.from != r.from || i.to != r.to || i.direction != r.direction || !fC(i.inner, r.inner))
      return !1;
  }
  return !0;
}
h(fC, "$d$1");
m(fC, "isolatesEq");
const Jt = [];
function E7(s, t, e, i, r) {
  for (let n = 0; n <= i.length; n++) {
    let a = n ? i[n - 1].to : t, o = n < i.length ? i[n].from : e, l = n ? 256 : r;
    for (let d = a, u = l, p = l; d < o; d++) {
      let f = pC(s.charCodeAt(d));
      f == 512 ? f = u : f == 8 && p == 4 && (f = 16), Jt[d] = f == 4 ? 2 : f, f & 7 && (p = f), u = f;
    }
    for (let d = a, u = l, p = l; d < o; d++) {
      let f = Jt[d];
      if (f == 128)
        d < o - 1 && u == Jt[d + 1] && u & 24 ? f = Jt[d] = u : Jt[d] = 256;
      else if (f == 64) {
        let y = d + 1;
        for (; y < o && Jt[y] == 64; )
          y++;
        let g = d && u == 8 || y < e && Jt[y] == 8 ? p == 1 ? 1 : 8 : 256;
        for (let O = d; O < y; O++)
          Jt[O] = g;
        d = y - 1;
      } else f == 8 && p == 1 && (Jt[d] = 1);
      u = f, f & 7 && (p = f);
    }
  }
}
h(E7, "Q0$1");
m(E7, "computeCharTypes");
function _7(s, t, e, i, r) {
  let n = r == 1 ? 2 : 1;
  for (let a = 0, o = 0, l = 0; a <= i.length; a++) {
    let d = a ? i[a - 1].to : t, u = a < i.length ? i[a].from : e;
    for (let p = d, f, y, g; p < u; p++)
      if (y = Nk[f = s.charCodeAt(p)])
        if (y < 0) {
          for (let O = o - 3; O >= 0; O -= 3)
            if (jr[O + 1] == -y) {
              let k = jr[O + 2], $ = k & 2 ? r : k & 4 ? k & 1 ? n : r : 0;
              $ && (Jt[p] = Jt[jr[O]] = $), o = O;
              break;
            }
        } else {
          if (jr.length == 189)
            break;
          jr[o++] = p, jr[o++] = f, jr[o++] = l;
        }
      else if ((g = Jt[p]) == 2 || g == 1) {
        let O = g == r;
        l = O ? 0 : 1;
        for (let k = o - 3; k >= 0; k -= 3) {
          let $ = jr[k + 2];
          if ($ & 2)
            break;
          if (O)
            jr[k + 2] |= 2;
          else {
            if ($ & 4)
              break;
            jr[k + 2] |= 4;
          }
        }
      }
  }
}
h(_7, "y0$1");
m(_7, "processBracketPairs");
function L7(s, t, e, i) {
  for (let r = 0, n = i; r <= e.length; r++) {
    let a = r ? e[r - 1].to : s, o = r < e.length ? e[r].from : t;
    for (let l = a; l < o; ) {
      let d = Jt[l];
      if (d == 256) {
        let u = l + 1;
        for (; ; )
          if (u == o) {
            if (r == e.length)
              break;
            u = e[r++].to, o = r < e.length ? e[r].from : t;
          } else if (Jt[u] == 256)
            u++;
          else
            break;
        let p = n == 1, f = (u < t ? Jt[u] : i) == 1, y = p == f ? p ? 1 : 2 : i;
        for (let g = u, O = r, k = O ? e[O - 1].to : s; g > l; )
          g == k && (g = e[--O].from, k = O ? e[O - 1].to : s), Jt[--g] = y;
        l = u;
      } else
        n = d, l++;
    }
  }
}
h(L7, "S0$1");
m(L7, "processNeutrals");
function PO(s, t, e, i, r, n, a) {
  let o = i % 2 ? 2 : 1;
  if (i % 2 == r % 2)
    for (let l = t, d = 0; l < e; ) {
      let u = !0, p = !1;
      if (d == n.length || l < n[d].from) {
        let O = Jt[l];
        O != o && (u = !1, p = O == 16);
      }
      let f = !u && o == 1 ? [] : null, y = u ? i : i + 1, g = l;
      t: for (; ; )
        if (d < n.length && g == n[d].from) {
          if (p)
            break t;
          let O = n[d];
          if (!u)
            for (let k = O.to, $ = d + 1; ; ) {
              if (k == e)
                break t;
              if ($ < n.length && n[$].from == k)
                k = n[$++].to;
              else {
                if (Jt[k] == o)
                  break t;
                break;
              }
            }
          if (d++, f)
            f.push(O);
          else {
            O.from > l && a.push(new qs(l, O.from, y));
            let k = O.direction == hl != !(y % 2);
            QO(s, k ? i + 1 : i, r, O.inner, O.from, O.to, a), l = O.to;
          }
          g = O.to;
        } else {
          if (g == e || (u ? Jt[g] != o : Jt[g] == o))
            break;
          g++;
        }
      f ? PO(s, l, g, i + 1, r, f, a) : l < g && a.push(new qs(l, g, y)), l = g;
    }
  else
    for (let l = e, d = n.length; l > t; ) {
      let u = !0, p = !1;
      if (!d || l > n[d - 1].to) {
        let O = Jt[l - 1];
        O != o && (u = !1, p = O == 16);
      }
      let f = !u && o == 1 ? [] : null, y = u ? i : i + 1, g = l;
      t: for (; ; )
        if (d && g == n[d - 1].to) {
          if (p)
            break t;
          let O = n[--d];
          if (!u)
            for (let k = O.from, $ = d; ; ) {
              if (k == t)
                break t;
              if ($ && n[$ - 1].to == k)
                k = n[--$].from;
              else {
                if (Jt[k - 1] == o)
                  break t;
                break;
              }
            }
          if (f)
            f.push(O);
          else {
            O.to < l && a.push(new qs(O.to, l, y));
            let k = O.direction == hl != !(y % 2);
            QO(s, k ? i + 1 : i, r, O.inner, O.from, O.to, a), l = O.from;
          }
          g = O.from;
        } else {
          if (g == t || (u ? Jt[g - 1] != o : Jt[g - 1] == o))
            break;
          g--;
        }
      f ? PO(s, g, l, i + 1, r, f, a) : g < l && a.push(new qs(g, l, y)), l = g;
    }
}
h(PO, "Tl$1");
m(PO, "emitSpans");
function QO(s, t, e, i, r, n, a) {
  let o = t % 2 ? 2 : 1;
  E7(s, r, n, i, o), _7(s, r, n, i, o), L7(r, n, i, o), PO(s, r, n, t, e, i, a);
}
h(QO, "Al$1");
m(QO, "computeSectionOrder");
function z7(s, t, e) {
  if (!s)
    return [new qs(0, 0, t == dC ? 1 : 0)];
  if (t == hl && !e.length && !eF.test(s))
    return mC(s.length);
  if (e.length)
    for (; s.length > Jt.length; )
      Jt[Jt.length] = 256;
  let i = [], r = t == hl ? 0 : 1;
  return QO(s, r, r, e, 0, s.length, i), i;
}
h(z7, "b0$1");
m(z7, "computeOrder");
function mC(s) {
  return [new qs(0, s, 0)];
}
h(mC, "Rd$1");
m(mC, "trivialOrder");
let I7 = "";
function D7(s, t, e, i, r) {
  var n;
  let a = i.head - s.from, o = qs.find(t, a, (n = i.bidiLevel) !== null && n !== void 0 ? n : -1, i.assoc), l = t[o], d = l.side(r, e);
  if (a == d) {
    let f = o += r ? 1 : -1;
    if (f < 0 || f >= t.length)
      return null;
    l = t[o = f], a = l.side(!r, e), d = l.side(r, e);
  }
  let u = nr(s.text, a, l.forward(r, e));
  (u < l.from || u > l.to) && (u = d), I7 = s.text.slice(Math.min(a, u), Math.max(a, u));
  let p = o == (r ? t.length - 1 : 0) ? null : t[o + (r ? 1 : -1)];
  return p && u == d && p.level + (r ? 0 : 1) < l.level ? nt.cursor(p.side(!r, e) + s.from, p.forward(r, e) ? 1 : -1, p.level) : nt.cursor(u + s.from, l.forward(r, e) ? -1 : 1, l.level);
}
h(D7, "w0$1");
m(D7, "moveVisually");
function V7(s, t, e) {
  for (let i = t; i < e; i++) {
    let r = pC(s.charCodeAt(i));
    if (r == 1)
      return hl;
    if (r == 2 || r == 4)
      return dC;
  }
  return hl;
}
h(V7, "x0$1");
m(V7, "autoDirection");
const W7 = /* @__PURE__ */ Ct.define(), F7 = /* @__PURE__ */ Ct.define(), q7 = /* @__PURE__ */ Ct.define(), Z7 = /* @__PURE__ */ Ct.define(), Xk = /* @__PURE__ */ Ct.define(), B7 = /* @__PURE__ */ Ct.define(), N7 = /* @__PURE__ */ Ct.define(), yC = /* @__PURE__ */ Ct.define(), gC = /* @__PURE__ */ Ct.define(), X7 = /* @__PURE__ */ Ct.define({
  combine: /* @__PURE__ */ m((s) => s.some((t) => t), "combine")
}), iF = /* @__PURE__ */ Ct.define({
  combine: /* @__PURE__ */ m((s) => s.some((t) => t), "combine")
}), j7 = /* @__PURE__ */ Ct.define();
var Hn;
const U7 = (Hn = class {
  constructor(t, e = "nearest", i = "nearest", r = 5, n = 5, a = !1) {
    this.range = t, this.y = e, this.x = i, this.yMargin = r, this.xMargin = n, this.isSnapshot = a;
  }
  map(t) {
    return t.empty ? this : new Hn(this.range.map(t), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(t) {
    return this.range.to <= t.doc.length ? this : new Hn(nt.cursor(t.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}, h(Hn, "_r"), Hn);
m(U7, "ScrollTarget");
let f2 = U7;
const tv = /* @__PURE__ */ te.define({ map: /* @__PURE__ */ m((s, t) => s.map(t), "map") }), H7 = /* @__PURE__ */ te.define();
function Wi(s, t, e) {
  let i = s.facet(Z7);
  i.length ? i[0](t) : window.onerror && window.onerror(String(t), e, void 0, void 0, t) || (e ? console.error(e + ":", t) : console.error(t));
}
h(Wi, "$e$1");
m(Wi, "logException");
const Is = /* @__PURE__ */ Ct.define({ combine: /* @__PURE__ */ m((s) => s.length ? s[0] : !0, "combine") });
let rF = 0;
const dh = /* @__PURE__ */ Ct.define({
  combine(s) {
    return s.filter((t, e) => {
      for (let i = 0; i < e; i++)
        if (s[i].plugin == t.plugin)
          return !1;
      return !0;
    });
  }
});
var Yn;
const Y7 = (Yn = class {
  constructor(t, e, i, r, n) {
    this.id = t, this.create = e, this.domEventHandlers = i, this.domEventObservers = r, this.baseExtensions = n(this), this.extension = this.baseExtensions.concat(dh.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(t) {
    return this.baseExtensions.concat(dh.of({ plugin: this, arg: t }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(t, e) {
    const { eventHandlers: i, eventObservers: r, provide: n, decorations: a } = e || {};
    return new Yn(rF++, t, i, r, (o) => {
      let l = [];
      return a && l.push(N0.of((d) => {
        let u = d.plugin(o);
        return u ? a(u) : se.none;
      })), n && l.push(n(o)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(t, e) {
    return Yn.define((i, r) => new t(i, r), e);
  }
}, h(Yn, "Mr"), Yn);
m(Y7, "ViewPlugin");
let rn = Y7;
var Gh;
const G7 = (Gh = class {
  constructor(t) {
    this.spec = t, this.mustUpdate = null, this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(t) {
    if (this.value) {
      if (this.mustUpdate) {
        let e = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(e);
          } catch (i) {
            if (Wi(e.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.plugin.create(t, this.spec.arg);
      } catch (e) {
        Wi(t.state, e, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(t) {
    var e;
    if (!((e = this.value) === null || e === void 0) && e.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        Wi(t.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}, h(Gh, "df"), Gh);
m(G7, "PluginInstance");
let m2 = G7;
const K7 = /* @__PURE__ */ Ct.define(), wC = /* @__PURE__ */ Ct.define(), N0 = /* @__PURE__ */ Ct.define(), J7 = /* @__PURE__ */ Ct.define(), vC = /* @__PURE__ */ Ct.define(), w1 = /* @__PURE__ */ Ct.define(), tT = /* @__PURE__ */ Ct.define();
function jk(s, t) {
  let e = s.state.facet(tT);
  if (!e.length)
    return e;
  let i = e.map((n) => n instanceof Function ? n(s) : n), r = [];
  return ze.spans(i, t.from, t.to, {
    point() {
    },
    span(n, a, o, l) {
      let d = n - t.from, u = a - t.from, p = r;
      for (let f = o.length - 1; f >= 0; f--, l--) {
        let y = o[f].spec.bidiIsolate, g;
        if (y == null && (y = V7(t.text, d, u)), l > 0 && p.length && (g = p[p.length - 1]).to == d && g.direction == y)
          g.to = u, p = g.inner;
        else {
          let O = { from: d, to: u, direction: y, inner: [] };
          p.push(O), p = O.inner;
        }
      }
    }
  }), r;
}
h(jk, "pu");
m(jk, "getIsolatedRanges");
const eT = /* @__PURE__ */ Ct.define();
function X0(s) {
  let t = 0, e = 0, i = 0, r = 0;
  for (let n of s.state.facet(eT)) {
    let a = n(s);
    a && (a.left != null && (t = Math.max(t, a.left)), a.right != null && (e = Math.max(e, a.right)), a.top != null && (i = Math.max(i, a.top)), a.bottom != null && (r = Math.max(r, a.bottom)));
  }
  return { left: t, right: e, top: i, bottom: r };
}
h(X0, "yh$1");
m(X0, "getScrollMargins");
const Qg = /* @__PURE__ */ Ct.define();
var Gn;
const iT = (Gn = class {
  constructor(t, e, i, r) {
    this.fromA = t, this.toA = e, this.fromB = i, this.toB = r;
  }
  join(t) {
    return new Gn(Math.min(this.fromA, t.fromA), Math.max(this.toA, t.toA), Math.min(this.fromB, t.fromB), Math.max(this.toB, t.toB));
  }
  addToSet(t) {
    let e = t.length, i = this;
    for (; e > 0; e--) {
      let r = t[e - 1];
      if (!(r.fromA > i.toA)) {
        if (r.toA < i.fromA)
          break;
        i = i.join(r), t.splice(e - 1, 1);
      }
    }
    return t.splice(e, 0, i), t;
  }
  // Extend a set to cover all the content in `ranges`, which is a
  // flat array with each pair of numbers representing fromB/toB
  // positions. These pairs are generated in unchanged ranges, so the
  // offset between doc A and doc B is the same for their start and
  // end points.
  static extendWithRanges(t, e) {
    if (e.length == 0)
      return t;
    let i = [];
    for (let r = 0, n = 0, a = 0; ; ) {
      let o = r < t.length ? t[r].fromB : 1e9, l = n < e.length ? e[n] : 1e9, d = Math.min(o, l);
      if (d == 1e9)
        break;
      let u = d + a, p = d, f = u;
      for (; ; )
        if (n < e.length && e[n] <= p) {
          let y = e[n + 1];
          n += 2, p = Math.max(p, y);
          for (let g = r; g < t.length && t[g].fromB <= p; g++)
            a = t[g].toA - t[g].toB;
          f = Math.max(f, y + a);
        } else if (r < t.length && t[r].fromB <= p) {
          let y = t[r++];
          p = Math.max(p, y.toB), f = Math.max(f, y.toA), a = y.toA - y.toB;
        } else
          break;
      i.push(new Gn(u, f, d, p));
    }
    return i;
  }
}, h(Gn, "Zr"), Gn);
m(iT, "ChangedRange");
let Zs = iT;
var Eo;
const rT = (Eo = class {
  constructor(t, e, i) {
    this.view = t, this.state = e, this.transactions = i, this.flags = 0, this.startState = t.state, this.changes = Dr.empty(this.startState.doc.length);
    for (let n of i)
      this.changes = this.changes.compose(n.changes);
    let r = [];
    this.changes.iterChangedRanges((n, a, o, l) => r.push(new Zs(n, a, o, l))), this.changedRanges = r;
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new Eo(t, e, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((t) => t.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}, h(Eo, "Ns"), Eo);
m(rT, "ViewUpdate");
let J3 = rT;
const sF = [];
var Kh;
const sT = (Kh = class {
  constructor(t, e, i = 0) {
    this.dom = t, this.length = e, this.flags = i, this.parent = null, t.cmTile = this;
  }
  get breakAfter() {
    return this.flags & 1;
  }
  get children() {
    return sF;
  }
  isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  isComposite() {
    return !1;
  }
  isLine() {
    return !1;
  }
  isText() {
    return !1;
  }
  isBlock() {
    return !1;
  }
  get domAttrs() {
    return null;
  }
  sync(t) {
    if (this.flags |= 2, this.flags & 4) {
      this.flags &= -5;
      let e = this.domAttrs;
      e && y7(this.dom, e);
    }
  }
  toString() {
    return this.constructor.name + (this.children.length ? `(${this.children})` : "") + (this.breakAfter ? "#" : "");
  }
  destroy() {
    this.parent = null;
  }
  setDOM(t) {
    this.dom = t, t.cmTile = this;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(t, e = this.posAtStart) {
    let i = e;
    for (let r of this.children) {
      if (r == t)
        return i;
      i += r.length + r.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(t) {
    return this.posBefore(t) + t.length;
  }
  covers(t) {
    return !0;
  }
  coordsIn(t, e) {
    return null;
  }
  domPosFor(t, e) {
    let i = en(this.dom), r = this.length ? t > 0 : e > 0;
    return new Dn(this.parent.dom, i + (r ? 1 : 0), t == 0 || t == this.length);
  }
  markDirty(t) {
    this.flags &= -3, t && (this.flags |= 4), this.parent && this.parent.flags & 2 && this.parent.markDirty(!1);
  }
  get overrideDOMText() {
    return null;
  }
  get root() {
    for (let t = this; t; t = t.parent)
      if (t instanceof U0)
        return t;
    return null;
  }
  static get(t) {
    return t.cmTile;
  }
}, h(Kh, "pf"), Kh);
m(sT, "Tile");
let Le = sT;
var Jh;
const nT = (Jh = class extends Le {
  constructor(t) {
    super(t, 0), this._children = [];
  }
  isComposite() {
    return !0;
  }
  get children() {
    return this._children;
  }
  get lastChild() {
    return this.children.length ? this.children[this.children.length - 1] : null;
  }
  append(t) {
    this.children.push(t), t.parent = this;
  }
  sync(t) {
    if (this.flags & 2)
      return;
    super.sync(t);
    let e = this.dom, i = null, r, n = t?.node == e ? t : null, a = 0;
    for (let o of this.children) {
      if (o.sync(t), a += o.length + o.breakAfter, r = i ? i.nextSibling : e.firstChild, n && r != o.dom && (n.written = !0), o.dom.parentNode == e)
        for (; r && r != o.dom; )
          r = Uk(r);
      else
        e.insertBefore(o.dom, r);
      i = o.dom;
    }
    for (r = i ? i.nextSibling : e.firstChild, n && r && (n.written = !0); r; )
      r = Uk(r);
    this.length = a;
  }
}, h(Jh, "mf"), Jh);
m(nT, "CompositeTile");
let j0 = nT;
function Uk(s) {
  let t = s.nextSibling;
  return s.parentNode.removeChild(s), t;
}
h(Uk, "mu");
m(Uk, "rm$1");
var td;
const aT = (td = class extends j0 {
  constructor(t, e) {
    super(e), this.view = t;
  }
  owns(t) {
    for (; t; t = t.parent)
      if (t == this)
        return !0;
    return !1;
  }
  isBlock() {
    return !0;
  }
  nearest(t) {
    for (; ; ) {
      if (!t)
        return null;
      let e = Le.get(t);
      if (e && this.owns(e))
        return e;
      t = t.parentNode;
    }
  }
  blockTiles(t) {
    for (let e = [], i = this, r = 0, n = 0; ; )
      if (r == i.children.length) {
        if (!e.length)
          return;
        i = i.parent, i.breakAfter && n++, r = e.pop();
      } else {
        let a = i.children[r++];
        if (a instanceof vh)
          e.push(r), i = a, r = 0;
        else {
          let o = n + a.length, l = t(a, n);
          if (l !== void 0)
            return l;
          n = o + a.breakAfter;
        }
      }
  }
  // Find the block at the given position. If side < -1, make sure to
  // stay before block widgets at that position, if side > 1, after
  // such widgets (used for selection drawing, which needs to be able
  // to get coordinates for positions that aren't valid cursor positions).
  resolveBlock(t, e) {
    let i, r = -1, n, a = -1;
    if (this.blockTiles((o, l) => {
      let d = l + o.length;
      if (t >= l && t <= d) {
        if (o.isWidget() && e >= -1 && e <= 1) {
          if (o.flags & 32)
            return !0;
          o.flags & 16 && (i = void 0);
        }
        (l < t || t == d && (e < -1 ? o.length : o.covers(1))) && (!i || !o.isWidget() && i.isWidget()) && (i = o, r = t - l), (d > t || t == l && (e > 1 ? o.length : o.covers(-1))) && (!n || !o.isWidget() && n.isWidget()) && (n = o, a = t - l);
      }
    }), !i && !n)
      throw new Error("No tile at position " + t);
    return i && e < 0 || !n ? { tile: i, offset: r } : { tile: n, offset: a };
  }
}, h(td, "gf"), td);
m(aT, "DocTile");
let U0 = aT;
var _o;
const oT = (_o = class extends j0 {
  constructor(t, e) {
    super(t), this.wrapper = e;
  }
  isBlock() {
    return !0;
  }
  covers(t) {
    return this.children.length ? t < 0 ? this.children[0].covers(-1) : this.lastChild.covers(1) : !1;
  }
  get domAttrs() {
    return this.wrapper.attributes;
  }
  static of(t, e) {
    let i = new _o(e || document.createElement(t.tagName), t);
    return e || (i.flags |= 4), i;
  }
}, h(_o, "Gs"), _o);
m(oT, "BlockWrapperTile");
let vh = oT;
var Lo;
const lT = (Lo = class extends j0 {
  constructor(t, e) {
    super(t), this.attrs = e;
  }
  isLine() {
    return !0;
  }
  static start(t, e, i) {
    let r = new Lo(e || document.createElement("div"), t);
    return (!e || !i) && (r.flags |= 4), r;
  }
  get domAttrs() {
    return this.attrs;
  }
  // Find the tile associated with a given position in this line.
  resolveInline(t, e, i) {
    let r = null, n = -1, a = null, o = -1;
    function l(u, p) {
      for (let f = 0, y = 0; f < u.children.length && y <= p; f++) {
        let g = u.children[f], O = y + g.length;
        O >= p && (g.isComposite() ? l(g, p - y) : (!a || a.isHidden && (e > 0 || i && hT(a, g))) && (O > p || g.flags & 32) ? (a = g, o = p - y) : (y < p || g.flags & 16 && !g.isHidden) && (r = g, n = p - y)), y = O;
      }
    }
    h(l, "a"), m(l, "scan"), l(this, t);
    let d = (e < 0 ? r : a) || r || a;
    return d ? { tile: d, offset: d == r ? n : o } : null;
  }
  coordsIn(t, e) {
    let i = this.resolveInline(t, e, !0);
    return i ? i.tile.coordsIn(Math.max(0, i.offset), e) : cT(this);
  }
  domIn(t, e) {
    let i = this.resolveInline(t, e);
    if (i) {
      let { tile: r, offset: n } = i;
      if (this.dom.contains(r.dom))
        return r.isText() ? new Dn(r.dom, Math.min(r.dom.nodeValue.length, n)) : r.domPosFor(n, r.flags & 16 ? 1 : r.flags & 32 ? -1 : e);
      let a = i.tile.parent, o = !1;
      for (let l of a.children) {
        if (o)
          return new Dn(l.dom, 0);
        l == i.tile && (o = !0);
      }
    }
    return new Dn(this.dom, 0);
  }
}, h(Lo, "Fs"), Lo);
m(lT, "LineTile");
let TO = lT;
function cT(s) {
  let t = s.dom.lastChild;
  if (!t)
    return s.dom.getBoundingClientRect();
  let e = gh(t);
  return e[e.length - 1] || null;
}
h(cT, "R0$1");
m(cT, "fallbackRect");
function hT(s, t) {
  let e = s.coordsIn(0, 1), i = t.coordsIn(0, 1);
  return e && i && i.top < e.bottom;
}
h(hT, "v0$1");
m(hT, "onSameLine");
var zo;
const dT = (zo = class extends j0 {
  constructor(t, e) {
    super(t), this.mark = e;
  }
  get domAttrs() {
    return this.mark.attrs;
  }
  static of(t, e) {
    let i = new zo(e || document.createElement(t.tagName), t);
    return e || (i.flags |= 4), i;
  }
}, h(zo, "Hs"), zo);
m(dT, "MarkTile");
let yr = dT;
var Io;
const uT = (Io = class extends Le {
  constructor(t, e) {
    super(t, e.length), this.text = e;
  }
  sync(t) {
    this.flags & 2 || (super.sync(t), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text));
  }
  isText() {
    return !0;
  }
  toString() {
    return JSON.stringify(this.text);
  }
  coordsIn(t, e) {
    let i = this.dom.nodeValue.length;
    t > i && (t = i);
    let r = t, n = t, a = 0;
    t == 0 && e < 0 || t == i && e >= 0 ? at.chrome || at.gecko || (t ? (r--, a = 1) : n < i && (n++, a = -1)) : e < 0 ? r-- : n < i && n++;
    let o = oy(this.dom, r, n).getClientRects();
    if (!o.length)
      return null;
    let l = o[(a ? a < 0 : e >= 0) ? 0 : o.length - 1];
    return at.safari && !a && l.width == 0 && (l = Array.prototype.find.call(o, (d) => d.width) || l), a ? ay(l, a < 0) : l || null;
  }
  static of(t, e) {
    let i = new Io(e || document.createTextNode(t), t);
    return e || (i.flags |= 2), i;
  }
}, h(Io, "Ks"), Io);
m(uT, "TextTile");
let Tg = uT;
var Do;
const pT = (Do = class extends Le {
  constructor(t, e, i, r) {
    super(t, e, r), this.widget = i;
  }
  isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  covers(t) {
    return this.flags & 48 ? !1 : (this.flags & (t < 0 ? 64 : 128)) > 0;
  }
  coordsIn(t, e) {
    return this.coordsInWidget(t, e, !1);
  }
  coordsInWidget(t, e, i) {
    let r = this.widget.coordsAt(this.dom, t, e);
    if (r)
      return r;
    if (i)
      return ay(this.dom.getBoundingClientRect(), this.length ? t == 0 : e <= 0);
    {
      let n = this.dom.getClientRects(), a = null;
      if (!n.length)
        return null;
      let o = this.flags & 16 ? !0 : this.flags & 32 ? !1 : t > 0;
      for (let l = o ? n.length - 1 : 0; a = n[l], !(t > 0 ? l == 0 : l == n.length - 1 || a.top < a.bottom); l += o ? -1 : 1)
        ;
      return ay(a, !o);
    }
  }
  get overrideDOMText() {
    if (!this.length)
      return Ht.empty;
    let { root: t } = this;
    if (!t)
      return Ht.empty;
    let e = this.posAtStart;
    return t.view.state.doc.slice(e, e + this.length);
  }
  destroy() {
    super.destroy(), this.widget.destroy(this.dom);
  }
  static of(t, e, i, r, n) {
    return n || (n = t.toDOM(e), t.editable || (n.contentEditable = "false")), new Do(n, i, t, r);
  }
}, h(Do, "Js"), Do);
m(pT, "WidgetTile");
let Aw = pT;
var ed;
const fT = (ed = class extends Le {
  constructor(t) {
    let e = document.createElement("img");
    e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), super(e, 0, t);
  }
  get isHidden() {
    return !0;
  }
  get overrideDOMText() {
    return Ht.empty;
  }
  coordsIn(t) {
    return this.dom.getBoundingClientRect();
  }
}, h(ed, "Qf"), ed);
m(fT, "WidgetBufferTile");
let MO = fT;
var id;
const mT = (id = class {
  constructor(t) {
    this.index = 0, this.beforeBreak = !1, this.parents = [], this.tile = t;
  }
  // Advance by the given distance. If side is -1, stop leaving or
  // entering tiles, or skipping zero-length tiles, once the distance
  // has been traversed. When side is 1, leave, enter, or skip
  // everything at the end position.
  advance(t, e, i) {
    let { tile: r, index: n, beforeBreak: a, parents: o } = this;
    for (; t || e > 0; )
      if (r.isComposite())
        if (a) {
          if (!t)
            break;
          i && i.break(), t--, a = !1;
        } else if (n == r.children.length) {
          if (!t && !o.length)
            break;
          i && i.leave(r), a = !!r.breakAfter, { tile: r, index: n } = o.pop(), n++;
        } else {
          let l = r.children[n], d = l.breakAfter;
          (e > 0 ? l.length <= t : l.length < t) && (!i || i.skip(l, 0, l.length) !== !1 || !l.isComposite) ? (a = !!d, n++, t -= l.length) : (o.push({ tile: r, index: n }), r = l, n = 0, i && l.isComposite() && i.enter(l));
        }
      else if (n == r.length)
        a = !!r.breakAfter, { tile: r, index: n } = o.pop(), n++;
      else if (t) {
        let l = Math.min(t, r.length - n);
        i && i.skip(r, n, n + l), t -= l, n += l;
      } else
        break;
    return this.tile = r, this.index = n, this.beforeBreak = a, this;
  }
  get root() {
    return this.parents.length ? this.parents[0].tile : this.tile;
  }
}, h(id, "yf"), id);
m(mT, "TilePointer");
let nF = mT;
var rd;
const yT = (rd = class {
  constructor(t, e, i, r) {
    this.from = t, this.to = e, this.wrapper = i, this.rank = r;
  }
}, h(rd, "Sf"), rd);
m(yT, "OpenWrapper");
let aF = yT;
var sd;
const gT = (sd = class {
  constructor(t, e, i) {
    this.cache = t, this.root = e, this.blockWrappers = i, this.curLine = null, this.lastBlock = null, this.afterWidget = null, this.pos = 0, this.wrappers = [], this.wrapperPos = 0;
  }
  addText(t, e, i, r) {
    var n;
    this.flushBuffer();
    let a = this.ensureMarks(e, i), o = a.lastChild;
    if (o && o.isText() && !(o.flags & 8)) {
      this.cache.reused.set(
        o,
        2
        /* Reused.DOM */
      );
      let l = a.children[a.children.length - 1] = new Tg(o.dom, o.text + t);
      l.parent = a;
    } else
      a.append(r || Tg.of(t, (n = this.cache.find(Tg)) === null || n === void 0 ? void 0 : n.dom));
    this.pos += t.length, this.afterWidget = null;
  }
  addComposition(t, e) {
    let i = this.curLine;
    i.dom != e.line.dom && (i.setDOM(this.cache.reused.has(e.line) ? Qv(e.line.dom) : e.line.dom), this.cache.reused.set(
      e.line,
      2
      /* Reused.DOM */
    ));
    let r = i;
    for (let o = e.marks.length - 1; o >= 0; o--) {
      let l = e.marks[o], d = r.lastChild;
      if (d instanceof yr && d.mark.eq(l.mark))
        d.dom != l.dom && d.setDOM(Qv(l.dom)), r = d;
      else {
        if (this.cache.reused.get(l)) {
          let p = Le.get(l.dom);
          p && p.setDOM(Qv(l.dom));
        }
        let u = yr.of(l.mark, l.dom);
        r.append(u), r = u;
      }
      this.cache.reused.set(
        l,
        2
        /* Reused.DOM */
      );
    }
    let n = Le.get(t.text);
    n && this.cache.reused.set(
      n,
      2
      /* Reused.DOM */
    );
    let a = new Tg(t.text, t.text.nodeValue);
    a.flags |= 8, r.append(a);
  }
  addInlineWidget(t, e, i) {
    let r = this.afterWidget && t.flags & 48 && (this.afterWidget.flags & 48) == (t.flags & 48);
    r || this.flushBuffer();
    let n = this.ensureMarks(e, i);
    !r && !(t.flags & 16) && n.append(this.getBuffer(1)), n.append(t), this.pos += t.length, this.afterWidget = t;
  }
  addMark(t, e, i) {
    this.flushBuffer(), this.ensureMarks(e, i).append(t), this.pos += t.length, this.afterWidget = null;
  }
  addBlockWidget(t) {
    this.getBlockPos().append(t), this.pos += t.length, this.lastBlock = t, this.endLine();
  }
  continueWidget(t) {
    let e = this.afterWidget || this.lastBlock;
    e.length += t, this.pos += t;
  }
  addLineStart(t, e) {
    var i;
    t || (t = $T);
    let r = TO.start(t, e || ((i = this.cache.find(TO)) === null || i === void 0 ? void 0 : i.dom), !!e);
    this.getBlockPos().append(this.lastBlock = this.curLine = r);
  }
  addLine(t) {
    this.getBlockPos().append(t), this.pos += t.length, this.lastBlock = t, this.endLine();
  }
  addBreak() {
    this.lastBlock.flags |= 1, this.endLine(), this.pos++;
  }
  addLineStartIfNotCovered(t) {
    this.blockPosCovered() || this.addLineStart(t);
  }
  ensureLine(t) {
    this.curLine || this.addLineStart(t);
  }
  ensureMarks(t, e) {
    var i;
    let r = this.curLine;
    for (let n = t.length - 1; n >= 0; n--) {
      let a = t[n], o;
      if (e > 0 && (o = r.lastChild) && o instanceof yr && o.mark.eq(a))
        r = o, e--;
      else {
        let l = yr.of(a, (i = this.cache.find(yr, (d) => d.mark.eq(a))) === null || i === void 0 ? void 0 : i.dom);
        r.append(l), r = l, e = 0;
      }
    }
    return r;
  }
  endLine() {
    if (this.curLine) {
      this.flushBuffer();
      let t = this.curLine.lastChild;
      (!t || !Hk(this.curLine, !1) || t.dom.nodeName != "BR" && t.isWidget() && !(at.ios && Hk(this.curLine, !0))) && this.curLine.append(this.cache.findWidget(
        y2,
        0,
        32
        /* TileFlag.After */
      ) || new Aw(
        y2.toDOM(),
        0,
        y2,
        32
        /* TileFlag.After */
      )), this.curLine = this.afterWidget = null;
    }
  }
  updateBlockWrappers() {
    this.wrapperPos > this.pos + 1e4 && (this.blockWrappers.goto(this.pos), this.wrappers.length = 0);
    for (let t = this.wrappers.length - 1; t >= 0; t--)
      this.wrappers[t].to < this.pos && this.wrappers.splice(t, 1);
    for (let t = this.blockWrappers; t.value && t.from <= this.pos; t.next())
      if (t.to >= this.pos) {
        let e = new aF(t.from, t.to, t.value, t.rank), i = this.wrappers.length;
        for (; i > 0 && (this.wrappers[i - 1].rank - e.rank || this.wrappers[i - 1].to - e.to) < 0; )
          i--;
        this.wrappers.splice(i, 0, e);
      }
    this.wrapperPos = this.pos;
  }
  getBlockPos() {
    var t;
    this.updateBlockWrappers();
    let e = this.root;
    for (let i of this.wrappers) {
      let r = e.lastChild;
      if (i.from < this.pos && r instanceof vh && r.wrapper.eq(i.wrapper))
        e = r;
      else {
        let n = vh.of(i.wrapper, (t = this.cache.find(vh, (a) => a.wrapper.eq(i.wrapper))) === null || t === void 0 ? void 0 : t.dom);
        e.append(n), e = n;
      }
    }
    return e;
  }
  blockPosCovered() {
    let t = this.lastBlock;
    return t != null && !t.breakAfter && (!t.isWidget() || (t.flags & 160) > 0);
  }
  getBuffer(t) {
    let e = 2 | (t < 0 ? 16 : 32), i = this.cache.find(
      MO,
      void 0,
      1
      /* Reused.Full */
    );
    return i && (i.flags = e), i || new MO(e);
  }
  flushBuffer() {
    this.afterWidget && !(this.afterWidget.flags & 32) && (this.afterWidget.parent.append(this.getBuffer(-1)), this.afterWidget = null);
  }
}, h(sd, "bf"), sd);
m(gT, "TileBuilder");
let oF = gT;
var nd;
const wT = (nd = class {
  constructor(t) {
    this.skipCount = 0, this.text = "", this.textOff = 0, this.cursor = t.iter();
  }
  skip(t) {
    this.textOff + t <= this.text.length ? this.textOff += t : (this.skipCount += t - (this.text.length - this.textOff), this.text = "", this.textOff = 0);
  }
  next(t) {
    if (this.textOff == this.text.length) {
      let { value: r, lineBreak: n, done: a } = this.cursor.next(this.skipCount);
      if (this.skipCount = 0, a)
        throw new Error("Ran out of text content when drawing inline views");
      this.text = r;
      let o = this.textOff = Math.min(t, r.length);
      return n ? null : r.slice(0, o);
    }
    let e = Math.min(this.text.length, this.textOff + t), i = this.text.slice(this.textOff, e);
    return this.textOff = e, i;
  }
}, h(nd, "wf"), nd);
m(wT, "TextStream");
let lF = wT;
const AO = [Aw, TO, Tg, yr, MO, vh, U0];
for (let s = 0; s < AO.length; s++)
  AO[s].bucket = s;
var ad;
const vT = (ad = class {
  constructor(t) {
    this.view = t, this.buckets = AO.map(() => []), this.index = AO.map(() => 0), this.reused = /* @__PURE__ */ new Map();
  }
  // Put a tile in the cache.
  add(t) {
    let e = t.constructor.bucket, i = this.buckets[e];
    i.length < 6 ? i.push(t) : i[
      this.index[e] = (this.index[e] + 1) % 6
      /* C.Bucket */
    ] = t;
  }
  find(t, e, i = 2) {
    let r = t.bucket, n = this.buckets[r], a = this.index[r];
    for (let o = n.length - 1; o >= 0; o--) {
      let l = (o + a) % n.length, d = n[l];
      if ((!e || e(d)) && !this.reused.has(d))
        return n.splice(l, 1), l < a && this.index[r]--, this.reused.set(d, i), d;
    }
    return null;
  }
  findWidget(t, e, i) {
    let r = this.buckets[0];
    if (r.length)
      for (let n = 0, a = 0; ; n++) {
        if (n == r.length) {
          if (a)
            return null;
          a = 1, n = 0;
        }
        let o = r[n];
        if (!this.reused.has(o) && (a == 0 ? o.widget.compare(t) : o.widget.constructor == t.constructor && t.updateDOM(o.dom, this.view)))
          return r.splice(n, 1), n < this.index[0] && this.index[0]--, o.widget == t && o.length == e && (o.flags & 497) == i ? (this.reused.set(
            o,
            1
            /* Reused.Full */
          ), o) : (this.reused.set(
            o,
            2
            /* Reused.DOM */
          ), new Aw(o.dom, e, t, o.flags & -498 | i));
      }
  }
  reuse(t) {
    return this.reused.set(
      t,
      1
      /* Reused.Full */
    ), t;
  }
  maybeReuse(t, e = 2) {
    if (!this.reused.has(t))
      return this.reused.set(t, e), t.dom;
  }
  clear() {
    for (let t = 0; t < this.buckets.length; t++)
      this.buckets[t].length = this.index[t] = 0;
  }
}, h(ad, "xf"), ad);
m(vT, "TileCache");
let cF = vT;
var od;
const OT = (od = class {
  constructor(t, e, i, r, n) {
    this.view = t, this.decorations = r, this.disallowBlockEffectsFor = n, this.openWidget = !1, this.openMarks = 0, this.cache = new cF(t), this.text = new lF(t.state.doc), this.builder = new oF(this.cache, new U0(t, t.contentDOM), ze.iter(i)), this.cache.reused.set(
      e,
      2
      /* Reused.DOM */
    ), this.old = new nF(e), this.reuseWalker = {
      skip: /* @__PURE__ */ m((a, o, l) => {
        if (this.cache.add(a), a.isComposite())
          return !1;
      }, "skip"),
      enter: /* @__PURE__ */ m((a) => this.cache.add(a), "enter"),
      leave: /* @__PURE__ */ m(() => {
      }, "leave"),
      break: /* @__PURE__ */ m(() => {
      }, "break")
    };
  }
  run(t, e) {
    let i = e && this.getCompositionContext(e.text);
    for (let r = 0, n = 0, a = 0; ; ) {
      let o = a < t.length ? t[a++] : null, l = o ? o.fromA : this.old.root.length;
      if (l > r) {
        let d = l - r;
        this.preserve(d, !a, !o), r = l, n += d;
      }
      if (!o)
        break;
      e && o.fromA <= e.range.fromA && o.toA >= e.range.toA ? (this.forward(o.fromA, e.range.fromA, e.range.fromA < e.range.toA ? 1 : -1), this.emit(n, e.range.fromB), this.cache.clear(), this.builder.addComposition(e, i), this.text.skip(e.range.toB - e.range.fromB), this.forward(e.range.fromA, o.toA), this.emit(e.range.toB, o.toB)) : (this.forward(o.fromA, o.toA), this.emit(n, o.toB)), n = o.toB, r = o.toA;
    }
    return this.builder.curLine && this.builder.endLine(), this.builder.root;
  }
  preserve(t, e, i) {
    let r = kT(this.old), n = this.openMarks;
    this.old.advance(t, i ? 1 : -1, {
      skip: /* @__PURE__ */ m((a, o, l) => {
        if (a.isWidget())
          if (this.openWidget)
            this.builder.continueWidget(l - o);
          else {
            let d = l > 0 || o < a.length ? Aw.of(a.widget, this.view, l - o, a.flags & 496, this.cache.maybeReuse(a)) : this.cache.reuse(a);
            d.flags & 256 ? (d.flags &= -2, this.builder.addBlockWidget(d)) : (this.builder.ensureLine(null), this.builder.addInlineWidget(d, r, n), n = r.length);
          }
        else if (a.isText())
          this.builder.ensureLine(null), !o && l == a.length ? this.builder.addText(a.text, r, n, this.cache.reuse(a)) : (this.cache.add(a), this.builder.addText(a.text.slice(o, l), r, n)), n = r.length;
        else if (a.isLine())
          a.flags &= -2, this.cache.reused.set(
            a,
            1
            /* Reused.Full */
          ), this.builder.addLine(a);
        else if (a instanceof MO)
          this.cache.add(a);
        else if (a instanceof yr)
          this.builder.ensureLine(null), this.builder.addMark(a, r, n), this.cache.reused.set(
            a,
            1
            /* Reused.Full */
          ), n = r.length;
        else
          return !1;
        this.openWidget = !1;
      }, "skip"),
      enter: /* @__PURE__ */ m((a) => {
        a.isLine() ? this.builder.addLineStart(a.attrs, this.cache.maybeReuse(a)) : (this.cache.add(a), a instanceof yr && r.unshift(a.mark)), this.openWidget = !1;
      }, "enter"),
      leave: /* @__PURE__ */ m((a) => {
        a.isLine() ? r.length && (r.length = n = 0) : a instanceof yr && (r.shift(), n = Math.min(n, r.length));
      }, "leave"),
      break: /* @__PURE__ */ m(() => {
        this.builder.addBreak(), this.openWidget = !1;
      }, "break")
    }), this.text.skip(t);
  }
  emit(t, e) {
    let i = null, r = this.builder, n = 0, a = ze.spans(this.decorations, t, e, {
      point: /* @__PURE__ */ m((o, l, d, u, p, f) => {
        if (d instanceof Tw) {
          if (this.disallowBlockEffectsFor[f]) {
            if (d.block)
              throw new RangeError("Block decorations may not be specified via plugins");
            if (l > this.view.state.doc.lineAt(o).to)
              throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
          }
          if (n = u.length, p > u.length)
            r.continueWidget(l - o);
          else {
            let y = d.widget || (d.block ? ly.block : ly.inline), g = bT(d), O = this.cache.findWidget(y, l - o, g) || Aw.of(y, this.view, l - o, g);
            d.block ? (d.startSide > 0 && r.addLineStartIfNotCovered(i), r.addBlockWidget(O)) : (r.ensureLine(i), r.addInlineWidget(O, u, p));
          }
          i = null;
        } else
          i = xT(i, d);
        l > o && this.text.skip(l - o);
      }, "point"),
      span: /* @__PURE__ */ m((o, l, d, u) => {
        for (let p = o; p < l; ) {
          let f = this.text.next(Math.min(512, l - p));
          f == null ? (r.addLineStartIfNotCovered(i), r.addBreak(), p++) : (r.ensureLine(i), r.addText(f, d, u), p += f.length), i = null;
        }
      }, "span")
    });
    r.addLineStartIfNotCovered(i), this.openWidget = a > n, this.openMarks = a;
  }
  forward(t, e, i = 1) {
    e - t <= 10 ? this.old.advance(e - t, i, this.reuseWalker) : (this.old.advance(5, -1, this.reuseWalker), this.old.advance(e - t - 10, -1), this.old.advance(5, i, this.reuseWalker));
  }
  getCompositionContext(t) {
    let e = [], i = null;
    for (let r = t.parentNode; ; r = r.parentNode) {
      let n = Le.get(r);
      if (r == this.view.contentDOM)
        break;
      n instanceof yr ? e.push(n) : n?.isLine() ? i = n : r.nodeName == "DIV" && !i && r != this.view.contentDOM ? i = new TO(r, $T) : e.push(yr.of(new rC({ tagName: r.nodeName.toLowerCase(), attributes: g7(r) }), r));
    }
    return { line: i, marks: e };
  }
}, h(od, "kf"), od);
m(OT, "TileUpdate");
let hF = OT;
function Hk(s, t) {
  let e = /* @__PURE__ */ m((i) => {
    for (let r of i.children)
      if ((t ? r.isText() : r.length) || e(r))
        return !0;
    return !1;
  }, "scan");
  return e(s);
}
h(Hk, "gu");
m(Hk, "hasContent");
function bT(s) {
  let t = s.isReplace ? (s.startSide < 0 ? 64 : 0) | (s.endSide > 0 ? 128 : 0) : s.startSide > 0 ? 32 : 16;
  return s.block && (t |= 256), t;
}
h(bT, "T0$1");
m(bT, "widgetFlags");
const $T = { class: "cm-line" };
function xT(s, t) {
  let e = t.spec.attributes, i = t.spec.class;
  return !e && !i || (s || (s = { class: "cm-line" }), e && Z0(e, s), i && (s.class += " " + i)), s;
}
h(xT, "A0$1");
m(xT, "addLineDeco");
function kT(s) {
  let t = [];
  for (let e = s.parents.length; e > 1; e--) {
    let i = e == s.parents.length ? s.tile : s.parents[e].tile;
    i instanceof yr && t.push(i.mark);
  }
  return t;
}
h(kT, "L0$1");
m(kT, "getMarks");
function Qv(s) {
  let t = Le.get(s);
  return t && t.setDOM(s.cloneNode()), s;
}
h(Qv, "Lo$1");
m(Qv, "freeNode");
var ld;
const ST = (ld = class extends zl {
  constructor(t) {
    super(), this.tag = t;
  }
  eq(t) {
    return t.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(t) {
    return t.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}, h(ld, "Pf"), ld);
m(ST, "NullWidget");
let ly = ST;
ly.inline = /* @__PURE__ */ new ly("span");
ly.block = /* @__PURE__ */ new ly("div");
const y2 = /* @__PURE__ */ new class extends zl {
  toDOM() {
    return document.createElement("br");
  }
  get isHidden() {
    return !0;
  }
  get editable() {
    return !0;
  }
}();
var cd;
const CT = (cd = class {
  constructor(t) {
    this.view = t, this.decorations = [], this.blockWrappers = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.editContextFormatting = se.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.updateDeco(), this.tile = new U0(t, t.contentDOM), this.updateInner([new Zs(0, 0, 0, t.state.doc.length)], null);
  }
  // Update the document view to a given state.
  update(t) {
    var e;
    let i = t.changedRanges;
    this.minWidth > 0 && i.length && (i.every(({ fromA: u, toA: p }) => p < this.minWidthFrom || u > this.minWidthTo) ? (this.minWidthFrom = t.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(t);
    let r = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((e = this.domChanged) === null || e === void 0) && e.newSel ? r = this.domChanged.newSel.head : !_T(t.changes, this.hasComposition) && !t.selectionSet && (r = t.state.selection.main.head));
    let n = r > -1 ? QT(this.view, t.changes, r) : null;
    if (this.domChanged = null, this.hasComposition) {
      let { from: u, to: p } = this.hasComposition;
      i = new Zs(u, p, t.changes.mapPos(u, -1), t.changes.mapPos(p, 1)).addToSet(i.slice());
    }
    this.hasComposition = n ? { from: n.range.fromB, to: n.range.toB } : null, (at.ie || at.chrome) && !n && t && t.state.doc.lines != t.startState.doc.lines && (this.forceSelection = !0);
    let a = this.decorations, o = this.blockWrappers;
    this.updateDeco();
    let l = MT(a, this.decorations, t.changes);
    l.length && (i = Zs.extendWithRanges(i, l));
    let d = RT(o, this.blockWrappers, t.changes);
    return d.length && (i = Zs.extendWithRanges(i, d)), n && !i.some((u) => u.fromA <= n.range.fromA && u.toA >= n.range.toA) && (i = n.range.addToSet(i.slice())), this.tile.flags & 2 && i.length == 0 ? !1 : (this.updateInner(i, n), t.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(t, e) {
    this.view.viewState.mustMeasureContent = !0;
    let { observer: i } = this.view;
    i.ignore(() => {
      if (e || t.length) {
        let a = this.tile, o = new hF(this.view, a, this.blockWrappers, this.decorations, this.dynamicDecorationMap);
        this.tile = o.run(t, e), RO(a, o.cache.reused);
      }
      this.tile.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.tile.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let n = at.chrome || at.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.tile.sync(n), n && (n.written || i.selectionRange.focusNode != n.node || !this.tile.dom.contains(n.node)) && (this.forceSelection = !0), this.tile.dom.style.height = "";
    });
    let r = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let n of this.tile.children)
        n.isWidget() && n.widget instanceof w2 && r.push(n.dom);
    i.updateGaps(r);
  }
  updateEditContextFormatting(t) {
    this.editContextFormatting = this.editContextFormatting.map(t.changes);
    for (let e of t.transactions)
      for (let i of e.effects)
        i.is(H7) && (this.editContextFormatting = i.value);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(t = !1, e = !1) {
    (t || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let { dom: i } = this.tile, r = this.view.root.activeElement, n = r == i, a = !n && !(this.view.state.facet(Is) || i.tabIndex > -1) && yh(i, this.view.observer.selectionRange) && !(r && i.contains(r));
    if (!(n || e || a))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let l = this.view.state.selection.main, d, u;
    if (l.empty ? u = d = this.inlineDOMNearPos(l.anchor, l.assoc || 1) : (u = this.inlineDOMNearPos(l.head, l.head == l.from ? 1 : -1), d = this.inlineDOMNearPos(l.anchor, l.anchor == l.from ? 1 : -1)), at.gecko && l.empty && !this.hasComposition && PT(d)) {
      let f = document.createTextNode("");
      this.view.observer.ignore(() => d.node.insertBefore(f, d.node.childNodes[d.offset] || null)), d = u = new Dn(f, 0), o = !0;
    }
    let p = this.view.observer.selectionRange;
    (o || !p.focusNode || (!wh(d.node, d.offset, p.anchorNode, p.anchorOffset) || !wh(u.node, u.offset, p.focusNode, p.focusOffset)) && !this.suppressWidgetCursorChange(p, l)) && (this.view.observer.ignore(() => {
      at.android && at.chrome && i.contains(p.focusNode) && ET(p.focusNode, i) && (i.blur(), i.focus({ preventScroll: !0 }));
      let f = cl(this.view.root);
      if (f) if (l.empty) {
        if (at.gecko) {
          let y = TT(d.node, d.offset);
          if (y && y != 3) {
            let g = (y == 1 ? cC : hC)(d.node, d.offset);
            g && (d = new Dn(g.node, g.offset));
          }
        }
        f.collapse(d.node, d.offset), l.bidiLevel != null && f.caretBidiLevel !== void 0 && (f.caretBidiLevel = l.bidiLevel);
      } else if (f.extend) {
        f.collapse(d.node, d.offset);
        try {
          f.extend(u.node, u.offset);
        } catch {
        }
      } else {
        let y = document.createRange();
        l.anchor > l.head && ([d, u] = [u, d]), y.setEnd(u.node, u.offset), y.setStart(d.node, d.offset), f.removeAllRanges(), f.addRange(y);
      }
      a && this.view.root.activeElement == i && (i.blur(), r && r.focus());
    }), this.view.observer.setSelectionRange(d, u)), this.impreciseAnchor = d.precise ? null : new Dn(p.anchorNode, p.anchorOffset), this.impreciseHead = u.precise ? null : new Dn(p.focusNode, p.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(t, e) {
    return this.hasComposition && e.empty && wh(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset) && this.posFromDOM(t.focusNode, t.focusOffset) == e.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: t } = this, e = t.state.selection.main, i = cl(t.root), { anchorNode: r, anchorOffset: n } = t.observer.selectionRange;
    if (!i || !e.empty || !e.assoc || !i.modify)
      return;
    let a = this.lineAt(e.head, e.assoc);
    if (!a)
      return;
    let o = a.posAtStart;
    if (e.head == o || e.head == o + a.length)
      return;
    let l = this.coordsAt(e.head, -1), d = this.coordsAt(e.head, 1);
    if (!l || !d || l.bottom > d.top)
      return;
    let u = this.domAtPos(e.head + e.assoc, e.assoc);
    i.collapse(u.node, u.offset), i.modify("move", e.assoc < 0 ? "forward" : "backward", "lineboundary"), t.observer.readSelectionRange();
    let p = t.observer.selectionRange;
    t.docView.posFromDOM(p.anchorNode, p.anchorOffset) != e.from && i.collapse(r, n);
  }
  posFromDOM(t, e) {
    let i = this.tile.nearest(t);
    if (!i)
      return this.tile.dom.compareDocumentPosition(t) & 2 ? 0 : this.view.state.doc.length;
    let r = i.posAtStart;
    if (i.isComposite()) {
      let n;
      if (t == i.dom)
        n = i.dom.childNodes[e];
      else {
        let a = fs(t) == 0 ? 0 : e == 0 ? -1 : 1;
        for (; ; ) {
          let o = t.parentNode;
          if (o == i.dom)
            break;
          a == 0 && o.firstChild != o.lastChild && (t == o.firstChild ? a = -1 : a = 1), t = o;
        }
        a < 0 ? n = t : n = t.nextSibling;
      }
      if (n == i.dom.firstChild)
        return r;
      for (; n && !Le.get(n); )
        n = n.nextSibling;
      if (!n)
        return r + i.length;
      for (let a = 0, o = r; ; a++) {
        let l = i.children[a];
        if (l.dom == n)
          return o;
        o += l.length + l.breakAfter;
      }
    } else return i.isText() ? t == i.dom ? r + e : r + (e ? i.length : 0) : r;
  }
  domAtPos(t, e) {
    let { tile: i, offset: r } = this.tile.resolveBlock(t, e);
    return i.isWidget() ? i.domPosFor(t, e) : i.domIn(r, e);
  }
  inlineDOMNearPos(t, e) {
    let i, r = -1, n = !1, a, o = -1, l = !1;
    return this.tile.blockTiles((d, u) => {
      if (d.isWidget()) {
        if (d.flags & 32 && u >= t)
          return !0;
        d.flags & 16 && (n = !0);
      } else {
        let p = u + d.length;
        if (u <= t && (i = d, r = t - u, n = p < t), p >= t && !a && (a = d, o = t - u, l = u > t), u > t && a)
          return !0;
      }
    }), !i && !a ? this.domAtPos(t, e) : (n && a ? i = null : l && i && (a = null), i && e < 0 || !a ? i.domIn(r, e) : a.domIn(o, e));
  }
  coordsAt(t, e) {
    let { tile: i, offset: r } = this.tile.resolveBlock(t, e);
    return i.isWidget() ? i.widget instanceof w2 ? null : i.coordsInWidget(r, e, !0) : i.coordsIn(r, e);
  }
  lineAt(t, e) {
    let { tile: i } = this.tile.resolveBlock(t, e);
    return i.isLine() ? i : null;
  }
  coordsForChar(t) {
    let { tile: e, offset: i } = this.tile.resolveBlock(t, 1);
    if (!e.isLine())
      return null;
    function r(n, a) {
      if (n.isComposite())
        for (let o of n.children) {
          if (o.length >= a) {
            let l = r(o, a);
            if (l)
              return l;
          }
          if (a -= o.length, a < 0)
            break;
        }
      else if (n.isText() && a < n.length) {
        let o = nr(n.text, a);
        if (o == a)
          return null;
        let l = oy(n.dom, a, o).getClientRects();
        for (let d = 0; d < l.length; d++) {
          let u = l[d];
          if (d == l.length - 1 || u.top < u.bottom && u.left < u.right)
            return u;
        }
      }
      return null;
    }
    return h(r, "n"), m(r, "scan"), r(e, i);
  }
  measureVisibleLineHeights(t) {
    let e = [], { from: i, to: r } = t, n = this.view.contentDOM.clientWidth, a = n > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, o = -1, l = this.view.textDirection == me.LTR, d = 0, u = /* @__PURE__ */ m((p, f, y) => {
      for (let g = 0; g < p.children.length && !(f > r); g++) {
        let O = p.children[g], k = f + O.length, $ = O.dom.getBoundingClientRect(), { height: T } = $;
        if (y && !g && (d += $.top - y.top), O instanceof vh)
          k > i && u(O, f, $);
        else if (f >= i && (d > 0 && e.push(-d), e.push(T + d), d = 0, a)) {
          let _ = O.dom.lastChild, D = _ ? gh(_) : [];
          if (D.length) {
            let A = D[D.length - 1], z = l ? A.right - $.left : $.right - A.left;
            z > o && (o = z, this.minWidth = n, this.minWidthFrom = f, this.minWidthTo = k);
          }
        }
        y && g == p.children.length - 1 && (d += y.bottom - $.bottom), f = k + O.breakAfter;
      }
    }, "scan");
    return u(this.tile, 0, null), e;
  }
  textDirectionAt(t) {
    let { tile: e } = this.tile.resolveBlock(t, 1);
    return getComputedStyle(e.dom).direction == "rtl" ? me.RTL : me.LTR;
  }
  measureTextSize() {
    let t = this.tile.blockTiles((a) => {
      if (a.isLine() && a.children.length && a.length <= 20) {
        let o = 0, l;
        for (let d of a.children) {
          if (!d.isText() || /[^ -~]/.test(d.text))
            return;
          let u = gh(d.dom);
          if (u.length != 1)
            return;
          o += u[0].width, l = u[0].height;
        }
        if (o)
          return {
            lineHeight: a.dom.getBoundingClientRect().height,
            charWidth: o / a.length,
            textHeight: l
          };
      }
    });
    if (t)
      return t;
    let e = document.createElement("div"), i, r, n;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.tile.dom.appendChild(e);
      let a = gh(e.firstChild)[0];
      i = e.getBoundingClientRect().height, r = a && a.width ? a.width / 27 : 7, n = a && a.height ? a.height : i, e.remove();
    }), { lineHeight: i, charWidth: r, textHeight: n };
  }
  computeBlockGapDeco() {
    let t = [], e = this.view.viewState;
    for (let i = 0, r = 0; ; r++) {
      let n = r == e.viewports.length ? null : e.viewports[r], a = n ? n.from - 1 : this.view.state.doc.length;
      if (a > i) {
        let o = (e.lineBlockAt(a).bottom - e.lineBlockAt(i).top) / this.view.scaleY;
        t.push(se.replace({
          widget: new w2(o),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, a));
      }
      if (!n)
        break;
      i = n.to + 1;
    }
    return se.set(t);
  }
  updateDeco() {
    let t = 1, e = this.view.state.facet(N0).map((n) => (this.dynamicDecorationMap[t++] = typeof n == "function") ? n(this.view) : n), i = !1, r = this.view.state.facet(vC).map((n, a) => {
      let o = typeof n == "function";
      return o && (i = !0), o ? n(this.view) : n;
    });
    for (r.length && (this.dynamicDecorationMap[t++] = i, e.push(ze.join(r))), this.decorations = [
      this.editContextFormatting,
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; t < this.decorations.length; )
      this.dynamicDecorationMap[t++] = !1;
    this.blockWrappers = this.view.state.facet(J7).map((n) => typeof n == "function" ? n(this.view) : n);
  }
  scrollIntoView(t) {
    if (t.isSnapshot) {
      let d = this.view.viewState.lineBlockAt(t.range.head);
      this.view.scrollDOM.scrollTop = d.top - t.yMargin, this.view.scrollDOM.scrollLeft = t.xMargin;
      return;
    }
    for (let d of this.view.state.facet(j7))
      try {
        if (d(this.view, t.range, t))
          return !0;
      } catch (u) {
        Wi(this.view.state, u, "scroll handler");
      }
    let { range: e } = t, i = this.coordsAt(e.head, e.empty ? e.assoc : e.head > e.anchor ? -1 : 1), r;
    if (!i)
      return;
    !e.empty && (r = this.coordsAt(e.anchor, e.anchor > e.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, r.left),
      top: Math.min(i.top, r.top),
      right: Math.max(i.right, r.right),
      bottom: Math.max(i.bottom, r.bottom)
    });
    let n = X0(this.view), a = {
      left: i.left - n.left,
      top: i.top - n.top,
      right: i.right + n.right,
      bottom: i.bottom + n.bottom
    }, { offsetWidth: o, offsetHeight: l } = this.view.scrollDOM;
    C7(this.view.scrollDOM, a, e.head < e.anchor ? -1 : 1, t.x, t.y, Math.max(Math.min(t.xMargin, o), -o), Math.max(Math.min(t.yMargin, l), -l), this.view.textDirection == me.LTR);
  }
  lineHasWidget(t) {
    let e = /* @__PURE__ */ m((i) => i.isWidget() || i.children.some(e), "scan");
    return e(this.tile.resolveBlock(t, 1).tile);
  }
  destroy() {
    RO(this.tile);
  }
}, h(cd, "$f"), cd);
m(CT, "DocView");
let tQ = CT;
function RO(s, t) {
  let e = t?.get(s);
  if (e != 1) {
    e == null && s.destroy();
    for (let i of s.children)
      RO(i, t);
  }
}
h(RO, "Yl$1");
m(RO, "destroyDropped");
function PT(s) {
  return s.node.nodeType == 1 && s.node.firstChild && (s.offset == 0 || s.node.childNodes[s.offset - 1].contentEditable == "false") && (s.offset == s.node.childNodes.length || s.node.childNodes[s.offset].contentEditable == "false");
}
h(PT, "_0$1");
m(PT, "betweenUneditable");
function OC(s, t) {
  let e = s.observer.selectionRange;
  if (!e.focusNode)
    return null;
  let i = cC(e.focusNode, e.focusOffset), r = hC(e.focusNode, e.focusOffset), n = i || r;
  if (r && i && r.node != i.node) {
    let o = Le.get(r.node);
    if (!o || o.isText() && o.text != r.node.nodeValue)
      n = r;
    else if (s.docView.lastCompositionAfterCursor) {
      let l = Le.get(i.node);
      !l || l.isText() && l.text != i.node.nodeValue || (n = r);
    }
  }
  if (s.docView.lastCompositionAfterCursor = n != i, !n)
    return null;
  let a = t - n.offset;
  return { from: a, to: a + n.node.nodeValue.length, node: n.node };
}
h(OC, "zd$1");
m(OC, "findCompositionNode");
function QT(s, t, e) {
  let i = OC(s, e);
  if (!i)
    return null;
  let { node: r, from: n, to: a } = i, o = r.nodeValue;
  if (/[\n\r]/.test(o) || s.state.doc.sliceString(i.from, i.to) != o)
    return null;
  let l = t.invertedDesc;
  return { range: new Zs(l.mapPos(n), l.mapPos(a), n, a), text: r };
}
h(QT, "M0$1");
m(QT, "findCompositionRange");
function TT(s, t) {
  return s.nodeType != 1 ? 0 : (t && s.childNodes[t - 1].contentEditable == "false" ? 1 : 0) | (t < s.childNodes.length && s.childNodes[t].contentEditable == "false" ? 2 : 0);
}
h(TT, "Z0$1");
m(TT, "nextToUneditable");
var g2, hd;
let dF = (g2 = (hd = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t, e) {
    mo(t, e, this.changes);
  }
  comparePoint(t, e) {
    mo(t, e, this.changes);
  }
  boundChange(t) {
    mo(t, t, this.changes);
  }
}, h(hd, "Ri$1"), hd), m(g2, "DecorationComparator"), g2);
function MT(s, t, e) {
  let i = new dF();
  return ze.compare(s, t, e, i), i.changes;
}
h(MT, "X0$1");
m(MT, "findChangedDeco");
var dd;
const AT = (dd = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t, e) {
    mo(t, e, this.changes);
  }
  comparePoint() {
  }
  boundChange(t) {
    mo(t, t, this.changes);
  }
}, h(dd, "Rf"), dd);
m(AT, "WrapperComparator");
let uF = AT;
function RT(s, t, e) {
  let i = new uF();
  return ze.compare(s, t, e, i), i.changes;
}
h(RT, "E0$1");
m(RT, "findChangedWrappers");
function ET(s, t) {
  for (let e = s; e && e != t; e = e.assignedSlot || e.parentNode)
    if (e.nodeType == 1 && e.contentEditable == "false")
      return !0;
  return !1;
}
h(ET, "Y0$1");
m(ET, "inUneditable");
function _T(s, t) {
  let e = !1;
  return t && s.iterChangedRanges((i, r) => {
    i < t.to && r > t.from && (e = !0);
  }), e;
}
h(_T, "W0$1");
m(_T, "touchesComposition");
var ud;
const LT = (ud = class extends zl {
  constructor(t) {
    super(), this.height = t;
  }
  toDOM() {
    let t = document.createElement("div");
    return t.className = "cm-gap", this.updateDOM(t), t;
  }
  eq(t) {
    return t.height == this.height;
  }
  updateDOM(t) {
    return t.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}, h(ud, "vf"), ud);
m(LT, "BlockGapWidget");
let w2 = LT;
function zT(s, t, e = 1) {
  let i = s.charCategorizer(t), r = s.doc.lineAt(t), n = t - r.from;
  if (r.length == 0)
    return nt.cursor(t);
  n == 0 ? e = 1 : n == r.length && (e = -1);
  let a = n, o = n;
  e < 0 ? a = nr(r.text, n, !1) : o = nr(r.text, n);
  let l = i(r.text.slice(a, o));
  for (; a > 0; ) {
    let d = nr(r.text, a, !1);
    if (i(r.text.slice(d, a)) != l)
      break;
    a = d;
  }
  for (; o < r.length; ) {
    let d = nr(r.text, o);
    if (i(r.text.slice(o, d)) != l)
      break;
    o = d;
  }
  return nt.range(a + r.from, o + r.from);
}
h(zT, "V0$1");
m(zT, "groupAt");
function IT(s, t, e, i, r) {
  let n = Math.round((i - t.left) * s.defaultCharacterWidth);
  if (s.lineWrapping && e.height > s.defaultLineHeight * 1.5) {
    let o = s.viewState.heightOracle.textHeight, l = Math.floor((r - e.top - (s.defaultLineHeight - o) * 0.5) / o);
    n += l * s.viewState.heightOracle.lineLength;
  }
  let a = s.state.sliceDoc(e.from, e.to);
  return e.from + d7(a, n, s.state.tabSize);
}
h(IT, "U0$1");
m(IT, "posAtCoordsImprecise");
function DT(s, t, e) {
  let i = s.lineBlockAt(t);
  if (Array.isArray(i.type)) {
    let r;
    for (let n of i.type) {
      if (n.from > t)
        break;
      if (!(n.to < t)) {
        if (n.from < t && n.to > t)
          return n;
        (!r || n.type == vr.Text && (r.type != n.type || (e < 0 ? n.from < t : n.to > t))) && (r = n);
      }
    }
    return r || i;
  }
  return i;
}
h(DT, "I0$1");
m(DT, "blockAt");
function VT(s, t, e, i) {
  let r = DT(s, t.head, t.assoc || -1), n = !i || r.type != vr.Text || !(s.lineWrapping || r.widgetLineBreaks) ? null : s.coordsAtPos(t.assoc < 0 && t.head > r.from ? t.head - 1 : t.head);
  if (n) {
    let a = s.dom.getBoundingClientRect(), o = s.textDirectionAt(r.from), l = s.posAtCoords({
      x: e == (o == me.LTR) ? a.right - 1 : a.left + 1,
      y: (n.top + n.bottom) / 2
    });
    if (l != null)
      return nt.cursor(l, e ? -1 : 1);
  }
  return nt.cursor(e ? r.to : r.from, e ? -1 : 1);
}
h(VT, "z0$1");
m(VT, "moveToLineBoundary");
function Yk(s, t, e, i) {
  let r = s.state.doc.lineAt(t.head), n = s.bidiSpans(r), a = s.textDirectionAt(r.from);
  for (let o = t, l = null; ; ) {
    let d = D7(r, n, a, o, e), u = I7;
    if (!d) {
      if (r.number == (e ? s.state.doc.lines : 1))
        return o;
      u = `
`, r = s.state.doc.line(r.number + (e ? 1 : -1)), n = s.bidiSpans(r), d = s.visualLineSide(r, !e);
    }
    if (l) {
      if (!l(u))
        return o;
    } else {
      if (!i)
        return d;
      l = i(u);
    }
    o = d;
  }
}
h(Yk, "Qu$1");
m(Yk, "moveByChar");
function WT(s, t, e) {
  let i = s.state.charCategorizer(t), r = i(e);
  return (n) => {
    let a = i(n);
    return r == Fs.Space && (r = a), r == a;
  };
}
h(WT, "j0$1");
m(WT, "byGroup");
function FT(s, t, e, i) {
  let r = t.head, n = e ? 1 : -1;
  if (r == (e ? s.state.doc.length : 0))
    return nt.cursor(r, t.assoc);
  let a = t.goalColumn, o, l = s.contentDOM.getBoundingClientRect(), d = s.coordsAtPos(r, t.assoc || -1), u = s.documentTop;
  if (d)
    a == null && (a = d.left - l.left), o = n < 0 ? d.top : d.bottom;
  else {
    let g = s.viewState.lineBlockAt(r);
    a == null && (a = Math.min(l.right - l.left, s.defaultCharacterWidth * (r - g.from))), o = (n < 0 ? g.top : g.bottom) + u;
  }
  let p = l.left + a, f = i ?? s.viewState.heightOracle.textHeight >> 1, y = EO(s, { x: p, y: o + f * n }, !1, n);
  return nt.cursor(y.pos, y.assoc, void 0, a);
}
h(FT, "q0$1");
m(FT, "moveVertically");
function Oh(s, t, e) {
  for (; ; ) {
    let i = 0;
    for (let r of s)
      r.between(t - 1, t + 1, (n, a, o) => {
        if (t > n && t < a) {
          let l = i || e || (t - n < a - t ? -1 : 1);
          t = l < 0 ? n : a, i = l;
        }
      });
    if (!i)
      return t;
  }
}
h(Oh, "xr$1");
m(Oh, "skipAtomicRanges");
function bC(s, t) {
  let e = null;
  for (let i = 0; i < t.ranges.length; i++) {
    let r = t.ranges[i], n = null;
    if (r.empty) {
      let a = Oh(s, r.from, 0);
      a != r.from && (n = nt.cursor(a, -1));
    } else {
      let a = Oh(s, r.from, -1), o = Oh(s, r.to, 1);
      (a != r.from || o != r.to) && (n = nt.range(r.from == r.anchor ? a : o, r.from == r.head ? a : o));
    }
    n && (e || (e = t.ranges.slice()), e[i] = n);
  }
  return e ? nt.create(e, t.mainIndex) : t;
}
h(bC, "jd$1");
m(bC, "skipAtomsForSelection");
function Tv(s, t, e) {
  let i = Oh(s.state.facet(w1).map((r) => r(s)), e.from, t.head > e.from ? -1 : 1);
  return i == e.from ? e : nt.cursor(i, i < e.from ? 1 : -1);
}
h(Tv, "Mo$1");
m(Tv, "skipAtoms");
var pd;
const qT = (pd = class {
  constructor(t, e) {
    this.pos = t, this.assoc = e;
  }
}, h(pd, "Tf"), pd);
m(qT, "PosAssoc");
let ss = qT;
function EO(s, t, e, i) {
  let r = s.contentDOM.getBoundingClientRect(), n = r.top + s.viewState.paddingTop, { x: a, y: o } = t, l = o - n, d;
  for (; ; ) {
    if (l < 0)
      return new ss(0, 1);
    if (l > s.viewState.docHeight)
      return new ss(s.state.doc.length, -1);
    if (d = s.elementAtHeight(l), i == null)
      break;
    if (d.type == vr.Text) {
      let f = s.docView.coordsAt(i < 0 ? d.from : d.to, i);
      if (f && (i < 0 ? f.top <= l + n : f.bottom >= l + n))
        break;
    }
    let p = s.viewState.heightOracle.textHeight / 2;
    l = i > 0 ? d.bottom + p : d.top - p;
  }
  if (s.viewport.from >= d.to || s.viewport.to <= d.from) {
    if (e)
      return null;
    if (d.type == vr.Text) {
      let p = IT(s, r, d, a, o);
      return new ss(p, p == d.from ? 1 : -1);
    }
  }
  if (d.type != vr.Text)
    return l < (d.top + d.bottom) / 2 ? new ss(d.from, 1) : new ss(d.to, -1);
  let u = s.docView.lineAt(d.from, 2);
  return (!u || u.length != d.length) && (u = s.docView.lineAt(d.from, -2)), $C(s, u, d.from, a, o);
}
h(EO, "Vl$1");
m(EO, "posAtCoords");
function $C(s, t, e, i, r) {
  let n = -1, a = null, o = 1e9, l = 1e9, d = r, u = r, p = /* @__PURE__ */ m((f, y) => {
    for (let g = 0; g < f.length; g++) {
      let O = f[g];
      if (O.top == O.bottom)
        continue;
      let k = O.left > i ? O.left - i : O.right < i ? i - O.right : 0, $ = O.top > r ? O.top - r : O.bottom < r ? r - O.bottom : 0;
      O.top <= u && O.bottom >= d && (d = Math.min(O.top, d), u = Math.max(O.bottom, u), $ = 0), (n < 0 || ($ - l || k - o) < 0) && (n >= 0 && l && o < k && a.top <= u - 2 && a.bottom >= d + 2 ? l = 0 : (n = y, o = k, l = $, a = O));
    }
  }, "checkRects");
  if (t.isText()) {
    for (let f = 0; f < t.length; ) {
      let y = nr(t.text, f);
      if (p(oy(t.dom, f, y).getClientRects(), f), !o && !l)
        break;
      f = y;
    }
    return i > (a.left + a.right) / 2 == (Gk(s, n + e) == me.LTR) ? new ss(e + nr(t.text, n), -1) : new ss(e + n, 1);
  } else {
    if (!t.length)
      return new ss(e, 1);
    for (let g = 0; g < t.children.length; g++) {
      let O = t.children[g];
      if (O.flags & 48)
        continue;
      let k = (O.dom.nodeType == 1 ? O.dom : oy(O.dom, 0, O.length)).getClientRects();
      if (p(k, g), !o && !l)
        break;
    }
    let f = t.children[n], y = t.posBefore(f, e);
    return f.isComposite() || f.isText() ? $C(s, f, y, Math.max(a.left, Math.min(a.right, i)), r) : i > (a.left + a.right) / 2 == (Gk(s, n + e) == me.LTR) ? new ss(y + f.length, -1) : new ss(y, 1);
  }
}
h($C, "qd$1");
m($C, "posAtCoordsInline");
function Gk(s, t) {
  let e = s.state.doc.lineAt(t);
  return s.bidiSpans(e)[qs.find(s.bidiSpans(e), t - e.from, -1, 1)].dir;
}
h(Gk, "yu");
m(Gk, "dirAt");
const Mg = "￿";
var fd;
const ZT = (fd = class {
  constructor(t, e) {
    this.points = t, this.view = e, this.text = "", this.lineSeparator = e.state.facet(Be.lineSeparator);
  }
  append(t) {
    this.text += t;
  }
  lineBreak() {
    this.text += Mg;
  }
  readRange(t, e) {
    if (!t)
      return this;
    let i = t.parentNode;
    for (let r = t; ; ) {
      this.findPointBefore(i, r);
      let n = this.text.length;
      this.readNode(r);
      let a = Le.get(r), o = r.nextSibling;
      if (o == e) {
        a?.breakAfter && !o && i != this.view.contentDOM && this.lineBreak();
        break;
      }
      let l = Le.get(o);
      (a && l ? a.breakAfter : (a ? a.breakAfter : Mw(r)) || Mw(o) && (r.nodeName != "BR" || a?.isWidget()) && this.text.length > n) && !NT(o, e) && this.lineBreak(), r = o;
    }
    return this.findPointBefore(i, e), this;
  }
  readTextNode(t) {
    let e = t.nodeValue;
    for (let i of this.points)
      i.node == t && (i.pos = this.text.length + Math.min(i.offset, e.length));
    for (let i = 0, r = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let n = -1, a = 1, o;
      if (this.lineSeparator ? (n = e.indexOf(this.lineSeparator, i), a = this.lineSeparator.length) : (o = r.exec(e)) && (n = o.index, a = o[0].length), this.append(e.slice(i, n < 0 ? e.length : n)), n < 0)
        break;
      if (this.lineBreak(), a > 1)
        for (let l of this.points)
          l.node == t && l.pos > this.text.length && (l.pos -= a - 1);
      i = n + a;
    }
  }
  readNode(t) {
    let e = Le.get(t), i = e && e.overrideDOMText;
    if (i != null) {
      this.findPointInside(t, i.length);
      for (let r = i.iter(); !r.next().done; )
        r.lineBreak ? this.lineBreak() : this.append(r.value);
    } else t.nodeType == 3 ? this.readTextNode(t) : t.nodeName == "BR" ? t.nextSibling && this.lineBreak() : t.nodeType == 1 && this.readRange(t.firstChild, null);
  }
  findPointBefore(t, e) {
    for (let i of this.points)
      i.node == t && t.childNodes[i.offset] == e && (i.pos = this.text.length);
  }
  findPointInside(t, e) {
    for (let i of this.points)
      (t.nodeType == 3 ? i.node == t : t.contains(i.node)) && (i.pos = this.text.length + (BT(t, i.node, i.offset) ? e : 0));
  }
}, h(fd, "Af"), fd);
m(ZT, "DOMReader");
let pF = ZT;
function BT(s, t, e) {
  for (; ; ) {
    if (!t || e < fs(t))
      return !1;
    if (t == s)
      return !0;
    e = en(t) + 1, t = t.parentNode;
  }
}
h(BT, "B0$1");
m(BT, "isAtEnd");
function NT(s, t) {
  let e;
  for (; !(s == t || !s); s = s.nextSibling) {
    let i = Le.get(s);
    if (!i?.isWidget())
      return !1;
    i && (e || (e = [])).push(i);
  }
  if (e) {
    for (let i of e)
      if (i.overrideDOMText?.length)
        return !1;
  }
  return !0;
}
h(NT, "D0$1");
m(NT, "isEmptyToEnd");
var md;
const XT = (md = class {
  constructor(t, e) {
    this.node = t, this.offset = e, this.pos = -1;
  }
}, h(md, "Lf"), md);
m(XT, "DOMPoint");
let eQ = XT;
var yd;
const jT = (yd = class {
  constructor(t, e, i, r) {
    this.typeOver = r, this.bounds = null, this.text = "", this.domChanged = e > -1;
    let { impreciseHead: n, impreciseAnchor: a } = t.docView;
    if (t.state.readOnly && e > -1)
      this.newSel = null;
    else if (e > -1 && (this.bounds = xC(t.docView.tile, e, i, 0))) {
      let o = n || a ? [] : HT(t), l = new pF(o, t);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = YT(o, this.bounds.from);
    } else {
      let o = t.observer.selectionRange, l = n && n.node == o.focusNode && n.offset == o.focusOffset || !CO(t.contentDOM, o.focusNode) ? t.state.selection.main.head : t.docView.posFromDOM(o.focusNode, o.focusOffset), d = a && a.node == o.anchorNode && a.offset == o.anchorOffset || !CO(t.contentDOM, o.anchorNode) ? t.state.selection.main.anchor : t.docView.posFromDOM(o.anchorNode, o.anchorOffset), u = t.viewport;
      if ((at.ios || at.chrome) && t.state.selection.main.empty && l != d && (u.from > 0 || u.to < t.state.doc.length)) {
        let p = Math.min(l, d), f = Math.max(l, d), y = u.from - p, g = u.to - f;
        (y == 0 || y == 1 || p == 0) && (g == 0 || g == -1 || f == t.state.doc.length) && (l = 0, d = t.state.doc.length);
      }
      t.inputState.composing > -1 && t.state.selection.ranges.length > 1 ? this.newSel = t.state.selection.replaceRange(nt.range(d, l)) : this.newSel = nt.single(d, l);
    }
  }
}, h(yd, "_f"), yd);
m(jT, "DOMChange");
let fF = jT;
function xC(s, t, e, i) {
  if (s.isComposite()) {
    let r = -1, n = -1, a = -1, o = -1;
    for (let l = 0, d = i, u = i; l < s.children.length; l++) {
      let p = s.children[l], f = d + p.length;
      if (d < t && f > e)
        return xC(p, t, e, d);
      if (f >= t && r == -1 && (r = l, n = d), d > e && p.dom.parentNode == s.dom) {
        a = l, o = u;
        break;
      }
      u = f, d = f + p.breakAfter;
    }
    return {
      from: n,
      to: o < 0 ? i + s.length : o,
      startDOM: (r ? s.children[r - 1].dom.nextSibling : null) || s.dom.firstChild,
      endDOM: a < s.children.length && a >= 0 ? s.children[a].dom : null
    };
  } else return s.isText() ? { from: i, to: i + s.length, startDOM: s.dom, endDOM: s.dom.nextSibling } : null;
}
h(xC, "Bd$1");
m(xC, "domBoundsAround");
function kC(s, t) {
  let e, { newSel: i } = t, r = s.state.selection.main, n = s.inputState.lastKeyTime > Date.now() - 100 ? s.inputState.lastKeyCode : -1;
  if (t.bounds) {
    let { from: a, to: o } = t.bounds, l = r.from, d = null;
    (n === 8 || at.android && t.text.length < o - a) && (l = r.to, d = "end");
    let u = SC(s.state.doc.sliceString(a, o, Mg), t.text, l - a, d);
    u && (at.chrome && n == 13 && u.toB == u.from + 2 && t.text.slice(u.from, u.toB) == Mg + Mg && u.toB--, e = {
      from: a + u.from,
      to: a + u.toA,
      insert: Ht.of(t.text.slice(u.from, u.toB).split(Mg))
    });
  } else i && (!s.hasFocus && s.state.facet(Is) || Rw(i, r)) && (i = null);
  if (!e && !i)
    return !1;
  if (!e && t.typeOver && !r.empty && i && i.main.empty ? e = { from: r.from, to: r.to, insert: s.state.doc.slice(r.from, r.to) } : (at.mac || at.android) && e && e.from == e.to && e.from == r.head - 1 && /^\. ?$/.test(e.insert.toString()) && s.contentDOM.getAttribute("autocorrect") == "off" ? (i && e.insert.length == 2 && (i = nt.single(i.main.anchor - 1, i.main.head - 1)), e = { from: e.from, to: e.to, insert: Ht.of([e.insert.toString().replace(".", " ")]) }) : e && e.from >= r.from && e.to <= r.to && (e.from != r.from || e.to != r.to) && r.to - r.from - (e.to - e.from) <= 4 ? e = {
    from: r.from,
    to: r.to,
    insert: s.state.doc.slice(r.from, e.from).append(e.insert).append(s.state.doc.slice(e.to, r.to))
  } : s.state.doc.lineAt(r.from).to < r.to && s.docView.lineHasWidget(r.to) && s.inputState.insertingTextAt > Date.now() - 50 ? e = {
    from: r.from,
    to: r.to,
    insert: s.state.toText(s.inputState.insertingText)
  } : at.chrome && e && e.from == e.to && e.from == r.head && e.insert.toString() == `
 ` && s.lineWrapping && (i && (i = nt.single(i.main.anchor - 1, i.main.head - 1)), e = { from: r.from, to: r.to, insert: Ht.of([" "]) }), e)
    return H0(s, e, i, n);
  if (i && !Rw(i, r)) {
    let a = !1, o = "select";
    return s.inputState.lastSelectionTime > Date.now() - 50 && (s.inputState.lastSelectionOrigin == "select" && (a = !0), o = s.inputState.lastSelectionOrigin, o == "select.pointer" && (i = bC(s.state.facet(w1).map((l) => l(s)), i))), s.dispatch({ selection: i, scrollIntoView: a, userEvent: o }), !0;
  } else
    return !1;
}
h(kC, "Dd$1");
m(kC, "applyDOMChange");
function H0(s, t, e, i = -1) {
  if (at.ios && s.inputState.flushIOSKey(t))
    return !0;
  let r = s.state.selection.main;
  if (at.android && (t.to == r.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (t.from == r.from || t.from == r.from - 1 && s.state.sliceDoc(t.from, r.from) == " ") && t.insert.length == 1 && t.insert.lines == 2 && yo(s.contentDOM, "Enter", 13) || (t.from == r.from - 1 && t.to == r.to && t.insert.length == 0 || i == 8 && t.insert.length < t.to - t.from && t.to > r.head) && yo(s.contentDOM, "Backspace", 8) || t.from == r.from && t.to == r.to + 1 && t.insert.length == 0 && yo(s.contentDOM, "Delete", 46)))
    return !0;
  let n = t.insert.toString();
  s.inputState.composing >= 0 && s.inputState.composing++;
  let a, o = /* @__PURE__ */ m(() => a || (a = UT(s, t, e)), "defaultInsert");
  return s.state.facet(B7).some((l) => l(s, t.from, t.to, n, o)) || s.dispatch(o()), !0;
}
h(H0, "Sh$1");
m(H0, "applyDOMChangeInner");
function UT(s, t, e) {
  let i, r = s.state, n = r.selection.main, a = -1;
  if (t.from == t.to && t.from < n.from || t.from > n.to) {
    let l = t.from < n.from ? -1 : 1, d = l < 0 ? n.from : n.to, u = Oh(r.facet(w1).map((p) => p(s)), d, l);
    t.from == u && (a = u);
  }
  if (a > -1)
    i = {
      changes: t,
      selection: nt.cursor(t.from + t.insert.length, -1)
    };
  else if (t.from >= n.from && t.to <= n.to && t.to - t.from >= (n.to - n.from) / 3 && (!e || e.main.empty && e.main.from == t.from + t.insert.length) && s.inputState.composing < 0) {
    let l = n.from < t.from ? r.sliceDoc(n.from, t.from) : "", d = n.to > t.to ? r.sliceDoc(t.to, n.to) : "";
    i = r.replaceSelection(s.state.toText(l + t.insert.sliceString(0, void 0, s.state.lineBreak) + d));
  } else {
    let l = r.changes(t), d = e && e.main.to <= l.newLength ? e.main : void 0;
    if (r.selection.ranges.length > 1 && (s.inputState.composing >= 0 || s.inputState.compositionPendingChange) && t.to <= n.to + 10 && t.to >= n.to - 10) {
      let u = s.state.sliceDoc(t.from, t.to), p, f = e && OC(s, e.main.head);
      if (f) {
        let g = t.insert.length - (t.to - t.from);
        p = { from: f.from, to: f.to - g };
      } else
        p = s.state.doc.lineAt(n.head);
      let y = n.to - t.to;
      i = r.changeByRange((g) => {
        if (g.from == n.from && g.to == n.to)
          return { changes: l, range: d || g.map(l) };
        let O = g.to - y, k = O - u.length;
        if (s.state.sliceDoc(k, O) != u || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        O >= p.from && k <= p.to)
          return { range: g };
        let $ = r.changes({ from: k, to: O, insert: t.insert }), T = g.to - n.to;
        return {
          changes: $,
          range: d ? nt.range(Math.max(0, d.anchor + T), Math.max(0, d.head + T)) : g.map($)
        };
      });
    } else
      i = {
        changes: l,
        selection: d && r.selection.replaceRange(d)
      };
  }
  let o = "input.type";
  return (s.composing || s.inputState.compositionPendingChange && s.inputState.compositionEndedAt > Date.now() - 50) && (s.inputState.compositionPendingChange = !1, o += ".compose", s.inputState.compositionFirstChange && (o += ".start", s.inputState.compositionFirstChange = !1)), r.update(i, { userEvent: o, scrollIntoView: !0 });
}
h(UT, "N0$1");
m(UT, "applyDefaultInsert");
function SC(s, t, e, i) {
  let r = Math.min(s.length, t.length), n = 0;
  for (; n < r && s.charCodeAt(n) == t.charCodeAt(n); )
    n++;
  if (n == r && s.length == t.length)
    return null;
  let a = s.length, o = t.length;
  for (; a > 0 && o > 0 && s.charCodeAt(a - 1) == t.charCodeAt(o - 1); )
    a--, o--;
  if (i == "end") {
    let l = Math.max(0, n - Math.min(a, o));
    e -= a + l - n;
  }
  if (a < n && s.length < t.length) {
    let l = e <= n && e >= a ? n - e : 0;
    n -= l, o = n + (o - a), a = n;
  } else if (o < n) {
    let l = e <= n && e >= o ? n - e : 0;
    n -= l, a = n + (a - o), o = n;
  }
  return { from: n, toA: a, toB: o };
}
h(SC, "Nd");
m(SC, "findDiff");
function HT(s) {
  let t = [];
  if (s.root.activeElement != s.contentDOM)
    return t;
  let { anchorNode: e, anchorOffset: i, focusNode: r, focusOffset: n } = s.observer.selectionRange;
  return e && (t.push(new eQ(e, i)), (r != e || n != i) && t.push(new eQ(r, n))), t;
}
h(HT, "G0$1");
m(HT, "selectionPoints");
function YT(s, t) {
  if (s.length == 0)
    return null;
  let e = s[0].pos, i = s.length == 2 ? s[1].pos : e;
  return e > -1 && i > -1 ? nt.single(e + t, i + t) : null;
}
h(YT, "F0$1");
m(YT, "selectionFromPoints");
function Rw(s, t) {
  return t.head == s.main.head && t.anchor == s.main.anchor;
}
h(Rw, "as$2");
m(Rw, "sameSelPos");
var gd;
const GT = (gd = class {
  setSelectionOrigin(t) {
    this.lastSelectionOrigin = t, this.lastSelectionTime = Date.now();
  }
  constructor(t) {
    this.view = t, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.insertingText = "", this.insertingTextAt = 0, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = t.hasFocus, at.safari && t.contentDOM.addEventListener("input", () => null), at.gecko && f6(t.contentDOM.ownerDocument);
  }
  handleEvent(t) {
    !a6(this.view, t) || this.ignoreDuringComposition(t) || t.type == "keydown" && this.keydown(t) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(t.type, t)) : this.runHandlers(t.type, t));
  }
  runHandlers(t, e) {
    let i = this.handlers[t];
    if (i) {
      for (let r of i.observers)
        r(this.view, e);
      for (let r of i.handlers) {
        if (e.defaultPrevented)
          break;
        if (r(this.view, e)) {
          e.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(t) {
    let e = KT(t), i = this.handlers, r = this.view.contentDOM;
    for (let n in e)
      if (n != "scroll") {
        let a = !e[n].handlers.length, o = i[n];
        o && a != !o.handlers.length && (r.removeEventListener(n, this.handleEvent), o = null), o || r.addEventListener(n, this.handleEvent, { passive: a });
      }
    for (let n in i)
      n != "scroll" && !e[n] && r.removeEventListener(n, this.handleEvent);
    this.handlers = e;
  }
  keydown(t) {
    if (this.lastKeyCode = t.keyCode, this.lastKeyTime = Date.now(), t.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && t.keyCode != 27 && t6.indexOf(t.keyCode) < 0 && (this.tabFocusMode = -1), at.android && at.chrome && !t.synthetic && (t.keyCode == 13 || t.keyCode == 8))
      return this.view.observer.delayAndroidKey(t.key, t.keyCode), !0;
    let e;
    return at.ios && !t.synthetic && !t.altKey && !t.metaKey && ((e = JT.find((i) => i.keyCode == t.keyCode)) && !t.ctrlKey || yF.indexOf(t.key) > -1 && t.ctrlKey && !t.shiftKey) ? (this.pendingIOSKey = e || t, setTimeout(() => this.flushIOSKey(), 250), !0) : (t.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(t) {
    let e = this.pendingIOSKey;
    return !e || e.key == "Enter" && t && t.from < t.to && /^\S+$/.test(t.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, yo(this.view.contentDOM, e.key, e.keyCode, e instanceof KeyboardEvent ? e : void 0));
  }
  ignoreDuringComposition(t) {
    return !/^key/.test(t.type) || t.synthetic ? !1 : this.composing > 0 ? !0 : at.safari && !at.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1;
  }
  startMouseSelection(t) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = t;
  }
  update(t) {
    this.view.observer.update(t), this.mouseSelection && this.mouseSelection.update(t), this.draggedContent && t.docChanged && (this.draggedContent = this.draggedContent.map(t.changes)), t.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}, h(gd, "Mf"), gd);
m(GT, "InputState");
let mF = GT;
function Kk(s, t) {
  return (e, i) => {
    try {
      return t.call(s, i, e);
    } catch (r) {
      Wi(e.state, r);
    }
  };
}
h(Kk, "Su");
m(Kk, "bindHandler");
function KT(s) {
  let t = /* @__PURE__ */ Object.create(null);
  function e(i) {
    return t[i] || (t[i] = { observers: [], handlers: [] });
  }
  h(e, "t"), m(e, "record");
  for (let i of s) {
    let r = i.spec, n = r && r.plugin.domEventHandlers, a = r && r.plugin.domEventObservers;
    if (n)
      for (let o in n) {
        let l = n[o];
        l && e(o).handlers.push(Kk(i.value, l));
      }
    if (a)
      for (let o in a) {
        let l = a[o];
        l && e(o).observers.push(Kk(i.value, l));
      }
  }
  for (let i in Vr)
    e(i).handlers.push(Vr[i]);
  for (let i in Or)
    e(i).observers.push(Or[i]);
  return t;
}
h(KT, "H0$1");
m(KT, "computeHandlers");
const JT = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], yF = "dthko", t6 = [16, 17, 18, 20, 91, 92, 224, 225], ev = 6;
function Ag(s) {
  return Math.max(0, s) * 0.7 + 8;
}
h(Ag, "An$1");
m(Ag, "dragScrollSpeed");
function e6(s, t) {
  return Math.max(Math.abs(s.clientX - t.clientX), Math.abs(s.clientY - t.clientY));
}
h(e6, "J0$1");
m(e6, "dist");
var wd;
const i6 = (wd = class {
  constructor(t, e, i, r) {
    this.view = t, this.startEvent = e, this.style = i, this.mustSelect = r, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = e, this.scrollParents = P7(t.contentDOM), this.atoms = t.state.facet(w1).map((a) => a(t));
    let n = t.contentDOM.ownerDocument;
    n.addEventListener("mousemove", this.move = this.move.bind(this)), n.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = e.shiftKey, this.multiple = t.state.facet(Be.allowMultipleSelections) && r6(t, e), this.dragging = n6(t, e) && PC(e) == 1 ? null : !1;
  }
  start(t) {
    this.dragging === !1 && this.select(t);
  }
  move(t) {
    if (t.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && e6(this.startEvent, t) < 10)
      return;
    this.select(this.lastEvent = t);
    let e = 0, i = 0, r = 0, n = 0, a = this.view.win.innerWidth, o = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: r, right: a } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: n, bottom: o } = this.scrollParents.y.getBoundingClientRect());
    let l = X0(this.view);
    t.clientX - l.left <= r + ev ? e = -Ag(r - t.clientX) : t.clientX + l.right >= a - ev && (e = Ag(t.clientX - a)), t.clientY - l.top <= n + ev ? i = -Ag(n - t.clientY) : t.clientY + l.bottom >= o - ev && (i = Ag(t.clientY - o)), this.setScrollSpeed(e, i);
  }
  up(t) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || t.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let t = this.view.contentDOM.ownerDocument;
    t.removeEventListener("mousemove", this.move), t.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(t, e) {
    this.scrollSpeed = { x: t, y: e }, t || e ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: t, y: e } = this.scrollSpeed;
    t && this.scrollParents.x && (this.scrollParents.x.scrollLeft += t, t = 0), e && this.scrollParents.y && (this.scrollParents.y.scrollTop += e, e = 0), (t || e) && this.view.win.scrollBy(t, e), this.dragging === !1 && this.select(this.lastEvent);
  }
  select(t) {
    let { view: e } = this, i = bC(this.atoms, this.style.get(t, this.extend, this.multiple));
    (this.mustSelect || !i.eq(e.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(t) {
    t.transactions.some((e) => e.isUserEvent("input.type")) ? this.destroy() : this.style.update(t) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}, h(wd, "Zf"), wd);
m(i6, "MouseSelection");
let gF = i6;
function r6(s, t) {
  let e = s.state.facet(W7);
  return e.length ? e[0](t) : at.mac ? t.metaKey : t.ctrlKey;
}
h(r6, "e1$1");
m(r6, "addsSelectionRange");
function s6(s, t) {
  let e = s.state.facet(F7);
  return e.length ? e[0](t) : at.mac ? !t.altKey : !t.ctrlKey;
}
h(s6, "t1$1");
m(s6, "dragMovesSelection");
function n6(s, t) {
  let { main: e } = s.state.selection;
  if (e.empty)
    return !1;
  let i = cl(s.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let r = i.getRangeAt(0).getClientRects();
  for (let n = 0; n < r.length; n++) {
    let a = r[n];
    if (a.left <= t.clientX && a.right >= t.clientX && a.top <= t.clientY && a.bottom >= t.clientY)
      return !0;
  }
  return !1;
}
h(n6, "i1$1");
m(n6, "isInPrimarySelection");
function a6(s, t) {
  if (!t.bubbles)
    return !0;
  if (t.defaultPrevented)
    return !1;
  for (let e = t.target, i; e != s.contentDOM; e = e.parentNode)
    if (!e || e.nodeType == 11 || (i = Le.get(e)) && i.isWidget() && !i.isHidden && i.widget.ignoreEvent(t))
      return !1;
  return !0;
}
h(a6, "r1$1");
m(a6, "eventBelongsToEditor");
const Vr = /* @__PURE__ */ Object.create(null), Or = /* @__PURE__ */ Object.create(null), o6 = at.ie && at.ie_version < 15 || at.ios && at.webkit_version < 604;
function l6(s) {
  let t = s.dom.parentNode;
  if (!t)
    return;
  let e = t.appendChild(document.createElement("textarea"));
  e.style.cssText = "position: fixed; left: -10000px; top: 10px", e.focus(), setTimeout(() => {
    s.focus(), e.remove(), CC(s, e.value);
  }, 50);
}
h(l6, "n1$1");
m(l6, "capturePaste");
function v1(s, t, e) {
  for (let i of s.facet(t))
    e = i(e, s);
  return e;
}
h(v1, "bo$1");
m(v1, "textFilter");
function CC(s, t) {
  t = v1(s.state, yC, t);
  let { state: e } = s, i, r = 1, n = e.toText(t), a = n.lines == e.selection.ranges.length;
  if (e5 != null && e.selection.ranges.every((o) => o.empty) && e5 == n.toString()) {
    let o = -1;
    i = e.changeByRange((l) => {
      let d = e.doc.lineAt(l.from);
      if (d.from == o)
        return { range: l };
      o = d.from;
      let u = e.toText((a ? n.line(r++).text : t) + e.lineBreak);
      return {
        changes: { from: d.from, insert: u },
        range: nt.cursor(l.from + u.length)
      };
    });
  } else a ? i = e.changeByRange((o) => {
    let l = n.line(r++);
    return {
      changes: { from: o.from, to: o.to, insert: l.text },
      range: nt.cursor(o.from + l.length)
    };
  }) : i = e.replaceSelection(n);
  s.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
h(CC, "Kd$1");
m(CC, "doPaste");
Or.scroll = (s) => {
  s.inputState.lastScrollTop = s.scrollDOM.scrollTop, s.inputState.lastScrollLeft = s.scrollDOM.scrollLeft;
};
Vr.keydown = (s, t) => (s.inputState.setSelectionOrigin("select"), t.keyCode == 27 && s.inputState.tabFocusMode != 0 && (s.inputState.tabFocusMode = Date.now() + 2e3), !1);
Or.touchstart = (s, t) => {
  s.inputState.lastTouchTime = Date.now(), s.inputState.setSelectionOrigin("select.pointer");
};
Or.touchmove = (s) => {
  s.inputState.setSelectionOrigin("select.pointer");
};
Vr.mousedown = (s, t) => {
  if (s.observer.flush(), s.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let e = null;
  for (let i of s.state.facet(q7))
    if (e = i(s, t), e)
      break;
  if (!e && t.button == 0 && (e = c6(s, t)), e) {
    let i = !s.hasFocus;
    s.inputState.startMouseSelection(new gF(s, t, e, i)), i && s.observer.ignore(() => {
      oC(s.contentDOM);
      let n = s.root.activeElement;
      n && !n.contains(s.contentDOM) && n.blur();
    });
    let r = s.inputState.mouseSelection;
    if (r)
      return r.start(t), r.dragging === !1;
  } else
    s.inputState.setSelectionOrigin("select.pointer");
  return !1;
};
function Jk(s, t, e, i) {
  if (i == 1)
    return nt.cursor(t, e);
  if (i == 2)
    return zT(s.state, t, e);
  {
    let r = s.docView.lineAt(t, e), n = s.state.doc.lineAt(r ? r.posAtEnd : t), a = r ? r.posAtStart : n.from, o = r ? r.posAtEnd : n.to;
    return o < s.state.doc.length && o == n.to && o++, nt.range(a, o);
  }
}
h(Jk, "bu");
m(Jk, "rangeForClick");
const wF = at.ie && at.ie_version <= 11;
let iQ = null, rQ = 0, sQ = 0;
function PC(s) {
  if (!wF)
    return s.detail;
  let t = iQ, e = sQ;
  return iQ = s, sQ = Date.now(), rQ = !t || e > Date.now() - 400 && Math.abs(t.clientX - s.clientX) < 2 && Math.abs(t.clientY - s.clientY) < 2 ? (rQ + 1) % 3 : 1;
}
h(PC, "Jd$1");
m(PC, "getClickType");
function c6(s, t) {
  let e = s.posAndSideAtCoords({ x: t.clientX, y: t.clientY }, !1), i = PC(t), r = s.state.selection;
  return {
    update(n) {
      n.docChanged && (e.pos = n.changes.mapPos(e.pos), r = r.map(n.changes));
    },
    get(n, a, o) {
      let l = s.posAndSideAtCoords({ x: n.clientX, y: n.clientY }, !1), d, u = Jk(s, l.pos, l.assoc, i);
      if (e.pos != l.pos && !a) {
        let p = Jk(s, e.pos, e.assoc, i), f = Math.min(p.from, u.from), y = Math.max(p.to, u.to);
        u = f < u.from ? nt.range(f, y) : nt.range(y, f);
      }
      return a ? r.replaceRange(r.main.extend(u.from, u.to)) : o && i == 1 && r.ranges.length > 1 && (d = h6(r, l.pos)) ? d : o ? r.addRange(u) : nt.create([u]);
    }
  };
}
h(c6, "o1$1");
m(c6, "basicMouseSelection");
function h6(s, t) {
  for (let e = 0; e < s.ranges.length; e++) {
    let { from: i, to: r } = s.ranges[e];
    if (i <= t && r >= t)
      return nt.create(s.ranges.slice(0, e).concat(s.ranges.slice(e + 1)), s.mainIndex == e ? 0 : s.mainIndex - (s.mainIndex > e ? 1 : 0));
  }
  return null;
}
h(h6, "l1$1");
m(h6, "removeRangeAround");
Vr.dragstart = (s, t) => {
  let { selection: { main: e } } = s.state;
  if (t.target.draggable) {
    let r = s.docView.tile.nearest(t.target);
    if (r && r.isWidget()) {
      let n = r.posAtStart, a = n + r.length;
      (n >= e.to || a <= e.from) && (e = nt.range(n, a));
    }
  }
  let { inputState: i } = s;
  return i.mouseSelection && (i.mouseSelection.dragging = !0), i.draggedContent = e, t.dataTransfer && (t.dataTransfer.setData("Text", v1(s.state, gC, s.state.sliceDoc(e.from, e.to))), t.dataTransfer.effectAllowed = "copyMove"), !1;
};
Vr.dragend = (s) => (s.inputState.draggedContent = null, !1);
function t5(s, t, e, i) {
  if (e = v1(s.state, yC, e), !e)
    return;
  let r = s.posAtCoords({ x: t.clientX, y: t.clientY }, !1), { draggedContent: n } = s.inputState, a = i && n && s6(s, t) ? { from: n.from, to: n.to } : null, o = { from: r, insert: e }, l = s.state.changes(a ? [a, o] : o);
  s.focus(), s.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(r, -1), head: l.mapPos(r, 1) },
    userEvent: a ? "move.drop" : "input.drop"
  }), s.inputState.draggedContent = null;
}
h(t5, "Pu");
m(t5, "dropText");
Vr.drop = (s, t) => {
  if (!t.dataTransfer)
    return !1;
  if (s.state.readOnly)
    return !0;
  let e = t.dataTransfer.files;
  if (e && e.length) {
    let i = Array(e.length), r = 0, n = /* @__PURE__ */ m(() => {
      ++r == e.length && t5(s, t, i.filter((a) => a != null).join(s.state.lineBreak), !1);
    }, "finishFile");
    for (let a = 0; a < e.length; a++) {
      let o = new FileReader();
      o.onerror = n, o.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(o.result) || (i[a] = o.result), n();
      }, o.readAsText(e[a]);
    }
    return !0;
  } else {
    let i = t.dataTransfer.getData("Text");
    if (i)
      return t5(s, t, i, !0), !0;
  }
  return !1;
};
Vr.paste = (s, t) => {
  if (s.state.readOnly)
    return !0;
  s.observer.flush();
  let e = o6 ? null : t.clipboardData;
  return e ? (CC(s, e.getData("text/plain") || e.getData("text/uri-list")), !0) : (l6(s), !1);
};
function d6(s, t) {
  let e = s.dom.parentNode;
  if (!e)
    return;
  let i = e.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = t, i.focus(), i.selectionEnd = t.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), s.focus();
  }, 50);
}
h(d6, "a1$1");
m(d6, "captureCopy");
function u6(s) {
  let t = [], e = [], i = !1;
  for (let r of s.selection.ranges)
    r.empty || (t.push(s.sliceDoc(r.from, r.to)), e.push(r));
  if (!t.length) {
    let r = -1;
    for (let { from: n } of s.selection.ranges) {
      let a = s.doc.lineAt(n);
      a.number > r && (t.push(a.text), e.push({ from: a.from, to: Math.min(s.doc.length, a.to + 1) })), r = a.number;
    }
    i = !0;
  }
  return { text: v1(s, gC, t.join(s.lineBreak)), ranges: e, linewise: i };
}
h(u6, "h1$1");
m(u6, "copiedRange");
let e5 = null;
Vr.copy = Vr.cut = (s, t) => {
  let e = cl(s.root);
  if (e && !yh(s.contentDOM, e))
    return !1;
  let { text: i, ranges: r, linewise: n } = u6(s.state);
  if (!i && !n)
    return !1;
  e5 = n ? i : null, t.type == "cut" && !s.state.readOnly && s.dispatch({
    changes: r,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let a = o6 ? null : t.clipboardData;
  return a ? (a.clearData(), a.setData("text/plain", i), !0) : (d6(s, i), !1);
};
const p6 = /* @__PURE__ */ yn.define();
function QC(s, t) {
  let e = [];
  for (let i of s.facet(N7)) {
    let r = i(s, t);
    r && e.push(r);
  }
  return e.length ? s.update({ effects: e, annotations: p6.of(!0) }) : null;
}
h(QC, "tp$1");
m(QC, "focusChangeTransaction");
function TC(s) {
  setTimeout(() => {
    let t = s.hasFocus;
    if (t != s.inputState.notifiedFocused) {
      let e = QC(s.state, t);
      e ? s.dispatch(e) : s.update([]);
    }
  }, 10);
}
h(TC, "ip$1");
m(TC, "updateForFocusChange");
Or.focus = (s) => {
  s.inputState.lastFocusTime = Date.now(), !s.scrollDOM.scrollTop && (s.inputState.lastScrollTop || s.inputState.lastScrollLeft) && (s.scrollDOM.scrollTop = s.inputState.lastScrollTop, s.scrollDOM.scrollLeft = s.inputState.lastScrollLeft), TC(s);
};
Or.blur = (s) => {
  s.observer.clearSelectionRange(), TC(s);
};
Or.compositionstart = Or.compositionupdate = (s) => {
  s.observer.editContext || (s.inputState.compositionFirstChange == null && (s.inputState.compositionFirstChange = !0), s.inputState.composing < 0 && (s.inputState.composing = 0));
};
Or.compositionend = (s) => {
  s.observer.editContext || (s.inputState.composing = -1, s.inputState.compositionEndedAt = Date.now(), s.inputState.compositionPendingKey = !0, s.inputState.compositionPendingChange = s.observer.pendingRecords().length > 0, s.inputState.compositionFirstChange = null, at.chrome && at.android ? s.observer.flushSoon() : s.inputState.compositionPendingChange ? Promise.resolve().then(() => s.observer.flush()) : setTimeout(() => {
    s.inputState.composing < 0 && s.docView.hasComposition && s.update([]);
  }, 50));
};
Or.contextmenu = (s) => {
  s.inputState.lastContextMenu = Date.now();
};
Vr.beforeinput = (s, t) => {
  var e, i;
  if ((t.inputType == "insertText" || t.inputType == "insertCompositionText") && (s.inputState.insertingText = t.data, s.inputState.insertingTextAt = Date.now()), t.inputType == "insertReplacementText" && s.observer.editContext) {
    let n = (e = t.dataTransfer) === null || e === void 0 ? void 0 : e.getData("text/plain"), a = t.getTargetRanges();
    if (n && a.length) {
      let o = a[0], l = s.posAtDOM(o.startContainer, o.startOffset), d = s.posAtDOM(o.endContainer, o.endOffset);
      return H0(s, { from: l, to: d, insert: s.state.toText(n) }, null), !0;
    }
  }
  let r;
  if (at.chrome && at.android && (r = JT.find((n) => n.inputType == t.inputType)) && (s.observer.delayAndroidKey(r.key, r.keyCode), r.key == "Backspace" || r.key == "Delete")) {
    let n = ((i = window.visualViewport) === null || i === void 0 ? void 0 : i.height) || 0;
    setTimeout(() => {
      var a;
      (((a = window.visualViewport) === null || a === void 0 ? void 0 : a.height) || 0) > n + 10 && s.hasFocus && (s.contentDOM.blur(), s.focus());
    }, 100);
  }
  return at.ios && t.inputType == "deleteContentForward" && s.observer.flushSoon(), at.safari && t.inputType == "insertText" && s.inputState.composing >= 0 && setTimeout(() => Or.compositionend(s, t), 20), !1;
};
const nQ = /* @__PURE__ */ new Set();
function f6(s) {
  nQ.has(s) || (nQ.add(s), s.addEventListener("copy", () => {
  }), s.addEventListener("cut", () => {
  }));
}
h(f6, "f1$1");
m(f6, "firefoxCopyCutHack");
const aQ = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let cy = !1;
function i5() {
  cy = !1;
}
h(i5, "vu");
m(i5, "clearHeightChangeFlag");
var vd;
const m6 = (vd = class {
  constructor(t) {
    this.lineWrapping = t, this.doc = Ht.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(t, e) {
    let i = this.doc.lineAt(e).number - this.doc.lineAt(t).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((e - t - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(t) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t - this.lineLength) / Math.max(1, this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(t) {
    return this.doc = t, this;
  }
  mustRefreshForWrapping(t) {
    return aQ.indexOf(t) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(t) {
    let e = !1;
    for (let i = 0; i < t.length; i++) {
      let r = t[i];
      r < 0 ? i++ : this.heightSamples[Math.floor(r * 10)] || (e = !0, this.heightSamples[Math.floor(r * 10)] = !0);
    }
    return e;
  }
  refresh(t, e, i, r, n, a) {
    let o = aQ.indexOf(t) > -1, l = Math.abs(e - this.lineHeight) > 0.3 || this.lineWrapping != o || Math.abs(i - this.charWidth) > 0.1;
    if (this.lineWrapping = o, this.lineHeight = e, this.charWidth = i, this.textHeight = r, this.lineLength = n, l) {
      this.heightSamples = {};
      for (let d = 0; d < a.length; d++) {
        let u = a[d];
        u < 0 ? d++ : this.heightSamples[Math.floor(u * 10)] = !0;
      }
    }
    return l;
  }
}, h(vd, "Cf"), vd);
m(m6, "HeightOracle");
let vF = m6;
var Od;
const y6 = (Od = class {
  constructor(t, e) {
    this.from = t, this.heights = e, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}, h(Od, "Xf"), Od);
m(y6, "MeasuredHeights");
let OF = y6;
var Vo;
const g6 = (Vo = class {
  /**
  @internal
  */
  constructor(t, e, i, r, n) {
    this.from = t, this.length = e, this.top = i, this.height = r, this._content = n;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? vr.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof Tw ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(t) {
    let e = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(t._content) ? t._content : [t]);
    return new Vo(this.from, this.length + t.length, this.top, this.height + t.height, e);
  }
}, h(Vo, "eo"), Vo);
m(g6, "BlockInfo");
let Ds = g6;
var re = /* @__PURE__ */ (function(s) {
  return s[s.ByPos = 0] = "ByPos", s[s.ByHeight = 1] = "ByHeight", s[s.ByPosNoHeight = 2] = "ByPosNoHeight", s;
})(re || (re = {}));
const Mv = 1e-3;
var Us;
const w6 = (Us = class {
  constructor(t, e, i = 2) {
    this.length = t, this.height = e, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(t) {
    this.flags = (t ? 2 : 0) | this.flags & -3;
  }
  setHeight(t) {
    this.height != t && (Math.abs(this.height - t) > Mv && (cy = !0), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(t, e, i) {
    return Us.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(t, e) {
    e.push(this);
  }
  decomposeRight(t, e) {
    e.push(this);
  }
  applyChanges(t, e, i, r) {
    let n = this, a = i.doc;
    for (let o = r.length - 1; o >= 0; o--) {
      let { fromA: l, toA: d, fromB: u, toB: p } = r[o], f = n.lineAt(l, re.ByPosNoHeight, i.setDoc(e), 0, 0), y = f.to >= d ? f : n.lineAt(d, re.ByPosNoHeight, i, 0, 0);
      for (p += y.to - d, d = y.to; o > 0 && f.from <= r[o - 1].toA; )
        l = r[o - 1].fromA, u = r[o - 1].fromB, o--, l < f.from && (f = n.lineAt(l, re.ByPosNoHeight, i, 0, 0));
      u += f.from - l, l = f.from;
      let g = kF.build(i.setDoc(a), t, u, p);
      n = Ew(n, n.replace(l, d, g));
    }
    return n.updateHeight(i, 0);
  }
  static empty() {
    return new es(0, 0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(t) {
    if (t.length == 1)
      return t[0];
    let e = 0, i = t.length, r = 0, n = 0;
    for (; ; )
      if (e == i)
        if (r > n * 2) {
          let o = t[e - 1];
          o.break ? t.splice(--e, 1, o.left, null, o.right) : t.splice(--e, 1, o.left, o.right), i += 1 + o.break, r -= o.size;
        } else if (n > r * 2) {
          let o = t[i];
          o.break ? t.splice(i, 1, o.left, null, o.right) : t.splice(i, 1, o.left, o.right), i += 2 + o.break, n -= o.size;
        } else
          break;
      else if (r < n) {
        let o = t[e++];
        o && (r += o.size);
      } else {
        let o = t[--i];
        o && (n += o.size);
      }
    let a = 0;
    return t[e - 1] == null ? (a = 1, e--) : t[e] == null && (a = 1, i++), new $F(Us.of(t.slice(0, e)), a, Us.of(t.slice(i)));
  }
}, h(Us, "gi"), Us);
m(w6, "HeightMap");
let zr = w6;
function Ew(s, t) {
  return s == t ? s : (s.constructor != t.constructor && (cy = !0), t);
}
h(Ew, "hs$2");
m(Ew, "replace");
zr.prototype.size = 1;
const bF = /* @__PURE__ */ se.replace({});
var bd;
const v6 = (bd = class extends zr {
  constructor(t, e, i) {
    super(t, e), this.deco = i, this.spaceAbove = 0;
  }
  mainBlock(t, e) {
    return new Ds(e, this.length, t + this.spaceAbove, this.height - this.spaceAbove, this.deco || 0);
  }
  blockAt(t, e, i, r) {
    return this.spaceAbove && t < i + this.spaceAbove ? new Ds(r, 0, i, this.spaceAbove, bF) : this.mainBlock(i, r);
  }
  lineAt(t, e, i, r, n) {
    let a = this.mainBlock(r, n);
    return this.spaceAbove ? this.blockAt(0, i, r, n).join(a) : a;
  }
  forEachLine(t, e, i, r, n, a) {
    t <= n + this.length && e >= n && a(this.lineAt(0, re.ByPos, i, r, n));
  }
  setMeasuredHeight(t) {
    let e = t.heights[t.index++];
    e < 0 ? (this.spaceAbove = -e, e = t.heights[t.index++]) : this.spaceAbove = 0, this.setHeight(e);
  }
  updateHeight(t, e = 0, i = !1, r) {
    return r && r.from <= e && r.more && this.setMeasuredHeight(r), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}, h(bd, "Ef"), bd);
m(v6, "HeightMapBlock");
let O6 = v6;
var Kn;
const b6 = (Kn = class extends O6 {
  constructor(t, e, i) {
    super(t, e, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0, this.spaceAbove = i;
  }
  mainBlock(t, e) {
    return new Ds(e, this.length, t + this.spaceAbove, this.height - this.spaceAbove, this.breaks);
  }
  replace(t, e, i) {
    let r = i[0];
    return i.length == 1 && (r instanceof Kn || r instanceof bh && r.flags & 4) && Math.abs(this.length - r.length) < 10 ? (r instanceof bh ? r = new Kn(r.length, this.height, this.spaceAbove) : r.height = this.height, this.outdated || (r.outdated = !1), r) : zr.of(i);
  }
  updateHeight(t, e = 0, i = !1, r) {
    return r && r.from <= e && r.more ? this.setMeasuredHeight(r) : (i || this.outdated) && (this.spaceAbove = 0, this.setHeight(Math.max(this.widgetHeight, t.heightForLine(this.length - this.collapsed)) + this.breaks * t.lineHeight)), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}, h(Kn, "Cr"), Kn);
m(b6, "HeightMapText");
let es = b6;
var yi;
const $6 = (yi = class extends zr {
  constructor(t) {
    super(t, 0);
  }
  heightMetrics(t, e) {
    let i = t.doc.lineAt(e).number, r = t.doc.lineAt(e + this.length).number, n = r - i + 1, a, o = 0;
    if (t.lineWrapping) {
      let l = Math.min(this.height, t.lineHeight * n);
      a = l / n, this.length > n + 1 && (o = (this.height - l) / (this.length - n - 1));
    } else
      a = this.height / n;
    return { firstLine: i, lastLine: r, perLine: a, perChar: o };
  }
  blockAt(t, e, i, r) {
    let { firstLine: n, lastLine: a, perLine: o, perChar: l } = this.heightMetrics(e, r);
    if (e.lineWrapping) {
      let d = r + (t < e.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (t - i) / this.height)) * this.length)), u = e.doc.lineAt(d), p = o + u.length * l, f = Math.max(i, t - p / 2);
      return new Ds(u.from, u.length, f, p, 0);
    } else {
      let d = Math.max(0, Math.min(a - n, Math.floor((t - i) / o))), { from: u, length: p } = e.doc.line(n + d);
      return new Ds(u, p, i + o * d, o, 0);
    }
  }
  lineAt(t, e, i, r, n) {
    if (e == re.ByHeight)
      return this.blockAt(t, i, r, n);
    if (e == re.ByPosNoHeight) {
      let { from: y, to: g } = i.doc.lineAt(t);
      return new Ds(y, g - y, 0, 0, 0);
    }
    let { firstLine: a, perLine: o, perChar: l } = this.heightMetrics(i, n), d = i.doc.lineAt(t), u = o + d.length * l, p = d.number - a, f = r + o * p + l * (d.from - n - p);
    return new Ds(d.from, d.length, Math.max(r, Math.min(f, r + this.height - u)), u, 0);
  }
  forEachLine(t, e, i, r, n, a) {
    t = Math.max(t, n), e = Math.min(e, n + this.length);
    let { firstLine: o, perLine: l, perChar: d } = this.heightMetrics(i, n);
    for (let u = t, p = r; u <= e; ) {
      let f = i.doc.lineAt(u);
      if (u == t) {
        let g = f.number - o;
        p += l * g + d * (t - n - g);
      }
      let y = l + d * f.length;
      a(new Ds(f.from, f.length, p, y, 0)), p += y, u = f.to + 1;
    }
  }
  replace(t, e, i) {
    let r = this.length - e;
    if (r > 0) {
      let n = i[i.length - 1];
      n instanceof yi ? i[i.length - 1] = new yi(n.length + r) : i.push(null, new yi(r - 1));
    }
    if (t > 0) {
      let n = i[0];
      n instanceof yi ? i[0] = new yi(t + n.length) : i.unshift(new yi(t - 1), null);
    }
    return zr.of(i);
  }
  decomposeLeft(t, e) {
    e.push(new yi(t - 1), null);
  }
  decomposeRight(t, e) {
    e.push(null, new yi(this.length - t - 1));
  }
  updateHeight(t, e = 0, i = !1, r) {
    let n = e + this.length;
    if (r && r.from <= e + this.length && r.more) {
      let a = [], o = Math.max(e, r.from), l = -1;
      for (r.from > e && a.push(new yi(r.from - e - 1).updateHeight(t, e)); o <= n && r.more; ) {
        let u = t.doc.lineAt(o).length;
        a.length && a.push(null);
        let p = r.heights[r.index++], f = 0;
        p < 0 && (f = -p, p = r.heights[r.index++]), l == -1 ? l = p : Math.abs(p - l) >= Mv && (l = -2);
        let y = new es(u, p, f);
        y.outdated = !1, a.push(y), o += u + 1;
      }
      o <= n && a.push(null, new yi(n - o).updateHeight(t, o));
      let d = zr.of(a);
      return (l < 0 || Math.abs(d.height - this.height) >= Mv || Math.abs(l - this.heightMetrics(t, e).perLine) >= Mv) && (cy = !0), Ew(this, d);
    } else (i || this.outdated) && (this.setHeight(t.heightForGap(e, e + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}, h(yi, "ke"), yi);
m($6, "HeightMapGap");
let bh = $6;
var $d;
const x6 = ($d = class extends zr {
  constructor(t, e, i) {
    super(t.length + e + i.length, t.height + i.height, e | (t.outdated || i.outdated ? 2 : 0)), this.left = t, this.right = i, this.size = t.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(t, e, i, r) {
    let n = i + this.left.height;
    return t < n ? this.left.blockAt(t, e, i, r) : this.right.blockAt(t, e, n, r + this.left.length + this.break);
  }
  lineAt(t, e, i, r, n) {
    let a = r + this.left.height, o = n + this.left.length + this.break, l = e == re.ByHeight ? t < a : t < o, d = l ? this.left.lineAt(t, e, i, r, n) : this.right.lineAt(t, e, i, a, o);
    if (this.break || (l ? d.to < o : d.from > o))
      return d;
    let u = e == re.ByPosNoHeight ? re.ByPosNoHeight : re.ByPos;
    return l ? d.join(this.right.lineAt(o, u, i, a, o)) : this.left.lineAt(o, u, i, r, n).join(d);
  }
  forEachLine(t, e, i, r, n, a) {
    let o = r + this.left.height, l = n + this.left.length + this.break;
    if (this.break)
      t < l && this.left.forEachLine(t, e, i, r, n, a), e >= l && this.right.forEachLine(t, e, i, o, l, a);
    else {
      let d = this.lineAt(l, re.ByPos, i, r, n);
      t < d.from && this.left.forEachLine(t, d.from - 1, i, r, n, a), d.to >= t && d.from <= e && a(d), e > d.to && this.right.forEachLine(d.to + 1, e, i, o, l, a);
    }
  }
  replace(t, e, i) {
    let r = this.left.length + this.break;
    if (e < r)
      return this.balanced(this.left.replace(t, e, i), this.right);
    if (t > this.left.length)
      return this.balanced(this.left, this.right.replace(t - r, e - r, i));
    let n = [];
    t > 0 && this.decomposeLeft(t, n);
    let a = n.length;
    for (let o of i)
      n.push(o);
    if (t > 0 && r5(n, a - 1), e < this.length) {
      let o = n.length;
      this.decomposeRight(e, n), r5(n, o);
    }
    return zr.of(n);
  }
  decomposeLeft(t, e) {
    let i = this.left.length;
    if (t <= i)
      return this.left.decomposeLeft(t, e);
    e.push(this.left), this.break && (i++, t >= i && e.push(null)), t > i && this.right.decomposeLeft(t - i, e);
  }
  decomposeRight(t, e) {
    let i = this.left.length, r = i + this.break;
    if (t >= r)
      return this.right.decomposeRight(t - r, e);
    t < i && this.left.decomposeRight(t, e), this.break && t < r && e.push(null), e.push(this.right);
  }
  balanced(t, e) {
    return t.size > 2 * e.size || e.size > 2 * t.size ? zr.of(this.break ? [t, null, e] : [t, e]) : (this.left = Ew(this.left, t), this.right = Ew(this.right, e), this.setHeight(t.height + e.height), this.outdated = t.outdated || e.outdated, this.size = t.size + e.size, this.length = t.length + this.break + e.length, this);
  }
  updateHeight(t, e = 0, i = !1, r) {
    let { left: n, right: a } = this, o = e + n.length + this.break, l = null;
    return r && r.from <= e + n.length && r.more ? l = n = n.updateHeight(t, e, i, r) : n.updateHeight(t, e, i), r && r.from <= o + a.length && r.more ? l = a = a.updateHeight(t, o, i, r) : a.updateHeight(t, o, i), l ? this.balanced(n, a) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}, h($d, "Yf"), $d);
m(x6, "HeightMapBranch");
let $F = x6;
function r5(s, t) {
  let e, i;
  s[t] == null && (e = s[t - 1]) instanceof bh && (i = s[t + 1]) instanceof bh && s.splice(t - 1, 3, new bh(e.length + 1 + i.length));
}
h(r5, "Tu");
m(r5, "mergeGaps");
const xF = 5;
var Wo;
const k6 = (Wo = class {
  constructor(t, e) {
    this.pos = t, this.oracle = e, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(t, e) {
    if (this.lineStart > -1) {
      let i = Math.min(e, this.lineEnd), r = this.nodes[this.nodes.length - 1];
      r instanceof es ? r.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new es(i - this.pos, -1, 0)), this.writtenTo = i, e > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = e;
  }
  point(t, e, i) {
    if (t < e || i.heightRelevant) {
      let r = i.widget ? i.widget.estimatedHeight : 0, n = i.widget ? i.widget.lineBreaks : 0;
      r < 0 && (r = this.oracle.lineHeight);
      let a = e - t;
      i.block ? this.addBlock(new O6(a, r, i)) : (a || n || r >= xF) && this.addLineDeco(r, n, a);
    } else e > t && this.span(t, e);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: t, to: e } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = t, this.lineEnd = e, this.writtenTo < t && ((this.writtenTo < t - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, t - 1)), this.nodes.push(null)), this.pos > t && this.nodes.push(new es(this.pos - t, -1, 0)), this.writtenTo = this.pos;
  }
  blankContent(t, e) {
    let i = new bh(e - t);
    return this.oracle.doc.lineAt(t).to == e && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let t = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (t instanceof es)
      return t;
    let e = new es(0, -1, 0);
    return this.nodes.push(e), e;
  }
  addBlock(t) {
    this.enterLine();
    let e = t.deco;
    e && e.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(t), this.writtenTo = this.pos = this.pos + t.length, e && e.endSide > 0 && (this.covering = t);
  }
  addLineDeco(t, e, i) {
    let r = this.ensureLine();
    r.length += i, r.collapsed += i, r.widgetHeight = Math.max(r.widgetHeight, t), r.breaks += e, this.writtenTo = this.pos = this.pos + i;
  }
  finish(t) {
    let e = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(e instanceof es) && !this.isCovered ? this.nodes.push(new es(0, -1, 0)) : (this.writtenTo < this.pos || e == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = t;
    for (let r of this.nodes)
      r instanceof es && r.updateHeight(this.oracle, i), i += r ? r.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(t, e, i, r) {
    let n = new Wo(i, t);
    return ze.spans(e, i, r, n, 0), n.finish(i);
  }
}, h(Wo, "to"), Wo);
m(k6, "NodeBuilder");
let kF = k6;
function S6(s, t, e) {
  let i = new SF();
  return ze.compare(s, t, e, i, 0), i.changes;
}
h(S6, "O1$1");
m(S6, "heightRelevantDecoChanges");
var xd;
const C6 = (xd = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(t, e, i, r) {
    (t < e || i && i.heightRelevant || r && r.heightRelevant) && mo(t, e, this.changes, 5);
  }
}, h(xd, "Wf"), xd);
m(C6, "DecorationComparator");
let SF = C6;
function P6(s, t) {
  let e = s.getBoundingClientRect(), i = s.ownerDocument, r = i.defaultView || window, n = Math.max(0, e.left), a = Math.min(r.innerWidth, e.right), o = Math.max(0, e.top), l = Math.min(r.innerHeight, e.bottom);
  for (let d = s.parentNode; d && d != i.body; )
    if (d.nodeType == 1) {
      let u = d, p = window.getComputedStyle(u);
      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && p.overflow != "visible") {
        let f = u.getBoundingClientRect();
        n = Math.max(n, f.left), a = Math.min(a, f.right), o = Math.max(o, f.top), l = Math.min(d == s.parentNode ? r.innerHeight : l, f.bottom);
      }
      d = p.position == "absolute" || p.position == "fixed" ? u.offsetParent : u.parentNode;
    } else if (d.nodeType == 11)
      d = d.host;
    else
      break;
  return {
    left: n - e.left,
    right: Math.max(n, a) - e.left,
    top: o - (e.top + t),
    bottom: Math.max(o, l) - (e.top + t)
  };
}
h(P6, "d1$1");
m(P6, "visiblePixelRange");
function Q6(s) {
  let t = s.getBoundingClientRect(), e = s.ownerDocument.defaultView || window;
  return t.left < e.innerWidth && t.right > 0 && t.top < e.innerHeight && t.bottom > 0;
}
h(Q6, "p1$1");
m(Q6, "inWindow");
function T6(s, t) {
  let e = s.getBoundingClientRect();
  return {
    left: 0,
    right: e.right - e.left,
    top: t,
    bottom: e.bottom - (e.top + t)
  };
}
h(T6, "m1");
m(T6, "fullPixelRange");
var kd;
const M6 = (kd = class {
  constructor(t, e, i, r) {
    this.from = t, this.to = e, this.size = i, this.displaySize = r;
  }
  static same(t, e) {
    if (t.length != e.length)
      return !1;
    for (let i = 0; i < t.length; i++) {
      let r = t[i], n = e[i];
      if (r.from != n.from || r.to != n.to || r.size != n.size)
        return !1;
    }
    return !0;
  }
  draw(t, e) {
    return se.replace({
      widget: new CF(this.displaySize * (e ? t.scaleY : t.scaleX), e)
    }).range(this.from, this.to);
  }
}, h(kd, "Vf"), kd);
m(M6, "LineGap");
let v2 = M6;
var Sd;
const A6 = (Sd = class extends zl {
  constructor(t, e) {
    super(), this.size = t, this.vertical = e;
  }
  eq(t) {
    return t.size == this.size && t.vertical == this.vertical;
  }
  toDOM() {
    let t = document.createElement("div");
    return this.vertical ? t.style.height = this.size + "px" : (t.style.width = this.size + "px", t.style.height = "2px", t.style.display = "inline-block"), t;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}, h(Sd, "Uf"), Sd);
m(A6, "LineGapWidget");
let CF = A6;
var Cd;
const R6 = (Cd = class {
  constructor(t) {
    this.state = t, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = lQ, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = me.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let e = t.facet(wC).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new vF(e), this.stateDeco = s5(t), this.heightMap = zr.empty().applyChanges(this.stateDeco, Ht.empty, this.heightOracle.setDoc(t.doc), [new Zs(0, 0, 0, t.doc.length)]);
    for (let i = 0; i < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); i++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = se.set(this.lineGaps.map((i) => i.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let t = [this.viewport], { main: e } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let r = i ? e.head : e.anchor;
      if (!t.some(({ from: n, to: a }) => r >= n && r <= a)) {
        let { from: n, to: a } = this.lineBlockAt(r);
        t.push(new iv(n, a));
      }
    }
    return this.viewports = t.sort((i, r) => i.from - r.from), this.updateScaler();
  }
  updateScaler() {
    let t = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? lQ : new PF(this.heightOracle, this.heightMap, this.viewports), t.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (t) => {
      this.viewportLines.push(uh(t, this.scaler));
    });
  }
  update(t, e = null) {
    this.state = t.state;
    let i = this.stateDeco;
    this.stateDeco = s5(this.state);
    let r = t.changedRanges, n = Zs.extendWithRanges(r, S6(i, this.stateDeco, t ? t.changes : Dr.empty(this.state.doc.length))), a = this.heightMap.height, o = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    i5(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, t.startState.doc, this.heightOracle.setDoc(this.state.doc), n), (this.heightMap.height != a || cy) && (t.flags |= 2), o ? (this.scrollAnchorPos = t.changes.mapPos(o.from, -1), this.scrollAnchorHeight = o.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = a);
    let l = n.length ? this.mapViewport(this.viewport, t.changes) : this.viewport;
    (e && (e.range.head < l.from || e.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, e));
    let d = l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, t.flags |= this.updateForViewport(), (d || !t.changes.empty || t.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t.changes))), t.flags |= this.computeVisibleRanges(t.changes), e && (this.scrollTarget = e), !this.mustEnforceCursorAssoc && (t.selectionSet || t.focusChanged) && t.view.lineWrapping && t.state.selection.main.empty && t.state.selection.main.assoc && !t.state.facet(iF) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(t) {
    let e = t.contentDOM, i = window.getComputedStyle(e), r = this.heightOracle, n = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? me.RTL : me.LTR;
    let a = this.heightOracle.mustRefreshForWrapping(n) || this.mustMeasureContent, o = e.getBoundingClientRect(), l = a || this.mustMeasureContent || this.contentDOMHeight != o.height;
    this.contentDOMHeight = o.height, this.mustMeasureContent = !1;
    let d = 0, u = 0;
    if (o.width && o.height) {
      let { scaleX: D, scaleY: A } = aC(e, o);
      (D > 5e-3 && Math.abs(this.scaleX - D) > 5e-3 || A > 5e-3 && Math.abs(this.scaleY - A) > 5e-3) && (this.scaleX = D, this.scaleY = A, d |= 16, a = l = !0);
    }
    let p = (parseInt(i.paddingTop) || 0) * this.scaleY, f = (parseInt(i.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != p || this.paddingBottom != f) && (this.paddingTop = p, this.paddingBottom = f, d |= 18), this.editorWidth != t.scrollDOM.clientWidth && (r.lineWrapping && (l = !0), this.editorWidth = t.scrollDOM.clientWidth, d |= 16);
    let y = t.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != y && (this.scrollAnchorHeight = -1, this.scrollTop = y), this.scrolledToBottom = lC(t.scrollDOM);
    let g = (this.printing ? T6 : P6)(e, this.paddingTop), O = g.top - this.pixelViewport.top, k = g.bottom - this.pixelViewport.bottom;
    this.pixelViewport = g;
    let $ = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if ($ != this.inView && (this.inView = $, $ && (l = !0)), !this.inView && !this.scrollTarget && !Q6(t.dom))
      return 0;
    let T = o.width;
    if ((this.contentDOMWidth != T || this.editorHeight != t.scrollDOM.clientHeight) && (this.contentDOMWidth = o.width, this.editorHeight = t.scrollDOM.clientHeight, d |= 16), l) {
      let D = t.docView.measureVisibleLineHeights(this.viewport);
      if (r.mustRefreshForHeights(D) && (a = !0), a || r.lineWrapping && Math.abs(T - this.contentDOMWidth) > r.charWidth) {
        let { lineHeight: A, charWidth: z, textHeight: V } = t.docView.measureTextSize();
        a = A > 0 && r.refresh(n, A, z, V, Math.max(5, T / z), D), a && (t.docView.minWidth = 0, d |= 16);
      }
      O > 0 && k > 0 ? u = Math.max(O, k) : O < 0 && k < 0 && (u = Math.min(O, k)), i5();
      for (let A of this.viewports) {
        let z = A.from == this.viewport.from ? D : t.docView.measureVisibleLineHeights(A);
        this.heightMap = (a ? zr.empty().applyChanges(this.stateDeco, Ht.empty, this.heightOracle, [new Zs(0, 0, 0, t.state.doc.length)]) : this.heightMap).updateHeight(r, 0, a, new OF(A.from, z));
      }
      cy && (d |= 2);
    }
    let _ = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return _ && (d & 2 && (d |= this.updateScaler()), this.viewport = this.getViewport(u, this.scrollTarget), d |= this.updateForViewport()), (d & 2 || _) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(a ? [] : this.lineGaps, t)), d |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, t.docView.enforceCursorAssoc()), d;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(t, e) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, t / 1e3 / 2)), r = this.heightMap, n = this.heightOracle, { visibleTop: a, visibleBottom: o } = this, l = new iv(r.lineAt(a - i * 1e3, re.ByHeight, n, 0, 0).from, r.lineAt(o + (1 - i) * 1e3, re.ByHeight, n, 0, 0).to);
    if (e) {
      let { head: d } = e.range;
      if (d < l.from || d > l.to) {
        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), p = r.lineAt(d, re.ByPos, n, 0, 0), f;
        e.y == "center" ? f = (p.top + p.bottom) / 2 - u / 2 : e.y == "start" || e.y == "nearest" && d < l.from ? f = p.top : f = p.bottom - u, l = new iv(r.lineAt(f - 1e3 / 2, re.ByHeight, n, 0, 0).from, r.lineAt(f + u + 1e3 / 2, re.ByHeight, n, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(t, e) {
    let i = e.mapPos(t.from, -1), r = e.mapPos(t.to, 1);
    return new iv(this.heightMap.lineAt(i, re.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(r, re.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: t, to: e }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: r } = this.heightMap.lineAt(t, re.ByPos, this.heightOracle, 0, 0), { bottom: n } = this.heightMap.lineAt(e, re.ByPos, this.heightOracle, 0, 0), { visibleTop: a, visibleBottom: o } = this;
    return (t == 0 || r <= a - Math.max(10, Math.min(
      -i,
      250
      /* VP.MaxCoverMargin */
    ))) && (e == this.state.doc.length || n >= o + Math.max(10, Math.min(
      i,
      250
      /* VP.MaxCoverMargin */
    ))) && r > a - 2 * 1e3 && n < o + 2 * 1e3;
  }
  mapLineGaps(t, e) {
    if (!t.length || e.empty)
      return t;
    let i = [];
    for (let r of t)
      e.touchesRange(r.from, r.to) || i.push(new v2(e.mapPos(r.from), e.mapPos(r.to), r.size, r.displaySize));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(t, e) {
    let i = this.heightOracle.lineWrapping, r = i ? 1e4 : 2e3, n = r >> 1, a = r << 1;
    if (this.defaultTextDirection != me.LTR && !i)
      return [];
    let o = [], l = /* @__PURE__ */ m((u, p, f, y) => {
      if (p - u < n)
        return;
      let g = this.state.selection.main, O = [g.from];
      g.empty || O.push(g.to);
      for (let $ of O)
        if ($ > u && $ < p) {
          l(u, $ - 10, f, y), l($ + 10, p, f, y);
          return;
        }
      let k = L6(t, ($) => $.from >= f.from && $.to <= f.to && Math.abs($.from - u) < n && Math.abs($.to - p) < n && !O.some((T) => $.from < T && $.to > T));
      if (!k) {
        if (p < f.to && e && i && e.visibleRanges.some((_) => _.from <= p && _.to >= p)) {
          let _ = e.moveToLineBoundary(nt.cursor(p), !1, !0).head;
          _ > u && (p = _);
        }
        let $ = this.gapSize(f, u, p, y), T = i || $ < 2e6 ? $ : 2e6;
        k = new v2(u, p, $, T);
      }
      o.push(k);
    }, "addGap"), d = /* @__PURE__ */ m((u) => {
      if (u.length < a || u.type != vr.Text)
        return;
      let p = _6(u.from, u.to, this.stateDeco);
      if (p.total < a)
        return;
      let f = this.scrollTarget ? this.scrollTarget.range.head : null, y, g;
      if (i) {
        let O = r / this.heightOracle.lineLength * this.heightOracle.lineHeight, k, $;
        if (f != null) {
          let T = Eg(p, f), _ = ((this.visibleBottom - this.visibleTop) / 2 + O) / u.height;
          k = T - _, $ = T + _;
        } else
          k = (this.visibleTop - u.top - O) / u.height, $ = (this.visibleBottom - u.top + O) / u.height;
        y = Rg(p, k), g = Rg(p, $);
      } else {
        let O = p.total * this.heightOracle.charWidth, k = r * this.heightOracle.charWidth, $ = 0;
        if (O > 2e6)
          for (let z of t)
            z.from >= u.from && z.from < u.to && z.size != z.displaySize && z.from * this.heightOracle.charWidth + $ < this.pixelViewport.left && ($ = z.size - z.displaySize);
        let T = this.pixelViewport.left + $, _ = this.pixelViewport.right + $, D, A;
        if (f != null) {
          let z = Eg(p, f), V = ((_ - T) / 2 + k) / O;
          D = z - V, A = z + V;
        } else
          D = (T - k) / O, A = (_ + k) / O;
        y = Rg(p, D), g = Rg(p, A);
      }
      y > u.from && l(u.from, y, u, p), g < u.to && l(g, u.to, u, p);
    }, "checkLine");
    for (let u of this.viewportLines)
      Array.isArray(u.type) ? u.type.forEach(d) : d(u);
    return o;
  }
  gapSize(t, e, i, r) {
    let n = Eg(r, i) - Eg(r, e);
    return this.heightOracle.lineWrapping ? t.height * n : r.total * this.heightOracle.charWidth * n;
  }
  updateLineGaps(t) {
    v2.same(t, this.lineGaps) || (this.lineGaps = t, this.lineGapDeco = se.set(t.map((e) => e.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(t) {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let i = [];
    ze.spans(e, this.viewport.from, this.viewport.to, {
      span(n, a) {
        i.push({ from: n, to: a });
      },
      point() {
      }
    }, 20);
    let r = 0;
    if (i.length != this.visibleRanges.length)
      r = 12;
    else
      for (let n = 0; n < i.length && !(r & 8); n++) {
        let a = this.visibleRanges[n], o = i[n];
        (a.from != o.from || a.to != o.to) && (r |= 4, t && t.mapPos(a.from, -1) == o.from && t.mapPos(a.to, 1) == o.to || (r |= 8));
      }
    return this.visibleRanges = i, r;
  }
  lineBlockAt(t) {
    return t >= this.viewport.from && t <= this.viewport.to && this.viewportLines.find((e) => e.from <= t && e.to >= t) || uh(this.heightMap.lineAt(t, re.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(t) {
    return t >= this.viewportLines[0].top && t <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((e) => e.top <= t && e.bottom >= t) || uh(this.heightMap.lineAt(this.scaler.fromDOM(t), re.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(t) {
    let e = this.lineBlockAtHeight(t + 8);
    return e.from >= this.viewport.from || this.viewportLines[0].top - t > 200 ? e : this.viewportLines[0];
  }
  elementAtHeight(t) {
    return uh(this.heightMap.blockAt(this.scaler.fromDOM(t), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}, h(Cd, "If"), Cd);
m(R6, "ViewState");
let oQ = R6;
var Pd;
const E6 = (Pd = class {
  constructor(t, e) {
    this.from = t, this.to = e;
  }
}, h(Pd, "zf"), Pd);
m(E6, "Viewport");
let iv = E6;
function _6(s, t, e) {
  let i = [], r = s, n = 0;
  return ze.spans(e, s, t, {
    span() {
    },
    point(a, o) {
      a > r && (i.push({ from: r, to: a }), n += a - r), r = o;
    }
  }, 20), r < t && (i.push({ from: r, to: t }), n += t - r), { total: n, ranges: i };
}
h(_6, "g1");
m(_6, "lineStructure");
function Rg({ total: s, ranges: t }, e) {
  if (e <= 0)
    return t[0].from;
  if (e >= 1)
    return t[t.length - 1].to;
  let i = Math.floor(s * e);
  for (let r = 0; ; r++) {
    let { from: n, to: a } = t[r], o = a - n;
    if (i <= o)
      return n + i;
    i -= o;
  }
}
h(Rg, "Ln$1");
m(Rg, "findPosition");
function Eg(s, t) {
  let e = 0;
  for (let { from: i, to: r } of s.ranges) {
    if (t <= r) {
      e += t - i;
      break;
    }
    e += r - i;
  }
  return e / s.total;
}
h(Eg, "_n$1");
m(Eg, "findFraction");
function L6(s, t) {
  for (let e of s)
    if (t(e))
      return e;
}
h(L6, "Q1$1");
m(L6, "find");
const lQ = {
  toDOM(s) {
    return s;
  },
  fromDOM(s) {
    return s;
  },
  scale: 1,
  eq(s) {
    return s == this;
  }
};
function s5(s) {
  let t = s.facet(N0).filter((i) => typeof i != "function"), e = s.facet(vC).filter((i) => typeof i != "function");
  return e.length && t.push(ze.join(e)), t;
}
h(s5, "Lu");
m(s5, "staticDeco");
var Fo;
const z6 = (Fo = class {
  constructor(t, e, i) {
    let r = 0, n = 0, a = 0;
    this.viewports = i.map(({ from: o, to: l }) => {
      let d = e.lineAt(o, re.ByPos, t, 0, 0).top, u = e.lineAt(l, re.ByPos, t, 0, 0).bottom;
      return r += u - d, { from: o, to: l, top: d, bottom: u, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - r) / (e.height - r);
    for (let o of this.viewports)
      o.domTop = a + (o.top - n) * this.scale, a = o.domBottom = o.domTop + (o.bottom - o.top), n = o.bottom;
  }
  toDOM(t) {
    for (let e = 0, i = 0, r = 0; ; e++) {
      let n = e < this.viewports.length ? this.viewports[e] : null;
      if (!n || t < n.top)
        return r + (t - i) * this.scale;
      if (t <= n.bottom)
        return n.domTop + (t - n.top);
      i = n.bottom, r = n.domBottom;
    }
  }
  fromDOM(t) {
    for (let e = 0, i = 0, r = 0; ; e++) {
      let n = e < this.viewports.length ? this.viewports[e] : null;
      if (!n || t < n.domTop)
        return i + (t - r) / this.scale;
      if (t <= n.domBottom)
        return n.top + (t - n.domTop);
      i = n.bottom, r = n.domBottom;
    }
  }
  eq(t) {
    return t instanceof Fo ? this.scale == t.scale && this.viewports.length == t.viewports.length && this.viewports.every((e, i) => e.from == t.viewports[i].from && e.to == t.viewports[i].to) : !1;
  }
}, h(Fo, "io"), Fo);
m(z6, "BigScaler");
let PF = z6;
function uh(s, t) {
  if (t.scale == 1)
    return s;
  let e = t.toDOM(s.top), i = t.toDOM(s.bottom);
  return new Ds(s.from, s.length, e, i - e, Array.isArray(s._content) ? s._content.map((r) => uh(r, t)) : s._content);
}
h(uh, "Or$1");
m(uh, "scaleBlock");
const rv = /* @__PURE__ */ Ct.define({ combine: /* @__PURE__ */ m((s) => s.join(" "), "combine") }), n5 = /* @__PURE__ */ Ct.define({ combine: /* @__PURE__ */ m((s) => s.indexOf(!0) > -1, "combine") }), a5 = /* @__PURE__ */ pa.newName(), I6 = /* @__PURE__ */ pa.newName(), D6 = /* @__PURE__ */ pa.newName(), V6 = { "&light": "." + I6, "&dark": "." + D6 };
function _O(s, t, e) {
  return new pa(t, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (r) => {
        if (r == "&")
          return s;
        if (!e || !e[r])
          throw new RangeError(`Unsupported selector: ${r}`);
        return e[r];
      }) : s + " " + i;
    }
  });
}
h(_O, "ta$1");
m(_O, "buildTheme");
const QF = /* @__PURE__ */ _O("." + a5, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    zIndex: 200
  },
  ".cm-gutters-before": { insetInlineStart: 0 },
  ".cm-gutters-after": { insetInlineEnd: 0 },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    border: "0px solid #ddd",
    "&.cm-gutters-before": { borderRightWidth: "1px" },
    "&.cm-gutters-after": { borderLeftWidth: "1px" }
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, V6), TF = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, O2 = at.ie && at.ie_version <= 11;
var Qd;
const W6 = (Qd = class {
  constructor(t) {
    this.view = t, this.active = !1, this.editContext = null, this.selectionRange = new KW(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = t.contentDOM, this.observer = new MutationObserver((e) => {
      for (let i of e)
        this.queue.push(i);
      (at.ie && at.ie_version <= 11 || at.ios && t.composing) && e.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && at.android && t.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(at.chrome && at.chrome_version < 126) && (this.editContext = new AF(t), t.state.facet(Is) && (t.contentDOM.editContext = this.editContext.editContext)), O2 && (this.onCharData = (e) => {
      this.queue.push({
        target: e.target,
        type: "characterData",
        oldValue: e.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var e;
      ((e = this.view.docView) === null || e === void 0 ? void 0 : e.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(t.scrollDOM)), this.addWindowListeners(this.win = t.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((e) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), e.length > 0 && e[e.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((e) => {
      e.length > 0 && e[e.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(t) {
    this.view.inputState.runHandlers("scroll", t), this.intersecting && this.view.measure();
  }
  onScroll(t) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(t);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(t) {
    (t.type == "change" || !t.type) && !t.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(t) {
    if (this.gapIntersection && (t.length != this.gaps.length || this.gaps.some((e, i) => e != t[i]))) {
      this.gapIntersection.disconnect();
      for (let e of t)
        this.gapIntersection.observe(e);
      this.gaps = t;
    }
  }
  onSelectionChange(t) {
    let e = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, r = this.selectionRange;
    if (i.state.facet(Is) ? i.root.activeElement != this.dom : !yh(this.dom, r))
      return;
    let n = r.anchorNode && i.docView.tile.nearest(r.anchorNode);
    if (n && n.isWidget() && n.widget.ignoreEvent(t)) {
      e || (this.selectionChanged = !1);
      return;
    }
    (at.ie && at.ie_version <= 11 || at.android && at.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    r.focusNode && wh(r.focusNode, r.focusOffset, r.anchorNode, r.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: t } = this, e = cl(t.root);
    if (!e)
      return !1;
    let i = at.safari && t.root.nodeType == 11 && t.root.activeElement == this.dom && F6(this.view, e) || e;
    if (!i || this.selectionRange.eq(i))
      return !1;
    let r = yh(this.dom, i);
    return r && !this.selectionChanged && t.inputState.lastFocusTime > Date.now() - 200 && t.inputState.lastTouchTime < Date.now() - 300 && M7(this.dom, i) ? (this.view.inputState.lastFocusTime = 0, t.docView.updateSelection(), !1) : (this.selectionRange.setRange(i), r && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(t, e) {
    this.selectionRange.set(t.node, t.offset, e.node, e.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let t = 0, e = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !e && t < this.scrollTargets.length && this.scrollTargets[t] == i ? t++ : e || (e = this.scrollTargets.slice(0, t)), e && e.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (t < this.scrollTargets.length && !e && (e = this.scrollTargets.slice(0, t)), e) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = e)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(t) {
    if (!this.active)
      return t();
    try {
      return this.stop(), t();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, TF), O2 && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), O2 && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(t, e) {
    var i;
    if (!this.delayedAndroidKey) {
      let r = /* @__PURE__ */ m(() => {
        let n = this.delayedAndroidKey;
        n && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = n.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && n.force && yo(this.dom, n.key, n.keyCode));
      }, "flush");
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(r);
    }
    (!this.delayedAndroidKey || t == "Enter") && (this.delayedAndroidKey = {
      key: t,
      keyCode: e,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let t of this.observer.takeRecords())
      this.queue.push(t);
    return this.queue;
  }
  processRecords() {
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let e = -1, i = -1, r = !1;
    for (let n of t) {
      let a = this.readMutation(n);
      a && (a.typeOver && (r = !0), e == -1 ? { from: e, to: i } = a : (e = Math.min(a.from, e), i = Math.max(a.to, i)));
    }
    return { from: e, to: i, typeOver: r };
  }
  readChange() {
    let { from: t, to: e, typeOver: i } = this.processRecords(), r = this.selectionChanged && yh(this.dom, this.selectionRange);
    if (t < 0 && !r)
      return null;
    t > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let n = new fF(this.view, t, e, i);
    return this.view.docView.domChanged = { newSel: n.newSel ? n.newSel.main : null }, n;
  }
  // Apply pending changes, if any
  flush(t = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    t && this.readSelectionRange();
    let e = this.readChange();
    if (!e)
      return this.view.requestMeasure(), !1;
    let i = this.view.state, r = kC(this.view, e);
    return this.view.state == i && (e.domChanged || e.newSel && !Rw(this.view.state.selection, e.newSel.main)) && this.view.update([]), r;
  }
  readMutation(t) {
    let e = this.view.docView.tile.nearest(t.target);
    if (!e || e.isWidget())
      return null;
    if (e.markDirty(t.type == "attributes"), t.type == "childList") {
      let i = o5(e, t.previousSibling || t.target.previousSibling, -1), r = o5(e, t.nextSibling || t.target.nextSibling, 1);
      return {
        from: i ? e.posAfter(i) : e.posAtStart,
        to: r ? e.posBefore(r) : e.posAtEnd,
        typeOver: !1
      };
    } else return t.type == "characterData" ? { from: e.posAtStart, to: e.posAtEnd, typeOver: t.target.nodeValue == t.oldValue } : null;
  }
  setWindow(t) {
    t != this.win && (this.removeWindowListeners(this.win), this.win = t, this.addWindowListeners(this.win));
  }
  addWindowListeners(t) {
    t.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : t.addEventListener("beforeprint", this.onPrint), t.addEventListener("scroll", this.onScroll), t.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(t) {
    t.removeEventListener("scroll", this.onScroll), t.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : t.removeEventListener("beforeprint", this.onPrint), t.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(t) {
    this.editContext && (this.editContext.update(t), t.startState.facet(Is) != t.state.facet(Is) && (t.view.contentDOM.editContext = t.state.facet(Is) ? this.editContext.editContext : null));
  }
  destroy() {
    var t, e, i;
    this.stop(), (t = this.intersection) === null || t === void 0 || t.disconnect(), (e = this.gapIntersection) === null || e === void 0 || e.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect();
    for (let r of this.scrollTargets)
      r.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}, h(Qd, "jf"), Qd);
m(W6, "DOMObserver");
let MF = W6;
function o5(s, t, e) {
  for (; t; ) {
    let i = Le.get(t);
    if (i && i.parent == s)
      return i;
    let r = t.parentNode;
    t = r != s.dom ? r : e > 0 ? t.nextSibling : t.previousSibling;
  }
  return null;
}
h(o5, "_u");
m(o5, "findChild");
function l5(s, t) {
  let e = t.startContainer, i = t.startOffset, r = t.endContainer, n = t.endOffset, a = s.docView.domAtPos(s.state.selection.main.anchor, 1);
  return wh(a.node, a.offset, r, n) && ([e, i, r, n] = [r, n, e, i]), { anchorNode: e, anchorOffset: i, focusNode: r, focusOffset: n };
}
h(l5, "Mu");
m(l5, "buildSelectionRangeFromRange");
function F6(s, t) {
  if (t.getComposedRanges) {
    let r = t.getComposedRanges(s.root)[0];
    if (r)
      return l5(s, r);
  }
  let e = null;
  function i(r) {
    r.preventDefault(), r.stopImmediatePropagation(), e = r.getTargetRanges()[0];
  }
  return h(i, "i"), m(i, "read"), s.contentDOM.addEventListener("beforeinput", i, !0), s.dom.ownerDocument.execCommand("indent"), s.contentDOM.removeEventListener("beforeinput", i, !0), e ? l5(s, e) : null;
}
h(F6, "b1");
m(F6, "safariSelectionRangeHack");
var Td;
const q6 = (Td = class {
  constructor(t) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(t.state);
    let e = this.editContext = new window.EditContext({
      text: t.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, t.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(t.state.selection.main.head)
    });
    this.handlers.textupdate = (i) => {
      let r = t.state.selection.main, { anchor: n, head: a } = r, o = this.toEditorPos(i.updateRangeStart), l = this.toEditorPos(i.updateRangeEnd);
      t.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: i.updateRangeStart, editorBase: o, drifted: !1 });
      let d = l - o > i.text.length;
      o == this.from && n < this.from ? o = n : l == this.to && n > this.to && (l = n);
      let u = SC(t.state.sliceDoc(o, l), i.text, (d ? r.from : r.to) - o, d ? "end" : null);
      if (!u) {
        let f = nt.single(this.toEditorPos(i.selectionStart), this.toEditorPos(i.selectionEnd));
        Rw(f, r) || t.dispatch({ selection: f, userEvent: "select" });
        return;
      }
      let p = {
        from: u.from + o,
        to: u.toA + o,
        insert: Ht.of(i.text.slice(u.from, u.toB).split(`
`))
      };
      if ((at.mac || at.android) && p.from == a - 1 && /^\. ?$/.test(i.text) && t.contentDOM.getAttribute("autocorrect") == "off" && (p = { from: o, to: l, insert: Ht.of([i.text.replace(".", " ")]) }), this.pendingContextChange = p, !t.state.readOnly) {
        let f = this.to - this.from + (p.to - p.from + p.insert.length);
        H0(t, p, nt.single(this.toEditorPos(i.selectionStart, f), this.toEditorPos(i.selectionEnd, f)));
      }
      this.pendingContextChange && (this.revertPending(t.state), this.setSelection(t.state)), p.from < p.to && !p.insert.length && t.inputState.composing >= 0 && !/[\\p{Alphabetic}\\p{Number}_]/.test(e.text.slice(Math.max(0, i.updateRangeStart - 1), Math.min(e.text.length, i.updateRangeStart + 1))) && this.handlers.compositionend(i);
    }, this.handlers.characterboundsupdate = (i) => {
      let r = [], n = null;
      for (let a = this.toEditorPos(i.rangeStart), o = this.toEditorPos(i.rangeEnd); a < o; a++) {
        let l = t.coordsForChar(a);
        n = l && new DOMRect(l.left, l.top, l.right - l.left, l.bottom - l.top) || n || new DOMRect(), r.push(n);
      }
      e.updateCharacterBounds(i.rangeStart, r);
    }, this.handlers.textformatupdate = (i) => {
      let r = [];
      for (let n of i.getTextFormats()) {
        let a = n.underlineStyle, o = n.underlineThickness;
        if (!/none/i.test(a) && !/none/i.test(o)) {
          let l = this.toEditorPos(n.rangeStart), d = this.toEditorPos(n.rangeEnd);
          if (l < d) {
            let u = `text-decoration: underline ${/^[a-z]/.test(a) ? a + " " : a == "Dashed" ? "dashed " : a == "Squiggle" ? "wavy " : ""}${/thin/i.test(o) ? 1 : 2}px`;
            r.push(se.mark({ attributes: { style: u } }).range(l, d));
          }
        }
      }
      t.dispatch({ effects: H7.of(se.set(r)) });
    }, this.handlers.compositionstart = () => {
      t.inputState.composing < 0 && (t.inputState.composing = 0, t.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (t.inputState.composing = -1, t.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: i } = this.composing;
        this.composing = null, i && this.reset(t.state);
      }
    };
    for (let i in this.handlers)
      e.addEventListener(i, this.handlers[i]);
    this.measureReq = { read: /* @__PURE__ */ m((i) => {
      this.editContext.updateControlBounds(i.contentDOM.getBoundingClientRect());
      let r = cl(i.root);
      r && r.rangeCount && this.editContext.updateSelectionBounds(r.getRangeAt(0).getBoundingClientRect());
    }, "read") };
  }
  applyEdits(t) {
    let e = 0, i = !1, r = this.pendingContextChange;
    return t.changes.iterChanges((n, a, o, l, d) => {
      if (i)
        return;
      let u = d.length - (a - n);
      if (r && a >= r.to)
        if (r.from == n && r.to == a && r.insert.eq(d)) {
          r = this.pendingContextChange = null, e += u, this.to += u;
          return;
        } else
          r = null, this.revertPending(t.state);
      if (n += e, a += e, a <= this.from)
        this.from += u, this.to += u;
      else if (n < this.to) {
        if (n < this.from || a > this.to || this.to - this.from + d.length > 3e4) {
          i = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(n), this.toContextPos(a), d.toString()), this.to += u;
      }
      e += u;
    }), r && !i && this.revertPending(t.state), !i;
  }
  update(t) {
    let e = this.pendingContextChange, i = t.startState.selection.main;
    this.composing && (this.composing.drifted || !t.changes.touchesRange(i.from, i.to) && t.transactions.some((r) => !r.isUserEvent("input.type") && r.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = t.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(t) || !this.rangeIsValid(t.state) ? (this.pendingContextChange = null, this.reset(t.state)) : (t.docChanged || t.selectionSet || e) && this.setSelection(t.state), (t.geometryChanged || t.docChanged || t.selectionSet) && t.view.requestMeasure(this.measureReq);
  }
  resetRange(t) {
    let { head: e } = t.selection.main;
    this.from = Math.max(
      0,
      e - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      t.doc.length,
      e + 1e4
      /* CxVp.Margin */
    );
  }
  reset(t) {
    this.resetRange(t), this.editContext.updateText(0, this.editContext.text.length, t.doc.sliceString(this.from, this.to)), this.setSelection(t);
  }
  revertPending(t) {
    let e = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(e.from), this.toContextPos(e.from + e.insert.length), t.doc.sliceString(e.from, e.to));
  }
  setSelection(t) {
    let { main: e } = t.selection, i = this.toContextPos(Math.max(this.from, Math.min(this.to, e.anchor))), r = this.toContextPos(e.head);
    (this.editContext.selectionStart != i || this.editContext.selectionEnd != r) && this.editContext.updateSelection(i, r);
  }
  rangeIsValid(t) {
    let { head: e } = t.selection.main;
    return !(this.from > 0 && e - this.from < 500 || this.to < t.doc.length && this.to - e < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(t, e = this.to - this.from) {
    t = Math.min(t, e);
    let i = this.composing;
    return i && i.drifted ? i.editorBase + (t - i.contextBase) : t + this.from;
  }
  toContextPos(t) {
    let e = this.composing;
    return e && e.drifted ? e.contextBase + (t - e.editorBase) : t - this.from;
  }
  destroy() {
    for (let t in this.handlers)
      this.editContext.removeEventListener(t, this.handlers[t]);
  }
}, h(Td, "qf"), Td);
m(q6, "EditContextManager");
let AF = q6;
var Jn;
const Z6 = (Jn = class {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(t = {}) {
    var e;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), t.parent && t.parent.appendChild(this.dom);
    let { dispatch: i } = t;
    this.dispatchTransactions = t.dispatchTransactions || i && ((r) => r.forEach((n) => i(n, this))) || ((r) => this.update(r)), this.dispatch = this.dispatch.bind(this), this._root = t.root || T7(t.parent) || document, this.viewState = new oQ(t.state || Be.create(t)), t.scrollTo && t.scrollTo.is(tv) && (this.viewState.scrollTarget = t.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(dh).map((r) => new m2(r));
    for (let r of this.plugins)
      r.update(this);
    this.observer = new MF(this), this.inputState = new mF(this), this.inputState.ensureHandlers(this.plugins), this.docView = new tQ(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((e = document.fonts) === null || e === void 0) && e.ready && document.fonts.ready.then(() => {
      this.viewState.mustMeasureContent = !0, this.requestMeasure();
    });
  }
  dispatch(...t) {
    let e = t.length == 1 && t[0] instanceof Mi ? t : t.length == 1 && Array.isArray(t[0]) ? t[0] : [this.state.update(...t)];
    this.dispatchTransactions(e, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let e = !1, i = !1, r, n = this.state;
    for (let f of t) {
      if (f.startState != n)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      n = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = n;
      return;
    }
    let a = this.hasFocus, o = 0, l = null;
    t.some((f) => f.annotation(p6)) ? (this.inputState.notifiedFocused = a, o = 1) : a != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = a, l = QC(n, a), l || (o = 1));
    let d = this.observer.delayedAndroidKey, u = null;
    if (d ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(n.doc) || !this.state.selection.eq(n.selection)) && (u = null)) : this.observer.clear(), n.facet(Be.phrases) != this.state.facet(Be.phrases))
      return this.setState(n);
    r = J3.create(this, n, t), r.flags |= o;
    let p = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of t) {
        if (p && (p = p.map(f.changes)), f.scrollIntoView) {
          let { main: y } = f.state.selection;
          p = new f2(y.empty ? y : nt.cursor(y.head, y.head > y.anchor ? -1 : 1));
        }
        for (let y of f.effects)
          y.is(tv) && (p = y.value.clip(this.state));
      }
      this.viewState.update(r, p), this.bidiCache = hQ.update(this.bidiCache, r.changes), r.empty || (this.updatePlugins(r), this.inputState.update(r)), e = this.docView.update(r), this.state.facet(Qg) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(t), this.docView.updateSelection(e, t.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (r.startState.facet(rv) != r.state.facet(rv) && (this.viewState.mustMeasureContent = !0), (e || i || p || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), e && this.docViewUpdate(), !r.empty)
      for (let f of this.state.facet(Xk))
        try {
          f(r);
        } catch (y) {
          Wi(this.state, y, "update listener");
        }
    (l || u) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), u && !kC(this, u) && d.force && yo(this.contentDOM, d.key, d.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = t;
      return;
    }
    this.updateState = 2;
    let e = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new oQ(t), this.plugins = t.facet(dh).map((i) => new m2(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView.destroy(), this.docView = new tQ(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    e && this.focus(), this.requestMeasure();
  }
  updatePlugins(t) {
    let e = t.startState.facet(dh), i = t.state.facet(dh);
    if (e != i) {
      let r = [];
      for (let n of i) {
        let a = e.indexOf(n);
        if (a < 0)
          r.push(new m2(n));
        else {
          let o = this.plugins[a];
          o.mustUpdate = t, r.push(o);
        }
      }
      for (let n of this.plugins)
        n.mustUpdate != t && n.destroy(this);
      this.plugins = r, this.pluginMap.clear();
    } else
      for (let r of this.plugins)
        r.mustUpdate = t;
    for (let r = 0; r < this.plugins.length; r++)
      this.plugins[r].update(this);
    e != i && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let t of this.plugins) {
      let e = t.value;
      if (e && e.docViewUpdate)
        try {
          e.docViewUpdate(this);
        } catch (i) {
          Wi(this.state, i, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(t = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, t && this.observer.forceFlush();
    let e = null, i = this.scrollDOM, r = i.scrollTop * this.scaleY, { scrollAnchorPos: n, scrollAnchorHeight: a } = this.viewState;
    Math.abs(r - this.viewState.scrollTop) > 1 && (a = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let o = 0; ; o++) {
        if (a < 0)
          if (lC(i))
            n = -1, a = this.viewState.heightMap.height;
          else {
            let y = this.viewState.scrollAnchorAt(r);
            n = y.from, a = y.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (o > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let d = [];
        l & 4 || ([this.measureRequests, d] = [d, this.measureRequests]);
        let u = d.map((y) => {
          try {
            return y.read(this);
          } catch (g) {
            return Wi(this.state, g), cQ;
          }
        }), p = J3.create(this, this.state, []), f = !1;
        p.flags |= l, e ? e.flags |= l : e = p, this.updateState = 2, p.empty || (this.updatePlugins(p), this.inputState.update(p), this.updateAttrs(), f = this.docView.update(p), f && this.docViewUpdate());
        for (let y = 0; y < d.length; y++)
          if (u[y] != cQ)
            try {
              let g = d[y];
              g.write && g.write(u[y], this);
            } catch (g) {
              Wi(this.state, g);
            }
        if (f && this.docView.updateSelection(!0), !p.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, a = -1;
              continue;
            } else {
              let y = (n < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(n).top) - a;
              if (y > 1 || y < -1) {
                r = r + y, i.scrollTop = r / this.scaleY, a = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (e && !e.empty)
      for (let o of this.state.facet(Xk))
        o(e);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return a5 + " " + (this.state.facet(n5) ? D6 : I6) + " " + this.state.facet(rv);
  }
  updateAttrs() {
    let t = c5(this, K7, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), e = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(Is) ? "true" : "false",
      class: "cm-content",
      style: `${at.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (e["aria-readonly"] = "true"), c5(this, wC, e);
    let i = this.observer.ignore(() => {
      let r = Zk(this.contentDOM, this.contentAttrs, e), n = Zk(this.dom, this.editorAttrs, t);
      return r || n;
    });
    return this.editorAttrs = t, this.contentAttrs = e, i;
  }
  showAnnouncements(t) {
    let e = !0;
    for (let i of t)
      for (let r of i.effects)
        if (r.is(Jn.announce)) {
          e && (this.announceDOM.textContent = ""), e = !1;
          let n = this.announceDOM.appendChild(document.createElement("div"));
          n.textContent = r.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(Qg);
    let t = this.state.facet(Jn.cspNonce);
    pa.mount(this.root, this.styleModules.concat(QF).reverse(), t ? { nonce: t } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(t) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), t) {
      if (this.measureRequests.indexOf(t) > -1)
        return;
      if (t.key != null) {
        for (let e = 0; e < this.measureRequests.length; e++)
          if (this.measureRequests[e].key === t.key) {
            this.measureRequests[e] = t;
            return;
          }
      }
      this.measureRequests.push(t);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(t) {
    let e = this.pluginMap.get(t);
    return (e === void 0 || e && e.plugin != t) && this.pluginMap.set(t, e = this.plugins.find((i) => i.plugin == t) || null), e && e.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(t) {
    return this.readMeasured(), this.viewState.elementAtHeight(t);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(t) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(t);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(t) {
    return this.viewState.lineBlockAt(t);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(t, e, i) {
    return Tv(this, t, Yk(this, t, e, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(t, e) {
    return Tv(this, t, Yk(this, t, e, (i) => WT(this, t.head, i)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(t, e) {
    let i = this.bidiSpans(t), r = this.textDirectionAt(t.from), n = i[e ? i.length - 1 : 0];
    return nt.cursor(n.side(e, r) + t.from, n.forward(!e, r) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(t, e, i = !0) {
    return VT(this, t, e, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(t, e, i) {
    return Tv(this, t, FT(this, t, e, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(t, e = 1) {
    return this.docView.domAtPos(t, e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(t, e = 0) {
    return this.docView.posFromDOM(t, e);
  }
  posAtCoords(t, e = !0) {
    this.readMeasured();
    let i = EO(this, t, e);
    return i && i.pos;
  }
  posAndSideAtCoords(t, e = !0) {
    return this.readMeasured(), EO(this, t, e);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(t, e = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(t, e);
    if (!i || i.left == i.right)
      return i;
    let r = this.state.doc.lineAt(t), n = this.bidiSpans(r), a = n[qs.find(n, t - r.from, -1, e)];
    return ay(i, a.dir == me.LTR == e > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(t) {
    return this.readMeasured(), this.docView.coordsForChar(t);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(t) {
    return !this.state.facet(X7) || t < this.viewport.from || t > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(t));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(t) {
    if (t.length > RF)
      return mC(t.length);
    let e = this.textDirectionAt(t.from), i;
    for (let n of this.bidiCache)
      if (n.from == t.from && n.dir == e && (n.fresh || fC(n.isolates, i = jk(this, t))))
        return n.order;
    i || (i = jk(this, t));
    let r = z7(t.text, e, i);
    return this.bidiCache.push(new hQ(t.from, t.to, e, i, !0, r)), r;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var t;
    return (this.dom.ownerDocument.hasFocus() || at.safari && ((t = this.inputState) === null || t === void 0 ? void 0 : t.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      oC(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(t) {
    this._root != t && (this._root = t, this.observer.setWindow((t.nodeType == 9 ? t : t.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let t of this.plugins)
      t.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(t, e = {}) {
    return tv.of(new f2(typeof t == "number" ? nt.cursor(t) : t, e.y, e.x, e.yMargin, e.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: t, scrollLeft: e } = this.scrollDOM, i = this.viewState.scrollAnchorAt(t);
    return tv.of(new f2(nt.cursor(i.from), "start", "start", i.top - t, e, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(t) {
    t == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof t == "boolean" ? this.inputState.tabFocusMode = t ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + t);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(t) {
    return rn.define(() => ({}), { eventHandlers: t });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(t) {
    return rn.define(() => ({}), { eventObservers: t });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(t, e) {
    let i = pa.newName(), r = [rv.of(i), Qg.of(_O(`.${i}`, t))];
    return e && e.dark && r.push(n5.of(!0)), r;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(t) {
    return Ll.lowest(Qg.of(_O("." + a5, t, V6)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(t) {
    var e;
    let i = t.querySelector(".cm-content");
    return ((e = (i && Le.get(i) || Le.get(t))?.root) === null || e === void 0 ? void 0 : e.view) || null;
  }
}, h(Jn, "Xr"), Jn);
m(Z6, "EditorView");
let Mt = Z6;
Mt.styleModule = Qg;
Mt.inputHandler = B7;
Mt.clipboardInputFilter = yC;
Mt.clipboardOutputFilter = gC;
Mt.scrollHandler = j7;
Mt.focusChangeEffect = N7;
Mt.perLineTextDirection = X7;
Mt.exceptionSink = Z7;
Mt.updateListener = Xk;
Mt.editable = Is;
Mt.mouseSelectionStyle = q7;
Mt.dragMovesSelection = F7;
Mt.clickAddsSelectionRange = W7;
Mt.decorations = N0;
Mt.blockWrappers = J7;
Mt.outerDecorations = vC;
Mt.atomicRanges = w1;
Mt.bidiIsolatedRanges = tT;
Mt.scrollMargins = eT;
Mt.darkTheme = n5;
Mt.cspNonce = /* @__PURE__ */ Ct.define({ combine: /* @__PURE__ */ m((s) => s.length ? s[0] : "", "combine") });
Mt.contentAttributes = wC;
Mt.editorAttributes = K7;
Mt.lineWrapping = /* @__PURE__ */ Mt.contentAttributes.of({ class: "cm-lineWrapping" });
Mt.announce = /* @__PURE__ */ te.define();
const RF = 4096, cQ = {};
var qo;
const B6 = (qo = class {
  constructor(t, e, i, r, n, a) {
    this.from = t, this.to = e, this.dir = i, this.isolates = r, this.fresh = n, this.order = a;
  }
  static update(t, e) {
    if (e.empty && !t.some((n) => n.fresh))
      return t;
    let i = [], r = t.length ? t[t.length - 1].dir : me.LTR;
    for (let n = Math.max(0, t.length - 10); n < t.length; n++) {
      let a = t[n];
      a.dir == r && !e.touchesRange(a.from, a.to) && i.push(new qo(e.mapPos(a.from, 1), e.mapPos(a.to, -1), a.dir, a.isolates, !1, a.order));
    }
    return i;
  }
}, h(qo, "ro"), qo);
m(B6, "CachedOrder");
let hQ = B6;
function c5(s, t, e) {
  for (let i = s.state.facet(t), r = i.length - 1; r >= 0; r--) {
    let n = i[r], a = typeof n == "function" ? n(s) : n;
    a && Z0(a, e);
  }
  return e;
}
h(c5, "Cu");
m(c5, "attrsFromFacet");
const EF = at.mac ? "mac" : at.windows ? "win" : at.linux ? "linux" : "key";
function N6(s, t) {
  const e = s.split(/-(?!$)/);
  let i = e[e.length - 1];
  i == "Space" && (i = " ");
  let r, n, a, o;
  for (let l = 0; l < e.length - 1; ++l) {
    const d = e[l];
    if (/^(cmd|meta|m)$/i.test(d))
      o = !0;
    else if (/^a(lt)?$/i.test(d))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(d))
      n = !0;
    else if (/^s(hift)?$/i.test(d))
      a = !0;
    else if (/^mod$/i.test(d))
      t == "mac" ? o = !0 : n = !0;
    else
      throw new Error("Unrecognized modifier name: " + d);
  }
  return r && (i = "Alt-" + i), n && (i = "Ctrl-" + i), o && (i = "Meta-" + i), a && (i = "Shift-" + i), i;
}
h(N6, "k1");
m(N6, "normalizeKeyName");
function _g(s, t, e) {
  return t.altKey && (s = "Alt-" + s), t.ctrlKey && (s = "Ctrl-" + s), t.metaKey && (s = "Meta-" + s), e !== !1 && t.shiftKey && (s = "Shift-" + s), s;
}
h(_g, "Zn$1");
m(_g, "modifiers");
const _F = /* @__PURE__ */ Ll.default(/* @__PURE__ */ Mt.domEventHandlers({
  keydown(s, t) {
    return U6(X6(t.state), s, t, "editor");
  }
})), Y0 = /* @__PURE__ */ Ct.define({ enables: _F }), dQ = /* @__PURE__ */ new WeakMap();
function X6(s) {
  let t = s.facet(Y0), e = dQ.get(t);
  return e || dQ.set(t, e = j6(t.reduce((i, r) => i.concat(r), []))), e;
}
h(X6, "$1");
m(X6, "getKeymap");
let zn = null;
const LF = 4e3;
function j6(s, t = EF) {
  let e = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ m((a, o) => {
    let l = i[a];
    if (l == null)
      i[a] = o;
    else if (l != o)
      throw new Error("Key binding " + a + " is used both as a regular binding and as a multi-stroke prefix");
  }, "checkPrefix"), n = /* @__PURE__ */ m((a, o, l, d, u) => {
    var p, f;
    let y = e[a] || (e[a] = /* @__PURE__ */ Object.create(null)), g = o.split(/ (?!$)/).map(($) => N6($, t));
    for (let $ = 1; $ < g.length; $++) {
      let T = g.slice(0, $).join(" ");
      r(T, !0), y[T] || (y[T] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(_) => {
          let D = zn = { view: _, prefix: T, scope: a };
          return setTimeout(() => {
            zn == D && (zn = null);
          }, LF), !0;
        }]
      });
    }
    let O = g.join(" ");
    r(O, !1);
    let k = y[O] || (y[O] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((f = (p = y._any) === null || p === void 0 ? void 0 : p.run) === null || f === void 0 ? void 0 : f.slice()) || []
    });
    l && k.run.push(l), d && (k.preventDefault = !0), u && (k.stopPropagation = !0);
  }, "add");
  for (let a of s) {
    let o = a.scope ? a.scope.split(" ") : ["editor"];
    if (a.any)
      for (let d of o) {
        let u = e[d] || (e[d] = /* @__PURE__ */ Object.create(null));
        u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: p } = a;
        for (let f in u)
          u[f].run.push((y) => p(y, h5));
      }
    let l = a[t] || a.key;
    if (l)
      for (let d of o)
        n(d, l, a.run, a.preventDefault, a.stopPropagation), a.shift && n(d, "Shift-" + l, a.shift, a.preventDefault, a.stopPropagation);
  }
  return e;
}
h(j6, "v1$1");
m(j6, "buildKeymap");
let h5 = null;
function U6(s, t, e, i) {
  h5 = t;
  let r = f7(t), n = Rn(r, 0), a = oo(n) == r.length && r != " ", o = "", l = !1, d = !1, u = !1;
  zn && zn.view == e && zn.scope == i && (o = zn.prefix + " ", t6.indexOf(t.keyCode) < 0 && (d = !0, zn = null));
  let p = /* @__PURE__ */ new Set(), f = /* @__PURE__ */ m((k) => {
    if (k) {
      for (let $ of k.run)
        if (!p.has($) && (p.add($), $(e)))
          return k.stopPropagation && (u = !0), !0;
      k.preventDefault && (k.stopPropagation && (u = !0), d = !0);
    }
    return !1;
  }, "runFor"), y = s[i], g, O;
  return y && (f(y[o + _g(r, t, !a)]) ? l = !0 : a && (t.altKey || t.metaKey || t.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(at.windows && t.ctrlKey && t.altKey) && // Alt-combinations on macOS tend to be typed characters
  !(at.mac && t.altKey && !(t.ctrlKey || t.metaKey)) && (g = fa[t.keyCode]) && g != r ? (f(y[o + _g(g, t, !0)]) || t.shiftKey && (O = Qw[t.keyCode]) != r && O != g && f(y[o + _g(O, t, !1)])) && (l = !0) : a && t.shiftKey && f(y[o + _g(r, t, !0)]) && (l = !0), !l && f(y._any) && (l = !0)), d && (l = !0), l && u && t.stopPropagation(), h5 = null, l;
}
h(U6, "T1$1");
m(U6, "runHandlers");
const H6 = /* @__PURE__ */ te.define({
  map(s, t) {
    return s == null ? null : t.mapPos(s);
  }
}), Lg = /* @__PURE__ */ mn.define({
  create() {
    return null;
  },
  update(s, t) {
    return s != null && (s = t.changes.mapPos(s)), t.effects.reduce((e, i) => i.is(H6) ? i.value : e, s);
  }
}), zF = /* @__PURE__ */ rn.fromClass(class {
  constructor(s) {
    this.view = s, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(s) {
    var t;
    let e = s.state.field(Lg);
    e == null ? this.cursor != null && ((t = this.cursor) === null || t === void 0 || t.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (s.startState.field(Lg) != e || s.docChanged || s.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: s } = this, t = s.state.field(Lg), e = t != null && s.coordsAtPos(t);
    if (!e)
      return null;
    let i = s.scrollDOM.getBoundingClientRect();
    return {
      left: e.left - i.left + s.scrollDOM.scrollLeft * s.scaleX,
      top: e.top - i.top + s.scrollDOM.scrollTop * s.scaleY,
      height: e.bottom - e.top
    };
  }
  drawCursor(s) {
    if (this.cursor) {
      let { scaleX: t, scaleY: e } = this.view;
      s ? (this.cursor.style.left = s.left / t + "px", this.cursor.style.top = s.top / e + "px", this.cursor.style.height = s.height / e + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(s) {
    this.view.state.field(Lg) != s && this.view.dispatch({ effects: H6.of(s) });
  }
}, {
  eventObservers: {
    dragover(s) {
      this.setDropPos(this.view.posAtCoords({ x: s.clientX, y: s.clientY }));
    },
    dragleave(s) {
      (s.target == this.view.contentDOM || !this.view.contentDOM.contains(s.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function IF() {
  return [Lg, zF];
}
h(IF, "L1$1");
m(IF, "dropCursor");
function d5(s, t, e, i, r) {
  t.lastIndex = 0;
  for (let n = s.iterRange(e, i), a = e, o; !n.next().done; a += n.value.length)
    if (!n.lineBreak)
      for (; o = t.exec(n.value); )
        r(a + o.index, o);
}
h(d5, "Eu");
m(d5, "iterMatches");
function Y6(s, t) {
  let e = s.visibleRanges;
  if (e.length == 1 && e[0].from == s.viewport.from && e[0].to == s.viewport.to)
    return e;
  let i = [];
  for (let { from: r, to: n } of e)
    r = Math.max(s.state.doc.lineAt(r).from, r - t), n = Math.min(s.state.doc.lineAt(n).to, n + t), i.length && i[i.length - 1].to >= r ? i[i.length - 1].to = n : i.push({ from: r, to: n });
  return i;
}
h(Y6, "_1");
m(Y6, "matchRanges");
var Md;
const G6 = (Md = class {
  /**
  Create a decorator.
  */
  constructor(t) {
    const { regexp: e, decoration: i, decorate: r, boundary: n, maxLength: a = 1e3 } = t;
    if (!e.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = e, r)
      this.addMatch = (o, l, d, u) => r(u, d, d + o[0].length, o, l);
    else if (typeof i == "function")
      this.addMatch = (o, l, d, u) => {
        let p = i(o, l, d);
        p && u(d, d + o[0].length, p);
      };
    else if (i)
      this.addMatch = (o, l, d, u) => u(d, d + o[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = n, this.maxLength = a;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(t) {
    let e = new xO(), i = e.add.bind(e);
    for (let { from: r, to: n } of Y6(t, this.maxLength))
      d5(t.state.doc, this.regexp, r, n, (a, o) => this.addMatch(o, t, a, i));
    return e.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(t, e) {
    let i = 1e9, r = -1;
    return t.docChanged && t.changes.iterChanges((n, a, o, l) => {
      l >= t.view.viewport.from && o <= t.view.viewport.to && (i = Math.min(o, i), r = Math.max(l, r));
    }), t.viewportMoved || r - i > 1e3 ? this.createDeco(t.view) : r > -1 ? this.updateRange(t.view, e.map(t.changes), i, r) : e;
  }
  updateRange(t, e, i, r) {
    for (let n of t.visibleRanges) {
      let a = Math.max(n.from, i), o = Math.min(n.to, r);
      if (o >= a) {
        let l = t.state.doc.lineAt(a), d = l.to < o ? t.state.doc.lineAt(o) : l, u = Math.max(n.from, l.from), p = Math.min(n.to, d.to);
        if (this.boundary) {
          for (; a > l.from; a--)
            if (this.boundary.test(l.text[a - 1 - l.from])) {
              u = a;
              break;
            }
          for (; o < d.to; o++)
            if (this.boundary.test(d.text[o - d.from])) {
              p = o;
              break;
            }
        }
        let f = [], y, g = /* @__PURE__ */ m((O, k, $) => f.push($.range(O, k)), "add");
        if (l == d)
          for (this.regexp.lastIndex = u - l.from; (y = this.regexp.exec(l.text)) && y.index < p - l.from; )
            this.addMatch(y, t, y.index + l.from, g);
        else
          d5(t.state.doc, this.regexp, u, p, (O, k) => this.addMatch(k, t, O, g));
        e = e.update({ filterFrom: u, filterTo: p, filter: /* @__PURE__ */ m((O, k) => O < u || k > p, "filter"), add: f });
      }
    }
    return e;
  }
}, h(Md, "Bf"), Md);
m(G6, "MatchDecorator");
let DF = G6;
var Ad;
const K6 = (Ad = class extends zl {
  constructor(t) {
    super(), this.content = t;
  }
  toDOM(t) {
    let e = document.createElement("span");
    return e.className = "cm-placeholder", e.style.pointerEvents = "none", e.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(t) : this.content.cloneNode(!0)), e.setAttribute("aria-hidden", "true"), e;
  }
  coordsAt(t) {
    let e = t.firstChild ? gh(t.firstChild) : [];
    if (!e.length)
      return null;
    let i = window.getComputedStyle(t.parentNode), r = ay(e[0], i.direction != "rtl"), n = parseInt(i.lineHeight);
    return r.bottom - r.top > n * 1.5 ? { left: r.left, right: r.right, top: r.top, bottom: r.top + n } : r;
  }
  ignoreEvent() {
    return !1;
  }
}, h(Ad, "Df"), Ad);
m(K6, "Placeholder");
let VF = K6;
function WF(s) {
  let t = rn.fromClass(class {
    constructor(e) {
      this.view = e, this.placeholder = s ? se.set([se.widget({ widget: new VF(s), side: 1 }).range(0)]) : se.none;
    }
    get decorations() {
      return this.view.state.doc.length ? se.none : this.placeholder;
    }
  }, { decorations: /* @__PURE__ */ m((e) => e.decorations, "decorations") });
  return typeof s == "string" ? [
    t,
    Mt.contentAttributes.of({ "aria-placeholder": s })
  ] : t;
}
h(WF, "M1");
m(WF, "placeholder");
const sv = "-10000px";
var Rd;
const J6 = (Rd = class {
  constructor(t, e, i, r) {
    this.facet = e, this.createTooltipView = i, this.removeTooltipView = r, this.input = t.state.facet(e), this.tooltips = this.input.filter((a) => a);
    let n = null;
    this.tooltipViews = this.tooltips.map((a) => n = i(a, n));
  }
  update(t, e) {
    var i;
    let r = t.state.facet(this.facet), n = r.filter((l) => l);
    if (r === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(t);
      return !1;
    }
    let a = [], o = e ? [] : null;
    for (let l = 0; l < n.length; l++) {
      let d = n[l], u = -1;
      if (d) {
        for (let p = 0; p < this.tooltips.length; p++) {
          let f = this.tooltips[p];
          f && f.create == d.create && (u = p);
        }
        if (u < 0)
          a[l] = this.createTooltipView(d, l ? a[l - 1] : null), o && (o[l] = !!d.above);
        else {
          let p = a[l] = this.tooltipViews[u];
          o && (o[l] = e[u]), p.update && p.update(t);
        }
      }
    }
    for (let l of this.tooltipViews)
      a.indexOf(l) < 0 && (this.removeTooltipView(l), (i = l.destroy) === null || i === void 0 || i.call(l));
    return e && (o.forEach((l, d) => e[d] = l), e.length = o.length), this.input = r, this.tooltips = n, this.tooltipViews = a, !0;
  }
}, h(Rd, "Nf"), Rd);
m(J6, "TooltipViewManager");
let FF = J6;
function tM(s) {
  let t = s.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: t.clientHeight, right: t.clientWidth };
}
h(tM, "Z1$1");
m(tM, "windowSpace");
const b2 = /* @__PURE__ */ Ct.define({
  combine: /* @__PURE__ */ m((s) => {
    var t, e, i;
    return {
      position: at.ios ? "absolute" : ((t = s.find((r) => r.position)) === null || t === void 0 ? void 0 : t.position) || "fixed",
      parent: ((e = s.find((r) => r.parent)) === null || e === void 0 ? void 0 : e.parent) || null,
      tooltipSpace: ((i = s.find((r) => r.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || tM
    };
  }, "combine")
}), uQ = /* @__PURE__ */ new WeakMap(), eM = /* @__PURE__ */ rn.fromClass(class {
  constructor(s) {
    this.view = s, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let t = s.state.facet(b2);
    this.position = t.position, this.parent = t.parent, this.classes = s.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new FF(s, iM, (e, i) => this.createTooltip(e, i), (e) => {
      this.resizeObserver && this.resizeObserver.unobserve(e.dom), e.dom.remove();
    }), this.above = this.manager.tooltips.map((e) => !!e.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((e) => {
      Date.now() > this.lastTransaction - 50 && e.length > 0 && e[e.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), s.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let s of this.manager.tooltipViews)
        this.intersectionObserver.observe(s.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(s) {
    s.transactions.length && (this.lastTransaction = Date.now());
    let t = this.manager.update(s, this.above);
    t && this.observeIntersection();
    let e = t || s.geometryChanged, i = s.state.facet(b2);
    if (i.position != this.position && !this.madeAbsolute) {
      this.position = i.position;
      for (let r of this.manager.tooltipViews)
        r.dom.style.position = this.position;
      e = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let r of this.manager.tooltipViews)
        this.container.appendChild(r.dom);
      e = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    e && this.maybeMeasure();
  }
  createTooltip(s, t) {
    let e = s.create(this.view), i = t ? t.dom : null;
    if (e.dom.classList.add("cm-tooltip"), s.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let r = document.createElement("div");
      r.className = "cm-tooltip-arrow", e.dom.appendChild(r);
    }
    return e.dom.style.position = this.position, e.dom.style.top = sv, e.dom.style.left = "0px", this.container.insertBefore(e.dom, i), e.mount && e.mount(this.view), this.resizeObserver && this.resizeObserver.observe(e.dom), e;
  }
  destroy() {
    var s, t, e;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let i of this.manager.tooltipViews)
      i.dom.remove(), (s = i.destroy) === null || s === void 0 || s.call(i);
    this.parent && this.container.remove(), (t = this.resizeObserver) === null || t === void 0 || t.disconnect(), (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let s = 1, t = 1, e = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: n } = this.manager.tooltipViews[0];
      if (at.safari) {
        let a = n.getBoundingClientRect();
        e = Math.abs(a.top + 1e4) > 1 || Math.abs(a.left) > 1;
      } else
        e = !!n.offsetParent && n.offsetParent != this.container.ownerDocument.body;
    }
    if (e || this.position == "absolute")
      if (this.parent) {
        let n = this.parent.getBoundingClientRect();
        n.width && n.height && (s = n.width / this.parent.offsetWidth, t = n.height / this.parent.offsetHeight);
      } else
        ({ scaleX: s, scaleY: t } = this.view.viewState);
    let i = this.view.scrollDOM.getBoundingClientRect(), r = X0(this.view);
    return {
      visible: {
        left: i.left + r.left,
        top: i.top + r.top,
        right: i.right - r.right,
        bottom: i.bottom - r.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((n, a) => {
        let o = this.manager.tooltipViews[a];
        return o.getCoords ? o.getCoords(n.pos) : this.view.coordsAtPos(n.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: n }) => n.getBoundingClientRect()),
      space: this.view.state.facet(b2).tooltipSpace(this.view),
      scaleX: s,
      scaleY: t,
      makeAbsolute: e
    };
  }
  writeMeasure(s) {
    var t;
    if (s.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let o of this.manager.tooltipViews)
        o.dom.style.position = "absolute";
    }
    let { visible: e, space: i, scaleX: r, scaleY: n } = s, a = [];
    for (let o = 0; o < this.manager.tooltips.length; o++) {
      let l = this.manager.tooltips[o], d = this.manager.tooltipViews[o], { dom: u } = d, p = s.pos[o], f = s.size[o];
      if (!p || l.clip !== !1 && (p.bottom <= Math.max(e.top, i.top) || p.top >= Math.min(e.bottom, i.bottom) || p.right < Math.max(e.left, i.left) - 0.1 || p.left > Math.min(e.right, i.right) + 0.1)) {
        u.style.top = sv;
        continue;
      }
      let y = l.arrow ? d.dom.querySelector(".cm-tooltip-arrow") : null, g = y ? 7 : 0, O = f.right - f.left, k = (t = uQ.get(d)) !== null && t !== void 0 ? t : f.bottom - f.top, $ = d.offset || ZF, T = this.view.textDirection == me.LTR, _ = f.width > i.right - i.left ? T ? i.left : i.right - f.width : T ? Math.max(i.left, Math.min(p.left - (y ? 14 : 0) + $.x, i.right - O)) : Math.min(Math.max(i.left, p.left - O + (y ? 14 : 0) - $.x), i.right - O), D = this.above[o];
      !l.strictSide && (D ? p.top - k - g - $.y < i.top : p.bottom + k + g + $.y > i.bottom) && D == i.bottom - p.bottom > p.top - i.top && (D = this.above[o] = !D);
      let A = (D ? p.top - i.top : i.bottom - p.bottom) - g;
      if (A < k && d.resize !== !1) {
        if (A < this.view.defaultLineHeight) {
          u.style.top = sv;
          continue;
        }
        uQ.set(d, k), u.style.height = (k = A) / n + "px";
      } else u.style.height && (u.style.height = "");
      let z = D ? p.top - k - g - $.y : p.bottom + g + $.y, V = _ + O;
      if (d.overlap !== !0)
        for (let X of a)
          X.left < V && X.right > _ && X.top < z + k && X.bottom > z && (z = D ? X.top - k - 2 - g : X.bottom + g + 2);
      if (this.position == "absolute" ? (u.style.top = (z - s.parent.top) / n + "px", u5(u, (_ - s.parent.left) / r)) : (u.style.top = z / n + "px", u5(u, _ / r)), y) {
        let X = p.left + (T ? $.x : -$.x) - (_ + 14 - 7);
        y.style.left = X / r + "px";
      }
      d.overlap !== !0 && a.push({ left: _, top: z, right: V, bottom: z + k }), u.classList.toggle("cm-tooltip-above", D), u.classList.toggle("cm-tooltip-below", !D), d.positioned && d.positioned(s.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let s of this.manager.tooltipViews)
        s.dom.style.top = sv;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function u5(s, t) {
  let e = parseInt(s.style.left, 10);
  (isNaN(e) || Math.abs(t - e) > 1) && (s.style.left = t + "px");
}
h(u5, "Wu$1");
m(u5, "setLeftStyle");
const qF = /* @__PURE__ */ Mt.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: "14px",
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), ZF = { x: 0, y: 0 }, iM = /* @__PURE__ */ Ct.define({
  enables: [eM, qF]
});
function MC(s, t) {
  let e = s.plugin(eM);
  if (!e)
    return null;
  let i = e.manager.tooltips.indexOf(t);
  return i < 0 ? null : e.manager.tooltipViews[i];
}
h(MC, "hp$1");
m(MC, "getTooltip");
var Ed;
const rM = (Ed = class extends da {
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(t) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(t) {
  }
}, h(Ed, "Gf"), Ed);
m(rM, "GutterMarker");
let hy = rM;
hy.prototype.elementClass = "";
hy.prototype.toDOM = void 0;
hy.prototype.mapMode = Ti.TrackBefore;
hy.prototype.startSide = hy.prototype.endSide = -1;
hy.prototype.point = !0;
const sM = 1024;
let BF = 0;
var _d;
const nM = (_d = class {
  constructor(t, e) {
    this.from = t, this.to = e;
  }
}, h(_d, "Ff"), _d);
m(nM, "Range");
let gr = nM;
var Ld;
const aM = (Ld = class {
  /**
  Create a new node prop type.
  */
  constructor(t = {}) {
    this.id = BF++, this.perNode = !!t.perNode, this.deserialize = t.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    }), this.combine = t.combine || null;
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(t) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof t != "function" && (t = ei.match(t)), (e) => {
      let i = t(e);
      return i === void 0 ? null : [this, i];
    };
  }
}, h(Ld, "Hf"), Ld);
m(aM, "NodeProp");
let Et = aM;
Et.closedBy = new Et({ deserialize: /* @__PURE__ */ m((s) => s.split(" "), "deserialize") });
Et.openedBy = new Et({ deserialize: /* @__PURE__ */ m((s) => s.split(" "), "deserialize") });
Et.group = new Et({ deserialize: /* @__PURE__ */ m((s) => s.split(" "), "deserialize") });
Et.isolate = new Et({ deserialize: /* @__PURE__ */ m((s) => {
  if (s && s != "rtl" && s != "ltr" && s != "auto")
    throw new RangeError("Invalid value for isolate: " + s);
  return s || "auto";
}, "deserialize") });
Et.contextHash = new Et({ perNode: !0 });
Et.lookAhead = new Et({ perNode: !0 });
Et.mounted = new Et({ perNode: !0 });
var zd;
const oM = (zd = class {
  constructor(t, e, i, r = !1) {
    this.tree = t, this.overlay = e, this.parser = i, this.bracketed = r;
  }
  /**
  @internal
  */
  static get(t) {
    return t && t.props && t.props[Et.mounted.id];
  }
}, h(zd, "Kf"), zd);
m(oM, "MountedTree");
let $h = oM;
const NF = /* @__PURE__ */ Object.create(null);
var Zo;
const lM = (Zo = class {
  /**
  @internal
  */
  constructor(t, e, i, r = 0) {
    this.name = t, this.props = e, this.id = i, this.flags = r;
  }
  /**
  Define a node type.
  */
  static define(t) {
    let e = t.props && t.props.length ? /* @__PURE__ */ Object.create(null) : NF, i = (t.top ? 1 : 0) | (t.skipped ? 2 : 0) | (t.error ? 4 : 0) | (t.name == null ? 8 : 0), r = new Zo(t.name || "", e, t.id, i);
    if (t.props) {
      for (let n of t.props)
        if (Array.isArray(n) || (n = n(r)), n) {
          if (n[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          e[n[0].id] = n[1];
        }
    }
    return r;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(t) {
    return this.props[t.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(t) {
    if (typeof t == "string") {
      if (this.name == t)
        return !0;
      let e = this.prop(Et.group);
      return e ? e.indexOf(t) > -1 : !1;
    }
    return this.id == t;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(t) {
    let e = /* @__PURE__ */ Object.create(null);
    for (let i in t)
      for (let r of i.split(" "))
        e[r] = t[i];
    return (i) => {
      for (let r = i.prop(Et.group), n = -1; n < (r ? r.length : 0); n++) {
        let a = e[n < 0 ? i.name : r[n]];
        if (a)
          return a;
      }
    };
  }
}, h(Zo, "no"), Zo);
m(lM, "NodeType");
let ei = lM;
ei.none = new ei(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
var Bo;
const cM = (Bo = class {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(t) {
    this.types = t;
    for (let e = 0; e < t.length; e++)
      if (t[e].id != e)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...t) {
    let e = [];
    for (let i of this.types) {
      let r = null;
      for (let n of t) {
        let a = n(i);
        if (a) {
          r || (r = Object.assign({}, i.props));
          let o = a[1], l = a[0];
          l.combine && l.id in r && (o = l.combine(r[l.id], o)), r[l.id] = o;
        }
      }
      e.push(r ? new ei(i.name, r, i.id, i.flags) : i);
    }
    return new Bo(e);
  }
}, h(Bo, "so"), Bo);
m(cM, "NodeSet");
let G0 = cM;
const nv = /* @__PURE__ */ new WeakMap(), pQ = /* @__PURE__ */ new WeakMap();
var Ut;
(function(s) {
  s[s.ExcludeBuffers = 1] = "ExcludeBuffers", s[s.IncludeAnonymous = 2] = "IncludeAnonymous", s[s.IgnoreMounts = 4] = "IgnoreMounts", s[s.IgnoreOverlays = 8] = "IgnoreOverlays", s[s.EnterBracketed = 16] = "EnterBracketed";
})(Ut || (Ut = {}));
var ta;
const hM = (ta = class {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(t, e, i, r, n) {
    if (this.type = t, this.children = e, this.positions = i, this.length = r, this.props = null, n && n.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [a, o] of n)
        this.props[typeof a == "number" ? a : a.id] = o;
    }
  }
  /**
  @internal
  */
  toString() {
    let t = $h.get(this);
    if (t && !t.overlay)
      return t.tree.toString();
    let e = "";
    for (let i of this.children) {
      let r = i.toString();
      r && (e && (e += ","), e += r);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (e.length ? "(" + e + ")" : "") : e;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(t = 0) {
    return new zO(this.topNode, t);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(t, e = 0, i = 0) {
    let r = nv.get(this) || this.topNode, n = new zO(r);
    return n.moveTo(t, e), nv.set(this, n._tree), n;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new br(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(t, e = 0) {
    let i = uy(nv.get(this) || this.topNode, t, e, !1);
    return nv.set(this, i), i;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(t, e = 0) {
    let i = uy(pQ.get(this) || this.topNode, t, e, !0);
    return pQ.set(this, i), i;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(t, e = 0) {
    return vM(this, t, e);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(t) {
    let { enter: e, leave: i, from: r = 0, to: n = this.length } = t, a = t.mode || 0, o = (a & Ut.IncludeAnonymous) > 0;
    for (let l = this.cursor(a | Ut.IncludeAnonymous); ; ) {
      let d = !1;
      if (l.from <= n && l.to >= r && (!o && l.type.isAnonymous || e(l) !== !1)) {
        if (l.firstChild())
          continue;
        d = !0;
      }
      for (; d && i && (o || !l.type.isAnonymous) && i(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        d = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(t) {
    return t.perNode ? this.props ? this.props[t.id] : void 0 : this.type.prop(t);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let t = [];
    if (this.props)
      for (let e in this.props)
        t.push([+e, this.props[e]]);
    return t;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(t = {}) {
    return this.children.length <= 8 ? this : J0(ei.none, this.children, this.positions, 0, this.children.length, 0, this.length, (e, i, r) => new ta(this.type, e, i, r, this.propValues), t.makeTree || ((e, i, r) => new ta(ei.none, e, i, r)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(t) {
    return bM(t);
  }
}, h(ta, "Er"), ta);
m(hM, "Tree");
let Ft = hM;
Ft.empty = new Ft(ei.none, [], [], 0);
var No;
const dM = (No = class {
  constructor(t, e) {
    this.buffer = t, this.index = e;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new No(this.buffer, this.index);
  }
}, h(No, "oo"), No);
m(dM, "FlatBufferCursor");
let XF = dM;
var Xo;
const uM = (Xo = class {
  /**
  Create a tree buffer.
  */
  constructor(t, e, i) {
    this.buffer = t, this.length = e, this.set = i;
  }
  /**
  @internal
  */
  get type() {
    return ei.none;
  }
  /**
  @internal
  */
  toString() {
    let t = [];
    for (let e = 0; e < this.buffer.length; )
      t.push(this.childString(e)), e = this.buffer[e + 3];
    return t.join(",");
  }
  /**
  @internal
  */
  childString(t) {
    let e = this.buffer[t], i = this.buffer[t + 3], r = this.set.types[e], n = r.name;
    if (/\W/.test(n) && !r.isError && (n = JSON.stringify(n)), t += 4, i == t)
      return n;
    let a = [];
    for (; t < i; )
      a.push(this.childString(t)), t = this.buffer[t + 3];
    return n + "(" + a.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(t, e, i, r, n) {
    let { buffer: a } = this, o = -1;
    for (let l = t; l != e && !(AC(n, r, a[l + 1], a[l + 2]) && (o = l, i > 0)); l = a[l + 3])
      ;
    return o;
  }
  /**
  @internal
  */
  slice(t, e, i) {
    let r = this.buffer, n = new Uint16Array(e - t), a = 0;
    for (let o = t, l = 0; o < e; ) {
      n[l++] = r[o++], n[l++] = r[o++] - i;
      let d = n[l++] = r[o++] - i;
      n[l++] = r[o++] - t, a = Math.max(a, d);
    }
    return new Xo(n, a, this.set);
  }
}, h(Xo, "lo"), Xo);
m(uM, "TreeBuffer");
let dy = uM;
function AC(s, t, e, i) {
  switch (s) {
    case -2:
      return e < t;
    case -1:
      return i >= t && e < t;
    case 0:
      return e < t && i > t;
    case 1:
      return e <= t && i > t;
    case 2:
      return i > t;
    case 4:
      return !0;
  }
}
h(AC, "cp$1");
m(AC, "checkSide");
function uy(s, t, e, i) {
  for (var r; s.from == s.to || (e < 1 ? s.from >= t : s.from > t) || (e > -1 ? s.to <= t : s.to < t); ) {
    let a = !i && s instanceof br && s.index < 0 ? null : s.parent;
    if (!a)
      return s;
    s = a;
  }
  let n = i ? 0 : Ut.IgnoreOverlays;
  if (i)
    for (let a = s, o = a.parent; o; a = o, o = a.parent)
      a instanceof br && a.index < 0 && ((r = o.enter(t, e, n)) === null || r === void 0 ? void 0 : r.from) != a.from && (s = o);
  for (; ; ) {
    let a = s.enter(t, e, n);
    if (!a)
      return s;
    s = a;
  }
}
h(uy, "rn$1");
m(uy, "resolveNode");
var Id;
const pM = (Id = class {
  cursor(t = 0) {
    return new zO(this, t);
  }
  getChild(t, e = null, i = null) {
    let r = p5(this, t, e, i);
    return r.length ? r[0] : null;
  }
  getChildren(t, e = null, i = null) {
    return p5(this, t, e, i);
  }
  resolve(t, e = 0) {
    return uy(this, t, e, !1);
  }
  resolveInner(t, e = 0) {
    return uy(this, t, e, !0);
  }
  matchContext(t) {
    return LO(this.parent, t);
  }
  enterUnfinishedNodesBefore(t) {
    let e = this.childBefore(t), i = this;
    for (; e; ) {
      let r = e.lastChild;
      if (!r || r.to != e.to)
        break;
      r.type.isError && r.from == r.to ? (i = e, e = r.prevSibling) : e = r;
    }
    return i;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}, h(Id, "Jf"), Id);
m(pM, "BaseNode");
let fM = pM;
var Hs;
const mM = (Hs = class extends fM {
  constructor(t, e, i, r) {
    super(), this._tree = t, this.from = e, this.index = i, this._parent = r;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(t, e, i, r, n = 0) {
    var a;
    for (let o = this; ; ) {
      for (let { children: l, positions: d } = o._tree, u = e > 0 ? l.length : -1; t != u; t += e) {
        let p = l[t], f = d[t] + o.from;
        if (!(!(n & Ut.EnterBracketed && p instanceof Ft && ((a = $h.get(p)) === null || a === void 0 ? void 0 : a.overlay) === null && (f >= i || f + p.length <= i)) && !AC(r, i, f, f + p.length))) {
          if (p instanceof dy) {
            if (n & Ut.ExcludeBuffers)
              continue;
            let y = p.findChild(0, p.buffer.length, e, i - f, r);
            if (y > -1)
              return new _w(new jF(o, p, t, f), null, y);
          } else if (n & Ut.IncludeAnonymous || !p.type.isAnonymous || K0(p)) {
            let y;
            if (!(n & Ut.IgnoreMounts) && (y = $h.get(p)) && !y.overlay)
              return new Hs(y.tree, f, t, o);
            let g = new Hs(p, f, t, o);
            return n & Ut.IncludeAnonymous || !g.type.isAnonymous ? g : g.nextChild(e < 0 ? p.children.length - 1 : 0, e, i, r, n);
          }
        }
      }
      if (n & Ut.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? t = o.index + e : t = e < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.nextChild(
      0,
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  prop(t) {
    return this._tree.prop(t);
  }
  enter(t, e, i = 0) {
    let r;
    if (!(i & Ut.IgnoreOverlays) && (r = $h.get(this._tree)) && r.overlay) {
      let n = t - this.from, a = i & Ut.EnterBracketed && r.bracketed;
      for (let { from: o, to: l } of r.overlay)
        if ((e > 0 || a ? o <= n : o < n) && (e < 0 || a ? l >= n : l > n))
          return new Hs(r.tree, r.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, t, e, i);
  }
  nextSignificantParent() {
    let t = this;
    for (; t.type.isAnonymous && t._parent; )
      t = t._parent;
    return t;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}, h(Hs, "Qi"), Hs);
m(mM, "TreeNode");
let br = mM;
function p5(s, t, e, i) {
  let r = s.cursor(), n = [];
  if (!r.firstChild())
    return n;
  if (e != null) {
    for (let a = !1; !a; )
      if (a = r.type.is(e), !r.nextSibling())
        return n;
  }
  for (; ; ) {
    if (i != null && r.type.is(i))
      return n;
    if (r.type.is(t) && n.push(r.node), !r.nextSibling())
      return i == null ? n : [];
  }
}
h(p5, "Uu$1");
m(p5, "getChildren");
function LO(s, t, e = t.length - 1) {
  for (let i = s; e >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (t[e] && t[e] != i.name)
        return !1;
      e--;
    }
  }
  return !0;
}
h(LO, "ha$1");
m(LO, "matchNodeContext");
var Dd;
const yM = (Dd = class {
  constructor(t, e, i, r) {
    this.parent = t, this.buffer = e, this.index = i, this.start = r;
  }
}, h(Dd, "ec"), Dd);
m(yM, "BufferContext");
let jF = yM;
var as;
const gM = (as = class extends fM {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(t, e, i) {
    super(), this.context = t, this._parent = e, this.index = i, this.type = t.buffer.set.types[t.buffer.buffer[i]];
  }
  child(t, e, i) {
    let { buffer: r } = this.context, n = r.findChild(this.index + 4, r.buffer[this.index + 3], t, e - this.context.start, i);
    return n < 0 ? null : new as(this.context, this, n);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.child(
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.child(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  prop(t) {
    return this.type.prop(t);
  }
  enter(t, e, i = 0) {
    if (i & Ut.ExcludeBuffers)
      return null;
    let { buffer: r } = this.context, n = r.findChild(this.index + 4, r.buffer[this.index + 3], e > 0 ? 1 : -1, t - this.context.start, e);
    return n < 0 ? null : new as(this.context, this, n);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(t) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + t,
      t,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: t } = this.context, e = t.buffer[this.index + 3];
    return e < (this._parent ? t.buffer[this._parent.index + 3] : t.buffer.length) ? new as(this.context, this._parent, e) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: t } = this.context, e = this._parent ? this._parent.index + 4 : 0;
    return this.index == e ? this.externalSibling(-1) : new as(this.context, this._parent, t.findChild(
      e,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let t = [], e = [], { buffer: i } = this.context, r = this.index + 4, n = i.buffer[this.index + 3];
    if (n > r) {
      let a = i.buffer[this.index + 1];
      t.push(i.slice(r, n, a)), e.push(0);
    }
    return new Ft(this.type, t, e, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}, h(as, "Bt"), as);
m(gM, "BufferNode");
let _w = gM;
function RC(s) {
  if (!s.length)
    return null;
  let t = 0, e = s[0];
  for (let n = 1; n < s.length; n++) {
    let a = s[n];
    (a.from > e.from || a.to < e.to) && (e = a, t = n);
  }
  let i = e instanceof br && e.index < 0 ? null : e.parent, r = s.slice();
  return i ? r[t] = i : r.splice(t, 1), new UF(r, e);
}
h(RC, "up$1");
m(RC, "iterStack");
var Vd;
const wM = (Vd = class {
  constructor(t, e) {
    this.heads = t, this.node = e;
  }
  get next() {
    return RC(this.heads);
  }
}, h(Vd, "tc"), Vd);
m(wM, "StackIterator");
let UF = wM;
function vM(s, t, e) {
  let i = s.resolveInner(t, e), r = null;
  for (let n = i instanceof br ? i : i.context.parent; n; n = n.parent)
    if (n.index < 0) {
      let a = n.parent;
      (r || (r = [i])).push(a.resolve(t, e)), n = a;
    } else {
      let a = $h.get(n.tree);
      if (a && a.overlay && a.overlay[0].from <= t && a.overlay[a.overlay.length - 1].to >= t) {
        let o = new br(a.tree, a.overlay[0].from + n.from, -1, n);
        (r || (r = [i])).push(uy(o, t, e, !1));
      }
    }
  return r ? RC(r) : i;
}
h(vM, "W1$1");
m(vM, "stackIterator");
var Wd;
const OM = (Wd = class {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(t, e = 0) {
    if (this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, this.mode = e & ~Ut.EnterBracketed, t instanceof br)
      this.yieldNode(t);
    else {
      this._tree = t.context.parent, this.buffer = t.context;
      for (let i = t._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = t, this.yieldBuf(t.index);
    }
  }
  yieldNode(t) {
    return t ? (this._tree = t, this.type = t.type, this.from = t.from, this.to = t.to, !0) : !1;
  }
  yieldBuf(t, e) {
    this.index = t;
    let { start: i, buffer: r } = this.buffer;
    return this.type = e || r.set.types[r.buffer[t]], this.from = i + r.buffer[t + 1], this.to = i + r.buffer[t + 2], !0;
  }
  /**
  @internal
  */
  yield(t) {
    return t ? t instanceof br ? (this.buffer = null, this.yieldNode(t)) : (this.buffer = t.context, this.yieldBuf(t.index, t.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(t, e, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(t < 0 ? this._tree._tree.children.length - 1 : 0, t, e, i, this.mode));
    let { buffer: r } = this.buffer, n = r.findChild(this.index + 4, r.buffer[this.index + 3], t, e - this.buffer.start, i);
    return n < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(n));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(t) {
    return this.enterChild(
      1,
      t,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(t) {
    return this.enterChild(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(t, e, i = this.mode) {
    return this.buffer ? i & Ut.ExcludeBuffers ? !1 : this.enterChild(1, t, e) : this.yield(this._tree.enter(t, e, i));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Ut.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let t = this.mode & Ut.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(t);
  }
  /**
  @internal
  */
  sibling(t) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + t, t, 0, 4, this.mode)) : !1;
    let { buffer: e } = this.buffer, i = this.stack.length - 1;
    if (t < 0) {
      let r = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != r)
        return this.yieldBuf(e.findChild(
          r,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let r = e.buffer[this.index + 3];
      if (r < (i < 0 ? e.buffer.length : e.buffer[this.stack[i] + 3]))
        return this.yieldBuf(r);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + t, t, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(t) {
    let e, i, { buffer: r } = this;
    if (r) {
      if (t > 0) {
        if (this.index < r.buffer.buffer.length)
          return !1;
      } else
        for (let n = 0; n < this.index; n++)
          if (r.buffer.buffer[n + 3] < this.index)
            return !1;
      ({ index: e, parent: i } = r);
    } else
      ({ index: e, _parent: i } = this._tree);
    for (; i; { index: e, _parent: i } = i)
      if (e > -1)
        for (let n = e + t, a = t < 0 ? -1 : i._tree.children.length; n != a; n += t) {
          let o = i._tree.children[n];
          if (this.mode & Ut.IncludeAnonymous || o instanceof dy || !o.type.isAnonymous || K0(o))
            return !1;
        }
    return !0;
  }
  move(t, e) {
    if (e && this.enterChild(
      t,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(t))
        return !0;
      if (this.atLastNode(t) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(t = !0) {
    return this.move(1, t);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(t = !0) {
    return this.move(-1, t);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(t, e = 0) {
    for (; (this.from == this.to || (e < 1 ? this.from >= t : this.from > t) || (e > -1 ? this.to <= t : this.to < t)) && this.parent(); )
      ;
    for (; this.enterChild(1, t, e); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let t = this.bufferNode, e = null, i = 0;
    if (t && t.context == this.buffer)
      t: for (let r = this.index, n = this.stack.length; n >= 0; ) {
        for (let a = t; a; a = a._parent)
          if (a.index == r) {
            if (r == this.index)
              return a;
            e = a, i = n + 1;
            break t;
          }
        r = this.stack[--n];
      }
    for (let r = i; r < this.stack.length; r++)
      e = new _w(this.buffer, e, this.stack[r]);
    return this.bufferNode = new _w(this.buffer, e, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(t, e) {
    for (let i = 0; ; ) {
      let r = !1;
      if (this.type.isAnonymous || t(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (r = !0);
      }
      for (; ; ) {
        if (r && e && e(this), r = this.type.isAnonymous, !i)
          return;
        if (this.nextSibling())
          break;
        this.parent(), i--, r = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(t) {
    if (!this.buffer)
      return LO(this.node.parent, t);
    let { buffer: e } = this.buffer, { types: i } = e.set;
    for (let r = t.length - 1, n = this.stack.length - 1; r >= 0; n--) {
      if (n < 0)
        return LO(this._tree, t, r);
      let a = i[e.buffer[this.stack[n]]];
      if (!a.isAnonymous) {
        if (t[r] && t[r] != a.name)
          return !1;
        r--;
      }
    }
    return !0;
  }
}, h(Wd, "ic"), Wd);
m(OM, "TreeCursor");
let zO = OM;
function K0(s) {
  return s.children.some((t) => t instanceof dy || !t.type.isAnonymous || K0(t));
}
h(K0, "bh$1");
m(K0, "hasChild");
function bM(s) {
  var t;
  let { buffer: e, nodeSet: i, maxBufferLength: r = sM, reused: n = [], minRepeatType: a = i.types.length } = s, o = Array.isArray(e) ? new XF(e, e.length) : e, l = i.types, d = 0, u = 0;
  function p(A, z, V, X, tt, vt) {
    let { id: dt, start: st, end: Pt, size: ct } = o, Vt = u, _t = d;
    if (ct < 0)
      if (o.next(), ct == -1) {
        let qe = n[dt];
        V.push(qe), X.push(st - A);
        return;
      } else if (ct == -3) {
        d = dt;
        return;
      } else if (ct == -4) {
        u = dt;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${ct}`);
    let Zt = l[dt], Nt, Xt, Li = st - A;
    if (Pt - st <= r && (Xt = k(o.pos - z, tt))) {
      let qe = new Uint16Array(Xt.size - Xt.skip), fe = o.pos - Xt.size, oe = qe.length;
      for (; o.pos > fe; )
        oe = $(Xt.start, qe, oe);
      Nt = new dy(qe, Pt - Xt.start, i), Li = Xt.start - A;
    } else {
      let qe = o.pos - ct;
      o.next();
      let fe = [], oe = [], be = dt >= a ? dt : -1, zi = 0, Yi = Pt;
      for (; o.pos > qe; )
        be >= 0 && o.id == be && o.size >= 0 ? (o.end <= Yi - r && (g(fe, oe, st, zi, o.end, Yi, be, Vt, _t), zi = fe.length, Yi = o.end), o.next()) : vt > 2500 ? f(st, qe, fe, oe) : p(st, qe, fe, oe, be, vt + 1);
      if (be >= 0 && zi > 0 && zi < fe.length && g(fe, oe, st, zi, st, Yi, be, Vt, _t), fe.reverse(), oe.reverse(), be > -1 && zi > 0) {
        let pr = y(Zt, _t);
        Nt = J0(Zt, fe, oe, 0, fe.length, 0, Pt - st, pr, pr);
      } else
        Nt = O(Zt, fe, oe, Pt - st, Vt - Pt, _t);
    }
    V.push(Nt), X.push(Li);
  }
  h(p, "u"), m(p, "takeNode");
  function f(A, z, V, X) {
    let tt = [], vt = 0, dt = -1;
    for (; o.pos > z; ) {
      let { id: st, start: Pt, end: ct, size: Vt } = o;
      if (Vt > 4)
        o.next();
      else {
        if (dt > -1 && Pt < dt)
          break;
        dt < 0 && (dt = ct - r), tt.push(st, Pt, ct), vt++, o.next();
      }
    }
    if (vt) {
      let st = new Uint16Array(vt * 4), Pt = tt[tt.length - 2];
      for (let ct = tt.length - 3, Vt = 0; ct >= 0; ct -= 3)
        st[Vt++] = tt[ct], st[Vt++] = tt[ct + 1] - Pt, st[Vt++] = tt[ct + 2] - Pt, st[Vt++] = Vt;
      V.push(new dy(st, tt[2] - Pt, i)), X.push(Pt - A);
    }
  }
  h(f, "O"), m(f, "takeFlatNode");
  function y(A, z) {
    return (V, X, tt) => {
      let vt = 0, dt = V.length - 1, st, Pt;
      if (dt >= 0 && (st = V[dt]) instanceof Ft) {
        if (!dt && st.type == A && st.length == tt)
          return st;
        (Pt = st.prop(Et.lookAhead)) && (vt = X[dt] + st.length + Pt);
      }
      return O(A, V, X, tt, vt, z);
    };
  }
  h(y, "d"), m(y, "makeBalanced");
  function g(A, z, V, X, tt, vt, dt, st, Pt) {
    let ct = [], Vt = [];
    for (; A.length > X; )
      ct.push(A.pop()), Vt.push(z.pop() + V - tt);
    A.push(O(i.types[dt], ct, Vt, vt - tt, st - vt, Pt)), z.push(tt - V);
  }
  h(g, "p"), m(g, "makeRepeatLeaf");
  function O(A, z, V, X, tt, vt, dt) {
    if (vt) {
      let st = [Et.contextHash, vt];
      dt = dt ? [st].concat(dt) : [st];
    }
    if (tt > 25) {
      let st = [Et.lookAhead, tt];
      dt = dt ? [st].concat(dt) : [st];
    }
    return new Ft(A, z, V, X, dt);
  }
  h(O, "m"), m(O, "makeTree");
  function k(A, z) {
    let V = o.fork(), X = 0, tt = 0, vt = 0, dt = V.end - r, st = { size: 0, start: 0, skip: 0 };
    t: for (let Pt = V.pos - A; V.pos > Pt; ) {
      let ct = V.size;
      if (V.id == z && ct >= 0) {
        st.size = X, st.start = tt, st.skip = vt, vt += 4, X += 4, V.next();
        continue;
      }
      let Vt = V.pos - ct;
      if (ct < 0 || Vt < Pt || V.start < dt)
        break;
      let _t = V.id >= a ? 4 : 0, Zt = V.start;
      for (V.next(); V.pos > Vt; ) {
        if (V.size < 0)
          if (V.size == -3 || V.size == -4)
            _t += 4;
          else
            break t;
        else V.id >= a && (_t += 4);
        V.next();
      }
      tt = Zt, X += ct, vt += _t;
    }
    return (z < 0 || X == A) && (st.size = X, st.start = tt, st.skip = vt), st.size > 4 ? st : void 0;
  }
  h(k, "Q"), m(k, "findBufferSize");
  function $(A, z, V) {
    let { id: X, start: tt, end: vt, size: dt } = o;
    if (o.next(), dt >= 0 && X < a) {
      let st = V;
      if (dt > 4) {
        let Pt = o.pos - (dt - 4);
        for (; o.pos > Pt; )
          V = $(A, z, V);
      }
      z[--V] = st, z[--V] = vt - A, z[--V] = tt - A, z[--V] = X;
    } else dt == -3 ? d = X : dt == -4 && (u = X);
    return V;
  }
  h($, "y"), m($, "copyToBuffer");
  let T = [], _ = [];
  for (; o.pos > 0; )
    p(s.start || 0, s.bufferStart || 0, T, _, -1, 0);
  let D = (t = s.length) !== null && t !== void 0 ? t : T.length ? _[0] + T[0].length : 0;
  return new Ft(l[s.topID], T.reverse(), _.reverse(), D);
}
h(bM, "V1$1");
m(bM, "buildTree");
const fQ = /* @__PURE__ */ new WeakMap();
function vw(s, t) {
  if (!s.isAnonymous || t instanceof dy || t.type != s)
    return 1;
  let e = fQ.get(t);
  if (e == null) {
    e = 1;
    for (let i of t.children) {
      if (i.type != s || !(i instanceof Ft)) {
        e = 1;
        break;
      }
      e += vw(s, i);
    }
    fQ.set(t, e);
  }
  return e;
}
h(vw, "Dn$1");
m(vw, "nodeSize");
function J0(s, t, e, i, r, n, a, o, l) {
  let d = 0;
  for (let g = i; g < r; g++)
    d += vw(s, t[g]);
  let u = Math.ceil(
    d * 1.5 / 8
    /* Balance.BranchFactor */
  ), p = [], f = [];
  function y(g, O, k, $, T) {
    for (let _ = k; _ < $; ) {
      let D = _, A = O[_], z = vw(s, g[_]);
      for (_++; _ < $; _++) {
        let V = vw(s, g[_]);
        if (z + V >= u)
          break;
        z += V;
      }
      if (_ == D + 1) {
        if (z > u) {
          let V = g[D];
          y(V.children, V.positions, 0, V.children.length, O[D] + T);
          continue;
        }
        p.push(g[D]);
      } else {
        let V = O[_ - 1] + g[_ - 1].length - A;
        p.push(J0(s, g, O, D, _, A, V, null, l));
      }
      f.push(A + T - n);
    }
  }
  return h(y, "d"), m(y, "divide"), y(t, e, i, r, 0), (o || l)(p, f, a);
}
h(J0, "wh$1");
m(J0, "balanceRange");
var Fd;
const $M = (Fd = class {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(t, e, i) {
    let r = this.map.get(t);
    r || this.map.set(t, r = /* @__PURE__ */ new Map()), r.set(e, i);
  }
  getBuffer(t, e) {
    let i = this.map.get(t);
    return i && i.get(e);
  }
  /**
  Set the value for this syntax node.
  */
  set(t, e) {
    t instanceof _w ? this.setBuffer(t.context.buffer, t.index, e) : t instanceof br && this.map.set(t.tree, e);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(t) {
    return t instanceof _w ? this.getBuffer(t.context.buffer, t.index) : t instanceof br ? this.map.get(t.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(t, e) {
    t.buffer ? this.setBuffer(t.buffer.buffer, t.index, e) : this.map.set(t.tree, e);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(t) {
    return t.buffer ? this.getBuffer(t.buffer.buffer, t.index) : this.map.get(t.tree);
  }
}, h(Fd, "rc"), Fd);
m($M, "NodeWeakMap");
let xM = $M;
var ea;
const kM = (ea = class {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(t, e, i, r, n = !1, a = !1) {
    this.from = t, this.to = e, this.tree = i, this.offset = r, this.open = (n ? 1 : 0) | (a ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(t, e = [], i = !1) {
    let r = [new ea(0, t.length, t, 0, !1, i)];
    for (let n of e)
      n.to > t.length && r.push(n);
    return r;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(t, e, i = 128) {
    if (!e.length)
      return t;
    let r = [], n = 1, a = t.length ? t[0] : null;
    for (let o = 0, l = 0, d = 0; ; o++) {
      let u = o < e.length ? e[o] : null, p = u ? u.fromA : 1e9;
      if (p - l >= i)
        for (; a && a.from < p; ) {
          let f = a;
          if (l >= f.from || p <= f.to || d) {
            let y = Math.max(f.from, l) - d, g = Math.min(f.to, p) - d;
            f = y >= g ? null : new ea(y, g, f.tree, f.offset + d, o > 0, !!u);
          }
          if (f && r.push(f), a.to > p)
            break;
          a = n < t.length ? t[n++] : null;
        }
      if (!u)
        break;
      l = u.toA, d = u.toA - u.toB;
    }
    return r;
  }
}, h(ea, "Yr"), ea);
m(kM, "TreeFragment");
let xh = kM;
var qd;
const SM = (qd = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(t, e, i) {
    return typeof t == "string" && (t = new HF(t)), i = i ? i.length ? i.map((r) => new gr(r.from, r.to)) : [new gr(0, 0)] : [new gr(0, t.length)], this.createParse(t, e || [], i);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(t, e, i) {
    let r = this.startParse(t, e, i);
    for (; ; ) {
      let n = r.advance();
      if (n)
        return n;
    }
  }
}, h(qd, "nc"), qd);
m(SM, "Parser");
let tb = SM;
var Zd;
const CM = (Zd = class {
  constructor(t) {
    this.string = t;
  }
  get length() {
    return this.string.length;
  }
  chunk(t) {
    return this.string.slice(t);
  }
  get lineChunks() {
    return !1;
  }
  read(t, e) {
    return this.string.slice(t, e);
  }
}, h(Zd, "sc"), Zd);
m(CM, "StringInput");
let HF = CM;
function EC(s) {
  return (t, e, i, r) => new GF(t, s, e, i, r);
}
h(EC, "Op$1");
m(EC, "parseMixed");
var Bd;
const PM = (Bd = class {
  constructor(t, e, i, r, n, a) {
    this.parser = t, this.parse = e, this.overlay = i, this.bracketed = r, this.target = n, this.from = a;
  }
}, h(Bd, "oc"), Bd);
m(PM, "InnerParse");
let mQ = PM;
function f5(s) {
  if (!s.length || s.some((t) => t.from >= t.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(s));
}
h(f5, "zu$1");
m(f5, "checkRanges");
var Nd;
const QM = (Nd = class {
  constructor(t, e, i, r, n, a, o, l) {
    this.parser = t, this.predicate = e, this.mounts = i, this.index = r, this.start = n, this.bracketed = a, this.target = o, this.prev = l, this.depth = 0, this.ranges = [];
  }
}, h(Nd, "lc"), Nd);
m(QM, "ActiveOverlay");
let YF = QM;
const m5 = new Et({ perNode: !0 });
var Xd;
const TM = (Xd = class {
  constructor(t, e, i, r, n) {
    this.nest = e, this.input = i, this.fragments = r, this.ranges = n, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = t;
  }
  advance() {
    if (this.baseParse) {
      let i = this.baseParse.advance();
      if (!i)
        return null;
      if (this.baseParse = null, this.baseTree = i, this.startInner(), this.stoppedAt != null)
        for (let r of this.inner)
          r.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let i = this.baseTree;
      return this.stoppedAt != null && (i = new Ft(i.type, i.children, i.positions, i.length, i.propValues.concat([[m5, this.stoppedAt]]))), i;
    }
    let t = this.inner[this.innerDone], e = t.parse.advance();
    if (e) {
      this.innerDone++;
      let i = Object.assign(/* @__PURE__ */ Object.create(null), t.target.props);
      i[Et.mounted.id] = new $h(e, t.overlay, t.parser, t.bracketed), t.target.props = i;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let t = this.input.length;
    for (let e = this.innerDone; e < this.inner.length; e++)
      this.inner[e].from < t && (t = Math.min(t, this.inner[e].parse.parsedPos));
    return t;
  }
  stopAt(t) {
    if (this.stoppedAt = t, this.baseParse)
      this.baseParse.stopAt(t);
    else
      for (let e = this.innerDone; e < this.inner.length; e++)
        this.inner[e].parse.stopAt(t);
  }
  startInner() {
    let t = new KF(this.fragments), e = null, i = null, r = new zO(new br(this.baseTree, this.ranges[0].from, 0, null), Ut.IncludeAnonymous | Ut.IgnoreMounts);
    t: for (let n, a; ; ) {
      let o = !0, l;
      if (this.stoppedAt != null && r.from >= this.stoppedAt)
        o = !1;
      else if (t.hasNode(r)) {
        if (e) {
          let d = e.mounts.find((u) => u.frag.from <= r.from && u.frag.to >= r.to && u.mount.overlay);
          if (d)
            for (let u of d.mount.overlay) {
              let p = u.from + d.pos, f = u.to + d.pos;
              p >= r.from && f <= r.to && !e.ranges.some((y) => y.from < f && y.to > p) && e.ranges.push({ from: p, to: f });
            }
        }
        o = !1;
      } else if (i && (a = MM(i.ranges, r.from, r.to)))
        o = a != 2;
      else if (!r.type.isAnonymous && (n = this.nest(r, this.input)) && (r.from < r.to || !n.overlay)) {
        r.tree || (AM(r), e && e.depth++, i && i.depth++);
        let d = t.findMounts(r.from, n.parser);
        if (typeof n.overlay == "function")
          e = new YF(n.parser, n.overlay, d, this.inner.length, r.from, !!n.bracketed, r.tree, e);
        else {
          let u = g5(this.ranges, n.overlay || (r.from < r.to ? [new gr(r.from, r.to)] : []));
          u.length && f5(u), (u.length || !n.overlay) && this.inner.push(new mQ(n.parser, u.length ? n.parser.startParse(this.input, w5(d, u), u) : n.parser.startParse(""), n.overlay ? n.overlay.map((p) => new gr(p.from - r.from, p.to - r.from)) : null, !!n.bracketed, r.tree, u.length ? u[0].from : r.from)), n.overlay ? u.length && (i = { ranges: u, depth: 0, prev: i }) : o = !1;
        }
      } else if (e && (l = e.predicate(r)) && (l === !0 && (l = new gr(r.from, r.to)), l.from < l.to)) {
        let d = e.ranges.length - 1;
        d >= 0 && e.ranges[d].to == l.from ? e.ranges[d] = { from: e.ranges[d].from, to: l.to } : e.ranges.push(l);
      }
      if (o && r.firstChild())
        e && e.depth++, i && i.depth++;
      else
        for (; !r.nextSibling(); ) {
          if (!r.parent())
            break t;
          if (e && !--e.depth) {
            let d = g5(this.ranges, e.ranges);
            d.length && (f5(d), this.inner.splice(e.index, 0, new mQ(e.parser, e.parser.startParse(this.input, w5(e.mounts, d), d), e.ranges.map((u) => new gr(u.from - e.start, u.to - e.start)), e.bracketed, e.target, d[0].from))), e = e.prev;
          }
          i && !--i.depth && (i = i.prev);
        }
    }
  }
}, h(Xd, "ac"), Xd);
m(TM, "MixedParse");
let GF = TM;
function MM(s, t, e) {
  for (let i of s) {
    if (i.from >= e)
      break;
    if (i.to > t)
      return i.from <= t && i.to >= e ? 2 : 1;
  }
  return 0;
}
h(MM, "U1$1");
m(MM, "checkCover");
function y5(s, t, e, i, r, n) {
  if (t < e) {
    let a = s.buffer[t + 1];
    i.push(s.slice(t, e, a)), r.push(a - n);
  }
}
h(y5, "ju$1");
m(y5, "sliceBuf");
function AM(s) {
  let { node: t } = s, e = [], i = t.context.buffer;
  do
    e.push(s.index), s.parent();
  while (!s.tree);
  let r = s.tree, n = r.children.indexOf(i), a = r.children[n], o = a.buffer, l = [n];
  function d(u, p, f, y, g, O) {
    let k = e[O], $ = [], T = [];
    y5(a, u, k, $, T, y);
    let _ = o[k + 1], D = o[k + 2];
    l.push($.length);
    let A = O ? d(k + 4, o[k + 3], a.set.types[o[k]], _, D - _, O - 1) : t.toTree();
    return $.push(A), T.push(_ - y), y5(a, o[k + 3], p, $, T, y), new Ft(f, $, T, g);
  }
  h(d, "h"), m(d, "split"), r.children[n] = d(0, o.length, ei.none, 0, a.length, e.length - 1);
  for (let u of l) {
    let p = s.tree.children[u], f = s.tree.positions[u];
    s.yield(new br(p, f + s.from, u, s._tree));
  }
}
h(AM, "I1$1");
m(AM, "materialize");
var jd;
const RM = (jd = class {
  constructor(t, e) {
    this.offset = e, this.done = !1, this.cursor = t.cursor(Ut.IncludeAnonymous | Ut.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(t) {
    let { cursor: e } = this, i = t - this.offset;
    for (; !this.done && e.from < i; )
      e.to >= t && e.enter(i, 1, Ut.IgnoreOverlays | Ut.ExcludeBuffers) || e.next(!1) || (this.done = !0);
  }
  hasNode(t) {
    if (this.moveTo(t.from), !this.done && this.cursor.from + this.offset == t.from && this.cursor.tree)
      for (let e = this.cursor.tree; ; ) {
        if (e == t.tree)
          return !0;
        if (e.children.length && e.positions[0] == 0 && e.children[0] instanceof Ft)
          e = e.children[0];
        else
          break;
      }
    return !1;
  }
}, h(jd, "hc"), jd);
m(RM, "StructureCursor");
let yQ = RM;
var $2, Ud;
let KF = ($2 = (Ud = class {
  constructor(t) {
    var e;
    if (this.fragments = t, this.curTo = 0, this.fragI = 0, t.length) {
      let i = this.curFrag = t[0];
      this.curTo = (e = i.tree.prop(m5)) !== null && e !== void 0 ? e : i.to, this.inner = new yQ(i.tree, -i.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(t) {
    for (; this.curFrag && t.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= t.from && this.curTo >= t.to && this.inner.hasNode(t);
  }
  nextFrag() {
    var t;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let e = this.curFrag = this.fragments[this.fragI];
      this.curTo = (t = e.tree.prop(m5)) !== null && t !== void 0 ? t : e.to, this.inner = new yQ(e.tree, -e.offset);
    }
  }
  findMounts(t, e) {
    var i;
    let r = [];
    if (this.inner) {
      this.inner.cursor.moveTo(t, 1);
      for (let n = this.inner.cursor.node; n; n = n.parent) {
        let a = (i = n.tree) === null || i === void 0 ? void 0 : i.prop(Et.mounted);
        if (a && a.parser == e)
          for (let o = this.fragI; o < this.fragments.length; o++) {
            let l = this.fragments[o];
            if (l.from >= n.to)
              break;
            l.tree == this.curFrag.tree && r.push({
              frag: l,
              pos: n.from - l.offset,
              mount: a
            });
          }
      }
    }
    return r;
  }
}, h(Ud, "vi$1"), Ud), m($2, "FragmentCursor"), $2);
function g5(s, t) {
  let e = null, i = t;
  for (let r = 1, n = 0; r < s.length; r++) {
    let a = s[r - 1].to, o = s[r].from;
    for (; n < i.length; n++) {
      let l = i[n];
      if (l.from >= o)
        break;
      l.to <= a || (e || (i = e = t.slice()), l.from < a ? (e[n] = new gr(l.from, a), l.to > o && e.splice(n + 1, 0, new gr(o, l.to))) : l.to > o ? e[n--] = new gr(o, l.to) : e.splice(n--, 1));
    }
  }
  return i;
}
h(g5, "qu$1");
m(g5, "punchRanges");
function EM(s, t, e, i) {
  let r = 0, n = 0, a = !1, o = !1, l = -1e9, d = [];
  for (; ; ) {
    let u = r == s.length ? 1e9 : a ? s[r].to : s[r].from, p = n == t.length ? 1e9 : o ? t[n].to : t[n].from;
    if (a != o) {
      let f = Math.max(l, e), y = Math.min(u, p, i);
      f < y && d.push(new gr(f, y));
    }
    if (l = Math.min(u, p), l == 1e9)
      break;
    u == l && (a ? (a = !1, r++) : a = !0), p == l && (o ? (o = !1, n++) : o = !0);
  }
  return d;
}
h(EM, "j1$1");
m(EM, "findCoverChanges");
function w5(s, t) {
  let e = [];
  for (let { pos: i, mount: r, frag: n } of s) {
    let a = i + (r.overlay ? r.overlay[0].from : 0), o = a + r.tree.length, l = Math.max(n.from, a), d = Math.min(n.to, o);
    if (r.overlay) {
      let u = r.overlay.map((f) => new gr(f.from + i, f.to + i)), p = EM(t, u, l, d);
      for (let f = 0, y = l; ; f++) {
        let g = f == p.length, O = g ? d : p[f].from;
        if (O > y && e.push(new xh(y, O, r.tree, -a, n.from >= y || n.openStart, n.to <= O || n.openEnd)), g)
          break;
        y = p[f].to;
      }
    } else
      e.push(new xh(l, d, r.tree, -a, n.from >= a || n.openStart, n.to <= o || n.openEnd));
  }
  return e;
}
h(w5, "Bu$1");
m(w5, "enterFragments");
let JF = 0;
var ia;
const _M = (ia = class {
  /**
  @internal
  */
  constructor(t, e, i, r) {
    this.name = t, this.set = e, this.base = i, this.modified = r, this.id = JF++;
  }
  toString() {
    let { name: t } = this;
    for (let e of this.modified)
      e.name && (t = `${e.name}(${t})`);
    return t;
  }
  static define(t, e) {
    let i = typeof t == "string" ? t : "?";
    if (t instanceof ia && (e = t), e?.base)
      throw new Error("Can not derive from a modified tag");
    let r = new ia(i, [], null, []);
    if (r.set.push(r), e)
      for (let n of e.set)
        r.set.push(n);
    return r;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(t) {
    let e = new gQ(t);
    return (i) => i.modified.indexOf(e) > -1 ? i : gQ.get(i.base || i, i.modified.concat(e).sort((r, n) => r.id - n.id));
  }
}, h(ia, "Wr"), ia);
m(_M, "Tag");
let is = _M, tq = 0;
var jo;
const LM = (jo = class {
  constructor(t) {
    this.name = t, this.instances = [], this.id = tq++;
  }
  static get(t, e) {
    if (!e.length)
      return t;
    let i = e[0].instances.find((o) => o.base == t && zM(e, o.modified));
    if (i)
      return i;
    let r = [], n = new is(t.name, r, t, e);
    for (let o of e)
      o.instances.push(n);
    let a = IM(e);
    for (let o of t.set)
      if (!o.modified.length)
        for (let l of a)
          r.push(jo.get(o, l));
    return n;
  }
}, h(jo, "ao"), jo);
m(LM, "Modifier");
let gQ = LM;
function zM(s, t) {
  return s.length == t.length && s.every((e, i) => e == t[i]);
}
h(zM, "D1$1");
m(zM, "sameArray");
function IM(s) {
  let t = [[]];
  for (let e = 0; e < s.length; e++)
    for (let i = 0, r = t.length; i < r; i++)
      t.push(t[i].concat(s[e]));
  return t.sort((e, i) => i.length - e.length);
}
h(IM, "N1$1");
m(IM, "powerSet");
function Il(s) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let e in s) {
    let i = s[e];
    Array.isArray(i) || (i = [i]);
    for (let r of e.split(" "))
      if (r) {
        let n = [], a = 2, o = r;
        for (let p = 0; ; ) {
          if (o == "..." && p > 0 && p + 3 == r.length) {
            a = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(o);
          if (!f)
            throw new RangeError("Invalid path: " + r);
          if (n.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), p += f[0].length, p == r.length)
            break;
          let y = r[p++];
          if (p == r.length && y == "!") {
            a = 0;
            break;
          }
          if (y != "/")
            throw new RangeError("Invalid path: " + r);
          o = r.slice(p);
        }
        let l = n.length - 1, d = n[l];
        if (!d)
          throw new RangeError("Invalid path: " + r);
        let u = new Lw(i, a, l > 0 ? n.slice(0, l) : null);
        t[d] = u.sort(t[d]);
      }
  }
  return DM.add(t);
}
h(Il, "er$1");
m(Il, "styleTags");
const DM = new Et({
  combine(s, t) {
    let e, i, r;
    for (; s || t; ) {
      if (!s || t && s.depth >= t.depth ? (r = t, t = t.next) : (r = s, s = s.next), e && e.mode == r.mode && !r.context && !e.context)
        continue;
      let n = new Lw(r.tags, r.mode, r.context);
      e ? e.next = n : i = n, e = n;
    }
    return i;
  }
});
var x2, Hd;
let Lw = (x2 = (Hd = class {
  constructor(t, e, i, r) {
    this.tags = t, this.mode = e, this.context = i, this.next = r;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(t) {
    return !t || t.depth < this.depth ? (this.next = t, this) : (t.next = this.sort(t.next), t);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}, h(Hd, "Ti$1"), Hd), m(x2, "Rule"), x2);
Lw.empty = new Lw([], 2, null);
function _C(s, t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n of s)
    if (!Array.isArray(n.tag))
      e[n.tag.id] = n.class;
    else
      for (let a of n.tag)
        e[a.id] = n.class;
  let { scope: i, all: r = null } = t || {};
  return {
    style: /* @__PURE__ */ m((n) => {
      let a = r;
      for (let o of n)
        for (let l of o.set) {
          let d = e[l.id];
          if (d) {
            a = a ? a + " " + d : d;
            break;
          }
        }
      return a;
    }, "style"),
    scope: i
  };
}
h(_C, "pp$1");
m(_C, "tagHighlighter");
function VM(s, t) {
  let e = null;
  for (let i of s) {
    let r = i.style(t);
    r && (e = e ? e + " " + r : r);
  }
  return e;
}
h(VM, "G1$1");
m(VM, "highlightTags");
function WM(s, t, e, i = 0, r = s.length) {
  let n = new eq(i, Array.isArray(t) ? t : [t], e);
  n.highlightRange(s.cursor(), i, r, "", n.highlighters), n.flush(r);
}
h(WM, "F1$1");
m(WM, "highlightTree");
var Yd;
const FM = (Yd = class {
  constructor(t, e, i) {
    this.at = t, this.highlighters = e, this.span = i, this.class = "";
  }
  startSpan(t, e) {
    e != this.class && (this.flush(t), t > this.at && (this.at = t), this.class = e);
  }
  flush(t) {
    t > this.at && this.class && this.span(this.at, t, this.class);
  }
  highlightRange(t, e, i, r, n) {
    let { type: a, from: o, to: l } = t;
    if (o >= i || l <= e)
      return;
    a.isTop && (n = this.highlighters.filter((y) => !y.scope || y.scope(a)));
    let d = r, u = qM(t) || Lw.empty, p = VM(n, u.tags);
    if (p && (d && (d += " "), d += p, u.mode == 1 && (r += (r ? " " : "") + p)), this.startSpan(Math.max(e, o), d), u.opaque)
      return;
    let f = t.tree && t.tree.prop(Et.mounted);
    if (f && f.overlay) {
      let y = t.node.enter(f.overlay[0].from + o, 1), g = this.highlighters.filter((k) => !k.scope || k.scope(f.tree.type)), O = t.firstChild();
      for (let k = 0, $ = o; ; k++) {
        let T = k < f.overlay.length ? f.overlay[k] : null, _ = T ? T.from + o : l, D = Math.max(e, $), A = Math.min(i, _);
        if (D < A && O)
          for (; t.from < A && (this.highlightRange(t, D, A, r, n), this.startSpan(Math.min(A, t.to), d), !(t.to >= _ || !t.nextSibling())); )
            ;
        if (!T || _ > i)
          break;
        $ = T.to + o, $ > e && (this.highlightRange(y.cursor(), Math.max(e, T.from + o), Math.min(i, $), "", g), this.startSpan(Math.min(i, $), d));
      }
      O && t.parent();
    } else if (t.firstChild()) {
      f && (r = "");
      do
        if (!(t.to <= e)) {
          if (t.from >= i)
            break;
          this.highlightRange(t, e, i, r, n), this.startSpan(Math.min(i, t.to), d);
        }
      while (t.nextSibling());
      t.parent();
    }
  }
}, h(Yd, "fc"), Yd);
m(FM, "HighlightBuilder");
let eq = FM;
function qM(s) {
  let t = s.type.prop(DM);
  for (; t && t.context && !s.matchContext(t.context); )
    t = t.next;
  return t || null;
}
h(qM, "H1$1");
m(qM, "getStyleTags");
const et = is.define, av = et(), En = et(), wQ = et(En), vQ = et(En), _n = et(), ov = et(_n), k2 = et(_n), Kr = et(), Fa = et(Kr), Ur = et(), Hr = et(), v5 = et(), ig = et(v5), lv = et(), Q = {
  /**
  A comment.
  */
  comment: av,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: et(av),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: et(av),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: et(av),
  /**
  Any kind of identifier.
  */
  name: En,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: et(En),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: wQ,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: et(wQ),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: vQ,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: et(vQ),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: et(En),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: et(En),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: et(En),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: et(En),
  /**
  A literal value.
  */
  literal: _n,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: ov,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: et(ov),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: et(ov),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: et(ov),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: k2,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: et(k2),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: et(k2),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: et(_n),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: et(_n),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: et(_n),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: et(_n),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: et(_n),
  /**
  A language keyword.
  */
  keyword: Ur,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: et(Ur),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: et(Ur),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: et(Ur),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: et(Ur),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: et(Ur),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: et(Ur),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: et(Ur),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: et(Ur),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: et(Ur),
  /**
  An operator.
  */
  operator: Hr,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: et(Hr),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: et(Hr),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: et(Hr),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: et(Hr),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: et(Hr),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: et(Hr),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: et(Hr),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: et(Hr),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: et(Hr),
  /**
  Program or markup punctuation.
  */
  punctuation: v5,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: et(v5),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: ig,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: et(ig),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: et(ig),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: et(ig),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: et(ig),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Kr,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Fa,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: et(Fa),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: et(Fa),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: et(Fa),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: et(Fa),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: et(Fa),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: et(Fa),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: et(Kr),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: et(Kr),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: et(Kr),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: et(Kr),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: et(Kr),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: et(Kr),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: et(Kr),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: et(Kr),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: et(),
  /**
  Deleted text.
  */
  deleted: et(),
  /**
  Changed text.
  */
  changed: et(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: et(),
  /**
  Metadata or meta-instruction.
  */
  meta: lv,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: et(lv),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: et(lv),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: et(lv),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: is.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: is.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: is.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: is.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: is.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: is.defineModifier("special")
};
for (let s in Q) {
  let t = Q[s];
  t instanceof is && (t.name = s);
}
_C([
  { tag: Q.link, class: "tok-link" },
  { tag: Q.heading, class: "tok-heading" },
  { tag: Q.emphasis, class: "tok-emphasis" },
  { tag: Q.strong, class: "tok-strong" },
  { tag: Q.keyword, class: "tok-keyword" },
  { tag: Q.atom, class: "tok-atom" },
  { tag: Q.bool, class: "tok-bool" },
  { tag: Q.url, class: "tok-url" },
  { tag: Q.labelName, class: "tok-labelName" },
  { tag: Q.inserted, class: "tok-inserted" },
  { tag: Q.deleted, class: "tok-deleted" },
  { tag: Q.literal, class: "tok-literal" },
  { tag: Q.string, class: "tok-string" },
  { tag: Q.number, class: "tok-number" },
  { tag: [Q.regexp, Q.escape, Q.special(Q.string)], class: "tok-string2" },
  { tag: Q.variableName, class: "tok-variableName" },
  { tag: Q.local(Q.variableName), class: "tok-variableName tok-local" },
  { tag: Q.definition(Q.variableName), class: "tok-variableName tok-definition" },
  { tag: Q.special(Q.variableName), class: "tok-variableName2" },
  { tag: Q.definition(Q.propertyName), class: "tok-propertyName tok-definition" },
  { tag: Q.typeName, class: "tok-typeName" },
  { tag: Q.namespace, class: "tok-namespace" },
  { tag: Q.className, class: "tok-className" },
  { tag: Q.macroName, class: "tok-macroName" },
  { tag: Q.propertyName, class: "tok-propertyName" },
  { tag: Q.operator, class: "tok-operator" },
  { tag: Q.comment, class: "tok-comment" },
  { tag: Q.meta, class: "tok-meta" },
  { tag: Q.invalid, class: "tok-invalid" },
  { tag: Q.punctuation, class: "tok-punctuation" }
]);
var S2;
const Vn = /* @__PURE__ */ new Et();
function O1(s) {
  return Ct.define({
    combine: s ? (t) => t.concat(s) : void 0
  });
}
h(O1, "wo$1");
m(O1, "defineLanguageFacet");
const LC = /* @__PURE__ */ new Et();
var Gd;
const ZM = (Gd = class {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(t, e, i = [], r = "") {
    this.data = t, this.name = r, Be.prototype.hasOwnProperty("tree") || Object.defineProperty(Be.prototype, "tree", { get() {
      return de(this);
    } }), this.parser = e, this.extension = [
      py.of(this),
      Be.languageData.of((n, a, o) => {
        let l = O5(n, a, o), d = l.type.prop(Vn);
        if (!d)
          return [];
        let u = n.facet(d), p = l.type.prop(LC);
        if (p) {
          let f = l.resolve(a - l.from, o);
          for (let y of p)
            if (y.test(f, n)) {
              let g = n.facet(y.facet);
              return y.type == "replace" ? g : g.concat(u);
            }
        }
        return u;
      })
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(t, e, i = -1) {
    return O5(t, e, i).type.prop(Vn) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(t) {
    let e = t.facet(py);
    if (e?.data == this.data)
      return [{ from: 0, to: t.doc.length }];
    if (!e || !e.allowsNesting)
      return [];
    let i = [], r = /* @__PURE__ */ m((n, a) => {
      if (n.prop(Vn) == this.data) {
        i.push({ from: a, to: a + n.length });
        return;
      }
      let o = n.prop(Et.mounted);
      if (o) {
        if (o.tree.prop(Vn) == this.data) {
          if (o.overlay)
            for (let l of o.overlay)
              i.push({ from: l.from + a, to: l.to + a });
          else
            i.push({ from: a, to: a + n.length });
          return;
        } else if (o.overlay) {
          let l = i.length;
          if (r(o.tree, o.overlay[0].from + a), i.length > l)
            return;
        }
      }
      for (let l = 0; l < n.children.length; l++) {
        let d = n.children[l];
        d instanceof Ft && r(d, n.positions[l] + a);
      }
    }, "explore");
    return r(de(t), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}, h(Gd, "cc"), Gd);
m(ZM, "Language");
let ar = ZM;
ar.setState = /* @__PURE__ */ te.define();
function O5(s, t, e) {
  let i = s.facet(py), r = de(s).topNode;
  if (!i || i.allowsNesting)
    for (let n = r; n; n = n.enter(t, e, Ut.ExcludeBuffers | Ut.EnterBracketed))
      n.type.isTop && (r = n);
  return r;
}
h(O5, "Gu");
m(O5, "topNodeAt");
var ra;
const BM = (ra = class extends ar {
  constructor(t, e, i) {
    super(t, e, [], i), this.parser = e;
  }
  /**
  Define a language from a parser.
  */
  static define(t) {
    let e = O1(t.languageData);
    return new ra(e, t.parser.configure({
      props: [Vn.add((i) => i.isTop ? e : void 0)]
    }), t.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(t, e) {
    return new ra(this.data, this.parser.configure(t), e || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}, h(ra, "Vr"), ra);
m(BM, "LRLanguage");
let zC = BM;
function de(s) {
  let t = s.field(ar.state, !1);
  return t ? t.tree : Ft.empty;
}
h(de, "F$2");
m(de, "syntaxTree");
var Kd;
const NM = (Kd = class {
  /**
  Create an input object for the given document.
  */
  constructor(t) {
    this.doc = t, this.cursorPos = 0, this.string = "", this.cursor = t.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(t) {
    return this.string = this.cursor.next(t - this.cursorPos).value, this.cursorPos = t + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(t) {
    return this.syncTo(t), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(t, e) {
    let i = this.cursorPos - this.string.length;
    return t < i || e >= this.cursorPos ? this.doc.sliceString(t, e) : this.string.slice(t - i, e - i);
  }
}, h(Kd, "uc"), Kd);
m(NM, "DocInput");
let iq = NM, rg = null;
var sa;
const XM = (sa = class {
  constructor(t, e, i = [], r, n, a, o, l) {
    this.parser = t, this.state = e, this.fragments = i, this.tree = r, this.treeLen = n, this.viewport = a, this.skipped = o, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new sa(t, e, [], Ft.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new iq(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(t, e) {
    return e != null && e >= this.state.doc.length && (e = void 0), this.tree != Ft.empty && this.isDone(e ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof t == "number") {
        let r = Date.now() + t;
        t = /* @__PURE__ */ m(() => Date.now() > r, "until");
      }
      for (this.parse || (this.parse = this.startParse()), e != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > e) && e < this.state.doc.length && this.parse.stopAt(e); ; ) {
        let r = this.parse.advance();
        if (r)
          if (this.fragments = this.withoutTempSkipped(xh.addTree(r, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = r, this.parse = null, this.treeLen < (e ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (t())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let t, e;
    this.parse && (t = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > t) && this.parse.stopAt(t), this.withContext(() => {
      for (; !(e = this.parse.advance()); )
        ;
    }), this.treeLen = t, this.tree = e, this.fragments = this.withoutTempSkipped(xh.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(t) {
    let e = rg;
    rg = this;
    try {
      return t();
    } finally {
      rg = e;
    }
  }
  withoutTempSkipped(t) {
    for (let e; e = this.tempSkipped.pop(); )
      t = b5(t, e.from, e.to);
    return t;
  }
  /**
  @internal
  */
  changes(t, e) {
    let { fragments: i, tree: r, treeLen: n, viewport: a, skipped: o } = this;
    if (this.takeTree(), !t.empty) {
      let l = [];
      if (t.iterChangedRanges((d, u, p, f) => l.push({ fromA: d, toA: u, fromB: p, toB: f })), i = xh.applyChanges(i, l), r = Ft.empty, n = 0, a = { from: t.mapPos(a.from, -1), to: t.mapPos(a.to, 1) }, this.skipped.length) {
        o = [];
        for (let d of this.skipped) {
          let u = t.mapPos(d.from, 1), p = t.mapPos(d.to, -1);
          u < p && o.push({ from: u, to: p });
        }
      }
    }
    return new sa(this.parser, e, i, r, n, a, o, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(t) {
    if (this.viewport.from == t.from && this.viewport.to == t.to)
      return !1;
    this.viewport = t;
    let e = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: r, to: n } = this.skipped[i];
      r < t.to && n > t.from && (this.fragments = b5(this.fragments, r, n), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= e ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(t, e) {
    this.skipped.push({ from: t, to: e });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(t) {
    return new class extends tb {
      createParse(e, i, r) {
        let n = r[0].from, a = r[r.length - 1].to;
        return {
          parsedPos: n,
          advance() {
            let o = rg;
            if (o) {
              for (let l of r)
                o.tempSkipped.push(l);
              t && (o.scheduleOn = o.scheduleOn ? Promise.all([o.scheduleOn, t]) : t);
            }
            return this.parsedPos = a, new Ft(ei.none, [], [], a - n);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(t) {
    t = Math.min(t, this.state.doc.length);
    let e = this.fragments;
    return this.treeLen >= t && e.length && e[0].from == 0 && e[0].to >= t;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return rg;
  }
}, h(sa, "Ur"), sa);
m(XM, "ParseContext");
let IO = XM;
function b5(s, t, e) {
  return xh.applyChanges(s, [{ fromA: t, toA: e, fromB: t, toB: e }]);
}
h(b5, "Fu$1");
m(b5, "cutFragments");
var na;
const jM = (na = class {
  constructor(t) {
    this.context = t, this.tree = t.tree;
  }
  apply(t) {
    if (!t.docChanged && this.tree == this.context.tree)
      return this;
    let e = this.context.changes(t.changes, t.state), i = this.context.treeLen == t.startState.doc.length ? void 0 : Math.max(t.changes.mapPos(this.context.treeLen), e.viewport.to);
    return e.work(20, i) || e.takeTree(), new na(e);
  }
  static init(t) {
    let e = Math.min(3e3, t.doc.length), i = IO.create(t.facet(py).parser, t, { from: 0, to: e });
    return i.work(20, e) || i.takeTree(), new na(i);
  }
}, h(na, "Ir"), na);
m(jM, "LanguageState");
let $5 = jM;
ar.state = /* @__PURE__ */ mn.define({
  create: $5.init,
  update(s, t) {
    for (let e of t.effects)
      if (e.is(ar.setState))
        return e.value;
    return t.startState.facet(py) != t.state.facet(py) ? $5.init(t.state) : s.apply(t);
  }
});
let UM = /* @__PURE__ */ m((s) => {
  let t = setTimeout(
    () => s(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(t);
}, "requestIdle");
typeof requestIdleCallback < "u" && (UM = /* @__PURE__ */ m((s) => {
  let t = -1, e = setTimeout(
    () => {
      t = requestIdleCallback(s, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => t < 0 ? clearTimeout(e) : cancelIdleCallback(t);
}, "requestIdle"));
const C2 = typeof navigator < "u" && !((S2 = navigator.scheduling) === null || S2 === void 0) && S2.isInputPending ? () => navigator.scheduling.isInputPending() : null;
var P2, Jd;
const rq = /* @__PURE__ */ rn.fromClass((P2 = (Jd = class {
  constructor(t) {
    this.view = t, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(t) {
    let e = this.view.state.field(ar.state).context;
    (e.updateViewport(t.view.viewport) || this.view.viewport.to > e.treeLen) && this.scheduleWork(), (t.docChanged || t.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(e);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: t } = this.view, e = t.field(ar.state);
    (e.tree != e.context.tree || !e.context.isDone(t.doc.length)) && (this.working = UM(this.work));
  }
  work(t) {
    this.working = null;
    let e = Date.now();
    if (this.chunkEnd < e && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = e + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: r } } = this.view, n = i.field(ar.state);
    if (n.tree == n.context.tree && n.context.isDone(
      r + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let a = Date.now() + Math.min(this.chunkBudget, 100, t && !C2 ? Math.max(25, t.timeRemaining() - 5) : 1e9), o = n.context.treeLen < r && i.doc.length > r + 1e3, l = n.context.work(() => C2 && C2() || Date.now() > a, r + (o ? 0 : 1e5));
    this.chunkBudget -= Date.now() - e, (l || this.chunkBudget <= 0) && (n.context.takeTree(), this.view.dispatch({ effects: ar.setState.of(new $5(n.context)) })), this.chunkBudget > 0 && !(l && !o) && this.scheduleWork(), this.checkAsyncSchedule(n.context);
  }
  checkAsyncSchedule(t) {
    t.scheduleOn && (this.workScheduled++, t.scheduleOn.then(() => this.scheduleWork()).catch((e) => Wi(this.view.state, e)).then(() => this.workScheduled--), t.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, h(Jd, "Ai$1"), Jd), m(P2, "ParseWorker"), P2), {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), py = /* @__PURE__ */ Ct.define({
  combine(s) {
    return s.length ? s[0] : null;
  },
  enables: /* @__PURE__ */ m((s) => [
    ar.state,
    rq,
    Mt.contentAttributes.compute([s], (t) => {
      let e = t.facet(s);
      return e && e.name ? { "data-language": e.name } : {};
    })
  ], "enables")
});
var tu;
const HM = (tu = class {
  /**
  Create a language support object.
  */
  constructor(t, e = []) {
    this.language = t, this.support = e, this.extension = [t, e];
  }
}, h(tu, "Oc"), tu);
m(HM, "LanguageSupport");
let fy = HM;
var Uo;
const YM = (Uo = class {
  constructor(t, e, i, r, n, a = void 0) {
    this.name = t, this.alias = e, this.extensions = i, this.filename = r, this.loadFunc = n, this.support = a, this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return this.loading || (this.loading = this.loadFunc().then((t) => this.support = t, (t) => {
      throw this.loading = null, t;
    }));
  }
  /**
  Create a language description.
  */
  static of(t) {
    let { load: e, support: i } = t;
    if (!e) {
      if (!i)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      e = /* @__PURE__ */ m(() => Promise.resolve(i), "load");
    }
    return new Uo(t.name, (t.alias || []).concat(t.name).map((r) => r.toLowerCase()), t.extensions || [], t.filename, e, i);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(t, e) {
    for (let r of t)
      if (r.filename && r.filename.test(e))
        return r;
    let i = /\.([^.]+)$/.exec(e);
    if (i) {
      for (let r of t)
        if (r.extensions.indexOf(i[1]) > -1)
          return r;
    }
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(t, e, i = !0) {
    e = e.toLowerCase();
    for (let r of t)
      if (r.alias.some((n) => n == e))
        return r;
    if (i)
      for (let r of t)
        for (let n of r.alias) {
          let a = e.indexOf(n);
          if (a > -1 && (n.length > 2 || !/\w/.test(e[a - 1]) && !/\w/.test(e[a + n.length])))
            return r;
        }
    return null;
  }
}, h(Uo, "ho"), Uo);
m(YM, "LanguageDescription");
let OQ = YM;
const sq = /* @__PURE__ */ Ct.define(), eb = /* @__PURE__ */ Ct.define({
  combine: /* @__PURE__ */ m((s) => {
    if (!s.length)
      return "  ";
    let t = s[0];
    if (!t || /\S/.test(t) || Array.from(t).some((e) => e != t[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(s[0]));
    return t;
  }, "combine")
});
function zw(s) {
  let t = s.facet(eb);
  return t.charCodeAt(0) == 9 ? s.tabSize * t.length : t.length;
}
h(zw, "li$1");
m(zw, "getIndentUnit");
function x5(s, t) {
  let e = "", i = s.tabSize, r = s.facet(eb)[0];
  if (r == "	") {
    for (; t >= i; )
      e += "	", t -= i;
    r = " ";
  }
  for (let n = 0; n < t; n++)
    e += r;
  return e;
}
h(x5, "Qs$1");
m(x5, "indentString");
function GM(s, t) {
  s instanceof Be && (s = new IC(s));
  for (let i of s.state.facet(sq)) {
    let r = i(s, t);
    if (r !== void 0)
      return r;
  }
  let e = de(s.state);
  return e.length >= t ? JM(s, e, t) : null;
}
h(GM, "gp$1");
m(GM, "getIndentation");
var eu;
const KM = (eu = class {
  /**
  Create an indent context.
  */
  constructor(t, e = {}) {
    this.state = t, this.options = e, this.unit = zw(t);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(t, e = 1) {
    let i = this.state.doc.lineAt(t), { simulateBreak: r, simulateDoubleBreak: n } = this.options;
    return r != null && r >= i.from && r <= i.to ? n && r == t ? { text: "", from: t } : (e < 0 ? r < t : r <= t) ? { text: i.text.slice(r - i.from), from: r } : { text: i.text.slice(0, r - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(t, e = 1) {
    if (this.options.simulateDoubleBreak && t == this.options.simulateBreak)
      return "";
    let { text: i, from: r } = this.lineAt(t, e);
    return i.slice(t - r, Math.min(i.length, t + 100 - r));
  }
  /**
  Find the column for the given position.
  */
  column(t, e = 1) {
    let { text: i, from: r } = this.lineAt(t, e), n = this.countColumn(i, t - r), a = this.options.overrideIndentation ? this.options.overrideIndentation(r) : -1;
    return a > -1 && (n += a - this.countColumn(i, i.search(/\S|$/))), n;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(t, e = t.length) {
    return ua(t, this.state.tabSize, e);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(t, e = 1) {
    let { text: i, from: r } = this.lineAt(t, e), n = this.options.overrideIndentation;
    if (n) {
      let a = n(r);
      if (a > -1)
        return a;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}, h(eu, "dc"), eu);
m(KM, "IndentContext");
let IC = KM;
const zy = /* @__PURE__ */ new Et();
function JM(s, t, e) {
  let i = t.resolveStack(e), r = t.resolveInner(e, -1).resolve(e, 0).enterUnfinishedNodesBefore(e);
  if (r != i.node) {
    let n = [];
    for (let a = r; a && !(a.from < i.node.from || a.to > i.node.to || a.from == i.node.from && a.type == i.node.type); a = a.parent)
      n.push(a);
    for (let a = n.length - 1; a >= 0; a--)
      i = { node: n[a], next: i };
  }
  return DC(i, s, e);
}
h(JM, "eQ");
m(JM, "syntaxIndentation");
function DC(s, t, e) {
  for (let i = s; i; i = i.next) {
    let r = eA(i.node);
    if (r)
      return r(nq.create(t, e, i));
  }
  return 0;
}
h(DC, "Qp");
m(DC, "indentFor");
function tA(s) {
  return s.pos == s.options.simulateBreak && s.options.simulateDoubleBreak;
}
h(tA, "tQ");
m(tA, "ignoreClosed");
function eA(s) {
  let t = s.type.prop(zy);
  if (t)
    return t;
  let e = s.firstChild, i;
  if (e && (i = e.type.prop(Et.closedBy))) {
    let r = s.lastChild, n = r && i.indexOf(r.name) > -1;
    return (a) => VC(a, !0, 1, void 0, n && !tA(a) ? r.from : void 0);
  }
  return s.parent == null ? iA : null;
}
h(eA, "iQ");
m(eA, "indentStrategy");
function iA() {
  return 0;
}
h(iA, "rQ");
m(iA, "topIndent");
var Ho;
const rA = (Ho = class extends IC {
  constructor(t, e, i) {
    super(t.state, t.options), this.base = t, this.pos = e, this.context = i;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new Ho(t, e, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(t) {
    let e = this.state.doc.lineAt(t.from);
    for (; ; ) {
      let i = t.resolve(e.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (sA(i, t))
        break;
      e = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(e.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return DC(this.context.next, this.base, this.pos);
  }
}, h(Ho, "fo"), Ho);
m(rA, "TreeIndentContext");
let nq = rA;
function sA(s, t) {
  for (let e = t; e; e = e.parent)
    if (s == e)
      return !0;
  return !1;
}
h(sA, "nQ");
m(sA, "isParent");
function nA(s) {
  let t = s.node, e = t.childAfter(t.from), i = t.lastChild;
  if (!e)
    return null;
  let r = s.options.simulateBreak, n = s.state.doc.lineAt(e.from), a = r == null || r <= n.from ? n.to : Math.min(n.to, r);
  for (let o = e.to; ; ) {
    let l = t.childAfter(o);
    if (!l || l == i)
      return null;
    if (!l.type.isSkipped) {
      if (l.from >= a)
        return null;
      let d = /^ */.exec(n.text.slice(e.to - n.from))[0].length;
      return { from: e.from, to: e.to + d };
    }
    o = l.to;
  }
}
h(nA, "sQ");
m(nA, "bracketedAligned");
function aA({ closing: s, align: t = !0, units: e = 1 }) {
  return (i) => VC(i, t, e, s);
}
h(aA, "oQ");
m(aA, "delimitedIndent");
function VC(s, t, e, i, r) {
  let n = s.textAfter, a = n.match(/^\s*/)[0].length, o = i && n.slice(a, a + i.length) == i || r == s.pos + a, l = t ? nA(s) : null;
  return l ? o ? s.column(l.from) : s.column(l.to) : s.baseIndent + (o ? 0 : s.unit * e);
}
h(VC, "yp$1");
m(VC, "delimitedStrategy");
const aq = /* @__PURE__ */ m((s) => s.baseIndent, "flatIndent");
function Ow({ except: s, units: t = 1 } = {}) {
  return (e) => {
    let i = s && s.test(e.textAfter);
    return e.baseIndent + (i ? 0 : t * e.unit);
  };
}
h(Ow, "Nn$1");
m(Ow, "continuedIndent");
const oq = /* @__PURE__ */ Ct.define(), b1 = /* @__PURE__ */ new Et();
function WC(s) {
  let t = s.firstChild, e = s.lastChild;
  return t && t.to < e.from ? { from: t.to, to: e.type.isError ? s.to : e.from } : null;
}
h(WC, "Sp$1");
m(WC, "foldInside");
var Yo;
const oA = (Yo = class {
  constructor(t, e) {
    this.specs = t;
    let i;
    function r(o) {
      let l = pa.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + l] = o, l;
    }
    h(r, "n"), m(r, "def");
    const n = typeof e.all == "string" ? e.all : e.all ? r(e.all) : void 0, a = e.scope;
    this.scope = a instanceof ar ? (o) => o.prop(Vn) == a.data : a ? (o) => o == a : void 0, this.style = _C(t.map((o) => ({
      tag: o.tag,
      class: o.class || r(Object.assign({}, o, { tag: null }))
    })), {
      all: n
    }).style, this.module = i ? new pa(i) : null, this.themeType = e.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(t, e) {
    return new Yo(t, e || {});
  }
}, h(Yo, "co"), Yo);
m(oA, "HighlightStyle");
let lA = oA;
const k5 = /* @__PURE__ */ Ct.define(), cA = /* @__PURE__ */ Ct.define({
  combine(s) {
    return s.length ? [s[0]] : null;
  }
});
function Av(s) {
  let t = s.facet(k5);
  return t.length ? t : s.facet(cA);
}
h(Av, "Wo$1");
m(Av, "getHighlighters");
function lq(s, t) {
  let e = [hq], i;
  return s instanceof lA && (s.module && e.push(Mt.styleModule.of(s.module)), i = s.themeType), t?.fallback ? e.push(cA.of(s)) : i ? e.push(k5.computeN([Mt.darkTheme], (r) => r.facet(Mt.darkTheme) == (i == "dark") ? [s] : [])) : e.push(k5.of(s)), e;
}
h(lq, "hQ");
m(lq, "syntaxHighlighting");
var iu;
const hA = (iu = class {
  constructor(t) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = de(t.state), this.decorations = this.buildDeco(t, Av(t.state)), this.decoratedTo = t.viewport.to;
  }
  update(t) {
    let e = de(t.state), i = Av(t.state), r = i != Av(t.startState), { viewport: n } = t.view, a = t.changes.mapPos(this.decoratedTo, 1);
    e.length < n.to && !r && e.type == this.tree.type && a >= n.to ? (this.decorations = this.decorations.map(t.changes), this.decoratedTo = a) : (e != this.tree || t.viewportChanged || r) && (this.tree = e, this.decorations = this.buildDeco(t.view, i), this.decoratedTo = n.to);
  }
  buildDeco(t, e) {
    if (!e || !this.tree.length)
      return se.none;
    let i = new xO();
    for (let { from: r, to: n } of t.visibleRanges)
      WM(this.tree, e, (a, o, l) => {
        i.add(a, o, this.markCache[l] || (this.markCache[l] = se.mark({ class: l })));
      }, r, n);
    return i.finish();
  }
}, h(iu, "pc"), iu);
m(hA, "TreeHighlighter");
let cq = hA;
const hq = /* @__PURE__ */ Ll.high(/* @__PURE__ */ rn.fromClass(cq, {
  decorations: /* @__PURE__ */ m((s) => s.decorations, "decorations")
})), dq = 1e4, uq = "()[]{}", dA = /* @__PURE__ */ new Et();
function DO(s, t, e) {
  let i = s.prop(t < 0 ? Et.openedBy : Et.closedBy);
  if (i)
    return i;
  if (s.name.length == 1) {
    let r = e.indexOf(s.name);
    if (r > -1 && r % 2 == (t < 0 ? 1 : 0))
      return [e[r + t]];
  }
  return null;
}
h(DO, "wa$1");
m(DO, "matchingNodes");
function VO(s) {
  let t = s.type.prop(dA);
  return t ? t(s.node) : s;
}
h(VO, "xa$1");
m(VO, "findHandle");
function ho(s, t, e, i = {}) {
  let r = i.maxScanDistance || dq, n = i.brackets || uq, a = de(s), o = a.resolveInner(t, e);
  for (let l = o; l; l = l.parent) {
    let d = DO(l.type, e, n);
    if (d && l.from < l.to) {
      let u = VO(l);
      if (u && (e > 0 ? t >= u.from && t < u.to : t > u.from && t <= u.to))
        return uA(s, t, e, l, u, d, n);
    }
  }
  return pA(s, t, e, a, o.type, r, n);
}
h(ho, "pi$1");
m(ho, "matchBrackets");
function uA(s, t, e, i, r, n, a) {
  let o = i.parent, l = { from: r.from, to: r.to }, d = 0, u = o?.cursor();
  if (u && (e < 0 ? u.childBefore(i.from) : u.childAfter(i.to)))
    do
      if (e < 0 ? u.to <= i.from : u.from >= i.to) {
        if (d == 0 && n.indexOf(u.type.name) > -1 && u.from < u.to) {
          let p = VO(u);
          return { start: l, end: p ? { from: p.from, to: p.to } : void 0, matched: !0 };
        } else if (DO(u.type, e, a))
          d++;
        else if (DO(u.type, -e, a)) {
          if (d == 0) {
            let p = VO(u);
            return {
              start: l,
              end: p && p.from < p.to ? { from: p.from, to: p.to } : void 0,
              matched: !1
            };
          }
          d--;
        }
      }
    while (e < 0 ? u.prevSibling() : u.nextSibling());
  return { start: l, matched: !1 };
}
h(uA, "OQ");
m(uA, "matchMarkedBrackets");
function pA(s, t, e, i, r, n, a) {
  let o = e < 0 ? s.sliceDoc(t - 1, t) : s.sliceDoc(t, t + 1), l = a.indexOf(o);
  if (l < 0 || l % 2 == 0 != e > 0)
    return null;
  let d = { from: e < 0 ? t - 1 : t, to: e > 0 ? t + 1 : t }, u = s.doc.iterRange(t, e > 0 ? s.doc.length : 0), p = 0;
  for (let f = 0; !u.next().done && f <= n; ) {
    let y = u.value;
    e < 0 && (f += y.length);
    let g = t + f * e;
    for (let O = e > 0 ? 0 : y.length - 1, k = e > 0 ? y.length : -1; O != k; O += e) {
      let $ = a.indexOf(y[O]);
      if (!($ < 0 || i.resolveInner(g + O, 1).type != r))
        if ($ % 2 == 0 == e > 0)
          p++;
        else {
          if (p == 1)
            return { start: d, end: { from: g + O, to: g + O + 1 }, matched: $ >> 1 == l >> 1 };
          p--;
        }
    }
    e > 0 && (f += y.length);
  }
  return u.done ? { start: d, matched: !1 } : null;
}
h(pA, "dQ");
m(pA, "matchPlainBrackets");
function S5(s, t, e, i = 0, r = 0) {
  t == null && (t = s.search(/[^\s\u00a0]/), t == -1 && (t = s.length));
  let n = r;
  for (let a = i; a < t; a++)
    s.charCodeAt(a) == 9 ? n += e - n % e : n++;
  return n;
}
h(S5, "Hu$1");
m(S5, "countCol");
var ru;
const fA = (ru = class {
  /**
  Create a stream.
  */
  constructor(t, e, i, r) {
    this.string = t, this.tabSize = e, this.indentUnit = i, this.overrideIndent = r, this.pos = 0, this.start = 0, this.lastColumnPos = 0, this.lastColumnValue = 0;
  }
  /**
  True if we are at the end of the line.
  */
  eol() {
    return this.pos >= this.string.length;
  }
  /**
  True if we are at the start of the line.
  */
  sol() {
    return this.pos == 0;
  }
  /**
  Get the next code unit after the current position, or undefined
  if we're at the end of the line.
  */
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  /**
  Read the next code unit and advance `this.pos`.
  */
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  /**
  Match the next character against the given string, regular
  expression, or predicate. Consume and return it if it matches.
  */
  eat(t) {
    let e = this.string.charAt(this.pos), i;
    if (typeof t == "string" ? i = e == t : i = e && (t instanceof RegExp ? t.test(e) : t(e)), i)
      return ++this.pos, e;
  }
  /**
  Continue matching characters that match the given string,
  regular expression, or predicate function. Return true if any
  characters were consumed.
  */
  eatWhile(t) {
    let e = this.pos;
    for (; this.eat(t); )
      ;
    return this.pos > e;
  }
  /**
  Consume whitespace ahead of `this.pos`. Return true if any was
  found.
  */
  eatSpace() {
    let t = this.pos;
    for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
      ++this.pos;
    return this.pos > t;
  }
  /**
  Move to the end of the line.
  */
  skipToEnd() {
    this.pos = this.string.length;
  }
  /**
  Move to directly before the given character, if found on the
  current line.
  */
  skipTo(t) {
    let e = this.string.indexOf(t, this.pos);
    if (e > -1)
      return this.pos = e, !0;
  }
  /**
  Move back `n` characters.
  */
  backUp(t) {
    this.pos -= t;
  }
  /**
  Get the column position at `this.pos`.
  */
  column() {
    return this.lastColumnPos < this.start && (this.lastColumnValue = S5(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue;
  }
  /**
  Get the indentation column of the current line.
  */
  indentation() {
    var t;
    return (t = this.overrideIndent) !== null && t !== void 0 ? t : S5(this.string, null, this.tabSize);
  }
  /**
  Match the input against the given string or regular expression
  (which should start with a `^`). Return true or the regexp match
  if it matches.
  
  Unless `consume` is set to `false`, this will move `this.pos`
  past the matched text.
  
  When matching a string `caseInsensitive` can be set to true to
  make the match case-insensitive.
  */
  match(t, e, i) {
    if (typeof t == "string") {
      let r = /* @__PURE__ */ m((a) => i ? a.toLowerCase() : a, "cased"), n = this.string.substr(this.pos, t.length);
      return r(n) == r(t) ? (e !== !1 && (this.pos += t.length), !0) : null;
    } else {
      let r = this.string.slice(this.pos).match(t);
      return r && r.index > 0 ? null : (r && e !== !1 && (this.pos += r[0].length), r);
    }
  }
  /**
  Get the current token.
  */
  current() {
    return this.string.slice(this.start, this.pos);
  }
}, h(ru, "mc"), ru);
m(fA, "StringStream");
let mA = fA;
function yA(s) {
  return {
    name: s.name || "",
    token: s.token,
    blankLine: s.blankLine || (() => {
    }),
    startState: s.startState || (() => !0),
    copyState: s.copyState || gA,
    indent: s.indent || (() => null),
    languageData: s.languageData || {},
    tokenTable: s.tokenTable || ZC,
    mergeTokens: s.mergeTokens !== !1
  };
}
h(yA, "pQ");
m(yA, "fullParser");
function gA(s) {
  if (typeof s != "object")
    return s;
  let t = {};
  for (let e in s) {
    let i = s[e];
    t[e] = i instanceof Array ? i.slice() : i;
  }
  return t;
}
h(gA, "mQ");
m(gA, "defaultCopyState");
const bQ = /* @__PURE__ */ new WeakMap();
var Go;
const wA = (Go = class extends ar {
  constructor(t) {
    let e = O1(t.languageData), i = yA(t), r, n = new class extends tb {
      createParse(a, o, l) {
        return new fq(r, a, o, l);
      }
    }();
    super(e, n, [], t.name), this.topNode = xA(e, this), r = this, this.streamParser = i, this.stateAfter = new Et({ perNode: !0 }), this.tokenTable = t.tokenTable ? new $A(i.tokenTable) : yq;
  }
  /**
  Define a stream language.
  */
  static define(t) {
    return new Go(t);
  }
  /**
  @internal
  */
  getIndent(t) {
    let e, { overrideIndentation: i } = t.options;
    i && (e = bQ.get(t.state), e != null && e < t.pos - 1e4 && (e = void 0));
    let r = ib(this, t.node.tree, t.node.from, t.node.from, e ?? t.pos), n, a;
    if (r ? (a = r.state, n = r.pos + 1) : (a = this.streamParser.startState(t.unit), n = t.node.from), t.pos - n > 1e4)
      return null;
    for (; n < t.pos; ) {
      let l = t.state.doc.lineAt(n), d = Math.min(t.pos, l.to);
      if (l.length) {
        let u = i ? i(l.from) : -1, p = new mA(l.text, t.state.tabSize, t.unit, u < 0 ? void 0 : u);
        for (; p.pos < d - l.from; )
          qC(this.streamParser.token, p, a);
      } else
        this.streamParser.blankLine(a, t.unit);
      if (d == t.pos)
        break;
      n = l.to + 1;
    }
    let o = t.lineAt(t.pos);
    return i && e == null && bQ.set(t.state, o.from), this.streamParser.indent(a, /^\s*(.*)/.exec(o.text)[1], t);
  }
  get allowsNesting() {
    return !1;
  }
}, h(Go, "uo"), Go);
m(wA, "StreamLanguage");
let pq = wA;
function ib(s, t, e, i, r) {
  let n = e >= i && e + t.length <= r && t.prop(s.stateAfter);
  if (n)
    return { state: s.streamParser.copyState(n), pos: e + t.length };
  for (let a = t.children.length - 1; a >= 0; a--) {
    let o = t.children[a], l = e + t.positions[a], d = o instanceof Ft && l < r && ib(s, o, l, i, r);
    if (d)
      return d;
  }
  return null;
}
h(ib, "kh$1");
m(ib, "findState");
function FC(s, t, e, i, r) {
  if (r && e <= 0 && i >= t.length)
    return t;
  !r && e == 0 && t.type == s.topNode && (r = !0);
  for (let n = t.children.length - 1; n >= 0; n--) {
    let a = t.positions[n], o = t.children[n], l;
    if (a < i && o instanceof Ft) {
      if (!(l = FC(s, o, e - a, i - a, r)))
        break;
      return r ? new Ft(t.type, t.children.slice(0, n).concat(l), t.positions.slice(0, n + 1), a + l.length) : l;
    }
  }
  return null;
}
h(FC, "xp$1");
m(FC, "cutTree");
function vA(s, t, e, i, r) {
  for (let n of t) {
    let a = n.from + (n.openStart ? 25 : 0), o = n.to - (n.openEnd ? 25 : 0), l = a <= e && o > e && ib(s, n.tree, 0 - n.offset, e, o), d;
    if (l && l.pos <= i && (d = FC(s, n.tree, e + n.offset, l.pos + n.offset, !1)))
      return { state: l.state, tree: d };
  }
  return { state: s.streamParser.startState(r ? zw(r) : 4), tree: Ft.empty };
}
h(vA, "gQ");
m(vA, "findStartInFragments");
var Q2, su;
let fq = (Q2 = (su = class {
  constructor(t, e, i, r) {
    this.lang = t, this.input = e, this.fragments = i, this.ranges = r, this.stoppedAt = null, this.chunks = [], this.chunkPos = [], this.chunk = [], this.chunkReused = void 0, this.rangeIndex = 0, this.to = r[r.length - 1].to;
    let n = IO.get(), a = r[0].from, { state: o, tree: l } = vA(t, i, a, this.to, n?.state);
    this.state = o, this.parsedPos = this.chunkStart = a + l.length;
    for (let d = 0; d < l.children.length; d++)
      this.chunks.push(l.children[d]), this.chunkPos.push(l.positions[d]);
    n && this.parsedPos < n.viewport.from - 1e5 && r.some((d) => d.from <= n.viewport.from && d.to >= n.viewport.from) && (this.state = this.lang.streamParser.startState(zw(n.state)), n.skipUntilInView(this.parsedPos, n.viewport.from), this.parsedPos = n.viewport.from), this.moveRangeIndex();
  }
  advance() {
    let t = IO.get(), e = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt), i = Math.min(
      e,
      this.chunkStart + 512
      /* C.ChunkSize */
    );
    for (t && (i = Math.min(i, t.viewport.to)); this.parsedPos < i; )
      this.parseLine(t);
    return this.chunkStart < this.parsedPos && this.finishChunk(), this.parsedPos >= e ? this.finish() : t && this.parsedPos >= t.viewport.to ? (t.skipUntilInView(this.parsedPos, e), this.finish()) : null;
  }
  stopAt(t) {
    this.stoppedAt = t;
  }
  lineAfter(t) {
    let e = this.input.chunk(t);
    if (this.input.lineChunks)
      e == `
` && (e = "");
    else {
      let i = e.indexOf(`
`);
      i > -1 && (e = e.slice(0, i));
    }
    return t + e.length <= this.to ? e : e.slice(0, this.to - t);
  }
  nextLine() {
    let t = this.parsedPos, e = this.lineAfter(t), i = t + e.length;
    for (let r = this.rangeIndex; ; ) {
      let n = this.ranges[r].to;
      if (n >= i || (e = e.slice(0, n - (i - e.length)), r++, r == this.ranges.length))
        break;
      let a = this.ranges[r].from, o = this.lineAfter(a);
      e += o, i = a + o.length;
    }
    return { line: e, end: i };
  }
  skipGapsTo(t, e, i) {
    for (; ; ) {
      let r = this.ranges[this.rangeIndex].to, n = t + e;
      if (i > 0 ? r > n : r >= n)
        break;
      let a = this.ranges[++this.rangeIndex].from;
      e += a - r;
    }
    return e;
  }
  moveRangeIndex() {
    for (; this.ranges[this.rangeIndex].to < this.parsedPos; )
      this.rangeIndex++;
  }
  emitToken(t, e, i, r) {
    let n = 4;
    if (this.ranges.length > 1) {
      r = this.skipGapsTo(e, r, 1), e += r;
      let o = this.chunk.length;
      r = this.skipGapsTo(i, r, -1), i += r, n += this.chunk.length - o;
    }
    let a = this.chunk.length - 4;
    return this.lang.streamParser.mergeTokens && n == 4 && a >= 0 && this.chunk[a] == t && this.chunk[a + 2] == e ? this.chunk[a + 2] = i : this.chunk.push(t, e, i, n), r;
  }
  parseLine(t) {
    let { line: e, end: i } = this.nextLine(), r = 0, { streamParser: n } = this.lang, a = new mA(e, t ? t.state.tabSize : 4, t ? zw(t.state) : 2);
    if (a.eol())
      n.blankLine(this.state, a.indentUnit);
    else
      for (; !a.eol(); ) {
        let o = qC(n.token, a, this.state);
        if (o && (r = this.emitToken(this.lang.tokenTable.resolve(o), this.parsedPos + a.start, this.parsedPos + a.pos, r)), a.start > 1e4)
          break;
      }
    this.parsedPos = i, this.moveRangeIndex(), this.parsedPos < this.to && this.parsedPos++;
  }
  finishChunk() {
    let t = Ft.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet: mq,
      topID: 0,
      maxBufferLength: 512,
      reused: this.chunkReused
    });
    t = new Ft(t.type, t.children, t.positions, t.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]), this.chunks.push(t), this.chunkPos.push(this.chunkStart - this.ranges[0].from), this.chunk = [], this.chunkReused = void 0, this.chunkStart = this.parsedPos;
  }
  finish() {
    return new Ft(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
}, h(su, "Li$1"), su), m(Q2, "Parse"), Q2);
function qC(s, t, e) {
  t.start = t.pos;
  for (let i = 0; i < 10; i++) {
    let r = s(t, e);
    if (t.pos > t.start)
      return r;
  }
  throw new Error("Stream parser failed to advance stream.");
}
h(qC, "kp$1");
m(qC, "readToken$1");
const ZC = /* @__PURE__ */ Object.create(null), Iw = [ei.none], mq = /* @__PURE__ */ new G0(Iw), $Q = [], xQ = /* @__PURE__ */ Object.create(null), OA = /* @__PURE__ */ Object.create(null);
for (let [s, t] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  OA[s] = /* @__PURE__ */ BC(ZC, t);
var nu;
const bA = (nu = class {
  constructor(t) {
    this.extra = t, this.table = Object.assign(/* @__PURE__ */ Object.create(null), OA);
  }
  resolve(t) {
    return t ? this.table[t] || (this.table[t] = BC(this.extra, t)) : 0;
  }
}, h(nu, "gc"), nu);
m(bA, "TokenTable");
let $A = bA;
const yq = /* @__PURE__ */ new $A(ZC);
function Rv(s, t) {
  $Q.indexOf(s) > -1 || ($Q.push(s), console.warn(t));
}
h(Rv, "Vo$1");
m(Rv, "warnForPart");
function BC(s, t) {
  let e = [];
  for (let o of t.split(" ")) {
    let l = [];
    for (let d of o.split(".")) {
      let u = s[d] || Q[d];
      u ? typeof u == "function" ? l.length ? l = l.map(u) : Rv(d, `Modifier ${d} used at start of tag`) : l.length ? Rv(d, `Tag ${d} used as modifier`) : l = Array.isArray(u) ? u : [u] : Rv(d, `Unknown highlighting tag ${d}`);
    }
    for (let d of l)
      e.push(d);
  }
  if (!e.length)
    return 0;
  let i = t.replace(/ /g, "_"), r = i + " " + e.map((o) => o.id), n = xQ[r];
  if (n)
    return n.id;
  let a = xQ[r] = ei.define({
    id: Iw.length,
    name: i,
    props: [Il({ [i]: e })]
  });
  return Iw.push(a), a.id;
}
h(BC, "$p$1");
m(BC, "createTokenType");
function xA(s, t) {
  let e = ei.define({ id: Iw.length, name: "Document", props: [
    Vn.add(() => s),
    zy.add(() => (i) => t.getIndent(i))
  ], top: !0 });
  return Iw.push(e), e;
}
h(xA, "bQ");
m(xA, "docID");
me.RTL, me.LTR;
var au;
const kA = (au = class {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(t, e, i, r) {
    this.state = t, this.pos = e, this.explicit = i, this.view = r, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(t) {
    let e = de(this.state).resolveInner(this.pos, -1);
    for (; e && t.indexOf(e.name) < 0; )
      e = e.parent;
    return e ? {
      from: e.from,
      to: this.pos,
      text: this.state.sliceDoc(e.from, this.pos),
      type: e.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(t) {
    let e = this.state.doc.lineAt(this.pos), i = Math.max(e.from, this.pos - 250), r = e.text.slice(i - e.from, this.pos - e.from), n = r.search(jC(t, !1));
    return n < 0 ? null : { from: i + n, to: this.pos, text: r.slice(n) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(t, e, i) {
    t == "abort" && this.abortListeners && (this.abortListeners.push(e), i && i.onDocChange && (this.abortOnDocChange = !0));
  }
}, h(au, "Qc"), au);
m(kA, "CompletionContext");
let NC = kA;
function C5(s) {
  let t = Object.keys(s).join(""), e = /\w/.test(t);
  return e && (t = t.replace(/\w/g, "")), `[${e ? "\\w" : ""}${t.replace(/[^\w\s]/g, "\\$&")}]`;
}
h(C5, "tO");
m(C5, "toSet");
function SA(s) {
  let t = /* @__PURE__ */ Object.create(null), e = /* @__PURE__ */ Object.create(null);
  for (let { label: r } of s) {
    t[r[0]] = !0;
    for (let n = 1; n < r.length; n++)
      e[r[n]] = !0;
  }
  let i = C5(t) + C5(e) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
h(SA, "wQ");
m(SA, "prefixMatch");
function XC(s) {
  let t = s.map((r) => typeof r == "string" ? { label: r } : r), [e, i] = t.every((r) => /^\w+$/.test(r.label)) ? [/\w*$/, /\w+$/] : SA(t);
  return (r) => {
    let n = r.matchBefore(i);
    return n || r.explicit ? { from: n ? n.from : r.pos, options: t, validFor: e } : null;
  };
}
h(XC, "Rp$1");
m(XC, "completeFromList");
function CA(s, t) {
  return (e) => {
    for (let i = de(e.state).resolveInner(e.pos, -1); i; i = i.parent) {
      if (s.indexOf(i.name) > -1)
        return null;
      if (i.type.isTop)
        break;
    }
    return t(e);
  };
}
h(CA, "xQ");
m(CA, "ifNotIn");
var ou;
const PA = (ou = class {
  constructor(t, e, i, r) {
    this.completion = t, this.source = e, this.match = i, this.score = r;
  }
}, h(ou, "yc"), ou);
m(PA, "Option");
let kQ = PA;
function Zn(s) {
  return s.selection.main.from;
}
h(Zn, "Jt$2");
m(Zn, "cur");
function jC(s, t) {
  var e;
  let { source: i } = s, r = t && i[0] != "^", n = i[i.length - 1] != "$";
  return !r && !n ? s : new RegExp(`${r ? "^" : ""}(?:${i})${n ? "$" : ""}`, (e = s.flags) !== null && e !== void 0 ? e : s.ignoreCase ? "i" : "");
}
h(jC, "vp$1");
m(jC, "ensureAnchor");
const UC = /* @__PURE__ */ yn.define();
function QA(s, t, e, i) {
  let { main: r } = s.selection, n = e - r.from, a = i - r.from;
  return {
    ...s.changeByRange((o) => {
      if (o != r && e != i && s.sliceDoc(o.from + n, o.from + a) != s.sliceDoc(e, i))
        return { range: o };
      let l = s.toText(t);
      return {
        changes: { from: o.from + n, to: i == r.from ? o.to : o.from + a, insert: l },
        range: nt.cursor(o.from + n + l.length)
      };
    }),
    scrollIntoView: !0,
    userEvent: "input.complete"
  };
}
h(QA, "kQ");
m(QA, "insertCompletionText");
const SQ = /* @__PURE__ */ new WeakMap();
function TA(s) {
  if (!Array.isArray(s))
    return s;
  let t = SQ.get(s);
  return t || SQ.set(s, t = XC(s)), t;
}
h(TA, "PQ");
m(TA, "asSource");
const WO = /* @__PURE__ */ te.define(), Dw = /* @__PURE__ */ te.define();
var lu;
const MA = (lu = class {
  constructor(t) {
    this.pattern = t, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let e = 0; e < t.length; ) {
      let i = Rn(t, e), r = oo(i);
      this.chars.push(i);
      let n = t.slice(e, e + r), a = n.toUpperCase();
      this.folded.push(Rn(a == n ? n.toLowerCase() : a, 0)), e += r;
    }
    this.astral = t.length != this.chars.length;
  }
  ret(t, e) {
    return this.score = t, this.matched = e, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(t) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (t.length < this.pattern.length)
      return null;
    let { chars: e, folded: i, any: r, precise: n, byWord: a } = this;
    if (e.length == 1) {
      let T = Rn(t, 0), _ = oo(T), D = _ == t.length ? 0 : -100;
      if (T != e[0]) if (T == i[0])
        D += -200;
      else
        return null;
      return this.ret(D, [0, _]);
    }
    let o = t.indexOf(this.pattern);
    if (o == 0)
      return this.ret(t.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = e.length, d = 0;
    if (o < 0) {
      for (let T = 0, _ = Math.min(t.length, 200); T < _ && d < l; ) {
        let D = Rn(t, T);
        (D == e[d] || D == i[d]) && (r[d++] = T), T += oo(D);
      }
      if (d < l)
        return null;
    }
    let u = 0, p = 0, f = !1, y = 0, g = -1, O = -1, k = /[a-z]/.test(t), $ = !0;
    for (let T = 0, _ = Math.min(t.length, 200), D = 0; T < _ && p < l; ) {
      let A = Rn(t, T);
      o < 0 && (u < l && A == e[u] && (n[u++] = T), y < l && (A == e[y] || A == i[y] ? (y == 0 && (g = T), O = T + 1, y++) : y = 0));
      let z, V = A < 255 ? A >= 48 && A <= 57 || A >= 97 && A <= 122 ? 2 : A >= 65 && A <= 90 ? 1 : 0 : (z = $8(A)) != z.toLowerCase() ? 1 : z != z.toUpperCase() ? 2 : 0;
      (!T || V == 1 && k || D == 0 && V != 0) && (e[p] == A || i[p] == A && (f = !0) ? a[p++] = T : a.length && ($ = !1)), D = V, T += oo(A);
    }
    return p == l && a[0] == 0 && $ ? this.result(-100 + (f ? -200 : 0), a, t) : y == l && g == 0 ? this.ret(-200 - t.length + (O == t.length ? 0 : -100), [0, O]) : o > -1 ? this.ret(-700 - t.length, [o, o + this.pattern.length]) : y == l ? this.ret(-900 - t.length, [g, O]) : p == l ? this.result(-100 + (f ? -200 : 0) + -700 + ($ ? 0 : -1100), a, t) : e.length == 2 ? null : this.result((r[0] ? -700 : 0) + -200 + -1100, r, t);
  }
  result(t, e, i) {
    let r = [], n = 0;
    for (let a of e) {
      let o = a + (this.astral ? oo(Rn(i, a)) : 1);
      n && r[n - 1] == a ? r[n - 1] = o : (r[n++] = a, r[n++] = o);
    }
    return this.ret(t - i.length, r);
  }
}, h(lu, "Sc"), lu);
m(MA, "FuzzyMatcher");
let gq = MA;
var cu;
const AA = (cu = class {
  constructor(t) {
    this.pattern = t, this.matched = [], this.score = 0, this.folded = t.toLowerCase();
  }
  match(t) {
    if (t.length < this.pattern.length)
      return null;
    let e = t.slice(0, this.pattern.length), i = e == this.pattern ? 0 : e.toLowerCase() == this.folded ? -200 : null;
    return i == null ? null : (this.matched = [0, e.length], this.score = i + (t.length == this.pattern.length ? 0 : -100), this);
  }
}, h(cu, "bc"), cu);
m(AA, "StrictMatcher");
let wq = AA;
const ti = /* @__PURE__ */ Ct.define({
  combine(s) {
    return iC(s, {
      activateOnTyping: !0,
      activateOnCompletion: /* @__PURE__ */ m(() => !1, "activateOnCompletion"),
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: /* @__PURE__ */ m(() => "", "tooltipClass"),
      optionClass: /* @__PURE__ */ m(() => "", "optionClass"),
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: RA,
      filterStrict: !1,
      compareCompletions: /* @__PURE__ */ m((t, e) => (t.sortText || t.label).localeCompare(e.sortText || e.label), "compareCompletions"),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: /* @__PURE__ */ m((t, e) => t && e, "defaultKeymap"),
      closeOnBlur: /* @__PURE__ */ m((t, e) => t && e, "closeOnBlur"),
      icons: /* @__PURE__ */ m((t, e) => t && e, "icons"),
      tooltipClass: /* @__PURE__ */ m((t, e) => (i) => P5(t(i), e(i)), "tooltipClass"),
      optionClass: /* @__PURE__ */ m((t, e) => (i) => P5(t(i), e(i)), "optionClass"),
      addToOptions: /* @__PURE__ */ m((t, e) => t.concat(e), "addToOptions"),
      filterStrict: /* @__PURE__ */ m((t, e) => t || e, "filterStrict")
    });
  }
});
function P5(s, t) {
  return s ? t ? s + " " + t : s : t;
}
h(P5, "rO");
m(P5, "joinClass");
function RA(s, t, e, i, r, n) {
  let a = s.textDirection == me.RTL, o = a, l = !1, d = "top", u, p, f = t.left - r.left, y = r.right - t.right, g = i.right - i.left, O = i.bottom - i.top;
  if (o && f < Math.min(g, y) ? o = !1 : !o && y < Math.min(g, f) && (o = !0), g <= (o ? f : y))
    u = Math.max(r.top, Math.min(e.top, r.bottom - O)) - t.top, p = Math.min(400, o ? f : y);
  else {
    l = !0, p = Math.min(
      400,
      (a ? t.right : r.right - t.left) - 30
      /* Info.Margin */
    );
    let T = r.bottom - t.bottom;
    T >= O || T > t.top ? u = e.bottom - t.top : (d = "bottom", u = t.bottom - e.top);
  }
  let k = (t.bottom - t.top) / n.offsetHeight, $ = (t.right - t.left) / n.offsetWidth;
  return {
    style: `${d}: ${u / k}px; max-width: ${p / $}px`,
    class: "cm-completionInfo-" + (l ? a ? "left-narrow" : "right-narrow" : o ? "left" : "right")
  };
}
h(RA, "$Q");
m(RA, "defaultPositionInfo");
function EA(s) {
  let t = s.addToOptions.slice();
  return s.icons && t.push({
    render(e) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), e.type && i.classList.add(...e.type.split(/\s+/g).map((r) => "cm-completionIcon-" + r)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), t.push({
    render(e, i, r, n) {
      let a = document.createElement("span");
      a.className = "cm-completionLabel";
      let o = e.displayLabel || e.label, l = 0;
      for (let d = 0; d < n.length; ) {
        let u = n[d++], p = n[d++];
        u > l && a.appendChild(document.createTextNode(o.slice(l, u)));
        let f = a.appendChild(document.createElement("span"));
        f.appendChild(document.createTextNode(o.slice(u, p))), f.className = "cm-completionMatchedText", l = p;
      }
      return l < o.length && a.appendChild(document.createTextNode(o.slice(l))), a;
    },
    position: 50
  }, {
    render(e) {
      if (!e.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = e.detail, i;
    },
    position: 80
  }), t.sort((e, i) => e.position - i.position).map((e) => e.render);
}
h(EA, "RQ");
m(EA, "optionContent");
function Ev(s, t, e) {
  if (s <= e)
    return { from: 0, to: s };
  if (t < 0 && (t = 0), t <= s >> 1) {
    let r = Math.floor(t / e);
    return { from: r * e, to: (r + 1) * e };
  }
  let i = Math.floor((s - t) / e);
  return { from: s - (i + 1) * e, to: s - i * e };
}
h(Ev, "Uo$1");
m(Ev, "rangeAroundSelected");
var hu;
const _A = (hu = class {
  constructor(t, e, i) {
    this.view = t, this.stateField = e, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: /* @__PURE__ */ m(() => this.measureInfo(), "read"),
      write: /* @__PURE__ */ m((l) => this.placeInfo(l), "write"),
      key: this
    }, this.space = null, this.currentClass = "";
    let r = t.state.field(e), { options: n, selected: a } = r.open, o = t.state.facet(ti);
    this.optionContent = EA(o), this.optionClass = o.optionClass, this.tooltipClass = o.tooltipClass, this.range = Ev(n.length, a, o.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(t.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: d } = t.state.field(e).open;
      for (let u = l.target, p; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (p = /-(\d+)$/.exec(u.id)) && +p[1] < d.length) {
          this.applyCompletion(t, d[+p[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let d = t.state.field(this.stateField, !1);
      d && d.tooltip && t.state.facet(ti).closeOnBlur && l.relatedTarget != t.contentDOM && t.dispatch({ effects: Dw.of(null) });
    }), this.showOptions(n, r.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(t, e) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t, e, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(t) {
    var e;
    let i = t.state.field(this.stateField), r = t.startState.field(this.stateField);
    if (this.updateTooltipClass(t.state), i != r) {
      let { options: n, selected: a, disabled: o } = i.open;
      (!r.open || r.open.options != n) && (this.range = Ev(n.length, a, t.state.facet(ti).maxRenderedOptions), this.showOptions(n, i.id)), this.updateSel(), o != ((e = r.open) === null || e === void 0 ? void 0 : e.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!o);
    }
  }
  updateTooltipClass(t) {
    let e = this.tooltipClass(t);
    if (e != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of e.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = e;
    }
  }
  positioned(t) {
    this.space = t, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let t = this.view.state.field(this.stateField), e = t.open;
    (e.selected > -1 && e.selected < this.range.from || e.selected >= this.range.to) && (this.range = Ev(e.options.length, e.selected, this.view.state.facet(ti).maxRenderedOptions), this.showOptions(e.options, t.id));
    let i = this.updateSelectedOption(e.selected);
    if (i) {
      this.destroyInfo();
      let { completion: r } = e.options[e.selected], { info: n } = r;
      if (!n)
        return;
      let a = typeof n == "string" ? document.createTextNode(n) : n(r);
      if (!a)
        return;
      "then" in a ? a.then((o) => {
        o && this.view.state.field(this.stateField, !1) == t && this.addInfoPane(o, r);
      }).catch((o) => Wi(this.view.state, o, "completion info")) : (this.addInfoPane(a, r), i.setAttribute("aria-describedby", this.info.id));
    }
  }
  addInfoPane(t, e) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", i.id = "cm-completionInfo-" + Math.floor(Math.random() * 65535).toString(16), t.nodeType != null)
      i.appendChild(t), this.infoDestroy = null;
    else {
      let { dom: r, destroy: n } = t;
      i.appendChild(r), this.infoDestroy = n || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(t) {
    let e = null;
    for (let i = this.list.firstChild, r = this.range.from; i; i = i.nextSibling, r++)
      i.nodeName != "LI" || !i.id ? r-- : r == t ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), e = i) : i.hasAttribute("aria-selected") && (i.removeAttribute("aria-selected"), i.removeAttribute("aria-describedby"));
    return e && zA(this.list, e), e;
  }
  measureInfo() {
    let t = this.dom.querySelector("[aria-selected]");
    if (!t || !this.info)
      return null;
    let e = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), r = t.getBoundingClientRect(), n = this.space;
    if (!n) {
      let a = this.dom.ownerDocument.documentElement;
      n = { left: 0, top: 0, right: a.clientWidth, bottom: a.clientHeight };
    }
    return r.top > Math.min(n.bottom, e.bottom) - 10 || r.bottom < Math.max(n.top, e.top) + 10 ? null : this.view.state.facet(ti).positionInfo(this.view, e, r, i, n, this.dom);
  }
  placeInfo(t) {
    this.info && (t ? (t.style && (this.info.style.cssText = t.style), this.info.className = "cm-tooltip cm-completionInfo " + (t.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(t, e, i) {
    const r = document.createElement("ul");
    r.id = e, r.setAttribute("role", "listbox"), r.setAttribute("aria-expanded", "true"), r.setAttribute("aria-label", this.view.state.phrase("Completions")), r.addEventListener("mousedown", (a) => {
      a.target == r && a.preventDefault();
    });
    let n = null;
    for (let a = i.from; a < i.to; a++) {
      let { completion: o, match: l } = t[a], { section: d } = o;
      if (d) {
        let f = typeof d == "string" ? d : d.name;
        if (f != n && (a > i.from || i.from == 0))
          if (n = f, typeof d != "string" && d.header)
            r.appendChild(d.header(d));
          else {
            let y = r.appendChild(document.createElement("completion-section"));
            y.textContent = f;
          }
      }
      const u = r.appendChild(document.createElement("li"));
      u.id = e + "-" + a, u.setAttribute("role", "option");
      let p = this.optionClass(o);
      p && (u.className = p);
      for (let f of this.optionContent) {
        let y = f(o, this.view.state, this.view, l);
        y && u.appendChild(y);
      }
    }
    return i.from && r.classList.add("cm-completionListIncompleteTop"), i.to < t.length && r.classList.add("cm-completionListIncompleteBottom"), r;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}, h(hu, "wc"), hu);
m(_A, "CompletionTooltip");
let vq = _A;
function LA(s, t) {
  return (e) => new vq(e, s, t);
}
h(LA, "vQ");
m(LA, "completionTooltip");
function zA(s, t) {
  let e = s.getBoundingClientRect(), i = t.getBoundingClientRect(), r = e.height / s.offsetHeight;
  i.top < e.top ? s.scrollTop -= (e.top - i.top) / r : i.bottom > e.bottom && (s.scrollTop += (i.bottom - e.bottom) / r);
}
h(zA, "TQ");
m(zA, "scrollIntoView");
function Q5(s) {
  return (s.boost || 0) * 100 + (s.apply ? 10 : 0) + (s.info ? 5 : 0) + (s.type ? 1 : 0);
}
h(Q5, "nO");
m(Q5, "score");
function IA(s, t) {
  let e = [], i = null, r = null, n = /* @__PURE__ */ m((u) => {
    e.push(u);
    let { section: p } = u.completion;
    if (p) {
      i || (i = []);
      let f = typeof p == "string" ? p : p.name;
      i.some((y) => y.name == f) || i.push(typeof p == "string" ? { name: f } : p);
    }
  }, "addOption"), a = t.facet(ti);
  for (let u of s)
    if (u.hasResult()) {
      let p = u.result.getMatch;
      if (u.result.filter === !1)
        for (let f of u.result.options)
          n(new kQ(f, u.source, p ? p(f) : [], 1e9 - e.length));
      else {
        let f = t.sliceDoc(u.from, u.to), y, g = a.filterStrict ? new wq(f) : new gq(f);
        for (let O of u.result.options)
          if (y = g.match(O.label)) {
            let k = O.displayLabel ? p ? p(O, y.matched) : [] : y.matched, $ = y.score + (O.boost || 0);
            if (n(new kQ(O, u.source, k, $)), typeof O.section == "object" && O.section.rank === "dynamic") {
              let { name: T } = O.section;
              r || (r = /* @__PURE__ */ Object.create(null)), r[T] = Math.max($, r[T] || -1e9);
            }
          }
      }
    }
  if (i) {
    let u = /* @__PURE__ */ Object.create(null), p = 0, f = /* @__PURE__ */ m((y, g) => (y.rank === "dynamic" && g.rank === "dynamic" ? r[g.name] - r[y.name] : 0) || (typeof y.rank == "number" ? y.rank : 1e9) - (typeof g.rank == "number" ? g.rank : 1e9) || (y.name < g.name ? -1 : 1), "cmp");
    for (let y of i.sort(f))
      p -= 1e5, u[y.name] = p;
    for (let y of e) {
      let { section: g } = y.completion;
      g && (y.score += u[typeof g == "string" ? g : g.name]);
    }
  }
  let o = [], l = null, d = a.compareCompletions;
  for (let u of e.sort((p, f) => f.score - p.score || d(p.completion, f.completion))) {
    let p = u.completion;
    !l || l.label != p.label || l.detail != p.detail || l.type != null && p.type != null && l.type != p.type || l.apply != p.apply || l.boost != p.boost ? o.push(u) : Q5(u.completion) > Q5(l) && (o[o.length - 1] = u), l = u.completion;
  }
  return o;
}
h(IA, "AQ");
m(IA, "sortOptions");
var os;
const DA = (os = class {
  constructor(t, e, i, r, n, a) {
    this.options = t, this.attrs = e, this.tooltip = i, this.timestamp = r, this.selected = n, this.disabled = a;
  }
  setSelected(t, e) {
    return t == this.selected || t >= this.options.length ? this : new os(this.options, T5(e, t), this.tooltip, this.timestamp, t, this.disabled);
  }
  static build(t, e, i, r, n, a) {
    if (r && !a && t.some((d) => d.isPending))
      return r.setDisabled();
    let o = IA(t, e);
    if (!o.length)
      return r && t.some((d) => d.isPending) ? r.setDisabled() : null;
    let l = e.facet(ti).selectOnOpen ? 0 : -1;
    if (r && r.selected != l && r.selected != -1) {
      let d = r.options[r.selected].completion;
      for (let u = 0; u < o.length; u++)
        if (o[u].completion == d) {
          l = u;
          break;
        }
    }
    return new os(o, T5(i, l), {
      pos: t.reduce((d, u) => u.hasResult() ? Math.min(d, u.from) : d, 1e8),
      create: Sq,
      above: n.aboveCursor
    }, r ? r.timestamp : Date.now(), l, !1);
  }
  map(t) {
    return new os(this.options, this.attrs, { ...this.tooltip, pos: t.mapPos(this.tooltip.pos) }, this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new os(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}, h(os, "Dt"), os);
m(DA, "CompletionDialog");
let Oq = DA;
var aa;
const VA = (aa = class {
  constructor(t, e, i) {
    this.active = t, this.id = e, this.open = i;
  }
  static start() {
    return new aa(kq, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(t) {
    let { state: e } = t, i = e.facet(ti), r = (i.override || e.languageDataAt("autocomplete", Zn(e)).map(TA)).map((o) => (this.active.find((l) => l.source == o) || new uo(
      o,
      this.active.some(
        (l) => l.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(t, i));
    r.length == this.active.length && r.every((o, l) => o == this.active[l]) && (r = this.active);
    let n = this.open, a = t.effects.some((o) => o.is(YC));
    n && t.docChanged && (n = n.map(t.changes)), t.selection || r.some((o) => o.hasResult() && t.changes.touchesRange(o.from, o.to)) || !WA(r, this.active) || a ? n = Oq.build(r, e, this.id, n, i, a) : n && n.disabled && !r.some((o) => o.isPending) && (n = null), !n && r.every((o) => !o.isPending) && r.some((o) => o.hasResult()) && (r = r.map((o) => o.hasResult() ? new uo(
      o.source,
      0
      /* State.Inactive */
    ) : o));
    for (let o of t.effects)
      o.is(NA) && (n = n && n.setSelected(o.value, this.id));
    return r == this.active && n == this.open ? this : new aa(r, this.id, n);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? $q : xq;
  }
}, h(aa, "zr"), aa);
m(VA, "CompletionState");
let bq = VA;
function WA(s, t) {
  if (s == t)
    return !0;
  for (let e = 0, i = 0; ; ) {
    for (; e < s.length && !s[e].hasResult(); )
      e++;
    for (; i < t.length && !t[i].hasResult(); )
      i++;
    let r = e == s.length, n = i == t.length;
    if (r || n)
      return r == n;
    if (s[e++].result != t[i++].result)
      return !1;
  }
}
h(WA, "LQ");
m(WA, "sameResults");
const $q = {
  "aria-autocomplete": "list"
}, xq = {};
function T5(s, t) {
  let e = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": s
  };
  return t > -1 && (e["aria-activedescendant"] = s + "-" + t), e;
}
h(T5, "sO");
m(T5, "makeAttrs");
const kq = [];
function HC(s, t) {
  if (s.isUserEvent("input.complete")) {
    let i = s.annotation(UC);
    if (i && t.activateOnCompletion(i))
      return 12;
  }
  let e = s.isUserEvent("input.type");
  return e && t.activateOnTyping ? 5 : e ? 1 : s.isUserEvent("delete.backward") ? 2 : s.selection ? 8 : s.docChanged ? 16 : 0;
}
h(HC, "Tp$1");
m(HC, "getUpdateType");
var ls;
const FA = (ls = class {
  constructor(t, e, i = !1) {
    this.source = t, this.state = e, this.explicit = i;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(t, e) {
    let i = HC(t, e), r = this;
    (i & 8 || i & 16 && this.touches(t)) && (r = new ls(
      r.source,
      0
      /* State.Inactive */
    )), i & 4 && r.state == 0 && (r = new ls(
      this.source,
      1
      /* State.Pending */
    )), r = r.updateFor(t, i);
    for (let n of t.effects)
      if (n.is(WO))
        r = new ls(r.source, 1, n.value);
      else if (n.is(Dw))
        r = new ls(
          r.source,
          0
          /* State.Inactive */
        );
      else if (n.is(YC))
        for (let a of n.value)
          a.source == r.source && (r = a);
    return r;
  }
  updateFor(t, e) {
    return this.map(t.changes);
  }
  map(t) {
    return this;
  }
  touches(t) {
    return t.changes.touchesRange(Zn(t.state));
  }
}, h(ls, "Nt"), ls);
m(FA, "ActiveSource");
let uo = FA;
var Ys;
const qA = (Ys = class extends uo {
  constructor(t, e, i, r, n, a) {
    super(t, 3, e), this.limit = i, this.result = r, this.from = n, this.to = a;
  }
  hasResult() {
    return !0;
  }
  updateFor(t, e) {
    var i;
    if (!(e & 3))
      return this.map(t.changes);
    let r = this.result;
    r.map && !t.changes.empty && (r = r.map(r, t.changes));
    let n = t.changes.mapPos(this.from), a = t.changes.mapPos(this.to, 1), o = Zn(t.state);
    if (o > a || !r || e & 2 && (Zn(t.startState) == this.from || o < this.limit))
      return new uo(
        this.source,
        e & 4 ? 1 : 0
        /* State.Inactive */
      );
    let l = t.changes.mapPos(this.limit);
    return BA(r.validFor, t.state, n, a) ? new Ys(this.source, this.explicit, l, r, n, a) : r.update && (r = r.update(r, n, a, new NC(t.state, o, !1))) ? new Ys(this.source, this.explicit, l, r, r.from, (i = r.to) !== null && i !== void 0 ? i : Zn(t.state)) : new uo(this.source, 1, this.explicit);
  }
  map(t) {
    return t.empty ? this : (this.result.map ? this.result.map(this.result, t) : this.result) ? new Ys(this.source, this.explicit, t.mapPos(this.limit), this.result, t.mapPos(this.from), t.mapPos(this.to, 1)) : new uo(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(t) {
    return t.changes.touchesRange(this.from, this.to);
  }
}, h(Ys, "yi"), Ys);
m(qA, "ActiveResult");
let ZA = qA;
function BA(s, t, e, i) {
  if (!s)
    return !1;
  let r = t.sliceDoc(e, i);
  return typeof s == "function" ? s(r, e, i, t) : jC(s, !0).test(r);
}
h(BA, "CQ");
m(BA, "checkValid");
const YC = /* @__PURE__ */ te.define({
  map(s, t) {
    return s.map((e) => e.map(t));
  }
}), NA = /* @__PURE__ */ te.define(), Pi = /* @__PURE__ */ mn.define({
  create() {
    return bq.start();
  },
  update(s, t) {
    return s.update(t);
  },
  provide: /* @__PURE__ */ m((s) => [
    iM.from(s, (t) => t.tooltip),
    Mt.contentAttributes.from(s, (t) => t.attrs)
  ], "provide")
});
function rb(s, t) {
  const e = t.completion.apply || t.completion.label;
  let i = s.state.field(Pi).active.find((r) => r.source == t.source);
  return i instanceof ZA ? (typeof e == "string" ? s.dispatch({
    ...QA(s.state, e, i.from, i.to),
    annotations: UC.of(t.completion)
  }) : e(s, t.completion, i.from, i.to), !0) : !1;
}
h(rb, "vh");
m(rb, "applyCompletion");
const Sq = /* @__PURE__ */ LA(Pi, rb);
function zg(s, t = "option") {
  return (e) => {
    let i = e.state.field(Pi, !1);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < e.state.facet(ti).interactionDelay)
      return !1;
    let r = 1, n;
    t == "page" && (n = MC(e, i.open.tooltip)) && (r = Math.max(2, Math.floor(n.dom.offsetHeight / n.dom.querySelector("li").offsetHeight) - 1));
    let { length: a } = i.open.options, o = i.open.selected > -1 ? i.open.selected + r * (s ? 1 : -1) : s ? 0 : a - 1;
    return o < 0 ? o = t == "page" ? 0 : a - 1 : o >= a && (o = t == "page" ? a - 1 : 0), e.dispatch({ effects: NA.of(o) }), !0;
  };
}
h(zg, "Vn$1");
m(zg, "moveCompletionSelection");
const Cq = /* @__PURE__ */ m((s) => {
  let t = s.state.field(Pi, !1);
  return s.state.readOnly || !t || !t.open || t.open.selected < 0 || t.open.disabled || Date.now() - t.open.timestamp < s.state.facet(ti).interactionDelay ? !1 : rb(s, t.open.options[t.open.selected]);
}, "acceptCompletion"), T2 = /* @__PURE__ */ m((s) => s.state.field(Pi, !1) ? (s.dispatch({ effects: WO.of(!0) }), !0) : !1, "startCompletion"), Pq = /* @__PURE__ */ m((s) => {
  let t = s.state.field(Pi, !1);
  return !t || !t.active.some(
    (e) => e.state != 0
    /* State.Inactive */
  ) ? !1 : (s.dispatch({ effects: Dw.of(null) }), !0);
}, "closeCompletion");
var du;
const XA = (du = class {
  constructor(t, e) {
    this.active = t, this.context = e, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}, h(du, "xc"), du);
m(XA, "RunningQuery");
let Qq = XA;
const Tq = 50, Mq = 1e3, Aq = /* @__PURE__ */ rn.fromClass(class {
  constructor(s) {
    this.view = s, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let t of s.state.field(Pi).active)
      t.isPending && this.startQuery(t);
  }
  update(s) {
    let t = s.state.field(Pi), e = s.state.facet(ti);
    if (!s.selectionSet && !s.docChanged && s.startState.field(Pi) == t)
      return;
    let i = s.transactions.some((n) => {
      let a = HC(n, e);
      return a & 8 || (n.selection || n.docChanged) && !(a & 3);
    });
    for (let n = 0; n < this.running.length; n++) {
      let a = this.running[n];
      if (i || a.context.abortOnDocChange && s.docChanged || a.updates.length + s.transactions.length > Tq && Date.now() - a.time > Mq) {
        for (let o of a.context.abortListeners)
          try {
            o();
          } catch (l) {
            Wi(this.view.state, l);
          }
        a.context.abortListeners = null, this.running.splice(n--, 1);
      } else
        a.updates.push(...s.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), s.transactions.some((n) => n.effects.some((a) => a.is(WO))) && (this.pendingStart = !0);
    let r = this.pendingStart ? 50 : e.activateOnTypingDelay;
    if (this.debounceUpdate = t.active.some((n) => n.isPending && !this.running.some((a) => a.active.source == n.source)) ? setTimeout(() => this.startUpdate(), r) : -1, this.composing != 0)
      for (let n of s.transactions)
        n.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && n.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: s } = this.view, t = s.field(Pi);
    for (let e of t.active)
      e.isPending && !this.running.some((i) => i.active.source == e.source) && this.startQuery(e);
    this.running.length && t.open && t.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(ti).updateSyncTime));
  }
  startQuery(s) {
    let { state: t } = this.view, e = Zn(t), i = new NC(t, e, s.explicit, this.view), r = new Qq(s, i);
    this.running.push(r), Promise.resolve(s.source(i)).then((n) => {
      r.context.aborted || (r.done = n || null, this.scheduleAccept());
    }, (n) => {
      this.view.dispatch({ effects: Dw.of(null) }), Wi(this.view.state, n);
    });
  }
  scheduleAccept() {
    this.running.every((s) => s.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(ti).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var s;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let t = [], e = this.view.state.facet(ti), i = this.view.state.field(Pi);
    for (let r = 0; r < this.running.length; r++) {
      let n = this.running[r];
      if (n.done === void 0)
        continue;
      if (this.running.splice(r--, 1), n.done) {
        let o = Zn(n.updates.length ? n.updates[0].startState : this.view.state), l = Math.min(o, n.done.from + (n.active.explicit ? 0 : 1)), d = new ZA(n.active.source, n.active.explicit, l, n.done, n.done.from, (s = n.done.to) !== null && s !== void 0 ? s : o);
        for (let u of n.updates)
          d = d.update(u, e);
        if (d.hasResult()) {
          t.push(d);
          continue;
        }
      }
      let a = i.active.find((o) => o.source == n.active.source);
      if (a && a.isPending)
        if (n.done == null) {
          let o = new uo(
            n.active.source,
            0
            /* State.Inactive */
          );
          for (let l of n.updates)
            o = o.update(l, e);
          o.isPending || t.push(o);
        } else
          this.startQuery(a);
    }
    (t.length || i.open && i.open.disabled) && this.view.dispatch({ effects: YC.of(t) });
  }
}, {
  eventHandlers: {
    blur(s) {
      let t = this.view.state.field(Pi, !1);
      if (t && t.tooltip && this.view.state.facet(ti).closeOnBlur) {
        let e = t.open && MC(this.view, t.open.tooltip);
        (!e || !e.dom.contains(s.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: Dw.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: WO.of(!1) }), 20), this.composing = 0;
    }
  }
}), Rq = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), Eq = /* @__PURE__ */ Ll.highest(/* @__PURE__ */ Mt.domEventHandlers({
  keydown(s, t) {
    let e = t.state.field(Pi, !1);
    if (!e || !e.open || e.open.disabled || e.open.selected < 0 || s.key.length > 1 || s.ctrlKey && !(Rq && s.altKey) || s.metaKey)
      return !1;
    let i = e.open.options[e.open.selected], r = e.active.find((a) => a.source == i.source), n = i.completion.commitCharacters || r.result.commitCharacters;
    return n && n.indexOf(s.key) > -1 && rb(t, i), !1;
  }
})), jA = /* @__PURE__ */ Mt.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
var uu;
const UA = (uu = class {
  constructor(t, e, i, r) {
    this.field = t, this.line = e, this.from = i, this.to = r;
  }
}, h(uu, "kc"), uu);
m(UA, "FieldPos");
let _q = UA;
var Ko;
const HA = (Ko = class {
  constructor(t, e, i) {
    this.field = t, this.from = e, this.to = i;
  }
  map(t) {
    let e = t.mapPos(this.from, -1, Ti.TrackDel), i = t.mapPos(this.to, 1, Ti.TrackDel);
    return e == null || i == null ? null : new Ko(this.field, e, i);
  }
}, h(Ko, "Oo"), Ko);
m(HA, "FieldRange");
let Lq = HA;
var Jo;
const YA = (Jo = class {
  constructor(t, e) {
    this.lines = t, this.fieldPositions = e;
  }
  instantiate(t, e) {
    let i = [], r = [e], n = t.doc.lineAt(e), a = /^\s*/.exec(n.text)[0];
    for (let l of this.lines) {
      if (i.length) {
        let d = a, u = /^\t*/.exec(l)[0].length;
        for (let p = 0; p < u; p++)
          d += t.facet(eb);
        r.push(e + d.length - u), l = d + l.slice(u);
      }
      i.push(l), e += l.length + 1;
    }
    let o = this.fieldPositions.map((l) => new Lq(l.field, r[l.line] + l.from, r[l.line] + l.to));
    return { text: i, ranges: o };
  }
  static parse(t) {
    let e = [], i = [], r = [], n;
    for (let a of t.split(/\r\n?|\n/)) {
      for (; n = /[#$]\{(?:(\d+)(?::([^{}]*))?|((?:\\[{}]|[^{}])*))\}/.exec(a); ) {
        let o = n[1] ? +n[1] : null, l = n[2] || n[3] || "", d = -1, u = l.replace(/\\[{}]/g, (p) => p[1]);
        for (let p = 0; p < e.length; p++)
          (o != null ? e[p].seq == o : u && e[p].name == u) && (d = p);
        if (d < 0) {
          let p = 0;
          for (; p < e.length && (o == null || e[p].seq != null && e[p].seq < o); )
            p++;
          e.splice(p, 0, { seq: o, name: u }), d = p;
          for (let f of r)
            f.field >= d && f.field++;
        }
        for (let p of r)
          if (p.line == i.length && p.from > n.index) {
            let f = n[2] ? 3 + (n[1] || "").length : 2;
            p.from -= f, p.to -= f;
          }
        r.push(new _q(d, i.length, n.index, n.index + u.length)), a = a.slice(0, n.index) + l + a.slice(n.index + n[0].length);
      }
      a = a.replace(/\\([{}])/g, (o, l, d) => {
        for (let u of r)
          u.line == i.length && u.from > d && (u.from--, u.to--);
        return l;
      }), i.push(a);
    }
    return new Jo(i, r);
  }
}, h(Jo, "po"), Jo);
m(YA, "Snippet");
let zq = YA, Iq = /* @__PURE__ */ se.widget({ widget: /* @__PURE__ */ new class extends zl {
  toDOM() {
    let s = document.createElement("span");
    return s.className = "cm-snippetFieldPosition", s;
  }
  ignoreEvent() {
    return !1;
  }
}() }), Dq = /* @__PURE__ */ se.mark({ class: "cm-snippetField" });
var tl;
const GA = (tl = class {
  constructor(t, e) {
    this.ranges = t, this.active = e, this.deco = se.set(t.map((i) => (i.from == i.to ? Iq : Dq).range(i.from, i.to)), !0);
  }
  map(t) {
    let e = [];
    for (let i of this.ranges) {
      let r = i.map(t);
      if (!r)
        return null;
      e.push(r);
    }
    return new tl(e, this.active);
  }
  selectionInsideField(t) {
    return t.ranges.every((e) => this.ranges.some((i) => i.field == this.active && i.from <= e.from && i.to >= e.to));
  }
}, h(tl, "mo"), tl);
m(GA, "ActiveSnippet");
let sb = GA;
const $1 = /* @__PURE__ */ te.define({
  map(s, t) {
    return s && s.map(t);
  }
}), Vq = /* @__PURE__ */ te.define(), Vw = /* @__PURE__ */ mn.define({
  create() {
    return null;
  },
  update(s, t) {
    for (let e of t.effects) {
      if (e.is($1))
        return e.value;
      if (e.is(Vq) && s)
        return new sb(s.ranges, e.value);
    }
    return s && t.docChanged && (s = s.map(t.changes)), s && t.selection && !s.selectionInsideField(t.selection) && (s = null), s;
  },
  provide: /* @__PURE__ */ m((s) => Mt.decorations.from(s, (t) => t ? t.deco : se.none), "provide")
});
function nb(s, t) {
  return nt.create(s.filter((e) => e.field == t).map((e) => nt.range(e.from, e.to)));
}
h(nb, "Th$1");
m(nb, "fieldSelection");
function KA(s) {
  let t = zq.parse(s);
  return (e, i, r, n) => {
    let { text: a, ranges: o } = t.instantiate(e.state, r), { main: l } = e.state.selection, d = {
      changes: { from: r, to: n == l.from ? l.to : n, insert: Ht.of(a) },
      scrollIntoView: !0,
      annotations: i ? [UC.of(i), Mi.userEvent.of("input.complete")] : void 0
    };
    if (o.length && (d.selection = nb(o, 0)), o.some((u) => u.field > 0)) {
      let u = new sb(o, 0), p = d.effects = [$1.of(u)];
      e.state.field(Vw, !1) === void 0 && p.push(te.appendConfig.of([Vw, Bq, Nq, jA]));
    }
    e.dispatch(e.state.update(d));
  };
}
h(KA, "BQ");
m(KA, "snippet");
function GC(s) {
  return ({ state: t, dispatch: e }) => {
    let i = t.field(Vw, !1);
    if (!i || s < 0 && i.active == 0)
      return !1;
    let r = i.active + s, n = s > 0 && !i.ranges.some((a) => a.field == r + s);
    return e(t.update({
      selection: nb(i.ranges, r),
      effects: $1.of(n ? null : new sb(i.ranges, r)),
      scrollIntoView: !0
    })), !0;
  };
}
h(GC, "Mp$1");
m(GC, "moveField");
const Wq = /* @__PURE__ */ m(({ state: s, dispatch: t }) => s.field(Vw, !1) ? (t(s.update({ effects: $1.of(null) })), !0) : !1, "clearSnippet"), Fq = /* @__PURE__ */ GC(1), qq = /* @__PURE__ */ GC(-1), Zq = [
  { key: "Tab", run: Fq, shift: qq },
  { key: "Escape", run: Wq }
], CQ = /* @__PURE__ */ Ct.define({
  combine(s) {
    return s.length ? s[0] : Zq;
  }
}), Bq = /* @__PURE__ */ Ll.highest(/* @__PURE__ */ Y0.compute([CQ], (s) => s.facet(CQ)));
function ki(s, t) {
  return { ...t, apply: KA(s) };
}
h(ki, "ge$2");
m(ki, "snippetCompletion");
const Nq = /* @__PURE__ */ Mt.domEventHandlers({
  mousedown(s, t) {
    let e = t.state.field(Vw, !1), i;
    if (!e || (i = t.posAtCoords({ x: s.clientX, y: s.clientY })) == null)
      return !1;
    let r = e.ranges.find((n) => n.from <= i && n.to >= i);
    return !r || r.field == e.active ? !1 : (t.dispatch({
      selection: nb(e.ranges, r.field),
      effects: $1.of(e.ranges.some((n) => n.field > r.field) ? new sb(e.ranges, r.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), JA = /* @__PURE__ */ new class extends da {
}();
JA.startSide = 1;
JA.endSide = -1;
function Xq(s = {}) {
  return [
    Eq,
    Pi,
    ti.of(s),
    Aq,
    Uq,
    jA
  ];
}
h(Xq, "JQ");
m(Xq, "autocompletion");
const jq = [
  { key: "Ctrl-Space", run: T2 },
  { mac: "Alt-`", run: T2 },
  { mac: "Alt-i", run: T2 },
  { key: "Escape", run: Pq },
  { key: "ArrowDown", run: /* @__PURE__ */ zg(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ zg(!1) },
  { key: "PageDown", run: /* @__PURE__ */ zg(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ zg(!1, "page") },
  { key: "Enter", run: Cq }
], Uq = /* @__PURE__ */ Ll.highest(/* @__PURE__ */ Y0.computeN([ti], (s) => s.facet(ti).defaultKeymap ? [jq] : []));
function Hq(s) {
  let t = s.field(Pi, !1);
  return t && t.active.some((e) => e.isPending) ? "pending" : t && t.active.some(
    (e) => e.state != 0
    /* State.Inactive */
  ) ? "active" : null;
}
h(Hq, "iy$1");
m(Hq, "completionStatus");
var el;
const tR = (el = class {
  static create(t, e, i, r, n) {
    let a = r + (r << 8) + t + (e << 4) | 0;
    return new el(t, e, i, a, n, [], []);
  }
  constructor(t, e, i, r, n, a, o) {
    this.type = t, this.value = e, this.from = i, this.hash = r, this.end = n, this.children = a, this.positions = o, this.hashProp = [[Et.contextHash, r]];
  }
  addChild(t, e) {
    t.prop(Et.contextHash) != this.hash && (t = new Ft(t.type, t.children, t.positions, t.length, this.hashProp)), this.children.push(t), this.positions.push(e);
  }
  toTree(t, e = this.end) {
    let i = this.children.length - 1;
    return i >= 0 && (e = Math.max(e, this.positions[i] + this.children[i].length + this.from)), new Ft(t.types[this.type], this.children, this.positions, e - this.from).balance({
      makeTree: /* @__PURE__ */ m((r, n, a) => new Ft(ei.none, r, n, a, this.hashProp), "makeTree")
    });
  }
}, h(el, "go"), el);
m(tR, "CompositeBlock");
let PQ = tR;
var K;
(function(s) {
  s[s.Document = 1] = "Document", s[s.CodeBlock = 2] = "CodeBlock", s[s.FencedCode = 3] = "FencedCode", s[s.Blockquote = 4] = "Blockquote", s[s.HorizontalRule = 5] = "HorizontalRule", s[s.BulletList = 6] = "BulletList", s[s.OrderedList = 7] = "OrderedList", s[s.ListItem = 8] = "ListItem", s[s.ATXHeading1 = 9] = "ATXHeading1", s[s.ATXHeading2 = 10] = "ATXHeading2", s[s.ATXHeading3 = 11] = "ATXHeading3", s[s.ATXHeading4 = 12] = "ATXHeading4", s[s.ATXHeading5 = 13] = "ATXHeading5", s[s.ATXHeading6 = 14] = "ATXHeading6", s[s.SetextHeading1 = 15] = "SetextHeading1", s[s.SetextHeading2 = 16] = "SetextHeading2", s[s.HTMLBlock = 17] = "HTMLBlock", s[s.LinkReference = 18] = "LinkReference", s[s.Paragraph = 19] = "Paragraph", s[s.CommentBlock = 20] = "CommentBlock", s[s.ProcessingInstructionBlock = 21] = "ProcessingInstructionBlock", s[s.Escape = 22] = "Escape", s[s.Entity = 23] = "Entity", s[s.HardBreak = 24] = "HardBreak", s[s.Emphasis = 25] = "Emphasis", s[s.StrongEmphasis = 26] = "StrongEmphasis", s[s.Link = 27] = "Link", s[s.Image = 28] = "Image", s[s.InlineCode = 29] = "InlineCode", s[s.HTMLTag = 30] = "HTMLTag", s[s.Comment = 31] = "Comment", s[s.ProcessingInstruction = 32] = "ProcessingInstruction", s[s.Autolink = 33] = "Autolink", s[s.HeaderMark = 34] = "HeaderMark", s[s.QuoteMark = 35] = "QuoteMark", s[s.ListMark = 36] = "ListMark", s[s.LinkMark = 37] = "LinkMark", s[s.EmphasisMark = 38] = "EmphasisMark", s[s.CodeMark = 39] = "CodeMark", s[s.CodeText = 40] = "CodeText", s[s.CodeInfo = 41] = "CodeInfo", s[s.LinkTitle = 42] = "LinkTitle", s[s.LinkLabel = 43] = "LinkLabel", s[s.URL = 44] = "URL";
})(K || (K = {}));
var pu;
const eR = (pu = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.start = t, this.content = e, this.marks = [], this.parsers = [];
  }
}, h(pu, "Pc"), pu);
m(eR, "LeafBlock");
let Yq = eR;
var fu;
const iR = (fu = class {
  constructor() {
    this.text = "", this.baseIndent = 0, this.basePos = 0, this.depth = 0, this.markers = [], this.pos = 0, this.indent = 0, this.next = -1;
  }
  /**
  @internal
  */
  forward() {
    this.basePos > this.pos && this.forwardInner();
  }
  /**
  @internal
  */
  forwardInner() {
    let t = this.skipSpace(this.basePos);
    this.indent = this.countIndent(t, this.pos, this.indent), this.pos = t, this.next = t == this.text.length ? -1 : this.text.charCodeAt(t);
  }
  /**
  Skip whitespace after the given position, return the position of
  the next non-space character or the end of the line if there's
  only space after `from`.
  */
  skipSpace(t) {
    return kh(this.text, t);
  }
  /**
  @internal
  */
  reset(t) {
    for (this.text = t, this.baseIndent = this.basePos = this.pos = this.indent = 0, this.forwardInner(), this.depth = 1; this.markers.length; )
      this.markers.pop();
  }
  /**
  Move the line's base position forward to the given position.
  This should only be called by composite [block
  parsers](#BlockParser.parse) or [markup skipping
  functions](#NodeSpec.composite).
  */
  moveBase(t) {
    this.basePos = t, this.baseIndent = this.countIndent(t, this.pos, this.indent);
  }
  /**
  Move the line's base position forward to the given _column_.
  */
  moveBaseColumn(t) {
    this.baseIndent = t, this.basePos = this.findColumn(t);
  }
  /**
  Store a composite-block-level marker. Should be called from
  [markup skipping functions](#NodeSpec.composite) when they
  consume any non-whitespace characters.
  */
  addMarker(t) {
    this.markers.push(t);
  }
  /**
  Find the column position at `to`, optionally starting at a given
  position and column.
  */
  countIndent(t, e = 0, i = 0) {
    for (let r = e; r < t; r++)
      i += this.text.charCodeAt(r) == 9 ? 4 - i % 4 : 1;
    return i;
  }
  /**
  Find the position corresponding to the given column.
  */
  findColumn(t) {
    let e = 0;
    for (let i = 0; e < this.text.length && i < t; e++)
      i += this.text.charCodeAt(e) == 9 ? 4 - i % 4 : 1;
    return e;
  }
  /**
  @internal
  */
  scrub() {
    if (!this.baseIndent)
      return this.text;
    let t = "";
    for (let e = 0; e < this.basePos; e++)
      t += " ";
    return t + this.text.slice(this.basePos);
  }
}, h(fu, "$c"), fu);
m(iR, "Line");
let Gq = iR;
function M5(s, t, e) {
  if (e.pos == e.text.length || s != t.block && e.indent >= t.stack[e.depth + 1].value + e.baseIndent)
    return !0;
  if (e.indent >= e.baseIndent + 4)
    return !1;
  let i = (s.type == K.OrderedList ? lb : ob)(e, t, !1);
  return i > 0 && (s.type != K.BulletList || ab(e, t, !1) < 0) && e.text.charCodeAt(e.pos + i - 1) == s.value;
}
h(M5, "lO");
m(M5, "skipForList");
const rR = {
  [K.Blockquote](s, t, e) {
    return e.next != 62 ? !1 : (e.markers.push(Wt(K.QuoteMark, t.lineStart + e.pos, t.lineStart + e.pos + 1)), e.moveBase(e.pos + (cr(e.text.charCodeAt(e.pos + 1)) ? 2 : 1)), s.end = t.lineStart + e.text.length, !0);
  },
  [K.ListItem](s, t, e) {
    return e.indent < e.baseIndent + s.value && e.next > -1 ? !1 : (e.moveBaseColumn(e.baseIndent + s.value), !0);
  },
  [K.OrderedList]: M5,
  [K.BulletList]: M5,
  [K.Document]() {
    return !0;
  }
};
function cr(s) {
  return s == 32 || s == 9 || s == 10 || s == 13;
}
h(cr, "Ye");
m(cr, "space$2");
function kh(s, t = 0) {
  for (; t < s.length && cr(s.charCodeAt(t)); )
    t++;
  return t;
}
h(kh, "Pr$1");
m(kh, "skipSpace");
function A5(s, t, e) {
  for (; t > e && cr(s.charCodeAt(t - 1)); )
    t--;
  return t;
}
h(A5, "aO");
m(A5, "skipSpaceBack");
function KC(s) {
  if (s.next != 96 && s.next != 126)
    return -1;
  let t = s.pos + 1;
  for (; t < s.text.length && s.text.charCodeAt(t) == s.next; )
    t++;
  if (t < s.pos + 3)
    return -1;
  if (s.next == 96) {
    for (let e = t; e < s.text.length; e++)
      if (s.text.charCodeAt(e) == 96)
        return -1;
  }
  return t;
}
h(KC, "Xp");
m(KC, "isFencedCode");
function JC(s) {
  return s.next != 62 ? -1 : s.text.charCodeAt(s.pos + 1) == 32 ? 2 : 1;
}
h(JC, "Ep$1");
m(JC, "isBlockquote");
function ab(s, t, e) {
  if (s.next != 42 && s.next != 45 && s.next != 95)
    return -1;
  let i = 1;
  for (let r = s.pos + 1; r < s.text.length; r++) {
    let n = s.text.charCodeAt(r);
    if (n == s.next)
      i++;
    else if (!cr(n))
      return -1;
  }
  return e && s.next == 45 && iP(s) > -1 && s.depth == t.stack.length && t.parser.leafBlockParsers.indexOf(lR.SetextHeading) > -1 || i < 3 ? -1 : 1;
}
h(ab, "Ah$1");
m(ab, "isHorizontalRule");
function tP(s, t) {
  for (let e = s.stack.length - 1; e >= 0; e--)
    if (s.stack[e].type == t)
      return !0;
  return !1;
}
h(tP, "Yp$1");
m(tP, "inList");
function ob(s, t, e) {
  return (s.next == 45 || s.next == 43 || s.next == 42) && (s.pos == s.text.length - 1 || cr(s.text.charCodeAt(s.pos + 1))) && (!e || tP(t, K.BulletList) || s.skipSpace(s.pos + 2) < s.text.length) ? 1 : -1;
}
h(ob, "Lh$1");
m(ob, "isBulletList");
function lb(s, t, e) {
  let i = s.pos, r = s.next;
  for (; r >= 48 && r <= 57; ) {
    if (i++, i == s.text.length)
      return -1;
    r = s.text.charCodeAt(i);
  }
  return i == s.pos || i > s.pos + 9 || r != 46 && r != 41 || i < s.text.length - 1 && !cr(s.text.charCodeAt(i + 1)) || e && !tP(t, K.OrderedList) && (s.skipSpace(i + 1) == s.text.length || i > s.pos + 1 || s.next != 49) ? -1 : i + 1 - s.pos;
}
h(lb, "_h$1");
m(lb, "isOrderedList");
function eP(s) {
  if (s.next != 35)
    return -1;
  let t = s.pos + 1;
  for (; t < s.text.length && s.text.charCodeAt(t) == 35; )
    t++;
  if (t < s.text.length && s.text.charCodeAt(t) != 32)
    return -1;
  let e = t - s.pos;
  return e > 6 ? -1 : e;
}
h(eP, "Wp");
m(eP, "isAtxHeading");
function iP(s) {
  if (s.next != 45 && s.next != 61 || s.indent >= s.baseIndent + 4)
    return -1;
  let t = s.pos + 1;
  for (; t < s.text.length && s.text.charCodeAt(t) == s.next; )
    t++;
  let e = t;
  for (; t < s.text.length && cr(s.text.charCodeAt(t)); )
    t++;
  return t == s.text.length ? e : -1;
}
h(iP, "Vp$1");
m(iP, "isSetextUnderline");
const R5 = /^[ \t]*$/, sR = /-->/, nR = /\?>/, E5 = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, sR],
  [/^\s*<\?/, nR],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, R5],
  [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, R5]
];
function rP(s, t, e) {
  if (s.next != 60)
    return -1;
  let i = s.text.slice(s.pos);
  for (let r = 0, n = E5.length - (e ? 1 : 0); r < n; r++)
    if (E5[r][0].test(i))
      return r;
  return -1;
}
h(rP, "zp$1");
m(rP, "isHTMLBlock");
function _5(s, t) {
  let e = s.countIndent(t, s.pos, s.indent), i = s.countIndent(s.skipSpace(t), t, e);
  return i >= e + 5 ? e + 1 : i;
}
h(_5, "hO");
m(_5, "getListIndent");
function Qn(s, t, e) {
  let i = s.length - 1;
  i >= 0 && s[i].to == t && s[i].type == K.CodeText ? s[i].to = e : s.push(Wt(K.CodeText, t, e));
}
h(Qn, "Wt$2");
m(Qn, "addCodeText");
const cv = {
  LinkReference: void 0,
  IndentedCode(s, t) {
    let e = t.baseIndent + 4;
    if (t.indent < e)
      return !1;
    let i = t.findColumn(e), r = s.lineStart + i, n = s.lineStart + t.text.length, a = [], o = [];
    for (Qn(a, r, n); s.nextLine() && t.depth >= s.stack.length; )
      if (t.pos == t.text.length) {
        Qn(o, s.lineStart - 1, s.lineStart);
        for (let l of t.markers)
          o.push(l);
      } else {
        if (t.indent < e)
          break;
        {
          if (o.length) {
            for (let d of o)
              d.type == K.CodeText ? Qn(a, d.from, d.to) : a.push(d);
            o = [];
          }
          Qn(a, s.lineStart - 1, s.lineStart);
          for (let d of t.markers)
            a.push(d);
          n = s.lineStart + t.text.length;
          let l = s.lineStart + t.findColumn(t.baseIndent + 4);
          l < n && Qn(a, l, n);
        }
      }
    return o.length && (o = o.filter((l) => l.type != K.CodeText), o.length && (t.markers = o.concat(t.markers))), s.addNode(s.buffer.writeElements(a, -r).finish(K.CodeBlock, n - r), r), !0;
  },
  FencedCode(s, t) {
    let e = KC(t);
    if (e < 0)
      return !1;
    let i = s.lineStart + t.pos, r = t.next, n = e - t.pos, a = t.skipSpace(e), o = A5(t.text, t.text.length, a), l = [Wt(K.CodeMark, i, i + n)];
    a < o && l.push(Wt(K.CodeInfo, s.lineStart + a, s.lineStart + o));
    for (let d = !0; s.nextLine() && t.depth >= s.stack.length; d = !1) {
      let u = t.pos;
      if (t.indent - t.baseIndent < 4)
        for (; u < t.text.length && t.text.charCodeAt(u) == r; )
          u++;
      if (u - t.pos >= n && t.skipSpace(u) == t.text.length) {
        for (let p of t.markers)
          l.push(p);
        l.push(Wt(K.CodeMark, s.lineStart + t.pos, s.lineStart + u)), s.nextLine();
        break;
      } else {
        d || Qn(l, s.lineStart - 1, s.lineStart);
        for (let y of t.markers)
          l.push(y);
        let p = s.lineStart + t.basePos, f = s.lineStart + t.text.length;
        p < f && Qn(l, p, f);
      }
    }
    return s.addNode(s.buffer.writeElements(l, -i).finish(K.FencedCode, s.prevLineEnd() - i), i), !0;
  },
  Blockquote(s, t) {
    let e = JC(t);
    return e < 0 ? !1 : (s.startContext(K.Blockquote, t.pos), s.addNode(K.QuoteMark, s.lineStart + t.pos, s.lineStart + t.pos + 1), t.moveBase(t.pos + e), null);
  },
  HorizontalRule(s, t) {
    if (ab(t, s, !1) < 0)
      return !1;
    let e = s.lineStart + t.pos;
    return s.nextLine(), s.addNode(K.HorizontalRule, e), !0;
  },
  BulletList(s, t) {
    let e = ob(t, s, !1);
    if (e < 0)
      return !1;
    s.block.type != K.BulletList && s.startContext(K.BulletList, t.basePos, t.next);
    let i = _5(t, t.pos + 1);
    return s.startContext(K.ListItem, t.basePos, i - t.baseIndent), s.addNode(K.ListMark, s.lineStart + t.pos, s.lineStart + t.pos + e), t.moveBaseColumn(i), null;
  },
  OrderedList(s, t) {
    let e = lb(t, s, !1);
    if (e < 0)
      return !1;
    s.block.type != K.OrderedList && s.startContext(K.OrderedList, t.basePos, t.text.charCodeAt(t.pos + e - 1));
    let i = _5(t, t.pos + e);
    return s.startContext(K.ListItem, t.basePos, i - t.baseIndent), s.addNode(K.ListMark, s.lineStart + t.pos, s.lineStart + t.pos + e), t.moveBaseColumn(i), null;
  },
  ATXHeading(s, t) {
    let e = eP(t);
    if (e < 0)
      return !1;
    let i = t.pos, r = s.lineStart + i, n = A5(t.text, t.text.length, i), a = n;
    for (; a > i && t.text.charCodeAt(a - 1) == t.next; )
      a--;
    (a == n || a == i || !cr(t.text.charCodeAt(a - 1))) && (a = t.text.length);
    let o = s.buffer.write(K.HeaderMark, 0, e).writeElements(s.parser.parseInline(t.text.slice(i + e + 1, a), r + e + 1), -r);
    a < t.text.length && o.write(K.HeaderMark, a - i, n - i);
    let l = o.finish(K.ATXHeading1 - 1 + e, t.text.length - i);
    return s.nextLine(), s.addNode(l, r), !0;
  },
  HTMLBlock(s, t) {
    let e = rP(t, s, !1);
    if (e < 0)
      return !1;
    let i = s.lineStart + t.pos, r = E5[e][1], n = [], a = r != R5;
    for (; !r.test(t.text) && s.nextLine(); ) {
      if (t.depth < s.stack.length) {
        a = !1;
        break;
      }
      for (let d of t.markers)
        n.push(d);
    }
    a && s.nextLine();
    let o = r == sR ? K.CommentBlock : r == nR ? K.ProcessingInstructionBlock : K.HTMLBlock, l = s.prevLineEnd();
    return s.addNode(s.buffer.writeElements(n, -i).finish(o, l - i), i), !0;
  },
  SetextHeading: void 0
  // Specifies relative precedence for block-continue function
};
var mu;
const aR = (mu = class {
  constructor(t) {
    this.stage = 0, this.elts = [], this.pos = 0, this.start = t.start, this.advance(t.content);
  }
  nextLine(t, e, i) {
    if (this.stage == -1)
      return !1;
    let r = i.content + `
` + e.scrub(), n = this.advance(r);
    return n > -1 && n < r.length ? this.complete(t, i, n) : !1;
  }
  finish(t, e) {
    return (this.stage == 2 || this.stage == 3) && kh(e.content, this.pos) == e.content.length ? this.complete(t, e, e.content.length) : !1;
  }
  complete(t, e, i) {
    return t.addLeafElement(e, Wt(K.LinkReference, this.start, this.start + i, this.elts)), !0;
  }
  nextStage(t) {
    return t ? (this.pos = t.to - this.start, this.elts.push(t), this.stage++, !0) : (t === !1 && (this.stage = -1), !1);
  }
  advance(t) {
    for (; ; ) {
      if (this.stage == -1)
        return -1;
      if (this.stage == 0) {
        if (!this.nextStage(oP(t, this.pos, this.start, !0)))
          return -1;
        if (t.charCodeAt(this.pos) != 58)
          return this.stage = -1;
        this.elts.push(Wt(K.LinkMark, this.pos + this.start, this.pos + this.start + 1)), this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(nP(t, kh(t, this.pos), this.start)))
          return -1;
      } else if (this.stage == 2) {
        let e = kh(t, this.pos), i = 0;
        if (e > this.pos) {
          let r = aP(t, e, this.start);
          if (r) {
            let n = _v(t, r.to - this.start);
            n > 0 && (this.nextStage(r), i = n);
          }
        }
        return i || (i = _v(t, this.pos)), i > 0 && i < t.length ? i : -1;
      } else
        return _v(t, this.pos);
    }
  }
}, h(mu, "Rc"), mu);
m(aR, "LinkReferenceParser");
let Kq = aR;
function _v(s, t) {
  for (; t < s.length; t++) {
    let e = s.charCodeAt(t);
    if (e == 10)
      break;
    if (!cr(e))
      return -1;
  }
  return t;
}
h(_v, "zo$1");
m(_v, "lineEnd");
var yu;
const oR = (yu = class {
  nextLine(t, e, i) {
    let r = e.depth < t.stack.length ? -1 : iP(e), n = e.next;
    if (r < 0)
      return !1;
    let a = Wt(K.HeaderMark, t.lineStart + e.pos, t.lineStart + r);
    return t.nextLine(), t.addLeafElement(i, Wt(n == 61 ? K.SetextHeading1 : K.SetextHeading2, i.start, t.prevLineEnd(), [
      ...t.parser.parseInline(i.content, i.start),
      a
    ])), !0;
  }
  finish() {
    return !1;
  }
}, h(yu, "vc"), yu);
m(oR, "SetextHeadingParser");
let Jq = oR;
const lR = {
  LinkReference(s, t) {
    return t.content.charCodeAt(0) == 91 ? new Kq(t) : null;
  },
  SetextHeading() {
    return new Jq();
  }
}, tZ = [
  (s, t) => eP(t) >= 0,
  (s, t) => KC(t) >= 0,
  (s, t) => JC(t) >= 0,
  (s, t) => ob(t, s, !0) >= 0,
  (s, t) => lb(t, s, !0) >= 0,
  (s, t) => ab(t, s, !0) >= 0,
  (s, t) => rP(t, s, !0) >= 0
], eZ = { text: "", end: 0 };
var gu;
const cR = (gu = class {
  /**
  @internal
  */
  constructor(t, e, i, r) {
    this.parser = t, this.input = e, this.ranges = r, this.line = new Gq(), this.atEnd = !1, this.reusePlaceholders = /* @__PURE__ */ new Map(), this.stoppedAt = null, this.rangeI = 0, this.to = r[r.length - 1].to, this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = r[0].from, this.block = PQ.create(K.Document, 0, this.lineStart, 0, 0), this.stack = [this.block], this.fragments = i.length ? new sZ(i, e) : null, this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
      return this.finish();
    let { line: t } = this;
    for (; ; ) {
      for (let i = 0; ; ) {
        let r = t.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
        for (; i < t.markers.length && (!r || t.markers[i].from < r.end); ) {
          let n = t.markers[i++];
          this.addNode(n.type, n.from, n.to);
        }
        if (!r)
          break;
        this.finishContext();
      }
      if (t.pos < t.text.length)
        break;
      if (!this.nextLine())
        return this.finish();
    }
    if (this.fragments && this.reuseFragment(t.basePos))
      return null;
    t: for (; ; ) {
      for (let i of this.parser.blockParsers)
        if (i) {
          let r = i(this, t);
          if (r != !1) {
            if (r == !0)
              return null;
            t.forward();
            continue t;
          }
        }
      break;
    }
    let e = new Yq(this.lineStart + t.pos, t.text.slice(t.pos));
    for (let i of this.parser.leafBlockParsers)
      if (i) {
        let r = i(this, e);
        r && e.parsers.push(r);
      }
    t: for (; this.nextLine() && t.pos != t.text.length; ) {
      if (t.indent < t.baseIndent + 4) {
        for (let i of this.parser.endLeafBlock)
          if (i(this, t, e))
            break t;
      }
      for (let i of e.parsers)
        if (i.nextLine(this, t, e))
          return null;
      e.content += `
` + t.scrub();
      for (let i of t.markers)
        e.marks.push(i);
    }
    return this.finishLeaf(e), null;
  }
  stopAt(t) {
    if (this.stoppedAt != null && this.stoppedAt < t)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = t;
  }
  reuseFragment(t) {
    if (!this.fragments.moveTo(this.absoluteLineStart + t, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
      return !1;
    let e = this.fragments.takeNodes(this);
    return e ? (this.absoluteLineStart += e, this.lineStart = cP(this.absoluteLineStart, this.ranges), this.moveRangeI(), this.absoluteLineStart < this.to ? (this.lineStart++, this.absoluteLineStart++, this.readLine()) : (this.atEnd = !0, this.readLine()), !0) : !1;
  }
  /**
  The number of parent blocks surrounding the current block.
  */
  get depth() {
    return this.stack.length;
  }
  /**
  Get the type of the parent block at the given depth. When no
  depth is passed, return the type of the innermost parent.
  */
  parentType(t = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[t].type];
  }
  /**
  Move to the next input line. This should only be called by
  (non-composite) [block parsers](#BlockParser.parse) that consume
  the line directly, or leaf block parser
  [`nextLine`](#LeafBlockParser.nextLine) methods when they
  consume the current line (and return true).
  */
  nextLine() {
    return this.lineStart += this.line.text.length, this.absoluteLineEnd >= this.to ? (this.absoluteLineStart = this.absoluteLineEnd, this.atEnd = !0, this.readLine(), !1) : (this.lineStart++, this.absoluteLineStart = this.absoluteLineEnd + 1, this.moveRangeI(), this.readLine(), !0);
  }
  /**
  Retrieve the text of the line after the current one, without
  actually moving the context's current line forward.
  */
  peekLine() {
    return this.scanLine(this.absoluteLineEnd + 1).text;
  }
  moveRangeI() {
    for (; this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to; )
      this.rangeI++, this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
  }
  /**
  @internal
  Collect the text for the next line.
  */
  scanLine(t) {
    let e = eZ;
    if (e.end = t, t >= this.to)
      e.text = "";
    else if (e.text = this.lineChunkAt(t), e.end += e.text.length, this.ranges.length > 1) {
      let i = this.absoluteLineStart, r = this.rangeI;
      for (; this.ranges[r].to < e.end; ) {
        r++;
        let n = this.ranges[r].from, a = this.lineChunkAt(n);
        e.end = n + a.length, e.text = e.text.slice(0, this.ranges[r - 1].to - i) + a, i = e.end - e.text.length;
      }
    }
    return e;
  }
  /**
  @internal
  Populate this.line with the content of the next line. Skip
  leading characters covered by composite blocks.
  */
  readLine() {
    let { line: t } = this, { text: e, end: i } = this.scanLine(this.absoluteLineStart);
    for (this.absoluteLineEnd = i, t.reset(e); t.depth < this.stack.length; t.depth++) {
      let r = this.stack[t.depth], n = this.parser.skipContextMarkup[r.type];
      if (!n)
        throw new Error("Unhandled block context " + K[r.type]);
      let a = this.line.markers.length;
      if (!n(r, this, t)) {
        this.line.markers.length > a && (r.end = this.line.markers[this.line.markers.length - 1].to);
        break;
      }
      t.forward();
    }
  }
  lineChunkAt(t) {
    let e = this.input.chunk(t), i;
    if (this.input.lineChunks)
      i = e == `
` ? "" : e;
    else {
      let r = e.indexOf(`
`);
      i = r < 0 ? e : e.slice(0, r);
    }
    return t + i.length > this.to ? i.slice(0, this.to - t) : i;
  }
  /**
  The end position of the previous line.
  */
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  /**
  @internal
  */
  startContext(t, e, i = 0) {
    this.block = PQ.create(t, i, this.lineStart + e, this.block.hash, this.lineStart + this.line.text.length), this.stack.push(this.block);
  }
  /**
  Start a composite block. Should only be called from [block
  parser functions](#BlockParser.parse) that return null.
  */
  startComposite(t, e, i = 0) {
    this.startContext(this.parser.getNodeType(t), e, i);
  }
  /**
  @internal
  */
  addNode(t, e, i) {
    typeof t == "number" && (t = new Ft(this.parser.nodeSet.types[t], my, my, (i ?? this.prevLineEnd()) - e)), this.block.addChild(t, e - this.block.from);
  }
  /**
  Add a block element. Can be called by [block
  parsers](#BlockParser.parse).
  */
  addElement(t) {
    this.block.addChild(t.toTree(this.parser.nodeSet), t.from - this.block.from);
  }
  /**
  Add a block element from a [leaf parser](#LeafBlockParser). This
  makes sure any extra composite block markup (such as blockquote
  markers) inside the block are also added to the syntax tree.
  */
  addLeafElement(t, e) {
    this.addNode(this.buffer.writeElements(ZO(e.children, t.marks), -e.from).finish(e.type, e.to - e.from), e.from);
  }
  /**
  @internal
  */
  finishContext() {
    let t = this.stack.pop(), e = this.stack[this.stack.length - 1];
    e.addChild(t.toTree(this.parser.nodeSet), t.from - e.from), this.block = e;
  }
  finish() {
    for (; this.stack.length > 1; )
      this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(t) {
    return this.ranges.length > 1 ? sP(this.ranges, 0, t.topNode, this.ranges[0].from, this.reusePlaceholders) : t;
  }
  /**
  @internal
  */
  finishLeaf(t) {
    for (let i of t.parsers)
      if (i.finish(this, t))
        return;
    let e = ZO(this.parser.parseInline(t.content, t.start), t.marks);
    this.addNode(this.buffer.writeElements(e, -t.start).finish(K.Paragraph, t.content.length), t.start);
  }
  elt(t, e, i, r) {
    return typeof t == "string" ? Wt(this.parser.getNodeType(t), e, i, r) : new yR(t, e);
  }
  /**
  @internal
  */
  get buffer() {
    return new fR(this.parser.nodeSet);
  }
}, h(gu, "Tc"), gu);
m(cR, "BlockContext");
let iZ = cR;
function sP(s, t, e, i, r) {
  let n = s[t].to, a = [], o = [], l = e.from + i;
  function d(u, p) {
    for (; p ? u >= n : u > n; ) {
      let f = s[t + 1].from - n;
      i += f, u += f, t++, n = s[t].to;
    }
  }
  h(d, "h"), m(d, "movePastNext");
  for (let u = e.firstChild; u; u = u.nextSibling) {
    d(u.from + i, !0);
    let p = u.from + i, f, y = r.get(u.tree);
    y ? f = y : u.to + i > n ? (f = sP(s, t, u, i, r), d(u.to + i, !1)) : f = u.toTree(), a.push(f), o.push(p - l);
  }
  return d(e.to + i, !1), new Ft(e.type, a, o, e.to + i - l, e.tree ? e.tree.propValues : void 0);
}
h(sP, "qp$1");
m(sP, "injectGaps");
var il;
const hR = (il = class extends tb {
  /**
  @internal
  */
  constructor(t, e, i, r, n, a, o, l, d) {
    super(), this.nodeSet = t, this.blockParsers = e, this.leafBlockParsers = i, this.blockNames = r, this.endLeafBlock = n, this.skipContextMarkup = a, this.inlineParsers = o, this.inlineNames = l, this.wrappers = d, this.nodeTypes = /* @__PURE__ */ Object.create(null);
    for (let u of t.types)
      this.nodeTypes[u.name] = u.id;
  }
  createParse(t, e, i) {
    let r = new iZ(this, t, e, i);
    for (let n of this.wrappers)
      r = n(r, t, e, i);
    return r;
  }
  /**
  Reconfigure the parser.
  */
  configure(t) {
    let e = FO(t);
    if (!e)
      return this;
    let { nodeSet: i, skipContextMarkup: r } = this, n = this.blockParsers.slice(), a = this.leafBlockParsers.slice(), o = this.blockNames.slice(), l = this.inlineParsers.slice(), d = this.inlineNames.slice(), u = this.endLeafBlock.slice(), p = this.wrappers;
    if (Nc(e.defineNodes)) {
      r = Object.assign({}, r);
      let f = i.types.slice(), y;
      for (let g of e.defineNodes) {
        let { name: O, block: k, composite: $, style: T } = typeof g == "string" ? { name: g } : g;
        if (f.some((A) => A.name == O))
          continue;
        $ && (r[f.length] = (A, z, V) => $(z, V, A.value));
        let _ = f.length, D = $ ? ["Block", "BlockContext"] : k ? _ >= K.ATXHeading1 && _ <= K.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"] : void 0;
        f.push(ei.define({
          id: _,
          name: O,
          props: D && [[Et.group, D]]
        })), T && (y || (y = {}), Array.isArray(T) || T instanceof is ? y[O] = T : Object.assign(y, T));
      }
      i = new G0(f), y && (i = i.extend(Il(y)));
    }
    if (Nc(e.props) && (i = i.extend(...e.props)), Nc(e.remove))
      for (let f of e.remove) {
        let y = this.blockNames.indexOf(f), g = this.inlineNames.indexOf(f);
        y > -1 && (n[y] = a[y] = void 0), g > -1 && (l[g] = void 0);
      }
    if (Nc(e.parseBlock))
      for (let f of e.parseBlock) {
        let y = o.indexOf(f.name);
        if (y > -1)
          n[y] = f.parse, a[y] = f.leaf;
        else {
          let g = f.before ? Ig(o, f.before) : f.after ? Ig(o, f.after) + 1 : o.length - 1;
          n.splice(g, 0, f.parse), a.splice(g, 0, f.leaf), o.splice(g, 0, f.name);
        }
        f.endLeaf && u.push(f.endLeaf);
      }
    if (Nc(e.parseInline))
      for (let f of e.parseInline) {
        let y = d.indexOf(f.name);
        if (y > -1)
          l[y] = f.parse;
        else {
          let g = f.before ? Ig(d, f.before) : f.after ? Ig(d, f.after) + 1 : d.length - 1;
          l.splice(g, 0, f.parse), d.splice(g, 0, f.name);
        }
      }
    return e.wrap && (p = p.concat(e.wrap)), new il(i, n, a, o, u, r, l, d, p);
  }
  /**
  @internal
  */
  getNodeType(t) {
    let e = this.nodeTypes[t];
    if (e == null)
      throw new RangeError(`Unknown node type '${t}'`);
    return e;
  }
  /**
  Parse the given piece of inline text at the given offset,
  returning an array of [`Element`](#Element) objects representing
  the inline content.
  */
  parseInline(t, e) {
    let i = new lP(this, t, e);
    t: for (let r = e; r < i.end; ) {
      let n = i.char(r);
      for (let a of this.inlineParsers)
        if (a) {
          let o = a(i, n, r);
          if (o >= 0) {
            r = o;
            continue t;
          }
        }
      r++;
    }
    return i.resolveMarkers(0);
  }
}, h(il, "Qo"), il);
m(hR, "MarkdownParser");
let dR = hR;
function Nc(s) {
  return s != null && s.length > 0;
}
h(Nc, "lr$1");
m(Nc, "nonEmpty");
function FO(s) {
  if (!Array.isArray(s))
    return s;
  if (s.length == 0)
    return null;
  let t = FO(s[0]);
  if (s.length == 1)
    return t;
  let e = FO(s.slice(1));
  if (!e || !t)
    return t || e;
  let i = /* @__PURE__ */ m((a, o) => (a || my).concat(o || my), "conc"), r = t.wrap, n = e.wrap;
  return {
    props: i(t.props, e.props),
    defineNodes: i(t.defineNodes, e.defineNodes),
    parseBlock: i(t.parseBlock, e.parseBlock),
    parseInline: i(t.parseInline, e.parseInline),
    remove: i(t.remove, e.remove),
    wrap: r ? n ? (a, o, l, d) => r(n(a, o, l, d), o, l, d) : r : n
  };
}
h(FO, "Ua$1");
m(FO, "resolveConfig");
function Ig(s, t) {
  let e = s.indexOf(t);
  if (e < 0)
    throw new RangeError(`Position specified relative to unknown parser ${t}`);
  return e;
}
h(Ig, "In$1");
m(Ig, "findName");
let uR = [ei.none];
for (let s = 1, t; t = K[s]; s++)
  uR[s] = ei.define({
    id: s,
    name: t,
    props: s >= K.Escape ? [] : [[Et.group, s in rR ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
    top: t == "Document"
  });
const my = [];
var wu;
const pR = (wu = class {
  constructor(t) {
    this.nodeSet = t, this.content = [], this.nodes = [];
  }
  write(t, e, i, r = 0) {
    return this.content.push(t, e, i, 4 + r * 4), this;
  }
  writeElements(t, e = 0) {
    for (let i of t)
      i.writeTo(this, e);
    return this;
  }
  finish(t, e) {
    return Ft.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: t,
      length: e
    });
  }
}, h(wu, "Ac"), wu);
m(pR, "Buffer");
let fR = pR;
var M2, vu;
let Ww = (M2 = (vu = class {
  /**
  @internal
  */
  constructor(t, e, i, r = my) {
    this.type = t, this.from = e, this.to = i, this.children = r;
  }
  /**
  @internal
  */
  writeTo(t, e) {
    let i = t.content.length;
    t.writeElements(this.children, e), t.content.push(this.type, this.from + e, this.to + e, t.content.length + 4 - i);
  }
  /**
  @internal
  */
  toTree(t) {
    return new fR(t).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
}, h(vu, "_i$1"), vu), m(M2, "Element"), M2);
var Ou;
const mR = (Ou = class {
  constructor(t, e) {
    this.tree = t, this.from = e;
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return my;
  }
  writeTo(t, e) {
    t.nodes.push(this.tree), t.content.push(t.nodes.length - 1, this.from + e, this.to + e, -1);
  }
  toTree() {
    return this.tree;
  }
}, h(Ou, "Lc"), Ou);
m(mR, "TreeElement");
let yR = mR;
function Wt(s, t, e, i) {
  return new Ww(s, t, e, i);
}
h(Wt, "W$1");
m(Wt, "elt");
const gR = { resolve: "Emphasis", mark: "EmphasisMark" }, wR = { resolve: "Emphasis", mark: "EmphasisMark" }, co = {}, qO = {};
var bu;
const vR = (bu = class {
  constructor(t, e, i, r) {
    this.type = t, this.from = e, this.to = i, this.side = r;
  }
}, h(bu, "_c"), bu);
m(vR, "InlineDelimiter");
let er = vR;
const QQ = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
let Fw = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  Fw = new RegExp("[\\p{S}|\\p{P}]", "u");
} catch {
}
const A2 = {
  Escape(s, t, e) {
    if (t != 92 || e == s.end - 1)
      return -1;
    let i = s.char(e + 1);
    for (let r = 0; r < QQ.length; r++)
      if (QQ.charCodeAt(r) == i)
        return s.append(Wt(K.Escape, e, e + 2));
    return -1;
  },
  Entity(s, t, e) {
    if (t != 38)
      return -1;
    let i = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(s.slice(e + 1, e + 31));
    return i ? s.append(Wt(K.Entity, e, e + 1 + i[0].length)) : -1;
  },
  InlineCode(s, t, e) {
    if (t != 96 || e && s.char(e - 1) == 96)
      return -1;
    let i = e + 1;
    for (; i < s.end && s.char(i) == 96; )
      i++;
    let r = i - e, n = 0;
    for (; i < s.end; i++)
      if (s.char(i) == 96) {
        if (n++, n == r && s.char(i + 1) != 96)
          return s.append(Wt(K.InlineCode, e, i + 1, [
            Wt(K.CodeMark, e, e + r),
            Wt(K.CodeMark, i + 1 - r, i + 1)
          ]));
      } else
        n = 0;
    return -1;
  },
  HTMLTag(s, t, e) {
    if (t != 60 || e == s.end - 1)
      return -1;
    let i = s.slice(e + 1, s.end), r = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(i);
    if (r)
      return s.append(Wt(K.Autolink, e, e + 1 + r[0].length, [
        Wt(K.LinkMark, e, e + 1),
        // url[0] includes the closing bracket, so exclude it from this slice
        Wt(K.URL, e + 1, e + r[0].length),
        Wt(K.LinkMark, e + r[0].length, e + 1 + r[0].length)
      ]));
    let n = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(i);
    if (n)
      return s.append(Wt(K.Comment, e, e + 1 + n[0].length));
    let a = /^\?[^]*?\?>/.exec(i);
    if (a)
      return s.append(Wt(K.ProcessingInstruction, e, e + 1 + a[0].length));
    let o = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(i);
    return o ? s.append(Wt(K.HTMLTag, e, e + 1 + o[0].length)) : -1;
  },
  Emphasis(s, t, e) {
    if (t != 95 && t != 42)
      return -1;
    let i = e + 1;
    for (; s.char(i) == t; )
      i++;
    let r = s.slice(e - 1, e), n = s.slice(i, i + 1), a = Fw.test(r), o = Fw.test(n), l = /\s|^$/.test(r), d = /\s|^$/.test(n), u = !d && (!o || l || a), p = !l && (!a || d || o), f = u && (t == 42 || !p || a), y = p && (t == 42 || !u || o);
    return s.append(new er(t == 95 ? gR : wR, e, i, (f ? 1 : 0) | (y ? 2 : 0)));
  },
  HardBreak(s, t, e) {
    if (t == 92 && s.char(e + 1) == 10)
      return s.append(Wt(K.HardBreak, e, e + 2));
    if (t == 32) {
      let i = e + 1;
      for (; s.char(i) == 32; )
        i++;
      if (s.char(i) == 10 && i >= e + 2)
        return s.append(Wt(K.HardBreak, e, i + 1));
    }
    return -1;
  },
  Link(s, t, e) {
    return t == 91 ? s.append(new er(
      co,
      e,
      e + 1,
      1
      /* Mark.Open */
    )) : -1;
  },
  Image(s, t, e) {
    return t == 33 && s.char(e + 1) == 91 ? s.append(new er(
      qO,
      e,
      e + 2,
      1
      /* Mark.Open */
    )) : -1;
  },
  LinkEnd(s, t, e) {
    if (t != 93)
      return -1;
    for (let i = s.parts.length - 1; i >= 0; i--) {
      let r = s.parts[i];
      if (r instanceof er && (r.type == co || r.type == qO)) {
        if (!r.side || s.skipSpace(r.to) == e && !/[(\[]/.test(s.slice(e + 1, e + 2)))
          return s.parts[i] = null, -1;
        let n = s.takeContent(i), a = s.parts[i] = OR(s, n, r.type == co ? K.Link : K.Image, r.from, e + 1);
        if (r.type == co)
          for (let o = 0; o < i; o++) {
            let l = s.parts[o];
            l instanceof er && l.type == co && (l.side = 0);
          }
        return a.to;
      }
    }
    return -1;
  }
};
function OR(s, t, e, i, r) {
  let { text: n } = s, a = s.char(r), o = r;
  if (t.unshift(Wt(K.LinkMark, i, i + (e == K.Image ? 2 : 1))), t.push(Wt(K.LinkMark, r - 1, r)), a == 40) {
    let l = s.skipSpace(r + 1), d = nP(n, l - s.offset, s.offset), u;
    d && (l = s.skipSpace(d.to), l != d.to && (u = aP(n, l - s.offset, s.offset), u && (l = s.skipSpace(u.to)))), s.char(l) == 41 && (t.push(Wt(K.LinkMark, r, r + 1)), o = l + 1, d && t.push(d), u && t.push(u), t.push(Wt(K.LinkMark, l, o)));
  } else if (a == 91) {
    let l = oP(n, r - s.offset, s.offset, !1);
    l && (t.push(l), o = l.to);
  }
  return Wt(e, i, o, t);
}
h(OR, "sy$1");
m(OR, "finishLink");
function nP(s, t, e) {
  if (s.charCodeAt(t) == 60) {
    for (let i = t + 1; i < s.length; i++) {
      let r = s.charCodeAt(i);
      if (r == 62)
        return Wt(K.URL, t + e, i + 1 + e);
      if (r == 60 || r == 10)
        return !1;
    }
    return null;
  } else {
    let i = 0, r = t;
    for (let n = !1; r < s.length; r++) {
      let a = s.charCodeAt(r);
      if (cr(a))
        break;
      if (n)
        n = !1;
      else if (a == 40)
        i++;
      else if (a == 41) {
        if (!i)
          break;
        i--;
      } else a == 92 && (n = !0);
    }
    return r > t ? Wt(K.URL, t + e, r + e) : r == s.length ? null : !1;
  }
}
h(nP, "Gp$1");
m(nP, "parseURL");
function aP(s, t, e) {
  let i = s.charCodeAt(t);
  if (i != 39 && i != 34 && i != 40)
    return !1;
  let r = i == 40 ? 41 : i;
  for (let n = t + 1, a = !1; n < s.length; n++) {
    let o = s.charCodeAt(n);
    if (a)
      a = !1;
    else {
      if (o == r)
        return Wt(K.LinkTitle, t + e, n + 1 + e);
      o == 92 && (a = !0);
    }
  }
  return null;
}
h(aP, "Fp$1");
m(aP, "parseLinkTitle");
function oP(s, t, e, i) {
  for (let r = !1, n = t + 1, a = Math.min(s.length, n + 999); n < a; n++) {
    let o = s.charCodeAt(n);
    if (r)
      r = !1;
    else {
      if (o == 93)
        return i ? !1 : Wt(K.LinkLabel, t + e, n + 1 + e);
      if (i && !cr(o) && (i = !1), o == 91)
        return !1;
      o == 92 && (r = !0);
    }
  }
  return null;
}
h(oP, "Hp$1");
m(oP, "parseLinkLabel");
var $u;
const bR = ($u = class {
  /**
  @internal
  */
  constructor(t, e, i) {
    this.parser = t, this.text = e, this.offset = i, this.parts = [];
  }
  /**
  Get the character code at the given (document-relative)
  position.
  */
  char(t) {
    return t >= this.end ? -1 : this.text.charCodeAt(t - this.offset);
  }
  /**
  The position of the end of this inline section.
  */
  get end() {
    return this.offset + this.text.length;
  }
  /**
  Get a substring of this inline section. Again uses
  document-relative positions.
  */
  slice(t, e) {
    return this.text.slice(t - this.offset, e - this.offset);
  }
  /**
  @internal
  */
  append(t) {
    return this.parts.push(t), t.to;
  }
  /**
  Add a [delimiter](#DelimiterType) at this given position. `open`
  and `close` indicate whether this delimiter is opening, closing,
  or both. Returns the end of the delimiter, for convenient
  returning from [parse functions](#InlineParser.parse).
  */
  addDelimiter(t, e, i, r, n) {
    return this.append(new er(t, e, i, (r ? 1 : 0) | (n ? 2 : 0)));
  }
  /**
  Returns true when there is an unmatched link or image opening
  token before the current position.
  */
  get hasOpenLink() {
    for (let t = this.parts.length - 1; t >= 0; t--) {
      let e = this.parts[t];
      if (e instanceof er && (e.type == co || e.type == qO))
        return !0;
    }
    return !1;
  }
  /**
  Add an inline element. Returns the end of the element.
  */
  addElement(t) {
    return this.append(t);
  }
  /**
  Resolve markers between this.parts.length and from, wrapping matched markers in the
  appropriate node and updating the content of this.parts. @internal
  */
  resolveMarkers(t) {
    for (let i = t; i < this.parts.length; i++) {
      let r = this.parts[i];
      if (!(r instanceof er && r.type.resolve && r.side & 2))
        continue;
      let n = r.type == gR || r.type == wR, a = r.to - r.from, o, l = i - 1;
      for (; l >= t; l--) {
        let g = this.parts[l];
        if (g instanceof er && g.side & 1 && g.type == r.type && // Ignore emphasis delimiters where the character count doesn't match
        !(n && (r.side & 1 || g.side & 2) && (g.to - g.from + a) % 3 == 0 && ((g.to - g.from) % 3 || a % 3))) {
          o = g;
          break;
        }
      }
      if (!o)
        continue;
      let d = r.type.resolve, u = [], p = o.from, f = r.to;
      if (n) {
        let g = Math.min(2, o.to - o.from, a);
        p = o.to - g, f = r.from + g, d = g == 1 ? "Emphasis" : "StrongEmphasis";
      }
      o.type.mark && u.push(this.elt(o.type.mark, p, o.to));
      for (let g = l + 1; g < i; g++)
        this.parts[g] instanceof Ww && u.push(this.parts[g]), this.parts[g] = null;
      r.type.mark && u.push(this.elt(r.type.mark, r.from, f));
      let y = this.elt(d, p, f, u);
      this.parts[l] = n && o.from != p ? new er(o.type, o.from, p, o.side) : null, (this.parts[i] = n && r.to != f ? new er(r.type, f, r.to, r.side) : null) ? this.parts.splice(i, 0, y) : this.parts[i] = y;
    }
    let e = [];
    for (let i = t; i < this.parts.length; i++) {
      let r = this.parts[i];
      r instanceof Ww && e.push(r);
    }
    return e;
  }
  /**
  Find an opening delimiter of the given type. Returns `null` if
  no delimiter is found, or an index that can be passed to
  [`takeContent`](#InlineContext.takeContent) otherwise.
  */
  findOpeningDelimiter(t) {
    for (let e = this.parts.length - 1; e >= 0; e--) {
      let i = this.parts[e];
      if (i instanceof er && i.type == t && i.side & 1)
        return e;
    }
    return null;
  }
  /**
  Remove all inline elements and delimiters starting from the
  given index (which you should get from
  [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
  resolve delimiters inside of them, and return them as an array
  of elements.
  */
  takeContent(t) {
    let e = this.resolveMarkers(t);
    return this.parts.length = t, e;
  }
  /**
  Return the delimiter at the given index. Mostly useful to get
  additional info out of a delimiter index returned by
  [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter).
  Returns null if there is no delimiter at this index.
  */
  getDelimiterAt(t) {
    let e = this.parts[t];
    return e instanceof er ? e : null;
  }
  /**
  Skip space after the given (document) position, returning either
  the position of the next non-space character or the end of the
  section.
  */
  skipSpace(t) {
    return kh(this.text, t - this.offset) + this.offset;
  }
  elt(t, e, i, r) {
    return typeof t == "string" ? Wt(this.parser.getNodeType(t), e, i, r) : new yR(t, e);
  }
}, h($u, "Mc"), $u);
m(bR, "InlineContext");
let lP = bR;
lP.linkStart = co;
lP.imageStart = qO;
function ZO(s, t) {
  if (!t.length)
    return s;
  if (!s.length)
    return t;
  let e = s.slice(), i = 0;
  for (let r of t) {
    for (; i < e.length && e[i].to < r.to; )
      i++;
    if (i < e.length && e[i].from < r.from) {
      let n = e[i];
      n instanceof Ww && (e[i] = new Ww(n.type, n.from, n.to, ZO(n.children, [r])));
    } else
      e.splice(i++, 0, r);
  }
  return e;
}
h(ZO, "Ia$1");
m(ZO, "injectMarks");
const rZ = [K.CodeBlock, K.ListItem, K.OrderedList, K.BulletList];
var R2, xu;
let sZ = (R2 = (xu = class {
  constructor(t, e) {
    this.fragments = t, this.input = e, this.i = 0, this.fragment = null, this.fragmentEnd = -1, this.cursor = null, t.length && (this.fragment = t[this.i++]);
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null, this.cursor = null, this.fragmentEnd = -1;
  }
  moveTo(t, e) {
    for (; this.fragment && this.fragment.to <= t; )
      this.nextFragment();
    if (!this.fragment || this.fragment.from > (t ? t - 1 : 0))
      return !1;
    if (this.fragmentEnd < 0) {
      let n = this.fragment.to;
      for (; n > 0 && this.input.read(n - 1, n) != `
`; )
        n--;
      this.fragmentEnd = n ? n - 1 : 0;
    }
    let i = this.cursor;
    i || (i = this.cursor = this.fragment.tree.cursor(), i.firstChild());
    let r = t + this.fragment.offset;
    for (; i.to <= r; )
      if (!i.parent())
        return !1;
    for (; ; ) {
      if (i.from >= r)
        return this.fragment.from <= e;
      if (!i.childAfter(r))
        return !1;
    }
  }
  matches(t) {
    let e = this.cursor.tree;
    return e && e.prop(Et.contextHash) == t;
  }
  takeNodes(t) {
    let e = this.cursor, i = this.fragment.offset, r = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0), n = t.absoluteLineStart, a = n, o = t.block.children.length, l = a, d = o;
    for (; ; ) {
      if (e.to - i > r) {
        if (e.type.isAnonymous && e.firstChild())
          continue;
        break;
      }
      let u = cP(e.from - i, t.ranges);
      if (e.to - i <= t.ranges[t.rangeI].to)
        t.addNode(e.tree, u);
      else {
        let p = new Ft(t.parser.nodeSet.types[K.Paragraph], [], [], 0, t.block.hashProp);
        t.reusePlaceholders.set(p, e.tree), t.addNode(p, u);
      }
      if (e.type.is("Block") && (rZ.indexOf(e.type.id) < 0 ? (a = e.to - i, o = t.block.children.length) : (a = l, o = d, l = e.to - i, d = t.block.children.length)), !e.nextSibling())
        break;
    }
    for (; t.block.children.length > o; )
      t.block.children.pop(), t.block.positions.pop();
    return a - n;
  }
}, h(xu, "Mi$1"), xu), m(R2, "FragmentCursor"), R2);
function cP(s, t) {
  let e = s;
  for (let i = 1; i < t.length; i++) {
    let r = t[i - 1].to, n = t[i].from;
    r < s && (e -= n - r);
  }
  return e;
}
h(cP, "Kp");
m(cP, "toRelative");
const nZ = Il({
  "Blockquote/...": Q.quote,
  HorizontalRule: Q.contentSeparator,
  "ATXHeading1/... SetextHeading1/...": Q.heading1,
  "ATXHeading2/... SetextHeading2/...": Q.heading2,
  "ATXHeading3/...": Q.heading3,
  "ATXHeading4/...": Q.heading4,
  "ATXHeading5/...": Q.heading5,
  "ATXHeading6/...": Q.heading6,
  "Comment CommentBlock": Q.comment,
  Escape: Q.escape,
  Entity: Q.character,
  "Emphasis/...": Q.emphasis,
  "StrongEmphasis/...": Q.strong,
  "Link/... Image/...": Q.link,
  "OrderedList/... BulletList/...": Q.list,
  "BlockQuote/...": Q.quote,
  "InlineCode CodeText": Q.monospace,
  "URL Autolink": Q.url,
  "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": Q.processingInstruction,
  "CodeInfo LinkLabel": Q.labelName,
  LinkTitle: Q.string,
  Paragraph: Q.content
}), aZ = new dR(new G0(uR).extend(nZ), Object.keys(cv).map((s) => cv[s]), Object.keys(cv).map((s) => lR[s]), Object.keys(cv), tZ, rR, Object.keys(A2).map((s) => A2[s]), Object.keys(A2), []);
function $R(s, t, e) {
  let i = [];
  for (let r = s.firstChild, n = t; ; r = r.nextSibling) {
    let a = r ? r.from : e;
    if (a > n && i.push({ from: n, to: a }), !r)
      break;
    n = r.to;
  }
  return i;
}
h($R, "fy$1");
m($R, "leftOverSpace");
function xR(s) {
  let { codeParser: t, htmlParser: e } = s;
  return { wrap: EC((i, r) => {
    let n = i.type.id;
    if (t && (n == K.CodeBlock || n == K.FencedCode)) {
      let a = "";
      if (n == K.FencedCode) {
        let l = i.node.getChild(K.CodeInfo);
        l && (a = r.read(l.from, l.to));
      }
      let o = t(a);
      if (o)
        return { parser: o, overlay: /* @__PURE__ */ m((l) => l.type.id == K.CodeText, "overlay") };
    } else if (e && (n == K.HTMLBlock || n == K.HTMLTag || n == K.CommentBlock))
      return { parser: e, overlay: $R(i.node, i.from, i.to) };
    return null;
  }) };
}
h(xR, "cy$1");
m(xR, "parseCode");
const oZ = { resolve: "Strikethrough", mark: "StrikethroughMark" }, lZ = {
  defineNodes: [{
    name: "Strikethrough",
    style: { "Strikethrough/...": Q.strikethrough }
  }, {
    name: "StrikethroughMark",
    style: Q.processingInstruction
  }],
  parseInline: [{
    name: "Strikethrough",
    parse(s, t, e) {
      if (t != 126 || s.char(e + 1) != 126 || s.char(e + 2) == 126)
        return -1;
      let i = s.slice(e - 1, e), r = s.slice(e + 2, e + 3), n = /\s|^$/.test(i), a = /\s|^$/.test(r), o = Fw.test(i), l = Fw.test(r);
      return s.addDelimiter(oZ, e, e + 2, !a && (!l || n || o), !n && (!o || a || l));
    },
    after: "Emphasis"
  }]
};
function Sh(s, t, e = 0, i, r = 0) {
  let n = 0, a = !0, o = -1, l = -1, d = !1, u = /* @__PURE__ */ m(() => {
    i.push(s.elt("TableCell", r + o, r + l, s.parser.parseInline(t.slice(o, l), r + o)));
  }, "parseCell");
  for (let p = e; p < t.length; p++) {
    let f = t.charCodeAt(p);
    f == 124 && !d ? ((!a || o > -1) && n++, a = !1, i && (o > -1 && u(), i.push(s.elt("TableDelimiter", p + r, p + r + 1))), o = l = -1) : (d || f != 32 && f != 9) && (o < 0 && (o = p), l = p + 1), d = !d && f == 92;
  }
  return o > -1 && (n++, i && u()), n;
}
h(Sh, "$r$1");
m(Sh, "parseRow");
function L5(s, t) {
  for (let e = t; e < s.length; e++) {
    let i = s.charCodeAt(e);
    if (i == 124)
      return !0;
    i == 92 && e++;
  }
  return !1;
}
h(L5, "cO");
m(L5, "hasPipe");
const kR = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
var ku;
const SR = (ku = class {
  constructor() {
    this.rows = null;
  }
  nextLine(t, e, i) {
    if (this.rows == null) {
      this.rows = !1;
      let r;
      if ((e.next == 45 || e.next == 58 || e.next == 124) && kR.test(r = e.text.slice(e.pos))) {
        let n = [];
        Sh(t, i.content, 0, n, i.start) == Sh(t, r, e.pos) && (this.rows = [
          t.elt("TableHeader", i.start, i.start + i.content.length, n),
          t.elt("TableDelimiter", t.lineStart + e.pos, t.lineStart + e.text.length)
        ]);
      }
    } else if (this.rows) {
      let r = [];
      Sh(t, e.text, e.pos, r, t.lineStart), this.rows.push(t.elt("TableRow", t.lineStart + e.pos, t.lineStart + e.text.length, r));
    }
    return !1;
  }
  finish(t, e) {
    return this.rows ? (t.addLeafElement(e, t.elt("Table", e.start, e.start + e.content.length, this.rows)), !0) : !1;
  }
}, h(ku, "Zc"), ku);
m(SR, "TableParser");
let TQ = SR;
const cZ = {
  defineNodes: [
    { name: "Table", block: !0 },
    { name: "TableHeader", style: { "TableHeader/...": Q.heading } },
    "TableRow",
    { name: "TableCell", style: Q.content },
    { name: "TableDelimiter", style: Q.processingInstruction }
  ],
  parseBlock: [{
    name: "Table",
    leaf(s, t) {
      return L5(t.content, 0) ? new TQ() : null;
    },
    endLeaf(s, t, e) {
      if (e.parsers.some((r) => r instanceof TQ) || !L5(t.text, t.basePos))
        return !1;
      let i = s.peekLine();
      return kR.test(i) && Sh(s, t.text, t.basePos) == Sh(s, i, t.basePos);
    },
    before: "SetextHeading"
  }]
};
var Su;
const CR = (Su = class {
  nextLine() {
    return !1;
  }
  finish(t, e) {
    return t.addLeafElement(e, t.elt("Task", e.start, e.start + e.content.length, [
      t.elt("TaskMarker", e.start, e.start + 3),
      ...t.parser.parseInline(e.content.slice(3), e.start + 3)
    ])), !0;
  }
}, h(Su, "Cc"), Su);
m(CR, "TaskParser");
let hZ = CR;
const dZ = {
  defineNodes: [
    { name: "Task", block: !0, style: Q.list },
    { name: "TaskMarker", style: Q.atom }
  ],
  parseBlock: [{
    name: "TaskList",
    leaf(s, t) {
      return /^\[[ xX]\][ \t]/.test(t.content) && s.parentType().name == "ListItem" ? new hZ() : null;
    },
    after: "SetextHeading"
  }]
}, MQ = /(www\.)|(https?:\/\/)|([\w.+-]{1,100}@)|(mailto:|xmpp:)/gy, AQ = /[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy, uZ = /[\w-]+\.[\w-]+($|\/)/, RQ = /[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy, EQ = /\/[a-zA-Z\d@.]+/gy;
function z5(s, t, e, i) {
  let r = 0;
  for (let n = t; n < e; n++)
    s[n] == i && r++;
  return r;
}
h(z5, "mO");
m(z5, "count");
function PR(s, t) {
  AQ.lastIndex = t;
  let e = AQ.exec(s);
  if (!e || uZ.exec(e[0])[0].indexOf("_") > -1)
    return -1;
  let i = t + e[0].length;
  for (; ; ) {
    let r = s[i - 1], n;
    if (/[?!.,:*_~]/.test(r) || r == ")" && z5(s, t, i, ")") > z5(s, t, i, "("))
      i--;
    else if (r == ";" && (n = /&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(s.slice(t, i))))
      i = t + n.index;
    else
      break;
  }
  return i;
}
h(PR, "gy$1");
m(PR, "autolinkURLEnd");
function I5(s, t) {
  RQ.lastIndex = t;
  let e = RQ.exec(s);
  if (!e)
    return -1;
  let i = e[0][e[0].length - 1];
  return i == "_" || i == "-" ? -1 : t + e[0].length - (i == "." ? 1 : 0);
}
h(I5, "gO");
m(I5, "autolinkEmailEnd");
const pZ = {
  parseInline: [{
    name: "Autolink",
    parse(s, t, e) {
      let i = e - s.offset;
      if (i && /\w/.test(s.text[i - 1]))
        return -1;
      MQ.lastIndex = i;
      let r = MQ.exec(s.text), n = -1;
      if (!r)
        return -1;
      if (r[1] || r[2]) {
        if (n = PR(s.text, i + r[0].length), n > -1 && s.hasOpenLink) {
          let a = /([^\[\]]|\[[^\]]*\])*/.exec(s.text.slice(i, n));
          n = i + a[0].length;
        }
      } else r[3] ? n = I5(s.text, i) : (n = I5(s.text, i + r[0].length), n > -1 && r[0] == "xmpp:" && (EQ.lastIndex = n, r = EQ.exec(s.text), r && (n = r.index + r[0].length)));
      return n < 0 ? -1 : (s.addElement(s.elt("URL", e, n + s.offset)), n + s.offset);
    }
  }]
}, fZ = [cZ, dZ, lZ, pZ];
function hP(s, t, e) {
  return (i, r, n) => {
    if (r != s || i.char(n + 1) == s)
      return -1;
    let a = [i.elt(e, n, n + 1)];
    for (let o = n + 1; o < i.end; o++) {
      let l = i.char(o);
      if (l == s)
        return i.addElement(i.elt(t, n, o + 1, a.concat(i.elt(e, o, o + 1))));
      if (l == 92 && a.push(i.elt("Escape", o, o++ + 2)), cr(l))
        break;
    }
    return -1;
  };
}
h(hP, "em$1");
m(hP, "parseSubSuper");
const mZ = {
  defineNodes: [
    { name: "Superscript", style: Q.special(Q.content) },
    { name: "SuperscriptMark", style: Q.processingInstruction }
  ],
  parseInline: [{
    name: "Superscript",
    parse: hP(94, "Superscript", "SuperscriptMark")
  }]
}, yZ = {
  defineNodes: [
    { name: "Subscript", style: Q.special(Q.content) },
    { name: "SubscriptMark", style: Q.processingInstruction }
  ],
  parseInline: [{
    name: "Subscript",
    parse: hP(126, "Subscript", "SubscriptMark")
  }]
}, gZ = {
  defineNodes: [{ name: "Emoji", style: Q.character }],
  parseInline: [{
    name: "Emoji",
    parse(s, t, e) {
      let i;
      return t != 58 || !(i = /^[a-zA-Z_0-9]+:/.exec(s.slice(e + 1, s.end))) ? -1 : s.addElement(s.elt("Emoji", e, e + 1 + i[0].length));
    }
  }]
};
var oa;
const QR = (oa = class {
  /**
  @internal
  */
  constructor(t, e, i, r, n, a, o, l, d, u = 0, p) {
    this.p = t, this.stack = e, this.state = i, this.reducePos = r, this.pos = n, this.score = a, this.buffer = o, this.bufferBase = l, this.curContext = d, this.lookAhead = u, this.parent = p;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((t, e) => e % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(t, e, i = 0) {
    let r = t.parser.context;
    return new oa(t, [], e, i, i, 0, [], 0, r ? new _Q(r, r.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(t, e) {
    this.stack.push(this.state, e, this.bufferBase + this.buffer.length), this.state = t;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(t) {
    var e;
    let i = t >> 19, r = t & 65535, { parser: n } = this.p, a = this.reducePos < this.pos - 25;
    a && this.setLookAhead(this.pos);
    let o = n.dynamicPrecedence(r);
    if (o && (this.score += o), i == 0) {
      this.pushState(n.getGoto(this.state, r, !0), this.reducePos), r < n.minRepeatTerm && this.storeNode(r, this.reducePos, this.reducePos, a ? 8 : 4, !0), this.reduceContext(r, this.reducePos);
      return;
    }
    let l = this.stack.length - (i - 1) * 3 - (t & 262144 ? 6 : 0), d = l ? this.stack[l - 2] : this.p.ranges[0].from, u = this.reducePos - d;
    u >= 2e3 && !(!((e = this.p.parser.nodeSet.types[r]) === null || e === void 0) && e.isAnonymous) && (d == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = u) : this.p.lastBigReductionSize < u && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = d, this.p.lastBigReductionSize = u));
    let p = l ? this.stack[l - 1] : 0, f = this.bufferBase + this.buffer.length - p;
    if (r < n.minRepeatTerm || t & 131072) {
      let y = n.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(r, d, y, f + 4, !0);
    }
    if (t & 262144)
      this.state = this.stack[l];
    else {
      let y = this.stack[l - 3];
      this.state = n.getGoto(y, r, !0);
    }
    for (; this.stack.length > l; )
      this.stack.pop();
    this.reduceContext(r, d);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(t, e, i, r = 4, n = !1) {
    if (t == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let a = this, o = this.buffer.length;
      if (o == 0 && a.parent && (o = a.bufferBase - a.parent.bufferBase, a = a.parent), o > 0 && a.buffer[o - 4] == 0 && a.buffer[o - 1] > -1) {
        if (e == i)
          return;
        if (a.buffer[o - 2] >= e) {
          a.buffer[o - 2] = i;
          return;
        }
      }
    }
    if (!n || this.pos == i)
      this.buffer.push(t, e, i, r);
    else {
      let a = this.buffer.length;
      if (a > 0 && (this.buffer[a - 4] != 0 || this.buffer[a - 1] < 0)) {
        let o = !1;
        for (let l = a; l > 0 && this.buffer[l - 2] > i; l -= 4)
          if (this.buffer[l - 1] >= 0) {
            o = !0;
            break;
          }
        if (o)
          for (; a > 0 && this.buffer[a - 2] > i; )
            this.buffer[a] = this.buffer[a - 4], this.buffer[a + 1] = this.buffer[a - 3], this.buffer[a + 2] = this.buffer[a - 2], this.buffer[a + 3] = this.buffer[a - 1], a -= 4, r > 4 && (r -= 4);
      }
      this.buffer[a] = t, this.buffer[a + 1] = e, this.buffer[a + 2] = i, this.buffer[a + 3] = r;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(t, e, i, r) {
    if (t & 131072)
      this.pushState(t & 65535, this.pos);
    else if ((t & 262144) == 0) {
      let n = t, { parser: a } = this.p;
      (r > this.pos || e <= a.maxNode) && (this.pos = r, a.stateFlag(
        n,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = r)), this.pushState(n, i), this.shiftContext(e, i), e <= a.maxNode && this.buffer.push(e, i, r, 4);
    } else
      this.pos = r, this.shiftContext(e, i), e <= this.p.parser.maxNode && this.buffer.push(e, i, r, 4);
  }
  // Apply an action
  /**
  @internal
  */
  apply(t, e, i, r) {
    t & 65536 ? this.reduce(t) : this.shift(t, e, i, r);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(t, e) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != t) && (this.p.reused.push(t), i++);
    let r = this.pos;
    this.reducePos = this.pos = r + t.length, this.pushState(e, r), this.buffer.push(
      i,
      r,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, t, this, this.p.stream.reset(this.pos - t.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let t = this, e = t.buffer.length;
    for (; e > 0 && t.buffer[e - 2] > t.reducePos; )
      e -= 4;
    let i = t.buffer.slice(e), r = t.bufferBase + e;
    for (; t && r == t.bufferBase; )
      t = t.parent;
    return new oa(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, r, this.curContext, this.lookAhead, t);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(t, e) {
    let i = t <= this.p.parser.maxNode;
    i && this.storeNode(t, this.pos, e, 4), this.storeNode(0, this.pos, e, i ? 8 : 4), this.pos = this.reducePos = e, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(t) {
    for (let e = new vZ(this); ; ) {
      let i = this.p.parser.stateSlot(
        e.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(e.state, t);
      if (i == 0)
        return !1;
      if ((i & 65536) == 0)
        return !0;
      e.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(t) {
    if (this.stack.length >= 300)
      return [];
    let e = this.p.parser.nextStates(this.state);
    if (e.length > 8 || this.stack.length >= 120) {
      let r = [];
      for (let n = 0, a; n < e.length; n += 2)
        (a = e[n + 1]) != this.state && this.p.parser.hasAction(a, t) && r.push(e[n], a);
      if (this.stack.length < 120)
        for (let n = 0; r.length < 8 && n < e.length; n += 2) {
          let a = e[n + 1];
          r.some((o, l) => l & 1 && o == a) || r.push(e[n], a);
        }
      e = r;
    }
    let i = [];
    for (let r = 0; r < e.length && i.length < 4; r += 2) {
      let n = e[r + 1];
      if (n == this.state)
        continue;
      let a = this.split();
      a.pushState(n, this.pos), a.storeNode(0, a.pos, a.pos, 4, !0), a.shiftContext(e[r], this.pos), a.reducePos = this.pos, a.score -= 200, i.push(a);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: t } = this.p, e = t.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((e & 65536) == 0)
      return !1;
    if (!t.validAction(this.state, e)) {
      let i = e >> 19, r = e & 65535, n = this.stack.length - i * 3;
      if (n < 0 || t.getGoto(this.stack[n], r, !1) < 0) {
        let a = this.findForcedReduction();
        if (a == null)
          return !1;
        e = a;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(e), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: t } = this.p, e = [], i = /* @__PURE__ */ m((r, n) => {
      if (!e.includes(r))
        return e.push(r), t.allActions(r, (a) => {
          if (!(a & 393216)) if (a & 65536) {
            let o = (a >> 19) - n;
            if (o > 1) {
              let l = a & 65535, d = this.stack.length - o * 3;
              if (d >= 0 && t.getGoto(this.stack[d], l, !1) >= 0)
                return o << 19 | 65536 | l;
            }
          } else {
            let o = i(a, n + 1);
            if (o != null)
              return o;
          }
        });
    }, "explore");
    return i(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: t } = this.p;
    return t.data[t.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !t.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(t) {
    if (this.state != t.state || this.stack.length != t.stack.length)
      return !1;
    for (let e = 0; e < this.stack.length; e += 3)
      if (this.stack[e] != t.stack[e])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(t) {
    return this.p.parser.dialect.flags[t];
  }
  shiftContext(t, e) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, t, this, this.p.stream.reset(e)));
  }
  reduceContext(t, e) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, t, this, this.p.stream.reset(e)));
  }
  /**
  @internal
  */
  emitContext() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(t) {
    if (t != this.curContext.context) {
      let e = new _Q(this.curContext.tracker, t);
      e.hash != this.curContext.hash && this.emitContext(), this.curContext = e;
    }
  }
  /**
  @internal
  */
  setLookAhead(t) {
    t > this.lookAhead && (this.emitLookAhead(), this.lookAhead = t);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}, h(oa, "jr"), oa);
m(QR, "Stack");
let wZ = QR;
var Cu;
const TR = (Cu = class {
  constructor(t, e) {
    this.tracker = t, this.context = e, this.hash = t.strict ? t.hash(e) : 0;
  }
}, h(Cu, "Xc"), Cu);
m(TR, "StackContext");
let _Q = TR;
var Pu;
const MR = (Pu = class {
  constructor(t) {
    this.start = t, this.state = t.state, this.stack = t.stack, this.base = this.stack.length;
  }
  reduce(t) {
    let e = t & 65535, i = t >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let r = this.start.p.parser.getGoto(this.stack[this.base - 3], e, !0);
    this.state = r;
  }
}, h(Pu, "Ec"), Pu);
m(MR, "SimulatedStack");
let vZ = MR;
var la;
const AR = (la = class {
  constructor(t, e, i) {
    this.stack = t, this.pos = e, this.index = i, this.buffer = t.buffer, this.index == 0 && this.maybeNext();
  }
  static create(t, e = t.bufferBase + t.buffer.length) {
    return new la(t, e, e - t.bufferBase);
  }
  maybeNext() {
    let t = this.stack.parent;
    t != null && (this.index = this.stack.bufferBase - t.bufferBase, this.stack = t, this.buffer = t.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new la(this.stack, this.pos, this.index);
  }
}, h(la, "qr"), la);
m(AR, "StackBufferCursor");
let OZ = AR;
function ph(s, t = Uint16Array) {
  if (typeof s != "string")
    return s;
  let e = null;
  for (let i = 0, r = 0; i < s.length; ) {
    let n = 0;
    for (; ; ) {
      let a = s.charCodeAt(i++), o = !1;
      if (a == 126) {
        n = 65535;
        break;
      }
      a >= 92 && a--, a >= 34 && a--;
      let l = a - 32;
      if (l >= 46 && (l -= 46, o = !0), n += l, o)
        break;
      n *= 46;
    }
    e ? e[r++] = n : e = new t(n);
  }
  return e;
}
h(ph, "pr$1");
m(ph, "decodeArray");
var Qu;
const RR = (Qu = class {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}, h(Qu, "Yc"), Qu);
m(RR, "CachedToken");
let Lv = RR;
const LQ = new Lv();
var Tu;
const ER = (Tu = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.input = t, this.ranges = e, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = LQ, this.rangeIndex = 0, this.pos = this.chunkPos = e[0].from, this.range = e[0], this.end = e[e.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(t, e) {
    let i = this.range, r = this.rangeIndex, n = this.pos + t;
    for (; n < i.from; ) {
      if (!r)
        return null;
      let a = this.ranges[--r];
      n -= i.from - a.to, i = a;
    }
    for (; e < 0 ? n > i.to : n >= i.to; ) {
      if (r == this.ranges.length - 1)
        return null;
      let a = this.ranges[++r];
      n += a.from - i.to, i = a;
    }
    return n;
  }
  /**
  @internal
  */
  clipPos(t) {
    if (t >= this.range.from && t < this.range.to)
      return t;
    for (let e of this.ranges)
      if (e.to > t)
        return Math.max(t, e.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(t) {
    let e = this.chunkOff + t, i, r;
    if (e >= 0 && e < this.chunk.length)
      i = this.pos + t, r = this.chunk.charCodeAt(e);
    else {
      let n = this.resolveOffset(t, 1);
      if (n == null)
        return -1;
      if (i = n, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        r = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let a = this.rangeIndex, o = this.range;
        for (; o.to <= i; )
          o = this.ranges[++a];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > o.to && (this.chunk2 = this.chunk2.slice(0, o.to - i)), r = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), r;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(t, e = 0) {
    let i = e ? this.resolveOffset(e, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = t, this.token.end = i;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(t, e) {
    this.token.value = t, this.token.end = e;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: t, chunkPos: e } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = t, this.chunk2Pos = e, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let t = this.input.chunk(this.pos), e = this.pos + t.length;
      this.chunk = e > this.range.to ? t.slice(0, this.range.to - this.pos) : t, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(t = 1) {
    for (this.chunkOff += t; this.pos + t >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      t -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += t, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(t, e) {
    if (e ? (this.token = e, e.start = t, e.lookAhead = t + 1, e.value = e.extended = -1) : this.token = LQ, this.pos != t) {
      if (this.pos = t, t == this.end)
        return this.setDone(), this;
      for (; t < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; t >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      t >= this.chunkPos && t < this.chunkPos + this.chunk.length ? this.chunkOff = t - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(t, e) {
    if (t >= this.chunkPos && e <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(t - this.chunkPos, e - this.chunkPos);
    if (t >= this.chunk2Pos && e <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(t - this.chunk2Pos, e - this.chunk2Pos);
    if (t >= this.range.from && e <= this.range.to)
      return this.input.read(t, e);
    let i = "";
    for (let r of this.ranges) {
      if (r.from >= e)
        break;
      r.to > t && (i += this.input.read(Math.max(r.from, t), Math.min(r.to, e)));
    }
    return i;
  }
}, h(Tu, "Wc"), Tu);
m(ER, "InputStream");
let bZ = ER;
var Mu;
const _R = (Mu = class {
  constructor(t, e) {
    this.data = t, this.id = e;
  }
  token(t, e) {
    let { parser: i } = e.p;
    dP(this.data, t, e, this.id, i.data, i.tokenPrecTable);
  }
}, h(Mu, "Vc"), Mu);
m(_R, "TokenGroup");
let Ch = _R;
Ch.prototype.contextual = Ch.prototype.fallback = Ch.prototype.extend = !1;
var Au;
const LR = (Au = class {
  constructor(t, e, i) {
    this.precTable = e, this.elseToken = i, this.data = typeof t == "string" ? ph(t) : t;
  }
  token(t, e) {
    let i = t.pos, r = 0;
    for (; ; ) {
      let n = t.next < 0, a = t.resolveOffset(1, 1);
      if (dP(this.data, t, e, 0, this.data, this.precTable), t.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (n || r++, a == null)
        break;
      t.reset(a, t.token);
    }
    r && (t.reset(i, t.token), t.acceptToken(this.elseToken, r));
  }
}, h(Au, "Uc"), Au);
m(LR, "LocalTokenGroup");
let BO = LR;
BO.prototype.contextual = Ch.prototype.fallback = Ch.prototype.extend = !1;
var Ru;
const zR = (Ru = class {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(t, e = {}) {
    this.token = t, this.contextual = !!e.contextual, this.fallback = !!e.fallback, this.extend = !!e.extend;
  }
}, h(Ru, "Ic"), Ru);
m(zR, "ExternalTokenizer");
let hr = zR;
function dP(s, t, e, i, r, n) {
  let a = 0, o = 1 << i, { dialect: l } = e.p.parser;
  t: for (; (o & s[a]) != 0; ) {
    let d = s[a + 1];
    for (let y = a + 3; y < d; y += 2)
      if ((s[y + 1] & o) > 0) {
        let g = s[y];
        if (l.allows(g) && (t.token.value == -1 || t.token.value == g || IR(g, t.token.value, r, n))) {
          t.acceptToken(g);
          break;
        }
      }
    let u = t.next, p = 0, f = s[a + 2];
    if (t.next < 0 && f > p && s[d + f * 3 - 3] == 65535) {
      a = s[d + f * 3 - 1];
      continue t;
    }
    for (; p < f; ) {
      let y = p + f >> 1, g = d + y + (y << 1), O = s[g], k = s[g + 1] || 65536;
      if (u < O)
        f = y;
      else if (u >= k)
        p = y + 1;
      else {
        a = s[g + 2], t.advance();
        continue t;
      }
    }
    break;
  }
}
h(dP, "tm$1");
m(dP, "readToken");
function D5(s, t, e) {
  for (let i = t, r; (r = s[i]) != 65535; i++)
    if (r == e)
      return i - t;
  return -1;
}
h(D5, "yO");
m(D5, "findOffset");
function IR(s, t, e, i) {
  let r = D5(e, i, t);
  return r < 0 || D5(e, i, s) < r;
}
h(IR, "xy$1");
m(IR, "overrides");
const Gi = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let E2 = null;
function V5(s, t, e) {
  let i = s.cursor(Ut.IncludeAnonymous);
  for (i.moveTo(t); ; )
    if (!(e < 0 ? i.childBefore(t) : i.childAfter(t)))
      for (; ; ) {
        if ((e < 0 ? i.to < t : i.from > t) && !i.type.isError)
          return e < 0 ? Math.max(0, Math.min(
            i.to - 1,
            t - 25
            /* Lookahead.Margin */
          )) : Math.min(s.length, Math.max(
            i.from + 1,
            t + 25
            /* Lookahead.Margin */
          ));
        if (e < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return e < 0 ? 0 : s.length;
      }
}
h(V5, "SO");
m(V5, "cutAt");
var Eu;
const DR = (Eu = class {
  constructor(t, e) {
    this.fragments = t, this.nodeSet = e, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let t = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (t) {
      for (this.safeFrom = t.openStart ? V5(t.tree, t.from + t.offset, 1) - t.offset : t.from, this.safeTo = t.openEnd ? V5(t.tree, t.to + t.offset, -1) - t.offset : t.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(t.tree), this.start.push(-t.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(t) {
    if (t < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= t; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let e = this.trees.length - 1;
      if (e < 0)
        return this.nextFragment(), null;
      let i = this.trees[e], r = this.index[e];
      if (r == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let n = i.children[r], a = this.start[e] + i.positions[r];
      if (a > t)
        return this.nextStart = a, null;
      if (n instanceof Ft) {
        if (a == t) {
          if (a < this.safeFrom)
            return null;
          let o = a + n.length;
          if (o <= this.safeTo) {
            let l = n.prop(Et.lookAhead);
            if (!l || o + l < this.fragment.to)
              return n;
          }
        }
        this.index[e]++, a + n.length >= Math.max(this.safeFrom, t) && (this.trees.push(n), this.start.push(a), this.index.push(0));
      } else
        this.index[e]++, this.nextStart = a + n.length;
    }
  }
}, h(Eu, "zc"), Eu);
m(DR, "FragmentCursor");
let $Z = DR;
var _u;
const VR = (_u = class {
  constructor(t, e) {
    this.stream = e, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = t.tokenizers.map((i) => new Lv());
  }
  getActions(t) {
    let e = 0, i = null, { parser: r } = t.p, { tokenizers: n } = r, a = r.stateSlot(
      t.state,
      3
      /* ParseState.TokenizerMask */
    ), o = t.curContext ? t.curContext.hash : 0, l = 0;
    for (let d = 0; d < n.length; d++) {
      if ((1 << d & a) == 0)
        continue;
      let u = n[d], p = this.tokens[d];
      if (!(i && !u.fallback) && ((u.contextual || p.start != t.pos || p.mask != a || p.context != o) && (this.updateCachedToken(p, u, t), p.mask = a, p.context = o), p.lookAhead > p.end + 25 && (l = Math.max(p.lookAhead, l)), p.value != 0)) {
        let f = e;
        if (p.extended > -1 && (e = this.addActions(t, p.extended, p.end, e)), e = this.addActions(t, p.value, p.end, e), !u.extend && (i = p, e > f))
          break;
      }
    }
    for (; this.actions.length > e; )
      this.actions.pop();
    return l && t.setLookAhead(l), !i && t.pos == this.stream.end && (i = new Lv(), i.value = t.p.parser.eofTerm, i.start = i.end = t.pos, e = this.addActions(t, i.value, i.end, e)), this.mainToken = i, this.actions;
  }
  getMainToken(t) {
    if (this.mainToken)
      return this.mainToken;
    let e = new Lv(), { pos: i, p: r } = t;
    return e.start = i, e.end = Math.min(i + 1, r.stream.end), e.value = i == r.stream.end ? r.parser.eofTerm : 0, e;
  }
  updateCachedToken(t, e, i) {
    let r = this.stream.clipPos(i.pos);
    if (e.token(this.stream.reset(r, t), i), t.value > -1) {
      let { parser: n } = i.p;
      for (let a = 0; a < n.specialized.length; a++)
        if (n.specialized[a] == t.value) {
          let o = n.specializers[a](this.stream.read(t.start, t.end), i);
          if (o >= 0 && i.p.parser.dialect.allows(o >> 1)) {
            (o & 1) == 0 ? t.value = o >> 1 : t.extended = o >> 1;
            break;
          }
        }
    } else
      t.value = 0, t.end = this.stream.clipPos(r + 1);
  }
  putAction(t, e, i, r) {
    for (let n = 0; n < r; n += 3)
      if (this.actions[n] == t)
        return r;
    return this.actions[r++] = t, this.actions[r++] = e, this.actions[r++] = i, r;
  }
  addActions(t, e, i, r) {
    let { state: n } = t, { parser: a } = t.p, { data: o } = a;
    for (let l = 0; l < 2; l++)
      for (let d = a.stateSlot(
        n,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; d += 3) {
        if (o[d] == 65535)
          if (o[d + 1] == 1)
            d = rs(o, d + 2);
          else {
            r == 0 && o[d + 1] == 2 && (r = this.putAction(rs(o, d + 2), e, i, r));
            break;
          }
        o[d] == e && (r = this.putAction(rs(o, d + 1), e, i, r));
      }
    return r;
  }
}, h(_u, "jc"), _u);
m(VR, "TokenCache");
let xZ = VR;
var Lu;
const WR = (Lu = class {
  constructor(t, e, i, r) {
    this.parser = t, this.input = e, this.ranges = r, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new bZ(e, r), this.tokens = new xZ(t, this.stream), this.topTerm = t.top[1];
    let { from: n } = r[0];
    this.stacks = [wZ.start(this, t.top[0], n)], this.fragments = i.length && this.stream.end - n > t.bufferLength * 4 ? new $Z(i, t.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let t = this.stacks, e = this.minStackPos, i = this.stacks = [], r, n;
    if (this.bigReductionCount > 300 && t.length == 1) {
      let [a] = t;
      for (; a.forceReduce() && a.stack.length && a.stack[a.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let a = 0; a < t.length; a++) {
      let o = t[a];
      for (; ; ) {
        if (this.tokens.mainToken = null, o.pos > e)
          i.push(o);
        else {
          if (this.advanceStack(o, i, t))
            continue;
          {
            r || (r = [], n = []), r.push(o);
            let l = this.tokens.getMainToken(o);
            n.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let a = r && NR(r);
      if (a)
        return Gi && console.log("Finish with " + this.stackID(a)), this.stackToTree(a);
      if (this.parser.strict)
        throw Gi && r && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + e);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && r) {
      let a = this.stoppedAt != null && r[0].pos > this.stoppedAt ? r[0] : this.runRecovery(r, n, i);
      if (a)
        return Gi && console.log("Force-finish " + this.stackID(a)), this.stackToTree(a.forceAll());
    }
    if (this.recovering) {
      let a = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > a)
        for (i.sort((o, l) => l.score - o.score); i.length > a; )
          i.pop();
      i.some((o) => o.reducePos > e) && this.recovering--;
    } else if (i.length > 1) {
      t: for (let a = 0; a < i.length - 1; a++) {
        let o = i[a];
        for (let l = a + 1; l < i.length; l++) {
          let d = i[l];
          if (o.sameState(d) || o.buffer.length > 500 && d.buffer.length > 500)
            if ((o.score - d.score || o.buffer.length - d.buffer.length) > 0)
              i.splice(l--, 1);
            else {
              i.splice(a--, 1);
              continue t;
            }
        }
      }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let a = 1; a < i.length; a++)
      i[a].pos < this.minStackPos && (this.minStackPos = i[a].pos);
    return null;
  }
  stopAt(t) {
    if (this.stoppedAt != null && this.stoppedAt < t)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = t;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(t, e, i) {
    let r = t.pos, { parser: n } = this, a = Gi ? this.stackID(t) + " -> " : "";
    if (this.stoppedAt != null && r > this.stoppedAt)
      return t.forceReduce() ? t : null;
    if (this.fragments) {
      let d = t.curContext && t.curContext.tracker.strict, u = d ? t.curContext.hash : 0;
      for (let p = this.fragments.nodeAt(r); p; ) {
        let f = this.parser.nodeSet.types[p.type.id] == p.type ? n.getGoto(t.state, p.type.id) : -1;
        if (f > -1 && p.length && (!d || (p.prop(Et.contextHash) || 0) == u))
          return t.useNode(p, f), Gi && console.log(a + this.stackID(t) + ` (via reuse of ${n.getName(p.type.id)})`), !0;
        if (!(p instanceof Ft) || p.children.length == 0 || p.positions[0] > 0)
          break;
        let y = p.children[0];
        if (y instanceof Ft && p.positions[0] == 0)
          p = y;
        else
          break;
      }
    }
    let o = n.stateSlot(
      t.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (o > 0)
      return t.reduce(o), Gi && console.log(a + this.stackID(t) + ` (via always-reduce ${n.getName(
        o & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (t.stack.length >= 8400)
      for (; t.stack.length > 6e3 && t.forceReduce(); )
        ;
    let l = this.tokens.getActions(t);
    for (let d = 0; d < l.length; ) {
      let u = l[d++], p = l[d++], f = l[d++], y = d == l.length || !i, g = y ? t : t.split(), O = this.tokens.mainToken;
      if (g.apply(u, p, O ? O.start : g.pos, f), Gi && console.log(a + this.stackID(g) + ` (via ${(u & 65536) == 0 ? "shift" : `reduce of ${n.getName(
        u & 65535
        /* Action.ValueMask */
      )}`} for ${n.getName(p)} @ ${r}${g == t ? "" : ", split"})`), y)
        return !0;
      g.pos > r ? e.push(g) : i.push(g);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(t, e) {
    let i = t.pos;
    for (; ; ) {
      if (!this.advanceStack(t, null, null))
        return !1;
      if (t.pos > i)
        return W5(t, e), !0;
    }
  }
  runRecovery(t, e, i) {
    let r = null, n = !1;
    for (let a = 0; a < t.length; a++) {
      let o = t[a], l = e[a << 1], d = e[(a << 1) + 1], u = Gi ? this.stackID(o) + " -> " : "";
      if (o.deadEnd && (n || (n = !0, o.restart(), Gi && console.log(u + this.stackID(o) + " (restarted)"), this.advanceFully(o, i))))
        continue;
      let p = o.split(), f = u;
      for (let y = 0; y < 10 && p.forceReduce() && (Gi && console.log(f + this.stackID(p) + " (via force-reduce)"), !this.advanceFully(p, i)); y++)
        Gi && (f = this.stackID(p) + " -> ");
      for (let y of o.recoverByInsert(l))
        Gi && console.log(u + this.stackID(y) + " (via recover-insert)"), this.advanceFully(y, i);
      this.stream.end > o.pos ? (d == o.pos && (d++, l = 0), o.recoverByDelete(l, d), Gi && console.log(u + this.stackID(o) + ` (via recover-delete ${this.parser.getName(l)})`), W5(o, i)) : (!r || r.score < o.score) && (r = o);
    }
    return r;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(t) {
    return t.close(), Ft.build({
      buffer: OZ.create(t),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: t.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(t) {
    let e = (E2 || (E2 = /* @__PURE__ */ new WeakMap())).get(t);
    return e || E2.set(t, e = String.fromCodePoint(this.nextStackID++)), e + t;
  }
}, h(Lu, "qc"), Lu);
m(WR, "Parse");
let kZ = WR;
function W5(s, t) {
  for (let e = 0; e < t.length; e++) {
    let i = t[e];
    if (i.pos == s.pos && i.sameState(s)) {
      t[e].score < s.score && (t[e] = s);
      return;
    }
  }
  t.push(s);
}
h(W5, "bO");
m(W5, "pushStackDedup");
var zu;
const FR = (zu = class {
  constructor(t, e, i) {
    this.source = t, this.flags = e, this.disabled = i;
  }
  allows(t) {
    return !this.disabled || this.disabled[t] == 0;
  }
}, h(zu, "Bc"), zu);
m(FR, "Dialect");
let SZ = FR;
const _2 = /* @__PURE__ */ m((s) => s, "id");
var Iu;
const qR = (Iu = class {
  /**
  Define a context tracker.
  */
  constructor(t) {
    this.start = t.start, this.shift = t.shift || _2, this.reduce = t.reduce || _2, this.reuse = t.reuse || _2, this.hash = t.hash || (() => 0), this.strict = t.strict !== !1;
  }
}, h(Iu, "Dc"), Iu);
m(qR, "ContextTracker");
let ZR = qR;
var ca;
const BR = (ca = class extends tb {
  /**
  @internal
  */
  constructor(t) {
    if (super(), this.wrappers = [], t.version != 14)
      throw new RangeError(`Parser version (${t.version}) doesn't match runtime version (14)`);
    let e = t.nodeNames.split(" ");
    this.minRepeatTerm = e.length;
    for (let o = 0; o < t.repeatNodeCount; o++)
      e.push("");
    let i = Object.keys(t.topRules).map((o) => t.topRules[o][1]), r = [];
    for (let o = 0; o < e.length; o++)
      r.push([]);
    function n(o, l, d) {
      r[o].push([l, l.deserialize(String(d))]);
    }
    if (h(n, "s"), m(n, "setProp"), t.nodeProps)
      for (let o of t.nodeProps) {
        let l = o[0];
        typeof l == "string" && (l = Et[l]);
        for (let d = 1; d < o.length; ) {
          let u = o[d++];
          if (u >= 0)
            n(u, l, o[d++]);
          else {
            let p = o[d + -u];
            for (let f = -u; f > 0; f--)
              n(o[d++], l, p);
            d++;
          }
        }
      }
    this.nodeSet = new G0(e.map((o, l) => ei.define({
      name: l >= this.minRepeatTerm ? void 0 : o,
      id: l,
      props: r[l],
      top: i.indexOf(l) > -1,
      error: l == 0,
      skipped: t.skippedNodes && t.skippedNodes.indexOf(l) > -1
    }))), t.propSources && (this.nodeSet = this.nodeSet.extend(...t.propSources)), this.strict = !1, this.bufferLength = sM;
    let a = ph(t.tokenData);
    this.context = t.context, this.specializerSpecs = t.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let o = 0; o < this.specializerSpecs.length; o++)
      this.specialized[o] = this.specializerSpecs[o].term;
    this.specializers = this.specializerSpecs.map(F5), this.states = ph(t.states, Uint32Array), this.data = ph(t.stateData), this.goto = ph(t.goto), this.maxTerm = t.maxTerm, this.tokenizers = t.tokenizers.map((o) => typeof o == "number" ? new Ch(a, o) : o), this.topRules = t.topRules, this.dialects = t.dialects || {}, this.dynamicPrecedences = t.dynamicPrecedences || null, this.tokenPrecTable = t.tokenPrec, this.termNames = t.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(t, e, i) {
    let r = new kZ(this, t, e, i);
    for (let n of this.wrappers)
      r = n(r, t, e, i);
    return r;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(t, e, i = !1) {
    let r = this.goto;
    if (e >= r[0])
      return -1;
    for (let n = r[e + 1]; ; ) {
      let a = r[n++], o = a & 1, l = r[n++];
      if (o && i)
        return l;
      for (let d = n + (a >> 1); n < d; n++)
        if (r[n] == t)
          return l;
      if (o)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(t, e) {
    let i = this.data;
    for (let r = 0; r < 2; r++)
      for (let n = this.stateSlot(
        t,
        r ? 2 : 1
        /* ParseState.Actions */
      ), a; ; n += 3) {
        if ((a = i[n]) == 65535)
          if (i[n + 1] == 1)
            a = i[n = rs(i, n + 2)];
          else {
            if (i[n + 1] == 2)
              return rs(i, n + 2);
            break;
          }
        if (a == e || a == 0)
          return rs(i, n + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(t, e) {
    return this.states[t * 6 + e];
  }
  /**
  @internal
  */
  stateFlag(t, e) {
    return (this.stateSlot(
      t,
      0
      /* ParseState.Flags */
    ) & e) > 0;
  }
  /**
  @internal
  */
  validAction(t, e) {
    return !!this.allActions(t, (i) => i == e ? !0 : null);
  }
  /**
  @internal
  */
  allActions(t, e) {
    let i = this.stateSlot(
      t,
      4
      /* ParseState.DefaultReduce */
    ), r = i ? e(i) : void 0;
    for (let n = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); r == null; n += 3) {
      if (this.data[n] == 65535)
        if (this.data[n + 1] == 1)
          n = rs(this.data, n + 2);
        else
          break;
      r = e(rs(this.data, n + 1));
    }
    return r;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(t) {
    let e = [];
    for (let i = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = rs(this.data, i + 2);
        else
          break;
      if ((this.data[i + 2] & 1) == 0) {
        let r = this.data[i + 1];
        e.some((n, a) => a & 1 && n == r) || e.push(this.data[i], r);
      }
    }
    return e;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(t) {
    let e = Object.assign(Object.create(ca.prototype), this);
    if (t.props && (e.nodeSet = this.nodeSet.extend(...t.props)), t.top) {
      let i = this.topRules[t.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${t.top}`);
      e.top = i;
    }
    return t.tokenizers && (e.tokenizers = this.tokenizers.map((i) => {
      let r = t.tokenizers.find((n) => n.from == i);
      return r ? r.to : i;
    })), t.specializers && (e.specializers = this.specializers.slice(), e.specializerSpecs = this.specializerSpecs.map((i, r) => {
      let n = t.specializers.find((o) => o.from == i.external);
      if (!n)
        return i;
      let a = Object.assign(Object.assign({}, i), { external: n.to });
      return e.specializers[r] = F5(a), a;
    })), t.contextTracker && (e.context = t.contextTracker), t.dialect && (e.dialect = this.parseDialect(t.dialect)), t.strict != null && (e.strict = t.strict), t.wrap && (e.wrappers = e.wrappers.concat(t.wrap)), t.bufferLength != null && (e.bufferLength = t.bufferLength), e;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(t) {
    return this.termNames ? this.termNames[t] : String(t <= this.maxNode && this.nodeSet.types[t].name || t);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(t) {
    let e = this.dynamicPrecedences;
    return e == null ? 0 : e[t] || 0;
  }
  /**
  @internal
  */
  parseDialect(t) {
    let e = Object.keys(this.dialects), i = e.map(() => !1);
    if (t)
      for (let n of t.split(" ")) {
        let a = e.indexOf(n);
        a >= 0 && (i[a] = !0);
      }
    let r = null;
    for (let n = 0; n < e.length; n++)
      if (!i[n])
        for (let a = this.dialects[e[n]], o; (o = this.data[a++]) != 65535; )
          (r || (r = new Uint8Array(this.maxTerm + 1)))[o] = 1;
    return new SZ(t, i, r);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(t) {
    return new ca(t);
  }
}, h(ca, "Br"), ca);
m(BR, "LRParser");
let uP = BR;
function rs(s, t) {
  return s[t] | s[t + 1] << 16;
}
h(rs, "at$2");
m(rs, "pair");
function NR(s) {
  let t = null;
  for (let e of s) {
    let i = e.p.stoppedAt;
    (e.pos == e.p.stream.end || i != null && e.pos > i) && e.p.parser.stateFlag(
      e.state,
      2
      /* StateFlag.Accepting */
    ) && (!t || t.score < e.score) && (t = e);
  }
  return t;
}
h(NR, "ky$1");
m(NR, "findFinished");
function F5(s) {
  if (s.external) {
    let t = s.extend ? 1 : 0;
    return (e, i) => s.external(e, i) << 1 | t;
  }
  return s.get;
}
h(F5, "wO");
m(F5, "getSpecializer");
const CZ = 55, PZ = 1, QZ = 56, TZ = 2, MZ = 57, AZ = 3, zQ = 4, RZ = 5, pP = 6, XR = 7, jR = 8, UR = 9, HR = 10, EZ = 11, _Z = 12, LZ = 13, L2 = 58, zZ = 14, IZ = 15, IQ = 59, YR = 21, DZ = 23, GR = 24, VZ = 25, q5 = 27, KR = 28, WZ = 29, FZ = 32, qZ = 35, ZZ = 37, BZ = 38, NZ = 0, XZ = 1, jZ = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, UZ = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, DQ = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function JR(s) {
  return s == 45 || s == 46 || s == 58 || s >= 65 && s <= 90 || s == 95 || s >= 97 && s <= 122 || s >= 161;
}
h(JR, "Ny$1");
m(JR, "nameChar");
let VQ = null, WQ = null, FQ = 0;
function NO(s, t) {
  let e = s.pos + t;
  if (FQ == e && WQ == s) return VQ;
  let i = s.peek(t), r = "";
  for (; JR(i); )
    r += String.fromCharCode(i), i = s.peek(++t);
  return WQ = s, FQ = e, VQ = r ? r.toLowerCase() : i == HZ || i == YZ ? void 0 : null;
}
h(NO, "Ja$1");
m(NO, "tagNameAfter");
const tE = 60, XO = 62, fP = 47, HZ = 63, YZ = 33, GZ = 45;
function Z5(s, t) {
  this.name = s, this.parent = t;
}
h(Z5, "TO");
m(Z5, "ElementContext");
const KZ = [pP, HR, XR, jR, UR], JZ = new ZR({
  start: null,
  shift(s, t, e, i) {
    return KZ.indexOf(t) > -1 ? new Z5(NO(i, 1) || "", s) : s;
  },
  reduce(s, t) {
    return t == YR && s ? s.parent : s;
  },
  reuse(s, t, e, i) {
    let r = t.type.id;
    return r == pP || r == ZZ ? new Z5(NO(i, 1) || "", s) : s;
  },
  strict: !1
}), tB = new hr((s, t) => {
  if (s.next != tE) {
    s.next < 0 && t.context && s.acceptToken(L2);
    return;
  }
  s.advance();
  let e = s.next == fP;
  e && s.advance();
  let i = NO(s, 0);
  if (i === void 0) return;
  if (!i) return s.acceptToken(e ? IZ : zZ);
  let r = t.context ? t.context.name : null;
  if (e) {
    if (i == r) return s.acceptToken(EZ);
    if (r && UZ[r]) return s.acceptToken(L2, -2);
    if (t.dialectEnabled(NZ)) return s.acceptToken(_Z);
    for (let n = t.context; n; n = n.parent) if (n.name == i) return;
    s.acceptToken(LZ);
  } else {
    if (i == "script") return s.acceptToken(XR);
    if (i == "style") return s.acceptToken(jR);
    if (i == "textarea") return s.acceptToken(UR);
    if (jZ.hasOwnProperty(i)) return s.acceptToken(HR);
    r && DQ[r] && DQ[r][i] ? s.acceptToken(L2, -1) : s.acceptToken(pP);
  }
}, { contextual: !0 }), eB = new hr((s) => {
  for (let t = 0, e = 0; ; e++) {
    if (s.next < 0) {
      e && s.acceptToken(IQ);
      break;
    }
    if (s.next == GZ)
      t++;
    else if (s.next == XO && t >= 2) {
      e >= 3 && s.acceptToken(IQ, -2);
      break;
    } else
      t = 0;
    s.advance();
  }
});
function eE(s) {
  for (; s; s = s.parent)
    if (s.name == "svg" || s.name == "math") return !0;
  return !1;
}
h(eE, "iS");
m(eE, "inForeignElement");
const iB = new hr((s, t) => {
  if (s.next == fP && s.peek(1) == XO) {
    let e = t.dialectEnabled(XZ) || eE(t.context);
    s.acceptToken(e ? RZ : zQ, 2);
  } else s.next == XO && s.acceptToken(zQ, 1);
});
function cb(s, t, e) {
  let i = 2 + s.length;
  return new hr((r) => {
    for (let n = 0, a = 0, o = 0; ; o++) {
      if (r.next < 0) {
        o && r.acceptToken(t);
        break;
      }
      if (n == 0 && r.next == tE || n == 1 && r.next == fP || n >= 2 && n < i && r.next == s.charCodeAt(n - 2))
        n++, a++;
      else if (n == i && r.next == XO) {
        o > a ? r.acceptToken(t, -a) : r.acceptToken(e, -(a - 2));
        break;
      } else if ((r.next == 10 || r.next == 13) && o) {
        r.acceptToken(t, 1);
        break;
      } else
        n = a = 0;
      r.advance();
    }
  });
}
h(cb, "Ch$1");
m(cb, "contentTokenizer");
const rB = cb("script", CZ, PZ), sB = cb("style", QZ, TZ), nB = cb("textarea", MZ, AZ), aB = Il({
  "Text RawText IncompleteTag IncompleteCloseTag": Q.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": Q.angleBracket,
  TagName: Q.tagName,
  "MismatchedCloseTag/TagName": [Q.tagName, Q.invalid],
  AttributeName: Q.attributeName,
  "AttributeValue UnquotedAttributeValue": Q.attributeValue,
  Is: Q.definitionOperator,
  "EntityReference CharacterReference": Q.character,
  Comment: Q.blockComment,
  ProcessingInst: Q.processingInstruction,
  DoctypeDecl: Q.documentMeta
}), oB = uP.deserialize({
  version: 14,
  states: ",xOVO!rOOO!ZQ#tO'#CrO!`Q#tO'#C{O!eQ#tO'#DOO!jQ#tO'#DRO!oQ#tO'#DTO!tOaO'#CqO#PObO'#CqO#[OdO'#CqO$kO!rO'#CqOOO`'#Cq'#CqO$rO$fO'#DUO$zQ#tO'#DWO%PQ#tO'#DXOOO`'#Dl'#DlOOO`'#DZ'#DZQVO!rOOO%UQ&rO,59^O%aQ&rO,59gO%lQ&rO,59jO%wQ&rO,59mO&SQ&rO,59oOOOa'#D_'#D_O&_OaO'#CyO&jOaO,59]OOOb'#D`'#D`O&rObO'#C|O&}ObO,59]OOOd'#Da'#DaO'VOdO'#DPO'bOdO,59]OOO`'#Db'#DbO'jO!rO,59]O'qQ#tO'#DSOOO`,59],59]OOOp'#Dc'#DcO'vO$fO,59pOOO`,59p,59pO(OQ#|O,59rO(TQ#|O,59sOOO`-E7X-E7XO(YQ&rO'#CtOOQW'#D['#D[O(hQ&rO1G.xOOOa1G.x1G.xOOO`1G/Z1G/ZO(sQ&rO1G/ROOOb1G/R1G/RO)OQ&rO1G/UOOOd1G/U1G/UO)ZQ&rO1G/XOOO`1G/X1G/XO)fQ&rO1G/ZOOOa-E7]-E7]O)qQ#tO'#CzOOO`1G.w1G.wOOOb-E7^-E7^O)vQ#tO'#C}OOOd-E7_-E7_O){Q#tO'#DQOOO`-E7`-E7`O*QQ#|O,59nOOOp-E7a-E7aOOO`1G/[1G/[OOO`1G/^1G/^OOO`1G/_1G/_O*VQ,UO,59`OOQW-E7Y-E7YOOOa7+$d7+$dOOO`7+$u7+$uOOOb7+$m7+$mOOOd7+$p7+$pOOO`7+$s7+$sO*bQ#|O,59fO*gQ#|O,59iO*lQ#|O,59lOOO`1G/Y1G/YO*qO7[O'#CwO+SOMhO'#CwOOQW1G.z1G.zOOO`1G/Q1G/QOOO`1G/T1G/TOOO`1G/W1G/WOOOO'#D]'#D]O+eO7[O,59cOOQW,59c,59cOOOO'#D^'#D^O+vOMhO,59cOOOO-E7Z-E7ZOOQW1G.}1G.}OOOO-E7[-E7[",
  stateData: ",c~O!_OS~OUSOVPOWQOXROYTO[]O][O^^O_^Oa^Ob^Oc^Od^Oy^O|_O!eZO~OgaO~OgbO~OgcO~OgdO~OgeO~O!XfOPmP![mP~O!YiOQpP![pP~O!ZlORsP![sP~OUSOVPOWQOXROYTOZqO[]O][O^^O_^Oa^Ob^Oc^Od^Oy^O!eZO~O![rO~P#gO!]sO!fuO~OgvO~OgwO~OS|OT}OiyO~OS!POT}OiyO~OS!ROT}OiyO~OS!TOT}OiyO~OS}OT}OiyO~O!XfOPmX![mX~OP!WO![!XO~O!YiOQpX![pX~OQ!ZO![!XO~O!ZlORsX![sX~OR!]O![!XO~O![!XO~P#gOg!_O~O!]sO!f!aO~OS!bO~OS!cO~Oj!dOShXThXihX~OS!fOT!gOiyO~OS!hOT!gOiyO~OS!iOT!gOiyO~OS!jOT!gOiyO~OS!gOT!gOiyO~Og!kO~Og!lO~Og!mO~OS!nO~Ol!qO!a!oO!c!pO~OS!rO~OS!sO~OS!tO~Ob!uOc!uOd!uO!a!wO!b!uO~Ob!xOc!xOd!xO!c!wO!d!xO~Ob!uOc!uOd!uO!a!{O!b!uO~Ob!xOc!xOd!xO!c!{O!d!xO~OT~cbd!ey|!e~",
  goto: "%q!aPPPPPPPPPPPPPPPPPPPPP!b!hP!nPP!zP!}#Q#T#Z#^#a#g#j#m#s#y!bP!b!bP$P$V$m$s$y%P%V%]%cPPPPPPPP%iX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 68,
  context: JZ,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 22, 31, 34, 37, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 30, 33, 36, 38, "OpenTag"],
    ["group", -10, 14, 15, 18, 19, 20, 21, 40, 41, 42, 43, "Entity", 17, "Entity TextContent", -3, 29, 32, 35, "TextContent Entity"],
    ["isolate", -11, 22, 30, 31, 33, 34, 36, 37, 38, 39, 42, 43, "ltr", -3, 27, 28, 40, ""]
  ],
  propSources: [aB],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|caPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bXaP!b`!dpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UVaP!dpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pTaPOv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!dpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({WaP!b`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!b`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!b`!dpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYlWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]`aP!b`!dp!_^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljiSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebiSlWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXiSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vciSaP!b`!dpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!ahaP!dpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WiiSlWd!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zblWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOb!R!R7tP;=`<%l7S!Z8OYlWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{iiSlWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbiSlWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QciSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXiSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhiSlWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TalWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOc!R!RAwP;=`<%lAY!ZBRYlWc!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhiSlWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbiSlWc!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbiSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXiSc!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!cxaP!b`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYliSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_kiSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_XaP!b`!dp!fQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZiSgQaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!b`!dpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!b`!dpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!b`!dpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!b`!dp!ePOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!b`!dpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!b`!dpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!b`!dpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!b`!dpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!b`!dpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!b`!dpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!b`!dpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!dpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO|PP!-nP;=`<%l!-Sq!-xS!dp|POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!b`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!b`|POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!b`!dp|POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!b`!dpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!b`!dpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!b`!dpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!b`!dpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!b`!dpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!b`!dpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!b`!dpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!dpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOyPP!7TP;=`<%l!6Vq!7]V!dpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!dpyPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!b`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!b`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!b`yPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!b`!dpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!b`!dpyPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXjSaP!b`!dpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [rB, sB, nB, iB, tB, eB, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 16] },
  dialects: { noMatch: 0, selfClosing: 515 },
  tokenPrec: 517
});
function mP(s, t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let i of s.getChildren(GR)) {
    let r = i.getChild(VZ), n = i.getChild(q5) || i.getChild(KR);
    r && (e[t.read(r.from, r.to)] = n ? n.type.id == q5 ? t.read(n.from + 1, n.to - 1) : t.read(n.from, n.to) : "");
  }
  return e;
}
h(mP, "fm$1");
m(mP, "getAttrs");
function B5(s, t) {
  let e = s.getChild(DZ);
  return e ? t.read(e.from, e.to) : " ";
}
h(B5, "AO");
m(B5, "findTagName");
function zv(s, t, e) {
  let i;
  for (let r of e)
    if (!r.attrs || r.attrs(i || (i = mP(s.node.parent.firstChild, t))))
      return { parser: r.parser };
  return null;
}
h(zv, "No$1");
m(zv, "maybeNest");
function yP(s = [], t = []) {
  let e = [], i = [], r = [], n = [];
  for (let o of s)
    (o.tag == "script" ? e : o.tag == "style" ? i : o.tag == "textarea" ? r : n).push(o);
  let a = t.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let o of t) (a[o.name] || (a[o.name] = [])).push(o);
  return EC((o, l) => {
    let d = o.type.id;
    if (d == WZ) return zv(o, l, e);
    if (d == FZ) return zv(o, l, i);
    if (d == qZ) return zv(o, l, r);
    if (d == YR && n.length) {
      let u = o.node, p = u.firstChild, f = p && B5(p, l), y;
      if (f) {
        for (let g of n)
          if (g.tag == f && (!g.attrs || g.attrs(y || (y = mP(p, l))))) {
            let O = u.lastChild, k = O.type.id == BZ ? O.from : u.to;
            if (k > p.to)
              return { parser: g.parser, overlay: [{ from: p.to, to: k }] };
          }
      }
    }
    if (a && d == GR) {
      let u = o.node, p;
      if (p = u.firstChild) {
        let f = a[l.read(p.from, p.to)];
        if (f) for (let y of f) {
          if (y.tagName && y.tagName != B5(u.parent, l)) continue;
          let g = u.lastChild;
          if (g.type.id == q5) {
            let O = g.from + 1, k = g.lastChild, $ = g.to - (k && k.isError ? 0 : 1);
            if ($ > O) return { parser: y.parser, overlay: [{ from: O, to: $ }] };
          } else if (g.type.id == KR)
            return { parser: y.parser, overlay: [{ from: g.from, to: g.to }] };
        }
      }
    }
    return null;
  });
}
h(yP, "cm$1");
m(yP, "configureNesting");
const lB = 122, qQ = 1, cB = 123, hB = 124, iE = 2, dB = 125, uB = 3, pB = 4, rE = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], fB = 58, mB = 40, sE = 95, yB = 91, Iv = 45, gB = 46, wB = 35, vB = 37, OB = 38, bB = 92, $B = 10, xB = 42;
function yy(s) {
  return s >= 65 && s <= 90 || s >= 97 && s <= 122 || s >= 161;
}
h(yy, "dn$1");
m(yy, "isAlpha");
function hb(s) {
  return s >= 48 && s <= 57;
}
h(hb, "Xh");
m(hb, "isDigit");
function N5(s) {
  return hb(s) || s >= 97 && s <= 102 || s >= 65 && s <= 70;
}
h(N5, "_O");
m(N5, "isHex");
const nE = /* @__PURE__ */ m((s, t, e) => (i, r) => {
  for (let n = !1, a = 0, o = 0; ; o++) {
    let { next: l } = i;
    if (yy(l) || l == Iv || l == sE || n && hb(l))
      !n && (l != Iv || o > 0) && (n = !0), a === o && l == Iv && a++, i.advance();
    else if (l == bB && i.peek(1) != $B) {
      if (i.advance(), N5(i.next)) {
        do
          i.advance();
        while (N5(i.next));
        i.next == 32 && i.advance();
      } else i.next > -1 && i.advance();
      n = !0;
    } else {
      n && i.acceptToken(
        a == 2 && r.canShift(iE) ? t : l == mB ? e : s
      );
      break;
    }
  }
}, "identifierTokens"), kB = new hr(
  nE(cB, iE, hB)
), SB = new hr(
  nE(dB, uB, pB)
), CB = new hr((s) => {
  if (rE.includes(s.peek(-1))) {
    let { next: t } = s;
    (yy(t) || t == sE || t == wB || t == gB || t == xB || t == yB || t == fB && yy(s.peek(1)) || t == Iv || t == OB) && s.acceptToken(lB);
  }
}), PB = new hr((s) => {
  if (!rE.includes(s.peek(-1))) {
    let { next: t } = s;
    if (t == vB && (s.advance(), s.acceptToken(qQ)), yy(t)) {
      do
        s.advance();
      while (yy(s.next) || hb(s.next));
      s.acceptToken(qQ);
    }
  }
}), QB = Il({
  "AtKeyword import charset namespace keyframes media supports": Q.definitionKeyword,
  "from to selector": Q.keyword,
  NamespaceName: Q.namespace,
  KeyframeName: Q.labelName,
  KeyframeRangeName: Q.operatorKeyword,
  TagName: Q.tagName,
  ClassName: Q.className,
  PseudoClassName: Q.constant(Q.className),
  IdName: Q.labelName,
  "FeatureName PropertyName": Q.propertyName,
  AttributeName: Q.attributeName,
  NumberLiteral: Q.number,
  KeywordQuery: Q.keyword,
  UnaryQueryOp: Q.operatorKeyword,
  "CallTag ValueName": Q.atom,
  VariableName: Q.variableName,
  Callee: Q.operatorKeyword,
  Unit: Q.unit,
  "UniversalSelector NestingSelector": Q.definitionOperator,
  "MatchOp CompareOp": Q.compareOperator,
  "ChildOp SiblingOp, LogicOp": Q.logicOperator,
  BinOp: Q.arithmeticOperator,
  Important: Q.modifier,
  Comment: Q.blockComment,
  ColorLiteral: Q.color,
  "ParenthesizedContent StringLiteral": Q.string,
  ":": Q.punctuation,
  "PseudoOp #": Q.derefOperator,
  "; ,": Q.separator,
  "( )": Q.paren,
  "[ ]": Q.squareBracket,
  "{ }": Q.brace
}), TB = { __proto__: null, lang: 38, "nth-child": 38, "nth-last-child": 38, "nth-of-type": 38, "nth-last-of-type": 38, dir: 38, "host-context": 38, if: 84, url: 124, "url-prefix": 124, domain: 124, regexp: 124 }, MB = { __proto__: null, or: 98, and: 98, not: 106, only: 106, layer: 170 }, AB = { __proto__: null, selector: 112, layer: 166 }, RB = { __proto__: null, "@import": 162, "@media": 174, "@charset": 178, "@namespace": 182, "@keyframes": 188, "@supports": 200, "@scope": 204 }, EB = { __proto__: null, to: 207 }, _B = uP.deserialize({
  version: 14,
  states: "EbQYQdOOO#qQdOOP#xO`OOOOQP'#Cf'#CfOOQP'#Ce'#CeO#}QdO'#ChO$nQaO'#CcO$xQdO'#CkO%TQdO'#DpO%YQdO'#DrO%_QdO'#DuO%_QdO'#DxOOQP'#FV'#FVO&eQhO'#EhOOQS'#FU'#FUOOQS'#Ek'#EkQYQdOOO&lQdO'#EOO&PQhO'#EUO&lQdO'#EWO'aQdO'#EYO'lQdO'#E]O'tQhO'#EcO(VQdO'#EeO(bQaO'#CfO)VQ`O'#D{O)[Q`O'#F`O)gQdO'#F`QOQ`OOP)qO&jO'#CaPOOO)C@t)C@tOOQP'#Cj'#CjOOQP,59S,59SO#}QdO,59SO)|QdO,59VO%TQdO,5:[O%YQdO,5:^O%_QdO,5:aO%_QdO,5:cO%_QdO,5:dO%_QdO'#ErO*XQ`O,58}O*aQdO'#DzOOQS,58},58}OOQP'#Cn'#CnOOQO'#Dn'#DnOOQP,59V,59VO*hQ`O,59VO*mQ`O,59VOOQP'#Dq'#DqOOQP,5:[,5:[OOQO'#Ds'#DsO*rQpO,5:^O+]QaO,5:aO+sQaO,5:dOOQW'#DZ'#DZO,ZQhO'#DdO,xQhO'#FaO'tQhO'#DbO-WQ`O'#DhOOQW'#F['#F[O-]Q`O,5;SO-eQ`O'#DeOOQS-E8i-E8iOOQ['#Cs'#CsO-jQdO'#CtO.QQdO'#CzO.hQdO'#C}O/OQ!pO'#DPO1RQ!jO,5:jOOQO'#DU'#DUO*mQ`O'#DTO1cQ!nO'#FXO3`Q`O'#DVO3eQ`O'#DkOOQ['#FX'#FXO-`Q`O,5:pO3jQ!bO,5:rOOQS'#E['#E[O3rQ`O,5:tO3wQdO,5:tOOQO'#E_'#E_O4PQ`O,5:wO4UQhO,5:}O%_QdO'#DgOOQS,5;P,5;PO-eQ`O,5;PO4^QdO,5;PO4fQdO,5:gO4vQdO'#EtO5TQ`O,5;zO5TQ`O,5;zPOOO'#Ej'#EjP5`O&jO,58{POOO,58{,58{OOQP1G.n1G.nOOQP1G.q1G.qO*hQ`O1G.qO*mQ`O1G.qOOQP1G/v1G/vO5kQpO1G/xO5sQaO1G/{O6ZQaO1G/}O6qQaO1G0OO7XQaO,5;^OOQO-E8p-E8pOOQS1G.i1G.iO7cQ`O,5:fO7hQdO'#DoO7oQdO'#CrOOQP1G/x1G/xO&lQdO1G/xO7vQ!jO'#DZO8UQ!bO,59vO8^QhO,5:OOOQO'#F]'#F]O8XQ!bO,59zO'tQhO,59xO8fQhO'#EvO8sQ`O,5;{O9OQhO,59|O9uQhO'#DiOOQW,5:S,5:SOOQS1G0n1G0nOOQW,5:P,5:PO9|Q!fO'#FYOOQS'#FY'#FYOOQS'#Em'#EmO;^QdO,59`OOQ[,59`,59`O;tQdO,59fOOQ[,59f,59fO<[QdO,59iOOQ[,59i,59iOOQ[,59k,59kO&lQdO,59mO<rQhO'#EQOOQW'#EQ'#EQO=WQ`O1G0UO1[QhO1G0UOOQ[,59o,59oO'tQhO'#DXOOQ[,59q,59qO=]Q#tO,5:VOOQS1G0[1G0[OOQS1G0^1G0^OOQS1G0`1G0`O=hQ`O1G0`O=mQdO'#E`OOQS1G0c1G0cOOQS1G0i1G0iO=xQaO,5:RO-`Q`O1G0kOOQS1G0k1G0kO-eQ`O1G0kO>PQ!fO1G0ROOQO1G0R1G0ROOQO,5;`,5;`O>gQdO,5;`OOQO-E8r-E8rO>tQ`O1G1fPOOO-E8h-E8hPOOO1G.g1G.gOOQP7+$]7+$]OOQP7+%d7+%dO&lQdO7+%dOOQS1G0Q1G0QO?PQaO'#F_O?ZQ`O,5:ZO?`Q!fO'#ElO@^QdO'#FWO@hQ`O,59^O@mQ!bO7+%dO&lQdO1G/bO@uQhO1G/fOOQW1G/j1G/jOOQW1G/d1G/dOAWQhO,5;bOOQO-E8t-E8tOAfQhO'#DZOAtQhO'#F^OBPQ`O'#F^OBUQ`O,5:TOOQS-E8k-E8kOOQ[1G.z1G.zOOQ[1G/Q1G/QOOQ[1G/T1G/TOOQ[1G/X1G/XOBZQdO,5:lOOQS7+%p7+%pOB`Q`O7+%pOBeQhO'#DYOBmQ`O,59sO'tQhO,59sOOQ[1G/q1G/qOBuQ`O1G/qOOQS7+%z7+%zOBzQbO'#DPOOQO'#Eb'#EbOCYQ`O'#EaOOQO'#Ea'#EaOCeQ`O'#EwOCmQdO,5:zOOQS,5:z,5:zOOQ[1G/m1G/mOOQS7+&V7+&VO-`Q`O7+&VOCxQ!fO'#EsO&lQdO'#EsOEPQdO7+%mOOQO7+%m7+%mOOQO1G0z1G0zOEdQ!bO<<IOOElQdO'#EqOEvQ`O,5;yOOQP1G/u1G/uOOQS-E8j-E8jOFOQdO'#EpOFYQ`O,5;rOOQ]1G.x1G.xOOQP<<IO<<IOOFbQdO7+$|OOQO'#D]'#D]OFiQ!bO7+%QOFqQhO'#EoOF{Q`O,5;xO&lQdO,5;xOOQW1G/o1G/oOOQO'#ES'#ESOGTQ`O1G0WOOQS<<I[<<I[O&lQdO,59tOGnQhO1G/_OOQ[1G/_1G/_OGuQ`O1G/_OOQW-E8l-E8lOOQ[7+%]7+%]OOQO,5:{,5:{O=pQdO'#ExOCeQ`O,5;cOOQS,5;c,5;cOOQS-E8u-E8uOOQS1G0f1G0fOOQS<<Iq<<IqOG}Q!fO,5;_OOQS-E8q-E8qOOQO<<IX<<IXOOQPAN>jAN>jOIUQaO,5;]OOQO-E8o-E8oOI`QdO,5;[OOQO-E8n-E8nOOQW<<Hh<<HhOOQW<<Hl<<HlOIjQhO<<HlOI{QhO,5;ZOJWQ`O,5;ZOOQO-E8m-E8mOJ]QdO1G1dOBZQdO'#EuOJgQ`O7+%rOOQW7+%r7+%rOJoQ!bO1G/`OOQ[7+$y7+$yOJzQhO7+$yPKRQ`O'#EnOOQO,5;d,5;dOOQO-E8v-E8vOOQS1G0}1G0}OKWQ`OAN>WO&lQdO1G0uOK]Q`O7+'OOOQO,5;a,5;aOOQO-E8s-E8sOOQW<<I^<<I^OOQ[<<He<<HePOQW,5;Y,5;YOOQWG23rG23rOKeQdO7+&a",
  stateData: "Kx~O#sOS#tQQ~OW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#oRO~OQiOW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#ohO~O#m$SP~P!dO#tmO~O#ooO~O]qO`rOarOjsOmtO!juO!mwO#nvO~OpzO!^xO~P$SOc!QO#o|O#p}O~O#o!RO~O#o!TO~OW[OZ[O]TO`VOaVOjWOmXO!jYO!mZO#oRO~OS!]Oe!YO!V![O!Y!`O#q!XOp$TP~Ok$TP~P&POQ!jOe!cOm!dOp!eOr!mOt!mOz!kO!`!lO#o!bO#p!hO#}!fO~Ot!qO!`!lO#o!pO~Ot!sO#o!sO~OS!]Oe!YO!V![O!Y!`O#q!XO~Oe!vOpzO#Z!xO~O]YX`YX`!pXaYXjYXmYXpYX!^YX!jYX!mYX#nYX~O`!zO~Ok!{O#m$SXo$SX~O#m$SXo$SX~P!dO#u#OO#v#OO#w#QO~Oc#UO#o|O#p}O~OpzO!^xO~Oo$SP~P!dOe#`O~Oe#aO~Ol#bO!h#cO~O]qO`rOarOjsOmtO~Op!ia!^!ia!j!ia!m!ia#n!iad!ia~P*zOp!la!^!la!j!la!m!la#n!lad!la~P*zOR#gOS!]Oe!YOr#gOt#gO!V![O!Y!`O#q#dO#}!fO~O!R#iO!^#jOk$TXp$TX~Oe#mO~Ok#oOpzO~Oe!vO~O]#rO`#rOd#uOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl#wO~P&lO]#rO`#rOi#rOj#rOk#rOo#yO~P&lOP#zOSsXesXksXvsX!VsX!YsX!usX!wsX#qsX!TsXQsX]sX`sXdsXisXjsXmsXpsXrsXtsXzsX!`sX#osX#psX#}sXlsXosX!^sX!qsX#msX~Ov#{O!u#|O!w#}Ok$TP~P'tOe#aOS#{Xk#{Xv#{X!V#{X!Y#{X!u#{X!w#{X#q#{XQ#{X]#{X`#{Xd#{Xi#{Xj#{Xm#{Xp#{Xr#{Xt#{Xz#{X!`#{X#o#{X#p#{X#}#{Xl#{Xo#{X!^#{X!q#{X#m#{X~Oe$RO~Oe$TO~Ok$VOv#{O~Ok$WO~Ot$XO!`!lO~Op$YO~OpzO!R#iO~OpzO#Z$`O~O!q$bOk!oa#m!oao!oa~P&lOk#hX#m#hXo#hX~P!dOk!{O#m$Sao$Sa~O#u#OO#v#OO#w$hO~Ol$jO!h$kO~Op!ii!^!ii!j!ii!m!ii#n!iid!ii~P*zOp!ki!^!ki!j!ki!m!ki#n!kid!ki~P*zOp!li!^!li!j!li!m!li#n!lid!li~P*zOp#fa!^#fa~P$SOo$lO~Od$RP~P%_Od#zP~P&lO`!PXd}X!R}X!T!PX~O`$sO!T$tO~Od$uO!R#iO~Ok#jXp#jX!^#jX~P'tO!^#jOk$Tap$Ta~O!R#iOk!Uap!Ua!^!Uad!Ua`!Ua~OS!]Oe!YO!V![O!Y!`O#q$yO~Od$QP~P9dOv#{OQ#|X]#|X`#|Xd#|Xe#|Xi#|Xj#|Xk#|Xm#|Xp#|Xr#|Xt#|Xz#|X!`#|X#o#|X#p#|X#}#|Xl#|Xo#|X~O]#rO`#rOd%OOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl%PO~P&lO]#rO`#rOi#rOj#rOk#rOo%QO~P&lOe%SOS!tXk!tX!V!tX!Y!tX#q!tX~Ok%TO~Od%YOt%ZO!a%ZO~Ok%[O~Oo%cO#o%^O#}%]O~Od%dO~P$SOv#{O!^%hO!q%jOk!oi#m!oio!oi~P&lOk#ha#m#hao#ha~P!dOk!{O#m$Sio$Si~O!^%mOd$RX~P$SOd%oO~Ov#{OQ#`Xd#`Xe#`Xm#`Xp#`Xr#`Xt#`Xz#`X!^#`X!`#`X#o#`X#p#`X#}#`X~O!^%qOd#zX~P&lOd%sO~Ol%tOv#{O~OR#gOr#gOt#gO#q%vO#}!fO~O!R#iOk#jap#ja!^#ja~O`!PXd}X!R}X!^}X~O!R#iO!^%xOd$QX~O`%zO~Od%{O~O#o%|O~Ok&OO~O`&PO!R#iO~Od&ROk&QO~Od&UO~OP#zOpsX!^sXdsX~O#}%]Op#TX!^#TX~OpzO!^&WO~Oo&[O#o%^O#}%]O~Ov#{OQ#gXe#gXk#gXm#gXp#gXr#gXt#gXz#gX!^#gX!`#gX!q#gX#m#gX#o#gX#p#gX#}#gXo#gX~O!^%hO!q&`Ok!oq#m!oqo!oq~P&lOl&aOv#{O~Od#eX!^#eX~P%_O!^%mOd$Ra~Od#dX!^#dX~P&lO!^%qOd#za~Od&fO~P&lOd&gO!T&hO~Od#cX!^#cX~P9dO!^%xOd$Qa~O]&mOd&oO~OS#bae#ba!V#ba!Y#ba#q#ba~Od&qO~PG]Od&qOk&rO~Ov#{OQ#gae#gak#gam#gap#gar#gat#gaz#ga!^#ga!`#ga!q#ga#m#ga#o#ga#p#ga#}#gao#ga~Od#ea!^#ea~P$SOd#da!^#da~P&lOR#gOr#gOt#gO#q%vO#}%]O~O!R#iOd#ca!^#ca~O`&xO~O!^%xOd$Qi~P&lO]&mOd&|O~Ov#{Od|ik|i~Od&}O~PG]Ok'OO~Od'PO~O!^%xOd$Qq~Od#cq!^#cq~P&lO#s!a#t#}]#}v!m~",
  goto: "2h$UPPPPP$VP$YP$c$uP$cP%X$cPP%_PPP%e%o%oPPPPP%oPP%oP&]P%oP%o'W%oP't'w'}'}(^'}P'}P'}P'}'}P(m'}(yP(|PP)p)v$c)|$c*SP$cP$c$cP*Y*{+YP$YP+aP+dP$YP$YP$YP+j$YP+m+p+s+z$YP$YPP$YP,P,V,f,|-[-b-l-r-x.O.U.`.f.l.rPPPPPPPPPPP.x/R/w/z0|P1U1u2O2R2U2[RnQ_^OP`kz!{$dq[OPYZ`kuvwxz!v!{#`$d%mqSOPYZ`kuvwxz!v!{#`$d%mQpTR#RqQ!OVR#SrQ#S!QS$Q!i!jR$i#U!V!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'Q!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QU#g!Y$t&hU%`$Y%b&WR&V%_!V!iac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QR$S!kQ%W$RR&S%Xk!^]bf!Y![!g#i#j#m$P$R%X%xQ#e!YQ${#mQ%w$tQ&j%xR&w&hQ!ygQ#p!`Q$^!xR%f$`R#n!]!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QQ!qdR$X!rQ!PVR#TrQ#S!PR$i#TQ!SWR#VsQ!UXR#WtQ{UQ!wgQ#^yQ#o!_Q$U!nQ$[!uQ$_!yQ%e$^Q&Y%aQ&]%fR&v&XSjPzQ!}kQ$c!{R%k$dZiPkz!{$dR$P!gQ%}%SR&z&mR!rdR!teR$Z!tS%a$Y%bR&t&WV%_$Y%b&WQ#PmR$g#PQ`OSkPzU!a`k$dR$d!{Q$p#aY%p$p%u&d&l'QQ%u$sQ&d%qQ&l%zR'Q&xQ#t!cQ#v!dQ#x!eV$}#t#v#xQ%X$RR&T%XQ%y$zS&k%y&yR&y&lQ%r$pR&e%rQ%n$mR&c%nQyUR#]yQ%i$aR&_%iQ!|jS$e!|$fR$f!}Q&n%}R&{&nQ#k!ZR$x#kQ%b$YR&Z%bQ&X%aR&u&X__OP`kz!{$d^UOP`kz!{$dQ!VYQ!WZQ#XuQ#YvQ#ZwQ#[xQ$]!vQ$m#`R&b%mR$q#aQ!gaQ!oc[#q!c!d!e#t#v#xQ$a!zd$o#a$p$s%q%u%z&d&l&x'QQ$r#cQ%R#{S%g$a%iQ%l$kQ&^%hR&p&P]#s!c!d!e#t#v#xW!Z]b!g$PQ!ufQ#f!YQ#l![Q$v#iQ$w#jQ$z#mS%V$R%XR&i%xQ#h!YQ%w$tR&w&hR$|#mR$n#`QlPR#_zQ!_]Q!nbQ$O!gR%U$P",
  nodeNames: "⚠ Unit VariableName VariableName QueryCallee Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector . ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue AtKeyword # ; ] [ BracketedValue } { BracedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee IfExpression if ArgList IfBranch KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp ComparisonQuery CompareOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector ParenthesizedSelector CallQuery ArgList , CallLiteral CallTag ParenthesizedContent PseudoClassName ArgList IdSelector IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp Block Declaration PropertyName Important ImportStatement import Layer layer LayerName layer MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports ScopeStatement scope to AtRule Styles",
  maxTerm: 143,
  nodeProps: [
    ["isolate", -2, 5, 36, ""],
    ["openedBy", 20, "(", 28, "[", 31, "{"],
    ["closedBy", 21, ")", 29, "]", 32, "}"]
  ],
  propSources: [QB],
  skippedNodes: [0, 5, 106],
  repeatNodeCount: 15,
  tokenData: "JQ~R!YOX$qX^%i^p$qpq%iqr({rs-ust/itu6Wuv$qvw7Qwx7cxy9Qyz9cz{9h{|:R|}>t}!O?V!O!P?t!P!Q@]!Q![AU![!]BP!]!^B{!^!_C^!_!`DY!`!aDm!a!b$q!b!cEn!c!}$q!}#OG{#O#P$q#P#QH^#Q#R6W#R#o$q#o#pHo#p#q6W#q#rIQ#r#sIc#s#y$q#y#z%i#z$f$q$f$g%i$g#BY$q#BY#BZ%i#BZ$IS$q$IS$I_%i$I_$I|$q$I|$JO%i$JO$JT$q$JT$JU%i$JU$KV$q$KV$KW%i$KW&FU$q&FU&FV%i&FV;'S$q;'S;=`Iz<%lO$q`$tSOy%Qz;'S%Q;'S;=`%c<%lO%Q`%VS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q`%fP;=`<%l%Q~%nh#s~OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Q~'ah#s~!a`OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Qj)OUOy%Qz#]%Q#]#^)b#^;'S%Q;'S;=`%c<%lO%Qj)gU!a`Oy%Qz#a%Q#a#b)y#b;'S%Q;'S;=`%c<%lO%Qj*OU!a`Oy%Qz#d%Q#d#e*b#e;'S%Q;'S;=`%c<%lO%Qj*gU!a`Oy%Qz#c%Q#c#d*y#d;'S%Q;'S;=`%c<%lO%Qj+OU!a`Oy%Qz#f%Q#f#g+b#g;'S%Q;'S;=`%c<%lO%Qj+gU!a`Oy%Qz#h%Q#h#i+y#i;'S%Q;'S;=`%c<%lO%Qj,OU!a`Oy%Qz#T%Q#T#U,b#U;'S%Q;'S;=`%c<%lO%Qj,gU!a`Oy%Qz#b%Q#b#c,y#c;'S%Q;'S;=`%c<%lO%Qj-OU!a`Oy%Qz#h%Q#h#i-b#i;'S%Q;'S;=`%c<%lO%Qj-iS!qY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q~-xWOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c<%lO-u~.gOt~~.jRO;'S-u;'S;=`.s;=`O-u~.vXOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c;=`<%l-u<%lO-u~/fP;=`<%l-uj/nYjYOy%Qz!Q%Q!Q![0^![!c%Q!c!i0^!i#T%Q#T#Z0^#Z;'S%Q;'S;=`%c<%lO%Qj0cY!a`Oy%Qz!Q%Q!Q![1R![!c%Q!c!i1R!i#T%Q#T#Z1R#Z;'S%Q;'S;=`%c<%lO%Qj1WY!a`Oy%Qz!Q%Q!Q![1v![!c%Q!c!i1v!i#T%Q#T#Z1v#Z;'S%Q;'S;=`%c<%lO%Qj1}YrY!a`Oy%Qz!Q%Q!Q![2m![!c%Q!c!i2m!i#T%Q#T#Z2m#Z;'S%Q;'S;=`%c<%lO%Qj2tYrY!a`Oy%Qz!Q%Q!Q![3d![!c%Q!c!i3d!i#T%Q#T#Z3d#Z;'S%Q;'S;=`%c<%lO%Qj3iY!a`Oy%Qz!Q%Q!Q![4X![!c%Q!c!i4X!i#T%Q#T#Z4X#Z;'S%Q;'S;=`%c<%lO%Qj4`YrY!a`Oy%Qz!Q%Q!Q![5O![!c%Q!c!i5O!i#T%Q#T#Z5O#Z;'S%Q;'S;=`%c<%lO%Qj5TY!a`Oy%Qz!Q%Q!Q![5s![!c%Q!c!i5s!i#T%Q#T#Z5s#Z;'S%Q;'S;=`%c<%lO%Qj5zSrY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qd6ZUOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qd6tS!hS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qb7VSZQOy%Qz;'S%Q;'S;=`%c<%lO%Q~7fWOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z<%lO7c~8RRO;'S7c;'S;=`8[;=`O7c~8_XOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z;=`<%l7c<%lO7c~8}P;=`<%l7cj9VSeYOy%Qz;'S%Q;'S;=`%c<%lO%Q~9hOd~n9oUWQvWOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qj:YWvW!mQOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj:wU!a`Oy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Qj;bY!a`#}YOy%Qz!Q%Q!Q![;Z![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj<VY!a`Oy%Qz{%Q{|<u|}%Q}!O<u!O!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj<zU!a`Oy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj=eU!a`#}YOy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj>O[!a`#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj>yS!^YOy%Qz;'S%Q;'S;=`%c<%lO%Qj?[WvWOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj?yU]YOy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Q~@bTvWOy%Qz{@q{;'S%Q;'S;=`%c<%lO%Q~@xS!a`#t~Oy%Qz;'S%Q;'S;=`%c<%lO%QjAZ[#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%QjBUU`YOy%Qz![%Q![!]Bh!];'S%Q;'S;=`%c<%lO%QbBoSaQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjCQSkYOy%Qz;'S%Q;'S;=`%c<%lO%QhCcU!TWOy%Qz!_%Q!_!`Cu!`;'S%Q;'S;=`%c<%lO%QhC|S!TW!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QlDaS!TW!hSOy%Qz;'S%Q;'S;=`%c<%lO%QjDtV!jQ!TWOy%Qz!_%Q!_!`Cu!`!aEZ!a;'S%Q;'S;=`%c<%lO%QbEbS!jQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjEqYOy%Qz}%Q}!OFa!O!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjFfW!a`Oy%Qz!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjGV[iY!a`Oy%Qz}%Q}!OGO!O!Q%Q!Q![GO![!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjHQSmYOy%Qz;'S%Q;'S;=`%c<%lO%QnHcSl^Oy%Qz;'S%Q;'S;=`%c<%lO%QjHtSpYOy%Qz;'S%Q;'S;=`%c<%lO%QjIVSoYOy%Qz;'S%Q;'S;=`%c<%lO%QfIhU!mQOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Q`I}P;=`<%l$q",
  tokenizers: [CB, PB, kB, SB, 1, 2, 3, 4, new BO("m~RRYZ[z{a~~g~aO#v~~dP!P!Qg~lO#w~~", 28, 129)],
  topRules: { StyleSheet: [0, 6], Styles: [1, 105] },
  specialized: [{ term: 124, get: /* @__PURE__ */ m((s) => TB[s] || -1, "get") }, { term: 125, get: /* @__PURE__ */ m((s) => MB[s] || -1, "get") }, { term: 4, get: /* @__PURE__ */ m((s) => AB[s] || -1, "get") }, { term: 25, get: /* @__PURE__ */ m((s) => RB[s] || -1, "get") }, { term: 123, get: /* @__PURE__ */ m((s) => EB[s] || -1, "get") }],
  tokenPrec: 1963
});
let z2 = null;
function Dv() {
  if (!z2 && typeof document == "object" && document.body) {
    let { style: s } = document.body, t = [], e = /* @__PURE__ */ new Set();
    for (let i in s)
      i != "cssText" && i != "cssFloat" && typeof s[i] == "string" && (/[A-Z]/.test(i) && (i = i.replace(/[A-Z]/g, (r) => "-" + r.toLowerCase())), e.has(i) || (t.push(i), e.add(i)));
    z2 = t.sort().map((i) => ({ type: "property", label: i, apply: i + ": " }));
  }
  return z2 || [];
}
h(Dv, "Fo$1");
m(Dv, "properties");
const ZQ = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((s) => ({ type: "class", label: s })), BQ = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((s) => ({ type: "keyword", label: s })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((s) => ({ type: "constant", label: s }))), LB = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((s) => ({ type: "type", label: s })), zB = /* @__PURE__ */ [
  "@charset",
  "@color-profile",
  "@container",
  "@counter-style",
  "@font-face",
  "@font-feature-values",
  "@font-palette-values",
  "@import",
  "@keyframes",
  "@layer",
  "@media",
  "@namespace",
  "@page",
  "@position-try",
  "@property",
  "@scope",
  "@starting-style",
  "@supports",
  "@view-transition"
].map((s) => ({ type: "keyword", label: s })), Qs = /^(\w[\w-]*|-\w[\w-]*|)$/, IB = /^-(-[\w-]*)?$/;
function aE(s, t) {
  var e;
  if ((s.name == "(" || s.type.isError) && (s = s.parent || s), s.name != "ArgList")
    return !1;
  let i = (e = s.parent) === null || e === void 0 ? void 0 : e.firstChild;
  return i?.name != "Callee" ? !1 : t.sliceString(i.from, i.to) == "var";
}
h(aE, "WS");
m(aE, "isVarArg");
const NQ = /* @__PURE__ */ new xM(), DB = ["Declaration"];
function oE(s) {
  for (let t = s; ; ) {
    if (t.type.isTop)
      return t;
    if (!(t = t.parent))
      return s;
  }
}
h(oE, "US");
m(oE, "astTop");
function gP(s, t, e) {
  if (t.to - t.from > 4096) {
    let i = NQ.get(t);
    if (i)
      return i;
    let r = [], n = /* @__PURE__ */ new Set(), a = t.cursor(Ut.IncludeAnonymous);
    if (a.firstChild())
      do
        for (let o of gP(s, a.node, e))
          n.has(o.label) || (n.add(o.label), r.push(o));
      while (a.nextSibling());
    return NQ.set(t, r), r;
  } else {
    let i = [], r = /* @__PURE__ */ new Set();
    return t.cursor().iterate((n) => {
      var a;
      if (e(n) && n.matchContext(DB) && ((a = n.node.nextSibling) === null || a === void 0 ? void 0 : a.name) == ":") {
        let o = s.sliceString(n.from, n.to);
        r.has(o) || (r.add(o), i.push({ label: o, type: "variable" }));
      }
    }), i;
  }
}
h(gP, "mm$1");
m(gP, "variableNames");
const VB = /* @__PURE__ */ m((s) => (t) => {
  let { state: e, pos: i } = t, r = de(e).resolveInner(i, -1), n = r.type.isError && r.from == r.to - 1 && e.doc.sliceString(r.from, r.to) == "-";
  if (r.name == "PropertyName" || (n || r.name == "TagName") && /^(Block|Styles)$/.test(r.resolve(r.to).name))
    return { from: r.from, options: Dv(), validFor: Qs };
  if (r.name == "ValueName")
    return { from: r.from, options: BQ, validFor: Qs };
  if (r.name == "PseudoClassName")
    return { from: r.from, options: ZQ, validFor: Qs };
  if (s(r) || (t.explicit || n) && aE(r, e.doc))
    return {
      from: s(r) || n ? r.from : i,
      options: gP(e.doc, oE(r), s),
      validFor: IB
    };
  if (r.name == "TagName") {
    for (let { parent: l } = r; l; l = l.parent)
      if (l.name == "Block")
        return { from: r.from, options: Dv(), validFor: Qs };
    return { from: r.from, options: LB, validFor: Qs };
  }
  if (r.name == "AtKeyword")
    return { from: r.from, options: zB, validFor: Qs };
  if (!t.explicit)
    return null;
  let a = r.resolve(i), o = a.childBefore(i);
  return o && o.name == ":" && a.name == "PseudoClassSelector" ? { from: i, options: ZQ, validFor: Qs } : o && o.name == ":" && a.name == "Declaration" || a.name == "ArgList" ? { from: i, options: BQ, validFor: Qs } : a.name == "Block" || a.name == "Styles" ? { from: i, options: Dv(), validFor: Qs } : null;
}, "defineCSSCompletionSource"), WB = /* @__PURE__ */ VB((s) => s.name == "VariableName"), jO = /* @__PURE__ */ zC.define({
  name: "css",
  parser: /* @__PURE__ */ _B.configure({
    props: [
      /* @__PURE__ */ zy.add({
        Declaration: /* @__PURE__ */ Ow()
      }),
      /* @__PURE__ */ b1.add({
        "Block KeyframeList": WC
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function lE() {
  return new fy(jO, jO.data.of({ autocomplete: WB }));
}
h(lE, "ym$1");
m(lE, "css");
const FB = 316, qB = 317, XQ = 1, ZB = 2, BB = 3, NB = 4, XB = 318, jB = 320, UB = 321, HB = 5, YB = 6, GB = 0, X5 = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], cE = 125, KB = 59, j5 = 47, JB = 42, tN = 43, eN = 45, iN = 60, rN = 44, sN = 63, nN = 46, aN = 91, oN = new ZR({
  start: !1,
  shift(s, t) {
    return t == HB || t == YB || t == jB ? s : t == UB;
  },
  strict: !1
}), lN = new hr((s, t) => {
  let { next: e } = s;
  (e == cE || e == -1 || t.context) && s.acceptToken(XB);
}, { contextual: !0, fallback: !0 }), cN = new hr((s, t) => {
  let { next: e } = s, i;
  X5.indexOf(e) > -1 || e == j5 && ((i = s.peek(1)) == j5 || i == JB) || e != cE && e != KB && e != -1 && !t.context && s.acceptToken(FB);
}, { contextual: !0 }), hN = new hr((s, t) => {
  s.next == aN && !t.context && s.acceptToken(qB);
}, { contextual: !0 }), dN = new hr((s, t) => {
  let { next: e } = s;
  if (e == tN || e == eN) {
    if (s.advance(), e == s.next) {
      s.advance();
      let i = !t.context && t.canShift(XQ);
      s.acceptToken(i ? XQ : ZB);
    }
  } else e == sN && s.peek(1) == nN && (s.advance(), s.advance(), (s.next < 48 || s.next > 57) && s.acceptToken(BB));
}, { contextual: !0 });
function Vv(s, t) {
  return s >= 65 && s <= 90 || s >= 97 && s <= 122 || s == 95 || s >= 192 || !t && s >= 48 && s <= 57;
}
h(Vv, "Ho$1");
m(Vv, "identifierChar");
const uN = new hr((s, t) => {
  if (s.next != iN || !t.dialectEnabled(GB) || (s.advance(), s.next == j5)) return;
  let e = 0;
  for (; X5.indexOf(s.next) > -1; )
    s.advance(), e++;
  if (Vv(s.next, !0)) {
    for (s.advance(), e++; Vv(s.next, !1); )
      s.advance(), e++;
    for (; X5.indexOf(s.next) > -1; )
      s.advance(), e++;
    if (s.next == rN) return;
    for (let i = 0; ; i++) {
      if (i == 7) {
        if (!Vv(s.next, !0)) return;
        break;
      }
      if (s.next != "extends".charCodeAt(i)) break;
      s.advance(), e++;
    }
  }
  s.acceptToken(NB, -e);
}), pN = Il({
  "get set async static": Q.modifier,
  "for while do if else switch try catch finally return throw break continue default case defer": Q.controlKeyword,
  "in of await yield void typeof delete instanceof as satisfies": Q.operatorKeyword,
  "let var const using function class extends": Q.definitionKeyword,
  "import export from": Q.moduleKeyword,
  "with debugger new": Q.keyword,
  TemplateString: Q.special(Q.string),
  super: Q.atom,
  BooleanLiteral: Q.bool,
  this: Q.self,
  null: Q.null,
  Star: Q.modifier,
  VariableName: Q.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": Q.function(Q.variableName),
  VariableDefinition: Q.definition(Q.variableName),
  Label: Q.labelName,
  PropertyName: Q.propertyName,
  PrivatePropertyName: Q.special(Q.propertyName),
  "CallExpression/MemberExpression/PropertyName": Q.function(Q.propertyName),
  "FunctionDeclaration/VariableDefinition": Q.function(Q.definition(Q.variableName)),
  "ClassDeclaration/VariableDefinition": Q.definition(Q.className),
  "NewExpression/VariableName": Q.className,
  PropertyDefinition: Q.definition(Q.propertyName),
  PrivatePropertyDefinition: Q.definition(Q.special(Q.propertyName)),
  UpdateOp: Q.updateOperator,
  "LineComment Hashbang": Q.lineComment,
  BlockComment: Q.blockComment,
  Number: Q.number,
  String: Q.string,
  Escape: Q.escape,
  ArithOp: Q.arithmeticOperator,
  LogicOp: Q.logicOperator,
  BitOp: Q.bitwiseOperator,
  CompareOp: Q.compareOperator,
  RegExp: Q.regexp,
  Equals: Q.definitionOperator,
  Arrow: Q.function(Q.punctuation),
  ": Spread": Q.punctuation,
  "( )": Q.paren,
  "[ ]": Q.squareBracket,
  "{ }": Q.brace,
  "InterpolationStart InterpolationEnd": Q.special(Q.brace),
  ".": Q.derefOperator,
  ", ;": Q.separator,
  "@": Q.meta,
  TypeName: Q.typeName,
  TypeDefinition: Q.definition(Q.typeName),
  "type enum interface implements namespace module declare": Q.definitionKeyword,
  "abstract global Privacy readonly override": Q.modifier,
  "is keyof unique infer asserts": Q.operatorKeyword,
  JSXAttributeValue: Q.attributeValue,
  JSXText: Q.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": Q.angleBracket,
  "JSXIdentifier JSXNameSpacedName": Q.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": Q.attributeName,
  "JSXBuiltin/JSXIdentifier": Q.standard(Q.tagName)
}), fN = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, in: 52, out: 55, const: 56, extends: 60, this: 64, true: 72, false: 72, null: 84, void: 88, typeof: 92, super: 108, new: 142, delete: 154, yield: 163, await: 167, class: 172, public: 235, private: 235, protected: 235, readonly: 237, instanceof: 256, satisfies: 259, import: 292, keyof: 349, unique: 353, infer: 359, asserts: 395, is: 397, abstract: 417, implements: 419, type: 421, let: 424, var: 426, using: 429, interface: 435, enum: 439, namespace: 445, module: 447, declare: 451, global: 455, defer: 471, for: 476, of: 485, while: 488, with: 492, do: 496, if: 500, else: 502, switch: 506, case: 512, try: 518, catch: 522, finally: 526, return: 530, throw: 534, break: 538, continue: 542, debugger: 546 }, mN = { __proto__: null, async: 129, get: 131, set: 133, declare: 195, public: 197, private: 197, protected: 197, static: 199, abstract: 201, override: 203, readonly: 209, accessor: 211, new: 401 }, yN = { __proto__: null, "<": 193 }, gN = uP.deserialize({
  version: 14,
  states: "$F|Q%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#DaO.QQlO'#DgO.bQlO'#DrO%[QlO'#DzO0fQlO'#ESOOQ!0Lf'#E['#E[O1PQ`O'#EXOOQO'#Ep'#EpOOQO'#Il'#IlO1XQ`O'#GsO1dQ`O'#EoO1iQ`O'#EoO3hQ!0MxO'#JrO6[Q!0MxO'#JsO6uQ`O'#F]O6zQ,UO'#FtOOQ!0Lf'#Ff'#FfO7VO7dO'#FfO9XQMhO'#F|O9`Q`O'#F{OOQ!0Lf'#Js'#JsOOQ!0Lb'#Jr'#JrO9eQ`O'#GwOOQ['#K_'#K_O9pQ`O'#IYO9uQ!0LrO'#IZOOQ['#J`'#J`OOQ['#I_'#I_Q`QlOOQ`QlOOO9}Q!L^O'#DvO:UQlO'#EOO:]QlO'#EQO9kQ`O'#GsO:dQMhO'#CoO:rQ`O'#EnO:}Q`O'#EyO;hQMhO'#FeO;xQ`O'#GsOOQO'#K`'#K`O;}Q`O'#K`O<]Q`O'#G{O<]Q`O'#G|O<]Q`O'#HOO9kQ`O'#HRO=SQ`O'#HUO>kQ`O'#CeO>{Q`O'#HcO?TQ`O'#HiO?TQ`O'#HkO`QlO'#HmO?TQ`O'#HoO?TQ`O'#HrO?YQ`O'#HxO?_Q!0LsO'#IOO%[QlO'#IQO?jQ!0LsO'#ISO?uQ!0LsO'#IUO9uQ!0LrO'#IWO@QQ!0MxO'#CiOASQpO'#DlQOQ`OOO%[QlO'#EQOAjQ`O'#ETO:dQMhO'#EnOAuQ`O'#EnOBQQ!bO'#FeOOQ['#Cg'#CgOOQ!0Lb'#Dq'#DqOOQ!0Lb'#Jv'#JvO%[QlO'#JvOOQO'#Jy'#JyOOQO'#Ih'#IhOCQQpO'#EgOOQ!0Lb'#Ef'#EfOOQ!0Lb'#J}'#J}OC|Q!0MSO'#EgODWQpO'#EWOOQO'#Jx'#JxODlQpO'#JyOEyQpO'#EWODWQpO'#EgPFWO&2DjO'#CbPOOO)CD})CD}OOOO'#I`'#I`OFcO#tO,59UOOQ!0Lh,59U,59UOOOO'#Ia'#IaOFqO&jO,59UOGPQ!L^O'#DcOOOO'#Ic'#IcOGWO#@ItO,59{OOQ!0Lf,59{,59{OGfQlO'#IdOGyQ`O'#JtOIxQ!fO'#JtO+}QlO'#JtOJPQ`O,5:ROJgQ`O'#EpOJtQ`O'#KTOKPQ`O'#KSOKPQ`O'#KSOKXQ`O,5;^OK^Q`O'#KROOQ!0Ln,5:^,5:^OKeQlO,5:^OMcQ!0MxO,5:fONSQ`O,5:nONmQ!0LrO'#KQONtQ`O'#KPO9eQ`O'#KPO! YQ`O'#KPO! bQ`O,5;]O! gQ`O'#KPO!#lQ!fO'#JsOOQ!0Lh'#Ci'#CiO%[QlO'#ESO!$[Q!fO,5:sOOQS'#Jz'#JzOOQO-E<j-E<jO9kQ`O,5=_O!$rQ`O,5=_O!$wQlO,5;ZO!&zQMhO'#EkO!(eQ`O,5;ZO!(jQlO'#DyO!(tQpO,5;dO!(|QpO,5;dO%[QlO,5;dOOQ['#FT'#FTOOQ['#FV'#FVO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eOOQ['#FZ'#FZO!)[QlO,5;tOOQ!0Lf,5;y,5;yOOQ!0Lf,5;z,5;zOOQ!0Lf,5;|,5;|O%[QlO'#IpO!+_Q!0LrO,5<iO%[QlO,5;eO!&zQMhO,5;eO!+|QMhO,5;eO!-nQMhO'#E^O%[QlO,5;wOOQ!0Lf,5;{,5;{O!-uQ,UO'#FjO!.rQ,UO'#KXO!.^Q,UO'#KXO!.yQ,UO'#KXOOQO'#KX'#KXO!/_Q,UO,5<SOOOW,5<`,5<`O!/pQlO'#FvOOOW'#Io'#IoO7VO7dO,5<QO!/wQ,UO'#FxOOQ!0Lf,5<Q,5<QO!0hQ$IUO'#CyOOQ!0Lh'#C}'#C}O!0{O#@ItO'#DRO!1iQMjO,5<eO!1pQ`O,5<hO!3YQ(CWO'#GXO!3jQ`O'#GYO!3oQ`O'#GYO!5_Q(CWO'#G^O!6dQpO'#GbOOQO'#Gn'#GnO!,TQMhO'#GmOOQO'#Gp'#GpO!,TQMhO'#GoO!7VQ$IUO'#JlOOQ!0Lh'#Jl'#JlO!7aQ`O'#JkO!7oQ`O'#JjO!7wQ`O'#CuOOQ!0Lh'#C{'#C{O!8YQ`O'#C}OOQ!0Lh'#DV'#DVOOQ!0Lh'#DX'#DXO!8_Q`O,5<eO1SQ`O'#DZO!,TQMhO'#GPO!,TQMhO'#GRO!8gQ`O'#GTO!8lQ`O'#GUO!3oQ`O'#G[O!,TQMhO'#GaO<]Q`O'#JkO!8qQ`O'#EqO!9`Q`O,5<gOOQ!0Lb'#Cr'#CrO!9hQ`O'#ErO!:bQpO'#EsOOQ!0Lb'#KR'#KRO!:iQ!0LrO'#KaO9uQ!0LrO,5=cO`QlO,5>tOOQ['#Jh'#JhOOQ[,5>u,5>uOOQ[-E<]-E<]O!<hQ!0MxO,5:bO!:]QpO,5:`O!?RQ!0MxO,5:jO%[QlO,5:jO!AiQ!0MxO,5:lOOQO,5@z,5@zO!BYQMhO,5=_O!BhQ!0LrO'#JiO9`Q`O'#JiO!ByQ!0LrO,59ZO!CUQpO,59ZO!C^QMhO,59ZO:dQMhO,59ZO!CiQ`O,5;ZO!CqQ`O'#HbO!DVQ`O'#KdO%[QlO,5;}O!:]QpO,5<PO!D_Q`O,5=zO!DdQ`O,5=zO!DiQ`O,5=zO!DwQ`O,5=zO9uQ!0LrO,5=zO<]Q`O,5=jOOQO'#Cy'#CyO!EOQpO,5=gO!EWQMhO,5=hO!EcQ`O,5=jO!EhQ!bO,5=mO!EpQ`O'#K`O?YQ`O'#HWO9kQ`O'#HYO!EuQ`O'#HYO:dQMhO'#H[O!EzQ`O'#H[OOQ[,5=p,5=pO!FPQ`O'#H]O!FbQ`O'#CoO!FgQ`O,59PO!FqQ`O,59PO!HvQlO,59POOQ[,59P,59PO!IWQ!0LrO,59PO%[QlO,59PO!KcQlO'#HeOOQ['#Hf'#HfOOQ['#Hg'#HgO`QlO,5=}O!KyQ`O,5=}O`QlO,5>TO`QlO,5>VO!LOQ`O,5>XO`QlO,5>ZO!LTQ`O,5>^O!LYQlO,5>dOOQ[,5>j,5>jO%[QlO,5>jO9uQ!0LrO,5>lOOQ[,5>n,5>nO#!dQ`O,5>nOOQ[,5>p,5>pO#!dQ`O,5>pOOQ[,5>r,5>rO##QQpO'#D_O%[QlO'#JvO##sQpO'#JvO##}QpO'#DmO#$`QpO'#DmO#&qQlO'#DmO#&xQ`O'#JuO#'QQ`O,5:WO#'VQ`O'#EtO#'eQ`O'#KUO#'mQ`O,5;_O#'rQpO'#DmO#(PQpO'#EVOOQ!0Lf,5:o,5:oO%[QlO,5:oO#(WQ`O,5:oO?YQ`O,5;YO!CUQpO,5;YO!C^QMhO,5;YO:dQMhO,5;YO#(`Q`O,5@bO#(eQ07dO,5:sOOQO-E<f-E<fO#)kQ!0MSO,5;RODWQpO,5:rO#)uQpO,5:rODWQpO,5;RO!ByQ!0LrO,5:rOOQ!0Lb'#Ej'#EjOOQO,5;R,5;RO%[QlO,5;RO#*SQ!0LrO,5;RO#*_Q!0LrO,5;RO!CUQpO,5:rOOQO,5;X,5;XO#*mQ!0LrO,5;RPOOO'#I^'#I^P#+RO&2DjO,58|POOO,58|,58|OOOO-E<^-E<^OOQ!0Lh1G.p1G.pOOOO-E<_-E<_OOOO,59},59}O#+^Q!bO,59}OOOO-E<a-E<aOOQ!0Lf1G/g1G/gO#+cQ!fO,5?OO+}QlO,5?OOOQO,5?U,5?UO#+mQlO'#IdOOQO-E<b-E<bO#+zQ`O,5@`O#,SQ!fO,5@`O#,ZQ`O,5@nOOQ!0Lf1G/m1G/mO%[QlO,5@oO#,cQ`O'#IjOOQO-E<h-E<hO#,ZQ`O,5@nOOQ!0Lb1G0x1G0xOOQ!0Ln1G/x1G/xOOQ!0Ln1G0Y1G0YO%[QlO,5@lO#,wQ!0LrO,5@lO#-YQ!0LrO,5@lO#-aQ`O,5@kO9eQ`O,5@kO#-iQ`O,5@kO#-wQ`O'#ImO#-aQ`O,5@kOOQ!0Lb1G0w1G0wO!(tQpO,5:uO!)PQpO,5:uOOQS,5:w,5:wO#.iQdO,5:wO#.qQMhO1G2yO9kQ`O1G2yOOQ!0Lf1G0u1G0uO#/PQ!0MxO1G0uO#0UQ!0MvO,5;VOOQ!0Lh'#GW'#GWO#0rQ!0MzO'#JlO!$wQlO1G0uO#2}Q!fO'#JwO%[QlO'#JwO#3XQ`O,5:eOOQ!0Lh'#D_'#D_OOQ!0Lf1G1O1G1OO%[QlO1G1OOOQ!0Lf1G1f1G1fO#3^Q`O1G1OO#5rQ!0MxO1G1PO#5yQ!0MxO1G1PO#8aQ!0MxO1G1PO#8hQ!0MxO1G1PO#;OQ!0MxO1G1PO#=fQ!0MxO1G1PO#=mQ!0MxO1G1PO#=tQ!0MxO1G1PO#@[Q!0MxO1G1PO#@cQ!0MxO1G1PO#BpQ?MtO'#CiO#DkQ?MtO1G1`O#DrQ?MtO'#JsO#EVQ!0MxO,5?[OOQ!0Lb-E<n-E<nO#GdQ!0MxO1G1PO#HaQ!0MzO1G1POOQ!0Lf1G1P1G1PO#IdQMjO'#J|O#InQ`O,5:xO#IsQ!0MxO1G1cO#JgQ,UO,5<WO#JoQ,UO,5<XO#JwQ,UO'#FoO#K`Q`O'#FnOOQO'#KY'#KYOOQO'#In'#InO#KeQ,UO1G1nOOQ!0Lf1G1n1G1nOOOW1G1y1G1yO#KvQ?MtO'#JrO#LQQ`O,5<bO!)[QlO,5<bOOOW-E<m-E<mOOQ!0Lf1G1l1G1lO#LVQpO'#KXOOQ!0Lf,5<d,5<dO#L_QpO,5<dO#LdQMhO'#DTOOOO'#Ib'#IbO#LkO#@ItO,59mOOQ!0Lh,59m,59mO%[QlO1G2PO!8lQ`O'#IrO#LvQ`O,5<zOOQ!0Lh,5<w,5<wO!,TQMhO'#IuO#MdQMjO,5=XO!,TQMhO'#IwO#NVQMjO,5=ZO!&zQMhO,5=]OOQO1G2S1G2SO#NaQ!dO'#CrO#NtQ(CWO'#ErO$ |QpO'#GbO$!dQ!dO,5<sO$!kQ`O'#K[O9eQ`O'#K[O$!yQ`O,5<uO$#aQ!dO'#C{O!,TQMhO,5<tO$#kQ`O'#GZO$$PQ`O,5<tO$$UQ!dO'#GWO$$cQ!dO'#K]O$$mQ`O'#K]O!&zQMhO'#K]O$$rQ`O,5<xO$$wQlO'#JvO$%RQpO'#GcO#$`QpO'#GcO$%dQ`O'#GgO!3oQ`O'#GkO$%iQ!0LrO'#ItO$%tQpO,5<|OOQ!0Lp,5<|,5<|O$%{QpO'#GcO$&YQpO'#GdO$&kQpO'#GdO$&pQMjO,5=XO$'QQMjO,5=ZOOQ!0Lh,5=^,5=^O!,TQMhO,5@VO!,TQMhO,5@VO$'bQ`O'#IyO$'vQ`O,5@UO$(OQ`O,59aOOQ!0Lh,59i,59iO$(TQ`O,5@VO$)TQ$IYO,59uOOQ!0Lh'#Jp'#JpO$)vQMjO,5<kO$*iQMjO,5<mO@zQ`O,5<oOOQ!0Lh,5<p,5<pO$*sQ`O,5<vO$*xQMjO,5<{O$+YQ`O'#KPO!$wQlO1G2RO$+_Q`O1G2RO9eQ`O'#KSO9eQ`O'#EtO%[QlO'#EtO9eQ`O'#I{O$+dQ!0LrO,5@{OOQ[1G2}1G2}OOQ[1G4`1G4`OOQ!0Lf1G/|1G/|OOQ!0Lf1G/z1G/zO$-fQ!0MxO1G0UOOQ[1G2y1G2yO!&zQMhO1G2yO%[QlO1G2yO#.tQ`O1G2yO$/jQMhO'#EkOOQ!0Lb,5@T,5@TO$/wQ!0LrO,5@TOOQ[1G.u1G.uO!ByQ!0LrO1G.uO!CUQpO1G.uO!C^QMhO1G.uO$0YQ`O1G0uO$0_Q`O'#CiO$0jQ`O'#KeO$0rQ`O,5=|O$0wQ`O'#KeO$0|Q`O'#KeO$1[Q`O'#JRO$1jQ`O,5AOO$1rQ!fO1G1iOOQ!0Lf1G1k1G1kO9kQ`O1G3fO@zQ`O1G3fO$1yQ`O1G3fO$2OQ`O1G3fO!DiQ`O1G3fO9uQ!0LrO1G3fOOQ[1G3f1G3fO!EcQ`O1G3UO!&zQMhO1G3RO$2TQ`O1G3ROOQ[1G3S1G3SO!&zQMhO1G3SO$2YQ`O1G3SO$2bQpO'#HQOOQ[1G3U1G3UO!6_QpO'#I}O!EhQ!bO1G3XOOQ[1G3X1G3XOOQ[,5=r,5=rO$2jQMhO,5=tO9kQ`O,5=tO$%dQ`O,5=vO9`Q`O,5=vO!CUQpO,5=vO!C^QMhO,5=vO:dQMhO,5=vO$2xQ`O'#KcO$3TQ`O,5=wOOQ[1G.k1G.kO$3YQ!0LrO1G.kO@zQ`O1G.kO$3eQ`O1G.kO9uQ!0LrO1G.kO$5mQ!fO,5AQO$5zQ`O,5AQO9eQ`O,5AQO$6VQlO,5>PO$6^Q`O,5>POOQ[1G3i1G3iO`QlO1G3iOOQ[1G3o1G3oOOQ[1G3q1G3qO?TQ`O1G3sO$6cQlO1G3uO$:gQlO'#HtOOQ[1G3x1G3xO$:tQ`O'#HzO?YQ`O'#H|OOQ[1G4O1G4OO$:|QlO1G4OO9uQ!0LrO1G4UOOQ[1G4W1G4WOOQ!0Lb'#G_'#G_O9uQ!0LrO1G4YO9uQ!0LrO1G4[O$?TQ`O,5@bO!)[QlO,5;`O9eQ`O,5;`O?YQ`O,5:XO!)[QlO,5:XO!CUQpO,5:XO$?YQ?MtO,5:XOOQO,5;`,5;`O$?dQpO'#IeO$?zQ`O,5@aOOQ!0Lf1G/r1G/rO$@SQpO'#IkO$@^Q`O,5@pOOQ!0Lb1G0y1G0yO#$`QpO,5:XOOQO'#Ig'#IgO$@fQpO,5:qOOQ!0Ln,5:q,5:qO#(ZQ`O1G0ZOOQ!0Lf1G0Z1G0ZO%[QlO1G0ZOOQ!0Lf1G0t1G0tO?YQ`O1G0tO!CUQpO1G0tO!C^QMhO1G0tOOQ!0Lb1G5|1G5|O!ByQ!0LrO1G0^OOQO1G0m1G0mO%[QlO1G0mO$@mQ!0LrO1G0mO$@xQ!0LrO1G0mO!CUQpO1G0^ODWQpO1G0^O$AWQ!0LrO1G0mOOQO1G0^1G0^O$AlQ!0MxO1G0mPOOO-E<[-E<[POOO1G.h1G.hOOOO1G/i1G/iO$AvQ!bO,5<iO$BOQ!fO1G4jOOQO1G4p1G4pO%[QlO,5?OO$BYQ`O1G5zO$BbQ`O1G6YO$BjQ!fO1G6ZO9eQ`O,5?UO$BtQ!0MxO1G6WO%[QlO1G6WO$CUQ!0LrO1G6WO$CgQ`O1G6VO$CgQ`O1G6VO9eQ`O1G6VO$CoQ`O,5?XO9eQ`O,5?XOOQO,5?X,5?XO$DTQ`O,5?XO$+YQ`O,5?XOOQO-E<k-E<kOOQS1G0a1G0aOOQS1G0c1G0cO#.lQ`O1G0cOOQ[7+(e7+(eO!&zQMhO7+(eO%[QlO7+(eO$DcQ`O7+(eO$DnQMhO7+(eO$D|Q!0MzO,5=XO$GXQ!0MzO,5=ZO$IdQ!0MzO,5=XO$KuQ!0MzO,5=ZO$NWQ!0MzO,59uO%!]Q!0MzO,5<kO%$hQ!0MzO,5<mO%&sQ!0MzO,5<{OOQ!0Lf7+&a7+&aO%)UQ!0MxO7+&aO%)xQlO'#IfO%*VQ`O,5@cO%*_Q!fO,5@cOOQ!0Lf1G0P1G0PO%*iQ`O7+&jOOQ!0Lf7+&j7+&jO%*nQ?MtO,5:fO%[QlO7+&zO%*xQ?MtO,5:bO%+VQ?MtO,5:jO%+aQ?MtO,5:lO%+kQMhO'#IiO%+uQ`O,5@hOOQ!0Lh1G0d1G0dOOQO1G1r1G1rOOQO1G1s1G1sO%+}Q!jO,5<ZO!)[QlO,5<YOOQO-E<l-E<lOOQ!0Lf7+'Y7+'YOOOW7+'e7+'eOOOW1G1|1G1|O%,YQ`O1G1|OOQ!0Lf1G2O1G2OOOOO,59o,59oO%,_Q!dO,59oOOOO-E<`-E<`OOQ!0Lh1G/X1G/XO%,fQ!0MxO7+'kOOQ!0Lh,5?^,5?^O%-YQMhO1G2fP%-aQ`O'#IrPOQ!0Lh-E<p-E<pO%-}QMjO,5?aOOQ!0Lh-E<s-E<sO%.pQMjO,5?cOOQ!0Lh-E<u-E<uO%.zQ!dO1G2wO%/RQ!dO'#CrO%/iQMhO'#KSO$$wQlO'#JvOOQ!0Lh1G2_1G2_O%/sQ`O'#IqO%0[Q`O,5@vO%0[Q`O,5@vO%0dQ`O,5@vO%0oQ`O,5@vOOQO1G2a1G2aO%0}QMjO1G2`O$+YQ`O'#K[O!,TQMhO1G2`O%1_Q(CWO'#IsO%1lQ`O,5@wO!&zQMhO,5@wO%1tQ!dO,5@wOOQ!0Lh1G2d1G2dO%4UQ!fO'#CiO%4`Q`O,5=POOQ!0Lb,5<},5<}O%4hQpO,5<}OOQ!0Lb,5=O,5=OOCwQ`O,5<}O%4sQpO,5<}OOQ!0Lb,5=R,5=RO$+YQ`O,5=VOOQO,5?`,5?`OOQO-E<r-E<rOOQ!0Lp1G2h1G2hO#$`QpO,5<}O$$wQlO,5=PO%5RQ`O,5=OO%5^QpO,5=OO!,TQMhO'#IuO%6WQMjO1G2sO!,TQMhO'#IwO%6yQMjO1G2uO%7TQMjO1G5qO%7_QMjO1G5qOOQO,5?e,5?eOOQO-E<w-E<wOOQO1G.{1G.{O!,TQMhO1G5qO!,TQMhO1G5qO!:]QpO,59wO%[QlO,59wOOQ!0Lh,5<j,5<jO%7lQ`O1G2ZO!,TQMhO1G2bO%7qQ!0MxO7+'mOOQ!0Lf7+'m7+'mO!$wQlO7+'mO%8eQ`O,5;`OOQ!0Lb,5?g,5?gOOQ!0Lb-E<y-E<yO%8jQ!dO'#K^O#(ZQ`O7+(eO4UQ!fO7+(eO$DfQ`O7+(eO%8tQ!0MvO'#CiO%9XQ!0MvO,5=SO%9lQ`O,5=SO%9tQ`O,5=SOOQ!0Lb1G5o1G5oOOQ[7+$a7+$aO!ByQ!0LrO7+$aO!CUQpO7+$aO!$wQlO7+&aO%9yQ`O'#JQO%:bQ`O,5APOOQO1G3h1G3hO9kQ`O,5APO%:bQ`O,5APO%:jQ`O,5APOOQO,5?m,5?mOOQO-E=P-E=POOQ!0Lf7+'T7+'TO%:oQ`O7+)QO9uQ!0LrO7+)QO9kQ`O7+)QO@zQ`O7+)QO%:tQ`O7+)QOOQ[7+)Q7+)QOOQ[7+(p7+(pO%:yQ!0MvO7+(mO!&zQMhO7+(mO!E^Q`O7+(nOOQ[7+(n7+(nO!&zQMhO7+(nO%;TQ`O'#KbO%;`Q`O,5=lOOQO,5?i,5?iOOQO-E<{-E<{OOQ[7+(s7+(sO%<rQpO'#HZOOQ[1G3`1G3`O!&zQMhO1G3`O%[QlO1G3`O%<yQ`O1G3`O%=UQMhO1G3`O9uQ!0LrO1G3bO$%dQ`O1G3bO9`Q`O1G3bO!CUQpO1G3bO!C^QMhO1G3bO%=dQ`O'#JPO%=xQ`O,5@}O%>QQpO,5@}OOQ!0Lb1G3c1G3cOOQ[7+$V7+$VO@zQ`O7+$VO9uQ!0LrO7+$VO%>]Q`O7+$VO%[QlO1G6lO%[QlO1G6mO%>bQ!0LrO1G6lO%>lQlO1G3kO%>sQ`O1G3kO%>xQlO1G3kOOQ[7+)T7+)TO9uQ!0LrO7+)_O`QlO7+)aOOQ['#Kh'#KhOOQ['#JS'#JSO%?PQlO,5>`OOQ[,5>`,5>`O%[QlO'#HuO%?^Q`O'#HwOOQ[,5>f,5>fO9eQ`O,5>fOOQ[,5>h,5>hOOQ[7+)j7+)jOOQ[7+)p7+)pOOQ[7+)t7+)tOOQ[7+)v7+)vO%?cQpO1G5|O%?}Q?MtO1G0zO%@XQ`O1G0zOOQO1G/s1G/sO%@dQ?MtO1G/sO?YQ`O1G/sO!)[QlO'#DmOOQO,5?P,5?POOQO-E<c-E<cOOQO,5?V,5?VOOQO-E<i-E<iO!CUQpO1G/sOOQO-E<e-E<eOOQ!0Ln1G0]1G0]OOQ!0Lf7+%u7+%uO#(ZQ`O7+%uOOQ!0Lf7+&`7+&`O?YQ`O7+&`O!CUQpO7+&`OOQO7+%x7+%xO$AlQ!0MxO7+&XOOQO7+&X7+&XO%[QlO7+&XO%@nQ!0LrO7+&XO!ByQ!0LrO7+%xO!CUQpO7+%xO%@yQ!0LrO7+&XO%AXQ!0MxO7++rO%[QlO7++rO%AiQ`O7++qO%AiQ`O7++qOOQO1G4s1G4sO9eQ`O1G4sO%AqQ`O1G4sOOQS7+%}7+%}O#(ZQ`O<<LPO4UQ!fO<<LPO%BPQ`O<<LPOOQ[<<LP<<LPO!&zQMhO<<LPO%[QlO<<LPO%BXQ`O<<LPO%BdQ!0MzO,5?aO%DoQ!0MzO,5?cO%FzQ!0MzO1G2`O%I]Q!0MzO1G2sO%KhQ!0MzO1G2uO%MsQ!fO,5?QO%[QlO,5?QOOQO-E<d-E<dO%M}Q`O1G5}OOQ!0Lf<<JU<<JUO%NVQ?MtO1G0uO&!^Q?MtO1G1PO&!eQ?MtO1G1PO&$fQ?MtO1G1PO&$mQ?MtO1G1PO&&nQ?MtO1G1PO&(oQ?MtO1G1PO&(vQ?MtO1G1PO&(}Q?MtO1G1PO&+OQ?MtO1G1PO&+VQ?MtO1G1PO&+^Q!0MxO<<JfO&-UQ?MtO1G1PO&.RQ?MvO1G1PO&/UQ?MvO'#JlO&1[Q?MtO1G1cO&1iQ?MtO1G0UO&1sQMjO,5?TOOQO-E<g-E<gO!)[QlO'#FqOOQO'#KZ'#KZOOQO1G1u1G1uO&1}Q`O1G1tO&2SQ?MtO,5?[OOOW7+'h7+'hOOOO1G/Z1G/ZO&2^Q!dO1G4xOOQ!0Lh7+(Q7+(QP!&zQMhO,5?^O!,TQMhO7+(cO&2eQ`O,5?]O9eQ`O,5?]O$+YQ`O,5?]OOQO-E<o-E<oO&2sQ`O1G6bO&2sQ`O1G6bO&2{Q`O1G6bO&3WQMjO7+'zO&3hQ!dO,5?_O&3rQ`O,5?_O!&zQMhO,5?_OOQO-E<q-E<qO&3wQ!dO1G6cO&4RQ`O1G6cO&4ZQ`O1G2kO!&zQMhO1G2kOOQ!0Lb1G2i1G2iOOQ!0Lb1G2j1G2jO%4hQpO1G2iO!CUQpO1G2iOCwQ`O1G2iOOQ!0Lb1G2q1G2qO&4`QpO1G2iO&4nQ`O1G2kO$+YQ`O1G2jOCwQ`O1G2jO$$wQlO1G2kO&4vQ`O1G2jO&5jQMjO,5?aOOQ!0Lh-E<t-E<tO&6]QMjO,5?cOOQ!0Lh-E<v-E<vO!,TQMhO7++]O&6gQMjO7++]O&6qQMjO7++]OOQ!0Lh1G/c1G/cO&7OQ`O1G/cOOQ!0Lh7+'u7+'uO&7TQMjO7+'|O&7eQ!0MxO<<KXOOQ!0Lf<<KX<<KXO&8XQ`O1G0zO!&zQMhO'#IzO&8^Q`O,5@xO&:`Q!fO<<LPO!&zQMhO1G2nO&:gQ!0LrO1G2nOOQ[<<G{<<G{O!ByQ!0LrO<<G{O&:xQ!0MxO<<I{OOQ!0Lf<<I{<<I{OOQO,5?l,5?lO&;lQ`O,5?lO&;qQ`O,5?lOOQO-E=O-E=OO&<PQ`O1G6kO&<PQ`O1G6kO9kQ`O1G6kO@zQ`O<<LlOOQ[<<Ll<<LlO&<XQ`O<<LlO9uQ!0LrO<<LlO9kQ`O<<LlOOQ[<<LX<<LXO%:yQ!0MvO<<LXOOQ[<<LY<<LYO!E^Q`O<<LYO&<^QpO'#I|O&<iQ`O,5@|O!)[QlO,5@|OOQ[1G3W1G3WOOQO'#JO'#JOO9uQ!0LrO'#JOO&<qQpO,5=uOOQ[,5=u,5=uO&<xQpO'#EgO&=PQpO'#GeO&=UQ`O7+(zO&=ZQ`O7+(zOOQ[7+(z7+(zO!&zQMhO7+(zO%[QlO7+(zO&=cQ`O7+(zOOQ[7+(|7+(|O9uQ!0LrO7+(|O$%dQ`O7+(|O9`Q`O7+(|O!CUQpO7+(|O&=nQ`O,5?kOOQO-E<}-E<}OOQO'#H^'#H^O&=yQ`O1G6iO9uQ!0LrO<<GqOOQ[<<Gq<<GqO@zQ`O<<GqO&>RQ`O7+,WO&>WQ`O7+,XO%[QlO7+,WO%[QlO7+,XOOQ[7+)V7+)VO&>]Q`O7+)VO&>bQlO7+)VO&>iQ`O7+)VOOQ[<<Ly<<LyOOQ[<<L{<<L{OOQ[-E=Q-E=QOOQ[1G3z1G3zO&>nQ`O,5>aOOQ[,5>c,5>cO&>sQ`O1G4QO9eQ`O7+&fO!)[QlO7+&fOOQO7+%_7+%_O&>xQ?MtO1G6ZO?YQ`O7+%_OOQ!0Lf<<Ia<<IaOOQ!0Lf<<Iz<<IzO?YQ`O<<IzOOQO<<Is<<IsO$AlQ!0MxO<<IsO%[QlO<<IsOOQO<<Id<<IdO!ByQ!0LrO<<IdO&?SQ!0LrO<<IsO&?_Q!0MxO<= ^O&?oQ`O<= ]OOQO7+*_7+*_O9eQ`O7+*_OOQ[ANAkANAkO&?wQ!fOANAkO!&zQMhOANAkO#(ZQ`OANAkO4UQ!fOANAkO&@OQ`OANAkO%[QlOANAkO&@WQ!0MzO7+'zO&BiQ!0MzO,5?aO&DtQ!0MzO,5?cO&GPQ!0MzO7+'|O&IbQ!fO1G4lO&IlQ?MtO7+&aO&KpQ?MvO,5=XO&MwQ?MvO,5=ZO&NXQ?MvO,5=XO&NiQ?MvO,5=ZO&NyQ?MvO,59uO'#PQ?MvO,5<kO'%SQ?MvO,5<mO''hQ?MvO,5<{O')^Q?MtO7+'kO')kQ?MtO7+'mO')xQ`O,5<]OOQO7+'`7+'`OOQ!0Lh7+*d7+*dO')}QMjO<<K}OOQO1G4w1G4wO'*UQ`O1G4wO'*aQ`O1G4wO'*oQ`O7++|O'*oQ`O7++|O!&zQMhO1G4yO'*wQ!dO1G4yO'+RQ`O7++}O'+ZQ`O7+(VO'+fQ!dO7+(VOOQ!0Lb7+(T7+(TOOQ!0Lb7+(U7+(UO!CUQpO7+(TOCwQ`O7+(TO'+pQ`O7+(VO!&zQMhO7+(VO$+YQ`O7+(UO'+uQ`O7+(VOCwQ`O7+(UO'+}QMjO<<NwO!,TQMhO<<NwOOQ!0Lh7+$}7+$}O',XQ!dO,5?fOOQO-E<x-E<xO',cQ!0MvO7+(YO!&zQMhO7+(YOOQ[AN=gAN=gO9kQ`O1G5WOOQO1G5W1G5WO',sQ`O1G5WO',xQ`O7+,VO',xQ`O7+,VO9uQ!0LrOANBWO@zQ`OANBWOOQ[ANBWANBWO'-QQ`OANBWOOQ[ANAsANAsOOQ[ANAtANAtO'-VQ`O,5?hOOQO-E<z-E<zO'-bQ?MtO1G6hOOQO,5?j,5?jOOQO-E<|-E<|OOQ[1G3a1G3aO'-lQ`O,5=POOQ[<<Lf<<LfO!&zQMhO<<LfO&=UQ`O<<LfO'-qQ`O<<LfO%[QlO<<LfOOQ[<<Lh<<LhO9uQ!0LrO<<LhO$%dQ`O<<LhO9`Q`O<<LhO'-yQpO1G5VO'.UQ`O7+,TOOQ[AN=]AN=]O9uQ!0LrOAN=]OOQ[<= r<= rOOQ[<= s<= sO'.^Q`O<= rO'.cQ`O<= sOOQ[<<Lq<<LqO'.hQ`O<<LqO'.mQlO<<LqOOQ[1G3{1G3{O?YQ`O7+)lO'.tQ`O<<JQO'/PQ?MtO<<JQOOQO<<Hy<<HyOOQ!0LfAN?fAN?fOOQOAN?_AN?_O$AlQ!0MxOAN?_OOQOAN?OAN?OO%[QlOAN?_OOQO<<My<<MyOOQ[G27VG27VO!&zQMhOG27VO#(ZQ`OG27VO'/ZQ!fOG27VO4UQ!fOG27VO'/bQ`OG27VO'/jQ?MtO<<JfO'/wQ?MvO1G2`O'1mQ?MvO,5?aO'3pQ?MvO,5?cO'5sQ?MvO1G2sO'7vQ?MvO1G2uO'9yQ?MtO<<KXO':WQ?MtO<<I{OOQO1G1w1G1wO!,TQMhOANAiOOQO7+*c7+*cO':eQ`O7+*cO':pQ`O<= hO':xQ!dO7+*eOOQ!0Lb<<Kq<<KqO$+YQ`O<<KqOCwQ`O<<KqO';SQ`O<<KqO!&zQMhO<<KqOOQ!0Lb<<Ko<<KoO!CUQpO<<KoO';_Q!dO<<KqOOQ!0Lb<<Kp<<KpO';iQ`O<<KqO!&zQMhO<<KqO$+YQ`O<<KpO';nQMjOANDcO';xQ!0MvO<<KtOOQO7+*r7+*rO9kQ`O7+*rO'<YQ`O<= qOOQ[G27rG27rO9uQ!0LrOG27rO@zQ`OG27rO!)[QlO1G5SO'<bQ`O7+,SO'<jQ`O1G2kO&=UQ`OANBQOOQ[ANBQANBQO!&zQMhOANBQO'<oQ`OANBQOOQ[ANBSANBSO9uQ!0LrOANBSO$%dQ`OANBSOOQO'#H_'#H_OOQO7+*q7+*qOOQ[G22wG22wOOQ[ANE^ANE^OOQ[ANE_ANE_OOQ[ANB]ANB]O'<wQ`OANB]OOQ[<<MW<<MWO!)[QlOAN?lOOQOG24yG24yO$AlQ!0MxOG24yO#(ZQ`OLD,qOOQ[LD,qLD,qO!&zQMhOLD,qO'<|Q!fOLD,qO'=TQ?MvO7+'zO'>yQ?MvO,5?aO'@|Q?MvO,5?cO'CPQ?MvO7+'|O'DuQMjOG27TOOQO<<M}<<M}OOQ!0LbANA]ANA]O$+YQ`OANA]OCwQ`OANA]O'EVQ!dOANA]OOQ!0LbANAZANAZO'E^Q`OANA]O!&zQMhOANA]O'EiQ!dOANA]OOQ!0LbANA[ANA[OOQO<<N^<<N^OOQ[LD-^LD-^O9uQ!0LrOLD-^O'EsQ?MtO7+*nOOQO'#Gf'#GfOOQ[G27lG27lO&=UQ`OG27lO!&zQMhOG27lOOQ[G27nG27nO9uQ!0LrOG27nOOQ[G27wG27wO'E}Q?MtOG25WOOQOLD*eLD*eOOQ[!$(!]!$(!]O#(ZQ`O!$(!]O!&zQMhO!$(!]O'FXQ!0MzOG27TOOQ!0LbG26wG26wO$+YQ`OG26wO'HjQ`OG26wOCwQ`OG26wO'HuQ!dOG26wO!&zQMhOG26wOOQ[!$(!x!$(!xOOQ[LD-WLD-WO&=UQ`OLD-WOOQ[LD-YLD-YOOQ[!)9Ew!)9EwO#(ZQ`O!)9EwOOQ!0LbLD,cLD,cO$+YQ`OLD,cOCwQ`OLD,cO'H|Q`OLD,cO'IXQ!dOLD,cOOQ[!$(!r!$(!rOOQ[!.K;c!.K;cO'I`Q?MvOG27TOOQ!0Lb!$( }!$( }O$+YQ`O!$( }OCwQ`O!$( }O'KUQ`O!$( }OOQ!0Lb!)9Ei!)9EiO$+YQ`O!)9EiOCwQ`O!)9EiOOQ!0Lb!.K;T!.K;TO$+YQ`O!.K;TOOQ!0Lb!4/0o!4/0oO!)[QlO'#DzO1PQ`O'#EXO'KaQ!fO'#JrO'KhQ!L^O'#DvO'KoQlO'#EOO'KvQ!fO'#CiO'N^Q!fO'#CiO!)[QlO'#EQO'NnQlO,5;ZO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO'#IpO(!qQ`O,5<iO!)[QlO,5;eO(!yQMhO,5;eO($dQMhO,5;eO!)[QlO,5;wO!&zQMhO'#GmO(!yQMhO'#GmO!&zQMhO'#GoO(!yQMhO'#GoO1SQ`O'#DZO1SQ`O'#DZO!&zQMhO'#GPO(!yQMhO'#GPO!&zQMhO'#GRO(!yQMhO'#GRO!&zQMhO'#GaO(!yQMhO'#GaO!)[QlO,5:jO($kQpO'#D_O($uQpO'#JvO!)[QlO,5@oO'NnQlO1G0uO(%PQ?MtO'#CiO!)[QlO1G2PO!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO(%ZQ!dO'#CrO!&zQMhO,5<tO(!yQMhO,5<tO'NnQlO1G2RO!)[QlO7+&zO!&zQMhO1G2`O(!yQMhO1G2`O!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO!&zQMhO1G2bO(!yQMhO1G2bO'NnQlO7+'mO'NnQlO7+&aO!&zQMhOANAiO(!yQMhOANAiO(%nQ`O'#EoO(%sQ`O'#EoO(%{Q`O'#F]O(&QQ`O'#EyO(&VQ`O'#KTO(&bQ`O'#KRO(&mQ`O,5;ZO(&rQMjO,5<eO(&yQ`O'#GYO('OQ`O'#GYO('TQ`O,5<eO(']Q`O,5<gO('eQ`O,5;ZO('mQ?MtO1G1`O('tQ`O,5<tO('yQ`O,5<tO((OQ`O,5<vO((TQ`O,5<vO((YQ`O1G2RO((_Q`O1G0uO((dQMjO<<K}O((kQMjO<<K}O((rQMhO'#F|O9`Q`O'#F{OAuQ`O'#EnO!)[QlO,5;tO!3oQ`O'#GYO!3oQ`O'#GYO!3oQ`O'#G[O!3oQ`O'#G[O!,TQMhO7+(cO!,TQMhO7+(cO%.zQ!dO1G2wO%.zQ!dO1G2wO!&zQMhO,5=]O!&zQMhO,5=]",
  stateData: "()x~O'|OS'}OSTOS(ORQ~OPYOQYOSfOY!VOaqOdzOeyOl!POpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O$W|O$niO%h}O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO&W!WO&^!XO&`!YO&b!ZO&d![O&g!]O&m!^O&s!_O&u!`O&w!aO&y!bO&{!cO(TSO(VTO(YUO(aVO(o[O~OWtO~P`OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa!wOs!nO!S!oO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!xO#W!pO#X!pO#[!zO#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O(O!{O~OP]XR]X[]Xa]Xj]Xr]X!Q]X!S]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X'z]X(a]X(r]X(y]X(z]X~O!g%RX~P(qO_!}O(V#PO(W!}O(X#PO~O_#QO(X#PO(Y#PO(Z#QO~Ox#SO!U#TO(b#TO(c#VO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T<ZO(VTO(YUO(aVO(o[O~O![#ZO!]#WO!Y(hP!Y(vP~P+}O!^#cO~P`OPYOQYOSfOd!jOe!iOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(VTO(YUO(aVO(o[O~Op#mO![#iO!|]O#i#lO#j#iO(T<[O!k(sP~P.iO!l#oO(T#nO~O!x#sO!|]O%h#tO~O#k#uO~O!g#vO#k#uO~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!]$_O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa(fX'z(fX'w(fX!k(fX!Y(fX!_(fX%i(fX!g(fX~P1qO#S$dO#`$eO$Q$eOP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX!_(gX%i(gX~Oa(gX'z(gX'w(gX!Y(gX!k(gXv(gX!g(gX~P4UO#`$eO~O$]$hO$_$gO$f$mO~OSfO!_$nO$i$oO$k$qO~Oh%VOj%dOk%dOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T$sO(VTO(YUO(a$uO(y$}O(z%POg(^P~Ol%[O~P7eO!l%eO~O!S%hO!_%iO(T%gO~O!g%mO~Oa%nO'z%nO~O!Q%rO~P%[O(U!lO~P%[O%n%vO~P%[Oh%VO!l%eO(T%gO(U!lO~Oe%}O!l%eO(T%gO~Oj$RO~O!_&PO(T%gO(U!lO(VTO(YUO`)WP~O!Q&SO!l&RO%j&VO&T&WO~P;SO!x#sO~O%s&YO!S)SX!_)SX(T)SX~O(T&ZO~Ol!PO!u&`O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO~Od&eOe&dO!x&bO%h&cO%{&aO~P<bOd&hOeyOl!PO!_&gO!u&`O!xxO!|]O%h}O%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO~Ob&kO#`&nO%j&iO(U!lO~P=gO!l&oO!u&sO~O!l#oO~O!_XO~Oa%nO'x&{O'z%nO~Oa%nO'x'OO'z%nO~Oa%nO'x'QO'z%nO~O'w]X!Y]Xv]X!k]X&[]X!_]X%i]X!g]X~P(qO!b'_O!c'WO!d'WO(U!lO(VTO(YUO~Os'UO!S'TO!['XO(e'SO!^(iP!^(xP~P@nOn'bO!_'`O(T%gO~Oe'gO!l%eO(T%gO~O!Q&SO!l&RO~Os!nO!S!oO!|<VO#T!pO#U!pO#W!pO#X!pO(U!lO(VTO(YUO(e!mO(o!sO~O!b'mO!c'lO!d'lO#V!pO#['nO#]'nO~PBYOa%nOh%VO!g#vO!l%eO'z%nO(r'pO~O!p'tO#`'rO~PChOs!nO!S!oO(VTO(YUO(e!mO(o!sO~O!_XOs(mX!S(mX!b(mX!c(mX!d(mX!|(mX#T(mX#U(mX#V(mX#W(mX#X(mX#[(mX#](mX(U(mX(V(mX(Y(mX(e(mX(o(mX~O!c'lO!d'lO(U!lO~PDWO(P'xO(Q'xO(R'zO~O_!}O(V'|O(W!}O(X'|O~O_#QO(X'|O(Y'|O(Z#QO~Ov(OO~P%[Ox#SO!U#TO(b#TO(c(RO~O![(TO!Y'WX!Y'^X!]'WX!]'^X~P+}O!](VO!Y(hX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!](VO!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~O!Y(hX~PHRO!Y([O~O!Y(uX!](uX!g(uX!k(uX(r(uX~O#`(uX#k#dX!^(uX~PJUO#`(]O!Y(wX!](wX~O!](^O!Y(vX~O!Y(aO~O#`$eO~PJUO!^(bO~P`OR#zO!Q#yO!S#{O!l#xO(aVOP!na[!naj!nar!na!]!na!p!na#R!na#n!na#o!na#p!na#q!na#r!na#s!na#t!na#u!na#v!na#x!na#z!na#{!na(r!na(y!na(z!na~Oa!na'z!na'w!na!Y!na!k!nav!na!_!na%i!na!g!na~PKlO!k(cO~O!g#vO#`(dO(r'pO!](tXa(tX'z(tX~O!k(tX~PNXO!S%hO!_%iO!|]O#i(iO#j(hO(T%gO~O!](jO!k(sX~O!k(lO~O!S%hO!_%iO#j(hO(T%gO~OP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~O!g#vO!k(gX~P! uOR(nO!Q(mO!l#xO#S$dO!|!{a!S!{a~O!x!{a%h!{a!_!{a#i!{a#j!{a(T!{a~P!#vO!x(rO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~O#k(xO~O![(zO!k(kP~P%[O(e(|O(o[O~O!S)OO!l#xO(e(|O(o[O~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]$_Oa$qa'z$qa'w$qa!k$qa!Y$qa!_$qa%i$qa!g$qa~Ol)dO~P!&zOh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Og(pP~P!,TO!Q)iO!g)hO!_$^X$Z$^X$]$^X$_$^X$f$^X~O!g)hO!_({X$Z({X$]({X$_({X$f({X~O!Q)iO~P!.^O!Q)iO!_({X$Z({X$]({X$_({X$f({X~O!_)kO$Z)oO$])jO$_)jO$f)pO~O![)sO~P!)[O$]$hO$_$gO$f)wO~On$zX!Q$zX#S$zX'y$zX(y$zX(z$zX~OgmXg$zXnmX!]mX#`mX~P!0SOx)yO(b)zO(c)|O~On*VO!Q*OO'y*PO(y$}O(z%PO~Og)}O~P!1WOg*WO~Oh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S*YO!_*ZO!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op*`O![*^O(T*XO!k)OP~P!1uO#k*aO~O!l*bO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T*dO(VTO(YUO(a$uO(y$}O(z%PO~O![*gO!Y)PP~P!3tOr*sOs!nO!S*iO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO(e!mO~O!^*pO~P!5iO#S$dOn(`X!Q(`X'y(`X(y(`X(z(`X!](`X#`(`X~Og(`X$O(`X~P!6kOn*xO#`*wOg(_X!](_X~O!]*yOg(^X~Oj%dOk%dOl%dO(T&ZOg(^P~Os*|O~Og)}O(T&ZO~O!l+SO~O(T(vO~Op+WO!S%hO![#iO!_%iO!|]O#i#lO#j#iO(T%gO!k(sP~O!g#vO#k+XO~O!S%hO![+ZO!](^O!_%iO(T%gO!Y(vP~Os'[O!S+]O![+[O(VTO(YUO(e(|O~O!^(xP~P!9|O!]+^Oa)TX'z)TX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa!ja!]!ja'z!ja'w!ja!Y!ja!k!jav!ja!_!ja%i!ja!g!ja~P!:tOR#zO!Q#yO!S#{O!l#xO(aVOP!ra[!raj!rar!ra!]!ra!p!ra#R!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#v!ra#x!ra#z!ra#{!ra(r!ra(y!ra(z!ra~Oa!ra'z!ra'w!ra!Y!ra!k!rav!ra!_!ra%i!ra!g!ra~P!=[OR#zO!Q#yO!S#{O!l#xO(aVOP!ta[!taj!tar!ta!]!ta!p!ta#R!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#t!ta#u!ta#v!ta#x!ta#z!ta#{!ta(r!ta(y!ta(z!ta~Oa!ta'z!ta'w!ta!Y!ta!k!tav!ta!_!ta%i!ta!g!ta~P!?rOh%VOn+gO!_'`O%i+fO~O!g+iOa(]X!_(]X'z(]X!](]X~Oa%nO!_XO'z%nO~Oh%VO!l%eO~Oh%VO!l%eO(T%gO~O!g#vO#k(xO~Ob+tO%j+uO(T+qO(VTO(YUO!^)XP~O!]+vO`)WX~O[+zO~O`+{O~O!_&PO(T%gO(U!lO`)WP~O%j,OO~P;SOh%VO#`,SO~Oh%VOn,VO!_$|O~O!_,XO~O!Q,ZO!_XO~O%n%vO~O!x,`O~Oe,eO~Ob,fO(T#nO(VTO(YUO!^)VP~Oe%}O~O%j!QO(T&ZO~P=gO[,kO`,jO~OPYOQYOSfOdzOeyOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!iuO!lZO!oYO!pYO!qYO!svO!xxO!|]O$niO%h}O(VTO(YUO(aVO(o[O~O!_!eO!u!gO$W!kO(T!dO~P!FyO`,jOa%nO'z%nO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa,pOl!OO!uwO%l!OO%m!OO%n!OO~P!IcO!l&oO~O&^,vO~O!_,xO~O&o,zO&q,{OP&laQ&laS&laY&laa&lad&lae&lal&lap&lar&las&lat&laz&la|&la!O&la!S&la!W&la!X&la!_&la!i&la!l&la!o&la!p&la!q&la!s&la!u&la!x&la!|&la$W&la$n&la%h&la%j&la%l&la%m&la%n&la%q&la%s&la%v&la%w&la%y&la&W&la&^&la&`&la&b&la&d&la&g&la&m&la&s&la&u&la&w&la&y&la&{&la'w&la(T&la(V&la(Y&la(a&la(o&la!^&la&e&lab&la&j&la~O(T-QO~Oh!eX!]!RX!^!RX!g!RX!g!eX!l!eX#`!RX~O!]!eX!^!eX~P#!iO!g-VO#`-UOh(jX!]#hX!^#hX!g(jX!l(jX~O!](jX!^(jX~P##[Oh%VO!g-XO!l%eO!]!aX!^!aX~Os!nO!S!oO(VTO(YUO(e!mO~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(VTO(YUO(aVO(o[O~O(T=QO~P#$qO!]-]O!^(iX~O!^-_O~O!g-VO#`-UO!]#hX!^#hX~O!]-`O!^(xX~O!^-bO~O!c-cO!d-cO(U!lO~P#$`O!^-fO~P'_On-iO!_'`O~O!Y-nO~Os!{a!b!{a!c!{a!d!{a#T!{a#U!{a#V!{a#W!{a#X!{a#[!{a#]!{a(U!{a(V!{a(Y!{a(e!{a(o!{a~P!#vO!p-sO#`-qO~PChO!c-uO!d-uO(U!lO~PDWOa%nO#`-qO'z%nO~Oa%nO!g#vO#`-qO'z%nO~Oa%nO!g#vO!p-sO#`-qO'z%nO(r'pO~O(P'xO(Q'xO(R-zO~Ov-{O~O!Y'Wa!]'Wa~P!:tO![.PO!Y'WX!]'WX~P%[O!](VO!Y(ha~O!Y(ha~PHRO!](^O!Y(va~O!S%hO![.TO!_%iO(T%gO!Y'^X!]'^X~O#`.VO!](ta!k(taa(ta'z(ta~O!g#vO~P#,wO!](jO!k(sa~O!S%hO!_%iO#j.ZO(T%gO~Op.`O!S%hO![.]O!_%iO!|]O#i._O#j.]O(T%gO!]'aX!k'aX~OR.dO!l#xO~Oh%VOn.gO!_'`O%i.fO~Oa#ci!]#ci'z#ci'w#ci!Y#ci!k#civ#ci!_#ci%i#ci!g#ci~P!:tOn>]O!Q*OO'y*PO(y$}O(z%PO~O#k#_aa#_a#`#_a'z#_a!]#_a!k#_a!_#_a!Y#_a~P#/sO#k(`XP(`XR(`X[(`Xa(`Xj(`Xr(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X'z(`X(a(`X(r(`X!k(`X!Y(`X'w(`Xv(`X!_(`X%i(`X!g(`X~P!6kO!].tO!k(kX~P!:tO!k.wO~O!Y.yO~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mia#mij#mir#mi!]#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#n#mi~P#3cO#n$OO~P#3cOP$[OR#zOr$aO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO[#mia#mij#mi!]#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#r#mi~P#6QO#r$QO~P#6QOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO(aVOa#mi!]#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#v#mi~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO(aVO(z#}Oa#mi!]#mi#z#mi#{#mi'z#mi(r#mi(y#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#x$UO~P#;VO#x#mi~P#;VO#v$SO~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO(aVO(y#|O(z#}Oa#mi!]#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#z#mi~P#={O#z$WO~P#={OP]XR]X[]Xj]Xr]X!Q]X!S]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X!]]X!^]X~O$O]X~P#@jOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO#z<gO#{<hO(aVO(r$YO(y#|O(z#}O~O$O.{O~P#BwO#S$dO#`<nO$Q<nO$O(gX!^(gX~P! uOa'da!]'da'z'da'w'da!k'da!Y'dav'da!_'da%i'da!g'da~P!:tO[#mia#mij#mir#mi!]#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO(y#mi(z#mi~P#EyOn>]O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P#EyO!]/POg(pX~P!1WOg/RO~Oa$Pi!]$Pi'z$Pi'w$Pi!Y$Pi!k$Piv$Pi!_$Pi%i$Pi!g$Pi~P!:tO$]/SO$_/SO~O$]/TO$_/TO~O!g)hO#`/UO!_$cX$Z$cX$]$cX$_$cX$f$cX~O![/VO~O!_)kO$Z/XO$])jO$_)jO$f/YO~O!]<iO!^(fX~P#BwO!^/ZO~O!g)hO$f({X~O$f/]O~Ov/^O~P!&zOx)yO(b)zO(c/aO~O!S/dO~O(y$}On%aa!Q%aa'y%aa(z%aa!]%aa#`%aa~Og%aa$O%aa~P#L{O(z%POn%ca!Q%ca'y%ca(y%ca!]%ca#`%ca~Og%ca$O%ca~P#MnO!]fX!gfX!kfX!k$zX(rfX~P!0SOp%WO![/mO!](^O(T/lO!Y(vP!Y)PP~P!1uOr*sO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO~Os<}O!S/nO![+[O!^*pO(e<|O!^(xP~P$ [O!k/oO~P#/sO!]/pO!g#vO(r'pO!k)OX~O!k/uO~OnoX!QoX'yoX(yoX(zoX~O!g#vO!koX~P$#OOp/wO!S%hO![*^O!_%iO(T%gO!k)OP~O#k/xO~O!Y$zX!]$zX!g%RX~P!0SO!]/yO!Y)PX~P#/sO!g/{O~O!Y/}O~OpkO(T0OO~P.iOh%VOr0TO!g#vO!l%eO(r'pO~O!g+iO~Oa%nO!]0XO'z%nO~O!^0ZO~P!5iO!c0[O!d0[O(U!lO~P#$`Os!nO!S0]O(VTO(YUO(e!mO~O#[0_O~Og%aa!]%aa#`%aa$O%aa~P!1WOg%ca!]%ca#`%ca$O%ca~P!1WOj%dOk%dOl%dO(T&ZOg'mX!]'mX~O!]*yOg(^a~Og0hO~On0jO#`0iOg(_a!](_a~OR0kO!Q0kO!S0lO#S$dOn}a'y}a(y}a(z}a!]}a#`}a~Og}a$O}a~P$(cO!Q*OO'y*POn$sa(y$sa(z$sa!]$sa#`$sa~Og$sa$O$sa~P$)_O!Q*OO'y*POn$ua(y$ua(z$ua!]$ua#`$ua~Og$ua$O$ua~P$*QO#k0oO~Og%Ta!]%Ta#`%Ta$O%Ta~P!1WO!g#vO~O#k0rO~O!]+^Oa)Ta'z)Ta~OR#zO!Q#yO!S#{O!l#xO(aVOP!ri[!rij!rir!ri!]!ri!p!ri#R!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#t!ri#u!ri#v!ri#x!ri#z!ri#{!ri(r!ri(y!ri(z!ri~Oa!ri'z!ri'w!ri!Y!ri!k!riv!ri!_!ri%i!ri!g!ri~P$+oOh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op0{O%]0|O(T0zO~P$.VO!g+iOa(]a!_(]a'z(]a!](]a~O#k1SO~O[]X!]fX!^fX~O!]1TO!^)XX~O!^1VO~O[1WO~Ob1YO(T+qO(VTO(YUO~O!_&PO(T%gO`'uX!]'uX~O!]+vO`)Wa~O!k1]O~P!:tO[1`O~O`1aO~O#`1fO~On1iO!_$|O~O(e(|O!^)UP~Oh%VOn1rO!_1oO%i1qO~O[1|O!]1zO!^)VX~O!^1}O~O`2POa%nO'z%nO~O(T#nO(VTO(YUO~O#S$dO#`$eO$Q$eOP(gXR(gX[(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~Oj2SO&[2TOa(gX~P$3pOj2SO#`$eO&[2TO~Oa2VO~P%[Oa2XO~O&e2[OP&ciQ&ciS&ciY&cia&cid&cie&cil&cip&cir&cis&cit&ciz&ci|&ci!O&ci!S&ci!W&ci!X&ci!_&ci!i&ci!l&ci!o&ci!p&ci!q&ci!s&ci!u&ci!x&ci!|&ci$W&ci$n&ci%h&ci%j&ci%l&ci%m&ci%n&ci%q&ci%s&ci%v&ci%w&ci%y&ci&W&ci&^&ci&`&ci&b&ci&d&ci&g&ci&m&ci&s&ci&u&ci&w&ci&y&ci&{&ci'w&ci(T&ci(V&ci(Y&ci(a&ci(o&ci!^&cib&ci&j&ci~Ob2bO!^2`O&j2aO~P`O!_XO!l2dO~O&q,{OP&liQ&liS&liY&lia&lid&lie&lil&lip&lir&lis&lit&liz&li|&li!O&li!S&li!W&li!X&li!_&li!i&li!l&li!o&li!p&li!q&li!s&li!u&li!x&li!|&li$W&li$n&li%h&li%j&li%l&li%m&li%n&li%q&li%s&li%v&li%w&li%y&li&W&li&^&li&`&li&b&li&d&li&g&li&m&li&s&li&u&li&w&li&y&li&{&li'w&li(T&li(V&li(Y&li(a&li(o&li!^&li&e&lib&li&j&li~O!Y2jO~O!]!aa!^!aa~P#BwOs!nO!S!oO![2pO(e!mO!]'XX!^'XX~P@nO!]-]O!^(ia~O!]'_X!^'_X~P!9|O!]-`O!^(xa~O!^2wO~P'_Oa%nO#`3QO'z%nO~Oa%nO!g#vO#`3QO'z%nO~Oa%nO!g#vO!p3UO#`3QO'z%nO(r'pO~Oa%nO'z%nO~P!:tO!]$_Ov$qa~O!Y'Wi!]'Wi~P!:tO!](VO!Y(hi~O!](^O!Y(vi~O!Y(wi!](wi~P!:tO!](ti!k(tia(ti'z(ti~P!:tO#`3WO!](ti!k(tia(ti'z(ti~O!](jO!k(si~O!S%hO!_%iO!|]O#i3]O#j3[O(T%gO~O!S%hO!_%iO#j3[O(T%gO~On3dO!_'`O%i3cO~Oh%VOn3dO!_'`O%i3cO~O#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aav%aa!_%aa%i%aa!g%aa~P#L{O#k%caP%caR%ca[%caa%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%cav%ca!_%ca%i%ca!g%ca~P#MnO#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!]%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aa#`%aav%aa!_%aa%i%aa!g%aa~P#/sO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!]%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%ca#`%cav%ca!_%ca%i%ca!g%ca~P#/sO#k}aP}a[}aa}aj}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a'z}a(a}a(r}a!k}a!Y}a'w}av}a!_}a%i}a!g}a~P$(cO#k$saP$saR$sa[$saa$saj$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa'z$sa(a$sa(r$sa!k$sa!Y$sa'w$sav$sa!_$sa%i$sa!g$sa~P$)_O#k$uaP$uaR$ua[$uaa$uaj$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua'z$ua(a$ua(r$ua!k$ua!Y$ua'w$uav$ua!_$ua%i$ua!g$ua~P$*QO#k%TaP%TaR%Ta[%Taa%Taj%Tar%Ta!S%Ta!]%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta'z%Ta(a%Ta(r%Ta!k%Ta!Y%Ta'w%Ta#`%Tav%Ta!_%Ta%i%Ta!g%Ta~P#/sOa#cq!]#cq'z#cq'w#cq!Y#cq!k#cqv#cq!_#cq%i#cq!g#cq~P!:tO![3lO!]'YX!k'YX~P%[O!].tO!k(ka~O!].tO!k(ka~P!:tO!Y3oO~O$O!na!^!na~PKlO$O!ja!]!ja!^!ja~P#BwO$O!ra!^!ra~P!=[O$O!ta!^!ta~P!?rOg']X!]']X~P!,TO!]/POg(pa~OSfO!_4TO$d4UO~O!^4YO~Ov4ZO~P#/sOa$mq!]$mq'z$mq'w$mq!Y$mq!k$mqv$mq!_$mq%i$mq!g$mq~P!:tO!Y4]O~P!&zO!S4^O~O!Q*OO'y*PO(z%POn'ia(y'ia!]'ia#`'ia~Og'ia$O'ia~P%-fO!Q*OO'y*POn'ka(y'ka(z'ka!]'ka#`'ka~Og'ka$O'ka~P%.XO(r$YO~P#/sO!YfX!Y$zX!]fX!]$zX!g%RX#`fX~P!0SOp%WO(T=WO~P!1uOp4bO!S%hO![4aO!_%iO(T%gO!]'eX!k'eX~O!]/pO!k)Oa~O!]/pO!g#vO!k)Oa~O!]/pO!g#vO(r'pO!k)Oa~Og$|i!]$|i#`$|i$O$|i~P!1WO![4jO!Y'gX!]'gX~P!3tO!]/yO!Y)Pa~O!]/yO!Y)Pa~P#/sOP]XR]X[]Xj]Xr]X!Q]X!S]X!Y]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~Oj%YX!g%YX~P%2OOj4oO!g#vO~Oh%VO!g#vO!l%eO~Oh%VOr4tO!l%eO(r'pO~Or4yO!g#vO(r'pO~Os!nO!S4zO(VTO(YUO(e!mO~O(y$}On%ai!Q%ai'y%ai(z%ai!]%ai#`%ai~Og%ai$O%ai~P%5oO(z%POn%ci!Q%ci'y%ci(y%ci!]%ci#`%ci~Og%ci$O%ci~P%6bOg(_i!](_i~P!1WO#`5QOg(_i!](_i~P!1WO!k5VO~Oa$oq!]$oq'z$oq'w$oq!Y$oq!k$oqv$oq!_$oq%i$oq!g$oq~P!:tO!Y5ZO~O!]5[O!_)QX~P#/sOa$zX!_$zX%^]X'z$zX!]$zX~P!0SO%^5_OaoX!_oX'zoX!]oX~P$#OOp5`O(T#nO~O%^5_O~Ob5fO%j5gO(T+qO(VTO(YUO!]'tX!^'tX~O!]1TO!^)Xa~O[5kO~O`5lO~O[5pO~Oa%nO'z%nO~P#/sO!]5uO#`5wO!^)UX~O!^5xO~Or6OOs!nO!S*iO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!pO#W!pO#X!pO#[5}O#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O!^5|O~P%;eOn6TO!_1oO%i6SO~Oh%VOn6TO!_1oO%i6SO~Ob6[O(T#nO(VTO(YUO!]'sX!^'sX~O!]1zO!^)Va~O(VTO(YUO(e6^O~O`6bO~Oj6eO&[6fO~PNXO!k6gO~P%[Oa6iO~Oa6iO~P%[Ob2bO!^6nO&j2aO~P`O!g6pO~O!g6rOh(ji!](ji!^(ji!g(ji!l(jir(ji(r(ji~O!]#hi!^#hi~P#BwO#`6sO!]#hi!^#hi~O!]!ai!^!ai~P#BwOa%nO#`6|O'z%nO~Oa%nO!g#vO#`6|O'z%nO~O!](tq!k(tqa(tq'z(tq~P!:tO!](jO!k(sq~O!S%hO!_%iO#j7TO(T%gO~O!_'`O%i7WO~On7[O!_'`O%i7WO~O#k'iaP'iaR'ia['iaa'iaj'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia'z'ia(a'ia(r'ia!k'ia!Y'ia'w'iav'ia!_'ia%i'ia!g'ia~P%-fO#k'kaP'kaR'ka['kaa'kaj'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka'z'ka(a'ka(r'ka!k'ka!Y'ka'w'kav'ka!_'ka%i'ka!g'ka~P%.XO#k$|iP$|iR$|i[$|ia$|ij$|ir$|i!S$|i!]$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i'z$|i(a$|i(r$|i!k$|i!Y$|i'w$|i#`$|iv$|i!_$|i%i$|i!g$|i~P#/sO#k%aiP%aiR%ai[%aia%aij%air%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai'z%ai(a%ai(r%ai!k%ai!Y%ai'w%aiv%ai!_%ai%i%ai!g%ai~P%5oO#k%ciP%ciR%ci[%cia%cij%cir%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci'z%ci(a%ci(r%ci!k%ci!Y%ci'w%civ%ci!_%ci%i%ci!g%ci~P%6bO!]'Ya!k'Ya~P!:tO!].tO!k(ki~O$O#ci!]#ci!^#ci~P#BwOP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mij#mir#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#n#mi~P%NdO#n<_O~P%NdOP$[OR#zOr<kO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO[#mij#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#r#mi~P&!lO#r<aO~P&!lOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO(aVO#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#v#mi~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO(aVO(z#}O#z#mi#{#mi$O#mi(r#mi(y#mi!]#mi!^#mi~O#x<eO~P&&uO#x#mi~P&&uO#v<cO~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO(aVO(y#|O(z#}O#{#mi$O#mi(r#mi!]#mi!^#mi~O#z#mi~P&)UO#z<gO~P&)UOa#|y!]#|y'z#|y'w#|y!Y#|y!k#|yv#|y!_#|y%i#|y!g#|y~P!:tO[#mij#mir#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi!]#mi!^#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO(y#mi(z#mi~P&,QOn>^O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P&,QO#S$dOP(`XR(`X[(`Xj(`Xn(`Xr(`X!Q(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X$O(`X'y(`X(a(`X(r(`X(y(`X(z(`X!](`X!^(`X~O$O$Pi!]$Pi!^$Pi~P#BwO$O!ri!^!ri~P$+oOg']a!]']a~P!1WO!^7nO~O!]'da!^'da~P#BwO!Y7oO~P#/sO!g#vO(r'pO!]'ea!k'ea~O!]/pO!k)Oi~O!]/pO!g#vO!k)Oi~Og$|q!]$|q#`$|q$O$|q~P!1WO!Y'ga!]'ga~P#/sO!g7vO~O!]/yO!Y)Pi~P#/sO!]/yO!Y)Pi~O!Y7yO~Oh%VOr8OO!l%eO(r'pO~Oj8QO!g#vO~Or8TO!g#vO(r'pO~O!Q*OO'y*PO(z%POn'ja(y'ja!]'ja#`'ja~Og'ja$O'ja~P&5RO!Q*OO'y*POn'la(y'la(z'la!]'la#`'la~Og'la$O'la~P&5tOg(_q!](_q~P!1WO#`8VOg(_q!](_q~P!1WO!Y8WO~Og%Oq!]%Oq#`%Oq$O%Oq~P!1WOa$oy!]$oy'z$oy'w$oy!Y$oy!k$oyv$oy!_$oy%i$oy!g$oy~P!:tO!g6rO~O!]5[O!_)Qa~O!_'`OP$TaR$Ta[$Taj$Tar$Ta!Q$Ta!S$Ta!]$Ta!l$Ta!p$Ta#R$Ta#n$Ta#o$Ta#p$Ta#q$Ta#r$Ta#s$Ta#t$Ta#u$Ta#v$Ta#x$Ta#z$Ta#{$Ta(a$Ta(r$Ta(y$Ta(z$Ta~O%i7WO~P&8fO%^8[Oa%[i!_%[i'z%[i!]%[i~Oa#cy!]#cy'z#cy'w#cy!Y#cy!k#cyv#cy!_#cy%i#cy!g#cy~P!:tO[8^O~Ob8`O(T+qO(VTO(YUO~O!]1TO!^)Xi~O`8dO~O(e(|O!]'pX!^'pX~O!]5uO!^)Ua~O!^8nO~P%;eO(o!sO~P$&YO#[8oO~O!_1oO~O!_1oO%i8qO~On8tO!_1oO%i8qO~O[8yO!]'sa!^'sa~O!]1zO!^)Vi~O!k8}O~O!k9OO~O!k9RO~O!k9RO~P%[Oa9TO~O!g9UO~O!k9VO~O!](wi!^(wi~P#BwOa%nO#`9_O'z%nO~O!](ty!k(tya(ty'z(ty~P!:tO!](jO!k(sy~O%i9bO~P&8fO!_'`O%i9bO~O#k$|qP$|qR$|q[$|qa$|qj$|qr$|q!S$|q!]$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q'z$|q(a$|q(r$|q!k$|q!Y$|q'w$|q#`$|qv$|q!_$|q%i$|q!g$|q~P#/sO#k'jaP'jaR'ja['jaa'jaj'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja'z'ja(a'ja(r'ja!k'ja!Y'ja'w'jav'ja!_'ja%i'ja!g'ja~P&5RO#k'laP'laR'la['laa'laj'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la'z'la(a'la(r'la!k'la!Y'la'w'lav'la!_'la%i'la!g'la~P&5tO#k%OqP%OqR%Oq[%Oqa%Oqj%Oqr%Oq!S%Oq!]%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq'z%Oq(a%Oq(r%Oq!k%Oq!Y%Oq'w%Oq#`%Oqv%Oq!_%Oq%i%Oq!g%Oq~P#/sO!]'Yi!k'Yi~P!:tO$O#cq!]#cq!^#cq~P#BwO(y$}OP%aaR%aa[%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa$O%aa(a%aa(r%aa!]%aa!^%aa~On%aa!Q%aa'y%aa(z%aa~P&IyO(z%POP%caR%ca[%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca$O%ca(a%ca(r%ca!]%ca!^%ca~On%ca!Q%ca'y%ca(y%ca~P&LQOn>^O!Q*OO'y*PO(z%PO~P&IyOn>^O!Q*OO'y*PO(y$}O~P&LQOR0kO!Q0kO!S0lO#S$dOP}a[}aj}an}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a$O}a'y}a(a}a(r}a(y}a(z}a!]}a!^}a~O!Q*OO'y*POP$saR$sa[$saj$san$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa$O$sa(a$sa(r$sa(y$sa(z$sa!]$sa!^$sa~O!Q*OO'y*POP$uaR$ua[$uaj$uan$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua$O$ua(a$ua(r$ua(y$ua(z$ua!]$ua!^$ua~On>^O!Q*OO'y*PO(y$}O(z%PO~OP%TaR%Ta[%Taj%Tar%Ta!S%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta$O%Ta(a%Ta(r%Ta!]%Ta!^%Ta~P''VO$O$mq!]$mq!^$mq~P#BwO$O$oq!]$oq!^$oq~P#BwO!^9oO~O$O9pO~P!1WO!g#vO!]'ei!k'ei~O!g#vO(r'pO!]'ei!k'ei~O!]/pO!k)Oq~O!Y'gi!]'gi~P#/sO!]/yO!Y)Pq~Or9wO!g#vO(r'pO~O[9yO!Y9xO~P#/sO!Y9xO~Oj:PO!g#vO~Og(_y!](_y~P!1WO!]'na!_'na~P#/sOa%[q!_%[q'z%[q!]%[q~P#/sO[:UO~O!]1TO!^)Xq~O`:YO~O#`:ZO!]'pa!^'pa~O!]5uO!^)Ui~P#BwO!S:]O~O!_1oO%i:`O~O(VTO(YUO(e:eO~O!]1zO!^)Vq~O!k:hO~O!k:iO~O!k:jO~O!k:jO~P%[O#`:mO!]#hy!^#hy~O!]#hy!^#hy~P#BwO%i:rO~P&8fO!_'`O%i:rO~O$O#|y!]#|y!^#|y~P#BwOP$|iR$|i[$|ij$|ir$|i!S$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i$O$|i(a$|i(r$|i!]$|i!^$|i~P''VO!Q*OO'y*PO(z%POP'iaR'ia['iaj'ian'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia$O'ia(a'ia(r'ia(y'ia!]'ia!^'ia~O!Q*OO'y*POP'kaR'ka['kaj'kan'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka$O'ka(a'ka(r'ka(y'ka(z'ka!]'ka!^'ka~O(y$}OP%aiR%ai[%aij%ain%air%ai!Q%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai$O%ai'y%ai(a%ai(r%ai(z%ai!]%ai!^%ai~O(z%POP%ciR%ci[%cij%cin%cir%ci!Q%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci$O%ci'y%ci(a%ci(r%ci(y%ci!]%ci!^%ci~O$O$oy!]$oy!^$oy~P#BwO$O#cy!]#cy!^#cy~P#BwO!g#vO!]'eq!k'eq~O!]/pO!k)Oy~O!Y'gq!]'gq~P#/sOr:|O!g#vO(r'pO~O[;QO!Y;PO~P#/sO!Y;PO~Og(_!R!](_!R~P!1WOa%[y!_%[y'z%[y!]%[y~P#/sO!]1TO!^)Xy~O!]5uO!^)Uq~O(T;XO~O!_1oO%i;[O~O!k;_O~O%i;dO~P&8fOP$|qR$|q[$|qj$|qr$|q!S$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q$O$|q(a$|q(r$|q!]$|q!^$|q~P''VO!Q*OO'y*PO(z%POP'jaR'ja['jaj'jan'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja$O'ja(a'ja(r'ja(y'ja!]'ja!^'ja~O!Q*OO'y*POP'laR'la['laj'lan'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la$O'la(a'la(r'la(y'la(z'la!]'la!^'la~OP%OqR%Oq[%Oqj%Oqr%Oq!S%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq$O%Oq(a%Oq(r%Oq!]%Oq!^%Oq~P''VOg%e!Z!]%e!Z#`%e!Z$O%e!Z~P!1WO!Y;hO~P#/sOr;iO!g#vO(r'pO~O[;kO!Y;hO~P#/sO!]'pq!^'pq~P#BwO!]#h!Z!^#h!Z~P#BwO#k%e!ZP%e!ZR%e!Z[%e!Za%e!Zj%e!Zr%e!Z!S%e!Z!]%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z'z%e!Z(a%e!Z(r%e!Z!k%e!Z!Y%e!Z'w%e!Z#`%e!Zv%e!Z!_%e!Z%i%e!Z!g%e!Z~P#/sOr;tO!g#vO(r'pO~O!Y;uO~P#/sOr;|O!g#vO(r'pO~O!Y;}O~P#/sOP%e!ZR%e!Z[%e!Zj%e!Zr%e!Z!S%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z$O%e!Z(a%e!Z(r%e!Z!]%e!Z!^%e!Z~P''VOr<QO!g#vO(r'pO~Ov(fX~P1qO!Q%rO~P!)[O(U!lO~P!)[O!YfX!]fX#`fX~P%2OOP]XR]X[]Xj]Xr]X!Q]X!S]X!]]X!]fX!l]X!p]X#R]X#S]X#`]X#`fX#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~O!gfX!k]X!kfX(rfX~P'LTOP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_XO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]<iO!^$qa~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<tO!S${O!_$|O!i>WO!l$xO#j<zO$W%`O$t<vO$v<xO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Ol)dO~P(!yOr!eX(r!eX~P#!iOr(jX(r(jX~P##[O!^]X!^fX~P'LTO!YfX!Y$zX!]fX!]$zX#`fX~P!0SO#k<^O~O!g#vO#k<^O~O#`<nO~Oj<bO~O#`=OO!](wX!^(wX~O#`<nO!](uX!^(uX~O#k=PO~Og=RO~P!1WO#k=XO~O#k=YO~Og=RO(T&ZO~O!g#vO#k=ZO~O!g#vO#k=PO~O$O=[O~P#BwO#k=]O~O#k=^O~O#k=cO~O#k=dO~O#k=eO~O#k=fO~O$O=gO~P!1WO$O=hO~P!1WOl=sO~P7eOk#S#T#U#W#X#[#i#j#u$n$t$v$y%]%^%h%i%j%q%s%v%w%y%{~(OT#o!X'|(U#ps#n#qr!Q'}$]'}(T$_(e~",
  goto: "$9Y)]PPPPPP)^PP)aP)rP+W/]PPPP6mPP7TPP=QPPP@tPA^PA^PPPA^PCfPA^PA^PA^PCjPCoPD^PIWPPPI[PPPPI[L_PPPLeMVPI[PI[PP! eI[PPPI[PI[P!#lI[P!'S!(X!(bP!)U!)Y!)U!,gPPPPPPP!-W!(XPP!-h!/YP!2iI[I[!2n!5z!:h!:h!>gPPP!>oI[PPPPPPPPP!BOP!C]PPI[!DnPI[PI[I[I[I[I[PI[!FQP!I[P!LbP!Lf!Lp!Lt!LtP!IXP!Lx!LxP#!OP#!SI[PI[#!Y#%_CjA^PA^PA^A^P#&lA^A^#)OA^#+vA^#.SA^A^#.r#1W#1W#1]#1f#1W#1qPP#1WPA^#2ZA^#6YA^A^6mPPP#:_PPP#:x#:xP#:xP#;`#:xPP#;fP#;]P#;]#;y#;]#<e#<k#<n)aP#<q)aP#<z#<z#<zP)aP)aP)aP)aPP)aP#=Q#=TP#=T)aP#=XP#=[P)aP)aP)aP)aP)aP)a)aPP#=b#=h#=s#=y#>P#>V#>]#>k#>q#>{#?R#?]#?c#?s#?y#@k#@}#AT#AZ#Ai#BO#Cs#DR#DY#Et#FS#Gt#HS#HY#H`#Hf#Hp#Hv#H|#IW#Ij#IpPPPPPPPPPPP#IvPPPPPPP#Jk#Mx$ b$ i$ qPPP$']P$'f$*_$0x$0{$1O$1}$2Q$2X$2aP$2g$2jP$3W$3[$4S$5b$5g$5}PP$6S$6Y$6^$6a$6e$6i$7e$7|$8e$8i$8l$8o$8y$8|$9Q$9UR!|RoqOXst!Z#d%m&r&t&u&w,s,x2[2_Y!vQ'`-e1o5{Q%tvQ%|yQ&T|Q&j!VS'W!e-]Q'f!iS'l!r!yU*k$|*Z*oQ+o%}S+|&V&WQ,d&dQ-c'_Q-m'gQ-u'mQ0[*qQ1b,OQ1y,eR<{<Y%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_S#q]<V!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU+P%]<s<tQ+t&PQ,f&gQ,m&oQ0x+gQ0}+iQ1Y+uQ2R,kQ3`.gQ5`0|Q5f1TQ6[1zQ7Y3dQ8`5gR9e7['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S!S!nQ!r!v!y!z$|'W'_'`'l'm'n*k*o*q*r-]-c-e-u0[0_1o5{5}%[$ti#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q&X|Q'U!eS'[%i-`Q+t&PQ,P&WQ,f&gQ0n+SQ1Y+uQ1_+{Q2Q,jQ2R,kQ5f1TQ5o1aQ6[1zQ6_1|Q6`2PQ8`5gQ8c5lQ8|6bQ:X8dQ:f8yQ;V:YR<}*ZrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R,h&k&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'b'r(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>R>S[#]WZ#W#Z'X(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ%wxQ%{yW&Q|&V&W,OQ&_!TQ'c!hQ'e!iQ(q#sS+n%|%}Q+r&PQ,_&bQ,c&dS-l'f'gQ.i(rQ1R+oQ1X+uQ1Z+vQ1^+zQ1t,`S1x,d,eQ2|-mQ5e1TQ5i1WQ5n1`Q6Z1yQ8_5gQ8b5kQ8f5pQ:T8^R;T:U!U$zi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y!^%yy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{Q+h%wQ,T&[Q,W&]Q,b&dQ.h(qQ1s,_U1w,c,d,eQ3e.iQ6U1tS6Y1x1yQ8x6Z#f>T#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o>U<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hW%Ti%V*y>PS&[!Q&iQ&]!RQ&^!SU*}%[%d=sR,R&Y%]%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^T)z$u){V+P%]<s<tW'[!e%i*Z-`S(}#y#zQ+c%rQ+y&SS.b(m(nQ1j,XQ5T0kR8i5u'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S$i$^c#Y#e%q%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.|.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ'Y!eR2q-]!W!nQ!e!r!v!y!z$|'W'_'`'l'm'n*Z*k*o*q*r-]-c-e-u0[0_1o5{5}R1l,ZnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&y!^Q'v!xS(s#u<^Q+l%zQ,]&_Q,^&aQ-j'dQ-w'oS.r(x=PS0q+X=ZQ1P+mQ1n,[Q2c,zQ2e,{Q2m-WQ2z-kQ2}-oS5Y0r=eQ5a1QS5d1S=fQ6t2oQ6x2{Q6}3SQ8]5bQ9Y6vQ9Z6yQ9^7OR:l9V$d$]c#Y#e%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vS(o#p'iQ)P#zS+b%q.|S.c(n(pR3^.d'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS#q]<VQ&t!XQ&u!YQ&w![Q&x!]R2Z,vQ'a!hQ+e%wQ-h'cS.e(q+hQ2x-gW3b.h.i0w0yQ6w2yW7U3_3a3e5^U9a7V7X7ZU:q9c9d9fS;b:p:sQ;p;cR;x;qU!wQ'`-eT5y1o5{!Q_OXZ`st!V!Z#d#h%e%m&i&k&r&t&u&w(j,s,x.[2[2_]!pQ!r'`-e1o5{T#q]<V%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S(}#y#zS.b(m(n!s=l$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU$fd)_,mS(p#p'iU*v%R(w4OU0m+O.n7gQ5^0xQ7V3`Q9d7YR:s9em!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}Q't!uS(f#g2US-s'k'wQ/s*]Q0R*jQ3U-vQ4f/tQ4r0TQ4s0UQ4x0^Q7r4`S7}4t4vS8R4y4{Q9r7sQ9v7yQ9{8OQ:Q8TS:{9w9xS;g:|;PS;s;h;iS;{;t;uS<P;|;}R<S<QQ#wbQ's!uS(e#g2US(g#m+WQ+Y%fQ+j%xQ+p&OU-r'k't'wQ.W(fU/r*]*`/wQ0S*jQ0V*lQ1O+kQ1u,aS3R-s-vQ3Z.`S4e/s/tQ4n0PS4q0R0^Q4u0WQ6W1vQ7P3US7q4`4bQ7u4fU7|4r4x4{Q8P4wQ8v6XS9q7r7sQ9u7yQ9}8RQ:O8SQ:c8wQ:y9rS:z9v9xQ;S:QQ;^:dS;f:{;PS;r;g;hS;z;s;uS<O;{;}Q<R<PQ<T<SQ=o=jQ={=tR=|=uV!wQ'`-e%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S#wz!j!r=i$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=o>R%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Q%fj!^%xy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{S&Oz!jQ+k%yQ,a&dW1v,b,c,d,eU6X1w1x1yS8w6Y6ZQ:d8x!r=j$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ=t>QR=u>R%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Y#bWZ#W#Z(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ,n&o!p=k$Z$n)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=n'XU']!e%i*ZR2s-`%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ,m&oQ0x+gQ3`.gQ7Y3dR9e7[!b$Tc#Y%q(S(Y(t(y)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!P<d)^)q-Z.|2k2n3p3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!f$Vc#Y%q(S(Y(t(y)W)X)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!T<f)^)q-Z.|2k2n3p3v3w3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!^$Zc#Y%q(S(Y(t(y)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<WQ4_/kz>S)^)q-Z.|2k2n3p4P4X6u7b7k7l8k9X9g9m9n;W;`=vQ>X>ZR>Y>['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS$oh$pR4U/U'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$kf$qQ$ifS)j$l)nR)v$qT$jf$qT)l$l)n'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$oh$pQ$rhR)u$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_!s>Q$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S#glOPXZst!Z!`!o#S#d#o#{$n%m&k&n&o&r&t&u&w&{'T'b)O)s*i+]+g,p,s,x-i.g/V/n0]0l1r2S2T2V2X2[2_2a3d4T4z6T6e6f6i7[8t9T!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^Q+T%aQ/c*Oo4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!U$yi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>YQ*c$zU*l$|*Z*oQ+U%bQ0W*m#f=q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n=r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hQ=w>TQ=x>UQ=y>VR=z>W!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hnoOXst!Z#d%m&r&t&u&w,s,x2[2_S*f${*YQ-R'OQ-S'QR4i/y%[%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q,U&]Q1h,WQ5s1gR8h5tV*n$|*Z*oU*n$|*Z*oT5z1o5{S0P*i/nQ4w0]T8S4z:]Q+j%xQ0V*lQ1O+kQ1u,aQ6W1vQ8v6XQ:c8wR;^:d!U%Oi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Yx*R$v)e*S*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>OS0`*t0a#f<o#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<p<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!d=S(u)c*[*e.j.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[`=T3}7c7f7j9h:t:w;yS=_.l3iT=`7e9k!U%Qi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y|*T$v)e*U*t+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>OS0b*u0c#f<q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!h=U(u)c*[*e.k.l.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[d=V3}7d7e7j9h9i:t:u:w;yS=a.m3jT=b7f9lrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q&f!UR,p&ornOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R&f!UQ,Y&^R1d,RsnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q1p,_S6R1s1tU8p6P6Q6US:_8r8sS;Y:^:aQ;m;ZR;w;nQ&m!VR,i&iR6_1|R:f8yW&Q|&V&W,OR1Z+vQ&r!WR,s&sR,y&xT2],x2_R,}&yQ,|&yR2f,}Q'y!{R-y'ySsOtQ#dXT%ps#dQ#OTR'{#OQ#RUR'}#RQ){$uR/`){Q#UVR(Q#UQ#XWU(W#X(X.QQ(X#YR.Q(YQ-^'YR2r-^Q.u(yS3m.u3nR3n.vQ-e'`R2v-eY!rQ'`-e1o5{R'j!rQ/Q)eR4S/QU#_W%h*YU(_#_(`.RQ(`#`R.R(ZQ-a']R2t-at`OXst!V!Z#d%m&i&k&r&t&u&w,s,x2[2_S#hZ%eU#r`#h.[R.[(jQ(k#jQ.X(gW.a(k.X3X7RQ3X.YR7R3YQ)n$lR/W)nQ$phR)t$pQ$`cU)a$`-|<jQ-|<WR<j)qQ/q*]W4c/q4d7t9sU4d/r/s/tS7t4e4fR9s7u$e*Q$v(u)c)e*[*e*t*u+Q+R+V.l.m.o.p.q/_/g/i/k/v/|0d0e0v1e3f3g3h3}4R4[4g4h4l4|5O5R5S5W5r7]7^7_7`7e7f7h7i7j7p7w7z8U8X8Z9h9i9j9t9|:R:S:t:u:v:w:x:};R;e;j;v;y=p=}>O>Z>[Q/z*eU4k/z4m7xQ4m/|R7x4lS*o$|*ZR0Y*ox*S$v)e*t*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>O!d.j(u)c*[*e.l.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/h*S.j7ca7c3}7e7f7j9h:t:w;yQ0a*tQ3i.lU4}0a3i9kR9k7e|*U$v)e*t*u+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>O!h.k(u)c*[*e.l.m.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/j*U.k7de7d3}7e7f7j9h9i:t:u:w;yQ0c*uQ3j.mU5P0c3j9lR9l7fQ*z%UR0g*zQ5]0vR8Y5]Q+_%kR0u+_Q5v1jS8j5v:[R:[8kQ,[&_R1m,[Q5{1oR8m5{Q1{,fS6]1{8zR8z6_Q1U+rW5h1U5j8a:VQ5j1XQ8a5iR:V8bQ+w&QR1[+wQ2_,xR6m2_YrOXst#dQ&v!ZQ+a%mQ,r&rQ,t&tQ,u&uQ,w&wQ2Y,sS2],x2_R6l2[Q%opQ&z!_Q&}!aQ'P!bQ'R!cQ'q!uQ+`%lQ+l%zQ,Q&XQ,h&mQ-P&|W-p'k's't'wQ-w'oQ0X*nQ1P+mQ1c,PS2O,i,lQ2g-OQ2h-RQ2i-SQ2}-oW3P-r-s-v-xQ5a1QQ5m1_Q5q1eQ6V1uQ6a2QQ6k2ZU6z3O3R3UQ6}3SQ8]5bQ8e5oQ8g5rQ8l5zQ8u6WQ8{6`S9[6{7PQ9^7OQ:W8cQ:b8vQ:g8|Q:n9]Q;U:XQ;]:cQ;a:oQ;l;VR;o;^Q%zyQ'd!iQ'o!uU+m%{%|%}Q-W'VU-k'e'f'gS-o'k'uQ0Q*jS1Q+n+oQ2o-YS2{-l-mQ3S-tS4p0R0UQ5b1RQ6v2uQ6y2|Q7O3TU7{4r4s4vQ9z7}R;O9{S$wi>PR*{%VU%Ui%V>PR0f*yQ$viS(u#v+iS)c$b$cQ)e$dQ*[$xS*e${*YQ*t%OQ*u%QQ+Q%^Q+R%_Q+V%cQ.l<oQ.m<qQ.o<uQ.p<wQ.q<yQ/_)yQ/g*RQ/i*TQ/k*VQ/v*aS/|*g/mQ0d*wQ0e*xl0v+f,V.f1i1q3c6S7W8q9b:`:r;[;dQ1e,SQ3f=SQ3g=UQ3h=XS3}<l<mQ4R/PS4[/d4^Q4g/xQ4h/yQ4l/{Q4|0`Q5O0bQ5R0iQ5S0jQ5W0oQ5r1fQ7]=]Q7^=_Q7_=aQ7`=cQ7e<pQ7f<rQ7h<vQ7i<xQ7j<zQ7p4_Q7w4jQ7z4oQ8U5QQ8X5[Q8Z5_Q9h=YQ9i=TQ9j=VQ9t7vQ9|8QQ:R8VQ:S8[Q:t=^Q:u=`Q:v=bQ:w=dQ:x9pQ:}9yQ;R:PQ;e=gQ;j;QQ;v;kQ;y=hQ=p>PQ=}>XQ>O>YQ>Z>]R>[>^Q+O%]Q.n<sR7g<tnpOXst!Z#d%m&r&t&u&w,s,x2[2_Q!fPS#fZ#oQ&|!`W'h!o*i0]4zQ(P#SQ)Q#{Q)r$nS,l&k&nQ,q&oQ-O&{S-T'T/nQ-g'bQ.x)OQ/[)sQ0s+]Q0y+gQ2W,pQ2y-iQ3a.gQ4W/VQ5U0lQ6Q1rQ6c2SQ6d2TQ6h2VQ6j2XQ6o2aQ7Z3dQ7m4TQ8s6TQ9P6eQ9Q6fQ9S6iQ9f7[Q:a8tR:k9T#[cOPXZst!Z!`!o#d#o#{%m&k&n&o&r&t&u&w&{'T'b)O*i+]+g,p,s,x-i.g/n0]0l1r2S2T2V2X2[2_2a3d4z6T6e6f6i7[8t9TQ#YWQ#eYQ%quQ%svS%uw!gS(S#W(VQ(Y#ZQ(t#uQ(y#xQ)R$OQ)S$PQ)T$QQ)U$RQ)V$SQ)W$TQ)X$UQ)Y$VQ)Z$WQ)[$XQ)^$ZQ)`$_Q)b$aQ)g$eW)q$n)s/V4TQ+d%tQ+x&RS-Z'X2pQ-x'rS-}(T.PQ.S(]Q.U(dQ.s(xQ.v(zQ.z<UQ.|<XQ.}<YQ/O<]Q/b)}Q0p+XQ2k-UQ2n-XQ3O-qQ3V.VQ3k.tQ3p<^Q3q<_Q3r<`Q3s<aQ3t<bQ3u<cQ3v<dQ3w<eQ3x<fQ3y<gQ3z<hQ3{.{Q3|<kQ4P<nQ4Q<{Q4X<iQ5X0rQ5c1SQ6u=OQ6{3QQ7Q3WQ7a3lQ7b=PQ7k=RQ7l=ZQ8k5wQ9X6sQ9]6|Q9g=[Q9m=eQ9n=fQ:o9_Q;W:ZQ;`:mQ<W#SR=v>SR#[WR'Z!el!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}S'V!e-]U*j$|*Z*oS-Y'W'_S0U*k*qQ0^*rQ2u-cQ4v0[R4{0_R({#xQ!fQT-d'`-e]!qQ!r'`-e1o5{Q#p]R'i<VR)f$dY!uQ'`-e1o5{Q'k!rS'u!v!yS'w!z5}S-t'l'mQ-v'nR3T-uT#kZ%eS#jZ%eS%km,oU(g#h#i#lS.Y(h(iQ.^(jQ0t+^Q3Y.ZU3Z.[.]._S7S3[3]R9`7Td#^W#W#Z%h(T(^*Y+Z.T/mr#gZm#h#i#l%e(h(i(j+^.Z.[.]._3[3]7TS*]$x*bQ/t*^Q2U,oQ2l-VQ4`/pQ6q2dQ7s4aQ9W6rT=m'X+[V#aW%h*YU#`W%h*YS(U#W(^U(Z#Z+Z/mS-['X+[T.O(T.TV'^!e%i*ZQ$lfR)x$qT)m$l)nR4V/UT*_$x*bT*h${*YQ0w+fQ1g,VQ3_.fQ5t1iQ6P1qQ7X3cQ8r6SQ9c7WQ:^8qQ:p9bQ;Z:`Q;c:rQ;n;[R;q;dnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&l!VR,h&itmOXst!U!V!Z#d%m&i&r&t&u&w,s,x2[2_R,o&oT%lm,oR1k,XR,g&gQ&U|S+}&V&WR1^,OR+s&PT&p!W&sT&q!W&sT2^,x2_",
  nodeNames: "⚠ ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList in out const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration defer ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 380,
  context: oN,
  nodeProps: [
    ["isolate", -8, 5, 6, 14, 37, 39, 51, 53, 55, ""],
    ["group", -26, 9, 17, 19, 68, 207, 211, 215, 216, 218, 221, 224, 234, 237, 243, 245, 247, 249, 252, 258, 264, 266, 268, 270, 272, 274, 275, "Statement", -34, 13, 14, 32, 35, 36, 42, 51, 54, 55, 57, 62, 70, 72, 76, 80, 82, 84, 85, 110, 111, 120, 121, 136, 139, 141, 142, 143, 144, 145, 147, 148, 167, 169, 171, "Expression", -23, 31, 33, 37, 41, 43, 45, 173, 175, 177, 178, 180, 181, 182, 184, 185, 186, 188, 189, 190, 201, 203, 205, 206, "Type", -3, 88, 103, 109, "ClassItem"],
    ["openedBy", 23, "<", 38, "InterpolationStart", 56, "[", 60, "{", 73, "(", 160, "JSXStartCloseTag"],
    ["closedBy", -2, 24, 168, ">", 40, "InterpolationEnd", 50, "]", 61, "}", 74, ")", 165, "JSXEndTag"]
  ],
  propSources: [pN],
  skippedNodes: [0, 5, 6, 278],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$i&j(Wp(Z!b'|0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(X#S$i&j'}0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$i&j(Wp(Z!b'}0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$i&j!p),Q(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(V':f$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$i&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$d`$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$d``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$d`$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(Z!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$d`(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$i&j(Wp(Z!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$i&j(Wp(Z!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$i&j(Z!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$i&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(Z!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$i&j(WpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(WpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Wp(Z!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$i&j(o%1l(Wp(Z!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$i&j(Wp(Z!b$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$i&j(Wp(Z!b$]#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$i&j(Wp(Z!b#p(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$i&j$Q(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(z+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$i&j#z(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(Y';W$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$i&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$d`$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(WpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$d`(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$i&j(Wp(Z!b(U%&f#q(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$i&j(Wp(Z!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$i&j(Wp(Z!br+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!]+Jf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$i&j(Wp(Z!b!Q.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_![!L^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$i&j(Wp(Z!b#o(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$i&j(Z!b!X7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$i&j!X7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$i&j!X7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!X7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!X7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$i&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$i&j(Z!b!X7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(Z!b!X7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(Z!b!X7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(Z!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$i&j(Z!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$i&j(Wp!X7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$i&j(Wp!X7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Wp!X7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Wp!X7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(WpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$i&j(WpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$i&j(Wp(Z!b!X7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Wp(Z!b!X7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Wp(Z!b!X7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Wp(Z!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$i&j(Wp(Z!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$i&j(Wp(Z!b(O0/l!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$i&j(Wp(Z!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$i&j(Z!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$i&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(Z!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$i&j(WpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(WpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Wp(Z!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$i&j$Q(Ch(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Z#t$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!g$b$i&j$O)Lv(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#R-<U(Wp(Z!b$n7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$k&j(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#r(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$Q(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#s(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#`*!Y$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#k(Cl$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#s(Ch$f#|$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#s(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(r(Ct$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$i&j#{(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!|$Ip$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!S0,v$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$i&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$i&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$i&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$i&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$i&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!Y#)l$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#x(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$i&j(Wp(Z!b(a+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$i&j(Wp(Z!b(T,2j$_#t(e$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$i&j(Wp(Z!b$_#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!_#Hb(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(y+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!^(CdvBr$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!q7`$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$i&j(Wp(Z!b'|0/l$]#t(T,2j(e$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$i&j(Wp(Z!b'}0/l$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [cN, hN, dN, uN, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, lN, new BO("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOx~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!U~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(c~~", 141, 340), new BO("j~RQYZXz{^~^O(Q~~aP!P!Qd~iO(R~~", 25, 323)],
  topRules: { Script: [0, 7], SingleExpression: [1, 276], SingleClassItem: [2, 277] },
  dialects: { jsx: 0, ts: 15175 },
  dynamicPrecedences: { 80: 1, 82: 1, 94: 1, 169: 1, 199: 1 },
  specialized: [{ term: 327, get: /* @__PURE__ */ m((s) => fN[s] || -1, "get") }, { term: 343, get: /* @__PURE__ */ m((s) => mN[s] || -1, "get") }, { term: 95, get: /* @__PURE__ */ m((s) => yN[s] || -1, "get") }],
  tokenPrec: 15201
}), hE = [
  /* @__PURE__ */ ki("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ ki("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ ki("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ ki("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ ki("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ ki(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ ki("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ ki(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ ki(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ ki('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ ki('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], wN = /* @__PURE__ */ hE.concat([
  /* @__PURE__ */ ki("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ ki("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ ki("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), jQ = /* @__PURE__ */ new xM(), dE = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function Xc(s) {
  return (t, e) => {
    let i = t.node.getChild("VariableDefinition");
    return i && e(i, s), !0;
  };
}
h(Xc, "ar$1");
m(Xc, "defID");
const vN = ["FunctionDeclaration"], ON = {
  FunctionDeclaration: /* @__PURE__ */ Xc("function"),
  ClassDeclaration: /* @__PURE__ */ Xc("class"),
  ClassExpression: /* @__PURE__ */ m(() => !0, "ClassExpression"),
  EnumDeclaration: /* @__PURE__ */ Xc("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ Xc("type"),
  NamespaceDeclaration: /* @__PURE__ */ Xc("namespace"),
  VariableDefinition(s, t) {
    s.matchContext(vN) || t(s, "variable");
  },
  TypeDefinition(s, t) {
    t(s, "type");
  },
  __proto__: null
};
function wP(s, t) {
  let e = jQ.get(t);
  if (e)
    return e;
  let i = [], r = !0;
  function n(a, o) {
    let l = s.sliceString(a.from, a.to);
    i.push({ label: l, type: o });
  }
  return h(n, "s"), m(n, "def"), t.cursor(Ut.IncludeAnonymous).iterate((a) => {
    if (r)
      r = !1;
    else if (a.name) {
      let o = ON[a.name];
      if (o && o(a, n) || dE.has(a.name))
        return !1;
    } else if (a.to - a.from > 8192) {
      for (let o of wP(s, a.node))
        i.push(o);
      return !1;
    }
  }), jQ.set(t, i), i;
}
h(wP, "xm$1");
m(wP, "getScope");
const UO = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, vP = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  "JSXText",
  "JSXAttributeValue",
  "JSXOpenTag",
  "JSXCloseTag",
  "JSXSelfClosingTag",
  ".",
  "?."
];
function uE(s) {
  let t = de(s.state).resolveInner(s.pos, -1);
  if (vP.indexOf(t.name) > -1)
    return null;
  let e = t.name == "VariableName" || t.to - t.from < 20 && UO.test(s.state.sliceDoc(t.from, t.to));
  if (!e && !s.explicit)
    return null;
  let i = [];
  for (let r = t; r; r = r.parent)
    dE.has(r.name) && (i = i.concat(wP(s.state.doc, r)));
  return {
    options: i,
    from: e ? t.from : s.pos,
    validFor: UO
  };
}
h(uE, "km$1");
m(uE, "localCompletionSource");
function Wv(s, t, e) {
  var i;
  let r = [];
  for (; ; ) {
    let n = t.firstChild, a;
    if (n?.name == "VariableName")
      return r.push(s(n)), { path: r.reverse(), name: e };
    if (n?.name == "MemberExpression" && ((i = a = n.lastChild) === null || i === void 0 ? void 0 : i.name) == "PropertyName")
      r.push(s(a)), t = n;
    else
      return null;
  }
}
h(Wv, "Ko$1");
m(Wv, "pathFor");
function pE(s) {
  let t = /* @__PURE__ */ m((i) => s.state.doc.sliceString(i.from, i.to), "read"), e = de(s.state).resolveInner(s.pos, -1);
  return e.name == "PropertyName" ? Wv(t, e.parent, t(e)) : (e.name == "." || e.name == "?.") && e.parent.name == "MemberExpression" ? Wv(t, e.parent, "") : vP.indexOf(e.name) > -1 ? null : e.name == "VariableName" || e.to - e.from < 20 && UO.test(t(e)) ? { path: [], name: t(e) } : e.name == "MemberExpression" ? Wv(t, e, "") : s.explicit ? { path: [], name: "" } : null;
}
h(pE, "Pm$1");
m(pE, "completionPath");
function fE(s, t) {
  let e = [], i = /* @__PURE__ */ new Set();
  for (let r = 0; ; r++) {
    for (let a of (Object.getOwnPropertyNames || Object.keys)(s)) {
      if (!/^[a-zA-Z_$\xaa-\uffdc][\w$\xaa-\uffdc]*$/.test(a) || i.has(a))
        continue;
      i.add(a);
      let o;
      try {
        o = s[a];
      } catch {
        continue;
      }
      e.push({
        label: a,
        type: typeof o == "function" ? /^[A-Z]/.test(a) ? "class" : t ? "function" : "method" : t ? "variable" : "property",
        boost: -r
      });
    }
    let n = Object.getPrototypeOf(s);
    if (!n)
      return e;
    s = n;
  }
}
h(fE, "wb$1");
m(fE, "enumeratePropertyCompletions");
function bN(s) {
  let t = /* @__PURE__ */ new Map();
  return (e) => {
    let i = pE(e);
    if (!i)
      return null;
    let r = s;
    for (let a of i.path)
      if (r = r[a], !r)
        return null;
    let n = t.get(r);
    return n || t.set(r, n = fE(r, !i.path.length)), {
      from: e.pos - i.name.length,
      options: n,
      validFor: UO
    };
  };
}
h(bN, "xb$1");
m(bN, "scopeCompletionSource");
const Ir = /* @__PURE__ */ zC.define({
  name: "javascript",
  parser: /* @__PURE__ */ gN.configure({
    props: [
      /* @__PURE__ */ zy.add({
        IfStatement: /* @__PURE__ */ Ow({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ Ow({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: aq,
        SwitchBody: /* @__PURE__ */ m((s) => {
          let t = s.textAfter, e = /^\s*\}/.test(t), i = /^\s*(case|default)\b/.test(t);
          return s.baseIndent + (e ? 0 : i ? 1 : 2) * s.unit;
        }, "SwitchBody"),
        Block: /* @__PURE__ */ aA({ closing: "}" }),
        ArrowFunction: /* @__PURE__ */ m((s) => s.baseIndent + s.unit, "ArrowFunction"),
        "TemplateString BlockComment": /* @__PURE__ */ m(() => null, "TemplateString BlockComment"),
        "Statement Property": /* @__PURE__ */ Ow({ except: /^\s*{/ }),
        JSXElement(s) {
          let t = /^\s*<\//.test(s.textAfter);
          return s.lineIndent(s.node.from) + (t ? 0 : s.unit);
        },
        JSXEscape(s) {
          let t = /\s*\}/.test(s.textAfter);
          return s.lineIndent(s.node.from) + (t ? 0 : s.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(s) {
          return s.column(s.node.from) + s.unit;
        }
      }),
      /* @__PURE__ */ b1.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": WC,
        BlockComment(s) {
          return { from: s.from + 2, to: s.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), mE = {
  test: /* @__PURE__ */ m((s) => /^JSX/.test(s.name), "test"),
  facet: /* @__PURE__ */ O1({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, yE = /* @__PURE__ */ Ir.configure({ dialect: "ts" }, "typescript"), gE = /* @__PURE__ */ Ir.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ LC.add((s) => s.isTop ? [mE] : void 0)]
}), wE = /* @__PURE__ */ Ir.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ LC.add((s) => s.isTop ? [mE] : void 0)]
}, "typescript");
let vE = /* @__PURE__ */ m((s) => ({ label: s, type: "keyword" }), "kwCompletion");
const OE = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(vE), $N = /* @__PURE__ */ OE.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(vE));
function bE(s = {}) {
  let t = s.jsx ? s.typescript ? wE : gE : s.typescript ? yE : Ir, e = s.typescript ? wN.concat($N) : hE.concat(OE);
  return new fy(t, [
    Ir.data.of({
      autocomplete: CA(vP, XC(e))
    }),
    Ir.data.of({
      autocomplete: uE
    }),
    s.jsx ? kN : []
  ]);
}
h(bE, "Tm$1");
m(bE, "javascript");
function $E(s) {
  for (; ; ) {
    if (s.name == "JSXOpenTag" || s.name == "JSXSelfClosingTag" || s.name == "JSXFragmentTag")
      return s;
    if (s.name == "JSXEscape" || !s.parent)
      return null;
    s = s.parent;
  }
}
h($E, "Pb$1");
m($E, "findOpenTag");
function U5(s, t, e = s.length) {
  for (let i = t?.firstChild; i; i = i.nextSibling)
    if (i.name == "JSXIdentifier" || i.name == "JSXBuiltin" || i.name == "JSXNamespacedName" || i.name == "JSXMemberExpression")
      return s.sliceString(i.from, Math.min(i.to, e));
  return "";
}
h(U5, "YO");
m(U5, "elementName$1");
const xN = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), kN = /* @__PURE__ */ Mt.inputHandler.of((s, t, e, i, r) => {
  if ((xN ? s.composing : s.compositionStarted) || s.state.readOnly || t != e || i != ">" && i != "/" || !Ir.isActiveAt(s.state, t, -1))
    return !1;
  let n = r(), { state: a } = n, o = a.changeByRange((l) => {
    var d;
    let { head: u } = l, p = de(a).resolveInner(u - 1, -1), f;
    if (p.name == "JSXStartTag" && (p = p.parent), !(a.doc.sliceString(u - 1, u) != i || p.name == "JSXAttributeValue" && p.to > u)) {
      if (i == ">" && p.name == "JSXFragmentTag")
        return { range: l, changes: { from: u, insert: "</>" } };
      if (i == "/" && p.name == "JSXStartCloseTag") {
        let y = p.parent, g = y.parent;
        if (g && y.from == u - 2 && ((f = U5(a.doc, g.firstChild, u)) || ((d = g.firstChild) === null || d === void 0 ? void 0 : d.name) == "JSXFragmentTag")) {
          let O = `${f}>`;
          return { range: nt.cursor(u + O.length, -1), changes: { from: u, insert: O } };
        }
      } else if (i == ">") {
        let y = $E(p);
        if (y && y.name == "JSXOpenTag" && !/^\/?>|^<\//.test(a.doc.sliceString(u, u + 2)) && (f = U5(a.doc, y, u)))
          return { range: l, changes: { from: u, insert: `</${f}>` } };
      }
    }
    return { range: l };
  });
  return o.changes.empty ? !1 : (s.dispatch([
    n,
    a.update(o, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
});
function SN(s, t) {
  return t || (t = {
    parserOptions: { ecmaVersion: 2019, sourceType: "module" },
    env: { browser: !0, node: !0, es6: !0, es2015: !0, es2017: !0, es2020: !0 },
    rules: {}
  }, s.getRules().forEach((e, i) => {
    var r;
    !((r = e.meta.docs) === null || r === void 0) && r.recommended && (t.rules[i] = 2);
  })), (e) => {
    let { state: i } = e, r = [];
    for (let { from: n, to: a } of Ir.findRegions(i)) {
      let o = i.doc.lineAt(n), l = { line: o.number - 1, col: n - o.from, pos: n };
      for (let d of s.verify(i.sliceDoc(n, a), t))
        r.push(xE(d, i.doc, l));
    }
    return r;
  };
}
h(SN, "Rb$1");
m(SN, "esLint");
function H5(s, t, e, i) {
  return e.line(s + i.line).from + t + (s == 1 ? i.col - 1 : -1);
}
h(H5, "WO");
m(H5, "mapPos");
function xE(s, t, e) {
  let i = H5(s.line, s.column, t, e), r = {
    from: i,
    to: s.endLine != null && s.endColumn != 1 ? H5(s.endLine, s.endColumn, t, e) : i,
    message: s.message,
    source: s.ruleId ? "eslint:" + s.ruleId : "eslint",
    severity: s.severity == 1 ? "warning" : "error"
  };
  if (s.fix) {
    let { range: n, text: a } = s.fix, o = n[0] + e.pos - i, l = n[1] + e.pos - i;
    r.actions = [{
      name: "fix",
      apply(d, u) {
        d.dispatch({ changes: { from: u + o, to: u + l, insert: a }, scrollIntoView: !0 });
      }
    }];
  }
  return r;
}
h(xE, "vb$1");
m(xE, "translateDiagnostic");
const sg = ["_blank", "_self", "_top", "_parent"], I2 = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], D2 = ["get", "post", "put", "delete"], V2 = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], Ki = ["true", "false"], mt = {}, CN = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: sg,
      hreflang: null
    }
  },
  abbr: mt,
  address: mt,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: mt,
  aside: mt,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: mt,
  base: { attrs: { href: null, target: sg } },
  bdi: mt,
  bdo: mt,
  blockquote: { attrs: { cite: null } },
  body: mt,
  br: mt,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: V2,
      formmethod: D2,
      formnovalidate: ["novalidate"],
      formtarget: sg,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: mt,
  center: mt,
  cite: mt,
  code: mt,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: mt,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: mt,
  div: mt,
  dl: mt,
  dt: mt,
  em: mt,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: mt,
  figure: mt,
  footer: mt,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": I2,
      autocomplete: ["on", "off"],
      enctype: V2,
      method: D2,
      novalidate: ["novalidate"],
      target: sg
    }
  },
  h1: mt,
  h2: mt,
  h3: mt,
  h4: mt,
  h5: mt,
  h6: mt,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: mt,
  hgroup: mt,
  hr: mt,
  html: {
    attrs: { manifest: null }
  },
  i: mt,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: V2,
      formmethod: D2,
      formnovalidate: ["novalidate"],
      formtarget: sg,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: mt,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: mt,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: mt,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: I2,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: mt,
  noscript: mt,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: mt,
  param: { attrs: { name: null, value: null } },
  pre: mt,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: mt,
  rt: mt,
  ruby: mt,
  samp: mt,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: I2
    }
  },
  section: mt,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: mt,
  source: { attrs: { src: null, type: null, media: null } },
  span: mt,
  strong: mt,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: mt,
  summary: mt,
  sup: mt,
  table: mt,
  tbody: mt,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: mt,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: mt,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: mt,
  time: { attrs: { datetime: null } },
  title: mt,
  tr: mt,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: mt,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: mt
}, kE = {
  accesskey: null,
  class: null,
  contenteditable: Ki,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Ki,
  autocorrect: Ki,
  autocapitalize: Ki,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Ki,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Ki,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Ki,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Ki,
  "aria-hidden": Ki,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Ki,
  "aria-multiselectable": Ki,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Ki,
  "aria-relevant": null,
  "aria-required": Ki,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, SE = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((s) => "on" + s);
for (let s of SE)
  kE[s] = null;
var Du;
const CE = (Du = class {
  constructor(t, e) {
    this.tags = { ...CN, ...t }, this.globalAttrs = { ...kE, ...e }, this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}, h(Du, "Nc"), Du);
m(CE, "Schema");
let qw = CE;
qw.default = /* @__PURE__ */ new qw();
function dl(s, t, e = s.length) {
  if (!t)
    return "";
  let i = t.firstChild, r = i && i.getChild("TagName");
  return r ? s.sliceString(r.from, Math.min(r.to, e)) : "";
}
h(dl, "Ki$1");
m(dl, "elementName");
function ul(s, t = !1) {
  for (; s; s = s.parent)
    if (s.name == "Element")
      if (t)
        t = !1;
      else
        return s;
  return null;
}
h(ul, "Ji$1");
m(ul, "findParentElement");
function OP(s, t, e) {
  return e.tags[dl(s, ul(t))]?.children || e.allTags;
}
h(OP, "Mm$1");
m(OP, "allowedChildren");
function db(s, t) {
  let e = [];
  for (let i = ul(t); i && !i.type.isTop; i = ul(i.parent)) {
    let r = dl(s, i);
    if (r && i.lastChild.name == "CloseTag")
      break;
    r && e.indexOf(r) < 0 && (t.name == "EndTag" || t.from >= i.firstChild.to) && e.push(r);
  }
  return e;
}
h(db, "Ih$1");
m(db, "openTags");
const PE = /^[:\-\.\w\u00b7-\uffff]*$/;
function Y5(s, t, e, i, r) {
  let n = /\s*>/.test(s.sliceDoc(r, r + 5)) ? "" : ">", a = ul(e, e.name == "StartTag" || e.name == "TagName");
  return {
    from: i,
    to: r,
    options: OP(s.doc, a, t).map((o) => ({ label: o, type: "type" })).concat(db(s.doc, e).map((o, l) => ({
      label: "/" + o,
      apply: "/" + o + n,
      type: "type",
      boost: 99 - l
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
h(Y5, "VO");
m(Y5, "completeTag");
function G5(s, t, e, i) {
  let r = /\s*>/.test(s.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: e,
    to: i,
    options: db(s.doc, t).map((n, a) => ({ label: n, apply: n + r, type: "type", boost: 99 - a })),
    validFor: PE
  };
}
h(G5, "UO");
m(G5, "completeCloseTag");
function QE(s, t, e, i) {
  let r = [], n = 0;
  for (let a of OP(s.doc, e, t))
    r.push({ label: "<" + a, type: "type" });
  for (let a of db(s.doc, e))
    r.push({ label: "</" + a + ">", type: "type", boost: 99 - n++ });
  return { from: i, to: i, options: r, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
h(QE, "Ab$1");
m(QE, "completeStartTag");
function TE(s, t, e, i, r) {
  let n = ul(e), a = n ? t.tags[dl(s.doc, n)] : null, o = a && a.attrs ? Object.keys(a.attrs) : [], l = a && a.globalAttrs === !1 ? o : o.length ? o.concat(t.globalAttrNames) : t.globalAttrNames;
  return {
    from: i,
    to: r,
    options: l.map((d) => ({ label: d, type: "property" })),
    validFor: PE
  };
}
h(TE, "Lb$1");
m(TE, "completeAttrName");
function ME(s, t, e, i, r) {
  var n;
  let a = (n = e.parent) === null || n === void 0 ? void 0 : n.getChild("AttributeName"), o = [], l;
  if (a) {
    let d = s.sliceDoc(a.from, a.to), u = t.globalAttrs[d];
    if (!u) {
      let p = ul(e), f = p ? t.tags[dl(s.doc, p)] : null;
      u = f?.attrs && f.attrs[d];
    }
    if (u) {
      let p = s.sliceDoc(i, r).toLowerCase(), f = '"', y = '"';
      /^['"]/.test(p) ? (l = p[0] == '"' ? /^[^"]*$/ : /^[^']*$/, f = "", y = s.sliceDoc(r, r + 1) == p[0] ? "" : p[0], p = p.slice(1), i++) : l = /^[^\s<>='"]*$/;
      for (let g of u)
        o.push({ label: g, apply: f + g + y, type: "constant" });
    }
  }
  return { from: i, to: r, options: o, validFor: l };
}
h(ME, "_b$1");
m(ME, "completeAttrValue");
function bP(s, t) {
  let { state: e, pos: i } = t, r = de(e).resolveInner(i, -1), n = r.resolve(i);
  for (let a = i, o; n == r && (o = r.childBefore(a)); ) {
    let l = o.lastChild;
    if (!l || !l.type.isError || l.from < l.to)
      break;
    n = r = o, a = l.from;
  }
  return r.name == "TagName" ? r.parent && /CloseTag$/.test(r.parent.name) ? G5(e, r, r.from, i) : Y5(e, s, r, r.from, i) : r.name == "StartTag" || r.name == "IncompleteTag" ? Y5(e, s, r, i, i) : r.name == "StartCloseTag" || r.name == "IncompleteCloseTag" ? G5(e, r, i, i) : r.name == "OpenTag" || r.name == "SelfClosingTag" || r.name == "AttributeName" ? TE(e, s, r, r.name == "AttributeName" ? r.from : i, i) : r.name == "Is" || r.name == "AttributeValue" || r.name == "UnquotedAttributeValue" ? ME(e, s, r, r.name == "Is" ? i : r.from, i) : t.explicit && (n.name == "Element" || n.name == "Text" || n.name == "Document") ? QE(e, s, r, i) : null;
}
h(bP, "Cm$1");
m(bP, "htmlCompletionFor");
function AE(s) {
  return bP(qw.default, s);
}
h(AE, "Xm$1");
m(AE, "htmlCompletionSource");
function RE(s) {
  let { extraTags: t, extraGlobalAttributes: e } = s, i = e || t ? new qw(t, e) : qw.default;
  return (r) => bP(i, r);
}
h(RE, "Em$1");
m(RE, "htmlCompletionSourceWith");
const PN = /* @__PURE__ */ Ir.parser.configure({ top: "SingleExpression" }), EE = [
  {
    tag: "script",
    attrs: /* @__PURE__ */ m((s) => s.type == "text/typescript" || s.lang == "ts", "attrs"),
    parser: yE.parser
  },
  {
    tag: "script",
    attrs: /* @__PURE__ */ m((s) => s.type == "text/babel" || s.type == "text/jsx", "attrs"),
    parser: gE.parser
  },
  {
    tag: "script",
    attrs: /* @__PURE__ */ m((s) => s.type == "text/typescript-jsx", "attrs"),
    parser: wE.parser
  },
  {
    tag: "script",
    attrs(s) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(s.type);
    },
    parser: PN
  },
  {
    tag: "script",
    attrs(s) {
      return !s.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(s.type);
    },
    parser: Ir.parser
  },
  {
    tag: "style",
    attrs(s) {
      return (!s.lang || s.lang == "css") && (!s.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(s.type));
    },
    parser: jO.parser
  }
], _E = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ jO.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ SE.map((s) => ({ name: s, parser: Ir.parser }))), LE = /* @__PURE__ */ zC.define({
  name: "html",
  parser: /* @__PURE__ */ oB.configure({
    props: [
      /* @__PURE__ */ zy.add({
        Element(s) {
          let t = /^(\s*)(<\/)?/.exec(s.textAfter);
          return s.node.to <= s.pos + t[0].length ? s.continue() : s.lineIndent(s.node.from) + (t[2] ? 0 : s.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(s) {
          return s.column(s.node.from) + s.unit;
        },
        Document(s) {
          if (s.pos + /\s*/.exec(s.textAfter)[0].length < s.node.to)
            return s.continue();
          let t = null, e;
          for (let i = s.node; ; ) {
            let r = i.lastChild;
            if (!r || r.name != "Element" || r.to != i.to)
              break;
            t = i = r;
          }
          return t && !((e = t.lastChild) && (e.name == "CloseTag" || e.name == "SelfClosingTag")) ? s.lineIndent(t.from) + s.unit : null;
        }
      }),
      /* @__PURE__ */ b1.add({
        Element(s) {
          let t = s.firstChild, e = s.lastChild;
          return !t || t.name != "OpenTag" ? null : { from: t.to, to: e.name == "CloseTag" ? e.from : s.to };
        }
      }),
      /* @__PURE__ */ dA.add({
        "OpenTag CloseTag": /* @__PURE__ */ m((s) => s.getChild("TagName"), "OpenTag CloseTag")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-_"
  }
}), Fv = /* @__PURE__ */ LE.configure({
  wrap: /* @__PURE__ */ yP(EE, _E)
});
function zE(s = {}) {
  let t = "", e;
  s.matchClosingTags === !1 && (t = "noMatch"), s.selfClosingTags === !0 && (t = (t ? t + " " : "") + "selfClosing"), (s.nestedLanguages && s.nestedLanguages.length || s.nestedAttributes && s.nestedAttributes.length) && (e = yP((s.nestedLanguages || []).concat(EE), (s.nestedAttributes || []).concat(_E)));
  let i = e ? LE.configure({ wrap: e, dialect: t }) : t ? Fv.configure({ dialect: t }) : Fv;
  return new fy(i, [
    Fv.data.of({ autocomplete: RE(s) }),
    s.autoCloseTags !== !1 ? QN : [],
    bE().support,
    lE().support
  ]);
}
h(zE, "Um$1");
m(zE, "html");
const UQ = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), QN = /* @__PURE__ */ Mt.inputHandler.of((s, t, e, i, r) => {
  if (s.composing || s.state.readOnly || t != e || i != ">" && i != "/" || !Fv.isActiveAt(s.state, t, -1))
    return !1;
  let n = r(), { state: a } = n, o = a.changeByRange((l) => {
    var d, u, p;
    let f = a.doc.sliceString(l.from - 1, l.to) == i, { head: y } = l, g = de(a).resolveInner(y, -1), O;
    if (f && i == ">" && g.name == "EndTag") {
      let k = g.parent;
      if (((u = (d = k.parent) === null || d === void 0 ? void 0 : d.lastChild) === null || u === void 0 ? void 0 : u.name) != "CloseTag" && (O = dl(a.doc, k.parent, y)) && !UQ.has(O)) {
        let $ = y + (a.doc.sliceString(y, y + 1) === ">" ? 1 : 0), T = `</${O}>`;
        return { range: l, changes: { from: y, to: $, insert: T } };
      }
    } else if (f && i == "/" && g.name == "IncompleteCloseTag") {
      let k = g.parent;
      if (g.from == y - 2 && ((p = k.lastChild) === null || p === void 0 ? void 0 : p.name) != "CloseTag" && (O = dl(a.doc, k, y)) && !UQ.has(O)) {
        let $ = y + (a.doc.sliceString(y, y + 1) === ">" ? 1 : 0), T = `${O}>`;
        return {
          range: nt.cursor(y + T.length, -1),
          changes: { from: y, to: $, insert: T }
        };
      }
    }
    return { range: l };
  });
  return o.changes.empty ? !1 : (s.dispatch([
    n,
    a.update(o, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), IE = /* @__PURE__ */ O1({ commentTokens: { block: { open: "<!--", close: "-->" } } }), DE = /* @__PURE__ */ new Et(), VE = /* @__PURE__ */ aZ.configure({
  props: [
    /* @__PURE__ */ b1.add((s) => !s.is("Block") || s.is("Document") || HO(s) != null || WE(s) ? void 0 : (t, e) => ({ from: e.doc.lineAt(t.from).to, to: t.to })),
    /* @__PURE__ */ DE.add(HO),
    /* @__PURE__ */ zy.add({
      Document: /* @__PURE__ */ m(() => null, "Document")
    }),
    /* @__PURE__ */ Vn.add({
      Document: IE
    })
  ]
});
function HO(s) {
  let t = /^(?:ATX|Setext)Heading(\d)$/.exec(s.name);
  return t ? +t[1] : void 0;
}
h(HO, "ih$1");
m(HO, "isHeading");
function WE(s) {
  return s.name == "OrderedList" || s.name == "BulletList";
}
h(WE, "Cb$1");
m(WE, "isList");
function FE(s, t) {
  let e = s;
  for (; ; ) {
    let i = e.nextSibling, r;
    if (!i || (r = HO(i.type)) != null && r <= t)
      break;
    e = i;
  }
  return e.to;
}
h(FE, "Xb$1");
m(FE, "findSectionEnd");
const TN = /* @__PURE__ */ oq.of((s, t, e) => {
  for (let i = de(s).resolveInner(e, -1); i && !(i.from < t); i = i.parent) {
    let r = i.type.prop(DE);
    if (r == null)
      continue;
    let n = FE(i, r);
    if (n > e)
      return { from: e, to: n };
  }
  return null;
});
function ub(s) {
  return new ar(IE, s, [], "markdown");
}
h(ub, "zh$1");
m(ub, "mkLang");
const MN = /* @__PURE__ */ ub(VE), AN = /* @__PURE__ */ VE.configure([fZ, yZ, mZ, gZ, {
  props: [
    /* @__PURE__ */ b1.add({
      Table: /* @__PURE__ */ m((s, t) => ({ from: t.doc.lineAt(s.from).to, to: s.to }), "Table")
    })
  ]
}]), YO = /* @__PURE__ */ ub(AN);
function qE(s, t) {
  return (e) => {
    if (e && s) {
      let i = null;
      if (e = /\S*/.exec(e)[0], typeof s == "function" ? i = s(e) : i = OQ.matchLanguageName(s, e, !0), i instanceof OQ)
        return i.support ? i.support.language.parser : IO.getSkippingParser(i.load());
      if (i)
        return i.parser;
    }
    return t ? t.parser : null;
  };
}
h(qE, "Wb$1");
m(qE, "getCodeParser");
var Vu;
const ZE = (Vu = class {
  constructor(t, e, i, r, n, a, o) {
    this.node = t, this.from = e, this.to = i, this.spaceBefore = r, this.spaceAfter = n, this.type = a, this.item = o;
  }
  blank(t, e = !0) {
    let i = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
    if (t != null) {
      for (; i.length < t; )
        i += " ";
      return i;
    } else {
      for (let r = this.to - this.from - i.length - this.spaceAfter.length; r > 0; r--)
        i += " ";
      return i + (e ? this.spaceAfter : "");
    }
  }
  marker(t, e) {
    let i = this.node.name == "OrderedList" ? String(+xP(this.item, t)[2] + e) : "";
    return this.spaceBefore + i + this.type + this.spaceAfter;
  }
}, h(Vu, "Gc"), Vu);
m(ZE, "Context");
let W2 = ZE;
function $P(s, t) {
  let e = [], i = [];
  for (let r = s; r; r = r.parent) {
    if (r.name == "FencedCode")
      return i;
    (r.name == "ListItem" || r.name == "Blockquote") && e.push(r);
  }
  for (let r = e.length - 1; r >= 0; r--) {
    let n = e[r], a, o = t.lineAt(n.from), l = n.from - o.from;
    if (n.name == "Blockquote" && (a = /^ *>( ?)/.exec(o.text.slice(l))))
      i.push(new W2(n, l, l + a[0].length, "", a[1], ">", null));
    else if (n.name == "ListItem" && n.parent.name == "OrderedList" && (a = /^( *)\d+([.)])( *)/.exec(o.text.slice(l)))) {
      let d = a[3], u = a[0].length;
      d.length >= 4 && (d = d.slice(0, d.length - 4), u -= 4), i.push(new W2(n.parent, l, l + u, a[1], d, a[2], n));
    } else if (n.name == "ListItem" && n.parent.name == "BulletList" && (a = /^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(o.text.slice(l)))) {
      let d = a[4], u = a[0].length;
      d.length > 4 && (d = d.slice(0, d.length - 4), u -= 4);
      let p = a[2];
      a[3] && (p += a[3].replace(/[xX]/, " ")), i.push(new W2(n.parent, l, l + u, a[1], d, p, n));
    }
  }
  return i;
}
h($P, "Dm$1");
m($P, "getContext");
function xP(s, t) {
  return /^(\s*)(\d+)(?=[.)])/.exec(t.sliceString(s.from, s.from + 10));
}
h(xP, "Nm$1");
m(xP, "itemNumber");
function qv(s, t, e, i = 0) {
  for (let r = -1, n = s; ; ) {
    if (n.name == "ListItem") {
      let o = xP(n, t), l = +o[2];
      if (r >= 0) {
        if (l != r + 1)
          return;
        e.push({ from: n.from + o[1].length, to: n.from + o[0].length, insert: String(r + 2 + i) });
      }
      r = l;
    }
    let a = n.nextSibling;
    if (!a)
      break;
    n = a;
  }
}
h(qv, "il$1");
m(qv, "renumberList");
function pb(s, t) {
  let e = /^[ \t]*/.exec(s)[0].length;
  if (!e || t.facet(eb) != "	")
    return s;
  let i = ua(s, 4, e), r = "";
  for (let n = i; n > 0; )
    n >= 4 ? (r += "	", n -= 4) : (r += " ", n--);
  return r + s.slice(e);
}
h(pb, "jh$1");
m(pb, "normalizeIndent");
const RN = /* @__PURE__ */ m((s = {}) => ({ state: t, dispatch: e }) => {
  let i = de(t), { doc: r } = t, n = null, a = t.changeByRange((o) => {
    if (!o.empty || !YO.isActiveAt(t, o.from, -1) && !YO.isActiveAt(t, o.from, 1))
      return n = { range: o };
    let l = o.from, d = r.lineAt(l), u = $P(i.resolveInner(l, -1), r);
    for (; u.length && u[u.length - 1].from > l - d.from; )
      u.pop();
    if (!u.length)
      return n = { range: o };
    let p = u[u.length - 1];
    if (p.to - p.spaceAfter.length > l - d.from)
      return n = { range: o };
    let f = l >= p.to - p.spaceAfter.length && !/\S/.test(d.text.slice(p.to));
    if (p.item && f) {
      let $ = p.node.firstChild, T = p.node.getChild("ListItem", "ListItem");
      if ($.to >= l || T && T.to < l || d.from > 0 && !/[^\s>]/.test(r.lineAt(d.from - 1).text) || s.nonTightLists === !1) {
        let _ = u.length > 1 ? u[u.length - 2] : null, D, A = "";
        _ && _.item ? (D = d.from + _.from, A = _.marker(r, 1)) : D = d.from + (_ ? _.to : 0);
        let z = [{ from: D, to: l, insert: A }];
        return p.node.name == "OrderedList" && qv(p.item, r, z, -2), _ && _.node.name == "OrderedList" && qv(_.item, r, z), { range: nt.cursor(D + A.length), changes: z };
      } else {
        let _ = J5(u, t, d);
        return {
          range: nt.cursor(l + _.length + 1),
          changes: { from: d.from, insert: _ + t.lineBreak }
        };
      }
    }
    if (p.node.name == "Blockquote" && f && d.from) {
      let $ = r.lineAt(d.from - 1), T = />\s*$/.exec($.text);
      if (T && T.index == p.from) {
        let _ = t.changes([
          { from: $.from + T.index, to: $.to },
          { from: d.from + p.from, to: d.to }
        ]);
        return { range: o.map(_), changes: _ };
      }
    }
    let y = [];
    p.node.name == "OrderedList" && qv(p.item, r, y);
    let g = p.item && p.item.from < d.from, O = "";
    if (!g || /^[\s\d.)\-+*>]*/.exec(d.text)[0].length >= p.to)
      for (let $ = 0, T = u.length - 1; $ <= T; $++)
        O += $ == T && !g ? u[$].marker(r, 1) : u[$].blank($ < T ? ua(d.text, 4, u[$ + 1].from) - O.length : null);
    let k = l;
    for (; k > d.from && /\s/.test(d.text.charAt(k - d.from - 1)); )
      k--;
    return O = pb(O, t), BE(p.node, t.doc) && (O = J5(u, t, d) + t.lineBreak + O), y.push({ from: k, to: l, insert: t.lineBreak + O }), { range: nt.cursor(k + O.length + 1), changes: y };
  });
  return n ? !1 : (e(t.update(a, { scrollIntoView: !0, userEvent: "input" })), !0);
}, "insertNewlineContinueMarkupCommand"), EN = /* @__PURE__ */ RN();
function K5(s) {
  return s.name == "QuoteMark" || s.name == "ListMark";
}
h(K5, "zO");
m(K5, "isMark");
function BE(s, t) {
  if (s.name != "OrderedList" && s.name != "BulletList")
    return !1;
  let e = s.firstChild, i = s.getChild("ListItem", "ListItem");
  if (!i)
    return !1;
  let r = t.lineAt(e.to), n = t.lineAt(i.from), a = /^[\s>]*$/.test(r.text);
  return r.number + (a ? 0 : 1) < n.number;
}
h(BE, "Vb$1");
m(BE, "nonTightList");
function J5(s, t, e) {
  let i = "";
  for (let r = 0, n = s.length - 2; r <= n; r++)
    i += s[r].blank(r < n ? ua(e.text, 4, s[r + 1].from) - i.length : null, r < n);
  return pb(i, t);
}
h(J5, "jO");
m(J5, "blankLine");
function NE(s, t) {
  let e = s.resolveInner(t, -1), i = t;
  K5(e) && (i = e.from, e = e.parent);
  for (let r; r = e.childBefore(i); )
    if (K5(r))
      i = r.from;
    else if (r.name == "OrderedList" || r.name == "BulletList")
      e = r.lastChild, i = e.to;
    else
      break;
  return e;
}
h(NE, "Ub$1");
m(NE, "contextNodeForDelete");
const _N = /* @__PURE__ */ m(({ state: s, dispatch: t }) => {
  let e = de(s), i = null, r = s.changeByRange((n) => {
    let a = n.from, { doc: o } = s;
    if (n.empty && YO.isActiveAt(s, n.from)) {
      let l = o.lineAt(a), d = $P(NE(e, a), o);
      if (d.length) {
        let u = d[d.length - 1], p = u.to - u.spaceAfter.length + (u.spaceAfter ? 1 : 0);
        if (a - l.from > p && !/\S/.test(l.text.slice(p, a - l.from)))
          return {
            range: nt.cursor(l.from + p),
            changes: { from: l.from + p, to: a }
          };
        if (a - l.from == p && // Only apply this if we're on the line that has the
        // construct's syntax, or there's only indentation in the
        // target range
        (!u.item || l.from <= u.item.from || !/\S/.test(l.text.slice(0, u.to)))) {
          let f = l.from + u.from;
          if (u.item && u.node.from < u.item.from && /\S/.test(l.text.slice(u.from, u.to))) {
            let y = u.blank(ua(l.text, 4, u.to) - ua(l.text, 4, u.from));
            return f == l.from && (y = pb(y, s)), {
              range: nt.cursor(f + y.length),
              changes: { from: f, to: l.from + u.to, insert: y }
            };
          }
          if (f < a)
            return { range: nt.cursor(f), changes: { from: f, to: a } };
        }
      }
    }
    return i = { range: n };
  });
  return i ? !1 : (t(s.update(r, { scrollIntoView: !0, userEvent: "delete" })), !0);
}, "deleteMarkupBackward"), LN = [
  { key: "Enter", run: EN },
  { key: "Backspace", run: _N }
], XE = /* @__PURE__ */ zE({ matchClosingTags: !1 });
function zN(s = {}) {
  let { codeLanguages: t, defaultCodeLanguage: e, addKeymap: i = !0, base: { parser: r } = MN, completeHTMLTags: n = !0, pasteURLAsLink: a = !0, htmlTagLanguage: o = XE } = s;
  if (!(r instanceof dR))
    throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let l = s.extensions ? [s.extensions] : [], d = [o.support, TN], u;
  a && d.push(DN), e instanceof fy ? (d.push(e.support), u = e.language) : e && (u = e);
  let p = t || u ? qE(t, u) : void 0;
  l.push(xR({ codeParser: p, htmlParser: o.language.parser })), i && d.push(Ll.high(Y0.of(LN)));
  let f = ub(r.configure(l));
  return n && d.push(f.data.of({ autocomplete: jE })), new fy(f, d);
}
h(zN, "eg$1");
m(zN, "markdown");
function jE(s) {
  let { state: t, pos: e } = s, i = /<[:\-\.\w\u00b7-\uffff]*$/.exec(t.sliceDoc(e - 25, e));
  if (!i)
    return null;
  let r = de(t).resolveInner(e, -1);
  for (; r && !r.type.isTop; ) {
    if (r.name == "CodeBlock" || r.name == "FencedCode" || r.name == "ProcessingInstructionBlock" || r.name == "CommentBlock" || r.name == "Link" || r.name == "Image")
      return null;
    r = r.parent;
  }
  return {
    from: e - i[0].length,
    to: e,
    options: UE(),
    validFor: /^<[:\-\.\w\u00b7-\uffff]*$/
  };
}
h(jE, "Ib$1");
m(jE, "htmlTagCompletion");
let F2 = null;
function UE() {
  if (F2)
    return F2;
  let s = AE(new NC(Be.create({ extensions: XE }), 0, !0));
  return F2 = s ? s.options : [];
}
h(UE, "zb$1");
m(UE, "htmlTagCompletions");
const IN = /code|horizontalrule|html|link|comment|processing|escape|entity|image|mark|url/i, DN = /* @__PURE__ */ Mt.domEventHandlers({
  paste: /* @__PURE__ */ m((s, t) => {
    var e;
    let { main: i } = t.state.selection;
    if (i.empty)
      return !1;
    let r = (e = s.clipboardData) === null || e === void 0 ? void 0 : e.getData("text/plain");
    if (!r || !/^(https?:\/\/|mailto:|xmpp:|www\.)/.test(r) || (/^www\./.test(r) && (r = "https://" + r), !YO.isActiveAt(t.state, i.from, 1)))
      return !1;
    let n = de(t.state), a = !1;
    return n.iterate({
      from: i.from,
      to: i.to,
      enter: /* @__PURE__ */ m((o) => {
        (o.from > i.from || IN.test(o.name)) && (a = !0);
      }, "enter"),
      leave: /* @__PURE__ */ m((o) => {
        o.to < i.to && (a = !0);
      }, "leave")
    }), a ? !1 : (t.dispatch({
      changes: [{ from: i.from, insert: "[" }, { from: i.to, insert: `](${r})` }],
      userEvent: "input.paste",
      scrollIntoView: !0
    }), !0);
  }, "paste")
});
function VN(s) {
  return new fy(pq.define(s));
}
h(VN, "b$1");
m(VN, "legacy");
function WN(s) {
  return import(
    /* webpackIgnore: true */
    /* @vite-ignore */
    new URL("./@codemirror/lang-sql/dist/index-BV9u_JGn.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
  ).then((t) => t.sql({ dialect: t[s] }));
}
h(WN, "mt$2");
m(WN, "sql");
function FN(s) {
  const t = new CustomEvent("wy-submit", { bubbles: !0 });
  return s.dom.dispatchEvent(t);
}
h(FN, "ig$1");
m(FN, "softSubmit");
const HQ = new DF({
  regexp: /(\[(.+?)\])(\(@u(\d+)\))/g,
  decoration: /* @__PURE__ */ m((s) => se.replace({
    // NOTE: can't use backspace to go "up one row" when inclusive is false
    inclusive: !0,
    widget: new qN(s)
  }), "decoration")
});
var Wu;
const HE = (Wu = class extends zl {
  constructor(t) {
    super(), this.match = t;
  }
  eq(t) {
    return t.match[1] === this.match[1];
  }
  toDOM() {
    Se();
    const t = document.createElement("span");
    return t.className = "wy-mention", t.part = "wy-mention", t.innerHTML = "@" + (typeof this.match[5] < "u" ? this.match[5] : this.match[2]), t;
  }
  ignoreEvent() {
    return !1;
  }
}, h(Wu, "Fc"), Wu);
m(HE, "MentionWidget");
let qN = HE;
rn.fromClass(
  class {
    constructor(s) {
      this.mentions = HQ.createDeco(s);
    }
    update(s) {
      this.mentions = HQ.updateDeco(s, this.mentions);
    }
  },
  {
    decorations: /* @__PURE__ */ m((s) => s.mentions, "decorations"),
    provide: /* @__PURE__ */ m((s) => Mt.atomicRanges.of((t) => t.plugin(s)?.mentions || se.none), "provide")
  }
);
function ZN(s, t) {
  return ({ state: e, dispatch: i }) => {
    if (e.readOnly)
      return !1;
    let r = s(t, e);
    return r ? (i(e.update(r)), !0) : !1;
  };
}
h(ZN, "qh$1");
m(ZN, "command");
function kP(s, t) {
  let e = s.languageDataAt("commentTokens", t, 1);
  return e.length ? e[0] : {};
}
h(kP, "Bh$1");
m(kP, "getConfig");
const ng = 50;
function YE(s, { open: t, close: e }, i, r) {
  let n = s.sliceDoc(i - ng, i), a = s.sliceDoc(r, r + ng), o = /\s*$/.exec(n)[0].length, l = /^\s*/.exec(a)[0].length, d = n.length - o;
  if (n.slice(d - t.length, d) == t && a.slice(l, l + e.length) == e)
    return {
      open: { pos: i - o, margin: o && 1 },
      close: { pos: r + l, margin: l && 1 }
    };
  let u, p;
  r - i <= 2 * ng ? u = p = s.sliceDoc(i, r) : (u = s.sliceDoc(i, i + ng), p = s.sliceDoc(r - ng, r));
  let f = /^\s*/.exec(u)[0].length, y = /\s*$/.exec(p)[0].length, g = p.length - y - e.length;
  return u.slice(f, f + t.length) == t && p.slice(g, g + e.length) == e ? {
    open: {
      pos: i + f + t.length,
      margin: /\s/.test(u.charAt(f + t.length)) ? 1 : 0
    },
    close: {
      pos: r - y - e.length,
      margin: /\s/.test(p.charAt(g - 1)) ? 1 : 0
    }
  } : null;
}
h(YE, "tw$1");
m(YE, "findBlockComment");
function BN(s) {
  let t = [];
  for (let e of s.selection.ranges) {
    let i = s.doc.lineAt(e.from), r = e.to <= i.to ? i : s.doc.lineAt(e.to);
    r.from > i.from && r.from == e.to && (r = e.to == i.to + 1 ? i : s.doc.lineAt(e.to - 1));
    let n = t.length - 1;
    n >= 0 && t[n].to > i.from ? t[n].to = r.to : t.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: r.to });
  }
  return t;
}
h(BN, "iw$1");
m(BN, "selectedLineRanges");
function NN(s, t, e = t.selection.ranges) {
  let i = e.map((n) => kP(t, n.from).block);
  if (!i.every((n) => n))
    return null;
  let r = e.map((n, a) => YE(t, i[a], n.from, n.to));
  if (s != 2 && !r.every((n) => n))
    return { changes: t.changes(e.map((n, a) => r[a] ? [] : [{ from: n.from, insert: i[a].open + " " }, { from: n.to, insert: " " + i[a].close }])) };
  if (s != 1 && r.some((n) => n)) {
    let n = [];
    for (let a = 0, o; a < r.length; a++)
      if (o = r[a]) {
        let l = i[a], { open: d, close: u } = o;
        n.push({ from: d.pos - l.open.length, to: d.pos + d.margin }, { from: u.pos - u.margin, to: u.pos + l.close.length });
      }
    return { changes: n };
  }
  return null;
}
h(NN, "rg$1");
m(NN, "changeBlockComment");
function XN(s, t, e = t.selection.ranges) {
  let i = [], r = -1;
  for (let { from: n, to: a } of e) {
    let o = i.length, l = 1e9, d = kP(t, n).line;
    if (d) {
      for (let u = n; u <= a; ) {
        let p = t.doc.lineAt(u);
        if (p.from > r && (n == a || a > p.from)) {
          r = p.from;
          let f = /^\s*/.exec(p.text)[0].length, y = f == p.length, g = p.text.slice(f, f + d.length) == d ? f : -1;
          f < p.text.length && f < l && (l = f), i.push({ line: p, comment: g, token: d, indent: f, empty: y, single: !1 });
        }
        u = p.to + 1;
      }
      if (l < 1e9)
        for (let u = o; u < i.length; u++)
          i[u].indent < i[u].line.text.length && (i[u].indent = l);
      i.length == o + 1 && (i[o].single = !0);
    }
  }
  if (s != 2 && i.some((n) => n.comment < 0 && (!n.empty || n.single))) {
    let n = [];
    for (let { line: o, token: l, indent: d, empty: u, single: p } of i)
      (p || !u) && n.push({ from: o.from + d, insert: l + " " });
    let a = t.changes(n);
    return { changes: a, selection: t.selection.map(a, 1) };
  } else if (s != 1 && i.some((n) => n.comment >= 0)) {
    let n = [];
    for (let { line: a, comment: o, token: l } of i)
      if (o >= 0) {
        let d = a.from + o, u = d + l.length;
        a.text[u - a.from] == " " && u++, n.push({ from: d, to: u });
      }
    return { changes: n };
  }
  return null;
}
h(XN, "rw$1");
m(XN, "changeLineComment");
const tS = /* @__PURE__ */ yn.define(), jN = /* @__PURE__ */ yn.define(), UN = /* @__PURE__ */ Ct.define(), GE = /* @__PURE__ */ Ct.define({
  combine(s) {
    return iC(s, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: /* @__PURE__ */ m((t, e) => e, "joinToEvent")
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: /* @__PURE__ */ m((t, e) => (i, r) => t(i, r) || e(i, r), "joinToEvent")
    });
  }
}), KE = /* @__PURE__ */ mn.define({
  create() {
    return bw.empty;
  },
  update(s, t) {
    let e = t.state.facet(GE), i = t.annotation(tS);
    if (i) {
      let l = Bs.fromTransaction(t, i.selection), d = i.side, u = d == 0 ? s.undone : s.done;
      return l ? u = Zw(u, u.length, e.minDepth, l) : u = PP(u, t.startState.selection), new bw(d == 0 ? i.rest : u, d == 0 ? u : i.rest);
    }
    let r = t.annotation(jN);
    if ((r == "full" || r == "before") && (s = s.isolate()), t.annotation(Mi.addToHistory) === !1)
      return t.changes.empty ? s : s.addMapping(t.changes.desc);
    let n = Bs.fromTransaction(t), a = t.annotation(Mi.time), o = t.annotation(Mi.userEvent);
    return n ? s = s.addChanges(n, a, o, e, t) : t.selection && (s = s.addSelection(t.startState.selection, a, o, e.newGroupDelay)), (r == "full" || r == "after") && (s = s.isolate()), s;
  },
  toJSON(s) {
    return { done: s.done.map((t) => t.toJSON()), undone: s.undone.map((t) => t.toJSON()) };
  },
  fromJSON(s) {
    return new bw(s.done.map(Bs.fromJSON), s.undone.map(Bs.fromJSON));
  }
});
function HN(s = {}) {
  return [
    KE,
    GE.of(s),
    Mt.domEventHandlers({
      beforeinput(t, e) {
        let i = t.inputType == "historyUndo" ? YN : t.inputType == "historyRedo" ? GN : null;
        return i ? (t.preventDefault(), i(e)) : !1;
      }
    })
  ];
}
h(HN, "ow$1");
m(HN, "history");
function SP(s, t) {
  return function({ state: e, dispatch: i }) {
    if (!t && e.readOnly)
      return !1;
    let r = e.field(KE, !1);
    if (!r)
      return !1;
    let n = r.pop(s, e, t);
    return n ? (i(n), !0) : !1;
  };
}
h(SP, "xo$1");
m(SP, "cmd");
const YN = /* @__PURE__ */ SP(0, !1), GN = /* @__PURE__ */ SP(1, !1);
var cs;
const JE = (cs = class {
  constructor(t, e, i, r, n) {
    this.changes = t, this.effects = e, this.mapped = i, this.startSelection = r, this.selectionsAfter = n;
  }
  setSelAfter(t) {
    return new cs(this.changes, this.effects, this.mapped, this.startSelection, t);
  }
  toJSON() {
    var t, e, i;
    return {
      changes: (t = this.changes) === null || t === void 0 ? void 0 : t.toJSON(),
      mapped: (e = this.mapped) === null || e === void 0 ? void 0 : e.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((r) => r.toJSON())
    };
  }
  static fromJSON(t) {
    return new cs(t.changes && Dr.fromJSON(t.changes), [], t.mapped && fh.fromJSON(t.mapped), t.startSelection && nt.fromJSON(t.startSelection), t.selectionsAfter.map(nt.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(t, e) {
    let i = wr;
    for (let r of t.startState.facet(UN)) {
      let n = r(t);
      n.length && (i = i.concat(n));
    }
    return !i.length && t.changes.empty ? null : new cs(t.changes.invert(t.startState.doc), i, void 0, e || t.startState.selection, wr);
  }
  static selection(t) {
    return new cs(void 0, wr, void 0, void 0, t);
  }
}, h(cs, "Gt"), cs);
m(JE, "HistEvent");
let Bs = JE;
function Zw(s, t, e, i) {
  let r = t + 1 > e + 20 ? t - e - 1 : 0, n = s.slice(r, t);
  return n.push(i), n;
}
h(Zw, "Cs$1");
m(Zw, "updateBranch");
function t_(s, t) {
  let e = [], i = !1;
  return s.iterChangedRanges((r, n) => e.push(r, n)), t.iterChangedRanges((r, n, a, o) => {
    for (let l = 0; l < e.length; ) {
      let d = e[l++], u = e[l++];
      o >= d && a <= u && (i = !0);
    }
  }), i;
}
h(t_, "hw$1");
m(t_, "isAdjacent");
function e_(s, t) {
  return s.ranges.length == t.ranges.length && s.ranges.filter((e, i) => e.empty != t.ranges[i].empty).length === 0;
}
h(e_, "fw$1");
m(e_, "eqSelectionShape");
function CP(s, t) {
  return s.length ? t.length ? s.concat(t) : s : t;
}
h(CP, "lg$1");
m(CP, "conc");
const wr = [], KN = 200;
function PP(s, t) {
  if (s.length) {
    let e = s[s.length - 1], i = e.selectionsAfter.slice(Math.max(0, e.selectionsAfter.length - KN));
    return i.length && i[i.length - 1].eq(t) ? s : (i.push(t), Zw(s, s.length - 1, 1e9, e.setSelAfter(i)));
  } else
    return [Bs.selection([t])];
}
h(PP, "ag$1");
m(PP, "addSelection");
function i_(s) {
  let t = s[s.length - 1], e = s.slice();
  return e[s.length - 1] = t.setSelAfter(t.selectionsAfter.slice(0, t.selectionsAfter.length - 1)), e;
}
h(i_, "uw$1");
m(i_, "popSelection");
function Zv(s, t) {
  if (!s.length)
    return s;
  let e = s.length, i = wr;
  for (; e; ) {
    let r = r_(s[e - 1], t, i);
    if (r.changes && !r.changes.empty || r.effects.length) {
      let n = s.slice(0, e);
      return n[e - 1] = r, n;
    } else
      t = r.mapped, e--, i = r.selectionsAfter;
  }
  return i.length ? [Bs.selection(i)] : wr;
}
h(Zv, "nl$1");
m(Zv, "addMappingToBranch");
function r_(s, t, e) {
  let i = CP(s.selectionsAfter.length ? s.selectionsAfter.map((o) => o.map(t)) : wr, e);
  if (!s.changes)
    return Bs.selection(i);
  let r = s.changes.map(t), n = t.mapDesc(s.changes, !0), a = s.mapped ? s.mapped.composeDesc(n) : n;
  return new Bs(r, te.mapEffects(s.effects, t), a, s.startSelection.map(n), i);
}
h(r_, "Ow$1");
m(r_, "mapEvent");
const JN = /^(input\.type|delete)($|\.)/;
var hs;
const s_ = (hs = class {
  constructor(t, e, i = 0, r = void 0) {
    this.done = t, this.undone = e, this.prevTime = i, this.prevUserEvent = r;
  }
  isolate() {
    return this.prevTime ? new hs(this.done, this.undone) : this;
  }
  addChanges(t, e, i, r, n) {
    let a = this.done, o = a[a.length - 1];
    return o && o.changes && !o.changes.empty && t.changes && (!i || JN.test(i)) && (!o.selectionsAfter.length && e - this.prevTime < r.newGroupDelay && r.joinToEvent(n, t_(o.changes, t.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? a = Zw(a, a.length - 1, r.minDepth, new Bs(t.changes.compose(o.changes), CP(te.mapEffects(t.effects, o.changes), o.effects), o.mapped, o.startSelection, wr)) : a = Zw(a, a.length, r.minDepth, t), new hs(a, wr, e, i);
  }
  addSelection(t, e, i, r) {
    let n = this.done.length ? this.done[this.done.length - 1].selectionsAfter : wr;
    return n.length > 0 && e - this.prevTime < r && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && e_(n[n.length - 1], t) ? this : new hs(PP(this.done, t), this.undone, e, i);
  }
  addMapping(t) {
    return new hs(Zv(this.done, t), Zv(this.undone, t), this.prevTime, this.prevUserEvent);
  }
  pop(t, e, i) {
    let r = t == 0 ? this.done : this.undone;
    if (r.length == 0)
      return null;
    let n = r[r.length - 1], a = n.selectionsAfter[0] || e.selection;
    if (i && n.selectionsAfter.length)
      return e.update({
        selection: n.selectionsAfter[n.selectionsAfter.length - 1],
        annotations: tS.of({ side: t, rest: i_(r), selection: a }),
        userEvent: t == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (n.changes) {
      let o = r.length == 1 ? wr : r.slice(0, r.length - 1);
      return n.mapped && (o = Zv(o, n.mapped)), e.update({
        changes: n.changes,
        selection: n.startSelection,
        effects: n.effects,
        annotations: tS.of({ side: t, rest: o, selection: a }),
        filter: !1,
        userEvent: t == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}, h(hs, "Ft"), hs);
m(s_, "HistoryState");
let bw = s_;
bw.empty = /* @__PURE__ */ new bw(wr, wr);
function x1(s, t) {
  return nt.create(s.ranges.map(t), s.mainIndex);
}
h(x1, "ir$1");
m(x1, "updateSel");
function Iy(s, t) {
  return s.update({ selection: t, scrollIntoView: !0, userEvent: "select" });
}
h(Iy, "Ge$2");
m(Iy, "setSel");
function fb({ state: s, dispatch: t }, e) {
  let i = x1(s.selection, e);
  return i.eq(s.selection, !0) ? !1 : (t(Iy(s, i)), !0);
}
h(fb, "Fe$2");
m(fb, "moveSel");
function k1(s, t) {
  return nt.cursor(t ? s.to : s.from);
}
h(k1, "ko$1");
m(k1, "rangeEnd");
function tX(s, t) {
  return fb(s, (e) => e.empty ? s.moveByChar(e, t) : k1(e, t));
}
h(tX, "hg$1");
m(tX, "cursorByChar");
function eX(s) {
  return s.textDirectionAt(s.state.selection.main.head) == me.LTR;
}
h(eX, "he$2");
m(eX, "ltrAtCursor");
function iX(s, t) {
  return fb(s, (e) => e.empty ? s.moveByGroup(e, t) : k1(e, t));
}
h(iX, "ug$1");
m(iX, "cursorByGroup");
function n_(s, t, e) {
  if (t.type.prop(e))
    return !0;
  let i = t.to - t.from;
  return i && (i > 2 || /[^\s,.;:]/.test(s.sliceDoc(t.from, t.to))) || t.firstChild;
}
h(n_, "Qw$1");
m(n_, "interestingNode");
function rX(s, t, e) {
  let i = de(s).resolveInner(t.head), r = e ? Et.closedBy : Et.openedBy;
  for (let l = t.head; ; ) {
    let d = e ? i.childAfter(l) : i.childBefore(l);
    if (!d)
      break;
    n_(s, d, r) ? i = d : l = e ? d.to : d.from;
  }
  let n = i.type.prop(r), a, o;
  return n && (a = e ? ho(s, i.from, 1) : ho(s, i.to, -1)) && a.matched ? o = e ? a.end.to : a.end.from : o = e ? i.to : i.from, nt.cursor(o, e ? -1 : 1);
}
h(rX, "Po$1");
m(rX, "moveBySyntax");
function sX(s, t) {
  return fb(s, (e) => {
    if (!e.empty)
      return k1(e, t);
    let i = s.moveVertically(e, t);
    return i.head != e.head ? i : s.moveToLineBoundary(e, t);
  });
}
h(sX, "Og$1");
m(sX, "cursorByLine");
function QP(s) {
  let t = s.scrollDOM.clientHeight < s.scrollDOM.scrollHeight - 2, e = 0, i = 0, r;
  if (t) {
    for (let n of s.state.facet(Mt.scrollMargins)) {
      let a = n(s);
      a?.top && (e = Math.max(a?.top, e)), a?.bottom && (i = Math.max(a?.bottom, i));
    }
    r = s.scrollDOM.clientHeight - e - i;
  } else
    r = (s.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: e,
    marginBottom: i,
    selfScroll: t,
    height: Math.max(s.defaultLineHeight, r - 5)
  };
}
h(QP, "mg$1");
m(QP, "pageInfo");
function nX(s, t) {
  let e = QP(s), { state: i } = s, r = x1(i.selection, (a) => a.empty ? s.moveVertically(a, t, e.height) : k1(a, t));
  if (r.eq(i.selection))
    return !1;
  let n;
  if (e.selfScroll) {
    let a = s.coordsAtPos(i.selection.main.head), o = s.scrollDOM.getBoundingClientRect(), l = o.top + e.marginTop, d = o.bottom - e.marginBottom;
    a && a.top > l && a.bottom < d && (n = Mt.scrollIntoView(r.main.head, { y: "start", yMargin: a.top - l }));
  }
  return s.dispatch(Iy(i, r), { effects: n }), !0;
}
h(nX, "gg$1");
m(nX, "cursorByPage");
function aX(s, t, e) {
  let i = s.lineBlockAt(t.head), r = s.moveToLineBoundary(t, e);
  if (r.head == t.head && r.head != (e ? i.to : i.from) && (r = s.moveToLineBoundary(t, e, !1)), !e && r.head == i.from && i.length) {
    let n = /^\s*/.exec(s.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    n && t.head != i.from + n && (r = nt.cursor(i.from + n));
  }
  return r;
}
h(aX, "Ct$1");
m(aX, "moveByLineBoundary");
function oX(s, t, e) {
  let i = !1, r = x1(s.selection, (n) => {
    let a = ho(s, n.head, -1) || ho(s, n.head, 1) || n.head > 0 && ho(s, n.head - 1, 1) || n.head < s.doc.length && ho(s, n.head + 1, -1);
    if (!a || !a.end)
      return n;
    i = !0;
    let o = a.start.from == n.head ? a.end.to : a.end.from;
    return nt.cursor(o);
  });
  return i ? (t(Iy(s, r)), !0) : !1;
}
h(oX, "Rw$1");
m(oX, "toMatchingBracket");
function S1(s, t) {
  let e = x1(s.state.selection, (i) => {
    let r = t(i);
    return nt.range(i.anchor, r.head, r.goalColumn, r.bidiLevel || void 0);
  });
  return e.eq(s.state.selection) ? !1 : (s.dispatch(Iy(s.state, e)), !0);
}
h(S1, "We$2");
m(S1, "extendSel");
function lX(s, t) {
  return S1(s, (e) => s.moveByChar(e, t));
}
h(lX, "Qg$1");
m(lX, "selectByChar");
function cX(s, t) {
  return S1(s, (e) => s.moveByGroup(e, t));
}
h(cX, "bg$1");
m(cX, "selectByGroup");
function hX(s, t) {
  return S1(s, (e) => s.moveVertically(e, t));
}
h(hX, "wg$1");
m(hX, "selectByLine");
function dX(s, t) {
  return S1(s, (e) => s.moveVertically(e, t, QP(s).height));
}
h(dX, "Pg$1");
m(dX, "selectByPage");
function uX(s, t) {
  let { state: e } = s, i = e.selection, r = e.selection.ranges.slice();
  for (let n of e.selection.ranges) {
    let a = e.doc.lineAt(n.head);
    if (t ? a.to < s.state.doc.length : a.from > 0)
      for (let o = n; ; ) {
        let l = s.moveVertically(o, t);
        if (l.head < a.from || l.head > a.to) {
          r.some((d) => d.head == l.head) || r.push(l);
          break;
        } else {
          if (l.head == o.head)
            break;
          o = l;
        }
      }
  }
  return r.length == i.ranges.length ? !1 : (s.dispatch(Iy(e, nt.create(r, r.length - 1))), !0);
}
h(uX, "$g$1");
m(uX, "addCursorVertically");
function pX(s, t) {
  if (s.state.readOnly)
    return !1;
  let e = "delete.selection", { state: i } = s, r = i.changeByRange((n) => {
    let { from: a, to: o } = n;
    if (a == o) {
      let l = t(n);
      l < a ? (e = "delete.backward", l = Dg(s, l, !1)) : l > a && (e = "delete.forward", l = Dg(s, l, !0)), a = Math.min(a, l), o = Math.max(o, l);
    } else
      a = Dg(s, a, !1), o = Dg(s, o, !0);
    return a == o ? { range: n } : { changes: { from: a, to: o }, range: nt.cursor(a, a < n.head ? -1 : 1) };
  });
  return r.changes.empty ? !1 : (s.dispatch(i.update(r, {
    scrollIntoView: !0,
    userEvent: e,
    effects: e == "delete.selection" ? Mt.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
h(pX, "wn$1");
m(pX, "deleteBy");
function Dg(s, t, e) {
  if (s instanceof Mt)
    for (let i of s.state.facet(Mt.atomicRanges).map((r) => r(s)))
      i.between(t, t, (r, n) => {
        r < t && n > t && (t = e ? n : r);
      });
  return t;
}
h(Dg, "jn$1");
m(Dg, "skipAtomic");
function TP(s) {
  let t = [], e = -1;
  for (let i of s.selection.ranges) {
    let r = s.doc.lineAt(i.from), n = s.doc.lineAt(i.to);
    if (!i.empty && i.to == n.from && (n = s.doc.lineAt(i.to - 1)), e >= r.number) {
      let a = t[t.length - 1];
      a.to = n.to, a.ranges.push(i);
    } else
      t.push({ from: r.from, to: n.to, ranges: [i] });
    e = n.number + 1;
  }
  return t;
}
h(TP, "$o$1");
m(TP, "selectedLineBlocks");
function fX(s, t, e) {
  if (s.readOnly)
    return !1;
  let i = [], r = [];
  for (let n of TP(s)) {
    if (e ? n.to == s.doc.length : n.from == 0)
      continue;
    let a = s.doc.lineAt(e ? n.to + 1 : n.from - 1), o = a.length + 1;
    if (e) {
      i.push({ from: n.to, to: a.to }, { from: n.from, insert: a.text + s.lineBreak });
      for (let l of n.ranges)
        r.push(nt.range(Math.min(s.doc.length, l.anchor + o), Math.min(s.doc.length, l.head + o)));
    } else {
      i.push({ from: a.from, to: n.from }, { from: n.to, insert: s.lineBreak + a.text });
      for (let l of n.ranges)
        r.push(nt.range(l.anchor - o, l.head - o));
    }
  }
  return i.length ? (t(s.update({
    changes: i,
    scrollIntoView: !0,
    selection: nt.create(r, s.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
h(fX, "Lg$1");
m(fX, "moveLine");
function mX(s, t, e) {
  if (s.readOnly)
    return !1;
  let i = [];
  for (let n of TP(s))
    e ? i.push({ from: n.from, insert: s.doc.slice(n.from, n.to) + s.lineBreak }) : i.push({ from: n.to, insert: s.lineBreak + s.doc.slice(n.from, n.to) });
  let r = s.changes(i);
  return t(s.update({
    changes: r,
    selection: s.selection.map(r, e ? 1 : -1),
    scrollIntoView: !0,
    userEvent: "input.copyline"
  })), !0;
}
h(mX, "_g$1");
m(mX, "copyLine");
function a_(s, t) {
  if (/\(\)|\[\]|\{\}/.test(s.sliceDoc(t - 1, t + 1)))
    return { from: t, to: t };
  let e = de(s).resolveInner(t), i = e.childBefore(t), r = e.childAfter(t), n;
  return i && r && i.to <= t && r.from >= t && (n = i.type.prop(Et.closedBy)) && n.indexOf(r.name) > -1 && s.doc.lineAt(i.to).from == s.doc.lineAt(r.from).from && !/\S/.test(s.sliceDoc(i.to, r.from)) ? { from: i.to, to: r.from } : null;
}
h(a_, "ix$1");
m(a_, "isBetweenBrackets");
function yX(s) {
  return ({ state: t, dispatch: e }) => {
    if (t.readOnly)
      return !1;
    let i = t.changeByRange((r) => {
      let { from: n, to: a } = r, o = t.doc.lineAt(n), l = !s && n == a && a_(t, n);
      s && (n = a = (a <= o.to ? o : t.doc.lineAt(a)).to);
      let d = new IC(t, { simulateBreak: n, simulateDoubleBreak: !!l }), u = GM(d, n);
      for (u == null && (u = ua(/^\s*/.exec(t.doc.lineAt(n).text)[0], t.tabSize)); a < o.to && /\s/.test(o.text[a - o.from]); )
        a++;
      l ? { from: n, to: a } = l : n > o.from && n < o.from + 100 && !/\S/.test(o.text.slice(0, n)) && (n = o.from);
      let p = ["", x5(t, u)];
      return l && p.push(x5(t, d.lineIndent(o.from, -1))), {
        changes: { from: n, to: a, insert: Ht.of(p) },
        range: nt.cursor(n + 1 + p[1].length)
      };
    });
    return e(t.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
h(yX, "Mg$1");
m(yX, "newlineAndIndent");
function gX(s, t) {
  let e = -1;
  return s.changeByRange((i) => {
    let r = [];
    for (let a = i.from; a <= i.to; ) {
      let o = s.doc.lineAt(a);
      o.number > e && (i.empty || i.to > o.from) && (t(o, r, i), e = o.number), a = o.to + 1;
    }
    let n = s.changes(r);
    return {
      changes: r,
      range: nt.range(n.mapPos(i.anchor, 1), n.mapPos(i.head, 1))
    };
  });
}
h(gX, "Dh$1");
m(gX, "changeBySelectedLine");
lA.define([
  { tag: Q.meta, class: "code" },
  { tag: Q.link, class: "wy-link" },
  { tag: Q.heading, textDecoration: "underline", fontWeight: "bold" },
  { tag: Q.emphasis, fontStyle: "italic" },
  { tag: Q.strong, fontWeight: "bold" },
  { tag: Q.strikethrough, textDecoration: "line-through" },
  { tag: Q.keyword, class: "code token keyword" },
  { tag: [Q.atom, Q.bool], class: "code token builtin" },
  { tag: [Q.url, Q.contentSeparator, Q.labelName], class: "code token prolog" },
  { tag: Q.literal, class: "code token char" },
  { tag: Q.inserted, class: "code token inserted" },
  { tag: Q.deleted, class: "code token deleted" },
  { tag: Q.string, class: "code token string" },
  { tag: [Q.regexp, Q.escape, Q.special(Q.string)], class: "code token regex" },
  { tag: Q.definition(Q.variableName), class: "code token constant" },
  { tag: Q.local(Q.variableName), class: "code token variable" },
  { tag: [Q.typeName, Q.namespace], class: "code token keyword" },
  { tag: Q.className, class: "code token class-name" },
  { tag: [Q.special(Q.variableName), Q.macroName], class: "code token function" },
  { tag: Q.propertyName, class: "code token property" },
  { tag: Q.comment, class: "code token comment" },
  { tag: Q.invalid, color: "#f00", class: "code token" }
]);
function wX(s) {
  MP(s, "start");
  var t = {}, e = s.languageData || {}, i = !1;
  for (var r in s) if (r != e && s.hasOwnProperty(r))
    for (var n = t[r] = [], a = s[r], o = 0; o < a.length; o++) {
      var l = a[o];
      n.push(new c_(l, s)), (l.indent || l.dedent) && (i = !0);
    }
  return {
    name: e.name,
    startState: /* @__PURE__ */ m(function() {
      return { state: "start", pending: null, indent: i ? [] : null };
    }, "startState"),
    copyState: /* @__PURE__ */ m(function(d) {
      var u = { state: d.state, pending: d.pending, indent: d.indent && d.indent.slice(0) };
      return d.stack && (u.stack = d.stack.slice(0)), u;
    }, "copyState"),
    token: h_(t),
    indent: d_(t, e),
    mergeTokens: e.mergeTokens,
    languageData: e
  };
}
h(wX, "Tx$1");
m(wX, "simpleMode");
function MP(s, t) {
  if (!s.hasOwnProperty(t))
    throw new Error("Undefined state " + t + " in simple mode");
}
h(MP, "Zg$1");
m(MP, "ensureState");
function o_(s, t) {
  if (!s) return /(?:)/;
  var e = "";
  return s instanceof RegExp ? (s.ignoreCase && (e = "i"), s.unicode && (e += "u"), s = s.source) : s = String(s), new RegExp("^(?:" + s + ")", e);
}
h(o_, "ux$1");
m(o_, "toRegex");
function l_(s) {
  if (!s) return null;
  if (s.apply) return s;
  if (typeof s == "string") return s.replace(/\./g, " ");
  for (var t = [], e = 0; e < s.length; e++)
    t.push(s[e] && s[e].replace(/\./g, " "));
  return t;
}
h(l_, "Ox$1");
m(l_, "asToken");
function c_(s, t) {
  (s.next || s.push) && MP(t, s.next || s.push), this.regex = o_(s.regex), this.token = l_(s.token), this.data = s;
}
h(c_, "dx$1");
m(c_, "Rule");
function h_(s) {
  return function(t, e) {
    if (e.pending) {
      var i = e.pending.shift();
      return e.pending.length == 0 && (e.pending = null), t.pos += i.text.length, i.token;
    }
    for (var r = s[e.state], n = 0; n < r.length; n++) {
      var a = r[n], o = (!a.data.sol || t.sol()) && t.match(a.regex);
      if (o) {
        a.data.next ? e.state = a.data.next : a.data.push ? ((e.stack || (e.stack = [])).push(e.state), e.state = a.data.push) : a.data.pop && e.stack && e.stack.length && (e.state = e.stack.pop()), a.data.indent && e.indent.push(t.indentation() + t.indentUnit), a.data.dedent && e.indent.pop();
        var l = a.token;
        if (l && l.apply && (l = l(o)), o.length > 2 && a.token && typeof a.token != "string") {
          e.pending = [];
          for (var d = 2; d < o.length; d++)
            o[d] && e.pending.push({ text: o[d], token: a.token[d - 1] });
          return t.backUp(o[0].length - (o[1] ? o[1].length : 0)), l[0];
        } else return l && l.join ? l[0] : l;
      }
    }
    return t.next(), null;
  };
}
h(h_, "px$1");
m(h_, "tokenFunction");
function d_(s, t) {
  return function(e, i) {
    if (e.indent == null || t.dontIndentStates && t.dontIndentStates.indexOf(e.state) > -1)
      return null;
    var r = e.indent.length - 1, n = s[e.state];
    t: for (; ; ) {
      for (var a = 0; a < n.length; a++) {
        var o = n[a];
        if (o.data.dedent && o.data.dedentIfLineStart !== !1) {
          var l = o.regex.exec(i);
          if (l && l[0]) {
            r--, (o.next || o.push) && (n = s[o.next || o.push]), i = i.slice(l[0].length);
            continue t;
          }
        }
      }
      break;
    }
    return r < 0 ? 0 : e.indent[r];
  };
}
h(d_, "mx$1");
m(d_, "indentFunction");
var vX = Object.defineProperty, yt = /* @__PURE__ */ h((s, t) => vX(s, "name", { value: t, configurable: !0 }), "o$1");
const eS = "lit-localize-status", OX = /* @__PURE__ */ yt((s, ...t) => ({
  strTag: !0,
  strings: s,
  values: t
}), "_str"), lt = OX, bX = /* @__PURE__ */ yt((s) => typeof s != "string" && "strTag" in s, "isStrTagged"), u_ = /* @__PURE__ */ yt((s, t, e) => {
  let i = s[0];
  for (let r = 1; r < s.length; r++)
    i += t[e ? e[r - 1] : r - 1], i += s[r];
  return i;
}, "joinStringsAndValues"), p_ = /* @__PURE__ */ yt(((s) => bX(s) ? u_(s.strings, s.values) : s), "defaultMsg");
let P = p_, YQ = !1;
function f_(s) {
  if (YQ)
    throw new Error("lit-localize can only be configured once");
  P = s, YQ = !0;
}
h(f_, "xt");
yt(f_, "_installMsgImplementation");
var Fu;
const m_ = (Fu = class {
  constructor(t) {
    this.__litLocalizeEventHandler = (e) => {
      e.detail.status === "ready" && this.host.requestUpdate();
    }, this.host = t;
  }
  hostConnected() {
    window.addEventListener(eS, this.__litLocalizeEventHandler);
  }
  hostDisconnected() {
    window.removeEventListener(eS, this.__litLocalizeEventHandler);
  }
}, h(Fu, "Be"), Fu);
yt(m_, "LocalizeController");
let $X = m_;
const xX = /* @__PURE__ */ yt((s) => s.addController(new $X(s)), "_updateWhenLocaleChanges"), kX = xX, At = /* @__PURE__ */ yt(() => (s, t) => (s.addInitializer(kX), s), "localized");
var qu;
const y_ = (qu = class {
  constructor() {
    this.settled = !1, this.promise = new Promise((t, e) => {
      this._resolve = t, this._reject = e;
    });
  }
  resolve(t) {
    this.settled = !0, this._resolve(t);
  }
  reject(t) {
    this.settled = !0, this._reject(t);
  }
}, h(qu, "Ve"), qu);
yt(y_, "Deferred");
let g_ = y_;
const Es = [];
for (let s = 0; s < 256; s++)
  Es[s] = (s >> 4 & 15).toString(16) + (s & 15).toString(16);
function w_(s) {
  let t = 0, e = 8997, i = 0, r = 33826, n = 0, a = 40164, o = 0, l = 52210;
  for (let d = 0; d < s.length; d++)
    e ^= s.charCodeAt(d), t = e * 435, i = r * 435, n = a * 435, o = l * 435, n += e << 8, o += r << 8, i += t >>> 16, e = t & 65535, n += i >>> 16, r = i & 65535, l = o + (n >>> 16) & 65535, a = n & 65535;
  return Es[l >> 8] + Es[l & 255] + Es[a >> 8] + Es[a & 255] + Es[r >> 8] + Es[r & 255] + Es[e >> 8] + Es[e & 255];
}
h(w_, "Ut$1");
yt(w_, "fnv1a64");
const SX = "", CX = "h", PX = "s";
function v_(s, t) {
  return (t ? CX : PX) + w_(typeof s == "string" ? s : s.join(SX));
}
h(v_, "jt$1");
yt(v_, "generateMsgId");
const GQ = /* @__PURE__ */ new WeakMap(), KQ = /* @__PURE__ */ new Map();
function O_(s, t, e) {
  if (s) {
    const i = e?.id ?? b_(t), r = s[i];
    if (r) {
      if (typeof r == "string")
        return r;
      if ("strTag" in r)
        return u_(
          r.strings,
          // Cast `template` because its type wasn't automatically narrowed (but
          // we know it must be the same type as `localized`).
          t.values,
          r.values
        );
      {
        let n = GQ.get(r);
        return n === void 0 && (n = r.values, GQ.set(r, n)), {
          ...r,
          values: n.map((a) => t.values[a])
        };
      }
    }
  }
  return p_(t);
}
h(O_, "Wt$1");
yt(O_, "runtimeMsg");
function b_(s) {
  const t = typeof s == "string" ? s : s.strings;
  let e = KQ.get(t);
  return e === void 0 && (e = v_(t, typeof s != "string" && !("strTag" in s)), KQ.set(t, e)), e;
}
h(b_, "Bt");
yt(b_, "generateId");
function Bv(s) {
  window.dispatchEvent(new CustomEvent(eS, { detail: s }));
}
h(Bv, "ve$1");
yt(Bv, "dispatchStatusEvent");
let GO = "", q2, $_, KO, iS, x_, io = new g_();
io.resolve();
let hv = 0;
const QX = /* @__PURE__ */ yt((s) => (f_(((t, e) => O_(x_, t, e))), GO = $_ = s.sourceLocale, KO = new Set(s.targetLocales), KO.add(s.sourceLocale), iS = s.loadLocale, { getLocale: TX, setLocale: MX }), "configureLocalization"), TX = /* @__PURE__ */ yt(() => GO, "getLocale"), MX = /* @__PURE__ */ yt((s) => {
  if (s === (q2 ?? GO))
    return io.promise;
  if (!KO || !iS)
    throw new Error("Internal error");
  if (!KO.has(s))
    throw new Error("Invalid locale code");
  hv++;
  const t = hv;
  return q2 = s, io.settled && (io = new g_()), Bv({ status: "loading", loadingLocale: s }), (s === $_ ? (
    // We could switch to the source locale synchronously, but we prefer to
    // queue it on a microtask so that switching locales is consistently
    // asynchronous.
    Promise.resolve({ templates: void 0 })
  ) : iS(s)).then((e) => {
    hv === t && (GO = s, q2 = void 0, x_ = e.templates, Bv({ status: "ready", readyLocale: s }), io.resolve());
  }, (e) => {
    hv === t && (Bv({
      status: "error",
      errorLocale: s,
      errorMessage: e.toString()
    }), io.reject(e));
  }), io.promise;
}, "setLocale");
var Z2, Zu;
const AX = (Z2 = (Zu = class {
  get shadowRoot() {
    return this.__host.__shadowRoot;
  }
  constructor(t) {
    this.ariaAtomic = "", this.ariaAutoComplete = "", this.ariaBrailleLabel = "", this.ariaBrailleRoleDescription = "", this.ariaBusy = "", this.ariaChecked = "", this.ariaColCount = "", this.ariaColIndex = "", this.ariaColSpan = "", this.ariaCurrent = "", this.ariaDescription = "", this.ariaDisabled = "", this.ariaExpanded = "", this.ariaHasPopup = "", this.ariaHidden = "", this.ariaInvalid = "", this.ariaKeyShortcuts = "", this.ariaLabel = "", this.ariaLevel = "", this.ariaLive = "", this.ariaModal = "", this.ariaMultiLine = "", this.ariaMultiSelectable = "", this.ariaOrientation = "", this.ariaPlaceholder = "", this.ariaPosInSet = "", this.ariaPressed = "", this.ariaReadOnly = "", this.ariaRequired = "", this.ariaRoleDescription = "", this.ariaRowCount = "", this.ariaRowIndex = "", this.ariaRowSpan = "", this.ariaSelected = "", this.ariaSetSize = "", this.ariaSort = "", this.ariaValueMax = "", this.ariaValueMin = "", this.ariaValueNow = "", this.ariaValueText = "", this.role = "", this.form = null, this.labels = [], this.states = /* @__PURE__ */ new Set(), this.validationMessage = "", this.validity = {}, this.willValidate = !0, this.__host = t;
  }
  checkValidity() {
    return console.warn("`ElementInternals.checkValidity()` was called on the server.This method always returns true."), !0;
  }
  reportValidity() {
    return !0;
  }
  setFormValue() {
  }
  setValidity() {
  }
}, h(Zu, "O$1"), Zu), yt(Z2, "ElementInternals"), Z2);
var Jr = /* @__PURE__ */ h(function(s, t, e, i, r) {
  if (typeof t == "function" ? s !== t || !0 : !t.has(s)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t.set(s, e), e;
}, "E$1"), ni = /* @__PURE__ */ h(function(s, t, e, i) {
  if (typeof t == "function" ? s !== t || !i : !t.has(s)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e === "m" ? i : e === "a" ? i.call(s) : i ? i.value : t.get(s);
}, "_$1"), _c, dv, uv, ag, B2, og, pv, qa, lg, $n, fv, JQ;
const t9 = /* @__PURE__ */ yt((s) => typeof s == "boolean" ? s : s?.capture ?? !1, "isCaptureEventListener"), JO = 0, rS = 1, t0 = 2, sS = 3;
var Bu;
const k_ = (Bu = class {
  constructor() {
    this.__eventListeners = /* @__PURE__ */ new Map(), this.__captureEventListeners = /* @__PURE__ */ new Map();
  }
  addEventListener(t, e, i) {
    if (e == null)
      return;
    const r = t9(i) ? this.__captureEventListeners : this.__eventListeners;
    let n = r.get(t);
    if (n === void 0)
      n = /* @__PURE__ */ new Map(), r.set(t, n);
    else if (n.has(e))
      return;
    const a = typeof i == "object" && i ? i : {};
    a.signal?.addEventListener("abort", () => this.removeEventListener(t, e, i)), n.set(e, a ?? {});
  }
  removeEventListener(t, e, i) {
    if (e == null)
      return;
    const r = t9(i) ? this.__captureEventListeners : this.__eventListeners, n = r.get(t);
    n !== void 0 && (n.delete(e), n.size || r.delete(t));
  }
  dispatchEvent(t) {
    const e = [this];
    let i = this.__eventTargetParent;
    if (t.composed)
      for (; i; )
        e.push(i), i = i.__eventTargetParent;
    else
      for (; i && i !== this.__host; )
        e.push(i), i = i.__eventTargetParent;
    let r = !1, n = !1, a = JO, o = null, l = null, d = null;
    const u = t.stopPropagation, p = t.stopImmediatePropagation;
    Object.defineProperties(t, {
      target: {
        get() {
          return o ?? l;
        },
        ...Kt
      },
      srcElement: {
        get() {
          return t.target;
        },
        ...Kt
      },
      currentTarget: {
        get() {
          return d;
        },
        ...Kt
      },
      eventPhase: {
        get() {
          return a;
        },
        ...Kt
      },
      composedPath: {
        value: /* @__PURE__ */ yt(() => e, "value"),
        ...Kt
      },
      stopPropagation: {
        value: /* @__PURE__ */ yt(() => {
          r = !0, u.call(t);
        }, "value"),
        ...Kt
      },
      stopImmediatePropagation: {
        value: /* @__PURE__ */ yt(() => {
          n = !0, p.call(t);
        }, "value"),
        ...Kt
      }
    });
    const f = /* @__PURE__ */ yt(($, T, _) => {
      typeof $ == "function" ? $(t) : typeof $?.handleEvent == "function" && $.handleEvent(t), T.once && _.delete($);
    }, "invokeEventListener"), y = /* @__PURE__ */ yt(() => (d = null, a = JO, !t.defaultPrevented), "finishDispatch"), g = e.slice().reverse();
    o = !this.__host || !t.composed ? this : null;
    const O = /* @__PURE__ */ yt(($) => {
      for (l = this; l.__host && $.includes(l.__host); )
        l = l.__host;
    }, "retarget");
    for (const $ of g) {
      !o && (!l || l === $.__host) && O(g.slice(g.indexOf($))), d = $, a = $ === t.target ? t0 : rS;
      const T = $.__captureEventListeners.get(t.type);
      if (T) {
        for (const [_, D] of T)
          if (f(_, D, T), n)
            return y();
      }
      if (r)
        return y();
    }
    const k = t.bubbles ? e : [this];
    l = null;
    for (const $ of k) {
      !o && (!l || $ === l.__host) && O(k.slice(0, k.indexOf($) + 1)), d = $, a = $ === t.target ? t0 : sS;
      const T = $.__eventListeners.get(t.type);
      if (T) {
        for (const [_, D] of T)
          if (f(_, D, T), n)
            return y();
      }
      if (r)
        return y();
    }
    return y();
  }
}, h(Bu, "ze"), Bu);
yt(k_, "EventTarget");
let RX = k_;
const EX = RX, Kt = { __proto__: null };
Kt.enumerable = !0;
Object.freeze(Kt);
var N2, Nu;
const AP = ($n = (N2 = (Nu = class {
  constructor(t, e = {}) {
    if (_c.set(this, !1), dv.set(this, !1), uv.set(this, !1), ag.set(this, !1), B2.set(this, Date.now()), og.set(this, !1), pv.set(this, void 0), qa.set(this, void 0), lg.set(this, void 0), this.NONE = JO, this.CAPTURING_PHASE = rS, this.AT_TARGET = t0, this.BUBBLING_PHASE = sS, arguments.length === 0)
      throw new Error("The type argument must be specified");
    if (typeof e != "object" || !e)
      throw new Error('The "options" argument must be an object');
    const { bubbles: i, cancelable: r, composed: n } = e;
    Jr(this, _c, !!r), Jr(this, dv, !!i), Jr(this, uv, !!n), Jr(this, pv, `${t}`), Jr(this, qa, null), Jr(this, lg, !1);
  }
  initEvent(t, e, i) {
    throw new Error("Method not implemented.");
  }
  stopImmediatePropagation() {
    this.stopPropagation();
  }
  preventDefault() {
    Jr(this, ag, !0);
  }
  get target() {
    return ni(this, qa, "f");
  }
  get currentTarget() {
    return ni(this, qa, "f");
  }
  get srcElement() {
    return ni(this, qa, "f");
  }
  get type() {
    return ni(this, pv, "f");
  }
  get cancelable() {
    return ni(this, _c, "f");
  }
  get defaultPrevented() {
    return ni(this, _c, "f") && ni(this, ag, "f");
  }
  get timeStamp() {
    return ni(this, B2, "f");
  }
  composedPath() {
    return ni(this, lg, "f") ? [ni(this, qa, "f")] : [];
  }
  get returnValue() {
    return !ni(this, _c, "f") || !ni(this, ag, "f");
  }
  get bubbles() {
    return ni(this, dv, "f");
  }
  get composed() {
    return ni(this, uv, "f");
  }
  get eventPhase() {
    return ni(this, lg, "f") ? $n.AT_TARGET : $n.NONE;
  }
  get cancelBubble() {
    return ni(this, og, "f");
  }
  set cancelBubble(t) {
    t && Jr(this, og, !0);
  }
  stopPropagation() {
    Jr(this, og, !0);
  }
  get isTrusted() {
    return !1;
  }
}, h(Nu, "U"), Nu), yt(N2, "Event"), N2), _c = /* @__PURE__ */ new WeakMap(), dv = /* @__PURE__ */ new WeakMap(), uv = /* @__PURE__ */ new WeakMap(), ag = /* @__PURE__ */ new WeakMap(), B2 = /* @__PURE__ */ new WeakMap(), og = /* @__PURE__ */ new WeakMap(), pv = /* @__PURE__ */ new WeakMap(), qa = /* @__PURE__ */ new WeakMap(), lg = /* @__PURE__ */ new WeakMap(), $n.NONE = JO, $n.CAPTURING_PHASE = rS, $n.AT_TARGET = t0, $n.BUBBLING_PHASE = sS, $n);
Object.defineProperties(AP.prototype, {
  initEvent: Kt,
  stopImmediatePropagation: Kt,
  preventDefault: Kt,
  target: Kt,
  currentTarget: Kt,
  srcElement: Kt,
  type: Kt,
  cancelable: Kt,
  defaultPrevented: Kt,
  timeStamp: Kt,
  composedPath: Kt,
  returnValue: Kt,
  bubbles: Kt,
  composed: Kt,
  eventPhase: Kt,
  cancelBubble: Kt,
  stopPropagation: Kt,
  isTrusted: Kt
});
var X2, Xu;
const S_ = (JQ = (X2 = (Xu = class extends AP {
  constructor(t, e = {}) {
    super(t, e), fv.set(this, void 0), Jr(this, fv, e?.detail ?? null);
  }
  initCustomEvent(t, e, i, r) {
    throw new Error("Method not implemented.");
  }
  get detail() {
    return ni(this, fv, "f");
  }
}, h(Xu, "H"), Xu), yt(X2, "CustomEvent"), X2), fv = /* @__PURE__ */ new WeakMap(), JQ);
Object.defineProperties(S_.prototype, {
  detail: Kt
});
const _X = AP, LX = S_;
globalThis.Event ??= _X;
globalThis.CustomEvent ??= LX;
const e9 = /* @__PURE__ */ new WeakMap(), cg = /* @__PURE__ */ yt((s) => {
  let t = e9.get(s);
  return t === void 0 && e9.set(s, t = /* @__PURE__ */ new Map()), t;
}, "attributesForElement");
var j2, ju;
const zX = (j2 = (ju = class extends EX {
  constructor() {
    super(...arguments), this.__shadowRootMode = null, this.__shadowRoot = null, this.__internals = null;
  }
  get attributes() {
    return Array.from(cg(this)).map(([t, e]) => ({
      name: t,
      value: e
    }));
  }
  get shadowRoot() {
    return this.__shadowRootMode === "closed" ? null : this.__shadowRoot;
  }
  get localName() {
    return this.constructor.__localName;
  }
  get tagName() {
    return this.localName?.toUpperCase();
  }
  setAttribute(t, e) {
    cg(this).set(t, String(e));
  }
  removeAttribute(t) {
    cg(this).delete(t);
  }
  toggleAttribute(t, e) {
    if (this.hasAttribute(t)) {
      if (e === void 0 || !e)
        return this.removeAttribute(t), !1;
    } else
      return e === void 0 || e ? (this.setAttribute(t, ""), !0) : !1;
    return !0;
  }
  hasAttribute(t) {
    return cg(this).has(t);
  }
  attachShadow(t) {
    const e = { host: this };
    return this.__shadowRootMode = t.mode, t && t.mode === "open" && (this.__shadowRoot = e), e;
  }
  attachInternals() {
    if (this.__internals !== null)
      throw new Error("Failed to execute 'attachInternals' on 'HTMLElement': ElementInternals for the specified element was already attached.");
    const t = new AX(this);
    return this.__internals = t, t;
  }
  getAttribute(t) {
    return cg(this).get(t) ?? null;
  }
}, h(ju, "I"), ju), yt(j2, "Element"), j2);
var U2, Uu;
const IX = (U2 = (Uu = class extends zX {
}, h(Uu, "D$1"), Uu), yt(U2, "HTMLElement"), U2), C_ = IX;
globalThis.litServerRoot ??= Object.defineProperty(new C_(), "localName", {
  // Patch localName (and tagName) to return a unique name.
  get() {
    return "lit-server-root";
  }
});
function P_() {
  let s, t;
  return { promise: new Promise((e, i) => {
    s = e, t = i;
  }), resolve: s, reject: t };
}
h(P_, "Xt$1");
yt(P_, "promiseWithResolvers");
var Hu;
const Q_ = (Hu = class {
  constructor() {
    this.__definitions = /* @__PURE__ */ new Map(), this.__reverseDefinitions = /* @__PURE__ */ new Map(), this.__pendingWhenDefineds = /* @__PURE__ */ new Map();
  }
  define(t, e) {
    if (this.__definitions.has(t))
      throw new Error(`Failed to execute 'define' on 'CustomElementRegistry': the name "${t}" has already been used with this registry`);
    if (this.__reverseDefinitions.has(e))
      throw new Error(`Failed to execute 'define' on 'CustomElementRegistry': the constructor has already been used with this registry for the tag name ${this.__reverseDefinitions.get(e)}`);
    e.__localName = t, this.__definitions.set(t, {
      ctor: e,
      // Note it's important we read `observedAttributes` in case it is a getter
      // with side-effects, as is the case in Lit, where it triggers class
      // finalization.
      //
      // TODO(aomarks) To be spec compliant, we should also capture the
      // registration-time lifecycle methods like `connectedCallback`. For them
      // to be actually accessible to e.g. the Lit SSR element renderer, though,
      // we'd need to introduce a new API for accessing them (since `get` only
      // returns the constructor).
      observedAttributes: e.observedAttributes ?? []
    }), this.__reverseDefinitions.set(e, t), this.__pendingWhenDefineds.get(t)?.resolve(e), this.__pendingWhenDefineds.delete(t);
  }
  get(t) {
    return this.__definitions.get(t)?.ctor;
  }
  getName(t) {
    return this.__reverseDefinitions.get(t) ?? null;
  }
  upgrade(t) {
    throw new Error("customElements.upgrade is not currently supported in SSR. Please file a bug if you need it.");
  }
  async whenDefined(t) {
    const e = this.__definitions.get(t);
    if (e)
      return e.ctor;
    let i = this.__pendingWhenDefineds.get(t);
    return i || (i = P_(), this.__pendingWhenDefineds.set(t, i)), i.promise;
  }
}, h(Hu, "Fe"), Hu);
yt(Q_, "CustomElementRegistry");
let DX = Q_;
const VX = DX, WX = new VX(), $w = globalThis, mb = $w.ShadowRoot && ($w.ShadyCSS === void 0 || $w.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, RP = Symbol(), i9 = /* @__PURE__ */ new WeakMap();
var H2, Yu;
let T_ = (H2 = (Yu = class {
  constructor(t, e, i) {
    if (this._$cssResult$ = !0, i !== RP) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (mb && t === void 0) {
      const i = e !== void 0 && e.length === 1;
      i && (t = i9.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), i && i9.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
}, h(Yu, "j"), Yu), yt(H2, "n"), H2);
const M_ = /* @__PURE__ */ yt((s) => new T_(typeof s == "string" ? s : s + "", void 0, RP), "r$2"), it = /* @__PURE__ */ yt((s, ...t) => {
  const e = s.length === 1 ? s[0] : t.reduce(((i, r, n) => i + ((a) => {
    if (a._$cssResult$ === !0) return a.cssText;
    if (typeof a == "number") return a;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + a + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(r) + s[n + 1]), s[0]);
  return new T_(e, s, RP);
}, "i$2"), A_ = /* @__PURE__ */ yt((s, t) => {
  if (mb) s.adoptedStyleSheets = t.map(((e) => e instanceof CSSStyleSheet ? e : e.styleSheet));
  else for (const e of t) {
    const i = document.createElement("style"), r = $w.litNonce;
    r !== void 0 && i.setAttribute("nonce", r), i.textContent = e.cssText, s.appendChild(i);
  }
}, "S$1"), r9 = mb || $w.CSSStyleSheet === void 0 ? (s) => s : (s) => s instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const i of t.cssRules) e += i.cssText;
  return M_(e);
})(s) : s, { is: FX, defineProperty: qX, getOwnPropertyDescriptor: ZX, getOwnPropertyNames: BX, getOwnPropertySymbols: NX, getPrototypeOf: XX } = Object, C1 = globalThis;
C1.customElements ??= WX;
const s9 = C1.trustedTypes, jX = s9 ? s9.emptyScript : "", UX = C1.reactiveElementPolyfillSupport, xw = /* @__PURE__ */ yt((s, t) => s, "f$1"), e0 = { toAttribute(s, t) {
  switch (t) {
    case Boolean:
      s = s ? jX : null;
      break;
    case Object:
    case Array:
      s = s == null ? s : JSON.stringify(s);
  }
  return s;
}, fromAttribute(s, t) {
  let e = s;
  switch (t) {
    case Boolean:
      e = s !== null;
      break;
    case Number:
      e = s === null ? null : Number(s);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(s);
      } catch {
        e = null;
      }
  }
  return e;
} }, EP = /* @__PURE__ */ yt((s, t) => !FX(s, t), "m$1"), n9 = { attribute: !0, type: String, converter: e0, reflect: !1, useDefault: !1, hasChanged: EP };
Symbol.metadata ??= Symbol("metadata"), C1.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var Y2, Gu;
let jc = (Y2 = (Gu = class extends (globalThis.HTMLElement ?? C_) {
  static addInitializer(t) {
    this._$Ei(), (this.l ??= []).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = n9) {
    if (e.state && (e.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(t) && ((e = Object.create(e)).wrapped = !0), this.elementProperties.set(t, e), !e.noAccessor) {
      const i = Symbol(), r = this.getPropertyDescriptor(t, i, e);
      r !== void 0 && qX(this.prototype, t, r);
    }
  }
  static getPropertyDescriptor(t, e, i) {
    const { get: r, set: n } = ZX(this.prototype, t) ?? { get() {
      return this[e];
    }, set(a) {
      this[e] = a;
    } };
    return { get: r, set(a) {
      const o = r?.call(this);
      n?.call(this, a), this.requestUpdate(t, o, i);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? n9;
  }
  static _$Ei() {
    if (this.hasOwnProperty(xw("elementProperties"))) return;
    const t = XX(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(xw("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(xw("properties"))) {
      const e = this.properties, i = [...BX(e), ...NX(e)];
      for (const r of i) this.createProperty(r, e[r]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0) for (const [i, r] of e) this.elementProperties.set(i, r);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, i] of this.elementProperties) {
      const r = this._$Eu(e, i);
      r !== void 0 && this._$Eh.set(r, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const i = new Set(t.flat(1 / 0).reverse());
      for (const r of i) e.unshift(r9(r));
    } else t !== void 0 && e.push(r9(t));
    return e;
  }
  static _$Eu(t, e) {
    const i = e.attribute;
    return i === !1 ? void 0 : typeof i == "string" ? i : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise(((t) => this.enableUpdating = t)), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach(((t) => t(this)));
  }
  addController(t) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t), this.renderRoot !== void 0 && this.isConnected && t.hostConnected?.();
  }
  removeController(t) {
    this._$EO?.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const i of e.keys()) this.hasOwnProperty(i) && (t.set(i, this[i]), delete this[i]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return A_(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(!0), this._$EO?.forEach(((t) => t.hostConnected?.()));
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    this._$EO?.forEach(((t) => t.hostDisconnected?.()));
  }
  attributeChangedCallback(t, e, i) {
    this._$AK(t, i);
  }
  _$ET(t, e) {
    const i = this.constructor.elementProperties.get(t), r = this.constructor._$Eu(t, i);
    if (r !== void 0 && i.reflect === !0) {
      const n = (i.converter?.toAttribute !== void 0 ? i.converter : e0).toAttribute(e, i.type);
      this._$Em = t, n == null ? this.removeAttribute(r) : this.setAttribute(r, n), this._$Em = null;
    }
  }
  _$AK(t, e) {
    const i = this.constructor, r = i._$Eh.get(t);
    if (r !== void 0 && this._$Em !== r) {
      const n = i.getPropertyOptions(r), a = typeof n.converter == "function" ? { fromAttribute: n.converter } : n.converter?.fromAttribute !== void 0 ? n.converter : e0;
      this._$Em = r;
      const o = a.fromAttribute(e, n.type);
      this[r] = o ?? this._$Ej?.get(r) ?? o, this._$Em = null;
    }
  }
  requestUpdate(t, e, i) {
    if (t !== void 0) {
      const r = this.constructor, n = this[t];
      if (i ??= r.getPropertyOptions(t), !((i.hasChanged ?? EP)(n, e) || i.useDefault && i.reflect && n === this._$Ej?.get(t) && !this.hasAttribute(r._$Eu(t, i)))) return;
      this.C(t, e, i);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$EP());
  }
  C(t, e, { useDefault: i, reflect: r, wrapped: n }, a) {
    i && !(this._$Ej ??= /* @__PURE__ */ new Map()).has(t) && (this._$Ej.set(t, a ?? e ?? this[t]), n !== !0 || a !== void 0) || (this._$AL.has(t) || (this.hasUpdated || i || (e = void 0), this._$AL.set(t, e)), r === !0 && this._$Em !== t && (this._$Eq ??= /* @__PURE__ */ new Set()).add(t));
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [r, n] of this._$Ep) this[r] = n;
        this._$Ep = void 0;
      }
      const i = this.constructor.elementProperties;
      if (i.size > 0) for (const [r, n] of i) {
        const { wrapped: a } = n, o = this[r];
        a !== !0 || this._$AL.has(r) || o === void 0 || this.C(r, void 0, n, o);
      }
    }
    let t = !1;
    const e = this._$AL;
    try {
      t = this.shouldUpdate(e), t ? (this.willUpdate(e), this._$EO?.forEach(((i) => i.hostUpdate?.())), this.update(e)) : this._$EM();
    } catch (i) {
      throw t = !1, this._$EM(), i;
    }
    t && this._$AE(e);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    this._$EO?.forEach(((e) => e.hostUpdated?.())), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$Eq &&= this._$Eq.forEach(((e) => this._$ET(e, this[e]))), this._$EM();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
}, h(Gu, "W"), Gu), yt(Y2, "g"), Y2);
jc.elementStyles = [], jc.shadowRootOptions = { mode: "open" }, jc[xw("elementProperties")] = /* @__PURE__ */ new Map(), jc[xw("finalized")] = /* @__PURE__ */ new Map(), UX?.({ ReactiveElement: jc }), (C1.reactiveElementVersions ??= []).push("2.1.1");
const yb = globalThis, i0 = yb.trustedTypes, a9 = i0 ? i0.createPolicy("lit-html", { createHTML: /* @__PURE__ */ yt((s) => s, "createHTML") }) : void 0, R_ = "$lit$", In = `lit$${Math.random().toFixed(9).slice(2)}$`, E_ = "?" + In, HX = `<${E_}>`, pl = yb.document === void 0 ? { createTreeWalker: /* @__PURE__ */ yt(() => ({}), "createTreeWalker") } : document, Bw = /* @__PURE__ */ yt(() => pl.createComment(""), "l"), Nw = /* @__PURE__ */ yt((s) => s === null || typeof s != "object" && typeof s != "function", "c"), _P = Array.isArray, YX = /* @__PURE__ */ yt((s) => _P(s) || typeof s?.[Symbol.iterator] == "function", "u"), G2 = `[ 	
\f\r]`, hg = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, o9 = /-->/g, l9 = />/g, Za = RegExp(`>|${G2}(?:([^\\s"'>=/]+)(${G2}*=${G2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), c9 = /'/g, h9 = /"/g, __ = /^(?:script|style|textarea|title)$/i, L_ = /* @__PURE__ */ yt((s) => (t, ...e) => ({ _$litType$: s, strings: t, values: e }), "y"), v = L_(1), r0 = L_(2), ms = Symbol.for("lit-noChange"), C = Symbol.for("lit-nothing"), d9 = /* @__PURE__ */ new WeakMap(), po = pl.createTreeWalker(pl, 129);
function LP(s, t) {
  if (!_P(s) || !s.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return a9 !== void 0 ? a9.createHTML(t) : t;
}
h(LP, "Mt$1");
yt(LP, "P");
const GX = /* @__PURE__ */ yt((s, t) => {
  const e = s.length - 1, i = [];
  let r, n = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", a = hg;
  for (let o = 0; o < e; o++) {
    const l = s[o];
    let d, u, p = -1, f = 0;
    for (; f < l.length && (a.lastIndex = f, u = a.exec(l), u !== null); ) f = a.lastIndex, a === hg ? u[1] === "!--" ? a = o9 : u[1] !== void 0 ? a = l9 : u[2] !== void 0 ? (__.test(u[2]) && (r = RegExp("</" + u[2], "g")), a = Za) : u[3] !== void 0 && (a = Za) : a === Za ? u[0] === ">" ? (a = r ?? hg, p = -1) : u[1] === void 0 ? p = -2 : (p = a.lastIndex - u[2].length, d = u[1], a = u[3] === void 0 ? Za : u[3] === '"' ? h9 : c9) : a === h9 || a === c9 ? a = Za : a === o9 || a === l9 ? a = hg : (a = Za, r = void 0);
    const y = a === Za && s[o + 1].startsWith("/>") ? " " : "";
    n += a === hg ? l + HX : p >= 0 ? (i.push(d), l.slice(0, p) + R_ + l.slice(p) + In + y) : l + In + (p === -2 ? o : y);
  }
  return [LP(s, n + (s[e] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), i];
}, "V");
var rl;
const z_ = (rl = class {
  constructor({ strings: t, _$litType$: e }, i) {
    let r;
    this.parts = [];
    let n = 0, a = 0;
    const o = t.length - 1, l = this.parts, [d, u] = GX(t, e);
    if (this.el = rl.createElement(d, i), po.currentNode = this.el.content, e === 2 || e === 3) {
      const p = this.el.content.firstChild;
      p.replaceWith(...p.childNodes);
    }
    for (; (r = po.nextNode()) !== null && l.length < o; ) {
      if (r.nodeType === 1) {
        if (r.hasAttributes()) for (const p of r.getAttributeNames()) if (p.endsWith(R_)) {
          const f = u[a++], y = r.getAttribute(p).split(In), g = /([.?@])?(.*)/.exec(f);
          l.push({ type: 1, index: n, name: g[2], strings: y, ctor: g[1] === "." ? JX : g[1] === "?" ? tj : g[1] === "@" ? ej : wb }), r.removeAttribute(p);
        } else p.startsWith(In) && (l.push({ type: 6, index: n }), r.removeAttribute(p));
        if (__.test(r.tagName)) {
          const p = r.textContent.split(In), f = p.length - 1;
          if (f > 0) {
            r.textContent = i0 ? i0.emptyScript : "";
            for (let y = 0; y < f; y++) r.append(p[y], Bw()), po.nextNode(), l.push({ type: 2, index: ++n });
            r.append(p[f], Bw());
          }
        }
      } else if (r.nodeType === 8) if (r.data === E_) l.push({ type: 2, index: n });
      else {
        let p = -1;
        for (; (p = r.data.indexOf(In, p + 1)) !== -1; ) l.push({ type: 7, index: n }), p += In.length - 1;
      }
      n++;
    }
  }
  static createElement(t, e) {
    const i = pl.createElement("template");
    return i.innerHTML = t, i;
  }
}, h(rl, "ge"), rl);
yt(z_, "N");
let nS = z_;
function fl(s, t, e = s, i) {
  if (t === ms) return t;
  let r = i !== void 0 ? e._$Co?.[i] : e._$Cl;
  const n = Nw(t) ? void 0 : t._$litDirective$;
  return r?.constructor !== n && (r?._$AO?.(!1), n === void 0 ? r = void 0 : (r = new n(s), r._$AT(s, e, i)), i !== void 0 ? (e._$Co ??= [])[i] = r : e._$Cl = r), r !== void 0 && (t = fl(s, r._$AS(s, t.values), r, i)), t;
}
h(fl, "V");
yt(fl, "S");
var Ku;
const I_ = (Ku = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: i } = this._$AD, r = (t?.creationScope ?? pl).importNode(e, !0);
    po.currentNode = r;
    let n = po.nextNode(), a = 0, o = 0, l = i[0];
    for (; l !== void 0; ) {
      if (a === l.index) {
        let d;
        l.type === 2 ? d = new gb(n, n.nextSibling, this, t) : l.type === 1 ? d = new l.ctor(n, l.name, l.strings, this, t) : l.type === 6 && (d = new ij(n, this, t)), this._$AV.push(d), l = i[++o];
      }
      a !== l?.index && (n = po.nextNode(), a++);
    }
    return po.currentNode = pl, r;
  }
  p(t) {
    let e = 0;
    for (const i of this._$AV) i !== void 0 && (i.strings !== void 0 ? (i._$AI(t, i, e), e += i.strings.length - 2) : i._$AI(t[e])), e++;
  }
}, h(Ku, "Ge"), Ku);
yt(I_, "M");
let KX = I_;
var sl;
const D_ = (sl = class {
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(t, e, i, r) {
    this.type = 2, this._$AH = C, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = i, this.options = r, this._$Cv = r?.isConnected ?? !0;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && t?.nodeType === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = fl(this, t, e), Nw(t) ? t === C || t == null || t === "" ? (this._$AH !== C && this._$AR(), this._$AH = C) : t !== this._$AH && t !== ms && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : YX(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== C && Nw(this._$AH) ? this._$AA.nextSibling.data = t : this.T(pl.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    const { values: e, _$litType$: i } = t, r = typeof i == "number" ? this._$AC(t) : (i.el === void 0 && (i.el = nS.createElement(LP(i.h, i.h[0]), this.options)), i);
    if (this._$AH?._$AD === r) this._$AH.p(e);
    else {
      const n = new KX(r, this), a = n.u(this.options);
      n.p(e), this.T(a), this._$AH = n;
    }
  }
  _$AC(t) {
    let e = d9.get(t.strings);
    return e === void 0 && d9.set(t.strings, e = new nS(t)), e;
  }
  k(t) {
    _P(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let i, r = 0;
    for (const n of t) r === e.length ? e.push(i = new sl(this.O(Bw()), this.O(Bw()), this, this.options)) : i = e[r], i._$AI(n), r++;
    r < e.length && (this._$AR(i && i._$AB.nextSibling, r), e.length = r);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    for (this._$AP?.(!1, !0, e); t !== this._$AB; ) {
      const i = t.nextSibling;
      t.remove(), t = i;
    }
  }
  setConnected(t) {
    this._$AM === void 0 && (this._$Cv = t, this._$AP?.(t));
  }
}, h(sl, "me"), sl);
yt(D_, "k");
let gb = D_;
var Ju;
const V_ = (Ju = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, i, r, n) {
    this.type = 1, this._$AH = C, this._$AN = void 0, this.element = t, this.name = e, this._$AM = r, this.options = n, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = C;
  }
  _$AI(t, e = this, i, r) {
    const n = this.strings;
    let a = !1;
    if (n === void 0) t = fl(this, t, e, 0), a = !Nw(t) || t !== this._$AH && t !== ms, a && (this._$AH = t);
    else {
      const o = t;
      let l, d;
      for (t = n[0], l = 0; l < n.length - 1; l++) d = fl(this, o[i + l], e, l), d === ms && (d = this._$AH[l]), a ||= !Nw(d) || d !== this._$AH[l], d === C ? t = C : t !== C && (t += (d ?? "") + n[l + 1]), this._$AH[l] = d;
    }
    a && !r && this.j(t);
  }
  j(t) {
    t === C ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}, h(Ju, "qe"), Ju);
yt(V_, "R");
let wb = V_;
var tp;
const W_ = (tp = class extends wb {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === C ? void 0 : t;
  }
}, h(tp, "Ke"), tp);
yt(W_, "H");
let JX = W_;
var ep;
const F_ = (ep = class extends wb {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== C);
  }
}, h(ep, "Ze"), ep);
yt(F_, "I");
let tj = F_;
var ip;
const q_ = (ip = class extends wb {
  constructor(t, e, i, r, n) {
    super(t, e, i, r, n), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = fl(this, t, e, 0) ?? C) === ms) return;
    const i = this._$AH, r = t === C && i !== C || t.capture !== i.capture || t.once !== i.once || t.passive !== i.passive, n = t !== C && (i === C || r);
    r && this.element.removeEventListener(this.name, this, i), n && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    typeof this._$AH == "function" ? this._$AH.call(this.options?.host ?? this.element, t) : this._$AH.handleEvent(t);
  }
}, h(ip, "Je"), ip);
yt(q_, "L");
let ej = q_;
var rp;
const Z_ = (rp = class {
  constructor(t, e, i) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = i;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    fl(this, t);
  }
}, h(rp, "Xe"), rp);
yt(Z_, "z");
let ij = Z_;
const rj = { I: gb }, sj = yb.litHtmlPolyfillSupport;
sj?.(nS, gb), (yb.litHtmlVersions ??= []).push("3.3.1");
const nj = /* @__PURE__ */ yt((s, t, e) => {
  const i = e?.renderBefore ?? t;
  let r = i._$litPart$;
  if (r === void 0) {
    const n = e?.renderBefore ?? null;
    i._$litPart$ = r = new gb(t.insertBefore(Bw(), n), n, void 0, e ?? {});
  }
  return r._$AI(s), r;
}, "j"), zP = globalThis;
var sp;
const B_ = (sp = class extends jc {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    const t = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t.firstChild, t;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = nj(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(!0);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(!1);
  }
  render() {
    return ms;
  }
}, h(sp, "Qe"), sp);
yt(B_, "i");
let wt = B_;
wt._$litElement$ = !0, wt.finalized = !0, zP.litElementHydrateSupport?.({ LitElement: wt });
const aj = zP.litElementPolyfillSupport;
aj?.({ LitElement: wt });
(zP.litElementVersions ??= []).push("4.2.1");
v`<strong>${0}</strong> redigerade <em>${1}</em>`, v`<strong>${0}</strong> nämnde dig i ett inlägg`, v`<strong>${0}</strong> kommenterade på <strong>${1}</strong>`, v`<strong>${0}</strong> reagerade med ${1} på <em>${2}</em>`, v`<strong>${0}</strong> svarade på ett inlägg`, v`<strong>${0}</strong> redigerade ett inlägg`, v`<strong>${0}</strong> nämnde dig i ett meddelande`, v`<strong>${0}</strong> nämnde dig i en kommentar`, v`<strong>${0}</strong> och <strong>${1}</strong> röstade i din omröstning`, v`<strong>${0}</strong> reagerade med ${1} på ditt inlägg`, v`<strong>${0}</strong> reagerade med ${1} på din kommentar`, v`Nytt meddelande från <strong>${0}</strong>`, v`<strong>${0}</strong> svarade på ditt inlägg`, v`<strong>${0}</strong> röstade i din omröstning`, v`<strong>${0}</strong> publicerade ett inlägg i <strong>${1}</strong>`, v`<strong>${0}</strong> gillade ditt meddelande`, v`<strong>${0}</strong>, <strong>${1}</strong> och <strong>${2}</strong> röstade i din omröstning`, v`<strong>${0}</strong> lade till <em>${1}</em> till <strong>${2}</strong>`, v`<strong>${0}</strong> skickade ett meddelande i <strong>${1}</strong>`, v`<strong>${0}</strong> reagerade med ${1} på ditt meddelande`, v`<strong>${0}</strong> gillade <em>${1}</em>`, v`<strong>${0}</strong> gillade ditt inlägg`, v`<strong>${0}</strong> gillade din kommentar`, v`<strong>${0}</strong> och ${1} andra röstade i din omröstning`, v`<strong>${0}</strong> kommenterade på <em>${1}</em>`, lt`${0} svarade på ditt inlägg`, lt`${0} röstade i din omröstning`, lt`${0} skriver${1}`, lt`${0} och ${1} röstade i din omröstning`, lt`${0} kommenterade på ${1}`, lt`${0} gillade ${1}`, lt`${0} skickade ett meddelande i ${1}`, lt`${0} redigerade ett inlägg`, lt`Röster på ${0}`, lt`${0} kommentarer`, lt`Sedd av ${0} vid ${1}`, lt`${0} och ${1} andra röstade i din omröstning`, lt`Nytt meddelande från ${0}`, lt`${0} reagerade med ${1} på ditt inlägg`, lt`${0} nämnde dig i ett inlägg`, lt`${0} nämnde dig i en kommentar`, lt`${0} publicerade ett inlägg i ${1}`, lt`${0} gillade ditt inlägg`, lt`${0} nämnde dig i ett meddelande`, lt`${0} reagerade med ${1} på din kommentar`, lt`Öppna i ${0}`, lt`${0} svarade på ett inlägg`, lt`${0} lade till ${1} till ${2}`, lt`${0} redigerade ${1}`, lt`${0} gillade ditt meddelande`, lt`${0}, ${1} och ${2} röstade i din omröstning`, lt`Alternativ ${0}`, lt`${0} reagerade med ${1} på ${2}`, lt`${0} reagerade med ${1} på ditt meddelande`, lt`${0} gillade din kommentar`, lt`${0} skriver${1}`;
var oj = Object.defineProperty, N_ = /* @__PURE__ */ h((s) => {
  throw TypeError(s);
}, "Hw"), c = /* @__PURE__ */ h((s, t) => oj(s, "name", { value: t, configurable: !0 }), "a"), IP = /* @__PURE__ */ h((s, t, e) => t.has(s) || N_("Cannot " + e), "Ou"), x = /* @__PURE__ */ h((s, t, e) => (IP(s, t, "read from private field"), e ? e.call(s) : t.get(s)), "y"), q = /* @__PURE__ */ h((s, t, e) => t.has(s) ? N_("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(s) : t.set(s, e), "O"), E = /* @__PURE__ */ h((s, t, e, i) => (IP(s, t, "write to private field"), t.set(s, e), e), "_"), kt = /* @__PURE__ */ h((s, t, e) => (IP(s, t, "access private method"), e), "lt"), aS = /* @__PURE__ */ h((s, t, e, i) => ({
  set _(r) {
    E(s, t, r);
  },
  get _() {
    return x(s, t, i);
  }
}), "Rd");
function Xw(s) {
  return Object.prototype.toString.call(s) === "[object Object]";
}
h(Xw, "Ud");
c(Xw, "isObject");
function sn(s) {
  if (Xw(s) === !1) return !1;
  const t = s.constructor;
  if (t === void 0) return !0;
  const e = t.prototype;
  return !(Xw(e) === !1 || Object.prototype.hasOwnProperty.call(e, "isPrototypeOf") === !1);
}
h(sn, "Dr");
c(sn, "isPlainObject$1");
function s0(s) {
  return typeof s.toJSON == "function";
}
h(s0, "Yu");
c(s0, "hasToJSON");
function X_(s) {
  return typeof s == "boolean" || typeof s == "number" || typeof s == "string" || s === null || sn(s) || Array.isArray(s);
}
h(X_, "E1");
c(X_, "isJSONSerializable");
function go(s, t, e = !1) {
  s = s || {}, t = t || {};
  const i = {};
  for (const r in s)
    Object.prototype.hasOwnProperty.call(s, r) && (i[r] = s[r]);
  for (const r in t)
    Object.prototype.hasOwnProperty.call(t, r) && (e && i[r] && sn(i[r]) && sn(t[r]) ? i[r] = go(i[r], t[r], e) : i[r] = t[r]);
  return i;
}
h(go, "Pa");
c(go, "assign");
function j_(s) {
  return s ? Array.isArray(s) ? s : [s] : [];
}
h(j_, "R1");
c(j_, "asArray");
async function U_(s, t) {
  for (const e of s)
    if (await t(e))
      return e;
}
h(U_, "T1");
c(U_, "findAsyncSequential");
function wo(s, t, e = !1, i = !1) {
  if (!i && (!sn(s) || !sn(t)) || i && (!Xw(s) || !Xw(t)))
    return !1;
  const r = Object.getOwnPropertyNames(s), n = Object.getOwnPropertyNames(t);
  if (!e && r.length !== n.length)
    return !1;
  for (let a = 0; a < r.length; a++) {
    const o = r[a], l = s[o], d = t[o];
    if (l !== d && !wo(l, d, e))
      return !1;
  }
  return !0;
}
h(wo, "_a");
c(wo, "eqObjects");
function DP(s) {
  return Object.entries(s);
}
h(DP, "am");
c(DP, "objectAsIterable");
function VP(s) {
  return s.charAt(0).toUpperCase() + s.substring(1).toLowerCase();
}
h(VP, "sm");
c(VP, "toUpperCaseFirst");
const lj = '\\s,.:;"', cj = new RegExp(`^|[${lj}]|$`, "g"), hj = ".!?", dj = new RegExp(`^|(?<=[${hj}])|$`);
function WP(s) {
  return s.length > 0 ? s.replace(/([a-z\d])([A-Z]+)/g, "$1-$2").replace(/_|\s+/g, "-").toLowerCase() : s;
}
h(WP, "om");
c(WP, "toKebabCase");
function H_(s, t = 2) {
  if (!s)
    return null;
  let e = "";
  const i = s.split(cj).filter((r) => r);
  return i.length == 1 ? e = i[0] : i.forEach((r) => {
    e += r.charAt(0);
  }), e.substring(0, t).toUpperCase();
}
h(H_, "F1");
c(H_, "getInitials");
function FP(s) {
  let t;
  const e = s.split(dj).filter((i) => i);
  return e.length ? t = e[0] : t = s, t;
}
h(FP, "cm");
c(FP, "getTitleFromText");
function qP(s, t = 256) {
  return s.length > t && (s = s.substring(0, t - 1) + "…"), s;
}
h(qP, "lm");
c(qP, "truncateText");
const uj = /^[\p{Extended_Pictographic}\p{Emoji_Presentation}]+$/u;
function Y_(s) {
  return !!s?.match(uj)?.length;
}
h(Y_, "V1");
c(Y_, "checkOnlyEmojis");
const pj = {
  //mode: 'cors', // no-cors, *cors, same-origin
  // cache: 'default' means the server is in control of the caching which is preferred instead of using 'reload'
  //cache: 'default', // *default, no-cache, reload, force-cache, only-if-cached
  credentials: "omit",
  // include, *same-origin, omit
  headers: {
    // https://stackoverflow.com/questions/8163703/cross-domain-ajax-doesnt-send-x-requested-with-header
    "X-Requested-With": "XMLHttpRequest"
  },
  redirect: "manual"
  // manual, *follow, error
  //referrerPolicy: 'no-referrer-when-downgrade', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
};
function G_() {
  const s = /* @__PURE__ */ new WeakSet(), t = /* @__PURE__ */ c(function(e, i) {
    if (s0(i) && (i = i.toJSON()), !(i !== null && typeof i == "object"))
      return i;
    if (s.has(i))
      return "[Circular]";
    let r;
    if (s.add(i), sn(i)) {
      const n = {};
      Object.keys(i).forEach((a) => {
        n[a] = t(a, i[a]);
      }), r = n;
    } else Array.isArray(i) && (r = i.map((n, a) => t(a, n)));
    return s.delete(i), r;
  }, "replacer");
  return t;
}
h(G_, "B1");
c(G_, "getCircularReferenceReplacer");
function gy() {
  return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
}
h(gy, "fl");
c(gy, "S4");
function K_(s) {
  if (s && s.ok && s.body) {
    const t = s.body.getReader();
    return new ReadableStream({
      start(e) {
        const i = /* @__PURE__ */ c(() => t.read().then(({ done: r, value: n }) => {
          if (r) {
            e.close();
            return;
          }
          return e.enqueue(n), i();
        }), "pump");
        return i();
      }
    });
  } else
    throw new Error("Could not parse text stream");
}
h(K_, "N1");
c(K_, "getTextStreamFromResponse");
function ZP(s) {
  let t;
  try {
    if (t = window[s], t) {
      const e = "__storage_test__";
      t.setItem(e, e), t.removeItem(e);
    }
  } catch (e) {
    e instanceof DOMException && e.name === "QuotaExceededError" && // acknowledge QuotaExceededError only if there's something already stored
    t && t.length !== 0 && console.error("Storage not available:", s);
  }
  return t;
}
h(ZP, "dm");
c(ZP, "getStorage");
var np;
const J_ = (np = class extends Error {
  constructor() {
    super("Instance destroyed"), this.name = "DestroyError";
  }
}, h(np, "Wy"), np);
c(J_, "DestroyError");
let Ee = J_;
const fj = /* @__PURE__ */ c((s) => {
  var e;
  var t;
  return t = (e = class extends s {
    // AUTHENTICATION
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), this._whenTokenFactory = new Promise((n) => {
        this._resolveTokenFactory = n;
      }), this._whenUrlAndTokenFactory = new Promise((n) => {
        this._resolveUrlAndTokenFactory = (a) => {
          n(a), this.configurationState = "configured";
        };
      }), this._whenTokenIsValid = new Promise((n) => {
        this._resolveTokenIsValid = n;
      }), this._tokenPromise = null, this._token = "", this._validTokenFromFactory = async (n = !1) => {
        const a = [this.whenTokenFactory()];
        this.tokenFactoryRetryDelay >= 0 && this.tokenFactoryRetryDelay < 1 / 0 && a.push(new Promise((l) => setTimeout(l, this.tokenFactoryRetryDelay))), await Promise.race(a);
        const o = await this.tokenFactory?.(n) ?? "";
        if (this._validateToken(o)) {
          if (n && o === this._token && this.tokenFactoryRetryDelay >= 0 && this.tokenFactoryRetryDelay < 1 / 0)
            return await new Promise((l) => setTimeout(l, this.tokenFactoryRetryDelay)), await this._validTokenFromFactory(!0);
        } else if (this._whenTokenFactory = new Promise((l) => {
          this._resolveTokenFactory = l;
        }), !n)
          return await this._validTokenFromFactory(!1);
        if (!o)
          throw new TypeError("Could not get a valid token from tokenFactory.");
        return this._resolveTokenFactory?.(!0), this.whenUrl().then(this._resolveUrlAndTokenFactory), o;
      }, Promise.all([this.whenUrl(), this.whenTokenFactory()]).then(() => {
        this.url && this.tokenFactory && this._resolveUrlAndTokenFactory?.(!0);
      });
    }
    async whenTokenFactory() {
      await this._whenTokenFactory;
    }
    async whenUrlAndTokenFactory() {
      await this._whenUrlAndTokenFactory;
    }
    async whenTokenIsValid() {
      await this._whenTokenIsValid;
    }
    /**
     * Async function returning an `access_token` string for _your_ authenticated user. A boolean `refresh` parameter is provided to let you now if a fresh token is needed from Weavy.
     */
    get tokenFactory() {
      return this._tokenFactory;
    }
    set tokenFactory(r) {
      if (this.isDestroyed)
        throw new Ee();
      this._tokenFactory && this._tokenFactory !== r && this.whenTokenFactory().then(() => {
        this.queryClient.refetchQueries({ stale: !0 });
      }), this._tokenFactory = r ?? void 0, this._tokenFactory && queueMicrotask(() => {
        this._resolveTokenFactory?.(!0);
      });
    }
    /**
     * An URL to an endpoint returning an JSON data containing an `access_token` string property for _your_ authenticated user. A boolean `refresh=true` query parameter is provided in the request to let you now if when a fresh token is needed from Weavy.
     */
    get tokenUrl() {
      return this._tokenUrl;
    }
    set tokenUrl(r) {
      if (this.isDestroyed)
        throw new Ee();
      try {
        if (typeof r == "string")
          r && (this._tokenUrl = new URL(r, window.location.toString()));
        else if (r instanceof URL)
          this._tokenUrl = r;
        else if (r == null)
          this._tokenUrl = void 0;
        else
          throw new Error();
      } catch (n) {
        throw new Error("Invalid url", n);
      }
      this._tokenUrl && !this.tokenFactory && (this.tokenFactory = async (n) => {
        if (!this.tokenUrl)
          throw new Error("tokenURL property is not valid");
        const a = new URL(this.tokenUrl);
        n ? a.searchParams.set("refresh", "true") : a.searchParams.delete("refresh");
        const o = await fetch(a);
        if (o.ok) {
          const l = await o.json();
          if (l.access_token === void 0)
            throw new Error("Token response does not contain required property: access_token");
          return l.access_token;
        } else
          throw new Error("Could not get access token from server!");
      });
    }
    _validateToken(r) {
      if (!r)
        return !1;
      if (typeof r != "string")
        throw new TypeError(`You have provided an invalid string access token of type ${typeof r}.`);
      if (typeof r == "string" && !r.startsWith("wyu_"))
        throw r.startsWith("wys_") ? new TypeError("You have provided an API key for authentication. Provide a user access token instead.") : new TypeError("You have provided an invalid string as access token.");
      return this._resolveTokenIsValid?.(r), !0;
    }
    async getToken(r = !1) {
      if (this.isDestroyed)
        throw new Ee();
      if (this._token && !r)
        return this._token;
      if (this._tokenPromise)
        return await this._tokenPromise;
      this._tokenPromise = new Promise((n, a) => {
        this._validTokenFromFactory(r).then(n).catch(a), this.tokenFactoryTimeout >= 0 && this.tokenFactoryTimeout < 1 / 0 && setTimeout(() => a(new Error("Token factory timeout.")), this.tokenFactoryTimeout), window.addEventListener("offline", () => a(new Error("Network changed.")), { once: !0 }), window.addEventListener("online", () => a(new Error("Network changed.")), { once: !0 });
      });
      try {
        const n = await this._tokenPromise;
        return this._tokenPromise = null, this._token = n, this._token;
      } catch (n) {
        throw this._tokenPromise = null, n;
      }
    }
  }, h(e, "t"), e), c(t, "WeavyAuthentication"), t;
}, "WeavyAuthenticationMixin");
var mv = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function tL(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
h(tL, "q1");
c(tL, "getDefaultExportFromCjs");
function Nv(s) {
  throw new Error('Could not dynamically require "' + s + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
h(Nv, "zu");
c(Nv, "commonjsRequire");
var u9 = { exports: {} }, p9;
function eL() {
  return p9 || (p9 = 1, (function(s, t) {
    var e;
    e = /* @__PURE__ */ c(() => (() => {
      var ec, ic, rc, sc, nc, ac, oc, lc, cc, hc, dc, uc, Cs, pc, fc, mc, yc, gc, Ps, wc, vc, Oc, bc, Va, $c, xc, kc, Sc, Cc, Pc, Qc, Tc, Wa, Mc, Ac, Rc;
      var i = { d: /* @__PURE__ */ c((H, w) => {
        for (var S in w) i.o(w, S) && !i.o(H, S) && Object.defineProperty(H, S, { enumerable: !0, get: w[S] });
      }, "d") };
      i.g = (function() {
        if (typeof globalThis == "object") return globalThis;
        try {
          return this || new Function("return this")();
        } catch {
          if (typeof window == "object") return window;
        }
      })(), i.o = (H, w) => Object.prototype.hasOwnProperty.call(H, w), i.r = (H) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(H, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(H, "t", { value: !0 });
      };
      var r, n = {};
      i.r(n), i.d(n, { AbortError: /* @__PURE__ */ c(() => p, "AbortError"), DefaultHttpClient: /* @__PURE__ */ c(() => g3, "DefaultHttpClient"), HttpClient: /* @__PURE__ */ c(() => tt, "HttpClient"), HttpError: /* @__PURE__ */ c(() => o, "HttpError"), HttpResponse: /* @__PURE__ */ c(() => V, "HttpResponse"), HttpTransportType: /* @__PURE__ */ c(() => Ae, "HttpTransportType"), HubConnection: /* @__PURE__ */ c(() => S3, "HubConnection"), HubConnectionBuilder: /* @__PURE__ */ c(() => IW, "HubConnectionBuilder"), HubConnectionState: /* @__PURE__ */ c(() => ne, "HubConnectionState"), JsonHubProtocol: /* @__PURE__ */ c(() => V3, "JsonHubProtocol"), LogLevel: /* @__PURE__ */ c(() => r, "LogLevel"), MessageType: /* @__PURE__ */ c(() => zt, "MessageType"), NullLogger: /* @__PURE__ */ c(() => dt, "NullLogger"), Subject: /* @__PURE__ */ c(() => b3, "Subject"), TimeoutError: /* @__PURE__ */ c(() => d, "TimeoutError"), TransferFormat: /* @__PURE__ */ c(() => ri, "TransferFormat"), VERSION: /* @__PURE__ */ c(() => st, "VERSION") });
      const a = (ec = class extends Error {
        constructor(w, S) {
          const M = new.target.prototype;
          super(`${w}: Status code '${S}'`), this.statusCode = S, this.__proto__ = M;
        }
      }, h(ec, "iu"), ec);
      c(a, "i");
      let o = a;
      const l = (ic = class extends Error {
        constructor(w = "A timeout occurred.") {
          const S = new.target.prototype;
          super(w), this.__proto__ = S;
        }
      }, h(ic, "ru"), ic);
      c(l, "n");
      let d = l;
      const u = (rc = class extends Error {
        constructor(w = "An abort occurred.") {
          const S = new.target.prototype;
          super(w), this.__proto__ = S;
        }
      }, h(rc, "nu"), rc);
      c(u, "r");
      let p = u;
      const f = (sc = class extends Error {
        constructor(w, S) {
          const M = new.target.prototype;
          super(w), this.transport = S, this.errorType = "UnsupportedTransportError", this.__proto__ = M;
        }
      }, h(sc, "au"), sc);
      c(f, "o");
      let y = f;
      const g = (nc = class extends Error {
        constructor(w, S) {
          const M = new.target.prototype;
          super(w), this.transport = S, this.errorType = "DisabledTransportError", this.__proto__ = M;
        }
      }, h(nc, "su"), nc);
      c(g, "h");
      let O = g;
      const k = (ac = class extends Error {
        constructor(w, S) {
          const M = new.target.prototype;
          super(w), this.transport = S, this.errorType = "FailedToStartTransportError", this.__proto__ = M;
        }
      }, h(ac, "ou"), ac);
      c(k, "c");
      let $ = k;
      const T = (oc = class extends Error {
        constructor(w) {
          const S = new.target.prototype;
          super(w), this.errorType = "FailedToNegotiateWithServerError", this.__proto__ = S;
        }
      }, h(oc, "cu"), oc);
      c(T, "a");
      let _ = T;
      const D = (lc = class extends Error {
        constructor(w, S) {
          const M = new.target.prototype;
          super(w), this.innerErrors = S, this.__proto__ = M;
        }
      }, h(lc, "lu"), lc);
      c(D, "l");
      let A = D;
      const z = (cc = class {
        constructor(w, S, M) {
          this.statusCode = w, this.statusText = S, this.content = M;
        }
      }, h(cc, "du"), cc);
      c(z, "u");
      let V = z;
      const X = (hc = class {
        get(w, S) {
          return this.send({ ...S, method: "GET", url: w });
        }
        post(w, S) {
          return this.send({ ...S, method: "POST", url: w });
        }
        delete(w, S) {
          return this.send({ ...S, method: "DELETE", url: w });
        }
        getCookieString(w) {
          return "";
        }
      }, h(hc, "hu"), hc);
      c(X, "d");
      let tt = X;
      (function(H) {
        H[H.Trace = 0] = "Trace", H[H.Debug = 1] = "Debug", H[H.Information = 2] = "Information", H[H.Warning = 3] = "Warning", H[H.Error = 4] = "Error", H[H.Critical = 5] = "Critical", H[H.None = 6] = "None";
      })(r || (r = {}));
      const vt = (dc = class {
        constructor() {
        }
        log(w, S) {
        }
      }, h(dc, "uu"), dc);
      c(vt, "f");
      let dt = vt;
      dt.instance = new dt();
      const st = "9.0.6", Pt = (uc = class {
        static isRequired(w, S) {
          if (w == null) throw new Error(`The '${S}' argument is required.`);
        }
        static isNotEmpty(w, S) {
          if (!w || w.match(/^\s*$/)) throw new Error(`The '${S}' argument should not be empty.`);
        }
        static isIn(w, S, M) {
          if (!(w in S)) throw new Error(`Unknown ${M} value: ${w}.`);
        }
      }, h(uc, "pu"), uc);
      c(Pt, "w");
      let ct = Pt;
      const Vt = (Cs = class {
        static get isBrowser() {
          return !Cs.isNode && typeof window == "object" && typeof window.document == "object";
        }
        static get isWebWorker() {
          return !Cs.isNode && typeof self == "object" && "importScripts" in self;
        }
        static get isReactNative() {
          return !Cs.isNode && typeof window == "object" && window.document === void 0;
        }
        static get isNode() {
          return typeof process < "u" && process.release && process.release.name === "node";
        }
      }, h(Cs, "sa"), Cs);
      c(Vt, "g");
      let _t = Vt;
      function Zt(H, w) {
        let S = "";
        return Nt(H) ? (S = `Binary data of length ${H.byteLength}`, w && (S += `. Content: '${(function(M) {
          const R = new Uint8Array(M);
          let W = "";
          return R.forEach(((Z) => {
            W += `0x${Z < 16 ? "0" : ""}${Z.toString(16)} `;
          })), W.substr(0, W.length - 1);
        })(H)}'`)) : typeof H == "string" && (S = `String data of length ${H.length}`, w && (S += `. Content: '${H}'`)), S;
      }
      h(Zt, "W"), c(Zt, "m");
      function Nt(H) {
        return H && typeof ArrayBuffer < "u" && (H instanceof ArrayBuffer || H.constructor && H.constructor.name === "ArrayBuffer");
      }
      h(Nt, "I"), c(Nt, "y");
      async function Xt(H, w, S, M, R, W) {
        const Z = {}, [ut, pt] = be();
        Z[ut] = pt, H.log(r.Trace, `(${w} transport) sending data. ${Zt(R, W.logMessageContent)}.`);
        const It = Nt(R) ? "arraybuffer" : "text", ie = await S.post(M, { content: R, headers: { ...Z, ...W.headers }, responseType: It, timeout: W.timeout, withCredentials: W.withCredentials });
        H.log(r.Trace, `(${w} transport) request complete. Response status: ${ie.statusCode}.`);
      }
      h(Xt, "U"), c(Xt, "b");
      const Li = (pc = class {
        constructor(w, S) {
          this.i = w, this.h = S;
        }
        dispose() {
          const w = this.i.observers.indexOf(this.h);
          w > -1 && this.i.observers.splice(w, 1), this.i.observers.length === 0 && this.i.cancelCallback && this.i.cancelCallback().catch(((S) => {
          }));
        }
      }, h(pc, "yu"), pc);
      c(Li, "v");
      let qe = Li;
      const fe = (fc = class {
        constructor(w) {
          this.l = w, this.out = console;
        }
        log(w, S) {
          if (w >= this.l) {
            const M = `[${(/* @__PURE__ */ new Date()).toISOString()}] ${r[w]}: ${S}`;
            switch (w) {
              case r.Critical:
              case r.Error:
                this.out.error(M);
                break;
              case r.Warning:
                this.out.warn(M);
                break;
              case r.Information:
                this.out.info(M);
                break;
              default:
                this.out.log(M);
            }
          }
        }
      }, h(fc, "wu"), fc);
      c(fe, "E");
      let oe = fe;
      function be() {
        let H = "X-SignalR-User-Agent";
        return _t.isNode && (H = "User-Agent"), [H, zi(st, Yi(), _t.isNode ? "NodeJS" : "Browser", pr())];
      }
      h(be, "ot"), c(be, "$");
      function zi(H, w, S, M) {
        let R = "Microsoft SignalR/";
        const W = H.split(".");
        return R += `${W[0]}.${W[1]}`, R += ` (${H}; `, R += w && w !== "" ? `${w}; ` : "Unknown OS; ", R += `${S}`, R += M ? `; ${M}` : "; Unknown Runtime Version", R += ")", R;
      }
      h(zi, "rt"), c(zi, "C");
      function Yi() {
        if (!_t.isNode) return "";
        switch (process.platform) {
          case "win32":
            return "Windows NT";
          case "darwin":
            return "macOS";
          case "linux":
            return "Linux";
          default:
            return process.platform;
        }
      }
      h(Yi, "Lt"), c(Yi, "S");
      function pr() {
        if (_t.isNode) return process.versions.node;
      }
      h(pr, "Ot"), c(pr, "k");
      function ee(H) {
        return H.stack ? H.stack : H.message ? H.message : `${H}`;
      }
      h(ee, "At"), c(ee, "P");
      const Tr = (mc = class extends tt {
        constructor(w) {
          if (super(), this.u = w, typeof fetch > "u" || _t.isNode) {
            const S = Nv;
            this.p = new (S("tough-cookie")).CookieJar(), typeof fetch > "u" ? this.m = S("node-fetch") : this.m = fetch, this.m = S("fetch-cookie")(this.m, this.p);
          } else this.m = fetch.bind((function() {
            if (typeof globalThis < "u") return globalThis;
            if (typeof self < "u") return self;
            if (typeof window < "u") return window;
            if (i.g !== void 0) return i.g;
            throw new Error("could not find global");
          })());
          if (typeof AbortController > "u") {
            const S = Nv;
            this.v = S("abort-controller");
          } else this.v = AbortController;
        }
        async send(w) {
          if (w.abortSignal && w.abortSignal.aborted) throw new p();
          if (!w.method) throw new Error("No method defined.");
          if (!w.url) throw new Error("No url defined.");
          const S = new this.v();
          let M;
          w.abortSignal && (w.abortSignal.onabort = () => {
            S.abort(), M = new p();
          });
          let R, W = null;
          if (w.timeout) {
            const pt = w.timeout;
            W = setTimeout((() => {
              S.abort(), this.u.log(r.Warning, "Timeout from HTTP request."), M = new d();
            }), pt);
          }
          w.content === "" && (w.content = void 0), w.content && (w.headers = w.headers || {}, Nt(w.content) ? w.headers["Content-Type"] = "application/octet-stream" : w.headers["Content-Type"] = "text/plain;charset=UTF-8");
          try {
            R = await this.m(w.url, { body: w.content, cache: "no-cache", credentials: w.withCredentials === !0 ? "include" : "same-origin", headers: { "X-Requested-With": "XMLHttpRequest", ...w.headers }, method: w.method, mode: "cors", redirect: "follow", signal: S.signal });
          } catch (pt) {
            throw M || (this.u.log(r.Warning, `Error from HTTP request. ${pt}.`), pt);
          } finally {
            W && clearTimeout(W), w.abortSignal && (w.abortSignal.onabort = null);
          }
          if (!R.ok) {
            const pt = await tc(R, "text");
            throw new o(pt || R.statusText, R.status);
          }
          const Z = tc(R, w.responseType), ut = await Z;
          return new V(R.status, R.statusText, ut);
        }
        getCookieString(w) {
          let S = "";
          return _t.isNode && this.p && this.p.getCookies(w, ((M, R) => S = R.join("; "))), S;
        }
      }, h(mc, "fu"), mc);
      c(Tr, "T");
      let Ia = Tr;
      function tc(H, w) {
        let S;
        switch (w) {
          case "arraybuffer":
            S = H.arrayBuffer();
            break;
          case "text":
          default:
            S = H.text();
            break;
          case "blob":
          case "document":
          case "json":
            throw new Error(`${w} is not supported.`);
        }
        return S;
      }
      h(tc, "Bt"), c(tc, "I");
      const m3 = (yc = class extends tt {
        constructor(w) {
          super(), this.u = w;
        }
        send(w) {
          return w.abortSignal && w.abortSignal.aborted ? Promise.reject(new p()) : w.method ? w.url ? new Promise(((S, M) => {
            const R = new XMLHttpRequest();
            R.open(w.method, w.url, !0), R.withCredentials = w.withCredentials === void 0 || w.withCredentials, R.setRequestHeader("X-Requested-With", "XMLHttpRequest"), w.content === "" && (w.content = void 0), w.content && (Nt(w.content) ? R.setRequestHeader("Content-Type", "application/octet-stream") : R.setRequestHeader("Content-Type", "text/plain;charset=UTF-8"));
            const W = w.headers;
            W && Object.keys(W).forEach(((Z) => {
              R.setRequestHeader(Z, W[Z]);
            })), w.responseType && (R.responseType = w.responseType), w.abortSignal && (w.abortSignal.onabort = () => {
              R.abort(), M(new p());
            }), w.timeout && (R.timeout = w.timeout), R.onload = () => {
              w.abortSignal && (w.abortSignal.onabort = null), R.status >= 200 && R.status < 300 ? S(new V(R.status, R.statusText, R.response || R.responseText)) : M(new o(R.response || R.responseText || R.statusText, R.status));
            }, R.onerror = () => {
              this.u.log(r.Warning, `Error from HTTP request. ${R.status}: ${R.statusText}.`), M(new o(R.statusText, R.status));
            }, R.ontimeout = () => {
              this.u.log(r.Warning, "Timeout from HTTP request."), M(new d());
            }, R.send(w.content);
          })) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."));
        }
      }, h(yc, "mu"), yc);
      c(m3, "_");
      let SW = m3;
      const y3 = (gc = class extends tt {
        constructor(w) {
          if (super(), typeof fetch < "u" || _t.isNode) this.$ = new Ia(w);
          else {
            if (typeof XMLHttpRequest > "u") throw new Error("No usable HttpClient found.");
            this.$ = new SW(w);
          }
        }
        send(w) {
          return w.abortSignal && w.abortSignal.aborted ? Promise.reject(new p()) : w.method ? w.url ? this.$.send(w) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."));
        }
        getCookieString(w) {
          return this.$.getCookieString(w);
        }
      }, h(gc, "vu"), gc);
      c(y3, "H");
      let g3 = y3;
      const w3 = (Ps = class {
        static write(w) {
          return `${w}${Ps.RecordSeparator}`;
        }
        static parse(w) {
          if (w[w.length - 1] !== Ps.RecordSeparator) throw new Error("Message is incomplete.");
          const S = w.split(Ps.RecordSeparator);
          return S.pop(), S;
        }
      }, h(Ps, "oa"), Ps);
      c(w3, "D");
      let Ss = w3;
      Ss.RecordSeparatorCode = 30, Ss.RecordSeparator = String.fromCharCode(Ss.RecordSeparatorCode);
      const v3 = (wc = class {
        writeHandshakeRequest(w) {
          return Ss.write(JSON.stringify(w));
        }
        parseHandshakeResponse(w) {
          let S, M;
          if (Nt(w)) {
            const Z = new Uint8Array(w), ut = Z.indexOf(Ss.RecordSeparatorCode);
            if (ut === -1) throw new Error("Message is incomplete.");
            const pt = ut + 1;
            S = String.fromCharCode.apply(null, Array.prototype.slice.call(Z.slice(0, pt))), M = Z.byteLength > pt ? Z.slice(pt).buffer : null;
          } else {
            const Z = w, ut = Z.indexOf(Ss.RecordSeparator);
            if (ut === -1) throw new Error("Message is incomplete.");
            const pt = ut + 1;
            S = Z.substring(0, pt), M = Z.length > pt ? Z.substring(pt) : null;
          }
          const R = Ss.parse(S), W = JSON.parse(R[0]);
          if (W.type) throw new Error("Expected a handshake response from the server.");
          return [M, W];
        }
      }, h(wc, "gu"), wc);
      c(v3, "R");
      let CW = v3;
      var zt, ne;
      (function(H) {
        H[H.Invocation = 1] = "Invocation", H[H.StreamItem = 2] = "StreamItem", H[H.Completion = 3] = "Completion", H[H.StreamInvocation = 4] = "StreamInvocation", H[H.CancelInvocation = 5] = "CancelInvocation", H[H.Ping = 6] = "Ping", H[H.Close = 7] = "Close", H[H.Ack = 8] = "Ack", H[H.Sequence = 9] = "Sequence";
      })(zt || (zt = {}));
      const O3 = (vc = class {
        constructor() {
          this.observers = [];
        }
        next(w) {
          for (const S of this.observers) S.next(w);
        }
        error(w) {
          for (const S of this.observers) S.error && S.error(w);
        }
        complete() {
          for (const w of this.observers) w.complete && w.complete();
        }
        subscribe(w) {
          return this.observers.push(w), new qe(this, w);
        }
      }, h(vc, "bu"), vc);
      c(O3, "U");
      let b3 = O3;
      const $3 = (Oc = class {
        constructor(w, S, M) {
          this.C = 1e5, this.S = [], this.k = 0, this.P = !1, this.T = 1, this.I = 0, this._ = 0, this.H = !1, this.D = w, this.R = S, this.C = M;
        }
        async A(w) {
          const S = this.D.writeMessage(w);
          let M = Promise.resolve();
          if (this.U(w)) {
            this.k++;
            let R = /* @__PURE__ */ c(() => {
            }, "t"), W = /* @__PURE__ */ c(() => {
            }, "i");
            Nt(S) ? this._ += S.byteLength : this._ += S.length, this._ >= this.C && (M = new Promise(((Z, ut) => {
              R = Z, W = ut;
            }))), this.S.push(new QW(S, this.k, R, W));
          }
          try {
            this.H || await this.R.send(S);
          } catch {
            this.L();
          }
          await M;
        }
        N(w) {
          let S = -1;
          for (let M = 0; M < this.S.length; M++) {
            const R = this.S[M];
            if (R.q <= w.sequenceId) S = M, Nt(R.M) ? this._ -= R.M.byteLength : this._ -= R.M.length, R.j();
            else {
              if (!(this._ < this.C)) break;
              R.j();
            }
          }
          S !== -1 && (this.S = this.S.slice(S + 1));
        }
        W(w) {
          if (this.P) return w.type === zt.Sequence && (this.P = !1, !0);
          if (!this.U(w)) return !0;
          const S = this.T;
          return this.T++, S <= this.I ? (S === this.I && this.O(), !1) : (this.I = S, this.O(), !0);
        }
        F(w) {
          w.sequenceId > this.T ? this.R.stop(new Error("Sequence ID greater than amount of messages we've received.")) : this.T = w.sequenceId;
        }
        L() {
          this.H = !0, this.P = !0;
        }
        async B() {
          const w = this.S.length !== 0 ? this.S[0].q : this.k + 1;
          await this.R.send(this.D.writeMessage({ type: zt.Sequence, sequenceId: w }));
          const S = this.S;
          for (const M of S) await this.R.send(M.M);
          this.H = !1;
        }
        X(w) {
          w != null || (w = new Error("Unable to reconnect to server."));
          for (const S of this.S) S.J(w);
        }
        U(w) {
          switch (w.type) {
            case zt.Invocation:
            case zt.StreamItem:
            case zt.Completion:
            case zt.StreamInvocation:
            case zt.CancelInvocation:
              return !0;
            case zt.Close:
            case zt.Sequence:
            case zt.Ping:
            case zt.Ack:
              return !1;
          }
        }
        O() {
          this.V === void 0 && (this.V = setTimeout((async () => {
            try {
              this.H || await this.R.send(this.D.writeMessage({ type: zt.Ack, sequenceId: this.I }));
            } catch {
            }
            clearTimeout(this.V), this.V = void 0;
          }), 1e3));
        }
      }, h(Oc, "xu"), Oc);
      c($3, "L");
      let PW = $3;
      const x3 = (bc = class {
        constructor(w, S, M, R) {
          this.M = w, this.q = S, this.j = M, this.J = R;
        }
      }, h(bc, "Cu"), bc);
      c(x3, "N");
      let QW = x3;
      (function(H) {
        H.Disconnected = "Disconnected", H.Connecting = "Connecting", H.Connected = "Connected", H.Disconnecting = "Disconnecting", H.Reconnecting = "Reconnecting";
      })(ne || (ne = {}));
      const k3 = (Va = class {
        static create(w, S, M, R, W, Z, ut) {
          return new Va(w, S, M, R, W, Z, ut);
        }
        constructor(w, S, M, R, W, Z, ut) {
          this.K = 0, this.G = () => {
            this.u.log(r.Warning, "The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep");
          }, ct.isRequired(w, "connection"), ct.isRequired(S, "logger"), ct.isRequired(M, "protocol"), this.serverTimeoutInMilliseconds = W ?? 3e4, this.keepAliveIntervalInMilliseconds = Z ?? 15e3, this.Y = ut ?? 1e5, this.u = S, this.D = M, this.connection = w, this.Z = R, this.tt = new CW(), this.connection.onreceive = (pt) => this.et(pt), this.connection.onclose = (pt) => this.st(pt), this.it = {}, this.nt = {}, this.rt = [], this.ot = [], this.ht = [], this.ct = 0, this.lt = !1, this.ut = ne.Disconnected, this.dt = !1, this.ft = this.D.writeMessage({ type: zt.Ping });
        }
        get state() {
          return this.ut;
        }
        get connectionId() {
          return this.connection && this.connection.connectionId || null;
        }
        get baseUrl() {
          return this.connection.baseUrl || "";
        }
        set baseUrl(w) {
          if (this.ut !== ne.Disconnected && this.ut !== ne.Reconnecting) throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");
          if (!w) throw new Error("The HubConnection url must be a valid url.");
          this.connection.baseUrl = w;
        }
        start() {
          return this.wt = this.gt(), this.wt;
        }
        async gt() {
          if (this.ut !== ne.Disconnected) return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));
          this.ut = ne.Connecting, this.u.log(r.Debug, "Starting HubConnection.");
          try {
            await this.yt(), _t.isBrowser && window.document.addEventListener("freeze", this.G), this.ut = ne.Connected, this.dt = !0, this.u.log(r.Debug, "HubConnection connected successfully.");
          } catch (w) {
            return this.ut = ne.Disconnected, this.u.log(r.Debug, `HubConnection failed to start successfully because of error '${w}'.`), Promise.reject(w);
          }
        }
        async yt() {
          this.bt = void 0, this.lt = !1;
          const w = new Promise(((S, M) => {
            this.vt = S, this.Et = M;
          }));
          await this.connection.start(this.D.transferFormat);
          try {
            let S = this.D.version;
            this.connection.features.reconnect || (S = 1);
            const M = { protocol: this.D.name, version: S };
            if (this.u.log(r.Debug, "Sending handshake request."), await this.$t(this.tt.writeHandshakeRequest(M)), this.u.log(r.Information, `Using HubProtocol '${this.D.name}'.`), this.Ct(), this.St(), this.kt(), await w, this.bt) throw this.bt;
            this.connection.features.reconnect && (this.Pt = new PW(this.D, this.connection, this.Y), this.connection.features.disconnected = this.Pt.L.bind(this.Pt), this.connection.features.resend = () => {
              if (this.Pt) return this.Pt.B();
            }), this.connection.features.inherentKeepAlive || await this.$t(this.ft);
          } catch (S) {
            throw this.u.log(r.Debug, `Hub handshake failed with error '${S}' during start(). Stopping HubConnection.`), this.Ct(), this.Tt(), await this.connection.stop(S), S;
          }
        }
        async stop() {
          const w = this.wt;
          this.connection.features.reconnect = !1, this.It = this._t(), await this.It;
          try {
            await w;
          } catch {
          }
        }
        _t(w) {
          if (this.ut === ne.Disconnected) return this.u.log(r.Debug, `Call to HubConnection.stop(${w}) ignored because it is already in the disconnected state.`), Promise.resolve();
          if (this.ut === ne.Disconnecting) return this.u.log(r.Debug, `Call to HttpConnection.stop(${w}) ignored because the connection is already in the disconnecting state.`), this.It;
          const S = this.ut;
          return this.ut = ne.Disconnecting, this.u.log(r.Debug, "Stopping HubConnection."), this.Ht ? (this.u.log(r.Debug, "Connection stopped during reconnect delay. Done reconnecting."), clearTimeout(this.Ht), this.Ht = void 0, this.Dt(), Promise.resolve()) : (S === ne.Connected && this.Rt(), this.Ct(), this.Tt(), this.bt = w || new p("The connection was stopped before the hub handshake could complete."), this.connection.stop(w));
        }
        async Rt() {
          try {
            await this.xt(this.At());
          } catch {
          }
        }
        stream(w, ...S) {
          const [M, R] = this.Ut(S), W = this.Lt(w, S, R);
          let Z;
          const ut = new b3();
          return ut.cancelCallback = () => {
            const pt = this.Nt(W.invocationId);
            return delete this.it[W.invocationId], Z.then((() => this.xt(pt)));
          }, this.it[W.invocationId] = (pt, It) => {
            It ? ut.error(It) : pt && (pt.type === zt.Completion ? pt.error ? ut.error(new Error(pt.error)) : ut.complete() : ut.next(pt.item));
          }, Z = this.xt(W).catch(((pt) => {
            ut.error(pt), delete this.it[W.invocationId];
          })), this.qt(M, Z), ut;
        }
        $t(w) {
          return this.kt(), this.connection.send(w);
        }
        xt(w) {
          return this.Pt ? this.Pt.A(w) : this.$t(this.D.writeMessage(w));
        }
        send(w, ...S) {
          const [M, R] = this.Ut(S), W = this.xt(this.Mt(w, S, !0, R));
          return this.qt(M, W), W;
        }
        invoke(w, ...S) {
          const [M, R] = this.Ut(S), W = this.Mt(w, S, !1, R);
          return new Promise(((Z, ut) => {
            this.it[W.invocationId] = (It, ie) => {
              ie ? ut(ie) : It && (It.type === zt.Completion ? It.error ? ut(new Error(It.error)) : Z(It.result) : ut(new Error(`Unexpected message type: ${It.type}`)));
            };
            const pt = this.xt(W).catch(((It) => {
              ut(It), delete this.it[W.invocationId];
            }));
            this.qt(M, pt);
          }));
        }
        on(w, S) {
          w && S && (w = w.toLowerCase(), this.nt[w] || (this.nt[w] = []), this.nt[w].indexOf(S) === -1 && this.nt[w].push(S));
        }
        off(w, S) {
          if (!w) return;
          w = w.toLowerCase();
          const M = this.nt[w];
          if (M) if (S) {
            const R = M.indexOf(S);
            R !== -1 && (M.splice(R, 1), M.length === 0 && delete this.nt[w]);
          } else delete this.nt[w];
        }
        onclose(w) {
          w && this.rt.push(w);
        }
        onreconnecting(w) {
          w && this.ot.push(w);
        }
        onreconnected(w) {
          w && this.ht.push(w);
        }
        et(w) {
          if (this.Ct(), this.lt || (w = this.jt(w), this.lt = !0), w) {
            const S = this.D.parseMessages(w, this.u);
            for (const M of S) if (!this.Pt || this.Pt.W(M)) switch (M.type) {
              case zt.Invocation:
                this.Wt(M).catch(((R) => {
                  this.u.log(r.Error, `Invoke client method threw error: ${ee(R)}`);
                }));
                break;
              case zt.StreamItem:
              case zt.Completion: {
                const R = this.it[M.invocationId];
                if (R) {
                  M.type === zt.Completion && delete this.it[M.invocationId];
                  try {
                    R(M);
                  } catch (W) {
                    this.u.log(r.Error, `Stream callback threw error: ${ee(W)}`);
                  }
                }
                break;
              }
              case zt.Ping:
                break;
              case zt.Close: {
                this.u.log(r.Information, "Close message received from server.");
                const R = M.error ? new Error("Server returned an error on close: " + M.error) : void 0;
                M.allowReconnect === !0 ? this.connection.stop(R) : this.It = this._t(R);
                break;
              }
              case zt.Ack:
                this.Pt && this.Pt.N(M);
                break;
              case zt.Sequence:
                this.Pt && this.Pt.F(M);
                break;
              default:
                this.u.log(r.Warning, `Invalid message type: ${M.type}.`);
            }
          }
          this.St();
        }
        jt(w) {
          let S, M;
          try {
            [M, S] = this.tt.parseHandshakeResponse(w);
          } catch (R) {
            const W = "Error parsing handshake response: " + R;
            this.u.log(r.Error, W);
            const Z = new Error(W);
            throw this.Et(Z), Z;
          }
          if (S.error) {
            const R = "Server returned handshake error: " + S.error;
            this.u.log(r.Error, R);
            const W = new Error(R);
            throw this.Et(W), W;
          }
          return this.u.log(r.Debug, "Server handshake complete."), this.vt(), M;
        }
        kt() {
          this.connection.features.inherentKeepAlive || (this.K = (/* @__PURE__ */ new Date()).getTime() + this.keepAliveIntervalInMilliseconds, this.Tt());
        }
        St() {
          if (!(this.connection.features && this.connection.features.inherentKeepAlive || (this.Ot = setTimeout((() => this.serverTimeout()), this.serverTimeoutInMilliseconds), this.Ft !== void 0))) {
            let w = this.K - (/* @__PURE__ */ new Date()).getTime();
            w < 0 && (w = 0), this.Ft = setTimeout((async () => {
              if (this.ut === ne.Connected) try {
                await this.$t(this.ft);
              } catch {
                this.Tt();
              }
            }), w);
          }
        }
        serverTimeout() {
          this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."));
        }
        async Wt(w) {
          const S = w.target.toLowerCase(), M = this.nt[S];
          if (!M) return this.u.log(r.Warning, `No client method with the name '${S}' found.`), void (w.invocationId && (this.u.log(r.Warning, `No result given for '${S}' method and invocation ID '${w.invocationId}'.`), await this.xt(this.Bt(w.invocationId, "Client didn't provide a result.", null))));
          const R = M.slice(), W = !!w.invocationId;
          let Z, ut, pt;
          for (const It of R) try {
            const ie = Z;
            Z = await It.apply(this, w.arguments), W && Z && ie && (this.u.log(r.Error, `Multiple results provided for '${S}'. Sending error to server.`), pt = this.Bt(w.invocationId, "Client provided multiple results.", null)), ut = void 0;
          } catch (ie) {
            ut = ie, this.u.log(r.Error, `A callback for the method '${S}' threw error '${ie}'.`);
          }
          pt ? await this.xt(pt) : W ? (ut ? pt = this.Bt(w.invocationId, `${ut}`, null) : Z !== void 0 ? pt = this.Bt(w.invocationId, null, Z) : (this.u.log(r.Warning, `No result given for '${S}' method and invocation ID '${w.invocationId}'.`), pt = this.Bt(w.invocationId, "Client didn't provide a result.", null)), await this.xt(pt)) : Z && this.u.log(r.Error, `Result given for '${S}' method but server is not expecting a result.`);
        }
        st(w) {
          this.u.log(r.Debug, `HubConnection.connectionClosed(${w}) called while in state ${this.ut}.`), this.bt = this.bt || w || new p("The underlying connection was closed before the hub handshake could complete."), this.vt && this.vt(), this.Xt(w || new Error("Invocation canceled due to the underlying connection being closed.")), this.Ct(), this.Tt(), this.ut === ne.Disconnecting ? this.Dt(w) : this.ut === ne.Connected && this.Z ? this.Jt(w) : this.ut === ne.Connected && this.Dt(w);
        }
        Dt(w) {
          if (this.dt) {
            this.ut = ne.Disconnected, this.dt = !1, this.Pt && (this.Pt.X(w ?? new Error("Connection closed.")), this.Pt = void 0), _t.isBrowser && window.document.removeEventListener("freeze", this.G);
            try {
              this.rt.forEach(((S) => S.apply(this, [w])));
            } catch (S) {
              this.u.log(r.Error, `An onclose callback called with error '${w}' threw error '${S}'.`);
            }
          }
        }
        async Jt(w) {
          const S = Date.now();
          let M = 0, R = w !== void 0 ? w : new Error("Attempting to reconnect due to a unknown error."), W = this.zt(M++, 0, R);
          if (W === null) return this.u.log(r.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."), void this.Dt(w);
          if (this.ut = ne.Reconnecting, w ? this.u.log(r.Information, `Connection reconnecting because of error '${w}'.`) : this.u.log(r.Information, "Connection reconnecting."), this.ot.length !== 0) {
            try {
              this.ot.forEach(((Z) => Z.apply(this, [w])));
            } catch (Z) {
              this.u.log(r.Error, `An onreconnecting callback called with error '${w}' threw error '${Z}'.`);
            }
            if (this.ut !== ne.Reconnecting) return void this.u.log(r.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.");
          }
          for (; W !== null; ) {
            if (this.u.log(r.Information, `Reconnect attempt number ${M} will start in ${W} ms.`), await new Promise(((Z) => {
              this.Ht = setTimeout(Z, W);
            })), this.Ht = void 0, this.ut !== ne.Reconnecting) return void this.u.log(r.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting.");
            try {
              if (await this.yt(), this.ut = ne.Connected, this.u.log(r.Information, "HubConnection reconnected successfully."), this.ht.length !== 0) try {
                this.ht.forEach(((Z) => Z.apply(this, [this.connection.connectionId])));
              } catch (Z) {
                this.u.log(r.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${Z}'.`);
              }
              return;
            } catch (Z) {
              if (this.u.log(r.Information, `Reconnect attempt failed because of error '${Z}'.`), this.ut !== ne.Reconnecting) return this.u.log(r.Debug, `Connection moved to the '${this.ut}' from the reconnecting state during reconnect attempt. Done reconnecting.`), void (this.ut === ne.Disconnecting && this.Dt());
              R = Z instanceof Error ? Z : new Error(Z.toString()), W = this.zt(M++, Date.now() - S, R);
            }
          }
          this.u.log(r.Information, `Reconnect retries have been exhausted after ${Date.now() - S} ms and ${M} failed attempts. Connection disconnecting.`), this.Dt();
        }
        zt(w, S, M) {
          try {
            return this.Z.nextRetryDelayInMilliseconds({ elapsedMilliseconds: S, previousRetryCount: w, retryReason: M });
          } catch (R) {
            return this.u.log(r.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${w}, ${S}) threw error '${R}'.`), null;
          }
        }
        Xt(w) {
          const S = this.it;
          this.it = {}, Object.keys(S).forEach(((M) => {
            const R = S[M];
            try {
              R(null, w);
            } catch (W) {
              this.u.log(r.Error, `Stream 'error' callback called with '${w}' threw error: ${ee(W)}`);
            }
          }));
        }
        Tt() {
          this.Ft && (clearTimeout(this.Ft), this.Ft = void 0);
        }
        Ct() {
          this.Ot && clearTimeout(this.Ot);
        }
        Mt(w, S, M, R) {
          if (M) return R.length !== 0 ? { target: w, arguments: S, streamIds: R, type: zt.Invocation } : { target: w, arguments: S, type: zt.Invocation };
          {
            const W = this.ct;
            return this.ct++, R.length !== 0 ? { target: w, arguments: S, invocationId: W.toString(), streamIds: R, type: zt.Invocation } : { target: w, arguments: S, invocationId: W.toString(), type: zt.Invocation };
          }
        }
        qt(w, S) {
          if (w.length !== 0) {
            S || (S = Promise.resolve());
            for (const M in w) w[M].subscribe({ complete: /* @__PURE__ */ c(() => {
              S = S.then((() => this.xt(this.Bt(M))));
            }, "complete"), error: /* @__PURE__ */ c((R) => {
              let W;
              W = R instanceof Error ? R.message : R && R.toString ? R.toString() : "Unknown error", S = S.then((() => this.xt(this.Bt(M, W))));
            }, "error"), next: /* @__PURE__ */ c((R) => {
              S = S.then((() => this.xt(this.Vt(M, R))));
            }, "next") });
          }
        }
        Ut(w) {
          const S = [], M = [];
          for (let R = 0; R < w.length; R++) {
            const W = w[R];
            if (this.Kt(W)) {
              const Z = this.ct;
              this.ct++, S[Z] = W, M.push(Z.toString()), w.splice(R, 1);
            }
          }
          return [S, M];
        }
        Kt(w) {
          return w && w.subscribe && typeof w.subscribe == "function";
        }
        Lt(w, S, M) {
          const R = this.ct;
          return this.ct++, M.length !== 0 ? { target: w, arguments: S, invocationId: R.toString(), streamIds: M, type: zt.StreamInvocation } : { target: w, arguments: S, invocationId: R.toString(), type: zt.StreamInvocation };
        }
        Nt(w) {
          return { invocationId: w, type: zt.CancelInvocation };
        }
        Vt(w, S) {
          return { invocationId: w, item: S, type: zt.StreamItem };
        }
        Bt(w, S, M) {
          return S ? { error: S, invocationId: w, type: zt.Completion } : { invocationId: w, result: M, type: zt.Completion };
        }
        At() {
          return { type: zt.Close };
        }
      }, h(Va, "Ad"), Va);
      c(k3, "q");
      let S3 = k3;
      const TW = [0, 2e3, 1e4, 3e4, null], C3 = ($c = class {
        constructor(w) {
          this.Gt = w !== void 0 ? [...w, null] : TW;
        }
        nextRetryDelayInMilliseconds(w) {
          return this.Gt[w.previousRetryCount];
        }
      }, h($c, "$u"), $c);
      c(C3, "j");
      let P3 = C3;
      const Q3 = (xc = class {
      }, h(xc, "ku"), xc);
      c(Q3, "W");
      let Da = Q3;
      Da.Authorization = "Authorization", Da.Cookie = "Cookie";
      const T3 = (kc = class extends tt {
        constructor(w, S) {
          super(), this.Qt = w, this.Yt = S;
        }
        async send(w) {
          let S = !0;
          this.Yt && (!this.Zt || w.url && w.url.indexOf("/negotiate?") > 0) && (S = !1, this.Zt = await this.Yt()), this.te(w);
          const M = await this.Qt.send(w);
          return S && M.statusCode === 401 && this.Yt ? (this.Zt = await this.Yt(), this.te(w), await this.Qt.send(w)) : M;
        }
        te(w) {
          w.headers || (w.headers = {}), this.Zt ? w.headers[Da.Authorization] = `Bearer ${this.Zt}` : this.Yt && w.headers[Da.Authorization] && delete w.headers[Da.Authorization];
        }
        getCookieString(w) {
          return this.Qt.getCookieString(w);
        }
      }, h(kc, "Pu"), kc);
      c(T3, "O");
      let MW = T3;
      var Ae, ri;
      (function(H) {
        H[H.None = 0] = "None", H[H.WebSockets = 1] = "WebSockets", H[H.ServerSentEvents = 2] = "ServerSentEvents", H[H.LongPolling = 4] = "LongPolling";
      })(Ae || (Ae = {})), (function(H) {
        H[H.Text = 1] = "Text", H[H.Binary = 2] = "Binary";
      })(ri || (ri = {}));
      const M3 = (Sc = class {
        constructor() {
          this.ee = !1, this.onabort = null;
        }
        abort() {
          this.ee || (this.ee = !0, this.onabort && this.onabort());
        }
        get signal() {
          return this;
        }
        get aborted() {
          return this.ee;
        }
      }, h(Sc, "_u"), Sc);
      c(M3, "X");
      let AW = M3;
      const A3 = (Cc = class {
        get pollAborted() {
          return this.se.aborted;
        }
        constructor(w, S, M) {
          this.$ = w, this.u = S, this.se = new AW(), this.ie = M, this.ne = !1, this.onreceive = null, this.onclose = null;
        }
        async connect(w, S) {
          if (ct.isRequired(w, "url"), ct.isRequired(S, "transferFormat"), ct.isIn(S, ri, "transferFormat"), this.re = w, this.u.log(r.Trace, "(LongPolling transport) Connecting."), S === ri.Binary && typeof XMLHttpRequest < "u" && typeof new XMLHttpRequest().responseType != "string") throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");
          const [M, R] = be(), W = { [M]: R, ...this.ie.headers }, Z = { abortSignal: this.se.signal, headers: W, timeout: 1e5, withCredentials: this.ie.withCredentials };
          S === ri.Binary && (Z.responseType = "arraybuffer");
          const ut = `${w}&_=${Date.now()}`;
          this.u.log(r.Trace, `(LongPolling transport) polling: ${ut}.`);
          const pt = await this.$.get(ut, Z);
          pt.statusCode !== 200 ? (this.u.log(r.Error, `(LongPolling transport) Unexpected response code: ${pt.statusCode}.`), this.oe = new o(pt.statusText || "", pt.statusCode), this.ne = !1) : this.ne = !0, this.he = this.ce(this.re, Z);
        }
        async ce(w, S) {
          try {
            for (; this.ne; ) try {
              const M = `${w}&_=${Date.now()}`;
              this.u.log(r.Trace, `(LongPolling transport) polling: ${M}.`);
              const R = await this.$.get(M, S);
              R.statusCode === 204 ? (this.u.log(r.Information, "(LongPolling transport) Poll terminated by server."), this.ne = !1) : R.statusCode !== 200 ? (this.u.log(r.Error, `(LongPolling transport) Unexpected response code: ${R.statusCode}.`), this.oe = new o(R.statusText || "", R.statusCode), this.ne = !1) : R.content ? (this.u.log(r.Trace, `(LongPolling transport) data received. ${Zt(R.content, this.ie.logMessageContent)}.`), this.onreceive && this.onreceive(R.content)) : this.u.log(r.Trace, "(LongPolling transport) Poll timed out, reissuing.");
            } catch (M) {
              this.ne ? M instanceof d ? this.u.log(r.Trace, "(LongPolling transport) Poll timed out, reissuing.") : (this.oe = M, this.ne = !1) : this.u.log(r.Trace, `(LongPolling transport) Poll errored after shutdown: ${M.message}`);
            }
          } finally {
            this.u.log(r.Trace, "(LongPolling transport) Polling complete."), this.pollAborted || this.ae();
          }
        }
        async send(w) {
          return this.ne ? Xt(this.u, "LongPolling", this.$, this.re, w, this.ie) : Promise.reject(new Error("Cannot send until the transport is connected"));
        }
        async stop() {
          this.u.log(r.Trace, "(LongPolling transport) Stopping polling."), this.ne = !1, this.se.abort();
          try {
            await this.he, this.u.log(r.Trace, `(LongPolling transport) sending DELETE request to ${this.re}.`);
            const w = {}, [S, M] = be();
            w[S] = M;
            const R = { headers: { ...w, ...this.ie.headers }, timeout: this.ie.timeout, withCredentials: this.ie.withCredentials };
            let W;
            try {
              await this.$.delete(this.re, R);
            } catch (Z) {
              W = Z;
            }
            W ? W instanceof o && (W.statusCode === 404 ? this.u.log(r.Trace, "(LongPolling transport) A 404 response was returned from sending a DELETE request.") : this.u.log(r.Trace, `(LongPolling transport) Error sending a DELETE request: ${W}`)) : this.u.log(r.Trace, "(LongPolling transport) DELETE request accepted.");
          } finally {
            this.u.log(r.Trace, "(LongPolling transport) Stop finished."), this.ae();
          }
        }
        ae() {
          if (this.onclose) {
            let w = "(LongPolling transport) Firing onclose event.";
            this.oe && (w += " Error: " + this.oe), this.u.log(r.Trace, w), this.onclose(this.oe);
          }
        }
      }, h(Cc, "Su"), Cc);
      c(A3, "J");
      let R3 = A3;
      const E3 = (Pc = class {
        constructor(w, S, M, R) {
          this.$ = w, this.Zt = S, this.u = M, this.ie = R, this.onreceive = null, this.onclose = null;
        }
        async connect(w, S) {
          return ct.isRequired(w, "url"), ct.isRequired(S, "transferFormat"), ct.isIn(S, ri, "transferFormat"), this.u.log(r.Trace, "(SSE transport) Connecting."), this.re = w, this.Zt && (w += (w.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(this.Zt)}`), new Promise(((M, R) => {
            let W, Z = !1;
            if (S === ri.Text) {
              if (_t.isBrowser || _t.isWebWorker) W = new this.ie.EventSource(w, { withCredentials: this.ie.withCredentials });
              else {
                const ut = this.$.getCookieString(w), pt = {};
                pt.Cookie = ut;
                const [It, ie] = be();
                pt[It] = ie, W = new this.ie.EventSource(w, { withCredentials: this.ie.withCredentials, headers: { ...pt, ...this.ie.headers } });
              }
              try {
                W.onmessage = (ut) => {
                  if (this.onreceive) try {
                    this.u.log(r.Trace, `(SSE transport) data received. ${Zt(ut.data, this.ie.logMessageContent)}.`), this.onreceive(ut.data);
                  } catch (pt) {
                    return void this.le(pt);
                  }
                }, W.onerror = (ut) => {
                  Z ? this.le() : R(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled."));
                }, W.onopen = () => {
                  this.u.log(r.Information, `SSE connected to ${this.re}`), this.ue = W, Z = !0, M();
                };
              } catch (ut) {
                return void R(ut);
              }
            } else R(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));
          }));
        }
        async send(w) {
          return this.ue ? Xt(this.u, "SSE", this.$, this.re, w, this.ie) : Promise.reject(new Error("Cannot send until the transport is connected"));
        }
        stop() {
          return this.le(), Promise.resolve();
        }
        le(w) {
          this.ue && (this.ue.close(), this.ue = void 0, this.onclose && this.onclose(w));
        }
      }, h(Pc, "Mu"), Pc);
      c(E3, "z");
      let RW = E3;
      const _3 = (Qc = class {
        constructor(w, S, M, R, W, Z) {
          this.u = M, this.Yt = S, this.de = R, this.fe = W, this.$ = w, this.onreceive = null, this.onclose = null, this.pe = Z;
        }
        async connect(w, S) {
          let M;
          return ct.isRequired(w, "url"), ct.isRequired(S, "transferFormat"), ct.isIn(S, ri, "transferFormat"), this.u.log(r.Trace, "(WebSockets transport) Connecting."), this.Yt && (M = await this.Yt()), new Promise(((R, W) => {
            let Z;
            w = w.replace(/^http/, "ws");
            const ut = this.$.getCookieString(w);
            let pt = !1;
            if (_t.isNode || _t.isReactNative) {
              const It = {}, [ie, Ec] = be();
              It[ie] = Ec, M && (It[Da.Authorization] = `Bearer ${M}`), ut && (It[Da.Cookie] = ut), Z = new this.fe(w, void 0, { headers: { ...It, ...this.pe } });
            } else M && (w += (w.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(M)}`);
            Z || (Z = new this.fe(w)), S === ri.Binary && (Z.binaryType = "arraybuffer"), Z.onopen = (It) => {
              this.u.log(r.Information, `WebSocket connected to ${w}.`), this.we = Z, pt = !0, R();
            }, Z.onerror = (It) => {
              let ie = null;
              ie = typeof ErrorEvent < "u" && It instanceof ErrorEvent ? It.error : "There was an error with the transport", this.u.log(r.Information, `(WebSockets transport) ${ie}.`);
            }, Z.onmessage = (It) => {
              if (this.u.log(r.Trace, `(WebSockets transport) data received. ${Zt(It.data, this.de)}.`), this.onreceive) try {
                this.onreceive(It.data);
              } catch (ie) {
                return void this.le(ie);
              }
            }, Z.onclose = (It) => {
              if (pt) this.le(It);
              else {
                let ie = null;
                ie = typeof ErrorEvent < "u" && It instanceof ErrorEvent ? It.error : "WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.", W(new Error(ie));
              }
            };
          }));
        }
        send(w) {
          return this.we && this.we.readyState === this.fe.OPEN ? (this.u.log(r.Trace, `(WebSockets transport) sending data. ${Zt(w, this.de)}.`), this.we.send(w), Promise.resolve()) : Promise.reject("WebSocket is not in the OPEN state");
        }
        stop() {
          return this.we && this.le(void 0), Promise.resolve();
        }
        le(w) {
          this.we && (this.we.onclose = () => {
          }, this.we.onmessage = () => {
          }, this.we.onerror = () => {
          }, this.we.close(), this.we = void 0), this.u.log(r.Trace, "(WebSockets transport) socket closed."), this.onclose && (!this.ge(w) || w.wasClean !== !1 && w.code === 1e3 ? w instanceof Error ? this.onclose(w) : this.onclose() : this.onclose(new Error(`WebSocket closed with status code: ${w.code} (${w.reason || "no reason given"}).`)));
        }
        ge(w) {
          return w && typeof w.wasClean == "boolean" && typeof w.code == "number";
        }
      }, h(Qc, "Au"), Qc);
      c(_3, "V");
      let EW = _3;
      const L3 = (Tc = class {
        constructor(w, S = {}) {
          var M;
          if (this.me = () => {
          }, this.features = {}, this.ye = 1, ct.isRequired(w, "url"), this.u = (M = S.logger) === void 0 ? new oe(r.Information) : M === null ? dt.instance : M.log !== void 0 ? M : new oe(M), this.baseUrl = this.be(w), (S = S || {}).logMessageContent = S.logMessageContent !== void 0 && S.logMessageContent, typeof S.withCredentials != "boolean" && S.withCredentials !== void 0) throw new Error("withCredentials option was not a 'boolean' or 'undefined' value");
          S.withCredentials = S.withCredentials === void 0 || S.withCredentials, S.timeout = S.timeout === void 0 ? 1e5 : S.timeout;
          let R = null, W = null;
          if (_t.isNode) {
            const Z = Nv;
            R = Z("ws"), W = Z("eventsource");
          }
          _t.isNode || typeof WebSocket > "u" || S.WebSocket ? _t.isNode && !S.WebSocket && R && (S.WebSocket = R) : S.WebSocket = WebSocket, _t.isNode || typeof EventSource > "u" || S.EventSource ? _t.isNode && !S.EventSource && W !== void 0 && (S.EventSource = W) : S.EventSource = EventSource, this.$ = new MW(S.httpClient || new g3(this.u), S.accessTokenFactory), this.ut = "Disconnected", this.dt = !1, this.ie = S, this.onreceive = null, this.onclose = null;
        }
        async start(w) {
          if (w = w || ri.Binary, ct.isIn(w, ri, "transferFormat"), this.u.log(r.Debug, `Starting connection with transfer format '${ri[w]}'.`), this.ut !== "Disconnected") return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."));
          if (this.ut = "Connecting", this.ve = this.yt(w), await this.ve, this.ut === "Disconnecting") {
            const S = "Failed to start the HttpConnection before stop() was called.";
            return this.u.log(r.Error, S), await this.It, Promise.reject(new p(S));
          }
          if (this.ut !== "Connected") {
            const S = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";
            return this.u.log(r.Error, S), Promise.reject(new p(S));
          }
          this.dt = !0;
        }
        send(w) {
          return this.ut !== "Connected" ? Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State.")) : (this.Ee || (this.Ee = new LW(this.transport)), this.Ee.send(w));
        }
        async stop(w) {
          return this.ut === "Disconnected" ? (this.u.log(r.Debug, `Call to HttpConnection.stop(${w}) ignored because the connection is already in the disconnected state.`), Promise.resolve()) : this.ut === "Disconnecting" ? (this.u.log(r.Debug, `Call to HttpConnection.stop(${w}) ignored because the connection is already in the disconnecting state.`), this.It) : (this.ut = "Disconnecting", this.It = new Promise(((S) => {
            this.me = S;
          })), await this._t(w), void await this.It);
        }
        async _t(w) {
          this.$e = w;
          try {
            await this.ve;
          } catch {
          }
          if (this.transport) {
            try {
              await this.transport.stop();
            } catch (S) {
              this.u.log(r.Error, `HttpConnection.transport.stop() threw error '${S}'.`), this.Ce();
            }
            this.transport = void 0;
          } else this.u.log(r.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.");
        }
        async yt(w) {
          let S = this.baseUrl;
          this.Yt = this.ie.accessTokenFactory, this.$.Yt = this.Yt;
          try {
            if (this.ie.skipNegotiation) {
              if (this.ie.transport !== Ae.WebSockets) throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");
              this.transport = this.Se(Ae.WebSockets), await this.ke(S, w);
            } else {
              let M = null, R = 0;
              do {
                if (M = await this.Pe(S), this.ut === "Disconnecting" || this.ut === "Disconnected") throw new p("The connection was stopped during negotiation.");
                if (M.error) throw new Error(M.error);
                if (M.ProtocolVersion) throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");
                if (M.url && (S = M.url), M.accessToken) {
                  const W = M.accessToken;
                  this.Yt = () => W, this.$.Zt = W, this.$.Yt = void 0;
                }
                R++;
              } while (M.url && R < 100);
              if (R === 100 && M.url) throw new Error("Negotiate redirection limit exceeded.");
              await this.Te(S, this.ie.transport, M, w);
            }
            this.transport instanceof R3 && (this.features.inherentKeepAlive = !0), this.ut === "Connecting" && (this.u.log(r.Debug, "The HttpConnection connected successfully."), this.ut = "Connected");
          } catch (M) {
            return this.u.log(r.Error, "Failed to start the connection: " + M), this.ut = "Disconnected", this.transport = void 0, this.me(), Promise.reject(M);
          }
        }
        async Pe(w) {
          const S = {}, [M, R] = be();
          S[M] = R;
          const W = this.Ie(w);
          this.u.log(r.Debug, `Sending negotiation request: ${W}.`);
          try {
            const Z = await this.$.post(W, { content: "", headers: { ...S, ...this.ie.headers }, timeout: this.ie.timeout, withCredentials: this.ie.withCredentials });
            if (Z.statusCode !== 200) return Promise.reject(new Error(`Unexpected status code returned from negotiate '${Z.statusCode}'`));
            const ut = JSON.parse(Z.content);
            return (!ut.negotiateVersion || ut.negotiateVersion < 1) && (ut.connectionToken = ut.connectionId), ut.useStatefulReconnect && this.ie._e !== !0 ? Promise.reject(new _("Client didn't negotiate Stateful Reconnect but the server did.")) : ut;
          } catch (Z) {
            let ut = "Failed to complete negotiation with the server: " + Z;
            return Z instanceof o && Z.statusCode === 404 && (ut += " Either this is not a SignalR endpoint or there is a proxy blocking the connection."), this.u.log(r.Error, ut), Promise.reject(new _(ut));
          }
        }
        He(w, S) {
          return S ? w + (w.indexOf("?") === -1 ? "?" : "&") + `id=${S}` : w;
        }
        async Te(w, S, M, R) {
          let W = this.He(w, M.connectionToken);
          if (this.De(S)) return this.u.log(r.Debug, "Connection was provided an instance of ITransport, using that directly."), this.transport = S, await this.ke(W, R), void (this.connectionId = M.connectionId);
          const Z = [], ut = M.availableTransports || [];
          let pt = M;
          for (const It of ut) {
            const ie = this.Re(It, S, R, pt?.useStatefulReconnect === !0);
            if (ie instanceof Error) Z.push(`${It.transport} failed:`), Z.push(ie);
            else if (this.De(ie)) {
              if (this.transport = ie, !pt) {
                try {
                  pt = await this.Pe(w);
                } catch (Ec) {
                  return Promise.reject(Ec);
                }
                W = this.He(w, pt.connectionToken);
              }
              try {
                return await this.ke(W, R), void (this.connectionId = pt.connectionId);
              } catch (Ec) {
                if (this.u.log(r.Error, `Failed to start the transport '${It.transport}': ${Ec}`), pt = void 0, Z.push(new $(`${It.transport} failed: ${Ec}`, Ae[It.transport])), this.ut !== "Connecting") {
                  const F3 = "Failed to select transport before stop() was called.";
                  return this.u.log(r.Debug, F3), Promise.reject(new p(F3));
                }
              }
            }
          }
          return Z.length > 0 ? Promise.reject(new A(`Unable to connect to the server with any of the available transports. ${Z.join(" ")}`, Z)) : Promise.reject(new Error("None of the transports supported by the client are supported by the server."));
        }
        Se(w) {
          switch (w) {
            case Ae.WebSockets:
              if (!this.ie.WebSocket) throw new Error("'WebSocket' is not supported in your environment.");
              return new EW(this.$, this.Yt, this.u, this.ie.logMessageContent, this.ie.WebSocket, this.ie.headers || {});
            case Ae.ServerSentEvents:
              if (!this.ie.EventSource) throw new Error("'EventSource' is not supported in your environment.");
              return new RW(this.$, this.$.Zt, this.u, this.ie);
            case Ae.LongPolling:
              return new R3(this.$, this.u, this.ie);
            default:
              throw new Error(`Unknown transport: ${w}.`);
          }
        }
        ke(w, S) {
          return this.transport.onreceive = this.onreceive, this.features.reconnect ? this.transport.onclose = async (M) => {
            let R = !1;
            if (this.features.reconnect) {
              try {
                this.features.disconnected(), await this.transport.connect(w, S), await this.features.resend();
              } catch {
                R = !0;
              }
              R && this.Ce(M);
            } else this.Ce(M);
          } : this.transport.onclose = (M) => this.Ce(M), this.transport.connect(w, S);
        }
        Re(w, S, M, R) {
          const W = Ae[w.transport];
          if (W == null) return this.u.log(r.Debug, `Skipping transport '${w.transport}' because it is not supported by this client.`), new Error(`Skipping transport '${w.transport}' because it is not supported by this client.`);
          if (!(function(Z, ut) {
            return !Z || !!(ut & Z);
          })(S, W)) return this.u.log(r.Debug, `Skipping transport '${Ae[W]}' because it was disabled by the client.`), new O(`'${Ae[W]}' is disabled by the client.`, W);
          if (!(w.transferFormats.map(((Z) => ri[Z])).indexOf(M) >= 0)) return this.u.log(r.Debug, `Skipping transport '${Ae[W]}' because it does not support the requested transfer format '${ri[M]}'.`), new Error(`'${Ae[W]}' does not support ${ri[M]}.`);
          if (W === Ae.WebSockets && !this.ie.WebSocket || W === Ae.ServerSentEvents && !this.ie.EventSource) return this.u.log(r.Debug, `Skipping transport '${Ae[W]}' because it is not supported in your environment.'`), new y(`'${Ae[W]}' is not supported in your environment.`, W);
          this.u.log(r.Debug, `Selecting transport '${Ae[W]}'.`);
          try {
            return this.features.reconnect = W === Ae.WebSockets ? R : void 0, this.Se(W);
          } catch (Z) {
            return Z;
          }
        }
        De(w) {
          return w && typeof w == "object" && "connect" in w;
        }
        Ce(w) {
          if (this.u.log(r.Debug, `HttpConnection.stopConnection(${w}) called while in state ${this.ut}.`), this.transport = void 0, w = this.$e || w, this.$e = void 0, this.ut !== "Disconnected") {
            if (this.ut === "Connecting") throw this.u.log(r.Warning, `Call to HttpConnection.stopConnection(${w}) was ignored because the connection is still in the connecting state.`), new Error(`HttpConnection.stopConnection(${w}) was called while the connection is still in the connecting state.`);
            if (this.ut === "Disconnecting" && this.me(), w ? this.u.log(r.Error, `Connection disconnected with error '${w}'.`) : this.u.log(r.Information, "Connection disconnected."), this.Ee && (this.Ee.stop().catch(((S) => {
              this.u.log(r.Error, `TransportSendQueue.stop() threw error '${S}'.`);
            })), this.Ee = void 0), this.connectionId = void 0, this.ut = "Disconnected", this.dt) {
              this.dt = !1;
              try {
                this.onclose && this.onclose(w);
              } catch (S) {
                this.u.log(r.Error, `HttpConnection.onclose(${w}) threw error '${S}'.`);
              }
            }
          } else this.u.log(r.Debug, `Call to HttpConnection.stopConnection(${w}) was ignored because the connection is already in the disconnected state.`);
        }
        be(w) {
          if (w.lastIndexOf("https://", 0) === 0 || w.lastIndexOf("http://", 0) === 0) return w;
          if (!_t.isBrowser) throw new Error(`Cannot resolve '${w}'.`);
          const S = window.document.createElement("a");
          return S.href = w, this.u.log(r.Information, `Normalizing '${w}' to '${S.href}'.`), S.href;
        }
        Ie(w) {
          const S = new URL(w);
          S.pathname.endsWith("/") ? S.pathname += "negotiate" : S.pathname += "/negotiate";
          const M = new URLSearchParams(S.searchParams);
          return M.has("negotiateVersion") || M.append("negotiateVersion", this.ye.toString()), M.has("useStatefulReconnect") ? M.get("useStatefulReconnect") === "true" && (this.ie._e = !0) : this.ie._e === !0 && M.append("useStatefulReconnect", "true"), S.search = M.toString(), S.toString();
        }
      }, h(Tc, "Eu"), Tc);
      c(L3, "K");
      let _W = L3;
      const z3 = (Wa = class {
        constructor(w) {
          this.xe = w, this.Ae = [], this.Ue = !0, this.Le = new Y1(), this.Ne = new Y1(), this.qe = this.Me();
        }
        send(w) {
          return this.je(w), this.Ne || (this.Ne = new Y1()), this.Ne.promise;
        }
        stop() {
          return this.Ue = !1, this.Le.resolve(), this.qe;
        }
        je(w) {
          if (this.Ae.length && typeof this.Ae[0] != typeof w) throw new Error(`Expected data to be of type ${typeof this.Ae} but was of type ${typeof w}`);
          this.Ae.push(w), this.Le.resolve();
        }
        async Me() {
          for (; ; ) {
            if (await this.Le.promise, !this.Ue) {
              this.Ne && this.Ne.reject("Connection stopped.");
              break;
            }
            this.Le = new Y1();
            const w = this.Ne;
            this.Ne = void 0;
            const S = typeof this.Ae[0] == "string" ? this.Ae.join("") : Wa.We(this.Ae);
            this.Ae.length = 0;
            try {
              await this.xe.send(S), w.resolve();
            } catch (M) {
              w.reject(M);
            }
          }
        }
        static We(w) {
          const S = w.map(((W) => W.byteLength)).reduce(((W, Z) => W + Z)), M = new Uint8Array(S);
          let R = 0;
          for (const W of w) M.set(new Uint8Array(W), R), R += W.byteLength;
          return M.buffer;
        }
      }, h(Wa, "Ed"), Wa);
      c(z3, "G");
      let LW = z3;
      const I3 = (Mc = class {
        constructor() {
          this.promise = new Promise(((w, S) => [this.j, this.Oe] = [w, S]));
        }
        resolve() {
          this.j();
        }
        reject(w) {
          this.Oe(w);
        }
      }, h(Mc, "Ru"), Mc);
      c(I3, "Q");
      let Y1 = I3;
      const D3 = (Ac = class {
        constructor() {
          this.name = "json", this.version = 2, this.transferFormat = ri.Text;
        }
        parseMessages(w, S) {
          if (typeof w != "string") throw new Error("Invalid input for JSON hub protocol. Expected a string.");
          if (!w) return [];
          S === null && (S = dt.instance);
          const M = Ss.parse(w), R = [];
          for (const W of M) {
            const Z = JSON.parse(W);
            if (typeof Z.type != "number") throw new Error("Invalid payload.");
            switch (Z.type) {
              case zt.Invocation:
                this.U(Z);
                break;
              case zt.StreamItem:
                this.Fe(Z);
                break;
              case zt.Completion:
                this.Be(Z);
                break;
              case zt.Ping:
              case zt.Close:
                break;
              case zt.Ack:
                this.Xe(Z);
                break;
              case zt.Sequence:
                this.Je(Z);
                break;
              default:
                S.log(r.Information, "Unknown message type '" + Z.type + "' ignored.");
                continue;
            }
            R.push(Z);
          }
          return R;
        }
        writeMessage(w) {
          return Ss.write(JSON.stringify(w));
        }
        U(w) {
          this.ze(w.target, "Invalid payload for Invocation message."), w.invocationId !== void 0 && this.ze(w.invocationId, "Invalid payload for Invocation message.");
        }
        Fe(w) {
          if (this.ze(w.invocationId, "Invalid payload for StreamItem message."), w.item === void 0) throw new Error("Invalid payload for StreamItem message.");
        }
        Be(w) {
          if (w.result && w.error) throw new Error("Invalid payload for Completion message.");
          !w.result && w.error && this.ze(w.error, "Invalid payload for Completion message."), this.ze(w.invocationId, "Invalid payload for Completion message.");
        }
        Xe(w) {
          if (typeof w.sequenceId != "number") throw new Error("Invalid SequenceId for Ack message.");
        }
        Je(w) {
          if (typeof w.sequenceId != "number") throw new Error("Invalid SequenceId for Sequence message.");
        }
        ze(w, S) {
          if (typeof w != "string" || w === "") throw new Error(S);
        }
      }, h(Ac, "Tu"), Ac);
      c(D3, "Y");
      let V3 = D3;
      const zW = { trace: r.Trace, debug: r.Debug, info: r.Information, information: r.Information, warn: r.Warning, warning: r.Warning, error: r.Error, critical: r.Critical, none: r.None }, W3 = (Rc = class {
        configureLogging(w) {
          if (ct.isRequired(w, "logging"), w.log !== void 0) this.logger = w;
          else if (typeof w == "string") {
            const S = (function(M) {
              const R = zW[M.toLowerCase()];
              if (R !== void 0) return R;
              throw new Error(`Unknown log level: ${M}`);
            })(w);
            this.logger = new oe(S);
          } else this.logger = new oe(w);
          return this;
        }
        withUrl(w, S) {
          return ct.isRequired(w, "url"), ct.isNotEmpty(w, "url"), this.url = w, this.httpConnectionOptions = typeof S == "object" ? { ...this.httpConnectionOptions, ...S } : { ...this.httpConnectionOptions, transport: S }, this;
        }
        withHubProtocol(w) {
          return ct.isRequired(w, "protocol"), this.protocol = w, this;
        }
        withAutomaticReconnect(w) {
          if (this.reconnectPolicy) throw new Error("A reconnectPolicy has already been set.");
          return w ? Array.isArray(w) ? this.reconnectPolicy = new P3(w) : this.reconnectPolicy = w : this.reconnectPolicy = new P3(), this;
        }
        withServerTimeout(w) {
          return ct.isRequired(w, "milliseconds"), this.Ve = w, this;
        }
        withKeepAliveInterval(w) {
          return ct.isRequired(w, "milliseconds"), this.Ke = w, this;
        }
        withStatefulReconnect(w) {
          return this.httpConnectionOptions === void 0 && (this.httpConnectionOptions = {}), this.httpConnectionOptions._e = !0, this.Y = w?.bufferSize, this;
        }
        build() {
          const w = this.httpConnectionOptions || {};
          if (w.logger === void 0 && (w.logger = this.logger), !this.url) throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");
          const S = new _W(this.url, w);
          return S3.create(S, this.logger || dt.instance, this.protocol || new V3(), this.reconnectPolicy, this.Ve, this.Ke, this.Y);
        }
      }, h(Rc, "Lu"), Rc);
      c(W3, "tt");
      let IW = W3;
      return Uint8Array.prototype.indexOf || Object.defineProperty(Uint8Array.prototype, "indexOf", { value: Array.prototype.indexOf, writable: !0 }), Uint8Array.prototype.slice || Object.defineProperty(Uint8Array.prototype, "slice", { value: /* @__PURE__ */ c(function(H, w) {
        return new Uint8Array(Array.prototype.slice.call(this, H, w));
      }, "value"), writable: !0 }), Uint8Array.prototype.forEach || Object.defineProperty(Uint8Array.prototype, "forEach", { value: Array.prototype.forEach, writable: !0 }), n;
    })(), "e"), s.exports = e();
  })(u9)), u9.exports;
}
h(eL, "j1");
c(eL, "requireSignalr_min");
var f9 = /* @__PURE__ */ eL();
const mj = /* @__PURE__ */ c((s) => {
  var e;
  var t;
  return t = (e = class extends s {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), this._whenConnectionRequested = new Promise((n) => {
        this._resolveConnectionRequested = n;
      }), this._whenConnectionCreated = new Promise((n) => {
        this._resolveConnectionCreated = n;
      }), this._connectionEventListeners = [], this.signalRAccessTokenRefresh = !1, this._whenConnectionStarted = new Promise((n, a) => {
        this._whenConnectionStartedResolve = n, this._whenConnectionStartedReject = a;
      }), this.whenConnectionRequested().then(() => {
        this.isDestroyed || this.createConnection();
      });
    }
    async whenConnectionRequested() {
      await this._whenConnectionRequested;
    }
    async whenConnectionCreated() {
      return await this._whenConnectionCreated;
    }
    get rtmConnection() {
      return this._connection;
    }
    async whenConnectionStarted() {
      return await this._whenConnectionStarted;
    }
    async createConnection() {
      if (this.isDestroyed)
        throw new Ee();
      if (this.networkStateIsPending = !0, await this.whenUrlAndTokenFactory(), this._connection) {
        const r = new URL("/hubs/rtm", this.url);
        this._connection.baseUrl !== r.toString() && (this.connectionState = "reconnecting", console.info(
          this.weavyId,
          "Reconnecting due to changed url.",
          this._connection.baseUrl,
          "=>",
          r.toString()
        ), await this.disconnect(), this._connection.baseUrl = r.toString(), this.connect());
      } else {
        this.connectionState = "connecting";
        const r = new URL("/hubs/rtm", this.url);
        this._connection = new f9.HubConnectionBuilder().configureLogging(f9.LogLevel.None).withUrl(r.toString(), {
          accessTokenFactory: /* @__PURE__ */ c(async () => {
            try {
              if (this.signalRAccessTokenRefresh) {
                const n = await this.getToken(!0);
                return this.signalRAccessTokenRefresh = !1, n;
              } else
                return await this.getToken();
            } catch (n) {
              throw console.error(n), n;
            }
          }, "accessTokenFactory")
        }).withAutomaticReconnect({
          nextRetryDelayInMilliseconds: /* @__PURE__ */ c((n) => !this.isDestroyed && window.navigator.onLine && document?.visibilityState !== "hidden" && n.elapsedMilliseconds < 6e4 ? [0, 2e3, 1e4][n.previousRetryCount] || 1e4 : null, "nextRetryDelayInMilliseconds")
        }).build(), this._connection.onclose(() => {
          console.info(this.weavyId, "SignalR closed."), this.connectionState = "disconnected", !this.isDestroyed && (this.networkStateIsPending = !0, this._whenConnectionStarted = new Promise((n, a) => {
            this._whenConnectionStartedResolve = n, this._whenConnectionStartedReject = a;
          }), this.connect());
        }), this._connection.onreconnecting(() => {
          console.info(this.weavyId, "SignalR reconnecting..."), this.connectionState = "reconnecting";
        }), this._connection.onreconnected((n) => {
          console.info(this.weavyId, `SignalR reconnected ${n}`), this.connectionState = "connected", this.networkStateIsPending = !1;
          for (let a = 0; a < this._connectionEventListeners.length; a++)
            this._connection?.invoke("Subscribe", this._connectionEventListeners[a].name);
        }), this._resolveConnectionCreated?.(this._connection), this.connect();
      }
      return this._connection;
    }
    async disconnect() {
      this._connection && (await this._connection.stop(), this.connectionState = "disconnected");
    }
    async connect() {
      if (this.isDestroyed)
        throw new Ee();
      let r;
      this._connection ? r = this._connection : r = await this.whenConnectionCreated(), console.info(this.weavyId, "Connecting SignalR...");
      try {
        if (!window.navigator.onLine)
          throw new Error();
        await Promise.race([r.start(), this.whenConnectionStarted()]), this.signalRAccessTokenRefresh = !1, this.networkStateIsPending = !1, this.connectionState = "connected", this._whenConnectionStartedResolve?.(r), console.info(this.weavyId, `SignalR connected ${r.connectionId}`);
      } catch (n) {
        if (n instanceof Ee)
          return console.warn(this.weavyId, "SignalR connection aborted."), r;
        window.navigator.onLine ? !this.signalRAccessTokenRefresh && window.document.visibilityState !== "hidden" && n.toString().includes("Unauthorized") ? (console.info(this.weavyId, "Retrying SignalR connect with fresh token."), this.signalRAccessTokenRefresh = !0) : (console.info(
          this.weavyId,
          "Server is probably down, retrying SignalR connect after a delay or when window regains focus."
        ), this.connectionState = "reconnecting", await new Promise((a) => {
          setTimeout(a, 5e3), window.addEventListener("visibilitychange", a, { once: !0 }), window.addEventListener("offline", a, { once: !0 }), window.addEventListener("online", a, { once: !0 });
        })) : (this.networkStateIsPending = !1, console.info(this.weavyId, "Offline, reconnecting SignalR when online."), await new Promise((a) => {
          window.addEventListener("online", a, { once: !0 });
        })), window.navigator.onLine && document?.visibilityState !== "hidden" && await new Promise((a) => setTimeout(a, 1e3)), this.checkVersion(), this.networkStateIsPending = !0, await this.connect();
      }
      return r;
    }
    async subscribe(r, n, a) {
      if (this.isDestroyed)
        throw new Ee();
      this._resolveConnectionRequested?.(!0);
      const o = r ? r + ":" + n : n;
      try {
        if (this._connectionEventListeners || await new Promise((l) => queueMicrotask(() => l(!0))), this._connectionEventListeners.some((l) => l.name === o && l.callback === a))
          throw new Error("Duplicate subscribe: " + o);
        if (this._connectionEventListeners.push({ name: o, callback: a }), await this.whenConnectionStarted(), !this._connection)
          throw new Error("Connection not created");
        if (this._connection.on(o, a), await this._connection.invoke("Subscribe", o) === !1)
          throw new Error("Could not subscribe to " + o);
        return !0;
      } catch (l) {
        l instanceof Ee || console.error(this.weavyId, "Error in Subscribe:", l);
        const d = this._connectionEventListeners.findIndex((u) => u.name === o && u.callback === a);
        return d !== -1 && (this._connectionEventListeners.splice(d, 1), this._connection?.off(o, a)), !1;
      }
    }
    async unsubscribe(r, n, a) {
      if (this.isDestroyed)
        throw new Ee();
      try {
        const o = r ? r + ":" + n : n, l = this._connectionEventListeners.findIndex((d) => d.name === o && d.callback === a);
        if (l !== -1) {
          if (this._connectionEventListeners.splice(l, 1), await this.whenConnectionStarted(), !this._connection)
            throw new Error("Connection not created");
          this._connection?.off(o, a), this._connectionEventListeners.some((d) => d.name === o) || await this._connection.invoke("Unsubscribe", o);
        }
      } catch (o) {
        o instanceof Ee || console.error(this.weavyId, "Error in Unsubscribe:", o);
      }
    }
    destroy() {
      super.destroy(), this.disconnect(), this._whenConnectionStartedReject && (this._whenConnectionStarted.catch(() => {
      }), this._whenConnectionStartedReject(new Ee()));
    }
  }, h(e, "t"), e), c(t, "WeavyConnection"), t;
}, "WeavyConnectionMixin");
var n0 = /* @__PURE__ */ ((s) => (s.JSON = "application/json;charset=utf-8", s.FormData = "multipart/form-data;charset=utf-8", s.URLEncoded = "application/x-www-form-urlencoded;charset=utf-8", s.Text = "text/plain;charset=utf-8", s.Auto = "", s))(n0 || {});
const yj = /* @__PURE__ */ c((s) => {
  var e;
  var t;
  return t = (e = class extends s {
    // FETCH
    async fetchOptions(r = {}, n = !0) {
      if (this.isDestroyed)
        throw new Ee();
      const a = {
        headers: {
          "X-Weavy-Source": `${_e.sourceName}@${_e.version}`,
          "Content-Type": n0.JSON
        },
        method: "GET"
      }, o = go(go(pj, a, !0), r, !0);
      return n ? go(
        o,
        {
          headers: {
            Authorization: "Bearer " + await this.getToken()
          }
        },
        !0
      ) : o;
    }
    async fetch(r, n, a = !0) {
      if (this.isDestroyed)
        throw new Ee();
      const o = await this.fetchOptions(n);
      this.networkStateIsPending = !0;
      const l = await fetch(new URL(r, this.url), o);
      if (l.ok)
        this.networkStateIsPending = !1, this.serverState = "ok";
      else if (l.status === 401 || l.status === 403) {
        if (a)
          return await this.getToken(!0), await this.fetch(r, n, !1);
        this.networkStateIsPending = !1, this.serverState = "unauthorized";
      } else
        this.networkStateIsPending = !1;
      return l;
    }
    async upload(r, n, a, o = n0.JSON, l, d, u = !0) {
      if (this.isDestroyed)
        throw new Ee();
      const p = await this.getToken();
      return await new Promise((f, y) => {
        const g = new XMLHttpRequest();
        g.open(n, new URL(r, this.url), !0), g.setRequestHeader("Authorization", "Bearer " + p), g.setRequestHeader("X-Weavy-Source", `${_e.sourceName}@${_e.version}`), o && g.setRequestHeader("Content-Type", o), l && g.upload.addEventListener("progress", (O) => {
          l(O.loaded / O.total * 100 || 100);
        }), g.onload = (O) => {
          u && (g.status === 401 || g.status === 401) ? this.getToken(!0).then(() => this.upload(r, n, a, o, l, d, !1)).then(f).catch(y) : f(new Response(g.response, { status: g.status, statusText: g.statusText }));
        }, g.onerror = y, g.onabort = y, d?.addEventListener("abort", () => {
          g.abort();
        }), g.send(a);
      });
    }
    // DEPRECATED
    async get(r) {
      return console.warn(`weavy.get() is deprecated, use weavy.fetch("${r}") instead.`), this.fetch(r);
    }
    // DEPRECATED
    async post(r, n, a, o) {
      console.warn(
        `weavy.post() is deprecated, use weavy.fetch("${r}", { method: "${n}"}) instead.`
      );
      const l = o ? { "Content-Type": o } : void 0;
      return this.fetch(r, { method: n, body: a, headers: l });
    }
  }, h(e, "t"), e), c(t, "WeavyFetch"), t;
}, "WeavyFetchMixin"), iL = "en", gj = /* @__PURE__ */ c((s) => {
  var e;
  var t;
  return t = (e = class extends s {
    constructor() {
      super(...arguments), this._locales = /* @__PURE__ */ new Map([
        ["sv-SE", () => import(
          /* webpackIgnore: true */
          /* @vite-ignore */
          new URL("./es/locales/sv-SE-DNn-JJCG.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
        ).then((r) => r.svSE)]
      ]), this._locale = t.sourceLocale;
    }
    /**
     * The locale used in the Weavy source.
     */
    static get sourceLocale() {
      try {
        return iL;
      } catch {
        return "";
      }
    }
    get locales() {
      return Array.from(this._locales.entries());
    }
    set locales(r) {
      if (this.isDestroyed)
        throw new Ee();
      if (this.localization)
        throw new Error("Locales may only be configured once");
      if (r) {
        if (!Array.isArray(r))
          throw new TypeError("Provided locales have invalid format.");
        r.forEach((n) => {
          if (!Array.isArray(n) || n.length !== 2 || typeof n[0] != "string")
            throw new TypeError("Invalid locale provided: " + n[0]);
          this._locales.set(...n);
        }), this.configureLocalization();
      }
    }
    get localization() {
      return this._localization;
    }
    /**
     * Selected locale. The locale must be pre configured in `.locales`.
     */
    get locale() {
      return this._locale;
    }
    set locale(r) {
      if (this.isDestroyed)
        throw new Ee();
      !this._locale && !r || (r ||= t.sourceLocale, this._locale = r, this.localization ? this.localization.setLocale(this._locale) : queueMicrotask(() => {
        this.localization ? this.localization.setLocale(this._locale) : this._locale !== t.sourceLocale && (this._locales.has(this._locale) && this.configureLocalization(), this.localization ? this.localization.setLocale(this._locale) : console.error(
          this.weavyId,
          `You need to configure additional languages in config to use '${r}'.`
        ));
      }));
    }
    async loadLocale(r) {
      if (this.isDestroyed)
        throw new Ee();
      if (this._locales?.has(r)) {
        const n = this._locales.get(r);
        return console.info(
          this.weavyId,
          typeof n == "function" ? "loading locale" : "preloaded locale",
          r
        ), await (typeof n == "function" ? n() : n);
      } else
        throw new Error("The requested locale is not configured");
    }
    configureLocalization() {
      if (this.isDestroyed)
        throw new Ee();
      if (this._locales?.size && !this.localization) {
        const r = this._locales.keys();
        console.info(this.weavyId, "Configuring locales", r);
        const { getLocale: n, setLocale: a } = QX({
          sourceLocale: t.sourceLocale,
          targetLocales: r,
          loadLocale: /* @__PURE__ */ c((o) => this.loadLocale(o), "loadLocale")
        });
        this._localization = {
          getLocale: n,
          setLocale: a
        };
      }
    }
  }, h(e, "t"), e), c(t, "WeavyLocalization"), t;
}, "WeavyLocalizationMixin"), wj = /* @__PURE__ */ c((s) => {
  var e;
  var t;
  return t = (e = class extends s {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), this._configurationState = "pending", this._networkEvents = /* @__PURE__ */ new Set(), this._connectionState = "connecting", this._serverState = "ok", this._networkState = window.navigator.onLine ? "online" : "offline", this._networkStateIsPending = !1, window.addEventListener("online", () => {
        this.networkState = "online";
      }), window.addEventListener("offline", () => {
        this.networkState = "offline", this.networkStateIsPending = !1;
      }), queueMicrotask(() => this.requestConfigurationCheck());
    }
    get configurationState() {
      return this._configurationState;
    }
    set configurationState(r) {
      this._configurationState = r, this._configurationTimer && r === "configured" && (window.clearTimeout(this._configurationTimer), this._configurationTimer = null), this.triggerNetworkChange();
    }
    get networkState() {
      return this._networkState;
    }
    set networkState(r) {
      this._networkState = r, this.triggerNetworkChange();
    }
    get serverState() {
      return this._serverState;
    }
    set serverState(r) {
      this._serverState = r, this.triggerNetworkChange();
    }
    get connectionState() {
      return this._connectionState;
    }
    set connectionState(r) {
      this._connectionState = r, this.triggerNetworkChange();
    }
    get networkStateIsPending() {
      return this._networkStateIsPending;
    }
    set networkStateIsPending(r) {
      this._networkStateIsPending = r, this.triggerNetworkChange();
    }
    get network() {
      return {
        state: this._networkState === "online" ? (this._connectionState === "connected" || this._serverState === "ok") && this.configurationState !== "uninitialized" ? "online" : "unreachable" : "offline",
        isPending: this._networkStateIsPending
      };
    }
    requestConfigurationCheck() {
      !this._configurationTimer && this.configurationTimeout >= 0 && this.configurationTimeout < 1 / 0 && (this._configurationTimer = window.setTimeout(() => {
        this.configurationState === "pending" && (this.configurationState = "uninitialized", console.error("Weavy was not configured with required url and tokenFactory/tokenUrl within a reasonable time. Please check your configuration!")), this._configurationTimer = null;
      }, this.configurationTimeout));
    }
    triggerNetworkChange() {
      const r = this.network;
      this._networkEvents.forEach((n) => {
        n(r);
      });
    }
    addNetworkListener(r) {
      this._networkEvents.add(r);
    }
    removeNetworkListener(r) {
      this._networkEvents.delete(r);
    }
  }, h(e, "t"), e), c(t, "WeavyNetwork"), t;
}, "WeavyNetworkMixin");
var K2, ap, Dy = (K2 = (ap = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, h(ap, "Ma"), ap), c(K2, "Subscribable"), K2), vj = {
  // We need the wrapper function syntax below instead of direct references to
  // global setTimeout etc.
  //
  // BAD: `setTimeout: setTimeout`
  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
  //
  // If we use direct references here, then anything that wants to spy on or
  // replace the global setTimeout (like tests) won't work since we'll already
  // have a hard reference to the original implementation at the time when this
  // file was imported.
  setTimeout: /* @__PURE__ */ c((s, t) => setTimeout(s, t), "setTimeout"),
  clearTimeout: /* @__PURE__ */ c((s) => clearTimeout(s), "clearTimeout"),
  setInterval: /* @__PURE__ */ c((s, t) => setInterval(s, t), "setInterval"),
  clearInterval: /* @__PURE__ */ c((s) => clearInterval(s), "clearInterval")
}, Ba, m9, J2, op, Oj = (J2 = (op = class {
  constructor() {
    q(this, Ba, vj), q(this, m9, !1);
  }
  setTimeoutProvider(t) {
    E(this, Ba, t);
  }
  setTimeout(t, e) {
    return x(this, Ba).setTimeout(t, e);
  }
  clearTimeout(t) {
    x(this, Ba).clearTimeout(t);
  }
  setInterval(t, e) {
    return x(this, Ba).setInterval(t, e);
  }
  clearInterval(t) {
    x(this, Ba).clearInterval(t);
  }
}, h(op, "Aa"), op), Ba = /* @__PURE__ */ new WeakMap(), m9 = /* @__PURE__ */ new WeakMap(), c(J2, "TimeoutManager"), J2), Wn = new Oj();
function rL(s) {
  setTimeout(s, 0);
}
h(rL, "X1");
c(rL, "systemSetTimeoutZero");
var wy = typeof window > "u" || "Deno" in globalThis;
function oi() {
}
h(oi, "Me");
c(oi, "noop$1");
function sL(s, t) {
  return typeof s == "function" ? s(t) : s;
}
h(sL, "J1");
c(sL, "functionalUpdate");
function a0(s) {
  return typeof s == "number" && s >= 0 && s !== 1 / 0;
}
h(a0, "Xu");
c(a0, "isValidTimeout");
function BP(s, t) {
  return Math.max(s + (t || 0) - Date.now(), 0);
}
h(BP, "um");
c(BP, "timeUntilStale");
function tn(s, t) {
  return typeof s == "function" ? s(t) : s;
}
h(tn, "Ir");
c(tn, "resolveStaleTime");
function sr(s, t) {
  return typeof s == "function" ? s(t) : s;
}
h(sr, "ai");
c(sr, "resolveEnabled");
function oS(s, t) {
  const {
    type: e = "all",
    exact: i,
    fetchStatus: r,
    predicate: n,
    queryKey: a,
    stale: o
  } = s;
  if (a) {
    if (i) {
      if (t.queryHash !== vb(a, t.options))
        return !1;
    } else if (!vy(t.queryKey, a))
      return !1;
  }
  if (e !== "all") {
    const l = t.isActive();
    if (e === "active" && !l || e === "inactive" && l)
      return !1;
  }
  return !(typeof o == "boolean" && t.isStale() !== o || r && r !== t.state.fetchStatus || n && !n(t));
}
h(oS, "qw");
c(oS, "matchQuery");
function lS(s, t) {
  const { exact: e, status: i, predicate: r, mutationKey: n } = s;
  if (n) {
    if (!t.options.mutationKey)
      return !1;
    if (e) {
      if (ma(t.options.mutationKey) !== ma(n))
        return !1;
    } else if (!vy(t.options.mutationKey, n))
      return !1;
  }
  return !(i && t.state.status !== i || r && !r(t));
}
h(lS, "jw");
c(lS, "matchMutation");
function vb(s, t) {
  return (t?.queryKeyHashFn || ma)(s);
}
h(vb, "ty");
c(vb, "hashQueryKeyByOptions");
function ma(s) {
  return JSON.stringify(
    s,
    (t, e) => o0(e) ? Object.keys(e).sort().reduce((i, r) => (i[r] = e[r], i), {}) : e
  );
}
h(ma, "Pn");
c(ma, "hashKey");
function vy(s, t) {
  return s === t ? !0 : typeof s != typeof t ? !1 : s && t && typeof s == "object" && typeof t == "object" ? Object.keys(t).every((e) => vy(s[e], t[e])) : !1;
}
h(vy, "ml");
c(vy, "partialMatchKey");
var bj = Object.prototype.hasOwnProperty;
function Vy(s, t, e = 0) {
  if (s === t)
    return s;
  if (e > 500) return t;
  const i = cS(s) && cS(t);
  if (!i && !(o0(s) && o0(t))) return t;
  const r = (i ? s : Object.keys(s)).length, n = i ? t : Object.keys(t), a = n.length, o = i ? new Array(a) : {};
  let l = 0;
  for (let d = 0; d < a; d++) {
    const u = i ? d : n[d], p = s[u], f = t[u];
    if (p === f) {
      o[u] = p, (i ? d < r : bj.call(s, u)) && l++;
      continue;
    }
    if (p === null || f === null || typeof p != "object" || typeof f != "object") {
      o[u] = f;
      continue;
    }
    const y = Vy(p, f, e + 1);
    o[u] = y, y === p && l++;
  }
  return r === a && l === r ? s : o;
}
h(Vy, "dd");
c(Vy, "replaceEqualDeep");
function jw(s, t) {
  if (!t || Object.keys(s).length !== Object.keys(t).length)
    return !1;
  for (const e in s)
    if (s[e] !== t[e])
      return !1;
  return !0;
}
h(jw, "jd");
c(jw, "shallowEqualObjects");
function cS(s) {
  return Array.isArray(s) && s.length === Object.keys(s).length;
}
h(cS, "Ww");
c(cS, "isPlainArray");
function o0(s) {
  if (!hS(s))
    return !1;
  const t = s.constructor;
  if (t === void 0)
    return !0;
  const e = t.prototype;
  return !(!hS(e) || !e.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(s) !== Object.prototype);
}
h(o0, "Ju");
c(o0, "isPlainObject");
function hS(s) {
  return Object.prototype.toString.call(s) === "[object Object]";
}
h(hS, "Kw");
c(hS, "hasObjectPrototype");
function nL(s) {
  return new Promise((t) => {
    Wn.setTimeout(t, s);
  });
}
h(nL, "eg");
c(nL, "sleep");
function l0(s, t, e) {
  return typeof e.structuralSharing == "function" ? e.structuralSharing(s, t) : e.structuralSharing !== !1 ? Vy(s, t) : t;
}
h(l0, "tp");
c(l0, "replaceData");
function aL(s, t, e = 0) {
  const i = [...s, t];
  return e && i.length > e ? i.slice(1) : i;
}
h(aL, "ig");
c(aL, "addToEnd");
function oL(s, t, e = 0) {
  const i = [t, ...s];
  return e && i.length > e ? i.slice(0, -1) : i;
}
h(oL, "rg");
c(oL, "addToStart");
var NP = Symbol();
function XP(s, t) {
  return !s.queryFn && t?.initialPromise ? () => t.initialPromise : !s.queryFn || s.queryFn === NP ? () => Promise.reject(new Error(`Missing queryFn: '${s.queryHash}'`)) : s.queryFn;
}
h(XP, "pm");
c(XP, "ensureQueryFn");
function lL(s, t, e) {
  let i = !1, r;
  return Object.defineProperty(s, "signal", {
    enumerable: !0,
    get: /* @__PURE__ */ c(() => (r ??= t(), i || (i = !0, r.aborted ? e() : r.addEventListener("abort", e, { once: !0 })), r), "get")
  }), s;
}
h(lL, "ng");
c(lL, "addConsumeAwareSignal");
var Lc, Na, dg, t$, lp, $j = (t$ = (lp = class extends Dy {
  constructor() {
    super(), q(this, Lc), q(this, Na), q(this, dg), E(this, dg, (t) => {
      if (!wy && window.addEventListener) {
        const e = /* @__PURE__ */ c(() => t(), "listener");
        return window.addEventListener("visibilitychange", e, !1), () => {
          window.removeEventListener("visibilitychange", e);
        };
      }
    });
  }
  onSubscribe() {
    x(this, Na) || this.setEventListener(x(this, dg));
  }
  onUnsubscribe() {
    var t;
    this.hasListeners() || ((t = x(this, Na)) == null || t.call(this), E(this, Na, void 0));
  }
  setEventListener(t) {
    var e;
    E(this, dg, t), (e = x(this, Na)) == null || e.call(this), E(this, Na, t((i) => {
      typeof i == "boolean" ? this.setFocused(i) : this.onFocus();
    }));
  }
  setFocused(t) {
    x(this, Lc) !== t && (E(this, Lc, t), this.onFocus());
  }
  onFocus() {
    const t = this.isFocused();
    this.listeners.forEach((e) => {
      e(t);
    });
  }
  isFocused() {
    return typeof x(this, Lc) == "boolean" ? x(this, Lc) : globalThis.document?.visibilityState !== "hidden";
  }
}, h(lp, "Ra"), lp), Lc = /* @__PURE__ */ new WeakMap(), Na = /* @__PURE__ */ new WeakMap(), dg = /* @__PURE__ */ new WeakMap(), c(t$, "FocusManager"), t$), jP = new $j();
function c0() {
  let s, t;
  const e = new Promise((r, n) => {
    s = r, t = n;
  });
  e.status = "pending", e.catch(() => {
  });
  function i(r) {
    Object.assign(e, r), delete e.resolve, delete e.reject;
  }
  return h(i, "i"), c(i, "finalize"), e.resolve = (r) => {
    i({
      status: "fulfilled",
      value: r
    }), s(r);
  }, e.reject = (r) => {
    i({
      status: "rejected",
      reason: r
    }), t(r);
  }, e;
}
h(c0, "ep");
c(c0, "pendingThenable");
function cL(s) {
  let t;
  if (s.then((e) => (t = e, e), oi)?.catch(oi), t !== void 0)
    return { data: t };
}
h(cL, "sg");
c(cL, "tryResolveSync");
function UP(s) {
  return s;
}
h(UP, "ym");
c(UP, "defaultTransformerFn");
function hL(s) {
  return {
    mutationKey: s.options.mutationKey,
    state: s.state,
    ...s.options.scope && { scope: s.options.scope },
    ...s.meta && { meta: s.meta }
  };
}
h(hL, "og");
c(hL, "dehydrateMutation");
function dL(s, t, e) {
  const i = /* @__PURE__ */ c(() => {
    const r = s.promise?.then(t).catch((n) => e(n) ? Promise.reject(new Error("redacted")) : Promise.reject(n));
    return r?.catch(oi), r;
  }, "dehydratePromise");
  return {
    dehydratedAt: Date.now(),
    state: {
      ...s.state,
      ...s.state.data !== void 0 && {
        data: t(s.state.data)
      }
    },
    queryKey: s.queryKey,
    queryHash: s.queryHash,
    ...s.state.status === "pending" && {
      promise: i()
    },
    ...s.meta && { meta: s.meta }
  };
}
h(dL, "cg");
c(dL, "dehydrateQuery");
function uL(s) {
  return s.state.isPaused;
}
h(uL, "lg");
c(uL, "defaultShouldDehydrateMutation");
function pL(s) {
  return s.state.status === "success";
}
h(pL, "dg");
c(pL, "defaultShouldDehydrateQuery");
function fL(s) {
  return !0;
}
h(fL, "hg");
c(fL, "defaultShouldRedactErrors");
function mL(s, t = {}) {
  const e = t.shouldDehydrateMutation ?? s.getDefaultOptions().dehydrate?.shouldDehydrateMutation ?? uL, i = s.getMutationCache().getAll().flatMap(
    (l) => e(l) ? [hL(l)] : []
  ), r = t.shouldDehydrateQuery ?? s.getDefaultOptions().dehydrate?.shouldDehydrateQuery ?? pL, n = t.shouldRedactErrors ?? s.getDefaultOptions().dehydrate?.shouldRedactErrors ?? fL, a = t.serializeData ?? s.getDefaultOptions().dehydrate?.serializeData ?? UP, o = s.getQueryCache().getAll().flatMap(
    (l) => r(l) ? [dL(l, a, n)] : []
  );
  return { mutations: i, queries: o };
}
h(mL, "ug");
c(mL, "dehydrate");
function yL(s, t, e) {
  if (typeof t != "object" || t === null)
    return;
  const i = s.getMutationCache(), r = s.getQueryCache(), n = s.getDefaultOptions().hydrate?.deserializeData ?? UP, a = t.mutations || [], o = t.queries || [];
  a.forEach(({ state: l, ...d }) => {
    i.build(
      s,
      {
        ...s.getDefaultOptions().hydrate?.mutations,
        ...e?.defaultOptions?.mutations,
        ...d
      },
      l
    );
  }), o.forEach(
    ({ queryKey: l, state: d, queryHash: u, meta: p, promise: f, dehydratedAt: y }) => {
      const g = f ? cL(f) : void 0, O = d.data === void 0 ? g?.data : d.data, k = O === void 0 ? O : n(O);
      let $ = r.get(u);
      const T = $?.state.status === "pending", _ = $?.state.fetchStatus === "fetching";
      if ($) {
        const D = g && // We only need this undefined check to handle older dehydration
        // payloads that might not have dehydratedAt
        y !== void 0 && y > $.state.dataUpdatedAt;
        if (d.dataUpdatedAt > $.state.dataUpdatedAt || D) {
          const { fetchStatus: A, ...z } = d;
          $.setState({
            ...z,
            data: k
          });
        }
      } else
        $ = r.build(
          s,
          {
            ...s.getDefaultOptions().hydrate?.queries,
            ...e?.defaultOptions?.queries,
            queryKey: l,
            queryHash: u,
            meta: p
          },
          // Reset fetch status to idle to avoid
          // query being stuck in fetching state upon hydration
          {
            ...d,
            data: k,
            fetchStatus: "idle",
            status: k !== void 0 ? "success" : d.status
          }
        );
      f && !T && !_ && // Only hydrate if dehydration is newer than any existing data,
      // this is always true for new queries
      (y === void 0 || y > $.state.dataUpdatedAt) && $.fetch(void 0, {
        // RSC transformed promises are not thenable
        initialPromise: Promise.resolve(f).then(n)
      }).catch(oi);
    }
  );
}
h(yL, "pg");
c(yL, "hydrate");
var xj = rL;
function gL() {
  let s = [], t = 0, e = /* @__PURE__ */ c((o) => {
    o();
  }, "notifyFn"), i = /* @__PURE__ */ c((o) => {
    o();
  }, "batchNotifyFn"), r = xj;
  const n = /* @__PURE__ */ c((o) => {
    t ? s.push(o) : r(() => {
      e(o);
    });
  }, "schedule"), a = /* @__PURE__ */ c(() => {
    const o = s;
    s = [], o.length && r(() => {
      i(() => {
        o.forEach((l) => {
          e(l);
        });
      });
    });
  }, "flush");
  return {
    batch: /* @__PURE__ */ c((o) => {
      let l;
      t++;
      try {
        l = o();
      } finally {
        t--, t || a();
      }
      return l;
    }, "batch"),
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: /* @__PURE__ */ c((o) => (...l) => {
      n(() => {
        o(...l);
      });
    }, "batchCalls"),
    schedule: n,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: /* @__PURE__ */ c((o) => {
      e = o;
    }, "setNotifyFunction"),
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: /* @__PURE__ */ c((o) => {
      i = o;
    }, "setBatchNotifyFunction"),
    setScheduler: /* @__PURE__ */ c((o) => {
      r = o;
    }, "setScheduler")
  };
}
h(gL, "wg");
c(gL, "createNotifyManager");
var hi = gL(), ug, Xa, pg, e$, cp, kj = (e$ = (cp = class extends Dy {
  constructor() {
    super(), q(this, ug, !0), q(this, Xa), q(this, pg), E(this, pg, (t) => {
      if (!wy && window.addEventListener) {
        const e = /* @__PURE__ */ c(() => t(!0), "onlineListener"), i = /* @__PURE__ */ c(() => t(!1), "offlineListener");
        return window.addEventListener("online", e, !1), window.addEventListener("offline", i, !1), () => {
          window.removeEventListener("online", e), window.removeEventListener("offline", i);
        };
      }
    });
  }
  onSubscribe() {
    x(this, Xa) || this.setEventListener(x(this, pg));
  }
  onUnsubscribe() {
    var t;
    this.hasListeners() || ((t = x(this, Xa)) == null || t.call(this), E(this, Xa, void 0));
  }
  setEventListener(t) {
    var e;
    E(this, pg, t), (e = x(this, Xa)) == null || e.call(this), E(this, Xa, t(this.setOnline.bind(this)));
  }
  setOnline(t) {
    x(this, ug) !== t && (E(this, ug, t), this.listeners.forEach((e) => {
      e(t);
    }));
  }
  isOnline() {
    return x(this, ug);
  }
}, h(cp, "Oa"), cp), ug = /* @__PURE__ */ new WeakMap(), Xa = /* @__PURE__ */ new WeakMap(), pg = /* @__PURE__ */ new WeakMap(), c(e$, "OnlineManager"), e$), h0 = new kj();
function wL(s) {
  return Math.min(1e3 * 2 ** s, 3e4);
}
h(wL, "mg");
c(wL, "defaultRetryDelay");
function HP(s) {
  return (s ?? "online") === "online" ? h0.isOnline() : !0;
}
h(HP, "wm");
c(HP, "canFetch");
var i$, hp, dS = (i$ = (hp = class extends Error {
  constructor(t) {
    super("CancelledError"), this.revert = t?.revert, this.silent = t?.silent;
  }
}, h(hp, "za"), hp), c(i$, "CancelledError"), i$);
function YP(s) {
  let t = !1, e = 0, i;
  const r = c0(), n = /* @__PURE__ */ c(() => r.status !== "pending", "isResolved"), a = /* @__PURE__ */ c((O) => {
    if (!n()) {
      const k = new dS(O);
      f(k), s.onCancel?.(k);
    }
  }, "cancel"), o = /* @__PURE__ */ c(() => {
    t = !0;
  }, "cancelRetry"), l = /* @__PURE__ */ c(() => {
    t = !1;
  }, "continueRetry"), d = /* @__PURE__ */ c(() => jP.isFocused() && (s.networkMode === "always" || h0.isOnline()) && s.canRun(), "canContinue"), u = /* @__PURE__ */ c(() => HP(s.networkMode) && s.canRun(), "canStart"), p = /* @__PURE__ */ c((O) => {
    n() || (i?.(), r.resolve(O));
  }, "resolve"), f = /* @__PURE__ */ c((O) => {
    n() || (i?.(), r.reject(O));
  }, "reject"), y = /* @__PURE__ */ c(() => new Promise((O) => {
    i = /* @__PURE__ */ c((k) => {
      (n() || d()) && O(k);
    }, "continueFn"), s.onPause?.();
  }).then(() => {
    i = void 0, n() || s.onContinue?.();
  }), "pause"), g = /* @__PURE__ */ c(() => {
    if (n())
      return;
    let O;
    const k = e === 0 ? s.initialPromise : void 0;
    try {
      O = k ?? s.fn();
    } catch ($) {
      O = Promise.reject($);
    }
    Promise.resolve(O).then(p).catch(($) => {
      if (n())
        return;
      const T = s.retry ?? (wy ? 0 : 3), _ = s.retryDelay ?? wL, D = typeof _ == "function" ? _(e, $) : _, A = T === !0 || typeof T == "number" && e < T || typeof T == "function" && T(e, $);
      if (t || !A) {
        f($);
        return;
      }
      e++, s.onFail?.(e, $), nL(D).then(() => d() ? void 0 : y()).then(() => {
        t ? f($) : g();
      });
    });
  }, "run");
  return {
    promise: r,
    status: /* @__PURE__ */ c(() => r.status, "status"),
    cancel: a,
    continue: /* @__PURE__ */ c(() => (i?.(), r), "continue"),
    cancelRetry: o,
    continueRetry: l,
    canStart: u,
    start: /* @__PURE__ */ c(() => (u() ? g() : y().then(g), r), "start")
  };
}
h(YP, "fm");
c(YP, "createRetryer");
var zc, r$, dp, vL = (r$ = (dp = class {
  constructor() {
    q(this, zc);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), a0(this.gcTime) && E(this, zc, Wn.setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t ?? (wy ? 1 / 0 : 300 * 1e3)
    );
  }
  clearGcTimeout() {
    x(this, zc) && (Wn.clearTimeout(x(this, zc)), E(this, zc, void 0));
  }
}, h(dp, "Ia"), dp), zc = /* @__PURE__ */ new WeakMap(), c(r$, "Removable"), r$), Ic, fg, Mr, Dc, si, yv, Vc, Yr, Ts, s$, up, Sj = (s$ = (up = class extends vL {
  constructor(t) {
    super(), q(this, Yr), q(this, Ic), q(this, fg), q(this, Mr), q(this, Dc), q(this, si), q(this, yv), q(this, Vc), E(this, Vc, !1), E(this, yv, t.defaultOptions), this.setOptions(t.options), this.observers = [], E(this, Dc, t.client), E(this, Mr, x(this, Dc).getQueryCache()), this.queryKey = t.queryKey, this.queryHash = t.queryHash, E(this, Ic, pS(this.options)), this.state = t.state ?? x(this, Ic), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return x(this, si)?.promise;
  }
  setOptions(t) {
    if (this.options = { ...x(this, yv), ...t }, this.updateGcTime(this.options.gcTime), this.state && this.state.data === void 0) {
      const e = pS(this.options);
      e.data !== void 0 && (this.setState(
        uS(e.data, e.dataUpdatedAt)
      ), E(this, Ic, e));
    }
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && x(this, Mr).remove(this);
  }
  setData(t, e) {
    const i = l0(this.state.data, t, this.options);
    return kt(this, Yr, Ts).call(this, {
      data: i,
      type: "success",
      dataUpdatedAt: e?.updatedAt,
      manual: e?.manual
    }), i;
  }
  setState(t, e) {
    kt(this, Yr, Ts).call(this, { type: "setState", state: t, setStateOptions: e });
  }
  cancel(t) {
    const e = x(this, si)?.promise;
    return x(this, si)?.cancel(t), e ? e.then(oi).catch(oi) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(x(this, Ic));
  }
  isActive() {
    return this.observers.some(
      (t) => sr(t.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === NP || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (t) => tn(t.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (t) => t.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(t = 0) {
    return this.state.data === void 0 ? !0 : t === "static" ? !1 : this.state.isInvalidated ? !0 : !BP(this.state.dataUpdatedAt, t);
  }
  onFocus() {
    this.observers.find((t) => t.shouldFetchOnWindowFocus())?.refetch({ cancelRefetch: !1 }), x(this, si)?.continue();
  }
  onOnline() {
    this.observers.find((t) => t.shouldFetchOnReconnect())?.refetch({ cancelRefetch: !1 }), x(this, si)?.continue();
  }
  addObserver(t) {
    this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), x(this, Mr).notify({ type: "observerAdded", query: this, observer: t }));
  }
  removeObserver(t) {
    this.observers.includes(t) && (this.observers = this.observers.filter((e) => e !== t), this.observers.length || (x(this, si) && (x(this, Vc) ? x(this, si).cancel({ revert: !0 }) : x(this, si).cancelRetry()), this.scheduleGc()), x(this, Mr).notify({ type: "observerRemoved", query: this, observer: t }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || kt(this, Yr, Ts).call(this, { type: "invalidate" });
  }
  async fetch(t, e) {
    if (this.state.fetchStatus !== "idle" && // If the promise in the retryer is already rejected, we have to definitely
    // re-start the fetch; there is a chance that the query is still in a
    // pending state when that happens
    x(this, si)?.status() !== "rejected") {
      if (this.state.data !== void 0 && e?.cancelRefetch)
        this.cancel({ silent: !0 });
      else if (x(this, si))
        return x(this, si).continueRetry(), x(this, si).promise;
    }
    if (t && this.setOptions(t), !this.options.queryFn) {
      const o = this.observers.find((l) => l.options.queryFn);
      o && this.setOptions(o.options);
    }
    const i = new AbortController(), r = /* @__PURE__ */ c((o) => {
      Object.defineProperty(o, "signal", {
        enumerable: !0,
        get: /* @__PURE__ */ c(() => (E(this, Vc, !0), i.signal), "get")
      });
    }, "addSignalProperty"), n = /* @__PURE__ */ c(() => {
      const o = XP(this.options, e), l = (/* @__PURE__ */ c(() => {
        const d = {
          client: x(this, Dc),
          queryKey: this.queryKey,
          meta: this.meta
        };
        return r(d), d;
      }, "createQueryFnContext"))();
      return E(this, Vc, !1), this.options.persister ? this.options.persister(
        o,
        l,
        this
      ) : o(l);
    }, "fetchFn"), a = (/* @__PURE__ */ c(() => {
      const o = {
        fetchOptions: e,
        options: this.options,
        queryKey: this.queryKey,
        client: x(this, Dc),
        state: this.state,
        fetchFn: n
      };
      return r(o), o;
    }, "createFetchContext"))();
    this.options.behavior?.onFetch(a, this), E(this, fg, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== a.fetchOptions?.meta) && kt(this, Yr, Ts).call(this, { type: "fetch", meta: a.fetchOptions?.meta }), E(this, si, YP({
      initialPromise: e?.initialPromise,
      fn: a.fetchFn,
      onCancel: /* @__PURE__ */ c((o) => {
        o instanceof dS && o.revert && this.setState({
          ...x(this, fg),
          fetchStatus: "idle"
        }), i.abort();
      }, "onCancel"),
      onFail: /* @__PURE__ */ c((o, l) => {
        kt(this, Yr, Ts).call(this, { type: "failed", failureCount: o, error: l });
      }, "onFail"),
      onPause: /* @__PURE__ */ c(() => {
        kt(this, Yr, Ts).call(this, { type: "pause" });
      }, "onPause"),
      onContinue: /* @__PURE__ */ c(() => {
        kt(this, Yr, Ts).call(this, { type: "continue" });
      }, "onContinue"),
      retry: a.options.retry,
      retryDelay: a.options.retryDelay,
      networkMode: a.options.networkMode,
      canRun: /* @__PURE__ */ c(() => !0, "canRun")
    }));
    try {
      const o = await x(this, si).start();
      if (o === void 0)
        throw new Error(`${this.queryHash} data is undefined`);
      return this.setData(o), x(this, Mr).config.onSuccess?.(o, this), x(this, Mr).config.onSettled?.(
        o,
        this.state.error,
        this
      ), o;
    } catch (o) {
      if (o instanceof dS) {
        if (o.silent)
          return x(this, si).promise;
        if (o.revert) {
          if (this.state.data === void 0)
            throw o;
          return this.state.data;
        }
      }
      throw kt(this, Yr, Ts).call(this, {
        type: "error",
        error: o
      }), x(this, Mr).config.onError?.(
        o,
        this
      ), x(this, Mr).config.onSettled?.(
        this.state.data,
        o,
        this
      ), o;
    } finally {
      this.scheduleGc();
    }
  }
}, h(up, "Da"), up), Ic = /* @__PURE__ */ new WeakMap(), fg = /* @__PURE__ */ new WeakMap(), Mr = /* @__PURE__ */ new WeakMap(), Dc = /* @__PURE__ */ new WeakMap(), si = /* @__PURE__ */ new WeakMap(), yv = /* @__PURE__ */ new WeakMap(), Vc = /* @__PURE__ */ new WeakMap(), Yr = /* @__PURE__ */ new WeakSet(), Ts = /* @__PURE__ */ c(function(s) {
  const t = /* @__PURE__ */ c((e) => {
    switch (s.type) {
      case "failed":
        return {
          ...e,
          fetchFailureCount: s.failureCount,
          fetchFailureReason: s.error
        };
      case "pause":
        return {
          ...e,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...e,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...e,
          ...GP(e.data, this.options),
          fetchMeta: s.meta ?? null
        };
      case "success":
        const i = {
          ...e,
          ...uS(s.data, s.dataUpdatedAt),
          dataUpdateCount: e.dataUpdateCount + 1,
          ...!s.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
        return E(this, fg, s.manual ? i : void 0), i;
      case "error":
        const r = s.error;
        return {
          ...e,
          error: r,
          errorUpdateCount: e.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: e.fetchFailureCount + 1,
          fetchFailureReason: r,
          fetchStatus: "idle",
          status: "error",
          // flag existing data as invalidated if we get a background error
          // note that "no data" always means stale so we can set unconditionally here
          isInvalidated: !0
        };
      case "invalidate":
        return {
          ...e,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...e,
          ...s.state
        };
    }
  }, "reducer");
  this.state = t(this.state), hi.batch(() => {
    this.observers.forEach((e) => {
      e.onQueryUpdate();
    }), x(this, Mr).notify({ query: this, type: "updated", action: s });
  });
}, "#dispatch"), c(s$, "Query"), s$);
function GP(s, t) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: HP(t.networkMode) ? "fetching" : "paused",
    ...s === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
h(GP, "vm");
c(GP, "fetchState");
function uS(s, t) {
  return {
    data: s,
    dataUpdatedAt: t ?? Date.now(),
    error: null,
    isInvalidated: !1,
    status: "success"
  };
}
h(uS, "Qw");
c(uS, "successState");
function pS(s) {
  const t = typeof s.initialData == "function" ? s.initialData() : s.initialData, e = t !== void 0, i = e ? typeof s.initialDataUpdatedAt == "function" ? s.initialDataUpdatedAt() : s.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: e ? i ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: e ? "success" : "pending",
    fetchStatus: "idle"
  };
}
h(pS, "Gw");
c(pS, "getDefaultState$1");
var Ji, qt, gv, Ii, Wc, mg, xn, ja, wv, yg, gg, Fc, qc, Ua, wg, $e, vg, n$, a$, o$, l$, c$, h$, d$, y9, u$, pp, OL = (u$ = (pp = class extends Dy {
  constructor(t, e) {
    super(), q(this, $e), q(this, Ji), q(this, qt), q(this, gv), q(this, Ii), q(this, Wc), q(this, mg), q(this, xn), q(this, ja), q(this, wv), q(this, yg), q(this, gg), q(this, Fc), q(this, qc), q(this, Ua), q(this, wg, /* @__PURE__ */ new Set()), this.options = e, E(this, Ji, t), E(this, ja, null), E(this, xn, c0()), this.bindMethods(), this.setOptions(e);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (x(this, qt).addObserver(this), fS(x(this, qt), this.options) ? kt(this, $e, vg).call(this) : this.updateResult(), kt(this, $e, l$).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return d0(
      x(this, qt),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return d0(
      x(this, qt),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), kt(this, $e, c$).call(this), kt(this, $e, h$).call(this), x(this, qt).removeObserver(this);
  }
  setOptions(t) {
    const e = this.options, i = x(this, qt);
    if (this.options = x(this, Ji).defaultQueryOptions(t), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof sr(this.options.enabled, x(this, qt)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    kt(this, $e, d$).call(this), x(this, qt).setOptions(this.options), e._defaulted && !jw(this.options, e) && x(this, Ji).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: x(this, qt),
      observer: this
    });
    const r = this.hasListeners();
    r && mS(
      x(this, qt),
      i,
      this.options,
      e
    ) && kt(this, $e, vg).call(this), this.updateResult(), r && (x(this, qt) !== i || sr(this.options.enabled, x(this, qt)) !== sr(e.enabled, x(this, qt)) || tn(this.options.staleTime, x(this, qt)) !== tn(e.staleTime, x(this, qt))) && kt(this, $e, n$).call(this);
    const n = kt(this, $e, a$).call(this);
    r && (x(this, qt) !== i || sr(this.options.enabled, x(this, qt)) !== sr(e.enabled, x(this, qt)) || n !== x(this, Ua)) && kt(this, $e, o$).call(this, n);
  }
  getOptimisticResult(t) {
    const e = x(this, Ji).getQueryCache().build(x(this, Ji), t), i = this.createResult(e, t);
    return $L(this, i) && (E(this, Ii, i), E(this, mg, this.options), E(this, Wc, x(this, qt).state)), i;
  }
  getCurrentResult() {
    return x(this, Ii);
  }
  trackResult(t, e) {
    return new Proxy(t, {
      get: /* @__PURE__ */ c((i, r) => (this.trackProp(r), e?.(r), r === "promise" && (this.trackProp("data"), !this.options.experimental_prefetchInRender && x(this, xn).status === "pending" && x(this, xn).reject(
        new Error(
          "experimental_prefetchInRender feature flag is not enabled"
        )
      )), Reflect.get(i, r)), "get")
    });
  }
  trackProp(t) {
    x(this, wg).add(t);
  }
  getCurrentQuery() {
    return x(this, qt);
  }
  refetch({ ...t } = {}) {
    return this.fetch({
      ...t
    });
  }
  fetchOptimistic(t) {
    const e = x(this, Ji).defaultQueryOptions(t), i = x(this, Ji).getQueryCache().build(x(this, Ji), e);
    return i.fetch().then(() => this.createResult(i, e));
  }
  fetch(t) {
    return kt(this, $e, vg).call(this, {
      ...t,
      cancelRefetch: t.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), x(this, Ii)));
  }
  createResult(t, e) {
    const i = x(this, qt), r = this.options, n = x(this, Ii), a = x(this, Wc), o = x(this, mg), l = t !== i ? t.state : x(this, gv), { state: d } = t;
    let u = { ...d }, p = !1, f;
    if (e._optimisticResults) {
      const V = this.hasListeners(), X = !V && fS(t, e), tt = V && mS(t, i, e, r);
      (X || tt) && (u = {
        ...u,
        ...GP(d.data, t.options)
      }), e._optimisticResults === "isRestoring" && (u.fetchStatus = "idle");
    }
    let { error: y, errorUpdatedAt: g, status: O } = u;
    f = u.data;
    let k = !1;
    if (e.placeholderData !== void 0 && f === void 0 && O === "pending") {
      let V;
      n?.isPlaceholderData && e.placeholderData === o?.placeholderData ? (V = n.data, k = !0) : V = typeof e.placeholderData == "function" ? e.placeholderData(
        x(this, gg)?.state.data,
        x(this, gg)
      ) : e.placeholderData, V !== void 0 && (O = "success", f = l0(
        n?.data,
        V,
        e
      ), p = !0);
    }
    if (e.select && f !== void 0 && !k)
      if (n && f === a?.data && e.select === x(this, wv))
        f = x(this, yg);
      else
        try {
          E(this, wv, e.select), f = e.select(f), f = l0(n?.data, f, e), E(this, yg, f), E(this, ja, null);
        } catch (V) {
          E(this, ja, V);
        }
    x(this, ja) && (y = x(this, ja), f = x(this, yg), g = Date.now(), O = "error");
    const $ = u.fetchStatus === "fetching", T = O === "pending", _ = O === "error", D = T && $, A = f !== void 0, z = {
      status: O,
      fetchStatus: u.fetchStatus,
      isPending: T,
      isSuccess: O === "success",
      isError: _,
      isInitialLoading: D,
      isLoading: D,
      data: f,
      dataUpdatedAt: u.dataUpdatedAt,
      error: y,
      errorUpdatedAt: g,
      failureCount: u.fetchFailureCount,
      failureReason: u.fetchFailureReason,
      errorUpdateCount: u.errorUpdateCount,
      isFetched: u.dataUpdateCount > 0 || u.errorUpdateCount > 0,
      isFetchedAfterMount: u.dataUpdateCount > l.dataUpdateCount || u.errorUpdateCount > l.errorUpdateCount,
      isFetching: $,
      isRefetching: $ && !T,
      isLoadingError: _ && !A,
      isPaused: u.fetchStatus === "paused",
      isPlaceholderData: p,
      isRefetchError: _ && A,
      isStale: Ob(t, e),
      refetch: this.refetch,
      promise: x(this, xn),
      isEnabled: sr(e.enabled, t) !== !1
    };
    if (this.options.experimental_prefetchInRender) {
      const V = z.data !== void 0, X = z.status === "error" && !V, tt = /* @__PURE__ */ c((st) => {
        X ? st.reject(z.error) : V && st.resolve(z.data);
      }, "finalizeThenableIfPossible"), vt = /* @__PURE__ */ c(() => {
        const st = E(this, xn, z.promise = c0());
        tt(st);
      }, "recreateThenable"), dt = x(this, xn);
      switch (dt.status) {
        case "pending":
          t.queryHash === i.queryHash && tt(dt);
          break;
        case "fulfilled":
          (X || z.data !== dt.value) && vt();
          break;
        case "rejected":
          (!X || z.error !== dt.reason) && vt();
          break;
      }
    }
    return z;
  }
  updateResult() {
    const t = x(this, Ii), e = this.createResult(x(this, qt), this.options);
    if (E(this, Wc, x(this, qt).state), E(this, mg, this.options), x(this, Wc).data !== void 0 && E(this, gg, x(this, qt)), jw(e, t))
      return;
    E(this, Ii, e);
    const i = /* @__PURE__ */ c(() => {
      if (!t)
        return !0;
      const { notifyOnChangeProps: r } = this.options, n = typeof r == "function" ? r() : r;
      if (n === "all" || !n && !x(this, wg).size)
        return !0;
      const a = new Set(
        n ?? x(this, wg)
      );
      return this.options.throwOnError && a.add("error"), Object.keys(x(this, Ii)).some((o) => {
        const l = o;
        return x(this, Ii)[l] !== t[l] && a.has(l);
      });
    }, "shouldNotifyListeners");
    kt(this, $e, y9).call(this, { listeners: i() });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && kt(this, $e, l$).call(this);
  }
}, h(pp, "Ua"), pp), Ji = /* @__PURE__ */ new WeakMap(), qt = /* @__PURE__ */ new WeakMap(), gv = /* @__PURE__ */ new WeakMap(), Ii = /* @__PURE__ */ new WeakMap(), Wc = /* @__PURE__ */ new WeakMap(), mg = /* @__PURE__ */ new WeakMap(), xn = /* @__PURE__ */ new WeakMap(), ja = /* @__PURE__ */ new WeakMap(), wv = /* @__PURE__ */ new WeakMap(), yg = /* @__PURE__ */ new WeakMap(), gg = /* @__PURE__ */ new WeakMap(), Fc = /* @__PURE__ */ new WeakMap(), qc = /* @__PURE__ */ new WeakMap(), Ua = /* @__PURE__ */ new WeakMap(), wg = /* @__PURE__ */ new WeakMap(), $e = /* @__PURE__ */ new WeakSet(), vg = /* @__PURE__ */ c(function(s) {
  kt(this, $e, d$).call(this);
  let t = x(this, qt).fetch(
    this.options,
    s
  );
  return s?.throwOnError || (t = t.catch(oi)), t;
}, "#executeFetch"), n$ = /* @__PURE__ */ c(function() {
  kt(this, $e, c$).call(this);
  const s = tn(
    this.options.staleTime,
    x(this, qt)
  );
  if (wy || x(this, Ii).isStale || !a0(s))
    return;
  const t = BP(x(this, Ii).dataUpdatedAt, s) + 1;
  E(this, Fc, Wn.setTimeout(() => {
    x(this, Ii).isStale || this.updateResult();
  }, t));
}, "#updateStaleTimeout"), a$ = /* @__PURE__ */ c(function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(x(this, qt)) : this.options.refetchInterval) ?? !1;
}, "#computeRefetchInterval"), o$ = /* @__PURE__ */ c(function(s) {
  kt(this, $e, h$).call(this), E(this, Ua, s), !(wy || sr(this.options.enabled, x(this, qt)) === !1 || !a0(x(this, Ua)) || x(this, Ua) === 0) && E(this, qc, Wn.setInterval(() => {
    (this.options.refetchIntervalInBackground || jP.isFocused()) && kt(this, $e, vg).call(this);
  }, x(this, Ua)));
}, "#updateRefetchInterval"), l$ = /* @__PURE__ */ c(function() {
  kt(this, $e, n$).call(this), kt(this, $e, o$).call(this, kt(this, $e, a$).call(this));
}, "#updateTimers"), c$ = /* @__PURE__ */ c(function() {
  x(this, Fc) && (Wn.clearTimeout(x(this, Fc)), E(this, Fc, void 0));
}, "#clearStaleTimeout"), h$ = /* @__PURE__ */ c(function() {
  x(this, qc) && (Wn.clearInterval(x(this, qc)), E(this, qc, void 0));
}, "#clearRefetchInterval"), d$ = /* @__PURE__ */ c(function() {
  const s = x(this, Ji).getQueryCache().build(x(this, Ji), this.options);
  if (s === x(this, qt))
    return;
  const t = x(this, qt);
  E(this, qt, s), E(this, gv, s.state), this.hasListeners() && (t?.removeObserver(this), s.addObserver(this));
}, "#updateQuery"), y9 = /* @__PURE__ */ c(function(s) {
  hi.batch(() => {
    s.listeners && this.listeners.forEach((t) => {
      t(x(this, Ii));
    }), x(this, Ji).getQueryCache().notify({
      query: x(this, qt),
      type: "observerResultsUpdated"
    });
  });
}, "#notify"), c(u$, "QueryObserver"), u$);
function bL(s, t) {
  return sr(t.enabled, s) !== !1 && s.state.data === void 0 && !(s.state.status === "error" && t.retryOnMount === !1);
}
h(bL, "gg");
c(bL, "shouldLoadOnMount");
function fS(s, t) {
  return bL(s, t) || s.state.data !== void 0 && d0(s, t, t.refetchOnMount);
}
h(fS, "Zw");
c(fS, "shouldFetchOnMount");
function d0(s, t, e) {
  if (sr(t.enabled, s) !== !1 && tn(t.staleTime, s) !== "static") {
    const i = typeof e == "function" ? e(s) : e;
    return i === "always" || i !== !1 && Ob(s, t);
  }
  return !1;
}
h(d0, "dp");
c(d0, "shouldFetchOn");
function mS(s, t, e, i) {
  return (s !== t || sr(i.enabled, s) === !1) && (!e.suspense || s.state.status !== "error") && Ob(s, e);
}
h(mS, "Yw");
c(mS, "shouldFetchOptionally");
function Ob(s, t) {
  return sr(t.enabled, s) !== !1 && s.isStaleByTime(tn(t.staleTime, s));
}
h(Ob, "ry");
c(Ob, "isStale");
function $L(s, t) {
  return !jw(s.getCurrentResult(), t);
}
h($L, "bg");
c($L, "shouldAssignObserverCurrentProperties");
function Uw(s) {
  return {
    onFetch: /* @__PURE__ */ c((t, e) => {
      const i = t.options, r = t.fetchOptions?.meta?.fetchMore?.direction, n = t.state.data?.pages || [], a = t.state.data?.pageParams || [];
      let o = { pages: [], pageParams: [] }, l = 0;
      const d = /* @__PURE__ */ c(async () => {
        let u = !1;
        const p = /* @__PURE__ */ c((g) => {
          lL(
            g,
            () => t.signal,
            () => u = !0
          );
        }, "addSignalProperty"), f = XP(t.options, t.fetchOptions), y = /* @__PURE__ */ c(async (g, O, k) => {
          if (u)
            return Promise.reject();
          if (O == null && g.pages.length)
            return Promise.resolve(g);
          const $ = (/* @__PURE__ */ c(() => {
            const A = {
              client: t.client,
              queryKey: t.queryKey,
              pageParam: O,
              direction: k ? "backward" : "forward",
              meta: t.options.meta
            };
            return p(A), A;
          }, "createQueryFnContext"))(), T = await f($), { maxPages: _ } = t.options, D = k ? oL : aL;
          return {
            pages: D(g.pages, T, _),
            pageParams: D(g.pageParams, O, _)
          };
        }, "fetchPage");
        if (r && n.length) {
          const g = r === "backward", O = g ? KP : u0, k = {
            pages: n,
            pageParams: a
          }, $ = O(i, k);
          o = await y(k, $, g);
        } else {
          const g = s ?? n.length;
          do {
            const O = l === 0 ? a[0] ?? i.initialPageParam : u0(i, o);
            if (l > 0 && O == null)
              break;
            o = await y(o, O), l++;
          } while (l < g);
        }
        return o;
      }, "fetchFn");
      t.options.persister ? t.fetchFn = () => t.options.persister?.(
        d,
        {
          client: t.client,
          queryKey: t.queryKey,
          meta: t.options.meta,
          signal: t.signal
        },
        e
      ) : t.fetchFn = d;
    }, "onFetch")
  };
}
h(Uw, "Kd");
c(Uw, "infiniteQueryBehavior");
function u0(s, { pages: t, pageParams: e }) {
  const i = t.length - 1;
  return t.length > 0 ? s.getNextPageParam(
    t[i],
    t,
    e[i],
    e
  ) : void 0;
}
h(u0, "hp");
c(u0, "getNextPageParam");
function KP(s, { pages: t, pageParams: e }) {
  return t.length > 0 ? s.getPreviousPageParam?.(t[0], t, e[0], e) : void 0;
}
h(KP, "xm");
c(KP, "getPreviousPageParam");
function xL(s, t) {
  return t ? u0(s, t) != null : !1;
}
h(xL, "xg");
c(xL, "hasNextPage");
function kL(s, t) {
  return !t || !s.getPreviousPageParam ? !1 : KP(s, t) != null;
}
h(kL, "Cg");
c(kL, "hasPreviousPage");
var p$, fp, Cj = (p$ = (fp = class extends OL {
  constructor(t, e) {
    super(t, e);
  }
  bindMethods() {
    super.bindMethods(), this.fetchNextPage = this.fetchNextPage.bind(this), this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
  }
  setOptions(t) {
    super.setOptions({
      ...t,
      behavior: Uw()
    });
  }
  getOptimisticResult(t) {
    return t.behavior = Uw(), super.getOptimisticResult(t);
  }
  fetchNextPage(t) {
    return this.fetch({
      ...t,
      meta: {
        fetchMore: { direction: "forward" }
      }
    });
  }
  fetchPreviousPage(t) {
    return this.fetch({
      ...t,
      meta: {
        fetchMore: { direction: "backward" }
      }
    });
  }
  createResult(t, e) {
    const { state: i } = t, r = super.createResult(t, e), { isFetching: n, isRefetching: a, isError: o, isRefetchError: l } = r, d = i.fetchMeta?.fetchMore?.direction, u = o && d === "forward", p = n && d === "forward", f = o && d === "backward", y = n && d === "backward";
    return {
      ...r,
      fetchNextPage: this.fetchNextPage,
      fetchPreviousPage: this.fetchPreviousPage,
      hasNextPage: xL(e, i.data),
      hasPreviousPage: kL(e, i.data),
      isFetchNextPageError: u,
      isFetchingNextPage: p,
      isFetchPreviousPageError: f,
      isFetchingPreviousPage: y,
      isRefetchError: l && !u && !f,
      isRefetching: a && !p && !y
    };
  }
}, h(fp, "qa"), fp), c(p$, "InfiniteQueryObserver"), p$), vv, Ms, Di, Zc, As, kn, f$, mp, Pj = (f$ = (mp = class extends vL {
  constructor(t) {
    super(), q(this, As), q(this, vv), q(this, Ms), q(this, Di), q(this, Zc), E(this, vv, t.client), this.mutationId = t.mutationId, E(this, Di, t.mutationCache), E(this, Ms, []), this.state = t.state || JP(), this.setOptions(t.options), this.scheduleGc();
  }
  setOptions(t) {
    this.options = t, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(t) {
    x(this, Ms).includes(t) || (x(this, Ms).push(t), this.clearGcTimeout(), x(this, Di).notify({
      type: "observerAdded",
      mutation: this,
      observer: t
    }));
  }
  removeObserver(t) {
    E(this, Ms, x(this, Ms).filter((e) => e !== t)), this.scheduleGc(), x(this, Di).notify({
      type: "observerRemoved",
      mutation: this,
      observer: t
    });
  }
  optionalRemove() {
    x(this, Ms).length || (this.state.status === "pending" ? this.scheduleGc() : x(this, Di).remove(this));
  }
  continue() {
    return x(this, Zc)?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(t) {
    const e = /* @__PURE__ */ c(() => {
      kt(this, As, kn).call(this, { type: "continue" });
    }, "onContinue"), i = {
      client: x(this, vv),
      meta: this.options.meta,
      mutationKey: this.options.mutationKey
    };
    E(this, Zc, YP({
      fn: /* @__PURE__ */ c(() => this.options.mutationFn ? this.options.mutationFn(t, i) : Promise.reject(new Error("No mutationFn found")), "fn"),
      onFail: /* @__PURE__ */ c((a, o) => {
        kt(this, As, kn).call(this, { type: "failed", failureCount: a, error: o });
      }, "onFail"),
      onPause: /* @__PURE__ */ c(() => {
        kt(this, As, kn).call(this, { type: "pause" });
      }, "onPause"),
      onContinue: e,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: /* @__PURE__ */ c(() => x(this, Di).canRun(this), "canRun")
    }));
    const r = this.state.status === "pending", n = !x(this, Zc).canStart();
    try {
      if (r)
        e();
      else {
        kt(this, As, kn).call(this, { type: "pending", variables: t, isPaused: n }), await x(this, Di).config.onMutate?.(
          t,
          this,
          i
        );
        const o = await this.options.onMutate?.(
          t,
          i
        );
        o !== this.state.context && kt(this, As, kn).call(this, {
          type: "pending",
          context: o,
          variables: t,
          isPaused: n
        });
      }
      const a = await x(this, Zc).start();
      return await x(this, Di).config.onSuccess?.(
        a,
        t,
        this.state.context,
        this,
        i
      ), await this.options.onSuccess?.(
        a,
        t,
        this.state.context,
        i
      ), await x(this, Di).config.onSettled?.(
        a,
        null,
        this.state.variables,
        this.state.context,
        this,
        i
      ), await this.options.onSettled?.(
        a,
        null,
        t,
        this.state.context,
        i
      ), kt(this, As, kn).call(this, { type: "success", data: a }), a;
    } catch (a) {
      try {
        await x(this, Di).config.onError?.(
          a,
          t,
          this.state.context,
          this,
          i
        );
      } catch (o) {
        Promise.reject(o);
      }
      try {
        await this.options.onError?.(
          a,
          t,
          this.state.context,
          i
        );
      } catch (o) {
        Promise.reject(o);
      }
      try {
        await x(this, Di).config.onSettled?.(
          void 0,
          a,
          this.state.variables,
          this.state.context,
          this,
          i
        );
      } catch (o) {
        Promise.reject(o);
      }
      try {
        await this.options.onSettled?.(
          void 0,
          a,
          t,
          this.state.context,
          i
        );
      } catch (o) {
        Promise.reject(o);
      }
      throw kt(this, As, kn).call(this, { type: "error", error: a }), a;
    } finally {
      x(this, Di).runNext(this);
    }
  }
}, h(mp, "ja"), mp), vv = /* @__PURE__ */ new WeakMap(), Ms = /* @__PURE__ */ new WeakMap(), Di = /* @__PURE__ */ new WeakMap(), Zc = /* @__PURE__ */ new WeakMap(), As = /* @__PURE__ */ new WeakSet(), kn = /* @__PURE__ */ c(function(s) {
  const t = /* @__PURE__ */ c((e) => {
    switch (s.type) {
      case "failed":
        return {
          ...e,
          failureCount: s.failureCount,
          failureReason: s.error
        };
      case "pause":
        return {
          ...e,
          isPaused: !0
        };
      case "continue":
        return {
          ...e,
          isPaused: !1
        };
      case "pending":
        return {
          ...e,
          context: s.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: s.isPaused,
          status: "pending",
          variables: s.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...e,
          data: s.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...e,
          data: void 0,
          error: s.error,
          failureCount: e.failureCount + 1,
          failureReason: s.error,
          isPaused: !1,
          status: "error"
        };
    }
  }, "reducer");
  this.state = t(this.state), hi.batch(() => {
    x(this, Ms).forEach((e) => {
      e.onMutationUpdate(s);
    }), x(this, Di).notify({
      mutation: this,
      type: "updated",
      action: s
    });
  });
}, "#dispatch"), c(f$, "Mutation"), f$);
function JP() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
h(JP, "Cm");
c(JP, "getDefaultState");
var Sn, Gr, Ov, m$, yp, Qj = (m$ = (yp = class extends Dy {
  constructor(t = {}) {
    super(), q(this, Sn), q(this, Gr), q(this, Ov), this.config = t, E(this, Sn, /* @__PURE__ */ new Set()), E(this, Gr, /* @__PURE__ */ new Map()), E(this, Ov, 0);
  }
  build(t, e, i) {
    const r = new Pj({
      client: t,
      mutationCache: this,
      mutationId: ++aS(this, Ov)._,
      options: t.defaultMutationOptions(e),
      state: i
    });
    return this.add(r), r;
  }
  add(t) {
    x(this, Sn).add(t);
    const e = Vg(t);
    if (typeof e == "string") {
      const i = x(this, Gr).get(e);
      i ? i.push(t) : x(this, Gr).set(e, [t]);
    }
    this.notify({ type: "added", mutation: t });
  }
  remove(t) {
    if (x(this, Sn).delete(t)) {
      const e = Vg(t);
      if (typeof e == "string") {
        const i = x(this, Gr).get(e);
        if (i)
          if (i.length > 1) {
            const r = i.indexOf(t);
            r !== -1 && i.splice(r, 1);
          } else i[0] === t && x(this, Gr).delete(e);
      }
    }
    this.notify({ type: "removed", mutation: t });
  }
  canRun(t) {
    const e = Vg(t);
    if (typeof e == "string") {
      const i = x(this, Gr).get(e)?.find(
        (r) => r.state.status === "pending"
      );
      return !i || i === t;
    } else
      return !0;
  }
  runNext(t) {
    const e = Vg(t);
    return typeof e == "string" ? x(this, Gr).get(e)?.find((i) => i !== t && i.state.isPaused)?.continue() ?? Promise.resolve() : Promise.resolve();
  }
  clear() {
    hi.batch(() => {
      x(this, Sn).forEach((t) => {
        this.notify({ type: "removed", mutation: t });
      }), x(this, Sn).clear(), x(this, Gr).clear();
    });
  }
  getAll() {
    return Array.from(x(this, Sn));
  }
  find(t) {
    const e = { exact: !0, ...t };
    return this.getAll().find(
      (i) => lS(e, i)
    );
  }
  findAll(t = {}) {
    return this.getAll().filter((e) => lS(t, e));
  }
  notify(t) {
    hi.batch(() => {
      this.listeners.forEach((e) => {
        e(t);
      });
    });
  }
  resumePausedMutations() {
    const t = this.getAll().filter((e) => e.state.isPaused);
    return hi.batch(
      () => Promise.all(
        t.map((e) => e.continue().catch(oi))
      )
    );
  }
}, h(yp, "Wa"), yp), Sn = /* @__PURE__ */ new WeakMap(), Gr = /* @__PURE__ */ new WeakMap(), Ov = /* @__PURE__ */ new WeakMap(), c(m$, "MutationCache"), m$);
function Vg(s) {
  return s.options.scope?.id;
}
h(Vg, "Ld");
c(Vg, "scopeFor");
var Cn, Ha, tr, Pn, Ya, bv, y$, g$, gp, Yt = (g$ = (gp = class extends Dy {
  constructor(t, e) {
    super(), q(this, Ya), q(this, Cn), q(this, Ha), q(this, tr), q(this, Pn), E(this, Cn, t), this.setOptions(e), this.bindMethods(), kt(this, Ya, bv).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);
  }
  setOptions(t) {
    const e = this.options;
    this.options = x(this, Cn).defaultMutationOptions(t), jw(this.options, e) || x(this, Cn).getMutationCache().notify({
      type: "observerOptionsUpdated",
      mutation: x(this, tr),
      observer: this
    }), e?.mutationKey && this.options.mutationKey && ma(e.mutationKey) !== ma(this.options.mutationKey) ? this.reset() : x(this, tr)?.state.status === "pending" && x(this, tr).setOptions(this.options);
  }
  onUnsubscribe() {
    this.hasListeners() || x(this, tr)?.removeObserver(this);
  }
  onMutationUpdate(t) {
    kt(this, Ya, bv).call(this), kt(this, Ya, y$).call(this, t);
  }
  getCurrentResult() {
    return x(this, Ha);
  }
  reset() {
    x(this, tr)?.removeObserver(this), E(this, tr, void 0), kt(this, Ya, bv).call(this), kt(this, Ya, y$).call(this);
  }
  mutate(t, e) {
    return E(this, Pn, e), x(this, tr)?.removeObserver(this), E(this, tr, x(this, Cn).getMutationCache().build(x(this, Cn), this.options)), x(this, tr).addObserver(this), x(this, tr).execute(t);
  }
}, h(gp, "Ka"), gp), Cn = /* @__PURE__ */ new WeakMap(), Ha = /* @__PURE__ */ new WeakMap(), tr = /* @__PURE__ */ new WeakMap(), Pn = /* @__PURE__ */ new WeakMap(), Ya = /* @__PURE__ */ new WeakSet(), bv = /* @__PURE__ */ c(function() {
  const s = x(this, tr)?.state ?? JP();
  E(this, Ha, {
    ...s,
    isPending: s.status === "pending",
    isSuccess: s.status === "success",
    isError: s.status === "error",
    isIdle: s.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, "#updateResult"), y$ = /* @__PURE__ */ c(function(s) {
  hi.batch(() => {
    if (x(this, Pn) && this.hasListeners()) {
      const t = x(this, Ha).variables, e = x(this, Ha).context, i = {
        client: x(this, Cn),
        meta: this.options.meta,
        mutationKey: this.options.mutationKey
      };
      if (s?.type === "success") {
        try {
          x(this, Pn).onSuccess?.(
            s.data,
            t,
            e,
            i
          );
        } catch (r) {
          Promise.reject(r);
        }
        try {
          x(this, Pn).onSettled?.(
            s.data,
            null,
            t,
            e,
            i
          );
        } catch (r) {
          Promise.reject(r);
        }
      } else if (s?.type === "error") {
        try {
          x(this, Pn).onError?.(
            s.error,
            t,
            e,
            i
          );
        } catch (r) {
          Promise.reject(r);
        }
        try {
          x(this, Pn).onSettled?.(
            void 0,
            s.error,
            t,
            e,
            i
          );
        } catch (r) {
          Promise.reject(r);
        }
      }
    }
    this.listeners.forEach((t) => {
      t(x(this, Ha));
    });
  });
}, "#notify"), c(g$, "MutationObserver"), g$), Rs, w$, wp, Tj = (w$ = (wp = class extends Dy {
  constructor(t = {}) {
    super(), q(this, Rs), this.config = t, E(this, Rs, /* @__PURE__ */ new Map());
  }
  build(t, e, i) {
    const r = e.queryKey, n = e.queryHash ?? vb(r, e);
    let a = this.get(n);
    return a || (a = new Sj({
      client: t,
      queryKey: r,
      queryHash: n,
      options: t.defaultQueryOptions(e),
      state: i,
      defaultOptions: t.getQueryDefaults(r)
    }), this.add(a)), a;
  }
  add(t) {
    x(this, Rs).has(t.queryHash) || (x(this, Rs).set(t.queryHash, t), this.notify({
      type: "added",
      query: t
    }));
  }
  remove(t) {
    const e = x(this, Rs).get(t.queryHash);
    e && (t.destroy(), e === t && x(this, Rs).delete(t.queryHash), this.notify({ type: "removed", query: t }));
  }
  clear() {
    hi.batch(() => {
      this.getAll().forEach((t) => {
        this.remove(t);
      });
    });
  }
  get(t) {
    return x(this, Rs).get(t);
  }
  getAll() {
    return [...x(this, Rs).values()];
  }
  find(t) {
    const e = { exact: !0, ...t };
    return this.getAll().find(
      (i) => oS(e, i)
    );
  }
  findAll(t = {}) {
    const e = this.getAll();
    return Object.keys(t).length > 0 ? e.filter((i) => oS(t, i)) : e;
  }
  notify(t) {
    hi.batch(() => {
      this.listeners.forEach((e) => {
        e(t);
      });
    });
  }
  onFocus() {
    hi.batch(() => {
      this.getAll().forEach((t) => {
        t.onFocus();
      });
    });
  }
  onOnline() {
    hi.batch(() => {
      this.getAll().forEach((t) => {
        t.onOnline();
      });
    });
  }
}, h(wp, "Qa"), wp), Rs = /* @__PURE__ */ new WeakMap(), c(w$, "QueryCache"), w$), xe, Ga, Ka, Og, bg, Ja, $g, xg, v$, vp, Mj = (v$ = (vp = class {
  constructor(t = {}) {
    q(this, xe), q(this, Ga), q(this, Ka), q(this, Og), q(this, bg), q(this, Ja), q(this, $g), q(this, xg), E(this, xe, t.queryCache || new Tj()), E(this, Ga, t.mutationCache || new Qj()), E(this, Ka, t.defaultOptions || {}), E(this, Og, /* @__PURE__ */ new Map()), E(this, bg, /* @__PURE__ */ new Map()), E(this, Ja, 0);
  }
  mount() {
    aS(this, Ja)._++, x(this, Ja) === 1 && (E(this, $g, jP.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), x(this, xe).onFocus());
    })), E(this, xg, h0.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), x(this, xe).onOnline());
    })));
  }
  unmount() {
    var t, e;
    aS(this, Ja)._--, x(this, Ja) === 0 && ((t = x(this, $g)) == null || t.call(this), E(this, $g, void 0), (e = x(this, xg)) == null || e.call(this), E(this, xg, void 0));
  }
  isFetching(t) {
    return x(this, xe).findAll({ ...t, fetchStatus: "fetching" }).length;
  }
  isMutating(t) {
    return x(this, Ga).findAll({ ...t, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(t) {
    const e = this.defaultQueryOptions({ queryKey: t });
    return x(this, xe).get(e.queryHash)?.state.data;
  }
  ensureQueryData(t) {
    const e = this.defaultQueryOptions(t), i = x(this, xe).build(this, e), r = i.state.data;
    return r === void 0 ? this.fetchQuery(t) : (t.revalidateIfStale && i.isStaleByTime(tn(e.staleTime, i)) && this.prefetchQuery(e), Promise.resolve(r));
  }
  getQueriesData(t) {
    return x(this, xe).findAll(t).map(({ queryKey: e, state: i }) => {
      const r = i.data;
      return [e, r];
    });
  }
  setQueryData(t, e, i) {
    const r = this.defaultQueryOptions({ queryKey: t }), n = x(this, xe).get(
      r.queryHash
    )?.state.data, a = sL(e, n);
    if (a !== void 0)
      return x(this, xe).build(this, r).setData(a, { ...i, manual: !0 });
  }
  setQueriesData(t, e, i) {
    return hi.batch(
      () => x(this, xe).findAll(t).map(({ queryKey: r }) => [
        r,
        this.setQueryData(r, e, i)
      ])
    );
  }
  getQueryState(t) {
    const e = this.defaultQueryOptions({ queryKey: t });
    return x(this, xe).get(
      e.queryHash
    )?.state;
  }
  removeQueries(t) {
    const e = x(this, xe);
    hi.batch(() => {
      e.findAll(t).forEach((i) => {
        e.remove(i);
      });
    });
  }
  resetQueries(t, e) {
    const i = x(this, xe);
    return hi.batch(() => (i.findAll(t).forEach((r) => {
      r.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...t
      },
      e
    )));
  }
  cancelQueries(t, e = {}) {
    const i = { revert: !0, ...e }, r = hi.batch(
      () => x(this, xe).findAll(t).map((n) => n.cancel(i))
    );
    return Promise.all(r).then(oi).catch(oi);
  }
  invalidateQueries(t, e = {}) {
    return hi.batch(() => (x(this, xe).findAll(t).forEach((i) => {
      i.invalidate();
    }), t?.refetchType === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...t,
        type: t?.refetchType ?? t?.type ?? "active"
      },
      e
    )));
  }
  refetchQueries(t, e = {}) {
    const i = {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }, r = hi.batch(
      () => x(this, xe).findAll(t).filter((n) => !n.isDisabled() && !n.isStatic()).map((n) => {
        let a = n.fetch(void 0, i);
        return i.throwOnError || (a = a.catch(oi)), n.state.fetchStatus === "paused" ? Promise.resolve() : a;
      })
    );
    return Promise.all(r).then(oi);
  }
  fetchQuery(t) {
    const e = this.defaultQueryOptions(t);
    e.retry === void 0 && (e.retry = !1);
    const i = x(this, xe).build(this, e);
    return i.isStaleByTime(
      tn(e.staleTime, i)
    ) ? i.fetch(e) : Promise.resolve(i.state.data);
  }
  prefetchQuery(t) {
    return this.fetchQuery(t).then(oi).catch(oi);
  }
  fetchInfiniteQuery(t) {
    return t.behavior = Uw(t.pages), this.fetchQuery(t);
  }
  prefetchInfiniteQuery(t) {
    return this.fetchInfiniteQuery(t).then(oi).catch(oi);
  }
  ensureInfiniteQueryData(t) {
    return t.behavior = Uw(t.pages), this.ensureQueryData(t);
  }
  resumePausedMutations() {
    return h0.isOnline() ? x(this, Ga).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return x(this, xe);
  }
  getMutationCache() {
    return x(this, Ga);
  }
  getDefaultOptions() {
    return x(this, Ka);
  }
  setDefaultOptions(t) {
    E(this, Ka, t);
  }
  setQueryDefaults(t, e) {
    x(this, Og).set(ma(t), {
      queryKey: t,
      defaultOptions: e
    });
  }
  getQueryDefaults(t) {
    const e = [...x(this, Og).values()], i = {};
    return e.forEach((r) => {
      vy(t, r.queryKey) && Object.assign(i, r.defaultOptions);
    }), i;
  }
  setMutationDefaults(t, e) {
    x(this, bg).set(ma(t), {
      mutationKey: t,
      defaultOptions: e
    });
  }
  getMutationDefaults(t) {
    const e = [...x(this, bg).values()], i = {};
    return e.forEach((r) => {
      vy(t, r.mutationKey) && Object.assign(i, r.defaultOptions);
    }), i;
  }
  defaultQueryOptions(t) {
    if (t._defaulted)
      return t;
    const e = {
      ...x(this, Ka).queries,
      ...this.getQueryDefaults(t.queryKey),
      ...t,
      _defaulted: !0
    };
    return e.queryHash || (e.queryHash = vb(
      e.queryKey,
      e
    )), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.queryFn === NP && (e.enabled = !1), e;
  }
  defaultMutationOptions(t) {
    return t?._defaulted ? t : {
      ...x(this, Ka).mutations,
      ...t?.mutationKey && this.getMutationDefaults(t.mutationKey),
      ...t,
      _defaulted: !0
    };
  }
  clear() {
    x(this, xe).clear(), x(this, Ga).clear();
  }
}, h(vp, "Ja"), vp), xe = /* @__PURE__ */ new WeakMap(), Ga = /* @__PURE__ */ new WeakMap(), Ka = /* @__PURE__ */ new WeakMap(), Og = /* @__PURE__ */ new WeakMap(), bg = /* @__PURE__ */ new WeakMap(), Ja = /* @__PURE__ */ new WeakMap(), $g = /* @__PURE__ */ new WeakMap(), xg = /* @__PURE__ */ new WeakMap(), c(v$, "QueryClient"), v$);
function Xv() {
}
h(Xv, "Fu");
c(Xv, "noop");
function SL({
  storage: s,
  key: t = "REACT_QUERY_OFFLINE_CACHE",
  throttleTime: e = 1e3,
  serialize: i = JSON.stringify,
  deserialize: r = JSON.parse,
  retry: n
}) {
  if (s) {
    const a = /* @__PURE__ */ c((o) => {
      try {
        s.setItem(t, i(o));
        return;
      } catch (l) {
        return l;
      }
    }, "trySave");
    return {
      persistClient: CL((o) => {
        let l = o, d = a(l), u = 0;
        for (; d && l; )
          u++, l = n?.({
            persistedClient: l,
            error: d,
            errorCount: u
          }), l && (d = a(l));
      }, e),
      restoreClient: /* @__PURE__ */ c(() => {
        const o = s.getItem(t);
        if (o)
          return r(o);
      }, "restoreClient"),
      removeClient: /* @__PURE__ */ c(() => {
        s.removeItem(t);
      }, "removeClient")
    };
  }
  return {
    persistClient: Xv,
    restoreClient: Xv,
    removeClient: Xv
  };
}
h(SL, "Mg");
c(SL, "createSyncStoragePersister");
function CL(s, t = 100) {
  let e = null, i;
  return function(...r) {
    i = r, e === null && (e = Wn.setTimeout(() => {
      s(...i), e = null;
    }, t));
  };
}
h(CL, "Ag");
c(CL, "throttle$1");
var Aj = ["added", "removed", "updated"];
function yS(s) {
  return Aj.includes(s);
}
h(yS, "Xw");
c(yS, "isCacheEventType");
async function PL({
  queryClient: s,
  persister: t,
  maxAge: e = 1e3 * 60 * 60 * 24,
  buster: i = "",
  hydrateOptions: r
}) {
  try {
    const n = await t.restoreClient();
    if (n)
      if (n.timestamp) {
        const a = Date.now() - n.timestamp > e, o = n.buster !== i;
        if (a || o)
          return t.removeClient();
        yL(s, n.clientState, r);
      } else
        return t.removeClient();
  } catch (n) {
    throw await t.removeClient(), n;
  }
}
h(PL, "Rg");
c(PL, "persistQueryClientRestore");
async function gS({
  queryClient: s,
  persister: t,
  buster: e = "",
  dehydrateOptions: i
}) {
  const r = {
    buster: e,
    timestamp: Date.now(),
    clientState: mL(s, i)
  };
  await t.persistClient(r);
}
h(gS, "Jw");
c(gS, "persistQueryClientSave");
function QL(s) {
  const t = s.queryClient.getQueryCache().subscribe((i) => {
    yS(i.type) && gS(s);
  }), e = s.queryClient.getMutationCache().subscribe((i) => {
    yS(i.type) && gS(s);
  });
  return () => {
    t(), e();
  };
}
h(QL, "Tg");
c(QL, "persistQueryClientSubscribe");
const Rj = /* @__PURE__ */ c((s) => {
  var e;
  var t;
  return t = (e = class extends s {
    // QUERY CLIENT
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), this._queryClient = new Mj({
        defaultOptions: {
          queries: {
            staleTime: this.staleTime,
            gcTime: this.gcTime
          }
        }
      }), this.initQueryClient();
    }
    get queryClient() {
      return this._queryClient;
    }
    async initQueryClient() {
      if (this.isDestroyed)
        throw new Ee();
      await this.whenUrl();
      try {
        this._sessionStoragePersister = SL({
          key: "WEAVY_QUERY_OFFLINE_CACHE",
          storage: window.sessionStorage,
          throttleTime: this.staleTime
        });
        const r = {
          queryClient: this._queryClient,
          persister: this._sessionStoragePersister,
          maxAge: this.gcTime,
          // 24h - should match gcTime
          buster: this.cachePrefix,
          // Cache busting parameter (build hash or similar)
          hydrateOptions: void 0,
          dehydrateOptions: {
            shouldDehydrateMutation: /* @__PURE__ */ c((n) => {
              const a = n.state.context?.status?.state === "pending";
              return !!(n.state.context && !a || n.state.isPaused);
            }, "shouldDehydrateMutation")
          }
        };
        await PL(r), this._unsubscribeQueryClient = QL(r);
      } catch {
        console.warn(this.weavyId, "Query cache persister not available.");
      }
      this.host.isConnected && this._queryClient.mount(), this._hostIsConnectedObserver = r8(this.host, (r) => {
        this.isDestroyed || (r ? (console.info(this.weavyId, "Query client mounted"), this._queryClient.mount()) : (console.info(this.weavyId, "Query client unmounted"), this._queryClient.unmount()));
      });
    }
    async reset() {
      await super.reset(), await this._queryClient.cancelQueries(), await this._sessionStoragePersister?.removeClient(), await this.queryClient.resetQueries();
    }
    async disconnectQueryClient() {
      console.info(this.weavyId, "Query client disconnected"), await this._queryClient.cancelQueries(), await this._sessionStoragePersister?.removeClient(), this._unsubscribeQueryClient?.(), this._queryClient.unmount(), this._queryClient.clear();
    }
    destroy() {
      super.destroy(), this._hostIsConnectedObserver?.disconnect(), this.disconnectQueryClient();
    }
  }, h(e, "t"), e), c(t, "WeavyQuery"), t;
}, "WeavyQueryMixin"), Ej = /* @__PURE__ */ c((s) => {
  var e;
  var t;
  return t = (e = class extends s {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r);
    }
    set annotations(r) {
      this._annotations = r, this.updateContext();
    }
    get annotations() {
      return this._annotations ?? _e.defaults.annotations;
    }
    set enterToSend(r) {
      this._enterToSend = r, this.updateContext();
    }
    get enterToSend() {
      return this._enterToSend ?? _e.defaults.enterToSend;
    }
    set reactions(r) {
      this._reactions = r, this.updateContext();
    }
    get reactions() {
      return this._reactions ?? _e.defaults.reactions;
    }
  }, h(e, "t"), e), c(t, "WeavySettings"), t;
}, "WeavySettingsMixin");
function xi(s) {
  return s < 0 ? -1 : s === 0 ? 0 : 1;
}
h(xi, "He");
c(xi, "signum");
function Ph(s, t, e) {
  return (1 - e) * s + e * t;
}
h(Ph, "hl");
c(Ph, "lerp");
function TL(s, t, e) {
  return e < s ? s : e > t ? t : e;
}
h(TL, "zg");
c(TL, "clampInt");
function Ke(s, t, e) {
  return e < s ? s : e > t ? t : e;
}
h(Ke, "$e");
c(Ke, "clampDouble");
function wS(s) {
  return s = s % 360, s < 0 && (s = s + 360), s;
}
h(wS, "tf");
c(wS, "sanitizeDegreesInt");
function Qi(s) {
  return s = s % 360, s < 0 && (s = s + 360), s;
}
h(Qi, "Ue");
c(Qi, "sanitizeDegreesDouble");
function p0(s, t) {
  const e = s[0] * t[0][0] + s[1] * t[0][1] + s[2] * t[0][2], i = s[0] * t[1][0] + s[1] * t[1][1] + s[2] * t[1][2], r = s[0] * t[2][0] + s[1] * t[2][1] + s[2] * t[2][2];
  return [e, i, r];
}
h(p0, "pp");
c(p0, "matrixMultiply");
const ML = [
  [0.41233895, 0.35762064, 0.18051042],
  [0.2126, 0.7152, 0.0722],
  [0.01932141, 0.11916382, 0.95034478]
], _j = [
  [
    3.2413774792388685,
    -1.5376652402851851,
    -0.49885366846268053
  ],
  [
    -0.9691452513005321,
    1.8758853451067872,
    0.04156585616912061
  ],
  [
    0.05562093689691305,
    -0.20395524564742123,
    1.0571799111220335
  ]
], AL = [95.047, 100, 108.883];
function bb(s, t, e) {
  return (255 << 24 | (s & 255) << 16 | (t & 255) << 8 | e & 255) >>> 0;
}
h(bb, "ny");
c(bb, "argbFromRgb");
function vS(s) {
  const t = Bn(s[0]), e = Bn(s[1]), i = Bn(s[2]);
  return bb(t, e, i);
}
h(vS, "ef");
c(vS, "argbFromLinrgb");
function RL(s) {
  return s >> 24 & 255;
}
h(RL, "Fg");
c(RL, "alphaFromArgb");
function $b(s) {
  return s >> 16 & 255;
}
h($b, "ay");
c($b, "redFromArgb");
function xb(s) {
  return s >> 8 & 255;
}
h(xb, "sy");
c(xb, "greenFromArgb");
function kb(s) {
  return s & 255;
}
h(kb, "oy");
c(kb, "blueFromArgb");
function EL(s, t, e) {
  const i = _j, r = i[0][0] * s + i[0][1] * t + i[0][2] * e, n = i[1][0] * s + i[1][1] * t + i[1][2] * e, a = i[2][0] * s + i[2][1] * t + i[2][2] * e, o = Bn(r), l = Bn(n), d = Bn(a);
  return bb(o, l, d);
}
h(EL, "Dg");
c(EL, "argbFromXyz");
function _L(s) {
  const t = ds($b(s)), e = ds(xb(s)), i = ds(kb(s));
  return p0([t, e, i], ML);
}
h(_L, "Vg");
c(_L, "xyzFromArgb");
function LL(s) {
  const t = ds($b(s)), e = ds(xb(s)), i = ds(kb(s)), r = ML, n = r[0][0] * t + r[0][1] * e + r[0][2] * i, a = r[1][0] * t + r[1][1] * e + r[1][2] * i, o = r[2][0] * t + r[2][1] * e + r[2][2] * i, l = AL, d = n / l[0], u = a / l[1], p = o / l[2], f = Qh(d), y = Qh(u), g = Qh(p), O = 116 * y - 16, k = 500 * (f - y), $ = 200 * (y - g);
  return [O, k, $];
}
h(LL, "Hg");
c(LL, "labFromArgb");
function zL(s) {
  const t = Ns(s), e = Bn(t);
  return bb(e, e, e);
}
h(zL, "Bg");
c(zL, "argbFromLstar");
function OS(s) {
  const t = _L(s)[1];
  return 116 * Qh(t / 100) - 16;
}
h(OS, "rf");
c(OS, "lstarFromArgb");
function Ns(s) {
  return 100 * DL((s + 16) / 116);
}
h(Ns, "Or");
c(Ns, "yFromLstar");
function f0(s) {
  return Qh(s / 100) * 116 - 16;
}
h(f0, "yp");
c(f0, "lstarFromY");
function ds(s) {
  const t = s / 255;
  return t <= 0.040449936 ? t / 12.92 * 100 : Math.pow((t + 0.055) / 1.055, 2.4) * 100;
}
h(ds, "Ji");
c(ds, "linearized");
function Bn(s) {
  const t = s / 100;
  let e = 0;
  return t <= 31308e-7 ? e = t * 12.92 : e = 1.055 * Math.pow(t, 1 / 2.4) - 0.055, TL(0, 255, Math.round(e * 255));
}
h(Bn, "$n");
c(Bn, "delinearized");
function IL() {
  return AL;
}
h(IL, "Ng");
c(IL, "whitePointD65");
function Qh(s) {
  const t = 0.008856451679035631, e = 24389 / 27;
  return s > t ? Math.pow(s, 1 / 3) : (e * s + 16) / 116;
}
h(Qh, "ul");
c(Qh, "labF");
function DL(s) {
  const t = 0.008856451679035631, e = 24389 / 27, i = s * s * s;
  return i > t ? i : (116 * s - 16) / e;
}
h(DL, "Ug");
c(DL, "labInvf");
var nl;
const VL = (nl = class {
  /**
   * Create ViewingConditions from a simple, physically relevant, set of
   * parameters.
   *
   * @param whitePoint White point, measured in the XYZ color space.
   *     default = D65, or sunny day afternoon
   * @param adaptingLuminance The luminance of the adapting field. Informally,
   *     how bright it is in the room where the color is viewed. Can be
   *     calculated from lux by multiplying lux by 0.0586. default = 11.72,
   *     or 200 lux.
   * @param backgroundLstar The lightness of the area surrounding the color.
   *     measured by L* in L*a*b*. default = 50.0
   * @param surround A general description of the lighting surrounding the
   *     color. 0 is pitch dark, like watching a movie in a theater. 1.0 is a
   *     dimly light room, like watching TV at home at night. 2.0 means there
   *     is no difference between the lighting on the color and around it.
   *     default = 2.0
   * @param discountingIlluminant Whether the eye accounts for the tint of the
   *     ambient lighting, such as knowing an apple is still red in green light.
   *     default = false, the eye does not perform this process on
   *       self-luminous objects like displays.
   */
  static make(t = IL(), e = 200 / Math.PI * Ns(50) / 100, i = 50, r = 2, n = !1) {
    const a = t, o = a[0] * 0.401288 + a[1] * 0.650173 + a[2] * -0.051461, l = a[0] * -0.250268 + a[1] * 1.204414 + a[2] * 0.045854, d = a[0] * -2079e-6 + a[1] * 0.048952 + a[2] * 0.953127, u = 0.8 + r / 10, p = u >= 0.9 ? Ph(0.59, 0.69, (u - 0.9) * 10) : Ph(0.525, 0.59, (u - 0.8) * 10);
    let f = n ? 1 : u * (1 - 1 / 3.6 * Math.exp((-e - 42) / 92));
    f = f > 1 ? 1 : f < 0 ? 0 : f;
    const y = u, g = [
      f * (100 / o) + 1 - f,
      f * (100 / l) + 1 - f,
      f * (100 / d) + 1 - f
    ], O = 1 / (5 * e + 1), k = O * O * O * O, $ = 1 - k, T = k * e + 0.1 * $ * $ * Math.cbrt(5 * e), _ = Ns(i) / t[1], D = 1.48 + Math.sqrt(_), A = 0.725 / Math.pow(_, 0.2), z = A, V = [
      Math.pow(T * g[0] * o / 100, 0.42),
      Math.pow(T * g[1] * l / 100, 0.42),
      Math.pow(T * g[2] * d / 100, 0.42)
    ], X = [
      400 * V[0] / (V[0] + 27.13),
      400 * V[1] / (V[1] + 27.13),
      400 * V[2] / (V[2] + 27.13)
    ], tt = (2 * X[0] + X[1] + 0.05 * X[2]) * A;
    return new nl(_, tt, A, z, p, y, g, T, Math.pow(T, 0.25), D);
  }
  /**
   * Parameters are intermediate values of the CAM16 conversion process. Their
   * names are shorthand for technical color science terminology, this class
   * would not benefit from documenting them individually. A brief overview
   * is available in the CAM16 specification, and a complete overview requires
   * a color science textbook, such as Fairchild's Color Appearance Models.
   */
  constructor(t, e, i, r, n, a, o, l, d, u) {
    this.n = t, this.aw = e, this.nbb = i, this.ncb = r, this.c = n, this.nc = a, this.rgbD = o, this.fl = l, this.fLRoot = d, this.z = u;
  }
}, h(nl, "wh"), nl);
c(VL, "ViewingConditions");
let Fn = VL;
Fn.DEFAULT = Fn.make();
var rr;
const WL = (rr = class {
  /**
   * All of the CAM16 dimensions can be calculated from 3 of the dimensions, in
   * the following combinations:
   *      -  {j or q} and {c, m, or s} and hue
   *      - jstar, astar, bstar
   * Prefer using a static method that constructs from 3 of those dimensions.
   * This constructor is intended for those methods to use to return all
   * possible dimensions.
   *
   * @param hue
   * @param chroma informally, colorfulness / color intensity. like saturation
   *     in HSL, except perceptually accurate.
   * @param j lightness
   * @param q brightness; ratio of lightness to white point's lightness
   * @param m colorfulness
   * @param s saturation; ratio of chroma to white point's chroma
   * @param jstar CAM16-UCS J coordinate
   * @param astar CAM16-UCS a coordinate
   * @param bstar CAM16-UCS b coordinate
   */
  constructor(t, e, i, r, n, a, o, l, d) {
    this.hue = t, this.chroma = e, this.j = i, this.q = r, this.m = n, this.s = a, this.jstar = o, this.astar = l, this.bstar = d;
  }
  /**
   * CAM16 instances also have coordinates in the CAM16-UCS space, called J*,
   * a*, b*, or jstar, astar, bstar in code. CAM16-UCS is included in the CAM16
   * specification, and is used to measure distances between colors.
   */
  distance(t) {
    const e = this.jstar - t.jstar, i = this.astar - t.astar, r = this.bstar - t.bstar, n = Math.sqrt(e * e + i * i + r * r);
    return 1.41 * Math.pow(n, 0.63);
  }
  /**
   * @param argb ARGB representation of a color.
   * @return CAM16 color, assuming the color was viewed in default viewing
   *     conditions.
   */
  static fromInt(t) {
    return rr.fromIntInViewingConditions(t, Fn.DEFAULT);
  }
  /**
   * @param argb ARGB representation of a color.
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   * @return CAM16 color.
   */
  static fromIntInViewingConditions(t, e) {
    const i = (t & 16711680) >> 16, r = (t & 65280) >> 8, n = t & 255, a = ds(i), o = ds(r), l = ds(n), d = 0.41233895 * a + 0.35762064 * o + 0.18051042 * l, u = 0.2126 * a + 0.7152 * o + 0.0722 * l, p = 0.01932141 * a + 0.11916382 * o + 0.95034478 * l, f = 0.401288 * d + 0.650173 * u - 0.051461 * p, y = -0.250268 * d + 1.204414 * u + 0.045854 * p, g = -2079e-6 * d + 0.048952 * u + 0.953127 * p, O = e.rgbD[0] * f, k = e.rgbD[1] * y, $ = e.rgbD[2] * g, T = Math.pow(e.fl * Math.abs(O) / 100, 0.42), _ = Math.pow(e.fl * Math.abs(k) / 100, 0.42), D = Math.pow(e.fl * Math.abs($) / 100, 0.42), A = xi(O) * 400 * T / (T + 27.13), z = xi(k) * 400 * _ / (_ + 27.13), V = xi($) * 400 * D / (D + 27.13), X = (11 * A + -12 * z + V) / 11, tt = (A + z - 2 * V) / 9, vt = (20 * A + 20 * z + 21 * V) / 20, dt = (40 * A + 20 * z + V) / 20, st = Math.atan2(tt, X) * 180 / Math.PI, Pt = Qi(st), ct = Pt * Math.PI / 180, Vt = dt * e.nbb, _t = 100 * Math.pow(Vt / e.aw, e.c * e.z), Zt = 4 / e.c * Math.sqrt(_t / 100) * (e.aw + 4) * e.fLRoot, Nt = Pt < 20.14 ? Pt + 360 : Pt, Xt = 0.25 * (Math.cos(Nt * Math.PI / 180 + 2) + 3.8), Li = 5e4 / 13 * Xt * e.nc * e.ncb * Math.sqrt(X * X + tt * tt) / (vt + 0.305), qe = Math.pow(Li, 0.9) * Math.pow(1.64 - Math.pow(0.29, e.n), 0.73), fe = qe * Math.sqrt(_t / 100), oe = fe * e.fLRoot, be = 50 * Math.sqrt(qe * e.c / (e.aw + 4)), zi = (1 + 100 * 7e-3) * _t / (1 + 7e-3 * _t), Yi = 1 / 0.0228 * Math.log(1 + 0.0228 * oe), pr = Yi * Math.cos(ct), ee = Yi * Math.sin(ct);
    return new rr(Pt, fe, _t, Zt, oe, be, zi, pr, ee);
  }
  /**
   * @param j CAM16 lightness
   * @param c CAM16 chroma
   * @param h CAM16 hue
   */
  static fromJch(t, e, i) {
    return rr.fromJchInViewingConditions(t, e, i, Fn.DEFAULT);
  }
  /**
   * @param j CAM16 lightness
   * @param c CAM16 chroma
   * @param h CAM16 hue
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   */
  static fromJchInViewingConditions(t, e, i, r) {
    const n = 4 / r.c * Math.sqrt(t / 100) * (r.aw + 4) * r.fLRoot, a = e * r.fLRoot, o = e / Math.sqrt(t / 100), l = 50 * Math.sqrt(o * r.c / (r.aw + 4)), d = i * Math.PI / 180, u = (1 + 100 * 7e-3) * t / (1 + 7e-3 * t), p = 1 / 0.0228 * Math.log(1 + 0.0228 * a), f = p * Math.cos(d), y = p * Math.sin(d);
    return new rr(i, e, t, n, a, l, u, f, y);
  }
  /**
   * @param jstar CAM16-UCS lightness.
   * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the Y axis.
   * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the X axis.
   */
  static fromUcs(t, e, i) {
    return rr.fromUcsInViewingConditions(t, e, i, Fn.DEFAULT);
  }
  /**
   * @param jstar CAM16-UCS lightness.
   * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the Y axis.
   * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the X axis.
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   */
  static fromUcsInViewingConditions(t, e, i, r) {
    const n = e, a = i, o = Math.sqrt(n * n + a * a), l = (Math.exp(o * 0.0228) - 1) / 0.0228 / r.fLRoot;
    let d = Math.atan2(a, n) * (180 / Math.PI);
    d < 0 && (d += 360);
    const u = t / (1 - (t - 100) * 7e-3);
    return rr.fromJchInViewingConditions(u, l, d, r);
  }
  /**
   *  @return ARGB representation of color, assuming the color was viewed in
   *     default viewing conditions, which are near-identical to the default
   *     viewing conditions for sRGB.
   */
  toInt() {
    return this.viewed(Fn.DEFAULT);
  }
  /**
   * @param viewingConditions Information about the environment where the color
   *     will be viewed.
   * @return ARGB representation of color
   */
  viewed(t) {
    const e = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100), i = Math.pow(e / Math.pow(1.64 - Math.pow(0.29, t.n), 0.73), 1 / 0.9), r = this.hue * Math.PI / 180, n = 0.25 * (Math.cos(r + 2) + 3.8), a = t.aw * Math.pow(this.j / 100, 1 / t.c / t.z), o = n * (5e4 / 13) * t.nc * t.ncb, l = a / t.nbb, d = Math.sin(r), u = Math.cos(r), p = 23 * (l + 0.305) * i / (23 * o + 11 * i * u + 108 * i * d), f = p * u, y = p * d, g = (460 * l + 451 * f + 288 * y) / 1403, O = (460 * l - 891 * f - 261 * y) / 1403, k = (460 * l - 220 * f - 6300 * y) / 1403, $ = Math.max(0, 27.13 * Math.abs(g) / (400 - Math.abs(g))), T = xi(g) * (100 / t.fl) * Math.pow($, 1 / 0.42), _ = Math.max(0, 27.13 * Math.abs(O) / (400 - Math.abs(O))), D = xi(O) * (100 / t.fl) * Math.pow(_, 1 / 0.42), A = Math.max(0, 27.13 * Math.abs(k) / (400 - Math.abs(k))), z = xi(k) * (100 / t.fl) * Math.pow(A, 1 / 0.42), V = T / t.rgbD[0], X = D / t.rgbD[1], tt = z / t.rgbD[2], vt = 1.86206786 * V - 1.01125463 * X + 0.14918677 * tt, dt = 0.38752654 * V + 0.62144744 * X - 897398e-8 * tt, st = -0.0158415 * V - 0.03412294 * X + 1.04996444 * tt;
    return EL(vt, dt, st);
  }
  /// Given color expressed in XYZ and viewed in [viewingConditions], convert to
  /// CAM16.
  static fromXyzInViewingConditions(t, e, i, r) {
    const n = 0.401288 * t + 0.650173 * e - 0.051461 * i, a = -0.250268 * t + 1.204414 * e + 0.045854 * i, o = -2079e-6 * t + 0.048952 * e + 0.953127 * i, l = r.rgbD[0] * n, d = r.rgbD[1] * a, u = r.rgbD[2] * o, p = Math.pow(r.fl * Math.abs(l) / 100, 0.42), f = Math.pow(r.fl * Math.abs(d) / 100, 0.42), y = Math.pow(r.fl * Math.abs(u) / 100, 0.42), g = xi(l) * 400 * p / (p + 27.13), O = xi(d) * 400 * f / (f + 27.13), k = xi(u) * 400 * y / (y + 27.13), $ = (11 * g + -12 * O + k) / 11, T = (g + O - 2 * k) / 9, _ = (20 * g + 20 * O + 21 * k) / 20, D = (40 * g + 20 * O + k) / 20, A = Math.atan2(T, $) * 180 / Math.PI, z = A < 0 ? A + 360 : A >= 360 ? A - 360 : A, V = z * Math.PI / 180, X = D * r.nbb, tt = 100 * Math.pow(X / r.aw, r.c * r.z), vt = 4 / r.c * Math.sqrt(tt / 100) * (r.aw + 4) * r.fLRoot, dt = z < 20.14 ? z + 360 : z, st = 1 / 4 * (Math.cos(dt * Math.PI / 180 + 2) + 3.8), Pt = 5e4 / 13 * st * r.nc * r.ncb * Math.sqrt($ * $ + T * T) / (_ + 0.305), ct = Math.pow(Pt, 0.9) * Math.pow(1.64 - Math.pow(0.29, r.n), 0.73), Vt = ct * Math.sqrt(tt / 100), _t = Vt * r.fLRoot, Zt = 50 * Math.sqrt(ct * r.c / (r.aw + 4)), Nt = (1 + 100 * 7e-3) * tt / (1 + 7e-3 * tt), Xt = Math.log(1 + 0.0228 * _t) / 0.0228, Li = Xt * Math.cos(V), qe = Xt * Math.sin(V);
    return new rr(z, Vt, tt, vt, _t, Zt, Nt, Li, qe);
  }
  /// XYZ representation of CAM16 seen in [viewingConditions].
  xyzInViewingConditions(t) {
    const e = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100), i = Math.pow(e / Math.pow(1.64 - Math.pow(0.29, t.n), 0.73), 1 / 0.9), r = this.hue * Math.PI / 180, n = 0.25 * (Math.cos(r + 2) + 3.8), a = t.aw * Math.pow(this.j / 100, 1 / t.c / t.z), o = n * (5e4 / 13) * t.nc * t.ncb, l = a / t.nbb, d = Math.sin(r), u = Math.cos(r), p = 23 * (l + 0.305) * i / (23 * o + 11 * i * u + 108 * i * d), f = p * u, y = p * d, g = (460 * l + 451 * f + 288 * y) / 1403, O = (460 * l - 891 * f - 261 * y) / 1403, k = (460 * l - 220 * f - 6300 * y) / 1403, $ = Math.max(0, 27.13 * Math.abs(g) / (400 - Math.abs(g))), T = xi(g) * (100 / t.fl) * Math.pow($, 1 / 0.42), _ = Math.max(0, 27.13 * Math.abs(O) / (400 - Math.abs(O))), D = xi(O) * (100 / t.fl) * Math.pow(_, 1 / 0.42), A = Math.max(0, 27.13 * Math.abs(k) / (400 - Math.abs(k))), z = xi(k) * (100 / t.fl) * Math.pow(A, 1 / 0.42), V = T / t.rgbD[0], X = D / t.rgbD[1], tt = z / t.rgbD[2], vt = 1.86206786 * V - 1.01125463 * X + 0.14918677 * tt, dt = 0.38752654 * V + 0.62144744 * X - 897398e-8 * tt, st = -0.0158415 * V - 0.03412294 * X + 1.04996444 * tt;
    return [vt, dt, st];
  }
}, h(rr, "ki"), rr);
c(WL, "Cam16");
let Wg = WL;
var Qt;
const FL = (Qt = class {
  /**
   * Sanitizes a small enough angle in radians.
   *
   * @param angle An angle in radians; must not deviate too much
   * from 0.
   * @return A coterminal angle between 0 and 2pi.
   */
  static sanitizeRadians(t) {
    return (t + Math.PI * 8) % (Math.PI * 2);
  }
  /**
   * Delinearizes an RGB component, returning a floating-point
   * number.
   *
   * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents
   * linear R/G/B channel
   * @return 0.0 <= output <= 255.0, color channel converted to
   * regular RGB space
   */
  static trueDelinearized(t) {
    const e = t / 100;
    let i = 0;
    return e <= 31308e-7 ? i = e * 12.92 : i = 1.055 * Math.pow(e, 1 / 2.4) - 0.055, i * 255;
  }
  static chromaticAdaptation(t) {
    const e = Math.pow(Math.abs(t), 0.42);
    return xi(t) * 400 * e / (e + 27.13);
  }
  /**
   * Returns the hue of a linear RGB color in CAM16.
   *
   * @param linrgb The linear RGB coordinates of a color.
   * @return The hue of the color in CAM16, in radians.
   */
  static hueOf(t) {
    const e = p0(t, Qt.SCALED_DISCOUNT_FROM_LINRGB), i = Qt.chromaticAdaptation(e[0]), r = Qt.chromaticAdaptation(e[1]), n = Qt.chromaticAdaptation(e[2]), a = (11 * i + -12 * r + n) / 11, o = (i + r - 2 * n) / 9;
    return Math.atan2(o, a);
  }
  static areInCyclicOrder(t, e, i) {
    const r = Qt.sanitizeRadians(e - t), n = Qt.sanitizeRadians(i - t);
    return r < n;
  }
  /**
   * Solves the lerp equation.
   *
   * @param source The starting number.
   * @param mid The number in the middle.
   * @param target The ending number.
   * @return A number t such that lerp(source, target, t) = mid.
   */
  static intercept(t, e, i) {
    return (e - t) / (i - t);
  }
  static lerpPoint(t, e, i) {
    return [
      t[0] + (i[0] - t[0]) * e,
      t[1] + (i[1] - t[1]) * e,
      t[2] + (i[2] - t[2]) * e
    ];
  }
  /**
   * Intersects a segment with a plane.
   *
   * @param source The coordinates of point A.
   * @param coordinate The R-, G-, or B-coordinate of the plane.
   * @param target The coordinates of point B.
   * @param axis The axis the plane is perpendicular with. (0: R, 1:
   * G, 2: B)
   * @return The intersection point of the segment AB with the plane
   * R=coordinate, G=coordinate, or B=coordinate
   */
  static setCoordinate(t, e, i, r) {
    const n = Qt.intercept(t[r], e, i[r]);
    return Qt.lerpPoint(t, n, i);
  }
  static isBounded(t) {
    return 0 <= t && t <= 100;
  }
  /**
   * Returns the nth possible vertex of the polygonal intersection.
   *
   * @param y The Y value of the plane.
   * @param n The zero-based index of the point. 0 <= n <= 11.
   * @return The nth possible vertex of the polygonal intersection
   * of the y plane and the RGB cube, in linear RGB coordinates, if
   * it exists. If this possible vertex lies outside of the cube,
   * [-1.0, -1.0, -1.0] is returned.
   */
  static nthVertex(t, e) {
    const i = Qt.Y_FROM_LINRGB[0], r = Qt.Y_FROM_LINRGB[1], n = Qt.Y_FROM_LINRGB[2], a = e % 4 <= 1 ? 0 : 100, o = e % 2 === 0 ? 0 : 100;
    if (e < 4) {
      const l = a, d = o, u = (t - l * r - d * n) / i;
      return Qt.isBounded(u) ? [u, l, d] : [-1, -1, -1];
    } else if (e < 8) {
      const l = a, d = o, u = (t - d * i - l * n) / r;
      return Qt.isBounded(u) ? [d, u, l] : [-1, -1, -1];
    } else {
      const l = a, d = o, u = (t - l * i - d * r) / n;
      return Qt.isBounded(u) ? [l, d, u] : [-1, -1, -1];
    }
  }
  /**
   * Finds the segment containing the desired color.
   *
   * @param y The Y value of the color.
   * @param targetHue The hue of the color.
   * @return A list of two sets of linear RGB coordinates, each
   * corresponding to an endpoint of the segment containing the
   * desired color.
   */
  static bisectToSegment(t, e) {
    let i = [-1, -1, -1], r = i, n = 0, a = 0, o = !1, l = !0;
    for (let d = 0; d < 12; d++) {
      const u = Qt.nthVertex(t, d);
      if (u[0] < 0)
        continue;
      const p = Qt.hueOf(u);
      if (!o) {
        i = u, r = u, n = p, a = p, o = !0;
        continue;
      }
      (l || Qt.areInCyclicOrder(n, p, a)) && (l = !1, Qt.areInCyclicOrder(n, e, p) ? (r = u, a = p) : (i = u, n = p));
    }
    return [i, r];
  }
  static midpoint(t, e) {
    return [
      (t[0] + e[0]) / 2,
      (t[1] + e[1]) / 2,
      (t[2] + e[2]) / 2
    ];
  }
  static criticalPlaneBelow(t) {
    return Math.floor(t - 0.5);
  }
  static criticalPlaneAbove(t) {
    return Math.ceil(t - 0.5);
  }
  /**
   * Finds a color with the given Y and hue on the boundary of the
   * cube.
   *
   * @param y The Y value of the color.
   * @param targetHue The hue of the color.
   * @return The desired color, in linear RGB coordinates.
   */
  static bisectToLimit(t, e) {
    const i = Qt.bisectToSegment(t, e);
    let r = i[0], n = Qt.hueOf(r), a = i[1];
    for (let o = 0; o < 3; o++)
      if (r[o] !== a[o]) {
        let l = -1, d = 255;
        r[o] < a[o] ? (l = Qt.criticalPlaneBelow(Qt.trueDelinearized(r[o])), d = Qt.criticalPlaneAbove(Qt.trueDelinearized(a[o]))) : (l = Qt.criticalPlaneAbove(Qt.trueDelinearized(r[o])), d = Qt.criticalPlaneBelow(Qt.trueDelinearized(a[o])));
        for (let u = 0; u < 8 && !(Math.abs(d - l) <= 1); u++) {
          const p = Math.floor((l + d) / 2), f = Qt.CRITICAL_PLANES[p], y = Qt.setCoordinate(r, f, a, o), g = Qt.hueOf(y);
          Qt.areInCyclicOrder(n, e, g) ? (a = y, d = p) : (r = y, n = g, l = p);
        }
      }
    return Qt.midpoint(r, a);
  }
  static inverseChromaticAdaptation(t) {
    const e = Math.abs(t), i = Math.max(0, 27.13 * e / (400 - e));
    return xi(t) * Math.pow(i, 1 / 0.42);
  }
  /**
   * Finds a color with the given hue, chroma, and Y.
   *
   * @param hueRadians The desired hue in radians.
   * @param chroma The desired chroma.
   * @param y The desired Y.
   * @return The desired color as a hexadecimal integer, if found; 0
   * otherwise.
   */
  static findResultByJ(t, e, i) {
    let r = Math.sqrt(i) * 11;
    const n = Fn.DEFAULT, a = 1 / Math.pow(1.64 - Math.pow(0.29, n.n), 0.73), o = 0.25 * (Math.cos(t + 2) + 3.8) * (5e4 / 13) * n.nc * n.ncb, l = Math.sin(t), d = Math.cos(t);
    for (let u = 0; u < 5; u++) {
      const p = r / 100, f = e === 0 || r === 0 ? 0 : e / Math.sqrt(p), y = Math.pow(f * a, 1 / 0.9), g = n.aw * Math.pow(p, 1 / n.c / n.z) / n.nbb, O = 23 * (g + 0.305) * y / (23 * o + 11 * y * d + 108 * y * l), k = O * d, $ = O * l, T = (460 * g + 451 * k + 288 * $) / 1403, _ = (460 * g - 891 * k - 261 * $) / 1403, D = (460 * g - 220 * k - 6300 * $) / 1403, A = Qt.inverseChromaticAdaptation(T), z = Qt.inverseChromaticAdaptation(_), V = Qt.inverseChromaticAdaptation(D), X = p0([A, z, V], Qt.LINRGB_FROM_SCALED_DISCOUNT);
      if (X[0] < 0 || X[1] < 0 || X[2] < 0)
        return 0;
      const tt = Qt.Y_FROM_LINRGB[0], vt = Qt.Y_FROM_LINRGB[1], dt = Qt.Y_FROM_LINRGB[2], st = tt * X[0] + vt * X[1] + dt * X[2];
      if (st <= 0)
        return 0;
      if (u === 4 || Math.abs(st - i) < 2e-3)
        return X[0] > 100.01 || X[1] > 100.01 || X[2] > 100.01 ? 0 : vS(X);
      r = r - (st - i) * r / (2 * st);
    }
    return 0;
  }
  /**
   * Finds an sRGB color with the given hue, chroma, and L*, if
   * possible.
   *
   * @param hueDegrees The desired hue, in degrees.
   * @param chroma The desired chroma.
   * @param lstar The desired L*.
   * @return A hexadecimal representing the sRGB color. The color
   * has sufficiently close hue, chroma, and L* to the desired
   * values, if possible; otherwise, the hue and L* will be
   * sufficiently close, and chroma will be maximized.
   */
  static solveToInt(t, e, i) {
    if (e < 1e-4 || i < 1e-4 || i > 99.9999)
      return zL(i);
    t = Qi(t);
    const r = t / 180 * Math.PI, n = Ns(i), a = Qt.findResultByJ(r, e, n);
    if (a !== 0)
      return a;
    const o = Qt.bisectToLimit(n, r);
    return vS(o);
  }
  /**
   * Finds an sRGB color with the given hue, chroma, and L*, if
   * possible.
   *
   * @param hueDegrees The desired hue, in degrees.
   * @param chroma The desired chroma.
   * @param lstar The desired L*.
   * @return An CAM16 object representing the sRGB color. The color
   * has sufficiently close hue, chroma, and L* to the desired
   * values, if possible; otherwise, the hue and L* will be
   * sufficiently close, and chroma will be maximized.
   */
  static solveToCam(t, e, i) {
    return Wg.fromInt(Qt.solveToInt(t, e, i));
  }
}, h(Qt, "wt"), Qt);
c(FL, "HctSolver");
let qn = FL;
qn.SCALED_DISCOUNT_FROM_LINRGB = [
  [
    0.001200833568784504,
    0.002389694492170889,
    2795742885861124e-19
  ],
  [
    5891086651375999e-19,
    0.0029785502573438758,
    3270666104008398e-19
  ],
  [
    10146692491640572e-20,
    5364214359186694e-19,
    0.0032979401770712076
  ]
];
qn.LINRGB_FROM_SCALED_DISCOUNT = [
  [
    1373.2198709594231,
    -1100.4251190754821,
    -7.278681089101213
  ],
  [
    -271.815969077903,
    559.6580465940733,
    -32.46047482791194
  ],
  [
    1.9622899599665666,
    -57.173814538844006,
    308.7233197812385
  ]
];
qn.Y_FROM_LINRGB = [0.2126, 0.7152, 0.0722];
qn.CRITICAL_PLANES = [
  0.015176349177441876,
  0.045529047532325624,
  0.07588174588720938,
  0.10623444424209313,
  0.13658714259697685,
  0.16693984095186062,
  0.19729253930674434,
  0.2276452376616281,
  0.2579979360165119,
  0.28835063437139563,
  0.3188300904430532,
  0.350925934958123,
  0.3848314933096426,
  0.42057480301049466,
  0.458183274052838,
  0.4976837250274023,
  0.5391024159806381,
  0.5824650784040898,
  0.6277969426914107,
  0.6751227633498623,
  0.7244668422128921,
  0.775853049866786,
  0.829304845476233,
  0.8848452951698498,
  0.942497089126609,
  1.0022825574869039,
  1.0642236851973577,
  1.1283421258858297,
  1.1946592148522128,
  1.2631959812511864,
  1.3339731595349034,
  1.407011200216447,
  1.4823302800086415,
  1.5599503113873272,
  1.6398909516233677,
  1.7221716113234105,
  1.8068114625156377,
  1.8938294463134073,
  1.9832442801866852,
  2.075074464868551,
  2.1693382909216234,
  2.2660538449872063,
  2.36523901573795,
  2.4669114995532007,
  2.5710888059345764,
  2.6777882626779785,
  2.7870270208169257,
  2.898822059350997,
  3.0131901897720907,
  3.1301480604002863,
  3.2497121605402226,
  3.3718988244681087,
  3.4967242352587946,
  3.624204428461639,
  3.754355295633311,
  3.887192587735158,
  4.022731918402185,
  4.160988767090289,
  4.301978482107941,
  4.445716283538092,
  4.592217266055746,
  4.741496401646282,
  4.893568542229298,
  5.048448422192488,
  5.20615066083972,
  5.3666897647573375,
  5.5300801301023865,
  5.696336044816294,
  5.865471690767354,
  6.037501145825082,
  6.212438385869475,
  6.390297286737924,
  6.571091626112461,
  6.7548350853498045,
  6.941541251256611,
  7.131223617812143,
  7.323895587840543,
  7.5195704746346665,
  7.7182615035334345,
  7.919981813454504,
  8.124744458384042,
  8.332562408825165,
  8.543448553206703,
  8.757415699253682,
  8.974476575321063,
  9.194643831691977,
  9.417930041841839,
  9.644347703669503,
  9.873909240696694,
  10.106627003236781,
  10.342513269534024,
  10.58158024687427,
  10.8238400726681,
  11.069304815507364,
  11.317986476196008,
  11.569896988756009,
  11.825048221409341,
  12.083451977536606,
  12.345119996613247,
  12.610063955123938,
  12.878295467455942,
  13.149826086772048,
  13.42466730586372,
  13.702830557985108,
  13.984327217668513,
  14.269168601521828,
  14.55736596900856,
  14.848930523210871,
  15.143873411576273,
  15.44220572664832,
  15.743938506781891,
  16.04908273684337,
  16.35764934889634,
  16.66964922287304,
  16.985093187232053,
  17.30399201960269,
  17.62635644741625,
  17.95219714852476,
  18.281524751807332,
  18.614349837764564,
  18.95068293910138,
  19.290534541298456,
  19.633915083172692,
  19.98083495742689,
  20.331304511189067,
  20.685334046541502,
  21.042933821039977,
  21.404114048223256,
  21.76888489811322,
  22.137256497705877,
  22.50923893145328,
  22.884842241736916,
  23.264076429332462,
  23.6469514538663,
  24.033477234264016,
  24.42366364919083,
  24.817520537484558,
  25.21505769858089,
  25.61628489293138,
  26.021211842414342,
  26.429848230738664,
  26.842203703840827,
  27.258287870275353,
  27.678110301598522,
  28.10168053274597,
  28.529008062403893,
  28.96010235337422,
  29.39497283293396,
  29.83362889318845,
  30.276079891419332,
  30.722335150426627,
  31.172403958865512,
  31.62629557157785,
  32.08401920991837,
  32.54558406207592,
  33.010999283389665,
  33.4802739966603,
  33.953417292456834,
  34.430438229418264,
  34.911345834551085,
  35.39614910352207,
  35.88485700094671,
  36.37747846067349,
  36.87402238606382,
  37.37449765026789,
  37.87891309649659,
  38.38727753828926,
  38.89959975977785,
  39.41588851594697,
  39.93615253289054,
  40.460400508064545,
  40.98864111053629,
  41.520882981230194,
  42.05713473317016,
  42.597404951718396,
  43.141702194811224,
  43.6900349931913,
  44.24241185063697,
  44.798841244188324,
  45.35933162437017,
  45.92389141541209,
  46.49252901546552,
  47.065252796817916,
  47.64207110610409,
  48.22299226451468,
  48.808024568002054,
  49.3971762874833,
  49.9904556690408,
  50.587870934119984,
  51.189430279724725,
  51.79514187861014,
  52.40501387947288,
  53.0190544071392,
  53.637271562750364,
  54.259673423945976,
  54.88626804504493,
  55.517063457223934,
  56.15206766869424,
  56.79128866487574,
  57.43473440856916,
  58.08241284012621,
  58.734331877617365,
  59.39049941699807,
  60.05092333227251,
  60.715611475655585,
  61.38457167773311,
  62.057811747619894,
  62.7353394731159,
  63.417162620860914,
  64.10328893648692,
  64.79372614476921,
  65.48848194977529,
  66.18756403501224,
  66.89098006357258,
  67.59873767827808,
  68.31084450182222,
  69.02730813691093,
  69.74813616640164,
  70.47333615344107,
  71.20291564160104,
  71.93688215501312,
  72.67524319850172,
  73.41800625771542,
  74.16517879925733,
  74.9167682708136,
  75.67278210128072,
  76.43322770089146,
  77.1981124613393,
  77.96744375590167,
  78.74122893956174,
  79.51947534912904,
  80.30219030335869,
  81.08938110306934,
  81.88105503125999,
  82.67721935322541,
  83.4778813166706,
  84.28304815182372,
  85.09272707154808,
  85.90692527145302,
  86.72564993000343,
  87.54890820862819,
  88.3767072518277,
  89.2090541872801,
  90.04595612594655,
  90.88742016217518,
  91.73345337380438,
  92.58406282226491,
  93.43925555268066,
  94.29903859396902,
  95.16341895893969,
  96.03240364439274,
  96.9059996312159,
  97.78421388448044,
  98.6670533535366,
  99.55452497210776
];
var Gs;
const qL = (Gs = class {
  static from(t, e, i) {
    return new Gs(qn.solveToInt(t, e, i));
  }
  /**
   * @param argb ARGB representation of a color.
   * @return HCT representation of a color in default viewing conditions
   */
  static fromInt(t) {
    return new Gs(t);
  }
  toInt() {
    return this.argb;
  }
  /**
   * A number, in degrees, representing ex. red, orange, yellow, etc.
   * Ranges from 0 <= hue < 360.
   */
  get hue() {
    return this.internalHue;
  }
  /**
   * @param newHue 0 <= newHue < 360; invalid values are corrected.
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set hue(t) {
    this.setInternalState(qn.solveToInt(t, this.internalChroma, this.internalTone));
  }
  get chroma() {
    return this.internalChroma;
  }
  /**
   * @param newChroma 0 <= newChroma < ?
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set chroma(t) {
    this.setInternalState(qn.solveToInt(this.internalHue, t, this.internalTone));
  }
  /** Lightness. Ranges from 0 to 100. */
  get tone() {
    return this.internalTone;
  }
  /**
   * @param newTone 0 <= newTone <= 100; invalid valids are corrected.
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set tone(t) {
    this.setInternalState(qn.solveToInt(this.internalHue, this.internalChroma, t));
  }
  /** Sets a property of the Hct object. */
  setValue(t, e) {
    this[t] = e;
  }
  toString() {
    return `HCT(${this.hue.toFixed(0)}, ${this.chroma.toFixed(0)}, ${this.tone.toFixed(0)})`;
  }
  static isBlue(t) {
    return t >= 250 && t < 270;
  }
  static isYellow(t) {
    return t >= 105 && t < 125;
  }
  static isCyan(t) {
    return t >= 170 && t < 207;
  }
  constructor(t) {
    this.argb = t;
    const e = Wg.fromInt(t);
    this.internalHue = e.hue, this.internalChroma = e.chroma, this.internalTone = OS(t), this.argb = t;
  }
  setInternalState(t) {
    const e = Wg.fromInt(t);
    this.internalHue = e.hue, this.internalChroma = e.chroma, this.internalTone = OS(t), this.argb = t;
  }
  /**
   * Translates a color into different [ViewingConditions].
   *
   * Colors change appearance. They look different with lights on versus off,
   * the same color, as in hex code, on white looks different when on black.
   * This is called color relativity, most famously explicated by Josef Albers
   * in Interaction of Color.
   *
   * In color science, color appearance models can account for this and
   * calculate the appearance of a color in different settings. HCT is based on
   * CAM16, a color appearance model, and uses it to make these calculations.
   *
   * See [ViewingConditions.make] for parameters affecting color appearance.
   */
  inViewingConditions(t) {
    const e = Wg.fromInt(this.toInt()).xyzInViewingConditions(t), i = Wg.fromXyzInViewingConditions(e[0], e[1], e[2], Fn.make());
    return Gs.from(i.hue, i.chroma, f0(e[1]));
  }
}, h(Gs, "Ca"), Gs);
c(qL, "Hct");
let Lt = qL;
var Er;
const ZL = (Er = class {
  /**
   * Returns a contrast ratio, which ranges from 1 to 21.
   *
   * @param toneA Tone between 0 and 100. Values outside will be clamped.
   * @param toneB Tone between 0 and 100. Values outside will be clamped.
   */
  static ratioOfTones(t, e) {
    return t = Ke(0, 100, t), e = Ke(0, 100, e), Er.ratioOfYs(Ns(t), Ns(e));
  }
  static ratioOfYs(t, e) {
    const i = t > e ? t : e, r = i === e ? t : e;
    return (i + 5) / (r + 5);
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns -1 if ratio cannot be achieved with tone parameter.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in -1 being returned.
   * @param ratio Contrast ratio of return value and tone.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static lighter(t, e) {
    if (t < 0 || t > 100)
      return -1;
    const i = Ns(t), r = e * (i + 5) - 5, n = Er.ratioOfYs(r, i), a = Math.abs(n - e);
    if (n < e && a > 0.04)
      return -1;
    const o = f0(r) + 0.4;
    return o < 0 || o > 100 ? -1 : o;
  }
  /**
   * Returns a tone <= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns -1 if ratio cannot be achieved with tone parameter.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in -1 being returned.
   * @param ratio Contrast ratio of return value and tone.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static darker(t, e) {
    if (t < 0 || t > 100)
      return -1;
    const i = Ns(t), r = (i + 5) / e - 5, n = Er.ratioOfYs(i, r), a = Math.abs(n - e);
    if (n < e && a > 0.04)
      return -1;
    const o = f0(r) - 0.4;
    return o < 0 || o > 100 ? -1 : o;
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns 100 if ratio cannot be achieved with tone parameter.
   *
   * This method is unsafe because the returned value is guaranteed to be in
   * bounds for tone, i.e. between 0 and 100. However, that value may not reach
   * the ratio with tone. For example, there is no color lighter than T100.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in 100 being returned.
   * @param ratio Desired contrast ratio of return value and tone parameter.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static lighterUnsafe(t, e) {
    const i = Er.lighter(t, e);
    return i < 0 ? 100 : i;
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns 100 if ratio cannot be achieved with tone parameter.
   *
   * This method is unsafe because the returned value is guaranteed to be in
   * bounds for tone, i.e. between 0 and 100. However, that value may not reach
   * the [ratio with [tone]. For example, there is no color darker than T0.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in 0 being returned.
   * @param ratio Desired contrast ratio of return value and tone parameter.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static darkerUnsafe(t, e) {
    const i = Er.darker(t, e);
    return i < 0 ? 0 : i;
  }
}, h(Er, "xr"), Er);
c(ZL, "Contrast");
let Je = ZL;
var al;
const BL = (al = class {
  /**
   * Returns true if a color is disliked.
   *
   * @param hct A color to be judged.
   * @return Whether the color is disliked.
   *
   * Disliked is defined as a dark yellow-green that is not neutral.
   */
  static isDisliked(t) {
    const e = Math.round(t.hue) >= 90 && Math.round(t.hue) <= 111, i = Math.round(t.chroma) > 16, r = Math.round(t.tone) < 65;
    return e && i && r;
  }
  /**
   * If a color is disliked, lighten it to make it likable.
   *
   * @param hct A color to be judged.
   * @return A new color if the original color is disliked, or the original
   *   color if it is acceptable.
   */
  static fixIfDisliked(t) {
    return al.isDisliked(t) ? Lt.from(t.hue, t.chroma, 70) : t;
  }
}, h(al, "fh"), al);
c(BL, "DislikeAnalyzer");
let bS = BL;
function NL(s, t, e) {
  if (s.name !== e.name)
    throw new Error(`Attempting to extend color ${s.name} with color ${e.name} of different name for spec version ${t}.`);
  if (s.isBackground !== e.isBackground)
    throw new Error(`Attempting to extend color ${s.name} as a ${s.isBackground ? "background" : "foreground"} with color ${e.name} as a ${e.isBackground ? "background" : "foreground"} for spec version ${t}.`);
}
h(NL, "qg");
c(NL, "validateExtendedColor");
function Tt(s, t, e) {
  return NL(s, t, e), F.fromPalette({
    name: s.name,
    palette: /* @__PURE__ */ c((i) => i.specVersion === t ? e.palette(i) : s.palette(i), "palette"),
    tone: /* @__PURE__ */ c((i) => i.specVersion === t ? e.tone(i) : s.tone(i), "tone"),
    isBackground: s.isBackground,
    chromaMultiplier: /* @__PURE__ */ c((i) => {
      const r = i.specVersion === t ? e.chromaMultiplier : s.chromaMultiplier;
      return r !== void 0 ? r(i) : 1;
    }, "chromaMultiplier"),
    background: /* @__PURE__ */ c((i) => {
      const r = i.specVersion === t ? e.background : s.background;
      return r !== void 0 ? r(i) : void 0;
    }, "background"),
    secondBackground: /* @__PURE__ */ c((i) => {
      const r = i.specVersion === t ? e.secondBackground : s.secondBackground;
      return r !== void 0 ? r(i) : void 0;
    }, "secondBackground"),
    contrastCurve: /* @__PURE__ */ c((i) => {
      const r = i.specVersion === t ? e.contrastCurve : s.contrastCurve;
      return r !== void 0 ? r(i) : void 0;
    }, "contrastCurve"),
    toneDeltaPair: /* @__PURE__ */ c((i) => {
      const r = i.specVersion === t ? e.toneDeltaPair : s.toneDeltaPair;
      return r !== void 0 ? r(i) : void 0;
    }, "toneDeltaPair")
  });
}
h(Tt, "ut");
c(Tt, "extendSpecVersion");
var fr;
const XL = (fr = class {
  /**
   * Create a DynamicColor defined by a TonalPalette and HCT tone.
   *
   * @param args Functions with DynamicScheme as input. Must provide a palette
   *     and tone. May provide a background DynamicColor and ToneDeltaPair.
   */
  static fromPalette(t) {
    return new fr(t.name ?? "", t.palette, t.tone ?? fr.getInitialToneFromBackground(t.background), t.isBackground ?? !1, t.chromaMultiplier, t.background, t.secondBackground, t.contrastCurve, t.toneDeltaPair);
  }
  static getInitialToneFromBackground(t) {
    return t === void 0 ? (e) => 50 : (e) => t(e) ? t(e).getTone(e) : 50;
  }
  /**
   * The base constructor for DynamicColor.
   *
   * _Strongly_ prefer using one of the convenience constructors. This class is
   * arguably too flexible to ensure it can support any scenario. Functional
   * arguments allow  overriding without risks that come with subclasses.
   *
   * For example, the default behavior of adjust tone at max contrast
   * to be at a 7.0 ratio with its background is principled and
   * matches accessibility guidance. That does not mean it's the desired
   * approach for _every_ design system, and every color pairing,
   * always, in every case.
   *
   * @param name The name of the dynamic color. Defaults to empty.
   * @param palette Function that provides a TonalPalette given DynamicScheme. A
   *     TonalPalette is defined by a hue and chroma, so this replaces the need
   *     to specify hue/chroma. By providing a tonal palette, when contrast
   *     adjustments are made, intended chroma can be preserved.
   * @param tone Function that provides a tone, given a DynamicScheme.
   * @param isBackground Whether this dynamic color is a background, with some
   *     other color as the foreground. Defaults to false.
   * @param chromaMultiplier A factor that multiplies the chroma for this color.
   * @param background The background of the dynamic color (as a function of a
   *     `DynamicScheme`), if it exists.
   * @param secondBackground A second background of the dynamic color (as a
   *     function of a `DynamicScheme`), if it exists.
   * @param contrastCurve A `ContrastCurve` object specifying how its contrast
   *     against its background should behave in various contrast levels
   *     options.
   * @param toneDeltaPair A `ToneDeltaPair` object specifying a tone delta
   *     constraint between two colors. One of them must be the color being
   *     constructed.
   */
  constructor(t, e, i, r, n, a, o, l, d) {
    if (this.name = t, this.palette = e, this.tone = i, this.isBackground = r, this.chromaMultiplier = n, this.background = a, this.secondBackground = o, this.contrastCurve = l, this.toneDeltaPair = d, this.hctCache = /* @__PURE__ */ new Map(), !a && o)
      throw new Error(`Color ${t} has secondBackgrounddefined, but background is not defined.`);
    if (!a && l)
      throw new Error(`Color ${t} has contrastCurvedefined, but background is not defined.`);
    if (a && !l)
      throw new Error(`Color ${t} has backgrounddefined, but contrastCurve is not defined.`);
  }
  /**
   * Returns a deep copy of this DynamicColor.
   */
  clone() {
    return fr.fromPalette({
      name: this.name,
      palette: this.palette,
      tone: this.tone,
      isBackground: this.isBackground,
      chromaMultiplier: this.chromaMultiplier,
      background: this.background,
      secondBackground: this.secondBackground,
      contrastCurve: this.contrastCurve,
      toneDeltaPair: this.toneDeltaPair
    });
  }
  /**
   * Clears the cache of HCT values for this color. For testing or debugging
   * purposes.
   */
  clearCache() {
    this.hctCache.clear();
  }
  /**
   * Returns a ARGB integer (i.e. a hex code).
   *
   * @param scheme Defines the conditions of the user interface, for example,
   *     whether or not it is dark mode or light mode, and what the desired
   *     contrast level is.
   */
  getArgb(t) {
    return this.getHct(t).toInt();
  }
  /**
   * Returns a color, expressed in the HCT color space, that this
   * DynamicColor is under the conditions in scheme.
   *
   * @param scheme Defines the conditions of the user interface, for example,
   *     whether or not it is dark mode or light mode, and what the desired
   *     contrast level is.
   */
  getHct(t) {
    const e = this.hctCache.get(t);
    if (e != null)
      return e;
    const i = $S(t.specVersion).getHct(t, this);
    return this.hctCache.size > 4 && this.hctCache.clear(), this.hctCache.set(t, i), i;
  }
  /**
   * Returns a tone, T in the HCT color space, that this DynamicColor is under
   * the conditions in scheme.
   *
   * @param scheme Defines the conditions of the user interface, for example,
   *     whether or not it is dark mode or light mode, and what the desired
   *     contrast level is.
   */
  getTone(t) {
    return $S(t.specVersion).getTone(t, this);
  }
  /**
   * Given a background tone, finds a foreground tone, while ensuring they reach
   * a contrast ratio that is as close to [ratio] as possible.
   *
   * @param bgTone Tone in HCT. Range is 0 to 100, undefined behavior when it
   *     falls outside that range.
   * @param ratio The contrast ratio desired between bgTone and the return
   *     value.
   */
  static foregroundTone(t, e) {
    const i = Je.lighterUnsafe(t, e), r = Je.darkerUnsafe(t, e), n = Je.ratioOfTones(i, t), a = Je.ratioOfTones(r, t);
    if (fr.tonePrefersLightForeground(t)) {
      const o = Math.abs(n - a) < 0.1 && n < e && a < e;
      return n >= e || n >= a || o ? i : r;
    } else
      return a >= e || a >= n ? r : i;
  }
  /**
   * Returns whether [tone] prefers a light foreground.
   *
   * People prefer white foregrounds on ~T60-70. Observed over time, and also
   * by Andrew Somers during research for APCA.
   *
   * T60 used as to create the smallest discontinuity possible when skipping
   * down to T49 in order to ensure light foregrounds.
   * Since `tertiaryContainer` in dark monochrome scheme requires a tone of
   * 60, it should not be adjusted. Therefore, 60 is excluded here.
   */
  static tonePrefersLightForeground(t) {
    return Math.round(t) < 60;
  }
  /**
   * Returns whether [tone] can reach a contrast ratio of 4.5 with a lighter
   * color.
   */
  static toneAllowsLightForeground(t) {
    return Math.round(t) <= 49;
  }
  /**
   * Adjusts a tone such that white has 4.5 contrast, if the tone is
   * reasonably close to supporting it.
   */
  static enableLightForeground(t) {
    return fr.tonePrefersLightForeground(t) && !fr.toneAllowsLightForeground(t) ? 49 : t;
  }
}, h(fr, "qi"), fr);
c(XL, "DynamicColor");
let F = XL;
var Op;
const jL = (Op = class {
  getHct(t, e) {
    const i = e.getTone(t);
    return e.palette(t).getHct(i);
  }
  getTone(t, e) {
    const i = t.contrastLevel < 0, r = e.toneDeltaPair ? e.toneDeltaPair(t) : void 0;
    if (r) {
      const n = r.roleA, a = r.roleB, o = r.delta, l = r.polarity, d = r.stayTogether, u = l === "nearer" || l === "lighter" && !t.isDark || l === "darker" && t.isDark, p = u ? n : a, f = u ? a : n, y = e.name === p.name, g = t.isDark ? 1 : -1;
      let O = p.tone(t), k = f.tone(t);
      if (e.background && p.contrastCurve && f.contrastCurve) {
        const $ = e.background(t), T = p.contrastCurve(t), _ = f.contrastCurve(t);
        if ($ && T && _) {
          const D = $.getTone(t), A = T.get(t.contrastLevel), z = _.get(t.contrastLevel);
          Je.ratioOfTones(D, O) < A && (O = F.foregroundTone(D, A)), Je.ratioOfTones(D, k) < z && (k = F.foregroundTone(D, z)), i && (O = F.foregroundTone(D, A), k = F.foregroundTone(D, z));
        }
      }
      return (k - O) * g < o && (k = Ke(0, 100, O + o * g), (k - O) * g >= o || (O = Ke(0, 100, k - o * g))), 50 <= O && O < 60 ? g > 0 ? (O = 60, k = Math.max(k, O + o * g)) : (O = 49, k = Math.min(k, O + o * g)) : 50 <= k && k < 60 && (d ? g > 0 ? (O = 60, k = Math.max(k, O + o * g)) : (O = 49, k = Math.min(k, O + o * g)) : g > 0 ? k = 60 : k = 49), y ? O : k;
    } else {
      let n = e.tone(t);
      if (e.background == null || e.background(t) === void 0 || e.contrastCurve == null || e.contrastCurve(t) === void 0)
        return n;
      const a = e.background(t).getTone(t), o = e.contrastCurve(t).get(t.contrastLevel);
      if (Je.ratioOfTones(a, n) >= o || (n = F.foregroundTone(a, o)), i && (n = F.foregroundTone(a, o)), e.isBackground && 50 <= n && n < 60 && (Je.ratioOfTones(49, a) >= o ? n = 49 : n = 60), e.secondBackground == null || e.secondBackground(t) === void 0)
        return n;
      const [l, d] = [e.background, e.secondBackground], [u, p] = [l(t).getTone(t), d(t).getTone(t)], [f, y] = [Math.max(u, p), Math.min(u, p)];
      if (Je.ratioOfTones(f, n) >= o && Je.ratioOfTones(y, n) >= o)
        return n;
      const g = Je.lighter(f, o), O = Je.darker(y, o), k = [];
      return g !== -1 && k.push(g), O !== -1 && k.push(O), F.tonePrefersLightForeground(u) || F.tonePrefersLightForeground(p) ? g < 0 ? 100 : g : k.length === 1 ? k[0] : O < 0 ? 0 : O;
    }
  }
}, h(Op, "Ky"), Op);
c(jL, "ColorCalculationDelegateImpl2021");
let Lj = jL;
var bp;
const UL = (bp = class {
  getHct(t, e) {
    const i = e.palette(t), r = e.getTone(t), n = i.hue, a = i.chroma * (e.chromaMultiplier ? e.chromaMultiplier(t) : 1);
    return Lt.from(n, a, r);
  }
  getTone(t, e) {
    const i = e.toneDeltaPair ? e.toneDeltaPair(t) : void 0;
    if (i) {
      const r = i.roleA, n = i.roleB, a = i.polarity, o = i.constraint, l = a === "darker" || a === "relative_lighter" && t.isDark || a === "relative_darker" && !t.isDark ? -i.delta : i.delta, d = e.name === r.name, u = d ? r : n, p = d ? n : r;
      let f = u.tone(t), y = p.getTone(t);
      const g = l * (d ? 1 : -1);
      if (o === "exact" ? f = Ke(0, 100, y + g) : o === "nearer" ? g > 0 ? f = Ke(0, 100, Ke(y, y + g, f)) : f = Ke(0, 100, Ke(y + g, y, f)) : o === "farther" && (g > 0 ? f = Ke(y + g, 100, f) : f = Ke(0, y + g, f)), e.background && e.contrastCurve) {
        const O = e.background(t), k = e.contrastCurve(t);
        if (O && k) {
          const $ = O.getTone(t), T = k.get(t.contrastLevel);
          f = Je.ratioOfTones($, f) >= T && t.contrastLevel >= 0 ? f : F.foregroundTone($, T);
        }
      }
      return e.isBackground && !e.name.endsWith("_fixed_dim") && (f >= 57 ? f = Ke(65, 100, f) : f = Ke(0, 49, f)), f;
    } else {
      let r = e.tone(t);
      if (e.background == null || e.background(t) === void 0 || e.contrastCurve == null || e.contrastCurve(t) === void 0)
        return r;
      const n = e.background(t).getTone(t), a = e.contrastCurve(t).get(t.contrastLevel);
      if (r = Je.ratioOfTones(n, r) >= a && t.contrastLevel >= 0 ? r : F.foregroundTone(n, a), e.isBackground && !e.name.endsWith("_fixed_dim") && (r >= 57 ? r = Ke(65, 100, r) : r = Ke(0, 49, r)), e.secondBackground == null || e.secondBackground(t) === void 0)
        return r;
      const [o, l] = [e.background, e.secondBackground], [d, u] = [o(t).getTone(t), l(t).getTone(t)], [p, f] = [Math.max(d, u), Math.min(d, u)];
      if (Je.ratioOfTones(p, r) >= a && Je.ratioOfTones(f, r) >= a)
        return r;
      const y = Je.lighter(p, a), g = Je.darker(f, a), O = [];
      return y !== -1 && O.push(y), g !== -1 && O.push(g), F.tonePrefersLightForeground(d) || F.tonePrefersLightForeground(u) ? y < 0 ? 100 : y : O.length === 1 ? O[0] : g < 0 ? 0 : g;
    }
  }
}, h(bp, "Qy"), bp);
c(UL, "ColorCalculationDelegateImpl2025");
let zj = UL;
const Ij = new Lj(), Dj = new zj();
function $S(s) {
  return s === "2025" ? Dj : Ij;
}
h($S, "nf");
c($S, "getSpec$1");
var Ks;
const HL = (Ks = class {
  /**
   * @param argb ARGB representation of a color
   * @return Tones matching that color's hue and chroma.
   */
  static fromInt(t) {
    const e = Lt.fromInt(t);
    return Ks.fromHct(e);
  }
  /**
   * @param hct Hct
   * @return Tones matching that color's hue and chroma.
   */
  static fromHct(t) {
    return new Ks(t.hue, t.chroma, t);
  }
  /**
   * @param hue HCT hue
   * @param chroma HCT chroma
   * @return Tones matching hue and chroma.
   */
  static fromHueAndChroma(t, e) {
    const i = new Vj(t, e).create();
    return new Ks(t, e, i);
  }
  constructor(t, e, i) {
    this.hue = t, this.chroma = e, this.keyColor = i, this.cache = /* @__PURE__ */ new Map();
  }
  /**
   * @param tone HCT tone, measured from 0 to 100.
   * @return ARGB representation of a color with that tone.
   */
  tone(t) {
    let e = this.cache.get(t);
    return e === void 0 && (t == 99 && Lt.isYellow(this.hue) ? e = this.averageArgb(this.tone(98), this.tone(100)) : e = Lt.from(this.hue, this.chroma, t).toInt(), this.cache.set(t, e)), e;
  }
  /**
   * @param tone HCT tone.
   * @return HCT representation of a color with that tone.
   */
  getHct(t) {
    return Lt.fromInt(this.tone(t));
  }
  averageArgb(t, e) {
    const i = t >>> 16 & 255, r = t >>> 8 & 255, n = t & 255, a = e >>> 16 & 255, o = e >>> 8 & 255, l = e & 255, d = Math.round((i + a) / 2), u = Math.round((r + o) / 2), p = Math.round((n + l) / 2);
    return (255 << 24 | (d & 255) << 16 | (u & 255) << 8 | p & 255) >>> 0;
  }
}, h(Ks, "$a"), Ks);
c(HL, "TonalPalette");
let G = HL;
var $p;
const YL = ($p = class {
  constructor(t, e) {
    this.hue = t, this.requestedChroma = e, this.chromaCache = /* @__PURE__ */ new Map(), this.maxChromaValue = 200;
  }
  /**
   * Creates a key color from a [hue] and a [chroma].
   * The key color is the first tone, starting from T50, matching the given hue
   * and chroma.
   *
   * @return Key color [Hct]
   */
  create() {
    let t = 0, e = 100;
    for (; t < e; ) {
      const i = Math.floor((t + e) / 2), r = this.maxChroma(i) < this.maxChroma(i + 1);
      if (this.maxChroma(i) >= this.requestedChroma - 0.01)
        if (Math.abs(t - 50) < Math.abs(e - 50))
          e = i;
        else {
          if (t === i)
            return Lt.from(this.hue, this.requestedChroma, t);
          t = i;
        }
      else
        r ? t = i + 1 : e = i;
    }
    return Lt.from(this.hue, this.requestedChroma, t);
  }
  // Find the maximum chroma for a given tone
  maxChroma(t) {
    if (this.chromaCache.has(t))
      return this.chromaCache.get(t);
    const e = Lt.from(this.hue, this.maxChromaValue, t).chroma;
    return this.chromaCache.set(t, e), e;
  }
}, h($p, "Gy"), $p);
c(YL, "KeyColor");
let Vj = YL;
var Js;
const GL = (Js = class {
  constructor(t) {
    this.input = t, this.hctsByTempCache = [], this.hctsByHueCache = [], this.tempsByHctCache = /* @__PURE__ */ new Map(), this.inputRelativeTemperatureCache = -1, this.complementCache = null;
  }
  get hctsByTemp() {
    if (this.hctsByTempCache.length > 0)
      return this.hctsByTempCache;
    const t = this.hctsByHue.concat([this.input]), e = this.tempsByHct;
    return t.sort((i, r) => e.get(i) - e.get(r)), this.hctsByTempCache = t, t;
  }
  get warmest() {
    return this.hctsByTemp[this.hctsByTemp.length - 1];
  }
  get coldest() {
    return this.hctsByTemp[0];
  }
  /**
   * A set of colors with differing hues, equidistant in temperature.
   *
   * In art, this is usually described as a set of 5 colors on a color wheel
   * divided into 12 sections. This method allows provision of either of those
   * values.
   *
   * Behavior is undefined when [count] or [divisions] is 0.
   * When divisions < count, colors repeat.
   *
   * [count] The number of colors to return, includes the input color.
   * [divisions] The number of divisions on the color wheel.
   */
  analogous(t = 5, e = 12) {
    const i = Math.round(this.input.hue), r = this.hctsByHue[i];
    let n = this.relativeTemperature(r);
    const a = [r];
    let o = 0;
    for (let g = 0; g < 360; g++) {
      const O = wS(i + g), k = this.hctsByHue[O], $ = this.relativeTemperature(k), T = Math.abs($ - n);
      n = $, o += T;
    }
    let l = 1;
    const d = o / e;
    let u = 0;
    for (n = this.relativeTemperature(r); a.length < e; ) {
      const g = wS(i + l), O = this.hctsByHue[g], k = this.relativeTemperature(O), $ = Math.abs(k - n);
      u += $;
      const T = a.length * d;
      let _ = u >= T, D = 1;
      for (; _ && a.length < e; ) {
        a.push(O);
        const A = (a.length + D) * d;
        _ = u >= A, D++;
      }
      if (n = k, l++, l > 360) {
        for (; a.length < e; )
          a.push(O);
        break;
      }
    }
    const p = [this.input], f = Math.floor((t - 1) / 2);
    for (let g = 1; g < f + 1; g++) {
      let O = 0 - g;
      for (; O < 0; )
        O = a.length + O;
      O >= a.length && (O = O % a.length), p.splice(0, 0, a[O]);
    }
    const y = t - f - 1;
    for (let g = 1; g < y + 1; g++) {
      let O = g;
      for (; O < 0; )
        O = a.length + O;
      O >= a.length && (O = O % a.length), p.push(a[O]);
    }
    return p;
  }
  /**
   * A color that complements the input color aesthetically.
   *
   * In art, this is usually described as being across the color wheel.
   * History of this shows intent as a color that is just as cool-warm as the
   * input color is warm-cool.
   */
  get complement() {
    if (this.complementCache != null)
      return this.complementCache;
    const t = this.coldest.hue, e = this.tempsByHct.get(this.coldest), i = this.warmest.hue, r = this.tempsByHct.get(this.warmest) - e, n = Js.isBetween(this.input.hue, t, i), a = n ? i : t, o = n ? t : i, l = 1;
    let d = 1e3, u = this.hctsByHue[Math.round(this.input.hue)];
    const p = 1 - this.inputRelativeTemperature;
    for (let f = 0; f <= 360; f += 1) {
      const y = Qi(a + l * f);
      if (!Js.isBetween(y, a, o))
        continue;
      const g = this.hctsByHue[Math.round(y)], O = (this.tempsByHct.get(g) - e) / r, k = Math.abs(p - O);
      k < d && (d = k, u = g);
    }
    return this.complementCache = u, this.complementCache;
  }
  /**
   * Temperature relative to all colors with the same chroma and tone.
   * Value on a scale from 0 to 1.
   */
  relativeTemperature(t) {
    const e = this.tempsByHct.get(this.warmest) - this.tempsByHct.get(this.coldest), i = this.tempsByHct.get(t) - this.tempsByHct.get(this.coldest);
    return e === 0 ? 0.5 : i / e;
  }
  /** Relative temperature of the input color. See [relativeTemperature]. */
  get inputRelativeTemperature() {
    return this.inputRelativeTemperatureCache >= 0 ? this.inputRelativeTemperatureCache : (this.inputRelativeTemperatureCache = this.relativeTemperature(this.input), this.inputRelativeTemperatureCache);
  }
  /** A Map with keys of HCTs in [hctsByTemp], values of raw temperature. */
  get tempsByHct() {
    if (this.tempsByHctCache.size > 0)
      return this.tempsByHctCache;
    const t = this.hctsByHue.concat([this.input]), e = /* @__PURE__ */ new Map();
    for (const i of t)
      e.set(i, Js.rawTemperature(i));
    return this.tempsByHctCache = e, e;
  }
  /**
   * HCTs for all hues, with the same chroma/tone as the input.
   * Sorted ascending, hue 0 to 360.
   */
  get hctsByHue() {
    if (this.hctsByHueCache.length > 0)
      return this.hctsByHueCache;
    const t = [];
    for (let e = 0; e <= 360; e += 1) {
      const i = Lt.from(e, this.input.chroma, this.input.tone);
      t.push(i);
    }
    return this.hctsByHueCache = t, this.hctsByHueCache;
  }
  /** Determines if an angle is between two other angles, rotating clockwise. */
  static isBetween(t, e, i) {
    return e < i ? e <= t && t <= i : e <= t || t <= i;
  }
  /**
   * Value representing cool-warm factor of a color.
   * Values below 0 are considered cool, above, warm.
   *
   * Color science has researched emotion and harmony, which art uses to select
   * colors. Warm-cool is the foundation of analogous and complementary colors.
   * See:
   * - Li-Chen Ou's Chapter 19 in Handbook of Color Psychology (2015).
   * - Josef Albers' Interaction of Color chapters 19 and 21.
   *
   * Implementation of Ou, Woodcock and Wright's algorithm, which uses
   * L*a*b* / LCH color space.
   * Return value has these properties:
   * - Values below 0 are cool, above 0 are warm.
   * - Lower bound: -0.52 - (chroma ^ 1.07 / 20). L*a*b* chroma is infinite.
   *   Assuming max of 130 chroma, -9.66.
   * - Upper bound: -0.52 + (chroma ^ 1.07 / 20). L*a*b* chroma is infinite.
   *   Assuming max of 130 chroma, 8.61.
   */
  static rawTemperature(t) {
    const e = LL(t.toInt()), i = Qi(Math.atan2(e[2], e[1]) * 180 / Math.PI), r = Math.sqrt(e[1] * e[1] + e[2] * e[2]);
    return -0.5 + 0.02 * Math.pow(r, 1.07) * Math.cos(Qi(i - 50) * Math.PI / 180);
  }
}, h(Js, "ka"), Js);
c(GL, "TemperatureCache");
let g9 = GL;
var xp;
const KL = (xp = class {
  /**
   * Creates a `ContrastCurve` object.
   *
   * @param low Value for contrast level -1.0
   * @param normal Value for contrast level 0.0
   * @param medium Value for contrast level 0.5
   * @param high Value for contrast level 1.0
   */
  constructor(t, e, i, r) {
    this.low = t, this.normal = e, this.medium = i, this.high = r;
  }
  /**
   * Returns the value at a given contrast level.
   *
   * @param contrastLevel The contrast level. 0.0 is the default (normal); -1.0
   *     is the lowest; 1.0 is the highest.
   * @return The value. For contrast ratios, a number between 1.0 and 21.0.
   */
  get(t) {
    return t <= -1 ? this.low : t < 0 ? Ph(this.low, this.normal, (t - -1) / 1) : t < 0.5 ? Ph(this.normal, this.medium, (t - 0) / 0.5) : t < 1 ? Ph(this.medium, this.high, (t - 0.5) / 0.5) : this.high;
  }
}, h(xp, "Zy"), xp);
c(KL, "ContrastCurve");
let Ot = KL;
var kp;
const JL = (kp = class {
  /**
   * Documents a constraint in tone distance between two DynamicColors.
   *
   * The polarity is an adjective that describes "A", compared to "B".
   *
   * For instance, ToneDeltaPair(A, B, 15, 'darker', 'exact') states that
   * A's tone should be exactly 15 darker than B's.
   *
   * 'relative_darker' and 'relative_lighter' describes the tone adjustment
   * relative to the surface color trend (white in light mode; black in dark
   * mode). For instance, ToneDeltaPair(A, B, 10, 'relative_lighter',
   * 'farther') states that A should be at least 10 lighter than B in light
   * mode, and at least 10 darker than B in dark mode.
   *
   * @param roleA The first role in a pair.
   * @param roleB The second role in a pair.
   * @param delta Required difference between tones. Absolute value, negative
   * values have undefined behavior.
   * @param polarity The relative relation between tones of roleA and roleB,
   * as described above.
   * @param constraint How to fulfill the tone delta pair constraint.
   * @param stayTogether Whether these two roles should stay on the same side
   * of the "awkward zone" (T50-59). This is necessary for certain cases where
   * one role has two backgrounds.
   */
  constructor(t, e, i, r, n, a) {
    this.roleA = t, this.roleB = e, this.delta = i, this.polarity = r, this.stayTogether = n, this.constraint = a, this.constraint = a ?? "exact";
  }
}, h(kp, "Yy"), kp);
c(JL, "ToneDeltaPair");
let Gt = JL;
var I;
(function(s) {
  s[s.MONOCHROME = 0] = "MONOCHROME", s[s.NEUTRAL = 1] = "NEUTRAL", s[s.TONAL_SPOT = 2] = "TONAL_SPOT", s[s.VIBRANT = 3] = "VIBRANT", s[s.EXPRESSIVE = 4] = "EXPRESSIVE", s[s.FIDELITY = 5] = "FIDELITY", s[s.CONTENT = 6] = "CONTENT", s[s.RAINBOW = 7] = "RAINBOW", s[s.FRUIT_SALAD = 8] = "FRUIT_SALAD";
})(I || (I = {}));
function ro(s) {
  return s.variant === I.FIDELITY || s.variant === I.CONTENT;
}
h(ro, "la");
c(ro, "isFidelity");
function le(s) {
  return s.variant === I.MONOCHROME;
}
h(le, "Ft");
c(le, "isMonochrome");
function tz(s, t, e, i) {
  let r = e, n = Lt.from(s, t, e);
  if (n.chroma < t) {
    let a = n.chroma;
    for (; n.chroma < t; ) {
      r += i ? -1 : 1;
      const o = Lt.from(s, t, r);
      if (a > o.chroma || Math.abs(o.chroma - t) < 0.4)
        break;
      const l = Math.abs(o.chroma - t), d = Math.abs(n.chroma - t);
      l < d && (n = o), a = Math.max(a, o.chroma);
    }
  }
  return r;
}
h(tz, "Kg");
c(tz, "findDesiredChromaByTone");
var Sp;
const ez = (Sp = class {
  ////////////////////////////////////////////////////////////////
  // Main Palettes                                              //
  ////////////////////////////////////////////////////////////////
  primaryPaletteKeyColor() {
    return F.fromPalette({
      name: "primary_palette_key_color",
      palette: /* @__PURE__ */ c((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.primaryPalette.keyColor.tone, "tone")
    });
  }
  secondaryPaletteKeyColor() {
    return F.fromPalette({
      name: "secondary_palette_key_color",
      palette: /* @__PURE__ */ c((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.secondaryPalette.keyColor.tone, "tone")
    });
  }
  tertiaryPaletteKeyColor() {
    return F.fromPalette({
      name: "tertiary_palette_key_color",
      palette: /* @__PURE__ */ c((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.tertiaryPalette.keyColor.tone, "tone")
    });
  }
  neutralPaletteKeyColor() {
    return F.fromPalette({
      name: "neutral_palette_key_color",
      palette: /* @__PURE__ */ c((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.neutralPalette.keyColor.tone, "tone")
    });
  }
  neutralVariantPaletteKeyColor() {
    return F.fromPalette({
      name: "neutral_variant_palette_key_color",
      palette: /* @__PURE__ */ c((t) => t.neutralVariantPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.neutralVariantPalette.keyColor.tone, "tone")
    });
  }
  errorPaletteKeyColor() {
    return F.fromPalette({
      name: "error_palette_key_color",
      palette: /* @__PURE__ */ c((t) => t.errorPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.errorPalette.keyColor.tone, "tone")
    });
  }
  ////////////////////////////////////////////////////////////////
  // Surfaces [S]                                               //
  ////////////////////////////////////////////////////////////////
  background() {
    return F.fromPalette({
      name: "background",
      palette: /* @__PURE__ */ c((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? 6 : 98, "tone"),
      isBackground: !0
    });
  }
  onBackground() {
    return F.fromPalette({
      name: "on_background",
      palette: /* @__PURE__ */ c((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? 90 : 10, "tone"),
      background: /* @__PURE__ */ c((t) => this.background(), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(3, 3, 4.5, 7), "contrastCurve")
    });
  }
  surface() {
    return F.fromPalette({
      name: "surface",
      palette: /* @__PURE__ */ c((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? 6 : 98, "tone"),
      isBackground: !0
    });
  }
  surfaceDim() {
    return F.fromPalette({
      name: "surface_dim",
      palette: /* @__PURE__ */ c((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? 6 : new Ot(87, 87, 80, 75).get(t.contrastLevel), "tone"),
      isBackground: !0
    });
  }
  surfaceBright() {
    return F.fromPalette({
      name: "surface_bright",
      palette: /* @__PURE__ */ c((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? new Ot(24, 24, 29, 34).get(t.contrastLevel) : 98, "tone"),
      isBackground: !0
    });
  }
  surfaceContainerLowest() {
    return F.fromPalette({
      name: "surface_container_lowest",
      palette: /* @__PURE__ */ c((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? new Ot(4, 4, 2, 0).get(t.contrastLevel) : 100, "tone"),
      isBackground: !0
    });
  }
  surfaceContainerLow() {
    return F.fromPalette({
      name: "surface_container_low",
      palette: /* @__PURE__ */ c((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? new Ot(10, 10, 11, 12).get(t.contrastLevel) : new Ot(96, 96, 96, 95).get(t.contrastLevel), "tone"),
      isBackground: !0
    });
  }
  surfaceContainer() {
    return F.fromPalette({
      name: "surface_container",
      palette: /* @__PURE__ */ c((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? new Ot(12, 12, 16, 20).get(t.contrastLevel) : new Ot(94, 94, 92, 90).get(t.contrastLevel), "tone"),
      isBackground: !0
    });
  }
  surfaceContainerHigh() {
    return F.fromPalette({
      name: "surface_container_high",
      palette: /* @__PURE__ */ c((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? new Ot(17, 17, 21, 25).get(t.contrastLevel) : new Ot(92, 92, 88, 85).get(t.contrastLevel), "tone"),
      isBackground: !0
    });
  }
  surfaceContainerHighest() {
    return F.fromPalette({
      name: "surface_container_highest",
      palette: /* @__PURE__ */ c((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? new Ot(22, 22, 26, 30).get(t.contrastLevel) : new Ot(90, 90, 84, 80).get(t.contrastLevel), "tone"),
      isBackground: !0
    });
  }
  onSurface() {
    return F.fromPalette({
      name: "on_surface",
      palette: /* @__PURE__ */ c((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? 90 : 10, "tone"),
      background: /* @__PURE__ */ c((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(4.5, 7, 11, 21), "contrastCurve")
    });
  }
  surfaceVariant() {
    return F.fromPalette({
      name: "surface_variant",
      palette: /* @__PURE__ */ c((t) => t.neutralVariantPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? 30 : 90, "tone"),
      isBackground: !0
    });
  }
  onSurfaceVariant() {
    return F.fromPalette({
      name: "on_surface_variant",
      palette: /* @__PURE__ */ c((t) => t.neutralVariantPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? 80 : 30, "tone"),
      background: /* @__PURE__ */ c((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(3, 4.5, 7, 11), "contrastCurve")
    });
  }
  inverseSurface() {
    return F.fromPalette({
      name: "inverse_surface",
      palette: /* @__PURE__ */ c((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? 90 : 20, "tone"),
      isBackground: !0
    });
  }
  inverseOnSurface() {
    return F.fromPalette({
      name: "inverse_on_surface",
      palette: /* @__PURE__ */ c((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? 20 : 95, "tone"),
      background: /* @__PURE__ */ c((t) => this.inverseSurface(), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(4.5, 7, 11, 21), "contrastCurve")
    });
  }
  outline() {
    return F.fromPalette({
      name: "outline",
      palette: /* @__PURE__ */ c((t) => t.neutralVariantPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? 60 : 50, "tone"),
      background: /* @__PURE__ */ c((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(1.5, 3, 4.5, 7), "contrastCurve")
    });
  }
  outlineVariant() {
    return F.fromPalette({
      name: "outline_variant",
      palette: /* @__PURE__ */ c((t) => t.neutralVariantPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? 30 : 80, "tone"),
      background: /* @__PURE__ */ c((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(1, 1, 3, 4.5), "contrastCurve")
    });
  }
  shadow() {
    return F.fromPalette({
      name: "shadow",
      palette: /* @__PURE__ */ c((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => 0, "tone")
    });
  }
  scrim() {
    return F.fromPalette({
      name: "scrim",
      palette: /* @__PURE__ */ c((t) => t.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => 0, "tone")
    });
  }
  surfaceTint() {
    return F.fromPalette({
      name: "surface_tint",
      palette: /* @__PURE__ */ c((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? 80 : 40, "tone"),
      isBackground: !0
    });
  }
  ////////////////////////////////////////////////////////////////
  // Primary [P].                                               //
  ////////////////////////////////////////////////////////////////
  primary() {
    return F.fromPalette({
      name: "primary",
      palette: /* @__PURE__ */ c((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => le(t) ? t.isDark ? 100 : 0 : t.isDark ? 80 : 40, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(3, 4.5, 7, 7), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((t) => new Gt(this.primaryContainer(), this.primary(), 10, "nearer", !1), "toneDeltaPair")
    });
  }
  primaryDim() {
  }
  onPrimary() {
    return F.fromPalette({
      name: "on_primary",
      palette: /* @__PURE__ */ c((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => le(t) ? t.isDark ? 10 : 90 : t.isDark ? 20 : 100, "tone"),
      background: /* @__PURE__ */ c((t) => this.primary(), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(4.5, 7, 11, 21), "contrastCurve")
    });
  }
  primaryContainer() {
    return F.fromPalette({
      name: "primary_container",
      palette: /* @__PURE__ */ c((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => ro(t) ? t.sourceColorHct.tone : le(t) ? t.isDark ? 85 : 25 : t.isDark ? 30 : 90, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((t) => new Gt(this.primaryContainer(), this.primary(), 10, "nearer", !1), "toneDeltaPair")
    });
  }
  onPrimaryContainer() {
    return F.fromPalette({
      name: "on_primary_container",
      palette: /* @__PURE__ */ c((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => ro(t) ? F.foregroundTone(this.primaryContainer().tone(t), 4.5) : le(t) ? t.isDark ? 0 : 100 : t.isDark ? 90 : 30, "tone"),
      background: /* @__PURE__ */ c((t) => this.primaryContainer(), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(3, 4.5, 7, 11), "contrastCurve")
    });
  }
  inversePrimary() {
    return F.fromPalette({
      name: "inverse_primary",
      palette: /* @__PURE__ */ c((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? 40 : 80, "tone"),
      background: /* @__PURE__ */ c((t) => this.inverseSurface(), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(3, 4.5, 7, 7), "contrastCurve")
    });
  }
  /////////////////////////////////////////////////////////////////
  // Secondary [Q].                                              //
  /////////////////////////////////////////////////////////////////
  secondary() {
    return F.fromPalette({
      name: "secondary",
      palette: /* @__PURE__ */ c((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? 80 : 40, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(3, 4.5, 7, 7), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((t) => new Gt(this.secondaryContainer(), this.secondary(), 10, "nearer", !1), "toneDeltaPair")
    });
  }
  secondaryDim() {
  }
  onSecondary() {
    return F.fromPalette({
      name: "on_secondary",
      palette: /* @__PURE__ */ c((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => le(t) ? t.isDark ? 10 : 100 : t.isDark ? 20 : 100, "tone"),
      background: /* @__PURE__ */ c((t) => this.secondary(), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(4.5, 7, 11, 21), "contrastCurve")
    });
  }
  secondaryContainer() {
    return F.fromPalette({
      name: "secondary_container",
      palette: /* @__PURE__ */ c((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => {
        const e = t.isDark ? 30 : 90;
        return le(t) ? t.isDark ? 30 : 85 : ro(t) ? tz(t.secondaryPalette.hue, t.secondaryPalette.chroma, e, !t.isDark) : e;
      }, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((t) => new Gt(this.secondaryContainer(), this.secondary(), 10, "nearer", !1), "toneDeltaPair")
    });
  }
  onSecondaryContainer() {
    return F.fromPalette({
      name: "on_secondary_container",
      palette: /* @__PURE__ */ c((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => le(t) ? t.isDark ? 90 : 10 : ro(t) ? F.foregroundTone(this.secondaryContainer().tone(t), 4.5) : t.isDark ? 90 : 30, "tone"),
      background: /* @__PURE__ */ c((t) => this.secondaryContainer(), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(3, 4.5, 7, 11), "contrastCurve")
    });
  }
  /////////////////////////////////////////////////////////////////
  // Tertiary [T].                                               //
  /////////////////////////////////////////////////////////////////
  tertiary() {
    return F.fromPalette({
      name: "tertiary",
      palette: /* @__PURE__ */ c((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => le(t) ? t.isDark ? 90 : 25 : t.isDark ? 80 : 40, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(3, 4.5, 7, 7), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((t) => new Gt(this.tertiaryContainer(), this.tertiary(), 10, "nearer", !1), "toneDeltaPair")
    });
  }
  tertiaryDim() {
  }
  onTertiary() {
    return F.fromPalette({
      name: "on_tertiary",
      palette: /* @__PURE__ */ c((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => le(t) ? t.isDark ? 10 : 90 : t.isDark ? 20 : 100, "tone"),
      background: /* @__PURE__ */ c((t) => this.tertiary(), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(4.5, 7, 11, 21), "contrastCurve")
    });
  }
  tertiaryContainer() {
    return F.fromPalette({
      name: "tertiary_container",
      palette: /* @__PURE__ */ c((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => {
        if (le(t))
          return t.isDark ? 60 : 49;
        if (!ro(t))
          return t.isDark ? 30 : 90;
        const e = t.tertiaryPalette.getHct(t.sourceColorHct.tone);
        return bS.fixIfDisliked(e).tone;
      }, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((t) => new Gt(this.tertiaryContainer(), this.tertiary(), 10, "nearer", !1), "toneDeltaPair")
    });
  }
  onTertiaryContainer() {
    return F.fromPalette({
      name: "on_tertiary_container",
      palette: /* @__PURE__ */ c((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => le(t) ? t.isDark ? 0 : 100 : ro(t) ? F.foregroundTone(this.tertiaryContainer().tone(t), 4.5) : t.isDark ? 90 : 30, "tone"),
      background: /* @__PURE__ */ c((t) => this.tertiaryContainer(), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(3, 4.5, 7, 11), "contrastCurve")
    });
  }
  //////////////////////////////////////////////////////////////////
  // Error [E].                                                   //
  //////////////////////////////////////////////////////////////////
  error() {
    return F.fromPalette({
      name: "error",
      palette: /* @__PURE__ */ c((t) => t.errorPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? 80 : 40, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(3, 4.5, 7, 7), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((t) => new Gt(this.errorContainer(), this.error(), 10, "nearer", !1), "toneDeltaPair")
    });
  }
  errorDim() {
  }
  onError() {
    return F.fromPalette({
      name: "on_error",
      palette: /* @__PURE__ */ c((t) => t.errorPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? 20 : 100, "tone"),
      background: /* @__PURE__ */ c((t) => this.error(), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(4.5, 7, 11, 21), "contrastCurve")
    });
  }
  errorContainer() {
    return F.fromPalette({
      name: "error_container",
      palette: /* @__PURE__ */ c((t) => t.errorPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.isDark ? 30 : 90, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((t) => new Gt(this.errorContainer(), this.error(), 10, "nearer", !1), "toneDeltaPair")
    });
  }
  onErrorContainer() {
    return F.fromPalette({
      name: "on_error_container",
      palette: /* @__PURE__ */ c((t) => t.errorPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => le(t) ? t.isDark ? 90 : 10 : t.isDark ? 90 : 30, "tone"),
      background: /* @__PURE__ */ c((t) => this.errorContainer(), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(3, 4.5, 7, 11), "contrastCurve")
    });
  }
  //////////////////////////////////////////////////////////////////
  // Primary Fixed [PF]                                           //
  //////////////////////////////////////////////////////////////////
  primaryFixed() {
    return F.fromPalette({
      name: "primary_fixed",
      palette: /* @__PURE__ */ c((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => le(t) ? 40 : 90, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((t) => new Gt(this.primaryFixed(), this.primaryFixedDim(), 10, "lighter", !0), "toneDeltaPair")
    });
  }
  primaryFixedDim() {
    return F.fromPalette({
      name: "primary_fixed_dim",
      palette: /* @__PURE__ */ c((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => le(t) ? 30 : 80, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((t) => new Gt(this.primaryFixed(), this.primaryFixedDim(), 10, "lighter", !0), "toneDeltaPair")
    });
  }
  onPrimaryFixed() {
    return F.fromPalette({
      name: "on_primary_fixed",
      palette: /* @__PURE__ */ c((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => le(t) ? 100 : 10, "tone"),
      background: /* @__PURE__ */ c((t) => this.primaryFixedDim(), "background"),
      secondBackground: /* @__PURE__ */ c((t) => this.primaryFixed(), "secondBackground"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(4.5, 7, 11, 21), "contrastCurve")
    });
  }
  onPrimaryFixedVariant() {
    return F.fromPalette({
      name: "on_primary_fixed_variant",
      palette: /* @__PURE__ */ c((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => le(t) ? 90 : 30, "tone"),
      background: /* @__PURE__ */ c((t) => this.primaryFixedDim(), "background"),
      secondBackground: /* @__PURE__ */ c((t) => this.primaryFixed(), "secondBackground"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(3, 4.5, 7, 11), "contrastCurve")
    });
  }
  ///////////////////////////////////////////////////////////////////
  // Secondary Fixed [QF]                                          //
  ///////////////////////////////////////////////////////////////////
  secondaryFixed() {
    return F.fromPalette({
      name: "secondary_fixed",
      palette: /* @__PURE__ */ c((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => le(t) ? 80 : 90, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((t) => new Gt(this.secondaryFixed(), this.secondaryFixedDim(), 10, "lighter", !0), "toneDeltaPair")
    });
  }
  secondaryFixedDim() {
    return F.fromPalette({
      name: "secondary_fixed_dim",
      palette: /* @__PURE__ */ c((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => le(t) ? 70 : 80, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((t) => new Gt(this.secondaryFixed(), this.secondaryFixedDim(), 10, "lighter", !0), "toneDeltaPair")
    });
  }
  onSecondaryFixed() {
    return F.fromPalette({
      name: "on_secondary_fixed",
      palette: /* @__PURE__ */ c((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => 10, "tone"),
      background: /* @__PURE__ */ c((t) => this.secondaryFixedDim(), "background"),
      secondBackground: /* @__PURE__ */ c((t) => this.secondaryFixed(), "secondBackground"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(4.5, 7, 11, 21), "contrastCurve")
    });
  }
  onSecondaryFixedVariant() {
    return F.fromPalette({
      name: "on_secondary_fixed_variant",
      palette: /* @__PURE__ */ c((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => le(t) ? 25 : 30, "tone"),
      background: /* @__PURE__ */ c((t) => this.secondaryFixedDim(), "background"),
      secondBackground: /* @__PURE__ */ c((t) => this.secondaryFixed(), "secondBackground"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(3, 4.5, 7, 11), "contrastCurve")
    });
  }
  /////////////////////////////////////////////////////////////////
  // Tertiary Fixed [TF]                                         //
  /////////////////////////////////////////////////////////////////
  tertiaryFixed() {
    return F.fromPalette({
      name: "tertiary_fixed",
      palette: /* @__PURE__ */ c((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => le(t) ? 40 : 90, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((t) => new Gt(this.tertiaryFixed(), this.tertiaryFixedDim(), 10, "lighter", !0), "toneDeltaPair")
    });
  }
  tertiaryFixedDim() {
    return F.fromPalette({
      name: "tertiary_fixed_dim",
      palette: /* @__PURE__ */ c((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => le(t) ? 30 : 80, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((t) => this.highestSurface(t), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(1, 1, 3, 4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((t) => new Gt(this.tertiaryFixed(), this.tertiaryFixedDim(), 10, "lighter", !0), "toneDeltaPair")
    });
  }
  onTertiaryFixed() {
    return F.fromPalette({
      name: "on_tertiary_fixed",
      palette: /* @__PURE__ */ c((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => le(t) ? 100 : 10, "tone"),
      background: /* @__PURE__ */ c((t) => this.tertiaryFixedDim(), "background"),
      secondBackground: /* @__PURE__ */ c((t) => this.tertiaryFixed(), "secondBackground"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(4.5, 7, 11, 21), "contrastCurve")
    });
  }
  onTertiaryFixedVariant() {
    return F.fromPalette({
      name: "on_tertiary_fixed_variant",
      palette: /* @__PURE__ */ c((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => le(t) ? 90 : 30, "tone"),
      background: /* @__PURE__ */ c((t) => this.tertiaryFixedDim(), "background"),
      secondBackground: /* @__PURE__ */ c((t) => this.tertiaryFixed(), "secondBackground"),
      contrastCurve: /* @__PURE__ */ c((t) => new Ot(3, 4.5, 7, 11), "contrastCurve")
    });
  }
  ////////////////////////////////////////////////////////////////
  // Other                                                      //
  ////////////////////////////////////////////////////////////////
  highestSurface(t) {
    return t.isDark ? this.surfaceBright() : this.surfaceDim();
  }
}, h(Sp, "Xy"), Sp);
c(ez, "ColorSpecDelegateImpl2021");
let Wj = ez;
function Dt(s, t = 0, e = 100, i = 1) {
  let r = t4(s.hue, s.chroma * i, 100, !0);
  return Ke(t, e, r);
}
h(Dt, "mt");
c(Dt, "tMaxC");
function _s(s, t = 0, e = 100) {
  let i = t4(s.hue, s.chroma, 0, !1);
  return Ke(t, e, i);
}
h(_s, "vr");
c(_s, "tMinC");
function t4(s, t, e, i) {
  let r = e, n = Lt.from(s, t, r);
  for (; n.chroma < t && !(e < 0 || e > 100); ) {
    e += i ? -1 : 1;
    const a = Lt.from(s, t, e);
    n.chroma < a.chroma && (n = a, r = e);
  }
  return r;
}
h(t4, "Pm");
c(t4, "findBestToneForChroma");
function bt(s) {
  return s === 1.5 ? new Ot(1.5, 1.5, 3, 5.5) : s === 3 ? new Ot(3, 3, 4.5, 7) : s === 4.5 ? new Ot(4.5, 4.5, 7, 11) : s === 6 ? new Ot(6, 6, 7, 11) : s === 7 ? new Ot(7, 7, 11, 21) : s === 9 ? new Ot(9, 9, 11, 21) : s === 11 ? new Ot(11, 11, 21, 21) : s === 21 ? new Ot(21, 21, 21, 21) : new Ot(s, s, 7, 21);
}
h(bt, "at");
c(bt, "getCurve");
var Cp;
const iz = (Cp = class extends Wj {
  ////////////////////////////////////////////////////////////////
  // Surfaces [S]                                               //
  ////////////////////////////////////////////////////////////////
  surface() {
    const t = F.fromPalette({
      name: "surface",
      palette: /* @__PURE__ */ c((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => (super.surface().tone(e), e.platform === "phone" ? e.isDark ? 4 : Lt.isYellow(e.neutralPalette.hue) ? 99 : e.variant === I.VIBRANT ? 97 : 98 : 0), "tone"),
      isBackground: !0
    });
    return Tt(super.surface(), "2025", t);
  }
  surfaceDim() {
    const t = F.fromPalette({
      name: "surface_dim",
      palette: /* @__PURE__ */ c((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => e.isDark ? 4 : Lt.isYellow(e.neutralPalette.hue) ? 90 : e.variant === I.VIBRANT ? 85 : 87, "tone"),
      isBackground: !0,
      chromaMultiplier: /* @__PURE__ */ c((e) => {
        if (!e.isDark) {
          if (e.variant === I.NEUTRAL)
            return 2.5;
          if (e.variant === I.TONAL_SPOT)
            return 1.7;
          if (e.variant === I.EXPRESSIVE)
            return Lt.isYellow(e.neutralPalette.hue) ? 2.7 : 1.75;
          if (e.variant === I.VIBRANT)
            return 1.36;
        }
        return 1;
      }, "chromaMultiplier")
    });
    return Tt(super.surfaceDim(), "2025", t);
  }
  surfaceBright() {
    const t = F.fromPalette({
      name: "surface_bright",
      palette: /* @__PURE__ */ c((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => e.isDark ? 18 : Lt.isYellow(e.neutralPalette.hue) ? 99 : e.variant === I.VIBRANT ? 97 : 98, "tone"),
      isBackground: !0,
      chromaMultiplier: /* @__PURE__ */ c((e) => {
        if (e.isDark) {
          if (e.variant === I.NEUTRAL)
            return 2.5;
          if (e.variant === I.TONAL_SPOT)
            return 1.7;
          if (e.variant === I.EXPRESSIVE)
            return Lt.isYellow(e.neutralPalette.hue) ? 2.7 : 1.75;
          if (e.variant === I.VIBRANT)
            return 1.36;
        }
        return 1;
      }, "chromaMultiplier")
    });
    return Tt(super.surfaceBright(), "2025", t);
  }
  surfaceContainerLowest() {
    const t = F.fromPalette({
      name: "surface_container_lowest",
      palette: /* @__PURE__ */ c((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => e.isDark ? 0 : 100, "tone"),
      isBackground: !0
    });
    return Tt(super.surfaceContainerLowest(), "2025", t);
  }
  surfaceContainerLow() {
    const t = F.fromPalette({
      name: "surface_container_low",
      palette: /* @__PURE__ */ c((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => e.platform === "phone" ? e.isDark ? 6 : Lt.isYellow(e.neutralPalette.hue) ? 98 : e.variant === I.VIBRANT ? 95 : 96 : 15, "tone"),
      isBackground: !0,
      chromaMultiplier: /* @__PURE__ */ c((e) => {
        if (e.platform === "phone") {
          if (e.variant === I.NEUTRAL)
            return 1.3;
          if (e.variant === I.TONAL_SPOT)
            return 1.25;
          if (e.variant === I.EXPRESSIVE)
            return Lt.isYellow(e.neutralPalette.hue) ? 1.3 : 1.15;
          if (e.variant === I.VIBRANT)
            return 1.08;
        }
        return 1;
      }, "chromaMultiplier")
    });
    return Tt(super.surfaceContainerLow(), "2025", t);
  }
  surfaceContainer() {
    const t = F.fromPalette({
      name: "surface_container",
      palette: /* @__PURE__ */ c((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => e.platform === "phone" ? e.isDark ? 9 : Lt.isYellow(e.neutralPalette.hue) ? 96 : e.variant === I.VIBRANT ? 92 : 94 : 20, "tone"),
      isBackground: !0,
      chromaMultiplier: /* @__PURE__ */ c((e) => {
        if (e.platform === "phone") {
          if (e.variant === I.NEUTRAL)
            return 1.6;
          if (e.variant === I.TONAL_SPOT)
            return 1.4;
          if (e.variant === I.EXPRESSIVE)
            return Lt.isYellow(e.neutralPalette.hue) ? 1.6 : 1.3;
          if (e.variant === I.VIBRANT)
            return 1.15;
        }
        return 1;
      }, "chromaMultiplier")
    });
    return Tt(super.surfaceContainer(), "2025", t);
  }
  surfaceContainerHigh() {
    const t = F.fromPalette({
      name: "surface_container_high",
      palette: /* @__PURE__ */ c((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => e.platform === "phone" ? e.isDark ? 12 : Lt.isYellow(e.neutralPalette.hue) ? 94 : e.variant === I.VIBRANT ? 90 : 92 : 25, "tone"),
      isBackground: !0,
      chromaMultiplier: /* @__PURE__ */ c((e) => {
        if (e.platform === "phone") {
          if (e.variant === I.NEUTRAL)
            return 1.9;
          if (e.variant === I.TONAL_SPOT)
            return 1.5;
          if (e.variant === I.EXPRESSIVE)
            return Lt.isYellow(e.neutralPalette.hue) ? 1.95 : 1.45;
          if (e.variant === I.VIBRANT)
            return 1.22;
        }
        return 1;
      }, "chromaMultiplier")
    });
    return Tt(super.surfaceContainerHigh(), "2025", t);
  }
  surfaceContainerHighest() {
    const t = F.fromPalette({
      name: "surface_container_highest",
      palette: /* @__PURE__ */ c((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => e.isDark ? 15 : Lt.isYellow(e.neutralPalette.hue) ? 92 : e.variant === I.VIBRANT ? 88 : 90, "tone"),
      isBackground: !0,
      chromaMultiplier: /* @__PURE__ */ c((e) => e.variant === I.NEUTRAL ? 2.2 : e.variant === I.TONAL_SPOT ? 1.7 : e.variant === I.EXPRESSIVE ? Lt.isYellow(e.neutralPalette.hue) ? 2.3 : 1.6 : e.variant === I.VIBRANT ? 1.29 : 1, "chromaMultiplier")
    });
    return Tt(super.surfaceContainerHighest(), "2025", t);
  }
  onSurface() {
    const t = F.fromPalette({
      name: "on_surface",
      palette: /* @__PURE__ */ c((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => e.variant === I.VIBRANT ? Dt(e.neutralPalette, 0, 100, 1.1) : F.getInitialToneFromBackground((i) => i.platform === "phone" ? this.highestSurface(i) : this.surfaceContainerHigh())(e), "tone"),
      chromaMultiplier: /* @__PURE__ */ c((e) => {
        if (e.platform === "phone") {
          if (e.variant === I.NEUTRAL)
            return 2.2;
          if (e.variant === I.TONAL_SPOT)
            return 1.7;
          if (e.variant === I.EXPRESSIVE)
            return Lt.isYellow(e.neutralPalette.hue) ? e.isDark ? 3 : 2.3 : 1.6;
        }
        return 1;
      }, "chromaMultiplier"),
      background: /* @__PURE__ */ c((e) => e.platform === "phone" ? this.highestSurface(e) : this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.isDark && e.platform === "phone" ? bt(11) : bt(9), "contrastCurve")
    });
    return Tt(super.onSurface(), "2025", t);
  }
  onSurfaceVariant() {
    const t = F.fromPalette({
      name: "on_surface_variant",
      palette: /* @__PURE__ */ c((e) => e.neutralPalette, "palette"),
      chromaMultiplier: /* @__PURE__ */ c((e) => {
        if (e.platform === "phone") {
          if (e.variant === I.NEUTRAL)
            return 2.2;
          if (e.variant === I.TONAL_SPOT)
            return 1.7;
          if (e.variant === I.EXPRESSIVE)
            return Lt.isYellow(e.neutralPalette.hue) ? e.isDark ? 3 : 2.3 : 1.6;
        }
        return 1;
      }, "chromaMultiplier"),
      background: /* @__PURE__ */ c((e) => e.platform === "phone" ? this.highestSurface(e) : this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" ? e.isDark ? bt(6) : bt(4.5) : bt(7), "contrastCurve")
    });
    return Tt(super.onSurfaceVariant(), "2025", t);
  }
  outline() {
    const t = F.fromPalette({
      name: "outline",
      palette: /* @__PURE__ */ c((e) => e.neutralPalette, "palette"),
      chromaMultiplier: /* @__PURE__ */ c((e) => {
        if (e.platform === "phone") {
          if (e.variant === I.NEUTRAL)
            return 2.2;
          if (e.variant === I.TONAL_SPOT)
            return 1.7;
          if (e.variant === I.EXPRESSIVE)
            return Lt.isYellow(e.neutralPalette.hue) ? e.isDark ? 3 : 2.3 : 1.6;
        }
        return 1;
      }, "chromaMultiplier"),
      background: /* @__PURE__ */ c((e) => e.platform === "phone" ? this.highestSurface(e) : this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" ? bt(3) : bt(4.5), "contrastCurve")
    });
    return Tt(super.outline(), "2025", t);
  }
  outlineVariant() {
    const t = F.fromPalette({
      name: "outline_variant",
      palette: /* @__PURE__ */ c((e) => e.neutralPalette, "palette"),
      chromaMultiplier: /* @__PURE__ */ c((e) => {
        if (e.platform === "phone") {
          if (e.variant === I.NEUTRAL)
            return 2.2;
          if (e.variant === I.TONAL_SPOT)
            return 1.7;
          if (e.variant === I.EXPRESSIVE)
            return Lt.isYellow(e.neutralPalette.hue) ? e.isDark ? 3 : 2.3 : 1.6;
        }
        return 1;
      }, "chromaMultiplier"),
      background: /* @__PURE__ */ c((e) => e.platform === "phone" ? this.highestSurface(e) : this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" ? bt(1.5) : bt(3), "contrastCurve")
    });
    return Tt(super.outlineVariant(), "2025", t);
  }
  inverseSurface() {
    const t = F.fromPalette({
      name: "inverse_surface",
      palette: /* @__PURE__ */ c((e) => e.neutralPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => e.isDark ? 98 : 4, "tone"),
      isBackground: !0
    });
    return Tt(super.inverseSurface(), "2025", t);
  }
  inverseOnSurface() {
    const t = F.fromPalette({
      name: "inverse_on_surface",
      palette: /* @__PURE__ */ c((e) => e.neutralPalette, "palette"),
      background: /* @__PURE__ */ c((e) => this.inverseSurface(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => bt(7), "contrastCurve")
    });
    return Tt(super.inverseOnSurface(), "2025", t);
  }
  ////////////////////////////////////////////////////////////////
  // Primaries [P]                                              //
  ////////////////////////////////////////////////////////////////
  primary() {
    const t = F.fromPalette({
      name: "primary",
      palette: /* @__PURE__ */ c((e) => e.primaryPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => e.variant === I.NEUTRAL ? e.platform === "phone" ? e.isDark ? 80 : 40 : 90 : e.variant === I.TONAL_SPOT ? e.platform === "phone" ? e.isDark ? 80 : Dt(e.primaryPalette) : Dt(e.primaryPalette, 0, 90) : e.variant === I.EXPRESSIVE ? e.platform === "phone" ? Dt(e.primaryPalette, 0, Lt.isYellow(e.primaryPalette.hue) ? 25 : Lt.isCyan(e.primaryPalette.hue) ? 88 : 98) : Dt(e.primaryPalette) : e.platform === "phone" ? Dt(e.primaryPalette, 0, Lt.isCyan(e.primaryPalette.hue) ? 88 : 98) : Dt(e.primaryPalette), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((e) => e.platform === "phone" ? this.highestSurface(e) : this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" ? bt(4.5) : bt(7), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((e) => e.platform === "phone" ? new Gt(this.primaryContainer(), this.primary(), 5, "relative_lighter", !0, "farther") : void 0, "toneDeltaPair")
    });
    return Tt(super.primary(), "2025", t);
  }
  primaryDim() {
    return F.fromPalette({
      name: "primary_dim",
      palette: /* @__PURE__ */ c((t) => t.primaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.variant === I.NEUTRAL ? 85 : t.variant === I.TONAL_SPOT ? Dt(t.primaryPalette, 0, 90) : Dt(t.primaryPalette), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((t) => this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => bt(4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((t) => new Gt(this.primaryDim(), this.primary(), 5, "darker", !0, "farther"), "toneDeltaPair")
    });
  }
  onPrimary() {
    const t = F.fromPalette({
      name: "on_primary",
      palette: /* @__PURE__ */ c((e) => e.primaryPalette, "palette"),
      background: /* @__PURE__ */ c((e) => e.platform === "phone" ? this.primary() : this.primaryDim(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" ? bt(6) : bt(7), "contrastCurve")
    });
    return Tt(super.onPrimary(), "2025", t);
  }
  primaryContainer() {
    const t = F.fromPalette({
      name: "primary_container",
      palette: /* @__PURE__ */ c((e) => e.primaryPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => e.platform === "watch" ? 30 : e.variant === I.NEUTRAL ? e.isDark ? 30 : 90 : e.variant === I.TONAL_SPOT ? e.isDark ? _s(e.primaryPalette, 35, 93) : Dt(e.primaryPalette, 0, 90) : e.variant === I.EXPRESSIVE ? e.isDark ? Dt(e.primaryPalette, 30, 93) : Dt(e.primaryPalette, 78, Lt.isCyan(e.primaryPalette.hue) ? 88 : 90) : e.isDark ? _s(e.primaryPalette, 66, 93) : Dt(e.primaryPalette, 66, Lt.isCyan(e.primaryPalette.hue) ? 88 : 93), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((e) => e.platform === "phone" ? this.highestSurface(e) : void 0, "background"),
      toneDeltaPair: /* @__PURE__ */ c((e) => e.platform === "phone" ? void 0 : new Gt(this.primaryContainer(), this.primaryDim(), 10, "darker", !0, "farther"), "toneDeltaPair"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" && e.contrastLevel > 0 ? bt(1.5) : void 0, "contrastCurve")
    });
    return Tt(super.primaryContainer(), "2025", t);
  }
  onPrimaryContainer() {
    const t = F.fromPalette({
      name: "on_primary_container",
      palette: /* @__PURE__ */ c((e) => e.primaryPalette, "palette"),
      background: /* @__PURE__ */ c((e) => this.primaryContainer(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" ? bt(6) : bt(7), "contrastCurve")
    });
    return Tt(super.onPrimaryContainer(), "2025", t);
  }
  primaryFixed() {
    const t = F.fromPalette({
      name: "primary_fixed",
      palette: /* @__PURE__ */ c((e) => e.primaryPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => {
        let i = Object.assign({}, e, { isDark: !1, contrastLevel: 0 });
        return this.primaryContainer().getTone(i);
      }, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((e) => e.platform === "phone" ? this.highestSurface(e) : void 0, "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" && e.contrastLevel > 0 ? bt(1.5) : void 0, "contrastCurve")
    });
    return Tt(super.primaryFixed(), "2025", t);
  }
  primaryFixedDim() {
    const t = F.fromPalette({
      name: "primary_fixed_dim",
      palette: /* @__PURE__ */ c((e) => e.primaryPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => this.primaryFixed().getTone(e), "tone"),
      isBackground: !0,
      toneDeltaPair: /* @__PURE__ */ c((e) => new Gt(this.primaryFixedDim(), this.primaryFixed(), 5, "darker", !0, "exact"), "toneDeltaPair")
    });
    return Tt(super.primaryFixedDim(), "2025", t);
  }
  onPrimaryFixed() {
    const t = F.fromPalette({
      name: "on_primary_fixed",
      palette: /* @__PURE__ */ c((e) => e.primaryPalette, "palette"),
      background: /* @__PURE__ */ c((e) => this.primaryFixedDim(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => bt(7), "contrastCurve")
    });
    return Tt(super.onPrimaryFixed(), "2025", t);
  }
  onPrimaryFixedVariant() {
    const t = F.fromPalette({
      name: "on_primary_fixed_variant",
      palette: /* @__PURE__ */ c((e) => e.primaryPalette, "palette"),
      background: /* @__PURE__ */ c((e) => this.primaryFixedDim(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => bt(4.5), "contrastCurve")
    });
    return Tt(super.onPrimaryFixedVariant(), "2025", t);
  }
  inversePrimary() {
    const t = F.fromPalette({
      name: "inverse_primary",
      palette: /* @__PURE__ */ c((e) => e.primaryPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => Dt(e.primaryPalette), "tone"),
      background: /* @__PURE__ */ c((e) => this.inverseSurface(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" ? bt(6) : bt(7), "contrastCurve")
    });
    return Tt(super.inversePrimary(), "2025", t);
  }
  ////////////////////////////////////////////////////////////////
  // Secondaries [Q]                                            //
  ////////////////////////////////////////////////////////////////
  secondary() {
    const t = F.fromPalette({
      name: "secondary",
      palette: /* @__PURE__ */ c((e) => e.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => e.platform === "watch" ? e.variant === I.NEUTRAL ? 90 : Dt(e.secondaryPalette, 0, 90) : e.variant === I.NEUTRAL ? e.isDark ? _s(e.secondaryPalette, 0, 98) : Dt(e.secondaryPalette) : e.variant === I.VIBRANT ? Dt(e.secondaryPalette, 0, e.isDark ? 90 : 98) : e.isDark ? 80 : Dt(e.secondaryPalette), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((e) => e.platform === "phone" ? this.highestSurface(e) : this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" ? bt(4.5) : bt(7), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((e) => e.platform === "phone" ? new Gt(this.secondaryContainer(), this.secondary(), 5, "relative_lighter", !0, "farther") : void 0, "toneDeltaPair")
    });
    return Tt(super.secondary(), "2025", t);
  }
  secondaryDim() {
    return F.fromPalette({
      name: "secondary_dim",
      palette: /* @__PURE__ */ c((t) => t.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.variant === I.NEUTRAL ? 85 : Dt(t.secondaryPalette, 0, 90), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((t) => this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => bt(4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((t) => new Gt(this.secondaryDim(), this.secondary(), 5, "darker", !0, "farther"), "toneDeltaPair")
    });
  }
  onSecondary() {
    const t = F.fromPalette({
      name: "on_secondary",
      palette: /* @__PURE__ */ c((e) => e.secondaryPalette, "palette"),
      background: /* @__PURE__ */ c((e) => e.platform === "phone" ? this.secondary() : this.secondaryDim(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" ? bt(6) : bt(7), "contrastCurve")
    });
    return Tt(super.onSecondary(), "2025", t);
  }
  secondaryContainer() {
    const t = F.fromPalette({
      name: "secondary_container",
      palette: /* @__PURE__ */ c((e) => e.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => e.platform === "watch" ? 30 : e.variant === I.VIBRANT ? e.isDark ? _s(e.secondaryPalette, 30, 40) : Dt(e.secondaryPalette, 84, 90) : e.variant === I.EXPRESSIVE ? e.isDark ? 15 : Dt(e.secondaryPalette, 90, 95) : e.isDark ? 25 : 90, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((e) => e.platform === "phone" ? this.highestSurface(e) : void 0, "background"),
      toneDeltaPair: /* @__PURE__ */ c((e) => e.platform === "watch" ? new Gt(this.secondaryContainer(), this.secondaryDim(), 10, "darker", !0, "farther") : void 0, "toneDeltaPair"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" && e.contrastLevel > 0 ? bt(1.5) : void 0, "contrastCurve")
    });
    return Tt(super.secondaryContainer(), "2025", t);
  }
  onSecondaryContainer() {
    const t = F.fromPalette({
      name: "on_secondary_container",
      palette: /* @__PURE__ */ c((e) => e.secondaryPalette, "palette"),
      background: /* @__PURE__ */ c((e) => this.secondaryContainer(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" ? bt(6) : bt(7), "contrastCurve")
    });
    return Tt(super.onSecondaryContainer(), "2025", t);
  }
  secondaryFixed() {
    const t = F.fromPalette({
      name: "secondary_fixed",
      palette: /* @__PURE__ */ c((e) => e.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => {
        let i = Object.assign({}, e, { isDark: !1, contrastLevel: 0 });
        return this.secondaryContainer().getTone(i);
      }, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((e) => e.platform === "phone" ? this.highestSurface(e) : void 0, "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" && e.contrastLevel > 0 ? bt(1.5) : void 0, "contrastCurve")
    });
    return Tt(super.secondaryFixed(), "2025", t);
  }
  secondaryFixedDim() {
    const t = F.fromPalette({
      name: "secondary_fixed_dim",
      palette: /* @__PURE__ */ c((e) => e.secondaryPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => this.secondaryFixed().getTone(e), "tone"),
      isBackground: !0,
      toneDeltaPair: /* @__PURE__ */ c((e) => new Gt(this.secondaryFixedDim(), this.secondaryFixed(), 5, "darker", !0, "exact"), "toneDeltaPair")
    });
    return Tt(super.secondaryFixedDim(), "2025", t);
  }
  onSecondaryFixed() {
    const t = F.fromPalette({
      name: "on_secondary_fixed",
      palette: /* @__PURE__ */ c((e) => e.secondaryPalette, "palette"),
      background: /* @__PURE__ */ c((e) => this.secondaryFixedDim(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => bt(7), "contrastCurve")
    });
    return Tt(super.onSecondaryFixed(), "2025", t);
  }
  onSecondaryFixedVariant() {
    const t = F.fromPalette({
      name: "on_secondary_fixed_variant",
      palette: /* @__PURE__ */ c((e) => e.secondaryPalette, "palette"),
      background: /* @__PURE__ */ c((e) => this.secondaryFixedDim(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => bt(4.5), "contrastCurve")
    });
    return Tt(super.onSecondaryFixedVariant(), "2025", t);
  }
  ////////////////////////////////////////////////////////////////
  // Tertiaries [T]                                             //
  ////////////////////////////////////////////////////////////////
  tertiary() {
    const t = F.fromPalette({
      name: "tertiary",
      palette: /* @__PURE__ */ c((e) => e.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => e.platform === "watch" ? e.variant === I.TONAL_SPOT ? Dt(e.tertiaryPalette, 0, 90) : Dt(e.tertiaryPalette) : e.variant === I.EXPRESSIVE || e.variant === I.VIBRANT ? Dt(e.tertiaryPalette, 0, Lt.isCyan(e.tertiaryPalette.hue) ? 88 : e.isDark ? 98 : 100) : e.isDark ? Dt(e.tertiaryPalette, 0, 98) : Dt(e.tertiaryPalette), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((e) => e.platform === "phone" ? this.highestSurface(e) : this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" ? bt(4.5) : bt(7), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((e) => e.platform === "phone" ? new Gt(this.tertiaryContainer(), this.tertiary(), 5, "relative_lighter", !0, "farther") : void 0, "toneDeltaPair")
    });
    return Tt(super.tertiary(), "2025", t);
  }
  tertiaryDim() {
    return F.fromPalette({
      name: "tertiary_dim",
      palette: /* @__PURE__ */ c((t) => t.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => t.variant === I.TONAL_SPOT ? Dt(t.tertiaryPalette, 0, 90) : Dt(t.tertiaryPalette), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((t) => this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => bt(4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((t) => new Gt(this.tertiaryDim(), this.tertiary(), 5, "darker", !0, "farther"), "toneDeltaPair")
    });
  }
  onTertiary() {
    const t = F.fromPalette({
      name: "on_tertiary",
      palette: /* @__PURE__ */ c((e) => e.tertiaryPalette, "palette"),
      background: /* @__PURE__ */ c((e) => e.platform === "phone" ? this.tertiary() : this.tertiaryDim(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" ? bt(6) : bt(7), "contrastCurve")
    });
    return Tt(super.onTertiary(), "2025", t);
  }
  tertiaryContainer() {
    const t = F.fromPalette({
      name: "tertiary_container",
      palette: /* @__PURE__ */ c((e) => e.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => e.platform === "watch" ? e.variant === I.TONAL_SPOT ? Dt(e.tertiaryPalette, 0, 90) : Dt(e.tertiaryPalette) : e.variant === I.NEUTRAL ? e.isDark ? Dt(e.tertiaryPalette, 0, 93) : Dt(e.tertiaryPalette, 0, 96) : e.variant === I.TONAL_SPOT ? Dt(e.tertiaryPalette, 0, e.isDark ? 93 : 100) : e.variant === I.EXPRESSIVE ? Dt(e.tertiaryPalette, 75, Lt.isCyan(e.tertiaryPalette.hue) ? 88 : e.isDark ? 93 : 100) : e.isDark ? Dt(e.tertiaryPalette, 0, 93) : Dt(e.tertiaryPalette, 72, 100), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((e) => e.platform === "phone" ? this.highestSurface(e) : void 0, "background"),
      toneDeltaPair: /* @__PURE__ */ c((e) => e.platform === "watch" ? new Gt(this.tertiaryContainer(), this.tertiaryDim(), 10, "darker", !0, "farther") : void 0, "toneDeltaPair"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" && e.contrastLevel > 0 ? bt(1.5) : void 0, "contrastCurve")
    });
    return Tt(super.tertiaryContainer(), "2025", t);
  }
  onTertiaryContainer() {
    const t = F.fromPalette({
      name: "on_tertiary_container",
      palette: /* @__PURE__ */ c((e) => e.tertiaryPalette, "palette"),
      background: /* @__PURE__ */ c((e) => this.tertiaryContainer(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" ? bt(6) : bt(7), "contrastCurve")
    });
    return Tt(super.onTertiaryContainer(), "2025", t);
  }
  tertiaryFixed() {
    const t = F.fromPalette({
      name: "tertiary_fixed",
      palette: /* @__PURE__ */ c((e) => e.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => {
        let i = Object.assign({}, e, { isDark: !1, contrastLevel: 0 });
        return this.tertiaryContainer().getTone(i);
      }, "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((e) => e.platform === "phone" ? this.highestSurface(e) : void 0, "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" && e.contrastLevel > 0 ? bt(1.5) : void 0, "contrastCurve")
    });
    return Tt(super.tertiaryFixed(), "2025", t);
  }
  tertiaryFixedDim() {
    const t = F.fromPalette({
      name: "tertiary_fixed_dim",
      palette: /* @__PURE__ */ c((e) => e.tertiaryPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => this.tertiaryFixed().getTone(e), "tone"),
      isBackground: !0,
      toneDeltaPair: /* @__PURE__ */ c((e) => new Gt(this.tertiaryFixedDim(), this.tertiaryFixed(), 5, "darker", !0, "exact"), "toneDeltaPair")
    });
    return Tt(super.tertiaryFixedDim(), "2025", t);
  }
  onTertiaryFixed() {
    const t = F.fromPalette({
      name: "on_tertiary_fixed",
      palette: /* @__PURE__ */ c((e) => e.tertiaryPalette, "palette"),
      background: /* @__PURE__ */ c((e) => this.tertiaryFixedDim(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => bt(7), "contrastCurve")
    });
    return Tt(super.onTertiaryFixed(), "2025", t);
  }
  onTertiaryFixedVariant() {
    const t = F.fromPalette({
      name: "on_tertiary_fixed_variant",
      palette: /* @__PURE__ */ c((e) => e.tertiaryPalette, "palette"),
      background: /* @__PURE__ */ c((e) => this.tertiaryFixedDim(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => bt(4.5), "contrastCurve")
    });
    return Tt(super.onTertiaryFixedVariant(), "2025", t);
  }
  ////////////////////////////////////////////////////////////////
  // Errors [E]                                                 //
  ////////////////////////////////////////////////////////////////
  error() {
    const t = F.fromPalette({
      name: "error",
      palette: /* @__PURE__ */ c((e) => e.errorPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => e.platform === "phone" ? e.isDark ? _s(e.errorPalette, 0, 98) : Dt(e.errorPalette) : _s(e.errorPalette), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((e) => e.platform === "phone" ? this.highestSurface(e) : this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" ? bt(4.5) : bt(7), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((e) => e.platform === "phone" ? new Gt(this.errorContainer(), this.error(), 5, "relative_lighter", !0, "farther") : void 0, "toneDeltaPair")
    });
    return Tt(super.error(), "2025", t);
  }
  errorDim() {
    return F.fromPalette({
      name: "error_dim",
      palette: /* @__PURE__ */ c((t) => t.errorPalette, "palette"),
      tone: /* @__PURE__ */ c((t) => _s(t.errorPalette), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((t) => this.surfaceContainerHigh(), "background"),
      contrastCurve: /* @__PURE__ */ c((t) => bt(4.5), "contrastCurve"),
      toneDeltaPair: /* @__PURE__ */ c((t) => new Gt(this.errorDim(), this.error(), 5, "darker", !0, "farther"), "toneDeltaPair")
    });
  }
  onError() {
    const t = F.fromPalette({
      name: "on_error",
      palette: /* @__PURE__ */ c((e) => e.errorPalette, "palette"),
      background: /* @__PURE__ */ c((e) => e.platform === "phone" ? this.error() : this.errorDim(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" ? bt(6) : bt(7), "contrastCurve")
    });
    return Tt(super.onError(), "2025", t);
  }
  errorContainer() {
    const t = F.fromPalette({
      name: "error_container",
      palette: /* @__PURE__ */ c((e) => e.errorPalette, "palette"),
      tone: /* @__PURE__ */ c((e) => e.platform === "watch" ? 30 : e.isDark ? _s(e.errorPalette, 30, 93) : Dt(e.errorPalette, 0, 90), "tone"),
      isBackground: !0,
      background: /* @__PURE__ */ c((e) => e.platform === "phone" ? this.highestSurface(e) : void 0, "background"),
      toneDeltaPair: /* @__PURE__ */ c((e) => e.platform === "watch" ? new Gt(this.errorContainer(), this.errorDim(), 10, "darker", !0, "farther") : void 0, "toneDeltaPair"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" && e.contrastLevel > 0 ? bt(1.5) : void 0, "contrastCurve")
    });
    return Tt(super.errorContainer(), "2025", t);
  }
  onErrorContainer() {
    const t = F.fromPalette({
      name: "on_error_container",
      palette: /* @__PURE__ */ c((e) => e.errorPalette, "palette"),
      background: /* @__PURE__ */ c((e) => this.errorContainer(), "background"),
      contrastCurve: /* @__PURE__ */ c((e) => e.platform === "phone" ? bt(4.5) : bt(7), "contrastCurve")
    });
    return Tt(super.onErrorContainer(), "2025", t);
  }
  /////////////////////////////////////////////////////////////////
  // Remapped Colors                                             //
  /////////////////////////////////////////////////////////////////
  surfaceVariant() {
    const t = Object.assign(this.surfaceContainerHighest().clone(), { name: "surface_variant" });
    return Tt(super.surfaceVariant(), "2025", t);
  }
  surfaceTint() {
    const t = Object.assign(this.primary().clone(), { name: "surface_tint" });
    return Tt(super.surfaceTint(), "2025", t);
  }
  background() {
    const t = Object.assign(this.surface().clone(), { name: "background" });
    return Tt(super.background(), "2025", t);
  }
  onBackground() {
    const t = Object.assign(this.onSurface().clone(), {
      name: "on_background",
      tone: /* @__PURE__ */ c((e) => e.platform === "watch" ? 100 : this.onSurface().getTone(e), "tone")
    });
    return Tt(super.onBackground(), "2025", t);
  }
}, h(Cp, "Jy"), Cp);
c(iz, "ColorSpecDelegateImpl2025");
let Fj = iz;
var ot;
const rz = (ot = class {
  constructor() {
    this.allColors = [
      this.background(),
      this.onBackground(),
      this.surface(),
      this.surfaceDim(),
      this.surfaceBright(),
      this.surfaceContainerLowest(),
      this.surfaceContainerLow(),
      this.surfaceContainer(),
      this.surfaceContainerHigh(),
      this.surfaceContainerHighest(),
      this.onSurface(),
      this.onSurfaceVariant(),
      this.outline(),
      this.outlineVariant(),
      this.inverseSurface(),
      this.inverseOnSurface(),
      this.primary(),
      this.primaryDim(),
      this.onPrimary(),
      this.primaryContainer(),
      this.onPrimaryContainer(),
      this.primaryFixed(),
      this.primaryFixedDim(),
      this.onPrimaryFixed(),
      this.onPrimaryFixedVariant(),
      this.inversePrimary(),
      this.secondary(),
      this.secondaryDim(),
      this.onSecondary(),
      this.secondaryContainer(),
      this.onSecondaryContainer(),
      this.secondaryFixed(),
      this.secondaryFixedDim(),
      this.onSecondaryFixed(),
      this.onSecondaryFixedVariant(),
      this.tertiary(),
      this.tertiaryDim(),
      this.onTertiary(),
      this.tertiaryContainer(),
      this.onTertiaryContainer(),
      this.tertiaryFixed(),
      this.tertiaryFixedDim(),
      this.onTertiaryFixed(),
      this.onTertiaryFixedVariant(),
      this.error(),
      this.errorDim(),
      this.onError(),
      this.errorContainer(),
      this.onErrorContainer()
    ].filter((t) => t !== void 0);
  }
  highestSurface(t) {
    return ot.colorSpec.highestSurface(t);
  }
  ////////////////////////////////////////////////////////////////
  // Main Palettes                                              //
  ////////////////////////////////////////////////////////////////
  primaryPaletteKeyColor() {
    return ot.colorSpec.primaryPaletteKeyColor();
  }
  secondaryPaletteKeyColor() {
    return ot.colorSpec.secondaryPaletteKeyColor();
  }
  tertiaryPaletteKeyColor() {
    return ot.colorSpec.tertiaryPaletteKeyColor();
  }
  neutralPaletteKeyColor() {
    return ot.colorSpec.neutralPaletteKeyColor();
  }
  neutralVariantPaletteKeyColor() {
    return ot.colorSpec.neutralVariantPaletteKeyColor();
  }
  errorPaletteKeyColor() {
    return ot.colorSpec.errorPaletteKeyColor();
  }
  ////////////////////////////////////////////////////////////////
  // Surfaces [S]                                               //
  ////////////////////////////////////////////////////////////////
  background() {
    return ot.colorSpec.background();
  }
  onBackground() {
    return ot.colorSpec.onBackground();
  }
  surface() {
    return ot.colorSpec.surface();
  }
  surfaceDim() {
    return ot.colorSpec.surfaceDim();
  }
  surfaceBright() {
    return ot.colorSpec.surfaceBright();
  }
  surfaceContainerLowest() {
    return ot.colorSpec.surfaceContainerLowest();
  }
  surfaceContainerLow() {
    return ot.colorSpec.surfaceContainerLow();
  }
  surfaceContainer() {
    return ot.colorSpec.surfaceContainer();
  }
  surfaceContainerHigh() {
    return ot.colorSpec.surfaceContainerHigh();
  }
  surfaceContainerHighest() {
    return ot.colorSpec.surfaceContainerHighest();
  }
  onSurface() {
    return ot.colorSpec.onSurface();
  }
  surfaceVariant() {
    return ot.colorSpec.surfaceVariant();
  }
  onSurfaceVariant() {
    return ot.colorSpec.onSurfaceVariant();
  }
  outline() {
    return ot.colorSpec.outline();
  }
  outlineVariant() {
    return ot.colorSpec.outlineVariant();
  }
  inverseSurface() {
    return ot.colorSpec.inverseSurface();
  }
  inverseOnSurface() {
    return ot.colorSpec.inverseOnSurface();
  }
  shadow() {
    return ot.colorSpec.shadow();
  }
  scrim() {
    return ot.colorSpec.scrim();
  }
  surfaceTint() {
    return ot.colorSpec.surfaceTint();
  }
  ////////////////////////////////////////////////////////////////
  // Primaries [P]                                              //
  ////////////////////////////////////////////////////////////////
  primary() {
    return ot.colorSpec.primary();
  }
  primaryDim() {
    return ot.colorSpec.primaryDim();
  }
  onPrimary() {
    return ot.colorSpec.onPrimary();
  }
  primaryContainer() {
    return ot.colorSpec.primaryContainer();
  }
  onPrimaryContainer() {
    return ot.colorSpec.onPrimaryContainer();
  }
  inversePrimary() {
    return ot.colorSpec.inversePrimary();
  }
  /////////////////////////////////////////////////////////////////
  // Primary Fixed [PF]                                          //
  /////////////////////////////////////////////////////////////////
  primaryFixed() {
    return ot.colorSpec.primaryFixed();
  }
  primaryFixedDim() {
    return ot.colorSpec.primaryFixedDim();
  }
  onPrimaryFixed() {
    return ot.colorSpec.onPrimaryFixed();
  }
  onPrimaryFixedVariant() {
    return ot.colorSpec.onPrimaryFixedVariant();
  }
  ////////////////////////////////////////////////////////////////
  // Secondaries [Q]                                            //
  ////////////////////////////////////////////////////////////////
  secondary() {
    return ot.colorSpec.secondary();
  }
  secondaryDim() {
    return ot.colorSpec.secondaryDim();
  }
  onSecondary() {
    return ot.colorSpec.onSecondary();
  }
  secondaryContainer() {
    return ot.colorSpec.secondaryContainer();
  }
  onSecondaryContainer() {
    return ot.colorSpec.onSecondaryContainer();
  }
  /////////////////////////////////////////////////////////////////
  // Secondary Fixed [QF]                                        //
  /////////////////////////////////////////////////////////////////
  secondaryFixed() {
    return ot.colorSpec.secondaryFixed();
  }
  secondaryFixedDim() {
    return ot.colorSpec.secondaryFixedDim();
  }
  onSecondaryFixed() {
    return ot.colorSpec.onSecondaryFixed();
  }
  onSecondaryFixedVariant() {
    return ot.colorSpec.onSecondaryFixedVariant();
  }
  ////////////////////////////////////////////////////////////////
  // Tertiaries [T]                                             //
  ////////////////////////////////////////////////////////////////
  tertiary() {
    return ot.colorSpec.tertiary();
  }
  tertiaryDim() {
    return ot.colorSpec.tertiaryDim();
  }
  onTertiary() {
    return ot.colorSpec.onTertiary();
  }
  tertiaryContainer() {
    return ot.colorSpec.tertiaryContainer();
  }
  onTertiaryContainer() {
    return ot.colorSpec.onTertiaryContainer();
  }
  /////////////////////////////////////////////////////////////////
  // Tertiary Fixed [TF]                                         //
  /////////////////////////////////////////////////////////////////
  tertiaryFixed() {
    return ot.colorSpec.tertiaryFixed();
  }
  tertiaryFixedDim() {
    return ot.colorSpec.tertiaryFixedDim();
  }
  onTertiaryFixed() {
    return ot.colorSpec.onTertiaryFixed();
  }
  onTertiaryFixedVariant() {
    return ot.colorSpec.onTertiaryFixedVariant();
  }
  ////////////////////////////////////////////////////////////////
  // Errors [E]                                                 //
  ////////////////////////////////////////////////////////////////
  error() {
    return ot.colorSpec.error();
  }
  errorDim() {
    return ot.colorSpec.errorDim();
  }
  onError() {
    return ot.colorSpec.onError();
  }
  errorContainer() {
    return ot.colorSpec.errorContainer();
  }
  onErrorContainer() {
    return ot.colorSpec.onErrorContainer();
  }
  // Static variables are deprecated. Use the instance methods to get correct
  // specs based on request.
  /** @deprecated Use highestSurface() instead. */
  static highestSurface(t) {
    return ot.colorSpec.highestSurface(t);
  }
}, h(ot, "G"), ot);
c(rz, "MaterialDynamicColors");
let B = rz;
B.contentAccentToneDelta = 15;
B.colorSpec = new Fj();
B.primaryPaletteKeyColor = B.colorSpec.primaryPaletteKeyColor();
B.secondaryPaletteKeyColor = B.colorSpec.secondaryPaletteKeyColor();
B.tertiaryPaletteKeyColor = B.colorSpec.tertiaryPaletteKeyColor();
B.neutralPaletteKeyColor = B.colorSpec.neutralPaletteKeyColor();
B.neutralVariantPaletteKeyColor = B.colorSpec.neutralVariantPaletteKeyColor();
B.background = B.colorSpec.background();
B.onBackground = B.colorSpec.onBackground();
B.surface = B.colorSpec.surface();
B.surfaceDim = B.colorSpec.surfaceDim();
B.surfaceBright = B.colorSpec.surfaceBright();
B.surfaceContainerLowest = B.colorSpec.surfaceContainerLowest();
B.surfaceContainerLow = B.colorSpec.surfaceContainerLow();
B.surfaceContainer = B.colorSpec.surfaceContainer();
B.surfaceContainerHigh = B.colorSpec.surfaceContainerHigh();
B.surfaceContainerHighest = B.colorSpec.surfaceContainerHighest();
B.onSurface = B.colorSpec.onSurface();
B.surfaceVariant = B.colorSpec.surfaceVariant();
B.onSurfaceVariant = B.colorSpec.onSurfaceVariant();
B.inverseSurface = B.colorSpec.inverseSurface();
B.inverseOnSurface = B.colorSpec.inverseOnSurface();
B.outline = B.colorSpec.outline();
B.outlineVariant = B.colorSpec.outlineVariant();
B.shadow = B.colorSpec.shadow();
B.scrim = B.colorSpec.scrim();
B.surfaceTint = B.colorSpec.surfaceTint();
B.primary = B.colorSpec.primary();
B.onPrimary = B.colorSpec.onPrimary();
B.primaryContainer = B.colorSpec.primaryContainer();
B.onPrimaryContainer = B.colorSpec.onPrimaryContainer();
B.inversePrimary = B.colorSpec.inversePrimary();
B.secondary = B.colorSpec.secondary();
B.onSecondary = B.colorSpec.onSecondary();
B.secondaryContainer = B.colorSpec.secondaryContainer();
B.onSecondaryContainer = B.colorSpec.onSecondaryContainer();
B.tertiary = B.colorSpec.tertiary();
B.onTertiary = B.colorSpec.onTertiary();
B.tertiaryContainer = B.colorSpec.tertiaryContainer();
B.onTertiaryContainer = B.colorSpec.onTertiaryContainer();
B.error = B.colorSpec.error();
B.onError = B.colorSpec.onError();
B.errorContainer = B.colorSpec.errorContainer();
B.onErrorContainer = B.colorSpec.onErrorContainer();
B.primaryFixed = B.colorSpec.primaryFixed();
B.primaryFixedDim = B.colorSpec.primaryFixedDim();
B.onPrimaryFixed = B.colorSpec.onPrimaryFixed();
B.onPrimaryFixedVariant = B.colorSpec.onPrimaryFixedVariant();
B.secondaryFixed = B.colorSpec.secondaryFixed();
B.secondaryFixedDim = B.colorSpec.secondaryFixedDim();
B.onSecondaryFixed = B.colorSpec.onSecondaryFixed();
B.onSecondaryFixedVariant = B.colorSpec.onSecondaryFixedVariant();
B.tertiaryFixed = B.colorSpec.tertiaryFixed();
B.tertiaryFixedDim = B.colorSpec.tertiaryFixedDim();
B.onTertiaryFixed = B.colorSpec.onTertiaryFixed();
B.onTertiaryFixedVariant = B.colorSpec.onTertiaryFixedVariant();
var ha;
const sz = (ha = class {
  static maybeFallbackSpecVersion(t, e) {
    switch (e) {
      case I.EXPRESSIVE:
      case I.VIBRANT:
      case I.TONAL_SPOT:
      case I.NEUTRAL:
        return t;
      default:
        return "2021";
    }
  }
  constructor(t) {
    this.sourceColorArgb = t.sourceColorHct.toInt(), this.variant = t.variant, this.contrastLevel = t.contrastLevel, this.isDark = t.isDark, this.platform = t.platform ?? "phone", this.specVersion = ha.maybeFallbackSpecVersion(t.specVersion ?? "2021", this.variant), this.sourceColorHct = t.sourceColorHct, this.primaryPalette = t.primaryPalette ?? so(this.specVersion).getPrimaryPalette(this.variant, t.sourceColorHct, this.isDark, this.platform, this.contrastLevel), this.secondaryPalette = t.secondaryPalette ?? so(this.specVersion).getSecondaryPalette(this.variant, t.sourceColorHct, this.isDark, this.platform, this.contrastLevel), this.tertiaryPalette = t.tertiaryPalette ?? so(this.specVersion).getTertiaryPalette(this.variant, t.sourceColorHct, this.isDark, this.platform, this.contrastLevel), this.neutralPalette = t.neutralPalette ?? so(this.specVersion).getNeutralPalette(this.variant, t.sourceColorHct, this.isDark, this.platform, this.contrastLevel), this.neutralVariantPalette = t.neutralVariantPalette ?? so(this.specVersion).getNeutralVariantPalette(this.variant, t.sourceColorHct, this.isDark, this.platform, this.contrastLevel), this.errorPalette = t.errorPalette ?? so(this.specVersion).getErrorPalette(this.variant, t.sourceColorHct, this.isDark, this.platform, this.contrastLevel) ?? G.fromHueAndChroma(25, 84), this.colors = new B();
  }
  toString() {
    return `Scheme: variant=${I[this.variant]}, mode=${this.isDark ? "dark" : "light"}, platform=${this.platform}, contrastLevel=${this.contrastLevel.toFixed(1)}, seed=${this.sourceColorHct.toString()}, specVersion=${this.specVersion}`;
  }
  /**
   * Returns a new hue based on a piecewise function and input color hue.
   *
   * For example, for the following function:
   * result = 26 if 0 <= hue < 101
   * result = 39 if 101 <= hue < 210
   * result = 28 if 210 <= hue < 360
   *
   * call the function as:
   *
   * const hueBreakpoints = [0, 101, 210, 360];
   * const hues = [26, 39, 28];
   * const result = scheme.piecewise(hue, hueBreakpoints, hues);
   *
   * @param sourceColorHct The input value.
   * @param hueBreakpoints The breakpoints, in sorted order. No default lower or
   *     upper bounds are assumed.
   * @param hues The hues that should be applied when source color's hue is >=
   *     the same index in hueBrakpoints array, and < the hue at the next index
   *     in hueBrakpoints array. Otherwise, the source color's hue is returned.
   */
  static getPiecewiseHue(t, e, i) {
    const r = Math.min(e.length - 1, i.length), n = t.hue;
    for (let a = 0; a < r; a++)
      if (n >= e[a] && n < e[a + 1])
        return Qi(i[a]);
    return n;
  }
  /**
   * Returns a shifted hue based on a piecewise function and input color hue.
   *
   * For example, for the following function:
   * result = hue + 26 if 0 <= hue < 101
   * result = hue - 39 if 101 <= hue < 210
   * result = hue + 28 if 210 <= hue < 360
   *
   * call the function as:
   *
   * const hueBreakpoints = [0, 101, 210, 360];
   * const hues = [26, -39, 28];
   * const result = scheme.getRotatedHue(hue, hueBreakpoints, hues);
   *
   * @param sourceColorHct the source color of the theme, in HCT.
   * @param hueBreakpoints The "breakpoints", i.e. the hues at which a rotation
   *     should be apply. No default lower or upper bounds are assumed.
   * @param rotations The rotation that should be applied when source color's
   *     hue is >= the same index in hues array, and < the hue at the next
   *     index in hues array. Otherwise, the source color's hue is returned.
   */
  static getRotatedHue(t, e, i) {
    let r = ha.getPiecewiseHue(t, e, i);
    return Math.min(e.length - 1, i.length) <= 0 && (r = 0), Qi(t.hue + r);
  }
  getArgb(t) {
    return t.getArgb(this);
  }
  getHct(t) {
    return t.getHct(this);
  }
  // Palette key colors
  get primaryPaletteKeyColor() {
    return this.getArgb(this.colors.primaryPaletteKeyColor());
  }
  get secondaryPaletteKeyColor() {
    return this.getArgb(this.colors.secondaryPaletteKeyColor());
  }
  get tertiaryPaletteKeyColor() {
    return this.getArgb(this.colors.tertiaryPaletteKeyColor());
  }
  get neutralPaletteKeyColor() {
    return this.getArgb(this.colors.neutralPaletteKeyColor());
  }
  get neutralVariantPaletteKeyColor() {
    return this.getArgb(this.colors.neutralVariantPaletteKeyColor());
  }
  get errorPaletteKeyColor() {
    return this.getArgb(this.colors.errorPaletteKeyColor());
  }
  // Surface colors
  get background() {
    return this.getArgb(this.colors.background());
  }
  get onBackground() {
    return this.getArgb(this.colors.onBackground());
  }
  get surface() {
    return this.getArgb(this.colors.surface());
  }
  get surfaceDim() {
    return this.getArgb(this.colors.surfaceDim());
  }
  get surfaceBright() {
    return this.getArgb(this.colors.surfaceBright());
  }
  get surfaceContainerLowest() {
    return this.getArgb(this.colors.surfaceContainerLowest());
  }
  get surfaceContainerLow() {
    return this.getArgb(this.colors.surfaceContainerLow());
  }
  get surfaceContainer() {
    return this.getArgb(this.colors.surfaceContainer());
  }
  get surfaceContainerHigh() {
    return this.getArgb(this.colors.surfaceContainerHigh());
  }
  get surfaceContainerHighest() {
    return this.getArgb(this.colors.surfaceContainerHighest());
  }
  get onSurface() {
    return this.getArgb(this.colors.onSurface());
  }
  get surfaceVariant() {
    return this.getArgb(this.colors.surfaceVariant());
  }
  get onSurfaceVariant() {
    return this.getArgb(this.colors.onSurfaceVariant());
  }
  get inverseSurface() {
    return this.getArgb(this.colors.inverseSurface());
  }
  get inverseOnSurface() {
    return this.getArgb(this.colors.inverseOnSurface());
  }
  get outline() {
    return this.getArgb(this.colors.outline());
  }
  get outlineVariant() {
    return this.getArgb(this.colors.outlineVariant());
  }
  get shadow() {
    return this.getArgb(this.colors.shadow());
  }
  get scrim() {
    return this.getArgb(this.colors.scrim());
  }
  get surfaceTint() {
    return this.getArgb(this.colors.surfaceTint());
  }
  // Primary colors
  get primary() {
    return this.getArgb(this.colors.primary());
  }
  get primaryDim() {
    const t = this.colors.primaryDim();
    if (t === void 0)
      throw new Error("`primaryDim` color is undefined prior to 2025 spec.");
    return this.getArgb(t);
  }
  get onPrimary() {
    return this.getArgb(this.colors.onPrimary());
  }
  get primaryContainer() {
    return this.getArgb(this.colors.primaryContainer());
  }
  get onPrimaryContainer() {
    return this.getArgb(this.colors.onPrimaryContainer());
  }
  get primaryFixed() {
    return this.getArgb(this.colors.primaryFixed());
  }
  get primaryFixedDim() {
    return this.getArgb(this.colors.primaryFixedDim());
  }
  get onPrimaryFixed() {
    return this.getArgb(this.colors.onPrimaryFixed());
  }
  get onPrimaryFixedVariant() {
    return this.getArgb(this.colors.onPrimaryFixedVariant());
  }
  get inversePrimary() {
    return this.getArgb(this.colors.inversePrimary());
  }
  // Secondary colors
  get secondary() {
    return this.getArgb(this.colors.secondary());
  }
  get secondaryDim() {
    const t = this.colors.secondaryDim();
    if (t === void 0)
      throw new Error("`secondaryDim` color is undefined prior to 2025 spec.");
    return this.getArgb(t);
  }
  get onSecondary() {
    return this.getArgb(this.colors.onSecondary());
  }
  get secondaryContainer() {
    return this.getArgb(this.colors.secondaryContainer());
  }
  get onSecondaryContainer() {
    return this.getArgb(this.colors.onSecondaryContainer());
  }
  get secondaryFixed() {
    return this.getArgb(this.colors.secondaryFixed());
  }
  get secondaryFixedDim() {
    return this.getArgb(this.colors.secondaryFixedDim());
  }
  get onSecondaryFixed() {
    return this.getArgb(this.colors.onSecondaryFixed());
  }
  get onSecondaryFixedVariant() {
    return this.getArgb(this.colors.onSecondaryFixedVariant());
  }
  // Tertiary colors
  get tertiary() {
    return this.getArgb(this.colors.tertiary());
  }
  get tertiaryDim() {
    const t = this.colors.tertiaryDim();
    if (t === void 0)
      throw new Error("`tertiaryDim` color is undefined prior to 2025 spec.");
    return this.getArgb(t);
  }
  get onTertiary() {
    return this.getArgb(this.colors.onTertiary());
  }
  get tertiaryContainer() {
    return this.getArgb(this.colors.tertiaryContainer());
  }
  get onTertiaryContainer() {
    return this.getArgb(this.colors.onTertiaryContainer());
  }
  get tertiaryFixed() {
    return this.getArgb(this.colors.tertiaryFixed());
  }
  get tertiaryFixedDim() {
    return this.getArgb(this.colors.tertiaryFixedDim());
  }
  get onTertiaryFixed() {
    return this.getArgb(this.colors.onTertiaryFixed());
  }
  get onTertiaryFixedVariant() {
    return this.getArgb(this.colors.onTertiaryFixedVariant());
  }
  // Error colors
  get error() {
    return this.getArgb(this.colors.error());
  }
  get errorDim() {
    const t = this.colors.errorDim();
    if (t === void 0)
      throw new Error("`errorDim` color is undefined prior to 2025 spec.");
    return this.getArgb(t);
  }
  get onError() {
    return this.getArgb(this.colors.onError());
  }
  get errorContainer() {
    return this.getArgb(this.colors.errorContainer());
  }
  get onErrorContainer() {
    return this.getArgb(this.colors.onErrorContainer());
  }
}, h(ha, "wl"), ha);
c(sz, "DynamicScheme");
let wi = sz;
wi.DEFAULT_SPEC_VERSION = "2021";
wi.DEFAULT_PLATFORM = "phone";
var Pp;
const nz = (Pp = class {
  //////////////////////////////////////////////////////////////////
  // Scheme Palettes                                              //
  //////////////////////////////////////////////////////////////////
  getPrimaryPalette(t, e, i, r, n) {
    switch (t) {
      case I.CONTENT:
      case I.FIDELITY:
        return G.fromHueAndChroma(e.hue, e.chroma);
      case I.FRUIT_SALAD:
        return G.fromHueAndChroma(Qi(e.hue - 50), 48);
      case I.MONOCHROME:
        return G.fromHueAndChroma(e.hue, 0);
      case I.NEUTRAL:
        return G.fromHueAndChroma(e.hue, 12);
      case I.RAINBOW:
        return G.fromHueAndChroma(e.hue, 48);
      case I.TONAL_SPOT:
        return G.fromHueAndChroma(e.hue, 36);
      case I.EXPRESSIVE:
        return G.fromHueAndChroma(Qi(e.hue + 240), 40);
      case I.VIBRANT:
        return G.fromHueAndChroma(e.hue, 200);
      default:
        throw new Error(`Unsupported variant: ${t}`);
    }
  }
  getSecondaryPalette(t, e, i, r, n) {
    switch (t) {
      case I.CONTENT:
      case I.FIDELITY:
        return G.fromHueAndChroma(e.hue, Math.max(e.chroma - 32, e.chroma * 0.5));
      case I.FRUIT_SALAD:
        return G.fromHueAndChroma(Qi(e.hue - 50), 36);
      case I.MONOCHROME:
        return G.fromHueAndChroma(e.hue, 0);
      case I.NEUTRAL:
        return G.fromHueAndChroma(e.hue, 8);
      case I.RAINBOW:
        return G.fromHueAndChroma(e.hue, 16);
      case I.TONAL_SPOT:
        return G.fromHueAndChroma(e.hue, 16);
      case I.EXPRESSIVE:
        return G.fromHueAndChroma(wi.getRotatedHue(e, [0, 21, 51, 121, 151, 191, 271, 321, 360], [45, 95, 45, 20, 45, 90, 45, 45, 45]), 24);
      case I.VIBRANT:
        return G.fromHueAndChroma(wi.getRotatedHue(e, [0, 41, 61, 101, 131, 181, 251, 301, 360], [18, 15, 10, 12, 15, 18, 15, 12, 12]), 24);
      default:
        throw new Error(`Unsupported variant: ${t}`);
    }
  }
  getTertiaryPalette(t, e, i, r, n) {
    switch (t) {
      case I.CONTENT:
        return G.fromHct(bS.fixIfDisliked(new g9(e).analogous(
          /* count= */
          3,
          /* divisions= */
          6
        )[2]));
      case I.FIDELITY:
        return G.fromHct(bS.fixIfDisliked(new g9(e).complement));
      case I.FRUIT_SALAD:
        return G.fromHueAndChroma(e.hue, 36);
      case I.MONOCHROME:
        return G.fromHueAndChroma(e.hue, 0);
      case I.NEUTRAL:
        return G.fromHueAndChroma(e.hue, 16);
      case I.RAINBOW:
      case I.TONAL_SPOT:
        return G.fromHueAndChroma(Qi(e.hue + 60), 24);
      case I.EXPRESSIVE:
        return G.fromHueAndChroma(wi.getRotatedHue(e, [0, 21, 51, 121, 151, 191, 271, 321, 360], [120, 120, 20, 45, 20, 15, 20, 120, 120]), 32);
      case I.VIBRANT:
        return G.fromHueAndChroma(wi.getRotatedHue(e, [0, 41, 61, 101, 131, 181, 251, 301, 360], [35, 30, 20, 25, 30, 35, 30, 25, 25]), 32);
      default:
        throw new Error(`Unsupported variant: ${t}`);
    }
  }
  getNeutralPalette(t, e, i, r, n) {
    switch (t) {
      case I.CONTENT:
      case I.FIDELITY:
        return G.fromHueAndChroma(e.hue, e.chroma / 8);
      case I.FRUIT_SALAD:
        return G.fromHueAndChroma(e.hue, 10);
      case I.MONOCHROME:
        return G.fromHueAndChroma(e.hue, 0);
      case I.NEUTRAL:
        return G.fromHueAndChroma(e.hue, 2);
      case I.RAINBOW:
        return G.fromHueAndChroma(e.hue, 0);
      case I.TONAL_SPOT:
        return G.fromHueAndChroma(e.hue, 6);
      case I.EXPRESSIVE:
        return G.fromHueAndChroma(Qi(e.hue + 15), 8);
      case I.VIBRANT:
        return G.fromHueAndChroma(e.hue, 10);
      default:
        throw new Error(`Unsupported variant: ${t}`);
    }
  }
  getNeutralVariantPalette(t, e, i, r, n) {
    switch (t) {
      case I.CONTENT:
        return G.fromHueAndChroma(e.hue, e.chroma / 8 + 4);
      case I.FIDELITY:
        return G.fromHueAndChroma(e.hue, e.chroma / 8 + 4);
      case I.FRUIT_SALAD:
        return G.fromHueAndChroma(e.hue, 16);
      case I.MONOCHROME:
        return G.fromHueAndChroma(e.hue, 0);
      case I.NEUTRAL:
        return G.fromHueAndChroma(e.hue, 2);
      case I.RAINBOW:
        return G.fromHueAndChroma(e.hue, 0);
      case I.TONAL_SPOT:
        return G.fromHueAndChroma(e.hue, 8);
      case I.EXPRESSIVE:
        return G.fromHueAndChroma(Qi(e.hue + 15), 12);
      case I.VIBRANT:
        return G.fromHueAndChroma(e.hue, 12);
      default:
        throw new Error(`Unsupported variant: ${t}`);
    }
  }
  getErrorPalette(t, e, i, r, n) {
  }
}, h(Pp, "tw"), Pp);
c(nz, "DynamicSchemePalettesDelegateImpl2021");
let az = nz;
var gi;
const oz = (gi = class extends az {
  //////////////////////////////////////////////////////////////////
  // Scheme Palettes                                              //
  //////////////////////////////////////////////////////////////////
  getPrimaryPalette(t, e, i, r, n) {
    switch (t) {
      case I.NEUTRAL:
        return G.fromHueAndChroma(e.hue, r === "phone" ? Lt.isBlue(e.hue) ? 12 : 8 : Lt.isBlue(e.hue) ? 16 : 12);
      case I.TONAL_SPOT:
        return G.fromHueAndChroma(e.hue, r === "phone" && i ? 26 : 32);
      case I.EXPRESSIVE:
        return G.fromHueAndChroma(e.hue, r === "phone" ? i ? 36 : 48 : 40);
      case I.VIBRANT:
        return G.fromHueAndChroma(e.hue, r === "phone" ? 74 : 56);
      default:
        return super.getPrimaryPalette(t, e, i, r, n);
    }
  }
  getSecondaryPalette(t, e, i, r, n) {
    switch (t) {
      case I.NEUTRAL:
        return G.fromHueAndChroma(e.hue, r === "phone" ? Lt.isBlue(e.hue) ? 6 : 4 : Lt.isBlue(e.hue) ? 10 : 6);
      case I.TONAL_SPOT:
        return G.fromHueAndChroma(e.hue, 16);
      case I.EXPRESSIVE:
        return G.fromHueAndChroma(wi.getRotatedHue(e, [0, 105, 140, 204, 253, 278, 300, 333, 360], [-160, 155, -100, 96, -96, -156, -165, -160]), r === "phone" && i ? 16 : 24);
      case I.VIBRANT:
        return G.fromHueAndChroma(wi.getRotatedHue(e, [0, 38, 105, 140, 333, 360], [-14, 10, -14, 10, -14]), r === "phone" ? 56 : 36);
      default:
        return super.getSecondaryPalette(t, e, i, r, n);
    }
  }
  getTertiaryPalette(t, e, i, r, n) {
    switch (t) {
      case I.NEUTRAL:
        return G.fromHueAndChroma(wi.getRotatedHue(e, [0, 38, 105, 161, 204, 278, 333, 360], [-32, 26, 10, -39, 24, -15, -32]), r === "phone" ? 20 : 36);
      case I.TONAL_SPOT:
        return G.fromHueAndChroma(wi.getRotatedHue(e, [0, 20, 71, 161, 333, 360], [-40, 48, -32, 40, -32]), r === "phone" ? 28 : 32);
      case I.EXPRESSIVE:
        return G.fromHueAndChroma(wi.getRotatedHue(e, [0, 105, 140, 204, 253, 278, 300, 333, 360], [-165, 160, -105, 101, -101, -160, -170, -165]), 48);
      case I.VIBRANT:
        return G.fromHueAndChroma(wi.getRotatedHue(e, [0, 38, 71, 105, 140, 161, 253, 333, 360], [-72, 35, 24, -24, 62, 50, 62, -72]), 56);
      default:
        return super.getTertiaryPalette(t, e, i, r, n);
    }
  }
  static getExpressiveNeutralHue(t) {
    return wi.getRotatedHue(t, [0, 71, 124, 253, 278, 300, 360], [10, 0, 10, 0, 10, 0]);
  }
  static getExpressiveNeutralChroma(t, e, i) {
    const r = gi.getExpressiveNeutralHue(t);
    return i === "phone" ? e ? Lt.isYellow(r) ? 6 : 14 : 18 : 12;
  }
  static getVibrantNeutralHue(t) {
    return wi.getRotatedHue(t, [0, 38, 105, 140, 333, 360], [-14, 10, -14, 10, -14]);
  }
  static getVibrantNeutralChroma(t, e) {
    const i = gi.getVibrantNeutralHue(t);
    return e === "phone" || Lt.isBlue(i) ? 28 : 20;
  }
  getNeutralPalette(t, e, i, r, n) {
    switch (t) {
      case I.NEUTRAL:
        return G.fromHueAndChroma(e.hue, r === "phone" ? 1.4 : 6);
      case I.TONAL_SPOT:
        return G.fromHueAndChroma(e.hue, r === "phone" ? 5 : 10);
      case I.EXPRESSIVE:
        return G.fromHueAndChroma(gi.getExpressiveNeutralHue(e), gi.getExpressiveNeutralChroma(e, i, r));
      case I.VIBRANT:
        return G.fromHueAndChroma(gi.getVibrantNeutralHue(e), gi.getVibrantNeutralChroma(e, r));
      default:
        return super.getNeutralPalette(t, e, i, r, n);
    }
  }
  getNeutralVariantPalette(t, e, i, r, n) {
    switch (t) {
      case I.NEUTRAL:
        return G.fromHueAndChroma(e.hue, (r === "phone" ? 1.4 : 6) * 2.2);
      case I.TONAL_SPOT:
        return G.fromHueAndChroma(e.hue, (r === "phone" ? 5 : 10) * 1.7);
      case I.EXPRESSIVE:
        const a = gi.getExpressiveNeutralHue(e), o = gi.getExpressiveNeutralChroma(e, i, r);
        return G.fromHueAndChroma(a, o * (a >= 105 && a < 125 ? 1.6 : 2.3));
      case I.VIBRANT:
        const l = gi.getVibrantNeutralHue(e), d = gi.getVibrantNeutralChroma(e, r);
        return G.fromHueAndChroma(l, d * 1.29);
      default:
        return super.getNeutralVariantPalette(t, e, i, r, n);
    }
  }
  getErrorPalette(t, e, i, r, n) {
    const a = wi.getPiecewiseHue(e, [0, 3, 13, 23, 33, 43, 153, 273, 360], [12, 22, 32, 12, 22, 32, 22, 12]);
    switch (t) {
      case I.NEUTRAL:
        return G.fromHueAndChroma(a, r === "phone" ? 50 : 40);
      case I.TONAL_SPOT:
        return G.fromHueAndChroma(a, r === "phone" ? 60 : 48);
      case I.EXPRESSIVE:
        return G.fromHueAndChroma(a, r === "phone" ? 64 : 48);
      case I.VIBRANT:
        return G.fromHueAndChroma(a, r === "phone" ? 80 : 60);
      default:
        return super.getErrorPalette(t, e, i, r, n);
    }
  }
}, h(gi, "Xe"), gi);
c(oz, "DynamicSchemePalettesDelegateImpl2025");
let qj = oz;
const Zj = new az(), Bj = new qj();
function so(s) {
  return s === "2025" ? Bj : Zj;
}
h(so, "da");
c(so, "getSpec");
function lz(s) {
  s = s.replace("#", "");
  const t = s.length === 3, e = s.length === 6, i = s.length === 8;
  if (!t && !e && !i)
    throw new Error("unexpected hex " + s);
  let r = 0, n = 0, a = 0;
  return t ? (r = ts(s.slice(0, 1).repeat(2)), n = ts(s.slice(1, 2).repeat(2)), a = ts(s.slice(2, 3).repeat(2))) : e ? (r = ts(s.slice(0, 2)), n = ts(s.slice(2, 4)), a = ts(s.slice(4, 6))) : i && (r = ts(s.slice(2, 4)), n = ts(s.slice(4, 6)), a = ts(s.slice(6, 8))), (255 << 24 | (r & 255) << 16 | (n & 255) << 8 | a & 255) >>> 0;
}
h(lz, "Zg");
c(lz, "argbFromHex");
function ts(s) {
  return parseInt(s, 16);
}
h(ts, "Ni");
c(ts, "parseIntHex");
function cz(s, t = !1) {
  const e = s.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+\.{0,1}\d*))?\)$/)?.slice(1).map((o, l) => l === 3 ? Math.round(parseFloat(o) * 255) : parseFloat(o));
  if (!e)
    throw new Error("Could not parse rgba color.");
  const [i, r, n, a] = e;
  return ((t ? 255 : a & 255) << 24 | (i & 255) << 16 | (r & 255) << 8 | n & 255) >>> 0;
}
h(cz, "Yg");
c(cz, "argbFromRgba");
function Ar(s, t) {
  return Math.round(255 * t) << 24 | s & 16777215;
}
h(Ar, "$i");
c(Ar, "addAlphaToArgb");
function hz(s) {
  const t = $b(s), e = xb(s), i = kb(s), r = RL(s), n = [t.toString(16), e.toString(16), i.toString(16)];
  r !== 255 && n.push(r.toString(16));
  for (const [a, o] of n.entries())
    o.length === 1 && (n[a] = "0" + o);
  return "#" + n.join("");
}
h(hz, "Xg");
c(hz, "hexWithAlphaFromArgb");
function dz(s) {
  Se();
  const t = document.createElement("wy-compute-styles");
  t.setAttribute("style", `color: ${s} !important;`), document.documentElement.append(t);
  const e = window.getComputedStyle(t).color;
  return t.remove(), e;
}
h(dz, "Jg");
c(dz, "getComputedColor");
var Qp;
const uz = (Qp = class extends wi {
  constructor(t, e, i, r = I.FIDELITY) {
    const n = t.chroma, a = Math.min(36, t.chroma * 16 / 36), o = a, l = Math.min(6, t.chroma * 6 / 36), d = Math.min(8, t.chroma * 8 / 36);
    super({
      sourceColorHct: t,
      variant: r,
      contrastLevel: i,
      isDark: e,
      primaryPalette: G.fromHueAndChroma(t.hue, n),
      secondaryPalette: G.fromHueAndChroma(t.hue, a),
      tertiaryPalette: G.fromHueAndChroma(Qi(t.hue - 6 * 22.5), o),
      neutralPalette: G.fromHueAndChroma(t.hue, l),
      neutralVariantPalette: G.fromHueAndChroma(t.hue, d)
    }), this.allTones = {
      //"100": 100,
      98: 98,
      // MD3
      95: 95,
      90: 90,
      80: 80,
      70: 70,
      60: 60,
      50: 50,
      40: 40,
      30: 30,
      20: 20,
      10: 10
      //"0": 0
    }, this.namedColorToneMap = {
      red: { light: 60, dark: 60 },
      "deep-orange": { light: 60, dark: 60 },
      orange: { light: 70, dark: 70 },
      amber: { light: 70, dark: 70 },
      yellow: { light: 70, dark: 80 },
      lime: { light: 70, dark: 70 },
      "light-green": { light: 70, dark: 70 },
      green: { light: 60, dark: 60 },
      teal: { light: 60, dark: 60 },
      cyan: { light: 50, dark: 60 },
      "light-blue": { light: 60, dark: 70 },
      blue: { light: 70, dark: 80 },
      indigo: { light: 60, dark: 60 },
      "deep-purple": { light: 60, dark: 70 },
      purple: { light: 60, dark: 70 },
      pink: { light: 60, dark: 70 },
      gray: { light: 50, dark: 60 }
    };
    const u = t.hue, p = t.chroma, f = Math.max(48, p), y = Math.min(f, 84), g = 360 / 16, O = 27.4, k = -8, $ = (u + 360 - O - k + g / 2) % g + O + k - g / 2;
    this.errorPalette = G.fromHueAndChroma($, 84), this.warningPalette = G.fromHueAndChroma($ + 4 * g, y), this.namedColorPalettes = {
      red: G.fromHueAndChroma($, y),
      "deep-orange": G.fromHueAndChroma($ + 1 * g, y),
      orange: G.fromHueAndChroma($ + 2 * g, y),
      amber: G.fromHueAndChroma($ + 3 * g, y),
      yellow: G.fromHueAndChroma($ + 4 * g, y),
      lime: G.fromHueAndChroma($ + 5 * g, y),
      "light-green": G.fromHueAndChroma($ + 6 * g, y),
      green: G.fromHueAndChroma($ + 7 * g, y),
      teal: G.fromHueAndChroma($ + 8 * g, y),
      cyan: G.fromHueAndChroma($ + 9 * g, y),
      "light-blue": G.fromHueAndChroma($ + 10 * g, y),
      blue: G.fromHueAndChroma($ + 11 * g, y),
      indigo: G.fromHueAndChroma($ + 12 * g, y),
      "deep-purple": G.fromHueAndChroma($ + 13 * g, y),
      purple: G.fromHueAndChroma($ + 14 * g, y),
      pink: G.fromHueAndChroma($ + 15 * g, y),
      gray: G.fromHueAndChroma(u, 4)
    };
  }
  // Solid base colors
  get black() {
    return 0;
  }
  get white() {
    return 16777215;
  }
  // Custom transparency based surface container colors
  get surfaceLayerLowest() {
    return this.isDark ? Ar(this.black, 0.5) : Ar(this.white, 0.75);
  }
  get surfaceLayerLow() {
    return this.isDark ? Ar(this.black, 0.25) : Ar(this.white, 0.5);
  }
  get surfaceLayer() {
    return this.isDark ? Ar(this.white, 0.05) : Ar(this.black, 0.05);
  }
  get surfaceLayerHigh() {
    return this.isDark ? Ar(this.white, 0.1) : Ar(this.black, 0.075);
  }
  get surfaceLayerHighest() {
    return this.isDark ? Ar(this.white, 0.15) : Ar(this.black, 0.1);
  }
  // Custom Tokens
  get warning() {
    return this.warningPalette.tone(this.isDark ? 90 : 70);
  }
  get onWarning() {
    return this.warningPalette.tone(this.isDark ? 30 : 0);
  }
  get warningContainer() {
    return this.warningPalette.tone(this.isDark ? 50 : 90);
  }
  get onWarningContainer() {
    return this.warningPalette.tone(this.isDark ? 95 : 10);
  }
  get highlight() {
    return this.primaryPalette.tone(this.isDark ? 20 : 95);
  }
  get onHighlight() {
    return this.primaryPalette.tone(this.isDark ? 90 : 10);
  }
  // Named colors
  namedColor(t) {
    return this.namedColorPalettes[t].tone(this.namedColorToneMap[t][this.isDark ? "dark" : "light"]);
  }
  get red() {
    return this.namedColor(
      "red"
      /* Red */
    );
  }
  get deepOrange() {
    return this.namedColor(
      "deep-orange"
      /* DeepOrange */
    );
  }
  get orange() {
    return this.namedColor(
      "orange"
      /* Orange */
    );
  }
  get amber() {
    return this.namedColor(
      "amber"
      /* Amber */
    );
  }
  get yellow() {
    return this.namedColor(
      "yellow"
      /* Yellow */
    );
  }
  get lime() {
    return this.namedColor(
      "lime"
      /* Lime */
    );
  }
  get lightGreen() {
    return this.namedColor(
      "light-green"
      /* LightGreen */
    );
  }
  get green() {
    return this.namedColor(
      "green"
      /* Green */
    );
  }
  get teal() {
    return this.namedColor(
      "teal"
      /* Teal */
    );
  }
  get cyan() {
    return this.namedColor(
      "cyan"
      /* Cyan */
    );
  }
  get lightBlue() {
    return this.namedColor(
      "light-blue"
      /* LightBlue */
    );
  }
  get blue() {
    return this.namedColor(
      "blue"
      /* Blue */
    );
  }
  get indigo() {
    return this.namedColor(
      "indigo"
      /* Indigo */
    );
  }
  get deepPurple() {
    return this.namedColor(
      "deep-purple"
      /* DeepPurple */
    );
  }
  get purple() {
    return this.namedColor(
      "purple"
      /* Purple */
    );
  }
  get pink() {
    return this.namedColor(
      "pink"
      /* Pink */
    );
  }
  get gray() {
    return this.namedColor(
      "gray"
      /* Gray */
    );
  }
}, h(Qp, "ew"), Qp);
c(uz, "SchemeWeavy");
let w9 = uz;
function m0(s) {
  return getComputedStyle(s).getPropertyValue("--wy-theme-color") || void 0;
}
h(m0, "xp");
c(m0, "getCSSThemeColor");
function pz(s, t) {
  let e = m0(s);
  const i = new MutationObserver(() => {
    const a = m0(s);
    a !== e && (e = a, t(a));
  }), r = {
    attributes: !0,
    attributeFilter: ["class", "style"]
  };
  let n = s;
  for (; n && n !== document; )
    i.observe(n, r), n = n.parentNode;
  return () => i.disconnect();
}
h(pz, "t0");
c(pz, "observeCSSThemeColor");
function y0() {
  return Se(), Array.from(document.head.querySelectorAll("meta[name='theme-color']")).filter((s) => {
    const t = s.getAttribute("media");
    return !t || window.matchMedia(t)?.matches;
  }).pop()?.getAttribute("content") || void 0;
}
h(y0, "Cp");
c(y0, "getMetaThemeColor");
function fz(s) {
  Se();
  const t = Array.from(document.head.querySelectorAll("meta[name='theme-color']"));
  if (!t)
    return () => {
    };
  let e = y0();
  const i = /* @__PURE__ */ c(() => {
    const o = y0();
    o !== e && (e = o, s(o));
  }, "checkChangedColor"), r = new MutationObserver(i), n = {
    attributes: !0,
    attributeFilter: ["content"]
  }, a = [];
  return t.forEach((o) => {
    r.observe(o, n);
    const l = o.getAttribute("media");
    if (l) {
      const d = window.matchMedia(l);
      d.addEventListener("change", i), a.push(d);
    }
  }), () => {
    r.disconnect(), a.forEach((o) => o.removeEventListener("change", i));
  };
}
h(fz, "e0");
c(fz, "observeMetaThemeColor");
const kg = [], Nj = 16;
function mz(s, t = !1) {
  if (kg.some((l) => l.seedColor === s)) {
    const l = kg.find((d) => d.seedColor === s)?.colors;
    if (l)
      return l;
  }
  const e = [];
  t && e.push(`--wy-theme-color:${s};`);
  let i = s;
  !s.startsWith("#") && !s.startsWith("rgb") && (i = dz(s));
  const r = s.startsWith("#") ? lz(i) : cz(i), n = Lt.fromInt(r), a = {
    light: new w9(n, !1, 0, I.FIDELITY),
    dark: new w9(n, !0, 0, I.FIDELITY)
  }, o = {
    primary: "primary",
    onPrimary: "on-primary",
    primaryContainer: "primary-container",
    onPrimaryContainer: "on-primary-container",
    secondary: "secondary",
    onSecondary: "on-secondary",
    secondaryContainer: "secondary-container",
    onSecondaryContainer: "on-secondary-container",
    tertiary: "tertiary",
    onTertiary: "on-tertiary",
    tertiaryContainer: "tertiary-container",
    onTertiaryContainer: "on-tertiary-container",
    error: "error",
    onError: "on-error",
    errorContainer: "error-container",
    onErrorContainer: "on-error-container",
    background: "background",
    onBackground: "on-background",
    surface: "surface",
    onSurface: "on-surface",
    surfaceVariant: "surface-variant",
    onSurfaceVariant: "on-surface-variant",
    surfaceContainerLowest: "surface-container-lowest",
    surfaceContainerLow: "surface-container-low",
    surfaceContainer: "surface-container",
    surfaceContainerHigh: "surface-container-high",
    surfaceContainerHighest: "surface-container-highest",
    outline: "outline",
    outlineVariant: "outline-variant",
    shadow: "shadow",
    scrim: "scrim",
    // Custom surface layers
    surfaceLayerLowest: "surface-layer-lowest",
    surfaceLayerLow: "surface-layer-low",
    surfaceLayer: "surface-layer",
    surfaceLayerHigh: "surface-layer-high",
    surfaceLayerHighest: "surface-layer-highest",
    // Custom tokens
    warning: "warning",
    onWarning: "on-warning",
    warningContainer: "warning-container",
    onWarningContainer: "on-warning-container",
    highlight: "highlight",
    onHighlight: "on-highlight",
    // Named colors
    red: "red",
    deepOrange: "deep-orange",
    orange: "orange",
    amber: "amber",
    yellow: "yellow",
    lime: "lime",
    lightGreen: "light-green",
    green: "green",
    teal: "teal",
    cyan: "cyan",
    lightBlue: "light-blue",
    blue: "blue",
    indigo: "indigo",
    deepPurple: "deep-purple",
    purple: "purple",
    pink: "pink",
    gray: "gray"
  };
  for (const l in a) {
    const d = a[l];
    for (const u in o) {
      const p = o[u], f = hz(d[u]);
      e.push(`--wy-${p}-${l}:${f};`);
    }
  }
  return kg.unshift({ seedColor: s, colors: e }), kg.length = Math.min(kg.length, Nj), e;
}
h(mz, "r0");
c(mz, "generateThemeColors");
const Xj = /* @__PURE__ */ c((s) => {
  if (Se(), mb)
    document.adoptedStyleSheets = s.map((t) => t instanceof CSSStyleSheet ? t : t.styleSheet);
  else
    for (const t of s) {
      const e = document.createElement("style"), i = global.litNonce;
      i !== void 0 && e.setAttribute("nonce", i), e.textContent = t.cssText, (document.head || document.documentElement).appendChild(e);
    }
}, "adoptGlobalStyles"), Ie = it`@property --wy-color-scheme{syntax:\"normal | light | dark\";inherits:true;initial-value:normal}:is(.wy-light,[part~=wy-light]) :where(wy-chat),:is(.wy-light,[part~=wy-light]) :where(wy-comments),:is(.wy-light,[part~=wy-light]) :where(wy-component),:is(.wy-light,[part~=wy-light]) :where(wy-copilot),:is(.wy-light,[part~=wy-light]) :where(wy-files),:is(.wy-light,[part~=wy-light]) :where(wy-messenger),:is(.wy-light,[part~=wy-light]) :where(wy-notification-toasts),:is(.wy-light,[part~=wy-light]) :where(wy-notifications),:is(.wy-light,[part~=wy-light]) :where(wy-posts),:host(:is(.wy-light,[part~=wy-light])),:host :is(.wy-light,[part~=wy-light]),::slotted(:is(.wy-light,[part~=wy-light])){color-scheme:light;--wy-primary:var(--wy-primary-light, #2f628c);--wy-on-primary:var(--wy-on-primary-light, #ffffff);--wy-primary-container:var(--wy-primary-container-light, #cee5ff);--wy-on-primary-container:var(--wy-on-primary-container-light, #0d4a73);--wy-secondary:var(--wy-secondary-light, #51606f);--wy-on-secondary:var(--wy-on-secondary-light, #ffffff);--wy-secondary-container:var(--wy-secondary-container-light, #d5e4f7);--wy-on-secondary-container:var(--wy-on-secondary-container-light, #3a4857);--wy-tertiary:var(--wy-tertiary-light, #645f41);--wy-on-tertiary:var(--wy-on-tertiary-light, #ffffff);--wy-tertiary-container:var(--wy-tertiary-container-light, #ebe3bd);--wy-on-tertiary-container:var(--wy-on-tertiary-container-light, #4c472b);--wy-error:var(--wy-error-light, #ba1821);--wy-on-error:var(--wy-on-error-light, #ffffff);--wy-error-container:var(--wy-error-container-light, #ffdad6);--wy-on-error-container:var(--wy-on-error-container-light, #930012);--wy-background:var(--wy-background-light, #f7f9ff);--wy-on-background:var(--wy-on-background-light, #181c20);--wy-surface:var(--wy-surface-light, #f7f9ff);--wy-on-surface:var(--wy-on-surface-light, #181c20);--wy-surface-variant:var(--wy-surface-variant-light, #dee3eb);--wy-on-surface-variant:var(--wy-on-surface-variant-light, #42474e);--wy-outline:var(--wy-outline-light, #72777f);--wy-outline-variant:var(--wy-outline-variant-light, #c2c7cf);--wy-surface-container-highest:var(--wy-surface-container-highest-light, #e0e2e8);--wy-surface-container-high:var(--wy-surface-container-high-light, #e6e8ee);--wy-surface-container:var(--wy-surface-container-light, #eceef3);--wy-surface-container-low:var(--wy-surface-container-low-light, #f1f3f9);--wy-surface-container-lowest:var(--wy-surface-container-lowest-light, #ffffff);--wy-surface-layer-highest:var(--wy-surface-layer-highest-light, rgba(0, 0, 0, .1019607843));--wy-surface-layer-high:var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039));--wy-surface-layer:var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922));--wy-surface-layer-low:var(--wy-surface-layer-low-light, rgba(255, 255, 255, .5019607843));--wy-surface-layer-lowest:var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078));--wy-warning:var(--wy-warning-light, #adb140);--wy-on-warning:var(--wy-on-warning-light, #000000);--wy-warning-container:var(--wy-warning-container-light, #e5e972);--wy-on-warning-container:var(--wy-on-warning-container-light, #1c1d00);--wy-highlight:var(--wy-highlight-light, #e8f2ff);--wy-on-highlight:var(--wy-on-highlight-light, #001d32);--wy-link:var(--wy-primary-light, #2f628c);--wy-presence-active:var(--wy-green-light, #00a38d);--wy-shade:var(--wy-shade-light, rgba(0, 0, 0, .3));--wy-shade-invert:var(--wy-shade-invert-light, rgba(255, 255, 255, .15));--wy-shade-opaque:var(--wy-shade-opaque-light, white);--wy-blue:var(--wy-blue-light, #8aa9fc);--wy-indigo:var(--wy-indigo-light, #9285de);--wy-purple:var(--wy-purple-light, #c675b6);--wy-pink:var(--wy-pink-light, #d57193);--wy-red:var(--wy-red-light, #db726b);--wy-orange:var(--wy-orange-light, #e79b3a);--wy-yellow:var(--wy-yellow-light, #adb140);--wy-green:var(--wy-green-light, #00a38d);--wy-teal:var(--wy-teal-light, #00a0a9);--wy-cyan:var(--wy-cyan-light, #0081a2);--wy-gray:var(--wy-gray-light, #76777a);--wy-code-text:var(--wy-code-text-light, #3b3b3b);--wy-code-variable:var(--wy-code-variable-light, #001080);--wy-code-operator:var(--wy-code-operator-light, #000000);--wy-code-prolog:var(--wy-code-prolog-light, #000080);--wy-code-comment:var(--wy-code-comment-light, #008000);--wy-code-builtin:var(--wy-code-builtin-light, #0070C1);--wy-code-number:var(--wy-code-number-light, #098658);--wy-code-inserted:var(--wy-code-inserted-light, #098658);--wy-code-constant:var(--wy-code-constant-light, #811F3F);--wy-code-hexcode:var(--wy-code-hexcode-light, #811F3F);--wy-code-regex:var(--wy-code-regex-light, #811F3F);--wy-code-char:var(--wy-code-char-light, #811F3F);--wy-code-tag:var(--wy-code-tag-light, #800000);--wy-code-attr-name:var(--wy-code-attr-name-light, #E50000);--wy-code-selector:var(--wy-code-selector-light, #E50000);--wy-code-property:var(--wy-code-property-light, #E50000);--wy-code-deleted:var(--wy-code-deleted-light, #A31515);--wy-code-string:var(--wy-code-string-light, #A31515);--wy-code-changed:var(--wy-code-changed-light, #0451A5);--wy-code-punctuation:var(--wy-code-punctuation-light, #000000);--wy-code-function:var(--wy-code-function-light, #0000FF);--wy-code-keyword:var(--wy-code-keyword-light, #AF00DB);--wy-code-class-name:var(--wy-code-class-name-light, #267F99)}:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-chat),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-comments),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-component),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-copilot),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-files),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-messenger),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-notification-toasts),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-notifications),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-posts),:host(:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light])),:host :is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]),::slotted(:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light])){color-scheme:dark;--wy-primary:var(--wy-primary-dark, #9bcbfa);--wy-on-primary:var(--wy-on-primary-dark, #003353);--wy-primary-container:var(--wy-primary-container-dark, #0d4a73);--wy-on-primary-container:var(--wy-on-primary-container-dark, #cee5ff);--wy-secondary:var(--wy-secondary-dark, #b9c8da);--wy-on-secondary:var(--wy-on-secondary-dark, #233240);--wy-secondary-container:var(--wy-secondary-container-dark, #3a4857);--wy-on-secondary-container:var(--wy-on-secondary-container-dark, #d5e4f7);--wy-tertiary:var(--wy-tertiary-dark, #cfc7a2);--wy-on-tertiary:var(--wy-on-tertiary-dark, #353117);--wy-tertiary-container:var(--wy-tertiary-container-dark, #4c472b);--wy-on-tertiary-container:var(--wy-on-tertiary-container-dark, #ebe3bd);--wy-error:var(--wy-error-dark, #ffb3ad);--wy-on-error:var(--wy-on-error-dark, #680009);--wy-error-container:var(--wy-error-container-dark, #930012);--wy-on-error-container:var(--wy-on-error-container-dark, #ffdad6);--wy-background:var(--wy-background-dark, #101418);--wy-on-background:var(--wy-on-background-dark, #e0e2e8);--wy-surface:var(--wy-surface-dark, #101418);--wy-on-surface:var(--wy-on-surface-dark, #e0e2e8);--wy-surface-variant:var(--wy-surface-variant-dark, #42474e);--wy-on-surface-variant:var(--wy-on-surface-variant-dark, #c2c7cf);--wy-outline:var(--wy-outline-dark, #8c9198);--wy-outline-variant:var(--wy-outline-variant-dark, #42474e);--wy-surface-container-highest:var(--wy-surface-container-highest-dark, #323539);--wy-surface-container-high:var(--wy-surface-container-high-dark, #272a2f);--wy-surface-container:var(--wy-surface-container-dark, #1c2024);--wy-surface-container-low:var(--wy-surface-container-low-dark, #181c20);--wy-surface-container-lowest:var(--wy-surface-container-lowest-dark, #0b0f12);--wy-surface-layer-highest:var(--wy-surface-layer-highest-dark, rgba(255, 255, 255, .1490196078));--wy-surface-layer-high:var(--wy-surface-layer-high-dark, rgba(255, 255, 255, .1019607843));--wy-surface-layer:var(--wy-surface-layer-dark, rgba(255, 255, 255, .0509803922));--wy-surface-layer-low:var(--wy-surface-layer-low-dark, rgba(0, 0, 0, .2509803922));--wy-surface-layer-lowest:var(--wy-surface-layer-lowest-dark, rgba(0, 0, 0, .5019607843));--wy-warning:var(--wy-warning-dark, #e5e972);--wy-on-warning:var(--wy-on-warning-dark, #484a00);--wy-warning-container:var(--wy-warning-container-dark, #787c07);--wy-on-warning-container:var(--wy-on-warning-container-dark, #f4f87e);--wy-highlight:var(--wy-highlight-dark, #003353);--wy-on-highlight:var(--wy-on-highlight-dark, #cee5ff);--wy-link:var(--wy-primary-dark, #9bcbfa);--wy-presence-active:var(--wy-green-dark, #00a38d);--wy-shade:var(--wy-shade-dark, rgba(0, 0, 0, .5));--wy-shade-invert:var(--wy-shade-invert-dark, rgba(255, 255, 255, .25));--wy-shade-opaque:var(--wy-shade-opaque-dark, grey);--wy-blue:var(--wy-blue-dark, #b2c5ff);--wy-indigo:var(--wy-indigo-dark, #9285de);--wy-purple:var(--wy-purple-dark, #e48fd2);--wy-pink:var(--wy-pink-dark, #f58bad);--wy-red:var(--wy-red-dark, #db726b);--wy-orange:var(--wy-orange-dark, #e79b3a);--wy-yellow:var(--wy-yellow-dark, #c9cd59);--wy-green:var(--wy-green-dark, #00a38d);--wy-teal:var(--wy-teal-dark, #00a0a9);--wy-cyan:var(--wy-cyan-dark, #009dc4);--wy-gray:var(--wy-gray-dark, #909194);--wy-code-text:var(--wy-code-text-dark, #cccccc);--wy-code-variable:var(--wy-code-variable-dark, #9CDCFE);--wy-code-operator:var(--wy-code-operator-dark, #d4d4d4);--wy-code-prolog:var(--wy-code-prolog-dark, #569CD6);--wy-code-comment:var(--wy-code-comment-dark, #6a9955);--wy-code-builtin:var(--wy-code-builtin-dark, #4fc1ff);--wy-code-number:var(--wy-code-number-dark, #b5cea8);--wy-code-inserted:var(--wy-code-inserted-dark, #b5cea8);--wy-code-constant:var(--wy-code-constant-dark, #646695);--wy-code-hexcode:var(--wy-code-hexcode-dark, #646695);--wy-code-regex:var(--wy-code-regex-dark, #d16969);--wy-code-char:var(--wy-code-char-dark, #d16969);--wy-code-tag:var(--wy-code-tag-dark, #569cd6);--wy-code-attr-name:var(--wy-code-attr-name-dark, #9cdcfe);--wy-code-selector:var(--wy-code-selector-dark, #9cdcfe);--wy-code-property:var(--wy-code-property-dark, #9cdcfe);--wy-code-deleted:var(--wy-code-deleted-dark, #ce9178);--wy-code-string:var(--wy-code-string-dark, #ce9178);--wy-code-changed:var(--wy-code-changed-dark, #569cd6);--wy-code-punctuation:var(--wy-code-punctuation-dark, #D4D4D4);--wy-code-function:var(--wy-code-function-dark, #569cd6);--wy-code-keyword:var(--wy-code-keyword-dark, #C586C0);--wy-code-class-name:var(--wy-code-class-name-dark, #4ec9b0)}@container style(--wy-color-scheme: dark){:not(.wy-light):not([part~=wy-light]) :where(wy-chat),:not(.wy-light):not([part~=wy-light]) :where(wy-comments),:not(.wy-light):not([part~=wy-light]) :where(wy-component),:not(.wy-light):not([part~=wy-light]) :where(wy-copilot),:not(.wy-light):not([part~=wy-light]) :where(wy-files),:not(.wy-light):not([part~=wy-light]) :where(wy-messenger),:not(.wy-light):not([part~=wy-light]) :where(wy-notification-toasts),:not(.wy-light):not([part~=wy-light]) :where(wy-notifications),:not(.wy-light):not([part~=wy-light]) :where(wy-posts),:host(:not(.wy-light):not([part~=wy-light])),:host :not(.wy-light):not([part~=wy-light]),::slotted(:not(.wy-light):not([part~=wy-light])){color-scheme:dark;--wy-primary:var(--wy-primary-dark, #9bcbfa);--wy-on-primary:var(--wy-on-primary-dark, #003353);--wy-primary-container:var(--wy-primary-container-dark, #0d4a73);--wy-on-primary-container:var(--wy-on-primary-container-dark, #cee5ff);--wy-secondary:var(--wy-secondary-dark, #b9c8da);--wy-on-secondary:var(--wy-on-secondary-dark, #233240);--wy-secondary-container:var(--wy-secondary-container-dark, #3a4857);--wy-on-secondary-container:var(--wy-on-secondary-container-dark, #d5e4f7);--wy-tertiary:var(--wy-tertiary-dark, #cfc7a2);--wy-on-tertiary:var(--wy-on-tertiary-dark, #353117);--wy-tertiary-container:var(--wy-tertiary-container-dark, #4c472b);--wy-on-tertiary-container:var(--wy-on-tertiary-container-dark, #ebe3bd);--wy-error:var(--wy-error-dark, #ffb3ad);--wy-on-error:var(--wy-on-error-dark, #680009);--wy-error-container:var(--wy-error-container-dark, #930012);--wy-on-error-container:var(--wy-on-error-container-dark, #ffdad6);--wy-background:var(--wy-background-dark, #101418);--wy-on-background:var(--wy-on-background-dark, #e0e2e8);--wy-surface:var(--wy-surface-dark, #101418);--wy-on-surface:var(--wy-on-surface-dark, #e0e2e8);--wy-surface-variant:var(--wy-surface-variant-dark, #42474e);--wy-on-surface-variant:var(--wy-on-surface-variant-dark, #c2c7cf);--wy-outline:var(--wy-outline-dark, #8c9198);--wy-outline-variant:var(--wy-outline-variant-dark, #42474e);--wy-surface-container-highest:var(--wy-surface-container-highest-dark, #323539);--wy-surface-container-high:var(--wy-surface-container-high-dark, #272a2f);--wy-surface-container:var(--wy-surface-container-dark, #1c2024);--wy-surface-container-low:var(--wy-surface-container-low-dark, #181c20);--wy-surface-container-lowest:var(--wy-surface-container-lowest-dark, #0b0f12);--wy-surface-layer-highest:var(--wy-surface-layer-highest-dark, rgba(255, 255, 255, .1490196078));--wy-surface-layer-high:var(--wy-surface-layer-high-dark, rgba(255, 255, 255, .1019607843));--wy-surface-layer:var(--wy-surface-layer-dark, rgba(255, 255, 255, .0509803922));--wy-surface-layer-low:var(--wy-surface-layer-low-dark, rgba(0, 0, 0, .2509803922));--wy-surface-layer-lowest:var(--wy-surface-layer-lowest-dark, rgba(0, 0, 0, .5019607843));--wy-warning:var(--wy-warning-dark, #e5e972);--wy-on-warning:var(--wy-on-warning-dark, #484a00);--wy-warning-container:var(--wy-warning-container-dark, #787c07);--wy-on-warning-container:var(--wy-on-warning-container-dark, #f4f87e);--wy-highlight:var(--wy-highlight-dark, #003353);--wy-on-highlight:var(--wy-on-highlight-dark, #cee5ff);--wy-link:var(--wy-primary-dark, #9bcbfa);--wy-presence-active:var(--wy-green-dark, #00a38d);--wy-shade:var(--wy-shade-dark, rgba(0, 0, 0, .5));--wy-shade-invert:var(--wy-shade-invert-dark, rgba(255, 255, 255, .25));--wy-shade-opaque:var(--wy-shade-opaque-dark, grey);--wy-blue:var(--wy-blue-dark, #b2c5ff);--wy-indigo:var(--wy-indigo-dark, #9285de);--wy-purple:var(--wy-purple-dark, #e48fd2);--wy-pink:var(--wy-pink-dark, #f58bad);--wy-red:var(--wy-red-dark, #db726b);--wy-orange:var(--wy-orange-dark, #e79b3a);--wy-yellow:var(--wy-yellow-dark, #c9cd59);--wy-green:var(--wy-green-dark, #00a38d);--wy-teal:var(--wy-teal-dark, #00a0a9);--wy-cyan:var(--wy-cyan-dark, #009dc4);--wy-gray:var(--wy-gray-dark, #909194);--wy-code-text:var(--wy-code-text-dark, #cccccc);--wy-code-variable:var(--wy-code-variable-dark, #9CDCFE);--wy-code-operator:var(--wy-code-operator-dark, #d4d4d4);--wy-code-prolog:var(--wy-code-prolog-dark, #569CD6);--wy-code-comment:var(--wy-code-comment-dark, #6a9955);--wy-code-builtin:var(--wy-code-builtin-dark, #4fc1ff);--wy-code-number:var(--wy-code-number-dark, #b5cea8);--wy-code-inserted:var(--wy-code-inserted-dark, #b5cea8);--wy-code-constant:var(--wy-code-constant-dark, #646695);--wy-code-hexcode:var(--wy-code-hexcode-dark, #646695);--wy-code-regex:var(--wy-code-regex-dark, #d16969);--wy-code-char:var(--wy-code-char-dark, #d16969);--wy-code-tag:var(--wy-code-tag-dark, #569cd6);--wy-code-attr-name:var(--wy-code-attr-name-dark, #9cdcfe);--wy-code-selector:var(--wy-code-selector-dark, #9cdcfe);--wy-code-property:var(--wy-code-property-dark, #9cdcfe);--wy-code-deleted:var(--wy-code-deleted-dark, #ce9178);--wy-code-string:var(--wy-code-string-dark, #ce9178);--wy-code-changed:var(--wy-code-changed-dark, #569cd6);--wy-code-punctuation:var(--wy-code-punctuation-dark, #D4D4D4);--wy-code-function:var(--wy-code-function-dark, #569cd6);--wy-code-keyword:var(--wy-code-keyword-dark, #C586C0);--wy-code-class-name:var(--wy-code-class-name-dark, #4ec9b0)}}`, jj = it`@property --wy-component-color{syntax:\"<color>\";inherits:true;initial-value:currentColor}@property --wy-component-background-color{syntax:\"<color>\";inherits:true;initial-value:rgba(0,0,0,0)}`, Uj = /* @__PURE__ */ c((s) => {
  var e;
  var t;
  return t = (e = class extends s {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), Xj([jj, Ie]);
    }
  }, h(e, "t"), e), c(t, "WeavyStyles"), t;
}, "WeavyStylesMixin"), Hj = /* @__PURE__ */ c((s) => {
  var i;
  var t, e;
  return e = (i = class extends s {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...n) {
      super(...n), q(this, t), this.version = _e.version, this.whenUrl().then(() => {
        this.isDestroyed || this.checkVersion();
      });
    }
    /**
     * Checks the version of the Weavy Context against the Weavy Environment version.
     *
     */
    async checkVersion() {
      return x(this, t) || E(this, t, (async () => {
        await this.whenUrl(), this.networkStateIsPending = !0;
        let n;
        try {
          if (n = await fetch(new URL("/version", this.url), await this.fetchOptions({}, !1)), !n.ok)
            throw new Error(`Could not verify environment version. ${n.status} ${n.statusText}`, {
              cause: n.status
            });
          this.networkStateIsPending = !1, this.serverState = "ok";
        } catch (o) {
          throw this.networkStateIsPending = !1, this.serverState = "unreachable", new Error("Error checking Weavy version: " + o.toString(), { cause: o.cause });
        }
        const a = await n.text();
        if (!this.version || !a || this.version !== a)
          try {
            const o = this.version.split(".").slice(0, 2), l = a.split(".").slice(0, 2);
            if (o[0] !== l[0])
              throw new Error("Major version mismatch", {
                cause: "major"
              });
            if (o[1] !== l[1])
              throw new Error("Minor version mismatch", {
                cause: "minor"
              });
            if (o[2] !== l[2])
              throw new Error("Patch version mismatch", {
                cause: "patch"
              });
          } catch (o) {
            throw new Error(
              `Weavy version mismatch! ${_e.sourceName}@${this.version} ≠ ${this.url?.hostname}@${a} - This will likely cause errors!`,
              {
                cause: {
                  mismatch: o.cause,
                  client: {
                    name: _e.sourceName,
                    version: this.version
                  },
                  environment: {
                    name: this.url?.hostname,
                    version: a
                  }
                }
              }
            );
          } finally {
            E(this, t, void 0);
          }
        else
          console.info(`Weavy version ${this.version} ☑️`);
        return {
          client: {
            name: _e.sourceName,
            version: this.version
          },
          environment: {
            name: this.url?.hostname,
            version: a
          }
        };
      })()), await x(this, t);
    }
  }, h(i, "e"), i), t = /* @__PURE__ */ new WeakMap(), c(e, "WeavyVersion"), e;
}, "WeavyVersionMixin");
var O$, Tp;
let yz = (O$ = (Tp = class extends Event {
  constructor(t, e, i, r) {
    super("context-request", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e, this.callback = i, this.subscribe = r ?? !1;
  }
}, h(Tp, "ts"), Tp), c(O$, "s"), O$);
var b$, Mp;
let $r = (b$ = (Mp = class {
  constructor(t, e, i, r) {
    if (this.subscribe = !1, this.provided = !1, this.value = void 0, this.t = (n, a) => {
      this.unsubscribe && (this.unsubscribe !== a && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = n, this.host.requestUpdate(), this.provided && !this.subscribe || (this.provided = !0, this.callback && this.callback(n, a)), this.unsubscribe = a;
    }, this.host = t, e.context !== void 0) {
      const n = e;
      this.context = n.context, this.callback = n.callback, this.subscribe = n.subscribe ?? !1;
    } else this.context = e, this.callback = i, this.subscribe = r ?? !1;
    this.host.addController(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.host.dispatchEvent(new yz(this.context, this.host, this.t, this.subscribe));
  }
}, h(Mp, "es"), Mp), c(b$, "s"), b$);
var $$, Ap;
let Yj = ($$ = (Ap = class {
  get value() {
    return this.o;
  }
  set value(t) {
    this.setValue(t);
  }
  setValue(t, e = !1) {
    const i = e || !Object.is(t, this.o);
    this.o = t, i && this.updateObservers();
  }
  constructor(t) {
    this.subscriptions = /* @__PURE__ */ new Map(), this.updateObservers = () => {
      for (const [e, { disposer: i }] of this.subscriptions) e(this.o, i);
    }, t !== void 0 && (this.value = t);
  }
  addCallback(t, e, i) {
    if (!i) return void t(this.value);
    this.subscriptions.has(t) || this.subscriptions.set(t, { disposer: /* @__PURE__ */ c(() => {
      this.subscriptions.delete(t);
    }, "disposer"), consumerHost: e });
    const { disposer: r } = this.subscriptions.get(t);
    t(this.value, r);
  }
  clearCallbacks() {
    this.subscriptions.clear();
  }
}, h(Ap, "is"), Ap), c($$, "s"), $$);
var x$, Rp;
let Gj = (x$ = (Rp = class extends Event {
  constructor(t, e) {
    super("context-provider", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e;
  }
}, h(Rp, "rs"), Rp), c(x$, "e"), x$);
var k$, Ep;
let xS = (k$ = (Ep = class extends Yj {
  constructor(t, e, i) {
    super(e.context !== void 0 ? e.initialValue : i), this.onContextRequest = (r) => {
      if (r.context !== this.context) return;
      const n = r.contextTarget ?? r.composedPath()[0];
      n !== this.host && (r.stopPropagation(), this.addCallback(r.callback, n, r.subscribe));
    }, this.onProviderRequest = (r) => {
      if (r.context !== this.context || (r.contextTarget ?? r.composedPath()[0]) === this.host) return;
      const n = /* @__PURE__ */ new Set();
      for (const [a, { consumerHost: o }] of this.subscriptions) n.has(a) || (n.add(a), o.dispatchEvent(new yz(this.context, o, a, !0)));
      r.stopPropagation();
    }, this.host = t, e.context !== void 0 ? this.context = e.context : this.context = e, this.attachListeners(), this.host.addController?.(this);
  }
  attachListeners() {
    this.host.addEventListener("context-request", this.onContextRequest), this.host.addEventListener("context-provider", this.onProviderRequest);
  }
  hostConnected() {
    this.host.dispatchEvent(new Gj(this.context, this.host));
  }
}, h(Ep, "ns"), Ep), c(k$, "i"), k$);
function gn({ context: s }) {
  return (t, e) => {
    const i = /* @__PURE__ */ new WeakMap();
    if (typeof e == "object") return { get() {
      return t.get.call(this);
    }, set(r) {
      return i.get(this).setValue(r), t.set.call(this, r);
    }, init(r) {
      return i.set(this, new xS(this, { context: s, initialValue: r })), r;
    } };
    {
      t.constructor.addInitializer(((a) => {
        i.set(a, new xS(a, { context: s }));
      }));
      const r = Object.getOwnPropertyDescriptor(t, e);
      let n;
      if (r === void 0) {
        const a = /* @__PURE__ */ new WeakMap();
        n = { get() {
          return a.get(this);
        }, set(o) {
          i.get(this).setValue(o), a.set(this, o);
        }, configurable: !0, enumerable: !0 };
      } else {
        const a = r.set;
        n = { ...r, set(o) {
          i.get(this).setValue(o), a?.call(this, o);
        } };
      }
      return void Object.defineProperty(t, e, n);
    }
  };
}
h(gn, "Yr");
c(gn, "e$4");
function Xe({ context: s, subscribe: t }) {
  return (e, i) => {
    typeof i == "object" ? i.addInitializer((function() {
      new $r(this, { context: s, callback: /* @__PURE__ */ c((r) => {
        e.set.call(this, r);
      }, "callback"), subscribe: t });
    })) : e.constructor.addInitializer(((r) => {
      new $r(r, { context: s, callback: /* @__PURE__ */ c((n) => {
        r[i] = n;
      }, "callback"), subscribe: t });
    }));
  };
}
h(Xe, "be");
c(Xe, "c$2");
var _p;
const gz = (_p = class extends Event {
  /**
   *
   * @param context the context key to request
   * @param contextTarget the original context target of the requester
   * @param callback the callback that should be invoked when the context with the specified key is available
   * @param subscribe when, true indicates we want to subscribe to future updates
   */
  constructor(t, e, i, r) {
    super("context-request", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e, this.callback = i, this.subscribe = r ?? !1;
  }
}, h(_p, "iw"), _p);
c(gz, "ContextRequestEvent");
let Kj = gz;
var Lp;
const wz = (Lp = class extends Event {
  /**
   *
   * @param context the context which this provider can provide
   * @param contextTarget the original context target of the provider
   */
  constructor(t, e) {
    super("context-provider", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e;
  }
}, h(Lp, "rw"), Lp);
c(wz, "ContextProviderEvent");
let Jj = wz;
var zp;
const vz = (zp = class extends xS {
  constructor(t, e, i) {
    e.context !== void 0 ? super(t, e) : super(t, e, i), e.context !== void 0 ? this._context = e.context : this._context = e, this.isAttached = !0, this.host instanceof wt || this.dispatchWhenConnected();
  }
  dispatchWhenConnected() {
    this.isAttached && (this.host.isConnected ? this.host.dispatchEvent(new Jj(this._context, this.host)) : requestAnimationFrame(() => this.dispatchWhenConnected()));
  }
  detachListeners() {
    this.isAttached = !1, this.host.removeEventListener("context-request", this.onContextRequest), this.host.removeEventListener("context-provider", this.onProviderRequest);
  }
}, h(zp, "nw"), zp);
c(vz, "WyContextProvider");
let Oz = vz;
const De = Symbol.for("weavy-client");
function bz(s, t) {
  return Se(), new Oz(s, { context: De, initialValue: t });
}
h(bz, "d0");
c(bz, "createWeavyContextProvider");
const Uc = V0() ? bz(document.documentElement) : void 0, tU = /* @__PURE__ */ c((s) => {
  var i;
  var t, e;
  return e = (i = class extends s {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...n) {
      super(...n), q(this, t), this.host !== document.documentElement ? (Uc?.detachListeners(), E(this, t, new Oz(this.host, {
        context: De,
        initialValue: this
      }))) : Uc?.setValue(this);
    }
    updateContext() {
      this.host !== document.documentElement ? x(this, t)?.updateObservers() : Uc?.updateObservers();
    }
    destroy() {
      super.destroy(), this.host !== document.documentElement ? x(this, t)?.detachListeners() : Uc?.value === this && Uc?.setValue(void 0);
    }
  }, h(i, "e"), i), t = /* @__PURE__ */ new WeakMap(), c(e, "WeavyContextProvider"), e;
}, "WeavyContextProviderMixin");
var jv, Uv, Tn, Fg, Ge;
const qg = (Ge = class {
  // CONSTRUCTOR
  constructor(t) {
    q(this, jv), q(this, Uv), q(this, Tn), q(this, Fg), this.weavySid = gy(), this.weavyId = `${Ge.sourceName}#${this.weavySid}`, this.cloudFilePickerUrl = Ge.defaults.cloudFilePickerUrl, this.configurationTimeout = Ge.defaults.configurationTimeout, this.disableEnvironmentImports = Ge.defaults.disableEnvironmentImports, this.gcTime = Ge.defaults.gcTime, this.scrollBehavior = Ge.defaults.scrollBehavior, this.staleTime = Ge.defaults.staleTime, this.tokenFactoryRetryDelay = Ge.defaults.tokenFactoryRetryDelay, this.tokenFactoryTimeout = Ge.defaults.tokenFactoryTimeout, E(this, Uv, new Promise((i) => {
      E(this, jv, i);
    })), E(this, Fg, !1), console.info(`${Ge.sourceName}@${Ge.version} #${this.weavySid}`), Se(), this.host = document.documentElement;
    const e = {};
    for (const i in t) {
      const r = i;
      t[r] !== void 0 && Object.assign(e, { [r]: t[r] });
    }
    e?.host && (this.host = e.host, delete e.host), e && Object.assign(this, e);
  }
  async whenUrl() {
    await x(this, Uv);
  }
  /**
   * The URL to the weavy environment.
   */
  get url() {
    return x(this, Tn);
  }
  set url(t) {
    var e;
    if (this.isDestroyed)
      throw new Ee();
    try {
      if (typeof t == "string")
        t && E(this, Tn, new URL(t, window.location.toString()));
      else if (t instanceof URL)
        E(this, Tn, t || void 0);
      else if (t == null)
        E(this, Tn, void 0);
      else
        throw new Error();
    } catch {
      throw new TypeError("Invalid url");
    }
    t && !this.disableEnvironmentImports && globalThis.WEAVY_IMPORT_URL === void 0 && (globalThis.WEAVY_IMPORT_URL = new URL(
      "./uikit-web/",
      t
    ).href), x(this, Tn) && ((e = x(this, jv)) == null || e.call(this, x(this, Tn)));
  }
  /**
   * Prefix to use for caches.
   */
  get cachePrefix() {
    return `${Ge.version}:${this.url}`;
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async reset() {
    console.info(this.weavyId, "is reset");
  }
  get isDestroyed() {
    return x(this, Fg);
  }
  destroy() {
    E(this, Fg, !0), console.info(this.weavyId, "was destroyed");
  }
}, h(Ge, "we"), Ge);
jv = /* @__PURE__ */ new WeakMap(), Uv = /* @__PURE__ */ new WeakMap(), Tn = /* @__PURE__ */ new WeakMap(), Fg = /* @__PURE__ */ new WeakMap(), c(qg, "WeavyClient"), qg.version = "30.3.0", qg.sourceName = "@weavy/uikit-web", qg.defaults = {
  // StrictWeavyOptions
  cloudFilePickerUrl: "https://filebrowser.weavy.io/v14/",
  configurationTimeout: 5e3,
  disableEnvironmentImports: !1,
  gcTime: 1e3 * 60 * 60 * 24,
  // 24h,
  locale: iL,
  scrollBehavior: "auto",
  staleTime: 1e3 * 1,
  // 1s
  tokenFactoryRetryDelay: 2e3,
  tokenFactoryTimeout: 2e4,
  // WeavyComponentSettingProps
  annotations: "buttons-inline",
  enterToSend: "auto",
  reactions: "😍 😎 😉 😜 👍"
};
let _e = qg;
var Ip;
const $z = (Ip = class extends tU(
  gj(
    mj(
      wj(
        fj(
          Rj(Hj(yj(Uj(Ej(_e)))))
        )
      )
    )
  )
) {
}, h(Ip, "aw"), Ip);
c($z, "Weavy");
let Re = $z;
const e4 = Symbol.for("weavy-app"), xz = Symbol.for("weavy-context-id"), kz = Symbol.for("weavy-data-blobs");
var L = /* @__PURE__ */ ((s) => (s.Attachments = "attachments", s.CloudFiles = "cloud_files", s.ContextData = "context_data", s.Comments = "comments", s.Embeds = "embeds", s.GoogleMeet = "google_meet", s.Meetings = "meetings", s.Mentions = "mentions", s.MicrosoftTeams = "microsoft_teams", s.Polls = "polls", s.Previews = "previews", s.Reactions = "reactions", s.Receipts = "receipts", s.Thumbnails = "thumbnails", s.Typing = "typing", s.Versions = "versions", s.WebDAV = "web_dav", s.ZoomMeetings = "zoom_meetings", s))(L || {});
const Sb = Symbol.for("weavy-features");
var no, Hc, Ls, ol;
const Sz = (ol = class {
  /**
   * Creates a feature policy. All features are initially enabled unless `defaultFeatures` is specified.
   *
   * @constructor
   * @param componentFeatures - Available features.
   */
  constructor(t, e) {
    q(this, no), q(this, Hc), q(this, Ls), E(this, no, Object.keys(t)), E(this, Hc, Object.entries(t).reduce(
      (i, [r, n]) => (n && i.push(r), i),
      []
    )), E(this, Ls, e ?? x(this, Hc));
  }
  features() {
    return x(this, no);
  }
  supportedFeature(...t) {
    return t.every((e) => x(this, no).includes(e));
  }
  allowedFeatures() {
    return x(this, Ls);
  }
  allowsFeature(...t) {
    return t.every((e) => this.supportedFeature(e) ? x(this, Ls).includes(e) : !1);
  }
  allowsAnyFeature(...t) {
    return t.some((e) => this.supportedFeature(e) ? x(this, Ls).includes(e) : !1);
  }
  /**
   * Sets the allowed features.
   * @param allowedFeatures - Space separated string with features that will be enabled. Empty string will disable all features. `null` or `undefined` will enable all features.
   */
  setAllowedFeatures(t) {
    return E(this, Ls, typeof t == "string" ? i4(t, x(this, no)) : x(this, Hc)), x(this, Ls);
  }
  immutable() {
    const t = Cb(x(this, no), x(this, Hc));
    return new ol(t, x(this, Ls));
  }
}, h(ol, "mh"), ol);
no = /* @__PURE__ */ new WeakMap(), Hc = /* @__PURE__ */ new WeakMap(), Ls = /* @__PURE__ */ new WeakMap(), c(Sz, "ComponentFeatures");
let di = Sz;
function i4(s, t) {
  return s.split(" ").filter((e) => {
    if (e) {
      if (t.includes(e))
        return !0;
      console.warn("Unknown feature provided:", e);
    }
    return !1;
  });
}
h(i4, "Am");
c(i4, "featureListFromString");
function Cb(s, t) {
  return t ??= s, Object.fromEntries(
    s.map((e) => [e, t.includes(e)])
  );
}
h(Cb, "ly");
c(Cb, "featureConfigFromList");
const kS = Object.values(L), Cz = Symbol.for("weavy-link");
var Hv, Dp;
const Pz = (Dp = class {
  // PROPERTY INIT
  constructor(t) {
    q(this, Hv), this.enterToSend = _e.defaults.enterToSend, this.reactions = _e.defaults.reactions, this.annotations = _e.defaults.annotations, E(this, Hv, t), Object.keys(this).forEach((e) => {
      e in t && Object.assign(this, { [e]: t[e] });
    });
  }
  /**
   * Provides a reference to the host.
   */
  get component() {
    return x(this, Hv);
  }
}, h(Dp, "sw"), Dp);
Hv = /* @__PURE__ */ new WeakMap(), c(Pz, "WeavyComponentSettings");
let v9 = Pz;
const Qz = Symbol.for("weavy-component-settings"), Pb = Symbol.for("weavy-user");
var Vp;
const Tz = (Vp = class {
  constructor(t, e, i, r, n) {
    if (this.subscribe = !1, this.provided = !1, this.value = void 0, this._callback = (a, o) => {
      this.unsubscribe && (this.unsubscribe !== o && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = a, this.host.requestUpdate(), (!this.provided || this.subscribe) && (this.provided = !0, this.callback && this.callback(a, o)), this.unsubscribe = o;
    }, this.host = t, e.context !== void 0) {
      const a = e;
      this.context = a.context, this.callback = a.callback, this.subscribe = a.subscribe ?? !1, this.ref = a.ref ?? t;
    } else
      this.context = e, this.callback = i, this.subscribe = r ?? !1, this.ref = n ?? t;
    this.host.addController?.(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.ref.dispatchEvent(
      new Kj(
        this.context,
        this.host,
        this._callback,
        this.subscribe
      )
    );
  }
}, h(Vp, "ow"), Vp);
c(Tz, "ContextConsumer");
let eU = Tz;
var Wp;
const Mz = (Wp = class {
  /**
   * @param host - The host element
   * @param context - The Context to use. Should be constructed using createContext().
   */
  constructor(t, e, i) {
    this.whenRef = new Promise((r) => this.resolveRef = r), t.addController(this), this.host = t, this.setRef(i), this.setContext(e);
  }
  /**
   * The DOM connected element that can subscribe to a context
   */
  get ref() {
    return this._ref;
  }
  set ref(t) {
    this._ref = t, t && this.resolveRef?.(t);
  }
  /** 
   * Set the DOM connected element that can subscribe to a context.
   * Wrapper function for React linting compatibility. 
   */
  setRef(t) {
    this.ref = t;
  }
  async setContext(t) {
    this.whenContext = new Promise((i) => this.resolveContext = i);
    const e = await this.whenRef;
    this.context = new eU(this.host, {
      context: t,
      subscribe: !0,
      callback: /* @__PURE__ */ c((i, r) => {
        this.resolveContext?.(i), this.host.requestUpdate();
      }, "callback"),
      ref: e
    }), await NS(e), this.context.dispatchRequest();
  }
  hostUpdate() {
    this.context?.value && this.resolveContext?.(this.context.value);
  }
}, h(Wp, "cw"), Wp);
c(Mz, "ContextController");
let iU = Mz;
var xt = /* @__PURE__ */ ((s) => (s.Chat = "d65dd4bc-418e-403c-9f56-f9cf4da931ed", s.Comments = "88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd", s.Files = "523edd88-4bbf-4547-b60f-2859a6d2ddc1", s.Posts = "5ebfa152-de85-48da-82dd-30a1b560c313", s.ChatRoom = "edb400ac-839b-45a7-b2a8-6a01820d1c44", s.PrivateChat = "7e14f418-8f15-46f4-b182-f619b671e470", s.AgentChat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", s))(xt || {}), Lr = /* @__PURE__ */ ((s) => (s.Chat = "chat", s.Comments = "comments", s.Files = "files", s.Posts = "posts", s.ChatRoom = "chat_room", s.PrivateChat = "private_chat", s.AgentChat = "agent_chat", s))(Lr || {}), Az = /* @__PURE__ */ ((s) => (s["d65dd4bc-418e-403c-9f56-f9cf4da931ed"] = "chat", s["88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd"] = "comments", s["523edd88-4bbf-4547-b60f-2859a6d2ddc1"] = "files", s["5ebfa152-de85-48da-82dd-30a1b560c313"] = "posts", s["edb400ac-839b-45a7-b2a8-6a01820d1c44"] = "chat_room", s["7e14f418-8f15-46f4-b182-f619b671e470"] = "private_chat", s["2352a1c6-abc6-420e-8b85-ca7d5aed8779"] = "agent_chat", s))(Az || {}), Rz = /* @__PURE__ */ ((s) => (s.chat = "d65dd4bc-418e-403c-9f56-f9cf4da931ed", s.comments = "88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd", s.files = "523edd88-4bbf-4547-b60f-2859a6d2ddc1", s.posts = "5ebfa152-de85-48da-82dd-30a1b560c313", s.chat_room = "edb400ac-839b-45a7-b2a8-6a01820d1c44", s.private_chat = "7e14f418-8f15-46f4-b182-f619b671e470", s.agent_chat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", s))(Rz || {}), Ez = /* @__PURE__ */ ((s) => (s["2352a1c6-abc6-420e-8b85-ca7d5aed8779"] = "agent_chat", s))(Ez || {}), _z = /* @__PURE__ */ ((s) => (s.agent_chat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", s))(_z || {}), Ln = /* @__PURE__ */ ((s) => (s.None = "none", s.Read = "read", s.Write = "write", s.Admin = "admin", s))(Ln || {}), ml = /* @__PURE__ */ ((s) => (s.List = "list", s.Read = "read", s.Create = "create", s.Update = "update", s.Delete = "delete", s.Admin = "admin", s))(ml || {}), vi = /* @__PURE__ */ ((s) => (s.App = "app", s.File = "file", s.Message = "message", s.User = "user", s.Comment = "comment", s.Post = "post", s))(vi || {});
function Wy(s, t, e, i, r, n = "GET") {
  return {
    // eslint-disable-next-line @tanstack/query/exhaustive-deps
    queryKey: t,
    queryFn: /* @__PURE__ */ c(async () => {
      const a = await s.fetch(e || "/api/" + t.join("/"), { method: n, body: r });
      if (a.ok)
        return await a.json();
      throw new Error(`Error calling ${e || "/api/" + t.join("/")}`);
    }, "queryFn"),
    ...i
  };
}
h(Wy, "hd");
c(Wy, "getApiOptions");
const Lz = /* @__PURE__ */ c((s) => (t, e) => {
  e !== void 0 ? e.addInitializer((() => {
    customElements.define(s, t);
  })) : customElements.define(s, t);
}, "t$3"), rU = { attribute: !0, type: String, converter: e0, reflect: !1, hasChanged: EP }, sU = /* @__PURE__ */ c((s = rU, t, e) => {
  const { kind: i, metadata: r } = e;
  let n = globalThis.litPropertyMetadata.get(r);
  if (n === void 0 && globalThis.litPropertyMetadata.set(r, n = /* @__PURE__ */ new Map()), i === "setter" && ((s = Object.create(s)).wrapped = !0), n.set(e.name, s), i === "accessor") {
    const { name: a } = e;
    return { set(o) {
      const l = t.get.call(this);
      t.set.call(this, o), this.requestUpdate(a, l, s);
    }, init(o) {
      return o !== void 0 && this.C(a, void 0, s, o), o;
    } };
  }
  if (i === "setter") {
    const { name: a } = e;
    return function(o) {
      const l = this[a];
      t.call(this, o), this.requestUpdate(a, l, s);
    };
  }
  throw Error("Unsupported decorator location: " + i);
}, "r$3");
function b(s) {
  return (t, e) => typeof e == "object" ? sU(s, t, e) : ((i, r, n) => {
    const a = r.hasOwnProperty(n);
    return r.constructor.createProperty(n, i), a ? Object.getOwnPropertyDescriptor(r, n) : void 0;
  })(s, t, e);
}
h(b, "u");
c(b, "n$3");
function N(s) {
  return b({ ...s, state: !0, attribute: !1 });
}
h(N, "D");
c(N, "r$2");
const nU = /* @__PURE__ */ c((s, t, e) => (e.configurable = !0, e.enumerable = !0, Reflect.decorate && typeof t != "object" && Object.defineProperty(s, t, e), e), "e$3");
function Dl(s) {
  return (t, e) => {
    const { slot: i, selector: r } = s ?? {}, n = "slot" + (i ? `[name=${i}]` : ":not([name])");
    return nU(t, e, { get() {
      const a = this.renderRoot?.querySelector(n), o = a?.assignedElements(s) ?? [];
      return r === void 0 ? o : o.filter(((l) => l.matches(r)));
    } });
  };
}
h(Dl, "Kc");
c(Dl, "o$6");
var Fp;
const zz = (Fp = class {
  get result() {
    return this._result && this.observer ? this.observer.trackResult(this._result) : { isPending: !0 };
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenQueryClient = new Promise((e) => this.resolveQueryClient = e), this.setContext();
  }
  async setContext() {
    await ks(this.host), this.context = new $r(this.host, {
      context: De,
      subscribe: !0,
      callback: /* @__PURE__ */ c((t) => {
        t && (this.resolveContext?.(t), this.queryClient = t.queryClient, this.resolveQueryClient?.(t.queryClient));
      }, "callback")
    });
  }
  async trackQuery(t, e = !0) {
    this.observerUnsubscribe?.();
    const i = await this.whenQueryClient;
    if (!i)
      throw new Error("No QueryClient provided");
    const r = new OL(i, t);
    this.observer = r, this.observerSubscribe(e);
  }
  observerSubscribe(t = !0) {
    if (this.queryClient && this.observer) {
      t ? this._result = this.observer.getOptimisticResult(this.observer.options) : this._result = this.observer.getCurrentResult(), this.observerUnsubscribe = this.observer.subscribe(() => {
        if (this.observer) {
          const i = Vy(this.result, this.observer.getCurrentResult());
          i !== this._result && (this._result = i, this.host.requestUpdate());
        }
      }), this.observer.updateResult(), this.host.requestUpdate();
      let e;
      t ? e = this.observer.fetchOptimistic(this.observer.options) : e = this.queryClient.getQueryCache().get(this.observer.options.queryHash)?.promise, e?.catch(() => {
      }).finally(() => {
        this.observer?.updateResult();
      });
    }
  }
  untrackQuery() {
    this.observerUnsubscribe?.(), this.observerUnsubscribe = void 0, this._result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    this.observerUnsubscribe?.();
  }
}, h(Fp, "lw"), Fp);
c(zz, "QueryController");
let Qr = zz;
function g0(s) {
  return s.signal instanceof AbortSignal || typeof s.abort == "function";
}
h(g0, "Mp");
c(g0, "hasAbort");
var qp;
const Iz = (qp = class {
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenObserver = new Promise((e) => this.resolveObserver = e), this.setContext();
  }
  async setContext() {
    await ks(this.host), this.context = new $r(this.host, { context: De, subscribe: !0 });
  }
  hostUpdate() {
    this.context?.value && this.resolveContext?.();
  }
  async trackMutation(t, e) {
    if (e || (await this.whenContext, e = this.context?.value?.queryClient), !e)
      throw new Error("No QueryClient provided");
    return this.observerUnsubscribe?.(), this.observer && (this.whenObserver = new Promise((i) => this.resolveObserver = i)), this.observer = new Yt(e, { ...t }), this.observerSubscribe(), this.resolveObserver?.(this.observer), this.observer;
  }
  observerSubscribe() {
    this.observer && (this.result = this.observer.getCurrentResult(), this.observerUnsubscribe ??= this.observer.subscribe(() => {
      if (this.observer) {
        const t = Vy(this.result, this.observer.getCurrentResult());
        this.result !== t && (this.result = t, this.host.requestUpdate());
      }
    }), this.host.requestUpdate());
  }
  untrackMutation() {
    this.observerUnsubscribe?.(), this.observerUnsubscribe = void 0, this.result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  async mutate(t, e) {
    const i = await this.whenObserver, r = new AbortController();
    return i.mutate(
      {
        ...t,
        signal: r.signal,
        abort: r.abort.bind(r)
      },
      e
    );
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    this.observerUnsubscribe?.();
  }
}, h(qp, "dw"), qp);
c(Iz, "MutationController");
let Wr = Iz;
function r4(s) {
  if (s)
    return s.match(/^[0-9]+$/) ? parseInt(s) : s;
}
h(r4, "Fm");
c(r4, "toIntOrString");
const ai = [];
for (let s = 0; s < 256; ++s)
  ai.push((s + 256).toString(16).slice(1));
function Dz(s, t = 0) {
  return (ai[s[t + 0]] + ai[s[t + 1]] + ai[s[t + 2]] + ai[s[t + 3]] + "-" + ai[s[t + 4]] + ai[s[t + 5]] + "-" + ai[s[t + 6]] + ai[s[t + 7]] + "-" + ai[s[t + 8]] + ai[s[t + 9]] + "-" + ai[s[t + 10]] + ai[s[t + 11]] + ai[s[t + 12]] + ai[s[t + 13]] + ai[s[t + 14]] + ai[s[t + 15]]).toLowerCase();
}
h(Dz, "w0");
c(Dz, "unsafeStringify");
let S$;
const aU = new Uint8Array(16);
function Vz() {
  if (!S$) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    S$ = crypto.getRandomValues.bind(crypto);
  }
  return S$(aU);
}
h(Vz, "m0");
c(Vz, "rng");
const oU = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), O9 = { randomUUID: oU };
function Wz(s, t, e) {
  s = s || {};
  const i = s.random ?? s.rng?.() ?? Vz();
  if (i.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, Dz(i);
}
h(Wz, "g0");
c(Wz, "_v4");
function Th(s, t, e) {
  return O9.randomUUID && !s ? O9.randomUUID() : Wz(s);
}
h(Th, "pl");
c(Th, "v4");
function Fz(s) {
  let t;
  if (s instanceof URL)
    t = { type: "url", item: s };
  else if (s instanceof File)
    t = { type: "file", item: s };
  else if (s instanceof Blob)
    t = {
      type: "file",
      item: new File([s], `${Th()}`, { type: s.type })
    };
  else if (typeof s == "string")
    t = {
      type: "file",
      item: new File([s], `${Th()}.data.txt`, { type: "text/plain;charset=UTF-8" })
    };
  else if (X_(s) || s0(s))
    try {
      const e = s0(s) ? s.toJSON() : JSON.stringify(s, G_(), 2);
      t = {
        type: "file",
        item: new File([e], `${Th()}.json.txt`, { type: "text/plain;charset=UTF-8" })
      };
    } catch (e) {
      console.error("Could not serialize context data to JSON.", e);
    }
  return t;
}
h(Fz, "b0");
c(Fz, "getContextDataRef");
const Qb = /* @__PURE__ */ c((s, t = 3) => {
  const e = [" B", " KB", " MB", " GB", " TB", " PB", " EB", " ZB", " YB"];
  let i = s, r = 0;
  for (; r < e.length - 1 && i >= 1024; )
    i = 100 * i / 1024 / 100, r++;
  return i.toLocaleString(void 0, { maximumSignificantDigits: t }) + e[r];
}, "fileSizeAsString");
function dr(s) {
  return s.lastIndexOf(".") === -1 ? "." : (s.substring(s.lastIndexOf("."), s.length) || s).toLowerCase();
}
h(dr, "di");
c(dr, "getExtension");
function s4(s) {
  switch (s) {
    case ".aac":
    case ".aif":
    case ".aiff":
    case ".au":
    case ".gsm":
    case ".m4a":
    case ".mid":
    case ".midi":
    case ".mka":
    case ".mp3":
    case ".oga":
    case ".ogg":
    case ".ra":
    case ".ram":
    case ".snd":
    case ".spx":
    case ".wav":
    case ".wma":
      return !0;
    default:
      return !1;
  }
}
h(s4, "Dm");
c(s4, "isAudio");
function qz(s) {
  switch (s) {
    case ".ai":
    case ".apng":
    case ".bmp":
    case ".emf":
    case ".eps":
    case ".gif":
    case ".heic":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".psd":
    case ".svg":
    case ".tif":
    case ".tiff":
    case ".webp":
    case ".wmf":
      return !0;
    default:
      return !1;
  }
}
h(qz, "x0");
c(qz, "isImage");
function Zz(s) {
  switch (dr(s)) {
    case ".apng":
    case ".bmp":
    case ".gif":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".svg":
    case ".webp":
      return !0;
    default:
      return !1;
  }
}
h(Zz, "C0");
c(Zz, "isWebImage");
function n4(s) {
  switch (s) {
    case ".3g2":
    case ".asx":
    case ".asf":
    case ".avi":
    case ".flv":
    case ".mk3d":
    case ".mkv":
    case ".mov":
    case ".mp4":
    case ".mpeg":
    case ".mpg":
    case ".ogm":
    case ".ogv":
    case ".ogx":
    case ".qt":
    case ".rm":
    case ".rv":
    case ".smi":
    case ".smil":
    case ".swf":
    case ".webm":
    case ".wmv":
    case ".xaml":
      return !0;
    default:
      return !1;
  }
}
h(n4, "Vm");
c(n4, "isVideo");
function Bz(s) {
  switch (s) {
    case ".markdown":
    case ".md":
      return !0;
    default:
      return !1;
  }
}
h(Bz, "$0");
c(Bz, "isMarkdown");
function a4(s) {
  switch (s) {
    case ".htm":
    case ".html":
    case ".xhtml":
    case ".xml":
      return !0;
    default:
      return !1;
  }
}
h(a4, "Hm");
c(a4, "isMarkup");
function Tb(s) {
  if (a4(s))
    return !0;
  switch (s) {
    case ".as":
    case ".as3":
    case ".asm":
    case ".aspx":
    case ".bat":
    case ".c":
    case ".cc":
    case ".cmake":
    case ".coffee":
    case ".cpp":
    case ".cs":
    case ".css":
    case ".cxx":
    case ".diff":
    case ".erb":
    case ".erl":
    case ".groovy":
    case ".gvy":
    case ".h":
    case ".haml":
    case ".hh":
    case ".hpp":
    case ".hxx":
    case ".java":
    case ".js":
    case ".json":
    case ".jsx":
    case ".less":
    case ".lst":
    case ".m":
    case ".make":
    case ".ml":
    case ".mm":
    case ".out":
    case ".patch":
    case ".php":
    case ".pl":
    case ".plist":
    case ".properties":
    case ".py":
    case ".rb":
    case ".sass":
    case ".scala":
    case ".scm":
    case ".script":
    case ".scss":
    case ".sh":
    case ".sml":
    case ".sql":
    case ".vb":
    case ".vi":
    case ".vim":
    case ".xsd":
    case ".xsl":
    case ".yaml":
    case ".yml":
      return !0;
    default:
      return !1;
  }
}
h(Tb, "dy");
c(Tb, "isCode");
function o4(s) {
  if (Tb(s) || Bz(s))
    return !0;
  switch (s) {
    case ".txt":
      return !0;
    default:
      return !1;
  }
}
h(o4, "Bm");
c(o4, "isText");
function wn(s) {
  const t = dr(s);
  if (t === "") return { icon: "file" };
  if (s4(t))
    return { icon: "file-music", color: "indigo" };
  if (qz(t))
    return { icon: "file-image", color: "cyan" };
  if (n4(t))
    return { icon: "file-video", color: "pink" };
  if (a4(t))
    return { icon: "file-xml", color: "purple" };
  if (Tb(t))
    return { icon: "file-code", color: "purple" };
  if (o4(t))
    return { icon: "file-document" };
  switch (t) {
    case ".7z":
    case ".zip":
      return { icon: "file-compressed", color: "orange" };
    case ".doc":
    case ".docm":
    case ".docx":
    case ".dotm":
    case ".dotx":
      return { icon: "file-word", color: "native" };
    case ".eml":
    case ".msg":
      return { icon: "email", color: "" };
    case ".xls":
    case ".xlsm":
    case ".xlsx":
    case ".xltx":
      return { icon: "file-excel", color: "native" };
    case ".pdf":
      return { icon: "file-pdf", color: "native" };
    case ".ppt":
    case ".pptm":
    case ".pptx":
    case ".potx":
      return { icon: "file-powerpoint", color: "native" };
    case ".pages":
      return { icon: "file", color: "orange" };
    case ".numbers":
      return { icon: "file", color: "green" };
    case ".keynote":
      return { icon: "file", color: "blue" };
  }
  return { icon: "file" };
}
h(wn, "Xr");
c(wn, "getIcon");
function Nz(s) {
  const t = dr(s);
  return t === "" ? "none" : Zz(t) ? "image" : Tb(t) ? "code" : o4(t) ? "text" : s4(t) ? "audio" : n4(t) ? "video" : "none";
}
h(Nz, "k0");
c(Nz, "getWebPreviewFormat");
function Fy(s) {
  switch (s) {
    case "Google Drive":
      return "google-drive";
    case "Dropbox":
      return "dropbox";
    case "OneDrive":
      return "onedrive";
    case "Box":
      return "box";
    default:
      return "";
  }
}
h(Fy, "ud");
c(Fy, "getProvider");
function Mb(s) {
  let t = "file";
  switch (dr(s)) {
    case ".7z":
    case ".zip":
      t = "archive";
      break;
    case ".aac":
    case ".aif":
    case ".aiff":
    case ".au":
    case ".gsm":
    case ".m4a":
    case ".mid":
    case ".midi":
    case ".mka":
    case ".mp3":
    case ".oga":
    case ".ogg":
    case ".ra":
    case ".ram":
    case ".snd":
    case ".spx":
    case ".wav":
    case ".wma":
      t = "audio";
      break;
    case ".c":
    case ".cgi":
    case ".cpp":
    case ".cs":
    case ".cshtml":
    case ".css":
    case ".html":
    case ".java":
    case ".js":
    case ".json":
    case ".less":
    case ".php":
    case ".pl":
    case ".ps1":
    case ".py":
    case ".rb":
    case ".rs":
    case ".scss":
    case ".sh":
    case ".swift":
    case ".sql":
    case ".ts":
    case ".xml":
    case ".yaml":
    case ".yml":
      t = "code";
      break;
    case ".doc":
    case ".docm":
    case ".docx":
    case ".dotm":
    case ".dotx":
    case ".gdoc":
    case ".pages":
    case ".pdf":
      t = "document";
      break;
    case ".eml":
    case ".msg":
      t = "email";
      break;
    case ".gslides":
    case ".keynote":
    case ".ppt":
    case ".pptm":
    case ".pptx":
    case ".potx":
      t = "presentation";
      break;
    case ".gsheet":
    case ".numbers":
    case ".xls":
    case ".xlsm":
    case ".xlsx":
    case ".xltx":
      t = "spreadsheet";
      break;
    case ".ai":
    case ".apng":
    case ".bmp":
    case ".emf":
    case ".eps":
    case ".gif":
    case ".heic":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".psd":
    case ".svg":
    case ".tif":
    case ".tiff":
    case ".webp":
    case ".wmf":
      t = "image";
      break;
    case ".md":
    case ".markdown":
    case ".txt":
      t = "text";
      break;
    case ".3g2":
    case ".asx":
    case ".asf":
    case ".avi":
    case ".flv":
    case ".mk3d":
    case ".mkv":
    case ".mov":
    case ".mp4":
    case ".mpeg":
    case ".mpg":
    case ".ogm":
    case ".ogv":
    case ".ogx":
    case ".qt":
    case ".rm":
    case ".rv":
    case ".smi":
    case ".smil":
    case ".swf":
    case ".webm":
    case ".wmv":
    case ".xaml":
      t = "video";
      break;
  }
  return t;
}
h(Mb, "hy");
c(Mb, "getKind");
function Ab(s) {
  const t = s.target, e = t?.value.lastIndexOf(".");
  e === -1 ? t?.select() : e !== void 0 && t?.setSelectionRange(0, e);
}
h(Ab, "uy");
c(Ab, "handleSelectFilename");
async function w0(s, t = "SHA-256") {
  return await new Promise((e) => {
    if (s) {
      const i = new FileReader();
      i.readAsArrayBuffer(s), i.onloadend = async () => {
        const r = await crypto.subtle.digest(t, i.result);
        let n = "";
        r && (n = Array.from(new Uint8Array(r)).map((a) => a.toString(16).padStart(2, "0")).join("")), e(n);
      };
    } else
      e("");
  });
}
h(w0, "Ap");
c(w0, "getHash");
function Yv(s, t) {
  return s.findAll(t.filters).map((e) => t.select ? t.select(e) : e.state);
}
h(Yv, "Vu");
c(Yv, "getResult");
var Zp;
const Xz = (Zp = class {
  constructor(t) {
    this.alwaysUpdate = !1, t.addController(this), this.host = t, this.setContext();
  }
  async setContext() {
    this.whenContext = new Promise((t) => this.resolveContext = t), await ks(this.host), this.context = new $r(this.host, { context: De, subscribe: !0 });
  }
  hostUpdate() {
    this.context?.value && this.resolveContext?.();
  }
  async trackMutationState(t, e) {
    if (e || (await this.whenContext, e = this.context?.value?.queryClient), !e)
      throw new Error("No QueryClient provided");
    return this.mutationCacheUnsubscribe?.(), this.options = t, this.mutationCache = e.getMutationCache(), this.mutationCacheSubscribe(), this.result;
  }
  mutationCacheSubscribe() {
    this.mutationCache && this.options && (this.result = Yv(this.mutationCache, this.options), this.mutationCacheUnsubscribe = this.mutationCache.subscribe((t) => {
      if (this.mutationCache && this.options && /added|removed|updated/.test(t.type)) {
        const e = Yv(this.mutationCache, this.options);
        this.result !== e && !wo(this.result, e) && (this.result = e, this.host.requestUpdate());
      }
    }), this.host.requestUpdate());
  }
  get isMutating() {
    return !this.mutationCache || !this.options?.filters ? 0 : Yv(this.mutationCache, { filters: { ...this.options.filters, status: "pending" } }).length;
  }
  untrackMutationState() {
    this.mutationCacheUnsubscribe?.(), this.mutationCacheUnsubscribe = void 0, this.result = void 0, this.options = void 0, this.mutationCache = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.mutationCacheSubscribe();
  }
  hostDisconnected() {
    this.mutationCacheUnsubscribe?.();
  }
}, h(Zp, "hw"), Zp);
c(Xz, "MutationStateController");
let Rb = Xz;
function he(s, t, e, i) {
  const r = s.getMutationCache(), n = r.find({
    mutationKey: t,
    predicate: /* @__PURE__ */ c((a) => a.state.variables === e, "predicate")
  });
  if (n && n.state.context) {
    const a = { ...n.state.context };
    i(a);
    const o = { ...n.state, context: a };
    n.state = o, r.notify({
      mutation: n,
      type: "updated",
      action: {
        type: "pending",
        context: n.state.context,
        variables: n.state.variables,
        isPaused: !1
      }
    });
  }
}
h(he, "qt");
c(he, "updateMutationContext");
function l4(s, t, e) {
  const i = s.getMutationCache().find({ mutationKey: t, exact: !0, predicate: e });
  i && s.getMutationCache().remove(i);
}
h(l4, "Nm");
c(l4, "removeMutation");
function jz(s, t) {
  const e = s.getMutationCache();
  e.findAll({ mutationKey: t, exact: !0 }).forEach((i) => {
    e.remove(i);
  });
}
h(jz, "P0");
c(jz, "removeMutations");
const c4 = /* @__PURE__ */ c((s, t, e = 0, i = "application/octet-stream", r, n = Date.now()) => {
  const a = s && (s instanceof URL ? s.toString() : URL.createObjectURL(s));
  return {
    id: n,
    app: { id: -1 },
    name: t,
    kind: Mb(t),
    size: e,
    media_type: i,
    embed_url: "",
    preview_format: Nz(t),
    thumbnail_url: a,
    preview_url: a,
    download_url: a,
    rev: -1,
    created_by: r,
    created_at: (/* @__PURE__ */ new Date()).toUTCString(),
    is_subscribed: !1,
    is_trashed: !1,
    is_starred: !1
  };
}, "getTempFile");
function h4(s) {
  const t = s ? s.reduce(
    (e, i) => {
      const r = i.context?.file;
      return r && i.context?.status.progress && r.size ? {
        loaded: e.loaded + Math.floor(i.context.status.progress / 100 * r.size),
        total: e.total + r.size
      } : e;
    },
    { loaded: 0, total: 0 }
  ) : { loaded: 0, total: 0 };
  return {
    /** Loaded bytes */
    loaded: t.loaded,
    /** Total bytes */
    total: t.total,
    /** Progress of upload provided as 0-100 percent. */
    percent: t.total > 0 ? t.loaded / t.total * 100 : null
  };
}
h(h4, "Um");
c(h4, "getFileMutationsTotalProgress");
function v0(s) {
  return s ? s.some((t) => t.context?.status.state === "conflict") ? "conflict" : s.some((t) => t.status === "error") ? "error" : s.every((t) => t.status === "success") ? "ok" : "pending" : "ok";
}
h(v0, "Ep");
c(v0, "getFileMutationsTotalStatus");
function SS(s) {
  return s?.filter((t) => t.context?.status.state === "pending") || [];
}
h(SS, "of");
c(SS, "getPendingFileMutations");
function CS(s) {
  return s?.filter((t) => t.context?.status.state === "conflict" || t.status === "error") || [];
}
h(CS, "cf");
c(CS, "getFileMutationsByConflictOrError");
function Uz(s, t) {
  const e = s.queryClient;
  e.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "blobs"],
    exact: !0
  }).forEach((i) => {
    i.state.context?.status.state === "error" && e.getMutationCache().remove(i);
  }), e.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "files"],
    exact: !0
  }).forEach((i) => {
    i.state.context?.status.state === "conflict" && e.getMutationCache().remove(i);
  });
}
h(Uz, "_0");
c(Uz, "removeErroredFileMutations");
function O0(s, t, e) {
  const i = s.queryClient;
  i.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "blobs"],
    exact: !0,
    predicate: /* @__PURE__ */ c((r) => /error|success/.test(r.state.status) && (!e || r.state.variables?.blob?.name === e), "predicate")
  }).forEach((r) => {
    i.getMutationCache().remove(r);
  }), i.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "files"],
    exact: !0,
    predicate: /* @__PURE__ */ c((r) => /error|success/.test(r.state.status) && (!e || r.state.variables?.blob?.name === e), "predicate")
  }).forEach((r) => {
    i.getMutationCache().remove(r);
  });
}
h(O0, "Rp");
c(O0, "removeSettledFileMutations");
function Hz(s, t, e) {
  const i = s.queryClient, r = ["apps", e.id, "files"];
  return {
    mutationFn: /* @__PURE__ */ c(async ({ blob: n, replace: a = !1 }) => {
      const o = await s.fetch("/api/apps/" + e.id + "/files", {
        method: "POST",
        body: JSON.stringify({ blob_id: n.id, replace: a })
      });
      if (!o.ok) {
        const l = await o.json();
        throw new Error(l.detail || l.title, { cause: l });
      }
      return await o.json();
    }, "mutationFn"),
    mutationKey: r,
    onMutate: /* @__PURE__ */ c(async (n) => {
      await i.cancelQueries({ queryKey: r, exact: !0 }), Yz(s, e, n.blob.name), O0(s, e, n.blob.name);
      let a;
      try {
        a = n.blob.thumbnail_url && new URL(n.blob.thumbnail_url) || void 0;
      } catch {
      }
      const o = c4(a, n.blob.name, n.blob.size, n.blob.media_type, t);
      return {
        type: n.replace ? "replace" : "create",
        file: o,
        status: { state: "pending" }
      };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((n, a, o) => (he(i, r, a, (l) => {
      l && (l.status.state = "ok", l.status.progress = void 0, l.status.text = void 0);
    }), i.invalidateQueries({ queryKey: r })), "onSuccess"),
    onError(n, a, o) {
      n?.cause?.status === 409 ? he(i, r, a, (l) => {
        l && (l.status.progress = void 0, l.status.state = "conflict", l.status.text = n.message);
      }) : he(i, r, a, (l) => {
        l && (l.status.state = "error", l.status.progress = void 0, l.status.text = n.message);
      });
    }
  };
}
h(Hz, "S0");
c(Hz, "getCreateFileMutationOptions");
function Yz(s, t, e, i, r = "blobs") {
  const n = s.queryClient;
  n.getMutationCache().findAll({
    mutationKey: ["apps", t.id, r],
    exact: !0,
    status: "success",
    predicate: /* @__PURE__ */ c((a) => a.state.data?.name === e, "predicate")
  }).forEach((a) => {
    n.getMutationCache().remove(a);
  });
}
h(Yz, "M0");
c(Yz, "removeSuccessfulUploadBlobMutations");
async function d4(s, t, e, i) {
  const r = new FormData();
  r.append("blob", t);
  const n = await s.upload(
    "/api/blobs",
    "POST",
    r,
    n0.Auto,
    (a) => {
      e && e({ progress: a });
    },
    i
  );
  if (!n.ok) {
    const a = await n.json();
    throw new Error(a.detail || a.title, { cause: a });
  }
  return await n.json();
}
h(d4, "qm");
c(d4, "uploadBlob");
function Gz(s) {
  return {
    mutationFn: /* @__PURE__ */ c(async (t) => await d4(s, t.file, t.onProgress), "mutationFn")
    // TODO: implement onmutate, onsuccess, onerror...
  };
}
h(Gz, "A0");
c(Gz, "getSimpleUploadBlobMutationOptions");
function Eb(s, t, e, i, r = "blobs") {
  const n = s.queryClient, a = i ? ["apps", e, r, i] : ["apps", e, r];
  return {
    mutationFn: /* @__PURE__ */ c(async (o) => await d4(s, o.file, o.onProgress, o.signal), "mutationFn"),
    mutationKey: a,
    onMutate: /* @__PURE__ */ c(async (o) => {
      await n.cancelQueries({ queryKey: a, exact: !0 });
      const l = c4(o.file, o.file.name, o.file.size, o.file.type, t);
      o.onProgress = ({ progress: u }) => {
        he(n, a, o, (p) => {
          p.status.state = "pending", p.status.progress = u;
        });
      };
      const d = await w0(o.file);
      return { type: "upload", file: l, status: { state: "pending" }, sha256: d };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((o, l, d) => {
      he(n, a, l, (u) => {
        u.status.state = "ok", u.status.progress = void 0, u.status.text = void 0;
      });
    }, "onSuccess"),
    onError(o, l, d) {
      const u = o.cause;
      u && u.status === 409 ? he(n, a, l, (p) => {
        p.status.state = "conflict", p.status.progress = void 0, p.status.text = u.detail || u.title;
      }) : he(n, a, l, (p) => {
        p && (p.status.state = "error", p.status.progress = void 0, p.status.text = u.detail || u.title);
      });
    }
  };
}
h(Eb, "yy");
c(Eb, "getUploadBlobMutationOptions");
var lU = Object.defineProperty, u4 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = void 0, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = a(t, e, r) || r);
  return r && lU(t, e, r), r;
}, "__decorateClass$1j"), Zg, Bg, Ng, Xg, jg, Ug, Mn, Bp;
const Kz = (Bp = class extends wt {
  constructor() {
    super(...arguments), q(this, Zg), q(this, Bg), q(this, Ng), q(this, Xg), q(this, jg), q(this, Ug), q(this, Mn), this.contextId = Th(), E(this, Bg, new Promise((t) => {
      E(this, Zg, t);
    })), E(this, Xg, new Promise((t) => {
      E(this, Ng, t);
    })), E(this, Ug, new Promise((t) => {
      E(this, jg, t);
    })), E(this, Mn, new Qr(this));
  }
  // PROPERTIES
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  // Promise.withResolvers() is available in ES2024, that needs to be set in TSConfig
  /**
   * Resolves when a contextual id is available.
   *
   * @internal
   * @returns {Promise<ContextIdType>}
   */
  async whenContextId() {
    return await x(this, Bg);
  }
  /**
   * Resolves when current user data is available.
   *
   * @returns {Promise<UserType>}
   */
  async whenUser() {
    return await x(this, Xg);
  }
  /**
   * Resolves when a weavy context is available.
   *
   * @returns {Promise<WeavyType>}
   */
  async whenWeavy() {
    return await x(this, Ug);
  }
  connectedCallback() {
    super.connectedCallback(), this.contextId && this.requestUpdate("contextId"), this.user && this.requestUpdate("user"), this.weavy && this.requestUpdate("weavy");
  }
  async scheduleUpdate() {
    await ks(this), await super.scheduleUpdate();
  }
  async willUpdate(t) {
    var e, i, r;
    super.willUpdate(t), this.weavyContextConsumer ??= new $r(this, { context: De, subscribe: !0 }), this.weavyContextConsumer?.value && this.weavy !== this.weavyContextConsumer?.value && (this.weavy = this.weavyContextConsumer?.value), t.has("weavy") && this.weavy && await x(this, Mn).trackQuery(Wy(this.weavy, ["user"])), x(this, Mn).result?.isPending || (this.user && x(this, Mn).result.data && this.user.id !== x(this, Mn).result.data.id && (console.warn("User mismatch, resetting"), this.weavy?.reset()), this.user = x(this, Mn).result?.data), t.has("contextId") && this.contextId && (t.get("contextId") && E(this, Bg, new Promise((n) => {
      E(this, Zg, n);
    })), (e = x(this, Zg)) == null || e.call(this, this.contextId)), t.has("user") && this.user && (t.get("user") && E(this, Xg, new Promise((n) => {
      E(this, Ng, n);
    })), (i = x(this, Ng)) == null || i.call(this, this.user)), t.has("weavy") && this.weavy && (t.get("weavy") && E(this, Ug, new Promise((n) => {
      E(this, jg, n);
    })), (r = x(this, jg)) == null || r.call(this, this.weavy));
  }
}, h(Bp, "uw"), Bp);
Zg = /* @__PURE__ */ new WeakMap(), Bg = /* @__PURE__ */ new WeakMap(), Ng = /* @__PURE__ */ new WeakMap(), Xg = /* @__PURE__ */ new WeakMap(), jg = /* @__PURE__ */ new WeakMap(), Ug = /* @__PURE__ */ new WeakMap(), Mn = /* @__PURE__ */ new WeakMap(), c(Kz, "WeavyComponent");
let _b = Kz;
u4([
  N()
], _b.prototype, "weavy");
u4([
  gn({ context: xz }),
  N()
], _b.prototype, "contextId");
u4([
  gn({ context: Pb }),
  N()
], _b.prototype, "user");
var cU = Object.defineProperty, hU = Object.getOwnPropertyDescriptor, Bi = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? hU(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && cU(t, e, r), r;
}, "__decorateClass$1i"), Gv, Kv, Jv, tO, Hg, Yg, Gg, Kg, Yc, Gc, Jg, tw, zs, ew, Kc, Np;
const Jz = (Np = class extends _b {
  constructor() {
    super(), q(this, Gv), q(this, Kv), q(this, Jv), q(this, tO), q(this, Hg), q(this, Yg), q(this, Gg), q(this, Kg), q(this, Yc), q(this, Gc), q(this, Jg), q(this, tw), q(this, zs), q(this, ew), q(this, Kc), this.storage = ZP("localStorage"), this.storageLinkHandler = (t) => {
      t.storageArea === this.storage && t.key === "wy-link" && t.newValue && this.readStorageLink();
    }, this.linkEventHandler = async (t) => {
      !t.defaultPrevented && t.detail.link && (this.link && this.link.id === t.detail.link.id && (this.link = void 0, await this.updateComplete), this.link = t.detail.link, this.link || this.provideStorageLink(t.detail.link));
    }, this.notificationEventConsumer = (t) => {
      t.stopPropagation(), t.defaultPrevented || this.visibilityElement && this.visibilityElement.isConnected && this.visibilityElement.checkVisibility(XS) && this.matchesLink(t.detail.link) && t.preventDefault();
    }, E(this, Yg, new Promise((t) => {
      E(this, Hg, t);
    })), E(this, Kg, new Promise((t) => {
      E(this, Gg, t);
    })), E(this, Gc, new Promise((t) => {
      E(this, Yc, t);
    })), E(this, tw, new Promise((t) => {
      E(this, Jg, t);
    })), E(this, zs, /* @__PURE__ */ new Map()), E(this, ew, new Wr(this)), E(this, Kc, new Rb(this)), this.settings = new v9(this);
  }
  /**
   * Checks if an entity matches the component configuration.
   *
   * @internal
   * @param link - Entity to check for a match.
   * @returns True if the entity targets this component.
   */
  matchesLink(t) {
    return (
      // Type app match, like the Messenger
      t?.app?.type && this.componentTypes?.includes(t.app.type) ? t.agent ? t.agent === this.agent : !0 : !1
    );
  }
  set link(t) {
    const e = this._link;
    this._link = this.matchesLink(t) ? t : void 0, this.requestUpdate("link", e);
  }
  get link() {
    return this._link;
  }
  /**
   * Clears the link and resets the promise.
   *
   * @internal
   */
  clearLink() {
    this.link && (E(this, Gc, new Promise((t) => {
      E(this, Yc, t);
    })), this.link = void 0);
  }
  /**
   * Shares a link with other blocks that may consume it automatically.
   *
   * @param link - The entity to provide.
   * @internal
   */
  provideStorageLink(t) {
    this.storage?.setItem("wy-link", btoa(JSON.stringify(t)));
  }
  /**
   * Reads a link from storage and exposes it via the link property and context.
   *
   * @internal
   */
  readStorageLink() {
    if (!this.storage) {
      console.error("Storage not available");
      return;
    }
    const t = this.storage.getItem("wy-link");
    if (t)
      try {
        const e = JSON.parse(atob(t));
        e && (this.link = e);
      } catch (e) {
        console.error("Error parsing link", e);
      }
  }
  /**
   * Consumes a link in storage. Make sure to consume it after it has been used.
   *
   * @internal
   */
  consumeStorageLink() {
    this.storage?.removeItem("wy-link");
  }
  /**
   * Element to match visibility on.
   */
  get visibilityElement() {
    return this;
  }
  set agent(t) {
    this._agentUid = t || void 0;
  }
  get agent() {
    return this._agentUid;
  }
  set data(t) {
    console.warn(".data property array is deprecated. Use .contextualData string instead."), E(this, Gv, t);
  }
  /**
   * DEPRECATED: Use `.contextualData` property instead.
   *
   * Array with contextual data.
   *
   * *Note: Only the first item in the array is currently used.*
   * @internal
   * @deprecated
   */
  get data() {
    return x(this, Gv);
  }
  set annotations(t) {
    E(this, Kv, t);
  }
  get annotations() {
    return x(this, Kv) ?? this.weavy?.annotations ?? _e.defaults.annotations;
  }
  set enterToSend(t) {
    E(this, Jv, t);
  }
  get enterToSend() {
    return x(this, Jv) ?? this.weavy?.enterToSend ?? _e.defaults.enterToSend;
  }
  set reactions(t) {
    E(this, tO, t);
  }
  get reactions() {
    return x(this, tO) ?? this.weavy?.reactions ?? _e.defaults.reactions;
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  // Promise.withResolvers() is available in ES2024, that needs to be set in TSConfig
  // #resolveAgentUser?: (agent: AgentType) => void;
  // #whenAgentUser = new Promise<AgentType>((r) => {
  //   this.#resolveAgentUser = r;
  // });
  // async whenAgentUser() {
  //   return await this.#whenAgentUser;
  // }
  /**
   * Resolves when context data blob uploads has finished.
   *
   * @internal
   * @returns {Promise<ContextDataBlobsType>}
   */
  async whenContextDataBlobs() {
    return await x(this, Yg);
  }
  /**
   * Resolves when Weavy component features config is available.
   *
   * @internal
   * @returns {Promise<ComponentFeaturePolicy>}
   */
  async whenComponentFeatures() {
    return await x(this, Kg);
  }
  /**
   * Resolves when a provided link is available.
   *
   * @internal
   * @returns {Promise<LinkType>}
   */
  async whenLink() {
    return await x(this, Gc);
  }
  /**
   * Resolves when Weavy component settings are available.
   *
   * @internal
   * @returns {Promise<WeavyComponentSettingsType>}
   */
  async whenSettings() {
    return await x(this, tw);
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("wy-link", this.linkEventHandler), window.addEventListener("storage", this.storageLinkHandler), this.componentFeatures && this.requestUpdate("componentFeatures"), this.contextDataBlobs && this.requestUpdate("contextDataBlobs"), this.link && this.requestUpdate("link"), this.settings && this.requestUpdate("settings");
  }
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("wy-link", this.linkEventHandler), window.removeEventListener("storage", this.storageLinkHandler), this.weavy?.host.removeEventListener("wy-notification", this.notificationEventConsumer, { capture: !0 });
  }
  async willUpdate(t) {
    var e, i, r, n;
    await super.willUpdate(t), t.has("bot") && typeof this.bot == "string" && console.error(`Using .bot property is deprecated. Use .agent = "${this.bot}"; instead`);
    const a = Object.keys(this.settings);
    if ((t.has("weavy") || a.find((o) => t.has(o))) && (this.settings = new v9(this)), t.has("features") && this.componentFeatures && (this.componentFeatures.setAllowedFeatures(this.features), this.componentFeatures instanceof di && (this.componentFeatures = this.componentFeatures.immutable())), (t.has("weavy") || t.has("contextId") || t.has("user") || t.has("componentFeatures")) && this.weavy && this.contextId && this.user && this.componentFeatures?.allowsFeature(L.ContextData) && (await x(this, ew).trackMutation(
      Eb(this.weavy, this.user, this.contextId, void 0, "data")
    ), await x(this, Kc).trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.contextId, "data"],
          exact: !0
        }
      },
      this.weavy.queryClient
    )), t.has("contextualData") || t.has("data") || t.has("componentFeatures")) {
      const o = this.contextualData ? [this.contextualData] : this.data ? this.data : [], l = x(this, zs);
      if (E(this, zs, /* @__PURE__ */ new Map()), o.forEach((d) => {
        const u = l.get(d);
        if (u)
          x(this, zs).set(d, u);
        else {
          const p = Fz(d);
          p && x(this, zs).set(d, p);
        }
      }), x(this, zs) && this.componentFeatures?.allowsFeature(L.ContextData)) {
        for (const f of Array.from(x(this, zs).values()))
          if (f.type === "file") {
            const y = await w0(f.item);
            await U_(
              x(this, Kc).result ?? [],
              async (g) => (g.context?.sha256 ?? await w0(g.variables?.file)) === y
            ) || await x(this, ew).mutate({ file: f.item });
          }
        const d = x(this, Kc).result, u = d?.some((f) => f.status === "pending"), p = d?.map((f) => f.data?.id).filter((f) => f).reverse() ?? [];
        u || (this.contextDataBlobs = p);
      } else
        this.contextDataBlobs = [];
    }
    (t.has("componentTypes") || t.has("agent")) && this.componentTypes && this.readStorageLink(), t.has("link") && this.link && (console.info("Opening notification link"), this.consumeStorageLink()), t.has("contextDataBlobs") && this.contextDataBlobs && (t.get("contextDataBlobs") && E(this, Yg, new Promise((o) => {
      E(this, Hg, o);
    })), (e = x(this, Hg)) == null || e.call(this, this.contextDataBlobs)), t.has("componentFeatures") && this.componentFeatures && (t.get("componentFeatures") && E(this, Kg, new Promise((o) => {
      E(this, Gg, o);
    })), (i = x(this, Gg)) == null || i.call(this, this.componentFeatures)), t.has("link") && this.link && (t.get("link") && E(this, Gc, new Promise((o) => {
      E(this, Yc, o);
    })), (r = x(this, Yc)) == null || r.call(this, this.link)), t.has("settings") && this.settings && (t.get("settings") && E(this, tw, new Promise((o) => {
      E(this, Jg, o);
    })), (n = x(this, Jg)) == null || n.call(this, this.settings)), t.has("weavy") && this.weavy && this.weavy.host.addEventListener("wy-notification", this.notificationEventConsumer, { capture: !0 });
  }
}, h(Np, "pw"), Np);
Gv = /* @__PURE__ */ new WeakMap(), Kv = /* @__PURE__ */ new WeakMap(), Jv = /* @__PURE__ */ new WeakMap(), tO = /* @__PURE__ */ new WeakMap(), Hg = /* @__PURE__ */ new WeakMap(), Yg = /* @__PURE__ */ new WeakMap(), Gg = /* @__PURE__ */ new WeakMap(), Kg = /* @__PURE__ */ new WeakMap(), Yc = /* @__PURE__ */ new WeakMap(), Gc = /* @__PURE__ */ new WeakMap(), Jg = /* @__PURE__ */ new WeakMap(), tw = /* @__PURE__ */ new WeakMap(), zs = /* @__PURE__ */ new WeakMap(), ew = /* @__PURE__ */ new WeakMap(), Kc = /* @__PURE__ */ new WeakMap(), c(Jz, "WeavyTypeComponent");
let Ve = Jz;
Bi([
  gn({ context: kz }),
  N()
], Ve.prototype, "contextDataBlobs", 2);
Bi([
  gn({ context: Sb }),
  N()
], Ve.prototype, "componentFeatures", 2);
Bi([
  gn({ context: Qz }),
  N()
], Ve.prototype, "settings", 2);
Bi([
  gn({ context: Cz })
], Ve.prototype, "_link", 2);
Bi([
  b({ type: Object })
], Ve.prototype, "link", 1);
Bi([
  N()
], Ve.prototype, "componentTypes", 2);
Bi([
  b()
], Ve.prototype, "features", 2);
Bi([
  b({ type: String })
], Ve.prototype, "agent", 1);
Bi([
  b({
    attribute: !0,
    type: String
  })
], Ve.prototype, "contextualData", 2);
Bi([
  b({
    attribute: !0,
    type: String,
    converter: {
      fromAttribute(s) {
        return j_(s);
      }
    }
  })
], Ve.prototype, "data", 1);
Bi([
  b({ type: String })
], Ve.prototype, "annotations", 1);
Bi([
  b({ type: String })
], Ve.prototype, "enterToSend", 1);
Bi([
  b({ type: String })
], Ve.prototype, "reactions", 1);
Bi([
  b()
], Ve.prototype, "bot", 2);
const dU = new Map(DP(Az)), uU = new Map(DP(Rz)), b0 = new Map(Object.entries(Ez));
new Map(Object.entries(_z));
var pU = Object.defineProperty, fU = Object.getOwnPropertyDescriptor, Vl = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? fU(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && pU(t, e, r), r;
}, "__decorateClass$1h");
const Nn = "unknown";
var iw, rw, ao, Xp;
const tI = (Xp = class extends Ve {
  constructor() {
    super(...arguments), q(this, iw), q(this, rw), q(this, ao), this.appSubscribeMutation = new Wr(this), E(this, rw, new Promise((t) => {
      E(this, iw, t);
    })), E(this, ao, new Qr(this));
  }
  // @provide({ context: AgentContext })
  // @state()
  // agentUser: AgentType | undefined;
  /**
   * Sets the component to it's initial state and resets the app state.
   */
  reset() {
    this.app && (this.app = void 0), this._appName !== this._initialAppName && (this._appName = this._initialAppName);
  }
  /**
   * Checks if an entity matches the component configuration.
   *
   * @internal
   * @param link - Entity to check for a match.
   * @returns True if the entity targets this component.
   */
  matchesLink(t) {
    return (
      // Messenger conversation
      t?.app?.type && !this.appType && this.componentTypes?.includes(t.app.type) ? t.agent ? t.agent === this.agent : !0 : (
        // Normal contextual app
        !!(t && t.app && this.appType !== Nn && (typeof this.uid == "string" && t.app?.uid === this.uid || // Normal app with app uid
        typeof this.uid == "number" && t.app?.id === this.uid || // Normal app with app id
        !this.uid && this.app && t.app.id === this.app.id))
      )
    );
  }
  set link(t) {
    const e = this._link;
    !this.uid && this.appType && this.appType !== Nn ? this.whenApp().then(() => {
      this._link = this.matchesLink(t) ? t : void 0, this.requestUpdate("link", e);
    }) : (this._link = this.matchesLink(t) ? t : void 0, this.requestUpdate("link", e));
  }
  get link() {
    return this._link;
  }
  set name(t) {
    this._initialAppName = t, this._appName = t;
  }
  get name() {
    return this._appName;
  }
  /**
   * Subscribes or unsubscribes to notification updates from the app. Check `.app.is_subscribed` to see current state.
   *
   * @param subscribe - Set to `false` to unsubscribe from updates. Defaults to `true`.
   * @returns {Promise<void>}
   *
   * @example <caption>Toggle app subscription</caption>
   * ```js
   * // Wait for app data
   * await myWeavyComponent.whenApp();
   *
   * // Get current app subscription state
   * const isSubscribed = myWeavyComponent.app.is_subscribed;
   *
   * // Toggle the app subscription state
   * myWeavyComponent.subscribe(!isSubscribed);
   * ```
   */
  async subscribe(t = !0) {
    if (!this.uid)
      throw new Error(`Cannot ${t ? "subscribe" : "unsubscribe"} without a uid.`);
    await this.whenApp(), this.app?.id && this.appSubscribeMutation.mutate({ subscribe: t });
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  // Promise.withResolvers() is available in ES2024, that needs to be set in TSConfig
  /**
   * Resolves when app data is available.
   *
   * @returns {Promise<AppType>}
   */
  async whenApp() {
    return await x(this, rw);
  }
  connectedCallback() {
    super.connectedCallback(), this.app && this.requestUpdate("app");
  }
  async willUpdate(t) {
    var e;
    if (await super.willUpdate(t), t.has("autoUid") && typeof this.autoUid == "string" && (console.error(`Using .autoUid property is deprecated. Use .generateUid = "${this.autoUid}"; instead`), this.generateUid = this.autoUid), (t.has("generateUid") || t.has("user") || t.has("agent")) && this.generateUid && this.user && (this.appType && b0.has(this.appType) && this.agent || this.appType && !b0.has(this.appType))) {
      const r = [this.generateUid];
      this.agent && r.push(this.agent), this.user && r.push(this.user.uid || this.user.id), this.uid = r.join("-");
    }
    const i = this.name;
    if ((t.has("appType") || t.has("uid") || t.has("agent") || t.has("weavy")) && this._appName !== this._initialAppName && (this._appName = this._initialAppName, this.requestUpdate("name", i)), t.has("appType") || t.has("uid") || t.has("agent") || t.has("name") || t.has("weavy"))
      if (this.appType && this.uid && this.weavy) {
        const r = this.name ? { name: this.name } : void 0, n = this.agent ? [this.agent] : void 0;
        await x(this, ao).trackQuery(eI(this.weavy, this.uid, this.appType, n, r));
      } else
        x(this, ao).untrackQuery();
    if (x(this, ao).result?.isPending || (this.app = x(this, ao).result?.data, this.app?.name && this._appName !== this.app.name && (this.name = this.app.name, this.requestUpdate("name", i))), t.has("uid") && (this.uid || t.get("uid")) && this.uid !== t.get("uid") && this.clearLink(), !this.link && (t.has("uid") && this.uid || t.has("app") && this.app) && this.appType && this.appType !== Nn && this.readStorageLink(), t.has("app") && this.app) {
      const r = new CustomEvent("wy-app", {
        bubbles: !1,
        composed: !0,
        detail: {
          app: this.app
        }
      });
      this.dispatchEvent(r);
    }
    t.has("app") && this.app && (t.get("app") && E(this, rw, new Promise((r) => {
      E(this, iw, r);
    })), (e = x(this, iw)) == null || e.call(this, this.app)), (t.has("weavy") || t.has("app")) && this.weavy && this.app && this.appSubscribeMutation.trackMutation(rI(this.weavy, this.app));
  }
}, h(Xp, "yw"), Xp);
iw = /* @__PURE__ */ new WeakMap(), rw = /* @__PURE__ */ new WeakMap(), ao = /* @__PURE__ */ new WeakMap(), c(tI, "WeavyAppComponent");
let Ni = tI;
Vl([
  gn({ context: e4 }),
  N()
], Ni.prototype, "app", 2);
Vl([
  b({ type: Object })
], Ni.prototype, "link", 1);
Vl([
  N()
], Ni.prototype, "appType", 2);
Vl([
  b()
], Ni.prototype, "generateUid", 2);
Vl([
  b({ converter: r4 })
], Ni.prototype, "uid", 2);
Vl([
  b({ type: String })
], Ni.prototype, "name", 1);
Vl([
  b()
], Ni.prototype, "autoUid", 2);
function eI(s, t, e = Nn, i, r) {
  return {
    // eslint-disable-next-line @tanstack/query/exhaustive-deps
    queryKey: ["apps", t],
    queryFn: /* @__PURE__ */ c(async () => {
      const n = [];
      e === Nn || typeof t == "number" ? n.push(
        // Get existing app
        s.fetch(`/api/apps/${t}`)
      ) : i?.length ? (n.push(
        // Get existing app
        s.fetch(`/api/apps/${t}`)
      ), n.push(
        // Create app with members
        s.fetch("/api/apps", { method: "POST", body: JSON.stringify({ type: e, members: i, uid: t, ...r }) })
      )) : n.push(
        // Get, update or create app (upsert) using app uid
        s.fetch(`/api/apps/${t}`, { method: "PUT", body: JSON.stringify({ type: e, ...r }) })
      );
      const a = (await Promise.allSettled(n)).findLast(
        (l) => l.status === "fulfilled" && l.value?.ok
      ), o = a?.status === "fulfilled" && a.value;
      if (o)
        return await o.json();
      throw new Error(`Error getting or creating app ${t}`);
    }, "queryFn")
  };
}
h(eI, "F0");
c(eI, "getOrCreateAppOptions");
function iI(s) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ name: t, members: e, type: i, uid: r }) => await (await s.fetch("/api/apps", {
      method: "POST",
      body: JSON.stringify({
        name: t,
        members: e,
        type: i,
        uid: r
      })
    })).json(), "mutationFn"),
    onSettled: /* @__PURE__ */ c(async () => {
      await s.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
h(iI, "D0");
c(iI, "getCreateAppMutationOptions");
function p4(s) {
  return new Yt(s.queryClient, iI(s));
}
h(p4, "jm");
c(p4, "getCreateAppMutation");
function rI(s, t) {
  const e = s.queryClient, i = ["apps", t.uid || t.id];
  return {
    mutationFn: /* @__PURE__ */ c(async ({ subscribe: r }) => {
      if (t.id >= 1) {
        const n = await s.fetch(`/api/apps/${t.id}/${r ? "subscribe" : "unsubscribe"}`, {
          method: "POST"
        });
        if (!n.ok)
          throw await n.json();
      } else
        throw new Error(`Could not subscribe to app ${t.uid || t.id}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((r) => {
      let n;
      return e.setQueryData(i, (a) => (n = a.is_subscribed, { ...a, is_subscribed: r.subscribe })), {
        previousSubscribe: n,
        subscribe: r.subscribe
      };
    }, "onMutate"),
    onError(r, n, a) {
      a && a.previousSubscribe !== void 0 && e.setQueryData(i, (o) => ({ ...o, is_subscribed: a?.previousSubscribe }));
    }
  };
}
h(rI, "V0");
c(rI, "getAppSubscribeMutationOptions");
function sI(s, t = [xt.ChatRoom, xt.PrivateChat], e) {
  const i = new URLSearchParams({
    count_only: "true",
    unread: "true",
    uid: "false"
  });
  e && i.append("member", e), t?.forEach((n) => i.append("type", n));
  const r = `/api/apps?${i.toString()}`;
  return Wy(s, ["apps", "unread", t, e], r);
}
h(sI, "H0");
c(sI, "getAppsUnreadOptions");
function nI(s, t = {}, e, i, r, n, a) {
  return {
    ...t,
    initialPageParam: 0,
    queryKey: ["apps", "list", e, i, n, a],
    queryFn: /* @__PURE__ */ c(async (o) => {
      const l = new URLSearchParams();
      i && l.append("member", i), o.pageParam && typeof o.pageParam == "number" && l.append("skip", o.pageParam?.toString()), e?.forEach((f) => l.append("type", f)), l.append("order_by", n);
      const d = r?.();
      d && l.append("q", d), l.append("uid", "false");
      const u = `/api/apps?${l.toString()}`, p = await (await s.fetch(u)).json();
      return p.data = p.data || [], p;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ c((o) => {
      if (o.end && o?.end < o?.count)
        return o.end;
    }, "getNextPageParam")
  };
}
h(nI, "B0");
c(nI, "getAppListOptions");
var Oi = /* @__PURE__ */ ((s) => (s.Default = "", s.Select = "select", s.Star = "star", s.Unstar = "unstar", s.Subscribe = "subscribe", s.Unsubscribe = "unsubscribe", s.Pin = "pin", s.Unpin = "unpin", s.Download = "download", s.Preview = "preview", s))(Oi || {}), jp;
const aI = (jp = class {
  get weavy() {
    return this.weavyContext?.value;
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenWeavyContext = new Promise((e) => this.resolveWeavyContext = e), this.setContexts();
  }
  /**
   * Initiates context consumers
   */
  async setContexts() {
    await ks(this.host), this.weavyContext = new $r(this.host, { context: De, subscribe: !0 });
  }
  /**
   * Dispatch a `wy-action` event on the host.
   *
   * @fires {WyActionEventType} wy-action - Emitted when a conversation app is created and should be selected.
   */
  dispatchActionEvent(t) {
    const e = new CustomEvent("wy-action", {
      detail: { action: Oi.Select, app: t },
      bubbles: !0,
      composed: !0
    });
    return this.host.dispatchEvent(e);
  }
  /**
   * Create mutation controller.
   */
  async initMutation() {
    if (!this.addConversationMutation) {
      const t = await this.whenWeavyContext;
      this.addConversationMutation = p4(t);
    }
    return this.addConversationMutation;
  }
  /**
   * Create a conversation and trigger a `select` event.
   *
   * @param members - Array of members by id/uid for a new conversation.
   * @returns Whether the event was successful.
   * @fires {WyActionEventType} wy-action - Emitted when a conversation app is created and should be selected.
   */
  async create(t = []) {
    const e = await this.initMutation(), i = this.agent ?? this.host.agent, r = i ? { members: [i], type: Lr.AgentChat } : { members: t, type: t.length === 1 ? Lr.PrivateChat : Lr.ChatRoom }, n = await e.mutate(r);
    return this.dispatchActionEvent(n), n;
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
  }
}, h(jp, "ww"), jp);
c(aI, "CreateConversationController");
let Lb = aI;
var sw, Up;
const oI = (Up = class {
  constructor(t) {
    q(this, sw, !1), t.addController(this), this.host = t, t.addEventListener("dragstart", () => this.isDragActive = !0), t.addEventListener("dragenter", () => this.isDragActive = !0), t.addEventListener("dragover", (e) => {
      e.preventDefault(), this.isDragActive = !0;
    }), t.addEventListener("dragleave", () => this.isDragActive = !1), t.addEventListener("dragend", () => this.isDragActive = !1), t.addEventListener("drop", (e) => this.handleDrop(e));
  }
  get isDragActive() {
    return x(this, sw);
  }
  set isDragActive(t) {
    x(this, sw) !== t && (E(this, sw, t), this.host.requestUpdate());
  }
  handleDrop(t) {
    t.preventDefault();
    const e = [];
    t.dataTransfer?.items ? [...t.dataTransfer.items].forEach((i) => {
      if (i.kind === "file") {
        const r = i.getAsFile();
        r ? e.push(r) : console.error("Could not add file");
      }
    }) : t.dataTransfer?.files && [...t.dataTransfer.files].forEach((i) => {
      e.push(i);
    }), e.length && this.dispatchUploadFiles(e), this.isDragActive = !1;
  }
  dispatchUploadFiles(t) {
    const e = new CustomEvent("drop-files", { detail: { files: t } });
    return this.host.dispatchEvent(e);
  }
  hostDisconnected() {
  }
}, h(Up, "fw"), Up);
sw = /* @__PURE__ */ new WeakMap(), c(oI, "DropZoneController");
let lI = oI;
function kw(s, t) {
  Se();
  const e = go({}, window.history.state, !0);
  if (!e.weavy || !e.weavy[s] || !Object.hasOwn(e.weavy[s], t))
    throw new Error("Property not found");
  return e.weavy[s][t];
}
h(kw, "Fd");
c(kw, "getBrowserStateProperty");
function $0(s, t, e = "push", i) {
  if (Se(), t) {
    const r = go({}, window.history.state, !0);
    r.weavy ??= {}, r.weavy[s] = t, i = i && String(i) || window.location.href;
    try {
      e === "replace" ? window.history.replaceState(r, "", i) : window.history.pushState(r, "", i);
    } catch (n) {
      console.warn("history: Could not push history state.", n, t);
    }
  }
}
h($0, "Tp");
c($0, "setBrowserState");
function cI(s, t, e) {
  Se();
  const i = `${typeof s}:${t}`;
  e.forEach((r) => {
    try {
      const n = kw(i, r), a = s[r];
      f4(a, n) && (s[r] = n);
    } catch {
    }
  });
}
h(cI, "N0");
c(cI, "restoreHistoryProperties");
function x0(s, t, e, i = "push") {
  Se();
  const r = `${typeof s}:${t}`, n = {};
  e.forEach((a) => {
    n[a] = s[a];
  }), $0(r, n, i);
}
h(x0, "Lp");
c(x0, "pushHistoryProperties");
function hI(s, t, e) {
  x0(s, t, e, "replace");
}
h(hI, "U0");
c(hI, "updateHistoryProperties");
function f4(s, t) {
  return s && t && (sn(s) || sn(t)) ? s && Object.hasOwn(s, "id") || t && Object.hasOwn(t, "id") ? s.id !== t.id : !wo(s, t) : s !== t;
}
h(f4, "Wm");
c(f4, "itemHasChanged");
var Hp;
const mU = (Hp = class {
  constructor(t, e, i) {
    if (this._backCount = 0, this.restoreHistory = (r) => {
      if (this.prefixKey && this.properties) {
        cI(this.host, this.prefixKey, this.properties);
        try {
          this._backCount = kw(this.prefixKey, "_backCount") || 0;
        } catch {
          this._backCount = 0;
        }
        this.updatePrevPropertyValues();
      }
    }, t.addController(this), this.host = t, i && (this.properties = i), e) {
      this.prefixKey = e;
      try {
        this._backCount = kw(this.prefixKey, "_backCount") || this._backCount;
      } catch {
      }
    }
  }
  get hasBackNavigation() {
    return this._backCount > 0;
  }
  back() {
    window.history.back();
  }
  backAll() {
    window.history.go(this._backCount * -1);
  }
  observe(t, e) {
    if (this.properties = t, e) {
      this.prefixKey = e;
      try {
        this._backCount = kw(this.prefixKey, "_hasBack") || this._backCount;
      } catch {
      }
    }
  }
  /**
   * Method to manually push history
   */
  pushCurrentState() {
    this.prefixKey && (x0(this.host, this.prefixKey, this.properties), this._backCount++, $0(this.prefixKey, { _backCount: this._backCount }, "replace"));
  }
  updatePrevPropertyValues() {
    this.properties && this.properties.forEach((t) => {
      this.prevPropertyValues ??= {};
      const e = this.host[t];
      this.prevPropertyValues[t] !== e && (this.prevPropertyValues[t] = e && JSON.parse(JSON.stringify(e)));
    });
  }
  hostConnected() {
    window.addEventListener("popstate", this.restoreHistory);
  }
  hostUpdated() {
    this.prefixKey && this.properties && (this.prevPropertyValues ? this.properties.some(
      (t) => {
        const e = this.prevPropertyValues?.[t], i = this.host[t];
        return f4(e, i);
      }
    ) && (x0(
      this.prevPropertyValues,
      this.prefixKey,
      this.properties
    ), this._backCount++, $0(this.prefixKey, { _backCount: this._backCount }, "replace")) : this.prevPropertyValues = {}, hI(this.host, this.prefixKey, this.properties), this.updatePrevPropertyValues());
  }
  hostDisconnected() {
    window.removeEventListener("popstate", this.restoreHistory);
  }
}, h(Hp, "mw"), Hp);
c(mU, "HistoryController");
var Yp;
const dI = (Yp = class {
  get result() {
    return this._result && this.observer ? this.observer.trackResult(this._result) : this.observer?.getCurrentResult() ?? { isPending: !0 };
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenQueryClient = new Promise((e) => this.resolveQueryClient = e), this.setContext();
  }
  async setContext() {
    await ks(this.host), this.context = new $r(this.host, {
      context: De,
      subscribe: !0,
      callback: /* @__PURE__ */ c((t) => {
        t && (this.resolveContext?.(t), this.queryClient = t.queryClient, this.resolveQueryClient?.(t.queryClient));
      }, "callback")
    });
  }
  async trackInfiniteQuery(t, e = !0) {
    this.observerUnsubscribe?.();
    const i = await this.whenQueryClient;
    if (!i)
      throw new Error("No QueryClient provided");
    const r = new Cj(i, t);
    this.observer = r, this.observerSubscribe(e);
  }
  observerSubscribe(t = !0) {
    if (this.queryClient && this.observer) {
      t ? this._result = this.observer.getOptimisticResult(
        this.observer.options
      ) : this._result = this.observer.getCurrentResult(), this.observerUnsubscribe = this.observer.subscribe(() => {
        if (this.observer) {
          const i = Vy(this.result, this.observer.getCurrentResult());
          i !== this._result && (this._result = i, this.host.requestUpdate());
        }
      }), this.observer.updateResult(), this.host.requestUpdate();
      let e;
      t ? e = this.observer.fetchOptimistic(this.observer.options) : e = this.queryClient.getQueryCache().get(
        this.observer.options.queryHash
      )?.promise, e?.catch(() => {
      }).finally(() => {
        this.observer?.updateResult();
      });
    }
  }
  untrackInfiniteQuery() {
    this.observerUnsubscribe?.(), this.observerUnsubscribe = void 0, this._result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    this.observerUnsubscribe?.();
  }
}, h(Yp, "vw"), Yp);
c(dI, "InfiniteQueryController");
let Wl = dI;
function k0(s, t = !1) {
  for (s && !t && (s = s.nextElementSibling); s; ) {
    if (!(s instanceof HTMLElement))
      continue;
    const e = getComputedStyle(s);
    if (e.display !== "none") {
      if (e.display === "contents") {
        if (s.shadowRoot && s.shadowRoot.firstElementChild instanceof HTMLElement) {
          const i = k0(s.shadowRoot.firstElementChild, !0);
          if (i)
            return i;
        }
        if (s.firstElementChild instanceof HTMLElement) {
          const i = k0(s.firstElementChild, !0);
          if (i)
            return i;
        }
      }
      if (/absolute|sticky|fixed/.test(e.position) === !1)
        return s;
      s = s.nextElementSibling;
    }
  }
  return null;
}
h(k0, "Op");
c(k0, "getNextPositionedChild");
function P1(s, t = !1) {
  if (Se(), s) {
    let e = getComputedStyle(s);
    const i = e.position === "absolute", r = t ? /(auto|scroll|overlay|hidden)/ : /(auto|overlay|scroll)/;
    if (e.position === "fixed" && document.scrollingElement)
      return document.scrollingElement;
    for (let n = s; n = n.parentElement || n.parentNode || n.host; )
      if (n instanceof Element && (e = getComputedStyle(n), !(i && e.position === "static") && r.test(e.overflow + e.overflowY + e.overflowX)))
        return n;
  }
  return document.scrollingElement || s;
}
h(P1, "$h");
c(P1, "getScrollParent");
function uI(s) {
  if (s && s.isConnected) {
    const t = P1(s);
    return t.clientHeight !== t.scrollHeight;
  }
  return !1;
}
h(uI, "q0");
c(uI, "hasScroll");
function pI(s, t = 32) {
  if (s) {
    const e = P1(s);
    return Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) < t;
  }
  return !1;
}
h(pI, "j0");
c(pI, "isParentAtBottom");
async function fI(s, t = !1) {
  if (s) {
    const e = P1(s);
    Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) > 1 && (t ? e.scrollTo({
      top: e.scrollHeight,
      left: 0,
      behavior: "smooth"
    }) : e.scrollTop = e.scrollHeight), await new Promise((i) => {
      let r = e.scrollTop;
      const n = /* @__PURE__ */ c(() => {
        t && e.scrollTop === r && (e.scrollTop = e.scrollHeight), r = e.scrollTop, Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) > 1 ? requestAnimationFrame(n) : i(void 0);
      }, "scrollCheck");
      requestAnimationFrame(n);
    });
  }
}
h(fI, "W0");
c(fI, "scrollParentToBottom");
const yU = 0, gU = void 0;
function mI(s, t, e = !1) {
  Se(), t ??= /* @__PURE__ */ c(() => Promise.reject(new Error("No scroll function defined")), "whenNext");
  const i = e ? P1(s) : document.documentElement, r = i === document.documentElement ? document : i;
  let n = !1;
  const a = new IntersectionObserver(
    (o) => {
      o.forEach((l) => {
        if (l.isIntersecting && !n)
          if (n = !0, e && i && r instanceof HTMLElement) {
            const d = k0(l.target) || l.target, u = i.scrollHeight, p = d.offsetTop, f = /* @__PURE__ */ c(() => {
              queueMicrotask(() => {
                if (u !== i.scrollHeight) {
                  if (d?.isConnected) {
                    const y = d.offsetTop - p;
                    i.scrollTop += y;
                  }
                  requestAnimationFrame(() => n = !1);
                } else
                  queueMicrotask(() => {
                    if (u !== i.scrollHeight) {
                      if (d?.isConnected) {
                        const y = d.offsetTop - p;
                        i.scrollTop += y;
                      }
                      requestAnimationFrame(() => n = !1);
                    } else
                      requestAnimationFrame(() => {
                        if (a.takeRecords().length && d?.isConnected) {
                          const y = d.offsetTop - p;
                          i.scrollTop += y;
                        }
                        requestAnimationFrame(() => n = !1);
                      });
                  });
              });
            }, "afterNext");
            t().then(f);
          } else
            t().then(() => {
              requestAnimationFrame(() => n = !1);
            });
      });
    },
    { root: r, threshold: yU, rootMargin: gU }
  );
  return a.observe(s), a;
}
h(mI, "G0");
c(mI, "createScroller");
var Gp;
const yI = (Gp = class {
  constructor(t, e = !1) {
    this.reverse = !1, this.isObservePending = !1, t.addController(this), this.host = t, this.reverse = e;
  }
  observe(t, e) {
    t && e && !t.isLoading && !this.isObservePending && (this.isObservePending = !0, requestAnimationFrame(() => {
      this.loadMoreRefElement = e, this.scroller?.disconnect(), this.scroller = mI(
        e,
        async () => {
          t.hasNextPage && !t.isFetching && (await t.fetchNextPage({ cancelRefetch: !1 }), this.reverse && await this.host.updateComplete);
        },
        this.reverse
      ), this.isObservePending = !1;
    }));
  }
  hostConnected() {
    this.loadMoreRefElement && this.scroller?.observe(this.loadMoreRefElement);
  }
  hostDisconnected() {
    this.scroller?.disconnect();
  }
}, h(Gp, "gw"), Gp);
c(yI, "InfiniteScrollController");
let Fl = yI;
var Kp;
const gI = (Kp = class extends Fl {
  constructor(t) {
    super(t, !0);
  }
}, h(Kp, "bw"), Kp);
c(gI, "ReverseInfiniteScrollController");
let wU = gI;
var An, Jc, Jp;
const wI = (Jp = class {
  constructor(t) {
    if (q(this, An), q(this, Jc), E(this, An, /* @__PURE__ */ new Map()), this.keyPrefix = "WEAVY_OFFLINE_CACHE", t)
      E(this, Jc, t);
    else
      try {
        Se(), E(this, Jc, window.sessionStorage);
      } catch {
        console.warn("Session storage not available.");
      }
  }
  resetPersistPropertiesCache() {
    x(this, An).clear();
  }
  getStorageItem(t, e) {
    const i = x(this, Jc)?.getItem(`${t}-${e.toString()}`);
    if (i)
      return JSON.parse(i);
  }
  setStorageItem(t, e, i) {
    const r = JSON.stringify(i);
    r && x(this, Jc)?.setItem(`${t}-${e.toString()}`, r);
  }
  persistProperties(t, e, i, r, n) {
    const a = `${this.keyPrefix}:${r ? `${r}:` : ""}${typeof t}:${e}`, o = /* @__PURE__ */ new Map();
    for (const l of i) {
      if (!x(this, An).has(l.name)) {
        const d = this.getStorageItem(a, l.name);
        d && (l.override || !t[l.name]) && (o.set(l.name, t[l.name]), t[l.name] = d), x(this, An).set(l.name, d);
      }
      if (n?.(o), t[l.name] !== x(this, An).get(l.name)) {
        const d = t[l.name];
        x(this, An).set(l.name, d), this.setStorageItem(a, l.name, d);
      }
    }
  }
}, h(Jp, "xw"), Jp);
An = /* @__PURE__ */ new WeakMap(), Jc = /* @__PURE__ */ new WeakMap(), c(wI, "PersistStorageCache");
let vU = wI;
var th, nw, tf;
const vI = (tf = class {
  constructor(t) {
    q(this, th), q(this, nw), E(this, th, ""), this.properties = [], this.initialProperties = /* @__PURE__ */ new Map(), this.persistStorageCache = new vU(), t.addController(this), this.host = t;
  }
  get prefixKey() {
    return x(this, th);
  }
  set prefixKey(t) {
    t !== x(this, th) && (this.persistStorageCache.resetPersistPropertiesCache(), E(this, th, t), this.host.requestUpdate());
  }
  get cachePrefix() {
    return x(this, nw);
  }
  set cachePrefix(t) {
    t !== x(this, nw) && (this.persistStorageCache.resetPersistPropertiesCache(), E(this, nw, t), this.host.requestUpdate());
  }
  observe(t, e, i, r) {
    this.properties = t, this.callback = r;
    const n = !!(this.prefixKey && this.prefixKey !== e || this.cachePrefix && this.cachePrefix !== i);
    this.properties.forEach((a) => {
      n && this.initialProperties.has(a.name) ? this.host[a.name] = this.initialProperties.get(a.name) : this.initialProperties.has(a.name) || this.initialProperties.set(a.name, this.host[a.name]);
    }), e && (this.prefixKey = e), i && (this.cachePrefix = i);
  }
  hostUpdate() {
    this.prefixKey && this.properties && this.host.weavy && this.persistStorageCache.persistProperties(this.host, this.prefixKey, this.properties, this.cachePrefix ? `${this.host.weavy.cachePrefix}:${this.cachePrefix}` : this.host.weavy.cachePrefix, this.callback);
  }
}, h(tf, "Cw"), tf);
th = /* @__PURE__ */ new WeakMap(), nw = /* @__PURE__ */ new WeakMap(), c(vI, "PersistStateController");
let Q1 = vI;
var ef;
const OU = (ef = class {
  constructor(t) {
    this.observers = [], this.conditions = {}, this.resizer = new ResizeObserver((e) => {
      let i = !1;
      for (const r of e)
        i = this.checkConditions(r) || i;
      i && this.host.requestUpdate();
    }), t.addController(this), this.host = t;
  }
  checkConditions(t) {
    let e = !1;
    return this.observers.forEach((i) => {
      if (t.target === i.target) {
        const r = this.conditions[i.name], n = i.condition(t);
        r !== n && (this.conditions[i.name] = n, e = !0);
      }
    }), e;
  }
  observe(t) {
    const e = t.target, i = e.getBoundingClientRect();
    this.observers.push(t), this.resizer.observe(e), this.checkConditions({
      contentBoxSize: [
        {
          inlineSize: e.clientWidth,
          blockSize: e.clientHeight
        }
      ],
      borderBoxSize: [
        {
          inlineSize: i.width,
          blockSize: i.height
        }
      ],
      devicePixelContentBoxSize: [
        {
          inlineSize: i.width * window.devicePixelRatio,
          blockSize: i.height * window.devicePixelRatio
        }
      ],
      contentRect: i,
      target: e
    });
  }
  reset() {
    this.conditions = {}, this.observers.length = 0, this.resizer.disconnect();
  }
  hostConnected() {
    this.observers.forEach((t) => {
      this.resizer.observe(t.target);
    });
  }
  hostDisconnected() {
    this.resizer.disconnect();
  }
}, h(ef, "$w"), ef);
c(OU, "ResizeController");
var rf;
const OI = (rf = class {
  constructor(t, e) {
    this.additionalTargets = /* @__PURE__ */ new Set(), this.setExportParts = (i) => {
      (!this.host.hasAttribute("exportparts") || this.shadowParts) && (this.shadowParts ??= /* @__PURE__ */ new Set(), i.forEach((r) => {
        r.part.forEach((n) => this.shadowParts?.add(n)), r.getAttribute("exportparts")?.split(", ").forEach((n) => this.shadowParts?.add(n));
      }), this.shadowParts.size && this.host.setAttribute("exportparts", Array.from(this.shadowParts.values()).join(", ")));
    }, t.addController(this), this.host = t, this.addLocalName = e;
  }
  addPartsFrom(t) {
    t && !this.additionalTargets.has(t) && (this.setExportParts([t]), this.observer?.observe(t, {
      attributeFilter: ["part", "exportparts"]
    }), this.additionalTargets.add(t));
  }
  async hostConnected() {
    if (await this.host.updateComplete, $k(this.host) && this.host.shadowRoot) {
      const t = Array.from(this.host.shadowRoot.querySelectorAll("[part], [exportparts]"));
      this.setExportParts(t), this.observer = new MutationObserver((e) => {
        const i = e.flatMap((r) => r.type === "attributes" ? [r.target] : Array.from(r.addedNodes)).filter((r) => r instanceof Element);
        this.setExportParts(i);
      }), this.observer.observe(this.host.shadowRoot, {
        subtree: !0,
        childList: !0,
        attributeFilter: ["part", "exportparts"]
      }), Array.from(this.additionalTargets).forEach((e) => {
        this.observer?.observe(e, {
          attributeFilter: ["part", "exportparts"]
        });
      });
    }
  }
  hostUpdated() {
    $k(this.host) && this.addLocalName !== !1 && !this.host.part.contains(this.host.localName) && (this.addLocalName || getComputedStyle(this.host).display !== "contents") && this.host.part.add(this.host.localName);
  }
  hostDisconnected() {
    this.observer?.disconnect();
  }
}, h(rf, "kw"), rf);
c(OI, "ShadowPartsController");
let rt = OI;
var sf;
const bI = (sf = class {
  constructor(t) {
    this.delay = NaN, this.sleep = !1, t.addController(this), this.host = t;
  }
  createObserver(t) {
    this.scrollObserver?.disconnect(), this.swipeElement = t, this.scrollObserver = new IntersectionObserver(
      (e) => {
        e.forEach(async (i) => {
          i.isIntersecting && !this.sleep && i.intersectionRatio >= 1 && (this.sleep = !0, Number.isNaN(this.delay) || await new Promise((r) => {
            setTimeout(r, this.delay);
          }), i.target === this.prevElement && this.whenPrev && await this.whenPrev(), i.target === this.nextElement && this.whenNext && await this.whenNext(), await this.host.updateComplete);
        });
      },
      { root: t, threshold: 1, rootMargin: "0px" }
    );
  }
  observe(t, e) {
    this.prevElement && (this.scrollObserver?.unobserve(this.prevElement), this.prevElement = void 0), this.nextElement && (this.scrollObserver?.unobserve(this.nextElement), this.nextElement = void 0), t && (this.scrollObserver?.observe(t), this.prevElement = t), e && (this.scrollObserver?.observe(e), this.nextElement = e), this.sleep = !1;
  }
  clearObserver() {
    this.prevElement = void 0, this.nextElement = void 0, this.scrollObserver?.disconnect(), this.sleep = !1;
  }
  hostConnected() {
    this.scrollObserver && (this.prevElement && this.scrollObserver.observe(this.prevElement), this.nextElement && this.scrollObserver.observe(this.nextElement), this.sleep = !1);
  }
  hostDisconnected() {
    this.scrollObserver?.disconnect();
  }
}, h(sf, "Pw"), sf);
c(bI, "SwipeScrollController");
let bU = bI;
var aw, eO, nf;
const $I = (nf = class {
  constructor(t, e) {
    q(this, aw), q(this, eO), E(this, aw, !0), this.styles = [], t.addController(this), this.host = t, e && (this.styles = e);
  }
  get themeColor() {
    return x(this, eO);
  }
  set themeColor(t) {
    E(this, eO, t), this.checkThemeUpdate();
  }
  checkThemeUpdate() {
    const t = this.themeColor || m0(this.host) || y0();
    if (t && t !== this._resolvedThemeColor) {
      this._resolvedThemeColor = t, console.info("Configuring theme", this._resolvedThemeColor);
      const e = mz(this._resolvedThemeColor).join(""), i = it`
        :host {
          ${M_(e)};
        }
      `, r = this.host.renderRoot;
      A_(r, [...this.styles, i]);
    }
  }
  hostUpdate() {
    x(this, aw) && (this.checkThemeUpdate(), E(this, aw, !1));
  }
  hostConnected() {
    this.cssObserverDisconnect = pz(this.host, () => this.checkThemeUpdate()), this.metaObserverDisconnect = fz(() => this.checkThemeUpdate());
  }
  hostDisconnected() {
    this.cssObserverDisconnect?.(), this.metaObserverDisconnect?.();
  }
}, h(nf, "_w"), nf);
aw = /* @__PURE__ */ new WeakMap(), eO = /* @__PURE__ */ new WeakMap(), c($I, "ThemeController");
let Ri = $I;
var af;
const xI = (af = class {
  constructor(t) {
    this.registrationRequested = !1, this.typingTimeout = null, this.discardTime = 5 * 1e3, this.typingMembers = [], this.names = [], this.ellipsis = "", this.handleRealtimeTyping = (e) => {
      e.entity.id === this.appId && e.actor.id !== this.userId && (this.setTypers(e.actor), this.updateTyping());
    }, this.handleRealtimeStopTyping = (e) => {
      this.typingMembers.forEach((i, r) => {
        i.id === e.actor.id && this.typingMembers.splice(r, 1);
      }), this.updateTyping();
    }, t.addController(this), this.host = t, this.setContexts();
  }
  get weavy() {
    return this.weavyContext?.value;
  }
  get componentFeatures() {
    return this._componentFeatures;
  }
  get appId() {
    return this._appId;
  }
  set appId(t) {
    t !== this._appId && (this.typingMembers = [], this.unregisterRealtime(), this._appId = t, this.registerRealtime());
  }
  get userId() {
    return this._userId;
  }
  set userId(t) {
    t !== this._userId && (this.typingMembers = [], this.unregisterRealtime(), this._userId = t, this.registerRealtime());
  }
  async setContexts() {
    this.whenWeavyContext = new Promise((t) => this.resolveWeavyContext = t), this.whenComponentFeaturesContext = new Promise((t) => this.resolveComponentFeaturesContext = t), await ks(this.host), this.weavyContext = new $r(this.host, { context: De, subscribe: !0 }), this.componentFeaturesContext = new $r(this.host, {
      context: Sb,
      subscribe: !0
    });
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
    const t = this.componentFeaturesContext && this.componentFeaturesContext.value?.allowsFeature(L.Typing) !== this._componentFeatures?.allowsFeature(L.Typing);
    t && (this._componentFeatures = this.componentFeaturesContext?.value, this.componentFeaturesContext?.value && this.resolveComponentFeaturesContext?.(this.componentFeaturesContext.value), t && (this.unregisterRealtime(!0), this.registerRealtime()));
  }
  async registerRealtime() {
    !this.registrationRequested && this.appId && this._userId && (this.registrationRequested = !0, await Promise.all([this.whenWeavyContext, this.whenComponentFeaturesContext]), this.componentFeatures?.allowsFeature(L.Typing) && (this.weavy?.subscribe(`a${this.appId}`, "typing", this.handleRealtimeTyping), this.weavy?.subscribe(`a${this.appId}`, "message_created", this.handleRealtimeStopTyping)), this.registrationRequested = !1);
  }
  async unregisterRealtime(t = !1) {
    !this.registrationRequested && this.appId && this.userId && (!t && await this.whenWeavyContext, this.weavy?.unsubscribe(`a${this.appId}`, "typing", this.handleRealtimeTyping), this.weavy?.unsubscribe(`a${this.appId}`, "message_created", this.handleRealtimeStopTyping));
  }
  /**
   * @fires typing
   */
  updateTyping() {
    this.typingTimeout && (clearTimeout(this.typingTimeout), this.typingTimeout = null);
    const t = Date.now();
    if (this.typingMembers.forEach((i, r) => {
      t - i.time > this.discardTime && this.typingMembers.splice(r, 1);
    }), this.typingMembers.length) {
      const i = Date.now(), r = Math.round(
        (i - Math.max.apply(
          null,
          this.typingMembers.map((n) => n.time)
        )) / 1e3
      ) % 3 + 1;
      this.ellipsis = ".".repeat(r), this.names = this.typingMembers.map((n) => n.name).sort(), this.typingTimeout = window.setTimeout(() => this.updateTyping(), 1e3);
    } else
      this.names = [];
    this.host.requestUpdate();
    const e = new CustomEvent("typing", {
      bubbles: !0,
      composed: !1,
      detail: { count: this.typingMembers.length }
    });
    this.host.dispatchEvent(e);
  }
  setTypers(t) {
    this.typingMembers.forEach((i, r) => {
      i.id === t.id && this.typingMembers.splice(r, 1);
    });
    const e = { ...t, time: Date.now() };
    this.typingMembers.push(e);
  }
  hostDisconnected() {
    this.typingTimeout && (clearTimeout(this.typingTimeout), this.typingTimeout = null), this.typingMembers.length = 0, this.names.length = 0, this.weavy && this.unregisterRealtime(!0);
  }
}, h(af, "Sw"), af);
c(xI, "TypingController");
let kI = xI;
var ow, of;
const SI = (of = class {
  constructor(t) {
    q(this, ow), this.appTypes = [], E(this, ow, 0), this.registrationRequested = !1, this.handleRefresh = () => {
      this.unreadQuery.result.refetch();
    }, t.addController(this), this.host = t, this.unreadQuery = new Qr(t), this.whenWeavyContext = new Promise((e) => this.resolveWeavyContext = e), this.setContexts(), this.registerRealtime();
  }
  /**
   * The number of unread items for the current scope
   */
  get unread() {
    return x(this, ow);
  }
  /**
   * Is the unread count pending?
   */
  get isUnreadPending() {
    return this.unreadQuery.result.isPending;
  }
  /**
   * The underlying query result for the unread count.
   */
  get unreadResult() {
    return this.unreadQuery.result;
  }
  get weavy() {
    return this.weavyContext?.value;
  }
  /**
   * Initiates context consumers
   */
  async setContexts() {
    await ks(this.host), this.weavyContext = new $r(this.host, { context: De, subscribe: !0 });
  }
  /**
   * Dispatch a `wy-unread` event on the host.
   *
   * @fires {WyUnreadEventType} wy-unread - Emitted when the number of unread items change.
   */
  dispatchUnreadEvent() {
    const t = new CustomEvent("wy-unread", {
      detail: { unread: this.unread },
      bubbles: !1,
      composed: !0
    });
    this.host.dispatchEvent(t);
  }
  /**
   * Register realtime handlers.
   */
  async registerRealtime() {
    this.registrationRequested || (this.registrationRequested = !0, await this.whenWeavyContext, this.weavy?.subscribe(null, "message_created", this.handleRefresh), this.weavy?.subscribe(null, "app_marked", this.handleRefresh), this.registrationRequested = !1);
  }
  /**
   * Unregister realtime handlers.
   *
   * @param skipAwait - Skip waiting for any context.
   */
  async unregisterRealtime(t = !1) {
    this.registrationRequested || (!t && await this.whenWeavyContext, this.weavy?.unsubscribe(null, "message_created", this.handleRefresh), this.weavy?.unsubscribe(null, "app_marked", this.handleRefresh));
  }
  async track(t, e) {
    this.appTypes = t, this.agent = e;
    const i = await this.whenWeavyContext;
    await this.unreadQuery.trackQuery(sI(i, t, this.agent), !0);
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
    const t = this.unreadQuery.result?.data?.count ?? 0;
    t !== this.unread && (E(this, ow, t), this.dispatchUnreadEvent(), this.host.requestUpdate());
  }
  hostDisconnected() {
    this.weavy && this.unregisterRealtime(!0);
  }
}, h(of, "Mw"), of);
ow = /* @__PURE__ */ new WeakMap(), c(SI, "UnreadConversationsController");
let zb = SI;
var jt = /* @__PURE__ */ ((s) => (s.All = "", s.Activity = "activity", s.Mention = "mention", s.Reaction = "reaction", s))(jt || {});
function CI(s, t, e = {}, i) {
  if (s) {
    if (s = JSON.parse(JSON.stringify(s)), s?.pages) {
      let r = -1;
      return {
        pages: [...s.pages.map((n, a) => {
          if (r >= 0)
            return n;
          const o = n.data || [], l = o.filter(
            (d) => d.id !== t.id && !0
          );
          return e && e.by ? (r = l.findIndex((d) => {
            let u = e.by && d[e.by], p = e.by && t[e.by];
            if (e.by === "updated_at" && (u ??= d.created_at, p ??= t.created_at), typeof u == "string" && typeof p == "string") {
              const f = u.localeCompare(p, void 0, {
                sensitivity: "base",
                numeric: !0
              });
              return e.descending ? f < 0 : f > 0;
            }
            return u && p && (e.descending ? u < p : u > p);
          }), r >= 0 ? (l.splice(r, 0, t), n.data = [...l], n.end && (n.end += 1 + l.length - o.length)) : s && a == s.pages.length - 1 && n.end === n.count ? (n.data = [...l, t], n.end && (n.end += 1 + l.length - o.length)) : n.data = [...l]) : a === 0 && (e.descending ? n.data = [t, ...l] : n.data = [...l, t], n.end && (n.end += 1 + l.length - o.length)), n;
        }) ?? []],
        pageParams: [...s.pageParams]
      };
    } else if (s?.data?.length) {
      let r = -1;
      const n = [
        ...s.data?.filter(
          (o) => o.id !== t.id && !0
        ) || []
      ];
      let a = s.count;
      return e && e.by ? (r = n.findIndex((o) => {
        let l = o[e.by], d = t[e.by];
        if (e.by === "updated_at" && (l ??= o.created_at, d ??= t.created_at), typeof l == "string" && typeof d == "string") {
          const u = l.localeCompare(d, void 0, {
            sensitivity: "base",
            numeric: !0
          });
          return e.descending ? u < 0 : u > 0;
        }
        return l && d && (e.descending ? l < d : l > d);
      }), r >= 0 ? n.splice(r, 0, t) : (n.push(t), a++)) : (e.descending ? n.unshift(t) : n.push(t), a++), {
        data: n,
        count: a
      };
    }
  }
  return s;
}
h(CI, "Z0");
c(CI, "addToQueryData");
function m4(s, t, e) {
  const i = t === void 0 ? () => !0 : t instanceof Function ? t : (r) => r.id === t;
  return s && (s = JSON.parse(JSON.stringify(s)), s.pages ? {
    pages: s.pages.map((r) => (r.data && (r.data = [
      ...r.data.map((n) => (i(n) && (n = { ...n }, e(n)), n))
    ]), r)) ?? [],
    pageParams: s.pageParams
  } : s.data?.length ? {
    ...s,
    data: [
      ...s.data?.map((r) => (i(r) && (r = { ...r }, e(r)), r)) || []
    ]
  } : s.data ? {
    data: [
      ...s.data.map((r) => (i(r) && (r = { ...r }, e(r)), r))
    ],
    count: s.count
  } : s);
}
h(m4, "Km");
c(m4, "updateQueryData");
function y4(s, t) {
  if (t !== void 0) {
    const e = t instanceof Function ? t : (i) => i.id === t;
    if (s) {
      if (s = JSON.parse(JSON.stringify(s)), s.pages)
        return {
          pages: s.pages.map((i) => (i.data && (i.data = [...i.data.filter((r) => !e(r))]), i)) ?? [],
          pageParams: s.pageParams
        };
      if (s.data?.length) {
        const i = s.data?.length;
        let r = s.count;
        const n = [...s.data?.filter((a) => !e(a)) || []];
        return i !== n.length && r--, {
          data: n,
          count: r
        };
      }
    }
  }
  return s;
}
h(y4, "Qm");
c(y4, "removeQueryData");
const ya = /* @__PURE__ */ c((s, t, e, i) => s.setQueryData(t, (r) => CI(r, e, i)), "addCacheItem"), ke = /* @__PURE__ */ c((s, t, e, i) => s.setQueryData(t, (r) => m4(
  r,
  e,
  i
)), "updateCacheItem"), Rt = /* @__PURE__ */ c((s, t, e, i) => {
  s.setQueriesData(t, (r) => m4(
    r,
    e,
    i
  ));
}, "updateCacheItems"), Ib = /* @__PURE__ */ c((s, t, e) => s.setQueryData(t, (i) => y4(
  i,
  e
)), "removeCacheItem"), $U = /* @__PURE__ */ c((s, t, e) => {
  s.setQueriesData(t, (i) => y4(i, e));
}, "removeCacheItems"), Hw = /* @__PURE__ */ c((s, t, e) => {
  s.setQueriesData(t, (i) => {
    const { count: r } = i;
    return { count: e(r) };
  });
}, "updateCacheItemsCount");
function iO(s, t, e, i = 1) {
  if (!s)
    return;
  const r = s.getQueryData(t);
  r?.pages?.length && r.pages.length > 1 && s.setQueryData(
    t,
    (n) => ({
      pages: n.pages.slice(0, i),
      pageParams: n.pageParams.slice(0, i)
    }),
    e
  );
}
h(iO, "Hu");
c(iO, "keepPages");
function ga(s, t, e) {
  const i = s.getQueryCache().find({ queryKey: t });
  if (i && i.state.data) {
    const r = i.state.data.pages.flatMap((n) => n.data).filter((n) => n && n.id < 0).sort((n, a) => n && a ? n.id - a.id : 0);
    return r.length ? e ? r[r.length - 1] : r[0] : null;
  }
  return null;
}
h(ga, "Mn");
c(ga, "getPendingCacheItem");
function T1(s, t, e) {
  const i = s.getQueryCache().find({ queryKey: t });
  return i && i.state.data ? i.state.data.pages.flatMap((r) => r.data).find((r) => r?.id === e) : null;
}
h(T1, "Ph");
c(T1, "getCacheItem");
function ys(s) {
  return (s?.pages.flatMap((t) => t.data) || []).filter((t) => t);
}
h(ys, "nr");
c(ys, "getFlatInfiniteResultData");
function PS(s) {
  return !s || !s?.pages.some((t) => t.data?.length);
}
h(PS, "hf");
c(PS, "isInfiniteResultDataEmpty");
function PI(s, t = jt.All, e, i = {}) {
  return {
    ...i,
    initialPageParam: 0,
    queryKey: ["notifications", "list", e, t],
    queryFn: /* @__PURE__ */ c(async (r) => {
      const n = new URLSearchParams({
        skip: r.pageParam?.toString() || "0",
        type: t
      }), a = `/api/${e ? `apps/${e.toString()}/` : ""}notifications?${n.toString()}`, o = await (await s.fetch(a)).json();
      return o.data = o.data || [], o;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ c((r) => {
      if (r.end && r.end < r.count)
        return r.end;
    }, "getNextPageParam")
  };
}
h(PI, "X0");
c(PI, "getNotificationsOptions");
function QI(s, t = jt.All, e) {
  const i = s.queryClient.getQueryData(["notifications", "list", e, t])?.pages.flatMap((n) => n.data);
  let r;
  return i?.forEach((n) => {
    r = r && n && r.id > n.id ? r : n;
  }), r;
}
h(QI, "J0");
c(QI, "getLastNotification");
function TI(s, t) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ notificationId: e }) => {
      const i = new URL(`/api/${t ? `apps/${t.toString()}/` : ""}notifications/mark`, s.url);
      e && i.searchParams.append("id", e.toString()), await s.fetch(i, { method: "PUT" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((e) => {
      const i = [];
      return Rt(
        s.queryClient,
        { queryKey: t ? ["notifications", "list", t] : ["notifications", "list"], exact: !1 },
        void 0,
        (r) => {
          i.push({ id: r.id, is_unread: r.is_unread }), r.is_unread = !1;
        }
      ), t && i.length && Rt(
        s.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        (r) => !!i.find((n) => n.id === r.id && r.is_unread),
        (r) => {
          r.is_unread = !1;
        }
      ), t || Hw(
        s.queryClient,
        { queryKey: ["notifications", "unread"], exact: !1 },
        () => 0
      ), Hw(
        s.queryClient,
        {
          queryKey: t ? ["apps", "notifications", "unread", t] : ["apps", "notifications", "unread"],
          exact: !1
        },
        () => 0
      ), { changedNotifications: i };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c(async () => {
      t && await s.queryClient.invalidateQueries({ queryKey: ["notifications", "unread"], exact: !1 });
    }, "onSuccess"),
    onSettled: /* @__PURE__ */ c(async () => {
      await s.queryClient.invalidateQueries({ queryKey: ["notifications", "list"], exact: !1 }), await s.queryClient.invalidateQueries({ queryKey: ["notifications", "unread"], exact: !1 }), await s.queryClient.invalidateQueries({ queryKey: ["apps", "notifications", "unread"], exact: !1 });
    }, "onSettled"),
    onError: /* @__PURE__ */ c((e, i, r) => {
      console.error(e.message);
    }, "onError")
  };
}
h(TI, "tb");
c(TI, "getMarkNotificationsMutationOptions");
function MI(s, t) {
  return new Yt(s.queryClient, TI(s, t));
}
h(MI, "eb");
c(MI, "getMarkNotificationsMutation");
function AI(s) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ markAsRead: t, notificationId: e }) => {
      const i = `/api/notifications/${e}/mark`;
      await s.fetch(i, { method: t ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((t) => {
      const e = /* @__PURE__ */ new Map();
      Rt(
        s.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        t.notificationId,
        (i) => {
          !!i.is_unread === t.markAsRead && e.set(i.id, i), i.is_unread = !t.markAsRead;
        }
      ), e.size && (Hw(
        s.queryClient,
        {
          queryKey: ["notifications", "unread"],
          predicate: /* @__PURE__ */ c((i) => i.queryKey[3] === "" || i.queryKey[3] === e.values().next().value?.type, "predicate"),
          exact: !1
        },
        (i) => Math.max(0, i + (t.markAsRead ? -1 : 1))
      ), e.forEach((i) => {
        i.link?.app && Hw(
          s.queryClient,
          {
            queryKey: ["apps", "notifications", "unread"],
            predicate: /* @__PURE__ */ c((r) => {
              const n = r.queryKey[3] === i.link?.app?.id || r.queryKey[3] === i.link?.app?.uid, a = r.queryKey[4] === "" || r.queryKey[4] === i.type;
              return n && a;
            }, "predicate"),
            exact: !1
          },
          (r) => Math.max(0, r + (t.markAsRead ? -1 : 1))
        );
      }));
    }, "onMutate"),
    onError: /* @__PURE__ */ c(async (t, e) => {
      Rt(
        s.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        e.notificationId,
        (i) => {
          i.is_unread = e.markAsRead;
        }
      ), await s.queryClient.invalidateQueries({ queryKey: ["notifications", "unread"], exact: !1 }), await s.queryClient.invalidateQueries({ queryKey: ["apps", "notifications", "unread"], exact: !1 });
    }, "onError")
  };
}
h(AI, "ib");
c(AI, "getMarkNotificationMutationOptions");
function g4(s) {
  return new Yt(s.queryClient, AI(s));
}
h(g4, "Gm");
c(g4, "getMarkNotificationMutation");
function RI(s, t = jt.All, e, i = {}) {
  const r = new URLSearchParams({
    type: t,
    count_only: "true",
    unread: "true"
  }), n = `/api/${e ? `apps/${e.toString()}/` : ""}notifications?${r.toString()}`;
  return Wy(s, e ? ["apps", "notifications", "unread", e, t] : ["notifications", "unread", t], n, i);
}
h(RI, "rb");
c(RI, "getUnreadOptions");
var lw, lf;
const EI = (lf = class {
  constructor(t) {
    q(this, lw), this.typeFilter = jt.All, E(this, lw, 0), this.registrationRequested = !1, this.handleRefresh = () => {
      this.unreadQuery.result.refetch();
    }, t.addController(this), this.host = t, this.unreadQuery = new Qr(t), this.whenWeavyContext = new Promise((e) => this.resolveWeavyContext = e), this.setContexts(), this.registerRealtime();
  }
  /**
   * The number of unread notifications for the current scope
   */
  get unread() {
    return x(this, lw);
  }
  /**
   * Is the unread count pending?
   */
  get isUnreadPending() {
    return this.unreadQuery.result.isPending;
  }
  /**
   * The underlying query result for the unread count.
   */
  get unreadResult() {
    return this.unreadQuery.result;
  }
  get weavy() {
    return this.weavyContext?.value;
  }
  /**
   * Initiates context consumers
   */
  async setContexts() {
    await ks(this.host), this.weavyContext = new $r(this.host, { context: De, subscribe: !0 });
  }
  /**
   * Dispatch a `wy-unread` event on the host.
   *
   * @fires {WyUnreadEventType} wy-unread - Emitted when the number of unread notifications change.
   */
  dispatchNotificationUnreadEvent() {
    const t = new CustomEvent("wy-unread", {
      detail: { unread: this.unread },
      bubbles: !1,
      composed: !0
    });
    this.host.dispatchEvent(t);
  }
  /**
   * Register realtime handlers.
   */
  async registerRealtime() {
    this.registrationRequested || (this.registrationRequested = !0, await this.whenWeavyContext, this.weavy?.subscribe(null, "notification_created", this.handleRefresh), this.weavy?.subscribe(null, "notification_updated", this.handleRefresh), this.weavy?.subscribe(null, "notifications_marked", this.handleRefresh), this.registrationRequested = !1);
  }
  /**
   * Unregister realtime handlers.
   *
   * @param skipAwait - Skip waiting for any context.
   */
  async unregisterRealtime(t = !1) {
    this.registrationRequested || (!t && await this.whenWeavyContext, this.weavy?.unsubscribe(null, "notification_created", this.handleRefresh), this.weavy?.unsubscribe(null, "notification_updated", this.handleRefresh), this.weavy?.unsubscribe(null, "notifications_marked", this.handleRefresh));
  }
  /**
   * Tracks unread data. Initiates the query data with the given filtering scope.
   *
   * @param typeFilter - The notification types to track.
   * @param appId - Optional app id for the filtering scope.
   */
  async track(t, e) {
    this.appId = e, this.typeFilter = t;
    const i = await this.whenWeavyContext;
    this.markNotificationsMutation = MI(i, this.appId), await this.unreadQuery.trackQuery(RI(i, this.typeFilter, this.appId), !0);
  }
  async markAllAsRead() {
    const t = await this.whenWeavyContext, e = QI(t, jt.All, this.appId)?.id;
    await this.markNotificationsMutation?.mutate({ notificationId: e });
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
    const t = this.unreadQuery.result?.data?.count ?? 0;
    t !== this.unread && (E(this, lw, t), this.dispatchNotificationUnreadEvent(), this.host.requestUpdate());
  }
  hostDisconnected() {
    this.weavy && this.unregisterRealtime(!0);
  }
}, h(lf, "Aw"), lf);
lw = /* @__PURE__ */ new WeakMap(), c(EI, "UnreadNotificationsController");
let w4 = EI;
var xU = Object.defineProperty, _I = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = void 0, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = a(t, e, r) || r);
  return r && xU(t, e, r), r;
}, "__decorateClass$1g"), cf;
const LI = (cf = class extends Ni {
  constructor() {
    super(...arguments), this.appType = Nn;
  }
}, h(cf, "Ew"), cf);
c(LI, "WeavyOptionalAppComponent");
let qy = LI;
_I([
  N()
], qy.prototype, "appType");
_I([
  b({ converter: r4 })
], qy.prototype, "uid");
var kU = Object.defineProperty, v4 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = void 0, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = a(t, e, r) || r);
  return r && kU(t, e, r), r;
}, "__decorateClass$1f"), cw, rO, hw, sO, dw, nO, hf;
const zI = (hf = class extends wt {
  constructor() {
    super(...arguments), q(this, cw), q(this, rO, new Promise((t) => {
      E(this, cw, t);
    })), q(this, hw), q(this, sO, new Promise((t) => {
      E(this, hw, t);
    })), q(this, dw), q(this, nO, new Promise((t) => {
      E(this, dw, t);
    }));
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  /**
   * Resolves when a contextual id is available.
   *
   * @internal
   * @returns {Promise<ContextIdType>}
   */
  async whenContextId() {
    return await x(this, rO);
  }
  /**
   * Resolves when current user data is available.
   *
   * @internal
   * @returns {Promise<UserType>}
   */
  async whenUser() {
    return await x(this, sO);
  }
  /**
   * Resolves when a weavy context is available.
   *
   * @internal
   * @returns {Promise<WeavyType>}
   */
  async whenWeavy() {
    return await x(this, nO);
  }
  willUpdate(t) {
    var e, i, r;
    super.willUpdate(t), t.has("contextId") && this.contextId && (t.get("contextId") && E(this, rO, new Promise((n) => {
      E(this, cw, n);
    })), (e = x(this, cw)) == null || e.call(this, this.contextId)), t.has("user") && this.user && (t.get("user") && E(this, sO, new Promise((n) => {
      E(this, hw, n);
    })), (i = x(this, hw)) == null || i.call(this, this.user)), t.has("weavy") && this.weavy && (t.get("weavy") && E(this, nO, new Promise((n) => {
      E(this, dw, n);
    })), (r = x(this, dw)) == null || r.call(this, this.weavy));
  }
  connectedCallback() {
    super.connectedCallback(), this.contextId && this.requestUpdate("contextId"), this.user && this.requestUpdate("user"), this.weavy && this.requestUpdate("weavy");
  }
}, h(hf, "Rw"), hf);
cw = /* @__PURE__ */ new WeakMap(), rO = /* @__PURE__ */ new WeakMap(), hw = /* @__PURE__ */ new WeakMap(), sO = /* @__PURE__ */ new WeakMap(), dw = /* @__PURE__ */ new WeakMap(), nO = /* @__PURE__ */ new WeakMap(), c(zI, "WeavySubComponent");
let Xi = zI;
v4([
  Xe({ context: xz, subscribe: !0 }),
  N()
], Xi.prototype, "contextId");
v4([
  Xe({ context: Pb, subscribe: !0 }),
  N()
], Xi.prototype, "user");
v4([
  Xe({ context: De, subscribe: !0 }),
  N()
], Xi.prototype, "weavy");
var SU = Object.defineProperty, M1 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = void 0, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = a(t, e, r) || r);
  return r && SU(t, e, r), r;
}, "__decorateClass$1e"), uw, aO, pw, oO, fw, lO, mw, cO, yw, hO, df;
const II = (df = class extends Xi {
  constructor() {
    super(...arguments), q(this, uw), q(this, aO, new Promise((t) => {
      E(this, uw, t);
    })), q(this, pw), q(this, oO, new Promise((t) => {
      E(this, pw, t);
    })), q(this, fw), q(this, lO, new Promise((t) => {
      E(this, fw, t);
    })), q(this, mw), q(this, cO, new Promise((t) => {
      E(this, mw, t);
    })), q(this, yw), q(this, hO, new Promise((t) => {
      E(this, yw, t);
    }));
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  /**
   * Resolves when app data is available.
   *
   * @returns {Promise<AppType>}
   */
  async whenApp() {
    return await x(this, aO);
  }
  // #resolveAgentUser?: (agentUser: AgentType) => void;
  // #whenAgentUser = new Promise<AgentType>((r) => {
  //   this.#resolveAgentUser = r;
  // });
  // async whenAgentUser() {
  //   return await this.#whenAgentUser;
  // }
  /**
   * Resolves when context data blob uploads has finished.
   *
   * @internal
   * @returns {Promise<ContextDataBlobsType>}
   */
  async whenContextDataBlobs() {
    return await x(this, oO);
  }
  /**
   * Resolves when weavy component features config is available.
   *
   * @internal
   * @returns {Promise<ComponentFeaturePolicy>}
   */
  async whenComponentFeatures() {
    return await x(this, lO);
  }
  /**
   * Resolves when a provided link is available.
   *
   * @returns {Promise<LinkType>}
   */
  async whenLink() {
    return await x(this, cO);
  }
  /**
   * Resolves when weavy component settings are available.
   *
   * @internal
   * @returns {Promise<WeavyComponentSettingsType>}
   */
  async whenSettings() {
    return await x(this, hO);
  }
  willUpdate(t) {
    var e, i, r, n, a;
    super.willUpdate(t), t.has("app") && this.app && (t.get("app") && E(this, aO, new Promise((o) => {
      E(this, uw, o);
    })), (e = x(this, uw)) == null || e.call(this, this.app)), t.has("contextDataBlobs") && this.contextDataBlobs && (t.get("contextDataBlobs") && E(this, oO, new Promise((o) => {
      E(this, pw, o);
    })), (i = x(this, pw)) == null || i.call(this, this.contextDataBlobs)), t.has("componentFeatures") && this.componentFeatures && (t.get("componentFeatures") && E(this, lO, new Promise((o) => {
      E(this, fw, o);
    })), (r = x(this, fw)) == null || r.call(this, this.componentFeatures)), t.has("link") && this.link && (t.get("link") && E(this, cO, new Promise((o) => {
      E(this, mw, o);
    })), (n = x(this, mw)) == null || n.call(this, this.link)), t.has("settings") && this.settings && (t.get("settings") && E(this, hO, new Promise((o) => {
      E(this, yw, o);
    })), (a = x(this, yw)) == null || a.call(this, this.settings));
  }
  connectedCallback() {
    super.connectedCallback(), this.app && this.requestUpdate("app"), this.contextDataBlobs && this.requestUpdate("contextDataBlobs"), this.componentFeatures && this.requestUpdate("componentFeatures"), this.link && this.requestUpdate("link"), this.settings && this.requestUpdate("settings");
  }
}, h(df, "Tw"), df);
uw = /* @__PURE__ */ new WeakMap(), aO = /* @__PURE__ */ new WeakMap(), pw = /* @__PURE__ */ new WeakMap(), oO = /* @__PURE__ */ new WeakMap(), fw = /* @__PURE__ */ new WeakMap(), lO = /* @__PURE__ */ new WeakMap(), mw = /* @__PURE__ */ new WeakMap(), cO = /* @__PURE__ */ new WeakMap(), yw = /* @__PURE__ */ new WeakMap(), hO = /* @__PURE__ */ new WeakMap(), c(II, "WeavySubAppComponent");
let Pe = II;
M1([
  Xe({ context: e4, subscribe: !0 }),
  N()
], Pe.prototype, "app");
M1([
  Xe({ context: kz, subscribe: !0 }),
  N()
], Pe.prototype, "contextDataBlobs");
M1([
  Xe({ context: Sb, subscribe: !0 }),
  N()
], Pe.prototype, "componentFeatures");
M1([
  Xe({ context: Cz, subscribe: !0 }),
  N()
], Pe.prototype, "link");
M1([
  Xe({ context: Qz, subscribe: !0 }),
  N()
], Pe.prototype, "settings");
function DI(s) {
  return typeof s == "string" && s ? s = eval?.(`"use strict";(${s})`) : s = void 0, s;
}
h(DI, "ob");
c(DI, "indirectEvalObject");
function Db(s) {
  if (s)
    try {
      return new URL(s, window.location.toString());
    } catch {
      console.warn("Invalid url: ", s);
    }
}
h(Db, "my");
c(Db, "toUrl");
const Y = /* @__PURE__ */ c((s) => (t, e) => {
  e !== void 0 ? e.addInitializer(() => {
    !customElements.get(s) && customElements.define(
      s,
      t
    );
  }) : !customElements.get(s) && customElements.define(s, t);
}, "customElement"), ft = it`:host{display:contents}`;
var CU = Object.defineProperty, PU = Object.getOwnPropertyDescriptor, je = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? PU(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && CU(t, e, r), r;
}, "__decorateClass$1d");
function QS(s) {
  return s != null && s !== !1;
}
h(QS, "uf");
c(QS, "acceptedValue");
var C$, uf;
let ye = (C$ = (uf = class extends wt {
  constructor() {
    super(), this.provider = !1, this.annotations = Re.defaults.annotations, this.cloudFilePickerUrl = Re.defaults.cloudFilePickerUrl, this.configurationTimeout = Re.defaults.configurationTimeout, this.disableEnvironmentImports = Re.defaults.disableEnvironmentImports, this.enterToSend = Re.defaults.enterToSend, this.locale = Re.defaults.locale, this.locales = Re.defaults.locales, this.gcTime = Re.defaults.gcTime, this.scrollBehavior = Re.defaults.scrollBehavior, this.staleTime = Re.defaults.staleTime, this.tokenFactory = Re.defaults.tokenFactory, this.tokenFactoryRetryDelay = Re.defaults.tokenFactoryRetryDelay, this.tokenFactoryTimeout = Re.defaults.tokenFactoryTimeout, this.tokenUrl = Re.defaults.tokenUrl, this.url = Re.defaults.url, this.reactions = Re.defaults.reactions, this.childElementCount && (this.provider = !0), this.weavy ??= new Re({ host: this.provider ? this : void 0 });
  }
  /** The semver version of the package. */
  get version() {
    return Re.version;
  }
  /** The Weavy source name; package name. */
  get sourceName() {
    return Re.sourceName;
  }
  willUpdate(t) {
    if (super.willUpdate(t), this.weavy) {
      const e = {};
      Array.from(t.keys()).forEach((i) => {
        i !== "weavy" && (QS(this[i]) || QS(t.get(i))) && Object.assign(e, { [i]: this[i] });
      }), Object.assign(this.weavy, e);
    }
  }
  render() {
    return v` <slot></slot> `;
  }
}, h(uf, "Os"), uf), c(C$, "WyContext"), C$);
ye.styles = [Ie, ft];
je([
  b({ attribute: !0, type: Boolean })
], ye.prototype, "provider", 2);
je([
  b()
], ye.prototype, "annotations", 2);
je([
  b({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ c((s) => Db(s), "fromAttribute")
    }
  })
], ye.prototype, "cloudFilePickerUrl", 2);
je([
  b({ type: Number, attribute: !0 })
], ye.prototype, "configurationTimeout", 2);
je([
  b({ type: Boolean })
], ye.prototype, "disableEnvironmentImports", 2);
je([
  b({ attribute: !0 })
], ye.prototype, "enterToSend", 2);
je([
  b({ attribute: !0 })
], ye.prototype, "locale", 2);
je([
  b({ attribute: !0, type: Array })
], ye.prototype, "locales", 2);
je([
  b({ attribute: !0, type: Number })
], ye.prototype, "gcTime", 2);
je([
  b({ attribute: !0 })
], ye.prototype, "scrollBehavior", 2);
je([
  b({ attribute: !0, type: Number })
], ye.prototype, "staleTime", 2);
je([
  b({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ c((s) => DI(s), "fromAttribute")
    }
  })
], ye.prototype, "tokenFactory", 2);
je([
  b({ attribute: !0, type: Number })
], ye.prototype, "tokenFactoryRetryDelay", 2);
je([
  b({ attribute: !0, type: Number })
], ye.prototype, "tokenFactoryTimeout", 2);
je([
  b({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ c((s) => Db(s), "fromAttribute")
    }
  })
], ye.prototype, "tokenUrl", 2);
je([
  b({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ c((s) => Db(s), "fromAttribute")
    }
  })
], ye.prototype, "url", 2);
je([
  b({ attribute: !0 })
], ye.prototype, "reactions", 2);
je([
  N()
], ye.prototype, "weavy", 2);
ye = je([
  Y("wy-context")
], ye);
const Ei = it`:host{font-family:var(--wy-font-family, unset)}`;
var QU = Object.defineProperty, TU = Object.getOwnPropertyDescriptor, O4 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? TU(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && QU(t, e, r), r;
}, "__decorateClass$1c"), P$, pf;
let yl = (P$ = (pf = class extends Ni {
  constructor() {
    super(...arguments), this.appType = Nn, this.componentFeatures = new di(Cb(kS)), this.theme = new Ri(this, yl.styles);
  }
  render() {
    return v`<slot></slot>`;
  }
}, h(pf, "zs"), pf), c(P$, "WyComponent"), P$);
yl.styles = [Ie, ft, Ei];
O4([
  b({
    converter: {
      fromAttribute(s, t) {
        return uU.get(s) ?? s;
      }
    }
  })
], yl.prototype, "appType", 2);
O4([
  b({
    converter: {
      fromAttribute(s, t) {
        const e = typeof s == "string" ? i4(s, kS) : kS;
        return new di(Cb(e));
      }
    }
  })
], yl.prototype, "componentFeatures", 2);
yl = O4([
  Y("wy-component")
], yl);
const vn = it`:host{position:relative;display:flex;flex-direction:column;flex:1;min-height:3rem;min-width:16rem;isolation:isolate;box-sizing:border-box;container-type:inline-size}`, ql = it`:host{padding:var(--wy-padding-outer, 0);border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}`, Zl = it`:host{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}:host:not(body){-webkit-overflow-scrolling:touch}`;
function VI(s, t, e = {}) {
  return {
    ...e,
    initialPageParam: 0,
    queryKey: ["messages", t],
    queryFn: /* @__PURE__ */ c(async (i) => {
      const r = i.pageParam, n = "/api/apps/" + t + "/messages?order_by=id+desc&skip=" + r, a = await (await s.fetch(n)).json();
      return a.data = a.data?.reverse() || [], a;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ c((i) => {
      if (i?.end && i?.end < i?.count)
        return i.end;
    }, "getNextPageParam"),
    select: /* @__PURE__ */ c((i) => ({
      // reverse scroll
      pages: [...i.pages].reverse(),
      pageParams: [...i.pageParams].reverse()
    }), "select")
  };
}
h(VI, "ub");
c(VI, "getMessagesOptions");
function WI(s, t) {
  return {
    mutationFn: /* @__PURE__ */ c(async (e) => await (await s.fetch("/api/apps/" + e.app_id + "/messages", {
      method: "POST",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        embed_id: e.embed_id || null,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ text: i.text })),
        metadata: e.metadata || null,
        context: e.context
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ c((e) => {
      const i = ["messages", e.app_id], r = ga(s.queryClient, i, !1), n = {
        id: r ? r.id - 1 : -1,
        app: { id: e.app_id },
        text: e.text,
        html: e.text,
        plain: e.text,
        created_by: e.user,
        created_at: (/* @__PURE__ */ new Date()).toUTCString(),
        attachments: { count: 0 },
        reactions: { count: 0 },
        is_starred: !1,
        is_subscribed: !0,
        is_trashed: !1
      };
      ya(s.queryClient, i, n);
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((e) => {
      Rt(
        s.queryClient,
        { queryKey: ["members", e.app.id] },
        e.created_by.id,
        (l) => {
          l.marked_id = e.id, l.marked_at = e.created_at;
        }
      );
      const i = ["messages", e.app.id], { queryClient: r } = s, n = T1(r, i, e.id), a = n ? null : ga(r, i, !0), o = /* @__PURE__ */ c((l, d) => {
        ke(r, i, l, (u) => {
          u.id = d.id, u.app = d.app, u.text = d.text, u.plain = d.plain, u.html = d.html, u.embed = d.embed, u.meeting = d.meeting, u.attachments = d.attachments, u.options = d.options, u.created_at = d.created_at, u.created_by = d.created_by, u.updated_at = d.updated_at, u.updated_by = d.updated_by;
        });
      }, "replaceCacheItem");
      n ? o(n.id, e) : a ? o(a.id, e) : ya(r, i, e);
    }, "onSuccess")
  };
}
h(WI, "pb");
c(WI, "getAddMessageMutationOptions");
const { I: MU } = rj, AU = /* @__PURE__ */ c((s) => s.strings === void 0, "f$1"), b9 = /* @__PURE__ */ c(() => document.createComment(""), "r$1"), Sg = /* @__PURE__ */ c((s, t, e) => {
  const i = s._$AA.parentNode, r = t === void 0 ? s._$AB : t._$AA;
  if (e === void 0) {
    const n = i.insertBefore(b9(), r), a = i.insertBefore(b9(), r);
    e = new MU(n, a, s, s.options);
  } else {
    const n = e._$AB.nextSibling, a = e._$AM, o = a !== s;
    if (o) {
      let l;
      e._$AQ?.(s), e._$AM = s, e._$AP !== void 0 && (l = s._$AU) !== a._$AU && e._$AP(l);
    }
    if (n !== r || o) {
      let l = e._$AA;
      for (; l !== n; ) {
        const d = l.nextSibling;
        i.insertBefore(l, r), l = d;
      }
    }
  }
  return e;
}, "s$1"), to = /* @__PURE__ */ c((s, t, e = s) => (s._$AI(t, e), s), "v"), RU = {}, FI = /* @__PURE__ */ c((s, t = RU) => s._$AH = t, "m"), EU = /* @__PURE__ */ c((s) => s._$AH, "p"), Q$ = /* @__PURE__ */ c((s) => {
  s._$AR(), s._$AA.remove();
}, "M"), A1 = { ATTRIBUTE: 1, CHILD: 2 }, Bl = /* @__PURE__ */ c((s) => (...t) => ({ _$litDirective$: s, values: t }), "e$2");
var T$, ff;
let Zy = (T$ = (ff = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, i) {
    this._$Ct = t, this._$AM = e, this._$Ci = i;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
}, h(ff, "Is"), ff), c(T$, "i"), T$);
const Sw = /* @__PURE__ */ c((s, t) => {
  const e = s._$AN;
  if (e === void 0) return !1;
  for (const i of e) i._$AO?.(t, !1), Sw(i, t);
  return !0;
}, "s"), S0 = /* @__PURE__ */ c((s) => {
  let t, e;
  do {
    if ((t = s._$AM) === void 0) break;
    e = t._$AN, e.delete(s), s = t;
  } while (e?.size === 0);
}, "o$5"), qI = /* @__PURE__ */ c((s) => {
  for (let t; t = s._$AM; s = t) {
    let e = t._$AN;
    if (e === void 0) t._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(s)) break;
    e.add(s), _U(t);
  }
}, "r");
function ZI(s) {
  this._$AN !== void 0 ? (S0(this), this._$AM = s, qI(this)) : this._$AM = s;
}
h(ZI, "vb");
c(ZI, "h$1");
function BI(s, t = !1, e = 0) {
  const i = this._$AH, r = this._$AN;
  if (r !== void 0 && r.size !== 0) if (t) if (Array.isArray(i)) for (let n = e; n < i.length; n++) Sw(i[n], !1), S0(i[n]);
  else i != null && (Sw(i, !1), S0(i));
  else Sw(this, s);
}
h(BI, "gb");
c(BI, "n$2");
const _U = /* @__PURE__ */ c((s) => {
  s.type == A1.CHILD && (s._$AP ??= BI, s._$AQ ??= ZI);
}, "c$1");
var mf;
const NI = (mf = class extends Zy {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, e, i) {
    super._$AT(t, e, i), qI(this), this.isConnected = t._$AU;
  }
  _$AO(t, e = !0) {
    t !== this.isConnected && (this.isConnected = t, t ? this.reconnected?.() : this.disconnected?.()), e && (Sw(this, t), S0(this));
  }
  setValue(t) {
    if (AU(this._$Ct)) this._$Ct._$AI(t, this);
    else {
      const e = [...this._$Ct._$AH];
      e[this._$Ci] = t, this._$Ct._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}, h(mf, "Lw"), mf);
c(NI, "f");
let LU = NI;
const $t = /* @__PURE__ */ c(() => new zU(), "e$1");
var yf;
const XI = (yf = class {
}, h(yf, "Ow"), yf);
c(XI, "h");
let zU = XI;
const M$ = /* @__PURE__ */ new WeakMap(), ht = Bl(class extends LU {
  render(s) {
    return C;
  }
  update(s, [t]) {
    const e = t !== this.G;
    return e && this.G !== void 0 && this.rt(void 0), (e || this.lt !== this.ct) && (this.G = t, this.ht = s.options?.host, this.rt(this.ct = s.element)), C;
  }
  rt(s) {
    if (this.isConnected || (s = void 0), typeof this.G == "function") {
      const t = this.ht ?? globalThis;
      let e = M$.get(t);
      e === void 0 && (e = /* @__PURE__ */ new WeakMap(), M$.set(t, e)), e.get(this.G) !== void 0 && this.G.call(this.ht, void 0), e.set(this.G, s), s !== void 0 && this.G.call(this.ht, s);
    } else this.G.value = s;
  }
  get lt() {
    return typeof this.G == "function" ? M$.get(this.ht ?? globalThis)?.get(this.G) : this.G?.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
function jI(s, t, e) {
  const i = s.queryClient;
  return {
    mutationKey: ["apps", t, "polls"],
    mutationFn: /* @__PURE__ */ c(async ({ optionId: r }) => {
      const n = await s.fetch(`/api/options/${r}/vote`, { method: "POST" });
      if (!n.ok) {
        const a = await n.json();
        throw new Error(a.detail || a.title, { cause: a });
      }
      return await n.json();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((r) => (Rt(i, { queryKey: e }, r.parentId, (n) => {
      n.options?.data && (n.options.data = n.options.data?.map((a) => {
        if (a.has_voted) {
          a.has_voted = !1;
          const o = a.votes?.count || 1;
          a.votes ? a.votes.count = o - 1 : a.votes = { count: o - 1 };
        } else if (!a.has_voted && a.id === r.optionId) {
          a.has_voted = !0;
          const o = a.votes?.count || 0;
          a.votes ? a.votes.count = o + 1 : a.votes = { count: o + 1 };
        }
        return a;
      }));
    }), { id: r.optionId }), "onMutate"),
    onSuccess: /* @__PURE__ */ c(async (r, n) => {
      const a = await (await s.fetch("/api/" + n.parentType + "/" + n.parentId)).json();
      Rt(
        i,
        { queryKey: e, exact: !1 },
        n.parentId,
        (o) => Object.assign(o, a)
      );
    }, "onSuccess")
    /*onError(error: Error, variables: MutatePollVariables) {
      updateCacheItems(queryClient, { queryKey: postsKey, exact: false }, variables.id, (existingPost: PostType) => Object.assign(existingPost, { is_subscribed: variables..is_subscribed }));
    },*/
  };
}
h(jI, "xb");
c(jI, "getPollMutationOptions");
function Vb(s, t, e) {
  return new Yt(s.queryClient, jI(s, t, e));
}
h(Vb, "gy");
c(Vb, "getPollMutation");
function UI(s, t) {
  return {
    queryKey: ["votes", t],
    enabled: !1,
    queryFn: /* @__PURE__ */ c(async () => await (await s.fetch(`/api/options/${t}`)).json(), "queryFn")
  };
}
h(UI, "Cb");
c(UI, "getVotesOptions");
const Oy = /* @__PURE__ */ c((s, t) => !!(s && t && t.indexOf(s) !== -1), "hasPermission");
function HI(s) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ app: t, messageId: e }) => {
      const i = e ? `/api/apps/${t.id}/mark?messageId=${e}` : `/api/apps/${t.id}/mark`;
      await s.fetch(i, { method: e ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (t) => {
      await s.queryClient.cancelQueries({ queryKey: ["apps", t.app.id] }), await s.queryClient.cancelQueries({ queryKey: ["apps", "list"], exact: !1 }), await s.queryClient.cancelQueries({ queryKey: ["apps", "unread"], exact: !1 }), await s.queryClient.cancelQueries({ queryKey: ["members", t.app.id] }), s.queryClient.setQueryData(
        ["apps", t.app.id],
        (e) => e && { ...e, is_unread: !t.messageId || t.messageId < e.last_message.id }
      ), Rt(
        s.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.app.id,
        (e) => {
          e.is_unread = !t.messageId || t.messageId < e.last_message.id;
        }
      ), t.userId && Rt(s.queryClient, { queryKey: ["members", t.app.id] }, t.userId, (e) => {
        t.messageId ? (e.marked_at = (/* @__PURE__ */ new Date()).toISOString(), e.marked_id = t.messageId) : (e.marked_at = void 0, e.marked_id = void 0);
      }), Hw(
        s.queryClient,
        {
          queryKey: ["apps", "unread"],
          exact: !1,
          predicate: /* @__PURE__ */ c((e) => {
            const i = e.queryKey[2].includes(t.app.type), r = e.queryKey[2], n = !r || !!t.app.members.data?.find((a) => a.uid && a.uid === r);
            return i && n;
          }, "predicate")
        },
        (e) => Math.max(0, e + (t.messageId ? -1 : 1))
      );
    }, "onMutate"),
    onError: /* @__PURE__ */ c((t, e) => {
      console.error(t.message), Rt(
        s.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        e.app.id,
        (i) => {
          i.is_unread = !i.is_unread;
        }
      );
    }, "onError"),
    onSettled: /* @__PURE__ */ c(async (t, e, i) => {
      await s.queryClient.invalidateQueries({ queryKey: ["apps", i.app.id] }), await s.queryClient.invalidateQueries({ queryKey: ["apps", "list"], exact: !1 }), await s.queryClient.invalidateQueries({ queryKey: ["apps", "unread"], exact: !1 }), await s.queryClient.invalidateQueries({ queryKey: ["members", i.app.id] });
    }, "onSettled")
  };
}
h(HI, "$b");
c(HI, "getMarkConversationMutationOptions");
function YI(s) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ appId: t, star: e }) => {
      await s.fetch(`/api/apps/${t}/stars`, { method: e ? "POST" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((t) => {
      Rt(
        s.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.appId,
        (e) => {
          e.is_starred = t.star;
        }
      );
    }, "onMutate"),
    onError: /* @__PURE__ */ c((t, e) => {
      console.error(t.message), Rt(
        s.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        e.appId,
        (i) => {
          i.is_starred = !e.star;
        }
      );
    }, "onError")
  };
}
h(YI, "kb");
c(YI, "getStarConversationMutationOptions");
function GI(s) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ appId: t, pin: e }) => {
      await s.fetch(`/api/apps/${t}/pin`, { method: e ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((t) => {
      Rt(
        s.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.appId,
        (e) => {
          e.is_pinned = t.pin;
        }
      );
    }, "onMutate"),
    onSettled: /* @__PURE__ */ c(async () => {
      await s.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
h(GI, "Pb");
c(GI, "getPinConversationMutationOptions");
function KI(s) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ appId: t, members: e }) => {
      await s.fetch(`/api/apps/${t}/members/${e.join(",")}`, { method: "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((t) => {
      Ib(s.queryClient, ["apps", "list"], t.appId);
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((t, e) => {
      s.queryClient.removeQueries({ queryKey: ["apps", e.appId] }), s.queryClient.removeQueries({ queryKey: ["members", e.appId] });
    }, "onSuccess"),
    onSettled: /* @__PURE__ */ c(async () => {
      await s.queryClient.invalidateQueries({ queryKey: ["apps"] }), await s.queryClient.invalidateQueries({ queryKey: ["members"] });
    }, "onSettled")
  };
}
h(KI, "_b");
c(KI, "getLeaveConversationMutationOptions");
function JI(s) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ appId: t }) => {
      await s.fetch(`/api/apps/${t}/remove`, { method: "POST" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((t) => {
      Ib(s.queryClient, ["apps", "list"], t.appId);
    }, "onMutate"),
    onSettled: /* @__PURE__ */ c(async () => {
      await s.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
h(JI, "Sb");
c(JI, "getRemoveConversationMutationOptions");
function tD(s) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ appId: t, userId: e, access: i }) => {
      await s.fetch(`/api/apps/${t}/members/${e}`, { method: "PUT", body: JSON.stringify({ access: i }) });
    }, "mutationFn"),
    onSettled: /* @__PURE__ */ c(async (t, e, i) => {
      await s.queryClient.invalidateQueries({ queryKey: ["apps"] }), await s.queryClient.invalidateQueries({ queryKey: ["members", i.appId] });
    }, "onSettled")
  };
}
h(tD, "Mb");
c(tD, "getUpdateMemberMutationOptions");
function eD(s) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ appId: t, members: e }) => {
      await s.fetch(`/api/apps/${t}/members`, {
        method: "PUT",
        body: JSON.stringify(
          e.map((i) => ({ id: i, access: "write" }))
        )
      });
    }, "mutationFn"),
    onSettled: /* @__PURE__ */ c(async (t, e, i) => {
      await s.queryClient.invalidateQueries({ queryKey: ["apps"] }), await s.queryClient.invalidateQueries({ queryKey: ["members", i.appId] });
    }, "onSettled")
  };
}
h(eD, "Ab");
c(eD, "getAddMembersToConversationMutationOptions");
function iD(s) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ appId: t, name: e, blobId: i }) => await (await s.fetch(`/api/apps/${t}`, {
      method: "PATCH",
      body: JSON.stringify({
        name: e,
        picture: i
      })
    })).json(), "mutationFn"),
    onMutate: /* @__PURE__ */ c((t) => {
      const e = /* @__PURE__ */ c((i) => {
        typeof t.name == "string" && (i.name = t.name), typeof t?.thumbnailUrl == "string" && (i.avatar_url = t.thumbnailUrl);
      }, "modifyAppItem");
      ke(s.queryClient, ["apps", t.appId], void 0, e), Rt(s.queryClient, { queryKey: ["apps", "list"], exact: !1 }, t.appId, e);
    }, "onMutate")
  };
}
h(iD, "Eb");
c(iD, "getUpdateConversationMutationOptions");
function rD(s) {
  return {
    mutationFn: /* @__PURE__ */ c(async ({ appId: t }) => {
      await s.fetch(`/api/apps/${t}/trash`, { method: "POST" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((t) => {
      Ib(s.queryClient, ["apps", "list"], t.appId);
    }, "onMutate"),
    onSettled: /* @__PURE__ */ c(async () => {
      await s.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
h(rD, "Rb");
c(rD, "getTrashConversationMutationOptions");
function b4(s) {
  return new Yt(s.queryClient, HI(s));
}
h(b4, "Jm");
c(b4, "getMarkConversationMutation");
function sD(s) {
  return new Yt(s.queryClient, YI(s));
}
h(sD, "Tb");
c(sD, "getStarConversationMutation");
function nD(s) {
  return new Yt(s.queryClient, GI(s));
}
h(nD, "Lb");
c(nD, "getPinConversationMutation");
function $4(s) {
  return new Yt(s.queryClient, KI(s));
}
h($4, "tv");
c($4, "getLeaveConversationMutation");
function aD(s) {
  return new Yt(s.queryClient, JI(s));
}
h(aD, "Ob");
c(aD, "getRemoveConversationMutation");
function oD(s) {
  return new Yt(s.queryClient, tD(s));
}
h(oD, "zb");
c(oD, "getUpdateMemberMutation");
function lD(s) {
  return new Yt(s.queryClient, eD(s));
}
h(lD, "Ib");
c(lD, "getAddMembersToConversationMutation");
function x4(s) {
  return new Yt(s.queryClient, iD(s));
}
h(x4, "ev");
c(x4, "getUpdateConversationMutation");
function cD(s) {
  return new Yt(s.queryClient, rD(s));
}
h(cD, "Fb");
c(cD, "getTrashConversationMutation");
function k4(s, t, e = [xt.ChatRoom, xt.PrivateChat], i) {
  return Wy(s, ["apps", t], void 0, {
    initialData: /* @__PURE__ */ c(() => s?.queryClient.getQueryData(["apps", "list", e, i])?.pages.flatMap((r) => r.data).find((r) => r?.id === t), "initialData")
  });
}
h(k4, "iv");
c(k4, "getConversationOptions");
function S4(s, t, e) {
  return {
    queryKey: ["members", t],
    queryFn: /* @__PURE__ */ c(async () => await (await s.fetch(`/api/apps/${t}/members`)).json(), "queryFn"),
    ...e
  };
}
h(S4, "rv");
c(S4, "getMemberOptions");
function hD(s, t, e, i) {
  return {
    queryKey: ["search__members", e],
    initialPageParam: 0,
    enabled: !0,
    queryFn: /* @__PURE__ */ c(async (r) => {
      const n = t(), a = r.pageParam;
      let o;
      e ? o = await s.fetch(`/api/apps/${e}/members?q=${n}${i() !== void 0 ? `&agent=${!!i()}` : ""}&member=false&system=false&skip=${a}`) : o = await s.fetch(`/api/users?q=${n}${i() !== void 0 ? `&agent=${!!i()}` : ""}&system=false&skip=${a}`);
      const l = await o.json();
      return l.data = l.data || [], l;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ c((r) => {
      if (r.end && r.end < r.count)
        return r.end;
    }, "getNextPageParam")
  };
}
h(hD, "Db");
c(hD, "getInfiniteSearchMemberOptions");
const St = /* @__PURE__ */ c((s) => s ?? C, "o$3"), $9 = /* @__PURE__ */ c((s, t, e) => {
  const i = /* @__PURE__ */ new Map();
  for (let r = t; r <= e; r++) i.set(s[r], r);
  return i;
}, "u"), qi = Bl(class extends Zy {
  constructor(s) {
    if (super(s), s.type !== A1.CHILD) throw Error("repeat() can only be used in text expressions");
  }
  dt(s, t, e) {
    let i;
    e === void 0 ? e = t : t !== void 0 && (i = t);
    const r = [], n = [];
    let a = 0;
    for (const o of s) r[a] = i ? i(o, a) : a, n[a] = e(o, a), a++;
    return { values: n, keys: r };
  }
  render(s, t, e) {
    return this.dt(s, t, e).values;
  }
  update(s, [t, e, i]) {
    const r = EU(s), { values: n, keys: a } = this.dt(t, e, i);
    if (!Array.isArray(r)) return this.ut = a, n;
    const o = this.ut ??= [], l = [];
    let d, u, p = 0, f = r.length - 1, y = 0, g = n.length - 1;
    for (; p <= f && y <= g; ) if (r[p] === null) p++;
    else if (r[f] === null) f--;
    else if (o[p] === a[y]) l[y] = to(r[p], n[y]), p++, y++;
    else if (o[f] === a[g]) l[g] = to(r[f], n[g]), f--, g--;
    else if (o[p] === a[g]) l[g] = to(r[p], n[g]), Sg(s, l[g + 1], r[p]), p++, g--;
    else if (o[f] === a[y]) l[y] = to(r[f], n[y]), Sg(s, r[p], r[f]), f--, y++;
    else if (d === void 0 && (d = $9(a, y, g), u = $9(o, p, f)), d.has(o[p])) if (d.has(o[f])) {
      const O = u.get(a[y]), k = O !== void 0 ? r[O] : null;
      if (k === null) {
        const $ = Sg(s, r[p]);
        to($, n[y]), l[y] = $;
      } else l[y] = to(k, n[y]), Sg(s, r[p], k), r[O] = null;
      y++;
    } else Q$(r[f]), f--;
    else Q$(r[p]), p++;
    for (; y <= g; ) {
      const O = Sg(s, l[g + 1]);
      to(O, n[y]), l[y++] = O;
    }
    for (; p <= f; ) {
      const O = r[p++];
      O !== null && Q$(O);
    }
    return this.ut = a, FI(s, l), ms;
  }
}), dO = Bl(class extends Zy {
  constructor() {
    super(...arguments), this.key = C;
  }
  render(s, t) {
    return this.key = s, t;
  }
  update(s, [t, e]) {
    return t !== this.key && (FI(s), this.key = t), e;
  }
});
function nn(s) {
  s.stopPropagation();
}
h(nn, "Br");
c(nn, "inputConsume");
function dD(s) {
  s.key === "Escape" && (s.preventDefault(), s.stopPropagation(), s.target.value = "", s.target.dispatchEvent(new InputEvent("input", { data: "", inputType: "deleteContent" })));
}
h(dD, "Vb");
c(dD, "inputClearOnEscape");
function Yw(s) {
  s.key === "Escape" && (s.preventDefault(), s.stopPropagation(), s.target.blur());
}
h(Yw, "rh");
c(Yw, "inputBlurOnEscape");
function uD(s) {
  s.key === "Enter" && s.target.blur();
}
h(uD, "Hb");
c(uD, "inputBlurOnEnter");
function pD(s) {
  s.target.value ? dD(s) : Yw(s);
}
h(pD, "Bb");
c(pD, "inputClearAndBlurOnEscape");
function C4(s) {
  s.key === "Enter" && (s.preventDefault(), s.stopPropagation(), s.target.click());
}
h(C4, "nv");
c(C4, "clickOnEnter");
function fD(s) {
  s.key === " " && (s.preventDefault(), s.stopPropagation());
}
h(fD, "Nb");
c(fD, "consumeOnSpace");
function Ze(s) {
  C4(s), fD(s);
}
h(Ze, "ve");
c(Ze, "clickOnEnterAndConsumeOnSpace");
function bi(s) {
  s.key === " " && (s.preventDefault(), s.stopPropagation(), s.target.click());
}
h(bi, "Ie");
c(bi, "clickOnSpace");
function Wb(s) {
  C4(s), bi(s);
}
h(Wb, "by");
c(Wb, "clickOnEnterAndSpace");
const Fb = it`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-messages]{padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));flex:1 1 100%;display:flex;flex-direction:column}[part~=wy-message-placeholder]{opacity:.5}[part~=wy-message-date-separator]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));pointer-events:none;position:sticky;display:block;top:calc(var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) + var(--wy-component-offset-top, 0px));z-index:10;align-self:center;justify-self:center;margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));background:var(--wy-surface-container-high, var(--wy-surface-container-high-light, #e6e8ee));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));padding:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-message]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));display:flex;flex-direction:row;align-items:flex-start;margin-bottom:calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + .5*var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));scroll-margin-block:6rem}[part~=wy-message][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-message-meta]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:0 0 calc(.5*var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) calc(.5*var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));color:var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}[part~=wy-message-bubble]{background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));display:flex;flex-direction:column;padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));max-width:min(32*var(--wy-size, 1rem),100% - 2*var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}[part~=wy-message-bubble-section]{flex:1 1 100%;display:block;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));clip-path:border-box}[part~=wy-message-author]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:calc(1lh + .5*var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) calc(.5*var(--wy-size, 1rem)) 0 0}[part~=wy-message-content]{display:flex;flex-direction:column;width:100%;align-items:flex-start;flex-wrap:wrap;min-width:0;position:relative}[part~=wy-message-agent]{--wy-component-background-color: var(--wy-tertiary-container, var(--wy-tertiary-container-light, #ebe3bd));--wy-component-color: var(--wy-on-tertiary-container, var(--wy-on-tertiary-container-light, #4c472b))}[part~=wy-message-me]{margin-right:0;margin-left:calc(2.5*var(--wy-size, 1rem));align-items:flex-end;--wy-component-background-color: var(--wy-secondary-container, var(--wy-secondary-container-light, #d5e4f7));--wy-component-color: var(--wy-on-secondary-container, var(--wy-on-secondary-container-light, #3a4857))}[part~=wy-message-me] [part~=wy-message-meta]{margin:0 calc(.5*var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) calc(.5*var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) 0}[part~=wy-message-me] [part~=wy-message-content]{align-items:flex-end}[part~=wy-message-bubble-emoji]{background:none;padding:0 0 var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-message-seenby]{display:flex;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));height:calc(1.125*var(--wy-size, 1rem));justify-content:flex-end;margin-top:calc(-.125*var(--wy-size, 1rem))}`, mD = it`[part~=wy-footerbar]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));position:absolute;bottom:0;left:0;right:0;z-index:1020}[part~=wy-footerbar]:after{content:\"\";background-color:var(--wy-component-background-color);color:var(--wy-component-color);position:absolute;width:100%;left:0;bottom:0;height:100%;z-index:-1}[part~=wy-footerbar-sticky]{position:sticky}[part~=wy-footerbar-floating]{--wy-component-border-radius: var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));border-radius:var(--wy-component-border-radius)}[part~=wy-footerbar-floating]:after{border-radius:var(--wy-component-border-radius)}`, Nl = it`[part~=wy-pane]{display:flex;flex-direction:column;position:relative;min-height:0;height:100%;flex:1 1 auto}[part~=wy-pane-body]{display:flex;flex-direction:column;flex:1}[part~=wy-pane-group]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));display:flex;flex-direction:column;flex:1}[part~=wy-pane-group-fixed-size]{flex:0}[part~=wy-pane-toolbar]{display:flex;flex:1;justify-content:space-between;align-items:center;padding:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}`, Ma = it`[part~=wy-pager]{position:relative;align-self:center;justify-self:center}[part~=wy-pager-bottom]{width:16px;height:256px;max-height:100%;margin-top:-256px;margin-inline:auto;pointer-events:none}[part~=wy-pager-top]{width:16px;height:256px;max-height:100%;margin-bottom:-256px;margin-inline:auto;pointer-events:none}`, P4 = it`[part~=wy-toasts]{background:none;border:none;padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin:0;box-sizing:border-box;width:100%;height:100%;display:flex;flex-direction:column;flex-wrap:wrap;align-content:flex-end;align-items:flex-end;justify-content:flex-end;pointer-events:none}[part~=wy-toasts][popover]{position:fixed;inset:0;z-index:1070}[part~=wy-toasts]>::slotted(*){pointer-events:auto}[part~=wy-toast]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background:var(--wy-component-background-color);color:var(--wy-component-color);gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));margin-top:0;margin-bottom:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));display:flex;cursor:pointer;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));padding:0;-webkit-user-select:none;user-select:none;box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));position:relative;overflow:hidden;min-height:calc(3*var(--wy-size, 1rem));max-width:calc(32*var(--wy-size, 1rem))}[part~=wy-toast][part~=wy-fade]{transition-property:opacity,min-height,padding-top,padding-bottom,margin-top,margin-bottom,height;transition-duration:var(--wy-transition-duration, .2s);transition-timing-function:var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))}[part~=wy-toast][part~=wy-fade]:not([part~=wy-show]){opacity:0;min-height:0;height:0;padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;pointer-events:none}[part~=wy-toast-action]{position:sticky;top:calc(4.5*var(--wy-size, 1rem));bottom:calc(4.5*var(--wy-size, 1rem));z-index:990;background-color:var(--wy-primary, var(--wy-primary-light, #2f628c));color:var(--wy-on-primary, var(--wy-on-primary-light, #ffffff));padding:calc(.5*var(--wy-size, 1rem)) calc(1*var(--wy-size, 1rem));margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:calc(.5*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));width:max-content;min-height:0;max-width:calc(100% - 3*var(--wy-size, 1rem));height:auto;align-self:center;text-align:center;box-shadow:none}[part~=wy-toast-primary]{background:var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73));color:var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff))}`;
var Q4 = /* @__PURE__ */ ((s) => (s.Active = "active", s.Away = "away", s))(Q4 || {}), gf;
const yD = (gf = class extends Zy {
  constructor(t) {
    if (super(t), t.type !== A1.ATTRIBUTE || t.name !== "part" || t.strings?.length > 2)
      throw new Error(
        "`partMap()` can only be used in the `part` attribute and must be the only section in the attribute."
      );
  }
  render(t) {
    return " " + Object.keys(t).filter((e) => t[e]).join(" ") + " ";
  }
  update(t, [e]) {
    if (this._previousShadowParts === void 0) {
      this._previousShadowParts = /* @__PURE__ */ new Set(), t.strings !== void 0 && (this._staticShadowParts = new Set(
        t.strings.join(" ").split(/\s/).filter((r) => r !== "")
      ));
      for (const r in e)
        e[r] && !this._staticShadowParts?.has(r) && this._previousShadowParts.add(r);
      return this.render(e);
    }
    const i = t.element.part;
    for (const r of this._previousShadowParts)
      r in e || (i.remove(r), this._previousShadowParts.delete(r));
    for (const r in e) {
      const n = !!e[r];
      n !== this._previousShadowParts.has(r) && !this._staticShadowParts?.has(r) && (n ? (i.add(r), this._previousShadowParts.add(r)) : (i.remove(r), this._previousShadowParts.delete(r)));
    }
    return ms;
  }
}, h(gf, "zw"), gf);
c(yD, "ShadowPartMapDirective");
let IU = yD;
const gt = Bl(IU), pe = it`:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]){box-sizing:border-box;text-align:initial;font-size:var(--wy-font-size, var(--wy-size, 1em))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:before,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:after{box-sizing:inherit}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a){text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-light, #2f628c))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):hover{text-decoration:var(--wy-link-hover-decoration, var(--wy-link-decoration, none))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])):hover{text-decoration:none}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(p),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(p){margin-top:0;margin-bottom:calc(1*var(--wy-size, 1rem))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(label),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(label){cursor:inherit}:where(:host([hidden])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"])[hidden],:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *[hidden]{display:none!important}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where([role=button]),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where([role=button]){cursor:pointer}`, T4 = it`:host(wy-avatar){position:relative;display:inline-flex}[part~=wy-avatar-shape]{border-radius:var(--wy-avatar-border-radius, var(--wy-border-radius, 50%))}[part~=wy-avatar-img]{width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));object-fit:cover}[part~=wy-avatar-initials]{background-color:var(--wy-component-avatar-background-color, var(--wy-primary, var(--wy-primary-light, #2f628c)));color:var(--wy-component-avatar-color, var(--wy-on-primary, var(--wy-on-primary-light, #ffffff)));width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));display:flex;align-items:center;align-content:center;justify-content:center;justify-items:center;font-size:calc(var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem))))}[part~=wy-avatar-initials-text]{font-size:max(8px,var(--wy-avatar-font-size, .382em));font-weight:var(--wy-avatar-font-weight, var(--wy-font-weight-bold, unset));line-height:normal}[part~=wy-avatar-type-icon]{display:flex;position:absolute;z-index:1;bottom:0;right:-8.3333333333%;border-radius:50%;color:var(--wy-tertiary, var(--wy-tertiary-light, #645f41));stroke:var(--wy-on-tertiary, var(--wy-on-tertiary-light, #ffffff))}:host(wy-avatar-group){position:relative;display:inline-flex;flex-shrink:0;width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)))}[part~=wy-avatar-back]{position:absolute;top:0;left:0}[part~=wy-avatar-front]{position:absolute;bottom:0;right:0}:host(wy-avatar-header){padding:calc(1.5*var(--wy-size, 1rem));margin-left:auto;margin-right:auto;text-align:center;display:flex;flex-direction:column;justify-content:center;align-items:center}[part~=wy-avatar-description]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}`, gD = it`[part~=wy-presence]{width:calc(.75*var(--wy-size, 1rem));height:calc(.75*var(--wy-size, 1rem));border-radius:50%;position:absolute;bottom:0;right:-5%;box-sizing:border-box}[part~=wy-presence]:not([part~=wy-presence-active]){display:none}[part~=wy-presence]:after{content:\"\";position:absolute;width:100%;height:100%;top:0;left:0;border-radius:inherit;background-color:var(--wy-presence-active, var(--wy-green-light, #00a38d));background-clip:content-box;padding:calc(.125*var(--wy-size, 1rem));box-sizing:border-box}[part~=wy-presence-mask]{-webkit-mask-image:radial-gradient(circle calc(.75 * var(--wy-size, 1rem)) at bottom calc(.375 * var(--wy-size, 1rem)) right calc(.375 * var(--wy-size, 1rem) - 5%),rgba(0,0,0,0) calc(.375 * var(--wy-size, 1rem)),rgb(0,0,0) calc(.375 * var(--wy-size, 1rem) + 1px));mask-image:radial-gradient(circle calc(.75 * var(--wy-size, 1rem)) at bottom calc(.375 * var(--wy-size, 1rem)) right calc(.375 * var(--wy-size, 1rem) - 5%),#0000 calc(.375 * var(--wy-size, 1rem)),#000 calc(.375 * var(--wy-size, 1rem) + 1px))}[part~=wy-presence-in-text]{position:absolute;bottom:unset;right:unset}[part~=wy-presence-in-text]:after{left:calc(-.5*var(--wy-size, 1rem))}`;
var DU = Object.defineProperty, VU = Object.getOwnPropertyDescriptor, M4 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? VU(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && DU(t, e, r), r;
}, "__decorateClass$1b"), A$, wf;
let by = (A$ = (wf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.placement = "avatar";
  }
  render() {
    const t = {
      "wy-presence": !0,
      "wy-presence-active": this.status === Q4.Active,
      "wy-presence-in-text": this.placement === "text"
    };
    return v` <span part=${gt(t)} data-presence-id=${this.id}></span> `;
  }
}, h(wf, "Fs"), wf), c(A$, "WyPresence"), A$);
by.styles = [
  pe,
  gD,
  ft
];
M4([
  b()
], by.prototype, "placement", 2);
M4([
  b()
], by.prototype, "status", 2);
by = M4([
  Y("wy-presence")
], by);
var WU = "M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M1,10V12H9V10M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12Z", FU = "M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M6,10V7H4V10H1V12H4V15H6V12H9V10M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12Z", qU = "M13 14H11V9H13M13 18H11V16H13M1 21H23L12 2L1 21Z", ZU = "M13,13H11V7H13M13,17H11V15H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", BU = "M13 13H11V7H13M11 15H13V17H11M15.73 3H8.27L3 8.27V15.73L8.27 21H15.73L21 15.73V8.27L15.73 3Z", NU = "M19.5,3.09L15,7.59V4H13V11H20V9H16.41L20.91,4.5L19.5,3.09M4,13V15H7.59L3.09,19.5L4.5,20.91L9,16.41V20H11V13H4Z", XU = "M10,21V19H6.41L10.91,14.5L9.5,13.09L5,17.59V14H3V21H10M14.5,10.91L19,6.41V10H21V3H14V5H17.59L13.09,9.5L14.5,10.91Z", x9 = "M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z", jU = "M4,11V13H16L10.5,18.5L11.92,19.92L19.84,12L11.92,4.08L10.5,5.5L16,11H4Z", UU = "M7.5,18A5.5,5.5 0 0,1 2,12.5A5.5,5.5 0 0,1 7.5,7H18A4,4 0 0,1 22,11A4,4 0 0,1 18,15H9.5A2.5,2.5 0 0,1 7,12.5A2.5,2.5 0 0,1 9.5,10H17V11.5H9.5A1,1 0 0,0 8.5,12.5A1,1 0 0,0 9.5,13.5H18A2.5,2.5 0 0,0 20.5,11A2.5,2.5 0 0,0 18,8.5H7.5A4,4 0 0,0 3.5,12.5A4,4 0 0,0 7.5,16.5H17V18H7.5Z", HU = "M12,3A9,9 0 0,0 3,12H0L4,16L8,12H5A7,7 0 0,1 12,5A7,7 0 0,1 19,12A7,7 0 0,1 12,19C10.5,19 9.09,18.5 7.94,17.7L6.5,19.14C8.04,20.3 9.94,21 12,21A9,9 0 0,0 21,12A9,9 0 0,0 12,3M14,12A2,2 0 0,0 12,10A2,2 0 0,0 10,12A2,2 0 0,0 12,14A2,2 0 0,0 14,12Z", YU = "M21,19V20H3V19L5,17V11C5,7.9 7.03,5.17 10,4.29C10,4.19 10,4.1 10,4A2,2 0 0,1 12,2A2,2 0 0,1 14,4C14,4.1 14,4.19 14,4.29C16.97,5.17 19,7.9 19,11V17L21,19M14,21A2,2 0 0,1 12,23A2,2 0 0,1 10,21", GU = "M20.84,22.73L18.11,20H3V19L5,17V11C5,9.86 5.29,8.73 5.83,7.72L1.11,3L2.39,1.73L22.11,21.46L20.84,22.73M19,15.8V11C19,7.9 16.97,5.17 14,4.29C14,4.19 14,4.1 14,4A2,2 0 0,0 12,2A2,2 0 0,0 10,4C10,4.1 10,4.19 10,4.29C9.39,4.47 8.8,4.74 8.26,5.09L19,15.8M12,23A2,2 0 0,0 14,21H10A2,2 0 0,0 12,23Z", KU = "M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3M9 17H7V10H9V17M13 17H11V7H13V17M17 17H15V13H17V17Z", R$ = "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z", JU = "M0.41,13.41L6,19L7.41,17.58L1.83,12M22.24,5.58L11.66,16.17L7.5,12L6.07,13.41L11.66,19L23.66,7M18,7L16.59,5.58L10.24,11.93L11.66,13.34L18,7Z", tH = "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41 10.59L10 14.17L17.59 6.58L19 8L10 17Z", eH = "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M12 20C7.59 20 4 16.41 4 12S7.59 4 12 4 20 7.59 20 12 16.41 20 12 20M16.59 7.58L10 14.17L7.41 11.59L6 13L10 17L18 9L16.59 7.58Z", iH = "M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3M19,5V19H5V5H19Z", rH = "M19,19H5V5H15V3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V11H19M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z", sH = "M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", nH = "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z", aH = "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z", oH = "M6.5 20Q4.22 20 2.61 18.43 1 16.85 1 14.58 1 12.63 2.17 11.1 3.35 9.57 5.25 9.15 5.88 6.85 7.75 5.43 9.63 4 12 4 14.93 4 16.96 6.04 19 8.07 19 11 20.73 11.2 21.86 12.5 23 13.78 23 15.5 23 17.38 21.69 18.69 20.38 20 18.5 20Z", lH = "M9,22A1,1 0 0,1 8,21V18H4A2,2 0 0,1 2,16V4C2,2.89 2.9,2 4,2H20A2,2 0 0,1 22,4V16A2,2 0 0,1 20,18H13.9L10.2,21.71C10,21.9 9.75,22 9.5,22V22H9Z", cH = "M9,22A1,1 0 0,1 8,21V18H4A2,2 0 0,1 2,16V4C2,2.89 2.9,2 4,2H20A2,2 0 0,1 22,4V16A2,2 0 0,1 20,18H13.9L10.2,21.71C10,21.9 9.75,22 9.5,22V22H9M10,16V19.08L13.08,16H20V4H4V16H10Z", hH = "M15,9H5V5H15M12,19A3,3 0 0,1 9,16A3,3 0 0,1 12,13A3,3 0 0,1 15,16A3,3 0 0,1 12,19M17,3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V7L17,3Z", dH = "M19,1L17.74,3.75L15,5L17.74,6.26L19,9L20.25,6.26L23,5L20.25,3.75M9,4L6.5,9.5L1,12L6.5,14.5L9,20L11.5,14.5L17,12L11.5,9.5M19,15L17.74,17.74L15,19L17.74,20.25L19,23L20.25,20.25L23,19L20.25,17.74", uH = "M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z", pH = "M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19M8.46,11.88L9.87,10.47L12,12.59L14.12,10.47L15.53,11.88L13.41,14L15.53,16.12L14.12,17.53L12,15.41L9.88,17.53L8.47,16.12L10.59,14L8.46,11.88M15.5,4L14.5,3H9.5L8.5,4H5V6H19V4H15.5Z", fH = "M14,14H16L12,10L8,14H10V18H14V14M6,7H18V19C18,19.5 17.8,20 17.39,20.39C17,20.8 16.5,21 16,21H8C7.5,21 7,20.8 6.61,20.39C6.2,20 6,19.5 6,19V7M19,4V6H5V4H8.5L9.5,3H14.5L15.5,4H19Z", mH = "M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z", yH = "M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z", gH = "M17.9,17.39C17.64,16.59 16.89,16 16,16H15V13A1,1 0 0,0 14,12H8V10H10A1,1 0 0,0 11,9V7H13A2,2 0 0,0 15,5V4.59C17.93,5.77 20,8.64 20,12C20,14.08 19.2,15.97 17.9,17.39M11,19.93C7.05,19.44 4,16.08 4,12C4,11.38 4.08,10.78 4.21,10.21L9,15V16A2,2 0 0,0 11,18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", wH = "M20,8L12,13L4,8V6L12,11L20,6M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C22,4.89 21.1,4 20,4Z", vH = "M12,17.5C14.33,17.5 16.3,16.04 17.11,14H6.89C7.69,16.04 9.67,17.5 12,17.5M8.5,11A1.5,1.5 0 0,0 10,9.5A1.5,1.5 0 0,0 8.5,8A1.5,1.5 0 0,0 7,9.5A1.5,1.5 0 0,0 8.5,11M15.5,11A1.5,1.5 0 0,0 17,9.5A1.5,1.5 0 0,0 15.5,8A1.5,1.5 0 0,0 14,9.5A1.5,1.5 0 0,0 15.5,11M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2C6.47,2 2,6.5 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", OH = "M15 18H18V15H20V18H23V20H20V23H18V20H15V18M12 17.5C9.67 17.5 7.69 16.04 6.89 14H15.69C14.5 14.78 13.62 15.97 13.23 17.36C12.83 17.45 12.42 17.5 12 17.5M8.5 11C7.67 11 7 10.33 7 9.5C7 8.67 7.67 8 8.5 8C9.33 8 10 8.67 10 9.5C10 10.33 9.33 11 8.5 11M15.5 11C14.67 11 14 10.33 14 9.5C14 8.67 14.67 8 15.5 8C16.33 8 17 8.67 17 9.5C17 10.33 16.33 11 15.5 11M12 20L13.07 19.93C13.18 20.61 13.4 21.26 13.72 21.85C13.16 21.95 12.58 22 12 22C6.47 22 2 17.5 2 12C2 6.5 6.47 2 12 2C17.5 2 22 6.5 22 12C22 12.59 21.95 13.16 21.85 13.72C21.26 13.4 20.62 13.18 19.93 13.07L20 12C20 7.58 16.42 4 12 4C7.58 4 4 7.58 4 12C4 16.42 7.58 20 12 20Z", bH = "M13,9V3.5L18.5,9M6,2C4.89,2 4,2.89 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2H6Z", k9 = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M6.12,15.5L9.86,19.24L11.28,17.83L8.95,15.5L11.28,13.17L9.86,11.76L6.12,15.5M17.28,15.5L13.54,11.76L12.12,13.17L14.45,15.5L12.12,17.83L13.54,19.24L17.28,15.5Z", S9 = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M15,18V16H6V18H15M18,14V12H6V14H18Z", $H = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.8,20H14L12,16.6L10,20H8.2L11.1,15.5L8.2,11H10L12,14.4L14,11H15.8L12.9,15.5L15.8,20M13,9V3.5L18.5,9H13Z", xH = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M6,20H15L18,20V12L14,16L12,14L6,20M8,9A2,2 0 0,0 6,11A2,2 0 0,0 8,13A2,2 0 0,0 10,11A2,2 0 0,0 8,9Z", kH = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M13,13H11V18A2,2 0 0,1 9,20A2,2 0 0,1 7,18A2,2 0 0,1 9,16C9.4,16 9.7,16.1 10,16.3V11H13V13M13,9V3.5L18.5,9H13Z", SH = "M12.6,12.3H10.6V15.5H12.7C13.3,15.5 13.6,15.3 13.9,15C14.2,14.7 14.3,14.4 14.3,13.9C14.3,13.4 14.2,13.1 13.9,12.8C13.6,12.5 13.2,12.3 12.6,12.3M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.2,16C14.6,16.5 14.1,16.7 12.8,16.7H10.6V20H9V11H12.8C14.1,11 14.7,11.3 15.2,11.8C15.8,12.4 16,13 16,13.9C16,14.8 15.8,15.5 15.2,16M13,9V3.5L18.5,9H13Z", CH = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M13.5,16V19H10.5V16H8L12,12L16,16H13.5M13,9V3.5L18.5,9H13Z", PH = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M17,19V13L14,15.2V13H7V19H14V16.8L17,19Z", QH = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.2,20H13.8L12,13.2L10.2,20H8.8L6.6,11H8.1L9.5,17.8L11.3,11H12.6L14.4,17.8L15.8,11H17.3L15.2,20M13,9V3.5L18.5,9H13Z", TH = "M20,2H4C2.89,2 2,2.89 2,4V20C2,21.11 2.89,22 4,22H20C21.11,22 22,21.11 22,20V4C22,2.89 21.11,2 20,2M12,4L15,7H13V9H11V7H9M7,15L4,12L7,9V11H9V13H7M12,20L9,17H11V15H13V17H15M17,15V13H15V11H17V9L20,12", MH = "M17 4H20C21.1 4 22 4.9 22 6V8H20V6H17V4M4 8V6H7V4H4C2.9 4 2 4.9 2 6V8H4M20 16V18H17V20H20C21.1 20 22 19.1 22 18V16H20M7 18H4V16H2V18C2 19.1 2.9 20 4 20H7V18M18 8H6V16H18V8Z", AH = "M20 6H12L10 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V8C22 6.9 21.1 6 20 6M18 12H16V14H18V16H16V18H14V16H16V14H14V12H16V10H14V8H16V10H18V12Z", RH = "M17,7H22V17H17V19A1,1 0 0,0 18,20H20V22H17.5C16.95,22 16,21.55 16,21C16,21.55 15.05,22 14.5,22H12V20H14A1,1 0 0,0 15,19V5A1,1 0 0,0 14,4H12V2H14.5C15.05,2 16,2.45 16,3C16,2.45 16.95,2 17.5,2H20V4H18A1,1 0 0,0 17,5V7M2,7H13V9H4V15H13V17H2V7M20,15V9H17V15H20Z", EH = "M5,5H10V7H7V10H5V5M14,5H19V10H17V7H14V5M17,14H19V19H14V17H17V14M10,17V19H5V14H7V17H10Z", _H = "M14,14H19V16H16V19H14V14M5,14H10V19H8V16H5V14M8,5H10V10H5V8H8V5M19,8V10H14V5H16V8H19Z", LH = "M15.07,11.25L14.17,12.17C13.45,12.89 13,13.5 13,15H11V14.5C11,13.39 11.45,12.39 12.17,11.67L13.41,10.41C13.78,10.05 14,9.55 14,9C14,7.89 13.1,7 12,7A2,2 0 0,0 10,9H8A4,4 0 0,1 12,5A4,4 0 0,1 16,9C16,9.88 15.64,10.67 15.07,11.25M13,19H11V17H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12C22,6.47 17.5,2 12,2Z", zH = "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M11,17H13V11H11V17Z", IH = "M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z", DH = "M7,10L12,15L17,10H7Z", VH = "M7,15L12,10L17,15H7Z", WH = "M20,2H4A2,2 0 0,0 2,4V22L6,18H20A2,2 0 0,0 22,16V4C22,2.89 21.1,2 20,2Z", FH = "M20,2H4A2,2 0 0,0 2,4V22L6,18H20A2,2 0 0,0 22,16V4A2,2 0 0,0 20,2M6,9H18V11H6M14,14H6V12H14M18,8H6V6H18", qH = "M19,13H5V11H19V13Z", ZH = "M21 2C22.05 2 22.92 2.81 23 3.85L23 4V16C23 17.05 22.18 17.92 21.15 18L21 18H14V20H16V22H8V20H10V18H3C1.95 18 1.08 17.18 1 16.15L1 16V4C1 2.94 1.81 2.08 2.85 2L3 2H21M21 4H3V16H21V4M12 11C14.21 11 16 11.9 16 13V14H8V13C8 11.9 9.79 11 12 11M12 6C13.11 6 14 6.9 14 8S13.11 10 12 10 10 9.11 10 8 10.9 6 12 6Z", BH = "M14,3V5H17.59L7.76,14.83L9.17,16.24L19,6.41V10H21V3M19,19H5V5H12V3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V12H19V19Z", NH = "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z", XH = "M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z", jH = "M2,5.27L3.28,4L20,20.72L18.73,22L12.8,16.07V22H11.2V16H6V14L8,12V11.27L2,5.27M16,12L18,14V16H17.82L8,6.18V4H7V2H17V4H16V12Z", UH = "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z", HH = "M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M13,7H11V11H7V13H11V17H13V13H17V11H13V7Z", YH = "M13,3A9,9 0 0,0 4,12H1L4.89,15.89L4.96,16.03L9,12H6A7,7 0 0,1 13,5A7,7 0 0,1 20,12A7,7 0 0,1 13,19C11.07,19 9.32,18.21 8.06,16.94L6.64,18.36C8.27,20 10.5,21 13,21A9,9 0 0,0 22,12A9,9 0 0,0 13,3Z", GH = "M4,3H5V5H3V4A1,1 0 0,1 4,3M20,3A1,1 0 0,1 21,4V5H19V3H20M15,5V3H17V5H15M11,5V3H13V5H11M7,5V3H9V5H7M21,20A1,1 0 0,1 20,21H19V19H21V20M15,21V19H17V21H15M11,21V19H13V21H11M7,21V19H9V21H7M4,21A1,1 0 0,1 3,20V19H5V21H4M3,15H5V17H3V15M21,15V17H19V15H21M3,11H5V13H3V11M21,11V13H19V11H21M3,7H5V9H3V7M21,7V9H19V7H21Z", KH = "M2,21L23,12L2,3V10L17,12L2,14V21Z", JH = "M13,19H14A1,1 0 0,1 15,20H15.73L13,17.27V19M22,20V21.18L20.82,20H22M21,22.72L19.73,24L17.73,22H15A1,1 0 0,1 14,23H10A1,1 0 0,1 9,22H2V20H9A1,1 0 0,1 10,19H11V17H4A1,1 0 0,1 3,16V12A1,1 0 0,1 4,11H6.73L4.73,9H4A1,1 0 0,1 3,8V7.27L1,5.27L2.28,4L21,22.72M4,3H20A1,1 0 0,1 21,4V8A1,1 0 0,1 20,9H9.82L7,6.18V5H5.82L3.84,3C3.89,3 3.94,3 4,3M20,11A1,1 0 0,1 21,12V16A1,1 0 0,1 20,17H17.82L11.82,11H20M9,7H10V5H9V7M9,15H10V14.27L9,13.27V15M5,13V15H7V13H5Z", tY = "M12 1L3 5V11C3 16.55 6.84 21.74 12 23C17.16 21.74 21 16.55 21 11V5L12 1M15.08 16L12 14.15L8.93 16L9.74 12.5L7.03 10.16L10.61 9.85L12 6.55L13.39 9.84L16.97 10.15L14.26 12.5L15.08 16Z", eY = "M21 11C21 16.55 17.16 21.74 12 23C6.84 21.74 3 16.55 3 11V5L12 1L21 5V11M12 21C15.75 20 19 15.54 19 11.22V6.3L12 3.18L5 6.3V11.22C5 15.54 8.25 20 12 21M15.05 16L11.97 14.15L8.9 16L9.71 12.5L7 10.16L10.58 9.85L11.97 6.55L13.37 9.84L16.95 10.15L14.23 12.5L15.05 16", iY = "M18 21L14 17H17V7H14L18 3L22 7H19V17H22M2 19V17H12V19M2 13V11H9V13M2 7V5H6V7H2Z", rY = "M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z", sY = "M12,1L9,9L1,12L9,15L12,23L15,15L23,12L15,9L12,1Z", nY = "M20.8 22.7L17.9 19.8L18.2 21L12 17.3L5.8 21L7.4 14L2 9.2L6.9 8.8L1.1 3L2.4 1.7L22.1 21.4L20.8 22.7M22 9.2L14.8 8.6L12 2L10 6.8L16.9 13.7L22 9.2Z", aY = "M21,9L17,5V8H10V10H17V13M7,11L3,15L7,19V16H14V14H7V11Z", oY = "M23,10C23,8.89 22.1,8 21,8H14.68L15.64,3.43C15.66,3.33 15.67,3.22 15.67,3.11C15.67,2.7 15.5,2.32 15.23,2.05L14.17,1L7.59,7.58C7.22,7.95 7,8.45 7,9V19A2,2 0 0,0 9,21H18C18.83,21 19.54,20.5 19.84,19.78L22.86,12.73C22.95,12.5 23,12.26 23,12V10M1,21H5V9H1V21Z", lY = "M5,9V21H1V9H5M9,21A2,2 0 0,1 7,19V9C7,8.45 7.22,7.95 7.59,7.59L14.17,1L15.23,2.06C15.5,2.33 15.67,2.7 15.67,3.11L15.64,3.43L14.69,8H21C22.11,8 23,8.9 23,10V12C23,12.26 22.95,12.5 22.86,12.73L19.84,19.78C19.54,20.5 18.83,21 18,21H9M9,19H18.03L21,12V10H12.21L13.34,4.68L9,9.03V19Z", cY = "M9,3V4H4V6H5V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V6H20V4H15V3H9M9,8H11V17H9V8M13,8H15V17H13V8Z", hY = "M17,10.5V7A1,1 0 0,0 16,6H4A1,1 0 0,0 3,7V17A1,1 0 0,0 4,18H16A1,1 0 0,0 17,17V13.5L21,17.5V6.5L17,10.5Z", dY = "M3 5V19H20V5H3M7 7V9H5V7H7M5 13V11H7V13H5M5 15H7V17H5V15M18 17H9V15H18V17M18 13H9V11H18V13M18 9H9V7H18V9Z", uY = "M4 5V18H21V5H4M14 7V10.5H11V7H14M6 7H9V10.5H6V7M6 16V12.5H9V16H6M11 16V12.5H14V16H11M19 16H16V12.5H19V16M16 10.5V7H19V10.5H16Z", pY = "M2.28,3L1,4.27L2.47,5.74C2.04,6 1.61,6.29 1.2,6.6L3,9C3.53,8.6 4.08,8.25 4.66,7.93L6.89,10.16C6.15,10.5 5.44,10.91 4.8,11.4L6.6,13.8C7.38,13.22 8.26,12.77 9.2,12.47L11.75,15C10.5,15.07 9.34,15.5 8.4,16.2L12,21L14.46,17.73L17.74,21L19,19.72M12,3C9.85,3 7.8,3.38 5.9,4.07L8.29,6.47C9.5,6.16 10.72,6 12,6C15.38,6 18.5,7.11 21,9L22.8,6.6C19.79,4.34 16.06,3 12,3M12,9C11.62,9 11.25,9 10.88,9.05L14.07,12.25C15.29,12.53 16.43,13.07 17.4,13.8L19.2,11.4C17.2,9.89 14.7,9 12,9Z";
const C9 = GH, P9 = {
  "zoom-meetings": '<path d="M21.5 12.5c0 .96-.08 1.91-.23 2.83a7.198 7.198 0 01-5.95 5.95 17.527 17.527 0 01-5.66 0 7.198 7.198 0 01-5.95-5.95 17.527 17.527 0 010-5.66c.49-3.05 2.9-5.46 5.95-5.95a17.527 17.527 0 015.66 0c3.05.49 5.46 2.9 5.95 5.95.15.92.23 1.86.23 2.83z" fill="#0b5cff"/><path d="M14.43 14.75c0 .53-.43.96-.96.96H9.29c-1.07 0-1.93-.86-1.93-1.93v-3.54c0-.53.43-.96.96-.96h4.18c1.07 0 1.93.86 1.93 1.93v3.54zM16.87 9.86l-1.41 1.06c-.24.18-.39.47-.39.77v1.61c0 .3.14.59.39.77l1.41 1.06c.32.24.77.01.77-.39v-4.5c0-.4-.45-.62-.77-.39z" fill="#fff"/>',
  "google-meet": '<path fill="#1e88e5" d="M3.5 9.07v5.86l2.09.42 2.1-.42V9.07l-2.1-.42-2.09.42z"/><path d="M17.73 12v5.86c0 .69-.56 1.26-1.26 1.26H7.69l-.42-2.09.42-2.09h5.86v-2.93l2.09-.42 2.09.42z" fill="#4caf50"/><path d="M17.73 6.14V12h-4.19V9.07H7.68l-.42-2.09.42-2.09h8.79c.69 0 1.26.56 1.26 1.26z" fill="#fbc02d"/><path d="M7.69 14.93v4.19H4.76c-.69 0-1.26-.56-1.26-1.26v-2.93h4.19z" fill="#1565c0"/><path fill="#e53935" d="M7.69 4.88v4.19H3.5l4.19-4.19z"/><path fill="#2e7d32" d="M18.15 12l-.42 3.54L13.55 12l4.18-3.54.42 3.54z"/><path d="M21.5 6.19v11.63c0 .35-.41.55-.68.33l-3.09-2.6V8.48l3.09-2.6c.27-.22.68-.03.68.33z" fill="#4caf50"/>',
  "webex-meetings": '<defs><radialGradient id="prefix__b" cx="-951.63" cy="549.04" fx="-951.63" fy="549.04" r=".05" gradientTransform="matrix(-87.16473 -146.04628 -122.52671 73.12756 -15652.44 -179117.85)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#007383"/><stop offset=".41" stop-color="#00717e" stop-opacity=".75"/><stop offset=".87" stop-color="#007281" stop-opacity="0"/></radialGradient><radialGradient id="prefix__c" cx="-952.67" cy="549.07" fx="-952.67" fy="549.07" r=".05" gradientTransform="rotate(-126.7 -53497.341 -58162.752) scale(138.69 -91.09)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#218970"/><stop offset=".46" stop-color="#267e6a"/><stop offset="1" stop-color="#026c51" stop-opacity="0"/></radialGradient><radialGradient id="prefix__d" cx="-952.61" cy="541.2" fx="-952.61" fy="541.2" r=".05" gradientTransform="matrix(-33.8827 -107.79009 -56.09397 17.63256 -1902.72 -112216.84)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#178697"/><stop offset=".41" stop-color="#17838f" stop-opacity=".79"/><stop offset=".87" stop-color="#007281" stop-opacity="0"/></radialGradient><radialGradient id="prefix__e" cx="-949.76" cy="547.24" fx="-949.76" fy="547.24" r=".05" gradientTransform="matrix(-146.98086 -246.36712 -75.94201 45.30646 -98045.43 -258761.67)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#25342f" stop-opacity=".3"/><stop offset="1" stop-color="#25342f" stop-opacity="0"/></radialGradient><radialGradient id="prefix__f" cx="-942.87" cy="563.62" fx="-942.87" fy="563.62" r=".05" gradientTransform="rotate(85.1 -69752.427 38265.017) scale(108.08 -61.22)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#056d4f"/><stop offset=".23" stop-color="#056c4e" stop-opacity=".75"/><stop offset=".6" stop-color="#056c4e" stop-opacity=".3"/><stop offset=".87" stop-color="#056c4f" stop-opacity="0"/></radialGradient><radialGradient id="prefix__g" cx="-940.36" cy="556.77" fx="-940.36" fy="556.77" r=".05" gradientTransform="matrix(68.96997 106.65216 55.9082 -36.1548 33735.1 120422.29)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#22b67b"/><stop offset=".41" stop-color="#24be82"/><stop offset="1" stop-color="#24be82" stop-opacity=".07"/></radialGradient><radialGradient id="prefix__i" cx="-940.77" cy="554.96" fx="-940.77" fy="554.96" r=".05" gradientTransform="rotate(49.69 -177135.555 122596.9) scale(165.85 -165.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></radialGradient><radialGradient id="prefix__j" cx="-944.1" cy="553.18" fx="-944.1" fy="553.18" r=".05" gradientTransform="rotate(48.05 -367132.581 263331.898) scale(336.36 -335.78)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00b8ff"/><stop offset=".75" stop-color="#00b9fc" stop-opacity="0"/></radialGradient><radialGradient id="prefix__k" cx="-951.17" cy="546.23" fx="-951.17" fy="546.23" r=".05" gradientTransform="matrix(-48.64247 -154.74493 -107.10322 33.66679 12252.88 -165563.53)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00bcff" stop-opacity=".76"/><stop offset=".57" stop-color="#00bafc" stop-opacity="0"/></radialGradient><radialGradient id="prefix__l" cx="-953.78" cy="550.07" fx="-953.78" fy="550.07" r=".05" gradientTransform="matrix(-72.9418 -88.45403 -61.91396 51.05608 -35502.54 -112443.2)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5fec50"/><stop offset="1" stop-color="#3cc08e" stop-opacity="0"/></radialGradient><radialGradient id="prefix__m" cx="-954.59" cy="523.18" fx="-954.59" fy="523.18" r=".05" gradientTransform="rotate(-79.11 -8961.313 -26349.067) scale(34.73 -23.99)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#28855b"/><stop offset="1" stop-color="#14795c" stop-opacity="0"/></radialGradient><radialGradient id="prefix__n" cx="-955.7" cy="534.72" fx="-955.7" fy="534.72" r=".05" gradientTransform="matrix(6.00138 -27.99393 -39.07222 -8.37636 26647.75 -22260.21)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#28855b"/><stop offset="1" stop-color="#14795c" stop-opacity="0"/></radialGradient><radialGradient id="prefix__o" cx="-954.99" cy="550.19" fx="-954.99" fy="550.19" r=".05" gradientTransform="matrix(-64.43177 -69.7019 -48.95728 45.25565 -34575.21 -91452.74)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5ff05b"/><stop offset=".81" stop-color="#5de955" stop-opacity="0"/></radialGradient><radialGradient id="prefix__p" cx="-938.28" cy="553.05" fx="-938.28" fy="553.05" r=".05" gradientTransform="matrix(66.96005 51.3617 71.4219 -93.11248 23342.15 99701.75)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".97" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__q" cx="-940.1" cy="550.5" fx="-940.1" fy="550.5" r=".05" gradientTransform="matrix(98.43675 14.71147 21.98813 -147.126 80455.97 94829.3)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".59" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__r" cx="-938.38" cy="551.97" fx="-938.38" fy="551.97" r=".05" gradientTransform="rotate(24.69 -231174.852 140478.806) scale(85.04 -151.66)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".76" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__s" cx="-945.2" cy="560.82" fx="-945.2" fy="560.82" r=".05" gradientTransform="rotate(95.79 -93552.04 41883.384) scale(153.04 -83.75)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".59" stop-color="#123aa8" stop-opacity="0"/><stop offset="1" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__t" cx="-945.05" cy="562.66" fx="-945.05" fy="562.66" r=".05" gradientTransform="rotate(93.66 -104350.43 63182.76) scale(184.18 -65.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__u" cx="-942.29" cy="567.94" fx="-942.29" fy="567.94" r=".05" gradientTransform="matrix(8.78957 97.33394 51.50044 -4.65066 -20951.98 94373.6)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__v" cx="-942.85" cy="562.23" fx="-942.85" fy="562.23" r=".05" gradientTransform="matrix(4.89377 101.88254 84.00315 -4.03496 -42611.94 98338.06)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__w" cx="-941.74" cy="549.74" fx="-941.74" fy="549.74" r=".05" gradientTransform="rotate(-23.2 244205.91 -321749.854) scale(113.62 -222.29)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".71" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__x" cx="-959.91" cy="553.32" fx="-959.91" fy="553.32" r=".05" gradientTransform="matrix(-70.50332 -26.36011 -45.18376 120.84945 -42670.87 -92159.05)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#1a3da0"/><stop offset=".71" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__y" cx="-940.3" cy="551.63" fx="-940.3" fy="551.63" r=".05" gradientTransform="matrix(137.44492 41.41855 41.86 -138.90985 106154.62 115588.85)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#1e3882"/><stop offset=".76" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__A" cx="-940.77" cy="554.96" fx="-940.77" fy="554.96" r=".05" gradientTransform="rotate(49.69 -177135.55 122596.884) scale(165.85 -165.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></radialGradient><radialGradient id="prefix__D" cx="-951.17" cy="546.23" fx="-951.17" fy="546.23" r=".05" gradientTransform="matrix(-48.64247 -154.74493 -107.10322 33.66679 12252.88 -165563.53)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00bcff" stop-opacity=".76"/><stop offset=".57" stop-color="#00bafc" stop-opacity="0"/></radialGradient><linearGradient id="prefix__a" x1="76.14" y1="-95.89" x2="64.37" y2="-99.75" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5cee64"/><stop offset="1" stop-color="#0bf"/></linearGradient><linearGradient id="prefix__h" x1="56.74" y1="-98.36" x2="65.09" y2="-98.43" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient><linearGradient id="prefix__z" x1="61.48" y1="-92.95" x2="67.9" y2="-97.04" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset=".23" stop-color="#1dc4ff"/><stop offset="1" stop-color="#1cc1ff" stop-opacity="0"/></linearGradient><linearGradient id="prefix__B" x1="63.13" y1="-92.11" x2="64.93" y2="-93.74" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#26fbff"/><stop offset=".64" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient><linearGradient id="prefix__C" x1="60.36" y1="-97.78" x2="62.85" y2="-97.95" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#26fbff"/><stop offset=".64" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient></defs><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__a)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__b)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__c)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__d)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__e)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__f)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__g)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__h)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__i)"/><path d="M15.37 5.44c-1.34 0-2.88.45-3.9 2.4-.59 1.12-.89 2.38-1.16 3.63-.09.41-.18.83-.28 1.22v5.66c.51-.14 1.05-.42 1.57-.95 1.96-1.99 2.28-7.2 3.26-8.19.11-.11.23-.18.36-.18.39 0 .7.5.99 1.1.32.67.71 1.43 1.84 1.43.52 0 1.72-.38 1.72-1.85 0-.88-1.47-4.28-4.39-4.28z" fill="url(#prefix__j)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__k)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__l)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__m)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__n)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__o)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="#316aff"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__p)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__q)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__r)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__s)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__t)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__u)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__v)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__w)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__x)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__y)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__z)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__A)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__B)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__C)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__D)"/>',
  "microsoft-teams": '<path d="M15.56 9.91h4.65c.44 0 .8.36.8.8v4.24c0 1.61-1.31 2.92-2.92 2.92h-.01c-1.61 0-2.92-1.31-2.92-2.92v-4.62c0-.23.19-.42.42-.42z" fill="#5059c9"/><circle cx="18.7" cy="7.19" r="1.88" fill="#5059c9"/><circle cx="12.84" cy="6.35" r="2.72" fill="#7b83eb"/><path d="M16.47 9.91H8.8a.79.79 0 00-.77.8v4.83c-.06 2.6 2 4.77 4.6 4.83 2.6-.06 4.67-2.23 4.6-4.83v-4.83a.783.783 0 00-.77-.8z" fill="#7b83eb"/><path d="M3.77 7.4h7.67c.42 0 .77.34.77.77v7.67c0 .42-.34.77-.77.77H3.77a.77.77 0 01-.77-.77V8.17c0-.42.34-.77.77-.77z" fill="#5a62c3"/><path d="M9.62 10.32H8.09v4.18h-.98v-4.18H5.58v-.81h4.04v.81z" fill="#fff"/>'
}, fY = {
  box: "M15.39,14.04V14.04C15.39,12.62 14.24,11.47 12.82,11.47C11.41,11.47 10.26,12.62 10.26,14.04V14.04C10.26,15.45 11.41,16.6 12.82,16.6C14.24,16.6 15.39,15.45 15.39,14.04M17.1,14.04C17.1,16.4 15.18,18.31 12.82,18.31C11.19,18.31 9.77,17.39 9.05,16.04C8.33,17.39 6.91,18.31 5.28,18.31C2.94,18.31 1.04,16.43 1,14.11V14.11H1V7H1V7C1,6.56 1.39,6.18 1.86,6.18C2.33,6.18 2.7,6.56 2.71,7V7H2.71V10.62C3.43,10.08 4.32,9.76 5.28,9.76C6.91,9.76 8.33,10.68 9.05,12.03C9.77,10.68 11.19,9.76 12.82,9.76C15.18,9.76 17.1,11.68 17.1,14.04V14.04M7.84,14.04V14.04C7.84,12.62 6.69,11.47 5.28,11.47C3.86,11.47 2.71,12.62 2.71,14.04V14.04C2.71,15.45 3.86,16.6 5.28,16.6C6.69,16.6 7.84,15.45 7.84,14.04M22.84,16.96V16.96C22.95,17.12 23,17.3 23,17.47C23,17.73 22.88,18 22.66,18.15C22.5,18.26 22.33,18.32 22.15,18.32C21.9,18.32 21.65,18.21 21.5,18L19.59,15.47L17.7,18V18C17.53,18.21 17.28,18.32 17.03,18.32C16.85,18.32 16.67,18.26 16.5,18.15C16.29,18 16.17,17.72 16.17,17.46C16.17,17.29 16.23,17.11 16.33,16.96V16.96H16.33V16.96L18.5,14.04L16.33,11.11V11.11H16.33V11.11C16.22,10.96 16.17,10.79 16.17,10.61C16.17,10.35 16.29,10.1 16.5,9.93C16.89,9.65 17.41,9.72 17.7,10.09V10.09L19.59,12.61L21.5,10.09C21.76,9.72 22.29,9.65 22.66,9.93C22.89,10.1 23,10.36 23,10.63C23,10.8 22.95,10.97 22.84,11.11V11.11H22.84V11.11L20.66,14.04L22.84,16.96V16.96H22.84Z",
  dropbox: "M3 6.2L8 9.39L13 6.2L8 3L3 6.2M13 6.2L18 9.39L23 6.2L18 3L13 6.2M3 12.55L8 15.74L13 12.55L8 9.35L3 12.55M18 9.35L13 12.55L18 15.74L23 12.55L18 9.35M8.03 16.8L13.04 20L18.04 16.8L13.04 13.61L8.03 16.8Z",
  "google-drive": "M7.71,3.5L1.15,15L4.58,21L11.13,9.5M9.73,15L6.3,21H19.42L22.85,15M22.28,14L15.42,2H8.58L8.57,2L15.43,14H22.28Z",
  onedrive: "M18.21 10.29Q19 10.34 19.7 10.68 20.39 11 20.9 11.57 21.41 12.12 21.71 12.83 22 13.54 22 14.34 22 15.18 21.68 15.92 21.36 16.66 20.8 17.21 20.25 17.76 19.5 18.08 18.78 18.41 17.94 18.41H7Q5.97 18.41 5.06 18 4.15 17.61 3.47 16.94 2.79 16.26 2.4 15.35 2 14.44 2 13.41 2 12.59 2.26 11.83 2.5 11.08 3 10.45 3.44 9.82 4.08 9.35 4.72 8.88 5.5 8.63 5.87 8.5 6.21 8.5 6.56 8.43 6.93 8.41H6.94Q7.37 7.75 7.95 7.23 8.5 6.71 9.2 6.34 9.87 6 10.62 5.78 11.37 5.59 12.16 5.59 13.22 5.59 14.2 5.94 15.18 6.29 16 6.91 16.8 7.53 17.37 8.39 17.95 9.26 18.21 10.29M12.16 6.84Q11.05 6.84 10.06 7.3 9.06 7.75 8.36 8.6 8.73 8.7 9.07 8.85 9.4 9 9.73 9.2L13.71 11.58L16 10.62Q16.21 10.53 16.44 10.45 16.67 10.38 16.92 10.33 16.68 9.55 16.21 8.91 15.74 8.27 15.11 7.81 14.5 7.35 13.73 7.1 13 6.84 12.16 6.84M4 15.66L12.27 12.18L9.08 10.26Q8.59 9.97 8.06 9.81 7.5 9.66 6.95 9.66 6.19 9.66 5.5 9.96 4.84 10.26 4.34 10.77 3.84 11.29 3.54 11.97 3.25 12.65 3.25 13.41 3.25 14 3.45 14.59 3.64 15.19 4 15.66M17.94 17.16Q18.41 17.16 18.84 17 19.27 16.86 19.64 16.58L13.61 13L5.03 16.59Q5.47 16.86 5.97 17 6.47 17.16 7 17.16M20.45 15.61Q20.75 15 20.75 14.34 20.75 13.7 20.5 13.17 20.26 12.65 19.85 12.28 19.43 11.91 18.88 11.71 18.32 11.5 17.7 11.5 17.35 11.5 17 11.6 16.66 11.68 16.33 11.81 16 11.93 15.67 12.08 15.35 12.23 15.04 12.37Z"
}, mY = {
  email: wH,
  file: bH,
  "file-upload": CH,
  "file-music": kH,
  "file-image": xH,
  "file-video": PH,
  "file-code": k9,
  "file-xml": k9,
  "file-document": S9,
  "file-word": QH,
  "file-excel": $H,
  "file-pdf": S9,
  "file-powerpoint": SH,
  "file-compressed": AH
}, Q9 = {
  "account-minus": WU,
  "account-plus": FU,
  alert: qU,
  "alert-circle": ZU,
  "alert-octagon": BU,
  "arrow-collapse": NU,
  "arrow-expand": XU,
  attachment: UU,
  back: x9,
  "backup-restore": HU,
  bell: YU,
  "bell-off": GU,
  agent: sY,
  check: R$,
  "check-all": JU,
  "check-circle-outline": eH,
  "checkbox-blank": iH,
  "checkbox-marked": rH,
  "circle-outline": sH,
  "check-circle": tH,
  close: nH,
  "close-circle": aH,
  cloud: oH,
  comment: lH,
  "comment-outline": cH,
  "content-save": hH,
  delete: uH,
  "delete-restore": fH,
  "delete-forever": pH,
  "dots-vertical": mH,
  download: yH,
  earth: gH,
  emoticon: vH,
  "emoticon-plus": OH,
  "fit-screen": MH,
  "fit-width": TH,
  fullscreen: EH,
  "fullscreen-exit": _H,
  "help-circle": LH,
  information: zH,
  magnify: IH,
  meeting: ZH,
  "menu-down": DH,
  "menu-up": VH,
  message: WH,
  "message-text": FH,
  minus: qH,
  next: jU,
  "open-in-new": BH,
  pencil: NH,
  pin: XH,
  unpin: jH,
  plus: UH,
  "plus-circle-outline": HH,
  poll: KU,
  previous: x9,
  read: R$,
  restore: YH,
  unread: R$,
  send: KH,
  "server-network-off": JH,
  "shield-star": tY,
  "shield-star-outline": eY,
  sort: iY,
  star: rY,
  unstar: nY,
  stars: dH,
  "swap-horizontal": aY,
  textbox: RH,
  "thumb-up": oY,
  "thumb-up-outline": lY,
  trashcan: cY,
  video: hY,
  "view-list-outline": dY,
  "view-module-outline": uY,
  "wifi-off": pY,
  ...mY,
  ...fY
}, T9 = {
  dropbox: "#0061fe",
  onedrive: "#0078d4",
  box: "#0161d5",
  "google-drive": "#1a73e8",
  zoom: "#4a8cff"
};
function TS(s) {
  return s && s in Q9 ? Q9[s] : "";
}
h(TS, "Cf");
c(TS, "getIconMapping");
function wD(s) {
  return s && s in P9 ? P9[s] : "";
}
h(wD, "x5");
c(wD, "getSvgMapping");
var vf;
const vD = (vf = class extends Zy {
  constructor(t) {
    if (super(t), this.it = C, t.type !== A1.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(t) {
    if (t === C || t == null) return this._t = void 0, this.it = t;
    if (t === ms) return t;
    if (typeof t != "string") throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (t === this.it) return this._t;
    this.it = t;
    const e = [t];
    return e.raw = e, this._t = { _$litType$: this.constructor.resultType, strings: e, values: [] };
  }
}, h(vf, "Iw"), vf);
c(vD, "e");
let C0 = vD;
C0.directiveName = "unsafeHTML", C0.resultType = 1;
const gl = Bl(C0);
var Of;
const OD = (Of = class extends C0 {
}, h(Of, "Fw"), Of);
c(OD, "t");
let MS = OD;
MS.directiveName = "unsafeSVG", MS.resultType = 2;
const M9 = Bl(MS), A4 = it`[part~=wy-icon-wrapper]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative}[part~=wy-icon]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-icon][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon-first]{margin-left:calc(-.5*var(--wy-size, 1rem))}[part~=wy-icon-last]{margin-right:calc(-.5*var(--wy-size, 1rem))}[part~=wy-icon-inline]{vertical-align:-.25em}[part~=wy-icon-overlay]{position:absolute;bottom:0;right:0;border-radius:50%}:host(wy-icon-stack),[part~=wy-icon-stack]{display:inline-flex;position:relative;line-height:1}[part~=wy-icon-stack-layer]{position:absolute}[part~=wy-icon-stack-overlay]{position:absolute;bottom:0;right:0;border-radius:50%;width:calc(var(--wy-component-icon-width)/2);height:calc(var(--wy-component-icon-height)/2)}[part~=wy-icon-current-color]{fill:currentColor}[part~=wy-icon-state]{transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));align-self:center;justify-self:center;margin:auto;opacity:0}[part~=wy-icon-state][part~=wy-active]{opacity:1}[part~=wy-icon-display]{color:var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));border-radius:var(--wy-component-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;padding:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem))}[part~=wy-icon-display-fill]{flex:1 0 auto}[part~=wy-icon-display-icon]{color:var(--wy-component-color);--wy-component-icon-width: calc(4 * var(--wy-size, 1rem));--wy-component-icon-height: calc(4 * var(--wy-size, 1rem));padding:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem))}[part~=wy-icon-display-text],[part~=wy-icon-display-meta]{color:var(--wy-component-color);padding:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem));text-align:center;line-height:var(--wy-line-height, 1.5)}[part~=wy-icon-color-primary]{fill:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-icon-color-secondary]{fill:var(--wy-secondary, var(--wy-secondary-light, #51606f))}[part~=wy-icon-color-tertiary]{fill:var(--wy-tertiary, var(--wy-tertiary-light, #645f41))}[part~=wy-icon-color-surface]{fill:var(--wy-surface, var(--wy-surface-light, #f7f9ff))}[part~=wy-icon-color-surface-variant]{fill:var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb))}[part~=wy-icon-color-error]{fill:var(--wy-error, var(--wy-error-light, #ba1821))}[part~=wy-icon-color-warning]{fill:var(--wy-warning, var(--wy-warning-light, #adb140))}[part~=wy-icon-color-blue]{fill:var(--wy-blue, var(--wy-blue-light, #8aa9fc))}[part~=wy-icon-color-indigo]{fill:var(--wy-indigo, var(--wy-indigo-light, #9285de))}[part~=wy-icon-color-purple]{fill:var(--wy-purple, var(--wy-purple-light, #c675b6))}[part~=wy-icon-color-pink]{fill:var(--wy-pink, var(--wy-pink-light, #d57193))}[part~=wy-icon-color-red]{fill:var(--wy-red, var(--wy-red-light, #db726b))}[part~=wy-icon-color-orange]{fill:var(--wy-orange, var(--wy-orange-light, #e79b3a))}[part~=wy-icon-color-yellow]{fill:var(--wy-yellow, var(--wy-yellow-light, #adb140))}[part~=wy-icon-color-green]{fill:var(--wy-green, var(--wy-green-light, #00a38d))}[part~=wy-icon-color-teal]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a9))}[part~=wy-icon-color-cyan]{fill:var(--wy-cyan, var(--wy-cyan-light, #0081a2))}[part~=wy-icon-color-gray]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-icon-color-black]{fill:var(--wy-black, var(--wy-black, #000000))}[part~=wy-icon-color-white]{fill:var(--wy-white, var(--wy-white, #ffffff))}[part*=wy-kind-]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-kind-archive]{fill:var(--wy-orange, var(--wy-orange-light, #e79b3a))}[part~=wy-kind-audio]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a9))}[part~=wy-kind-code]{fill:var(--wy-green, var(--wy-green-light, #00a38d))}[part~=wy-kind-document]{fill:var(--wy-blue, var(--wy-blue-light, #8aa9fc))}[part~=wy-kind-email]{fill:var(--wy-red, var(--wy-red-light, #db726b))}[part~=wy-kind-presentation]{fill:var(--wy-orange, var(--wy-orange-light, #e79b3a))}[part~=wy-kind-spreadsheet]{fill:var(--wy-green, var(--wy-green-light, #00a38d))}[part~=wy-kind-image]{fill:var(--wy-pink, var(--wy-pink-light, #d57193))}[part~=wy-kind-text]{fill:var(--wy-cyan, var(--wy-cyan-light, #0081a2))}[part~=wy-kind-video]{fill:var(--wy-purple, var(--wy-purple-light, #c675b6))}[part~=wy-ext-pdf]{fill:var(--wy-red, var(--wy-red-light, #db726b))}[part~=wy-kind-text-icon]{width:calc(1.25*var(--wy-size, 1rem));height:calc(1.25*var(--wy-size, 1rem));vertical-align:calc(-.3125*var(--wy-size, 1rem))}`;
var yY = Object.defineProperty, gY = Object.getOwnPropertyDescriptor, Qe = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? gY(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && yY(t, e, r), r;
}, "__decorateClass$1a"), E$, bf;
let ge = (E$ = (bf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.color = "", this.size = 24, this.path = C9, this.inline = !1, this.first = !1, this.last = !1, this.layer = !1, this.state = !1, this.active = !1, this.uniqueId = `wy-icon-${gy()}`;
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("name") && this.name && (this.path = TS(this.name) || C9, this.overlayPath = TS(this.overlayName) || this.overlayPath, this.nativeIconColor = this.color === "native" && T9[this.name] || void 0, this.nativeOverlayColor = this.overlayName && T9[this.overlayName] || void 0);
  }
  render() {
    const t = this.kind ? WP(this.kind) : this.kind, e = this.ext?.startsWith(".") ? this.ext.substring(1) : this.ext, i = {
      "wy-icon-wrapper": !0,
      "wy-icon-stack-layer": this.layer
    }, r = {
      "wy-icon": !0,
      "wy-icon-current-color": !t && !this.color,
      ["wy-kind-" + t]: !!t,
      ["wy-ext-" + e]: !!e,
      ["wy-icon-color-" + this.color]: !!this.color,
      "wy-icon-first": this.first,
      "wy-icon-last": this.last,
      "wy-icon-inline": this.inline,
      "wy-icon-state": this.state,
      "wy-active": this.active
    }, n = this.size !== 24, a = this.size / 16, o = n ? `width: var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem))); height: var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem)));` : "", l = this.svg && wD(this.svg);
    return this.overlayPath ? [
      v`
          <style>
            .icon-mask-bg {
              width: var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem)));
              height: var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem)));
              fill: white;
            }

            .icon-mask {
              width: calc(var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem))));
              height: calc(var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem))));
              ry: calc(var(--wy-border-radius-pill, var(--wy-border-radius, 50%)));
              x: calc(var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem))) / 2);
              y: calc(var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem))) / 2);
              stroke: black;
              stroke-width: 4px;
              fill: black;
            }
          </style>
        `,
      v`
          <div part=${gt(i)}>
            <wy-icon-stack style="${o}">
              <svg
                part=${gt(r)}
                viewBox="0 0 24 24"
                width="${this.size}"
                height="${this.size}"
                style="mask-image: url(#${this.uniqueId}-mask); -webkit-mask-image: url(#${this.uniqueId}-mask);"
              >
                <defs>
                  <mask id="${this.uniqueId}-mask">
                    <rect class="icon-mask-bg" />
                    <rect class="icon-mask" />
                  </mask>
                </defs>
                ${l ? M9(l) : r0`
                    <path d="${this.path}" style="fill: ${St(this.nativeIconColor)}" />
                  `}
                <!--rect width="24" height="24" fill="transparent" /-->
              </svg>
              <svg part="wy-icon-stack-overlay" viewBox="0 0 24 24" width="${this.size / 2}" height="${this.size / 2}">
                <path d="${this.overlayPath}" style="fill: ${St(this.nativeOverlayColor)}" />
                <!--rect width="24" height="24" fill="transparent" /-->
              </svg>
            </wy-icon-stack>
            <slot></slot>
          </div>
        `
    ] : v`
      <div part=${gt(i)}>
        <svg
          part=${gt(r)}
          style="${o}"
          viewBox="0 0 24 24"
          width="${this.size}"
          height="${this.size}"
        >
          ${l ? M9(l) : r0`
            <path d="${this.path}" style="fill: ${St(this.nativeIconColor)}" />
          `}
          <!--rect width="24" height="24" fill="transparent" /-->
        </svg>
        <slot></slot>
      </div>
    `;
  }
}, h(bf, "Ds"), bf), c(E$, "WyIcon"), E$);
ge.styles = [pe, A4, ft];
Qe([
  b()
], ge.prototype, "name", 2);
Qe([
  b()
], ge.prototype, "overlayName", 2);
Qe([
  b()
], ge.prototype, "svg", 2);
Qe([
  b()
], ge.prototype, "color", 2);
Qe([
  b({ type: Number })
], ge.prototype, "size", 2);
Qe([
  b()
], ge.prototype, "kind", 2);
Qe([
  b()
], ge.prototype, "ext", 2);
Qe([
  b({ attribute: !1 })
], ge.prototype, "path", 2);
Qe([
  b({ attribute: !1 })
], ge.prototype, "overlayPath", 2);
Qe([
  b({ type: Boolean })
], ge.prototype, "inline", 2);
Qe([
  b({ type: Boolean })
], ge.prototype, "first", 2);
Qe([
  b({ type: Boolean })
], ge.prototype, "last", 2);
Qe([
  b({ type: Boolean })
], ge.prototype, "layer", 2);
Qe([
  b({ type: Boolean })
], ge.prototype, "state", 2);
Qe([
  b({ type: Boolean })
], ge.prototype, "active", 2);
Qe([
  N()
], ge.prototype, "nativeIconColor", 2);
Qe([
  N()
], ge.prototype, "nativeOverlayColor", 2);
ge = Qe([
  Y("wy-icon")
], ge);
var _$, $f;
let P0 = (_$ = ($f = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this);
  }
  render() {
    return v`<slot></slot>`;
  }
}, h($f, "Vs"), $f), c(_$, "WyIconStack"), _$);
P0.styles = [pe, A4];
P0 = Qe([
  Y("wy-icon-stack")
], P0);
var L$, xf;
let Gw = (L$ = (xf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.fill = !1;
  }
  render() {
    return v`
      <div part="wy-icon-display ${gt({ "wy-icon-display-fill": this.fill })}">
        <div part="wy-icon-display-icon">
          <slot></slot>
        </div>
        <div part="wy-icon-display-text">
          <slot name="text"></slot>
        </div>
        <div part="wy-icon-display-meta">
          <slot name="meta"></slot>
        </div>
      </div>
    `;
  }
}, h(xf, "Hs"), xf), c(L$, "WyIconDisplay"), L$);
Gw.styles = [pe, A4, ft];
Qe([
  b({ type: Boolean })
], Gw.prototype, "fill", 2);
Gw = Qe([
  Y("wy-icon-display")
], Gw);
var wY = Object.defineProperty, vY = Object.getOwnPropertyDescriptor, ur = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? vY(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && wY(t, e, r), r;
}, "__decorateClass$19"), z$, kf;
let gs = (z$ = (kf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.size = 32, this.src = "", this.name = "", this.description = "", this.isAgent = !1;
  }
  render() {
    const t = this.size / 16;
    let e;
    !this.src && this.name && (e = H_(this.name));
    const i = {
      "wy-avatar-shape": !0,
      "wy-avatar-img": !!this.src,
      "wy-avatar-initials": !this.src,
      "wy-presence-mask": this.presence === Q4.Active
    };
    return v`
      ${this.src ? v`
            <img
              alt=""
              title="${this.name}${this.description ? ` • ${this.description}` : ""}"
              part=${gt(i)}
              style="--wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));"
              height="${this.size}"
              width="${this.size}"
              src="${this.src}"
              decoding="async"
              loading="lazy"
            />
          ` : v`
            <div
              part=${gt(i)}
              style="--wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));"
              title="${this.name}${this.description ? ` • ${this.description}` : ""}"
            >
              <span part="wy-avatar-initials-text">${e}</span>
            </div>
          `}
      ${this.isAgent ? v`<wy-icon part="wy-avatar-type-icon" name="agent" size="${this.size / 3 * 1.25}"></wy-icon>` : C}
      ${this.presence && !this.isAgent ? v`<wy-presence part="wy-avatar-presence" .status=${this.presence} id=${this.id}></wy-presence>` : C}
    `;
  }
}, h(kf, "Bs"), kf), c(z$, "WyAvatar"), z$);
gs.styles = [pe, T4, gD];
ur([
  b({ type: Number })
], gs.prototype, "size", 2);
ur([
  b()
], gs.prototype, "src", 2);
ur([
  b()
], gs.prototype, "name", 2);
ur([
  b()
], gs.prototype, "description", 2);
ur([
  b({ type: Boolean, reflect: !0 })
], gs.prototype, "isAgent", 2);
ur([
  b()
], gs.prototype, "presence", 2);
gs = ur([
  Y("wy-avatar")
], gs);
var I$, Sf;
let wl = (I$ = (Sf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.size = 32, this.uniqueId = `wy-avatar-${gy()}`;
  }
  render() {
    if (!this.user)
      return C;
    const t = this.size / 16, e = (this.members || []).filter((n) => n.id !== this.user?.id).slice(0, 2).reverse(), i = e?.shift() || this.user, r = e?.shift() || (i !== this.user ? this.user : void 0);
    return [
      v`
        <style>
          :host {
            --wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));
          }

          [part~="wy-avatar-mask-bg"] {
            width: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            height: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            fill: white;
          }

          [part~="wy-avatar-mask"] {
            width: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            height: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            ry: var(--wy-avatar-border-radius, var(--wy-border-radius-pill, var(--wy-border-radius, 50%)));
            x: calc(${t / 3} * var(--wy-size, 1rem));
            y: calc(${t / 3} * var(--wy-size, 1rem));
            stroke: black;
            stroke-width: 4px;
            fill: black;
          }
        </style>
      `,
      v`
        <svg>
          <defs>
            <mask id="${this.uniqueId}-mask">
              <rect part="wy-avatar-mask-bg" />
              <rect part="wy-avatar-mask" />
            </mask>
          </defs>
        </svg>
      `,
      v`
        <wy-avatar
          part="wy-avatar-back"
          style="mask-image: url(#${this.uniqueId}-mask); -webkit-mask-image: url(#${this.uniqueId}-mask);"
          .src=${r?.avatar_url}
          .name=${r?.name}
          size=${this.size * 2 / 3}
        ></wy-avatar>
        <wy-avatar
          part="wy-avatar-front"
          .src=${i.avatar_url}
          .name=${i.name}
          .isAgent=${i.is_agent}
          size=${this.size * 2 / 3}
        ></wy-avatar>
      `
    ];
  }
}, h(Sf, "Ns"), Sf), c(I$, "WyAvatarGroup"), I$);
wl.styles = [pe, T4, ft];
ur([
  b({ type: Number })
], wl.prototype, "size", 2);
ur([
  b({
    type: Array,
    attribute: !1
  })
], wl.prototype, "members", 2);
ur([
  Xe({ context: Pb, subscribe: !0 }),
  N()
], wl.prototype, "user", 2);
wl = ur([
  Y("wy-avatar-group")
], wl);
var D$, Cf;
let Kw = (D$ = (Cf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this);
  }
  render() {
    return v`
      <slot></slot>
      ${this.description ? v` <div part="wy-avatar-description">${this.description}</div> ` : C}
    `;
  }
}, h(Cf, "Us"), Cf), c(D$, "WyAvatarHeader"), D$);
Kw.styles = [pe, T4];
ur([
  b()
], Kw.prototype, "description", 2);
Kw = ur([
  Y("wy-avatar-header")
], Kw);
const OY = it`[part~=wy-empty]{display:flex;align-items:center;justify-content:center;flex:1;min-width:0;position:relative;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}`, bD = it`[part~=wy-progress]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative}[part~=wy-progress-padded]{margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-progress-overlay]{position:absolute!important}[part~=wy-progress-reveal]{overflow:hidden;opacity:1;interpolate-size:allow-keywords;height:auto;transition:width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),margin var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-progress-reveal]{width:0;height:0;opacity:0;margin:0}}`, bY = it`[part~=wy-progress-circular]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-progress-circular]:not([width]),[part~=wy-progress-circular][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress-circular]:not([height]),[part~=wy-progress-circular][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress-circular][part~=wy-primary]{color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-progress-remaining]{fill:none;stroke:var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb))}[part~=wy-progress-done]{fill:none;stroke:currentColor}[part~=wy-progress-overlay]{position:absolute;inset:0;margin:auto}[part~=wy-progress-indeterminate-circle]{stroke-dasharray:1,100;stroke-dashoffset:0;transform-origin:center;fill:none!important}[part~=wy-progress-indeterminate]{animation:wy-rotate 1.4s linear infinite}[part~=wy-progress-indeterminate] [part~=wy-progress-indeterminate-circle]{animation:wy-dash 1.4s ease-in-out infinite,wy-color 2.8s ease-in-out infinite}@keyframes wy-rotate{to{transform:rotate(360deg)}}@keyframes wy-dash{0%{stroke-dasharray:1,100;stroke-dashoffset:0}50%{stroke-dasharray:44.5,100;stroke-dashoffset:-17.5}to{stroke-dasharray:44.5,100;stroke-dashoffset:-62}}@keyframes wy-color{0%,to{stroke:var(--wy-primary, var(--wy-primary-light, #2f628c))}25%{stroke:var(--wy-primary, var(--wy-primary-light, #2f628c))}50%{stroke:#0000}75%{stroke:var(--wy-primary, var(--wy-primary-light, #2f628c))}}`;
var $Y = Object.defineProperty, xY = Object.getOwnPropertyDescriptor, Aa = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? xY(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && $Y(t, e, r), r;
}, "__decorateClass$18"), V$, Pf;
let Fr = (V$ = (Pf = class extends wt {
  constructor() {
    super(...arguments), this.shadowParts = new rt(this), this.size = 24, this.indeterminate = !1, this.padded = !1, this.overlay = !1, this.value = 0, this.max = 1, this.reveal = !1;
  }
  render() {
    const t = {
      "wy-progress": !0,
      "wy-progress-reveal": this.reveal,
      "wy-progress-overlay": this.overlay,
      "wy-progress-padded": this.padded
    }, e = {
      "wy-progress-circular": !0,
      "wy-primary": !this.indeterminate,
      "wy-progress-indeterminate": this.indeterminate
    }, i = 10, r = Math.PI * (i * 2);
    let n;
    try {
      Number.isFinite(this.value) && Number.isFinite(this.max) && this.max > 0 && (n = this.value / this.max);
    } catch (a) {
      console.error(a);
    }
    return v`
      <div part="${gt(t)}">
        ${this.indeterminate || n === void 0 ? r0`
              <svg
                part="${gt(e)}"
                viewBox="0 0 24 24"
                width=${this.size}
                height=${this.size}
                role="progressbar"
                aria-label="${C}"
                aria-valuemin="0"
                aria-valuemax=${this.max}
                aria-valuenow=${C}
                xmlns="http://www.w3.org/2000/svg"
              >
                <circle
                  part="wy-progress-circle wy-progress-indeterminate-circle"
                  fill="none"
                  cx="12"
                  cy="12"
                  r=${i}
                  stroke-linecap="butt"
                  stroke-width="2"
                ></circle>
              </svg>
            ` : r0`
              <svg
                part="${gt(e)}"
                viewBox="0 0 24 24"
                width=${this.size}
                height=${this.size}
                transform="rotate(-90)"
                role="progressbar"
                aria-label="${C}"
                aria-valuemin="0"
                aria-valuemax=${this.max}
                aria-valuenow=${this.value}
                xmlns="http://www.w3.org/2000/svg"
              >
                <circle
                  part="wy-progress-circle wy-progress-remaining"
                  cx="12"
                  cy="12"
                  r=${i}
                  stroke-linecap="butt"
                  stroke-width="2"
                  fill="none"
                  stroke="#eee"
                ></circle>
                <circle
                  part="wy-progress-circle wy-progress-done"
                  cx="12"
                  cy="12"
                  r=${i}
                  stroke-dasharray=${r}
                  stroke-dashoffset=${r * (1 - n)}
                  stroke-linecap="butt"
                  stroke-width="2"
                  fill="none"
                  stroke="currentColor"
                  path-length="200"
                ></circle>
              </svg>
            `}
      </div>
    `;
  }
}, h(Pf, "qs"), Pf), c(V$, "WyProgressCircular"), V$);
Fr.styles = [pe, bD, bY, ft];
Aa([
  b({ type: Number })
], Fr.prototype, "size", 2);
Aa([
  b({ type: Boolean })
], Fr.prototype, "indeterminate", 2);
Aa([
  b({ type: Boolean })
], Fr.prototype, "padded", 2);
Aa([
  b({ type: Boolean })
], Fr.prototype, "overlay", 2);
Aa([
  b({ type: Number })
], Fr.prototype, "value", 2);
Aa([
  b({ type: Number })
], Fr.prototype, "max", 2);
Aa([
  b({ type: Boolean })
], Fr.prototype, "reveal", 2);
Fr = Aa([
  Y("wy-progress-circular")
], Fr);
var kY = Object.defineProperty, SY = Object.getOwnPropertyDescriptor, R4 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? SY(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && kY(t, e, r), r;
}, "__decorateClass$17"), W$, Qf;
let $y = (W$ = (Qf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.noNetwork = !1, this.handleUpdate = () => this.requestUpdate();
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("weavy")) {
      const e = t.get("weavy");
      e && e !== this.weavy && e.removeNetworkListener(this.handleUpdate), this.weavy && e !== this.weavy && this.weavy.addNetworkListener(this.handleUpdate);
    }
  }
  render() {
    return v`
      <div part="wy-empty">
        ${this.weavy && !this.noNetwork && this.weavy?.network.state === "unreachable" ? v`
              <wy-icon-display>
                <wy-icon name="server-network-off"></wy-icon>
                <span slot="text">${P("The server is offline, try again in a few minutes...")}</span>
                <wy-progress-circular indeterminate slot="meta" ?hidden=${!this.weavy?.network.isPending}></wy-progress-circular>
              </wy-icon-display>
            ` : !this.noNetwork && this.weavy?.network.state === "offline" ? v`
              <wy-icon-display>
                <wy-icon name="wifi-off"></wy-icon>
                <span slot="text">${P("You are currently offline.")}</span>
                <wy-progress-circular indeterminate slot="meta" ?hidden=${!this.weavy?.network.isPending}></wy-progress-circular>
              </wy-icon-display>
            ` : v`
              <slot>
                <wy-icon-display>
                  <wy-icon name="information"></wy-icon>
                  <slot slot="text" name="title">
                    <span>${P("Nothing to see here yet.")}</span>
                  </slot>
                </wy-icon-display>
              </slot>
            `}
      </div>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.weavy?.addNetworkListener(this.handleUpdate);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.weavy?.removeNetworkListener(this.handleUpdate);
  }
}, h(Qf, "js"), Qf), c(W$, "WyEmpty"), W$);
$y.styles = [
  OY,
  ft
];
R4([
  Xe({ context: De, subscribe: !0 }),
  N()
], $y.prototype, "weavy", 2);
R4([
  b({ type: Boolean })
], $y.prototype, "noNetwork", 2);
$y = R4([
  Y("wy-empty"),
  At()
], $y);
const CY = it`@keyframes wy-bouncing{to{transform:translate3d(0,calc(-.25 * var(--wy-size, 1rem)),0)}}@keyframes wy-bouncing-fade{to{opacity:.2}}[part~=wy-bouncer]{width:calc(1.5*var(--wy-size, 1rem));height:calc(.75*var(--wy-size, 1rem))}[part~=wy-bouncer-dot]{position:relative;animation:wy-bouncing .6s infinite alternate,wy-bouncing-fade .6s infinite alternate;fill:currentColor}[part~=wy-bouncer-dot-start]{animation-delay:0s,.6s}[part~=wy-bouncer-dot-middle]{animation-delay:.3s,.3s}[part~=wy-bouncer-dot-end]{animation-delay:.6s,0s}`;
var PY = Object.defineProperty, QY = Object.getOwnPropertyDescriptor, On = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? QY(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && PY(t, e, r), r;
}, "__decorateClass$16"), F$, Tf;
let xr = (F$ = (Tf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.typing = new kI(this), this.isPrivateChat = !1, this.members = [], this.typingMembers = [], this.names = [];
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("conversationId") && (this.typing.appId = this.conversationId), t.has("userId") && (this.typing.userId = this.userId);
    const { typingMembers: e, names: i } = this.typing;
    this.typingMembers = e, this.names = i, e.length ? this.typingTime ||= /* @__PURE__ */ new Date() : this.typingTime = void 0;
  }
  render() {
    const t = this.typingMembers.map(
      (a) => this.members.find((o) => o.id === a.id)
    ).filter((a) => a), e = new Intl.ListFormat(this.weavy?.locale, { style: "long", type: "conjunction" }).format(
      this.names
    ), i = this.typingTime ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(this.typingTime) : "", r = this.typingTime ? new Intl.DateTimeFormat(this.weavy?.locale, { timeStyle: "short" }).format(this.typingTime) : "", n = v`
      <svg part="wy-bouncer" viewBox="0 0 32 16" xmlns="http://www.w3.org/2000/svg">
        <circle part="wy-bouncer-dot wy-bouncer-dot-start" cx="4" cy="10" r="4" />
        <circle part="wy-bouncer-dot wy-bouncer-dot-middle" cx="16" cy="10" r="4" />
        <circle part="wy-bouncer-dot wy-bouncer-dot-end" cx="28" cy="10" r="4" />
      </svg>
    `;
    return t.length ? v`
          <div part=${gt({ "wy-message": !0, "wy-message-agent": !!t[0]?.is_agent })}>
            <div part="wy-message-author">
              ${t.length > 1 ? v`
                    <wy-avatar-group
                      .size=${32}
                      .members=${t}
                      title=${e}
                    ></wy-avatar-group>
                  ` : v`
                    <wy-avatar
                      .size=${32}
                      .src=${t[0]?.avatar_url}
                      .description=${t[0]?.comment}
                      .name=${e}
                      .isAgent=${t[0]?.is_agent}
                    ></wy-avatar>
                  `}
            </div>

            <div part="wy-message-content">
              <div part="wy-message-meta">
                ${this.isPrivateChat ? v`
                      <time datetime=${St(this.typingTime?.toISOString())} title=${i}>${r}</time>
                    ` : e}
              </div>
              <div part="wy-message-bubble"> ${n} </div>
            </div>
          </div>
        ` : C;
  }
}, h(Tf, "Ws"), Tf), c(F$, "WyMessageTyping"), F$);
xr.styles = [pe, CY, Fb];
On([
  Xe({ context: De, subscribe: !0 }),
  N()
], xr.prototype, "weavy", 2);
On([
  b({ attribute: !0, type: Number })
], xr.prototype, "conversationId", 2);
On([
  b({ attribute: !0, type: Number })
], xr.prototype, "userId", 2);
On([
  b({ type: Boolean })
], xr.prototype, "isPrivateChat", 2);
On([
  b({ attribute: !1 })
], xr.prototype, "members", 2);
On([
  N()
], xr.prototype, "typingMembers", 2);
On([
  N()
], xr.prototype, "names", 2);
On([
  N()
], xr.prototype, "typingTime", 2);
xr = On([
  Y("wy-message-typing")
], xr);
const qb = it`:host(wy-item),[part~=wy-item]{--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));display:flex;box-sizing:border-box}[part~=wy-item-rounded]{border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-item-rounded-outer]{border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-item-inner]{display:flex;position:relative;align-items:center;text-decoration:none;gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));flex:1 1 100%;min-width:0}[part~=wy-item-inner-no-padding]{padding:0}[part~=wy-item-sm]{min-height:calc(2*var(--wy-size, 1rem));padding:0 var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-item-md]{min-height:calc(3*var(--wy-size, 1rem))}[part~=wy-item-lg]{min-height:calc(4.5*var(--wy-size, 1rem))}[part~=wy-item-top]{align-items:flex-start}[part~=wy-item-body]{width:100%;min-width:0;min-height:100%;display:flex}[part~=wy-item-rows]{display:flex;flex-direction:column;min-width:0;justify-content:space-evenly;flex:1 1 100%}[part~=wy-item-row]{display:flex;align-items:center;column-gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));min-height:calc(var(--wy-button-line-height, var(--wy-line-height, 1.5))*var(--wy-size, 1rem))}[part~=wy-item-title] a:after{position:absolute;inset:0;z-index:1;content:\"\"}[part~=wy-item-title] a{color:inherit;text-decoration:none}[part~=wy-item-title]{color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset))}[part~=wy-item-title]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-item-image]{display:contents}[part~=wy-item-text]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-item-text]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-item-text-sm]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))}[part~=wy-item-meta]{white-space:nowrap}[part~=wy-item-actions]{--wy-component-background-color: transparent;display:flex;align-items:center;justify-items:flex-end;flex:0 0 auto;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-item-actions-top]{align-self:flex-start;margin:calc(-.25*var(--wy-size, 1rem))}[part~=wy-item-actions-bottom]{align-self:flex-start;margin:calc(-.125*var(--wy-size, 1rem)) 0 calc(-.625*var(--wy-size, 1rem))}[part~=wy-item-left]{margin-right:auto}[part~=wy-item-right]{margin-left:auto}[part~=wy-read]{opacity:var(--wy-opacity-muted, 65%);--wy-component-color: var(--wy-outline, var(--wy-outline-light, #72777f))}[part~=wy-unread]{--wy-component-color: color.token(--wy-on-background)}[part~=wy-unread] [part~=wy-item-title],[part~=wy-unread] [part~=wy-item-text]{font-weight:var(--wy-font-weight-bold, 600);color:var(--wy-component-color)}[part~=wy-item-interactive]{background-color:var(--wy-component-background-color);color:var(--wy-component-color);-webkit-user-select:none;user-select:none;cursor:pointer}[part~=wy-item-interactive]:hover,[part~=wy-item-interactive]:focus{--wy-component-background-color: var(--wy-component-background-color-hover, var(--wy-surface-layer-high, var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039))));text-decoration:none}[part~=wy-item-interactive]:active{--wy-component-background-color: var(--wy-component-background-color-active, var(--wy-surface-layer-highest, var(--wy-surface-layer-highest-light, rgba(0, 0, 0, .1019607843))))}[part~=wy-item-interactive][part~=wy-disabled],[part~=wy-item-interactive]:disabled{opacity:var(--wy-opacity-disabled, 38%);pointer-events:none}[part~=wy-item-interactive][part~=wy-selected]{--wy-component-background-color: var(--wy-component-background-color-selected, var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff)));--wy-component-color: var(--wy-component-color-selected, var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73)));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-color:var(--wy-component-background-color)}[part~=wy-item-trashed]{text-decoration:line-through;opacity:var(--wy-opacity-disabled, 38%)}[part~=wy-item-trashed][part~=wy-item-interactive]:hover{opacity:1}[part~=wy-item-list]{display:flex;flex-direction:column;gap:var(--wy-border, 1px);min-width:0}[part~=wy-item-list-filled]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));--wy-component-background-color: var(--wy-surface-layer-low, var(--wy-surface-layer-low-light, rgba(255, 255, 255, .5019607843)));--wy-component-background-color-hover: var(--wy-surface-layer-lowest, var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078)));--wy-component-background-color-active: var(--wy-surface-layer-lowest, var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078)))}[part~=wy-item-list-rounded]{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));clip-path:content-box}[part~=wy-item-list-rounded-outer]{border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));clip-path:content-box}[part~=wy-item-list-bordered]{border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));gap:0}[part~=wy-item-list-bordered]>:not(slot),[part~=wy-item-list-bordered] ::slotted(*){border-left:none;border-right:none}[part~=wy-item-list-bordered]>:not(slot):not(:first-child),[part~=wy-item-list-bordered] ::slotted(*:not(:first-child)){border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}`, By = it`[part~=wy-title]{font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));font-size:var(--wy-headings-font-size, var(--wy-font-size, 1em));font-style:var(--wy-headings-font-style, unset);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.5));margin-block:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-meta]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-meta-sm]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))}[part~=wy-quote]{color:var(--wy-outline, var(--wy-outline-light, #72777f))}[part~=wy-quote]:before,[part~=wy-quote]:after{content:'\"'}`;
var TY = Object.defineProperty, MY = Object.getOwnPropertyDescriptor, Te = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? MY(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && TY(t, e, r), r;
}, "__decorateClass$15"), q$, Mf;
let Ne = (q$ = (Mf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.size = "auto", this.align = "middle", this.actionsPosition = "end", this.rounded = !1, this.noPadding = !1, this.outer = !1, this.interactive = !1, this.selected = !1, this.disabled = !1, this.url = void 0, this.trashed = !1;
  }
  /**
   * If it has an url; handles ctrl click event for the item.
   * @param event MouseEvent
   */
  handleLinkClick(t) {
    if (this.disabled) {
      t.preventDefault(), t.stopPropagation();
      return;
    }
    g1(t) && t.stopPropagation();
  }
  render() {
    const t = !!this._slotActions.length, e = !!this._slotMeta.length, i = !!this._slotText.length || this.actionsPosition === "bottom" && t;
    return v`
      <div
        part=${gt({
      "wy-item-rounded": this.rounded,
      "wy-item-rounded-outer": this.outer,
      "wy-item-inner": !0,
      "wy-item-inner-no-padding": this.noPadding,
      "wy-item-interactive": this.interactive,
      "wy-item-sm": this.size === "sm",
      "wy-item-md": this.size === "md",
      "wy-item-lg": this.size === "lg",
      "wy-item-top": this.align === "top",
      "wy-item-middle": this.align === "middle",
      "wy-item-bottom": this.align === "bottom",
      "wy-read": this.status === "read",
      "wy-unread": this.status === "unread",
      "wy-selected": this.selected,
      "wy-disabled": this.disabled
    })}
      >
        <div part="wy-item-image"><slot name="image"></slot></div>
        <div part="wy-item-body">
          <slot name="content">
            <div part="wy-item-rows">
              <div part="wy-item-row wy-item-row-first">
                <div part="wy-item-title wy-item-left">
                  ${this.url ? v`<a href=${this.url} @click=${(r) => this.handleLinkClick(r)}><slot name="title"></slot></a>` : v`<slot name="title"></slot>`}
                </div>
                <div part="wy-item-meta wy-meta wy-meta-sm" ?hidden=${!e}
                  ><slot name="meta" @slotchange=${() => this.requestUpdate()}></slot
                ></div>
              </div>
              <div part="wy-item-row wy-item-row-second" ?hidden=${!i}>
                <div part="wy-item-text wy-item-left ${gt({ "wy-item-text-sm": this.size === "auto" })}"
                  ><slot name="text" @slotchange=${() => this.requestUpdate()}></slot
                ></div>
                ${this.actionsPosition === "bottom" ? v`
                      <div part="wy-item-actions wy-item-actions-bottom"
                        ><slot name="actions" @slotchange=${() => this.requestUpdate()}></slot
                      ></div>
                    ` : C}
              </div>
            </div>
          </slot>
        </div>
        ${this.actionsPosition !== "bottom" ? v`
              <div
                part="wy-item-actions ${gt({
      "wy-item-actions-top": this.align === "top" || this.actionsPosition === "top"
    })}"
                ?hidden=${!t}
                ><slot name="actions" @slotchange=${() => this.requestUpdate()}></slot
              ></div>
            ` : C}
      </div>
    `;
  }
}, h(Mf, "Ks"), Mf), c(q$, "WyItem"), q$);
Ne.styles = [pe, qb, By];
Te([
  b()
], Ne.prototype, "size", 2);
Te([
  b()
], Ne.prototype, "align", 2);
Te([
  b()
], Ne.prototype, "actionsPosition", 2);
Te([
  b({ type: Boolean, reflect: !0 })
], Ne.prototype, "rounded", 2);
Te([
  b({ type: Boolean, reflect: !0 })
], Ne.prototype, "noPadding", 2);
Te([
  b({ type: Boolean, reflect: !0 })
], Ne.prototype, "outer", 2);
Te([
  b({ type: Boolean, reflect: !0 })
], Ne.prototype, "interactive", 2);
Te([
  b({ type: Boolean, reflect: !0 })
], Ne.prototype, "selected", 2);
Te([
  b({ type: Boolean, reflect: !0 })
], Ne.prototype, "disabled", 2);
Te([
  b({ reflect: !0 })
], Ne.prototype, "url", 2);
Te([
  b({ type: Boolean, reflect: !0 })
], Ne.prototype, "trashed", 2);
Te([
  b()
], Ne.prototype, "status", 2);
Te([
  Dl({ slot: "actions" })
], Ne.prototype, "_slotActions", 2);
Te([
  Dl({ slot: "meta" })
], Ne.prototype, "_slotMeta", 2);
Te([
  Dl({ slot: "text" })
], Ne.prototype, "_slotText", 2);
Ne = Te([
  Y("wy-item")
], Ne);
var Z$, Af;
let wa = (Z$ = (Af = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.outer = !1, this.bordered = !1, this.rounded = !1, this.filled = !1;
  }
  render() {
    const t = {
      "wy-item-list": !0,
      "wy-item-list-bordered": this.bordered,
      "wy-item-list-rounded": this.rounded,
      "wy-item-list-outer": this.outer,
      "wy-item-list-filled": this.filled
    };
    return v`<div part=${gt(t)}><slot></slot></div>`;
  }
}, h(Af, "Qs"), Af), c(Z$, "WyItemList"), Z$);
wa.styles = [qb, ft];
Te([
  b({ type: Boolean })
], wa.prototype, "outer", 2);
Te([
  b({ type: Boolean })
], wa.prototype, "bordered", 2);
Te([
  b({ type: Boolean })
], wa.prototype, "rounded", 2);
Te([
  b({ type: Boolean })
], wa.prototype, "filled", 2);
wa = Te([
  Y("wy-item-list")
], wa);
const $D = it`[part~=wy-button]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c));color:var(--wy-component-color);background:var(--wy-component-background-color, transparent);height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;font-size:var(--wy-button-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-button-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));text-align:center;text-decoration:none;vertical-align:middle;cursor:pointer;-webkit-user-select:none;user-select:none;border:var(--wy-button-border-width, var(--wy-border-outline, 0)) solid var(--wy-outline, var(--wy-outline-light, #72777f));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem))));display:inline-flex;align-items:center;justify-content:center;gap:var(--wy-button-gap, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));position:relative}[part~=wy-button][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.8);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.5)}[part~=wy-button][part~=wy-disabled],[part~=wy-button]:disabled{opacity:var(--wy-opacity-disabled, 38%);cursor:unset;pointer-events:none}[part~=wy-button-state-layer]>*{z-index:3}[part~=wy-button-state-layer]:before{content:\"\";z-index:2;position:absolute;inset:0;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-button-state-layer]:hover:before{opacity:8%}[part~=wy-button-state-layer]:focus:before,[part~=wy-button-state-layer]:active:before,[part~=wy-button-state-layer][part~=wy-active]:before{opacity:12%}[part~=wy-button-icon]{--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));line-height:1;align-items:center;justify-content:center}[part~=wy-button-icon][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);padding:0;margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.5)}[part~=wy-button-icon][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*-.1)}[part~=wy-button-icon][part~=wy-active]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-button-icon-inline]{height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));width:auto;min-width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));background:var(--wy-component-background-color);color:currentColor;display:flex;padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-button-icon-inline][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);min-width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.25);margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.5)}[part~=wy-button-icon-inline][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*-.1)}[part~=wy-button-inline]{border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-button-inline][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.8);min-width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.8);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.75);margin-inline:calc(-.75*var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-button-primary]{--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73))}[part~=wy-button-variant]{--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}[part~=wy-button-primary-text]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-button-inherit-color]{--wy-component-color: currentColor}[part~=wy-button-no-color]{--wy-component-background-color: transparent;--wy-component-color: unset}[part~=wy-button-link]{padding:0;color:var(--wy-link-color, var(--wy-primary, var(--wy-primary-light, #2f628c)));text-decoration:var(--wy-link-decoration, none)}[part~=wy-button-link]:hover,[part~=wy-button-link]:focus{text-decoration:var(--wy-link-hover-decoration, var(--wy-link-decoration, none))}[part~=wy-buttons]{display:flex;align-items:center;flex-wrap:wrap;gap:calc(.5*var(--wy-size, 1rem))}[part~=wy-buttons-reverse]{flex-direction:row-reverse}[part~=wy-buttons-floating]{position:sticky;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) 0;top:0;height:0;margin-bottom:calc(-1*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));z-index:1030;--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}[part~=wy-buttons-sticky]{position:sticky;padding:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));top:var(--wy-component-offset-top, 0px);z-index:1021;--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}`, xD = it`[part~=wy-tabs]{display:flex;overflow-y:hidden;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));flex:1 1 auto}[part~=wy-tabs]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-tabs]{scrollbar-width:thin;scrollbar-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf)) rgba(0,0,0,0)}[part~=wy-tabs]::-webkit-scrollbar{height:.375rem;width:.375rem;background:#0000;z-index:999}[part~=wy-tabs]::-webkit-scrollbar-track{background:#0000}[part~=wy-tabs]::-webkit-scrollbar-thumb{background-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));opacity:75%;border:0 solid rgba(0,0,0,0);border-radius:0;background-clip:padding-box}[part~=wy-tabs]::-webkit-scrollbar-thumb:hover{background-color:var(--wy-outline, var(--wy-outline-light, #72777f));opacity:75%}[part~=wy-tabs]::-webkit-scrollbar-thumb:window-inactive{background-color:var(--wy-outline, var(--wy-outline-light, #72777f));opacity:50%}[part~=wy-tab]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c));--wy-component-background-color: transparent;color:var(--wy-component-color);background:var(--wy-component-background-color);border:none;border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));display:inline-flex;flex-direction:column;align-items:center;justify-content:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));position:relative;text-align:center;text-decoration:none;cursor:pointer;-webkit-user-select:none;user-select:none}[part~=wy-tab] .wy-tab-icon{position:relative;padding:calc(.25*var(--wy-size, 1rem)) calc(1*var(--wy-size, 1rem));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem))));display:inline-flex}[part~=wy-tab] .wy-tab-icon:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-tab]:hover .wy-tab-icon:before{opacity:8%}[part~=wy-tab]:focus .wy-tab-icon:before,[part~=wy-tab]:active .wy-tab-icon:before,[part~=wy-tab].wy-active .wy-tab-icon:before{opacity:12%}[part~=wy-tab] .wy-tab-label{font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));font-weight:var(--wy-font-weight, unset)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]{padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.5);margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) auto;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]:before{margin:calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*-.25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*0)}`;
var AY = Object.defineProperty, RY = Object.getOwnPropertyDescriptor, ji = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? RY(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && AY(t, e, r), r;
}, "__decorateClass$14"), B$, Rf;
let or = (B$ = (Rf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this, !1), this.kind = "filled", this.active = !1, this.small = !1, this.disabled = !1;
  }
  render() {
    const t = {
      "wy-button": !0,
      "wy-active": !!this.active,
      "wy-disabled": !!this.disabled,
      "wy-button-inline": this.kind === "inline",
      "wy-button-icon": this.kind === "icon",
      "wy-button-icon-inline": this.kind === "icon-inline",
      "wy-button-link": this.kind === "link",
      "wy-button-primary": this.color === "primary",
      "wy-button-primary-text": this.color === "primary-text",
      "wy-button-inherit-color": this.color === "inherit",
      "wy-button-no-color": this.color === "none",
      "wy-button-variant": this.color === "variant",
      "wy-button-type-submit": this.type === "submit",
      "wy-button-type-reset": this.type === "reset",
      "wy-button-state-layer": this.kind !== "link" && !this.disabled,
      "wy-button-sm": !!this.small,
      "wy-tab": this.kind === "tab",
      "wy-tab-sm": this.kind === "tab" && !!this.small
    };
    return this.href ? v`
      <a href=${this.href} target=${St(this.target)} download=${St(this.download)} part=${gt(t)} aria-disabled=${this.disabled ? "true" : "false"}>
        <slot></slot>
      </a>
    ` : v`
      <button part=${gt(t)} type=${St(this.type)} ?disabled=${this.disabled} aria-disabled=${this.disabled ? "true" : "false"}>
        <slot></slot>
      </button>
    `;
  }
}, h(Rf, "Gs"), Rf), c(B$, "WyButton"), B$);
or.styles = [
  pe,
  $D,
  xD,
  ft,
  it`
      :host {
        position: relative;
      }
    `
];
ji([
  b()
], or.prototype, "type", 2);
ji([
  b()
], or.prototype, "kind", 2);
ji([
  b({ type: Boolean })
], or.prototype, "active", 2);
ji([
  b()
], or.prototype, "color", 2);
ji([
  b({ type: Boolean })
], or.prototype, "small", 2);
ji([
  b({ type: Boolean, reflect: !0 })
], or.prototype, "disabled", 2);
ji([
  b()
], or.prototype, "href", 2);
ji([
  b()
], or.prototype, "target", 2);
ji([
  b()
], or.prototype, "download", 2);
or = ji([
  Y("wy-button")
], or);
var N$, Ef;
let vl = (N$ = (Ef = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.tabs = !1, this.position = "normal", this.reverse = !1;
  }
  render() {
    const t = {
      "wy-buttons": !this.tabs,
      "wy-buttons-reverse": this.reverse,
      "wy-tabs": this.tabs,
      "wy-buttons-floating": this.position === "floating",
      "wy-buttons-sticky": this.position === "sticky"
    };
    return v`<div part=${gt(t)}><slot></slot></div>`;
  }
}, h(Ef, "Zs"), Ef), c(N$, "WyButtons"), N$);
vl.styles = [
  pe,
  $D,
  xD,
  ft
];
ji([
  b({ type: Boolean })
], vl.prototype, "tabs", 2);
ji([
  b({ type: String })
], vl.prototype, "position", 2);
ji([
  b({ type: Boolean })
], vl.prototype, "reverse", 2);
vl = ji([
  Y("wy-buttons")
], vl);
const kD = "important", EY = " !" + kD, Jw = Bl(class extends Zy {
  constructor(s) {
    if (super(s), s.type !== A1.ATTRIBUTE || s.name !== "style" || s.strings?.length > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(s) {
    return Object.keys(s).reduce(((t, e) => {
      const i = s[e];
      return i == null ? t : t + `${e = e.includes("-") ? e : e.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${i};`;
    }), "");
  }
  update(s, [t]) {
    const { style: e } = s.element;
    if (this.ft === void 0) return this.ft = new Set(Object.keys(t)), this.render(t);
    for (const i of this.ft) t[i] == null && (this.ft.delete(i), i.includes("-") ? e.removeProperty(i) : e[i] = null);
    for (const i in t) {
      const r = t[i];
      if (r != null) {
        this.ft.add(i);
        const n = typeof r == "string" && r.endsWith(EY);
        i.includes("-") || n ? e.setProperty(i, n ? r.slice(0, -11) : r, n ? kD : "") : e[i] = r;
      }
    }
    return ms;
  }
}), Q0 = Math.min, vo = Math.max, T0 = Math.round, $v = Math.floor, us = /* @__PURE__ */ c((s) => ({
  x: s,
  y: s
}), "createCoords"), _Y = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, LY = {
  start: "end",
  end: "start"
};
function AS(s, t, e) {
  return vo(s, Q0(t, e));
}
h(AS, "kf");
c(AS, "clamp");
function R1(s, t) {
  return typeof s == "function" ? s(t) : s;
}
h(R1, "Mh");
c(R1, "evaluate");
function va(s) {
  return s.split("-")[0];
}
h(va, "Tn");
c(va, "getSide");
function E1(s) {
  return s.split("-")[1];
}
h(E1, "Ah");
c(E1, "getAlignment");
function E4(s) {
  return s === "x" ? "y" : "x";
}
h(E4, "hv");
c(E4, "getOppositeAxis");
function _4(s) {
  return s === "y" ? "height" : "width";
}
h(_4, "uv");
c(_4, "getAxisLength");
const zY = /* @__PURE__ */ new Set(["top", "bottom"]);
function Xs(s) {
  return zY.has(va(s)) ? "y" : "x";
}
h(Xs, "zr");
c(Xs, "getSideAxis");
function L4(s) {
  return E4(Xs(s));
}
h(L4, "pv");
c(L4, "getAlignmentAxis");
function SD(s, t, e) {
  e === void 0 && (e = !1);
  const i = E1(s), r = L4(s), n = _4(r);
  let a = r === "x" ? i === (e ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return t.reference[n] > t.floating[n] && (a = t1(a)), [a, t1(a)];
}
h(SD, "U5");
c(SD, "getAlignmentSides");
function CD(s) {
  const t = t1(s);
  return [M0(s), t, M0(t)];
}
h(CD, "q5");
c(CD, "getExpandedPlacements");
function M0(s) {
  return s.replace(/start|end/g, (t) => LY[t]);
}
h(M0, "Bp");
c(M0, "getOppositeAlignmentPlacement");
const A9 = ["left", "right"], R9 = ["right", "left"], IY = ["top", "bottom"], DY = ["bottom", "top"];
function PD(s, t, e) {
  switch (s) {
    case "top":
    case "bottom":
      return e ? t ? R9 : A9 : t ? A9 : R9;
    case "left":
    case "right":
      return t ? IY : DY;
    default:
      return [];
  }
}
h(PD, "K5");
c(PD, "getSideList");
function QD(s, t, e, i) {
  const r = E1(s);
  let n = PD(va(s), e === "start", i);
  return r && (n = n.map((a) => a + "-" + r), t && (n = n.concat(n.map(M0)))), n;
}
h(QD, "Q5");
c(QD, "getOppositeAxisPlacements");
function t1(s) {
  return s.replace(/left|right|bottom|top/g, (t) => _Y[t]);
}
h(t1, "oh");
c(t1, "getOppositePlacement");
function TD(s) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...s
  };
}
h(TD, "G5");
c(TD, "expandPaddingObject");
function MD(s) {
  return typeof s != "number" ? TD(s) : {
    top: s,
    right: s,
    bottom: s,
    left: s
  };
}
h(MD, "Z5");
c(MD, "getPaddingObject");
function e1(s) {
  const {
    x: t,
    y: e,
    width: i,
    height: r
  } = s;
  return {
    width: i,
    height: r,
    top: e,
    left: t,
    right: t + i,
    bottom: e + r,
    x: t,
    y: e
  };
}
h(e1, "ch");
c(e1, "rectToClientRect");
function RS(s, t, e) {
  let {
    reference: i,
    floating: r
  } = s;
  const n = Xs(t), a = L4(t), o = _4(a), l = va(t), d = n === "y", u = i.x + i.width / 2 - r.width / 2, p = i.y + i.height / 2 - r.height / 2, f = i[o] / 2 - r[o] / 2;
  let y;
  switch (l) {
    case "top":
      y = {
        x: u,
        y: i.y - r.height
      };
      break;
    case "bottom":
      y = {
        x: u,
        y: i.y + i.height
      };
      break;
    case "right":
      y = {
        x: i.x + i.width,
        y: p
      };
      break;
    case "left":
      y = {
        x: i.x - r.width,
        y: p
      };
      break;
    default:
      y = {
        x: i.x,
        y: i.y
      };
  }
  switch (E1(t)) {
    case "start":
      y[a] -= f * (e && d ? -1 : 1);
      break;
    case "end":
      y[a] += f * (e && d ? -1 : 1);
      break;
  }
  return y;
}
h(RS, "Sf");
c(RS, "computeCoordsFromPlacement");
const VY = /* @__PURE__ */ c(async (s, t, e) => {
  const {
    placement: i = "bottom",
    strategy: r = "absolute",
    middleware: n = [],
    platform: a
  } = e, o = n.filter(Boolean), l = await (a.isRTL == null ? void 0 : a.isRTL(t));
  let d = await a.getElementRects({
    reference: s,
    floating: t,
    strategy: r
  }), {
    x: u,
    y: p
  } = RS(d, i, l), f = i, y = {}, g = 0;
  for (let O = 0; O < o.length; O++) {
    const {
      name: k,
      fn: $
    } = o[O], {
      x: T,
      y: _,
      data: D,
      reset: A
    } = await $({
      x: u,
      y: p,
      initialPlacement: i,
      placement: f,
      strategy: r,
      middlewareData: y,
      rects: d,
      platform: a,
      elements: {
        reference: s,
        floating: t
      }
    });
    u = T ?? u, p = _ ?? p, y = {
      ...y,
      [k]: {
        ...y[k],
        ...D
      }
    }, A && g <= 50 && (g++, typeof A == "object" && (A.placement && (f = A.placement), A.rects && (d = A.rects === !0 ? await a.getElementRects({
      reference: s,
      floating: t,
      strategy: r
    }) : A.rects), {
      x: u,
      y: p
    } = RS(d, f, l)), O = -1);
  }
  return {
    x: u,
    y: p,
    placement: f,
    strategy: r,
    middlewareData: y
  };
}, "computePosition$1");
async function z4(s, t) {
  var e;
  t === void 0 && (t = {});
  const {
    x: i,
    y: r,
    platform: n,
    rects: a,
    elements: o,
    strategy: l
  } = s, {
    boundary: d = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: p = "floating",
    altBoundary: f = !1,
    padding: y = 0
  } = R1(t, s), g = MD(y), O = o[f ? p === "floating" ? "reference" : "floating" : p], k = e1(await n.getClippingRect({
    element: (e = await (n.isElement == null ? void 0 : n.isElement(O))) == null || e ? O : O.contextElement || await (n.getDocumentElement == null ? void 0 : n.getDocumentElement(o.floating)),
    boundary: d,
    rootBoundary: u,
    strategy: l
  })), $ = p === "floating" ? {
    x: i,
    y: r,
    width: a.floating.width,
    height: a.floating.height
  } : a.reference, T = await (n.getOffsetParent == null ? void 0 : n.getOffsetParent(o.floating)), _ = await (n.isElement == null ? void 0 : n.isElement(T)) ? await (n.getScale == null ? void 0 : n.getScale(T)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, D = e1(n.convertOffsetParentRelativeRectToViewportRelativeRect ? await n.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: o,
    rect: $,
    offsetParent: T,
    strategy: l
  }) : $);
  return {
    top: (k.top - D.top + g.top) / _.y,
    bottom: (D.bottom - k.bottom + g.bottom) / _.y,
    left: (k.left - D.left + g.left) / _.x,
    right: (D.right - k.right + g.right) / _.x
  };
}
h(z4, "yv");
c(z4, "detectOverflow");
const WY = /* @__PURE__ */ c(function(s) {
  return s === void 0 && (s = {}), {
    name: "flip",
    options: s,
    async fn(t) {
      var e, i;
      const {
        placement: r,
        middlewareData: n,
        rects: a,
        initialPlacement: o,
        platform: l,
        elements: d
      } = t, {
        mainAxis: u = !0,
        crossAxis: p = !0,
        fallbackPlacements: f,
        fallbackStrategy: y = "bestFit",
        fallbackAxisSideDirection: g = "none",
        flipAlignment: O = !0,
        ...k
      } = R1(s, t);
      if ((e = n.arrow) != null && e.alignmentOffset)
        return {};
      const $ = va(r), T = Xs(o), _ = va(o) === o, D = await (l.isRTL == null ? void 0 : l.isRTL(d.floating)), A = f || (_ || !O ? [t1(o)] : CD(o)), z = g !== "none";
      !f && z && A.push(...QD(o, O, g, D));
      const V = [o, ...A], X = await z4(t, k), tt = [];
      let vt = ((i = n.flip) == null ? void 0 : i.overflows) || [];
      if (u && tt.push(X[$]), p) {
        const ct = SD(r, a, D);
        tt.push(X[ct[0]], X[ct[1]]);
      }
      if (vt = [...vt, {
        placement: r,
        overflows: tt
      }], !tt.every((ct) => ct <= 0)) {
        var dt, st;
        const ct = (((dt = n.flip) == null ? void 0 : dt.index) || 0) + 1, Vt = V[ct];
        if (Vt && (!(p === "alignment" && T !== Xs(Vt)) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        vt.every((Zt) => Xs(Zt.placement) === T ? Zt.overflows[0] > 0 : !0)))
          return {
            data: {
              index: ct,
              overflows: vt
            },
            reset: {
              placement: Vt
            }
          };
        let _t = (st = vt.filter((Zt) => Zt.overflows[0] <= 0).sort((Zt, Nt) => Zt.overflows[1] - Nt.overflows[1])[0]) == null ? void 0 : st.placement;
        if (!_t)
          switch (y) {
            case "bestFit": {
              var Pt;
              const Zt = (Pt = vt.filter((Nt) => {
                if (z) {
                  const Xt = Xs(Nt.placement);
                  return Xt === T || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Xt === "y";
                }
                return !0;
              }).map((Nt) => [Nt.placement, Nt.overflows.filter((Xt) => Xt > 0).reduce((Xt, Li) => Xt + Li, 0)]).sort((Nt, Xt) => Nt[1] - Xt[1])[0]) == null ? void 0 : Pt[0];
              Zt && (_t = Zt);
              break;
            }
            case "initialPlacement":
              _t = o;
              break;
          }
        if (r !== _t)
          return {
            reset: {
              placement: _t
            }
          };
      }
      return {};
    }
  };
}, "flip$1"), FY = /* @__PURE__ */ new Set(["left", "top"]);
async function AD(s, t) {
  const {
    placement: e,
    platform: i,
    elements: r
  } = s, n = await (i.isRTL == null ? void 0 : i.isRTL(r.floating)), a = va(e), o = E1(e), l = Xs(e) === "y", d = FY.has(a) ? -1 : 1, u = n && l ? -1 : 1, p = R1(t, s);
  let {
    mainAxis: f,
    crossAxis: y,
    alignmentAxis: g
  } = typeof p == "number" ? {
    mainAxis: p,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: p.mainAxis || 0,
    crossAxis: p.crossAxis || 0,
    alignmentAxis: p.alignmentAxis
  };
  return o && typeof g == "number" && (y = o === "end" ? g * -1 : g), l ? {
    x: y * u,
    y: f * d
  } : {
    x: f * d,
    y: y * u
  };
}
h(AD, "tx");
c(AD, "convertValueToCoords");
const qY = /* @__PURE__ */ c(function(s) {
  return s === void 0 && (s = 0), {
    name: "offset",
    options: s,
    async fn(t) {
      var e, i;
      const {
        x: r,
        y: n,
        placement: a,
        middlewareData: o
      } = t, l = await AD(t, s);
      return a === ((e = o.offset) == null ? void 0 : e.placement) && (i = o.arrow) != null && i.alignmentOffset ? {} : {
        x: r + l.x,
        y: n + l.y,
        data: {
          ...l,
          placement: a
        }
      };
    }
  };
}, "offset$1"), ZY = /* @__PURE__ */ c(function(s) {
  return s === void 0 && (s = {}), {
    name: "shift",
    options: s,
    async fn(t) {
      const {
        x: e,
        y: i,
        placement: r
      } = t, {
        mainAxis: n = !0,
        crossAxis: a = !1,
        limiter: o = {
          fn: /* @__PURE__ */ c((k) => {
            let {
              x: $,
              y: T
            } = k;
            return {
              x: $,
              y: T
            };
          }, "fn")
        },
        ...l
      } = R1(s, t), d = {
        x: e,
        y: i
      }, u = await z4(t, l), p = Xs(va(r)), f = E4(p);
      let y = d[f], g = d[p];
      if (n) {
        const k = f === "y" ? "top" : "left", $ = f === "y" ? "bottom" : "right", T = y + u[k], _ = y - u[$];
        y = AS(T, y, _);
      }
      if (a) {
        const k = p === "y" ? "top" : "left", $ = p === "y" ? "bottom" : "right", T = g + u[k], _ = g - u[$];
        g = AS(T, g, _);
      }
      const O = o.fn({
        ...t,
        [f]: y,
        [p]: g
      });
      return {
        ...O,
        data: {
          x: O.x - e,
          y: O.y - i,
          enabled: {
            [f]: n,
            [p]: a
          }
        }
      };
    }
  };
}, "shift$1");
function _1() {
  return typeof window < "u";
}
h(_1, "Eh");
c(_1, "hasWindow");
function Xl(s) {
  return I4(s) ? (s.nodeName || "").toLowerCase() : "#document";
}
h(Xl, "Zc");
c(Xl, "getNodeName");
function Fi(s) {
  var t;
  return (s == null || (t = s.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
h(Fi, "Je");
c(Fi, "getWindow");
function Br(s) {
  var t;
  return (t = (I4(s) ? s.ownerDocument : s.document) || window.document) == null ? void 0 : t.documentElement;
}
h(Br, "Vi");
c(Br, "getDocumentElement");
function I4(s) {
  return _1() ? s instanceof Node || s instanceof Fi(s).Node : !1;
}
h(I4, "wv");
c(I4, "isNode");
function kr(s) {
  return _1() ? s instanceof Element || s instanceof Fi(s).Element : !1;
}
h(kr, "fi");
c(kr, "isElement");
function qr(s) {
  return _1() ? s instanceof HTMLElement || s instanceof Fi(s).HTMLElement : !1;
}
h(qr, "Oi");
c(qr, "isHTMLElement");
function ES(s) {
  return !_1() || typeof ShadowRoot > "u" ? !1 : s instanceof ShadowRoot || s instanceof Fi(s).ShadowRoot;
}
h(ES, "Mf");
c(ES, "isShadowRoot");
const BY = /* @__PURE__ */ new Set(["inline", "contents"]);
function Ny(s) {
  const {
    overflow: t,
    overflowX: e,
    overflowY: i,
    display: r
  } = Sr(s);
  return /auto|scroll|overlay|hidden|clip/.test(t + i + e) && !BY.has(r);
}
h(Ny, "wd");
c(Ny, "isOverflowElement");
const NY = /* @__PURE__ */ new Set(["table", "td", "th"]);
function RD(s) {
  return NY.has(Xl(s));
}
h(RD, "ax");
c(RD, "isTableElement");
const XY = [":popover-open", ":modal"];
function L1(s) {
  return XY.some((t) => {
    try {
      return s.matches(t);
    } catch {
      return !1;
    }
  });
}
h(L1, "Rh");
c(L1, "isTopLayer");
const jY = ["transform", "translate", "scale", "rotate", "perspective"], UY = ["transform", "translate", "scale", "rotate", "perspective", "filter"], HY = ["paint", "layout", "strict", "content"];
function Zb(s) {
  const t = Bb(), e = kr(s) ? Sr(s) : s;
  return jY.some((i) => e[i] ? e[i] !== "none" : !1) || (e.containerType ? e.containerType !== "normal" : !1) || !t && (e.backdropFilter ? e.backdropFilter !== "none" : !1) || !t && (e.filter ? e.filter !== "none" : !1) || UY.some((i) => (e.willChange || "").includes(i)) || HY.some((i) => (e.contain || "").includes(i));
}
h(Zb, "Sy");
c(Zb, "isContainingBlock");
function ED(s) {
  let t = an(s);
  for (; qr(t) && !Ol(t); ) {
    if (Zb(t))
      return t;
    if (L1(t))
      return null;
    t = an(t);
  }
  return null;
}
h(ED, "dx");
c(ED, "getContainingBlock");
function Bb() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
h(Bb, "My");
c(Bb, "isWebKit");
const YY = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Ol(s) {
  return YY.has(Xl(s));
}
h(Ol, "Lc");
c(Ol, "isLastTraversableNode");
function Sr(s) {
  return Fi(s).getComputedStyle(s);
}
h(Sr, "mi");
c(Sr, "getComputedStyle$1");
function z1(s) {
  return kr(s) ? {
    scrollLeft: s.scrollLeft,
    scrollTop: s.scrollTop
  } : {
    scrollLeft: s.scrollX,
    scrollTop: s.scrollY
  };
}
h(z1, "Th");
c(z1, "getNodeScroll");
function an(s) {
  if (Xl(s) === "html")
    return s;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    s.assignedSlot || // DOM Element detected.
    s.parentNode || // ShadowRoot detected.
    ES(s) && s.host || // Fallback.
    Br(s)
  );
  return ES(t) ? t.host : t;
}
h(an, "Ur");
c(an, "getParentNode");
function D4(s) {
  const t = an(s);
  return Ol(t) ? s.ownerDocument ? s.ownerDocument.body : s.body : qr(t) && Ny(t) ? t : D4(t);
}
h(D4, "fv");
c(D4, "getNearestOverflowAncestor");
function xy(s, t, e) {
  var i;
  t === void 0 && (t = []), e === void 0 && (e = !0);
  const r = D4(s), n = r === ((i = s.ownerDocument) == null ? void 0 : i.body), a = Fi(r);
  if (n) {
    const o = A0(a);
    return t.concat(a, a.visualViewport || [], Ny(r) ? r : [], o && e ? xy(o) : []);
  }
  return t.concat(r, xy(r, [], e));
}
h(xy, "Pl");
c(xy, "getOverflowAncestors");
function A0(s) {
  return s.parent && Object.getPrototypeOf(s.parent) ? s.frameElement : null;
}
h(A0, "Np");
c(A0, "getFrameElement");
function V4(s) {
  const t = Sr(s);
  let e = parseFloat(t.width) || 0, i = parseFloat(t.height) || 0;
  const r = qr(s), n = r ? s.offsetWidth : e, a = r ? s.offsetHeight : i, o = T0(e) !== n || T0(i) !== a;
  return o && (e = n, i = a), {
    width: e,
    height: i,
    $: o
  };
}
h(V4, "mv");
c(V4, "getCssDimensions");
function Nb(s) {
  return kr(s) ? s : s.contextElement;
}
h(Nb, "Ay");
c(Nb, "unwrapElement");
function Oo(s) {
  const t = Nb(s);
  if (!qr(t))
    return us(1);
  const e = t.getBoundingClientRect(), {
    width: i,
    height: r,
    $: n
  } = V4(t);
  let a = (n ? T0(e.width) : e.width) / i, o = (n ? T0(e.height) : e.height) / r;
  return (!a || !Number.isFinite(a)) && (a = 1), (!o || !Number.isFinite(o)) && (o = 1), {
    x: a,
    y: o
  };
}
h(Oo, "Sa");
c(Oo, "getScale");
const GY = /* @__PURE__ */ us(0);
function W4(s) {
  const t = Fi(s);
  return !Bb() || !t.visualViewport ? GY : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
h(W4, "vv");
c(W4, "getVisualOffsets");
function _D(s, t, e) {
  return t === void 0 && (t = !1), !e || t && e !== Fi(s) ? !1 : t;
}
h(_D, "px");
c(_D, "shouldAddVisualOffsets");
function Oa(s, t, e, i) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  const r = s.getBoundingClientRect(), n = Nb(s);
  let a = us(1);
  t && (i ? kr(i) && (a = Oo(i)) : a = Oo(s));
  const o = _D(n, e, i) ? W4(n) : us(0);
  let l = (r.left + o.x) / a.x, d = (r.top + o.y) / a.y, u = r.width / a.x, p = r.height / a.y;
  if (n) {
    const f = Fi(n), y = i && kr(i) ? Fi(i) : i;
    let g = f, O = A0(g);
    for (; O && i && y !== g; ) {
      const k = Oo(O), $ = O.getBoundingClientRect(), T = Sr(O), _ = $.left + (O.clientLeft + parseFloat(T.paddingLeft)) * k.x, D = $.top + (O.clientTop + parseFloat(T.paddingTop)) * k.y;
      l *= k.x, d *= k.y, u *= k.x, p *= k.y, l += _, d += D, g = Fi(O), O = A0(g);
    }
  }
  return e1({
    width: u,
    height: p,
    x: l,
    y: d
  });
}
h(Oa, "Ln");
c(Oa, "getBoundingClientRect");
function I1(s, t) {
  const e = z1(s).scrollLeft;
  return t ? t.left + e : Oa(Br(s)).left + e;
}
h(I1, "Lh");
c(I1, "getWindowScrollBarX");
function F4(s, t) {
  const e = s.getBoundingClientRect(), i = e.left + t.scrollLeft - I1(s, e), r = e.top + t.scrollTop;
  return {
    x: i,
    y: r
  };
}
h(F4, "gv");
c(F4, "getHTMLOffset");
function LD(s) {
  let {
    elements: t,
    rect: e,
    offsetParent: i,
    strategy: r
  } = s;
  const n = r === "fixed", a = Br(i), o = t ? L1(t.floating) : !1;
  if (i === a || o && n)
    return e;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, d = us(1);
  const u = us(0), p = qr(i);
  if ((p || !p && !n) && ((Xl(i) !== "body" || Ny(a)) && (l = z1(i)), qr(i))) {
    const y = Oa(i);
    d = Oo(i), u.x = y.x + i.clientLeft, u.y = y.y + i.clientTop;
  }
  const f = a && !p && !n ? F4(a, l) : us(0);
  return {
    width: e.width * d.x,
    height: e.height * d.y,
    x: e.x * d.x - l.scrollLeft * d.x + u.x + f.x,
    y: e.y * d.y - l.scrollTop * d.y + u.y + f.y
  };
}
h(LD, "yx");
c(LD, "convertOffsetParentRelativeRectToViewportRelativeRect");
function zD(s) {
  return Array.from(s.getClientRects());
}
h(zD, "wx");
c(zD, "getClientRects");
function ID(s) {
  const t = Br(s), e = z1(s), i = s.ownerDocument.body, r = vo(t.scrollWidth, t.clientWidth, i.scrollWidth, i.clientWidth), n = vo(t.scrollHeight, t.clientHeight, i.scrollHeight, i.clientHeight);
  let a = -e.scrollLeft + I1(s);
  const o = -e.scrollTop;
  return Sr(i).direction === "rtl" && (a += vo(t.clientWidth, i.clientWidth) - r), {
    width: r,
    height: n,
    x: a,
    y: o
  };
}
h(ID, "fx");
c(ID, "getDocumentRect");
const E9 = 25;
function DD(s, t) {
  const e = Fi(s), i = Br(s), r = e.visualViewport;
  let n = i.clientWidth, a = i.clientHeight, o = 0, l = 0;
  if (r) {
    n = r.width, a = r.height;
    const u = Bb();
    (!u || u && t === "fixed") && (o = r.offsetLeft, l = r.offsetTop);
  }
  const d = I1(i);
  if (d <= 0) {
    const u = i.ownerDocument, p = u.body, f = getComputedStyle(p), y = u.compatMode === "CSS1Compat" && parseFloat(f.marginLeft) + parseFloat(f.marginRight) || 0, g = Math.abs(i.clientWidth - p.clientWidth - y);
    g <= E9 && (n -= g);
  } else d <= E9 && (n += d);
  return {
    width: n,
    height: a,
    x: o,
    y: l
  };
}
h(DD, "mx");
c(DD, "getViewportRect");
const KY = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function VD(s, t) {
  const e = Oa(s, !0, t === "fixed"), i = e.top + s.clientTop, r = e.left + s.clientLeft, n = qr(s) ? Oo(s) : us(1), a = s.clientWidth * n.x, o = s.clientHeight * n.y, l = r * n.x, d = i * n.y;
  return {
    width: a,
    height: o,
    x: l,
    y: d
  };
}
h(VD, "gx");
c(VD, "getInnerBoundingClientRect");
function _S(s, t, e) {
  let i;
  if (t === "viewport")
    i = DD(s, e);
  else if (t === "document")
    i = ID(Br(s));
  else if (kr(t))
    i = VD(t, e);
  else {
    const r = W4(s);
    i = {
      x: t.x - r.x,
      y: t.y - r.y,
      width: t.width,
      height: t.height
    };
  }
  return e1(i);
}
h(_S, "Ef");
c(_S, "getClientRectFromClippingAncestor");
function q4(s, t) {
  const e = an(s);
  return e === t || !kr(e) || Ol(e) ? !1 : Sr(e).position === "fixed" || q4(e, t);
}
h(q4, "bv");
c(q4, "hasFixedPositionAncestor");
function WD(s, t) {
  const e = t.get(s);
  if (e)
    return e;
  let i = xy(s, [], !1).filter((o) => kr(o) && Xl(o) !== "body"), r = null;
  const n = Sr(s).position === "fixed";
  let a = n ? an(s) : s;
  for (; kr(a) && !Ol(a); ) {
    const o = Sr(a), l = Zb(a);
    !l && o.position === "fixed" && (r = null), (n ? !l && !r : !l && o.position === "static" && r && KY.has(r.position) || Ny(a) && !l && q4(s, a)) ? i = i.filter((d) => d !== a) : r = o, a = an(a);
  }
  return t.set(s, i), i;
}
h(WD, "bx");
c(WD, "getClippingElementAncestors");
function FD(s) {
  let {
    element: t,
    boundary: e,
    rootBoundary: i,
    strategy: r
  } = s;
  const n = [...e === "clippingAncestors" ? L1(t) ? [] : WD(t, this._c) : [].concat(e), i], a = n[0], o = n.reduce((l, d) => {
    const u = _S(t, d, r);
    return l.top = vo(u.top, l.top), l.right = Q0(u.right, l.right), l.bottom = Q0(u.bottom, l.bottom), l.left = vo(u.left, l.left), l;
  }, _S(t, a, r));
  return {
    width: o.right - o.left,
    height: o.bottom - o.top,
    x: o.left,
    y: o.top
  };
}
h(FD, "xx");
c(FD, "getClippingRect");
function qD(s) {
  const {
    width: t,
    height: e
  } = V4(s);
  return {
    width: t,
    height: e
  };
}
h(qD, "Cx");
c(qD, "getDimensions");
function ZD(s, t, e) {
  const i = qr(t), r = Br(t), n = e === "fixed", a = Oa(s, !0, n, t);
  let o = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = us(0);
  function d() {
    l.x = I1(r);
  }
  if (h(d, "p"), c(d, "setLeftRTLScrollbarOffset"), i || !i && !n)
    if ((Xl(t) !== "body" || Ny(r)) && (o = z1(t)), i) {
      const y = Oa(t, !0, n, t);
      l.x = y.x + t.clientLeft, l.y = y.y + t.clientTop;
    } else r && d();
  n && !i && r && d();
  const u = r && !i && !n ? F4(r, o) : us(0), p = a.left + o.scrollLeft - l.x - u.x, f = a.top + o.scrollTop - l.y - u.y;
  return {
    x: p,
    y: f,
    width: a.width,
    height: a.height
  };
}
h(ZD, "$x");
c(ZD, "getRectRelativeToOffsetParent");
function uO(s) {
  return Sr(s).position === "static";
}
h(uO, "qu");
c(uO, "isStaticPositioned");
function LS(s, t) {
  if (!qr(s) || Sr(s).position === "fixed")
    return null;
  if (t)
    return t(s);
  let e = s.offsetParent;
  return Br(s) === e && (e = e.ownerDocument.body), e;
}
h(LS, "Rf");
c(LS, "getTrueOffsetParent");
function Z4(s, t) {
  const e = Fi(s);
  if (L1(s))
    return e;
  if (!qr(s)) {
    let r = an(s);
    for (; r && !Ol(r); ) {
      if (kr(r) && !uO(r))
        return r;
      r = an(r);
    }
    return e;
  }
  let i = LS(s, t);
  for (; i && RD(i) && uO(i); )
    i = LS(i, t);
  return i && Ol(i) && uO(i) && !Zb(i) ? e : i || ED(s) || e;
}
h(Z4, "xv");
c(Z4, "getOffsetParent");
const JY = /* @__PURE__ */ c(async function(s) {
  const t = this.getOffsetParent || Z4, e = this.getDimensions, i = await e(s.floating);
  return {
    reference: ZD(s.reference, await t(s.floating), s.strategy),
    floating: {
      x: 0,
      y: 0,
      width: i.width,
      height: i.height
    }
  };
}, "getElementRects");
function BD(s) {
  return Sr(s).direction === "rtl";
}
h(BD, "Px");
c(BD, "isRTL");
const tG = {
  convertOffsetParentRelativeRectToViewportRelativeRect: LD,
  getDocumentElement: Br,
  getClippingRect: FD,
  getOffsetParent: Z4,
  getElementRects: JY,
  getClientRects: zD,
  getDimensions: qD,
  getScale: Oo,
  isElement: kr,
  isRTL: BD
};
function B4(s, t) {
  return s.x === t.x && s.y === t.y && s.width === t.width && s.height === t.height;
}
h(B4, "Cv");
c(B4, "rectsAreEqual");
function ND(s, t) {
  let e = null, i;
  const r = Br(s);
  function n() {
    var o;
    clearTimeout(i), (o = e) == null || o.disconnect(), e = null;
  }
  h(n, "s"), c(n, "cleanup");
  function a(o, l) {
    o === void 0 && (o = !1), l === void 0 && (l = 1), n();
    const d = s.getBoundingClientRect(), {
      left: u,
      top: p,
      width: f,
      height: y
    } = d;
    if (o || t(), !f || !y)
      return;
    const g = $v(p), O = $v(r.clientWidth - (u + f)), k = $v(r.clientHeight - (p + y)), $ = $v(u), T = {
      rootMargin: -g + "px " + -O + "px " + -k + "px " + -$ + "px",
      threshold: vo(0, Q0(1, l)) || 1
    };
    let _ = !0;
    function D(A) {
      const z = A[0].intersectionRatio;
      if (z !== l) {
        if (!_)
          return a();
        z ? a(!1, z) : i = setTimeout(() => {
          a(!1, 1e-7);
        }, 1e3);
      }
      z === 1 && !B4(d, s.getBoundingClientRect()) && a(), _ = !1;
    }
    h(D, "I"), c(D, "handleObserve");
    try {
      e = new IntersectionObserver(D, {
        ...T,
        // Handle <iframe>s
        root: r.ownerDocument
      });
    } catch {
      e = new IntersectionObserver(D, T);
    }
    e.observe(s);
  }
  return h(a, "o"), c(a, "refresh"), a(!0), n;
}
h(ND, "Sx");
c(ND, "observeMove");
function N4(s, t, e, i) {
  i === void 0 && (i = {});
  const {
    ancestorScroll: r = !0,
    ancestorResize: n = !0,
    elementResize: a = typeof ResizeObserver == "function",
    layoutShift: o = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = i, d = Nb(s), u = r || n ? [...d ? xy(d) : [], ...xy(t)] : [];
  u.forEach(($) => {
    r && $.addEventListener("scroll", e, {
      passive: !0
    }), n && $.addEventListener("resize", e);
  });
  const p = d && o ? ND(d, e) : null;
  let f = -1, y = null;
  a && (y = new ResizeObserver(($) => {
    let [T] = $;
    T && T.target === d && y && (y.unobserve(t), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var _;
      (_ = y) == null || _.observe(t);
    })), e();
  }), d && !l && y.observe(d), y.observe(t));
  let g, O = l ? Oa(s) : null;
  l && k();
  function k() {
    const $ = Oa(s);
    O && !B4(O, $) && e(), O = $, g = requestAnimationFrame(k);
  }
  return h(k, "A"), c(k, "frameLoop"), e(), () => {
    var $;
    u.forEach((T) => {
      r && T.removeEventListener("scroll", e), n && T.removeEventListener("resize", e);
    }), p?.(), ($ = y) == null || $.disconnect(), y = null, l && cancelAnimationFrame(g);
  };
}
h(N4, "$v");
c(N4, "autoUpdate");
const XD = qY, jD = ZY, UD = WY, HD = /* @__PURE__ */ c((s, t, e) => {
  const i = /* @__PURE__ */ new Map(), r = {
    platform: tG,
    ...e
  }, n = {
    ...r.platform,
    _c: i
  };
  return VY(s, t, {
    ...r,
    platform: n
  });
}, "computePosition"), Xb = it`[part~=wy-dropdown-menu]{width:max-content;position:absolute;z-index:1000;min-width:calc(10*var(--wy-size, 1rem));border:none;padding:0;--wy-component-background-color: var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);font-size:var(--wy-font-size, var(--wy-size, 1em));text-align:left;background-clip:padding-box;border-radius:var(--wy-dropdown-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));box-shadow:var(--wy-dropdown-shadow, var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12)));overflow:hidden}[part~=wy-dropdown-menu]:not([popover]){display:block}[part~=wy-dropdown-item]{background-color:#0000;color:var(--wy-component-color, var(--wy-on-surface, var(--wy-on-surface-light, #181c20)));width:100%;min-height:calc(2.5*var(--wy-size, 1rem));padding:var(--wy-dropdown-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-dropdown-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));clear:both;font-family:var(--wy-font-family, unset),inherit;font-size:inherit;font-weight:var(--wy-font-weight, unset);line-height:1;text-align:inherit;text-decoration:none;white-space:nowrap;border:0;gap:var(--wy-dropdown-gap, var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));cursor:pointer;display:flex;align-items:center}[part~=wy-dropdown-item]:hover,[part~=wy-dropdown-item]:focus{--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));color:var(--wy-component-color);background-color:var(--wy-component-background-color);text-decoration:none}[part~=wy-dropdown-item][part~=wy-active],[part~=wy-dropdown-item]:active{--wy-component-color: var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73));--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));color:var(--wy-component-color);background-color:var(--wy-component-background-color);text-decoration:none}[part~=wy-dropdown-item][part~=wy-disabled],[part~=wy-dropdown-item]:disabled{color:var(--wy-component-color);background-color:var(--wy-component-background-color);pointer-events:none;opacity:var(--wy-opacity-disabled, 38%)}[part~=wy-dropdown-item]>img,[part~=wy-dropdown-item]>wy-icon{margin-right:calc(.5*var(--wy-size, 1rem));color:inherit}[part~=wy-dropdown-item]:active>wy-icon{color:inherit}[part~=wy-dropdown-item][part~=wy-dropdown-option] wy-icon{visibility:hidden}[part~=wy-dropdown-item][part~=wy-dropdown-option][part~=wy-selected] wy-icon{visibility:visible}[part~=wy-dropdown-divider]{height:0;margin:0;overflow:hidden;border:none;border-top:var(--wy-dropdown-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}`;
var eG = Object.defineProperty, iG = Object.getOwnPropertyDescriptor, $i = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? iG(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && eG(t, e, r), r;
}, "__decorateClass$13"), X$, _f;
let lr = (X$ = (_f = class extends wt {
  constructor() {
    super(), this.exportParts = new rt(this), this.directionX = "right", this.directionY = "down", this.icon = "dots-vertical", this.small = !1, this.disabled = !1, this._placement = "bottom-start", this.showMenu = !1, this.buttonRef = $t(), this.menuRef = $t(), this._documentClickHandler = (t) => {
      this.showMenu && (t.preventDefault(), this.menuRef.value?.popover || (this.showMenu = !1));
    }, this.addEventListener("click", (t) => {
      t.preventDefault();
    });
  }
  handleClose(t) {
    (t.type === "toggle" && t.newState === "closed" || t.type === "click") && (this.showMenu = !1, this.dispatchEvent(new CustomEvent("close")));
  }
  handleClickToggle(t) {
    t.stopPropagation(), this.showMenu = this.disabled ? !1 : !this.showMenu;
  }
  willUpdate(t) {
    if (super.willUpdate(t), (t.has("disabled") || t.has("showMenu")) && this.disabled && this.showMenu && (this.showMenu = !1), (t.has("directionX") || t.has("directionY")) && (this._placement = this.directionX === "right" && this.directionY === "down" ? "bottom-start" : this.directionX === "left" && this.directionY === "down" ? "bottom-end" : this.directionX === "right" && this.directionY === "up" ? "top-start" : "top-end"), t.has("showMenu") && (this.showMenu && !this.computePositionCleanup && this.buttonRef.value && this.menuRef.value ? this.computePositionCleanup = N4(this.buttonRef.value, this.menuRef.value, () => {
      if (this.buttonRef.value && this.menuRef.value) {
        const e = !this.menuRef.value.popover, i = e || !a8(this.buttonRef.value);
        HD(this.buttonRef.value, this.menuRef.value, {
          placement: this._placement,
          strategy: e ? "fixed" : "absolute",
          middleware: [
            UD(),
            XD(({ placement: r }) => r.includes("top") ? 9 : 13),
            jD({ mainAxis: !0, crossAxis: !0, padding: 4, altBoundary: i })
          ]
        }).then(({ x: r, y: n }) => {
          this.menuRef.value && Object.assign(this.menuRef.value.style, {
            marginLeft: `${r}px`,
            marginTop: `${n}px`,
            top: 0,
            left: 0,
            position: e ? "fixed" : void 0,
            zIndex: e ? 1075 : void 0
          });
        });
      }
    }) : !this.showMenu && this.computePositionCleanup && (this.computePositionCleanup?.(), this.computePositionCleanup = void 0)), this.showMenu) {
      requestAnimationFrame(() => {
        document.addEventListener("click", this._documentClickHandler, { once: !0, capture: !0 });
      });
      try {
        this.menuRef.value?.showPopover();
      } catch {
      }
    } else
      try {
        this.menuRef.value?.hidePopover();
      } catch {
      }
  }
  render() {
    const t = this._slotButton.length === 0 || this._slotButton.length === 1 && this._slotButton[0] instanceof ge;
    return v`
      <span part="wy-dropdown">
        <span
          ${ht(this.buttonRef)}
          part="wy-dropdown-button-container"
          @click=${(e) => this.handleClickToggle(e)}
          @keydown=${Ze}
          @keyup=${bi}
        >
          <wy-button
            part="wy-dropdown-button"
            .kind=${t ? "icon" : void 0}
            ?small=${this.small}
            title=${this.title}
            ?active=${this.showMenu}
            ?disabled=${this.disabled}
          >
            <slot name="button-content" @slotchange=${() => this.requestUpdate()}>
              <wy-icon part="wy-dropdown-button-icon" name=${this.icon}></wy-icon>
            </slot>
          </wy-button>
        </span>

        <div
          ${ht(this.menuRef)}
          part="wy-dropdown-menu"
          @click=${(e) => this.handleClickToggle(e)}
          @keyup=${Wb}
          ?hidden=${gO() && !this.showMenu}
          popover=${St(gO() ? void 0 : "auto")}
        >
          <slot></slot>
        </div>
      </span>
    `;
  }
  firstUpdated(t) {
    this.menuRef.value?.addEventListener(
      this.menuRef.value.popover ? "toggle" : "click",
      (e) => this.handleClose(e)
    );
  }
  disconnectedCallback() {
    this.computePositionCleanup?.(), super.disconnectedCallback();
  }
}, h(_f, "Ys"), _f), c(X$, "WyDropdown"), X$);
lr.styles = [pe, Xb];
$i([
  b()
], lr.prototype, "directionX", 2);
$i([
  b()
], lr.prototype, "directionY", 2);
$i([
  b()
], lr.prototype, "icon", 2);
$i([
  b({ type: Boolean })
], lr.prototype, "small", 2);
$i([
  b({ type: Boolean })
], lr.prototype, "disabled", 2);
$i([
  N()
], lr.prototype, "_placement", 2);
$i([
  N()
], lr.prototype, "showMenu", 2);
$i([
  Dl({ slot: "button-content" })
], lr.prototype, "_slotButton", 2);
$i([
  N()
], lr.prototype, "computePositionCleanup", 2);
lr = $i([
  Y("wy-dropdown")
], lr);
var j$, Lf;
let i1 = (j$ = (Lf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.active = !1;
  }
  render() {
    return v`<div part="wy-dropdown-item ${gt({ "wy-active": this.active })}" tabindex="0"><slot></slot></div>`;
  }
}, h(Lf, "Xs"), Lf), c(j$, "WyDropdownItem"), j$);
i1.styles = [pe, Xb, ft];
$i([
  b({ type: Boolean })
], i1.prototype, "active", 2);
i1 = $i([
  Y("wy-dropdown-item")
], i1);
var U$, zf;
let ky = (U$ = (zf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.active = !1, this.selected = !1;
  }
  render() {
    const t = {
      visibility: this.selected ? null : "hidden"
    };
    return v`
      <div
        part="wy-dropdown-item wy-dropdown-option ${gt({
      "wy-active": this.active,
      "wy-selected": this.selected
    })}"
        tabindex="0"
      >
        <slot name="icon" style=${Jw(t)}
          ><wy-icon part="wy-dropdown-option-icon" name="check"></wy-icon
        ></slot>
        <slot></slot>
      </div>
    `;
  }
}, h(zf, "Js"), zf), c(U$, "WyDropdownOption"), U$);
ky.styles = [pe, Xb, ft];
$i([
  b({ type: Boolean })
], ky.prototype, "active", 2);
$i([
  b({ type: Boolean })
], ky.prototype, "selected", 2);
ky = $i([
  Y("wy-dropdown-option")
], ky);
var H$, If;
let R0 = (H$ = (If = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this);
  }
  render() {
    return v`<hr part="wy-dropdown-divider" />`;
  }
}, h(If, "to"), If), c(H$, "WyDropdownDivider"), H$);
R0.styles = [pe, Xb, ft];
R0 = $i([
  Y("wy-dropdown-divider")
], R0);
const YD = it`[part~=wy-placeholder]{cursor:wait;color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));background:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));opacity:.5;animation:wy-placeholder-glow 2s ease-in-out infinite;line-height:1.45}@keyframes wy-placeholder-glow{50%{opacity:.2}}`;
var rG = Object.defineProperty, sG = Object.getOwnPropertyDescriptor, GD = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? sG(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && rG(t, e, r), r;
}, "__decorateClass$12"), Y$, Df;
let r1 = (Y$ = (Df = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.text = "";
  }
  render() {
    const t = this.text.trim();
    return v`
      <div part="wy-skeleton">
        ${t.length ? t.split(/(\n+)/).map((e) => {
      const i = e.split(/(\s+)/);
      return v`
                <div part="wy-placeholder-line">
                  ${i.map((r) => v` <span part="wy-placeholder">${r}</span> `)}
                </div>
              `;
    }) : C}
      </div>
    `;
  }
}, h(Df, "eo"), Df), c(Y$, "WySkeleton"), Y$);
r1.styles = [YD, ft];
GD([
  b()
], r1.prototype, "text", 2);
r1 = GD([
  Y("wy-skeleton")
], r1);
function X4(s) {
  const t = [s];
  for (; s && s.parent; )
    s = s.parent, t.push(s);
  return t;
}
h(X4, "Ev");
c(X4, "getEntityChain");
function j4(s, t, e) {
  return s.type === t && (!e || s.id === e.id);
}
h(j4, "Rv");
c(j4, "isEntityMatch");
function D1(s, t, e) {
  return X4(s).some((i) => i && j4(i, t, e));
}
h(D1, "zh");
c(D1, "isEntityChainMatch");
function U4(s, t, e) {
  return X4(s).find((i) => i && j4(i, t, e));
}
h(U4, "Tv");
c(U4, "getEntityChainMatch");
function H4(s, t, e, i) {
  const r = U4(s, i);
  return r && r.parent ? D1(r.parent, t, e) : !1;
}
h(H4, "Lv");
c(H4, "hasEntityChildType");
async function Y4(s, t, e) {
  let i;
  if (t && e?.link?.app?.id) {
    const n = await t.fetch(`/api/apps/${e.link.app.id}`);
    n.ok && (i = (await n.json()).metadata);
  }
  const r = new CustomEvent("wy-link", {
    bubbles: !0,
    composed: !0,
    cancelable: !0,
    detail: {
      link: e.link ? {
        ...e?.link,
        // HACK: pass along the agent uid so uikit can match the correct agent chat     
        agent: e.actor.is_agent && e.link?.app?.type && b0.has(e.link.app.type) ? e.actor.uid : void 0
      } : void 0,
      metadata: e.metadata,
      app_type: e?.link?.app?.type && dU.get(e.link.app.type) || Nn,
      source_name: i?.source_name,
      source_url: i?.source_url,
      source_data: i?.source_data
    }
  });
  return s.dispatchEvent(r);
}
h(Y4, "Ov");
c(Y4, "dispatchLinkEvent");
function G4(s) {
  const t = s.args;
  switch (s.template) {
    case "**{0}** added *{1}* to **{2}**": {
      const [e, i, r] = t;
      return {
        title: P(lt`${e} added ${i} to ${r}`),
        titleHtml: P(v`<strong>${e}</strong> added <em>${i}</em> to <strong>${r}</strong>`)
      };
    }
    case "**{0}** edited *{1}*": {
      const [e, i] = t;
      return {
        title: P(lt`${e} edited ${i}`),
        titleHtml: P(v`<strong>${e}</strong> edited <em>${i}</em>`)
      };
    }
    case '**{0}** commented on *{1}*: "{2}"': {
      const [e, i, r] = t;
      return {
        title: P(lt`${e} commented on ${i}`),
        titleHtml: P(v`<strong>${e}</strong> commented on <em>${i}</em>`),
        detail: r
      };
    }
    case '**{0}** commented on **{1}**: "{2}"': {
      const [e, i, r] = t;
      return {
        title: P(lt`${e} commented on ${i}`),
        titleHtml: P(v`<strong>${e}</strong> commented on <strong>${i}</strong>`),
        detail: r
      };
    }
    case '**{0}** replied to your post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(lt`${e} replied to your post`),
        titleHtml: P(v`<strong>${e}</strong> replied to your post`),
        detail: i
      };
    }
    case '**{0}** replied to a post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(lt`${e} replied to a post`),
        titleHtml: P(v`<strong>${e}</strong> replied to a post`),
        detail: i
      };
    }
    case '**{0}** mentioned you in a comment: "{1}"': {
      const [e, i] = t;
      return {
        title: P(lt`${e} mentioned you in a comment`),
        titleHtml: P(v`<strong>${e}</strong> mentioned you in a comment`),
        detail: i
      };
    }
    case '**{0}** posted in **{1}**: "{2}"': {
      const [e, i, r] = t;
      return {
        title: P(lt`${e} posted in ${i}`),
        titleHtml: P(v`<strong>${e}</strong> posted in <strong>${i}</strong>`),
        detail: r
      };
    }
    case '**{0}** mentioned you in a post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(lt`${e} mentioned you in a post`),
        titleHtml: P(v`<strong>${e}</strong> mentioned you in a post`),
        detail: i
      };
    }
    case 'New message from **{0}**: "{1}"': {
      const [e, i] = t;
      return {
        title: P(lt`New message from ${e}`),
        titleHtml: P(v`New message from <strong>${e}</strong>`),
        detail: i
      };
    }
    case '**{0}** sent a message in **{1}**: "{2}"': {
      const [e, i, r] = t;
      return {
        title: P(lt`${e} sent a message in ${i}`),
        titleHtml: P(v`<strong>${e}</strong> sent a message in <strong>${i}</strong>`),
        detail: r
      };
    }
    case '**{0}** mentioned you in a message: "{1}"': {
      const [e, i] = t;
      return {
        title: P(lt`${e} mentioned you in a message`),
        titleHtml: P(v`<strong>${e}</strong> mentioned you in a message`),
        detail: i
      };
    }
    case '**{0}** edited a post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(lt`${e} edited a post`),
        titleHtml: P(v`<strong>${e}</strong> edited a post`),
        detail: i
      };
    }
    case "**{0}** liked *{1}*": {
      const [e, i] = t;
      return {
        title: P(lt`${e} liked ${i}`),
        titleHtml: P(v`<strong>${e}</strong> liked <em>${i}</em>`)
      };
    }
    case "**{0}** reacted {2} to *{1}*": {
      const [e, i, r] = t;
      return {
        title: P(lt`${e} reacted ${i} to ${r}`),
        titleHtml: P(v`<strong>${e}</strong> reacted ${i} to <em>${r}</em>`)
      };
    }
    case '**{0}** liked your comment: "{1}"': {
      const [e, i] = t;
      return {
        title: P(lt`${e} liked your comment`),
        titleHtml: P(v`<strong>${e}</strong> liked your comment`),
        detail: i
      };
    }
    case '**{0}** reacted {1} to your comment: "{2}"': {
      const [e, i, r] = t;
      return {
        title: P(lt`${e} reacted ${i} to your comment`),
        titleHtml: P(v`<strong>${e}</strong> reacted ${i} to your comment`),
        detail: r
      };
    }
    case '**{0}** liked your message: "{1}"': {
      const [e, i] = t;
      return {
        title: P(lt`${e} liked your message`),
        titleHtml: P(v`<strong>${e}</strong> liked your message`),
        detail: i
      };
    }
    case '**{0}** reacted {1} to your message: "{2}"': {
      const [e, i, r] = t;
      return {
        title: P(lt`${e} reacted ${i} to your message`),
        titleHtml: P(v`<strong>${e}</strong> reacted ${i} to your message`),
        detail: r
      };
    }
    case '**{0}** liked your post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(lt`${e} liked your post`),
        titleHtml: P(v`<strong>${e}</strong> liked your post`),
        detail: i
      };
    }
    case '**{0}** reacted {1} to your post: "{2}"': {
      const [e, i, r] = t;
      return {
        title: P(lt`${e} reacted ${i} to your post`),
        titleHtml: P(v`<strong>${e}</strong> reacted ${i} to your post`),
        detail: r
      };
    }
    case "**{0}** voted on your poll": {
      const [e] = t;
      return {
        title: P(lt`${e} voted on your poll`),
        titleHtml: P(v`<strong>${e}</strong> voted on your poll`)
      };
    }
    case "**{0}** and **{1}** voted on your poll": {
      const [e, i] = t;
      return {
        title: P(lt`${e} and ${i} voted on your poll`),
        titleHtml: P(v`<strong>${e}</strong> and <strong>${i}</strong> voted on your poll`)
      };
    }
    case "**{0}**, **{1}** and **{2}** voted on your poll": {
      const [e, i, r] = t;
      return {
        title: P(lt`${e}, ${i} and ${r} voted on your poll`),
        titleHtml: P(
          v`<strong>${e}</strong>, <strong>${i}</strong> and <strong>${r}</strong> voted on your poll`
        )
      };
    }
    case "**{0}** and {1} others voted on your poll": {
      const [e, i] = t;
      return {
        title: P(lt`${e} and ${i} others voted on your poll`),
        titleHtml: P(v`<strong>${e}</strong> and ${i} others voted on your poll`)
      };
    }
    default:
      return {
        title: s.plain,
        titleHtml: v`${gl(s.html)}`
      };
  }
}
h(G4, "zv");
c(G4, "getNotificationText");
const K4 = it`[part~=wy-code] pre,.wy-code pre,[part~=wy-content] pre{text-wrap:pretty}[part~=wy-code] .code,[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code .code,.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] .code,[part~=wy-content] code[class*=language-],[part~=wy-content] pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;word-wrap:break-word;line-height:1.25;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}@media print{[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] code[class*=language-],[part~=wy-content] pre[class*=language-]{text-shadow:none}}[part~=wy-code] pre[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}[part~=wy-code] :not(pre)>code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code :not(pre)>code[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] :not(pre)>code[class*=language-],[part~=wy-content] pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));background:var(--wy-background, var(--wy-background-light, #f7f9ff))}[part~=wy-code] :not(pre)>code[class*=language-],.wy-code :not(pre)>code[class*=language-],[part~=wy-content] :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}[part~=wy-code] .token.variable,.wy-code .token.variable,[part~=wy-content] .token.variable{color:var(--wy-code-variable, var(--wy-code-variable-light, #001080))}[part~=wy-code] .token.operator,.wy-code .token.operator,[part~=wy-content] .token.operator{color:var(--wy-code-operator, var(--wy-code-operator-light, #000000))}[part~=wy-code] .token.prolog,.wy-code .token.prolog,[part~=wy-content] .token.prolog{color:var(--wy-code-prolog, var(--wy-code-prolog-light, #000080))}[part~=wy-code] .token.comment,.wy-code .token.comment,[part~=wy-content] .token.comment{color:var(--wy-code-comment, var(--wy-code-comment-light, #008000))}[part~=wy-code] .token.builtin,.wy-code .token.builtin,[part~=wy-content] .token.builtin{color:var(--wy-code-builtin, var(--wy-code-builtin-light, #0070C1))}[part~=wy-code] .token.number,.wy-code .token.number,[part~=wy-content] .token.number{color:var(--wy-code-number, var(--wy-code-number-light, #098658))}[part~=wy-code] .token.inserted,.wy-code .token.inserted,[part~=wy-content] .token.inserted{color:var(--wy-code-inserted, var(--wy-code-inserted-light, #098658))}[part~=wy-code] .token.constant,.wy-code .token.constant,[part~=wy-content] .token.constant{color:var(--wy-code-constant, var(--wy-code-constant-light, #811F3F))}[part~=wy-code] .token.hexcode,.wy-code .token.hexcode,[part~=wy-content] .token.hexcode{color:var(--wy-code-hexcode, var(--wy-code-hexcode-light, #811F3F))}[part~=wy-code] .token.regex,.wy-code .token.regex,[part~=wy-content] .token.regex{color:var(--wy-code-regex, var(--wy-code-regex-light, #811F3F))}[part~=wy-code] .token.char,.wy-code .token.char,[part~=wy-content] .token.char{color:var(--wy-code-char, var(--wy-code-char-light, #811F3F))}[part~=wy-code] .token.tag,.wy-code .token.tag,[part~=wy-content] .token.tag{color:var(--wy-code-tag, var(--wy-code-tag-light, #800000))}[part~=wy-code] .token.attr-name,.wy-code .token.attr-name,[part~=wy-content] .token.attr-name{color:var(--wy-code-attr-name, var(--wy-code-attr-name-light, #E50000))}[part~=wy-code] .token.selector,.wy-code .token.selector,[part~=wy-content] .token.selector{color:var(--wy-code-selector, var(--wy-code-selector-light, #E50000))}[part~=wy-code] .token.property,.wy-code .token.property,[part~=wy-content] .token.property{color:var(--wy-code-property, var(--wy-code-property-light, #E50000))}[part~=wy-code] .token.deleted,.wy-code .token.deleted,[part~=wy-content] .token.deleted{color:var(--wy-code-deleted, var(--wy-code-deleted-light, #A31515))}[part~=wy-code] .token.string,.wy-code .token.string,[part~=wy-content] .token.string{color:var(--wy-code-string, var(--wy-code-string-light, #A31515))}[part~=wy-code] .token.changed,.wy-code .token.changed,[part~=wy-content] .token.changed{color:var(--wy-code-changed, var(--wy-code-changed-light, #0451A5))}[part~=wy-code] .token.punctuation,.wy-code .token.punctuation,[part~=wy-content] .token.punctuation{color:var(--wy-code-punctuation, var(--wy-code-punctuation-light, #000000))}[part~=wy-code] .token.function,.wy-code .token.function,[part~=wy-content] .token.function{color:var(--wy-code-function, var(--wy-code-function-light, #0000FF))}[part~=wy-code] .token.keyword,.wy-code .token.keyword,[part~=wy-content] .token.keyword{color:var(--wy-code-keyword, var(--wy-code-keyword-light, #AF00DB))}[part~=wy-code] .token.class-name,.wy-code .token.class-name,[part~=wy-content] .token.class-name{color:var(--wy-code-class-name, var(--wy-code-class-name-light, #267F99))}[part~=wy-code] .token.important,[part~=wy-code] .token.bold,.wy-code .token.important,.wy-code .token.bold,[part~=wy-content] .token.important,[part~=wy-content] .token.bold{font-weight:700}[part~=wy-code] .token.italic,.wy-code .token.italic,[part~=wy-content] .token.italic{font-style:italic}[part~=wy-content]{text-align:initial;font-size:var(--wy-font-size, var(--wy-size, 1em));overflow-wrap:break-word;min-width:0}[part~=wy-content]:empty{display:none}[part~=wy-content]>:first-child{margin-top:0}[part~=wy-content]>:last-child{margin-bottom:0}[part~=wy-content] a{text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-light, #2f628c))}[part~=wy-content] a:hover{text-decoration:var(--wy-link-hover-decoration, var(--wy-link-decoration, none))}[part~=wy-content] a:where(:not([href]):not([class])),[part~=wy-content] a:where(:not([href]):not([class])):hover{text-decoration:none}[part~=wy-content] p{margin-top:0;margin-bottom:calc(1*var(--wy-size, 1rem))}[part~=wy-content] b,[part~=wy-content] strong{font-weight:var(--wy-font-weight-bold, 600)}[part~=wy-content] blockquote{border-left:calc(2*var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));margin:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) 0;padding-left:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-content] blockquote>p{margin:0}[part~=wy-content] hr{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));border-width:var(--wy-border, 1px) 0 0 0;border-style:solid}[part~=wy-content] pre,[part~=wy-content] code{font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-content] :not(pre)>code{overflow-wrap:inherit}[part~=wy-content] pre>code{font-size:var(--wy-font-size, var(--wy-size, 1em));white-space:pre-wrap}[part~=wy-content] h1,[part~=wy-content] h2,[part~=wy-content] h3,[part~=wy-content] h4,[part~=wy-content] h5,[part~=wy-content] h6{font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.5))}[part~=wy-content] h1{font-size:var(--wy-h1-font-size, var(--wy-font-size-xxl, 1.5em));font-weight:var(--wy-h1-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h1-margin, 0 0 var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-content] h2{font-size:var(--wy-h2-font-size, var(--wy-font-size-xl, 1.25em));font-weight:var(--wy-h2-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h2-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content] h3{font-size:var(--wy-h3-font-size, var(--wy-font-size-lg, 1.125em));font-weight:var(--wy-h3-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h3-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content] h4{font-size:var(--wy-h4-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-h4-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h4-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 0)}[part~=wy-content] h5{font-size:var(--wy-h5-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-h5-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h5-margin, 0)}[part~=wy-content] h6{font-size:var(--wy-h6-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-h6-font-weight, inherit);margin:var(--wy-h6-margin, 0)}[part~=wy-content] table{display:block;width:100%;max-width:-moz-max-content;max-width:max-content;overflow-x:auto;white-space:nowrap;border-collapse:separate;border-spacing:0 0;margin-bottom:var(--wy-size, 1rem)}[part~=wy-content] table th,[part~=wy-content] table td{padding:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));border-color:inherit;border-style:solid}[part~=wy-content] table th{text-align:inherit;text-align:-webkit-match-parent;border-width:var(--wy-border, 1px) 0 var(--wy-border, 1px) var(--wy-border, 1px);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600))}[part~=wy-content] table th:first-child{border-top-left-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] table th:last-child{border-top-right-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-right-width:var(--wy-border, 1px)}[part~=wy-content] table td{border-width:0 0 var(--wy-border, 1px) var(--wy-border, 1px)}[part~=wy-content] table td:last-child{border-right-width:var(--wy-border, 1px)}[part~=wy-content] table tr:last-child td:first-child{border-bottom-left-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] table tr:last-child td:last-child{border-bottom-right-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] table>tbody{vertical-align:inherit}[part~=wy-content] table>thead{vertical-align:bottom}[part~=wy-content] img{max-width:100%;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin-block:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] ol{list-style-type:decimal}[part~=wy-content] ul{list-style-type:disc}[part~=wy-content] li{margin:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) 0}[part~=wy-content] ol,[part~=wy-content] ul{margin:var(--wy-size, 1rem) 0;padding:0 0 0 1.625em}[part~=wy-content] ol>li,[part~=wy-content] ul>li{padding-left:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content] ol>li>:first-child,[part~=wy-content] ul>li>:first-child{margin-bottom:0;margin-top:0}[part~=wy-content] ol>li>:last-child,[part~=wy-content] ul>li>:last-child{margin-bottom:0}[part~=wy-content] .wy-hashtag{color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-content] .wy-mention{font-weight:var(--wy-font-weight-bold, 600)}[part~=wy-content] .wy-mention:before{content:\"@\"}[part~=wy-content-emoji] .wy-emoji{font-size:3em}`;
function jb(s) {
  const t = s;
  t && (t.complete && t.naturalHeight !== 0 ? !t.classList.contains("wy-loading") && !t.part.contains("wy-loading") ? (t.classList.add("wy-loading", "wy-loaded"), t.part.add("wy-loading", "wy-loaded")) : t.decode().then(() => {
    t.classList.add("wy-loaded"), t.part.add("wy-loaded");
  }) : (t.classList.add("wy-loading"), t.part.add("wy-loading")));
}
h(jb, "Ry");
c(jb, "checkImageLoad");
function Ub(s) {
  const t = s.target;
  t.tagName === "IMG" && (t.classList.contains("wy-loading") || t.part.contains("wy-loading")) && !t.classList.contains("wy-loaded") && !t.part.contains("wy-loaded") && (t.classList.add("wy-loaded"), t.part.add("wy-loaded"));
}
h(Ub, "Ty");
c(Ub, "imageLoaded");
const nG = it`[part~=wy-image]{padding:0;width:50%;position:relative;flex:auto;background-color:inherit;background-clip:content-box;max-height:var(--wy-image-max-size, calc(32 * var(--wy-size, 1rem)))}[part~=wy-image-filled]{position:relative;background-size:100%,100% 100%;background-position:center;background-clip:content-box;clip-path:content-box;align-items:center;justify-content:center}[part~=wy-image-filled]:after{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;z-index:1;-webkit-backdrop-filter:blur(32px);backdrop-filter:blur(32px);background-color:var(--wy-shade, var(--wy-shade-light, rgba(0, 0, 0, .3)))}[part~=wy-image-full-width]{flex-basis:100%!important}[part~=wy-image-grid]{display:flex;flex-wrap:wrap;justify-content:space-evenly;position:relative;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));overflow:hidden;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-image-grid-outer]{border-radius:0}[part~=wy-image-area]{display:flex;height:100%;cursor:pointer;align-items:center}[part~=wy-image-content]{position:absolute;height:auto;max-height:100%;width:100%;object-fit:contain;z-index:2}[part~=wy-image-content][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-image-content][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-image-content][part~=wy-loading][part~=wy-loaded]~[part~=wy-image-preview]{transition-delay:.15s;opacity:0}[part~=wy-image-icon]{object-fit:scale-down;object-position:center center}[part~=wy-image-grid-more]{position:absolute;z-index:3;line-height:100%;color:var(--wy-white, #ffffff);inset:0;display:flex;align-items:center;justify-content:center;font-size:calc(1.5*var(--wy-size, 1rem));background:rgba(0,0,0,var(--wy-opacity-disabled, 38%))}`;
var aG = Object.defineProperty, oG = Object.getOwnPropertyDescriptor, Hb = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? oG(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && aG(t, e, r), r;
}, "__decorateClass$11");
const _9 = 128;
var G$, Vf;
let bl = (G$ = (Vf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.images = [], this.limit = 3, this.outer = !1;
  }
  /**
   * Dispatch a `file-open` event.
   *
   * @internal
   * @param e - Event that will be prevented.
   * @param file - The file to open.
   */
  dispatchFileOpen(t, e) {
    if (g1(t)) {
      t.stopPropagation();
      return;
    }
    if (t.preventDefault(), !e.is_trashed) {
      const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
      this.dispatchEvent(i);
    }
  }
  render() {
    const t = this.images.length > this.limit ? this.images.length - this.limit : 0, e = this.images.slice(0, this.limit);
    return v`
      <div
        part=${gt({
      "wy-image-grid": !0,
      "wy-image-grid-outer": this.outer
    })}
      >
        ${e.map((i, r) => {
      const n = !i.width || i.width <= _9 || !i.height || i.height <= _9, a = i.width && i.height ? i.width / i.height : 1, o = 64, l = a.toPrecision(5), d = (a * o).toPrecision(5) + "px", u = n ? o + "px" : (100 / a).toPrecision(5) + "%", p = i.width + "px", f = this.images.length !== 2 && r === 0, y = dr(i.name), g = y === ".gif" || y === ".svg" ? i.download_url : i.preview_url;
      return g ? v`
                <a
                  href="${i.download_url ?? "#"}"
                  @click=${(O) => {
        !O.defaultPrevented && this.dispatchFileOpen(O, i);
      }}
                  part=${gt({
        "wy-image": !0,
        "wy-image-filled": !0,
        "wy-image-full-width": f
      })}
                  style=${Jw({
        flexBasis: d,
        flexGrow: l,
        flexShrink: l,
        width: p,
        backgroundImage: `linear-gradient(var(--wy-shade-invert, rgba(255,255,255,0.15))), url(${g}), linear-gradient(var(--wy-shade-opaque, white));`
      })}
                >
                  <div part="wy-image-area" style=${Jw({ paddingBottom: u })}>
                    <img
                      part=${gt({ "wy-image-content": !0, "wy-image-icon": n })}
                      src=${g}
                      ${ht(jb)}
                      @load=${Ub}
                      alt=""
                      loading="lazy"
                      decoding="async"
                    />
                    ${r === e.length - 1 && t ? v`<span part="wy-image-grid-more">+${t}</span>` : ""}
                  </div>
                </a>
              ` : C;
    })}
      </div>
    `;
  }
}, h(Vf, "io"), Vf), c(G$, "WyImageGrid"), G$);
bl.styles = [nG, ft];
Hb([
  b({ attribute: !1 })
], bl.prototype, "images", 2);
Hb([
  b({ type: Number })
], bl.prototype, "limit", 2);
Hb([
  b({ type: Boolean, reflect: !0 })
], bl.prototype, "outer", 2);
bl = Hb([
  Y("wy-image-grid")
], bl);
var lG = Object.defineProperty, cG = Object.getOwnPropertyDescriptor, V1 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? cG(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && lG(t, e, r), r;
}, "__decorateClass$10"), K$, Wf;
let s1 = (K$ = (Wf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this);
  }
  /**
   * Triggers file-open event.
   *
   * @param e
   * @param file
   * @returns
   */
  dispatchFileOpen(t, e) {
    t.preventDefault();
    const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
    return this.dispatchEvent(i);
  }
  render() {
    const t = this.file.size && this.file.size > 0 ? Qb(this.file.size) : null, e = dr(this.file.name), { icon: i } = wn(this.file.name), r = Mb(this.file.name), n = Fy(this.file.provider);
    return v`    
      <wy-item
        @click=${(a) => {
      !a.defaultPrevented && !this.file.is_trashed && this.dispatchFileOpen(a, this.file);
    }}
        size="md"
        title=${this.file.name}
        url=${St(this.file.download_url ?? this.file.external_url)}
        interactive
      >
        <wy-icon slot="image" name=${i} .overlayName=${n} size="48" kind=${r} ext=${e}></wy-icon>
        <span slot="title">${this.file.name}</span>
        ${t ? v`<span slot="text" title="${t}">${t}</span>` : C}
      </wy-item>
    `;
  }
}, h(Wf, "ro"), Wf), c(K$, "WyAttachment"), K$);
s1.styles = [qb, ft];
V1([
  b({ attribute: !1 })
], s1.prototype, "file", 2);
s1 = V1([
  Y("wy-attachment")
], s1);
var J$, Ff;
let Sy = (J$ = (Ff = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.files = [], this.filled = !1;
  }
  dispatchFileOpen(t) {
    const e = new CustomEvent("file-open", { detail: { fileId: t.id } });
    return this.dispatchEvent(e);
  }
  render() {
    return v`
      <wy-item-list rounded ?filled=${this.filled}>
        ${this.files.map((t) => v`<wy-attachment @file-open=${() => this.dispatchFileOpen(t)} .file=${t}></wy-attachment>`)}
      </wy-item-list>
    `;
  }
}, h(Ff, "no"), Ff), c(J$, "WyAttachmentList"), J$);
Sy.styles = [qb, ft];
V1([
  b({ attribute: !1 })
], Sy.prototype, "files", 2);
V1([
  b({ type: Boolean })
], Sy.prototype, "filled", 2);
Sy = V1([
  Y("wy-attachment-list")
], Sy);
var hG = Object.defineProperty, dG = Object.getOwnPropertyDescriptor, Yb = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? dG(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && hG(t, e, r), r;
}, "__decorateClass$$"), tx, qf;
let n1 = (tx = (qf = class extends Xi {
  constructor() {
    super(...arguments), this.exportParts = new rt(this);
  }
  /**
   * Triggers file-open event.
   * @internal
   */
  dispatchFileOpen(t, e) {
    t.preventDefault();
    const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
    return this.dispatchEvent(i);
  }
  render() {
    const t = this.file.size && this.file.size > 0 ? Qb(this.file.size) : null, e = dr(this.file.name), { icon: i } = wn(this.file.name), r = Mb(this.file.name), n = Fy(this.file.provider), a = `${this.file.name}${t ? ` • ${t}` : ""}`;
    return v`
      <wy-button
        part="wy-annotation"
        @click=${(o) => {
      !o.defaultPrevented && !this.file.is_trashed && this.dispatchFileOpen(o, this.file);
    }}
        kind="filled"
        small
        title=${a}
      >
        <wy-icon
          part="wy-annotation-icon"
          name=${i}
          .overlayName=${n}
          size="24"
          kind=${r}
          ext=${e}
        ></wy-icon>
        <span part="wy-annotation-text">${this.file.name}</span>
      </wy-button>
    `;
  }
}, h(qf, "ao"), qf), c(tx, "WyAnnotation"), tx);
n1.styles = [ft];
Yb([
  b({ type: Object, attribute: !1 })
], n1.prototype, "file", 2);
n1 = Yb([
  Y("wy-annotation")
], n1);
var ex, Zf;
let a1 = (ex = (Zf = class extends Pe {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.files = [];
  }
  render() {
    return this.settings?.annotations === "none" ? C : v`
      <div part="wy-annotations">
        ${this.files.map((t) => v`<wy-annotation .file=${t}></wy-annotation>`)}
      </div>
    `;
  }
}, h(Zf, "so"), Zf), c(ex, "WyAnnotationList"), ex);
a1.styles = [ft];
Yb([
  b({ attribute: !1 })
], a1.prototype, "files", 2);
a1 = Yb([
  Y("wy-annotation-list")
], a1);
function ps(s = "", t = "", e = "", i = !1) {
  if (Se(), s) {
    const r = document.createElement("a");
    i && (/^(data:|blob:)/.test(s) ? r.download = e || "download" : s = s.includes("?d=1") || s.includes("&d=1") ? s : s.includes("?") ? s + "&d=1" : s + "?d=1"), t && (r.target = t), r.href = s, document.body.appendChild(r);
    try {
      r.click();
    } catch {
      if (console.warn("Could not open link normally, trying fallback"), /^(?:blob:|data:)/.test(s))
        console.error(`Could not ${i ? "download" : "open"} ${e}`);
      else
        try {
          window.open(s, t);
        } catch {
          console.error(`Could not ${i ? "download" : "open"} ${e}`);
        }
    }
    document.body.removeChild(r);
  }
}
h(ps, "tr");
c(ps, "openUrl");
function zS(s, t) {
  return new URL(
    s,
    typeof WEAVY_IMPORT_URL == "string" && (!t || !new URL(t).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : t
  );
}
h(zS, "Lf");
c(zS, "environmentUrl");
const KD = it`[part~=wy-embed]{display:flex;flex-direction:column;word-wrap:break-word;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));clip-path:border-box;--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));color:var(--wy-component-color)}[part~=wy-embed-interactive]{background-color:var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));-webkit-user-select:none;user-select:none;cursor:pointer}[part~=wy-embed-interactive]:active,[part~=wy-embed-interactive]:hover,[part~=wy-embed-interactive]:focus{background-color:var(--wy-surface-layer-high, var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039)))}[part~=wy-embed-interactive][part~=wy-disabled],[part~=wy-embed-interactive]:disabled{pointer-events:none;border-left:none;border-right:none;border-bottom:none;border-radius:0;background-color:#0000}[part~=wy-embed-area]{display:flex;justify-content:center;align-items:center}[part~=wy-embed-icon]{width:calc(3*var(--wy-size, 1rem));height:calc(3*var(--wy-size, 1rem));flex:0 0 auto;object-fit:contain}[part~=wy-embed-content]{display:flex;position:relative;padding:0;overflow:hidden;width:100%;flex-direction:column;align-items:center;justify-content:flex-start}[part~=wy-embed-content] iframe,[part~=wy-embed-content] embed,[part~=wy-embed-content] object,[part~=wy-embed-content] video{border:0;width:auto;height:auto;max-height:var(--wy-component-max-size, var(--wy-embed-content-max-size, calc(48 * var(--wy-size, 1rem))))}[part~=wy-embed-photo]{border-top-left-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-top-right-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-left-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-right-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));position:relative;background-size:cover;background-position:center;clip-path:border-box}[part~=wy-embed-photo]:after{border-top-left-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-top-right-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-left-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-right-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));content:\"\";position:absolute;width:100%;height:100%;z-index:1;-webkit-backdrop-filter:blur(32px);backdrop-filter:blur(32px);background-color:var(--wy-shade, var(--wy-shade-light, rgba(0, 0, 0, .3)))}[part~=wy-embed-photo-with-description]{--wy-component-border-bottom-radius: 0}[part~=wy-embed-image]{width:auto;height:auto;object-fit:contain;flex:0 1 auto;min-width:0;min-height:calc(3*var(--wy-size, 1rem));max-height:calc(var(--wy-component-max-size, var(--wy-embed-content-max-size, calc(48 * var(--wy-size, 1rem)))) - var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))*2 - var(--wy-button-line-height, var(--wy-line-height, 1.5))*var(--wy-size, 1rem));z-index:2}[part~=wy-embed-provider]{color:var(--wy-outline, var(--wy-outline-light, #72777f));text-transform:uppercase;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));margin-bottom:calc(.25*var(--wy-size, 1rem))}[part~=wy-embed-provider]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-embed-actions]{display:flex;justify-content:space-between}[part~=wy-embed-select]{display:flex;flex-direction:column;min-height:0;--wy-component-max-size: calc(12 * var(--wy-size, 1rem));--wy-component-background-color: transparent}[part~=wy-embed-select] wy-embed{border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));--wy-component-border-top-radius: 0;min-height:0;display:none}[part~=wy-embed-select] wy-embed:first-of-type{display:block}`;
var uG = Object.defineProperty, pG = Object.getOwnPropertyDescriptor, W1 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? pG(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && uG(t, e, r), r;
}, "__decorateClass$_"), ix, Bf;
let Cy = (ix = (Bf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.disabled = !1, this.embedContentRef = $t();
  }
  /**
   * Dispatch a wy-action event for this embed.
   *
   * @internal
   * @param {ActionType | string} [action=""] - Action to dispatch.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchActionEvent(t = Oi.Default) {
    const e = new CustomEvent("wy-action", {
      detail: {
        action: t,
        embed: this.embed
      },
      bubbles: !0,
      composed: !0,
      cancelable: !0
    });
    return this.dispatchEvent(e);
  }
  render() {
    const t = this.embed.actions ? [...this.embed.actions] : [], e = t.shift(), i = t.length === 1 ? t.shift() : void 0, r = !!((this.embed.type === "photo" || this.embed.type === "link") && (this.embed.title || this.embed.description || this.embed.type === "photo" && this.embed.provider_name));
    return v`
      <slot name="before"></slot>
      <div
        part="wy-embed ${gt({
      "wy-embed-interactive": !!this.embed.url,
      "wy-disabled": this.disabled
    })}"
        title=${this.embed.url ? this.embed.url : this.embed.title || ""}
        @click=${() => this.embed.url && this.dispatchActionEvent(Oi.Default) && ps(this.embed.url, "_blank")}
        @keydown=${Ze}
        @keyup=${bi}
      >
        ${(this.embed.type === "video" || this.embed.type === "rich") && this.embed.html ? v`
              <div part="wy-embed-area">
                <div
                  ${ht(this.embedContentRef)}
                  part=${gt({
      "wy-embed-content": !0,
      "wy-embed-video": this.embed.type === "video",
      "wy-embed-rich": this.embed.type === "rich"
    })}
                  data-width=${St(this.embed.width)}
                  data-height=${St(this.embed.height)}
                >
                  ${gl(this.embed.html)}
                </div>
              </div>
            ` : C}
        ${this.embed.type === "photo" && this.embed.image && this.embed.thumbnail_url ? v`
              <div
                part="wy-embed-photo wy-embed-area ${gt({
      "wy-embed-photo-with-description": r
    })}"
                style="background-image: linear-gradient(var(--wy-shade-invert, rgba(255,255,255,0.15))), url(${this.embed.thumbnail_url}), linear-gradient(var(--wy-shade-opaque, white));"
              >
                <img
                  part="wy-embed-image"
                  src=${this.embed.thumbnail_url}
                  alt=${this.embed.provider_name || this.embed.title || ""}
                  width=${St(this.embed.image.width)}
                  height=${St(this.embed.image.height)}
                />
              </div>
            ` : C}
        ${r ? v`
              <wy-item size="auto">
                ${this.embed.type === "link" && this.embed.image && this.embed.thumbnail_url ? v`
                      <img
                        part="wy-embed-icon"
                        slot="image"
                        src=${this.embed.thumbnail_url}
                        alt=${this.embed.provider_name || this.embed.title || ""}
                        width=${St(this.embed.image.width)}
                        height=${St(this.embed.image.height)}
                      />
                    ` : C}
                ${this.embed.provider_name ? v`<span slot="meta" part="wy-embed-provider">${this.embed.provider_name}</span>` : C}
                ${this.embed.title ? v`<span slot="title">${this.embed.title}</span>` : C}
                ${this.embed.description ? v`<span slot="text">${this.embed.description}</span>` : C}
                ${i ? v`
                      <wy-button
                        slot="actions"
                        color="variant"
                        @click=${(n) => {
      n.stopPropagation(), this.dispatchActionEvent(i);
    }}
                      >
                        ${i}
                      </wy-button>
                    ` : C}
                ${e ? v`
                      <wy-button
                        slot="actions"
                        color="primary"
                        @click=${(n) => {
      n.stopPropagation(), this.dispatchActionEvent(e);
    }}
                      >
                        ${e}
                      </wy-button>
                    ` : C}
                ${t.length ? v`
                      <wy-dropdown slot="actions">
                        ${t.map(
      (n) => v`
                              <wy-dropdown-item
                                @click=${(a) => {
        a.preventDefault(), a.stopPropagation(), this.dispatchActionEvent(n);
      }}
                              >
                                ${n}
                              </wy-dropdown-item>
                            `
    )}
                      </wy-dropdown>
                    ` : C}
              </wy-item>
            ` : C}
      </div>
    `;
  }
  updated(t) {
    if (this.embedContentRef.value) {
      const e = this.embedContentRef.value.firstElementChild, { width: i, height: r } = this.embedContentRef.value.dataset, n = Number(r ?? ""), a = n > 128 && n < 256 ? n : 128;
      i && r && (e.style.aspectRatio = `${i} / ${r}`, e.style.minHeight = `${a}px`);
    }
  }
}, h(Bf, "oo"), Bf), c(ix, "WyEmbed"), ix);
Cy.styles = [ft, KD];
W1([
  b({ attribute: !1 })
], Cy.prototype, "embed", 2);
W1([
  b({ type: Boolean, reflect: !0 })
], Cy.prototype, "disabled", 2);
Cy = W1([
  Y("wy-embed")
], Cy);
var rx, Nf;
let o1 = (rx = (Nf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this);
  }
  /**
   * Dispatch a local embed-remove event for the embed with the given id.
  *
   * @internal
   * @param id - Embed id to remove.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchRemove(t) {
    const e = new CustomEvent("embed-remove", {
      detail: { id: t },
      bubbles: !1,
      composed: !1
    });
    return this.dispatchEvent(e);
  }
  /**
   * Dispatch a local embed-swap event to request rotating/swapping embeds.
  *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSwap() {
    const t = new CustomEvent("embed-swap", {
      detail: {},
      bubbles: !1,
      composed: !1
    });
    return this.dispatchEvent(t);
  }
  render() {
    return v`
      <div part="wy-embed-select">
        ${qi(
      this.embeds,
      (t) => t.id,
      (t) => v`
            <wy-embed disabled .embed=${t}>
              <div part="wy-embed-actions" slot="before">
                ${this.embeds.length > 1 ? v`
                      <wy-button kind="icon" @click=${() => this.dispatchSwap()}>
                        <wy-icon name="swap-horizontal"></wy-icon>
                      </wy-button>
                    ` : v`<span></span>`}

                <wy-button kind="icon" @click=${() => this.dispatchRemove(t.id)}
                  ><wy-icon name="close-circle"></wy-icon
                ></wy-button>
              </div>
            </wy-embed>
          `
    )}
      </div>
    `;
  }
}, h(Nf, "co"), Nf), c(rx, "WyEmbedSelect"), rx);
o1.styles = [ft, KD];
W1([
  b({ attribute: !1 })
], o1.prototype, "embeds", 2);
o1 = W1([
  Y("wy-embed-select")
], o1);
function E0(s) {
  switch (s) {
    case "zoom":
      return "zoom-meetings";
    case "microsoft":
      return "microsoft-teams";
    case "google":
      return "google-meet";
  }
}
h(E0, "Up");
c(E0, "getMeetingIconName");
function _0(s) {
  switch (s) {
    case "zoom":
      return P("Zoom meeting");
    case "microsoft":
      return P("Teams meeting");
    case "google":
      return P("Google Meet");
  }
}
h(_0, "qp");
c(_0, "getMeetingTitle");
var fG = Object.defineProperty, mG = Object.getOwnPropertyDescriptor, JD = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? mG(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && fG(t, e, r), r;
}, "__decorateClass$Z"), sx, Xf;
let l1 = (sx = (Xf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this);
  }
  render() {
    const t = ((/* @__PURE__ */ new Date()).getTime() - new Date(this.meeting.created_at).getTime()) / 36e5 > 2;
    return v`
      <wy-item-list rounded filled>
        ${t ? v`
              <wy-item part="wy-meeting" size="lg" disabled title="${P("Meeting ended")}">
                <wy-icon slot="image" svg="${E0(this.meeting.provider)}" size="48"></wy-icon>
                <span slot="title">${_0(this.meeting.provider)}</span>
                <span slot="text">${this.meeting.code}</span>
              </wy-item>
            ` : v`
              <wy-item
                interactive
                size="lg"
                part="wy-meeting"
                @click=${(e) => {
      e.preventDefault(), ps(this.meeting.join_url, "_blank");
    }}
                url=${St(this.meeting.join_url)}
                title="${P("Join meeting")}"
              >
                <wy-icon
                  slot="image"
                  svg="${E0(this.meeting.provider)}"
                  size="48"
                  color="native"
                ></wy-icon>
                <span slot="title">${_0(this.meeting.provider)}</span>
                <span slot="text">${this.meeting.code}</span>
              </wy-item>
            `}
        </wy-item-list>
    `;
  }
}, h(Xf, "lo"), Xf), c(sx, "WyMeetingCard"), sx);
l1.styles = [ft];
JD([
  b({ attribute: !1 })
], l1.prototype, "meeting", 2);
l1 = JD([
  Y("wy-meeting-card"),
  At()
], l1);
const J4 = it`[part~=wy-poll]{min-width:0;display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));box-sizing:border-box;width:100%}[part~=wy-poll-form]{display:flex;flex-direction:column;gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-poll-form]:empty{display:none}[part~=wy-poll-option]{--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));display:flex;align-items:center;clip-path:border-box;overflow:hidden;position:relative;background-color:var(--wy-surface-layer-lowest, var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078)));border:var(--wy-border-outline, 0) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));padding:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));cursor:pointer;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-poll-option]>:not([part~=wy-poll-meter]){z-index:1}[part=wy-poll-image]{display:flex;height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);padding:0;line-height:1;align-items:center;justify-content:center}[part~=wy-poll-title]{width:100%;min-width:0;min-height:100%;color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset));align-content:center}[part~=wy-poll-title]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-poll-amount]{min-width:3em;text-align:end}[part~=wy-poll-meter]{position:absolute;top:0;left:0;bottom:0;background-color:var(--wy-surface-layer-highest, var(--wy-surface-layer-highest-light, rgba(0, 0, 0, .1019607843)))}`, yG = it`[part~=wy-dialog]{background:none;border:none;padding:0;margin:0;width:100%;height:100%;max-width:100%;max-height:100%;container-type:inline-size;pointer-events:none}[part~=wy-dialog][popover]{position:fixed;inset:0;z-index:1055}[part~=wy-dialog-modal]{align-items:center;justify-content:center;overflow:visible}[part~=wy-dialog-modal][open]{display:flex}[part~=wy-dialog-modal]:popover-open{display:flex}[part~=wy-dialog-modal]:focus-visible{outline:none}[part~=wy-overlay]{--wy-component-background-color: var(--wy-background, var(--wy-background-light, #f7f9ff));--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;overflow:hidden;container-type:inline-size}[part~=wy-overlay]{interpolate-size:allow-keywords;transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) .01s,visibility .01s step-end var(--wy-transition-duration-fast, .1s)}[part~=wy-overlay]:not([part~=wy-open]){opacity:0;visibility:hidden}[part~=wy-overlay][part~=wy-open]{transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),visibility var(--wy-transition-duration, .2s) step-start,top var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),right var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),bottom var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),left var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));visibility:visible;opacity:1;transform:none;pointer-events:auto}@starting-style{[part~=wy-overlay][part~=wy-open]{opacity:0;visibility:hidden}}`, gG = it`[part~=wy-modal]{width:100%;height:100%;border-radius:0}@container (inline-size >= 768px){[part~=wy-modal-centered]{border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level4, 0 calc(1 * var(--wy-size, 1rem)) calc(2.25 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .14), 0 calc(.375 * var(--wy-size, 1rem)) calc(1.875 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .12), 0 calc(.5 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) calc(-.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));margin-left:calc(4*var(--wy-size, 1rem));margin-top:auto;margin-right:calc(4*var(--wy-size, 1rem));margin-bottom:auto;width:calc(32*var(--wy-size, 1rem));max-height:calc(32*var(--wy-size, 1rem))}}@container (inline-size >= 768px){[part~=wy-modal-centered][part~=wy-maximized]{margin:0;width:100%;height:100%;max-width:calc(100% - 2*var(--wy-size, 1rem));max-height:calc(100% - 2*var(--wy-size, 1rem))}}`, wG = it`[part~=wy-sheet]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));position:fixed;z-index:1055;bottom:calc(.5*var(--wy-size, 1rem));left:calc(.5*var(--wy-size, 1rem));right:calc(.5*var(--wy-size, 1rem));max-height:max(50vh,50%);min-height:calc(3*var(--wy-size, 1rem));margin:calc(.5*var(--wy-size, 1rem)) auto;max-width:calc(32*var(--wy-size, 1rem));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12))}[part~=wy-sheet]:not([part~=wy-open]){transform:translateY(calc(32 * var(--wy-size, 1rem)))}@starting-style{[part~=wy-sheet][part~=wy-open]{transform:translateY(calc(32 * var(--wy-size, 1rem)))}}`, vG = it`[part~=wy-drawer]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));position:fixed;z-index:1055;box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));inset:0;border-radius:0}@container (inline-size >= 768px){[part~=wy-drawer]{top:var(--wy-padding-outer, 0px);right:var(--wy-padding-outer, 0px);bottom:var(--wy-padding-outer, 0px);left:auto;width:calc(24*var(--wy-size, 1rem));min-width:calc(24*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-outer, 0px)}}@container (inline-size >= 768px){[part~=wy-drawer][part~=wy-maximized]{width:calc(100% - 2*var(--wy-padding-outer, 0px))}}[part~=wy-drawer]:not([part~=wy-open]){transform:translate(calc(100% + var(--wy-padding-outer, 0px)))}@starting-style{[part~=wy-drawer][part~=wy-open]{transform:translate(calc(100% + var(--wy-padding-outer, 0px)))}}`, t3 = it`[part~=wy-header]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));background-color:var(--wy-component-background-color);box-sizing:border-box}@supports (position: sticky){[part~=wy-header]{position:sticky;top:0;z-index:1020}}[part~=wy-header]{z-index:1022}[part~=wy-header-floating]{--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-component-border-radius)}[part~=wy-header-outer]{--wy-component-border-radius: var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));border-radius:var(--wy-component-border-radius)}`, tV = it`[part~=wy-titlebar]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));box-sizing:border-box;display:grid;align-items:center;justify-content:space-between;justify-items:center;min-height:var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));padding:calc(var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));flex:0 0 var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));grid-template-columns:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) minmax(0,max-content) var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));column-gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));line-height:var(--wy-line-height, 1.5);color:var(--wy-component-color)}[part~=wy-titlebar-buttons],[part~=wy-titlebar-section]{display:flex;flex:0 0 auto;align-items:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));max-width:100%;box-shadow:var(--wy-component-box-shadow);border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem))));background-color:var(--wy-component-background-color)}[part~=wy-titlebar-lg]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));height:auto}[part~=wy-titlebar-buttons-first]{justify-content:flex-start}[part~=wy-titlebar-buttons-last]{justify-content:flex-end}[part~=wy-titlebar-text]{max-width:100%;display:block;color:inherit!important;-webkit-user-select:none;user-select:none;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-titlebar-text]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-titlebar-text-trashed]{text-decoration:line-through}`;
var OG = Object.defineProperty, bG = Object.getOwnPropertyDescriptor, Ra = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? bG(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && OG(t, e, r), r;
}, "__decorateClass$Y"), nx, jf;
let on = (nx = (jf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.header = !1, this.floating = !1, this.outer = !1, this.trashed = !1, this.size = "md";
  }
  /**
   * render function for the inner titlebar.
   * @internal
   * @returns
   */
  renderTitlebar() {
    return v`
      <nav part="wy-titlebar ${gt({ "wy-titlebar-lg": this.size === "lg" })}">
        <slot name="first">
          <div part="wy-titlebar-icon wy-titlebar-buttons wy-titlebar-buttons-first">
            <slot name="icon"></slot>
          </div>
        </slot>
        <slot name="middle">
          <div part="wy-titlebar-title wy-titlebar-section">
            <slot name="title-section">
              <wy-titlebar-text ?trashed=${this.trashed}><slot name="title"></slot></wy-titlebar-text>
            </slot>
          </div>
        </slot>
        <slot name="last">
          <div part="wy-titlebar-actions wy-titlebar-buttons wy-titlebar-buttons-last">
            <slot name="actions"></slot>
          </div>
        </slot>
      </nav>
    `;
  }
  render() {
    return this.header ? v`<header part="wy-header ${gt({ "wy-header-floating": this.floating, "wy-header-outer": this.outer })}"
          >${this.renderTitlebar()}</header
        >` : this.renderTitlebar();
  }
}, h(jf, "ho"), jf), c(nx, "WyTitlebar"), nx);
on.styles = [t3, tV, ft];
Ra([
  b({ type: Boolean })
], on.prototype, "header", 2);
Ra([
  b({ type: Boolean })
], on.prototype, "floating", 2);
Ra([
  b({ type: Boolean })
], on.prototype, "outer", 2);
Ra([
  b({ type: Boolean })
], on.prototype, "trashed", 2);
Ra([
  b()
], on.prototype, "size", 2);
on = Ra([
  Y("wy-titlebar")
], on);
var ax, Uf;
let c1 = (ax = (Uf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.trashed = !1;
  }
  render() {
    const t = {
      "wy-titlebar-text-trashed": this.trashed
    };
    return v` <slot part="wy-titlebar-text ${gt(t)}"></slot> `;
  }
}, h(Uf, "uo"), Uf), c(ax, "WyTitlebarText"), ax);
c1.styles = [tV, ft];
Ra([
  b({ type: Boolean })
], c1.prototype, "trashed", 2);
c1 = Ra([
  Y("wy-titlebar-text")
], c1);
var $G = Object.defineProperty, xG = Object.getOwnPropertyDescriptor, F1 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? xG(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && $G(t, e, r), r;
}, "__decorateClass$X"), ox, Hf;
let ba = (ox = (Hf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.viewportRef = $t(), this.show = !0, this.type = "modal", this.maximized = !1, this.noHeader = !1, this.handleClose = (t) => {
      if (this.isModal() || t?.type === "toggle" && t.newState === "closed" || t?.type === "close") {
        this.show = !1;
        const e = new CustomEvent("close");
        this.dispatchEvent(e);
      }
    };
  }
  /**
   * Close the modal.
   */
  close() {
    this.show = !1;
    try {
      this.type !== "modal" && this.viewportRef.value?.popover ? this.viewportRef.value?.hidePopover() : this.viewportRef.value?.close();
    } catch {
    }
  }
  /**
   * Checks whether the overlay is using the modal api.
   *
   * @param [type] - Optional type to check
   * @returns Whether the overlay is using the modal api.
   */
  isModal(t) {
    return t ??= this.type, t === "modal" || t === "full";
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("type") && this.viewportRef.value) {
      const e = !this.isModal(t.get("type")) && this.viewportRef.value.popover ? "toggle" : "close";
      this.viewportRef.value.removeEventListener(e, this.handleClose);
    }
  }
  render() {
    if (this.type === "none")
      return C;
    const t = {
      "wy-dialog": !0,
      "wy-dialog-modal": this.isModal()
    }, e = {
      "wy-overlay": !0,
      "wy-modal": this.isModal(),
      // modal, full
      "wy-modal-centered": this.type === "modal",
      "wy-sheet": this.type === "sheet",
      "wy-drawer": this.type === "drawer",
      "wy-maximized": this.maximized,
      "wy-open": this.show
    }, i = this.isModal() ? void 0 : "auto";
    return v`
      <dialog
        part=${gt(t)}
        tabindex="0"
        popover=${St(i)}
        ${ht(this.viewportRef)}
      >
        <div part=${gt(e)}>
          ${this.noHeader ? C : v`
                <slot name="header">
                  <wy-titlebar part="wy-overlay-titlebar" header>
                    <wy-button slot="icon" kind="icon" @click=${() => this.close()}>
                      <wy-icon name="close"></wy-icon>
                    </wy-button>
                    <slot slot="title" name="title"></slot>
                    <slot slot="actions" name="actions"></slot>
                  </wy-titlebar>
                </slot>
              `}
          <slot></slot>
        </div>
      </dialog>
    `;
  }
  updated(t) {
    if (t.has("type")) {
      const e = !this.isModal() && this.viewportRef.value?.popover ? "toggle" : "close";
      this.viewportRef.value?.addEventListener(e, this.handleClose), this.show && (!this.isModal(t.get("type")) && this.viewportRef.value?.popover ? this.viewportRef.value?.hidePopover() : this.viewportRef.value?.close(), this.requestUpdate("show"));
    }
    if (t.has("show"))
      try {
        this.show ? this.isModal() ? this.viewportRef.value?.showModal() : this.viewportRef.value?.popover ? this.viewportRef.value?.showPopover() : this.viewportRef.value?.show() : !this.isModal() && this.viewportRef.value?.popover ? this.viewportRef.value?.hidePopover() : this.viewportRef.value?.close();
      } catch {
      }
    t.has("show") && this.show && this.viewportRef.value?.focus();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.close();
  }
}, h(Hf, "po"), Hf), c(ox, "WyOverlay"), ox);
ba.styles = [Ie, ft, yG, gG, wG, vG];
F1([
  b({ type: Boolean, reflect: !0 })
], ba.prototype, "show", 2);
F1([
  b({ type: String })
], ba.prototype, "type", 2);
F1([
  b({ type: Boolean })
], ba.prototype, "maximized", 2);
F1([
  b({ type: Boolean })
], ba.prototype, "noHeader", 2);
ba = F1([
  Y("wy-overlay")
], ba);
const kG = it`[part~=wy-container]{display:flex;flex-direction:column;position:relative;min-height:0;height:100%;flex:1 1 auto}[part~=wy-container-padded]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));gap:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-container-outer]{padding:var(--wy-padding-outer, 0)}`, jl = it`[part~=wy-scroll-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x-y]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;overflow-x:auto;touch-action:pan-y,pan-x}[part~=wy-scroll-x-always],[part~=wy-scroll-y-always]{overflow-y:scroll}`;
var SG = Object.defineProperty, CG = Object.getOwnPropertyDescriptor, Xy = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? CG(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && SG(t, e, r), r;
}, "__decorateClass$W"), lx, Yf;
let ln = (lx = (Yf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.scrollX = !1, this.scrollY = !1, this.padded = !1, this.outer = !1, this.scrollbars = !1;
  }
  render() {
    const t = {
      "wy-container": !0,
      "wy-container-padded": this.padded,
      "wy-container-outer": this.outer,
      "wy-scroll-x": this.scrollX && !this.scrollY,
      "wy-scroll-y": this.scrollY && !this.scrollX,
      "wy-scroll-x-y": this.scrollX && this.scrollY,
      "wy-scroll-x-always": this.scrollbars && this.scrollX,
      "wy-scroll-y-always": this.scrollbars && this.scrollY
    };
    return v`
      <div part=${gt(t)}>
        <slot></slot>
      </div>
    `;
  }
}, h(Yf, "yo"), Yf), c(lx, "WyContainer"), lx);
ln.styles = [jl, ft, kG];
Xy([
  b({ type: Boolean })
], ln.prototype, "scrollX", 2);
Xy([
  b({ type: Boolean })
], ln.prototype, "scrollY", 2);
Xy([
  b({ type: Boolean })
], ln.prototype, "padded", 2);
Xy([
  b({ type: Boolean })
], ln.prototype, "outer", 2);
Xy([
  b({ type: Boolean })
], ln.prototype, "scrollbars", 2);
ln = Xy([
  Y("wy-container")
], ln);
var PG = Object.defineProperty, QG = Object.getOwnPropertyDescriptor, jy = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? QG(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && PG(t, e, r), r;
}, "__decorateClass$V"), cx, Gf;
let h1 = (cx = (Gf = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.pollOptions = [];
  }
  /**
   * Dispatch a `vote` event for the specified option.
   *
   * @param optionId - Identifier of the option to vote for.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  render() {
    const t = this.pollOptions.reduce((e, i) => e + (i.votes?.count || 0), 0);
    return v`
      <div part="wy-poll">
        ${this.pollOptions.map(
      (e) => v`<wy-poll-option
              @vote=${(i) => this.dispatchVote(i.detail.optionId)}
              .option=${e}
              .totalVotes=${t}
            ></wy-poll-option>`
    )}
      </div>
    `;
  }
}, h(Gf, "wo"), Gf), c(cx, "WyPoll"), cx);
h1.styles = [
  J4,
  ft
];
jy([
  b({ type: Array, attribute: !1 })
], h1.prototype, "pollOptions", 2);
h1 = jy([
  Y("wy-poll")
], h1);
var hx, Kf;
let $l = (hx = (Kf = class extends Xi {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.totalVotes = 0, this.showSheet = !1, this.getVotesQuery = new Qr(this);
  }
  async updated(t) {
    t.has("weavy") && this.weavy && this.option && this.option.id && await this.getVotesQuery.trackQuery(UI(this.weavy, this.option.id));
  }
  /**
   * Dispatch a `vote` event for the provided option id.
   *
   * @internal
   * @param optionId - Identifier of the option to vote for.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    if (!t)
      return;
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Toggle the voter sheet and refresh vote data.
   *
   * @internal
   * @param e - Triggering user event.
   */
  openSheet(t) {
    t.preventDefault(), t.stopPropagation(), this.getVotesQuery.observer?.refetch(), this.showSheet = !this.showSheet;
  }
  render() {
    if (!this.option || !this.option.id)
      return C;
    const { data: t, isLoading: e } = this.getVotesQuery.result ?? {}, i = this.totalVotes > 0 ? Math.round((this.option.votes?.count || 0) / this.totalVotes * 100) : 0;
    return v`
      <div
        part="wy-poll-option"
        tabindex="0"
        @click=${() => this.dispatchVote(this.option?.id)}
        @keydown=${Ze}
        @keyup=${bi}
      >
        <div part="wy-poll-meter" style="width: ${i + "%"}"></div>
        <div part="wy-poll-image">
          ${this.option.has_voted ? v`<wy-icon name="check-circle"></wy-icon>` : v`<wy-icon name="circle-outline"></wy-icon>`}
        </div>
        <div part="wy-poll-title">${this.option.text}</div>
        ${i > 0 ? v`<span
              part="wy-poll-amount"
              tabindex="0"
              @click=${(r) => this.openSheet(r)}
              @keydown=${Ze}
              @keyup=${bi}
            >
              ${i + "%"}
            </span>` : v`<span part="wy-poll-amount"></span>`}
      </div>

      ${this.weavy ? v`
            <wy-overlay type="sheet" .show=${this.showSheet} @close=${() => this.showSheet = !1}>
              <span slot="title">${P(lt`Votes on ${this.option.text}`)}</span>
              <wy-container scrollY padded>
                ${this.showSheet && t && !e ? v`
                      ${t.votes?.data ? t.votes.data.map(
      (r) => v`
                              <wy-item>
                                <wy-avatar
                                  slot="image"
                                  .size=${32}
                                  .src=${r.avatar_url}
                                  .name=${r.name}
                                ></wy-avatar>
                                <span slot="title">${r.name}</span>
                              </wy-item>
                            `
    ) : C}
                    ` : C}
              </wy-container>
            </wy-overlay>
          ` : C}
    `;
  }
}, h(Kf, "fo"), Kf), c(hx, "WyPollOption"), hx);
$l.styles = [J4, ft];
jy([
  b({ type: Number, attribute: !1 })
], $l.prototype, "totalVotes", 2);
jy([
  b({ attribute: !1 })
], $l.prototype, "option", 2);
jy([
  N()
], $l.prototype, "showSheet", 2);
$l = jy([
  Y("wy-poll-option"),
  At()
], $l);
function eV(s, t, e, i, r, n, a) {
  return new Yt(s.queryClient, {
    mutationFn: /* @__PURE__ */ c(async () => await s.fetch(`/api/${r}/${i}/reactions`, {
      method: n ? "POST" : "DELETE",
      body: JSON.stringify({ content: n })
    }), "mutationFn"),
    onMutate: /* @__PURE__ */ c(() => {
      const o = e === "apps" && r === "posts" ? [r, t] : [e, t, r];
      ke(s.queryClient, o, i, (l) => {
        Py(l, n, a);
      });
    }, "onMutate")
  });
}
h(eV, "i4");
c(eV, "reactionMutation");
function iV(s, t, e) {
  return {
    queryKey: [t, e, "reactions"],
    enabled: !1,
    queryFn: /* @__PURE__ */ c(async () => await (await s.fetch("/api/" + t + "/" + e + "/reactions")).json(), "queryFn")
  };
}
h(iV, "r4");
c(iV, "getReactionListOptions");
function Py(s, t, e) {
  return !t && !s.reactions?.data || (s.reactions || (s.reactions = { count: 0, data: [] }), s.reactions.data || (s.reactions.data = []), t ? s.reactions.data = [
    ...s.reactions.data.filter((i) => i.created_by?.id !== e.id),
    { content: t, created_by: e }
  ] : s.reactions.data && (s.reactions.data = [...s.reactions.data.filter((i) => i.created_by?.id !== e.id)])), s;
}
h(Py, "zl");
c(Py, "updateReaction");
const TG = it`[part~=wy-reaction]{font-size:calc(1.125*var(--wy-size, 1rem))}[part~=wy-reactions]{display:inline-flex;align-items:center;column-gap:calc(.25*var(--wy-size, 1rem))}[part~=wy-reactions] :first-child:not(:only-child){margin-left:calc(.25*var(--wy-size, 1rem))}[part~=wy-reactions] :last-child:not(:only-child){margin-right:calc(.25*var(--wy-size, 1rem))}[part~=wy-reaction-count]{margin:0 calc(.25*var(--wy-size, 1rem)) 0;line-height:1;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-reaction-menu]{width:max-content;position:absolute;z-index:1000;border:none;--wy-component-background-color: var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;margin:0;text-align:left;background-clip:padding-box;box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));overflow:hidden;padding:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));font-size:calc(1.25*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))))}[part~=wy-reaction-picker]{display:flex;flex-direction:row;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-reactions-line]{display:flex;align-items:center;gap:calc(.1875*var(--wy-size, 1rem));justify-content:end}[part~=wy-reactions-line-reverse]{flex-direction:row-reverse;justify-content:start}[part~=wy-reactions-line-bottom]{position:absolute;bottom:calc(-1*var(--wy-size, 1rem));right:calc(.25*var(--wy-size, 1rem));z-index:1}[part~=wy-reactions-line-below]{position:relative;height:0;min-height:0;max-height:0;margin:calc(var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) - var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) calc(-1*var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))) calc(-1*var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));padding-left:calc(.1875*var(--wy-size, 1rem));padding-right:calc(.1875*var(--wy-size, 1rem));gap:calc(.125*var(--wy-size, 1rem));flex:1 0 auto;justify-content:flex-end}`, rV = it`[part~=wy-emoji-icon]{display:inline-flex;justify-content:center;align-items:center;line-height:1;width:1em;height:1em;font-size:calc(1.25*var(--wy-size, 1rem))}[part~=wy-emoji-icon-sm]{width:calc(1.125*var(--wy-size, 1rem));height:calc(1.125*var(--wy-size, 1rem));font-size:calc(1.125*var(--wy-size, 1rem))}`;
var MG = Object.defineProperty, AG = Object.getOwnPropertyDescriptor, We = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? AG(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && MG(t, e, r), r;
}, "__decorateClass$U"), dx, Jf;
let Ce = (dx = (Jf = class extends Pe {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.directionX = "left", this.directionY = "up", this.small = !1, this.reactions = [], this.emojis = "", this.parentType = "apps", this.entityType = "messages", this.line = !1, this.lineReverse = !1, this.lineBottom = !1, this.lineBelow = !1, this._placement = "bottom-start", this.show = !1, this.showSheet = !1, this.buttonRef = $t(), this.menuRef = $t(), this.reactionListQuery = new Qr(this), this._documentClickHandler = (t) => {
      this.show && (t.preventDefault(), this.menuRef.value?.popover || (this.show = !1));
    }, this.handleReaction = async (t) => {
      if (!this.weavy || !this.parentId || !this.user)
        return;
      const e = eV(
        this.weavy,
        this.parentId,
        this.parentType,
        this.entityId,
        this.entityType,
        this.reactedEmoji === t ? void 0 : t,
        this.user
      );
      this.reactedEmoji = t, await e.mutate(), this.reactionListQuery.observer?.refetch();
    };
  }
  /**
   * Closes the picker when the popover hides.
   *
   * @internal
   */
  handleClose(t) {
    if (t.type === "toggle" && t.newState === "closed" || t.type === "click") {
      this.show = !1;
      const e = new CustomEvent("close");
      this.dispatchEvent(e);
    }
  }
  /**
   * Toggles the emoji picker visibility.
   *
   * @internal
   */
  handleClickToggle(t) {
    t.stopPropagation(), this.show = !this.show;
  }
  /**
   * Opens the detailed reaction sheet view.
   *
   * @internal
   */
  handleReactionsClick() {
    this.reactionListQuery.observer?.refetch(), this.showSheet = !this.showSheet, this.show = !1;
  }
  async willUpdate(t) {
    if (super.willUpdate(t), (t.has("weavy") || t.has("entityId") || t.has("showSheet")) && this.weavy && this.entityId && this.showSheet && await this.reactionListQuery.trackQuery(iV(this.weavy, this.entityType, this.entityId)), (t.has("reactions") || t.has("user")) && this.user && (this.reactedEmoji = this.reactions?.find((e) => e.created_by?.id === this.user?.id)?.content), (t.has("directionX") || t.has("directionY")) && (this._placement = this.directionX === "right" && this.directionY === "down" ? "bottom-start" : this.directionX === "left" && this.directionY === "down" ? "bottom-end" : this.directionX === "right" && this.directionY === "up" ? "top-start" : "top-end"), t.has("show") && (this.show && !this._computePositionCleanup && this.buttonRef.value && this.menuRef.value ? this._computePositionCleanup = N4(this.buttonRef.value, this.menuRef.value, () => {
      requestAnimationFrame(() => {
        this.buttonRef.value && this.menuRef.value && HD(this.buttonRef.value, this.menuRef.value, {
          placement: this._placement,
          strategy: this.menuRef.value.popover ? "absolute" : "fixed",
          middleware: [
            UD(),
            XD({ mainAxis: 0, alignmentAxis: -8 }),
            jD({ mainAxis: !0, crossAxis: !0, padding: 4, altBoundary: !0 })
          ]
        }).then(({ x: e, y: i }) => {
          this.menuRef.value && Object.assign(this.menuRef.value.style, {
            marginLeft: `${e}px`,
            marginTop: `${i}px`,
            top: 0,
            left: 0,
            position: this.menuRef.value.popover ? void 0 : "fixed",
            zIndex: this.menuRef.value.popover ? void 0 : 1075
          });
        });
      });
    }) : !this.show && this._computePositionCleanup && (this._computePositionCleanup(), this._computePositionCleanup = void 0)), this.show) {
      requestAnimationFrame(() => {
        document.addEventListener("click", this._documentClickHandler, { once: !0, capture: !0 });
      });
      try {
        this.menuRef.value?.showPopover();
      } catch {
      }
    } else
      try {
        this.menuRef.value?.hidePopover();
      } catch {
      }
    t.has("settings") && this.settings?.reactions && this.emojis != this.settings.reactions && (this.emojis = this.settings.reactions);
  }
  render() {
    const { data: t, isPending: e } = this.reactionListQuery.result ?? {};
    if (!this.emojis?.length)
      return C;
    const i = this.emojis?.length === 1 ? this.emojis[0] : "", r = [
      ...new Map(this.reactions?.map((d) => [d.content, d])).values()
    ], n = {
      "wy-emoji-icon": !0,
      "wy-emoji-icon-sm": this.small
    }, a = i ? v`
          ${this.reactions && this.reactions?.length > 1 ? v`<wy-button
                kind="icon-inline"
                ?active=${this.showSheet}
                ?small=${this.small}
                @click=${() => this.handleReactionsClick()}
              >
                <div part="wy-reactions">
                  <span part=${gt(n)}>
                    <small part="wy-reaction-count">${this.reactions.length}</small>
                  </span>
                </div>
              </wy-button>` : C}

          <div>
            <wy-button
              part="wy-reaction-menu-button"
              color="inherit"
              kind="icon"
              ?small=${this.small}
              ?active=${this.reactedEmoji === i}
              @click=${() => {
      this.handleReaction(i);
    }}
              @keydown=${Ze}
              @keyup=${bi}
              title=${P("React", { desc: "Button action to react" })}
            >
              <span part=${gt(n)} title=${i}>${i}</span>
            </wy-button>
          </div>
        ` : v`
          ${r.length ? v`
                <wy-button
                  kind="icon-inline"
                  ?active=${this.showSheet}
                  ?small=${this.small}
                  @click=${() => this.handleReactionsClick()}
                >
                  <div part="wy-reactions">
                    ${r.map((d) => v`<span part=${gt(n)} title="">${d.content}</span>`)}
                    ${this.reactions && this.reactions?.length > 1 ? v`<small part="wy-reaction-count">${this.reactions.length}</small>` : C}
                  </div>
                </wy-button>
              ` : C}

          <div ${ht(this.buttonRef)}>
            <wy-button
              part="wy-reaction-menu-button"
              color="inherit"
              kind="icon"
              ?active=${this.show}
              ?small=${this.small}
              @click=${(d) => this.handleClickToggle(d)}
              @keydown=${Ze}
              @keyup=${bi}
              title=${P("React", { desc: "Button action to react" })}
            >
              <wy-icon name="emoticon" size=${this.small ? 20 : 24}></wy-icon>
            </wy-button>
          </div>

          <div
            ${ht(this.menuRef)}
            part="wy-reaction-menu"
            @click=${(d) => this.handleClickToggle(d)}
            @keyup=${Wb}
            ?hidden=${!this.show}
            popover=${St(gO() ? void 0 : "auto")}
          >
            <div part="wy-reaction-picker">
              ${this.emojis.split(" ").map(
      (d) => v`
                    <wy-button
                      kind="icon"
                      color="none"
                      ?active=${this.reactedEmoji === d}
                      @click=${() => {
        this.handleReaction(d);
      }}
                    >
                      <span part="wy-emoji-icon">${d}</span>
                    </wy-button>
                  `
    )}
            </div>
          </div>
        `, o = v`
      ${this.weavy && this.showSheet ? v`
            <wy-overlay type="sheet" .show=${this.showSheet} @close=${() => this.showSheet = !1}>
              <span slot="title">${P("Reactions")}</span>
              <wy-container scrollY padded>
                ${this.showSheet && t && !e ? v`
                      ${t.data?.map(
      (d) => v` <wy-reaction-item .reaction=${d}></wy-reaction-item> `
    )}
                    ` : C}
              </wy-container>
            </wy-overlay>
          ` : C}
    `, l = {
      "wy-reactions-line": !0,
      "wy-reactions-line-reverse": this.lineReverse,
      "wy-reactions-line-bottom": this.lineBottom,
      "wy-reactions-line-below": this.lineBelow
    };
    return this.line || this.lineReverse || this.lineBottom || this.lineBelow ? v`
          <div part=${gt(l)}>${a}</div>
          ${o}
        ` : [a, o];
  }
  firstUpdated(t) {
    this.menuRef.value?.addEventListener(
      this.menuRef.value.popover ? "toggle" : "click",
      (e) => this.handleClose(e)
    );
  }
  disconnectedCallback() {
    this._computePositionCleanup?.(), super.disconnectedCallback();
  }
}, h(Jf, "mo"), Jf), c(dx, "WyReactions"), dx);
Ce.styles = [pe, TG, rV, ft];
We([
  b()
], Ce.prototype, "directionX", 2);
We([
  b()
], Ce.prototype, "directionY", 2);
We([
  b({ type: Boolean })
], Ce.prototype, "small", 2);
We([
  b({ attribute: !1 })
], Ce.prototype, "reactions", 2);
We([
  b({ attribute: !1 })
], Ce.prototype, "emojis", 2);
We([
  b({ type: String })
], Ce.prototype, "parentType", 2);
We([
  b({ attribute: !0, type: Number })
], Ce.prototype, "parentId", 2);
We([
  b({ attribute: !0, type: String })
], Ce.prototype, "entityType", 2);
We([
  b({ attribute: !0, type: Number })
], Ce.prototype, "entityId", 2);
We([
  b({ type: Boolean })
], Ce.prototype, "line", 2);
We([
  b({ type: Boolean })
], Ce.prototype, "lineReverse", 2);
We([
  b({ type: Boolean })
], Ce.prototype, "lineBottom", 2);
We([
  b({ type: Boolean })
], Ce.prototype, "lineBelow", 2);
We([
  N()
], Ce.prototype, "_placement", 2);
We([
  N()
], Ce.prototype, "reactedEmoji", 2);
We([
  N()
], Ce.prototype, "show", 2);
We([
  N()
], Ce.prototype, "showSheet", 2);
Ce = We([
  Y("wy-reactions"),
  At()
], Ce);
var ux, tm;
let d1 = (ux = (tm = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this);
  }
  render() {
    return v`
      <wy-item>
        <wy-avatar
          slot="image"
          .src=${this.reaction.created_by?.avatar_url}
          .name=${this.reaction.created_by?.name}
        ></wy-avatar>
        <span slot="title">${this.reaction.created_by?.name}</span>
        <span slot="actions" part="wy-emoji-icon">${this.reaction.content}</span>
      </wy-item>
    `;
  }
}, h(tm, "vo"), tm), c(ux, "WyReactionItem"), ux);
d1.styles = [pe, rV];
We([
  b({ attribute: !1 })
], d1.prototype, "reaction", 2);
d1 = We([
  Y("wy-reaction-item")
], d1);
const RG = it`[part~=wy-preview]{--wy-component-background-color: var(--wy-background, var(--wy-background-light, #f7f9ff));--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;box-sizing:border-box;align-items:stretch;justify-content:stretch;position:relative;flex:1 1 100%;min-width:calc(16*var(--wy-size, 1rem));min-height:calc(16*var(--wy-size, 1rem));max-height:100%;max-width:100%}[part~=wy-preview-layout]{width:100%;height:100%}[part~=wy-preview-main]{display:flex;height:calc(100% - var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem))))));min-height:0}@container (inline-size < 768px){[part~=wy-preview-main]{flex-direction:column}}[part~=wy-preview-swiper]{display:flex;flex-direction:row;flex:1 1 100%;align-items:center;justify-content:start;min-width:calc(16*var(--wy-size, 1rem));min-height:calc(16*var(--wy-size, 1rem));max-height:100%;max-width:100%;overflow-x:scroll;scroll-snap-type:x mandatory;scroll-behavior:auto;overscroll-behavior-x:none;scrollbar-width:none}[part~=wy-preview-swiper]::-webkit-scrollbar{display:none}[part~=wy-preview-swiper-disabled]{overflow-x:hidden}[part~=wy-preview-area]{position:relative;min-width:100%;min-height:100%;width:100%;height:100%;flex:1 1 auto;display:flex;flex-direction:column;scroll-snap-stop:always;scroll-snap-align:center}[part~=wy-nav-prev],[part~=wy-nav-next]{--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));background-color:var(--wy-component-background-color);position:absolute;top:50%;z-index:1000;border-radius:50%}[part~=wy-nav-prev]{left:calc(.5*var(--wy-size, 1rem))}[part~=wy-nav-next]{right:calc(.5*var(--wy-size, 1rem))}`, EG = it`[part~=wy-sidebar]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background:var(--wy-component-background-color);color:var(--wy-component-color);min-width:0;min-height:0;flex-grow:0;flex-shrink:0;flex-basis:calc(22*var(--wy-size, 1rem));z-index:10;display:flex;flex-direction:column;transition:flex-basis var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));position:relative;order:9999;overflow:clip}[part~=wy-sidebar]>*{transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) - var(--wy-transition-duration-fast, .1s));min-width:calc(22*var(--wy-size, 1rem))}[part~=wy-sidebar][hidden]{display:flex!important;flex-basis:0}[part~=wy-sidebar][hidden]>*{transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));opacity:0}@container (inline-size >= 768px){[part~=wy-sidebar]>*{min-width:calc(22*var(--wy-size, 1rem))}[part~=wy-sidebar] [part~=wy-sidebar-handle]{display:none}}@container (inline-size < 768px){[part~=wy-sidebar]{transition:flex-basis var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),margin-top var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));border-top-left-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-top-right-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));flex-basis:50vh}[part~=wy-sidebar]:not([hidden]){margin-top:calc(-1*var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-sidebar]:not([hidden])[part~=wy-maximized]{flex-basis:calc(100% - var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))*.5);margin-top:calc(-50% + var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))*2.5 - var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-sidebar]:not([hidden])[part~=wy-maximized]~* [part~=wy-nav-prev],[part~=wy-sidebar]:not([hidden])[part~=wy-maximized]~* [part~=wy-nav-next]{display:none}[part~=wy-sidebar]>*{min-height:var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))}}[part~=wy-sidebar-handle]{width:calc(4*var(--wy-size, 1rem));background-clip:content-box;background-color:var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));height:calc(1*var(--wy-size, 1rem));border:calc(.375*var(--wy-size, 1rem)) solid rgba(0,0,0,0);position:absolute;top:0;z-index:2;left:50%;margin-left:calc(-2*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));cursor:pointer}`;
var _G = Object.defineProperty, LG = Object.getOwnPropertyDescriptor, Gb = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? LG(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && _G(t, e, r), r;
}, "__decorateClass$T"), px, em;
let xl = (px = (em = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this);
  }
  /**
   * Dispatch `file-preview-loaded` when the fallback content is ready.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  render() {
    const t = this.icon, e = Fy(this.provider);
    return v`
      <wy-icon-display fill>
        <wy-icon name=${t} .overlayName=${e}></wy-icon>
        <span slot="text">
          ${this.provider ? v`
                <p>${P("No preview available :(")} </p>
                <wy-button kind="filled" color="variant" href=${this.src} target="_blank">${P(lt`Open in ${this.provider}`)}</wy-button>
              ` : v`<div>${P("No preview available :(")}</div>`}
        </span>
      </wy-icon-display>
    `;
  }
  updated(t) {
    (t.has("icon") || t.has("src")) && (this.icon || this.src) && this.dispatchLoaded();
  }
}, h(em, "go"), em), c(px, "WyPreviewIcon"), px);
xl.styles = [
  ft
];
Gb([
  b()
], xl.prototype, "src", 2);
Gb([
  b()
], xl.prototype, "icon", 2);
Gb([
  b()
], xl.prototype, "provider", 2);
xl = Gb([
  Y("wy-preview-icon"),
  At()
], xl);
const zG = it`[part~=wy-content-image]{min-width:0;display:flex;align-items:center;justify-content:center;position:relative;margin:auto;box-sizing:border-box;max-height:100%;max-width:100%;transition:transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform-origin var(--wy-transition-duration, .2s) step-end}[part~=wy-content-image][part~=wy-zoom]{cursor:zoom-out;transition:transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform-origin var(--wy-transition-duration, .2s) step-start}[part~=wy-content-image-img]{min-width:0;min-height:0;width:100%;height:100%}[part~=wy-content-image-img][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-content-image-img][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-content-image-img][part~=wy-loading][part~=wy-loaded]~[part~=wy-content-progress]{display:none}[part~=wy-content-image-img]~[part~=wy-content-progress]{position:absolute}`;
var IG = Object.defineProperty, DG = Object.getOwnPropertyDescriptor, Kb = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? DG(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && IG(t, e, r), r;
}, "__decorateClass$S"), fx, im;
let kl = (fx = (im = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this);
  }
  /**
   * Dispatches the `file-preview-loaded` event once the image has loaded.
   *
   * @internal
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  render() {
    const t = !!(this.width && this.height), e = t ? { "--width": this.width, "--height": this.height } : {};
    return v`
      <div part="wy-content-image ${gt({ "wy-intrinsic-image": !t })}" style=${Jw(e)}>
        <img
          part="wy-content-image-img"
          src=${this.src}
          ${ht(jb)}
          @load=${(i) => {
      Ub(i), this.dispatchLoaded();
    }}
          width=${St(this.width)}
          height=${St(this.height)}
          decoding="async"
          alt=${P("Preview")}
        />
        ${t ? v`<wy-progress-circular part="wy-content-progress" indeterminate overlay></wy-progress-circular>` : C}
      </div>
    `;
  }
}, h(im, "bo"), im), c(fx, "WyPreviewImage"), fx);
kl.styles = [zG, ft];
Kb([
  b()
], kl.prototype, "src", 2);
Kb([
  b({ type: Number })
], kl.prototype, "width", 2);
Kb([
  b({ type: Number })
], kl.prototype, "height", 2);
kl = Kb([
  Y("wy-preview-image"),
  At()
], kl);
function e3(s) {
  (s.classList.contains("wy-loading") || s.part.contains("wy-loading")) && (s.classList.add("wy-loaded"), s.part.add("wy-loaded")), s.classList.add("wy-error"), s.part.add("wy-error"), s.outerHTML = s.outerHTML.replace(/<(video|audio)/, "<div").replace(/(video|audio)>/, "div>");
}
h(e3, "Hv");
c(e3, "mediaFallback");
function sV(s) {
  const t = s.target;
  (t.tagName === "VIDEO" || t.tagName === "AUDIO") && (t.classList.contains("wy-loading") || t.part.contains("wy-loading")) && (t.classList.add("wy-loaded"), t.part.add("wy-loaded"));
}
h(sV, "y4");
c(sV, "mediaLoaded");
function IS(s) {
  const t = s.target;
  if (t.tagName === "SOURCE" && t.parentNode) {
    const e = t.parentNode, i = parseInt(e.dataset.errors || "0") + 1;
    e.dataset.errors = i.toString(), e.querySelectorAll("source").length >= i && (console.warn(e.tagName.toLowerCase() + " source error, switching to fallback"), e3(e));
  }
}
h(IS, "Of");
c(IS, "mediaError");
function DS(s) {
  const t = s.target;
  (t.tagName === "VIDEO" || t.tagName === "AUDIO") && (t.tagName === "VIDEO" && !t.videoWidth || t.tagName === "AUDIO" && !t.duration) && (console.warn(t.tagName.toLowerCase() + " track not available, switching to fallback"), e3(t));
}
h(DS, "zf");
c(DS, "codecError");
const VG = it`[part~=wy-content-video]{box-sizing:border-box}[part~=wy-content-video]:not([part~=wy-error]){min-height:0;max-width:100%;max-height:100%;flex:1 1 auto}[part~=wy-content-video],[part~=wy-content-audio]{margin:auto}[part~=wy-content-video][part~=wy-loading]:not([part~=wy-loaded]),[part~=wy-content-audio][part~=wy-loading]:not([part~=wy-loaded]){visibility:hidden}[part~=wy-content-video][part~=wy-loading][part~=wy-loaded]~[part~=wy-content-progress],[part~=wy-content-audio][part~=wy-loading][part~=wy-loaded]~[part~=wy-content-progress]{display:none}[part~=wy-content-video]:focus,[part~=wy-content-audio]:focus{outline:none}`;
var WG = Object.defineProperty, FG = Object.getOwnPropertyDescriptor, Uy = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? FG(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && WG(t, e, r), r;
}, "__decorateClass$R"), mx, rm;
let cn = (mx = (rm = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.format = "", this.play = !1, this.name = "", this.handleLoaded = (t) => {
      sV(t), this.dispatchLoaded();
    };
  }
  /**
   * Dispatches the `file-preview-loaded` event after the media metadata becomes available.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  /**
   * Registers load and error listeners on the provided media element.
   *
   * @internal
   * @param mediaElement - Media element to observe.
   */
  registerLoading(t) {
    this.unregisterLoading(), t && (this.mediaElement = t, t.part.add("wy-loading"), t.addEventListener("error", IS, !0), t.addEventListener("loadedmetadata", this.handleLoaded, !0), t.addEventListener("loadedmetadata", DS, !0));
  }
  /**
   * Cleans up listeners and state from the previously registered media element.
   *
   * @internal
   */
  unregisterLoading() {
    this.mediaElement && (this.mediaElement.pause(), this.mediaElement.removeAttribute("autoplay"), this.mediaElement.setAttribute("preload", "none"), this.mediaElement.removeEventListener("error", IS, !0), this.mediaElement.removeEventListener("loadedmetadata", this.handleLoaded, !0), this.mediaElement.removeEventListener("loadedmetadata", DS, !0), this.mediaElement = void 0);
  }
  render() {
    return this.format === "video" ? v`
          <video ${ht((t) => this.registerLoading(t))} part="wy-content-video" controls crossorigin="use-credentials">
            <source src=${this.src} type=${St(this.mediaType)} />
            <wy-preview-icon src=${this.src} icon="file-video"></wy-preview-icon>
          </video>
          <wy-progress-circular part="wy-content-progress" indeterminate overlay></wy-progress-circular>
        ` : v`
          <audio ${ht((t) => this.registerLoading(t))} part="wy-content-audio" controls crossorigin="use-credentials">
            <source src=${this.src} type=${St(this.mediaType)} />
          </audio>
        `;
  }
  updated(t) {
    super.updated(t), t.has("play") && this.mediaElement && (this.play ? this.mediaElement.play() : this.mediaElement.pause());
  }
  disconnectedCallback() {
    this.unregisterLoading(), super.disconnectedCallback();
  }
}, h(rm, "xo"), rm), c(mx, "WyPreviewMedia"), mx);
cn.styles = [
  VG,
  ft
];
Uy([
  b()
], cn.prototype, "format", 2);
Uy([
  b()
], cn.prototype, "src", 2);
Uy([
  b({ type: Boolean })
], cn.prototype, "play", 2);
Uy([
  b()
], cn.prototype, "name", 2);
Uy([
  b()
], cn.prototype, "mediaType", 2);
cn = Uy([
  Y("wy-preview-media")
], cn);
const qG = it`[part~=wy-content-code]{align-self:flex-start;box-sizing:border-box;width:100%;padding:calc(2*var(--wy-size, 1rem)) calc(3.5*var(--wy-size, 1rem));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}`, ZG = it`[part~=wy-content-text],[part~=wy-content-html] pre,[part~=wy-content-html] code{word-break:break-word;white-space:pre-wrap}[part~=wy-content-html] hr{border-color:var(--wy-outline, var(--wy-outline-light, #72777f));border-width:var(--wy-border, 1px) 0 0 0;border-style:solid}[part~=wy-content-html] h1,[part~=wy-content-html] h2,[part~=wy-content-html] h3,[part~=wy-content-html] h4,[part~=wy-content-html] h5,[part~=wy-content-html] h6{font-family:var(--wy-document-headings-font-family, var(--wy-headings-font-family, var(--wy-font-family, unset)));line-height:var(--wy-document-headings-line-height, var(--wy-headings-line-height, var(--wy-line-height, 1.5)))}[part~=wy-content-html] h1{font-size:var(--wy-document-h1-font-size, calc(2 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h1-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h1-margin, 0 0 var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-content-html] h2{font-size:var(--wy-document-h2-font-size, calc(1.5 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h2-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h2-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content-html] h3{font-size:var(--wy-document-h3-font-size, calc(1.25 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h3-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h3-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content-html] h4{font-size:var(--wy-document-h4-font-size, calc(1.125 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h4-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h4-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 0)}[part~=wy-content-html] h5{font-size:var(--wy-document-h5-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-document-h5-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h5-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 0)}[part~=wy-content-html] h6{font-size:var(--wy-document-h6-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-document-h6-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h6-margin, 0)}`, BG = it`[part~=wy-document]{--wy-component-background-color: var(--wy-background, var(--wy-background-light, #f7f9ff));--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);align-self:flex-start;padding:calc(2*var(--wy-size, 1rem)) calc(3.5*var(--wy-size, 1rem));box-sizing:border-box;width:100%;min-height:100%;flex:1 0 auto}@container (inline-size >= 768px){[part~=wy-document]{padding:calc(3*var(--wy-size, 1rem)) calc(4*var(--wy-size, 1rem));margin:calc(2*var(--wy-size, 1rem)) auto;border-radius:calc(.125*var(--wy-size, 1rem));box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));width:120ch;min-height:170ch;max-width:calc(100% - 3.5*var(--wy-size, 1rem))}}`, NG = it`[part~=wy-code] pre,.wy-code pre{text-wrap:pretty}[part~=wy-code] .code,[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code .code,.wy-code code[class*=language-],.wy-code pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;word-wrap:break-word;line-height:1.25;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}@media print{[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code code[class*=language-],.wy-code pre[class*=language-]{text-shadow:none}}[part~=wy-code] pre[class*=language-],.wy-code pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}[part~=wy-code] :not(pre)>code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code :not(pre)>code[class*=language-],.wy-code pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));background:var(--wy-background, var(--wy-background-light, #f7f9ff))}[part~=wy-code] :not(pre)>code[class*=language-],.wy-code :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}[part~=wy-code] .token.variable,.wy-code .token.variable{color:var(--wy-code-variable, var(--wy-code-variable-light, #001080))}[part~=wy-code] .token.operator,.wy-code .token.operator{color:var(--wy-code-operator, var(--wy-code-operator-light, #000000))}[part~=wy-code] .token.prolog,.wy-code .token.prolog{color:var(--wy-code-prolog, var(--wy-code-prolog-light, #000080))}[part~=wy-code] .token.comment,.wy-code .token.comment{color:var(--wy-code-comment, var(--wy-code-comment-light, #008000))}[part~=wy-code] .token.builtin,.wy-code .token.builtin{color:var(--wy-code-builtin, var(--wy-code-builtin-light, #0070C1))}[part~=wy-code] .token.number,.wy-code .token.number{color:var(--wy-code-number, var(--wy-code-number-light, #098658))}[part~=wy-code] .token.inserted,.wy-code .token.inserted{color:var(--wy-code-inserted, var(--wy-code-inserted-light, #098658))}[part~=wy-code] .token.constant,.wy-code .token.constant{color:var(--wy-code-constant, var(--wy-code-constant-light, #811F3F))}[part~=wy-code] .token.hexcode,.wy-code .token.hexcode{color:var(--wy-code-hexcode, var(--wy-code-hexcode-light, #811F3F))}[part~=wy-code] .token.regex,.wy-code .token.regex{color:var(--wy-code-regex, var(--wy-code-regex-light, #811F3F))}[part~=wy-code] .token.char,.wy-code .token.char{color:var(--wy-code-char, var(--wy-code-char-light, #811F3F))}[part~=wy-code] .token.tag,.wy-code .token.tag{color:var(--wy-code-tag, var(--wy-code-tag-light, #800000))}[part~=wy-code] .token.attr-name,.wy-code .token.attr-name{color:var(--wy-code-attr-name, var(--wy-code-attr-name-light, #E50000))}[part~=wy-code] .token.selector,.wy-code .token.selector{color:var(--wy-code-selector, var(--wy-code-selector-light, #E50000))}[part~=wy-code] .token.property,.wy-code .token.property{color:var(--wy-code-property, var(--wy-code-property-light, #E50000))}[part~=wy-code] .token.deleted,.wy-code .token.deleted{color:var(--wy-code-deleted, var(--wy-code-deleted-light, #A31515))}[part~=wy-code] .token.string,.wy-code .token.string{color:var(--wy-code-string, var(--wy-code-string-light, #A31515))}[part~=wy-code] .token.changed,.wy-code .token.changed{color:var(--wy-code-changed, var(--wy-code-changed-light, #0451A5))}[part~=wy-code] .token.punctuation,.wy-code .token.punctuation{color:var(--wy-code-punctuation, var(--wy-code-punctuation-light, #000000))}[part~=wy-code] .token.function,.wy-code .token.function{color:var(--wy-code-function, var(--wy-code-function-light, #0000FF))}[part~=wy-code] .token.keyword,.wy-code .token.keyword{color:var(--wy-code-keyword, var(--wy-code-keyword-light, #AF00DB))}[part~=wy-code] .token.class-name,.wy-code .token.class-name{color:var(--wy-code-class-name, var(--wy-code-class-name-light, #267F99))}[part~=wy-code] .token.important,[part~=wy-code] .token.bold,.wy-code .token.important,.wy-code .token.bold{font-weight:700}[part~=wy-code] .token.italic,.wy-code .token.italic{font-style:italic}`;
var XG = Object.defineProperty, jG = Object.getOwnPropertyDescriptor, Ul = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? jG(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && XG(t, e, r), r;
}, "__decorateClass$Q"), yx, sm;
let ws = (yx = (sm = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.html = !1, this.code = !1, this.textOrHtmlContent = "", this.loading = !0;
  }
  /**
   * Dispatches the `file-preview-loaded` event when content becomes available.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  updated(t) {
    super.updated(t), (t.has("weavy") || t.has("src")) && this.weavy && (this.loading = !0, this.weavy.fetchOptions().then((e) => fetch(this.src, e)).then(K_).then((e) => new Response(e)).then((e) => e.text()).then((e) => {
      this.loading = !1, this.textOrHtmlContent = e, this.dispatchLoaded();
    }));
  }
  render() {
    return this.loading ? v` <wy-empty><wy-progress-circular part="wy-content-progress" indeterminate></wy-progress-circular></wy-empty> ` : this.html ? this.code ? v` <div part="wy-content-code wy-code">${gl(this.textOrHtmlContent)}</div> ` : v`
            <div part="wy-document wy-light">
              <div part="wy-content-html">${gl(this.textOrHtmlContent)}</div>
            </div>
          ` : this.code ? v` <div part="wy-content-code">${this.textOrHtmlContent}</div> ` : v`
          <div part="wy-document wy-light">
            <pre part="wy-content-text">${this.textOrHtmlContent}</pre>
          </div>
        `;
  }
}, h(sm, "Co"), sm), c(yx, "WyPreviewText"), yx);
ws.styles = [Ie, ZG, qG, BG, NG, ft];
Ul([
  Xe({ context: De, subscribe: !0 }),
  N()
], ws.prototype, "weavy", 2);
Ul([
  b()
], ws.prototype, "src", 2);
Ul([
  b({ type: Boolean })
], ws.prototype, "html", 2);
Ul([
  b({ type: Boolean })
], ws.prototype, "code", 2);
Ul([
  N()
], ws.prototype, "textOrHtmlContent", 2);
Ul([
  N()
], ws.prototype, "loading", 2);
ws = Ul([
  Y("wy-preview-text")
], ws);
const UG = it`[part~=wy-content-embed]{border:0;display:block;box-sizing:border-box;width:100%;height:100%;top:0;left:0;flex:1 1 100%}[part~=wy-content-embed][part~=wy-loaded]{--wy-component-background-color: var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}[part~=wy-content-embed][part~=wy-loaded]~[part~=wy-content-embed-fallback],[part~=wy-content-embed][part~=wy-loaded]~[part~=wy-content-progress]{display:none}[part~=wy-content-embed][part~=wy-loading]:not([part~=wy-loaded]){position:absolute;visibility:hidden;z-index:-1;pointer-events:none}[part~=wy-content-embed][part~=wy-loading]:not([part~=wy-loaded]):not([part~=wy-fallback])~[part~=wy-content-embed-fallback]{display:none}[part~=wy-content-embed][part~=wy-loading]:not([part~=wy-loaded])[part~=wy-fallback]~[part~=wy-content-progress]{display:none}`;
var HG = Object.defineProperty, YG = Object.getOwnPropertyDescriptor, q1 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? YG(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && HG(t, e, r), r;
}, "__decorateClass$P"), gx, nm;
let $a = (gx = (nm = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this);
  }
  /**
   * Emit `file-preview-loaded` once the preview has finished loading.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  /**
   * Attach load listeners and register the provided embed element.
   *
   * @internal
   * @param embedElement - Newly rendered embed element.
   */
  registerLoading(t) {
    if (this.unregisterLoading?.(), t) {
      this.embedElement = t, t.part.add("wy-loading");
      const e = window.setTimeout(() => {
        t.part.add("wy-fallback"), this.dispatchLoaded();
      }, 2500), i = /* @__PURE__ */ c((r) => {
        const n = r.target;
        n.tagName === "OBJECT" && n.part.contains("wy-loading") && !n.part.contains("wy-loaded") && (n.part.add("wy-loaded"), window.clearTimeout(e), this.dispatchLoaded());
      }, "embedLoaded");
      t.addEventListener("load", i, !0), this.unregisterLoading = () => {
        this.embedElement && (t.removeEventListener("load", i, !0), window.clearTimeout(e), this.embedElement = void 0);
      };
    }
  }
  render() {
    return v`
      <object title=${P("Preview")} ${ht((t) => this.registerLoading(t))} part="wy-content-embed" data=${this.src}></object>
      <wy-progress-circular part="wy-content-progress" indeterminate overlay></wy-progress-circular>
      <wy-preview-icon
        src=${this.src}
        icon=${this.icon}
        provider=${St(this.provider)}
        part="wy-content-embed-fallback"></wy-preview-icon>
    `;
  }
  disconnectedCallback() {
    this.unregisterLoading?.(), super.disconnectedCallback();
  }
}, h(nm, "$o"), nm), c(gx, "WyPreviewEmbed"), gx);
$a.styles = [
  UG,
  ft
];
q1([
  b()
], $a.prototype, "src", 2);
q1([
  b()
], $a.prototype, "name", 2);
q1([
  b()
], $a.prototype, "icon", 2);
q1([
  b()
], $a.prototype, "provider", 2);
$a = q1([
  Y("wy-preview-embed"),
  At()
], $a);
const GG = it`.wy-pdf-container{position:absolute;width:100%;height:100%;bottom:0;left:0}.wy-pdf-container{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-pdf-container:not(body){-webkit-overflow-scrolling:touch}.wy-pdf-container{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-pdf-container{overflow-y:auto;overflow-x:auto;touch-action:pan-y,pan-x}.wy-content-pdf .textLayer{position:absolute;text-align:initial;inset:0;overflow:clip;opacity:1;line-height:1;text-size-adjust:none;forced-color-adjust:none;transform-origin:0 0;caret-color:CanvasText;z-index:0}.wy-content-pdf .textLayer.highlighting{touch-action:none}.wy-content-pdf .textLayer :is(span,br){color:#0000;position:absolute;white-space:pre;cursor:text;transform-origin:0% 0%}.wy-content-pdf .textLayer>:not(.markedContent),.wy-content-pdf .textLayer .markedContent span:not(.markedContent){z-index:1}.wy-content-pdf .textLayer span.markedContent{top:0;height:0}.wy-content-pdf .textLayer span[role=img]{-webkit-user-select:none;user-select:none;cursor:default}.wy-content-pdf .textLayer .highlight{--highlight-bg-color: rgb(180 0 170 / .25);--highlight-selected-bg-color: rgb(0 100 0 / .25);--highlight-backdrop-filter: none;--highlight-selected-backdrop-filter: none}@media screen and (forced-colors:active){.wy-content-pdf .textLayer .highlight{--highlight-bg-color: transparent;--highlight-selected-bg-color: transparent;--highlight-backdrop-filter: var(--hcm-highlight-filter);--highlight-selected-backdrop-filter: var(--hcm-highlight-selected-filter)}}.wy-content-pdf .textLayer .highlight{margin:-1px;padding:1px;background-color:var(--highlight-bg-color);-webkit-backdrop-filter:var(--highlight-backdrop-filter);backdrop-filter:var(--highlight-backdrop-filter);border-radius:4px}.wy-content-pdf .textLayer .highlight.appended{position:initial}.wy-content-pdf .textLayer .highlight.begin{border-radius:4px 0 0 4px}.wy-content-pdf .textLayer .highlight.end{border-radius:0 4px 4px 0}.wy-content-pdf .textLayer .highlight.middle{border-radius:0}.wy-content-pdf .textLayer .highlight.selected{background-color:var(--highlight-selected-bg-color);-webkit-backdrop-filter:var(--highlight-selected-backdrop-filter);backdrop-filter:var(--highlight-selected-backdrop-filter)}.wy-content-pdf .textLayer ::selection{background:#0000ff40;background:color-mix(in srgb,AccentColor,transparent 75%)}.wy-content-pdf .textLayer br::selection{background:#0000}.wy-content-pdf .textLayer .endOfContent{display:block;position:absolute;inset:100% 0 0;z-index:0;cursor:default;-webkit-user-select:none;user-select:none}.wy-content-pdf .textLayer.selecting .endOfContent{top:0}.wy-content-pdf .annotationLayer{--annotation-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\");--input-focus-border-color: Highlight;--input-focus-outline: 1px solid Canvas;--input-unfocused-border-color: transparent;--input-disabled-border-color: transparent;--input-hover-border-color: black;--link-outline: none}@media screen and (forced-colors:active){.wy-content-pdf .annotationLayer{--input-focus-border-color: CanvasText;--input-unfocused-border-color: ActiveText;--input-disabled-border-color: GrayText;--input-hover-border-color: Highlight;--link-outline: 1.5px solid LinkText}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):required,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:required,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:required{outline:1.5px solid selectedItem}.wy-content-pdf .annotationLayer .linkAnnotation{outline:var(--link-outline)}.wy-content-pdf .annotationLayer .linkAnnotation:hover{-webkit-backdrop-filter:var(--hcm-highlight-filter);backdrop-filter:var(--hcm-highlight-filter)}.wy-content-pdf .annotationLayer .linkAnnotation>a:hover{opacity:0!important;background:none!important;box-shadow:none}.wy-content-pdf .annotationLayer .popupAnnotation .popup{outline:calc(1.5px*var(--scale-factor)) solid CanvasText!important;background-color:ButtonFace!important;color:ButtonText!important}.wy-content-pdf .annotationLayer .highlightArea:hover:after{position:absolute;top:0;left:0;width:100%;height:100%;-webkit-backdrop-filter:var(--hcm-highlight-filter);backdrop-filter:var(--hcm-highlight-filter);content:\"\";pointer-events:none}.wy-content-pdf .annotationLayer .popupAnnotation.focused .popup{outline:calc(3px*var(--scale-factor)) solid Highlight!important}}.wy-content-pdf .annotationLayer{position:absolute;top:0;left:0;pointer-events:none;transform-origin:0 0}.wy-content-pdf .annotationLayer[data-main-rotation=\"90\"] .norotate{transform:rotate(270deg) translate(-100%)}.wy-content-pdf .annotationLayer[data-main-rotation=\"180\"] .norotate{transform:rotate(180deg) translate(-100%,-100%)}.wy-content-pdf .annotationLayer[data-main-rotation=\"270\"] .norotate{transform:rotate(90deg) translateY(-100%)}.wy-content-pdf .annotationLayer.disabled section,.wy-content-pdf .annotationLayer.disabled .popup{pointer-events:none}.wy-content-pdf .annotationLayer .annotationContent{position:absolute;width:100%;height:100%;pointer-events:none}.wy-content-pdf .annotationLayer .annotationContent.freetext{background:#0000;border:none;inset:0;overflow:visible;white-space:nowrap;font:10px sans-serif;line-height:1.35;-webkit-user-select:none;user-select:none}.wy-content-pdf .annotationLayer section{position:absolute;text-align:initial;pointer-events:auto;box-sizing:border-box;transform-origin:0 0}.wy-content-pdf .annotationLayer section:has(div.annotationContent) canvas.annotationContent{display:none}.textLayer.selecting~.wy-content-pdf .annotationLayer section{pointer-events:none}.wy-content-pdf .annotationLayer :is(.linkAnnotation,.buttonWidgetAnnotation.pushButton)>a{position:absolute;font-size:1em;top:0;left:0;width:100%;height:100%}.wy-content-pdf .annotationLayer :is(.linkAnnotation,.buttonWidgetAnnotation.pushButton):not(.hasBorder)>a:hover{opacity:.2;background-color:#ff0;box-shadow:0 2px 10px #ff0}.wy-content-pdf .annotationLayer .linkAnnotation.hasBorder:hover{background-color:#ff03}.wy-content-pdf .annotationLayer .hasBorder{background-size:100% 100%}.wy-content-pdf .annotationLayer .textAnnotation img{position:absolute;cursor:pointer;width:100%;height:100%;top:0;left:0}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea),.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input{background-image:var(--annotation-unfocused-field-background);border:2px solid var(--input-unfocused-border-color);box-sizing:border-box;font:calc(9px*var(--scale-factor)) sans-serif;height:100%;margin:0;vertical-align:top;width:100%}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):required,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:required,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:required{outline:1.5px solid red}.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select option{padding:0}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input{border-radius:50%}.wy-content-pdf .annotationLayer .textWidgetAnnotation textarea{resize:none}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea)[disabled],.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select[disabled],.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input[disabled]{background:none;border:2px solid var(--input-disabled-border-color);cursor:not-allowed}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):hover,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:hover,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:hover{border:2px solid var(--input-hover-border-color)}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):hover,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:hover,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:hover{border-radius:2px}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):focus,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:focus{background:none;border:2px solid var(--input-focus-border-color);border-radius:2px;outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) :focus{background-image:none;background-color:#0000}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox :focus{border:2px solid var(--input-focus-border-color);border-radius:2px;outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton :focus{border:2px solid var(--input-focus-border-color);outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{background-color:CanvasText;content:\"\";display:block;position:absolute}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{height:80%;left:45%;width:1px}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{transform:rotate(45deg)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{transform:rotate(-45deg)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{border-radius:50%;height:50%;left:25%;top:25%;width:50%}.wy-content-pdf .annotationLayer .textWidgetAnnotation input.comb{font-family:monospace;padding-left:2px;padding-right:0}.wy-content-pdf .annotationLayer .textWidgetAnnotation input.comb:focus{width:103%}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input{appearance:none}.wy-content-pdf .annotationLayer .fileAttachmentAnnotation .popupTriggerArea{height:100%;width:100%}.wy-content-pdf .annotationLayer .popupAnnotation{position:absolute;font-size:calc(9px*var(--scale-factor));pointer-events:none;width:max-content;max-width:45%;height:auto}.wy-content-pdf .annotationLayer .popup{background-color:#ff9;box-shadow:0 calc(2px*var(--scale-factor)) calc(5px*var(--scale-factor)) #888;border-radius:calc(2px*var(--scale-factor));outline:1.5px solid #ffff4a;padding:calc(6px*var(--scale-factor));cursor:pointer;font:message-box;white-space:normal;word-wrap:break-word;pointer-events:auto}.wy-content-pdf .annotationLayer .popupAnnotation.focused .popup{outline-width:3px}.wy-content-pdf .annotationLayer .popup *{font-size:calc(9px*var(--scale-factor))}.wy-content-pdf .annotationLayer .popup>.header{display:inline-block}.wy-content-pdf .annotationLayer .popup>.header h1{display:inline}.wy-content-pdf .annotationLayer .popup>.header .popupDate{display:inline-block;margin-left:calc(5px*var(--scale-factor));width:fit-content}.wy-content-pdf .annotationLayer .popupContent{border-top:1px solid #333;margin-top:calc(2px*var(--scale-factor));padding-top:calc(2px*var(--scale-factor))}.wy-content-pdf .annotationLayer .richText>*{white-space:pre-wrap;font-size:calc(9px*var(--scale-factor))}.wy-content-pdf .annotationLayer .popupTriggerArea{cursor:pointer}.wy-content-pdf .annotationLayer section svg{position:absolute;width:100%;height:100%;top:0;left:0}.wy-content-pdf .annotationLayer .annotationTextContent{position:absolute;width:100%;height:100%;opacity:0;color:#0000;-webkit-user-select:none;user-select:none;pointer-events:none}.wy-content-pdf .annotationLayer .annotationTextContent span{width:100%;display:inline-block}.wy-content-pdf .annotationLayer svg.quadrilateralsContainer{contain:strict;width:0;height:0;position:absolute;top:0;left:0;z-index:-1}:host{--xfa-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\");--xfa-focus-outline: auto}@media screen and (forced-colors:active){:host{--xfa-focus-outline: 2px solid CanvasText}.wy-content-pdf .xfaLayer *:required{outline:1.5px solid selectedItem}}.wy-content-pdf .xfaLayer{background-color:#0000}.wy-content-pdf .xfaLayer .highlight{margin:-1px;padding:1px;background-color:#efcbed;border-radius:4px}.wy-content-pdf .xfaLayer .highlight.appended{position:initial}.wy-content-pdf .xfaLayer .highlight.begin{border-radius:4px 0 0 4px}.wy-content-pdf .xfaLayer .highlight.end{border-radius:0 4px 4px 0}.wy-content-pdf .xfaLayer .highlight.middle{border-radius:0}.wy-content-pdf .xfaLayer .highlight.selected{background-color:#cbdfcb}.wy-content-pdf .xfaPage{overflow:hidden;position:relative}.wy-content-pdf .xfaContentarea{position:absolute}.wy-content-pdf .xfaPrintOnly{display:none}.wy-content-pdf .xfaLayer{position:absolute;text-align:initial;top:0;left:0;transform-origin:0 0;line-height:1.2}.wy-content-pdf .xfaLayer *{color:inherit;font:inherit;font-style:inherit;font-weight:inherit;font-kerning:inherit;letter-spacing:-.01px;text-align:inherit;text-decoration:inherit;box-sizing:border-box;background-color:#0000;padding:0;margin:0;pointer-events:auto;line-height:inherit}.wy-content-pdf .xfaLayer *:required{outline:1.5px solid red}.wy-content-pdf .xfaLayer div,.wy-content-pdf .xfaLayer svg,.wy-content-pdf .xfaLayer svg *{pointer-events:none}.wy-content-pdf .xfaLayer a{color:#00f}.wy-content-pdf .xfaRich li{margin-left:3em}.wy-content-pdf .xfaFont{color:#000;font-weight:400;font-kerning:none;font-size:10px;font-style:normal;letter-spacing:0;text-decoration:none;vertical-align:0}.wy-content-pdf .xfaCaption{overflow:hidden;flex:0 0 auto}.wy-content-pdf .xfaCaptionForCheckButton{overflow:hidden;flex:1 1 auto}.wy-content-pdf .xfaLabel{height:100%;width:100%}.wy-content-pdf .xfaLeft{display:flex;flex-direction:row;align-items:center}.wy-content-pdf .xfaRight{display:flex;flex-direction:row-reverse;align-items:center}.wy-content-pdf :is(.xfaLeft,.xfaRight)>:is(.xfaCaption,.xfaCaptionForCheckButton){max-height:100%}.wy-content-pdf .xfaTop{display:flex;flex-direction:column;align-items:flex-start}.wy-content-pdf .xfaBottom{display:flex;flex-direction:column-reverse;align-items:flex-start}.wy-content-pdf :is(.xfaTop,.xfaBottom)>:is(.xfaCaption,.xfaCaptionForCheckButton){width:100%}.wy-content-pdf .xfaBorder{background-color:#0000;position:absolute;pointer-events:none}.wy-content-pdf .xfaWrapped{width:100%;height:100%}.wy-content-pdf :is(.xfaTextfield,.xfaSelect):focus{background-image:none;background-color:#0000;outline:var(--xfa-focus-outline);outline-offset:-1px}.wy-content-pdf :is(.xfaCheckbox,.xfaRadio):focus{outline:var(--xfa-focus-outline)}.wy-content-pdf .xfaTextfield,.wy-content-pdf .xfaSelect{height:100%;width:100%;flex:1 1 auto;border:none;resize:none;background-image:var(--xfa-unfocused-field-background)}.wy-content-pdf .xfaSelect{padding-inline:2px}.wy-content-pdf :is(.xfaTop,.xfaBottom)>:is(.xfaTextfield,.xfaSelect){flex:0 1 auto}.wy-content-pdf .xfaButton{cursor:pointer;width:100%;height:100%;border:none;text-align:center}.wy-content-pdf .xfaLink{width:100%;height:100%;position:absolute;top:0;left:0}.wy-content-pdf .xfaCheckbox,.wy-content-pdf .xfaRadio{width:100%;height:100%;flex:0 0 auto;border:none}.wy-content-pdf .xfaRich{white-space:pre-wrap;width:100%;height:100%}.wy-content-pdf .xfaImage{object-position:left top;object-fit:contain;width:100%;height:100%}.wy-content-pdf .xfaLrTb,.wy-content-pdf .xfaRlTb,.wy-content-pdf .xfaTb{display:flex;flex-direction:column;align-items:stretch}.wy-content-pdf .xfaLr{display:flex;flex-direction:row;align-items:stretch}.wy-content-pdf .xfaRl{display:flex;flex-direction:row-reverse;align-items:stretch}.wy-content-pdf .xfaTb>div{justify-content:left}.wy-content-pdf .xfaPosition,.wy-content-pdf .xfaArea{position:relative}.wy-content-pdf .xfaValignMiddle{display:flex;align-items:center}.wy-content-pdf .xfaTable{display:flex;flex-direction:column;align-items:stretch}.wy-content-pdf .xfaTable .xfaRow{display:flex;flex-direction:row;align-items:stretch}.wy-content-pdf .xfaTable .xfaRlRow{display:flex;flex-direction:row-reverse;align-items:stretch;flex:1}.wy-content-pdf .xfaTable .xfaRlRow>div{flex:1}.wy-content-pdf :is(.xfaNonInteractive,.xfaDisabled,.xfaReadOnly) :is(input,textarea){background:initial}@media print{.wy-content-pdf .xfaTextfield,.wy-content-pdf .xfaSelect{background:#0000}.wy-content-pdf .xfaSelect{appearance:none;text-indent:1px;text-overflow:\"\"}}:host{--viewer-container-height: 0;--pdfViewer-padding-bottom: 0;--page-margin: 1px auto -8px;--page-border: 9px solid transparent;--spreadHorizontalWrapped-margin-LR: -3.5px;--loading-icon-delay: .4s}@media screen and (forced-colors:active){:host{--pdfViewer-padding-bottom: 9px;--page-margin: 8px auto -1px;--page-border: 1px solid CanvasText;--spreadHorizontalWrapped-margin-LR: 3.5px}}.wy-content-pdf [data-main-rotation=\"90\"]{transform:rotate(90deg) translateY(-100%)}.wy-content-pdf [data-main-rotation=\"180\"]{transform:rotate(180deg) translate(-100%,-100%)}.wy-content-pdf [data-main-rotation=\"270\"]{transform:rotate(270deg) translate(-100%)}.wy-content-pdf #hiddenCopyElement,.wy-content-pdf .hiddenCanvasElement{position:absolute;top:0;left:0;width:0;height:0;display:none}.wy-content-pdf .pdfViewer{--scale-factor: 1;--page-bg-color: unset;padding-bottom:var(--pdfViewer-padding-bottom);--hcm-highlight-filter: none;--hcm-highlight-selected-filter: none}@media screen and (forced-colors:active){.wy-content-pdf .pdfViewer{--hcm-highlight-filter: invert(100%)}}.wy-content-pdf .pdfViewer.copyAll{cursor:wait}.wy-content-pdf .pdfViewer .canvasWrapper{overflow:hidden;width:100%;height:100%}.wy-content-pdf .pdfViewer .canvasWrapper canvas{position:absolute;top:0;left:0;margin:0;display:block;width:100%;height:100%;contain:content}.wy-content-pdf .pdfViewer .canvasWrapper canvas .structTree{contain:strict}.wy-content-pdf .pdfViewer .page{--scale-round-x: 1px;--scale-round-y: 1px;direction:ltr;width:816px;height:1056px;margin:var(--page-margin);position:relative;overflow:visible;border:var(--page-border);background-clip:content-box;background-color:var(--page-bg-color, rgb(255, 255, 255))}.wy-content-pdf .pdfViewer .dummyPage{position:relative;width:0;height:var(--viewer-container-height)}.wy-content-pdf .pdfViewer.noUserSelect{-webkit-user-select:none;user-select:none}.wy-content-pdf .pdfViewer.removePageBorders .page{margin:0 auto 10px;border:none}.wy-content-pdf .pdfViewer.singlePageView{display:inline-block}.wy-content-pdf .pdfViewer.singlePageView .page{margin:0;border:none}.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped),.wy-content-pdf .spread{margin-inline:3.5px;text-align:center}.wy-content-pdf .pdfViewer.scrollHorizontal,.wy-content-pdf .spread{white-space:nowrap}.wy-content-pdf .pdfViewer.removePageBorders,.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) .spread{margin-inline:0}.wy-content-pdf .spread :is(.page,.dummyPage),.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) :is(.page,.spread){display:inline-block;vertical-align:middle}.wy-content-pdf .spread .page,.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) .page{margin-inline:var(--spreadHorizontalWrapped-margin-LR)}.wy-content-pdf .pdfViewer.removePageBorders .spread .page,.wy-content-pdf .pdfViewer.removePageBorders:is(.scrollHorizontal,.scrollWrapped) .page{margin-inline:5px}.wy-content-pdf .pdfViewer .page.loadingIcon:after{position:absolute;top:0;left:0;content:\"\";width:100%;height:100%;display:none;transition-property:display;transition-delay:var(--loading-icon-delay);z-index:5;contain:strict}.wy-content-pdf .pdfViewer .page.loading:after{display:block}.wy-content-pdf .pdfViewer .page:not(.loading):after{transition-property:none;display:none}.wy-content-pdf .pdfPresentationMode .pdfViewer{padding-bottom:0}.wy-content-pdf .pdfPresentationMode .spread{margin:0}.wy-content-pdf .pdfPresentationMode .pdfViewer .page{margin:0 auto;border:2px solid rgba(0,0,0,0)}.wy-content-pdf .pdfViewer .page{box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));background-color:var(--wy-white, var(--wy-white, #ffffff))}.wy-content-pdf .pdfViewer .page.loadingIcon:after{background:url(\"data:image/svg+xml,%3Csvg viewBox='0 0 24 24' width='24' height='24' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cstyle type='text/css'%3Eg%7Banimation:rotate 2s linear infinite;transform-origin:center center%7Dcircle%7Bstroke-dasharray:1,100;stroke-dashoffset:0;animation:dash 1.5s ease-in-out infinite,color 6s ease-in-out infinite%7D@keyframes rotate%7B100%25%7Btransform:rotate(360deg)%7D%7D@keyframes dash%7B0%25%7Bstroke-dasharray:1,100;stroke-dashoffset:0%7D50%25%7Bstroke-dasharray:44.5,100;stroke-dashoffset:-17.5px%7D100%25%7Bstroke-dasharray:44.5,100;stroke-dashoffset:-62px%7D%7D@keyframes color%7B0%25,100%25%7Bstroke:%23216eb4%7D40%25%7Bstroke:%2328b7cf%7D66%25%7Bstroke:%23216eb4%7D80%25,90%25%7Bstroke:%2328b7cf%7D%7D%3C/style%3E%3Cg%3E%3Ccircle fill='none' cx='12' cy='12' r='11' stroke-linecap='butt' stroke-width='2' /%3E%3C/g%3E%3C/svg%3E\") center no-repeat}.wy-pdf-page-number{width:calc(3*var(--wy-size, 1rem))}.wy-pdf-zoom-level{width:calc(5*var(--wy-size, 1rem))}`, nV = it`[part~=wy-toolbar]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));box-sizing:border-box;display:flex;flex-wrap:wrap;align-items:center;justify-content:flex-start;justify-items:center;min-height:var(--wy-toolbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));padding:calc(.5*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));flex:1 0 var(--wy-toolbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));column-gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));line-height:var(--wy-line-height, 1.5);background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-component-border-radius)}[part~=wy-toolbar-center]{margin:0 auto;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-toolbar-buttons]{display:flex;flex:0 0 auto;align-items:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));max-width:100%}[part~=wy-toolbar-buttons-last]{margin-inline-start:auto}[part~=wy-toolbar-text]{margin-left:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-toolbar-center-text]{text-align:center}[part~=wy-toolbars-bottom]{position:absolute;z-index:1030;bottom:calc(var(--wy-footerbar-height, calc(4 * var(--wy-size, 1rem)))/2);left:0;right:0;min-height:var(--wy-toolbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;justify-content:center;justify-items:center;box-sizing:border-box}`, Ea = it`[part~=wy-input]{--wy-component-background-color: var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border:var(--wy-input-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));margin:calc(-1*var(--wy-input-border-width, var(--wy-border, 1px)));display:block;max-width:100%;min-width:0;flex:1 1 auto;min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em))*1.5*var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*2 + var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))*2);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-input-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem))));background-clip:padding-box;appearance:none;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-input]:focus{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));color:var(--wy-component-color);border-color:var(--wy-primary, var(--wy-primary-light, #2f628c));outline:0}[part~=wy-input]::placeholder{color:var(--wy-outline, var(--wy-outline-light, #72777f));opacity:1}[part~=wy-input]:disabled{opacity:38%}[part~=wy-input]::file-selector-button,[part~=wy-input]::-webkit-file-upload-button{color:var(--wy-component-color);background-color:var(--wy-component-background-color);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));margin:calc(-1*var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) calc(-1*var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));margin-inline-end:var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));pointer-events:none;border-color:inherit;border-style:solid;border-width:0;border-inline-end-width:var(--wy-input-border-width, var(--wy-border, 1px));border-radius:0}[part~=wy-input]:hover:not(:disabled):not([readonly])::file-selector-button,[part~=wy-input]:hover:not(:disabled):not([readonly]) ::-webkit-file-upload-button{background-color:var(--wy-component-background-color)}[part~=wy-input][type=file]{overflow:hidden}[part~=wy-input][type=file]:not(:disabled):not([readonly]){cursor:pointer}[part~=wy-input]::-webkit-date-and-time-value{height:calc(var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem))))*1em)}[part~=wy-input][type=search]::-webkit-search-cancel-button{-webkit-appearance:none}[part~=wy-input-filled]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-input-filled-border-radius, var(--wy-border-radius-lg, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem)))));border-color:var(--wy-component-background-color)}[part~=wy-input-filled]:focus{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-label]{display:inline-block;font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));font-size:var(--wy-headings-font-size, var(--wy-font-size, 1em));font-style:var(--wy-headings-font-style, unset);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.5));margin-block:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-description]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));margin-top:calc(.25*var(--wy-size, 1rem))}[part~=wy-is-invalid],[part~=wy-is-invalid]:focus{border-color:var(--wy-error, var(--wy-error-light, #ba1821))}[part~=wy-invalid-feedback]{margin-top:calc(.25*var(--wy-size, 1rem));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));color:var(--wy-error, var(--wy-error-light, #ba1821))}[part~=wy-input-group]{position:relative;display:flex;gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));align-items:center;flex:1 0 auto}[part~=wy-input-group-button-icon]{--wy-component-background-color: transparent}[part~=wy-input-group-input-with-overlay]{padding-right:calc(var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) + var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}[part~=wy-input-group-button-icon-overlay]{position:absolute;display:inline-flex;top:0;right:0;z-index:4;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));--wy-component-background-color: transparent}[part~=wy-input-group-input]:placeholder-shown~[part~=wy-input-group-button-icon][type=reset]{display:none}[part~=wy-input-group-input]:not(:placeholder-shown)~[part~=wy-input-group-button-icon][type=reset]+[part~=wy-input-group-button-icon]{display:none}[part~=wy-no-result]{text-align:center;padding:calc(1*var(--wy-size, 1rem))}`;
var KG = Object.defineProperty, JG = Object.getOwnPropertyDescriptor, Jb = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? JG(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && KG(t, e, r), r;
}, "__decorateClass$O"), wx, am;
let Sl = (wx = (am = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.whenPdfjs = new Promise((t) => {
      this.whenPdfjsResolve = t;
    }), this.MAX_CANVAS_PIXELS = 0, this.TEXT_LAYER_MODE = 0, this.MAX_IMAGE_SIZE = -1, this.CMAP_PACKED = !0, this.DEFAULT_SCALE_DELTA = 1.1, this.MIN_SCALE = 0.25, this.MAX_SCALE = 10, this.DEFAULT_SCALE_VALUE = "auto", this.ENABLE_XFA = !0, this.DEFAULT_WORKER_URL = "/pdfjs/pdf.worker.min.mjs", this.DEFAULT_CMAPS_URL = "/pdfjs/cmaps/", this.pageNumberRef = $t(), this.totalPagesRef = $t(), this.zoomLevelRef = $t(), this.viewerContainerRef = $t(), this.resizer = new ResizeObserver(() => {
      this.pdfViewer && (this.delayedResize && (clearTimeout(this.delayedResize), this.delayedResize = void 0), this.delayedResize = window.setTimeout(() => {
        this.pdfViewer && (this.pdfViewer.currentScaleValue = this.pdfViewer._currentScaleValue);
      }, 100));
    });
  }
  /**
   * Emit `file-preview-loaded` once the viewer has initialized.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  ////////
  /**
   * Open the configured PDF source in the viewer.
   *
   * @internal
   */
  async open() {
    const { pdfjsLib: t } = await this.whenPdfjs;
    if (!this.pdfViewer || !this.pdfHistory || !this.l10n || !this.pdfLinkService)
      return;
    this.pdfLoadingTask && await this.close();
    const e = t.getDocument({
      url: this.src,
      maxImageSize: this.MAX_IMAGE_SIZE,
      enableXfa: this.ENABLE_XFA,
      cMapUrl: this.CMAP_URL?.toString() || "",
      cMapPacked: this.CMAP_PACKED
    });
    this.pdfLoadingTask = e, e.onProgress = (i) => {
    };
    try {
      const i = await e.promise;
      this.pdfDocument = i, this.pdfViewer.setDocument(i), this.pdfLinkService.setDocument(i), this.pdfHistory.initialize({
        // @ts-expect-error Type 'string | null' is not assignable to type 'string'.
        fingerprint: i.fingerprints[0]
      });
    } catch (i) {
      let r = "pdfjs-loading-error";
      i instanceof t.InvalidPDFException ? r = "pdfjs-invalid-file-error" : i instanceof t.MissingPDFException ? r = "pdfjs-missing-file-error" : i instanceof t.UnexpectedResponseException && (r = "pdfjs-unexpected-response-error"), await this.l10n.get(r, void 0, void 0).then((n) => {
        this.pdfViewError(t, n, { message: i?.message });
      });
    }
    this.dispatchLoaded();
  }
  /**
   * Close any currently loaded PDF and release resources.
   *
   * @internal
   */
  async close() {
    if (!this.pdfLoadingTask)
      return Promise.resolve();
    const t = this.pdfLoadingTask.destroy();
    return this.pdfLoadingTask = void 0, this.pdfDocument && (this.pdfDocument = void 0, this.pdfViewer?.setDocument(null), this.pdfLinkService?.setDocument(null, null), this.pdfHistory && this.pdfHistory.reset()), await t;
  }
  /**
   * Log a pdf.js related error with contextual metadata.
   *
   * @internal
   * @param pdfjsLib - pdf.js core library.
   * @param message - Human readable error.
   * @param moreInfo - Additional error metadata.
   */
  pdfViewError(t, e, i) {
    const r = [`PDF.js v${t?.version || "?"} (build: ${t?.build || "?"})`];
    i && (r.push(`Message: ${i.message}`), i.stack ? r.push(`Stack: ${i.stack}`) : (i.filename && r.push(`File: ${i.filename}`), i.lineNumber && r.push(`Line: ${i.lineNumber}`))), console.error(`${e}

${r.join(`
`)}`);
  }
  ///////
  /**
   * Navigate to the provided page number.
   *
   * @param pageNumber - One-based page index.
   */
  setPage(t) {
    this.pdfViewer && (this.pdfViewer.currentPageNumber = t);
  }
  /**
   * Increase zoom level by the configured delta.
   *
   * @param ticks - Number of zoom steps to apply.
   */
  zoomIn(t = 0) {
    if (this.pdfViewer) {
      let e = this.pdfViewer.currentScale;
      do
        e = parseFloat((e * this.DEFAULT_SCALE_DELTA).toFixed(2)), e = Math.ceil(e * 10) / 10, e = Math.min(this.MAX_SCALE, e);
      while (--t && e < this.MAX_SCALE);
      this.pdfViewer.currentScaleValue = e.toFixed(2);
    }
  }
  /**
   * Decrease zoom level by the configured delta.
   *
   * @param ticks - Number of zoom steps to apply.
   */
  zoomOut(t = 0) {
    if (this.pdfViewer) {
      let e = this.pdfViewer.currentScale;
      do
        e = parseFloat((e / this.DEFAULT_SCALE_DELTA).toFixed(2)), e = Math.floor(e * 10) / 10, e = Math.max(this.MIN_SCALE, e);
      while (--t && e > this.MIN_SCALE);
      this.pdfViewer.currentScaleValue = e.toFixed(2);
    }
  }
  /**
   * Apply an absolute zoom level or named scale preset.
   *
   * @param scale - Numeric zoom or preset name.
   */
  setScale(t) {
    this.pdfViewer && (this.pdfViewer.currentScaleValue = typeof t == "number" ? t.toFixed(2) : t);
  }
  /**
   * Validate and update the current page based on the input value.
   */
  updatePage() {
    if (this.pdfViewer && this.pageNumberRef.value) {
      const t = parseInt(this.pageNumberRef.value.value);
      isNaN(t) ? this.setPage(this.pdfViewer.currentPageNumber) : t > this.pdfViewer.pagesCount ? this.setPage(this.pdfViewer.pagesCount) : t <= 0 ? this.setPage(1) : this.setPage(t);
    }
  }
  /**
   * Select all text inside an input, aiding quick replacement.
   *
   * @param e - Input focus event.
   */
  select(t) {
    const e = t.target;
    e && e.setSelectionRange(0, e.value.length);
  }
  /**
   * Fit the PDF to the current viewport height.
   */
  fitToPage() {
    this.setScale("page-fit");
  }
  /**
   * Fit the PDF to the current viewport width.
   */
  fitToWidth() {
    this.setScale("page-width");
  }
  /**
   * Validate and persist zoom level from the input field.
   */
  updateZoom() {
    if (this.pdfViewer && this.zoomLevelRef.value) {
      const t = parseFloat(this.zoomLevelRef.value.value.replace("%", ""));
      isNaN(t) ? this.setScale(this.pdfViewer.currentScale + 1e-4) : this.setScale(t / 100);
    }
  }
  // clearDocument() {
  //   try {
  //     this.loadingTask?.destroy();
  //     //console.debug("loadingTask cleanup", loadingTask)
  //   } catch (e) {
  //     /* No worries */
  //   }
  //   try {
  //     // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  //     // @ts-ignore due to incorrect param type def?
  //     this.pdfViewer?.setDocument(null);
  //   } catch (e) {
  //     /* No worries */
  //   }
  //   try {
  //     this.pdfLinkService.setDocument(null, null);
  //   } catch (e) {
  //     /* No worries */
  //   }
  // }
  async willUpdate(t) {
    super.willUpdate(t), t.has("weavy") && this.weavy && (this.pdfjsLib || (await this.weavy.whenUrl(), this.pdfjsLib = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL("./es/pdfjs-dist/build/pdf.mjs-Bhye_tXX.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
    ), globalThis.pdfjsLib = this.pdfjsLib, this.pdfjsViewer = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL("./es/pdfjs-dist/web/pdf_viewer.mjs-bp-6p92T.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
    ), this.whenPdfjsResolve?.({
      pdfjsLib: this.pdfjsLib,
      pdfjsViewer: this.pdfjsViewer
    })), this.pdfjsLib && !this.WORKER_URL && (this.WORKER_URL = zS(this.DEFAULT_WORKER_URL, import.meta.url), this.WORKER_URL.searchParams.append("v", this.weavy.version), this.pdfjsLib.GlobalWorkerOptions.workerSrc = this.WORKER_URL.toString()), this.CMAP_URL || (this.CMAP_URL = zS(this.DEFAULT_CMAPS_URL, import.meta.url)));
  }
  update(t) {
    super.update(t), (t.has("weavy") || t.has("src") || t.has("pdfViewer")) && this.weavy && this.src && this.pdfViewer && this.open();
  }
  async updated() {
    if (this.weavy && this.viewerContainerRef.value && !this.pdfViewer) {
      const { pdfjsLib: t, pdfjsViewer: e } = await this.whenPdfjs;
      this.viewerContainerRef.value && !this.pdfViewer && (this.pdfEventBus = new e.EventBus(), this.pdfLinkService = new e.PDFLinkService({
        eventBus: this.pdfEventBus
      }), this.l10n = new e.GenericL10n(this.weavy?.locale), this.pdfViewer = new e.PDFViewer({
        container: this.viewerContainerRef.value,
        eventBus: this.pdfEventBus,
        linkService: this.pdfLinkService,
        //findController: this.pdfFindController,
        annotationEditorMode: t.AnnotationEditorType.DISABLE,
        l10n: this.l10n,
        maxCanvasPixels: this.MAX_CANVAS_PIXELS,
        textLayerMode: this.TEXT_LAYER_MODE
      }), this.pdfLinkService?.setViewer(this.pdfViewer), this.pdfHistory = new e.PDFHistory({
        eventBus: this.pdfEventBus,
        linkService: this.pdfLinkService
      }), this.pdfLinkService?.setHistory(this.pdfHistory), this.pdfEventBus?.on("scalechanging", () => {
        this.zoomLevelRef.value && this.pdfViewer ? this.zoomLevelRef.value.value = Math.round(this.pdfViewer.currentScale * 100).toFixed(0) + "%" : console.warn("Could not set zoom level");
      }), this.pdfEventBus?.on("pagechanging", () => {
        this.pageNumberRef.value && this.pdfViewer ? this.pageNumberRef.value.value = this.pdfViewer.currentPageNumber.toFixed(0) : console.warn("Could not set page number");
      }), this.pdfEventBus?.on("pagesinit", () => {
        this.isConnected && this.pdfViewer && this.pageNumberRef.value && this.totalPagesRef.value ? (this.pdfViewer.currentScaleValue = this.DEFAULT_SCALE_VALUE, this.pageNumberRef.value.value = "1", this.totalPagesRef.value.innerText = this.pdfViewer.pagesCount.toFixed(0), this.resizer.observe(this.pdfViewer.container)) : console.warn("Could not init pdf page");
      }));
    }
  }
  render() {
    return v`
      <div class="wy-content-pdf">
        <div part="wy-toolbars-bottom">
          <nav part="wy-toolbar wy-toolbar-center">
            <div part="wy-toolbar-buttons">
              <input
                type="text"
                part="wy-input wy-toolbar-center-text"
                class="wy-pdf-page-number"
                ${ht(this.pageNumberRef)}
                @keydown=${Yw}
                @keyup=${nn}
                @change=${() => this.updatePage()}
                @click=${(t) => this.select(t)}
              />
              <span part="wy-toolbar-text">/</span>
              <span part="wy-toolbar-text" ${ht(this.totalPagesRef)}>1</span>
            </div>
            <div part="wy-toolbar-buttons">
              <wy-button kind="icon" class="btn-zoom-out" @click=${() => this.zoomOut()} title=${P("Zoom out")}>
                <wy-icon name="minus"></wy-icon>
              </wy-button>
              <input
                type="text"
                part="wy-input"
                class="wy-pdf-zoom-level"
                ${ht(this.zoomLevelRef)}
                @keydown=${Yw}
                @keyup=${nn}
                @change=${() => this.updateZoom()}
                @click=${(t) => this.select(t)}
                value="100%"
              />
              <wy-button kind="icon" class="btn-zoom-in" @click=${() => this.zoomIn()} title=${P("Zoom in")}>
                <wy-icon name="plus"></wy-icon>
              </wy-button>
            </div>
            <div part="wy-toolbar-buttons">
              <wy-button kind="icon" class="btn-fit-page" @click=${() => this.fitToWidth()} title=${P("Fit to width")}>
                <wy-icon name="fit-width"></wy-icon>
              </wy-button>
              <wy-button kind="icon" @click=${() => this.fitToPage()} title=${P("Fit to screen")}>
                <wy-icon name="fit-screen"></wy-icon>
              </wy-button>
            </div>
          </nav>
        </div>
        <div ${ht(this.viewerContainerRef)} class="wy-pdf-container">
          <div class="pdfViewer"></div>
        </div>
      </div>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.pdfViewer && this.resizer.observe(this.pdfViewer.container);
  }
  disconnectedCallback() {
    this.resizer.unobserve(this);
    try {
      this.close(), this.pdfViewer?.cleanup();
    } catch {
    }
    this.pdfViewer = void 0, super.disconnectedCallback();
  }
}, h(am, "ko"), am), c(wx, "WyPdfViewer"), wx);
Sl.styles = [
  GG,
  nV,
  Ea,
  ft
];
Jb([
  Xe({ context: De, subscribe: !0 }),
  N()
], Sl.prototype, "weavy", 2);
Jb([
  b()
], Sl.prototype, "src", 2);
Jb([
  N()
], Sl.prototype, "pdfViewer", 2);
Sl = Jb([
  Y("wy-pdf-viewer"),
  At()
], Sl);
var tK = Object.defineProperty, eK = Object.getOwnPropertyDescriptor, i3 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? eK(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && tK(t, e, r), r;
}, "__decorateClass$N"), vx, om;
let Qy = (vx = (om = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.current = !1;
  }
  /**
   * Emits the `file-preview-loaded` event when the preview has finished loading.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  render() {
    const t = this.file;
    if (!t) return C;
    const { icon: e } = wn(t.name), i = dr(t.name);
    let r = t.preview_url || t.download_url || "";
    t.preview_format === "image" && (i === ".gif" || i === ".svg") && (r = t.download_url || "");
    const n = r, a = t.external_url, o = t.is_trashed ? "none" : t.preview_format, l = t.name, d = t.width, u = t.height, p = t.media_type, f = t.provider;
    return o === "image" ? v`<wy-preview-image
        src=${n}
        width=${St(d)}
        height=${St(u)}
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-image>` : o === "pdf" ? v`<wy-pdf-viewer src=${n} @file-preview-loaded=${() => this.dispatchLoaded()}></wy-pdf-viewer>` : o === "video" || o === "audio" ? v`<wy-preview-media
        format=${o}
        src=${n}
        name=${l}
        mediaType=${p}
        ?play=${this.current}
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-media>` : o === "text" ? v`<wy-preview-text src=${n} @file-preview-loaded=${() => this.dispatchLoaded()}></wy-preview-text>` : o === "code" ? v`<wy-preview-text
        src=${n}
        ?html=${!/^(?:blob:|data:)/.test(n)}
        code
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-text>` : o === "html" ? v`<wy-preview-text
        src=${n}
        html
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-text>` : o === "embed" ? v`<wy-preview-embed
        src=${n}
        name=${l}
        icon=${e}
        provider=${St(f)}
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-embed>` : o === "none" ? a ? v`<wy-preview-icon
            src=${a}
            icon=${e}
            provider=${St(f)}
            @file-preview-loaded=${() => this.dispatchLoaded()}
          ></wy-preview-icon>` : v`<wy-preview-icon
            src=${n}
            icon=${e}
            @file-preview-loaded=${() => this.dispatchLoaded()}
          ></wy-preview-icon>` : C;
  }
}, h(om, "Po"), om), c(vx, "WyPreviewItem"), vx);
Qy.styles = [ft];
i3([
  b({ type: Object })
], Qy.prototype, "file", 2);
i3([
  b({ type: Boolean })
], Qy.prototype, "current", 2);
Qy = i3([
  Y("wy-preview-item")
], Qy);
var iK = Object.defineProperty, rK = Object.getOwnPropertyDescriptor, Z1 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? rK(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && iK(t, e, r), r;
}, "__decorateClass$M"), Ox, lm;
let Cl = (Ox = (lm = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.small = !1, this.hasEventListener = {
      "edit-name": !1,
      subscribe: !1,
      trash: !1,
      restore: !1,
      "delete-forever": !1
    };
  }
  addEventListener(t, e, i) {
    if (this.hasEventListener) {
      const r = t;
      Object.prototype.hasOwnProperty.call(this.hasEventListener, r) && Object.assign(this.hasEventListener, {
        [r]: !0
      });
    }
    super.addEventListener(t, e, i);
  }
  /**
   * Open download URL for the current file.
   * @internal
   */
  triggerDownload() {
    this.file && ps(this.file.download_url, "_top", this.file.name, !0);
  }
  /**
   * Open external provider URL for the current file.
   * @internal
   */
  triggerExternal() {
    this.file && ps(this.file.external_url, "_blank", this.file.name);
  }
  /**
   * Open application-specific URL for the current file.
   * @internal
   */
  triggerApplication() {
    this.file && ps(this.file.application_url, "_top", this.file.name);
  }
  /**
   * Emit an `edit-name` event for the current file.
   * @internal
   */
  dispatchEditName() {
    const t = new CustomEvent("edit-name", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `subscribe` event toggling subscription state.
   *
   * @internal
   * @param subscribe - Desired subscription setting.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", {
      detail: {
        file: this.file,
        subscribe: t
      }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `trash` event for the current file.
   * @internal
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `restore` event for the current file.
   * @internal
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `delete-forever` event for the current file.
   * @internal
   */
  dispatchDeleteForever() {
    const t = new CustomEvent("delete-forever", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  render() {
    if (!this.file)
      return C;
    const { icon: t } = wn(this.file.name), e = this.file.id >= 1, i = this.file.provider, r = this.file.provider || "app";
    return v`
      <wy-dropdown directionX="left" ?small=${this.small}>
        ${e && this.file.is_trashed ? v`
              ${this.hasEventListener.restore ? v`
                    <wy-dropdown-item @click=${() => this.dispatchRestore()}>
                      <wy-icon name="delete-restore"></wy-icon>
                      ${P("Restore")}
                    </wy-dropdown-item>
                  ` : C}
              ${this.hasEventListener.restore && this.hasEventListener["delete-forever"] ? v` <wy-dropdown-divider></wy-dropdown-divider> ` : C}
              ${this.hasEventListener["delete-forever"] ? v`
                    <wy-dropdown-item @click=${() => this.dispatchDeleteForever()}>
                      <wy-icon name="delete-forever"></wy-icon>
                      ${P("Delete")}
                    </wy-dropdown-item>
                  ` : C}
            ` : C}
        ${this.file.is_trashed ? C : v`
              ${this.file.external_url ? v`
                    <wy-dropdown-item @click=${() => this.triggerExternal()}>
                      <wy-icon name=${t}></wy-icon>
                      ${P(lt`Open in ${i}`)}
                    </wy-dropdown-item>
                  ` : v`
                    ${this.componentFeatures?.allowsFeature(L.WebDAV) && this.file.application_url ? v`
                          <wy-dropdown-item @click=${() => this.triggerApplication()}>
                            <wy-icon
                              name=${this.file.provider ? WP(this.file.provider) : t}
                            ></wy-icon>
                            ${P(lt`Open in ${r}`)}
                          </wy-dropdown-item>
                        ` : C}
                    <wy-dropdown-item @click=${() => this.triggerDownload()}>
                      <wy-icon name="download"></wy-icon>
                      ${P("Download")}
                    </wy-dropdown-item>
                  `}
              ${e ? v`
                    ${this.hasEventListener["edit-name"] ? v`
                          <wy-dropdown-item @click=${() => this.dispatchEditName()}>
                            <wy-icon name="textbox"></wy-icon>
                            ${P("Rename")}
                          </wy-dropdown-item>
                        ` : C}
                    ${this.hasEventListener.subscribe ? this.file.is_subscribed ? v`
                            <wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                              <wy-icon name="bell-off"></wy-icon>
                              ${P("Unsubscribe")}
                            </wy-dropdown-item>
                          ` : v`
                            <wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                              <wy-icon name="bell"></wy-icon>
                              ${P("Subscribe")}
                            </wy-dropdown-item>
                          ` : C}
                    ${this.hasEventListener.trash ? v`
                          <wy-dropdown-divider></wy-dropdown-divider>
                          <wy-dropdown-item @click=${() => this.dispatchTrash()}>
                            <wy-icon name="delete"></wy-icon>
                            ${P("Trash")}
                          </wy-dropdown-item>
                        ` : C}
                  ` : C}
            `}
        <slot></slot>
      </wy-dropdown>
    `;
  }
}, h(lm, "_o"), lm), c(Ox, "WyFileMenu"), Ox);
Z1([
  Xe({ context: Sb, subscribe: !0 }),
  N()
], Cl.prototype, "componentFeatures", 2);
Z1([
  b({ type: Object })
], Cl.prototype, "file", 2);
Z1([
  b({ type: Boolean })
], Cl.prototype, "small", 2);
Z1([
  b({ type: Object })
], Cl.prototype, "hasEventListener", 2);
Cl = Z1([
  Y("wy-file-menu"),
  At()
], Cl);
function aV(s, t, e, i = {}) {
  return {
    ...i,
    initialPageParam: 0,
    queryKey: [t, e, "comments"],
    queryFn: /* @__PURE__ */ c(async (r) => {
      const n = r.pageParam, a = "/api/" + t + "/" + e + "/comments?order_by=id&skip=" + n, o = await (await s.fetch(a)).json();
      return o.data = o.data || [], o;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ c((r) => {
      if (r.end && r.end < r.count)
        return r.end;
    }, "getNextPageParam")
  };
}
h(aV, "O4");
c(aV, "getCommentsOptions");
function oV(s, t) {
  return {
    mutationFn: /* @__PURE__ */ c(async (e) => await (await s.fetch("/api/comments/" + e.id, {
      method: "PATCH",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        attachments: e.attachments,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ id: i.id, text: i.text })),
        embed_id: e.embed_id || null
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onSuccess: /* @__PURE__ */ c((e, i) => {
      i.id && ke(s.queryClient, [i.type, i.parent_id, "comments"], i.id, (r) => {
        r.text = e.text, r.html = e.html, r.attachments = e.attachments, r.meeting = e.meeting, r.updated_at = e.updated_at, r.updated_by = e.updated_by, r.options = e.options, r.embed = e.embed;
      });
    }, "onSuccess")
  };
}
h(oV, "z4");
c(oV, "getUpdateCommentMutationOptions");
function lV(s) {
  const t = s.queryClient;
  return {
    mutationFn: /* @__PURE__ */ c(async (e) => await (await s.fetch("/api/" + e.type + "/" + e.parent_id + "/comments", {
      method: "POST",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ text: i.text })),
        embed_id: e.embed_id,
        context: e.context
      })
    })).json(), "mutationFn"),
    onMutate: /* @__PURE__ */ c(async (e) => {
      const i = [e.type, e.parent_id, "comments"];
      await t.cancelQueries({ queryKey: i });
      const r = ga(s.queryClient, i, !1);
      if (e.user) {
        const n = {
          id: r ? r.id - 1 : -1,
          app: e.type === "apps" ? { id: e.parent_id } : { id: -1 },
          is_trashed: !1,
          text: e.text,
          html: e.text,
          plain: e.text,
          created_by: e.user,
          created_at: (/* @__PURE__ */ new Date()).toUTCString(),
          attachments: { count: 0 },
          reactions: { count: 0 },
          is_subscribed: !1,
          is_starred: !1
        };
        e.type === "files" ? n.parent = { type: vi.File, id: e.parent_id } : e.type === "posts" && (n.parent = { type: vi.Post, id: e.parent_id }), ya(t, i, n, { descending: !1 });
      }
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((e, i) => {
      const r = [i.type, e.parent?.id ?? e.app.id, "comments"];
      if (!T1(s.queryClient, r, e.id)) {
        const n = ga(s.queryClient, r, !0);
        n ? ke(s.queryClient, r, n.id, (a) => {
          a.id = e.id, a.app = e.app, a.text = e.text, a.html = e.html, a.embed = e.embed, a.meeting = e.meeting, a.attachments = e.attachments, a.options = e.options, a.created_at = e.created_at, a.created_by = e.created_by, a.updated_at = e.updated_at, a.updated_by = e.updated_by;
        }) : ya(s.queryClient, r, e), e.parent?.type === vi.Post && ke(t, ["posts", e.app.id], e.parent.id, (a) => {
          a.comments ? a.comments.count += 1 : a.comments = { count: 1 };
        });
      }
    }, "onSuccess")
  };
}
h(lV, "I4");
c(lV, "getAddCommentMutationOptions");
function cV(s, t, e) {
  const i = s.queryClient, r = {
    mutationKey: [t, e, "comments"],
    mutationFn: /* @__PURE__ */ c(async ({ id: n }) => {
      if (!(await s.fetch("/api/comments/" + n + "/trash", { method: "POST" })).ok)
        throw new Error();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((n) => {
      Rt(
        i,
        { queryKey: r.mutationKey, exact: !1 },
        n.id,
        (a) => Object.assign(a, { is_trashed: !0 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((n, a) => {
      Rt(
        i,
        { queryKey: r.mutationKey, exact: !1 },
        a.id,
        (o) => Object.assign(o, n)
      ), ke(i, [a.type, a.appId], a.parentId, (o) => {
        o.comments.count -= 1;
      });
    }, "onSuccess")
  };
  return r;
}
h(cV, "F4");
c(cV, "getTrashCommentMutationOptions");
function hV(s, t, e) {
  return new Yt(s.queryClient, cV(s, t, e));
}
h(hV, "D4");
c(hV, "getTrashCommentMutation");
function dV(s, t, e) {
  const i = s.queryClient, r = {
    mutationKey: [t, e, "comments"],
    mutationFn: /* @__PURE__ */ c(async ({ id: n }) => {
      const a = await s.fetch("/api/comments/" + n + "/restore", { method: "POST" });
      if (!a.ok) {
        const o = await a.json();
        throw new Error(o.detail || o.title, { cause: o });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((n) => {
      Rt(
        i,
        { queryKey: r.mutationKey, exact: !1 },
        n.id,
        (a) => Object.assign(a, { is_trashed: !1 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((n, a) => {
      Rt(
        i,
        { queryKey: r.mutationKey, exact: !1 },
        a.id,
        (o) => Object.assign(o, n)
      ), ke(i, [a.type, a.appId], a.parentId, (o) => {
        o.comments.count += 1;
      });
    }, "onSuccess")
  };
  return r;
}
h(dV, "V4");
c(dV, "getRestoreCommentMutationOptions");
function uV(s, t, e) {
  return new Yt(s.queryClient, dV(s, t, e));
}
h(uV, "H4");
c(uV, "getRestoreCommentMutation");
const r3 = it`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}:host(wy-comments){--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-border-radius: var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-comment-list-padded]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-comments]{display:flex;flex-direction:column}[part~=wy-comment]{display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));margin-bottom:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-comment][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-comment-reveal]{interpolate-size:allow-keywords;overflow:hidden;transition:height var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),margin-bottom var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-duration-fast, .1s);height:auto;opacity:1}@starting-style{[part~=wy-comment-reveal]{height:0;margin-bottom:0;opacity:0}}[part~=wy-comment-skeleton]{transition-delay:var(--wy-transition-reveal-delay, 1s)}[part~=wy-comment-body]{display:flex;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));min-width:0;flex:1 1 100%}[part~=wy-comment-footer]{margin-left:calc(-1*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));margin-top:calc(-1*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}::part(wy-trashed){text-decoration:line-through;color:var(--wy-outline, var(--wy-outline-light, #72777f))}wy-comment::part(wy-editor){padding-left:0;padding-right:0;margin-right:calc(-1*var(--wy-size, 1rem))}`, sK = 1e3 * 60 * 60, bx = sK * 24;
function Hl(s, t, e, i = 7) {
  e ??= /* @__PURE__ */ new Date();
  const r = new Date(e.getFullYear(), e.getMonth(), e.getDate()), n = t.valueOf() - e.valueOf(), a = t.toDateString() === e.toDateString(), o = t.valueOf() > r.valueOf() - bx * i && t.valueOf() < r.valueOf() + bx * i;
  if (!a && o) {
    const l = Math.round(n / bx);
    return new Intl.RelativeTimeFormat(s, { numeric: "auto" }).format(l, "days");
  } else return a ? new Intl.DateTimeFormat(s, { timeStyle: "short" }).format(t) : new Intl.DateTimeFormat(s, { dateStyle: "short" }).format(t);
}
h(Hl, "tl");
c(Hl, "relativeTime");
const pV = it`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}`;
var nK = Object.defineProperty, aK = Object.getOwnPropertyDescriptor, Yl = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? aK(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && nK(t, e, r), r;
}, "__decorateClass$L"), $x, cm;
let vs = ($x = (cm = class extends Pe {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.location = "apps", this.highlight = !1, this.reveal = !1, this.editing = !1, this.previewAnnotationsRef = $t(), this.previewAttachmentsRef = $t(), this.highlightRef = $t(), this.updateCommentMutation = new Wr(this);
  }
  /**
   * Dispatch a poll vote event for this comment.
   *
   * @internal
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", {
      detail: { optionId: t, parentId: this.comment.id, parentType: "comments" }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Dispatch a trash event for this comment.
   *
   * @internal
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.comment.id } });
    return this.dispatchEvent(t);
  }
  /**
   * Dispatch a restore event for this comment.
   *
   * @internal
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", {
      detail: { id: this.comment.id }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Submit updated comment content via mutation and exit edit mode.
   *
   * @internal
   */
  updateComment(t) {
    this.updateCommentMutation.mutate({
      id: this.comment.id,
      type: this.location,
      parent_id: this.parentId,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      attachments: t.detail.attachments,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId
    }), this.editing = !1;
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("parentId") || t.has("weavy")) && this.parentId && this.weavy && await this.updateCommentMutation.trackMutation(
      oV(this.weavy, [this.location, this.parentId, "comments"])
    ), t.has("link") && (this.highlight = !!(this.link && D1(this.link, vi.Comment, { id: this.comment.id }))), t.has("highlight") && (this.highlight ? this.part.add("wy-highlight") : this.part.remove("wy-highlight"));
  }
  render() {
    const t = this.comment.attachments?.data?.filter((a) => a.kind === "image" && a.thumbnail_url) || [], e = this.comment.attachments?.data?.filter((a) => a.kind !== "image" || !a.thumbnail_url) || [], i = new Intl.DateTimeFormat(this.weavy?.locale, {
      dateStyle: "full",
      timeStyle: "short"
    }).format(new Date(this.comment.created_at)), r = Hl(this.weavy?.locale, new Date(this.comment.created_at)), n = this.comment.id < 0;
    return v`
      <div part="wy-comment ${gt({ "wy-comment-reveal": this.reveal, "wy-comment-skeleton": n })}">
        ${n ? v`
              <wy-item align="top" part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src="${this.comment.created_by.avatar_url}"
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>
                <div slot="content" part="wy-comment-body">
                  <div part="wy-comment-title">
                    ${this.comment.created_by.name}
                    <small part="wy-meta">
                      ·
                      <time datetime=${this.comment.created_at} title=${i}>${r}</time>
                      ${this.comment.updated_at ? v`<time datetime=${this.comment.updated_at}> · ${P("edited")}</time>` : C}
                    </small>
                  </div>
                  ${this.comment.html ? v`<div part="wy-content"><wy-skeleton .text=${this.comment.text}></wy-skeleton></div>` : ""}
                </div>
              </wy-item>
            ` : this.comment.is_trashed ? v`
              <wy-item part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src="${this.comment.created_by.avatar_url}"
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>
                <span part="wy-trashed" slot="title">${P("Comment was trashed.")}</span>
                <wy-button small slot="actions" @click=${() => this.dispatchRestore()} color="variant"
                  >${P("Undo")}</wy-button
                >
              </wy-item>
            ` : this.editing ? v`
              <wy-item align="top" part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src="${this.comment.created_by.avatar_url}"
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>
                <wy-button small slot="actions" @click=${() => this.editing = !1} kind="icon">
                  <wy-icon name="close"></wy-icon>
                </wy-button>
                <div slot="content" part="wy-comment-body">
                  <div part="wy-comment-title">
                    ${this.comment.created_by.name}

                    <small part="wy-meta">
                      ·
                      <time datetime=${this.comment.created_at} title=${i}>${r}</time>
                    </small>
                  </div>
                  <wy-editor
                    editorLocation=${this.location}
                    .text=${this.comment.text}
                    .embed=${this.comment.embed}
                    .options=${this.comment.options?.data}
                    .attachments=${this.comment.attachments?.data ?? []}
                    .parentId=${this.comment.id}
                    .typing=${!1}
                    .draft=${!1}
                    placeholder=${P("Edit comment...")}
                    buttonText=${P("Update", { desc: "Button action to update" })}
                    @submit=${(a) => this.updateComment(a)}
                  ></wy-editor>
                </div>
              </wy-item>
            ` : v`
              <wy-item align="top" part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src=${this.comment.created_by.avatar_url}
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>

                ${this.user && this.user.id === this.comment.created_by.id ? v`
                      <wy-dropdown small slot="actions">
                        ${this.user.id === this.comment.created_by.id ? v`
                              <wy-dropdown-item @click=${() => this.editing = !0}>
                                <wy-icon name="pencil"></wy-icon>
                                ${P("Edit")}
                              </wy-dropdown-item>
                            ` : C}
                        ${this.user.id === this.comment.created_by.id ? v`
                              <wy-dropdown-item @click=${() => this.dispatchTrash()}>
                                <wy-icon name="trashcan"></wy-icon>
                                ${P("Trash")}
                              </wy-dropdown-item>
                            ` : C}
                      </wy-dropdown>
                    ` : C}

                <div slot="content" part="wy-comment-body">
                  <div part="wy-comment-title">
                    ${this.comment.created_by.name}
                    <small part="wy-meta">
                      ·
                      <time datetime=${this.comment.created_at} title=${i}>${r}</time>
                      ${this.comment.updated_at ? v`<time datetime=${this.comment.updated_at}> · ${P("edited")}</time>` : C}
                    </small>
                  </div>

                  <!-- image grid -->
                  ${t && t.length ? v`<wy-image-grid
                        part="wy-comment-images"
                        .images=${t}
                        @file-open=${(a) => {
      this.previewAttachmentsRef.value?.open(a.detail.fileId);
    }}
                      ></wy-image-grid>` : ""}

                  <!-- text content -->
                  ${this.comment.html ? v`<div part="wy-content">${gl(this.comment.html)}</div>` : ""}

                  <!-- annotations -->
                  ${this.comment.annotations?.data?.length ? v`<wy-annotation-list
                        .files=${this.comment.annotations.data}
                        @file-open=${(a) => {
      this.previewAnnotationsRef.value?.open(a.detail.fileId);
    }}
                      ></wy-annotation-list>` : C}

                  <!-- poll -->
                  ${this.comment.options?.data?.length ? v`
                        <wy-poll
                          .pollOptions=${this.comment.options.data}
                          @vote=${(a) => this.dispatchVote(a.detail.optionId)}
                        ></wy-poll>
                      ` : C}

                  <!-- embeds -->
                  ${this.comment.embed && this.componentFeatures?.allowsFeature(L.Embeds) ? v` <wy-embed .embed=${this.comment.embed}></wy-embed> ` : C}

                  <!-- files -->
                  ${e.length ? v`<wy-attachment-list
                        filled
                        .files=${e ?? []}
                        @file-open=${(a) => {
      this.previewAttachmentsRef.value?.open(a.detail.fileId);
    }}
                      ></wy-attachment-list>` : ""}

                  <!-- meeting -->
                  ${this.comment.meeting ? v`<wy-meeting-card .meeting=${this.comment.meeting}></wy-meeting-card>` : ""}

                  <div part="wy-comment-footer">
                    ${this.componentFeatures?.allowsFeature(L.Reactions) ? v` <wy-reactions
                          lineReverse
                          small
                          .reactions=${this.comment.reactions?.data}
                          parentType=${this.location}
                          parentId=${this.parentId}
                          entityId=${this.comment.id}
                          entityType="comments"
                        ></wy-reactions>` : C}
                    ${this.comment.annotations?.data?.length ? v`<wy-preview
                          ${ht(this.previewAnnotationsRef)}
                          .files=${this.comment.annotations.data}
                          .isAttachment=${!0}
                        ></wy-preview> ` : C}
                    ${this.comment.attachments?.data?.length ? v`<wy-preview
                          ${ht(this.previewAttachmentsRef)}
                          .files=${[...t, ...e]}
                          .isAttachment=${!0}
                        ></wy-preview> ` : C}
                  </div>
                </div>
              </wy-item>
            `}
      </div>
    `;
  }
  updated(t) {
    t.has("highlight") && this.highlight && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, h(cm, "So"), cm), c($x, "WyComment"), $x);
vs.styles = [pe, r3, By, pV, K4, ft];
Yl([
  b({ type: Object, attribute: !1 })
], vs.prototype, "comment", 2);
Yl([
  b({ type: Number })
], vs.prototype, "parentId", 2);
Yl([
  b({ attribute: !1 })
], vs.prototype, "location", 2);
Yl([
  N()
], vs.prototype, "highlight", 2);
Yl([
  b({ type: Boolean, reflect: !0 })
], vs.prototype, "reveal", 2);
Yl([
  N()
], vs.prototype, "editing", 2);
vs = Yl([
  Y("wy-comment"),
  At()
], vs);
const oK = it`[part~=wy-comment-editor]{position:relative;border-radius:var(--wy-padding-outer, 0)}[part~=wy-comment-editor-bottom]{position:sticky;bottom:0;z-index:999;background-color:var(--wy-component-background-color);padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-radius:var(--wy-component-border-radius);color:var(--wy-component-color)}[part~=wy-comment-editor-inputs]{display:flex;flex-direction:row;align-items:flex-end;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-comment-editor-text]{flex:1 1 100%;display:flex;flex-direction:column}[part~=wy-editor-parts]{padding-top:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));min-height:0}[part~=wy-comment-editor] .cm-editor{flex:1 1 100%;max-height:calc(11.25*var(--wy-size, 1rem));background-color:var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:calc(1.25*var(--wy-size, 1rem));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid rgba(0,0,0,0);margin:calc(-1*var(--wy-input-border-width, var(--wy-border, 1px)))}[part~=wy-comment-editor] .cm-editor:focus{border-color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-comment-editor] .cm-editor .cm-content{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-comment-editor] [part~=wy-is-invalid]+.cm-editor,[part~=wy-comment-editor] [part~=wy-is-invalid] .cm-editor{border-color:var(--wy-error, var(--wy-error-light, #ba1821))!important}`;
var xx, L9;
function fV() {
  if (L9) return xx;
  L9 = 1;
  var s = "Expected a function", t = NaN, e = "[object Symbol]", i = /^\s+|\s+$/g, r = /^[-+]0x[0-9a-f]+$/i, n = /^0b[01]+$/i, a = /^0o[0-7]+$/i, o = parseInt, l = typeof mv == "object" && mv && mv.Object === Object && mv, d = typeof self == "object" && self && self.Object === Object && self, u = l || d || Function("return this")(), p = Object.prototype, f = p.toString, y = Math.max, g = Math.min, O = /* @__PURE__ */ c(function() {
    return u.Date.now();
  }, "now");
  function k(z, V, X) {
    var tt, vt, dt, st, Pt, ct, Vt = 0, _t = !1, Zt = !1, Nt = !0;
    if (typeof z != "function")
      throw new TypeError(s);
    V = A(V) || 0, T(X) && (_t = !!X.leading, Zt = "maxWait" in X, dt = Zt ? y(A(X.maxWait) || 0, V) : dt, Nt = "trailing" in X ? !!X.trailing : Nt);
    function Xt(ee) {
      var Tr = tt, Ia = vt;
      return tt = vt = void 0, Vt = ee, st = z.apply(Ia, Tr), st;
    }
    h(Xt, "ie"), c(Xt, "invokeFunc");
    function Li(ee) {
      return Vt = ee, Pt = setTimeout(oe, V), _t ? Xt(ee) : st;
    }
    h(Li, "ct"), c(Li, "leadingEdge");
    function qe(ee) {
      var Tr = ee - ct, Ia = ee - Vt, tc = V - Tr;
      return Zt ? g(tc, dt - Ia) : tc;
    }
    h(qe, "kt"), c(qe, "remainingWait");
    function fe(ee) {
      var Tr = ee - ct, Ia = ee - Vt;
      return ct === void 0 || Tr >= V || Tr < 0 || Zt && Ia >= dt;
    }
    h(fe, "hi"), c(fe, "shouldInvoke");
    function oe() {
      var ee = O();
      if (fe(ee))
        return be(ee);
      Pt = setTimeout(oe, qe(ee));
    }
    h(oe, "Ye"), c(oe, "timerExpired");
    function be(ee) {
      return Pt = void 0, Nt && tt ? Xt(ee) : (tt = vt = void 0, st);
    }
    h(be, "Hi"), c(be, "trailingEdge");
    function zi() {
      Pt !== void 0 && clearTimeout(Pt), Vt = 0, tt = ct = vt = Pt = void 0;
    }
    h(zi, "Bi"), c(zi, "cancel");
    function Yi() {
      return Pt === void 0 ? st : be(O());
    }
    h(Yi, "sl"), c(Yi, "flush");
    function pr() {
      var ee = O(), Tr = fe(ee);
      if (tt = arguments, vt = this, ct = ee, Tr) {
        if (Pt === void 0)
          return Li(ct);
        if (Zt)
          return Pt = setTimeout(oe, V), Xt(ct);
      }
      return Pt === void 0 && (Pt = setTimeout(oe, V)), st;
    }
    return h(pr, "Ci"), c(pr, "debounced"), pr.cancel = zi, pr.flush = Yi, pr;
  }
  h(k, "A"), c(k, "debounce");
  function $(z, V, X) {
    var tt = !0, vt = !0;
    if (typeof z != "function")
      throw new TypeError(s);
    return T(X) && (tt = "leading" in X ? !!X.leading : tt, vt = "trailing" in X ? !!X.trailing : vt), k(z, V, {
      leading: tt,
      maxWait: V,
      trailing: vt
    });
  }
  h($, "M"), c($, "throttle");
  function T(z) {
    var V = typeof z;
    return !!z && (V == "object" || V == "function");
  }
  h(T, "R"), c(T, "isObject");
  function _(z) {
    return !!z && typeof z == "object";
  }
  h(_, "V"), c(_, "isObjectLike");
  function D(z) {
    return typeof z == "symbol" || _(z) && f.call(z) == e;
  }
  h(D, "W"), c(D, "isSymbol");
  function A(z) {
    if (typeof z == "number")
      return z;
    if (D(z))
      return t;
    if (T(z)) {
      var V = typeof z.valueOf == "function" ? z.valueOf() : z;
      z = T(V) ? V + "" : V;
    }
    if (typeof z != "string")
      return z === 0 ? z : +z;
    z = z.replace(i, "");
    var X = n.test(z);
    return X || a.test(z) ? o(z.slice(2), X ? 2 : 8) : r.test(z) ? t : +z;
  }
  return h(A, "I"), c(A, "toNumber"), xx = $, xx;
}
h(fV, "j4");
c(fV, "requireLodash_throttle");
var lK = fV();
const VS = /* @__PURE__ */ tL(lK);
function mV(s, t) {
  return new Yt(s.queryClient, {
    mutationFn: /* @__PURE__ */ c(async () => await s.fetch(`/api/apps/${t}/typing`, {
      method: "PUT",
      body: JSON.stringify({})
    }), "mutationFn")
  });
}
h(mV, "K4");
c(mV, "typingMutation");
function WS(s, t) {
  return new Yt(s.queryClient, {
    mutationFn: /* @__PURE__ */ c(async () => {
      const e = await s.fetch(`/x/${t}/meetings`, { method: "POST" });
      if (!e.ok)
        throw new Error("Failed to create meeting");
      return await e.json();
    }, "mutationFn")
  });
}
h(WS, "Ff");
c(WS, "addMeetingMutation");
async function yV(s, t) {
  const e = await s.fetch("/api/blobs/external", { method: "POST", body: JSON.stringify(t) });
  if (!e.ok) {
    const i = await e.json();
    throw new Error(i.detail || i.title, { cause: i });
  }
  return await e.json();
}
h(yV, "Q4");
c(yV, "externalBlob");
function gV(s, t, e, i) {
  const r = s.queryClient, n = ["apps", e, "blobs", i];
  return {
    mutationFn: /* @__PURE__ */ c(async (a) => await yV(s, a.externalBlob), "mutationFn"),
    mutationKey: n,
    onMutate: /* @__PURE__ */ c(async (a) => (await r.cancelQueries({ queryKey: n, exact: !0 }), { type: "attach", file: c4(void 0, a.externalBlob.name, a.externalBlob.size, void 0, t), status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ c((a, o, l) => {
      he(r, n, o, (d) => {
        d.status.state = "ok", d.status.progress = void 0, d.status.text = void 0;
      });
    }, "onSuccess"),
    onError(a, o, l) {
      const d = a.cause;
      d && d.status === 409 ? he(r, n, o, (u) => {
        u.status.state = "conflict", u.status.progress = void 0, u.status.text = d.detail || d.title;
      }) : he(r, n, o, (u) => {
        u && (u.status.state = "error", u.status.progress = void 0, u.status.text = d.detail || d.title);
      });
    }
  };
}
h(gV, "G4");
c(gV, "getExternalBlobMutationOptions");
function s3(s, t, e, i) {
  return new Yt(s.queryClient, gV(s, t, e, i));
}
h(s3, "Uv");
c(s3, "getExternalBlobMutation");
const cK = /(((https?|ftp):\/\/|(www|ftp)\.)[\w]+(.[\w]+)([\w\-.,@?^=%&amp;:/~+#]*[\w\-@?^=%&amp;/~+#]))/gim;
let eh = [], u1 = [], L0 = [], pO = [], Vs = {};
const hK = /* @__PURE__ */ c((s, t) => s.length === t.length && s.every((e, i) => e === t[i]), "arrayEquals");
function wV() {
  return !!Object.keys(Vs).length;
}
h(wV, "X4");
c(wV, "isFetchingEmbeds");
async function vV(s, t) {
  let e;
  try {
    const i = await t.fetch(`/api/embeds?url=${encodeURIComponent(s)}`);
    if (!i.ok)
      throw new Error();
    e = await i.json(), delete Vs[s], u1 = [...u1, s];
  } catch {
    L0 = [...L0, s], delete Vs[s];
  }
  return e;
}
h(vV, "J4");
c(vV, "fetchEmbed");
const dK = /* @__PURE__ */ c(() => {
  eh = [], u1 = [], L0 = [], pO = [], Vs = {};
}, "clearEmbeds"), z9 = /* @__PURE__ */ c((s) => {
  u1 = s;
}, "initEmbeds"), uK = /* @__PURE__ */ c((s, t, e) => {
  let i = s.match(cK)?.map((r) => r) || null;
  if (i !== null && (i = i.map((r) => r.startsWith("//") ? "http:" + r : !r.startsWith("http://") && !r.startsWith("https://") ? "http://" + r : r)), !(i === null || i.length === 0) && (i.length !== eh.length || !hK(i, eh))) {
    eh = i, i.forEach((r) => {
      !u1.includes(r) && !L0.includes(r) && !pO.includes(r) && typeof Vs[r] > "u" && (Se(), Vs[r] = window.setTimeout(async () => {
        const n = await vV(r, e);
        n && t(n);
      }, 500));
    }), pO = pO.filter((r) => eh.includes(r));
    for (const r in Vs)
      eh.includes(r) || (Se(), window.clearTimeout(Vs[r]), delete Vs[r]);
  }
}, "getEmbeds"), mr = V0() ? window.navigator.userAgent : "", OV = mr.includes("iPad") || mr.includes("Android") && !mr.includes("Mobi") || !1, pK = mr.includes("Mobi") || OV || !1, fK = !pK && !OV, I9 = mr.includes("Windows") ? "Windows" : mr.includes("Macintosh") ? "Mac" : mr.includes("iPad") || mr.includes("iPhone") || mr.includes("iPod") ? "iOS" : mr.includes("Android") ? "Android" : void 0;
I9 === "Android" && mr.includes("; wv") || I9 === "iOS" && mr.includes("Safari");
const mK = it`[part~=wy-scroll-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x-y]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;overflow-x:auto;touch-action:pan-y,pan-x}[part~=wy-scroll-x-always],[part~=wy-scroll-y-always]{overflow-y:scroll}[part~=wy-code] pre,.wy-code pre,[part~=wy-editor] .cm-content pre{text-wrap:pretty}[part~=wy-code] .code,[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code .code,.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content .code,[part~=wy-editor] .cm-content code[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;word-wrap:break-word;line-height:1.25;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}@media print{[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content code[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{text-shadow:none}}[part~=wy-code] pre[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}[part~=wy-code] :not(pre)>code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code :not(pre)>code[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content :not(pre)>code[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));background:var(--wy-background, var(--wy-background-light, #f7f9ff))}[part~=wy-code] :not(pre)>code[class*=language-],.wy-code :not(pre)>code[class*=language-],[part~=wy-editor] .cm-content :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}[part~=wy-code] .token.variable,.wy-code .token.variable,[part~=wy-editor] .cm-content .token.variable{color:var(--wy-code-variable, var(--wy-code-variable-light, #001080))}[part~=wy-code] .token.operator,.wy-code .token.operator,[part~=wy-editor] .cm-content .token.operator{color:var(--wy-code-operator, var(--wy-code-operator-light, #000000))}[part~=wy-code] .token.prolog,.wy-code .token.prolog,[part~=wy-editor] .cm-content .token.prolog{color:var(--wy-code-prolog, var(--wy-code-prolog-light, #000080))}[part~=wy-code] .token.comment,.wy-code .token.comment,[part~=wy-editor] .cm-content .token.comment{color:var(--wy-code-comment, var(--wy-code-comment-light, #008000))}[part~=wy-code] .token.builtin,.wy-code .token.builtin,[part~=wy-editor] .cm-content .token.builtin{color:var(--wy-code-builtin, var(--wy-code-builtin-light, #0070C1))}[part~=wy-code] .token.number,.wy-code .token.number,[part~=wy-editor] .cm-content .token.number{color:var(--wy-code-number, var(--wy-code-number-light, #098658))}[part~=wy-code] .token.inserted,.wy-code .token.inserted,[part~=wy-editor] .cm-content .token.inserted{color:var(--wy-code-inserted, var(--wy-code-inserted-light, #098658))}[part~=wy-code] .token.constant,.wy-code .token.constant,[part~=wy-editor] .cm-content .token.constant{color:var(--wy-code-constant, var(--wy-code-constant-light, #811F3F))}[part~=wy-code] .token.hexcode,.wy-code .token.hexcode,[part~=wy-editor] .cm-content .token.hexcode{color:var(--wy-code-hexcode, var(--wy-code-hexcode-light, #811F3F))}[part~=wy-code] .token.regex,.wy-code .token.regex,[part~=wy-editor] .cm-content .token.regex{color:var(--wy-code-regex, var(--wy-code-regex-light, #811F3F))}[part~=wy-code] .token.char,.wy-code .token.char,[part~=wy-editor] .cm-content .token.char{color:var(--wy-code-char, var(--wy-code-char-light, #811F3F))}[part~=wy-code] .token.tag,.wy-code .token.tag,[part~=wy-editor] .cm-content .token.tag{color:var(--wy-code-tag, var(--wy-code-tag-light, #800000))}[part~=wy-code] .token.attr-name,.wy-code .token.attr-name,[part~=wy-editor] .cm-content .token.attr-name{color:var(--wy-code-attr-name, var(--wy-code-attr-name-light, #E50000))}[part~=wy-code] .token.selector,.wy-code .token.selector,[part~=wy-editor] .cm-content .token.selector{color:var(--wy-code-selector, var(--wy-code-selector-light, #E50000))}[part~=wy-code] .token.property,.wy-code .token.property,[part~=wy-editor] .cm-content .token.property{color:var(--wy-code-property, var(--wy-code-property-light, #E50000))}[part~=wy-code] .token.deleted,.wy-code .token.deleted,[part~=wy-editor] .cm-content .token.deleted{color:var(--wy-code-deleted, var(--wy-code-deleted-light, #A31515))}[part~=wy-code] .token.string,.wy-code .token.string,[part~=wy-editor] .cm-content .token.string{color:var(--wy-code-string, var(--wy-code-string-light, #A31515))}[part~=wy-code] .token.changed,.wy-code .token.changed,[part~=wy-editor] .cm-content .token.changed{color:var(--wy-code-changed, var(--wy-code-changed-light, #0451A5))}[part~=wy-code] .token.punctuation,.wy-code .token.punctuation,[part~=wy-editor] .cm-content .token.punctuation{color:var(--wy-code-punctuation, var(--wy-code-punctuation-light, #000000))}[part~=wy-code] .token.function,.wy-code .token.function,[part~=wy-editor] .cm-content .token.function{color:var(--wy-code-function, var(--wy-code-function-light, #0000FF))}[part~=wy-code] .token.keyword,.wy-code .token.keyword,[part~=wy-editor] .cm-content .token.keyword{color:var(--wy-code-keyword, var(--wy-code-keyword-light, #AF00DB))}[part~=wy-code] .token.class-name,.wy-code .token.class-name,[part~=wy-editor] .cm-content .token.class-name{color:var(--wy-code-class-name, var(--wy-code-class-name-light, #267F99))}[part~=wy-code] .token.important,[part~=wy-code] .token.bold,.wy-code .token.important,.wy-code .token.bold,[part~=wy-editor] .cm-content .token.important,[part~=wy-editor] .cm-content .token.bold{font-weight:700}[part~=wy-code] .token.italic,.wy-code .token.italic,[part~=wy-editor] .cm-content .token.italic{font-style:italic}[part~=wy-editor]{box-sizing:border-box}[part~=wy-editor] .cm-scroller{font-family:unset;line-height:1.5}[part~=wy-editor] .cm-widgetBuffer{vertical-align:unset}[part~=wy-editor] .cm-placeholder{pointer-events:none;color:var(--wy-outline, var(--wy-outline-light, #72777f))}[part~=wy-editor] .cm-content{caret-color:var(--wy-on-background, var(--wy-on-background-light, #181c20))}[part~=wy-editor] .cm-content ::part(wy-link){text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-light, #2f628c))}[part~=wy-editor] .wy-mention{font-weight:700}[part~=wy-editor] .cm-editor{box-sizing:border-box;flex-direction:column;position:relative!important;display:flex!important}[part~=wy-editor] .cm-editor.cm-focused{--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));color:var(--wy-component-color);border-color:var(--wy-primary, var(--wy-primary-light, #2f628c));outline:0}[part~=wy-editor] .cm-editor .cm-scroller{overflow:auto}[part~=wy-editor] .cm-editor .cm-line{display:block;padding:0px var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) 0px var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-editor] .cm-tooltip.cm-tooltip-autocomplete>ul{font-family:unset;max-height:calc(15*var(--wy-size, 1rem))}[part~=wy-editor] .cm-tooltip.cm-tooltip-autocomplete>ul>li{padding:0}[part~=wy-editor] .cm-tooltip{border:none;background-clip:padding-box;background-color:var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));overflow:hidden;z-index:1000}[part~=wy-editor] .cm-tooltip-autocomplete ul li[aria-selected] wy-item{background:var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));color:unset}[part~=wy-editor] .cm-tooltip-autocomplete .cm-completionLabel{display:none}[part~=wy-editor] .cm-tooltip-autocomplete ::part(wy-item-interactive):hover,[part~=wy-editor] .cm-tooltip-autocomplete ::part(wy-item-interactive):focus{background:var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb))}`, yK = it`[part~=wy-post-editor]{padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-post-editor-inputs]{display:flex;flex-direction:row;align-items:flex-end;justify-content:space-between;flex-wrap:wrap;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-post-editor-buttons]{display:flex;flex-direction:row;align-items:flex-end;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));flex:1 0 auto}[part~=wy-post-editor-text]{flex:1 1 100%;display:flex;flex-direction:column}[part~=wy-editor-parts]{display:flex;flex-direction:column;gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));min-height:0}[part~=wy-post-editor] .cm-editor{flex:1 1 100%;max-height:11.25em;min-height:4em;background-color:var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid rgba(0,0,0,0);caret-color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-post-editor] .cm-editor:focus{border-color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-post-editor] .cm-editor .cm-content{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-post-editor] .cm-editor .cm-line{padding:0}[part~=wy-post-editor] [part~=wy-is-invalid]+[data-editor-target] .cm-editor,[part~=wy-post-editor] [part~=wy-is-invalid] .cm-editor{border-color:var(--wy-error, var(--wy-error-light, #ba1821))!important}`, bV = it`[part~=wy-dragging]:after{content:attr(data-drag-title);background-color:#ffffff80;display:flex;justify-content:center;align-items:center;border:calc(.125*var(--wy-size, 1rem)) dashed var(--wy-outline, var(--wy-outline-light, #72777f));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));font-size:calc(1.5*var(--wy-size, 1rem));font-weight:var(--wy-font-weight-bold, 600);z-index:10000;position:absolute;inset:0}`;
var gK = Object.defineProperty, wK = Object.getOwnPropertyDescriptor, Gl = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? wK(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && gK(t, e, r), r;
}, "__decorateClass$K"), kx, hm;
let Os = (kx = (hm = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.status = {
      state: "ok"
    }, this.interactive = !1, this.rounded = !1, this.isRenaming = !1;
  }
  /**
   * Emit an `edit-name` event requesting rename mode for the provided file.
   *
   * @param file - File that should enter rename mode.
   * @returns Whether the event was not canceled.
   */
  dispatchEditName(t) {
    const e = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `rename` event with a new filename.
   *
   * @param file - File being renamed.
   * @param name - New filename to apply.
   * @returns Whether the event was not canceled.
   */
  dispatchRename(t, e) {
    const i = new CustomEvent("rename", { detail: { file: t, name: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit a `trash` event to move the file to the recycle bin.
   *
   * @param file - File slated for trashing.
   * @returns Whether the event was not canceled.
   */
  dispatchTrash(t) {
    const e = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `restore` event to recover the provided file.
   *
   * @param file - File to restore from trash.
   * @returns Whether the event was not canceled.
   */
  dispatchRestore(t) {
    const e = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `delete-forever` event to permanently remove the file.
   *
   * @param file - File targeted for permanent deletion.
   * @returns Whether the event was not canceled.
   */
  dispatchDeleteForever(t) {
    const e = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling subscription for the file.
   *
   * @param file - File whose subscription changes.
   * @param subscribe - Desired subscription state.
   * @returns Whether the event was not canceled.
   */
  dispatchSubscribe(t, e) {
    const i = new CustomEvent("subscribe", { detail: { file: t, subscribe: e } });
    return this.dispatchEvent(i);
  }
  render() {
    const t = this.file;
    if (!t) return C;
    const { icon: e } = wn(t.name), i = dr(t.name), r = /* @__PURE__ */ c((a) => {
      a.stopImmediatePropagation();
      const o = a.target;
      o.value && o.value !== t.name ? this.dispatchRename(t, o.value) : this.dispatchEditName({ id: NaN });
    }, "handleRename"), n = /* @__PURE__ */ c((a) => {
      const o = a.target;
      a.key === "Escape" ? (a.preventDefault(), o.value = t.name, o.blur()) : a.key === "Enter" && (a.preventDefault(), o.blur());
    }, "handleRenameKey");
    return v`
      <wy-item
        ?rounded=${this.rounded}
        ?interactive=${this.interactive && !t.is_trashed && !this.isRenaming}
        ?trashed=${t.is_trashed}
        title=${t.name}
        size="sm"
      >
        ${this.status.state === "error" ? v`<wy-icon
              slot="image"
              name="alert-octagon"
              color="error"
              title=${St(this.status.text)}
            ></wy-icon>` : this.status.state === "conflict" ? v`<wy-icon slot="image" name="alert" color="yellow" title=${St(this.status.text)}></wy-icon>` : v`<wy-icon slot="image" .name=${e} .size=${24} .kind=${t.kind} ext=${i}></wy-icon>`}
        ${this.isRenaming ? v`
              <input
                slot="title"
                type="text"
                maxlength="256"
                part="wy-input"
                .defaultValue=${t.name}
                @blur=${r}
                @keyup=${(a) => {
      nn(a), n(a);
    }}
                @click=${(a) => a.preventDefault()}
                @focus=${Ab}
                ${ht(BS)}
              />
            ` : v`
              <span slot="title" title=${t.name + (this.status.text ? `: ${this.status.text}` : "")}>
                <slot name="title"
                  >${this.title || t.name}${this.status.text ? v`: <em>${this.status.text}</em>` : C}</slot
                >
              </span>
            `}

        <slot slot="actions" name="actions">
          <wy-file-menu
            .file=${t}
            @edit-name=${(a) => this.dispatchEditName(a.detail.file)}
            @trash=${(a) => this.dispatchTrash(a.detail.file)}
            @restore=${(a) => this.dispatchRestore(a.detail.file)}
            @delete-forever=${(a) => this.dispatchDeleteForever(a.detail.file)}
            @subscribe=${(a) => this.dispatchSubscribe(a.detail.file, a.detail.subscribe)}
          >
          </wy-file-menu>
        </slot>
      </wy-item>
    `;
  }
}, h(hm, "Mo"), hm), c(kx, "WyFileItem"), kx);
Os.styles = [Ea];
Gl([
  b({ type: Object })
], Os.prototype, "file", 2);
Gl([
  b({ type: Object })
], Os.prototype, "status", 2);
Gl([
  b({ type: Boolean })
], Os.prototype, "interactive", 2);
Gl([
  b({ type: Boolean })
], Os.prototype, "rounded", 2);
Gl([
  b()
], Os.prototype, "actionType", 2);
Gl([
  N()
], Os.prototype, "isRenaming", 2);
Os = Gl([
  Y("wy-file-item")
], Os);
const vK = /* @__PURE__ */ c((s) => {
  var p;
  var t, e, i, r, n, a, o, l, d, u;
  return u = (p = class extends s {
    /**
     * @constructor
     * @hideconstructor
     */
    constructor(...y) {
      super(...y), q(this, r), q(this, t, []), q(this, e), q(this, i, /* @__PURE__ */ new Set());
    }
    get eventParent() {
      return x(this, e);
    }
    set eventParent(y) {
      y?.eventChildren && y.eventChildren.add(this), E(this, e, y);
    }
    get eventChildren() {
      return x(this, i);
    }
    /**
     * Registers one or several event listeners. All event listeners are managed and automatically unregistered on destroy.
     *
     * When listening to weavy events, you may also listen to `before:` and `after:` events by simply adding the prefix to a weavy event.
     * Event handlers listening to weavy events may return modified data that is returned to the trigger. The data is passed on to the next event in the trigger event chain. If an event handler calls `event.stopPropagation()` or `return false`, the event chain will be stopped and the value is returned.
     *
     * @example <caption>Instance event</caption>
     * myInstance.on("before:options", function(options) { ... })
     * myInstance.on("options", function(options) { ... })
     * myInstance.on("after:options", function(options) { ... })
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#on
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string|Object} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     */
    on(...y) {
      const g = kt(this, r, d).call(this, y);
      if (y[3]) {
        const O = /* @__PURE__ */ c((...k) => {
          try {
            g.handler.apply(this, k);
          } catch {
            try {
              g.handler();
            } catch ($) {
              console.warn("Could not invoke one handler:", $);
            }
          }
          kt(this, r, o).call(this, g.events, g.selector, null, g.handler);
        }, "attachedHandler");
        kt(this, r, n).call(this, g.events, g.selector, O, g.handler);
      } else
        kt(this, r, n).call(this, g.events, g.selector, g.handler, g.handler);
    }
    /**
     * Registers one or several event listeners that are executed once. All event listeners are managed and automatically unregistered on destroy.
     *
     * Similar to {@link WeavyEvents#on}.
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#one
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string|Object} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {Function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     */
    one(y, g, O) {
      this.on(y, g, O, !0);
    }
    /**
     * Unregisters event listeners. The arguments must match the arguments provided on registration using .on() or .one().
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#off
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     * @returns {boolean} Was the handler removed?
     */
    off(...y) {
      const g = kt(this, r, d).call(this, y), O = kt(this, r, a).call(this, g.events, g.selector, g.handler);
      return kt(this, r, o).call(this, g.events, g.selector, O, g.handler);
    }
    /**
     * Clears all registered eventhandlers
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#clear
     */
    clearEventHandlers() {
      x(this, t).length = 0;
    }
    /**
     * Trigger a custom event. Events are per default triggered on the weavy instance using the weavy namespace.
     *
     * The trigger has an event chain that adds `before:` and `after:` events automatically for all events except when any custom `prefix:` is specified. This way you may customize the eventchain by specifying `before:`, `on:` and `after:` in your event name to fire them one at the time. The `on:` prefix will then be removed from the name when the event is fired.
     *
     * Eventhandlers listening to the event may return modified data that is returned by the trigger event. The data is passed on to the next event in the trigger event chain. If an event handler calls `event.stopPropagation()` or `return false`, the event chain will be stopped and the value is returned.
     *
     * @example
     * // Normal triggering
     * weavyEvents.triggerEvent("myevent");
     *
     * // Will trigger the following events on the root instance
     * // 1. before:myevent.event.weavy
     * // 2. myevent.event.weavy
     * // 3. after:myevent.event.weavy
     *
     * @example
     * // Custom triggering, one at the time
     * weavyEvents.triggerEvent("before:myevent");
     * weavyEvents.triggerEvent("on:myevent");
     * weavyEvents.triggerEvent("after:myevent");
     *
     * @example
     * // Advanced triggering with data handling
     *
     * function doSomething() {
     *     // Will trigger the events sequentially and check the response data in between
     *
     *     var myTriggerData = { counter: 123, label: "my label" };
     *
     *     // Custom triggering, one at the time
     *
     *     // 1. Trigger before: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("before:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("before:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     // ...
     *
     *     // 2. Continue with on: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("on:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("on:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     // ...
     *
     *     // 3. At last trigger after: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("after:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("after:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     console.log("myevent was fully executed", myTriggerData);
     *     return myTriggerData;
     * }
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#triggerEvent
     * @param {string} name - The name of the event.
     * @param {(Array/Object/JSON)} [data] - Data may be an array or plain object with data or a JSON encoded string.
     * @param {any} ...additionalData - Any raw extra data
     * @returns {data} The data passed to the event trigger including any modifications by event handlers. Returns false if the event is cancelled.
     */
    triggerEvent(y, g, ...O) {
      const k = /^(before|on|after):/.test(y), $ = k ? y.split(":")[0] : "";
      y = y.replace(/^(before|on|after):/, "");
      const T = "before:" + y, _ = y, D = "after:" + y;
      if (g && typeof g == "string")
        try {
          g = JSON.parse(g);
        } catch {
          console.warn("Could not parse event data", y, g);
        }
      let A;
      if (k) {
        if ($ === "before" || $ === "after") {
          if (x(this, e) && (A = x(this, e).triggerEvent(
            $ === "before" ? T : D,
            g,
            ...O
          ), g = A || A === !1 ? A : g, g === !1) || (A = kt(this, r, l).call(this, $ === "before" ? T : D, g, ...O), g = A || A === !1 ? A : g, g === !1))
            return g;
        } else if ($ === "on" && (A = kt(this, r, l).call(this, _, g, ...O), g = A || A === !1 ? A : g, g === !1 || x(this, e) && (A = x(this, e).triggerEvent("on:" + _, g, ...O), g = A || A === !1 ? A : g, g === !1)))
          return g;
      } else {
        if (x(this, e) && (A = x(this, e).triggerEvent(T, g, ...O), g = A || A === !1 ? A : g, g === !1) || (A = kt(this, r, l).call(this, T, g, ...O), g = A || A === !1 ? A : g, g === !1) || (A = kt(this, r, l).call(this, _, g, ...O), g = A || A === !1 ? A : g, g === !1) || x(this, e) && (A = x(this, e).triggerEvent("on:" + _, g, ...O), g = A || A === !1 ? A : g, g === !1) || x(this, e) && (A = x(this, e).triggerEvent(D, g, ...O), g = A || A === !1 ? A : g, g === !1))
          return g;
        A = kt(this, r, l).call(this, D, g, ...O), g = A || A === !1 ? A : g;
      }
      return g;
    }
  }, h(p, "v"), p), t = /* @__PURE__ */ new WeakMap(), e = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakSet(), /**
  * Saves a single event handler.
  *
  * @internal
  * @function
  * @param {string} event - One or more events. Multiple events are currently not registered individually.
  * @param {string|Object} [selector] - Optional refinement selector
  * @param {function} handler - The handler function. may be wrapped for once-handlers
  * @param {function} originalHandler - The original non-wrapped event handler.
  */
  n = /* @__PURE__ */ c(function(f, y, g, O) {
    x(this, t).push({
      events: f,
      selector: y,
      handler: g,
      originalHandler: O
    });
  }, "#registerEventHandler"), /**
  * Returns the event handler or wrapped event handler. The arguments must match the registered event handler.
  *
  * @internal
  * @function
  * @param {string} events - The events registered
  * @param {string|Object} [selector] - The optional selector for the handler.
  * @param {function} handler - The registered handler
  * @param {function} [originalHandler] - The original registered handler
  */
  a = /* @__PURE__ */ c(function(f, y, g, O) {
    const k = {
      events: f,
      selector: y,
      handler: g,
      originalHandler: O || g
    }, $ = x(this, t).filter((T) => wo(k, T, !0)).pop();
    return $ && $.handler;
  }, "#getEventHandler"), /**
  * Unregister an event handler. Arguments must match the registered event handler.
  *
  * @internal
  * @function
  * @param {string} event - The events registered
  * @param {function} handler - The registered handler
  * @param {string|Object} [selector] - The optional selector for the handler.
  * @returns {boolean} - True if any handler was removed
  */
  o = /* @__PURE__ */ c(function(f, y, g, O) {
    const k = {
      events: f,
      selector: y,
      handler: g,
      originalHandler: O
    };
    let $ = !1;
    return x(this, t).forEach((T, _) => {
      wo(k, T, !0) && ($ = !0, x(this, t).splice(_, 1));
    }), $;
  }, "#unregisterEventHandler"), /**
  * Triggers any local event handlers registered. Each handler may modify the data and return it or return false to cancel the event chain. .stopPropagation() and .preventDefault() may also be used.
  *
  * @example
  * weavyEvents.on("myevent", function(e, data) { ... })
  *
  * triggerHandler(this, "myevent", { key: 1 })
  *
  * @internal
  * @function
  * @param {any} eventName - The name of the event. Event names without prefix will also trigger handlers with the "on:" prefix.
  * @param {any} data - Any data to pass to the handler
  * @param {any} ...additionalData - Any extra data
  */
  l = /* @__PURE__ */ c(function(f, y, ...g) {
    let O = !1;
    return x(this, t).forEach((k) => {
      k.events.split(" ").forEach(($) => {
        if ($ = $.indexOf("on:") === 0 ? $.split("on:")[1] : $, f === $ && (!k.selector || wo(k.selector, y, !0))) {
          const T = k.handler(y, ...g);
          T ? y = T : T === !1 && (O = !0);
        }
      });
    }), O ? !1 : y;
  }, "#triggerHandler"), /**
  * Extracts and normalizes all parts of the events arguments.
  *
  * @internal
  * @function
  * @param {Array.<Object>} eventArguments - The function argument list: `[context], events, [selector], handler`
  * @returns {Object}
  * @property {string} events - Event names with added namespace for local events.
  * @property {string|Object} selector - The optional selector.
  * @property {function} handler - The handler function
  * @
  */
  d = /* @__PURE__ */ c(function(f) {
    const y = typeof f[1] == "function" ? f[1] : f[2], g = typeof f[1] == "function" ? null : f[1];
    return { events: f[0], selector: g, handler: y };
  }, "#getEventArguments"), c(u, "WeavyEvents"), u;
}, "MixinWeavyEvents"), OK = vK(class {
});
function FS(s) {
  let t = "";
  try {
    t = /^((?:https?:\/\/[^/]+)|(?:file:\/\/))\/?/.exec(s)?.[1] || "";
  } catch {
    console.error(
      "Unable to resolve location origin. Make sure you are using http, https or file protocol and have a valid location URL."
    );
  }
  return t;
}
h(FS, "Hf");
c(FS, "extractOrigin");
var dm;
const $V = (dm = class extends OK {
  constructor(t = {}) {
    super(), this.contentWindows = /* @__PURE__ */ new Set(), this.contentWindowsMapByWeavyId = /* @__PURE__ */ new Map(), this.contentWindowOrigins = /* @__PURE__ */ new WeakMap(), this.contentWindowNames = /* @__PURE__ */ new WeakMap(), this.contentWindowWeavyIds = /* @__PURE__ */ new WeakMap(), this.contentWindowDomain = /* @__PURE__ */ new WeakMap(), this.origin = V0() ? FS(window.location.href) : "", this.timeout = 2e3, t?.timeout && (this.timeout = t.timeout), window.addEventListener("message", (e) => {
      if (e.data.name && e.data.weavyId !== void 0) {
        if (e.data.weavyMessageId && e.data.name !== "message-receipt" && e.data.name !== "unready")
          try {
            e.source?.postMessage(
              { name: "message-receipt", weavyId: e.data.weavyId, weavyMessageId: e.data.weavyMessageId },
              { targetOrigin: e.origin }
            );
          } catch {
            console.error("could not post back message-receipt to source");
          }
        switch (e.data.name) {
          case "register-child": {
            if ((!e.source || !this.contentWindowWeavyIds.has(e.source)) && console.warn("register-child: contentWindow not pre-registered", e.source), e.source && this.contentWindowOrigins.get(e.source) !== e.origin) {
              console.error(
                "register-child: " + this.contentWindowNames.get(e.source) + " has invalid origin",
                e.origin
              );
              return;
            }
            try {
              const i = e.source ? this.contentWindowWeavyIds.get(e.source) : void 0, r = e.source ? this.contentWindowNames.get(e.source) : void 0;
              r && e.source && e.source.postMessage(
                {
                  name: "register-window",
                  windowName: r,
                  weavyId: i || !0
                },
                { targetOrigin: e.origin }
              );
            } catch (i) {
              console.error("could not register frame window", i);
            }
            break;
          }
          case "ready": {
            e.source && this.contentWindowsMapByWeavyId.has(e.data.weavyId) && this.contentWindowNames.has(e.source) && this.contentWindowsMapByWeavyId.get(e.data.weavyId)?.get(this.contentWindowNames.get(e.source)) && (this.contentWindowDomain.set(e.source, e.origin), this.distributeMessage(e));
            break;
          }
          case "unready": {
            this.contentWindowsMapByWeavyId.has(e.data.weavyId) && this.distributeMessage(e, !0);
            break;
          }
          default: {
            (e.source === window || this.contentWindowsMapByWeavyId.size) && this.distributeMessage(e);
            break;
          }
        }
      }
    });
  }
  /**
   * The weavy console logging.
   */
  get console() {
    return console;
  }
  distributeMessage(t, e = !1) {
    const i = t.source === window && t.origin === this.origin;
    if (e ||= t.source && this.contentWindowOrigins.has(t.source) && t.origin === this.contentWindowOrigins.get(t.source) || !1, i || e) {
      e && !t.data.windowName && t.source && (t.data.windowName = this.contentWindowNames.get(t.source));
      const r = t.data.name;
      r && this.triggerEvent(r, t.data, t), this.triggerEvent("message", t.data, t);
    }
  }
  /**
   * Sends the id of a frame to the frame content scripts, so that the frame gets aware of which id it has.
   * The frame needs to have a unique name attribute.
   *
   * @category panels
   * @param {string} weavyId - The id of the group or entity which the contentWindow belongs to.
   * @param {Window} contentWindow - The frame window to send the data to.
   */
  registerContentWindow(t, e, i, r) {
    try {
      if (!e) {
        console.error("registerContentWindow() No valid contentWindow to register, must be a window and have a name.");
        return;
      }
    } catch {
      console.error("registerContentWindow() cannot access contentWindowName");
    }
    t.self && (t = t.self), this.console.log("registerContentWindow", t), (!i || i === "true") && (i = !0), this.contentWindowsMapByWeavyId.has(i) || this.contentWindowsMapByWeavyId.set(i, /* @__PURE__ */ new Map()), this.contentWindowsMapByWeavyId.get(i)?.set(e, t), this.contentWindows.add(t), this.contentWindowNames.set(t, e), this.contentWindowWeavyIds.set(t, i), this.contentWindowOrigins.set(t, r);
  }
  unregisterAll(t) {
    this.contentWindowsMapByWeavyId.has(t) && (this.contentWindowsMapByWeavyId.get(t)?.forEach((e, i) => {
      this.unregisterContentWindow(i, t);
    }), this.contentWindowsMapByWeavyId.get(t), this.contentWindowsMapByWeavyId.delete(t));
  }
  unregisterContentWindow(t, e) {
    if (this.contentWindowsMapByWeavyId.has(e)) {
      if (this.contentWindowsMapByWeavyId.get(e)?.has(t)) {
        const i = this.contentWindowsMapByWeavyId.get(e)?.get(t);
        if (i)
          try {
            this.contentWindows.delete(i), this.contentWindowNames.delete(i), this.contentWindowWeavyIds.delete(i), this.contentWindowOrigins.delete(i);
          } catch {
          }
      }
      if (this.contentWindowsMapByWeavyId.get(e)?.delete(t), this.contentWindowsMapByWeavyId.get(e)?.size === 0)
        try {
          this.contentWindowsMapByWeavyId.delete(e);
        } catch {
        }
    }
  }
  async whenPostMessage(t, e, i) {
    Se(), i === null && (i = void 0);
    const r = t === window.self, n = r ? FS(window.location.href) : this.contentWindowOrigins.get(t);
    if (r || t && n === this.contentWindowDomain.get(t)) {
      e.weavyMessageId || (e.weavyMessageId = gy() + gy());
      let a;
      await Promise.race([
        new Promise((o, l) => {
          a = window.setTimeout(() => {
            l(new Error("postMessage() receipt timed out: " + e.weavyMessageId + ", " + e.name));
          }, this.timeout || 2e3);
        }),
        new Promise((o) => {
          this.on("message-receipt", { weavyId: e.weavyId, weavyMessageId: e.weavyMessageId }, () => {
            clearTimeout(a), o(void 0);
          }), t.postMessage(e, { targetOrigin: n, transfer: i });
        })
      ]);
    } else
      throw new Error("postMessage() Invalid window origin: " + n + ", " + e.name);
  }
  postToChildren(t, e) {
    if (typeof t != "object" || !t.name) {
      console.error("postToChildren() Invalid message format", t);
      return;
    }
    e === null && (e = void 0), t.distributeName = t.name, t.name = "distribute", t.weavyId = t.weavyId || !0, this.contentWindows.forEach((i) => {
      const r = this.contentWindowOrigins.get(i);
      if (r === this.contentWindowDomain.get(i))
        try {
          i.postMessage(t, { targetOrigin: r, transfer: e });
        } catch {
          console.warn(
            "postToChildren() could not distribute message to " + this.contentWindowNames.get(i)
          );
        }
    });
  }
  async postToFrame(t, e, i, r) {
    if (typeof i != "object" || !i.name) {
      console.error("postToFrame() Invalid message format", i);
      return;
    }
    const n = this.contentWindowsMapByWeavyId.get(e)?.get(t);
    if (!n)
      throw new Error(`postToFrame() Window not registered: ${e}, ${t}`);
    return i.weavyId = e, await this.whenPostMessage(n, i, r);
  }
  async postToSelf(t, e) {
    if (typeof t != "object" || !t.name) {
      console.error("postToSelf() Invalid message format", t);
      return;
    }
    return t.weavyId = t.weavyId || !0, await this.whenPostMessage(window.self, t, e);
  }
  postToSource(t, e, i) {
    if (t.source && t.data.weavyId !== void 0) {
      const r = t.source === window.self && t.origin === this.origin, n = this.contentWindowOrigins.has(t.source) && t.origin === this.contentWindowOrigins.get(t.source);
      if (i === null && (i = void 0), r || n) {
        e.weavyId = t.data.weavyId;
        try {
          t.source.postMessage(e, { targetOrigin: t.origin, transfer: i });
        } catch (a) {
          console.error("postToSource() Could not post message back to source", a);
        }
      }
    }
  }
}, h(dm, "Dw"), dm);
c($V, "WeavyPostalParent");
let bK = $V;
var $K = Object.defineProperty, xK = Object.getOwnPropertyDescriptor, t2 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? xK(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && $K(t, e, r), r;
}, "__decorateClass$J"), Sx, um;
let Pl = (Sx = (um = class extends Xi {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.iframeVisible = !1, this.showOverlay = !1, this.isRegistered = !1, this.iframeElementRef = $t(), this.overlayRef = $t();
  }
  /**
   * Open the file picker overlay.
   */
  open() {
    this.showOverlay = !0;
  }
  /**
   * Close the file picker overlay.
   */
  close() {
    this.showOverlay = !1, this.iframeVisible = !1;
  }
  /**
   * Returns the topmost available window/frame origin used when building the iframe src.
   *
   * @internal
   */
  get origin() {
    let t = "";
    try {
      window.location.ancestorOrigins && 0 < window.location.ancestorOrigins.length ? t = window.location.ancestorOrigins[window.location.ancestorOrigins.length - 1] : window.top && (t = window.top.document.location.origin);
    } catch {
    }
    if (!t)
      try {
        t = window.self.document.location.origin;
      } catch {
        console.error("Filebrowser: Could not read current origin.");
      }
    return t;
  }
  /**
   * Trigger `external-blobs` event with any selected blobs.
   *
   * @internal
   * @param {ExternalBlobType[] | null} externalBlobs - The externally selected blobs.
   * @returns {boolean} Whether the event was successful.
   */
  dispatchExternalBlobs(t) {
    const e = new CustomEvent("external-blobs", {
      detail: { externalBlobs: t }
    });
    return this.dispatchEvent(e);
  }
  connectedCallback() {
    super.connectedCallback(), this.handleFiles = (t, e) => {
      e.source === this.iframeElementRef.value?.contentWindow?.self && (this.dispatchExternalBlobs(t.blobs), this.close());
    }, this.handleClose = (t, e) => {
      e.source === this.iframeElementRef.value?.contentWindow?.self && this.close();
    }, this.handleGoogleSelected = (t, e) => {
      e.source === this.iframeElementRef.value?.contentWindow?.self && this.overlayRef.value && (this.overlayRef.value.maximized = !0);
    }, this.weavyPostal || (this.weavyPostal = new bK()), this.weavyPostal.on("add-external-blobs", this.handleFiles), this.weavyPostal.on("request:file-browser-close", this.handleClose), this.weavyPostal.on("google-selected", this.handleGoogleSelected);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.weavyPostal?.off("add-external-blobs", this.handleFiles), this.weavyPostal?.off("request:file-browser-close", this.handleClose), this.weavyPostal?.off("google-selected", this.handleGoogleSelected);
  }
  updated() {
    this.weavy && (this.showOverlay && !this.src && (this.src = new URL(
      "?origin=" + this.origin + "&v=X&t=" + Date.now().toString() + "&weavyId=wy-filebrowser",
      this.weavy.cloudFilePickerUrl
    )), this.weavyPostal && !this.isRegistered && this.showOverlay && this.src ? this.iframeElementRef.value?.contentWindow && (this.weavyPostal.registerContentWindow(
      this.iframeElementRef.value?.contentWindow.self,
      "weavy-filebrowser",
      "wy-filebrowser",
      this.src.origin
    ), this.isRegistered = !0) : this.weavyPostal && this.isRegistered && !this.showOverlay && this.src && (this.weavyPostal.unregisterContentWindow("weavy-filebrowser", "wy-filebrowser"), this.isRegistered = !1, this.src = void 0));
  }
  render() {
    return this.weavy ? v`
      <wy-overlay
        ?noHeader=${this.iframeVisible}
        part="wy-cloud-files-overlay"
        .show=${this.showOverlay}
        ${ht(this.overlayRef)}
        @close=${() => this.close()}
      >
        ${this.showOverlay ? v`
              <wy-progress-circular
                part="wy-cloud-files-progress"
                indeterminate
                overlay
                ?hidden=${this.iframeVisible}
              ></wy-progress-circular>
              <iframe
                part="wy-cloud-picker-frame"
                ${ht(this.iframeElementRef)}
                @load=${() => this.iframeVisible = !0}
                src=${St(this.src?.toString())}
                id="weavy-filebrowser"
                name="weavy-filebrowser"
                title=${P("Cloud File Browser")}
              ></iframe>
            ` : C}
      </wy-overlay>
    ` : C;
  }
}, h(um, "Ao"), um), c(Sx, "WyCloudFiles"), Sx);
Pl.styles = [
  ft,
  it`
      [part~="wy-cloud-picker-frame"] {
        flex: 1 1 100%;
        border: 0;
      }
    `
];
t2([
  N()
], Pl.prototype, "src", 2);
t2([
  N()
], Pl.prototype, "iframeVisible", 2);
t2([
  N()
], Pl.prototype, "showOverlay", 2);
Pl = t2([
  Y("wy-cloud-files"),
  At()
], Pl);
var kK = Object.defineProperty, SK = Object.getOwnPropertyDescriptor, ae = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? SK(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && kK(t, e, r), r;
}, "__decorateClass$I"), Cx, pm;
let Bt = (Cx = (pm = class extends Pe {
  constructor() {
    super(), this.exportParts = new rt(this), this.storage = ZP("localStorage"), this.disabled = !1, this._placeholder = "", this.text = "", this.metadata = {}, this.options = [], this.attachments = [], this.buttonText = "", this.typing = !0, this.draft = !1, this.editorType = "posts", this.editorClass = "wy-post-editor", this.editorLocation = "apps", this.editorError = !1, this.showPolls = !1, this.pollOptions = [], this._embeds = [], this.draftKey = "", this.uploadBlobMutation = new Wr(
      this
    ), this.mutatingFiles = new Rb(this), this.fileInputRef = $t(), this.cloudFilesRef = $t(), this.dropZone = new lI(this), this.keyMap = [], this.editorRef = $t(), this.editorInitialized = !1, this.throttledTyping = VS(
      async () => {
        this.weavy && this.app && !b0.has(this.app.type) && await mV(this.weavy, this.app.id).mutate();
      },
      2e3,
      { leading: !0, trailing: !1 }
    ), this.throttledDrafting = VS(
      () => {
        this.saveDraft();
      },
      500,
      { leading: !0, trailing: !0 }
    ), this.openFileInput = () => {
      this.fileInputRef.value?.click();
    }, this.openCloudFiles = () => {
      this.cloudFilesRef.value?.open();
    }, this.createMeeting = async (t) => {
      if (this.weavy && t.source === this.authWindow && this.weavy.url.origin === t.origin && t.data && t.data.name && t.data.name.endsWith("-authorized")) {
        const e = t.data.name.slice(0, -11), i = await WS(this.weavy, e).mutate();
        i.auth_url || (this.meeting = i);
      }
    }, this.addEventListener("drop-files", (t) => this.handleDropFiles(t)), this.addEventListener("keydown", Yw), this.addEventListener("keyup", nn);
  }
  set placeholder(t) {
    this._placeholder = t;
  }
  get placeholder() {
    return this._placeholder;
  }
  /**
   * Select all content in the editor.
   *
   * @internal
   */
  selectAllContent() {
    this.editor?.dispatch({
      selection: {
        anchor: 0,
        head: this.editor.state.doc.length
      }
    });
  }
  /**
   * Place cursor at the end of the editor content.
   *
   * @internal
   */
  setCursorLast() {
    this.editor?.dispatch({
      selection: {
        anchor: this.editor.state.doc.length,
        head: this.editor.state.doc.length
      }
    });
  }
  /**
   * Focus the editor input.
   *
   * @internal
   */
  focusInput() {
    this.editor?.focus();
  }
  set embeds(t) {
    const e = t.filter((i) => i.type !== "link" || i.title || i.description);
    this._embeds = [...e];
  }
  get embeds() {
    return this._embeds;
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("app") && (this.mutationAppId = void 0), (t.has("weavy") || t.has("app") || t.has("user") || t.has("parentId")) && this.weavy && this.app && this.user) {
      if (this.mutationAppId = this.mutationAppId ?? this.app?.id ?? Date.now() * -1, this.draftKey = `draft-${this.editorType}-${this.parentId || this.mutationAppId}`, this.uploadBlobMutation.trackMutation(
        Eb(
          this.weavy,
          this.user,
          this.mutationAppId,
          `${this.editorLocation}-${this.parentId || this.mutationAppId}`
        )
      ), this.mutatingFiles.trackMutationState(
        {
          filters: {
            mutationKey: [
              "apps",
              this.mutationAppId,
              "blobs",
              `${this.editorLocation}-${this.parentId || this.mutationAppId}`
            ],
            exact: !0
          }
        },
        this.weavy.queryClient
      ), this.externalBlobMutation = s3(
        this.weavy,
        this.user,
        this.mutationAppId,
        `${this.editorLocation}-${this.parentId || this.mutationAppId}`
      ), this.draft && this.storage) {
        const e = this.storage.getItem(this.draftKey);
        if (e) {
          const i = JSON.parse(e);
          this.text = i.text, this.embeds = i.embeds, this.meeting = i.meeting, i.pollOptions?.length > 0 && (this.showPolls = !0, this.pollOptions = i.pollOptions), z9(this.embeds.map((r) => r.url).filter((r) => typeof r == "string"));
        } else
          this.clearEditor();
      }
      this.embed && (this.embeds = [this.embed], z9(this.embeds.map((e) => e.url).filter((e) => typeof e == "string"))), this.options && this.options.length > 0 && (this.pollOptions = this.options, this.showPolls = !0);
    }
    t.has("text") && this.editor && this.editor.state.doc.toString() !== this.text && this.editor.dispatch({ changes: { from: 0, to: this.editor.state.doc.length, insert: this.text } });
  }
  updated(t) {
    if ((t.has("weavy") || t.has("app") || t.has("user") || t.has("parentId")) && this.weavy && this.user && this.editorRef.value && this.weavy.whenUrl().then(() => {
      import(
        /* webpackIgnore: true */
        /* @vite-ignore */
        new URL("./es/editor-M1x0pxVu.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
      ).then((e) => e.editor).then(
        ({
          weavyHighlighter: e,
          syntaxHighlighting: i,
          history: r,
          dropCursor: n,
          mentions: a,
          autocompletion: o,
          placeholder: l,
          keymap: d,
          weavyKeymap: u,
          defaultKeymap: p,
          historyKeymap: f,
          markdown: y,
          languages: g,
          EditorView: O,
          EditorState: k,
          weavyEnterSendKeymap: $,
          weavyModifierEnterSendKeymap: T,
          Compartment: _
        }) => {
          this.editorInitialized || (this.editorInitialized = !0, this.editorEditable = new _(), this.editorPlaceholder = new _(), this.editorKeymap = new _(), this.EditorView = O, this.placeholderExtension = l, this.keymapFacet = d, this.keymaps = {
            weavyEnterSendKeymap: $,
            weavyModifierEnterSendKeymap: T,
            weavyKeymap: u,
            defaultKeymap: [...p],
            historyKeymap: [...f]
          }, this.editorExtensions = [
            O.contentAttributes.of({
              spellcheck: "true",
              autocorrect: "on",
              autocapitalize: "on",
              enterkeyhint: this.settings?.enterToSend === "always" ? "send" : "enter"
            }),
            r(),
            n(),
            a,
            o({
              override: this.componentFeatures?.allowsFeature(L.Mentions) ? [(D) => this.autocomplete(D)] : [],
              //showMention
              closeOnBlur: !1,
              aboveCursor: this.editorType !== "posts",
              icons: !1,
              addToOptions: [
                {
                  render: /* @__PURE__ */ c(function(D, A) {
                    const z = document.createElement("wy-item");
                    z.interactive = !1, (!D.item?.access || D.item.access === Ln.None) && (z.disabled = !0);
                    const V = document.createElement("wy-avatar");
                    V.slot = "image", V.src = D.item?.avatar_url || "", V.name = D.item?.name || "";
                    const X = document.createElement("span");
                    return X.slot = "title", X.innerText = D.item?.name || "", z.appendChild(V), z.appendChild(X), z;
                  }, "render"),
                  position: 10
                }
              ]
            }),
            i(e, { fallback: !0 }),
            O.lineWrapping,
            y({ codeLanguages: g }),
            O.domEventHandlers({
              paste: /* @__PURE__ */ c((D, A) => {
                let z = [];
                const V = D.clipboardData?.items || [];
                for (const X of V)
                  if (X.kind === "file") {
                    const tt = X.getAsFile();
                    tt && (z = [...z, tt]);
                  }
                if (this.componentFeatures?.allowsFeature(L.Attachments) && z.length > 0) {
                  for (let X = 0; X < z.length; X++)
                    this.handleUploadFiles(z);
                  return !0;
                }
              }, "paste"),
              keyup: /* @__PURE__ */ c((D, A) => {
                this.text = A.state.doc.toString(), this.componentFeatures?.allowsFeature(L.Typing) && this.typing && A.state.doc.toString() !== "" && this.throttledTyping(), this.draft && this.throttledDrafting(), this.componentFeatures?.allowsFeature(L.Embeds) && A.state.doc.toString() !== "" && this.handleEmbeds(A.state.doc.toString());
              }, "keyup")
            }),
            // Compartments
            this.editorEditable.of(O.editable.of(!this.disabled)),
            this.editorPlaceholder.of(this.placeholderExtension(this.placeholder)),
            this.editorKeymap.of(this.keymapFacet.of(this.getKeymaps())),
            O.updateListener.of((D) => {
              this.setPlaceHolderText();
              const A = Array.from(
                (this.editor?.state).config.compartments.keys()
              );
              this.editorEditable = A[0], this.editorPlaceholder = A[1], this.editorKeymap = A[2];
            })
          ], this.editor || (this.editor = new O({
            state: k.create({
              doc: this.text,
              extensions: this.editorExtensions
            }),
            parent: this.editorRef.value
          }), this.editorRef.value?.addEventListener("wy-submit", this.submit.bind(this))));
        }
      );
    }), t.has("disabled") && this.editor && this.editorEditable && this.EditorView && this.editor.dispatch({
      // Update readonly state
      effects: this.editorEditable.reconfigure(this.EditorView.editable.of(!this.disabled))
    }), t.has("placeholder") && this.editor && this.editorPlaceholder && this.placeholderExtension) {
      const e = this.placeholderExtension(this.placeholder);
      this.editor.dispatch({
        // Update placeholder state
        effects: this.editorPlaceholder.reconfigure(e)
      }), this.setPlaceHolderText();
    }
    t.has("settings") && this.editor && this.editorKeymap && this.keymapFacet && (this.editor.dispatch({
      // Update readonly state
      effects: this.editorKeymap.reconfigure(this.keymapFacet.of(this.getKeymaps()))
    }), this.setEnterKeyHint());
  }
  /**
   * Update the visible placeholder text within the fallback DOM copy.
   *
   * @internal
   */
  setPlaceHolderText() {
    const t = this.renderRoot.querySelector(".cm-placeholder");
    t && this.editor && (t.setAttribute("aria-label", `placeholder ${this.placeholder}`), t.innerText = this.placeholder);
  }
  /**
   * Update contentEditable attribute on the fallback editor.
   *
   * @internal
   */
  setEditable() {
    const t = this.renderRoot.querySelector(".cm-content");
    t && this.editor && (t.contentEditable = String(!this.disabled));
  }
  /**
   * Update enter key hint on the content element.
   *
   * @internal
   */
  setEnterKeyHint() {
    const t = this.renderRoot.querySelector(".cm-content");
    t && this.editor && (t.enterKeyHint = this.settings?.enterToSend === "always" ? "send" : "enter");
  }
  /**
   * Compute and return keymaps for the current settings/editor type.
   *
   * @internal
   */
  getKeymaps() {
    if (!this.keymaps)
      return [];
    const { weavyEnterSendKeymap: t, weavyModifierEnterSendKeymap: e, weavyKeymap: i, defaultKeymap: r, historyKeymap: n } = this.keymaps;
    let a = this.settings?.enterToSend === "never" ? [] : [...e];
    return ((!this.settings?.enterToSend || this.settings?.enterToSend === "auto") && this.editorType === "messages" && fK || this.settings?.enterToSend === "always") && (a = [...t, ...a]), [...a, ...i, ...r, ...n];
  }
  connectedCallback() {
    super.connectedCallback(), window.addEventListener("message", this.createMeeting);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("message", this.createMeeting);
  }
  handleRemoveMeeting() {
    this.meeting = void 0;
  }
  /**
   * Autocomplete handler for mentions. Returns completion results or null.
   *
   * Called by the editor to resolve mention suggestions.
   *
   * @internal
   * @param context - Completion context from the editor
   * @returns Promise<CompletionResult | null>
   */
  async autocomplete(t) {
    if (!this.weavy || !this.app)
      return null;
    let e = t.matchBefore(/(?:^|\s)(?!\]\()@(?=\S)([^@]+)/);
    if (!t.explicit && !e) return null;
    e = t.matchBefore(/@[^@]+/);
    const i = e?.text.substring(1), r = await (await this.weavy.fetch(`/api/apps/${this.app.id}/members?member=null&q=${i}`)).json();
    let n = [];
    return r.data && (n = r.data.filter((a) => typeof a.name < "u").map((a) => ({
      item: a,
      label: a.name,
      apply: /* @__PURE__ */ c((o, l, d, u) => {
        const p = "[" + a.name + "](@u" + a.id.toString() + ")";
        let f = o.state.update({ changes: { from: d - 1, to: d } });
        o.dispatch(f), f = o.state.update({
          changes: { from: d - 1, to: u - 1, insert: p }
        }), o.dispatch(f);
      }, "apply")
    }))), {
      from: e ? e.from + 1 : t.pos,
      options: n,
      filter: !1
    };
  }
  /**
   * Handle files dropped on the editor.
   *
   * @internal
   * @param e - Drop files event
   */
  handleDropFiles(t) {
    const e = t.detail;
    e.files && this.handleUploadFiles(e.files);
  }
  /**
   * Upload array of File objects via the upload blob mutation controller.
   *
   * Preserves input value if provided and saves draft after each upload.
   *
   * @internal
   * @param files - FileList or array of File objects to upload
   * @param input - Optional input element to reset after upload
   */
  async handleUploadFiles(t, e) {
    if (t) {
      for (let i = 0; i < t.length; i++) {
        const r = { file: t[i] };
        await this.uploadBlobMutation.mutate(r), this.saveDraft();
      }
      e && (e.value = "");
    }
  }
  /**
   * Handle external blob imports (cloud/external sources).
   *
   * @internal
   * @param externalBlobs - Array of external blob descriptors
   */
  handleExternalBlobs(t) {
    if (t)
      for (let e = 0; e < t.length; e++) {
        const i = t[e];
        this.externalBlobMutation?.mutate({ externalBlob: i });
      }
  }
  /**
   * Handle removal/abortion of an upload mutation and clean cache state.
   *
   * @internal
   * @param mutation - Mutation state object to remove
   */
  handleRemoveUpload(t) {
    !this.weavy || !this.mutationAppId || (t.status === "pending" && g0(t.variables) && t.variables.abort?.(), l4(
      this.weavy.queryClient,
      ["apps", this.mutationAppId, "blobs", `${this.editorLocation}-${this.parentId || this.mutationAppId}`],
      (e) => e.state.data?.id === t.data?.id
    ));
  }
  /**
   * Persist draft to storage if draft mode is enabled.
   *
   * Saves editor text, embeds, poll options and ongoing file uploads to localStorage.
   *
   * @internal
   */
  saveDraft() {
    if (!this.draft || !this.storage) return;
    const t = this.mutatingFiles.result;
    let e = this.editor?.state.doc.toString();
    if (e === void 0 && (e = this.text), (!t || !t.length) && !this.meeting && !this.embeds.length && (!this.pollOptions.length || this.pollOptions.filter((i) => i.text.trim() !== "").length === 0) && e === "")
      this.storage.removeItem(this.draftKey);
    else {
      const i = {
        meeting: this.meeting,
        text: e,
        pollOptions: this.pollOptions.filter((r) => r.text.trim() !== ""),
        embeds: this.embeds
      };
      this.storage.setItem(this.draftKey, JSON.stringify(i));
    }
  }
  /**
   * Handle removal of an attachment reference from the editor state.
   *
   * @internal
   * @param attachment - Attachment to remove
   */
  handleRemoveAttachment(t) {
    this.attachments = this.attachments.filter((e) => e.id !== t.id);
  }
  /**
   * Submit the editor content by dispatching a `submit` event.
   *
   * Validates that there is content to submit and that no uploads/embeds are still processing.
   *
   * @internal
   */
  submit() {
    const t = this.mutatingFiles.result, e = t?.some((u) => u.status === "pending"), i = this.editor?.state.doc.toString().trim() ?? "", r = this.meeting?.id, n = t?.map((u) => u.data?.id).filter((u) => u), a = this.attachments?.map((u) => u.id) || [], o = this.pollOptions.filter((u) => u.text.trim() !== "");
    if (wV() || e || !this.contextDataBlobs || !i && !r && n?.length == 0 && o.length == 0 && a.length == 0 && this.embeds.length == 0)
      return;
    const l = this.contextDataBlobs.length ? this.contextDataBlobs : void 0, d = new CustomEvent("submit", {
      detail: { text: i, meetingId: r, blobs: n, attachments: a, pollOptions: o, embedId: this.embeds[0]?.id, contextData: l },
      bubbles: !0,
      composed: !0
    });
    this.dispatchEvent(d), this.resetEditor();
  }
  /**
   * Reset the editor state after a successful submit.
   *
   * Clears editor content, removes pending uploads from the query cache and deletes the stored draft.
   *
   * @internal
   */
  resetEditor() {
    this.clearEditor(), this.weavy && this.mutationAppId && jz(this.weavy.queryClient, [
      "apps",
      this.mutationAppId,
      "blobs",
      `${this.editorLocation}-${this.parentId || this.mutationAppId}`
    ]), this.storage?.removeItem(this.draftKey);
  }
  /**
   * Clear the editor UI and internal state (text, embeds, attachments, metadata).
   *
   * @internal
   */
  clearEditor() {
    this.editor?.dispatch({ changes: { from: 0, to: this.editor.state.doc.length, insert: "" } }), this.text = "", this.meeting = void 0, this.pollOptions = [], this.showPolls = !1, this.embeds = [], this.metadata = {}, dK();
  }
  /**
   * Create or initiate a meeting for the current user.
   *
   * If the meeting requires third-party auth, opens an auth popup; otherwise stores the created meeting.
   *
   * @internal
   * @param name - Provider key for the meeting (e.g. "zoom", "google", "microsoft")
   */
  async handleMeetingClick(t) {
    if (!this.weavy || !this.user)
      return;
    const e = await WS(this.weavy, t).mutate();
    e.auth_url ? this.authWindow = window.open(e.auth_url, "oauthwin", "height=640,width=480") : this.meeting = e;
  }
  /**
   * Add a discovered embed to the editor and persist draft.
   *
   * @internal
   * @param embed - Embed object to add.
   */
  setEmbeds(t) {
    this.embeds = [t, ...this.embeds], this.saveDraft();
  }
  /**
   * Scan content for embeds and add them via setEmbeds callback.
   *
   * @internal
   * @param content - Text content to scan for embed links.
   */
  handleEmbeds(t) {
    this.weavy && uK(t, this.setEmbeds.bind(this), this.weavy);
  }
  /**
   * Remove an embed by id from the editor embeds list and persist draft.
   *
   * @internal
   * @param e - Embed remove event containing embed id.
   */
  removeEmbed(t) {
    this.embeds = this.embeds.filter((e) => e.id !== t.detail.id), this.saveDraft();
  }
  /**
   * Cycle the primary embed (move first to the end) and persist draft.
   *
   * @internal
   */
  swapEmbed() {
    const t = this.embeds.shift();
    t && (this.embeds = [...this.embeds, t]), this.saveDraft();
  }
  /**
   * Toggle the poll UI in the editor and initialize default options when opened.
   *
   * @internal
   */
  openPolls() {
    this.showPolls ? this.showPolls = !1 : (this.pollOptions.length === 0 && (this.pollOptions = Array.from({ length: 3 }, () => ({ id: null, text: "" }))), this.showPolls = !0);
  }
  /**
   * Handle change to a poll option input and persist draft.
   *
   * @internal
   * @param e - Input event
   * @param index - Index of the poll option changed
   */
  handlePollOptionChange(t, e) {
    const i = [...this.pollOptions];
    i[e].text = t.target.value, this.pollOptions = i, this.saveDraft();
  }
  /**
   * Add a new poll option when focus reaches the last option (limit 5).
   *
   * @internal
   * @param e - Focus/keyboard event
   * @param index - Index of the poll option that triggered the add
   */
  handlePollOptionAdd(t, e) {
    if (e === this.pollOptions.length - 1 && this.pollOptions.length < 5) {
      const i = { id: null, text: "" };
      this.pollOptions = [...this.pollOptions, i], this.saveDraft();
    }
  }
  /**
   * Editor loading fallback dummy.
   * Hard copy of the rendered nodes when the editor is empty. Cleaned up to not be editable.
   */
  renderEditorDummy() {
    return this.editorInitialized ? C : v`
          <div class="cm-editor">
            <div class="cm-announced"></div>
            <div tabindex="-1" class="cm-scroller">
              <div class="cm-content cm-lineWrapping">
                <div class="cm-line"
                  ><img class="cm-widgetBuffer" aria-hidden="true" /><span class="cm-placeholder"
                    >${this.placeholder}</span
                  ><br
                /></div>
              </div>
            </div>
          </div>
        `;
  }
  renderTopSlot() {
    return C;
  }
  renderMiddleSlot() {
    return v`
      <!-- Input -->
      <div part=${gt({ "wy-post-editor-text": !0, "wy-is-invalid": this.editorError })} ${ht(this.editorRef)}>
        ${this.renderEditorDummy()}
      </div>

      <div part="wy-post-editor-inputs">
        <div part="wy-post-editor-buttons">
          ${this.componentFeatures?.allowsFeature(L.Attachments) ? v`<wy-button
                  kind="icon"
                  @click=${this.openFileInput}
                  title=${P("From device")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon name="attachment"></wy-icon>
                </wy-button>
                <input
                  type="file"
                  ${ht(this.fileInputRef)}
                  @click=${(t) => t.stopPropagation()}
                  @change=${(t) => this.handleUploadFiles(
      Array.from(t.target.files || []),
      t.target
    )}
                  multiple
                  hidden
                  tabindex="-1"
                  ?disabled=${this.disabled}
                />` : C}
          ${this.componentFeatures?.allowsFeature(L.CloudFiles) ? v`<wy-button
                kind="icon"
                @click=${this.openCloudFiles}
                title=${P("From cloud")}
                ?disabled=${this.disabled}
              >
                <wy-icon name="cloud"></wy-icon>
              </wy-button>` : C}
          ${this.componentFeatures?.allowsAnyFeature(L.Meetings, L.ZoomMeetings) ? v`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("zoom")}
                  title=${P("Zoom meeting")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="zoom-meetings"></wy-icon>
                </wy-button>
              ` : C}
          ${this.componentFeatures?.allowsAnyFeature(L.Meetings, L.GoogleMeet) ? v`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("google")}
                  title=${P("Google Meet")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="google-meet"></wy-icon>
                </wy-button>
              ` : C}
          ${this.componentFeatures?.allowsAnyFeature(L.Meetings, L.MicrosoftTeams) ? v`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("microsoft")}
                  title=${P("Microsoft Teams")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="microsoft-teams"></wy-icon>
                </wy-button>
              ` : C}
          ${this.componentFeatures?.allowsFeature(L.Polls) ? v`<wy-button
                kind="icon"
                @click=${() => this.openPolls()}
                title=${P("Poll")}
                ?disabled=${this.disabled}
              >
                <wy-icon name="poll"></wy-icon>
              </wy-button>` : C}
        </div>

        <!-- Button -->
        <wy-button @click="${() => this.submit()}" color="primary" title=${this.buttonText} ?disabled=${this.disabled}>
          ${this.buttonText}
        </wy-button>
      </div>
    `;
  }
  /**
   * Render the bottom slot which aggregates lists (polls, meetings, file uploads, attachments, embeds).
   *
   * @internal
   */
  renderBottomSlot() {
    return [this.renderLists()];
  }
  /**
   * Render the lists section (poll options, meetings, file uploads, attachments, embeds).
   *
   * @internal
   */
  renderLists() {
    const t = this.mutatingFiles.result, e = this.componentFeatures?.allowsFeature(L.Polls) && this.showPolls && this.pollOptions.length > 0 || !1, i = this.meeting?.provider === "zoom" && this.componentFeatures?.allowsAnyFeature(L.Meetings, L.ZoomMeetings) || this.meeting?.provider === "google" && this.componentFeatures?.allowsAnyFeature(L.Meetings, L.GoogleMeet) || this.meeting?.provider === "microsoft" && this.componentFeatures?.allowsAnyFeature(L.Meetings, L.MicrosoftTeams) || !1, r = t && t.length > 0 || !1, n = this.attachments && this.attachments.length > 0, a = this.componentFeatures?.allowsFeature(L.Embeds) && this.embeds.length > 0 || !1;
    return this.disabled || !(e || i || r || n || a) ? C : v` <div part="wy-editor-parts">
      <!-- polls -->
      ${e ? v`
            <div part="wy-poll-form">
              ${this.pollOptions.map((o, l) => {
      const d = l + 1;
      return v`<input
                  value="${o.text}"
                  part="wy-input"
                  type="text"
                  placeholder=${P(lt`Option ${d}`)}
                  @change=${(u) => this.handlePollOptionChange(u, l)}
                  @keyup=${nn}
                  @focus=${(u) => this.handlePollOptionAdd(u, l)}
                />`;
    })}
            </div>
          ` : C}

      <!-- meetings -->
      ${i && this.meeting ? v`
            <wy-item size="sm">
              <wy-icon slot="image" svg="${E0(this.meeting.provider)}"></wy-icon>
              <span slot="title">${_0(this.meeting.provider)}</span>
              <wy-button slot="actions" kind="icon" @click=${() => this.handleRemoveMeeting()}>
                <wy-icon name="close"></wy-icon>
              </wy-button>
            </wy-item>
          ` : C}

      <!-- blobs -->
      ${r && t ? v`<div>
            ${qi(
      t,
      (o) => "mutation" + o.submittedAt,
      (o) => {
        if (o.context?.file) {
          const l = o.context.file, d = {
            ...o.context.status
          };
          return v`
                    <wy-file-item
                      .file=${o.context.file}
                      .status=${d}
                      title="${VP(o.context.type)}: ${l.name + (d.text ? `: ${d.text}` : "")}"
                    >
                      <span slot="title"
                        ><strong></strong> ${l.name}
                        ${d.text ? v`: <em>${d.text}</em>` : C}</span
                      >
                      ${d.state === "pending" ? v`
                            <wy-progress-circular
                              slot="actions"
                              padded
                              ?indeterminate=${!d.progress}
                              .max=${100}
                              .value=${d.progress || 0}
                            ></wy-progress-circular>
                          ` : C}
                      <wy-button
                        slot="actions"
                        kind="icon"
                        @click=${() => {
            this.handleRemoveUpload(o);
          }}
                        title=${P("Discard", { desc: "Button action to discard" })}
                      >
                        <wy-icon name="close"></wy-icon>
                      </wy-button>
                    </wy-file-item>
                  `;
        }
        return C;
      }
    )}
          </div>` : C}

      <!-- attachments -->
      ${n ? this.attachments.map(
      (o) => v`<wy-file-item .file=${o} title="${o.name}">
              <span slot="title">${o.name}</span>
              <wy-button
                slot="actions"
                kind="icon"
                @click=${() => this.handleRemoveAttachment(o)}
                title=${P("Remove", { desc: "Button action to remove" })}
              >
                <wy-icon name="close"></wy-icon>
              </wy-button>
            </wy-file-item>`
    ) : C}

      <!-- embeds -->
      ${a ? v`
            <wy-embed-select
              .embeds=${this.embeds}
              @embed-remove=${(o) => this.removeEmbed(o)}
              @embed-swap=${() => this.swapEmbed()}
            ></wy-embed-select>
          ` : C}
    </div>`;
  }
  /**
   * Render the cloud files picker if cloud files feature is enabled.
   *
   * @internal
   */
  renderCloudFiles() {
    return this.disabled ? C : v`
      <wy-cloud-files
        ${ht(this.cloudFilesRef)}
        @external-blobs=${(t) => this.handleExternalBlobs(t.detail.externalBlobs)}
      ></wy-cloud-files>
    `;
  }
  render() {
    const t = this.dropZone.isDragActive;
    return v`
      <div
        part=${gt({
      "wy-editor": !0,
      [this.editorClass]: !0,
      "wy-dragging": t
    })}
        data-drag-title=${P("Drop files here")}
      >
        ${this.renderTopSlot()} ${this.renderMiddleSlot()} ${this.renderBottomSlot()}
      </div>
      ${this.renderCloudFiles()}
    `;
  }
}, h(pm, "Eo"), pm), c(Cx, "WyEditor"), Cx);
Bt.styles = [pe, mK, yK, J4, bV, Ea];
ae([
  b({ type: Boolean })
], Bt.prototype, "disabled", 2);
ae([
  b({ attribute: !1 })
], Bt.prototype, "parentId", 2);
ae([
  b()
], Bt.prototype, "placeholder", 1);
ae([
  b()
], Bt.prototype, "text", 2);
ae([
  b({ type: Object })
], Bt.prototype, "metadata", 2);
ae([
  b({ attribute: !1 })
], Bt.prototype, "embed", 2);
ae([
  b({ attribute: !1 })
], Bt.prototype, "options", 2);
ae([
  b({ attribute: !1 })
], Bt.prototype, "attachments", 2);
ae([
  b()
], Bt.prototype, "buttonText", 2);
ae([
  b({ type: Boolean })
], Bt.prototype, "typing", 2);
ae([
  b({ type: Boolean })
], Bt.prototype, "draft", 2);
ae([
  b()
], Bt.prototype, "editorType", 2);
ae([
  b()
], Bt.prototype, "editorClass", 2);
ae([
  b()
], Bt.prototype, "editorLocation", 2);
ae([
  N()
], Bt.prototype, "meeting", 2);
ae([
  N()
], Bt.prototype, "editorError", 2);
ae([
  N()
], Bt.prototype, "showPolls", 2);
ae([
  N()
], Bt.prototype, "pollOptions", 2);
ae([
  N()
], Bt.prototype, "embeds", 1);
ae([
  N()
], Bt.prototype, "draftKey", 2);
ae([
  N()
], Bt.prototype, "mutationAppId", 2);
ae([
  N()
], Bt.prototype, "keyMap", 2);
ae([
  N()
], Bt.prototype, "editorExtensions", 2);
ae([
  N()
], Bt.prototype, "editor", 2);
Bt = ae([
  Y("wy-editor"),
  At()
], Bt);
var CK = Object.getOwnPropertyDescriptor, PK = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? CK(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = a(r) || r);
  return r;
}, "__decorateClass$H"), Px, fm;
let z0 = (Px = (fm = class extends Bt {
  constructor() {
    super(), this.editorType = "comments", this.editorClass = "wy-comment-editor";
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("editorLocation") && (this.editorLocation === "files" ? this.editorClass = "wy-comment-editor wy-comment-editor-bottom" : this.editorLocation === "apps" && (this.editorClass = "wy-comment-editor wy-comment-editor-bottom"));
  }
  /**
   * Render the top slot for comment editor with no content.
   *
   * @internal
   */
  renderTopSlot() {
    return C;
  }
  /**
   * Render the primary middle slot containing the add-menu, editor and send button.
   *
   * Overrides the base implementation to provide message-specific controls and layout.
   *
   * @internal
   */
  renderMiddleSlot() {
    return v`<div part="wy-comment-editor-inputs">
      <!-- Add -->
      ${this.componentFeatures?.allowsAnyFeature(
      L.Attachments,
      L.CloudFiles,
      L.Meetings,
      L.ZoomMeetings,
      L.GoogleMeet,
      L.MicrosoftTeams,
      L.Polls
    ) ? v`<wy-dropdown icon="plus" directionY="up" ?disabled=${this.disabled}>
            ${this.componentFeatures?.allowsFeature(L.Attachments) ? v`<wy-dropdown-item @click=${this.openFileInput} title=${P("From device")}>
                    <wy-icon name="attachment"></wy-icon>
                    <span>${P("From device")}</span>
                  </wy-dropdown-item>
                  <input
                    type="file"
                    ${ht(this.fileInputRef)}
                    @click=${(t) => t.stopPropagation()}
                    @change=${(t) => this.handleUploadFiles(
      Array.from(t.target.files || []),
      t.target
    )}
                    multiple
                    hidden
                    tabindex="-1"
                  />` : C}
            ${this.componentFeatures?.allowsFeature(L.CloudFiles) ? v`<wy-dropdown-item @click=${this.openCloudFiles} title=${P("From cloud")}>
                  <wy-icon name="cloud"></wy-icon>
                  <span>${P("From cloud")}</span>
                </wy-dropdown-item>` : C}
            ${this.componentFeatures?.allowsAnyFeature(L.Meetings, L.ZoomMeetings) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("zoom")} title=${P("Zoom meeting")}>
                    <wy-icon svg="zoom-meetings"></wy-icon>
                    <span>${P("Zoom meeting")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsAnyFeature(L.Meetings, L.GoogleMeet) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("google")} title=${P("Google Meet")}>
                    <wy-icon svg="google-meet"></wy-icon>
                    <span>${P("Google Meet")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsAnyFeature(L.Meetings, L.MicrosoftTeams) ? v`
                  <wy-dropdown-item
                    @click=${() => this.handleMeetingClick("microsoft")}
                    title=${P("Microsoft Teams")}
                  >
                    <wy-icon svg="microsoft-teams"></wy-icon>
                    <span>${P("Microsoft Teams")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsFeature(L.Polls) ? v`<wy-dropdown-item @click=${() => this.openPolls()} title=${P("Poll")}>
                  <wy-icon name="poll"></wy-icon>
                  <span>${P("Poll")}</span>
                </wy-dropdown-item>` : C}
          </wy-dropdown>` : C}

      <!-- Input -->
      <div
        part=${gt({ "wy-comment-editor-text": !0, "wy-is-invalid": this.editorError })}
        ${ht(this.editorRef)}
      >
        ${this.renderEditorDummy()}
      </div>

      <!-- Button -->
      <wy-button kind="icon" @click="${() => this.submit()}" title=${this.buttonText} ?disabled=${this.disabled}>
        <wy-icon name="send"></wy-icon>
      </wy-button>
    </div>`;
  }
  /**
   * Render content that appears below the message editor.
   *
   * By default returns the same lists section used by the base editor.
   *
   * @internal
   */
  renderBottomSlot() {
    return [
      this.renderLists()
    ];
  }
}, h(fm, "Ro"), fm), c(Px, "WyCommentEditor"), Px);
z0.styles = [...Bt.styles, oK];
z0 = PK([
  Y("wy-comment-editor"),
  At()
], z0);
var QK = Object.defineProperty, TK = Object.getOwnPropertyDescriptor, xV = /* @__PURE__ */ c((s) => {
  throw TypeError(s);
}, "__typeError$9"), Hy = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? TK(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && QK(t, e, r), r;
}, "__decorateClass$G"), kV = /* @__PURE__ */ c((s, t, e) => t.has(s) || xV("Cannot " + e), "__accessCheck$9"), xv = /* @__PURE__ */ c((s, t, e) => (kV(s, t, "read from private field"), e ? e.call(s) : t.get(s)), "__privateGet$9"), Qx = /* @__PURE__ */ c((s, t, e) => t.has(s) ? xV("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(s) : t.set(s, e), "__privateAdd$9"), Tx = /* @__PURE__ */ c((s, t, e, i) => (kV(s, t, "write to private field"), t.set(s, e), e), "__privateSet$8"), fO, qS, ih, Mx, mm;
let hn = (Mx = (mm = class extends Pe {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.location = "apps", this.reveal = !1, this.padded = !1, Qx(this, fO), Qx(this, qS, new Promise((t) => {
      Tx(this, fO, t);
    })), this.commentsQuery = new Wl(this), this.addCommentMutation = new Wr(this), this.infiniteScroll = new Fl(this), this.pagerRef = $t(), Qx(this, ih), this.handleRealtimeCommentCreated = () => {
      this.weavy?.queryClient.invalidateQueries({ queryKey: [this.location, this.parentId, "comments"] });
    }, this.handleRealtimeReactionAdded = (t) => {
      !this.weavy || t.entity.type !== vi.Comment || ke(
        this.weavy.queryClient,
        [this.location, this.parentId, "comments"],
        t.entity.id,
        (e) => {
          Py(e, t.reaction, t.actor);
        }
      );
    }, this.handleRealtimeReactionDeleted = (t) => {
      !this.weavy || t.entity.type !== vi.Comment || ke(
        this.weavy.queryClient,
        [this.location, this.parentId, "comments"],
        t.entity.id,
        (e) => {
          Py(e, void 0, t.actor);
        }
      );
    };
  }
  /**
   * Resolves when `parentId` is available.
   *
   * @returns Promise<number>
   */
  async whenParentId() {
    return await xv(this, qS);
  }
  async willUpdate(t) {
    var e, i;
    if (super.willUpdate(t), t.has("parentId") && this.parentId && ((e = xv(this, fO)) == null || e.call(this, this.parentId)), (t.has("parentId") || t.has("weavy") || t.has("componentFeatures")) && this.parentId && this.weavy && (await this.commentsQuery.trackInfiniteQuery(aV(this.weavy, this.location, this.parentId)), await this.addCommentMutation.trackMutation(lV(this.weavy)), this.removeCommentMutation = hV(this.weavy, this.location, this.parentId), this.restoreCommentMutation = uV(this.weavy, this.location, this.parentId)), (t.has("weavy") || t.has("app") || t.has("componentFeatures")) && this.weavy && this.app) {
      this.pollMutation = Vb(this.weavy, this.app.id, [this.location, this.parentId, "comments"]), (i = xv(this, ih)) == null || i.call(this);
      const r = `a${this.app.id}`;
      this.weavy.subscribe(r, "comment_created", this.handleRealtimeCommentCreated), this.componentFeatures?.allowsFeature(L.Reactions) && (this.weavy.subscribe(r, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(r, "reaction_removed", this.handleRealtimeReactionDeleted)), Tx(this, ih, () => {
        this.weavy?.unsubscribe(r, "comment_created", this.handleRealtimeCommentCreated), this.weavy?.unsubscribe(r, "reaction_added", this.handleRealtimeReactionAdded), this.weavy?.unsubscribe(r, "reaction_removed", this.handleRealtimeReactionDeleted), Tx(this, ih, void 0);
      });
    }
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.commentsQuery.result, this.pagerRef.value);
  }
  /**
   * Handle submit from the comment editor and trigger add comment mutation.
   *
   * @internal
   */
  async handleSubmit(t) {
    this.app && this.parentId && this.user && await this.addCommentMutation.mutate({
      app_id: this.app.id,
      parent_id: this.parentId,
      type: this.location,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      context: t.detail.contextData,
      user: this.user
    });
  }
  /**
   * Render comment items from a flattened page array.
   *
   * @internal
   */
  renderComments(t) {
    return t ? qi(
      t,
      (e) => e.id,
      (e) => this.parentId ? v`<wy-comment
                id="comment-${e.id}"
                ?reveal=${this.reveal}
                .parentId=${this.parentId}
                .location=${this.location}
                .comment=${e}
                @trash=${async (i) => {
        const r = await this.whenApp(), n = await this.whenParentId();
        this.removeCommentMutation?.mutate({
          id: i.detail.id,
          appId: r.id,
          parentId: n,
          type: this.location
        });
      }}
                @restore=${async (i) => {
        const r = await this.whenApp(), n = await this.whenParentId();
        this.restoreCommentMutation?.mutate({
          id: i.detail.id,
          appId: r.id,
          parentId: n,
          type: this.location
        });
      }}
                @vote=${(i) => {
        i.detail.parentId && i.detail.parentType && this.pollMutation?.mutate({
          optionId: i.detail.optionId,
          parentType: i.detail.parentType,
          parentId: i.detail.parentId
        });
      }}
              ></wy-comment>` : C
    ) : C;
  }
  render() {
    const { data: t, hasNextPage: e, isPending: i } = this.commentsQuery.result ?? {}, r = ys(t);
    return v`
      ${r && r.length ? v`
            <div part="wy-comments">
              ${this.renderComments(r)}
              ${e ? v`<div ${ht(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
            </div>
          ` : v`
            <wy-empty noNetwork
              ><wy-progress-circular indeterminate padded reveal ?hidden=${!i}></wy-progress-circular
            ></wy-empty>
          `}

      <wy-comment-editor
        editorLocation=${this.location}
        .parentId=${this.parentId}
        .typing=${!1}
        .draft=${!0}
        ?disabled=${!Oy(ml.Create, this.app?.permissions)}
        placeholder=${this.placeholder ?? P("Create a comment...")}
        buttonText=${P("Comment", { desc: "Button action to comment" })}
        @submit=${(n) => this.handleSubmit(n)}
      ></wy-comment-editor>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = xv(this, ih)) == null || t.call(this), super.disconnectedCallback();
  }
}, h(mm, "To"), mm), c(Mx, "WyCommentList"), Mx);
fO = /* @__PURE__ */ new WeakMap();
qS = /* @__PURE__ */ new WeakMap();
ih = /* @__PURE__ */ new WeakMap();
hn.styles = [r3, Ma];
Hy([
  b({ type: Number })
], hn.prototype, "parentId", 2);
Hy([
  b({ attribute: !1 })
], hn.prototype, "location", 2);
Hy([
  b()
], hn.prototype, "placeholder", 2);
Hy([
  b({ type: Boolean, reflect: !0 })
], hn.prototype, "reveal", 2);
Hy([
  b({ type: Boolean, reflect: !0 })
], hn.prototype, "padded", 2);
hn = Hy([
  Y("wy-comment-list"),
  At()
], hn);
function e2(s, t) {
  return ["apps", s.id, "file", t.id, "versions"];
}
h(e2, "Fy");
c(e2, "getFileVersionsKey");
function SV(s, t, e) {
  const i = s.queryClient, r = ["apps", t.id, "files"], n = e2(t, e), a = {
    mutationKey: r,
    mutationFn: /* @__PURE__ */ c(async ({ versionFile: o }) => {
      if (o.id >= 1 && o.rev) {
        if (!(await s.fetch(`/api/files/${o.id}/versions/${o.rev}/restore`, {
          method: "POST"
        })).ok)
          throw new Error();
      } else
        throw new Error(`Could not restore ${o.name} to version ${o.rev}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((o) => (Rt(
      i,
      { queryKey: a.mutationKey, exact: !1 },
      o.versionFile.id,
      (l) => Object.assign(l, o.versionFile, { status: "pending" })
    ), { type: "version", file: e, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ c((o, l) => {
      Rt(
        i,
        { queryKey: a.mutationKey, exact: !1 },
        l.versionFile.id,
        (d) => Object.assign(d, o, { status: "ok" })
      ), he(i, a.mutationKey, l, (d) => {
        d.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ c((o, l, d) => {
      d?.file && Rt(
        i,
        { queryKey: a.mutationKey, exact: !1 },
        l.versionFile.id,
        (u) => Object.assign(u, d.file, { status: "error" })
      ), he(i, a.mutationKey, l, (u) => {
        u.status.state = "error", u.status.text = o.message;
      });
    }, "onError"),
    onSettled: /* @__PURE__ */ c(async () => {
      await i.invalidateQueries({ queryKey: n });
    }, "onSettled")
  };
  return a;
}
h(SV, "v3");
c(SV, "getFileVersionRestoreMutationOptions");
function CV(s, t, e) {
  return new Yt(s.queryClient, SV(s, t, e));
}
h(CV, "g3");
c(CV, "getFileVersionRestoreMutation");
function PV(s, t, e) {
  const i = s.queryClient, r = e2(t, e);
  return {
    mutationKey: r,
    mutationFn: /* @__PURE__ */ c(async ({ versionFile: n }) => {
      if (n.id >= 1 && n.rev) {
        const a = await s.fetch(`/api/files/${n.id}/versions/${n.rev}`, {
          method: "DELETE"
        });
        if (!a.ok) {
          const o = await a.json();
          throw new Error(o.detail || o.title, { cause: o });
        }
      } else {
        const a = {
          status: 400,
          title: `Could not remove ${n.name} version ${n.rev}.`
        };
        throw new Error(a.detail || a.title, { cause: a });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((n) => {
      ke(
        i,
        r,
        /* @__PURE__ */ c((a) => a.id === n.versionFile.id && a.rev === n.versionFile.rev, "versionPredicate"),
        (a) => Object.assign(a, { status: "pending" })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((n, a) => {
      Ib(i, r, /* @__PURE__ */ c((o) => o.id === a.versionFile.id && o.rev === a.versionFile.rev, "versionPredicate"));
    }, "onSuccess"),
    onError: /* @__PURE__ */ c((n, a) => {
      ke(
        i,
        r,
        /* @__PURE__ */ c((o) => o.id === a.versionFile.id && o.rev === a.versionFile.rev, "versionPredicate"),
        (o) => Object.assign(o, { status: void 0 })
      );
    }, "onError")
  };
}
h(PV, "b3");
c(PV, "getFileVersionDeleteMutationOptions");
function QV(s, t, e) {
  return new Yt(s.queryClient, PV(s, t, e));
}
h(QV, "x3");
c(QV, "getFileVersionDeleteMutation");
var MK = Object.defineProperty, AK = Object.getOwnPropertyDescriptor, n3 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? AK(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && MK(t, e, r), r;
}, "__decorateClass$F"), Ax, ym;
let p1 = (Ax = (ym = class extends Pe {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.fileVersionsQuery = new Qr(this);
  }
  /**
   * Selects the provided version and emits `file-version-select`.
   *
   * @param versionFile - Version to select.
   */
  selectVersion(t) {
    this.activeVersion = t, this.dispatchFileVersionSelect(t);
  }
  /**
   * Emit a `file-version-select` event with the chosen version.
   *
   * @internal
   * @param versionFile - Version to announce.
   * @returns Whether the event was not canceled.
   */
  dispatchFileVersionSelect(t) {
    const e = new CustomEvent("file-version-select", {
      detail: { versionFile: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Revert the file to the supplied version.
   *
   * @internal
   * @param versionFile - Version to restore.
   */
  handleRevert(t) {
    this.fileVersionRestoreMutation?.mutate({ versionFile: t }), this.selectVersion(t);
  }
  /**
   * Remove the supplied version and adjust the active selection if needed.
   *
   * @internal
   * @param versionFile - Version to delete.
   */
  handleRemove(t) {
    this.fileVersionDeleteMutation?.mutate({ versionFile: t }), this.activeVersion === t && (this.activeVersion = this.file);
  }
  /**
   * Download the provided version via the browser.
   *
   * @internal
   * @param file - Version file to download.
   */
  triggerDownload(t) {
    ps(t.download_url, "_top", t.name, !0);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("file") || t.has("app")) && this.weavy && this.file && this.app && (await this.fileVersionsQuery.trackQuery(
      Wy(
        this.weavy,
        e2(this.app, this.file),
        `/api/files/${this.file.id}/versions`
      )
    ), this.fileVersionRestoreMutation = CV(this.weavy, this.app, this.file), this.fileVersionDeleteMutation = QV(this.weavy, this.app, this.file));
  }
  render() {
    const { data: t, isPending: e } = this.fileVersionsQuery.result ?? { isPending: !0 };
    return e ? v`<wy-progress-circular indeterminate overlay></wy-progress-circular>` : t?.data ? v`
          <wy-item-list part="wy-versions">
            ${qi(
      t.data,
      (i) => i.id,
      (i, r) => {
        const n = wn(i.name || "").icon, a = t.data ? t.data.length - r : NaN, o = dr(i.name), l = new Date(i.updated_at || i.created_at), d = !!this.file.external_url, u = new Intl.DateTimeFormat(this.weavy?.locale, {
          dateStyle: "full",
          timeStyle: "short"
        }).format(l), p = Hl(this.weavy?.locale, new Date(l));
        return d ? v`
                      <wy-empty noNetwork>
                        <span slot="title">${P("Versions are not available for external cloud files.")}</span>
                      </wy-empty>
                    ` : v`
                      <wy-item
                        size="lg"
                        interactive
                        ?selected=${i.rev == this.activeVersion?.rev}
                        tabindex="0"
                        @click=${() => this.selectVersion(i)}
                        @keydown=${Ze}
                        @keyup=${bi}
                      >
                        <wy-icon
                          slot="image"
                          name=${n}
                          size="48"
                          kind=${i.kind}
                          ext=${o}
                        ></wy-icon>
                        <span slot="title">${a}. ${i.name}</span>
                        <span slot="text">
                          <time datetime=${i.updated_at || i.created_at} title=${u}
                            >${p}</time
                          >
                          ${i.updated_by ? v`· ${i.updated_by?.name}` : C}
                        </span>

                        <wy-dropdown slot="actions" directionX="left">
                          <wy-dropdown-item @click=${() => this.triggerDownload(i)}>
                            <wy-icon name="download"></wy-icon>
                            ${P("Download")}
                          </wy-dropdown-item>

                          ${r !== 0 ? v`
                                <wy-dropdown-divider></wy-dropdown-divider>
                                <wy-dropdown-item @click=${() => this.handleRevert(i)}>
                                  <wy-icon name="restore"></wy-icon>
                                  ${"Revert"}
                                </wy-dropdown-item>
                                <wy-dropdown-item @click=${() => this.handleRemove(i)}>
                                  <wy-icon name="delete"></wy-icon>
                                  ${P("Remove", { desc: "Button action to remove" })}
                                </wy-dropdown-item>
                              ` : C}
                        </wy-dropdown>
                      </wy-item>
                    `;
      }
    )}
          </wy-item-list>
        ` : C;
  }
}, h(ym, "Lo"), ym), c(Ax, "WyFileVersions"), Ax);
n3([
  b({ attribute: !1 })
], p1.prototype, "file", 2);
n3([
  b({ attribute: !1 })
], p1.prototype, "activeVersion", 2);
p1 = n3([
  Y("wy-file-versions"),
  At()
], p1);
var RK = Object.defineProperty, EK = Object.getOwnPropertyDescriptor, Ue = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? EK(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && RK(t, e, r), r;
}, "__decorateClass$E"), Rx, gm;
let we = (Rx = (gm = class extends Pe {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.currentId = NaN, this.isAttachment = !1, this.filled = !1, this.showOverlay = !1, this.commentsOpen = !1, this.versionsOpen = !1, this.sidePanelMaximized = !1, this.persistState = new Q1(this), this.swipeScroller = new bU(this), this.previewFileRef = $t(), this.nextRef = $t(), this.prevRef = $t(), this.loadingQueue = [], this.disableSwipeScroll = !1, this.handleKeys = (t) => {
      this.showOverlay && (t.key === "ArrowLeft" ? (t.stopPropagation(), this.setPrev()) : t.key === "ArrowRight" && (t.stopPropagation(), this.setNext()));
    };
  }
  /**
   * Moves a file to the front of the loading queue.
   *
   * @internal
   * @param file - File to prioritize.
   * @param state - Optional state override.
   */
  moveFirstInQueue(t, e) {
    let i = { file: t };
    const r = this.loadingQueue.filter((n) => n.file === t ? (i = n, !1) : !0);
    this.loadingQueue = [{ ...i, ...e }, ...r];
  }
  /**
   * Updates loading metadata for the supplied file.
   *
   * @internal
   * @param file - File whose state should change.
   * @param state - State patch to merge.
   */
  updateLoadingState(t, e) {
    t && (this.loadingQueue = this.loadingQueue.map((i) => t === i.file ? { ...i, ...e } : i));
  }
  /**
   * Marks the next unloaded item as loading.
   *
   * @internal
   */
  loadNextInQueue() {
    const t = this.loadingQueue.find((e) => !e.loaded);
    t && !t?.loading && this.updateLoadingState(t.file, { loading: !0 });
  }
  /**
   * Emits `wy-preview-open` with the current preview context.
   *
   * @internal
   */
  async dispatchOpen() {
    const t = await this.whenApp(), e = await this.whenComponentFeatures(), i = this.currentId, r = this.commentsOpen ? "comments" : this.versionsOpen ? "versions" : void 0, n = this.currentFile ? [this.currentFile] : [], a = this.isAttachment, o = this.contextDataBlobs, l = new CustomEvent("wy-preview-open", {
      detail: {
        fileId: i,
        tab: r,
        files: n,
        app: t,
        features: e.allowedFeatures().join(" "),
        isAttachment: a,
        contextDataBlobs: o
      },
      cancelable: !0,
      bubbles: !1,
      composed: !0
    });
    this.dispatchEvent(l) || (this.showOverlay = !1, this.commentsOpen = !1, this.versionsOpen = !1);
  }
  /**
   * Emits the `wy-preview-close` event.
   *
   * @internal
   */
  dispatchClose() {
    const t = new CustomEvent("wy-preview-close", {
      cancelable: !1,
      bubbles: !1,
      composed: !0
    });
    this.dispatchEvent(t);
  }
  /**
   * Opens the overlay for the provided file identifier.
   *
   * @param fileId - File to display.
   * @param showTab - Optional sidebar tab to activate.
   */
  async open(t, e) {
    await this.whenApp(), await this.updateComplete, t && (this.currentId = t), e && this.toggleSidebarTab(e, !0), this.showOverlay = !0;
  }
  /**
   * Closes the preview overlay.
   */
  close() {
    this.showOverlay = !1;
  }
  /**
   * Toggles sidebar visibility for comments or versions.
   *
   * @internal
   * @param tab - Sidebar to affect.
   * @param state - Forced open state; toggles when omitted.
   */
  toggleSidebarTab(t, e) {
    t === "comments" ? (this.versionsOpen = !1, this.commentsOpen = e !== void 0 ? e : !this.commentsOpen) : t === "versions" ? (this.commentsOpen = !1, this.versionsOpen = e !== void 0 ? e : !this.versionsOpen) : (this.commentsOpen = !1, this.versionsOpen = !1);
  }
  /**
   * Handles file version selection events.
   *
   * @internal
   * @param e - Version selection event.
   */
  handleVersionFile(t) {
    this.currentVersionFile = t.detail.versionFile;
  }
  /**
   * Scrolls to the previous preview area.
   *
   * @internal
   */
  scrollToPrev() {
    this.prevRef.value && (this.unblockSwipeScroll(), this.prevRef.value.scrollIntoView({ behavior: this.weavy?.scrollBehavior }));
  }
  /**
   * Scrolls to the next preview area.
   *
   * @internal
   */
  scrollToNext() {
    this.nextRef.value && (this.unblockSwipeScroll(), this.nextRef.value.scrollIntoView({ behavior: this.weavy?.scrollBehavior }));
  }
  /**
   * Disables swipe scrolling for a short duration.
   *
   * @internal
   * @param duration - Milliseconds before re-enabling.
   */
  blockSwipeScroll(t = 20) {
    window.clearTimeout(this.disableSwipeScrollTimeout), this.disableSwipeScroll = !0, this.disableSwipeScrollTimeout = window.setTimeout(() => this.disableSwipeScroll = !1, t);
  }
  /**
   * Re-enables swipe scrolling immediately.
   *
   * @internal
   */
  unblockSwipeScroll() {
    window.clearTimeout(this.disableSwipeScrollTimeout), this.disableSwipeScroll = !1;
  }
  /**
   * Selects the previous file when available.
   *
   * @internal
   */
  setPrev() {
    this.previousFile && (this.currentId = this.previousFile.id, this.blockSwipeScroll());
  }
  /**
   * Selects the next file when available.
   *
   * @internal
   */
  setNext() {
    this.nextFile && (this.currentId = this.nextFile.id, this.blockSwipeScroll());
  }
  /**
   * Registers swipe observers on the active scroll element.
   *
   * @internal
   */
  registerSwipeScroller() {
    this.swipeScrollElement && (this.swipeScroller.whenPrev ??= () => this.setPrev(), this.swipeScroller.whenNext ??= () => this.setNext(), this.swipeScroller.createObserver(this.swipeScrollElement));
  }
  async willUpdate(t) {
    if (super.willUpdate(t), (t.has("app") || t.has("user")) && this.app && this.user && !this.isAttachment && (this.persistState.observe(
      [
        { name: "commentsOpen", override: !0 },
        { name: "versionsOpen", override: !0 }
      ],
      `a${this.app.id}-preview`,
      `u${this.user.id}`
    ), this.commentsOpen && this.versionsOpen && (this.versionsOpen = !1)), t.has("queryResult") && this.queryResult) {
      const { data: e } = this.queryResult ?? {};
      this.files = e?.filter((i) => i && !i.is_trashed);
    }
    if (t.has("infiniteQueryResult") && this.infiniteQueryResult) {
      const { data: e } = this.infiniteQueryResult ?? {};
      this.files = ys(e).filter((i) => i && !i.is_trashed);
    }
    t.has("currentFile") && this.currentFile && this.currentFile.id !== this.currentId && (this.currentId = this.currentFile.id), (t.has("files") || t.has("currentId") || t.has("showOverlay")) && this.files && this.showOverlay && (this.currentFile = void 0, this.previousFile = void 0, this.nextFile = void 0, this.currentVersionFile = void 0, this.currentVersionFile = this.currentFile = this.files.find((e, i) => this.files && e.id === this.currentId ? (i >= 1 && (this.previousFile = this.files[i - 1]), i < this.files.length - 1 && (this.nextFile = this.files[i + 1]), this.infiniteQueryResult && i >= this.files.length - 2 && this.infiniteQueryResult.hasNextPage && !this.infiniteQueryResult.isFetchingNextPage && this.infiniteQueryResult.fetchNextPage(), this.infiniteQueryResult && i <= 1 && this.infiniteQueryResult.hasPreviousPage && !this.infiniteQueryResult.isFetchingPreviousPage && this.infiniteQueryResult.fetchPreviousPage(), !0) : !1)), t.has("currentFile") && this.currentFile && !this.files && (this.files = [this.currentFile]), t.has("previousFile") && this.previousFile && this.moveFirstInQueue(this.previousFile), t.has("nextFile") && this.nextFile && this.moveFirstInQueue(this.nextFile), t.has("currentVersionFile") && this.currentVersionFile && this.moveFirstInQueue(this.currentVersionFile, { loading: !0 }), t.has("loadingQueue") && this.loadNextInQueue(), t.has("showOverlay") && (this.showOverlay ? await this.dispatchOpen() : t.get("showOverlay") && this.dispatchClose());
  }
  /**
   * Renders the preview header for the active file.
   *
   * @internal
   * @param activeFile - File displayed in the main pane.
   */
  renderHeader(t) {
    return v`
      <wy-titlebar header ?trashed=${!!t?.is_trashed}>
        <wy-button slot="icon" kind="icon" @click=${() => this.close()}><wy-icon name="close"></wy-icon></wy-button>
        ${t ? v` <span slot="title">${t.name}</span> ` : C}
        ${t ? v`
              ${this.componentFeatures?.allowsFeature(L.Comments) && t.id >= 1 && !this.isAttachment ? v`
                    <wy-button
                      slot="actions"
                      kind="icon"
                      ?active=${this.commentsOpen}
                      @click=${() => this.toggleSidebarTab("comments")}
                      title=${P("Comments")}
                    >
                      <wy-icon-stack>
                        ${t.comments?.count && t.comments?.count > 0 ? v`<wy-icon name="comment" state ?active=${!this.commentsOpen}></wy-icon>
                              <wy-icon name="comment" layer state ?active=${this.commentsOpen}></wy-icon>` : v`<wy-icon name="comment-outline" state ?active=${!this.commentsOpen}></wy-icon>
                              <wy-icon name="comment" layer state ?active=${this.commentsOpen}></wy-icon>`}
                      </wy-icon-stack>
                    </wy-button>
                  ` : C}
              <wy-file-menu slot="actions" .file=${t}>
                ${this.componentFeatures?.allowsFeature(L.Versions) && t.id >= 1 && !this.isAttachment ? v`
                      <wy-dropdown-item ?active=${this.versionsOpen} @click=${() => this.toggleSidebarTab("versions")}>
                        <wy-icon name="backup-restore"></wy-icon>
                        ${P("Versions")}
                      </wy-dropdown-item>
                    ` : C}
              </wy-file-menu>
            ` : C}
      </wy-titlebar>
    `;
  }
  render() {
    let t = this.files === void 0;
    this.queryResult ? t = this.queryResult.isPending : this.infiniteQueryResult && (t = this.infiniteQueryResult.isPending);
    const e = [this.previousFile, this.currentVersionFile, this.nextFile].filter((r) => r);
    this.commentsOpen && this.versionsOpen && (this.versionsOpen = !1);
    const i = {
      "wy-preview-swiper-disabled": this.disableSwipeScroll
    };
    return this.weavy ? v`
      <wy-overlay
        part="wy-dark"
        maximized
        noHeader
        type=${this.filled ? "full" : "modal"}
        .show=${this.showOverlay}
        @keyup=${this.handleKeys}
        @close=${() => {
      this.showOverlay = !1;
    }}
      >
        ${this.showOverlay ? v`<div part="wy-preview-layout">
              ${this.renderHeader(this.currentFile)}

              <div part="wy-preview-main">
                ${this.isAttachment ? C : v` <aside
                        id="tab-comments"
                        part="wy-sidebar ${gt({
      "wy-active": this.commentsOpen,
      "wy-maximized": this.sidePanelMaximized
    })}"
                        ?hidden=${!this.commentsOpen}
                      >
                        <nav>
                          <wy-item size="md">
                            <span slot="title" part="wy-title">${P("Comments")}</span>
                            <wy-button
                              slot="actions"
                              kind="icon"
                              @click=${() => this.toggleSidebarTab("comments", !1)}
                            >
                              <wy-icon name="close"></wy-icon>
                            </wy-button>
                          </wy-item>
                          <button
                            @click=${() => this.sidePanelMaximized = !this.sidePanelMaximized}
                            part="wy-sidebar-handle"
                            title=${this.sidePanelMaximized ? P("Restore side panel") : P("Maximize side panel")}
                          ></button>
                        </nav>
                        <div part="wy-pane wy-scroll-y">
                          ${this.commentsOpen && this.currentFile && this.currentFile.id >= 1 && this.app && this.user ? v`
                                <wy-comment-list
                                  reveal
                                  .parentId=${this.currentFile.id}
                                  .location=${"files"}
                                ></wy-comment-list>
                              ` : C}
                        </div>
                      </aside>
                      <aside
                        id="tab-versions"
                        part="wy-sidebar ${gt({
      "wy-active": this.versionsOpen,
      "wy-maximized": this.sidePanelMaximized
    })}"
                        ?hidden=${!this.versionsOpen}
                      >
                        <nav>
                          <wy-item size="md">
                            <span slot="title" part="wy-title">${P("Versions")}</span>
                            <wy-button
                              slot="actions"
                              kind="icon"
                              @click=${() => this.toggleSidebarTab("versions", !1)}
                            >
                              <wy-icon name="close"></wy-icon>
                            </wy-button>
                          </wy-item>
                          <button
                            @click=${() => this.sidePanelMaximized = !this.sidePanelMaximized}
                            part="wy-sidebar-handle"
                            title=${this.sidePanelMaximized ? P("Restore side panel") : P("Maximize side panel")}
                          ></button>
                        </nav>
                        <div part="wy-pane wy-scroll-y">
                          <div part="wy-pane-body">
                            ${this.versionsOpen && this.currentFile && this.app ? v`
                                  <wy-file-versions
                                    .file=${this.currentFile}
                                    .activeVersion=${this.currentVersionFile}
                                    @file-version-select=${(r) => this.handleVersionFile(r)}
                                  ></wy-file-versions>
                                ` : C}
                          </div>
                        </div>
                      </aside>`}

                <div part="wy-preview">
                  <div
                    ${ht((r) => {
      r && (this.swipeScrollElement = r);
    })}
                    part="wy-preview-swiper ${gt(i)}"
                  >
                    ${qi(
      e,
      (r) => "preview-area-" + r?.id,
      (r) => {
        const n = /* @__PURE__ */ c((l) => {
          l?.scrollIntoView(), requestAnimationFrame(() => l?.scrollIntoView());
        }, "currentPreviewFileCallback"), a = r === this.currentVersionFile ? n : r === this.nextFile ? this.nextRef : r === this.previousFile ? this.prevRef : void 0, o = this.loadingQueue.find((l) => l.file === r);
        return r ? v`
                              <div
                                id="preview-${r.id}"
                                ${ht(a)}
                                part="wy-preview-area wy-scroll-x-y"
                              >
                                ${!t && (o?.loading || o?.loaded) ? v`
                                      <wy-preview-item
                                        .file=${r}
                                        ?current=${r === this.currentVersionFile}
                                        @file-preview-loaded=${(l) => this.updateLoadingState(l.detail.file, { loaded: !0 })}
                                      ></wy-preview-item>
                                    ` : v` <wy-progress-circular indeterminate overlay></wy-progress-circular> `}
                              </div>
                            ` : C;
      }
    )}
                  </div>
                  ${this.currentFile ? v`
                        ${this.previousFile ? v`
                              <nav part="wy-nav-prev">
                                <wy-button kind="icon" @click=${() => this.scrollToPrev()}>
                                  <wy-icon name="previous"></wy-icon>
                                </wy-button>
                              </nav>
                            ` : C}
                        ${this.nextFile ? v`
                              <nav part="wy-nav-next">
                                <wy-button kind="icon" @click=${() => this.scrollToNext()}>
                                  <wy-icon name="next"></wy-icon>
                                </wy-button>
                              </nav>
                            ` : C}
                      ` : C}
                </div>
              </div>
            </div> ` : C}
      </wy-overlay>
    ` : C;
  }
  updated(t) {
    t.has("swipeScrollElement") && t.get("swipeScrollElement") !== this.swipeScrollElement && this.registerSwipeScroller(), !this.disableSwipeScroll && this.swipeScroller.swipeElement === this.swipeScrollElement ? this.swipeScroller.observe(this.prevRef.value, this.nextRef.value) : this.swipeScroller.clearObserver();
  }
}, h(gm, "Oo"), gm), c(Rx, "WyPreview"), Rx);
we.styles = [RG, EG, Nl, jl, By, Ie];
Ue([
  b({ attribute: !1 })
], we.prototype, "files", 2);
Ue([
  b({ attribute: !1 })
], we.prototype, "queryResult", 2);
Ue([
  b({ attribute: !1 })
], we.prototype, "infiniteQueryResult", 2);
Ue([
  b({ type: Object })
], we.prototype, "user", 2);
Ue([
  b({ type: Number })
], we.prototype, "currentId", 2);
Ue([
  b({ type: Boolean })
], we.prototype, "isAttachment", 2);
Ue([
  b({ type: Boolean })
], we.prototype, "filled", 2);
Ue([
  N()
], we.prototype, "currentFile", 2);
Ue([
  N()
], we.prototype, "currentVersionFile", 2);
Ue([
  N()
], we.prototype, "previousFile", 2);
Ue([
  N()
], we.prototype, "nextFile", 2);
Ue([
  N()
], we.prototype, "showOverlay", 2);
Ue([
  N()
], we.prototype, "commentsOpen", 2);
Ue([
  N()
], we.prototype, "versionsOpen", 2);
Ue([
  N()
], we.prototype, "sidePanelMaximized", 2);
Ue([
  N()
], we.prototype, "swipeScrollElement", 2);
Ue([
  N()
], we.prototype, "loadingQueue", 2);
Ue([
  N()
], we.prototype, "disableSwipeScroll", 2);
we = Ue([
  Y("wy-preview"),
  At()
], we);
var _K = Object.defineProperty, LK = Object.getOwnPropertyDescriptor, Fe = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? LK(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && _K(t, e, r), r;
}, "__decorateClass$D"), Ex, wm;
let ue = (Ex = (wm = class extends Pe {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.me = !1, this.isAgent = !1, this.isPrivateChat = !1, this.name = "", this.comment = "", this.avatar = "", this.createdAt = "", this.html = "", this.text = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.seenBy = [], this.highlight = !1, this.previewAnnotationsRef = $t(), this.previewAttachmentsRef = $t(), this.highlightRef = $t();
  }
  /**
   * Emit a `vote` event for the specified poll option.
   *
   * @internal
   * @param optionId - Identifier of the selected poll option.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", {
      detail: { optionId: t, parentId: this.messageId }
    });
    return this.dispatchEvent(e);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("link") && (this.highlight = !!(this.link && D1(this.link, vi.Message, { id: this.messageId })));
  }
  render() {
    const t = this.attachments?.filter((a) => a.kind === "image" && a.thumbnail_url) || [], e = this.attachments?.filter((a) => a.kind !== "image" || !a.thumbnail_url) || [], i = this.createdAt ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.createdAt)
    ) : "", r = this.createdAt ? new Intl.DateTimeFormat(this.weavy?.locale, { timeStyle: "short" }).format(new Date(this.createdAt)) : "", n = !this.annotations?.length && !this.attachments?.length && !this.embed && !this.meeting && !this.pollOptions?.length && Y_(this.text);
    return v`
      <div
        part=${gt({ "wy-message": !0, "wy-message-me": this.me, "wy-message-agent": this.isAgent, "wy-highlight": this.highlight })}
        ${ht(this.highlightRef)}
      >
        ${this.me ? "" : v`
              <div part="wy-message-author">
                <wy-avatar
                  .src=${this.avatar}
                  .size=${32}
                  .name=${this.name}
                  .description=${this.comment}
                  .isAgent=${this.isAgent}
                ></wy-avatar>
              </div>
            `}

        <div part="wy-message-content">
          <div part="wy-message-meta">
            ${!this.isPrivateChat && !this.me ? v` <span>${this.name} · </span> ` : ""}
            <time datetime=${this.createdAt} title=${i}>${r}</time>
          </div>

          <div part=${gt({ "wy-message-bubble": !0, "wy-message-bubble-emoji": n })}>
            ${this.messageId < 0 ? v`<wy-skeleton .text=${this.text}></wy-skeleton>` : v`
                  ${t && t.length ? v`<wy-image-grid
                        part="wy-message-bubble-section"
                        .images=${t}
                        @file-open=${(a) => {
      this.previewAttachmentsRef.value?.open(a.detail.fileId);
    }}
                      ></wy-image-grid>` : C}


                  <!-- text -->
                  ${this.html ? v`<div part=${gt({ "wy-content": !0, "wy-message-bubble-section": !0, "wy-content-emoji": n })}>${gl(this.html)}</div>` : C}

                  ${this.annotations && this.annotations.length ? v`<wy-annotation-list
                        part="wy-message-bubble-section"
                        .files=${this.annotations}
                        @file-open=${(a) => {
      this.previewAnnotationsRef.value?.open(a.detail.fileId);
    }}
                      ></wy-annotation-list>` : C}

                  ${this.pollOptions && this.pollOptions.length ? v`<wy-poll
                        .pollOptions=${this.pollOptions}
                        @vote=${(a) => this.dispatchVote(a.detail.optionId)}
                      ></wy-poll>` : C}

                  ${this.componentFeatures?.allowsFeature(L.Embeds) && this.embed ? v` <wy-embed .embed=${this.embed}></wy-embed> ` : C}

                  ${e && e.length ? v`<wy-attachment-list
                        filled
                        part="wy-message-bubble-section"
                        .files=${e}
                        @file-open=${(a) => {
      this.previewAttachmentsRef.value?.open(a.detail.fileId);
    }}
                      ></wy-attachment-list>` : C}

                  ${this.meeting ? v`<wy-meeting-card .meeting=${this.meeting}></wy-meeting-card>` : C}

                  ${this.componentFeatures?.allowsFeature(L.Reactions) && this.conversation ? v`
                        ${dO(
      `reactions-${this.conversation.id}-${this.messageId}`,
      v`<wy-reactions
                            lineBelow
                            ?lineReverse=${!this.me}
                            small
                            directionX=${this.me ? "right" : "left"}
                            .reactions=${this.reactions}
                            parentId=${this.conversation.id}
                            parentType="apps"
                            entityId=${this.messageId}
                            entityType="messages"
                          ></wy-reactions>`
    )}
                      ` : C}
                `}
          </div>
        </div>
      </div>
      ${this.componentFeatures?.allowsFeature(L.Receipts) ? v`<div part="wy-message-seenby">
            ${this.seenBy && this.seenBy.length ? v`
                  ${this.seenBy.map((a) => {
      const o = a.marked_at ? new Intl.DateTimeFormat(this.weavy?.locale, {
        dateStyle: "full",
        timeStyle: "short"
      }).format(new Date(a.marked_at)) : "";
      return v`<wy-avatar
                      title=${P(lt`Seen by ${a.name} at ${o}`)}
                      .name=${a.name}
                      .src=${a.avatar_url}
                      size=${18}
                    ></wy-avatar>`;
    })}
                ` : C}
          </div>` : C}
      ${this.annotations ? dO(
      `annotation-preview-message-${this.messageId}`,
      v`
              <wy-preview
                ${ht(this.previewAnnotationsRef)}
                .files=${this.annotations}
                .isAttachment=${!0}
              ></wy-preview>
            `
    ) : C}
      ${this.attachments ? dO(
      `preview-message-${this.messageId}`,
      v`
              <wy-preview
                ${ht(this.previewAttachmentsRef)}
                .files=${[...t, ...e]}
                .isAttachment=${!0}
              ></wy-preview>
            `
    ) : C}
    `;
  }
  updated(t) {
    t.has("highlight") && this.highlight && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, h(wm, "zo"), wm), c(Ex, "WyMessage"), Ex);
ue.styles = [Fb, K4, ft];
Fe([
  b({ attribute: !1 })
], ue.prototype, "conversation", 2);
Fe([
  b({ type: Number })
], ue.prototype, "messageId", 2);
Fe([
  b({ type: Boolean })
], ue.prototype, "me", 2);
Fe([
  b({ type: Boolean })
], ue.prototype, "isAgent", 2);
Fe([
  b({ type: Boolean })
], ue.prototype, "isPrivateChat", 2);
Fe([
  b()
], ue.prototype, "name", 2);
Fe([
  b()
], ue.prototype, "comment", 2);
Fe([
  b()
], ue.prototype, "avatar", 2);
Fe([
  b()
], ue.prototype, "createdAt", 2);
Fe([
  b()
], ue.prototype, "html", 2);
Fe([
  b()
], ue.prototype, "text", 2);
Fe([
  b({ type: Array })
], ue.prototype, "annotations", 2);
Fe([
  b({ type: Array })
], ue.prototype, "attachments", 2);
Fe([
  b({ attribute: !1 })
], ue.prototype, "meeting", 2);
Fe([
  b({ type: Array })
], ue.prototype, "pollOptions", 2);
Fe([
  b({ attribute: !1 })
], ue.prototype, "embed", 2);
Fe([
  b({ type: Array })
], ue.prototype, "reactions", 2);
Fe([
  b({ type: Array })
], ue.prototype, "seenBy", 2);
Fe([
  b({ type: Boolean })
], ue.prototype, "highlight", 2);
ue = Fe([
  Y("wy-message"),
  At()
], ue);
var zK = Object.defineProperty, IK = Object.getOwnPropertyDescriptor, TV = /* @__PURE__ */ c((s) => {
  throw TypeError(s);
}, "__typeError$8"), Nr = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? IK(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && zK(t, e, r), r;
}, "__decorateClass$C"), MV = /* @__PURE__ */ c((s, t, e) => t.has(s) || TV("Cannot " + e), "__accessCheck$8"), D9 = /* @__PURE__ */ c((s, t, e) => (MV(s, t, "read from private field"), e ? e.call(s) : t.get(s)), "__privateGet$8"), DK = /* @__PURE__ */ c((s, t, e) => t.has(s) ? TV("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(s) : t.set(s, e), "__privateAdd$8"), V9 = /* @__PURE__ */ c((s, t, e, i) => (MV(s, t, "write to private field"), t.set(s, e), e), "__privateSet$7"), rh, _x, vm;
let Zi = (_x = (vm = class extends Pe {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.header = !1, this.lastReadMessagePosition = "below", this.showNewMessages = !1, this.isCreatingConversation = !1, this.showReadReceipts = !1, this.messagesQuery = new Wl(this), this.membersQuery = new Qr(this), this.addMessageMutation = new Wr(this), this.infiniteScroll = new wU(this), this.pagerRef = $t(), this.bottomRef = $t(), this.editorRef = $t(), this.shouldBeAtBottom = !0, this.isTyping = !1, this.handleRealtimeMessage = async (t) => {
      if (!this.weavy || !this.conversation || !(this.conversationId && this.conversationId > 0) || !this.user)
        return;
      await this.messagesQuery.observer?.getCurrentQuery().promise;
      const e = t.message.app.uid ?? t.message.app.id, i = ["messages", t.message.app.id];
      let r = T1(this.weavy.queryClient, i, t.message.id);
      r || (t.message.created_by.id === this.user.id && (r = ga(this.weavy.queryClient, i, !0), r && ke(this.weavy.queryClient, i, r.id, (n) => {
        n.id = t.message.id, n.app = t.message.app, n.text = t.message.text, n.html = t.message.html, n.embed = t.message.embed, n.meeting = t.message.meeting, n.attachments = t.message.attachments, n.options = t.message.options, n.created_at = t.message.created_at, n.created_by = t.message.created_by, n.updated_at = t.message.updated_at, n.updated_by = t.message.updated_by;
      })), r || ya(this.weavy.queryClient, i, t.message)), this.weavy.queryClient.setQueryData(
        ["apps", e],
        (n) => n && { ...n, last_message: t.message }
      ), t.actor.id !== this.user.id && (this.isAtBottom ? (this.markAsRead(t.message.id), requestAnimationFrame(() => {
        this.scrollToBottom();
      })) : (this.weavy.queryClient.setQueryData(
        ["apps", e],
        (n) => n && { ...n, is_unread: !0 }
      ), this.lastReadMessagePosition = "above", this.lastReadMessageId = t.message.id, this.showNewMessages = !0), Rt(
        this.weavy.queryClient,
        { queryKey: ["members", t.message.app.id], exact: !1 },
        t.actor.id,
        (n) => {
          n.marked_id = t.message.id, n.marked_at = t.message.created_at;
        }
      ));
    }, this.handleRealtimeReactionAdded = (t) => {
      !this.weavy || !this.user || !this.conversation || Rt(
        this.weavy.queryClient,
        { queryKey: ["messages"], exact: !1 },
        t.entity.id,
        (e) => {
          e.reactions || (e.reactions = { count: 0 }), e.reactions.data = [
            ...(e.reactions.data || []).filter((i) => i.created_by?.id !== t.actor.id),
            { content: t.reaction, created_by: t.actor }
          ];
        }
      );
    }, this.handleRealtimeReactionDeleted = (t) => {
      !this.weavy || !this.conversation || !this.user || Rt(
        this.weavy.queryClient,
        { queryKey: ["messages"], exact: !1 },
        t.entity.id,
        (e) => {
          e.reactions && e.reactions.data && (e.reactions.data = e.reactions.data.filter((i) => i.created_by?.id !== t.actor.id));
        }
      );
    }, this.handleRealtimeMarked = (t) => {
      !this.weavy || !this.conversation || Rt(
        this.weavy.queryClient,
        { queryKey: ["members", this.conversation.id] },
        t.actor.id,
        (e) => {
          e.marked_id = t.marked_id, e.marked_at = t.marked_at;
        }
      );
    }, this.markAsReadHandler = () => {
      !document.hidden && this.isAtBottom && this.markAsRead();
    }, DK(this, rh);
  }
  isPrivateChat(t) {
    return (t ?? this.conversation)?.type === xt.PrivateChat;
  }
  isChatRoom(t) {
    return (t ?? this.conversation)?.type === xt.ChatRoom;
  }
  /**
   * Read-only helper returning whether the viewport is currently scrolled to the bottom.
   *
   * @internal
   */
  get isAtBottom() {
    return this.bottomRef.value ? pI(this.bottomRef.value) : !0;
  }
  /**
   * Scroll the conversation to the bottom.
   *
   * @param smooth - Whether to perform a smooth scroll.
   * @returns Promise<void>
   *
   * @internal
   */
  async scrollToBottom(t = !1) {
    this.bottomRef.value && await yO(this.bottomRef.value), uI(this.bottomRef.value) && this.conversationId && this.conversationId > 0 && (requestAnimationFrame(() => {
      iO(this.weavy?.queryClient, ["messages", this.conversationId], void 0, 1);
    }), await fI(this.bottomRef.value, t));
  }
  /**
   * Handle typing indicator events from child components.
   *
   * @internal
   * @param e - Typing event
   */
  handleTyping(t) {
    this.isTyping = !!t.detail.count, this.isTyping && this.isAtBottom && requestAnimationFrame(() => {
      this.scrollToBottom(!0);
    });
  }
  /**
   * Submit handler for the message editor. Adds a message and optionally creates a conversation first.
   *
   * @internal
   * @param e - Editor submit event
   * @returns Promise<MessageType>
   */
  async handleSubmit(t) {
    if (!this.user)
      throw new Error("Error submitting message. Missing user.");
    const e = {
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      blobs: t.detail.blobs,
      user: this.user,
      context: t.detail.contextData
    };
    if (this.agentInstructions && (e.metadata = {
      instructions: this.agentInstructions
    }), !this.conversation && this.weavy && this.createConversation && (this.isCreatingConversation = !0, await this.createConversation(e), await this.updateComplete), !this.conversation)
      throw new Error("Error submitting message. Missing conversation.");
    const i = await this.addMessageMutation.mutate({
      ...e,
      app_id: this.conversation.id
    });
    return this.showNewMessages = !1, requestAnimationFrame(() => {
      this.scrollToBottom();
    }), this.isCreatingConversation = !1, i;
  }
  /**
   * Set the editor text programmatically.
   *
   * @param text - Text to set in the editor.
   * @returns Promise<void>
   *
   * @internal
   */
  async setEditorText(t) {
    this.editorRef.value && (this.editorRef.value.text = t, await this.editorRef.value.updateComplete, await new Promise((e) => requestAnimationFrame(e)));
  }
  /**
   * Set metadata on the editor instance.
   *
   * @param metadata - Optional metadata object.
   * @returns Promise<void>
   *
   * @internal
   */
  async setEditorMetadata(t = {}) {
    await this.updateComplete, this.editorRef.value && (this.editorRef.value.metadata = t);
  }
  /**
   * Select all content in the editor.
   *
   * @internal
   */
  async selectAllInEditor() {
    this.editorRef.value && (await this.updateComplete, await this.editorRef.value.updateComplete, this.editorRef.value?.selectAllContent());
  }
  /**
   * Move the editor cursor to the end of the content.
   *
   * @internal
   */
  async setCursorLastInEditor() {
    this.editorRef.value && (await this.updateComplete, await this.editorRef.value.updateComplete, this.editorRef.value?.setCursorLast());
  }
  /**
   * Focus the editor input.
   *
   * @internal
   */
  focusEditor() {
    this.editorRef.value && this.editorRef.value?.focusInput();
  }
  /**
   * Sets the conversation title when the conversation is empty, based on message text.
   *
   * @internal
   * @param name - Title string to set.
   * @returns Promise<void>
   */
  async setEmptyConversationTitle(t) {
    !this.conversation || this.conversation.name || (t = qP(t), await this.updateConversationMutation?.mutate({ appId: this.conversation.id, name: t }));
  }
  /**
   * Mark the conversation as read. Respects visibility and component lifecycle.
   *
   * @param messageId - Optional message id to mark as read.
   * @returns Promise<void>
   *
   * @internal
   */
  async markAsRead(t) {
    await s8(), await Promise.race([yO(this), NS(this, !1)]), !(!this.componentFeatures?.allowsFeature(L.Receipts) || !this.isConnected) && this.conversation && this.conversation.last_message && await this.markConversationMutation?.mutate({
      app: this.conversation,
      messageId: t ?? this.conversation.last_message.id,
      userId: this.user?.id
    });
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("weavy") && this.weavy && (this.updateConversationMutation = x4(this.weavy), this.markConversationMutation = b4(this.weavy)), (t.has("weavy") || t.has("conversationId") || t.has("componentFeatures")) && this.weavy) {
      (e = D9(this, rh)) == null || e.call(this);
      const i = t.get("conversationId");
      if (i && i > 0 && requestAnimationFrame(() => {
        iO(this.weavy?.queryClient, ["messages", i], void 0, 1);
      }), this.conversationId && this.conversationId > 0) {
        await this.messagesQuery.trackInfiniteQuery(VI(this.weavy, this.conversationId)), await this.addMessageMutation.trackMutation(
          WI(this.weavy, ["messages", this.conversationId])
        ), await this.membersQuery.trackQuery(S4(this.weavy, this.conversationId, {})), this.pollMutation = Vb(this.weavy, this.conversationId, ["messages", this.conversationId]), this.lastReadMessageId = void 0, this.showNewMessages = !1;
        const r = `a${this.conversationId}`;
        this.weavy.subscribe(r, "message_created", this.handleRealtimeMessage), this.componentFeatures?.allowsFeature(L.Reactions) && (this.weavy.subscribe(r, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(r, "reaction_removed", this.handleRealtimeReactionDeleted)), this.componentFeatures?.allowsFeature(L.Receipts) && this.weavy.subscribe(r, "app_marked", this.handleRealtimeMarked).then((n) => {
          this.showReadReceipts = n;
        }), V9(this, rh, () => {
          this.weavy?.unsubscribe(r, "message_created", this.handleRealtimeMessage), this.weavy?.unsubscribe(r, "reaction_added", this.handleRealtimeReactionAdded), this.weavy?.unsubscribe(r, "reaction_removed", this.handleRealtimeReactionDeleted), this.weavy?.unsubscribe(r, "app_marked", this.handleRealtimeMarked), this.showReadReceipts = !1, V9(this, rh, void 0);
        });
      } else
        this.messagesQuery.untrackInfiniteQuery(), this.addMessageMutation.untrackMutation(), this.membersQuery.untrackQuery();
    }
    if (t.has("showNewMessages") && this.showNewMessages && (this.shouldBeAtBottom = this.isAtBottom), t.has("conversationId") && t.get("conversationId") !== this.conversationId ? this.shouldBeAtBottom = !!this.conversationId : this.shouldBeAtBottom = this.isAtBottom, t.has("conversation")) {
      const i = t.get("conversation");
      if (i?.id !== this.conversation?.id || i?.is_unread !== this.conversation?.is_unread)
        if (this.componentFeatures?.allowsFeature(L.Receipts) && this.conversation?.is_unread) {
          const r = this.membersQuery.result.data?.data?.find(
            (n) => n.id === this.user?.id
          )?.marked_id;
          r && r < this.conversation.last_message.id && (this.lastReadMessagePosition = "below", this.lastReadMessageId = r, this.showNewMessages = !0), (i?.id !== this.conversation?.id || i?.last_message.id !== this.conversation?.last_message.id && (this.shouldBeAtBottom || this.isAtBottom)) && this.markAsRead();
        } else i?.id !== this.conversation?.id && (this.showNewMessages = !1);
    }
    if (this.conversation && !this.conversation?.name && !PS(this.messagesQuery.result.data)) {
      const i = ys(this.messagesQuery.result.data).find((r) => r.plain);
      i && this.setEmptyConversationTitle(FP(i.plain));
    }
  }
  renderConversationHeader() {
    if (!this.header)
      return v` <!-- Top of the conversation --> `;
    const { isPending: t, hasNextPage: e } = this.messagesQuery.result ?? {};
    if (!this.conversation || t || e)
      return C;
    const { data: i } = this.membersQuery.result ?? {}, r = this.user && this.isPrivateChat() ? (this.conversation?.members?.data || []).filter((n) => n.id !== this.user?.id)?.[0] ?? this.user : null;
    return v`
      <wy-avatar-header description=${St(r?.comment)}>
        ${this.conversation.avatar_url ? v`<wy-avatar .size=${96} src=${this.conversation.avatar_url}></wy-avatar>` : this.isChatRoom() ? v` <wy-avatar-group
              .members=${i?.data}
              title=${this.conversation.name}
              .size=${96}
            ></wy-avatar-group>` : r?.avatar_url ? v`
              <wy-avatar
                src=${St(r?.avatar_url)}
                name=${this.conversation.name}
                description=${St(r?.comment)}
                ?isAgent=${r?.is_agent}
                size=${96}
              ></wy-avatar>
            ` : C}
      </wy-avatar-header>
    `;
  }
  renderMessages() {
    const { isPending: t } = this.weavy?.network ?? { isPending: !0 }, {
      data: e,
      isPending: i
      //hasNextPage,
    } = this.messagesQuery.result ?? { isPending: t }, { data: r } = this.membersQuery.result ?? {}, n = ys(e);
    let a;
    return this.conversation && e && !PS(e) ? v`
          <div part="wy-messages">
            <div ${ht(this.pagerRef)} part="wy-pager wy-pager-top"></div>

            ${n && this.conversation && this.user ? qi(
      n,
      (o) => o.id,
      (o, l) => {
        const d = new Date(o.created_at);
        let u = v``;
        if (a?.toDateString() !== d.toDateString()) {
          const y = new Intl.DateTimeFormat(this.weavy?.locale, {
            dateStyle: "short"
          }).format(d);
          a = d, u = v`<time part="wy-message-date-separator">${y}</time>`;
        }
        let p = v``;
        this.lastReadMessageId && this.lastReadMessageId === o.id && (p = v`<div
                        id="unread-marker"
                        part="wy-toast wy-toast-action wy-fade ${this.showNewMessages ? "wy-show" : ""}"
                        tabindex=${this.showNewMessages ? 0 : -1}
                        @click=${() => {
          let y = `#message-${this.lastReadMessageId}`;
          this.lastReadMessagePosition === "below" && (y += "~ wy-message"), this.renderRoot.querySelector(y)?.scrollIntoView({
            block: "start",
            inline: "nearest",
            behavior: "smooth"
          });
        }}
                        @keydown=${Ze}
                        @keyup=${bi}
                      >
                        ${P("New messages")}
                      </div>`);
        const f = r?.data?.find((y) => y.id === o.created_by.id) || o.created_by;
        return v`${[
          v`${u}`,
          v`${this.lastReadMessagePosition === "above" ? p : C}`,
          dO(
            `message-${o.id}`,
            v`<wy-message
                          id="message-${o.id}"
                          .conversation=${this.conversation}
                          .messageId=${o.id}
                          .me=${f.id === this.user?.id}
                          .isAgent=${f.is_agent || !1}
                          .isPrivateChat=${this.conversation?.type === xt.PrivateChat || this.conversation?.type === xt.AgentChat}
                          .name=${f.name}
                          .comment=${f.comment}
                          .avatar=${f.avatar_url}
                          .createdAt=${o.created_at}
                          .text=${o.plain}
                          .html=${o.html}
                          .annotations=${o.annotations?.data}
                          .attachments=${o.attachments?.data}
                          .meeting=${o.meeting}
                          .pollOptions=${o.options?.data}
                          .embed=${o.embed}
                          .reactions=${o.reactions?.data}
                          .seenBy=${this.showReadReceipts && r && r.data && r.data.length > 0 ? r.data.filter((y) => y.marked_id === o.id && y.id !== this.user?.id) : []}
                          @vote=${(y) => {
              y.detail.parentId && y.detail.parentType && y.detail.parentId && this.pollMutation?.mutate({
                optionId: y.detail.optionId,
                parentType: y.detail.parentType,
                parentId: y.detail.parentId
              });
            }}
                        ></wy-message>`
          ),
          v`${this.lastReadMessagePosition === "below" ? p : C}`
        ]}`;
      }
    ) : C}
            ${this.componentFeatures?.allowsFeature(L.Typing) ? v`
                  <wy-message-typing
                    .conversationId=${this.conversation.id}
                    .userId=${this.user?.id}
                    .isPrivateChat=${this.isPrivateChat()}
                    .members=${r?.data ?? []}
                    @typing=${(o) => this.handleTyping(o)}
                  ></wy-message-typing>
                ` : C}
          </div>
        ` : v`
          <div part="wy-messages">
            <wy-empty part="wy-pane">
              ${i && this.conversationId || this.isCreatingConversation ? v`<wy-progress-circular indeterminate overlay></wy-progress-circular>` : v` <slot name="empty">${this.conversationId ? P("Start the conversation!") : C}</slot> `}
            </wy-empty>
          </div>
        `;
  }
  render() {
    return v`
      ${this.renderConversationHeader()} ${this.renderMessages()}
      <div ${ht(this.bottomRef)}></div>
      <div part="wy-footerbar wy-footerbar-sticky wy-footerbar-floating">
        <slot name="footerbar"></slot>
        <wy-message-editor
          ${ht(this.editorRef)}
          .draft=${!0}
          placeholder=${this.placeholder ?? P("Type a message...")}
          ?disabled=${this.conversation && !Oy(ml.Create, this.conversation?.permissions)}
          @submit=${(t) => this.handleSubmit(t)}
        ></wy-message-editor>
      </div>
    `;
  }
  updated() {
    this.shouldBeAtBottom && (iO(this.weavy?.queryClient, ["messages", this.conversationId], void 0, 1), requestAnimationFrame(() => {
      this.scrollToBottom();
    })), this.bottomObserver || (this.bottomObserver = new IntersectionObserver((t) => {
      t.forEach((e) => {
        e.isIntersecting && !this.isTyping && this.conversation?.is_unread && this.markAsRead();
      });
    })), this.bottomRef && this.bottomRef.value && this.bottomObserver.observe(this.bottomRef.value), this.infiniteScroll.observe(this.messagesQuery.result, this.pagerRef.value);
  }
  // hook up observer
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("visibilitychange", this.markAsReadHandler), this.conversationId && this.requestUpdate("conversationId");
  }
  disconnectedCallback() {
    var t;
    (t = D9(this, rh)) == null || t.call(this), this.bottomObserver && this.bottomObserver.disconnect(), document.removeEventListener("visibilitychange", this.markAsReadHandler), this.conversation = void 0, this.shouldBeAtBottom = this.isAtBottom, super.disconnectedCallback();
  }
}, h(vm, "Io"), vm), c(_x, "WyConversation"), _x);
rh = /* @__PURE__ */ new WeakMap();
Zi.styles = [
  Fb,
  Ma,
  Nl,
  mD,
  P4,
  it`
      :host {
        position: relative;
        display: flex;
        flex-direction: column;
        flex: 1 1 auto;
      }
    `
];
Nr([
  gn({ context: e4 }),
  b({ attribute: !1 })
], Zi.prototype, "conversation", 2);
Nr([
  b({ type: Number })
], Zi.prototype, "conversationId", 2);
Nr([
  b({ type: Boolean })
], Zi.prototype, "header", 2);
Nr([
  b()
], Zi.prototype, "agentInstructions", 2);
Nr([
  b()
], Zi.prototype, "placeholder", 2);
Nr([
  N()
], Zi.prototype, "lastReadMessagePosition", 2);
Nr([
  N()
], Zi.prototype, "lastReadMessageId", 2);
Nr([
  N()
], Zi.prototype, "showNewMessages", 2);
Nr([
  N()
], Zi.prototype, "isCreatingConversation", 2);
Nr([
  N()
], Zi.prototype, "showReadReceipts", 2);
Zi = Nr([
  Y("wy-conversation"),
  At()
], Zi);
const VK = it`:host{--_track-height: 4px;--_track-shape: 2px;--_active-indicator-height: 2px;--_active-indicator-color: var(--wy-primary, var(--wy-primary-light, #2f628c));--_warning-color: var(--wy-warning, var(--wy-warning-light, #adb140));--_error-color: var(--wy-error, var(--wy-error-light, #ba1821));--_track-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));display:contents;position:relative}[part~=wy-progress-linear]{border-radius:var(--_track-shape);position:relative;min-width:80px;height:var(--_track-height);content-visibility:auto;contain:strict;flex:1;direction:ltr;inset:0;border-radius:inherit;overflow:hidden;display:flex;align-items:center}[part~=wy-progress-linear][part~=wy-progress-padded]{margin:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem))}[part~=wy-inactive-track],[part~=wy-bar],[part~=wy-bar-inner]{position:absolute}[part~=wy-bar]{animation:none;width:100%;height:var(--_active-indicator-height);transform-origin:left center;transition:transform .25s cubic-bezier(.4,0,.6,1)}[part~=wy-secondary-bar]{display:none}[part~=wy-bar-inner]{inset:0;animation:none;background:var(--_active-indicator-color)}[part~=wy-inactive-track]{background:var(--_track-color);inset:0;transition:transform .25s cubic-bezier(.4,0,.6,1);transform-origin:left center}[part~=wy-progress-indeterminate] [part~=wy-bar]{transition:none}[part~=wy-progress-indeterminate] [part~=wy-primary-bar]{inset-inline-start:-145.167%}[part~=wy-progress-indeterminate] [part~=wy-secondary-bar]{inset-inline-start:-54.8889%;display:block}[part~=wy-progress-indeterminate] [part~=wy-primary-bar]{animation:linear infinite 2s;animation-name:primary-indeterminate-translate}[part~=wy-progress-indeterminate] [part~=wy-primary-bar]>[part~=wy-bar-inner]{animation:linear infinite 2s primary-indeterminate-scale}[part~=wy-progress-indeterminate] [part~=wy-secondary-bar]{animation:linear infinite 2s;animation-name:secondary-indeterminate-translate}[part~=wy-progress-indeterminate] [part~=wy-secondary-bar]>[part~=wy-bar-inner]{animation:linear infinite 2s secondary-indeterminate-scale}@keyframes primary-indeterminate-scale{0%{transform:scaleX(.08)}36.65%{animation-timing-function:cubic-bezier(.334731,.12482,.785844,1);transform:scaleX(.08)}69.15%{animation-timing-function:cubic-bezier(.06,.11,.6,1);transform:scaleX(.661479)}to{transform:scaleX(.08)}}@keyframes secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(.205028,.057051,.57661,.453971);transform:scaleX(.08)}19.15%{animation-timing-function:cubic-bezier(.152313,.196432,.648374,1.00432);transform:scaleX(.457104)}44.15%{animation-timing-function:cubic-bezier(.257759,-.003163,.211762,1.38179);transform:scaleX(.72796)}to{transform:scaleX(.08)}}@keyframes primary-indeterminate-translate{0%{transform:translate(0)}20%{animation-timing-function:cubic-bezier(.5,0,.701732,.495819);transform:translate(0)}59.15%{animation-timing-function:cubic-bezier(.302435,.381352,.55,.956352);transform:translate(83.6714%)}to{transform:translate(200.611%)}}@keyframes secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(.15,0,.515058,.409685);transform:translate(0)}25%{animation-timing-function:cubic-bezier(.31033,.284058,.8,.733712);transform:translate(37.6519%)}48.35%{animation-timing-function:cubic-bezier(.4,.627035,.6,.902026);transform:translate(84.3862%)}to{transform:translate(160.278%)}}[part~=wy-progress-warning] [part~=wy-primary-bar],[part~=wy-progress-warning] [part~=wy-secondary-bar],[part~=wy-progress-warning] [part~=wy-bar-inner],[part~=wy-progress-error] [part~=wy-primary-bar],[part~=wy-progress-error] [part~=wy-secondary-bar],[part~=wy-progress-error] [part~=wy-bar-inner]{animation:none!important}[part~=wy-progress-warning] [part~=wy-secondary-bar],[part~=wy-progress-error] [part~=wy-secondary-bar]{display:none!important}[part~=wy-progress-warning] [part~=wy-primary-bar],[part~=wy-progress-error] [part~=wy-primary-bar]{transform:scaleX(1)!important}[part~=wy-progress-warning] [part~=wy-bar-inner]{background:var(--_warning-color)}[part~=wy-progress-error] [part~=wy-bar-inner]{background:var(--_error-color)}`;
var WK = Object.defineProperty, FK = Object.getOwnPropertyDescriptor, bn = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? FK(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && WK(t, e, r), r;
}, "__decorateClass$B"), Lx, Om;
let Cr = (Lx = (Om = class extends wt {
  constructor() {
    super(...arguments), this.shadowParts = new rt(this), this.padded = !1, this.overlay = !1, this.reveal = !1, this.value = 0, this.max = 1, this.indeterminate = !1, this.warning = !1, this.error = !1;
  }
  render() {
    let t;
    try {
      Number.isFinite(this.value) && Number.isFinite(this.max) && this.max > 0 && (t = this.value / this.max);
    } catch (n) {
      console.error(n);
    }
    const e = this.indeterminate || t === void 0, i = {
      transform: `scaleX(${(e ? 1 : this.value / this.max) * 100}%)`
    }, r = {
      "wy-progress": !0,
      "wy-progress-linear": !0,
      "wy-progress-indeterminate": e,
      "wy-progress-overlay": this.overlay,
      "wy-progress-padded": this.padded,
      "wy-progress-reveal": this.reveal,
      "wy-progress-warning": this.warning,
      "wy-progress-error": this.error
    };
    return v`
      <div
        part=${gt(r)}
        role="progressbar"
        aria-label="${C}"
        aria-valuemin="0"
        aria-valuemax=${this.max}
        aria-valuenow=${e ? C : this.value}
      >
        <div part="wy-inactive-track"></div>
        <div part="wy-bar wy-primary-bar" style=${Jw(i)}>
          <div part="wy-bar-inner"></div>
        </div>
        <div part="wy-bar wy-secondary-bar">
          <div part="wy-bar-inner"></div>
        </div>
      </div>
    `;
  }
}, h(Om, "Fo"), Om), c(Lx, "WyProgressLinear"), Lx);
Cr.styles = [pe, bD, VK];
bn([
  b({ type: Boolean })
], Cr.prototype, "padded", 2);
bn([
  b({ type: Boolean })
], Cr.prototype, "overlay", 2);
bn([
  b({ type: Boolean })
], Cr.prototype, "reveal", 2);
bn([
  b({ type: Number })
], Cr.prototype, "value", 2);
bn([
  b({ type: Number })
], Cr.prototype, "max", 2);
bn([
  b({ type: Boolean })
], Cr.prototype, "indeterminate", 2);
bn([
  b({ type: Boolean })
], Cr.prototype, "warning", 2);
bn([
  b({ type: Boolean })
], Cr.prototype, "error", 2);
Cr = bn([
  Y("wy-progress-linear")
], Cr);
var qK = Object.getOwnPropertyDescriptor, AV = /* @__PURE__ */ c((s) => {
  throw TypeError(s);
}, "__typeError$7"), ZK = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? qK(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = a(r) || r);
  return r;
}, "__decorateClass$A"), BK = /* @__PURE__ */ c((s, t, e) => t.has(s) || AV("Cannot " + e), "__accessCheck$7"), W9 = /* @__PURE__ */ c((s, t, e) => (BK(s, t, "read from private field"), e ? e.call(s) : t.get(s)), "__privateGet$7"), NK = /* @__PURE__ */ c((s, t, e) => t.has(s) ? AV("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(s) : t.set(s, e), "__privateAdd$7"), mO, zx, bm;
let I0 = (zx = (bm = class extends Pe {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), NK(this, mO, new Rb(this));
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("contextId") || t.has("componentFeatures")) && this.weavy && this.contextId && this.componentFeatures?.allowsFeature(L.ContextData) && await W9(this, mO).trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.contextId, "data"],
          exact: !0
        }
      },
      this.weavy.queryClient
    );
  }
  render() {
    const { result: t, isMutating: e } = W9(this, mO), i = t?.filter((a) => a.variables?.file), r = h4(i), n = v0(i);
    return this.componentFeatures?.allowsFeature(L.ContextData) && t && t.length ? v`
          ${e || r.percent !== null && r.percent < 100 ? v`
                <wy-progress-linear
                  ?indeterminate=${r.percent === null}
                  overlay
                  reveal
                  ?warning=${n === "error"}
                  value=${r.percent ?? 0}
                  max=${100}
                ></wy-progress-linear>
              ` : C}
        ` : C;
  }
}, h(bm, "Do"), bm), c(zx, "WyContextDataProgress"), zx);
mO = /* @__PURE__ */ new WeakMap();
I0.styles = [ft];
I0 = ZK([
  Y("wy-context-data-progress")
], I0);
var XK = Object.defineProperty, jK = Object.getOwnPropertyDescriptor, a3 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? jK(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && XK(t, e, r), r;
}, "__decorateClass$z"), Ix, $m;
let Ql = (Ix = ($m = class extends Ni {
  constructor() {
    super(...arguments), this.appType = xt.Chat, this.componentFeatures = new di({
      // All available features as enabled/disabled by default
      [L.Attachments]: !0,
      [L.ContextData]: !0,
      [L.CloudFiles]: !0,
      [L.Embeds]: !0,
      [L.GoogleMeet]: !0,
      [L.Meetings]: !0,
      [L.Mentions]: !0,
      [L.MicrosoftTeams]: !0,
      [L.Polls]: !0,
      [L.Previews]: !0,
      [L.Reactions]: !0,
      [L.Receipts]: !1,
      [L.Typing]: !1,
      [L.ZoomMeetings]: !0
    }), this.theme = new Ri(this, Ql.styles);
  }
  render() {
    return v`
      <wy-buttons position="floating" reverse><slot name="actions"></slot></wy-buttons>
      <wy-conversation
        .agentInstructions=${this.instructions}
        .conversation=${this.app}
        .conversationId=${this.app?.id}
        .placeholder=${this.placeholder}
      >
        <wy-context-data-progress slot="footerbar"></wy-context-data-progress>
      </wy-conversation>
    `;
  }
}, h($m, "Vo"), $m), c(Ix, "WyChat"), Ix);
Ql.styles = [vn, ql, Zl, Ie, Ei];
a3([
  b()
], Ql.prototype, "instructions", 2);
a3([
  b()
], Ql.prototype, "placeholder", 2);
Ql = a3([
  Y("wy-chat"),
  At()
], Ql);
var UK = Object.defineProperty, HK = Object.getOwnPropertyDescriptor, RV = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? HK(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && UK(t, e, r), r;
}, "__decorateClass$y"), Dx, xm;
let Ty = (Dx = (xm = class extends Ni {
  constructor() {
    super(...arguments), this.appType = xt.Comments, this.componentFeatures = new di({
      // All available features as enabled/disabled by default
      [L.Attachments]: !0,
      [L.CloudFiles]: !0,
      [L.ContextData]: !0,
      [L.Embeds]: !0,
      [L.GoogleMeet]: !1,
      [L.Meetings]: !1,
      [L.Mentions]: !0,
      [L.MicrosoftTeams]: !1,
      [L.Polls]: !0,
      [L.Previews]: !0,
      [L.Reactions]: !0,
      [L.Typing]: !1,
      // Has no effect currently
      [L.ZoomMeetings]: !1
    }), this.theme = new Ri(this, Ty.styles);
  }
  render() {
    return v`
      <wy-buttons position="floating" reverse><slot name="actions"></slot></wy-buttons>
      <wy-comment-list .parentId=${this.app?.id} .location=${"apps"} .placeholder=${this.placeholder}></wy-comment-list>
      <wy-context-data-progress></wy-context-data-progress>
    `;
  }
}, h(xm, "Ho"), xm), c(Dx, "WyComments"), Dx);
Ty.styles = [vn, ql, Zl, Ie, Ei, r3];
RV([
  b()
], Ty.prototype, "placeholder", 2);
Ty = RV([
  Y("wy-comments"),
  At()
], Ty);
function EV(s) {
  if (!this.weavy || !this.app)
    return;
  const t = {
    message: s.message,
    direction: s.message.created_by.id === this.user?.id ? "outbound" : "inbound"
  };
  s.message.created_by.is_agent && (t.agent = s.message.created_by.uid);
  const e = new CustomEvent("wy-message", {
    bubbles: !1,
    cancelable: !1,
    composed: !0,
    detail: t
  });
  this.dispatchEvent(e);
}
h(EV, "N3");
c(EV, "triggerMessageEvent");
var YK = Object.defineProperty, GK = Object.getOwnPropertyDescriptor, o3 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? GK(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && YK(t, e, r), r;
}, "__decorateClass$x"), Vx, km;
let Tl = (Vx = (km = class extends Ni {
  constructor() {
    super(...arguments), this.appType = xt.AgentChat, this.componentFeatures = new di({
      // All available features as enabled/disabled by default
      [L.Attachments]: !1,
      [L.ContextData]: !0,
      [L.Embeds]: !0,
      [L.Mentions]: !1,
      [L.Previews]: !0,
      [L.Reactions]: !1,
      [L.Typing]: !0
    }), this.theme = new Ri(this, Tl.styles), this.conversationRef = $t(), this.handleRealtimeMessage = EV.bind(this);
  }
  /**
   * Sets the editor input to a suggested text. This replaces the text content of the editor. This can be used to create any custom suggestions.
   *
   * @param {string} text - The text suggestion to place in the editor.
   */
  async setSuggestion(t) {
    await this.conversationRef.value?.setEditorText(t);
  }
  async willUpdate(t) {
    if (await super.willUpdate(t), t.has("weavy") && this.weavy && (this.addConversationMutation = p4(this.weavy)), (t.has("app") || t.has("weavy")) && this.weavy && (this.unsubscribeToRealtime?.(), this.app)) {
      const e = `a${this.app.id}`;
      this.weavy.subscribe(e, "message_created", this.handleRealtimeMessage), this.unsubscribeToRealtime = () => {
        this.weavy?.unsubscribe(e, "message_created", this.handleRealtimeMessage), this.unsubscribeToRealtime = void 0;
      };
    }
    t.has("agent") && t.get("agent") && this.agent && this.reset();
  }
  render() {
    return this.agent ? v`
          <wy-buttons position="floating" reverse>
            <slot name="actions"></slot>
          </wy-buttons>
          <wy-conversation
            ${ht(this.conversationRef)}
            .conversation=${this.app}
            .conversationId=${this.app?.id}
            .placeholder=${this.placeholder ?? P("Ask anything...")}
            .agentInstructions=${this.instructions}
            .createConversation=${this.agent && this.addConversationMutation ? async (t) => {
      if (!this.agent || !this.addConversationMutation)
        throw new Error("Agent or addConversationMutation not defined");
      const e = {
        uid: `wy-copilot-${Th()}`,
        name: qP(FP(this.name ?? t.text)),
        members: [this.agent],
        type: Lr.AgentChat
      }, i = await this.addConversationMutation.mutate(e);
      return this.app = i, await this.updateComplete, i;
    } : void 0}
          >
            <slot
              slot="empty"
              name="empty"
              @click=${async (t) => {
      t.target.matches(".suggestion") && (t.stopPropagation(), await this.setSuggestion(t.target.innerText), await this.conversationRef.value?.setCursorLastInEditor(), this.conversationRef.value?.focusEditor());
    }}
              @keydown=${Ze}
              @keyup=${bi}
            >
              <slot name="header">
                <wy-icon-display>
                  <slot name="icon">
                    <wy-icon name="stars"></wy-icon>
                  </slot>
                </wy-icon-display>
              </slot>
              <slot name="suggestions">
                <wy-item-list>
                  <slot name="suggestion-list">
                    <!--wy-button class="suggestion">Summarize this page</wy-button-->
                  </slot>
                </wy-item-list>
              </slot>
              <slot name="footer"></slot>
            </slot>
            <wy-context-data-progress slot="footerbar"></wy-context-data-progress>
          </wy-conversation>
        ` : v`
          <wy-empty>
            <wy-icon-display>
              <slot name="icon">
                <wy-icon name="stars"></wy-icon>
              </slot>
            </wy-icon-display>
          </wy-empty>
        `;
  }
}, h(km, "Bo"), km), c(Vx, "WyCopilot"), Vx);
Tl.styles = [vn, ql, Zl, Ie, Ei];
o3([
  b()
], Tl.prototype, "instructions", 2);
o3([
  b()
], Tl.prototype, "placeholder", 2);
Tl = o3([
  Y("wy-copilot"),
  At()
], Tl);
var KK = Object.defineProperty, JK = Object.getOwnPropertyDescriptor, B1 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? JK(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && KK(t, e, r), r;
}, "__decorateClass$w"), Wx, Sm;
let xa = (Wx = (Sm = class extends Pe {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.order = { by: "name", descending: !1 }, this.view = "list", this.showTrashed = !1, this.showUploadSheet = !1, this.mutatingFiles = new Rb(
      this
    ), this.previousFailedFileMutations = [], this.fileInputRef = $t(), this.cloudFilesRef = $t(), this.openFileInput = () => {
      this.fileInputRef.value?.click();
    }, this.openCloudFiles = () => {
      this.cloudFilesRef.value?.open();
    };
  }
  // remove file attachment
  /**
   * Remove (or abort) an ongoing upload mutation.
   *
   * @internal
   * @param mutationState - Mutation state to remove.
   */
  async handleRemoveMutation(t) {
    const e = await this.whenWeavy(), i = await this.whenApp();
    t.status === "pending" && g0(t.variables) && t.variables.abort?.();
    const r = t.status === "error" && !t.variables?.blob || t.status === "pending" ? ["apps", i.id, "blobs"] : ["apps", i.id, "files"];
    l4(
      e.queryClient,
      r,
      (n) => n.state.submittedAt === t.submittedAt
    );
  }
  /**
   * Retry an upload by replacing the existing file.
   *
   * @internal
   * @param mutation - Failed mutation carrying the blob data.
   */
  handleOverwriteUpload(t) {
    const e = t.variables?.blob;
    e && this.dispatchCreateFiles([e], !0);
  }
  /**
   * Dispatch an `upload-files` event with the selected files.
   *
   * @param files - Files chosen from the native picker.
   * @returns Whether the event was not canceled.
   */
  dispatchUploadFiles(t) {
    this.weavy && this.app && (Uz(this.weavy, this.app), v0(this.mutatingFiles.result) === "ok" && O0(this.weavy, this.app));
    const e = new CustomEvent("upload-files", {
      detail: { files: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit an `external-blobs` event with selected cloud blobs.
   *
   * @internal
   * @param externalBlobs - Blobs returned from the cloud picker.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchExternalBlobs(t) {
    const e = new CustomEvent("external-blobs", {
      detail: { externalBlobs: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `create-files` event for programmatic uploads.
   *
   * @internal
   * @param blobs - Blobs to create files from.
   * @param replace - When true, replace the existing file.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchCreateFiles(t, e = !1) {
    const i = new CustomEvent("create-files", {
      detail: { blobs: t, replace: e }
    });
    return this.dispatchEvent(i);
  }
  /**
   * Emit an `order` event reflecting the chosen sort order.
   *
   * @internal
   * @param order - Order to apply.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `view` event for changing layout mode.
   *
   * @internal
   * @param view - Layout to activate.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchView(t) {
    const e = new CustomEvent("view", { detail: { view: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `show-trashed` event to toggle trashed visibility.
   *
   * @internal
   * @param showTrashed - Whether to show trashed files.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchShowTrashed(t) {
    const e = new CustomEvent("show-trashed", {
      detail: { showTrashed: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event to toggle app subscription.
   *
   * @internal
   * @param subscribe - Desired subscription state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", { detail: { subscribe: t } });
    return this.dispatchEvent(e);
  }
  async willUpdate(t) {
    super.willUpdate(t), t.has("app") && this.app && this.app.id !== t.get("app")?.id && this.weavy && O0(this.weavy, this.app), (t.has("weavy") || t.has("app")) && this.weavy && this.app && await this.mutatingFiles.trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.app.id],
          exact: !1
        }
      },
      this.weavy.queryClient
    );
  }
  renderFileMutation(t) {
    if (t.context?.file) {
      const e = t.context.file, i = {
        ...t.context.status
      };
      return t.context.status.state === "conflict" && (i.text = P("Replace existing file?")), v`
        <wy-file-item
          rounded
          .file=${t.context?.file}
          .status=${i}
          .actionType=${t.context.type}
          title="${VP(t.context.type)}: ${e.name}"
        >
          <span slot="title">${e.name}</span>
          ${t.context.status.state === "conflict" && i.text ? v`: <span slot="actions" title=${i.text}><em>${i.text}</em></span>` : C}
          ${i.state === "conflict" && t.variables?.blob ? v`
                <wy-button
                  slot="actions"
                  kind="icon"
                  @click=${() => this.handleOverwriteUpload(
        t
      )}
                  title=${P("Replace")}
                >
                  <wy-icon name="check"></wy-icon>
                </wy-button>
              ` : C}
          ${i.state === "pending" ? v`
                <wy-progress-circular
                  slot="actions"
                  padded
                  ?indeterminate=${!i.progress}
                  .max=${100}
                  .value=${i.progress || 0}
                ></wy-progress-circular>

                ${g0(t.variables) ? v`<wy-button slot="actions" kind="icon" @click=${() => this.handleRemoveMutation(t)}>
                      <wy-icon name="close"></wy-icon>
                    </wy-button>` : C}
              ` : v`<wy-button slot="actions" kind="icon" @click=${() => this.handleRemoveMutation(t)}>
                <wy-icon name="close"></wy-icon>
              </wy-button> `}
        </wy-file-item>
      `;
    }
    return C;
  }
  render() {
    const t = this.mutatingFiles.result, e = CS(t), i = SS(t), r = h4(t), n = v0(t);
    return v`
      <header part="wy-files-header wy-header wy-header-outer">
        <nav part="wy-files-header-toolbar wy-toolbar">
          <div part="wy-toolbar-buttons">
            ${Oy(ml.Create, this.app?.permissions) ? v`
                  <wy-dropdown title=${P("Add files")}>
                    <wy-icon slot="button-content" name="plus" first></wy-icon>
                    <span slot="button-content">${P("Add files")}</span>
                    <wy-dropdown-item @click=${this.openFileInput} title=${P("From device")}>
                      <wy-icon name="attachment"></wy-icon>
                      <span>${P("From device")}</span>
                    </wy-dropdown-item>
                    <input
                      type="file"
                      data-testid="uploadFile"
                      ${ht(this.fileInputRef)}
                      @click=${(a) => a.stopPropagation()}
                      @change=${(a) => {
      this.dispatchUploadFiles(a.target.files) && (a.target.value = "");
    }}
                      multiple
                      hidden
                      tabindex="-1"
                    />
                    ${this.componentFeatures?.allowsFeature(L.CloudFiles) ? v`
                          <wy-dropdown-item @click=${this.openCloudFiles} title=${P("From cloud")}>
                            <wy-icon name="cloud"></wy-icon>
                            <span>${P("From cloud")}</span>
                          </wy-dropdown-item>
                        ` : C}
                  </wy-dropdown>
                ` : C}
            ${t?.length ? v`
                  <wy-button
                    kind="icon"
                    @click=${() => {
      this.showUploadSheet = !this.showUploadSheet;
    }}
                    title=${P(n === "conflict" ? "File conflict" : n === "error" ? "Upload error" : n === "pending" ? "Pending" : "All uploads finished")}
                  >
                    ${n === "conflict" ? v`<wy-icon name="alert" color="yellow"></wy-icon>` : n === "error" ? v`<wy-icon name="alert-octagon" color="error"></wy-icon>` : n === "pending" ? v`<wy-progress-circular
                          ?indeterminate=${r.percent === null}
                          .value=${r.loaded}
                          .max=${r.total}
                        ></wy-progress-circular>` : v`<wy-icon name="check"></wy-icon>`}
                  </wy-button>
                ` : C}
          </div>
          <div part="wy-toolbar-buttons wy-toolbar-buttons-last">
            <slot name="actions"></slot>

            <wy-dropdown icon="sort" title="Sort items by" directionX="left">
              <wy-dropdown-option
                ?selected=${this.order.by === "name"}
                @click=${() => this.dispatchOrder({ ...this.order, by: "name" })}
              >
                ${P("Name")}
              </wy-dropdown-option>
              <wy-dropdown-option
                ?selected=${this.order.by === "updated_at"}
                @click=${() => this.dispatchOrder({ ...this.order, by: "updated_at" })}
              >
                ${P("Modified")}
              </wy-dropdown-option>
              <wy-dropdown-option
                ?selected=${this.order.by === "size"}
                @click=${() => this.dispatchOrder({ ...this.order, by: "size" })}
              >
                ${P("Size")}
              </wy-dropdown-option>
              <wy-dropdown-divider></wy-dropdown-divider>
              <wy-dropdown-option
                ?selected=${!this.order.descending}
                @click=${() => this.dispatchOrder({ ...this.order, descending: !1 })}
              >
                ${P("Ascending")}
              </wy-dropdown-option>
              <wy-dropdown-option
                ?selected=${this.order.descending}
                @click=${() => this.dispatchOrder({ ...this.order, descending: !0 })}
              >
                ${P("Descending")}
              </wy-dropdown-option>
            </wy-dropdown>

            <wy-dropdown
              icon=${this.view === "grid" ? "view-module-outline" : "view-list-outline"}
              title="View options"
              directionX="left"
            >
              <wy-dropdown-option ?selected=${this.view === "list"} @click=${() => this.dispatchView("list")}>
                ${P("List view")}
              </wy-dropdown-option>
              <wy-dropdown-option ?selected=${this.view === "grid"} @click=${() => this.dispatchView("grid")}>
                ${P("Grid view")}
              </wy-dropdown-option>
              <wy-dropdown-divider></wy-dropdown-divider>
              <wy-dropdown-option ?selected=${!this.showTrashed} @click=${() => this.dispatchShowTrashed(!1)}>
                ${P("Hide trashed")}
              </wy-dropdown-option>
              <wy-dropdown-option ?selected=${this.showTrashed} @click=${() => this.dispatchShowTrashed(!0)}>
                ${P("Show trashed")}
              </wy-dropdown-option>
            </wy-dropdown>

            <wy-dropdown directionX="left" ?disabled=${!this.app}>
              ${this.app?.is_subscribed ? v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                    <wy-icon name="bell-off"></wy-icon>
                    ${P("Unsubscribe")}
                  </wy-dropdown-item>` : v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                    <wy-icon name="bell"></wy-icon>
                    ${P("Subscribe")}
                  </wy-dropdown-item>`}
              ${this.app?.archive_url ? v`<wy-dropdown-item
                    @click=${() => ps(
      this.app?.archive_url,
      "_top",
      `${this.app?.uid ? this.app.uid : `${this.app?.type}-${this.app?.id}`}.zip`,
      !0
    )}
                  >
                    <wy-icon name="download"></wy-icon>
                    ${P("Download files")}
                  </wy-dropdown-item>` : C}
            </wy-dropdown>
          </div>
        </nav>

        <wy-context-data-progress></wy-context-data-progress>
      </header>

      ${this.weavy ? v`
            <wy-overlay
              type="sheet"
              .show=${this.showUploadSheet}
              @close=${() => {
      this.showUploadSheet = !1;
    }}
            >
              <span slot="title">${P("File actions")}</span>
              <wy-container scrollY padded>
                ${!e.length && !i.length ? v`
                      <wy-empty noNetwork><wy-container padded>${P("No pending uploads")}</wy-container></wy-empty>
                    ` : C}
                ${e.length ? v`
                      ${qi(
      e,
      (a) => "mutation" + a.submittedAt,
      (a) => this.renderFileMutation(a)
    )}
                    ` : C}
                ${i.length ? v`
                      ${qi(
      i,
      (a) => "mutation" + a.submittedAt,
      (a) => this.renderFileMutation(a)
    )}
                    ` : C}
              </wy-container>
            </wy-overlay>
          ` : C}

      <wy-cloud-files
        ${ht(this.cloudFilesRef)}
        @external-blobs=${(a) => this.dispatchExternalBlobs(a.detail.externalBlobs)}
      ></wy-cloud-files>
    `;
  }
  updated(t) {
    super.updated(t);
    const e = CS(this.mutatingFiles.result), i = SS(this.mutatingFiles.result);
    e.some(
      (r) => !this.previousFailedFileMutations.includes(r)
    ) ? this.showUploadSheet = !0 : this.showUploadSheet && !e.length && !i.length && setTimeout(() => {
      !e.length && !i.length && (this.showUploadSheet = !1);
    }, 1500), this.previousFailedFileMutations = e ?? [];
  }
}, h(Sm, "No"), Sm), c(Wx, "WyFilesHeader"), Wx);
xa.styles = [t3, nV, ft];
B1([
  b({ type: Object })
], xa.prototype, "order", 2);
B1([
  b()
], xa.prototype, "view", 2);
B1([
  b({ type: Boolean })
], xa.prototype, "showTrashed", 2);
B1([
  N()
], xa.prototype, "showUploadSheet", 2);
xa = B1([
  Y("wy-files-header"),
  At()
], xa);
function _V(s, t, e = {}, i = {}) {
  if (!s)
    throw new Error("useFileList must be used within a WeavyContext");
  return {
    ...i,
    queryKey: ["apps", t, "files", e],
    initialPageParam: 0,
    queryFn: /* @__PURE__ */ c(async (r) => {
      const n = r.pageParam, a = !!e?.trashed, o = e.order ? e.order.by + (e.order.descending ? "+desc" : "") : "";
      let l = "/api/apps/" + t + "/files?skip=" + n + "&order_by=" + o;
      return a && (l += "&trashed=null"), await (await s.fetch(l)).json();
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ c((r) => r.end && r.end < r.count ? r.end : null, "getNextPageParam")
  };
}
h(_V, "K3");
c(_V, "getInfiniteFileListOptions");
function LV(s, t) {
  const e = s.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ c(async ({ file: r }) => {
      if (r.id >= 1) {
        if (!(await s.fetch("/api/files/" + r.id + "/trash", { method: "POST" })).ok)
          throw new Error();
      } else
        throw new Error(`Could not trash ${r.name}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((r) => (Rt(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      r.file.id,
      (n) => Object.assign(n, { is_trashed: !0 })
    ), { type: "trash", file: r.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ c((r, n) => {
      Rt(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        n.file.id,
        (a) => Object.assign(a, r)
      ), he(e, i.mutationKey, n, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError(r, n) {
      Rt(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        n.file.id,
        (a) => Object.assign(a, { is_trashed: !1 })
      ), he(e, i.mutationKey, n, (a) => {
        a.status.state = "error", a.status.text = r.message;
      });
    }
  };
  return i;
}
h(LV, "Q3");
c(LV, "getTrashFileMutationOptions");
function zV(s, t) {
  return new Yt(s.queryClient, LV(s, t));
}
h(zV, "G3");
c(zV, "getTrashFileMutation");
function IV(s, t) {
  const e = s.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ c(async ({ file: r }) => {
      if (r.id >= 1) {
        const n = await s.fetch("/api/files/" + r.id + "/restore", { method: "POST" });
        if (!n.ok) {
          const a = await n.json();
          throw new Error(a.detail || a.title, { cause: a });
        }
      } else {
        const n = { status: 400, title: `Could not restore ${r.name}.` };
        throw new Error(n.detail || n.title, { cause: n });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((r) => (Rt(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      r.file.id,
      (n) => Object.assign(n, { status: "pending" })
    ), { type: "restore", file: r.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ c((r, n) => {
      Rt(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        n.file.id,
        (a) => Object.assign(a, { is_trashed: !1, status: "ok" })
      ), he(e, i.mutationKey, n, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError(r, n) {
      Rt(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        n.file.id,
        (a) => Object.assign(a, { is_trashed: !0 })
      ), he(e, i.mutationKey, n, (a) => {
        a.status.state = "error", a.status.text = r.message;
      });
    }
  };
  return i;
}
h(IV, "Z3");
c(IV, "getRestoreFileMutationOptions");
function DV(s, t) {
  return new Yt(s.queryClient, IV(s, t));
}
h(DV, "Y3");
c(DV, "getRestoreFileMutation");
function VV(s, t) {
  const e = s.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ c(async ({ file: r }) => {
      if (r.id >= 1 && r.is_trashed) {
        const n = await s.fetch("/api/files/" + r.id, { method: "DELETE" });
        if (!n.ok) {
          const a = await n.json();
          throw new Error(a.detail || a.title, { cause: a });
        }
      } else {
        const n = { status: 400, title: `Could not delete ${r.name} forever.` };
        throw new Error(n.detail || n.title, { cause: n });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((r) => (Rt(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      r.file.id,
      (n) => Object.assign(n, { status: "pending" })
    ), { type: "delete-forever", file: r.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ c((r, n) => {
      $U(e, { queryKey: i.mutationKey, exact: !1 }, n.file.id), he(e, i.mutationKey, n, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError(r, n) {
      Rt(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        n.file.id,
        (a) => Object.assign(a, { status: void 0 })
      ), he(e, i.mutationKey, n, (a) => {
        a.status.state = "error", a.status.text = r.message;
      });
    }
  };
  return i;
}
h(VV, "X3");
c(VV, "getDeleteForeverFileMutationOptions");
function WV(s, t) {
  return new Yt(s.queryClient, VV(s, t));
}
h(WV, "J3");
c(WV, "getDeleteForeverFileMutation");
function FV(s, t) {
  const e = s.queryClient, i = ["apps", t.id, "files"];
  return {
    mutationKey: i,
    mutationFn: /* @__PURE__ */ c(async ({ file: r, subscribe: n }) => {
      if (r.id >= 1) {
        const a = await s.fetch(`/api/files/${r.id}/${n ? "subscribe" : "unsubscribe"}`, {
          method: "POST"
        });
        if (!a.ok) {
          const o = await a.json();
          throw new Error(o.detail || o.title, { cause: o });
        }
      } else
        throw new Error(`Could not ${n ? "subscribe" : "unsubscribe"} to ${r.name}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((r) => (Rt(
      e,
      { queryKey: i, exact: !1 },
      r.file.id,
      (n) => Object.assign(n, { is_subscribed: r.subscribe, status: "pending" })
    ), {
      type: r.subscribe ? "subscribe" : "unsubscribe",
      file: r.file,
      status: { state: "pending" }
    }), "onMutate"),
    onSuccess: /* @__PURE__ */ c((r, n) => {
      Rt(
        e,
        { queryKey: i, exact: !1 },
        n.file.id,
        (a) => Object.assign(a, { status: "ok" })
      ), he(e, i, n, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ c((r, n) => {
      Rt(
        e,
        { queryKey: i, exact: !1 },
        n.file.id,
        (a) => Object.assign(a, { is_subscribed: n.file.is_subscribed, status: "error" })
      ), he(e, i, n, (a) => {
        a.status.state = "error", a.status.text = r.message;
      });
    }, "onError")
  };
}
h(FV, "tC");
c(FV, "getSubscribeFileMutationOptions");
function qV(s, t) {
  return new Yt(s.queryClient, FV(s, t));
}
h(qV, "eC");
c(qV, "getSubscribeFileMutation");
function ZV(s, t) {
  const e = s.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ c(async ({ file: r, name: n }) => {
      if (r.id >= 1) {
        const a = await s.fetch("/api/files/" + r.id, {
          method: "PATCH",
          body: JSON.stringify({
            name: n
          })
        });
        if (!a.ok) {
          const o = await a.json();
          throw new Error(o.detail || o.title, { cause: o });
        }
        return await a.json();
      } else
        throw new Error(`Could not rename ${r.name}`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((r) => (Rt(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      r.file.id,
      (n) => Object.assign(n, { name: r.name })
    ), { type: "rename", file: r.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ c((r, n) => {
      Rt(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        n.file.id,
        (a) => Object.assign(a, r)
      ), he(e, i.mutationKey, n, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ c((r, n) => {
      Rt(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        n.file.id,
        (a) => Object.assign(a, { name: n.file.name })
      ), he(e, i.mutationKey, n, (a) => {
        a.status.state = "error", a.status.text = r.message;
      });
    }, "onError")
  };
  return i;
}
h(ZV, "iC");
c(ZV, "getRenameFileMutationOptions");
function BV(s, t) {
  return new Yt(s.queryClient, ZV(s, t));
}
h(BV, "rC");
c(BV, "getRenameFileMutation");
const tJ = it`[part~=wy-grid]{display:grid;grid-auto-flow:dense;grid-template-columns:repeat(auto-fill,minmax(calc(10 * var(--wy-size, 1rem)),1fr));grid-gap:var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) 0}`, eJ = it`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-card]{--wy-component-background-color: var(--wy-surface-layer-high, var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039)));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));--wy-component-border-radius: var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));position:relative;display:flex;flex-direction:column;min-width:0;word-wrap:break-word;background-clip:border-box;padding:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-card][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-card-primary]{--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73))}[part~=wy-trashed]{text-decoration:line-through;opacity:var(--wy-opacity-disabled, 38%)}[part~=wy-card-hover]{cursor:pointer;-webkit-user-select:none;user-select:none}[part~=wy-card-hover]:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-card-hover]:hover:before{opacity:var(--wy-opacity-state-hover, 8%)}[part~=wy-card-hover]:focus:before{opacity:var(--wy-opacity-state-focus, 12%)}[part~=wy-card-hover]:active:before,[part~=wy-card-hover][part~=wy-active]:before{opacity:var(--wy-opacity-state-active, 12%)}[part~=wy-card-actions]{position:absolute;top:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));right:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));align-items:center;display:flex}[part~=wy-card-icon]{--wy-component-icon-width: calc(6 * var(--wy-size, 1rem));--wy-component-icon-height: calc(6 * var(--wy-size, 1rem));display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;margin:auto}[part~=wy-card-image]{width:auto;height:auto;border-radius:var(--wy-component-border-radius);object-fit:cover;object-position:center;flex:1 1 100%;max-height:calc(10*var(--wy-size, 1rem))}[part~=wy-card-image][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-card-image][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-card-image-top]{object-position:top center}[part~=wy-card-title]{padding:0 var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:flex;align-items:center;justify-content:space-between;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));height:2.25rem;box-sizing:border-box}[part~=wy-input]{height:2.25rem;box-sizing:border-box;flex:0 1 auto}[part~=wy-card-text]{line-height:var(--wy-line-height, 1.5);flex:0 1 auto;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}[part~=wy-card-action]{flex:0 0 auto;white-space:nowrap}`, iJ = it`[part~=wy-badge]{display:inline-block;text-align:center;vertical-align:middle;align-self:center;font-weight:var(--wy-font-weight-bold, 600);font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));line-height:1.333333;color:var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));background-color:var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));padding:.333333em;min-width:1lh}[part~=wy-badge]:empty{display:none!important}[part~=wy-badge-positioned]{margin:calc(-.5*(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + .333333em*2));position:absolute}[part~=wy-badge-positioned]:not(:empty){display:block}[part~=wy-badge-top-right]{top:0;right:0}[part~=wy-badge-bottom-right]{bottom:0;right:0}[part~=wy-badge-bottom-left]{bottom:0;left:0}[part~=wy-badge-top-left]{top:0;left:0}[part~=wy-badge-compact]{padding:.25em;max-width:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))*3 + .25em);height:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + .25em);line-height:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + .25em)}[part~=wy-badge-compact]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-badge-compact][part~=wy-badge-positioned]{margin:calc(-.5*(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + .25em*2))}[part~=wy-badge-dot]{content-visibility:hidden;line-height:0;min-width:0;height:0;width:0;padding:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-badge-dot][part~=wy-badge-positioned]{margin:calc(-1*var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-badge-reveal]{opacity:1;transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-badge-reveal]{opacity:0}}`;
var rJ = Object.defineProperty, sJ = Object.getOwnPropertyDescriptor, Yy = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? sJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && rJ(t, e, r), r;
}, "__decorateClass$v"), Fx, Cm;
let dn = (Fx = (Cm = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.appearance = "count", this.position = "inline", this.reveal = !1, this.count = NaN, this.limit = 99;
  }
  render() {
    const t = Number.isInteger(this.count) ? this.count > this.limit ? `${this.limit}+` : this.count : "", e = /^(top|bottom)-(right|left)$/.test(this.position), i = {
      "wy-badge": !0,
      "wy-badge-reveal": this.reveal,
      "wy-badge-compact": this.appearance === "compact",
      "wy-badge-dot": this.appearance === "dot",
      "wy-badge-positioned": e,
      [`wy-badge-${this.position}`]: e
    };
    return this.appearance !== "none" && t ? v`<span part=${gt(i)} title=${this.count}>${t}</span>` : C;
  }
}, h(Cm, "Uo"), Cm), c(Fx, "WyBadge"), Fx);
dn.styles = [iJ, ft];
Yy([
  b({ type: String })
], dn.prototype, "appearance", 2);
Yy([
  b({ type: String })
], dn.prototype, "position", 2);
Yy([
  b({ type: Boolean })
], dn.prototype, "reveal", 2);
Yy([
  b({ type: Number })
], dn.prototype, "count", 2);
Yy([
  b({ type: Number })
], dn.prototype, "limit", 2);
dn = Yy([
  Y("wy-badge")
], dn);
var nJ = Object.defineProperty, aJ = Object.getOwnPropertyDescriptor, i2 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? aJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && nJ(t, e, r), r;
}, "__decorateClass$u"), qx, Pm;
let Ml = (qx = (Pm = class extends Xi {
  constructor() {
    super(), this.exportParts = new rt(this), this.isRenamingId = NaN, this.highlightId = NaN, this.highlightRef = $t(), this.addEventListener("edit-name", (t) => {
      this.isRenamingId = t.detail.file.id;
    }), this.addEventListener("rename", () => {
      this.isRenamingId = NaN;
    });
  }
  /**
   * Emit a `file-open` event requesting preview for the given file.
   *
   * @param fileId - Identifier of the file to open.
   * @param tab - Optional preview tab to activate.
   * @returns Whether the event was not canceled.
   */
  dispatchFileOpen(t, e) {
    const i = new CustomEvent("file-open", { detail: { fileId: t, tab: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit an `order` event with the selected sort order.
   *
   * @param order - Order to apply.
   * @returns Whether the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit an `edit-name` event to enter rename mode for the given file.
   *
   * @param file - File that should be renamed.
   * @returns Whether the event was not canceled.
   */
  dispatchEditName(t) {
    const e = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `rename` event containing the updated file name.
   *
   * @param file - File being renamed.
   * @param name - New filename.
   * @returns Whether the event was not canceled.
   */
  dispatchRename(t, e) {
    const i = new CustomEvent("rename", { detail: { file: t, name: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit a `trash` event to move the file to the recycle bin.
   *
   * @param file - File to trash.
   * @returns Whether the event was not canceled.
   */
  dispatchTrash(t) {
    const e = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `restore` event to recover a trashed file.
   *
   * @param file - File to restore.
   * @returns Whether the event was not canceled.
   */
  dispatchRestore(t) {
    const e = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `delete-forever` event to permanently remove a file.
   *
   * @param file - File to delete.
   * @returns Whether the event was not canceled.
   */
  dispatchDeleteForever(t) {
    const e = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling file subscription.
   *
   * @param file - File to subscribe or unsubscribe.
   * @param subscribe - Desired subscription state.
   * @returns Whether the event was not canceled.
   */
  dispatchSubscribe(t, e) {
    const i = new CustomEvent("subscribe", { detail: { file: t, subscribe: e } });
    return this.dispatchEvent(i);
  }
  render() {
    return this.files && this.files.length ? v`
        <div part="wy-grid">
          ${qi(
      this.files,
      (t) => t.id,
      (t) => {
        const e = t.size && t.size > 0 ? Qb(t.size) : C, i = t.updated_at || t.created_at, r = new Intl.DateTimeFormat(this.weavy?.locale, {
          dateStyle: "full",
          timeStyle: "short"
        }).format(new Date(i)), n = !!(this.isRenamingId && this.isRenamingId === t.id), { icon: a } = wn(t.name), o = dr(t.name), l = Fy(t.provider), d = /* @__PURE__ */ c((f) => {
          f.stopImmediatePropagation();
          const y = f.target;
          y.value && y.value !== t.name ? this.dispatchRename(t, y.value) : this.dispatchEditName({ id: NaN });
        }, "handleRename"), u = /* @__PURE__ */ c((f) => {
          const y = f.target;
          f.key === "Escape" ? (f.preventDefault(), y.value = t.name, y.blur()) : f.key === "Enter" && (f.preventDefault(), y.blur());
        }, "handleRenameKey"), p = !!(this.highlightId && this.highlightId === t.id);
        return v`
                <div
                  part=${gt({
          "wy-card": !0,
          "wy-trashed": t.is_trashed,
          "wy-card-hover": !t.is_trashed && !n,
          "wy-highlight": p
        })}
                  title="${t.name} • ${e} • ${r}"
                  tabindex="0"
                  @click=${(f) => {
          g1(f) && (f.stopPropagation(), f.preventDefault(), ps(t.download_url ?? t.external_url, "_blank")), !f.defaultPrevented && !t.is_trashed && this.dispatchFileOpen(t.id);
        }}
                  @keydown=${Ze}
                  @keyup=${bi}
                  ${p && this.highlightRef ? ht(this.highlightRef) : C}
                >
                  <div part="wy-card-actions">
                    <wy-file-menu
                      small
                      .file=${t}
                      @edit-name=${(f) => this.dispatchEditName(f.detail.file)}
                      @trash=${(f) => this.dispatchTrash(f.detail.file)}
                      @restore=${(f) => this.dispatchRestore(f.detail.file)}
                      @delete-forever=${(f) => this.dispatchDeleteForever(f.detail.file)}
                      @subscribe=${(f) => this.dispatchSubscribe(f.detail.file, f.detail.subscribe)}
                    ></wy-file-menu>
                  </div>
                  ${!t.is_trashed && t.thumbnail_url ? v`
                        <img
                          part="wy-card-image ${gt({ "wy-card-image-top": t.kind !== "image" })}"
                          width=${St(t.width)}
                          height=${St(t.height)}
                          src=${t.thumbnail_url}
                          alt=${t.name}
                          ${ht(jb)}
                          @load=${Ub}
                          loading="lazy"
                          decoding="async"
                        />
                      ` : v`
                        <div part="wy-card-icon ">
                          <wy-icon
                            name=${a}
                            .overlayName=${l}
                            size="96"
                            kind=${t.kind}
                            ext=${o}
                          ></wy-icon>
                        </div>
                      `}
                  ${n ? v`
                        <input
                          type="text"
                          name="filename"
                          maxlength="256"
                          part="wy-input"
                          .defaultValue=${t.name}
                          @blur=${d}
                          @keyup=${(f) => {
          nn(f), u(f);
        }}
                          @click=${(f) => f.preventDefault()}
                          @focus=${Ab}
                          ${ht(BS)}
                        />
                      ` : v`<div part="wy-card-title">
                        <div part="wy-card-text">${t.name}</div> ${t.comments?.count ? v`<wy-button
                              part="wy-card-button-icon"
                              small
                              color="none"
                              kind="inline"
                              @click=${(f) => {
          !f.defaultPrevented && !t.is_trashed && (f.target.blur(), this.dispatchFileOpen(t.id, "comments"), f.stopPropagation());
        }}
                              title=${P(lt`${t.comments.count} comments`)}
                            >
                              <wy-badge count=${t.comments.count}></wy-badge>
                            </wy-button>` : C}
                      </div>`}
                </div>
              `;
      }
    )}
        </div>
      ` : C;
  }
  updated(t) {
    t.has("highlightId") && this.highlightId && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, h(Pm, "qo"), Pm), c(qx, "WyFileGrid"), qx);
Ml.styles = [Ea, tJ, eJ, ft];
i2([
  b({ attribute: !1 })
], Ml.prototype, "files", 2);
i2([
  N()
], Ml.prototype, "isRenamingId", 2);
i2([
  N()
], Ml.prototype, "highlightId", 2);
Ml = i2([
  Lz("wy-file-grid"),
  At()
], Ml);
const oJ = it`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-table]{table-layout:fixed;width:100%;vertical-align:top;border-collapse:collapse}[part~=wy-table] tr[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-table] th{font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600))}[part~=wy-table] th,[part~=wy-table] td{background-color:var(--wy-component-background-color);padding:var(--wy-table-cell-padding-y, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))) var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));box-shadow:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf)) 0 -1px 0 0 inset;line-height:1;vertical-align:middle;height:calc(calc(2 * var(--wy-size, 1rem)) + var(--wy-table-cell-padding-y, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*2)}[part~=wy-table]>tbody{vertical-align:inherit}[part~=wy-table]>thead{vertical-align:bottom}[part~=wy-table][part~=wy-table-interactive]>tbody>tr:hover>*{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));color:var(--wy-component-color);cursor:pointer}[part~=wy-col-icon]{vertical-align:middle;text-align:center;padding:calc(var(--wy-table-cell-padding-y, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*.5) calc(var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*.5);width:calc(calc(2 * var(--wy-size, 1rem)) + var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*2);font-size:var(--wy-font-size, var(--wy-size, 1em));font-weight:var(--wy-font-weight, unset);text-transform:none;letter-spacing:normal}[part~=wy-col-icon-content]{display:flex;justify-content:center;align-items:center}[part~=wy-trashed]{text-decoration:line-through}[part~=wy-sort-link]{display:inline-flex;align-items:center;color:var(--wy-primary, var(--wy-primary-light, #2f628c));cursor:pointer}`, lJ = it`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}table thead{text-align:left;display:none}@container (inline-size >= 576px){table thead{display:table-header-group}}[part~=wy-col-name]{width:100%}[part~=wy-col-name]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-col-name] [part~=wy-input]{width:100%;box-sizing:border-box}[part~=wy-col-time]{width:calc(8*var(--wy-size, 1rem));display:none}@container (inline-size >= 768px){[part~=wy-col-time]{display:table-cell}}[part~=wy-col-time]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-col-kind]{width:calc(8*var(--wy-size, 1rem));display:none}@container (inline-size >= 768px){[part~=wy-col-kind]{display:table-cell}}[part~=wy-col-kind]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-col-size]{width:calc(6*var(--wy-size, 1rem));text-align:right;display:none}@container (inline-size >= 576px){[part~=wy-col-size]{display:table-cell}}[part~=wy-col-size]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}`;
var cJ = Object.defineProperty, hJ = Object.getOwnPropertyDescriptor, N1 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? hJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && cJ(t, e, r), r;
}, "__decorateClass$t"), Zx, Qm;
let ka = (Zx = (Qm = class extends Xi {
  constructor() {
    super(), this.exportParts = new rt(this), this.order = { by: "name", descending: !1 }, this.isRenamingId = NaN, this.highlightId = NaN, this.highlightRef = $t(), this.addEventListener("edit-name", (t) => {
      this.isRenamingId = t.detail.file.id;
    }), this.addEventListener("rename", () => {
      this.isRenamingId = NaN;
    });
  }
  /**
   * Emit a `file-open` event requesting preview for the supplied file.
   *
   * @param fileId - Identifier of the file to open.
   * @param tab - Optional preview tab to activate.
   * @returns Whether the event was not canceled.
   */
  dispatchFileOpen(t, e) {
    const i = new CustomEvent("file-open", { detail: { fileId: t, tab: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit an `order` event with the provided sort order.
   *
   * @param order - Order to apply.
   * @returns Whether the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit an `edit-name` event to enter rename mode for the specified file.
   *
   * @param file - File that should be renamed.
   * @returns Whether the event was not canceled.
   */
  dispatchEditName(t) {
    const e = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `rename` event carrying the updated filename.
   *
   * @param file - File being renamed.
   * @param name - New filename value.
   * @returns Whether the event was not canceled.
   */
  dispatchRename(t, e) {
    const i = new CustomEvent("rename", { detail: { file: t, name: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit a `trash` event to move the file to the recycle bin.
   *
   * @param file - File to trash.
   * @returns Whether the event was not canceled.
   */
  dispatchTrash(t) {
    const e = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `restore` event to recover a trashed file.
   *
   * @param file - File to restore.
   * @returns Whether the event was not canceled.
   */
  dispatchRestore(t) {
    const e = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `delete-forever` event to permanently remove the file.
   *
   * @param file - File targeted for permanent deletion.
   * @returns Whether the event was not canceled.
   */
  dispatchDeleteForever(t) {
    const e = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling subscription state for the file.
   *
   * @param file - File whose subscription changes.
   * @param subscribe - Desired subscription state.
   * @returns Whether the event was not canceled.
   */
  dispatchSubscribe(t, e) {
    const i = new CustomEvent("subscribe", { detail: { file: t, subscribe: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Render the complete file table layout.
   *
   * @param files - Files to render.
   * @param order - Current table order.
   * @param isRenamingId - File id in rename mode.
   * @param highlightId - File id to highlight.
   * @param highlightRef - Reference for scrolling highlighted rows.
   */
  renderFileTable(t, e, i, r, n) {
    return t && t.length ? v`
          <table part="wy-table wy-table-interactive">
            <thead>${this.renderFileTableHeaders.call(this, e)}</thead>
            <tbody>
              ${qi(
      t,
      (a) => a.id,
      (a) => this.renderFileTableRow.call(this, this.weavy, { file: a }, i, r, n)
    )}
            </tbody>
          </table>
        ` : C;
  }
  /**
   * Render table header cells with sorting affordances.
   *
   * @param order - Current sort order.
   */
  renderFileTableHeaders(t) {
    const e = [
      { col: "icon", by: void 0, title: "" },
      // File icon
      { col: "name", by: "name", title: P("Name") },
      { col: "icon", by: void 0, title: "" },
      // Comments icon
      { col: "time", by: "updated_at", title: P("Modified") },
      { col: "kind", by: void 0, title: P("Kind") },
      { col: "size", by: "size", title: P("Size") },
      { col: "icon", by: void 0, title: "" }
      // Menu
    ];
    return v`
      <tr>
        ${e.map((i) => {
      if (i.title) {
        const r = i.by === t?.by, n = /* @__PURE__ */ c((a) => {
          a.preventDefault(), i.by && this.dispatchOrder({ by: i.by, descending: r && !t?.descending });
        }, "onHeaderClick");
        return v` <th part="wy-th ${`wy-col-${i.col}`}">
              ${i.by ? v`<div
                    part="wy-sort-link"
                    tabindex="0"
                    @click=${n}
                    @keydown=${Ze}
                    @keyup=${bi}
                    >${i.title}
                    ${r && v`<wy-icon name=${t?.descending ? "menu-down" : "menu-up"}></wy-icon>` || C}</div
                  >` : i.title}
            </th>`;
      } else
        return v`<th part="wy-th wy-col-icon"></th>`;
    })}
      </tr>
    `;
  }
  /**
   * Render a single file table row.
   *
   * @param weavy - Current Weavy context.
   * @param row - Row data containing the file.
   * @param isRenamingId - File id in rename mode.
   * @param highlightId - File id to highlight.
   * @param highlightRef - Reference for scrolling highlighted rows.
   */
  renderFileTableRow(t, { file: e }, i, r, n) {
    const a = e.size && e.size > 0 ? Qb(e.size) : C, o = e.updated_at || e.created_at, l = new Intl.DateTimeFormat(t?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(o)
    ), d = new Intl.DateTimeFormat(t?.locale, { dateStyle: "short" }).format(
      new Date(o)
    ), u = !!(i && i === e.id), { icon: p } = wn(e.name), f = dr(e.name), y = Fy(e.provider), g = /* @__PURE__ */ c(($) => {
      $.stopImmediatePropagation();
      const T = $.target;
      T.value && T.value !== e.name ? this.dispatchRename(e, T.value) : this.dispatchEditName({ id: NaN });
    }, "handleRename"), O = /* @__PURE__ */ c(($) => {
      const T = $.target;
      $.key === "Escape" ? ($.preventDefault(), T.value = e.name, T.blur()) : $.key === "Enter" && ($.preventDefault(), T.blur());
    }, "handleRenameKey"), k = !!(r && r === e.id);
    return v`
      <tr
        part=${gt({ "wy-tr": !0, "wy-highlight": k, "wy-trashed": e.is_trashed })}
        @click=${($) => {
      g1($) && ($.stopPropagation(), $.preventDefault(), ps(e.download_url ?? e.external_url, "_blank")), !$.defaultPrevented && !e.is_trashed && this.dispatchFileOpen(e.id);
    }}
        ${k && n ? ht(n) : C}
      >
        <td part="wy-td wy-col-icon"
          ><wy-icon part="wy-col-icon-content" name=${p} .overlayName=${y} size="24" kind=${e.kind} ext=${f}></wy-icon
        ></td>
        <td part="wy-td wy-col-name">
          ${u ? v`
                <input
                  type="text"
                  name="filename"
                  maxlength="256"
                  part="wy-input"
                  .defaultValue=${e.name}
                  @blur=${g}
                  @keyup=${($) => {
      nn($), O($);
    }}
                  @click=${($) => $.preventDefault()}
                  @focus=${Ab}
                  ${ht(BS)}
                />
              ` : v`${e.name}`}
        </td>
        <td part="wy-td wy-col-icon"
          >${e.comments?.count ? v`<wy-button
                part="wy-col-icon-content"
                kind="inline"
                @click=${($) => {
      !$.defaultPrevented && !e.is_trashed && ($.target.blur(), this.dispatchFileOpen(e.id, "comments"), $.stopPropagation());
    }}
                title=${P(lt`${e.comments.count} comments`)}
              >
                <wy-badge count=${e.comments.count}></wy-badge>
              </wy-button>` : C}</td
        >
        <td part="wy-td wy-col-time"
          ><time datetime="${o}" title=${l}>${d}</time></td
        >
        <td part="wy-td wy-col-kind">${e.kind}</td>
        <td part="wy-td wy-col-size">${a}</td>
        <td part="wy-td wy-col-icon">
          <wy-file-menu
            part="wy-col-icon-content"
            .file=${e}
            @edit-name=${($) => this.dispatchEditName($.detail.file)}
            @trash=${($) => this.dispatchTrash($.detail.file)}
            @restore=${($) => this.dispatchRestore($.detail.file)}
            @delete-forever=${($) => this.dispatchDeleteForever($.detail.file)}
            @subscribe=${($) => this.dispatchSubscribe($.detail.file, $.detail.subscribe)}
          >
          </wy-file-menu>
        </td>
      </tr>
    `;
  }
  render() {
    return this.files && this.files.length ? this.renderFileTable.call(
      this,
      this.files,
      this.order,
      this.isRenamingId,
      this.highlightId,
      this.highlightRef
    ) : C;
  }
  updated(t) {
    t.has("highlightId") && this.highlightId && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, h(Qm, "jo"), Qm), c(Zx, "WyFileTable"), Zx);
ka.styles = [Ea, oJ, lJ, ft];
N1([
  b({ attribute: !1 })
], ka.prototype, "files", 2);
N1([
  b({ attribute: !1 })
], ka.prototype, "order", 2);
N1([
  N()
], ka.prototype, "isRenamingId", 2);
N1([
  N()
], ka.prototype, "highlightId", 2);
ka = N1([
  Lz("wy-file-table"),
  At()
], ka);
var dJ = Object.defineProperty, uJ = Object.getOwnPropertyDescriptor, NV = /* @__PURE__ */ c((s) => {
  throw TypeError(s);
}, "__typeError$6"), Gy = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? uJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && dJ(t, e, r), r;
}, "__decorateClass$s"), XV = /* @__PURE__ */ c((s, t, e) => t.has(s) || NV("Cannot " + e), "__accessCheck$6"), F9 = /* @__PURE__ */ c((s, t, e) => (XV(s, t, "read from private field"), e ? e.call(s) : t.get(s)), "__privateGet$6"), pJ = /* @__PURE__ */ c((s, t, e) => t.has(s) ? NV("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(s) : t.set(s, e), "__privateAdd$6"), q9 = /* @__PURE__ */ c((s, t, e, i) => (XV(s, t, "write to private field"), t.set(s, e), e), "__privateSet$6"), sh, Bx, Tm;
let un = (Bx = (Tm = class extends Pe {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.order = { by: "name", descending: !1 }, this.view = "list", this.showTrashed = !1, this.highlightId = NaN, this.highlightComment = !1, this.filesQuery = new Wl(this), this.previewRef = $t(), this.infiniteScroll = new Fl(this), this.pagerRef = $t(), this.handleRealtimeFileCreated = (t) => {
      !this.weavy || !this.app || (t.file.created_by = t.actor, this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) }));
    }, this.handleRealtimeFileUpdated = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileTrashed = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileRestored = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileDeleted = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeCommentCreated = () => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, pJ(this, sh);
  }
  /**
   * Resolve the query key used for the app file listing.
   *
   * @internal
   * @param app - App owning the files.
   */
  getFilesQueryKey(t) {
    return ["apps", t.id, "files"];
  }
  /**
   * Emit a `file-open` event requesting preview for the supplied file.
   *
   * @param fileId - Identifier of the file to open.
   * @param tab - Optional preview tab to activate.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchFileOpen(t, e) {
    const i = new CustomEvent("file-open", { detail: { fileId: t, tab: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit an `order` event with the provided sort order.
   *
   * @param order - Order to apply.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("link") && (this.highlightId = this.link && U4(this.link, vi.File)?.id, this.highlightComment = this.link && this.highlightId ? H4(this.link, vi.File, { id: this.highlightId }, vi.Comment) : !1), t.has("highlightComment") && this.highlightComment && this.highlightId && this.dispatchFileOpen(this.highlightId, "comments"), (t.has("weavy") || t.has("app") || t.has("order") || t.has("showTrashed")) && this.weavy && this.app && await this.filesQuery.trackInfiniteQuery(
      _V(this.weavy, this.app.id, {
        order: this.order,
        trashed: this.showTrashed
      })
    ), (t.has("weavy") || t.has("app") || t.has("user")) && this.weavy && this.app && this.user) {
      this.renameFileMutation = BV(this.weavy, this.app), this.subscribeFileMutation = qV(this.weavy, this.app), this.trashFileMutation = zV(this.weavy, this.app), this.restoreFileMutation = DV(this.weavy, this.app), this.deleteForeverFileMutation = WV(this.weavy, this.app), (e = F9(this, sh)) == null || e.call(this);
      const i = `a${this.app.id}`;
      this.weavy.subscribe(i, "file_created", this.handleRealtimeFileCreated), this.weavy.subscribe(i, "file_updated", this.handleRealtimeFileUpdated), this.weavy.subscribe(i, "file_trashed", this.handleRealtimeFileTrashed), this.weavy.subscribe(i, "file_restored", this.handleRealtimeFileRestored), this.weavy.subscribe(i, "file_deleted", this.handleRealtimeFileDeleted), this.weavy.subscribe(i, "comment_created", this.handleRealtimeCommentCreated), q9(this, sh, () => {
        this.weavy?.unsubscribe(i, "file_created", this.handleRealtimeFileCreated), this.weavy?.unsubscribe(i, "file_updated", this.handleRealtimeFileUpdated), this.weavy?.unsubscribe(i, "file_trashed", this.handleRealtimeFileTrashed), this.weavy?.unsubscribe(i, "file_restored", this.handleRealtimeFileRestored), this.weavy?.unsubscribe(i, "file_deleted", this.handleRealtimeFileDeleted), this.weavy?.unsubscribe(i, "comment_created", this.handleRealtimeCommentCreated), q9(this, sh, void 0);
      });
    }
  }
  render() {
    const { data: t, hasNextPage: e, isPending: i } = this.filesQuery.result, r = ys(t);
    return r && r.length ? v`
        ${this.view === "grid" ? v`
              <wy-file-grid
                .files=${r}
                .highlightId=${this.highlightId}
                @file-open=${(n) => {
      this.previewRef.value?.open(n.detail.fileId, n.detail.tab);
    }}
                @order=${(n) => this.dispatchOrder(n.detail.order)}
                @rename=${(n) => {
      this.renameFileMutation?.mutate({ file: n.detail.file, name: n.detail.name });
    }}
                @subscribe=${(n) => {
      this.subscribeFileMutation?.mutate({
        file: n.detail.file,
        subscribe: n.detail.subscribe
      });
    }}
                @trash=${(n) => {
      this.trashFileMutation?.mutate({ file: n.detail.file });
    }}
                @restore=${(n) => {
      this.restoreFileMutation?.mutate({ file: n.detail.file });
    }}
                @delete-forever=${(n) => {
      this.deleteForeverFileMutation?.mutate({ file: n.detail.file });
    }}
              ></wy-file-grid>
            ` : v`
              <wy-file-table
                .files=${r}
                .order=${this.order}
                .highlightId=${this.highlightId}
                @file-open=${(n) => {
      this.previewRef.value?.open(n.detail.fileId, n.detail.tab);
    }}
                @order=${(n) => this.dispatchOrder(n.detail.order)}
                @rename=${(n) => {
      this.renameFileMutation?.mutate({ file: n.detail.file, name: n.detail.name });
    }}
                @subscribe=${(n) => {
      this.subscribeFileMutation?.mutate({
        file: n.detail.file,
        subscribe: n.detail.subscribe
      });
    }}
                @trash=${(n) => {
      this.trashFileMutation?.mutate({ file: n.detail.file });
    }}
                @restore=${(n) => {
      this.restoreFileMutation?.mutate({ file: n.detail.file });
    }}
                @delete-forever=${(n) => {
      this.deleteForeverFileMutation?.mutate({ file: n.detail.file });
    }}
              ></wy-file-table>
            `}
        ${e ? v`<div ${ht(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
        ${t ? v` <wy-preview ${ht(this.previewRef)} .infiniteQueryResult=${this.filesQuery.result}></wy-preview> ` : C}
      ` : v`
        <wy-empty>
          ${i ? v`<wy-progress-circular indeterminate padded reveal></wy-progress-circular>` : v` <wy-icon-display>
                <wy-icon name="file-upload"></wy-icon>
                <span slot="text">${P("Add some files to get started!")}</span>
              </wy-icon-display>`}
        </wy-empty>
      `;
  }
  updated() {
    this.infiniteScroll.observe(this.filesQuery.result, this.pagerRef.value);
  }
  disconnectedCallback() {
    var t;
    (t = F9(this, sh)) == null || t.call(this), super.disconnectedCallback();
  }
}, h(Tm, "Wo"), Tm), c(Bx, "WyFilesList"), Bx);
sh = /* @__PURE__ */ new WeakMap();
un.styles = [Ma];
Gy([
  b({ type: Object })
], un.prototype, "order", 2);
Gy([
  b()
], un.prototype, "view", 2);
Gy([
  b({ type: Boolean })
], un.prototype, "showTrashed", 2);
Gy([
  N()
], un.prototype, "highlightId", 2);
Gy([
  N()
], un.prototype, "highlightComment", 2);
un = Gy([
  Y("wy-files-list"),
  At()
], un);
var fJ = Object.defineProperty, mJ = Object.getOwnPropertyDescriptor, r2 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? mJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && fJ(t, e, r), r;
}, "__decorateClass$r"), Nx, Mm;
let Sa = (Nx = (Mm = class extends Ni {
  constructor() {
    super(), this.appType = xt.Files, this.componentFeatures = new di({
      // All available features as enabled/disabled by default
      [L.Attachments]: !0,
      [L.CloudFiles]: !0,
      [L.Comments]: !0,
      [L.ContextData]: !0,
      [L.Embeds]: !0,
      [L.GoogleMeet]: !1,
      [L.Meetings]: !1,
      [L.Mentions]: !0,
      [L.MicrosoftTeams]: !1,
      [L.Polls]: !0,
      [L.Previews]: !0,
      [L.Reactions]: !0,
      [L.Typing]: !1,
      // Has no effect currently
      [L.Versions]: !0,
      [L.WebDAV]: !0,
      [L.ZoomMeetings]: !1
    }), this.theme = new Ri(this, Sa.styles), this.view = "list", this.order = { by: "name", descending: !1 }, this.showTrashed = !1, this.persistState = new Q1(this), this.dropZone = new lI(this), this.uploadBlobMutation = new Wr(this), this.createFileMutation = new Wr(this), this.addEventListener("drop-files", (t) => this.handleBlobUpload(t));
  }
  /** @internal */
  handleBlobUpload(t) {
    const e = t.detail;
    if (e.files)
      for (let i = 0; i < e.files.length; i++) {
        const r = { file: e.files[i] };
        this.uploadBlobMutation.mutate(r).then((n) => this.handleCreateFile(n));
      }
  }
  /** @internal */
  handleExternalBlobs(t) {
    if (t.detail.externalBlobs)
      for (let e = 0; e < t.detail.externalBlobs.length; e++) {
        const i = t.detail.externalBlobs[e];
        this.externalBlobMutation?.mutate({ externalBlob: i }).then((r) => this.handleCreateFile(r));
      }
  }
  /** @internal */
  async handleCreateFile(t, e) {
    return await this.createFileMutation.mutate({ blob: t, replace: e });
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("uid") || t.has("weavy") || t.has("user")) && this.uid && this.weavy && this.user && this.persistState.observe(
      [
        { name: "view", override: !0 },
        { name: "order", override: !0 },
        { name: "showTrashed", override: !0 }
      ],
      this.uid.toString(),
      `u${this.user.id}`
    ), (t.has("weavy") || t.has("app") || t.has("user")) && this.weavy && this.app && this.user && (await this.uploadBlobMutation.trackMutation(Eb(this.weavy, this.user, this.app.id)), await this.createFileMutation.trackMutation(Hz(this.weavy, this.user, this.app)), this.externalBlobMutation = s3(this.weavy, this.user, this.app.id));
  }
  render() {
    const t = this.dropZone.isDragActive;
    return v`
      <div
        part="wy-files ${gt({ "wy-dragging": t })}"
        data-drag-title=${P("Drop files here")}
      >
        <wy-files-header
          .order=${this.order}
          .showTrashed=${this.showTrashed}
          .view=${this.view}
          @upload-files=${(e) => this.handleBlobUpload(e)}
          @external-blobs=${(e) => this.handleExternalBlobs(e)}
          @create-files=${(e) => e.detail.blobs.forEach((i) => this.handleCreateFile(i, e.detail.replace))}
          @order=${(e) => {
      this.order = e.detail.order;
    }}
          @show-trashed=${(e) => {
      this.showTrashed = e.detail.showTrashed;
    }}
          @view=${(e) => {
      this.view = e.detail.view;
    }}
          @subscribe=${(e) => this.subscribe(e.detail.subscribe)}
        >
          <slot name="actions" slot="actions"></slot>
        </wy-files-header>

        <wy-files-list
          .view=${this.view}
          .order=${this.order}
          .showTrashed=${this.showTrashed}
          @order=${(e) => {
      this.order = e.detail.order;
    }}
        ></wy-files-list>
      </div>
    `;
  }
}, h(Mm, "Ko"), Mm), c(Nx, "WyFiles"), Nx);
Sa.styles = [
  bV,
  Ie,
  vn,
  ql,
  Ei,
  Zl
];
r2([
  b()
], Sa.prototype, "view", 2);
r2([
  b({ type: Object })
], Sa.prototype, "order", 2);
r2([
  b({ type: Boolean })
], Sa.prototype, "showTrashed", 2);
Sa = r2([
  Y("wy-files"),
  At()
], Sa);
function jV(s, t) {
  const e = s.queryClient, i = {
    mutationKey: ["posts", t.id],
    mutationFn: /* @__PURE__ */ c(async ({ id: r }) => {
      if (!(await s.fetch("/api/posts/" + r + "/trash", { method: "POST" })).ok)
        throw new Error();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((r) => {
      Rt(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.id,
        (n) => Object.assign(n, { is_trashed: !0 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((r, n) => {
      Rt(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        n.id,
        (a) => Object.assign(a, r)
      );
    }, "onSuccess")
  };
  return i;
}
h(jV, "bC");
c(jV, "getTrashPostMutationOptions");
function UV(s, t) {
  return new Yt(s.queryClient, jV(s, t));
}
h(UV, "xC");
c(UV, "getTrashPostMutation");
function HV(s, t) {
  const e = s.queryClient, i = {
    mutationKey: ["posts", t.id],
    mutationFn: /* @__PURE__ */ c(async ({ id: r }) => {
      const n = await s.fetch("/api/posts/" + r + "/restore", { method: "POST" });
      if (!n.ok) {
        const a = await n.json();
        throw new Error(a.detail || a.title, { cause: a });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((r) => {
      Rt(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.id,
        (n) => Object.assign(n, { is_trashed: !1 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((r, n) => {
      Rt(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        n.id,
        (a) => Object.assign(a, { is_trashed: !1 })
      );
    }, "onSuccess")
  };
  return i;
}
h(HV, "CC");
c(HV, "getRestorePostMutationOptions");
function YV(s, t) {
  return new Yt(s.queryClient, HV(s, t));
}
h(YV, "$C");
c(YV, "getRestorePostMutation");
function GV(s, t) {
  const e = s.queryClient, i = ["posts", t.id];
  return {
    mutationKey: i,
    mutationFn: /* @__PURE__ */ c(async ({ id: r, subscribe: n }) => {
      const a = await s.fetch(
        `/api/posts/${r}/${n ? "subscribe" : "unsubscribe"}`,
        { method: "POST" }
      );
      if (!a.ok) {
        const o = await a.json();
        throw new Error(o.detail || o.title, { cause: o });
      }
      return await a.json();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ c((r) => {
      Rt(
        e,
        { queryKey: i, exact: !1 },
        r.id,
        (n) => Object.assign(n, { is_subscribed: r.subscribe })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((r, n) => {
      Rt(
        e,
        { queryKey: i, exact: !1 },
        n.id,
        (a) => Object.assign(a, r)
      );
    }, "onSuccess")
  };
}
h(GV, "kC");
c(GV, "getSubscribePostMutationOptions");
function KV(s, t) {
  return new Yt(s.queryClient, GV(s, t));
}
h(KV, "PC");
c(KV, "getSubscribePostMutation");
function JV(s, t) {
  return {
    initialPageParam: 0,
    queryKey: ["posts", t],
    queryFn: /* @__PURE__ */ c(async (e) => {
      const i = e.pageParam, r = "/api/apps/" + t + "/posts?order_by=id+desc&skip=" + i, n = await (await s.fetch(r)).json();
      return n.data = n.data || [], n;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ c((e) => {
      if (e.end && e.end < e.count)
        return e.end;
    }, "getNextPageParam")
  };
}
h(JV, "_C");
c(JV, "getPostsOptions");
function tW(s, t) {
  return {
    mutationFn: /* @__PURE__ */ c(async (e) => await (await s.fetch("/api/posts/" + e.id, {
      method: "PATCH",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        attachments: e.attachments,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ id: i.id, text: i.text })),
        embed_id: e.embed_id || null
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ c((e) => {
      ke(s.queryClient, ["posts", e.app_id], e.id, (i) => {
        i.text = e.text, i.html = e.text;
      });
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((e, i) => {
      i.id && ke(s.queryClient, ["posts", i.app_id], i.id, (r) => {
        r.text = e.text, r.html = e.html, r.attachments = e.attachments, r.embed = e.embed, r.meeting = e.meeting, r.updated_at = e.updated_at, r.updated_by = e.updated_by, r.options = e.options;
      });
    }, "onSuccess")
  };
}
h(tW, "SC");
c(tW, "getUpdatePostMutationOptions");
function eW(s, t) {
  const e = s.queryClient;
  return {
    mutationFn: /* @__PURE__ */ c(async (i) => await (await s.fetch("/api/apps/" + i.app_id + "/posts", {
      method: "POST",
      body: JSON.stringify({
        text: i.text,
        blobs: i.blobs,
        meeting_id: i.meeting_id,
        options: i.poll_options.filter((r) => r.text.trim() !== "").map((r) => ({ text: r.text })),
        embed_id: i.embed_id,
        context: i.context
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ c(async (i) => {
      const r = ["posts", i.app_id];
      await e.cancelQueries({ queryKey: r });
      const n = ga(s.queryClient, r, !1);
      if (i.user) {
        const a = {
          id: n ? n.id - 1 : -1,
          app: { id: i.app_id },
          is_subscribed: !0,
          is_trashed: !1,
          text: i.text,
          html: i.text,
          plain: i.text,
          created_by: i.user,
          created_at: (/* @__PURE__ */ new Date()).toUTCString(),
          attachments: { count: 0 },
          reactions: { count: 0 },
          is_starred: !1,
          comments: { count: 0 }
        };
        ya(e, ["posts", i.app_id], a, { descending: !0 });
      }
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ c((i) => {
      const r = ["posts", i.app.id];
      if (!T1(s.queryClient, r, i.id)) {
        const n = ga(s.queryClient, r, !0);
        n ? ke(s.queryClient, r, n.id, (a) => {
          a.id = i.id, a.app = i.app, a.text = i.text, a.html = i.html, a.embed = i.embed, a.meeting = i.meeting, a.attachments = i.attachments, a.options = i.options, a.created_at = i.created_at, a.created_by = i.created_by, a.updated_at = i.updated_at, a.updated_by = i.updated_by;
        }) : ya(s.queryClient, r, i);
      }
    }, "onSuccess")
  };
}
h(eW, "MC");
c(eW, "getAddPostMutationOptions");
const s2 = it`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-posts]{display:flex;flex-direction:column;gap:var(--wy-gap-xl, calc(2 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-posts-header]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));color:var(--wy-component-color);display:flex;flex-direction:column;position:relative;--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-post]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-background, var(--wy-background-light, #f7f9ff));color:var(--wy-component-color);display:flex;flex-direction:column;position:relative;clip-path:border-box;--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-component-border-radius)}[part~=wy-post][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-post-images]{display:flex;flex-direction:column;margin-top:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-post-header]{display:flex;flex-direction:column;padding:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) 0;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-post-body]{display:flex;flex-direction:column;padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) 0;gap:var(--wy-gap-xl, calc(2 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-post-footer]{display:flex;align-items:center;justify-content:space-between;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-content]{padding:0 var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-comments]{background-color:var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));interpolate-size:allow-keywords;padding:0 var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));height:0;visibility:hidden;transition:height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),padding var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));overflow:hidden}[part~=wy-post-comments][part~=wy-show]{height:auto;visibility:visible;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-post-trashed]{padding-bottom:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}::part(wy-trashed){text-decoration:line-through;color:var(--wy-outline, var(--wy-outline-light, #72777f))}`;
var yJ = Object.defineProperty, gJ = Object.getOwnPropertyDescriptor, l3 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? gJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && yJ(t, e, r), r;
}, "__decorateClass$q"), Xx, Am;
let My = (Xx = (Am = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this);
  }
  /**
   * Emit a `restore` event requesting restoration of the trashed post.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  render() {
    return v`
      <div part="wy-post wy-post-trashed">
        <wy-item part="wy-post-header" size="md" noPadding>
          <wy-avatar
            slot="image"
            .src="${this.createdBy.avatar_url}"
            .isAgent=${this.createdBy.is_agent}
            .size=${48}
            .name=${this.createdBy.name}
          ></wy-avatar>
          <span part="wy-trashed" slot="title">${P("Post was trashed.")}</span>
          <wy-button small slot="actions" @click=${() => this.dispatchRestore()} color="variant"
            >${P("Undo")}</wy-button
          >
        </wy-item>
      </div>
    `;
  }
}, h(Am, "Qo"), Am), c(Xx, "WyPostTrashed"), Xx);
My.styles = [s2, ft];
l3([
  b({ type: Number })
], My.prototype, "postId", 2);
l3([
  b({ attribute: !1 })
], My.prototype, "createdBy", 2);
My = l3([
  Y("wy-post-trashed"),
  At()
], My);
var wJ = Object.defineProperty, vJ = Object.getOwnPropertyDescriptor, Me = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? vJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && wJ(t, e, r), r;
}, "__decorateClass$p"), jx, Rm;
let ce = (jx = (Rm = class extends Pe {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.html = "", this.text = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.commentCount = 0, this.seenBy = [], this.highlight = !1, this.showComments = !1, this.loadComments = !1, this.isCommentLinked = !1, this.previewAnnotationsRef = $t(), this.previewAttachmentsRef = $t(), this.highlightRef = $t();
  }
  /**
   * Emit a `vote` event for the specified poll option.
   *
   * @internal
   * @param optionId - Identifier of the selected poll option.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling post subscription state.
   *
   * @internal
   * @param subscribe - Desired subscription state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", {
      detail: { id: this.postId, subscribe: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `trash` event requesting the post to move into trash.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  /**
   * Emit an `edit` event toggling edit mode for this post.
   *
   * @internal
   * @param edit - Desired edit state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchEdit(t) {
    const e = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Toggle comment visibility and ensure comment data is loaded.
   *
   * @internal
   * @param e - Click event originating from the comment button.
   */
  handleCommentsClick(t) {
    t.preventDefault(), this.showComments = !this.showComments, this.loadComments = !0;
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("link") && (this.highlight = !!(this.link && D1(this.link, vi.Post, { id: this.postId })), this.isCommentLinked = !!(this.link && H4(this.link, vi.Post, { id: this.postId }, vi.Comment))), t.has("isCommentLinked") && this.isCommentLinked && (this.loadComments = !0, this.showComments = !0);
  }
  render() {
    const t = this.attachments?.filter((g) => g.kind === "image" && g.thumbnail_url), e = this.attachments?.filter((g) => g.kind !== "image" || !g.thumbnail_url), i = new Intl.DateTimeFormat(this.weavy?.locale, {
      dateStyle: "full",
      timeStyle: "short"
    }).format(new Date(this.createdAt)), r = Hl(this.weavy?.locale, new Date(this.createdAt)), n = this.modifiedAt && this.weavy ? new Intl.DateTimeFormat(this.weavy.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.modifiedAt)
    ) : "", a = !!(t && t.length), o = !!this.html, l = !!(this.annotations && this.annotations.length), d = !!(this.pollOptions && this.pollOptions.length), u = !!(this.componentFeatures?.allowsFeature(L.Embeds) && this.embed), p = e && !!e.length, f = !!this.meeting, y = o || l || d || u || p || f;
    return this.postId < 0 ? v`
          <div part="wy-post">
            <wy-item part="wy-post-header" align="top" size="md" noPadding>
              <wy-avatar
                slot="image"
                .src="${this.createdBy.avatar_url}"
                .isAgent=${this.createdBy.is_agent}
                .size=${48}
                .name=${this.createdBy.name}
              ></wy-avatar>
              <span slot="title" part="wy-placeholder">${this.createdBy.name}</span>
              <time slot="text" part="wy-placeholder">${r}</time>
            </wy-item>
            <div part="wy-post-body">
              <div part="wy-content wy-post-content"><wy-skeleton .text=${this.text}></wy-skeleton></div>
            </div>
            <div part="wy-post-footer"></div>
          </div>
        ` : v`
          <div
            part=${gt({ "wy-post": !0, "wy-highlight": this.highlight && !this.isCommentLinked })}
            ${ht(this.highlightRef)}
          >
            <wy-item part="wy-post-header" align="top" size="md" noPadding>
              <wy-avatar
                slot="image"
                .src="${this.createdBy.avatar_url}"
                .isAgent=${this.createdBy.is_agent}
                .size=${48}
                .name=${this.createdBy.name}
              ></wy-avatar>
              <span slot="title">${this.createdBy.name}</span>
              <span slot="text">
                <time datetime=${this.createdAt} title=${i}>${r}</time>
                ${this.modifiedAt ? v`<time datetime="${this.modifiedAt}" title=${n}> · ${P("edited")}</time>` : C}
              </span>
              <wy-dropdown slot="actions">
                ${this.isSubscribed ? v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                        <wy-icon name="bell-off"></wy-icon>
                        ${P("Unsubscribe")}
                      </wy-dropdown-item>` : v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                        <wy-icon name="bell"></wy-icon>
                        ${P("Subscribe")}
                      </wy-dropdown-item>`}
                ${this.user && this.user.id === this.createdBy.id ? v`<wy-dropdown-item @click=${() => this.dispatchEdit(!0)}>
                        <wy-icon name="pencil"></wy-icon>
                        ${P("Edit")}
                      </wy-dropdown-item>` : C}
                ${this.user && this.user.id === this.createdBy.id ? v`<wy-dropdown-item @click=${() => this.dispatchTrash()}>
                        <wy-icon name="trashcan"></wy-icon>
                        ${P("Trash")}
                      </wy-dropdown-item>` : C}
              </wy-dropdown>
            </wy-item>

            <!-- image grid -->
            ${a ? v`<wy-image-grid
                    part="wy-post-images"
                    outer
                    .images=${t}
                    @file-open=${(g) => {
      this.previewAttachmentsRef.value?.open(g.detail.fileId);
    }}
                  ></wy-image-grid>` : ""}

            ${y ? v`
                    <div part="wy-post-body">
                      <!-- text content -->
                      ${o ? v`<div part="wy-content wy-post-content">${gl(this.html)}</div>` : ""}

                      <!-- annotations -->
                      ${l ? v`<wy-annotation-list
                            .files=${this.annotations}
                            @file-open=${(g) => {
      this.previewAnnotationsRef.value?.open(g.detail.fileId);
    }}
                          ></wy-annotation-list>` : C}

                      <!-- poll -->
                      ${d && this.pollOptions ? v`
                            <wy-poll
                              .pollOptions=${this.pollOptions}
                              @vote=${(g) => this.dispatchVote(g.detail.optionId)}
                            ></wy-poll>
                          ` : C}

                      <!-- embeds -->
                      ${u && this.embed ? v` <wy-embed .embed=${this.embed}></wy-embed> ` : C}

                      <!-- files -->
                      ${p ? v`<wy-attachment-list
                            filled
                            part="wy-post-attachments"
                            .files=${e ?? []}
                            @file-open=${(g) => {
      this.previewAttachmentsRef.value?.open(g.detail.fileId);
    }}
                          ></wy-attachment-list>` : C}
                      <!-- meeting -->
                      ${f && this.meeting ? v`<wy-meeting-card .meeting=${this.meeting}></wy-meeting-card>` : C}
                    </div>
                  ` : C}
          <div part="wy-post-footer">

            <!-- comment count -->
            ${this.componentFeatures?.allowsFeature(L.Comments) ? v` <wy-button
                    small
                    kind="inline"
                    ?active=${this.showComments}
                    part="wy-meta"
                    color="inherit"
                    @click=${(g) => this.handleCommentsClick(g)}
                  >
                    ${this.commentCount !== 1 ? P(lt`${this.commentCount} comments`) : P("1 comment")}
                  </wy-button>` : C}

            <!-- reactions -->
            ${this.componentFeatures?.allowsFeature(L.Reactions) && this.app ? v`
                    <wy-reactions
                      line
                      small
                      .reactions=${this.reactions}
                      parentId=${this.app.id}
                      parentType="apps"
                      entityId=${this.postId}
                      entityType="posts"
                    ></wy-reactions>
                  ` : C}

          </div>

          <!-- comments -->
          <div part="wy-post-comments ${gt({ "wy-show": this.showComments })}">
            ${this.loadComments ? v`
                    <wy-comment-list
                      reveal
                      part="wy-post-comment-list"
                      .parentId=${this.postId}
                      .location=${"posts"}
                    ></wy-comment-list>
                  ` : C}
          </div>
        </div>

            ${this.annotations?.length ? v`<wy-preview
                    ${ht(this.previewAnnotationsRef)}
                    .files=${this.annotations}
                    .isAttachment=${!0}
                  ></wy-preview> ` : C}
            ${this.attachments?.length ? v`<wy-preview
                    ${ht(this.previewAttachmentsRef)}
                    .files=${[...t, ...e]}
                    .isAttachment=${!0}
                  ></wy-preview> ` : C}
          </div>
        `;
  }
  updated(t) {
    t.has("highlight") && this.highlight && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, h(Rm, "Go"), Rm), c(jx, "WyPostView"), jx);
ce.styles = [s2, pV, K4, YD, Fb, By, ft];
Me([
  b({ type: Number })
], ce.prototype, "postId", 2);
Me([
  b({ attribute: !1 })
], ce.prototype, "createdBy", 2);
Me([
  b()
], ce.prototype, "createdAt", 2);
Me([
  b()
], ce.prototype, "modifiedAt", 2);
Me([
  b({ type: Boolean })
], ce.prototype, "isSubscribed", 2);
Me([
  b({ type: Boolean })
], ce.prototype, "isTrashed", 2);
Me([
  b()
], ce.prototype, "html", 2);
Me([
  b()
], ce.prototype, "text", 2);
Me([
  b({ type: Array })
], ce.prototype, "annotations", 2);
Me([
  b({ type: Array })
], ce.prototype, "attachments", 2);
Me([
  b({ type: Array })
], ce.prototype, "pollOptions", 2);
Me([
  b({ attribute: !1 })
], ce.prototype, "meeting", 2);
Me([
  b({ attribute: !1 })
], ce.prototype, "embed", 2);
Me([
  b({ type: Array })
], ce.prototype, "reactions", 2);
Me([
  b({ attribute: !1 })
], ce.prototype, "commentCount", 2);
Me([
  b({ type: Array })
], ce.prototype, "seenBy", 2);
Me([
  b({ type: Boolean })
], ce.prototype, "highlight", 2);
Me([
  N()
], ce.prototype, "showComments", 2);
Me([
  N()
], ce.prototype, "loadComments", 2);
Me([
  N()
], ce.prototype, "isCommentLinked", 2);
ce = Me([
  Y("wy-post-view"),
  At()
], ce);
var OJ = Object.defineProperty, bJ = Object.getOwnPropertyDescriptor, _i = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? bJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && OJ(t, e, r), r;
}, "__decorateClass$o"), Ux, Em;
let ii = (Ux = (Em = class extends Pe {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.temp = !1, this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.text = "", this.attachments = [], this.pollOptions = [], this.reactions = [], this.seenBy = [], this.updatePostMutation = new Wr(this);
  }
  /**
   * Emit an `edit` event toggling edit mode for the post.
   *
   * @param edit - Desired edit state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchEdit(t) {
    const e = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Handle editor submit events and trigger the post update mutation.
   *
   * @param e - Editor submit detail containing updated content.
   */
  async handleSubmit(t) {
    const e = await this.whenApp();
    this.updatePostMutation.mutate({
      id: this.postId,
      app_id: e.id,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      attachments: t.detail.attachments,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId
    }), this.dispatchEdit(!1);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && await this.updatePostMutation.trackMutation(tW(this.weavy, ["posts", this.app.id]));
  }
  render() {
    const t = Hl(this.weavy?.locale, new Date(this.createdAt));
    return v`
      <div part="wy-post">
        <wy-item part="wy-post-header" align="top" size="md" noPadding>
          <wy-avatar
            slot="image"
            .src="${this.createdBy.avatar_url}"
            .isAgent=${this.createdBy.is_agent}
            .size=${48}
            .name=${this.createdBy.name}
          ></wy-avatar>
          <span slot="title" part="wy-placeholder">${this.createdBy.name}</span>
          <time slot="text" part="wy-placeholder">${t}</time>
          <wy-button slot="actions" kind="icon" @click=${() => this.dispatchEdit(!1)}>
            <wy-icon name="close"></wy-icon>
          </wy-button>
        </wy-item>

        <wy-editor
          editorLocation="apps"
          .text=${this.text}
          .embed=${this.embed}
          .options=${this.pollOptions}
          .attachments=${this.attachments ?? []}
          .parentId=${this.postId}
          .typing=${!1}
          .draft=${!1}
          placeholder=${P("Edit post...")}
          buttonText=${P("Update", { desc: "Button action to update" })}
          @submit=${(e) => this.handleSubmit(e)}
        ></wy-editor>
      </div>
    `;
  }
}, h(Em, "Zo"), Em), c(Ux, "WyPostEdit"), Ux);
ii.styles = [s2, By, ft];
_i([
  b({ type: Number })
], ii.prototype, "postId", 2);
_i([
  b({ type: Boolean })
], ii.prototype, "temp", 2);
_i([
  b({ attribute: !1 })
], ii.prototype, "createdBy", 2);
_i([
  b()
], ii.prototype, "createdAt", 2);
_i([
  b()
], ii.prototype, "modifiedAt", 2);
_i([
  b({ type: Boolean })
], ii.prototype, "isSubscribed", 2);
_i([
  b({ type: Boolean })
], ii.prototype, "isTrashed", 2);
_i([
  b()
], ii.prototype, "text", 2);
_i([
  b({ type: Array })
], ii.prototype, "attachments", 2);
_i([
  b({ type: Array })
], ii.prototype, "pollOptions", 2);
_i([
  b({ attribute: !1 })
], ii.prototype, "meeting", 2);
_i([
  b({ attribute: !1 })
], ii.prototype, "embed", 2);
_i([
  b({ type: Array })
], ii.prototype, "reactions", 2);
_i([
  b({ type: Array })
], ii.prototype, "seenBy", 2);
ii = _i([
  Y("wy-post-edit"),
  At()
], ii);
var $J = Object.defineProperty, xJ = Object.getOwnPropertyDescriptor, He = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? xJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && $J(t, e, r), r;
}, "__decorateClass$n"), Hx, _m;
let ve = (Hx = (_m = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.html = "", this.text = "", this.plain = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.commentCount = 0, this.seenBy = [], this.editing = !1;
  }
  /**
   * Emit a `vote` event scoped to the post.
   *
   * @internal
   * @param optionId - Identifier of the selected poll option.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", {
      detail: { optionId: t, parentId: this.postId, parentType: "posts" }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling post subscription.
   *
   * @internal
   * @param subscribe - Desired subscription state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", {
      detail: { id: this.postId, subscribe: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `trash` event requesting the post to be trashed.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `restore` event requesting the post to be restored.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  render() {
    return v`
      ${this.isTrashed ? v`<wy-post-trashed
            postId=${this.postId}
            .createdBy=${this.createdBy}
            @restore=${() => {
      this.dispatchRestore();
    }}
          ></wy-post-trashed> ` : C}
      ${!this.isTrashed && this.editing ? v`<wy-post-edit
            .postId=${this.postId}
            .createdBy=${this.createdBy}
            .createdAt=${this.createdAt}
            .text=${this.text}
            .embed=${this.embed}
            .pollOptions=${this.pollOptions}
            .attachments=${this.attachments}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}
          ></wy-post-edit> ` : C}
      ${!this.isTrashed && !this.editing ? v`<wy-post-view
            id="${this.id}"
            .postId=${this.postId}
            .createdBy=${this.createdBy}
            .createdAt=${this.createdAt}
            .modifiedAt=${this.modifiedAt}
            .isSubscribed=${this.isSubscribed}
            .isTrashed=${this.isTrashed}
            .html=${this.html}
            .text=${this.plain}
            .annotations=${this.annotations ?? []}
            .attachments=${this.attachments ?? []}
            .meeting=${this.meeting}
            .pollOptions=${this.pollOptions}
            .embed=${this.embed}
            .reactions=${this.reactions}
            .commentCount=${this.commentCount}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}
            @subscribe=${(t) => {
      this.dispatchSubscribe(t.detail.subscribe);
    }}
            @trash=${() => {
      this.dispatchTrash();
    }}
            @vote=${(t) => {
      this.dispatchVote(t.detail.optionId);
    }}
          ></wy-post-view> ` : C}
    `;
  }
}, h(_m, "Yo"), _m), c(Hx, "WyPost"), Hx);
ve.styles = [pe];
He([
  b({ type: Number })
], ve.prototype, "postId", 2);
He([
  b({ attribute: !1 })
], ve.prototype, "createdBy", 2);
He([
  b()
], ve.prototype, "createdAt", 2);
He([
  b()
], ve.prototype, "modifiedAt", 2);
He([
  b({ type: Boolean })
], ve.prototype, "isSubscribed", 2);
He([
  b({ type: Boolean })
], ve.prototype, "isTrashed", 2);
He([
  b()
], ve.prototype, "html", 2);
He([
  b()
], ve.prototype, "text", 2);
He([
  b()
], ve.prototype, "plain", 2);
He([
  b({ attribute: !1 })
], ve.prototype, "annotations", 2);
He([
  b({ attribute: !1 })
], ve.prototype, "attachments", 2);
He([
  b({ type: Array })
], ve.prototype, "pollOptions", 2);
He([
  b({ attribute: !1 })
], ve.prototype, "meeting", 2);
He([
  b({ attribute: !1 })
], ve.prototype, "embed", 2);
He([
  b({ type: Array })
], ve.prototype, "reactions", 2);
He([
  b({ attribute: !1 })
], ve.prototype, "commentCount", 2);
He([
  b({ type: Array })
], ve.prototype, "seenBy", 2);
He([
  N()
], ve.prototype, "editing", 2);
ve = He([
  Y("wy-post")
], ve);
var kJ = Object.defineProperty, SJ = Object.getOwnPropertyDescriptor, iW = /* @__PURE__ */ c((s) => {
  throw TypeError(s);
}, "__typeError$5"), rW = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? SJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && kJ(t, e, r), r;
}, "__decorateClass$m"), sW = /* @__PURE__ */ c((s, t, e) => t.has(s) || iW("Cannot " + e), "__accessCheck$5"), Z9 = /* @__PURE__ */ c((s, t, e) => (sW(s, t, "read from private field"), e ? e.call(s) : t.get(s)), "__privateGet$5"), CJ = /* @__PURE__ */ c((s, t, e) => t.has(s) ? iW("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(s) : t.set(s, e), "__privateAdd$5"), B9 = /* @__PURE__ */ c((s, t, e, i) => (sW(s, t, "write to private field"), t.set(s, e), e), "__privateSet$5"), nh, Yx, Lm;
let f1 = (Yx = (Lm = class extends Pe {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.postsQuery = new Wl(this), this.infiniteScroll = new Fl(this), this.pagerRef = $t(), this.addPostMutation = new Wr(this), this.handleRealtimePostCreated = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp(), r = await this.whenUser();
      t.post.app.id !== i.id || t.post.created_by?.id === r.id || (t.post.created_by = t.actor, ya(e.queryClient, ["posts", i.id], t.post, {
        descending: !0
      }));
    }, this.handleRealtimeCommentCreated = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp(), r = await this.whenUser();
      t.actor.id === r.id || !t.comment.parent || (ke(e.queryClient, ["posts", i.id], t.comment.parent.id, (n) => {
        n.comments ? n.comments.count += 1 : n.comments = { count: 1 };
      }), await e.queryClient.invalidateQueries({ queryKey: ["posts", t.comment.app.id, "comments"] }));
    }, this.handleRealtimeReactionAdded = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp();
      t.entity.type === vi.Post && ke(e.queryClient, ["posts", i.id], t.entity.id, (r) => {
        Py(r, t.reaction, t.actor);
      });
    }, this.handleRealtimeReactionDeleted = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp();
      t.entity.type === vi.Post && ke(e.queryClient, ["posts", i.id], t.entity.id, (r) => {
        Py(r, void 0, t.actor);
      });
    }, CJ(this, nh);
  }
  /**
   * Handle editor submissions by dispatching the create-post mutation.
   *
   * @param e - Submitted editor data.
   */
  async handleSubmit(t) {
    const e = await this.whenApp(), i = await this.whenUser();
    this.addPostMutation.mutate({
      app_id: e.id,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      user: i,
      context: t.detail.contextData
    });
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && this.app?.id !== t.get("app")?.id && await this.postsQuery.trackInfiniteQuery(JV(this.weavy, this.app.id)), (t.has("weavy") || t.has("app") || t.has("componentFeatures")) && this.weavy && this.app && this.app?.id !== t.get("app")?.id) {
      await this.addPostMutation.trackMutation(eW(this.weavy, ["posts", this.app.id])), this.subscribePostMutation = KV(this.weavy, this.app), this.removePostMutation = UV(this.weavy, this.app), this.restorePostMutation = YV(this.weavy, this.app), this.pollMutation = Vb(this.weavy, this.app.id, ["posts", this.app.id]), (e = Z9(this, nh)) == null || e.call(this);
      const i = `a${this.app.id}`;
      this.weavy.subscribe(i, "post_created", this.handleRealtimePostCreated), this.weavy.subscribe(i, "comment_created", this.handleRealtimeCommentCreated), this.componentFeatures?.allowsFeature(L.Reactions) && (this.weavy.subscribe(i, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(i, "reaction_removed", this.handleRealtimeReactionDeleted)), B9(this, nh, () => {
        this.weavy?.unsubscribe(i, "post_created", this.handleRealtimePostCreated), this.weavy?.unsubscribe(i, "comment_created", this.handleRealtimeCommentCreated), this.weavy?.unsubscribe(i, "reaction_added", this.handleRealtimeReactionAdded), this.weavy?.unsubscribe(i, "reaction_removed", this.handleRealtimeReactionDeleted), B9(this, nh, void 0);
      });
    }
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.postsQuery.result, this.pagerRef.value);
  }
  render() {
    const { data: t, isPending: e, hasNextPage: i } = this.postsQuery.result ?? {}, r = ys(t);
    return v`
      <div part="wy-posts">
        <div part="wy-posts-header">
          <wy-editor
            editorLocation="apps"
            ?disabled=${!Oy(ml.Create, this.app?.permissions)}
            .typing=${!1}
            .draft=${!0}
            placeholder=${this.placeholder ?? P("Create a post...")}
            buttonText=${P("Post")}
            @submit=${(n) => this.handleSubmit(n)}
          ></wy-editor>
        </div>

        <!-- this.user ?? -->
        ${e ? v`<wy-empty><wy-progress-circular indeterminate padded></wy-progress-circular></wy-empty> ` : v`
              ${r ? qi(
      r,
      (n) => n.id,
      (n) => v`<wy-post
                        id="post-${n.id}"
                        .postId=${n.id}
                        .createdBy=${n.created_by}
                        .createdAt=${n.created_at}
                        .modifiedAt=${n.updated_at}
                        .isSubscribed=${n.is_subscribed}
                        .isTrashed=${n.is_trashed}
                        .html=${n.html}
                        .text=${n.text}
                        .plain=${n.plain}
                        .annotations=${n.annotations?.data}
                        .attachments=${n.attachments?.data}
                        .meeting=${n.meeting}
                        .pollOptions=${n.options?.data}
                        .embed=${n.embed}
                        .reactions=${n.reactions?.data}
                        .commentCount=${n.comments?.count || 0}
                        @subscribe=${(a) => {
        this.subscribePostMutation?.mutate({
          id: a.detail.id,
          subscribe: a.detail.subscribe
        });
      }}
                        @trash=${(a) => {
        this.removePostMutation?.mutate({ id: a.detail.id });
      }}
                        @restore=${(a) => {
        this.restorePostMutation?.mutate({ id: a.detail.id });
      }}
                        @vote=${(a) => {
        a.detail.parentType && a.detail.parentId && this.pollMutation?.mutate({
          optionId: a.detail.optionId,
          parentType: a.detail.parentType,
          parentId: a.detail.parentId
        });
      }}
                      ></wy-post>`
    ) : v`<wy-empty></wy-empty>`}
              ${i ? v`<div ${ht(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
            `}
      </div>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = Z9(this, nh)) == null || t.call(this), super.disconnectedCallback();
  }
}, h(Lm, "Xo"), Lm), c(Yx, "WyPostList"), Yx);
nh = /* @__PURE__ */ new WeakMap();
f1.styles = [s2, t3, Ma, ft];
rW([
  b()
], f1.prototype, "placeholder", 2);
f1 = rW([
  Y("wy-post-list"),
  At()
], f1);
var PJ = Object.defineProperty, QJ = Object.getOwnPropertyDescriptor, nW = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? QJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && PJ(t, e, r), r;
}, "__decorateClass$l"), Gx, zm;
let Ay = (Gx = (zm = class extends Ni {
  constructor() {
    super(...arguments), this.appType = xt.Posts, this.componentFeatures = new di({
      // All available features as enabled/disabled by default
      [L.Attachments]: !0,
      [L.CloudFiles]: !0,
      [L.Comments]: !0,
      [L.ContextData]: !0,
      [L.Embeds]: !0,
      [L.GoogleMeet]: !1,
      [L.Meetings]: !1,
      [L.Mentions]: !0,
      [L.MicrosoftTeams]: !1,
      [L.Polls]: !0,
      [L.Previews]: !0,
      [L.Reactions]: !0,
      [L.Typing]: !1,
      // Has no effect currently
      [L.ZoomMeetings]: !1
    }), this.theme = new Ri(this, Ay.styles);
  }
  render() {
    return v`
      <wy-buttons position="floating" reverse><slot name="actions"></slot></wy-buttons>
      <wy-post-list .placeholder=${this.placeholder}></wy-post-list>
      <wy-context-data-progress></wy-context-data-progress>
    `;
  }
}, h(zm, "Jo"), zm), c(Gx, "WyPosts"), Gx);
Ay.styles = [Ie, vn, ql, Zl, Ei];
nW([
  b()
], Ay.prototype, "placeholder", 2);
Ay = nW([
  Y("wy-posts"),
  At()
], Ay);
const TJ = it`[part~=wy-notification] strong{font-weight:var(--wy-font-weight-bold, 600)}[part~=wy-notification] p{display:inline}[part~=wy-notification-text]{color:var(--wy-component-color)}[part~=wy-notification-text]{display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;overflow:hidden}[part~=wy-notification-text]{white-space:normal}`;
var MJ = Object.defineProperty, AJ = Object.getOwnPropertyDescriptor, X1 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? AJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && MJ(t, e, r), r;
}, "__decorateClass$k"), Kx, Im;
let Ca = (Kx = (Im = class extends Xi {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.selected = !1, this.standalone = !1;
  }
  /**
   * Emit a `select` event for the current notification.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSelect(t) {
    const e = new CustomEvent("select", {
      detail: { notificationId: this.notificationId }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `mark` event toggling read status.
   *
   * @internal
   * @param e - Source event triggering the action.
   * @param markAsRead - Target read state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchMark(t, e) {
    if (t.stopPropagation(), e === !!this.notification.is_unread) {
      const i = new CustomEvent("mark", {
        detail: { notificationId: this.notificationId, markAsRead: e }
      });
      return this.dispatchEvent(i);
    }
    return !0;
  }
  /**
   * Emit a `hide` event when the toast should disappear.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchHide() {
    if (this.standalone) {
      const t = new CustomEvent("hide", {
        bubbles: !0
      });
      return this.dispatchEvent(t);
    }
    return !0;
  }
  /**
   * Emit a `close` event when the toast should close.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchClose() {
    if (this.standalone) {
      const t = new CustomEvent("close", {
        bubbles: !0
      });
      return this.dispatchEvent(t);
    }
    return !0;
  }
  /**
   * Handle click interactions and trigger navigation plus dismissal.
   *
   * @internal
   */
  async handleClick(t) {
    this.dispatchSelect(t), this.dispatchMark(t, !0), this.dispatchHide(), await Y4(this, this.weavy, this.notification), this.dispatchClose();
  }
  render() {
    const t = this.notification.created_at ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.notification.created_at)
    ) : "", e = this.notification.created_at ? Hl(this.weavy?.locale, new Date(this.notification.created_at)) : "", i = this.notification.actor, { title: r, titleHtml: n, detail: a } = G4(this.notification);
    return v`
      <wy-item
        part="wy-notification"
        size="md"
        interactive
        outer
        status=${!this.standalone && !this.notification.is_unread ? "read" : void 0}
        ?selected=${!this.standalone && this.selected}
        align="top"
        actionsPosition=${this.standalone ? "end" : "bottom"}
        tabindex="0"
        @click=${(o) => this.handleClick(o)}
        @keydown=${Ze}
        @keyup=${bi}
      >
        <wy-avatar
          slot="image"
          src=${St(i?.avatar_url)}
          name=${St(i?.name)}
          description=${St(i?.comment)}
          presence=${i?.presence || "away"}
          ?isAgent=${i?.is_agent}
          id=${St(i?.id)}
          size=${48}
        ></wy-avatar>

        <div slot="title" part="wy-notification-text" title=${r + (a ? `: "${a}"` : "")}>
          ${n}${a ? v`: <q part="wy-quote">${a}</q> ` : C}
      </div>

        ${this.standalone ? C : v`
              <time slot="text" part="wy-meta" datetime=${this.notification.created_at.toString()} title=${t}>
                ${e}
              </time>
            `}
        ${this.standalone ? v`
              <wy-button
                slot="actions"
                kind="icon"
                @click=${(o) => this.dispatchMark(o, !!this.notification.is_unread) && this.dispatchClose()}
              >
                <wy-icon name="close"></wy-icon>
              </wy-button>
            ` : v`
              <wy-button
                small
                slot="actions"
                kind="icon"
                @click=${(o) => this.dispatchMark(o, !!this.notification.is_unread) && this.dispatchClose()}
                title=${this.notification.is_unread ? P("Mark as read") : P("Mark as unread")}
              >
                <wy-icon
                  name=${this.notification.is_unread ? "read" : "unread"}
                  color=${this.notification.is_unread ? "" : "secondary"}
                ></wy-icon>
              </wy-button>
            `}
      </wy-item>
    `;
  }
}, h(Im, "tc"), Im), c(Kx, "WyNotificationListItem"), Kx);
Ca.styles = [pe, By, TJ, ft];
X1([
  b({ type: Number })
], Ca.prototype, "notificationId", 2);
X1([
  b({ type: Boolean, reflect: !0 })
], Ca.prototype, "selected", 2);
X1([
  b({ type: Boolean })
], Ca.prototype, "standalone", 2);
X1([
  b({ attribute: !1 })
], Ca.prototype, "notification", 2);
Ca = X1([
  Y("wy-notification-list-item"),
  At()
], Ca);
var RJ = Object.defineProperty, EJ = Object.getOwnPropertyDescriptor, aW = /* @__PURE__ */ c((s) => {
  throw TypeError(s);
}, "__typeError$4"), Kl = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? EJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && RJ(t, e, r), r;
}, "__decorateClass$j"), oW = /* @__PURE__ */ c((s, t, e) => t.has(s) || aW("Cannot " + e), "__accessCheck$4"), N9 = /* @__PURE__ */ c((s, t, e) => (oW(s, t, "read from private field"), e ? e.call(s) : t.get(s)), "__privateGet$4"), _J = /* @__PURE__ */ c((s, t, e) => t.has(s) ? aW("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(s) : t.set(s, e), "__privateAdd$4"), X9 = /* @__PURE__ */ c((s, t, e, i) => (oW(s, t, "write to private field"), t.set(s, e), e), "__privateSet$4"), ah, Jx, Dm;
let Ry = (Jx = (Dm = class extends Pe {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.typeFilter = jt.All, this.notificationsQuery = new Wl(this), this.infiniteScroll = new Fl(this), this.pagerRef = $t(), this.handleRefresh = (t) => {
      this.notificationsQuery.result.refetch();
    }, this.handlePresenceChange = (t) => {
      this.weavy && (Array.isArray(t) || (t = [parseInt(t)]), ke(this.weavy.queryClient, ["notifications", "list"], void 0, (e) => {
        const i = e.actor;
        i.presence = t.indexOf(i.id) != -1 ? "active" : "away", e.actor = i;
      }));
    }, _J(this, ah);
  }
  /**
   * Mark or unmark a notification as read.
   *
   * @param notificationId - Target notification id.
   * @param markAsRead - Desired read state.
   */
  async markAsRead(t, e = !0) {
    await this.markNotificationMutation?.mutate({ notificationId: t, markAsRead: e });
  }
  /**
   * Select the provided notification and emit a `wy-action` event.
   *
   * @internal
   * @param notification - Notification to select.
   */
  selectNotification(t) {
    this.notificationId = t.id, this.dispatchAction(Oi.Select, t);
  }
  /**
   * Triggers `wy-action` event.
   *
   * @internal
   * @param action - The performed action.
   * @param notification - Selected notification payload.
   * @returns Whether the event was successful.
   */
  dispatchAction(t, e) {
    const i = new CustomEvent("wy-action", {
      detail: { action: t, notification: e },
      bubbles: !0,
      composed: !0
    });
    return this.dispatchEvent(i);
  }
  async willUpdate(t) {
    var e;
    super.willUpdate(t), (t.has("weavy") || t.has("typeFilter") || t.has("app")) && this.weavy && await this.notificationsQuery.trackInfiniteQuery(
      PI(this.weavy, this.typeFilter, this.app?.id)
    ), t.has("weavy") && this.weavy && (this.markNotificationMutation = g4(this.weavy), (e = N9(this, ah)) == null || e.call(this), this.weavy.subscribe(null, "online", this.handlePresenceChange), this.weavy.subscribe(null, "notification_created", this.handleRefresh), this.weavy.subscribe(null, "notification_updated", this.handleRefresh), this.weavy.subscribe(null, "notifications_marked", this.handleRefresh), X9(this, ah, () => {
      this.weavy?.unsubscribe(null, "online", this.handlePresenceChange), this.weavy?.unsubscribe(null, "notification_created", this.handleRefresh), this.weavy?.unsubscribe(null, "notification_updated", this.handleRefresh), this.weavy?.unsubscribe(null, "notifications_marked", this.handleRefresh), X9(this, ah, void 0);
    }));
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.notificationsQuery.result, this.pagerRef.value);
  }
  /**
   * Render the notifications collection.
   *
   * @internal
   * @param user - Current user.
   * @param infiniteData - Notification pages.
   */
  renderNotifications(t, e) {
    if (e) {
      const i = ys(e);
      return qi(
        i,
        (r) => r?.id,
        (r) => [
          v`<wy-notification-list-item
              notificationId=${r.id}
              .notification=${r}
              .selected=${this.notificationId == r.id}
              @select=${(n) => this.selectNotification(r)}
              @mark=${(n) => this.markAsRead(n.detail.notificationId, n.detail.markAsRead)}
            ></wy-notification-list-item>`
        ]
      );
    }
    return C;
  }
  render() {
    const { data: t, hasNextPage: e, isPending: i } = this.notificationsQuery.result ?? {};
    return v`
      ${this.user ? v`
            <div class="wy-notifications">
              ${!i && this.user && t ? t.pages[0]?.count ? this.renderNotifications(this.user, t) : v`
                      <div part="wy-pane-body">
                        <div part="wy-pane-group">
                          <slot name="empty">
                            <wy-empty>${P("No updates yet.")}</wy-empty>
                          </slot>
                        </div>
                      </div>
                    ` : v`<wy-empty><wy-progress-circular indeterminate padded></wy-progress-circular></wy-empty>`}
              ${e ? v`<div ${ht(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
            </div>
          ` : v`<wy-empty part="wy-pane"><wy-progress-circular indeterminate overlay></wy-progress-circular></wy-empty>`}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = N9(this, ah)) == null || t.call(this), super.disconnectedCallback();
  }
}, h(Dm, "ec"), Dm), c(Jx, "WyNotificationList"), Jx);
ah = /* @__PURE__ */ new WeakMap();
Ry.styles = [
  Nl,
  Ma,
  it`
      :host {
        position: relative;
      }
    `
];
Kl([
  b({ type: Number })
], Ry.prototype, "notificationId", 2);
Kl([
  b()
], Ry.prototype, "typeFilter", 2);
Ry = Kl([
  Y("wy-notification-list"),
  At()
], Ry);
var tk, Vm;
let Al = (tk = (Vm = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.typeFilter = jt.All, this.activeFilter = jt.All;
  }
  /**
   * Trigger `filter` event.
   *
   * @param typeFilter - Filter to emit.
   * @returns Whether the event was dispatched successfully.
   */
  dispatchFilter(t) {
    const e = new CustomEvent("filter", {
      detail: { typeFilter: t }
    });
    return this.dispatchEvent(e);
  }
  render() {
    const t = !!this._slotDefault.length;
    return v`
      <div part="wy-pane-toolbar">
        <slot @slotchange=${() => this.requestUpdate()}></slot>
        ${t ? C : v`
              <wy-buttons tabs>
                <wy-button
                  ?active=${this.typeFilter === jt.All}
                  @click=${() => {
      this.dispatchFilter(jt.All) && (this.typeFilter = jt.All);
    }}
                  kind="tab"
                  small
                >
                  ${P("All")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === jt.Activity}
                  @click=${() => {
      this.dispatchFilter(jt.Activity) && (this.typeFilter = jt.Activity);
    }}
                  kind="tab"
                  small
                >
                  ${P("Activities")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === jt.Mention}
                  @click=${() => {
      this.dispatchFilter(jt.Mention) && (this.typeFilter = jt.Mention);
    }}
                  kind="tab"
                  small
                >
                  ${P("Mentions")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === jt.Reaction}
                  @click=${() => {
      this.dispatchFilter(jt.Reaction) && (this.typeFilter = jt.Reaction);
    }}
                  kind="tab"
                  small
                >
                  ${P("Reactions")}
                </wy-button>
              </wy-buttons>
            `}

        <slot name="actions" @slotchange=${() => this.requestUpdate()}></slot>
      </div>
    `;
  }
}, h(Vm, "ic"), Vm), c(tk, "WyNotificationHeader"), tk);
Al.styles = [
  Nl,
  Ma,
  it`
      :host {
        position: relative;
      }
    `
];
Kl([
  b()
], Al.prototype, "typeFilter", 2);
Kl([
  N()
], Al.prototype, "activeFilter", 2);
Kl([
  Dl({ flatten: !0, selector: ":not(slot)" })
], Al.prototype, "_slotDefault", 2);
Al = Kl([
  Y("wy-notification-header"),
  At()
], Al);
var LJ = Object.defineProperty, zJ = Object.getOwnPropertyDescriptor, c3 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? zJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && LJ(t, e, r), r;
}, "__decorateClass$i"), ek, Wm;
let Rl = (ek = (Wm = class extends qy {
  constructor() {
    super(...arguments), this.unreadNotifications = new w4(this), this.theme = new Ri(this, Rl.styles), this.currentTypeFilter = jt.All, this.typeFilter = jt.All;
  }
  /** Current unread notification count. */
  get unread() {
    return this.unreadNotifications.unread;
  }
  /** Marks all tracked notifications as read. */
  async markAllAsRead() {
    await this.unreadNotifications.markAllAsRead();
  }
  async willUpdate(t) {
    await super.willUpdate(t), t.has("typeFilter") && (this.currentTypeFilter = this.typeFilter), (t.has("typeFilter") || t.has("app")) && await this.unreadNotifications.track(this.typeFilter, this.app?.id);
  }
  render() {
    const t = this.typeFilter === jt.All;
    return v`
      ${t ? v`
            <wy-notification-header
              @filter=${(e) => {
      this.currentTypeFilter = e.detail.typeFilter;
    }}
            >
              <slot name="actions" slot="actions">
                <wy-button kind="icon" @click=${() => this.markAllAsRead()} title=${P("Mark all as read")}>
                  <wy-icon name="check-all"></wy-icon>
                </wy-button>
              </slot>
            </wy-notification-header>
          ` : C}
      ${this.user ? v` <wy-notification-list typeFilter=${this.currentTypeFilter}></wy-notification-list> ` : v`
            <wy-empty>
              <wy-progress-circular indeterminate padded reveal></wy-progress-circular>
            </wy-empty>
          `}
    `;
  }
}, h(Wm, "rc"), Wm), c(ek, "WyNotifications"), ek);
Rl.styles = [Ie, vn, ql, Zl, Ei];
c3([
  N()
], Rl.prototype, "currentTypeFilter", 2);
c3([
  b()
], Rl.prototype, "typeFilter", 2);
Rl = c3([
  Y("wy-notifications"),
  At()
], Rl);
const lW = it`:host{display:inline-flex}`;
var IJ = Object.defineProperty, DJ = Object.getOwnPropertyDescriptor, n2 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? DJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && IJ(t, e, r), r;
}, "__decorateClass$h"), ik, Fm;
let Pa = (ik = (Fm = class extends qy {
  constructor() {
    super(...arguments), this.theme = new Ri(this, Pa.styles), this.unreadNotifications = new w4(this), this.badge = "count", this.badgePosition = "inline", this.typeFilter = jt.All;
  }
  /** Current unread notification count. */
  get unread() {
    return this.unreadNotifications.unread;
  }
  /** Marks all tracked notifications as read. */
  async markAllAsRead() {
    await this.unreadNotifications.markAllAsRead();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("typeFilter") || t.has("app")) && await this.unreadNotifications.track(this.typeFilter, this.app?.id);
  }
  render() {
    return this.user && this.badge !== "none" ? v`
          <wy-badge
            appearance=${this.badge}
            position=${this.badgePosition}
            .count=${this.unreadNotifications.isUnreadPending ? NaN : this.unreadNotifications.unread}
          ></wy-badge>
        ` : C;
  }
}, h(Fm, "nc"), Fm), c(ik, "WyNotificationBadge"), ik);
Pa.styles = [lW, Ie, Ei];
n2([
  b({ type: String })
], Pa.prototype, "badge", 2);
n2([
  b({ type: String })
], Pa.prototype, "badgePosition", 2);
n2([
  b()
], Pa.prototype, "typeFilter", 2);
Pa = n2([
  Y("wy-notification-badge")
], Pa);
var VJ = Object.defineProperty, WJ = Object.getOwnPropertyDescriptor, _a = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? WJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && VJ(t, e, r), r;
}, "__decorateClass$g"), rk, qm;
let Pr = (rk = (qm = class extends qy {
  constructor() {
    super(...arguments), this.theme = new Ri(this, Pr.styles), this.unreadNotifications = new w4(this), this.overlay = "sheet", this.badge = "compact", this.badgePosition = "top-right", this.typeFilter = jt.All, this.currentTypeFilter = jt.All, this.showNotificationList = !1;
  }
  set list(t) {
    console.warn(`.list is deprecated. Use .overlay = "${t}"; instead`), this.overlay = t;
  }
  get list() {
    return this.overlay;
  }
  /** Current unread notification count. */
  get unread() {
    return this.unreadNotifications.unread;
  }
  /** Marks all tracked notifications as read. */
  async markAllAsRead() {
    await this.unreadNotifications.markAllAsRead();
  }
  async willUpdate(t) {
    await super.willUpdate(t), t.has("typeFilter") && (this.currentTypeFilter = this.typeFilter), (t.has("typeFilter") || t.has("app")) && await this.unreadNotifications.track(this.typeFilter, this.app?.id);
  }
  render() {
    const t = this.typeFilter === jt.All;
    return v`
      <wy-button
        kind="icon"
        ?active=${this.showNotificationList}
        @click=${() => this.showNotificationList = !this.showNotificationList}
      >
        <wy-icon name="bell">
          ${this.user && this.badge !== "none" ? v`
                <wy-badge
                  appearance=${this.badge}
                  position=${this.badgePosition}
                  .count=${this.unreadNotifications.isUnreadPending ? NaN : this.unreadNotifications.unread}
                ></wy-badge>
              ` : C}
        </wy-icon>
      </wy-button>

      ${this.overlay !== "none" ? v`<wy-overlay
            type=${this.overlay}
            .show=${this.showNotificationList}
            @close=${() => this.showNotificationList = !1}
          >
            <slot name="actions" slot="actions">
              <wy-button kind="icon" @click=${() => this.markAllAsRead()} title=${P("Mark all as read")}>
                <wy-icon name="check-all"></wy-icon>
              </wy-button>
              ${this.app ? v`
                    <wy-dropdown>
                      ${this.app?.is_subscribed ? v`
                            <wy-dropdown-item @click=${() => this.subscribe(!1)}>
                              <wy-icon name="bell-off"></wy-icon>
                              ${P("Unsubscribe")}
                            </wy-dropdown-item>
                          ` : v`
                            <wy-dropdown-item @click=${() => this.subscribe(!0)}>
                              <wy-icon name="bell"></wy-icon>
                              ${P("Subscribe")}
                            </wy-dropdown-item>
                          `}
                    </wy-dropdown>
                  ` : C}
            </slot>
            <slot slot="title">${P("Notifications")}</slot>
            <wy-container scrollY>
              ${this.showNotificationList ? v`
                    ${t ? v`
                          <wy-notification-header
                            @filter=${(e) => {
      this.currentTypeFilter = e.detail.typeFilter;
    }}
                          ></wy-notification-header>
                        ` : C}
                    <wy-notification-list typeFilter=${this.currentTypeFilter}>
                      ${this.app && !this.app?.is_subscribed ? v`
                            <wy-empty slot="empty">
                              <div>${P("You are not subscribed to updates yet.")}</div>
                              <wy-button color="primary" @click=${() => this.subscribe(!0)}
                                >${P("Subscribe")}</wy-button
                              >
                            </wy-empty>
                          ` : C}
                    </wy-notification-list>
                  ` : C}
            </wy-container>
          </wy-overlay>` : C}
    `;
  }
}, h(qm, "ac"), qm), c(rk, "WyNotificationButton"), rk);
Pr.styles = [ft, Ie, Ei];
_a([
  b({ type: String })
], Pr.prototype, "overlay", 2);
_a([
  b({ type: String })
], Pr.prototype, "list", 1);
_a([
  b({ type: String })
], Pr.prototype, "badge", 2);
_a([
  b({ type: String })
], Pr.prototype, "badgePosition", 2);
_a([
  b()
], Pr.prototype, "typeFilter", 2);
_a([
  N()
], Pr.prototype, "currentTypeFilter", 2);
_a([
  N()
], Pr.prototype, "showNotificationList", 2);
Pr = _a([
  Y("wy-notification-button"),
  At()
], Pr);
var FJ = Object.defineProperty, qJ = Object.getOwnPropertyDescriptor, j1 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? qJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && FJ(t, e, r), r;
}, "__decorateClass$f"), sk, Zm;
let m1 = (sk = (Zm = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.show = !1, this.viewportRef = $t();
  }
  /**
   * Close the popover layer.
   */
  close() {
    this.show = !1;
    try {
      this.viewportRef.value?.hidePopover();
    } catch {
    }
  }
  /**
   * Handler when popover is toggled.
   * @internal
   */
  handleClose(t) {
    if (t.type === "toggle" && t.newState === "closed" || t.type === "click") {
      this.show = !1;
      const e = new CustomEvent("hide");
      this.dispatchEvent(e);
    }
  }
  render() {
    return v`
      <div part="wy-toasts" tabindex="0" ${ht(this.viewportRef)} ?hidden=${!this.show} popover="auto">
        <slot></slot>
      </div>
    `;
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("show"))
      try {
        this.show ? this.viewportRef.value?.showPopover() : this.viewportRef.value?.hidePopover();
      } catch {
      }
    t.has("show") && this.show && this.viewportRef.value?.focus();
  }
  firstUpdated(t) {
    this.viewportRef.value?.addEventListener(this.viewportRef.value.popover ? "toggle" : "click", (e) => {
      this.handleClose(e);
    }), this.show && this.viewportRef.value?.showPopover();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
  }
}, h(Zm, "sc"), Zm), c(sk, "WyToasts"), sk);
m1.styles = [
  P4,
  ft
];
j1([
  b({ type: Boolean })
], m1.prototype, "show", 2);
m1 = j1([
  Y("wy-toasts")
], m1);
var nk, Bm;
let pn = (nk = (Bm = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.toastRef = $t(), this.show = !1, this.duration = pn.defaultDuration;
  }
  /**
   * Hide the toast.
   */
  hide() {
    this.show = !1;
  }
  /**
   * Hide and close the toast.
   * 
   * @param silent - Indicates that the toast should close silently.
   * @fires {ClosedEventType} closed - When the toast has been hidden and closed.
   */
  async close(t = !1) {
    this.show = !1, await new Promise((i) => requestAnimationFrame(i)), this.toastRef.value && await yO(this.toastRef.value, !1);
    const e = new CustomEvent("closed", { detail: { silent: t } });
    this.dispatchEvent(e);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("show") && (this.timeout && (window.clearTimeout(this.timeout), this.timeout = void 0), this.show && this.duration > 0 && this.duration < 1 / 0 && (this.timeout = window.setTimeout(() => this.close(!0), this.duration)));
  }
  render() {
    return v`
      <div
        ${ht(this.toastRef)}
        part="wy-toast wy-fade ${this.show ? "wy-show" : ""}"
        @hide=${(t) => {
      t.stopPropagation(), this.hide();
    }}
        @close=${() => this.close()}
        @keyup=${Wb}
      >
        <slot></slot>
      </div>
    `;
  }
  firstUpdated() {
    requestAnimationFrame(() => {
      this.show = !0;
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.timeout && (window.clearTimeout(this.timeout), this.timeout = void 0);
  }
}, h(Bm, "oc"), Bm), c(nk, "WyToast"), nk);
pn.styles = [
  P4,
  ft
];
pn.defaultDuration = 5e3;
j1([
  N()
], pn.prototype, "show", 2);
j1([
  b({ type: Number })
], pn.prototype, "duration", 2);
pn = j1([
  Y("wy-toast")
], pn);
var ZJ = Object.defineProperty, BJ = Object.getOwnPropertyDescriptor, cW = /* @__PURE__ */ c((s) => {
  throw TypeError(s);
}, "__typeError$3"), Ky = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? BJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && ZJ(t, e, r), r;
}, "__decorateClass$e"), hW = /* @__PURE__ */ c((s, t, e) => t.has(s) || cW("Cannot " + e), "__accessCheck$3"), j9 = /* @__PURE__ */ c((s, t, e) => (hW(s, t, "read from private field"), e ? e.call(s) : t.get(s)), "__privateGet$3"), NJ = /* @__PURE__ */ c((s, t, e) => t.has(s) ? cW("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(s) : t.set(s, e), "__privateAdd$3"), U9 = /* @__PURE__ */ c((s, t, e, i) => (hW(s, t, "write to private field"), t.set(s, e), e), "__privateSet$3"), oh, ak, Nm;
let bs = (ak = (Nm = class extends qy {
  constructor() {
    super(...arguments), this.theme = new Ri(this, bs.styles), this.typeFilter = jt.All, this.appearance = "internal", this.requestUserPermission = !1, this.duration = pn.defaultDuration, this._notifications = [], this._nativeNotifications = [], this.handleEvent = async (t) => {
      if (this.typeFilter === jt.All || this.typeFilter === t.notification.type)
        if (t.action === "notification_deleted")
          this.removeNotification(t.notification.id), this.closeNativeNotification(t.notification.id);
        else {
          const { title: e, detail: i } = G4(t.notification), r = {
            ...t.notification,
            title: e,
            detail: i,
            lang: this.weavy?.locale
          }, n = new CustomEvent("wy-notification", {
            bubbles: !0,
            composed: !0,
            cancelable: !0,
            detail: r
          });
          (!this.requestUserPermission && this.appearance !== "native" || await this.hasUserPermission()) && this.dispatchEvent(n) && (t.action === "notification_created" && t.notification.is_unread ? await this.addOrUpdateNotification(t.notification) : await this.updateNotification(t.notification), await this.addOrUpdateNativeNotification(r));
        }
    }, NJ(this, oh);
  }
  /** @internal */
  async addOrUpdateNotification(t) {
    if (!this.requestUserPermission || await this.hasUserPermission()) {
      const e = [...this._notifications], i = e.findIndex((r) => r.id === t.id);
      i !== -1 ? (e.splice(i, 1, t), this._notifications = e) : (e.push(t), this._notifications = e);
    }
  }
  /** @internal */
  async updateNotification(t) {
    if (!this.requestUserPermission || await this.hasUserPermission()) {
      const e = [...this._notifications], i = e.findIndex((r) => r.id === t.id);
      i !== -1 && (e.splice(i, 1, t), this._notifications = e);
    }
  }
  /** @internal */
  removeNotification(t) {
    const e = [...this._notifications], i = e.findIndex((r) => r.id === t);
    i !== -1 && (e.splice(i, 1), this._notifications = e);
  }
  /** @internal */
  async addOrUpdateNativeNotification(t) {
    if (this.appearance === "native" && await this.hasUserPermission()) {
      const e = this.removeNativeNotification(t.id), i = t.actor, r = new Notification(t.title, {
        tag: `wy-${t.id}`,
        lang: t.lang,
        body: t.detail,
        icon: i.avatar_url,
        // @ts-expect-error Property `renotify` not available in ts types yet
        renotify: e && t.is_unread
      });
      r.onclick = async () => {
        await this.markAsRead(t.id, !0), await Y4(this, this.weavy, t);
      }, r.onclose = () => {
        this.removeNativeNotification(t.id);
      }, this._nativeNotifications = [...this._nativeNotifications, r];
    }
  }
  /** @internal */
  removeNativeNotification(t) {
    const e = [...this._nativeNotifications], i = e.findIndex(
      (r) => r.tag === `wy-${t}`
    );
    return i ? (e.splice(i, 1), this._nativeNotifications = e, !0) : !1;
  }
  /** @internal */
  closeNativeNotification(t) {
    const e = this._nativeNotifications.findIndex(
      (i) => i.tag === `wy-${t}`
    );
    return e ? (this._nativeNotifications[e].close(), !0) : !1;
  }
  /** Checks if the user has granted permission for desktop notifications. A request will be made if permission has not yet been granted. */
  async hasUserPermission() {
    if (!("Notification" in window))
      console.error("This browser does not support desktop notifications");
    else if (!window.isSecureContext)
      console.error(
        `Desktop notifications can only be used in secure contexts. 
        See https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts`
      );
    else {
      if (Notification.permission === "granted")
        return !0;
      if (Notification.permission !== "denied")
        return await Notification.requestPermission() === "granted";
    }
    return !1;
  }
  /** Clears queued internal toast notifications. */
  clearNotifications() {
    this._notifications = [];
  }
  /**
   * Marks a notification as read or unread.
   * @param notificationId - The ID of the notification to mark.
   * @param [markAsRead=true] - Whether to mark the notification as read (true) or unread (false).
   */
  async markAsRead(t, e = !0) {
    await this.markNotificationMutation?.mutate({ notificationId: t, markAsRead: e });
  }
  async willUpdate(t) {
    var e;
    await super.willUpdate(t), t.has("weavy") && this.weavy && (this.markNotificationMutation = g4(this.weavy), (e = j9(this, oh)) == null || e.call(this), this.weavy.subscribe(null, "notification_created", this.handleEvent), this.weavy.subscribe(null, "notification_updated", this.handleEvent), U9(this, oh, () => {
      this.weavy?.unsubscribe(null, "notification_created", this.handleEvent), this.weavy?.unsubscribe(null, "notification_updated", this.handleEvent), U9(this, oh, void 0);
    })), (t.has("requestUserPermission") && this.requestUserPermission || t.has("appearance") && this.appearance === "native") && this.hasUserPermission();
  }
  render() {
    return v`
      ${this.user && this.appearance === "internal" ? v`
            <wy-toasts ?show=${!!this._notifications.length} @hide=${() => this.clearNotifications()}>
              ${qi(
      this._notifications,
      (t) => t.id,
      (t) => v`
                    <wy-toast
                      duration=${this.duration}
                      @closed=${(e) => {
        e.detail.silent || this.markAsRead(t.id, !0), this.removeNotification(t.id);
      }}
                    >
                      <wy-notification-list-item standalone .notification=${t}></wy-notification-list-item>
                    </wy-toast>
                  `
    )}
            </wy-toasts>
          ` : C}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = j9(this, oh)) == null || t.call(this), super.disconnectedCallback();
  }
}, h(Nm, "cc"), Nm), c(ak, "WyNotificationToasts"), ak);
oh = /* @__PURE__ */ new WeakMap();
bs.styles = [Ie, ft, Ei];
Ky([
  b()
], bs.prototype, "typeFilter", 2);
Ky([
  b()
], bs.prototype, "appearance", 2);
Ky([
  b({ type: Boolean })
], bs.prototype, "requestUserPermission", 2);
Ky([
  b({ type: Number })
], bs.prototype, "duration", 2);
Ky([
  N()
], bs.prototype, "_notifications", 2);
bs = Ky([
  Y("wy-notification-toasts"),
  At()
], bs);
const lit = new Map(
  Object.entries({
    [Lr.ChatRoom]: xt.ChatRoom,
    [Lr.PrivateChat]: xt.PrivateChat,
    [xt.ChatRoom]: Lr.ChatRoom,
    [xt.PrivateChat]: Lr.PrivateChat
  })
);
new Map(
  Object.entries({
    [Lr.AgentChat]: xt.AgentChat,
    [xt.AgentChat]: Lr.AgentChat
  })
);
const Ey = {
  // All available features as enabled/disabled by default
  [L.Attachments]: !0,
  [L.CloudFiles]: !0,
  [L.ContextData]: !0,
  [L.Embeds]: !0,
  [L.GoogleMeet]: !0,
  [L.Meetings]: !0,
  [L.Mentions]: !0,
  [L.MicrosoftTeams]: !0,
  [L.Polls]: !0,
  [L.Previews]: !0,
  [L.Reactions]: !0,
  [L.Receipts]: !0,
  [L.Typing]: !0,
  [L.ZoomMeetings]: !0
}, h3 = {
  // All available features as enabled/disabled by default
  [L.Attachments]: !0,
  [L.ContextData]: !0,
  [L.Embeds]: !0,
  [L.Previews]: !0,
  [L.Reactions]: !1,
  [L.Receipts]: !0,
  [L.Typing]: !0
}, d3 = it`[part~=wy-messenger-layout]{display:flex;flex:1;align-items:stretch;position:relative;container-type:inline-size;align-self:stretch;min-height:0;min-width:0;box-sizing:border-box}[part~=wy-messenger-overlay-container]{--wy-padding-outer: var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));--wy-component-offset-top: calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem))))))}[part~=wy-messenger-conversation-list]{flex:0 1 100%;min-width:0;max-width:none;display:flex;flex-direction:column;padding:var(--wy-padding-outer, 0);gap:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-messenger-conversation]{display:flex;flex-direction:column;overflow-anchor:none;height:100%;width:100%;flex:0 1 100%;box-sizing:border-box;padding:var(--wy-padding-outer, 0);--wy-component-offset-top: var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))}[part~=wy-close-conversation]{display:contents}@container (inline-size < 768px){[part~=wy-messenger-conversation-list]:not([data-conversation-id=\"\"]){display:none}[part~=wy-messenger-conversation][data-conversation-id=\"\"]{display:none}}@container (inline-size >= 768px){[part~=wy-messenger-conversation-list]{flex:0 1 50%;max-width:calc(24*var(--wy-size, 1rem));padding-right:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));border-right:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-messenger-conversation]{min-width:max(50%,calc(16 * var(--wy-size, 1rem)));padding-left:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-close-conversation]{display:none}}`;
var XJ = Object.defineProperty, jJ = Object.getOwnPropertyDescriptor, u3 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? jJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && XJ(t, e, r), r;
}, "__decorateClass$d"), ok, Xm;
let _y = (ok = (Xm = class extends Xi {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.uploadBlobMutation = new Wr(this), this.fileInputRef = $t(), this.openFileInput = () => {
      this.fileInputRef.value?.click();
    };
  }
  /**
   * Uploads the first selected file and resets the input.
   *
   * @internal
   */
  async handleBlobChange(t, e) {
    if (t && this.weavy) {
      const i = { file: t[0] };
      await this.uploadBlobMutation.trackMutation(Gz(this.weavy));
      const r = await this.uploadBlobMutation.mutate(i);
      e && (e.value = "");
      const n = new CustomEvent("blob-uploaded", { detail: { blob: r } });
      this.dispatchEvent(n);
    }
  }
  render() {
    return v`
      <div part="wy-upload">
        <slot
          part="wy-upload-placeholder"
          name="placeholder"
          @click=${this.openFileInput}
          @keydown=${Ze}
          @keyup=${bi}
        ></slot>
        <input
          accept=${St(this.accept)}
          type="file"
          ${ht(this.fileInputRef)}
          @click=${(t) => t.stopPropagation()}
          @change=${(t) => this.handleBlobChange(t.target.files, t.target)}
          hidden
        />
        <slot part="wy-upload-action" name="action">
          ${this.label ? v`<wy-button part="wy-upload-button" @click=${this.openFileInput}>${this.label}</wy-button>` : C}
        </slot>
      </div>
    `;
  }
}, h(Xm, "lc"), Xm), c(ok, "WyUpload"), ok);
_y.styles = [
  it`
      :host {
        display: contents;
      }

      [part~="wy-upload"] {
        text-align: center;
      }

      [part~="wy-upload-placeholder"] {
        cursor: pointer;
      }
    `
];
u3([
  b({ attribute: !1 })
], _y.prototype, "label", 2);
u3([
  b({ attribute: !1 })
], _y.prototype, "accept", 2);
_y = u3([
  Y("wy-upload")
], _y);
var UJ = Object.defineProperty, HJ = Object.getOwnPropertyDescriptor, a2 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? HJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && UJ(t, e, r), r;
}, "__decorateClass$c"), lk, jm;
let El = (lk = (jm = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.inputRef = $t(), this.compact = !1, this.query = "", this.throttledSearch = VS(
      () => {
        this.query = this.inputRef.value?.value || "";
      },
      250,
      { leading: !1, trailing: !0 }
    );
  }
  /**
   * Put focus on the input field.
   */
  focusInput() {
    this.inputRef.value?.focus();
  }
  /**
   * Clear the input field.
   */
  clear() {
    this.query = "";
  }
  willUpdate(t) {
    if (t.has("query")) {
      const e = new CustomEvent("search", {
        bubbles: !0,
        composed: !1,
        detail: { query: this.query }
      });
      this.dispatchEvent(e);
    }
  }
  render() {
    const t = {
      "wy-input": !0,
      "wy-input-group-input": !0,
      "wy-input-filled": !0,
      "wy-input-group-input-with-overlay": this.compact
    }, e = {
      "wy-input-group-button-icon": !0,
      "wy-input-group-button-icon-overlay": this.compact
    };
    return v`
      <div part="wy-input-group">
        <input
          part=${gt(t)}
          name="text"
          .value=${this.query || ""}
          ${ht(this.inputRef)}
          @input=${() => this.throttledSearch()}
          @keydown=${pD}
          @keyup=${nn}
          placeholder=${this.placeholder || P("Search...")}
          size="4"
        />
        <wy-button type="reset" @click=${() => this.clear()} kind="icon" part=${gt(e)}>
          <wy-icon name="close-circle"></wy-icon>
        </wy-button>
        <wy-button kind="icon" part=${gt(e)}>
          <wy-icon name="magnify"></wy-icon>
        </wy-button>
      </div>
    `;
  }
}, h(jm, "dc"), jm), c(lk, "WySearch"), lk);
El.styles = [Ea, ft];
a2([
  b()
], El.prototype, "placeholder", 2);
a2([
  b({ type: Boolean })
], El.prototype, "compact", 2);
a2([
  N()
], El.prototype, "query", 2);
El = a2([
  Y("wy-search"),
  At()
], El);
var YJ = Object.defineProperty, GJ = Object.getOwnPropertyDescriptor, La = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? GJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && YJ(t, e, r), r;
}, "__decorateClass$b"), ck, Um;
let Zr = (ck = (Um = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.agentFilter = void 0, this.selected = [], this.select = [], this.text = "", this.peopleQuery = new Wl(this), this.searchRef = $t(), this.infiniteScroll = new Fl(this), this.pagerRef = $t();
  }
  /**
   * Emits the selected members via the `submit` event.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchSubmit() {
    this.selected = [...this.selected, ...this.select];
    const t = new CustomEvent("submit", {
      detail: { members: this.selected }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Checks whether a member is currently selected.
   *
   * @internal
   */
  isChecked(t) {
    return this.select.find((e) => e.id === t) != null;
  }
  /**
   * Toggles selection state for the provided member.
   *
   * @internal
   */
  handleSelected(t, e) {
    e ? this.select = [...this.select, t] : (this.select = this.select.filter((i) => i.id !== t.id), this.selected = this.selected.filter((i) => i.id !== t.id));
  }
  /**
   * Renders the list of currently selected members.
   *
   * @internal
   */
  getSelected() {
    return this.selected.length > 0 ? v`
        ${this.selected.map((t) => v`
            <wy-item
              interactive
              @click=${() => this.handleSelected(t, !1)}
              @keydown=${Ze}
              @keyup=${Ze}
            >
              <wy-avatar
                slot="image"
                id=${t.id}
                .src=${t.avatar_url}
                .name=${t.name}
                .description=${t.comment}
                .presence=${t.presence}
                .isAgent=${t.is_agent}
                size=${32}
              ></wy-avatar>
              <span slot="title"> ${t.name} </span>
              <wy-button slot="actions" kind="icon" .active=${!1}
                ><wy-icon name="checkbox-marked"></wy-icon
              ></wy-button>
            </wy-item>
          `)}
      ` : C;
  }
  /**
   * Renders search results for the current query and filter.
   *
   * @internal
   */
  getSearchResult() {
    const { data: t, hasNextPage: e, isPending: i } = this.peopleQuery.result ?? { data: [], isPending: !0 }, r = ys(t), n = !!r.length, a = [];
    return i ? a.push(v`<wy-progress-circular indeterminate overlay></wy-progress-circular>`) : n || a.push(v`<div part="wy-pane-group">
        <div part="wy-no-result">
          ${this.text ? P("Your search did not match any people.") : P("No more users found.")}
        </div>
      </div>`), n && a.push(
      v` ${r.filter((o) => this.selected.find((l) => l.id === o.id) === void 0).map((o) => v` <wy-item
              interactive
              @click=${() => this.handleSelected(o, !this.isChecked(o.id))}
              @keydown=${Ze}
              @keyup=${Ze}
            >
              <wy-avatar
                slot="image"
                id=${o.id}
                .src=${o.avatar_url}
                .name=${o.name}
                .description=${o.comment}
                .presence=${o.presence}
                .isAgent=${o.is_agent}
                size=${32}
              ></wy-avatar>
              <span slot="title"> ${o.name} </span>
              <wy-button slot="actions" kind="icon" .active=${!1}
                ><wy-icon name="${this.isChecked(o.id) ? "checkbox-marked" : "checkbox-blank"}"></wy-icon
              ></wy-button>
            </wy-item>`) ?? C}`
    ), e && a.push(v`<div ${ht(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>`), a;
  }
  render() {
    return v`<div part="wy-pane wy-scroll-y wy-scroll-y-always">
      <div part="wy-pane-body">
        <div part="wy-pane-group wy-pane-group-fixed-size">
          <wy-search ${ht(this.searchRef)} @search=${(t) => this.text = t.detail.query}></wy-search>
        </div>
        <div>
          <wy-buttons tabs>
            <wy-button
              ?active=${this.agentFilter === void 0}
              @click=${() => this.agentFilter = void 0}
              kind="tab"
              small
              >${P("All")}</wy-button
            >
            <wy-button ?active=${this.agentFilter === !1} @click=${() => this.agentFilter = !1} kind="tab" small
              >${P("People")}</wy-button
            >
            <wy-button ?active=${this.agentFilter === !0} @click=${() => this.agentFilter = !0} kind="tab" small
              >${P("Agents")}</wy-button
            >
          </wy-buttons>
        </div>
        <div part="wy-pane-body"> ${this.getSelected()} ${this.getSearchResult()} </div>
      </div>
      <div part="wy-footerbar wy-footerbar-sticky">
        <div part="wy-pane-group">
          <wy-buttons reverse>
            <wy-button
              color="primary"
              @click=${() => this.dispatchSubmit()}
              ?disabled=${this.selected.length === 0 && this.select.length === 0 ? !0 : void 0}
              >${this.buttonTitle ?? P("Create")}</wy-button
            >
          </wy-buttons>
        </div>
      </div>
    </div>`;
  }
  async willUpdate(t) {
    super.willUpdate(t), t.has("weavy") && this.weavy && await this.peopleQuery.trackInfiniteQuery(
      hD(
        this.weavy,
        () => this.text,
        this.appId,
        () => this.agentFilter
      )
    );
  }
  async updated(t) {
    this.infiniteScroll.observe(this.peopleQuery.result, this.pagerRef.value), (t.has("text") || t.has("agentFilter")) && (this.select.length > 0 && (this.selected = [...this.selected, ...this.select], this.select = []), await this.peopleQuery.result?.refetch?.(), this.searchRef.value?.focusInput());
  }
}, h(Um, "hc"), Um), c(ck, "WyUsersSearch"), ck);
Zr.styles = [jl, mD, Ea, Ma, ft, Nl];
La([
  Xe({ context: De, subscribe: !0 }),
  N()
], Zr.prototype, "weavy", 2);
La([
  b({ attribute: !1 })
], Zr.prototype, "appId", 2);
La([
  b({ attribute: !1 })
], Zr.prototype, "buttonTitle", 2);
La([
  N()
], Zr.prototype, "agentFilter", 2);
La([
  N()
], Zr.prototype, "selected", 2);
La([
  N()
], Zr.prototype, "select", 2);
La([
  N()
], Zr.prototype, "text", 2);
Zr = La([
  Y("wy-users-search"),
  At()
], Zr);
var KJ = Object.defineProperty, JJ = Object.getOwnPropertyDescriptor, dW = /* @__PURE__ */ c((s) => {
  throw TypeError(s);
}, "__typeError$2"), Jl = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? JJ(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && KJ(t, e, r), r;
}, "__decorateClass$a"), uW = /* @__PURE__ */ c((s, t, e) => t.has(s) || dW("Cannot " + e), "__accessCheck$2"), H9 = /* @__PURE__ */ c((s, t, e) => (uW(s, t, "read from private field"), e ? e.call(s) : t.get(s)), "__privateGet$2"), ttt = /* @__PURE__ */ c((s, t, e) => t.has(s) ? dW("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(s) : t.set(s, e), "__privateAdd$2"), Y9 = /* @__PURE__ */ c((s, t, e, i) => (uW(s, t, "write to private field"), t.set(s, e), e), "__privateSet$2"), lh, hk, Hm;
let $s = (hk = (Hm = class extends Xi {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.showDetails = !1, this.showAddMembers = !1, this.conversationTitle = "", this.conversationTitleInput = "", this.membersQuery = new Qr(this), this.handleRealtimeAppUpdated = (t) => {
      !this.conversationId || t.app.id !== this.conversationId || (this.conversationTitle = this.conversationTitleInput = t.app.name);
    }, this.handlePresenceChange = (t) => {
      if (!this.weavy)
        return;
      Array.isArray(t) || (t = [parseInt(t)]);
      const e = /* @__PURE__ */ c((i = []) => (i.forEach((r) => {
        r.presence = t.indexOf(r.id) != -1 ? "active" : "away";
      }), i), "updateMembersInApps");
      this.weavy.queryClient.setQueryData(["apps", this.conversationId], (i) => (i.members.data = e(i.members.data), i)), this.weavy.queryClient.setQueryData(["members", this.conversationId], (i) => e(i));
    }, ttt(this, lh);
  }
  /** Checks whether the current or provided conversation is an agent chat. */
  isAgentChat(t) {
    return (t ?? this.conversation)?.type === xt.AgentChat;
  }
  /** Checks whether the current or provided conversation is a chat room. */
  isChatRoom(t) {
    return (t ?? this.conversation)?.type === xt.ChatRoom;
  }
  /** Checks whether the current or provided conversation is a private chat. */
  isPrivateChat(t) {
    return (t ?? this.conversation)?.type === xt.PrivateChat;
  }
  /**
   * Adds a list of members to the conversation.
   *
   * @internal
   */
  async addMembers(t) {
    this.showAddMembers = !1, this.showDetails = !0, !(!this.weavy || !this.conversationId) && (await this.addMembersMutation?.mutate({ appId: this.conversationId, members: t.map((e) => e.id) }), await this.membersQuery.result.refetch(), await this.weavy.queryClient.invalidateQueries({ queryKey: ["apps"] }));
  }
  /**
   * Handles saving the conversation name from the conversation name input.
   *
   * @internal
   */
  async handleSaveConversationName() {
    if (!this.weavy || !this.conversationId)
      return;
    const t = this.conversationTitleInput.trim() === "" ? null : this.conversationTitleInput.trim();
    await this.updateConversationMutation?.mutate({ appId: this.conversationId, name: t });
  }
  /**
   * Updates the avatar with an uploaded blob picture.
   *
   * @internal
   */
  async handleAvatarUploaded(t) {
    !this.weavy || !this.conversationId || await this.updateConversationMutation?.mutate({
      appId: this.conversationId,
      blobId: t.id,
      thumbnailUrl: t.thumbnail_url
    });
  }
  /**
   * Clears the set avatar for the conversation.
   *
   * @internal
   */
  async clearAvatar() {
    !this.weavy || !this.conversationId || await this.updateConversationMutation?.mutate({ appId: this.conversationId, blobId: null, thumbnailUrl: null });
  }
  /**
   * Updates the access for a member in the conversation.
   *
   * @internal
   */
  async updateMember(t, e) {
    !this.weavy || !this.conversationId || (await this.updateMemberMutation?.mutate({
      appId: this.conversationId,
      userId: t,
      access: e
    }), await this.membersQuery.result.refetch());
  }
  /**
   * Removes the current or provided member from the conversation.
   *
   * If no memberId is provided, the current user leaves the conversation and the component state is cleared.
   *
   * @internal
   */
  async leaveConversation(t) {
    !this.weavy || !this.conversationId || !this.user || (t && await this.leaveConversationMutation?.mutate({
      appId: this.conversationId,
      members: [t]
    }), !t || t === this.user.id ? (this.showDetails = !1, this.conversation = void 0, this.conversationId = void 0, this.dispatchAction(Oi.Select, null)) : await this.membersQuery.result.refetch(), await this.weavy.queryClient.invalidateQueries({ queryKey: ["apps"] }));
  }
  /**
   * Triggers `wy-action` event.
   *
   * @param action - The performed action.
   * @param conversation - The conversation to select or `null` to clear.
   * @returns Whether the event was successful.
   *
   * @internal
   */
  dispatchAction(t, e) {
    this.conversationId = e?.id;
    const i = new CustomEvent("wy-action", { detail: { action: t, app: e }, bubbles: !0, composed: !0 });
    return this.dispatchEvent(i);
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("weavy") && this.weavy && (this.leaveConversationMutation = $4(this.weavy), this.addMembersMutation = lD(this.weavy), this.updateConversationMutation = x4(this.weavy), this.updateMemberMutation = oD(this.weavy)), t.has("conversationId") && (this.showDetails = !1), (t.has("weavy") || t.has("conversationId")) && this.weavy)
      if ((e = H9(this, lh)) == null || e.call(this), this.conversationId) {
        await this.membersQuery.trackQuery(
          S4(this.weavy, this.conversationId, {
            initialData: /* @__PURE__ */ c(() => {
              if (this.conversationId)
                return this.weavy?.queryClient.getQueryData(["apps", this.conversationId])?.members;
            }, "initialData")
          })
        );
        const i = `a${this.conversationId}`;
        this.weavy.subscribe(i, "app_updated", this.handleRealtimeAppUpdated), this.weavy.subscribe(null, "online", this.handlePresenceChange), Y9(this, lh, () => {
          this.weavy?.unsubscribe(i, "app_updated", this.handleRealtimeAppUpdated), this.weavy?.unsubscribe(null, "online", this.handlePresenceChange), Y9(this, lh, void 0);
        });
      } else
        this.membersQuery.untrackQuery();
    t.has("conversation") && this.conversation && (this.conversationTitleInput = this.conversationTitle = this.conversation.name);
  }
  render() {
    const { data: t } = this.membersQuery.result ?? {}, e = (t?.data || []).filter((r) => r.access === Ln.Admin).length, i = this.user && this.isPrivateChat() ? (this.conversation?.members?.data || []).filter((r) => r.id !== this.user?.id)?.[0] ?? this.user : null;
    return this.conversationId ? v`
          <wy-titlebar outer header floating part="wy-conversation-titlebar">
            <slot slot="icon" name="icon"><span></span></slot>
            ${this.conversation && this.user ? v`
                  ${this.conversation.type === xt.PrivateChat ? v`<wy-presence
                        slot="title-section"
                        placement="text"
                        .status=${i?.presence}
                        id=${St(i?.id)}
                      ></wy-presence>` : C}
                  <wy-titlebar-text slot="title-section">${this.conversationTitle}</wy-titlebar-text>
                ` : C}
            ${this.isChatRoom() ? v`<wy-button
                  slot="actions"
                  kind="icon"
                  @click=${() => this.showDetails = !0}
                  title="${P("Details")}"
                >
                  <wy-icon name="information"></wy-icon>
                </wy-button>` : C}
          </wy-titlebar>

          <!-- details modal -->
          ${this.weavy ? v`
                <wy-overlay
                  part="wy-conversation-details"
                  .show=${this.showDetails}
                  @close=${() => {
      this.showDetails = !1;
    }}
                >
                  <wy-titlebar header slot="header">
                    <wy-button
                      slot="icon"
                      kind="icon"
                      @click=${() => {
      this.showDetails = !1;
    }}
                    >
                      <wy-icon name="close"></wy-icon>
                    </wy-button>
                    <span slot="title">${this.conversationTitle}</span>
                  </wy-titlebar>
                  <div part="wy-scroll-y">
                    ${this.showDetails && this.conversation && this.user ? v`
                          <wy-avatar-header>
                            ${this.isChatRoom() ? v`
                                  <wy-upload
                                    @blob-uploaded=${(r) => this.handleAvatarUploaded(r.detail.blob)}
                                    .accept=${"image/*"}
                                    .label=${P("Select picture")}
                                  >
                                    <div slot="placeholder">
                                      ${this.conversation.avatar_url ? v`<wy-avatar .size=${96} src=${this.conversation.avatar_url}></wy-avatar>` : v`<wy-avatar-group
                                            .members=${t?.data}
                                            title=${this.conversation.name}
                                            .size=${96}
                                          ></wy-avatar-group>`}
                                    </div>
                                    ${this.conversation.avatar_url ? v`<div slot="action"
                                          ><wy-button @click=${() => this.clearAvatar()}
                                            >${P("Remove picture")}</wy-button
                                          ></div
                                        >` : C}
                                  </wy-upload>
                                ` : v`
                                  <wy-avatar
                                    src=${St(i?.avatar_url)}
                                    name=${St(i?.name)}
                                    presence=${i?.presence || "away"}
                                    ?isAgent=${i?.is_agent}
                                    id=${St(i?.id)}
                                    size=${96}
                                  ></wy-avatar>
                                `}
                          </wy-avatar-header>
                          ${this.isChatRoom() ? v`
                                <div part="wy-pane-group">
                                  <label part="wy-label" for="roomName">${P("Room name")}</label>

                                  <input
                                    id="roomName"
                                    part="wy-input"
                                    .value=${this.conversationTitleInput}
                                    @input=${(r) => {
      this.conversationTitleInput = r.target.value;
    }}
                                    @keyup=${uD}
                                    @blur=${() => this.handleSaveConversationName()}
                                  />

                                  <div part="wy-description">
                                    ${P("Changing the name of a group chat changes it for everyone.")}
                                  </div>
                                  <br />
                                  <label part="wy-label">${P("Members")}</label>
                                  ${t ? v`
                                        <wy-item-list>
                                          ${t.data?.map(
      (r) => v`
                                              <wy-item>
                                                <wy-avatar
                                                  slot="image"
                                                  .src=${r.avatar_url}
                                                  .name=${r.name}
                                                  .description=${r.comment}
                                                  .isAgent=${r.is_agent}
                                                  size=${32}
                                                ></wy-avatar>
                                                <span slot="title">
                                                  ${r.name}
                                                  ${r.access === Ln.Admin ? v` <wy-icon
                                                        size="20"
                                                        inline
                                                        name="shield-star"
                                                        title=${P("Admin")}
                                                      ></wy-icon>` : C}
                                                </span>
                                                ${this.user && this.user.id === r.id && !Oy(ml.Admin, this.conversation?.permissions) ? v` <wy-button
                                                      slot="actions"
                                                      @click=${() => this.leaveConversation(r.id)}
                                                      title=${P("Leave conversation")}
                                                      kind="icon"
                                                    >
                                                      <wy-icon name="close"></wy-icon>
                                                    </wy-button>` : Oy(ml.Admin, this.conversation?.permissions) ? v`<wy-dropdown slot="actions">
                                                      <wy-dropdown-item
                                                        @click=${() => this.leaveConversation(r.id)}
                                                      >
                                                        <wy-icon name="account-minus"></wy-icon>
                                                        ${this.user && this.user.id === r.id ? P("Leave conversation") : P("Remove member")}
                                                      </wy-dropdown-item>
                                                      ${e > 1 && r.access === Ln.Admin ? v`<wy-dropdown-item
                                                            @click=${() => this.updateMember(r.id, Ln.Write)}
                                                          >
                                                            <wy-icon name="shield-star-outline"></wy-icon>
                                                            ${P("Remove as admin")}
                                                          </wy-dropdown-item>` : r.access !== Ln.Admin ? v`<wy-dropdown-item
                                                            @click=${() => this.updateMember(r.id, Ln.Admin)}
                                                          >
                                                            <wy-icon name="shield-star"></wy-icon>
                                                            ${P("Make admin")}
                                                          </wy-dropdown-item>` : C}
                                                    </wy-dropdown>` : C}
                                              </wy-item>
                                            `
    ) ?? C}
                                        </wy-item-list>
                                      ` : C}
                                  <div>
                                    <wy-button
                                      part="wy-conversation-details-add-members-button"
                                      kind="filled"
                                      color="primary"
                                      @click=${() => {
      this.showDetails = !1, this.showAddMembers = !0;
    }}
                                      title=${P("Add members")}
                                    >
                                      ${P("Add members")}
                                    </wy-button>
                                  </div>
                                </div>
                              ` : C}
                        ` : C}
                  </div>
                </wy-overlay>
              ` : C}

          <!-- add members modal -->
          ${this.weavy ? v`
                <wy-overlay
                  part="wy-conversation-add-members"
                  .show=${this.showAddMembers}
                  @close=${() => {
      this.showAddMembers = !1;
    }}
                >
                  <wy-titlebar header>
                    <wy-button
                      slot="icon"
                      kind="icon"
                      @click=${() => {
      this.showAddMembers = !1;
    }}
                    >
                      <wy-icon name="close"></wy-icon>
                    </wy-button>
                    <span slot="title">${P("Add members")}</span>
                  </wy-titlebar>
                  ${this.showAddMembers ? v`
                        <wy-users-search
                          .buttonTitle=${P("Add members")}
                          .appId=${this.conversationId}
                          @submit=${(r) => this.addMembers(r.detail.members)}
                        ></wy-users-search>
                      ` : C}
                </wy-overlay>
              ` : C}
        ` : C;
  }
  disconnectedCallback() {
    var t;
    (t = H9(this, lh)) == null || t.call(this), super.disconnectedCallback();
  }
}, h(Hm, "uc"), Hm), c(hk, "WyConversationHeader"), hk);
lh = /* @__PURE__ */ new WeakMap();
$s.styles = [Ea, Nl, jl, ft];
Jl([
  b({ attribute: !1 })
], $s.prototype, "conversationId", 2);
Jl([
  b({ attribute: !1 })
], $s.prototype, "conversation", 2);
Jl([
  N()
], $s.prototype, "showDetails", 2);
Jl([
  N()
], $s.prototype, "showAddMembers", 2);
Jl([
  N()
], $s.prototype, "conversationTitle", 2);
Jl([
  N()
], $s.prototype, "conversationTitleInput", 2);
$s = Jl([
  Y("wy-conversation-header"),
  At()
], $s);
var ett = Object.defineProperty, itt = Object.getOwnPropertyDescriptor, Jy = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? itt(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && ett(t, e, r), r;
}, "__decorateClass$9"), dk, Ym;
let xs = (dk = (Ym = class extends Ve {
  constructor() {
    super(...arguments), this.componentFeatures = new di(Ey), this.theme = new Ri(this, xs.styles), this.unreadConversationsController = new zb(this), this.createConversationController = new Lb(this), this.componentTypes = [xt.ChatRoom, xt.PrivateChat], this.conversationId = null, this.conversationQuery = new Qr(this), this.persistState = new Q1(this), this.conversationListRef = $t(), this.conversationNewRef = $t();
  }
  set agent(t) {
    super.agent = t, this._agentUid ? (this.componentTypes = [xt.AgentChat], this.componentFeatures = new di(
      h3,
      this.componentFeatures.allowedFeatures()
    )) : (this.componentTypes = [xt.ChatRoom, xt.PrivateChat], this.componentFeatures = new di(
      Ey,
      this.componentFeatures.allowedFeatures()
    )), this.conversationId = null;
  }
  get agent() {
    return super.agent;
  }
  /** Current unread conversation count. */
  get unread() {
    return this.unreadConversationsController.unread;
  }
  /**
   * Creates a new conversation.
   *
   * When in agent mode, a conversation is created instantly.
   *
   * @param members - Optional array of member ids or member uids.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select member dialog to let the user select members for creating a conversation.
   *
   * @returns Promise resolving to any selected member ids or uids.
   */
  async selectMembers() {
    return this.conversationId = null, await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("weavy") || t.has("agent") || t.has("user")) && this.weavy && this.user && this.persistState.observe(
      [{ name: "conversationId", override: !1 }],
      this.agent || "messenger",
      `u${this.user?.id}`,
      (e) => {
        if (e.has("conversationId") && this.conversationId) {
          const i = new CustomEvent("wy-action", {
            detail: {
              action: Oi.Select,
              app: { id: this.conversationId }
            },
            bubbles: !0,
            composed: !0
          });
          this.dispatchEvent(i);
        }
      }
    ), t.has("link") && this.link?.app && (this.conversationId = this.link.app.id), (t.has("conversationId") || t.has("weavy")) && this.weavy && (this.conversationId ? this.conversationQuery.trackQuery(
      k4(this.weavy, this.conversationId, this.componentTypes)
    ) : this.conversationQuery.untrackQuery()), t.has("agent") && (this.createConversationController.agent = this.agent), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversationsController.track(this.componentTypes, this.agent);
  }
  render() {
    const { isPending: t } = this.weavy?.network ?? { isPending: !0 }, { data: e } = this.conversationQuery.result ?? {}, i = this.conversationListRef.value?.conversationsQuery.result.data?.pages[0].count || 0;
    return v`
      <div part="wy-messenger-layout">
        <div
          part="wy-messenger-conversation-list wy-scroll-y"
          data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
        >
          <slot name="header"></slot>
          <wy-conversation-list
            ${ht(this.conversationListRef)}
            .conversationTypes=${this.componentTypes}
            .agent=${this.agent}
            conversationId=${St(this.conversationId !== null ? this.conversationId : void 0)}
            @wy-action=${(r) => {
      !r.defaultPrevented && r.detail.action === Oi.Select && r.detail.app !== void 0 && (this.conversationId = r.detail.app?.id);
    }}
          >
            <wy-conversation-new
              slot="actions"
              .agent=${this.agent}
              @create=${async (r) => {
      const n = await this.createConversationController.create(r.detail.members);
      n && (this.conversationId = n.id);
    }}
              ${ht(this.conversationNewRef)}
            >
              <slot name="conversation-new"></slot>
            </wy-conversation-new>
            <slot name="actions" slot="actions"></slot>
          </wy-conversation-list>
        </div>

        <div
          part="wy-messenger-conversation wy-scroll-y"
          data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
        >
          <wy-conversation-header
            .conversationId=${this.conversationId || void 0}
            .conversation=${e}
            @wy-action=${(r) => {
      !r.defaultPrevented && r.detail.action === Oi.Select && r.detail.app !== void 0 && (this.conversationId = r.detail.app?.id);
    }}
            ?hidden=${!this.conversationId}
          >
            <span slot="icon" part="wy-close-conversation">
              <wy-button kind="inline" @click=${() => this.conversationId = null}>
                <wy-icon name="back">
                  <wy-badge
                    reveal
                    .count=${this.unreadConversationsController.isUnreadPending ? NaN : this.unreadConversationsController.unread}
                  ></wy-badge>
                </wy-icon>
              </wy-button>
            </span>
          </wy-conversation-header>

          ${this.conversationId ? v`<wy-conversation
                .conversationId=${this.conversationId}
                .conversation=${e}
                .agentInstructions=${this.instructions}
                .placeholder=${this.placeholder ?? (this.agent ? P("Ask anything...") : void 0)}
                .header=${!this.agent}
              ></wy-conversation>` : i ? v`<wy-empty noNetwork>${P("Select a conversation")}</wy-empty>` : C}
        </div>

        <wy-context-data-progress></wy-context-data-progress>
      </div>
    `;
  }
}, h(Ym, "pc"), Ym), c(dk, "WyMessenger"), dk);
xs.styles = [Ie, jl, d3, vn, Ei];
Jy([
  b({ attribute: !1 })
], xs.prototype, "componentTypes", 2);
Jy([
  b({ type: String })
], xs.prototype, "agent", 1);
Jy([
  b()
], xs.prototype, "instructions", 2);
Jy([
  b()
], xs.prototype, "placeholder", 2);
Jy([
  b({ type: Number })
], xs.prototype, "conversationId", 2);
xs = Jy([
  Y("wy-messenger"),
  At()
], xs);
var rtt = Object.defineProperty, stt = Object.getOwnPropertyDescriptor, Xr = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? stt(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && rtt(t, e, r), r;
}, "__decorateClass$8"), uk, Gm;
let Ai = (uk = (Gm = class extends Ve {
  constructor() {
    super(...arguments), this.componentFeatures = new di(Ey), this.theme = new Ri(this, Ai.styles), this.unreadConversationsController = new zb(this), this.createConversationController = new Lb(this), this.overlay = "drawer", this.badge = "compact", this.badgePosition = "top-right", this.componentTypes = [xt.ChatRoom, xt.PrivateChat], this.conversationId = null, this.show = !1, this.maximized = !1, this.conversationQuery = new Qr(this), this.persistState = new Q1(this), this.messengerRef = $t(), this.conversationListRef = $t(), this.conversationNewRef = $t();
  }
  /** Check visibility on the Messenger */
  get visibilityElement() {
    return this.messengerRef.value;
  }
  set agent(t) {
    super.agent = t, this._agentUid ? (this.componentTypes = [xt.AgentChat], this.componentFeatures = new di(
      h3,
      this.componentFeatures.allowedFeatures()
    )) : (this.componentTypes = [xt.ChatRoom, xt.PrivateChat], this.componentFeatures = new di(
      Ey,
      this.componentFeatures.allowedFeatures()
    )), this.conversationId = null;
  }
  get agent() {
    return super.agent;
  }
  /** Current unread conversation count. */
  get unread() {
    return this.unreadConversationsController.unread;
  }
  /**
   * Creates a new conversation.
   *
   * - When in agent mode, a conversation is created instantly.
   *
   * @param members {(number|string)[] | undefined} - Optional array of member id or member uid.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select member dialog to let the user select members for creating a conversation.
   *
   * @returns Any selected member ids or uids.
   */
  async selectMembers() {
    return this.conversationId = null, await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("weavy") || t.has("agent") || t.has("user")) && this.weavy && this.user && this.persistState.observe(
      [{ name: "conversationId", override: !1 }],
      this.agent || "messenger",
      `u${this.user?.id}`,
      (e) => {
        if (e.has("conversationId") && this.conversationId) {
          const i = new CustomEvent("wy-action", {
            detail: {
              action: Oi.Select,
              app: { id: this.conversationId }
            },
            bubbles: !0,
            composed: !0
          });
          this.dispatchEvent(i);
        }
      }
    ), t.has("link") && this.link?.app && (this.conversationId = this.link.app.id), (t.has("conversationId") || t.has("weavy")) && this.weavy && (this.conversationId ? this.conversationQuery.trackQuery(k4(this.weavy, this.conversationId, this.componentTypes)) : this.conversationQuery.untrackQuery()), t.has("agent") && (this.createConversationController.agent = this.agent), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversationsController.track(this.componentTypes, this.agent);
  }
  render() {
    const { isPending: t } = this.weavy?.network ?? { isPending: !0 }, { data: e } = this.conversationQuery.result ?? {}, i = this.conversationListRef.value?.conversationsQuery.result.data?.pages[0].count || 0;
    return v`
      <wy-button kind="icon" ?active=${this.show} @click=${() => this.show = !this.show}>
        <wy-icon name="message-text">
          ${this.user && this.badge !== "none" ? v`
                <wy-badge
                  appearance=${this.badge}
                  position=${this.badgePosition}
                  .count=${this.unreadConversationsController.isUnreadPending ? NaN : this.unreadConversationsController.unread}
                ></wy-badge>
              ` : C}
        </wy-icon>
      </wy-button>

      ${this.overlay !== "none" ? v`<wy-overlay
            type=${this.overlay}
            .show=${this.show}
            .maximized=${this.maximized}
            @close=${() => this.show = !1}
            noHeader
          >
            <div ${ht(this.messengerRef)} part="wy-messenger-layout wy-messenger-overlay-container">
              <div
                part="wy-messenger-conversation-list wy-scroll-y"
                data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
              >
                <slot name="header">
                  <wy-titlebar floating header outer>
                    <wy-button kind="icon" slot="icon" @click=${() => this.show = !1}
                      ><wy-icon name="close"></wy-icon
                    ></wy-button>
                    <slot name="title" slot="title">${P("Conversations")}</slot>
                    <slot name="actions" slot="actions"></slot>
                    <wy-button kind="icon" slot="actions" @click=${() => this.maximized = !this.maximized}
                      ><wy-icon name=${this.maximized ? "arrow-collapse" : "arrow-expand"}></wy-icon
                    ></wy-button>
                  </wy-titlebar>
                </slot>

                <wy-conversation-list
                  ${ht(this.conversationListRef)}
                  .conversationTypes=${this.componentTypes}
                  .agent=${this.agent}
                  conversationId=${St(this.conversationId !== null ? this.conversationId : void 0)}
                  @wy-action=${(r) => {
      !r.defaultPrevented && r.detail.action === Oi.Select && r.detail.app !== void 0 && (this.conversationId = r.detail.app?.id);
    }}
                >
                  <wy-conversation-new
                    slot="actions"
                    .agent=${this.agent}
                    @create=${async (r) => {
      const n = await this.createConversationController.create(r.detail.members);
      n && (this.conversationId = n.id);
    }}
                    ${ht(this.conversationNewRef)}
                  >
                    <slot name="conversation-new"></slot>
                  </wy-conversation-new>
                </wy-conversation-list>
              </div>

              <div
                part="wy-messenger-conversation wy-scroll-y"
                data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
              >
                <wy-conversation-header
                  .conversationId=${this.conversationId || void 0}
                  .conversation=${e}
                  @wy-action=${(r) => {
      !r.defaultPrevented && r.detail.action === Oi.Select && r.detail.app !== void 0 && (this.conversationId = r.detail.app?.id);
    }}
                  ?hidden=${!this.conversationId}
                >
                  <span slot="icon" part="wy-close-conversation">
                    <wy-button kind="icon" @click=${() => this.conversationId = null}>
                      <wy-icon name="back"></wy-icon>
                    </wy-button>
                    <wy-badge
                      reveal
                      .count=${this.unreadConversationsController.isUnreadPending ? NaN : this.unreadConversationsController.unread}
                    ></wy-badge>
                  </span>
                </wy-conversation-header>

                ${this.conversationId ? v`<wy-conversation
                      .conversationId=${this.conversationId}
                      .conversation=${e}
                      .agentInstructions=${this.instructions}
                      .placeholder=${this.placeholder ?? (this.agent ? P("Ask anything...") : void 0)}
                      .header=${!this.agent}
                    ></wy-conversation>` : i ? v`<wy-empty noNetwork>${P("Select a conversation")}</wy-empty>` : C}
              </div>

              <wy-context-data-progress></wy-context-data-progress>
            </div>
          </wy-overlay> ` : C}
    `;
  }
}, h(Gm, "yc"), Gm), c(uk, "WyMessengerButton"), uk);
Ai.styles = [ft, Ie, Ei, jl, d3];
Xr([
  b({ type: String })
], Ai.prototype, "overlay", 2);
Xr([
  b({ type: String })
], Ai.prototype, "badge", 2);
Xr([
  b({ type: String })
], Ai.prototype, "badgePosition", 2);
Xr([
  b({ attribute: !1 })
], Ai.prototype, "componentTypes", 2);
Xr([
  b({ type: String })
], Ai.prototype, "agent", 1);
Xr([
  b()
], Ai.prototype, "instructions", 2);
Xr([
  b()
], Ai.prototype, "placeholder", 2);
Xr([
  b({ type: Number })
], Ai.prototype, "conversationId", 2);
Xr([
  N()
], Ai.prototype, "show", 2);
Xr([
  N()
], Ai.prototype, "maximized", 2);
Ai = Xr([
  Y("wy-messenger-button"),
  At()
], Ai);
var ntt = Object.getOwnPropertyDescriptor, att = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? ntt(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = a(r) || r);
  return r;
}, "__decorateClass$7"), pk, Km;
let y1 = (pk = (Km = class extends Ve {
  constructor() {
    super(...arguments), this.theme = new Ri(this, y1.styles), this.createConversationController = new Lb(this), this.conversationNewRef = $t();
  }
  /**
   * Creates a new conversation.
   *
   * When in agent mode, the conversation is created instantly.
   *
   * @param members - Optional array of member ids or member uids.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select-member dialog.
   *
   * @returns Promise resolving to the selected member ids or uids.
   */
  async selectMembers() {
    return await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), t.has("agent") && (this.createConversationController.agent = this.agent);
  }
  render() {
    return v`
      <wy-conversation-new
        .agent=${this.agent}
        @create=${async (t) => {
      await this.createConversationController.create(t.detail.members);
    }}
        ${ht(this.conversationNewRef)}
      ></wy-conversation-new>
    `;
  }
}, h(Km, "wc"), Km), c(pk, "WyMessengerNew"), pk);
y1.styles = [Ie, jl, d3, vn, Ei];
y1 = att([
  Y("wy-messenger-new")
], y1);
var ott = Object.defineProperty, ltt = Object.getOwnPropertyDescriptor, U1 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? ltt(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && ott(t, e, r), r;
}, "__decorateClass$6"), fk, Jm;
let fn = (fk = (Jm = class extends Ve {
  constructor() {
    super(...arguments), this.theme = new Ri(this, fn.styles), this.unreadConversations = new zb(this), this.componentTypes = [xt.ChatRoom, xt.PrivateChat], this.badge = "count", this.badgePosition = "inline";
  }
  set agent(t) {
    super.agent = t, this._agentUid ? this.componentTypes = [xt.AgentChat] : this.componentTypes = [xt.ChatRoom, xt.PrivateChat];
  }
  get agent() {
    return super.agent;
  }
  /**
   * Current unread conversation count.
   */
  get unread() {
    return this.unreadConversations.unread;
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversations.track(this.componentTypes, this.agent);
  }
  render() {
    return this.user && this.badge !== "none" ? v`
          <wy-badge
            appearance=${this.badge}
            position=${this.badgePosition}
            .count=${this.unreadConversations.isUnreadPending ? NaN : this.unreadConversations.unread}
          ></wy-badge>
        ` : C;
  }
}, h(Jm, "fc"), Jm), c(fk, "WyMessengerBadge"), fk);
fn.styles = [lW, Ie, Ei];
U1([
  b({ attribute: !1 })
], fn.prototype, "componentTypes", 2);
U1([
  b({ type: String })
], fn.prototype, "badge", 2);
U1([
  b({ type: String })
], fn.prototype, "badgePosition", 2);
U1([
  b({ type: String })
], fn.prototype, "agent", 1);
fn = U1([
  Y("wy-messenger-badge")
], fn);
const pW = it`[part~=wy-conversations]{position:relative;display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-conversation-list]{display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}`;
var ctt = Object.defineProperty, htt = Object.getOwnPropertyDescriptor, o2 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? htt(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && ctt(t, e, r), r;
}, "__decorateClass$5"), mk, ty;
let Ly = (mk = (ty = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.typing = new kI(this);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("appId") && (this.typing.appId = this.appId), t.has("userId") && (this.typing.userId = this.userId);
  }
  render() {
    const { names: t, ellipsis: e } = this.typing;
    let i;
    if (t.length === 1) {
      const r = t[0];
      i = P(lt`${r} is typing${e}`, { desc: "A is typing..." });
    } else if (t.length > 1) {
      const r = new Intl.ListFormat(this.weavy?.locale, { style: "long", type: "conjunction" }).format(
        t
      );
      i = P(lt`${r} are typing${e}`, {
        desc: "A, B and C are typing..."
      });
    }
    return i ? v`<span>${i}</span>` : v`<slot></slot>`;
  }
}, h(ty, "mc"), ty), c(mk, "WyTyping"), mk);
o2([
  Xe({ context: De, subscribe: !0 }),
  N()
], Ly.prototype, "weavy", 2);
o2([
  b({ attribute: !0, type: Number })
], Ly.prototype, "appId", 2);
o2([
  b({ attribute: !0, type: Number })
], Ly.prototype, "userId", 2);
Ly = o2([
  Y("wy-typing"),
  At()
], Ly);
var dtt = Object.defineProperty, utt = Object.getOwnPropertyDescriptor, fW = /* @__PURE__ */ c((s) => {
  throw TypeError(s);
}, "__typeError$1"), Ui = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? utt(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && dtt(t, e, r), r;
}, "__decorateClass$4"), mW = /* @__PURE__ */ c((s, t, e) => t.has(s) || fW("Cannot " + e), "__accessCheck$1"), G9 = /* @__PURE__ */ c((s, t, e) => (mW(s, t, "read from private field"), e ? e.call(s) : t.get(s)), "__privateGet$1"), ptt = /* @__PURE__ */ c((s, t, e) => t.has(s) ? fW("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(s) : t.set(s, e), "__privateAdd$1"), K9 = /* @__PURE__ */ c((s, t, e, i) => (mW(s, t, "write to private field"), t.set(s, e), e), "__privateSet$1"), ch, yk, ey;
let ui = (yk = (ey = class extends wt {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.unread = !1, this.avatarUrl = "", this.hideAvatar = !1, this.name = "", this.type = xt.PrivateChat, this.selected = !1, this.starred = !1, this.pinned = !1, this.handleMessageCreated = (t) => {
      !this.user || !this.weavy || (ke(this.weavy.queryClient, ["apps", t.message.app.id], void 0, (e) => {
        e.last_message = t.message, e.is_unread = t.message.created_by.id !== this.user?.id;
      }), Rt(
        this.weavy.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.message.app.id,
        (e) => {
          e.last_message = t.message, e.is_unread = t.message.created_by.id !== this.user?.id;
        }
      ));
    }, this.handleConversationUpdated = () => {
      this.weavy?.queryClient.invalidateQueries({ queryKey: ["apps"], exact: !1 });
    }, this.handleConversationMarked = (t) => {
      this.user && t.actor.id === this.user.id && this.weavy?.queryClient.invalidateQueries({ queryKey: ["apps"], exact: !1 });
    }, ptt(this, ch);
  }
  /**
   * Trigger `selected` event.
   *
   * @returns Whether the event was dispatched successfully.
   */
  dispatchSelected() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("selected", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Trigger `star` event.
   *
   * @param star - Whether the conversation should be starred.
   * @returns Whether the event was dispatched successfully.
   */
  dispatchStar(t) {
    if (!this.conversationId)
      return;
    const e = new CustomEvent("star", {
      detail: { id: this.conversationId, star: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Trigger `pin` event.
   *
   * @param pin - Whether the conversation should be pinned.
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchPin(t) {
    if (!this.conversationId)
      return;
    const e = new CustomEvent("pin", {
      detail: { id: this.conversationId, pin: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Trigger `mark` event for marking the conversation as read/unread.
   *
   * @param mark - Whether the conversation should be marked as read.
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchMarked(t) {
    if (!this.conversationId)
      return;
    const e = new CustomEvent("mark", {
      detail: { id: this.conversationId, messageId: t ? this.lastMessage?.id : null }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Triggers `leave` event when the current user is leaving the conversation.
   *
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchLeaveConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("leave", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Triggers `remove` when the conversation should be removed.
   *
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchRemoveConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("remove", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Triggers `trash` event when the conversation should be trashed.
   *
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchTrashConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("trash", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  willUpdate(t) {
    var e;
    if (super.willUpdate(t), (t.has("weavy") || t.has("conversationId")) && this.weavy && this.conversationId) {
      (e = G9(this, ch)) == null || e.call(this);
      const i = `a${this.conversationId}`;
      this.weavy.subscribe(i, "app_updated", this.handleConversationUpdated), this.weavy.subscribe(i, "member_added", this.handleConversationUpdated), this.weavy.subscribe(i, "message_created", this.handleMessageCreated), this.weavy.subscribe(i, "app_marked", this.handleConversationMarked), K9(this, ch, () => {
        this.weavy?.unsubscribe(i, "app_updated", this.handleConversationUpdated), this.weavy?.unsubscribe(i, "member_added", this.handleConversationUpdated), this.weavy?.unsubscribe(i, "message_created", this.handleMessageCreated), this.weavy?.unsubscribe(i, "app_marked", this.handleConversationMarked), K9(this, ch, void 0);
      });
    }
  }
  render() {
    const t = this.lastMessage?.created_at ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.lastMessage.created_at)
    ) : "", e = this.lastMessage?.created_at ? Hl(this.weavy?.locale, new Date(this.lastMessage.created_at)) : "", i = this.type === xt.PrivateChat && this.user ? (this.members?.data || []).filter((r) => r.id !== this.user?.id)?.[0] ?? this.user : null;
    return v`
      <wy-item
        part="wy-conversation-item"
        size="lg"
        interactive
        outer
        status=${this.unread ? "unread" : void 0}
        ?selected=${this.selected}
        tabindex="0"
        actionsPosition="bottom"
        @click=${(r) => (r.preventDefault(), this.dispatchSelected())}
        @keydown=${Ze}
        @keyup=${bi}
      >
        ${this.type !== xt.AgentChat ? this.avatarUrl ? v`<wy-avatar slot="image" .size=${48} src=${this.avatarUrl}></wy-avatar>` : this.type == xt.ChatRoom ? v` <wy-avatar-group
                slot="image"
                .members=${this.members?.data}
                title=${this.name}
                .size=${48}
              ></wy-avatar-group>` : v`
                <wy-avatar
                  slot="image"
                  src=${St(i?.avatar_url)}
                  name=${St(i?.name)}
                  description=${St(i?.comment)}
                  presence=${i?.presence || "away"}
                  ?isAgent=${i?.is_agent}
                  id=${St(i?.id)}
                  size=${48}
                ></wy-avatar>
              ` : C}

        <span slot="title">${this.name || this.lastMessage?.plain || P("Untitled conversation")}</span>
        ${this.lastMessage ? v`
              <time slot="meta" datetime=${this.lastMessage.created_at.toString()} title=${t}
                >${e}</time
              >
            ` : C}
        <span slot="text">
          ${this.user ? v`
                <wy-typing appId=${this.conversationId} userId=${this.user.id}>
                  ${this.lastMessage ? v`
                        ${this.user.id === this.lastMessage.created_by.id ? v`${P("You")}: ` : C}
                        ${this.members.count > 2 && this.user.id !== this.lastMessage?.created_by.id ? v`${this.lastMessage?.created_by.name}: ` : C}
                      ` : C}
                  ${this.lastMessage?.text ? v`<span>${this.lastMessage.plain}</span>` : C}
                  ${!this.lastMessage?.text && (this.lastMessage?.attachments?.count || 0) > 0 ? v`<wy-icon kind="text-icon" name="attachment"></wy-icon>` : C}
                  ${!this.lastMessage?.text && this.lastMessage?.meeting?.id ? v`<wy-icon kind="text-icon" name="video"></wy-icon>` : C}
                  ${!this.lastMessage?.text && (this.lastMessage?.options?.count || 0) > 0 ? v`<wy-icon kind="text-icon" name="poll"></wy-icon>` : C}
                  ${this.lastMessage ? C : v`&nbsp;`}
                </wy-typing>
              ` : C}
        </span>

        ${this.starred ? v`<wy-button
              small
              slot="actions"
              kind="icon"
              @click=${(r) => {
      r.stopPropagation(), this.dispatchStar(!1);
    }}
            >
              <wy-icon name="star" size=${24} color="yellow"></wy-icon>
            </wy-button>` : C}
        ${this.pinned ? v`<wy-button
              small
              slot="actions"
              kind="icon"
              @click=${(r) => {
      r.stopPropagation(), this.dispatchPin(!1);
    }}
            >
              <wy-icon name="pin" size=${20} color=""></wy-icon>
            </wy-button>` : C}
 
        <wy-dropdown small slot="actions" directionX="left">
          <wy-dropdown-item @click=${() => this.dispatchMarked(this.unread)}>
            <wy-icon name=${this.unread ? "read" : "unread"}></wy-icon>
            ${this.unread ? P("Mark as read") : P("Mark as unread")}
          </wy-dropdown-item>
          <wy-dropdown-item @click=${() => this.dispatchPin(!this.pinned)}>
            <wy-icon name=${this.pinned ? "unpin" : "pin"}></wy-icon>
            ${this.pinned ? P("Unpin") : P("Pin")}
          </wy-dropdown-item>
          <wy-dropdown-item @click=${() => this.dispatchStar(!this.starred)}>
            <wy-icon name=${this.starred ? "unstar" : "star"}></wy-icon>
            ${this.starred ? P("Unstar") : P("Star")}
          </wy-dropdown-item>
          ${this.type === xt.PrivateChat ? v`<wy-dropdown-item @click=${() => this.dispatchRemoveConversation()}>
                <wy-icon name="trashcan"></wy-icon>
                ${P("Delete")}
              </wy-dropdown-item>` : C}
          ${this.type === xt.ChatRoom ? v`<wy-dropdown-item @click=${() => this.dispatchLeaveConversation()}>
                <wy-icon name="account-minus"></wy-icon>
                ${P("Leave")}
              </wy-dropdown-item>` : C}
          ${this.type === xt.AgentChat ? v`
                <wy-dropdown-item @click=${() => this.dispatchTrashConversation()}>
                  <wy-icon name="trashcan"></wy-icon>
                  ${P("Delete")}
                </wy-dropdown-item>
              ` : C}
        </wy-dropdown>
      </wy-item>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.weavy && this.requestUpdate("weavy");
  }
  disconnectedCallback() {
    var t;
    (t = G9(this, ch)) == null || t.call(this), super.disconnectedCallback();
  }
}, h(ey, "vc"), ey), c(yk, "WyConversationItem"), yk);
ch = /* @__PURE__ */ new WeakMap();
ui.styles = [pW];
Ui([
  Xe({ context: De, subscribe: !0 }),
  N()
], ui.prototype, "weavy", 2);
Ui([
  Xe({ context: Pb, subscribe: !0 }),
  N()
], ui.prototype, "user", 2);
Ui([
  b({ attribute: !0, type: Number })
], ui.prototype, "conversationId", 2);
Ui([
  b({ attribute: !0, type: Boolean, reflect: !0 })
], ui.prototype, "unread", 2);
Ui([
  b({ attribute: !0 })
], ui.prototype, "avatarUrl", 2);
Ui([
  b({ attribute: !0, type: Boolean, reflect: !0 })
], ui.prototype, "hideAvatar", 2);
Ui([
  b({ attribute: !0 })
], ui.prototype, "name", 2);
Ui([
  b({ attribute: !0, type: String })
], ui.prototype, "type", 2);
Ui([
  b({ attribute: !0, type: Boolean, reflect: !0 })
], ui.prototype, "selected", 2);
Ui([
  b({ attribute: !0, type: Boolean, reflect: !0 })
], ui.prototype, "starred", 2);
Ui([
  b({ attribute: !0, type: Boolean, reflect: !0 })
], ui.prototype, "pinned", 2);
Ui([
  b({ attribute: !1 })
], ui.prototype, "members", 2);
Ui([
  b({ attribute: !1 })
], ui.prototype, "lastMessage", 2);
ui = Ui([
  Y("wy-conversation-item"),
  At()
], ui);
var ftt = Object.defineProperty, mtt = Object.getOwnPropertyDescriptor, yW = /* @__PURE__ */ c((s) => {
  throw TypeError(s);
}, "__typeError"), H1 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? mtt(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && ftt(t, e, r), r;
}, "__decorateClass$3"), gW = /* @__PURE__ */ c((s, t, e) => t.has(s) || yW("Cannot " + e), "__accessCheck"), J9 = /* @__PURE__ */ c((s, t, e) => (gW(s, t, "read from private field"), e ? e.call(s) : t.get(s)), "__privateGet"), ytt = /* @__PURE__ */ c((s, t, e) => t.has(s) ? yW("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(s) : t.set(s, e), "__privateAdd"), t8 = /* @__PURE__ */ c((s, t, e, i) => (gW(s, t, "write to private field"), t.set(s, e), e), "__privateSet"), hh, gk, iy;
let Qa = (gk = (iy = class extends Xi {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this.conversationTypes = [xt.ChatRoom, xt.PrivateChat], this.searchText = "", this.conversationsQuery = new Wl(this), this.infiniteScroll = new Fl(this), this.pagerRef = $t(), this.handleRefresh = () => {
      this.conversationsQuery.result.refetch();
    }, this.handlePresenceChange = (t) => {
      if (!this.weavy)
        return;
      Array.isArray(t) || (t = [parseInt(t)]);
      const e = /* @__PURE__ */ c((i) => {
        const r = i.members.data ?? [];
        r.forEach((n) => {
          n.presence = t.indexOf(n.id) != -1 ? "active" : "away";
        }), i.members.data = r;
      }, "updateMembersInApps");
      Rt(
        this.weavy.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        void 0,
        e
      );
    }, ytt(this, hh);
  }
  /**
   * Selects a conversation and triggers an action event.
   *
   * @param conversation - The conversation to select.
   */
  selectConversation(t) {
    this.conversationId = t?.id, this.dispatchAction(Oi.Select, t);
  }
  /**
   * Triggers `wy-action` event.
   * @param action - The performed action.
   * @param app - The conversation to select.
   * @returns Whether the event was successful.
   */
  dispatchAction(t, e) {
    const i = new CustomEvent("wy-action", {
      detail: { action: t, app: e },
      bubbles: !0,
      composed: !0
    });
    return this.dispatchEvent(i);
  }
  /**
   * Marks a conversation as read.
   *
   * @param appId - The id of the conversation to mark.
   * @param messageId - Optional message id to set the marker to.
   */
  async handleMark(t, e) {
    await this.markConversationMutation?.mutate({ app: t, messageId: e, userId: this.user?.id });
  }
  /**
   * Sets a conversation as starred.
   *
   * @param appId -  The id of the conversation to star.
   * @param star - Whether to make the conversation starred.
   */
  async handleStar(t, e) {
    await this.starConversationMutation?.mutate({ appId: t, star: e });
  }
  /**
   * Sets a conversation as pinned.
   *
   * @param appId - The id of the conversation to pin.
   * @param pin - Whether to make the conversation pinned.
   */
  async handlePin(t, e) {
    await this.pinConversationMutation?.mutate({ appId: t, pin: e });
  }
  /**
   * Leave a conversation (for the current user).
   *
   * @param appId - The id of the conversation to leave.
   */
  async handleLeaveConversation(t) {
    this.conversationId === t && this.selectConversation(null);
    const e = await this.whenUser();
    await this.leaveConversationMutation?.mutate({ appId: t, members: [e.id] }), this.conversationsQuery.result.refetch();
  }
  /**
   * Remove a conversation.
   *
   * @param appId - The id of the conversation to remove.
   */
  async handleRemoveConversation(t) {
    this.conversationId === t && this.selectConversation(null), await this.removeConversationMutation?.mutate({ appId: t }), this.conversationsQuery.result.refetch();
  }
  /**
   * Trash a conversation.
   *
   * @param appId - The id of the conversation to trash.
   */
  async handleTrashConversation(t) {
    this.conversationId === t && this.selectConversation(null), await this.trashConversationMutation?.mutate({ appId: t }), this.conversationsQuery.result.refetch();
  }
  async willUpdate(t) {
    var e;
    super.willUpdate(t), (t.has("weavy") || t.has("conversationTypes")) && this.weavy && (await this.conversationsQuery.trackInfiniteQuery(
      nI(
        this.weavy,
        {},
        this.conversationTypes,
        this.agent,
        () => this.searchText,
        "pinned_at desc,rev desc",
        !1
      )
    ), this.markConversationMutation = b4(this.weavy), this.starConversationMutation = sD(this.weavy), this.pinConversationMutation = nD(this.weavy), this.leaveConversationMutation = $4(this.weavy), this.removeConversationMutation = aD(this.weavy), this.trashConversationMutation = cD(this.weavy), (e = J9(this, hh)) == null || e.call(this), this.weavy.subscribe(null, "app_created", this.handleRefresh), this.weavy.subscribe(null, "message_created", this.handleRefresh), this.weavy.subscribe(null, "member_added", this.handleRefresh), this.weavy.subscribe(null, "online", this.handlePresenceChange), t8(this, hh, () => {
      this.weavy?.unsubscribe(null, "app_created", this.handleRefresh), this.weavy?.unsubscribe(null, "message_created", this.handleRefresh), this.weavy?.unsubscribe(null, "member_added", this.handleRefresh), this.weavy?.unsubscribe(null, "online", this.handlePresenceChange), t8(this, hh, void 0);
    }));
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.conversationsQuery.result, this.pagerRef.value);
  }
  async updated(t) {
    t.has("searchText") && t.get("searchText") !== void 0 && this.conversationsQuery.result && await this.conversationsQuery.result.refetch?.();
  }
  renderConversations(t) {
    if (t) {
      const e = ys(t);
      return qi(
        e,
        (i) => i?.id,
        (i) => [
          v`<wy-conversation-item
              conversationId=${i?.id}
              .avatarUrl=${i?.avatar_url}
              .hideAvatar=${!!this.agent}
              .name=${i.name}
              .lastMessage=${i.last_message}
              .members=${i.members}
              .unread=${i.is_unread}
              .starred=${i.is_starred}
              .pinned=${i.is_pinned}
              .type=${i.type}
              .selected=${this.conversationId == i.id}
              @selected=${() => this.selectConversation(i)}
              @mark=${(r) => this.handleMark(i, r.detail.messageId)}
              @star=${(r) => this.handleStar(r.detail.id, r.detail.star)}
              @pin=${(r) => this.handlePin(r.detail.id, r.detail.pin)}
              @leave=${(r) => this.handleLeaveConversation(r.detail.id)}
              @remove=${(r) => this.handleRemoveConversation(r.detail.id)}
              @trash=${(r) => this.handleTrashConversation(r.detail.id)}
            ></wy-conversation-item>`
        ]
      );
    }
    return C;
  }
  render() {
    const { data: t, isPending: e, hasNextPage: i } = this.conversationsQuery.result ?? {};
    return v`
      <div part="wy-conversations">
        <wy-buttons part="wy-conversations-toolbar" position=${this.agent ? "floating" : "sticky"} ?reverse=${!!this.agent}>
          <slot name="navigation"></slot>
          ${this.agent ? C : v`
                <wy-search
                  compact
                  placeholder=${P("Search for conversations...")}
                  @search=${(r) => this.searchText = r.detail.query}
                ></wy-search>
              `}
          <slot name="actions"></slot>
        </wy-buttons>

        <div part="wy-conversation-list">
          ${!e && this.user && t ? t.pages[0]?.count || this.searchText ? this.renderConversations(t) : v`
                  <div part="wy-pane-body">
                    <div part="wy-pane-group">
                      <wy-empty noNetwork>${P("Create a conversation to get started.")}</wy-empty>
                    </div>
                  </div>
                ` : v`<wy-empty><wy-progress-circular indeterminate padded></wy-progress-circular></wy-empty>`}
          ${i ? v`<div ${ht(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
        </div>
      </div>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = J9(this, hh)) == null || t.call(this), super.disconnectedCallback();
  }
}, h(iy, "gc"), iy), c(gk, "WyConversationList"), gk);
hh = /* @__PURE__ */ new WeakMap();
Qa.styles = [pW, Nl, ft, Ma];
H1([
  b({ type: Number })
], Qa.prototype, "conversationId", 2);
H1([
  b({ type: Array })
], Qa.prototype, "conversationTypes", 2);
H1([
  b()
], Qa.prototype, "agent", 2);
H1([
  N()
], Qa.prototype, "searchText", 2);
Qa = H1([
  Y("wy-conversation-list"),
  At()
], Qa);
var gtt = Object.defineProperty, wtt = Object.getOwnPropertyDescriptor, l2 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? wtt(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && gtt(t, e, r), r;
}, "__decorateClass$2"), wk, ry;
let Ta = (wk = (ry = class extends Ve {
  constructor() {
    super(...arguments), this.componentFeatures = new di(Ey), this.theme = new Ri(this, Ta.styles), this.unreadConversations = new zb(this), this.createConversationController = new Lb(this), this.componentTypes = [xt.ChatRoom, xt.PrivateChat], this.conversationId = null, this.conversationQuery = new Qr(this), this.persistState = new Q1(this), this.conversationNewRef = $t();
  }
  set agent(t) {
    super.agent = t, this._agentUid ? (this.componentTypes = [xt.AgentChat], this.componentFeatures = new di(
      h3,
      this.componentFeatures.allowedFeatures()
    )) : (this.componentTypes = [xt.ChatRoom, xt.PrivateChat], this.componentFeatures = new di(
      Ey,
      this.componentFeatures.allowedFeatures()
    )), this.conversationId = null;
  }
  get agent() {
    return super.agent;
  }
  /** Current unread conversation count. */
  get unread() {
    return this.unreadConversations.unread;
  }
  /**
   * Creates a new conversation.
   *
   * When in agent mode, a conversation is created instantly.
   *
   * @param members - Optional array of member id or member uid.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select member dialog to let the user choose members.
   *
   * @returns Promise resolving to any selected member ids or uids.
   */
  async selectMembers() {
    return await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("weavy") || t.has("agent") || t.has("user")) && this.weavy && this.user && this.persistState.observe(
      [{ name: "conversationId", override: !1 }],
      this.agent || "messenger",
      `u${this.user?.id}`,
      (e) => {
        if (e.has("conversationId") && this.conversationId) {
          const i = new CustomEvent("wy-action", {
            detail: {
              action: Oi.Select,
              app: { id: this.conversationId }
            },
            bubbles: !0,
            composed: !0
          });
          this.dispatchEvent(i);
        }
      }
    ), t.has("agent") && (this.createConversationController.agent = this.agent), t.has("link") && this.link?.app && (this.conversationId = this.link.app.id), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversations.track(this.componentTypes, this.agent);
  }
  render() {
    return v`
      <wy-conversation-list
        .conversationTypes=${this.componentTypes}
        .agent=${this.agent}
        conversationId=${St(this.conversationId !== null ? this.conversationId : void 0)}
        @wy-action=${(t) => {
      !t.defaultPrevented && t.detail.action === Oi.Select && t.detail.app !== void 0 && (this.conversationId = t.detail.app?.id);
    }}
      >
        <wy-conversation-new
          slot="actions"
          .agent=${this.agent}
          @wy-action=${(t) => {
      !t.defaultPrevented && t.detail.action === Oi.Select && t.detail.app !== void 0 && (this.conversationId = t.detail.app?.id);
    }}
          ${ht(this.conversationNewRef)}
        >
          <slot name="conversation-new"></slot>
        </wy-conversation-new>
        <slot name="actions" slot="actions"></slot>
      </wy-conversation-list>
    `;
  }
}, h(ry, "bc"), ry), c(wk, "WyMessengerConversations"), wk);
Ta.styles = [Ie, vn, Ei, ql, Zl];
l2([
  b({ attribute: !1 })
], Ta.prototype, "componentTypes", 2);
l2([
  b({ type: String })
], Ta.prototype, "agent", 1);
l2([
  b({ type: Number })
], Ta.prototype, "conversationId", 2);
Ta = l2([
  Y("wy-messenger-conversations"),
  At()
], Ta);
var vtt = Object.defineProperty, Ott = Object.getOwnPropertyDescriptor, c2 = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? Ott(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = (i ? a(t, e, r) : a(r)) || r);
  return i && r && vtt(t, e, r), r;
}, "__decorateClass$1"), vk, sy;
let _l = (vk = (sy = class extends Xi {
  constructor() {
    super(...arguments), this.exportParts = new rt(this), this._whenMembers = this.createMembersPromise(), this.show = !1;
  }
  /**
   * Resolves when members are selected from the modal.
   *
   * @returns Promise<MemberIdType[]>
   */
  async whenMembers() {
    return this._whenMembers;
  }
  /**
   * Create an internal members promise and store resolve/reject handlers.
   *
   * @internal
   */
  createMembersPromise() {
    const t = new Promise((e, i) => {
      this._resolveMembers = e, this._rejectMembers = i;
    });
    return this._whenMembers = t, t;
  }
  /**
   * Open the new conversation dialog and return selected members.
   *
   * @returns Promise<MemberIdType[]>
   */
  async selectMembers() {
    return this.show = !0, await this.whenMembers();
  }
  /**
   * Close the new conversation dialog and resolve or reject the selection promise.
   *
   * @internal
   * @param members - Optional selected member ids to resolve the promise with.
   */
  close(t) {
    this.show = !1, t ? this._resolveMembers?.(t) : this._rejectMembers?.("Selection aborted by user; no members selected"), this.createMembersPromise();
  }
  /**
   * Create a conversation by dispatching a `create` event and closing the dialog.
   *
   * @param members - Array of members by id/uid for a new conversation.
   */
  async submit(t = []) {
    await this.whenUser(), this.close(t);
    const e = new CustomEvent("create", {
      detail: { members: t }
    });
    this.dispatchEvent(e), this.createMembersPromise();
  }
  render() {
    return v`
      ${this.slotElements.length ? C : v`
            <wy-button
              part="wy-conversation-new-button"
              kind="icon"
              @click=${async () => {
      if (this.agent)
        await this.submit();
      else
        try {
          await this.selectMembers();
        } catch {
        }
    }}
            >
              <wy-icon name="plus"></wy-icon>
            </wy-button>
          `}
      <slot></slot>

      ${!this.agent && this.weavy && this.user ? v`<wy-overlay
            part="wy-conversation-new-dialog"
            .show=${this.show}
            @close=${() => {
      this.show = !1;
    }}
          >
            <wy-titlebar header slot="header">
              <wy-button slot="icon" kind="icon" @click=${() => this.close()}>
                <wy-icon name="close"></wy-icon>
              </wy-button>
              <span slot="title">${P("New conversation")}</span>
            </wy-titlebar>
            ${this.show ? v`
                  <wy-users-search
                    @submit=${(t) => this.submit(t.detail.members.map((e) => e.id))}
                  ></wy-users-search>
                ` : C}
          </wy-overlay>` : C}
    `;
  }
}, h(sy, "xc"), sy), c(vk, "WyConversationNew"), vk);
_l.styles = [ft];
c2([
  b()
], _l.prototype, "agent", 2);
c2([
  N()
], _l.prototype, "show", 2);
c2([
  Dl({ flatten: !0, selector: ":not(slot)" })
], _l.prototype, "slotElements", 2);
_l = c2([
  Y("wy-conversation-new"),
  At()
], _l);
const btt = it`[part~=wy-message-editor-inputs]{display:flex;flex-direction:row;align-items:flex-end;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em))*1.5*var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*2 + var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))*2)}[part~=wy-message-editor-text]{flex:1 1 100%;display:flex;flex-direction:column;margin-inline:var(--wy-padding-sm, calc(.75 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-editor-parts]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));min-height:0}[part~=wy-message-editor] .cm-editor{flex:1 1 100%;max-height:11.25em;background-color:var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:var(--wy-input-filled-border-radius, var(--wy-border-radius-lg, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem)))));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid rgba(0,0,0,0);margin:calc(-1*var(--wy-input-border-width, var(--wy-border, 1px)))}[part~=wy-message-editor] .cm-editor:focus{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-message-editor] .cm-editor.cm-focused{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-message-editor] .cm-editor .cm-content{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)), inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em))*1.5*var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*2 - var(--wy-input-border-width, var(--wy-border, 1px)));line-height:calc(1.5*var(--wy-size, 1rem))}[part~=wy-message-editor] [part~=wy-is-invalid]+[data-editor-target] .cm-editor,[part~=wy-message-editor] [part~=wy-is-invalid] .cm-editor{border-color:var(--wy-error, var(--wy-error-light, #ba1821))!important}`;
var $tt = Object.getOwnPropertyDescriptor, xtt = /* @__PURE__ */ c((s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? $tt(t, e) : t, n = s.length - 1, a; n >= 0; n--)
    (a = s[n]) && (r = a(r) || r);
  return r;
}, "__decorateClass"), Ok, ny;
let D0 = (Ok = (ny = class extends Bt {
  constructor() {
    super(), this.editorType = "messages", this.editorClass = "wy-message-editor";
  }
  /**
   * Render content that appears above the message editor.
   *
   * By default returns the same lists section used by the base editor.
   *
   * @internal
   */
  renderTopSlot() {
    return [
      this.renderLists()
    ];
  }
  /**
   * Render the primary middle slot containing the add-menu, editor and send button.
   *
   * Overrides the base implementation to provide message-specific controls and layout.
   *
   * @internal
   */
  renderMiddleSlot() {
    return v` <div part="wy-message-editor-inputs">
      <!-- Add -->
      ${this.componentFeatures?.allowsAnyFeature(
      L.Attachments,
      L.CloudFiles,
      L.Polls,
      L.Meetings,
      L.ZoomMeetings,
      L.GoogleMeet,
      L.MicrosoftTeams
    ) ? v`<wy-dropdown icon="plus" directionY="up" ?disabled=${this.disabled}>
            ${this.componentFeatures?.allowsFeature(L.Attachments) ? v`
                  <wy-dropdown-item @click=${this.openFileInput} title=${P("From device")}>
                    <wy-icon name="attachment"></wy-icon>
                    <span>${P("From device")}</span>
                  </wy-dropdown-item>
                  <input
                    type="file"
                    ${ht(this.fileInputRef)}
                    @click=${(t) => t.stopPropagation()}
                    @change=${(t) => this.handleUploadFiles(
      Array.from(t.target.files || []),
      t.target
    )}
                    multiple
                    hidden
                    tabindex="-1"
                  />
                ` : C}
            ${this.componentFeatures?.allowsFeature(L.CloudFiles) ? v`
                  <wy-dropdown-item @click=${this.openCloudFiles} title=${P("From cloud")}>
                    <wy-icon name="cloud"></wy-icon>
                    <span>${P("From cloud")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsFeature(L.Polls) ? v`
                  <wy-dropdown-item @click=${() => this.openPolls()} title=${P("Poll")}>
                    <wy-icon name="poll"></wy-icon>
                    <span>${P("Poll")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsAnyFeature(L.Meetings, L.ZoomMeetings) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("zoom")} title=${P("Zoom meeting")}>
                    <wy-icon svg="zoom-meetings"></wy-icon>
                    <span>${P("Zoom meeting")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsAnyFeature(L.Meetings, L.GoogleMeet) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("google")} title=${P("Google Meet")}>
                    <wy-icon svg="google-meet"></wy-icon>
                    <span>${P("Google Meet")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsAnyFeature(L.Meetings, L.MicrosoftTeams) ? v`
                  <wy-dropdown-item
                    @click=${() => this.handleMeetingClick("microsoft")}
                    title=${P("Microsoft Teams")}
                  >
                    <wy-icon svg="microsoft-teams"></wy-icon>
                    <span>${P("Microsoft Teams")}</span>
                  </wy-dropdown-item>
                ` : C}
          </wy-dropdown>` : C}

      <!-- Input -->
      <div part="wy-message-editor-text" ${ht(this.editorRef)}> ${this.renderEditorDummy()} </div>

      <!-- Button -->
      <wy-button
        kind="icon"
        color="primary-text"
        title=${P("Send", { desc: "Button action to send" })}
        @click="${() => this.submit()}"
        ?disabled=${this.disabled}
      >
        <wy-icon name="send"></wy-icon>
      </wy-button>
    </div>`;
  }
  /**
   * Render the bottom slot for message editor with no content.
   *
   * @internal
   */
  renderBottomSlot() {
    return C;
  }
}, h(ny, "Cc"), ny), c(Ok, "WyMessageEditor"), Ok);
D0.styles = [...Bt.styles, btt];
D0 = xtt([
  Y("wy-message-editor"),
  At()
], D0);
const J = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get WyAnnotation() {
    return n1;
  },
  get WyAnnotationList() {
    return a1;
  },
  get WyAttachment() {
    return s1;
  },
  get WyAttachmentList() {
    return Sy;
  },
  get WyAvatar() {
    return gs;
  },
  get WyAvatarGroup() {
    return wl;
  },
  get WyAvatarHeader() {
    return Kw;
  },
  get WyBadge() {
    return dn;
  },
  get WyButton() {
    return or;
  },
  get WyButtons() {
    return vl;
  },
  get WyCloudFiles() {
    return Pl;
  },
  get WyComment() {
    return vs;
  },
  get WyCommentEditor() {
    return z0;
  },
  get WyCommentList() {
    return hn;
  },
  get WyContainer() {
    return ln;
  },
  get WyContextDataProgress() {
    return I0;
  },
  get WyConversation() {
    return Zi;
  },
  get WyConversationHeader() {
    return $s;
  },
  get WyConversationItem() {
    return ui;
  },
  get WyConversationList() {
    return Qa;
  },
  get WyConversationNew() {
    return _l;
  },
  get WyDropdown() {
    return lr;
  },
  get WyDropdownDivider() {
    return R0;
  },
  get WyDropdownItem() {
    return i1;
  },
  get WyDropdownOption() {
    return ky;
  },
  get WyEditor() {
    return Bt;
  },
  get WyEmbed() {
    return Cy;
  },
  get WyEmbedSelect() {
    return o1;
  },
  get WyEmpty() {
    return $y;
  },
  get WyFileGrid() {
    return Ml;
  },
  get WyFileItem() {
    return Os;
  },
  get WyFileMenu() {
    return Cl;
  },
  get WyFileTable() {
    return ka;
  },
  get WyFileVersions() {
    return p1;
  },
  get WyFilesHeader() {
    return xa;
  },
  get WyFilesList() {
    return un;
  },
  get WyIcon() {
    return ge;
  },
  get WyIconDisplay() {
    return Gw;
  },
  get WyIconStack() {
    return P0;
  },
  get WyImageGrid() {
    return bl;
  },
  get WyItem() {
    return Ne;
  },
  get WyItemList() {
    return wa;
  },
  get WyMeetingCard() {
    return l1;
  },
  get WyMessage() {
    return ue;
  },
  get WyMessageEditor() {
    return D0;
  },
  get WyMessageTyping() {
    return xr;
  },
  get WyNotificationHeader() {
    return Al;
  },
  get WyNotificationList() {
    return Ry;
  },
  get WyNotificationListItem() {
    return Ca;
  },
  get WyOverlay() {
    return ba;
  },
  get WyPdfViewer() {
    return Sl;
  },
  get WyPoll() {
    return h1;
  },
  get WyPollOption() {
    return $l;
  },
  get WyPost() {
    return ve;
  },
  get WyPostEdit() {
    return ii;
  },
  get WyPostList() {
    return f1;
  },
  get WyPostTrashed() {
    return My;
  },
  get WyPostView() {
    return ce;
  },
  get WyPresence() {
    return by;
  },
  get WyPreview() {
    return we;
  },
  get WyPreviewEmbed() {
    return $a;
  },
  get WyPreviewIcon() {
    return xl;
  },
  get WyPreviewImage() {
    return kl;
  },
  get WyPreviewItem() {
    return Qy;
  },
  get WyPreviewMedia() {
    return cn;
  },
  get WyPreviewText() {
    return ws;
  },
  get WyProgressCircular() {
    return Fr;
  },
  get WyProgressLinear() {
    return Cr;
  },
  get WyReactionItem() {
    return d1;
  },
  get WyReactions() {
    return Ce;
  },
  get WySearch() {
    return El;
  },
  get WySkeleton() {
    return r1;
  },
  get WyTitlebar() {
    return on;
  },
  get WyTitlebarText() {
    return c1;
  },
  get WyToast() {
    return pn;
  },
  get WyToasts() {
    return m1;
  },
  get WyTyping() {
    return Ly;
  },
  get WyUpload() {
    return _y;
  },
  get WyUsersSearch() {
    return Zr;
  }
}, Symbol.toStringTag, { value: "Module" }));
_e.version = "1.0.0";
_e.sourceName = "@weavy/uikit-react";
const ktt = VW(null);
function cit(s, t = []) {
  const [e, i] = q3(), r = {
    ...s,
    cloudFilePickerUrl: s.cloudFilePickerUrl?.toString(),
    locales: Z3(() => s.locales, [s.locales?.length]),
    tokenUrl: s.tokenUrl?.toString(),
    tokenFactory: Z3(
      () => s.tokenFactory,
      [s.tokenFactory?.toString(), ...t]
    ),
    url: s.url?.toString()
  }, [n, a] = q3(r);
  return bk(() => {
    if (!e) {
      const l = Uc?.value ?? new Re(r);
      i(l);
    }
  }, []), bk(() => {
    if (e && !e.isDestroyed) {
      const o = {};
      Object.entries(r).forEach(([l, d]) => {
        d !== n[l] && Object.assign(o, { [l]: d });
      }), Object.keys(o).length && (a(r), Object.assign(e, o));
    }
  }, [r]), e;
}
h(cit, "useWeavy");
const wW = Promise.resolve(), f3 = class f3 {
  constructor(t, e) {
    this.o = [], this.t = !0, this.i = !1, this.l = t, this.h = e, this.u = new Promise(((i, r) => {
      this.p = i;
    }));
  }
  addController(t) {
    this.o.push(t);
  }
  removeController(t) {
    this.o?.splice(this.o.indexOf(t) >>> 0, 1);
  }
  requestUpdate() {
    this.t || (this.t = !0, wW.then((() => this.h(++this.l))));
  }
  get updateComplete() {
    return this.u;
  }
  m() {
    this.i = !0, this.o.forEach(((t) => t.hostConnected?.()));
  }
  _() {
    this.i = !1, this.o.forEach(((t) => t.hostDisconnected?.()));
  }
  v() {
    this.o.forEach(((t) => t.hostUpdate?.()));
  }
  C() {
    this.t = !1;
    const t = this.p;
    this.u = new Promise(((e, i) => {
      this.p = e;
    })), this.o.forEach(((e) => e.hostUpdated?.())), t(this.t);
  }
};
h(f3, "s");
let ZS = f3;
const Stt = /* @__PURE__ */ h((s, t) => {
  const { useState: e, useLayoutEffect: i } = s, [r, n] = e(0);
  let a = !1;
  const [o] = e((() => {
    const l = new ZS(r, n), d = t(l);
    return l.M = d, l.m(), a = !0, wW.then((() => {
      a && l._();
    })), l;
  }));
  return o.t = !0, i((() => (a = !1, o.i || o.m(), () => o._())), []), i((() => o.C())), o.v(), o.M;
}, "e$1");
function Ctt(s, t) {
  const e = (typeof s == "function" ? s() : s && "current" in s ? s.current : s) || void 0, i = Stt(
    j,
    (r) => new iU(r, t ?? De, e)
  );
  return bk(() => {
    e && i.setRef(e);
  }, [i, e]), i.context?.value;
}
h(Ctt, "useWeavyContext");
const Ptt = /* @__PURE__ */ new Set(["children", "localName", "ref", "style", "className"]), e8 = /* @__PURE__ */ new WeakMap(), i8 = /* @__PURE__ */ h((s, t, e, i, r) => {
  const n = r?.[t];
  n === void 0 ? (s[t] = e, e == null && t in HTMLElement.prototype && s.removeAttribute(t)) : e !== i && ((a, o, l) => {
    let d = e8.get(a);
    d === void 0 && e8.set(a, d = /* @__PURE__ */ new Map());
    let u = d.get(o);
    l !== void 0 ? u === void 0 ? (d.set(o, u = { handleEvent: l }), a.addEventListener(o, u)) : u.handleEvent = l : u !== void 0 && (d.delete(o), a.removeEventListener(o, u));
  })(s, n, e);
}, "t"), U = /* @__PURE__ */ h(({ react: s, tagName: t, elementClass: e, events: i, displayName: r }) => {
  const n = new Set(Object.keys(i ?? {})), a = s.forwardRef(((o, l) => {
    const d = s.useRef(/* @__PURE__ */ new Map()), u = s.useRef(null), p = {}, f = {};
    for (const [y, g] of Object.entries(o)) Ptt.has(y) ? p[y === "className" ? "class" : y] = g : n.has(y) || y in e.prototype ? f[y] = g : p[y] = g;
    return s.useLayoutEffect((() => {
      if (u.current === null) return;
      const y = /* @__PURE__ */ new Map();
      for (const g in f) i8(u.current, g, o[g], d.current.get(g), i), d.current.delete(g), y.set(g, o[g]);
      for (const [g, O] of d.current) i8(u.current, g, void 0, O, i);
      d.current = y;
    })), s.useLayoutEffect((() => {
      u.current?.removeAttribute("defer-hydration");
    }), []), p.suppressHydrationWarning = !0, s.createElement(t, { ...p, ref: s.useCallback(((y) => {
      u.current = y, typeof l == "function" ? l(y) : l !== null && (l.current = y);
    }), [l]) });
  }));
  return a.displayName = r ?? e.name, a;
}, "o"), Oe = "wy-action", Hi = "wy-app", h2 = "wy-link", vW = "wy-message", OW = "wy-notification", pi = "wy-preview-open", fi = "wy-preview-close", za = "wy-unread", Qtt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  onWyAction: Oe,
  onWyApp: Hi,
  onWyLink: h2,
  onWyMessage: vW,
  onWyNotification: OW,
  onWyPreviewClose: fi,
  onWyPreviewOpen: pi,
  onWyUnread: za
}, Symbol.toStringTag, { value: "Module" })), hit = U({
  react: j,
  tagName: "wy-chat",
  elementClass: Ql,
  events: {
    onWyApp: Hi,
    onWyAction: Oe,
    onWyPreviewOpen: pi,
    onWyPreviewClose: fi
  }
}), dit = U({
  react: j,
  tagName: "wy-comments",
  elementClass: Ty,
  events: {
    onWyApp: Hi,
    onWyAction: Oe,
    onWyPreviewOpen: pi,
    onWyPreviewClose: fi
  }
}), uit = U({
  react: j,
  tagName: "wy-component",
  elementClass: yl,
  events: {
    ...Qtt
  }
}), Ttt = U({
  react: j,
  tagName: "wy-context",
  elementClass: ye
});
function pit({
  children: s,
  ...t
}) {
  const e = WW(null), i = Ctt(() => e.current);
  return /* @__PURE__ */ j.createElement(Ttt, { ref: e, ...t }, /* @__PURE__ */ j.createElement(ktt.Provider, { value: i ?? null }, s));
}
h(pit, "WyContext");
const fit = U({
  react: j,
  tagName: "wy-copilot",
  elementClass: Tl,
  events: {
    onWyApp: Hi,
    onWyAction: Oe,
    onWyMessage: vW,
    onWyPreviewOpen: pi,
    onWyPreviewClose: fi
  }
}), mit = U({
  react: j,
  tagName: "wy-files",
  elementClass: Sa,
  events: {
    onWyApp: Hi,
    onWyAction: Oe,
    onWyPreviewOpen: pi,
    onWyPreviewClose: fi
  }
}), yit = U({
  react: j,
  tagName: "wy-messenger",
  elementClass: xs,
  events: {
    onWyAction: Oe,
    onWyApp: Hi,
    onWyPreviewOpen: pi,
    onWyPreviewClose: fi,
    onWyUnread: za
  }
}), git = U({
  react: j,
  tagName: "wy-messenger-badge",
  elementClass: fn,
  events: {
    onWyUnread: za
  }
}), wit = U({
  react: j,
  tagName: "wy-messenger-button",
  elementClass: Ai,
  events: {
    onWyAction: Oe,
    onWyApp: Hi,
    onWyPreviewOpen: pi,
    onWyPreviewClose: fi,
    onWyUnread: za
  }
}), vit = U({
  react: j,
  tagName: "wy-messenger-conversations",
  elementClass: Ta,
  events: {
    onWyAction: Oe,
    onWyApp: Hi,
    onWyUnread: za
  }
}), Oit = U({
  react: j,
  tagName: "wy-messenger-new",
  elementClass: y1,
  events: {
    onWyApp: Hi
  }
}), bit = U({
  react: j,
  tagName: "wy-notifications",
  elementClass: Rl,
  events: {
    onWyAction: Oe,
    onWyApp: Hi,
    onWyLink: h2,
    onWyUnread: za
  }
}), $it = U({
  react: j,
  tagName: "wy-notification-badge",
  elementClass: Pa,
  events: {
    onWyApp: Hi,
    onWyUnread: za
  }
}), xit = U({
  react: j,
  tagName: "wy-notification-button",
  elementClass: Pr,
  events: {
    onWyAction: Oe,
    onWyApp: Hi,
    onWyLink: h2,
    onWyUnread: za
  }
}), kit = U({
  react: j,
  tagName: "wy-notification-toasts",
  elementClass: bs,
  events: {
    onWyApp: Hi,
    onWyLink: h2,
    onWyNotification: OW
  }
}), Sit = U({
  react: j,
  tagName: "wy-posts",
  elementClass: Ay,
  events: {
    onWyAction: Oe,
    onWyApp: Hi,
    onWyPreviewOpen: pi,
    onWyPreviewClose: fi
  }
}), Mtt = U({
  react: j,
  tagName: "wy-avatar",
  elementClass: J.WyAvatar
}), Att = U({
  react: j,
  tagName: "wy-avatar-group",
  elementClass: J.WyAvatarGroup
}), Rtt = U({
  react: j,
  tagName: "wy-avatar-header",
  elementClass: J.WyAvatarHeader
}), Ett = U({
  react: j,
  tagName: "wy-button",
  elementClass: J.WyButton
}), _tt = U({
  react: j,
  tagName: "wy-buttons",
  elementClass: J.WyButtons
}), Ltt = U({
  react: j,
  tagName: "wy-badge",
  elementClass: J.WyBadge
}), ztt = U({
  react: j,
  tagName: "wy-dropdown",
  elementClass: J.WyDropdown
}), Itt = U({
  react: j,
  tagName: "wy-dropdown-item",
  elementClass: J.WyDropdownItem
}), Dtt = U({
  react: j,
  tagName: "wy-dropdown-option",
  elementClass: J.WyDropdownOption
}), Vtt = U({
  react: j,
  tagName: "wy-dropdown-divider",
  elementClass: J.WyDropdownDivider
}), Wtt = U({
  react: j,
  tagName: "wy-icon",
  elementClass: J.WyIcon
}), Ftt = U({
  react: j,
  tagName: "wy-icon-stack",
  elementClass: J.WyIconStack
}), qtt = U({
  react: j,
  tagName: "wy-icon-display",
  elementClass: J.WyIconDisplay
}), Ztt = U({
  react: j,
  tagName: "wy-image-grid",
  elementClass: J.WyImageGrid,
  events: {
    onFileOpen: "file-open"
  }
}), Btt = U({
  react: j,
  tagName: "wy-item",
  elementClass: J.WyItem
}), Ntt = U({
  react: j,
  tagName: "wy-item-list",
  elementClass: J.WyItemList
}), Xtt = U({
  react: j,
  tagName: "wy-overlay",
  elementClass: J.WyOverlay,
  events: {
    onClose: "close"
  }
}), jtt = U({
  react: j,
  tagName: "wy-presence",
  elementClass: J.WyPresence
}), Utt = U({
  react: j,
  tagName: "wy-progress-circular",
  elementClass: J.WyProgressCircular
}), Htt = U({
  react: j,
  tagName: "wy-progress-linear",
  elementClass: J.WyProgressLinear
}), Ytt = U({
  react: j,
  tagName: "wy-search",
  elementClass: J.WySearch,
  events: {
    onSearch: "search"
  }
}), Gtt = U({
  react: j,
  tagName: "wy-container",
  elementClass: J.WyContainer
}), Ktt = U({
  react: j,
  tagName: "wy-skeleton",
  elementClass: J.WySkeleton
}), Jtt = U({
  react: j,
  tagName: "wy-titlebar",
  elementClass: J.WyTitlebar
}), tet = U({
  react: j,
  tagName: "wy-titlebar-text",
  elementClass: J.WyTitlebarText
}), eet = U({
  react: j,
  tagName: "wy-toasts",
  elementClass: J.WyToasts,
  events: {
    onHide: "hide"
  }
}), iet = U({
  react: j,
  tagName: "wy-toast",
  elementClass: J.WyToast,
  events: {
    onClosed: "closed"
  }
}), ret = U({
  react: j,
  tagName: "wy-annotation",
  elementClass: J.WyAnnotation
}), set = U({
  react: j,
  tagName: "wy-annotation-list",
  elementClass: J.WyAnnotationList,
  events: {
    onFileOpen: "file-open"
  }
}), net = U({
  react: j,
  tagName: "wy-attachment",
  elementClass: J.WyAttachment,
  events: {
    onFileOpen: "file-open"
  }
}), aet = U({
  react: j,
  tagName: "wy-attachment-list",
  elementClass: J.WyAttachmentList,
  events: {
    onFileOpen: "file-open"
  }
}), oet = U({
  react: j,
  tagName: "wy-upload",
  elementClass: J.WyUpload,
  events: {
    onBlobUploaded: "blob-uploaded"
  }
}), cet = U({
  react: j,
  tagName: "wy-cloud-files",
  elementClass: J.WyCloudFiles,
  events: {
    onExternalBlobs: "external-blobs"
  }
}), het = U({
  react: j,
  tagName: "wy-comment-list",
  elementClass: J.WyCommentList,
  events: {
    onWyPreviewOpen: pi,
    onWyPreviewClose: fi
  }
}), det = U({
  react: j,
  tagName: "wy-comment",
  elementClass: J.WyComment,
  events: {
    onVote: "vote",
    onTrash: "trash",
    onRestore: "restore",
    onWyPreviewOpen: pi,
    onWyPreviewClose: fi
  }
}), uet = U({
  react: j,
  tagName: "wy-context-data-progress",
  elementClass: J.WyContextDataProgress
}), pet = U({
  react: j,
  tagName: "wy-conversation",
  elementClass: J.WyConversation,
  events: {
    onWyAction: Oe,
    onWyPreviewOpen: pi,
    onWyPreviewClose: fi
  }
}), fet = U({
  react: j,
  tagName: "wy-conversation-header",
  elementClass: J.WyConversationHeader,
  events: {
    onWyAction: Oe
  }
}), met = U({
  react: j,
  tagName: "wy-conversation-new",
  elementClass: J.WyConversationNew,
  events: {
    onSelected: "create"
  }
}), yet = U({
  react: j,
  tagName: "wy-conversation-list",
  elementClass: J.WyConversationList,
  events: {
    onWyAction: Oe
  }
}), get = U({
  react: j,
  tagName: "wy-conversation-item",
  elementClass: J.WyConversationItem,
  events: {
    onSelected: "selected",
    onStar: "star",
    onPin: "pin",
    onMark: "mark",
    onLeave: "leave",
    onRemove: "remove",
    onTrash: "trash"
  }
}), wet = U({
  react: j,
  tagName: "wy-editor",
  elementClass: J.WyEditor,
  events: {
    onSubmit: "submit"
  }
}), vet = U({
  react: j,
  tagName: "wy-comment-editor",
  elementClass: J.WyCommentEditor,
  events: {
    onSubmit: "submit"
  }
}), Oet = U({
  react: j,
  tagName: "wy-message-editor",
  elementClass: J.WyMessageEditor,
  events: {
    onSubmit: "submit"
  }
}), bet = U({
  react: j,
  tagName: "wy-embed",
  elementClass: J.WyEmbed,
  events: {
    onWyAction: Oe
  }
}), $et = U({
  react: j,
  tagName: "wy-embed-select",
  elementClass: J.WyEmbedSelect,
  events: {
    onEmbedRemove: "embed-remove",
    onEmbedSwap: "embed-swap"
  }
}), xet = U({
  react: j,
  tagName: "wy-empty",
  elementClass: J.WyEmpty
}), ket = U({
  react: j,
  tagName: "wy-file-grid",
  elementClass: J.WyFileGrid,
  events: {
    onFileOpen: "file-open",
    onOrder: "order",
    onEditName: "edit-name",
    onRename: "rename",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever",
    onSubscribe: "subscribe"
  }
}), Cet = U({
  react: j,
  tagName: "wy-file-item",
  elementClass: J.WyFileItem,
  events: {
    onEditName: "edit-name",
    onRename: "rename",
    onSubscribe: "subscribe",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever"
  }
}), Pet = U({
  react: j,
  tagName: "wy-file-menu",
  elementClass: J.WyFileMenu,
  events: {
    onEditName: "edit-name",
    onSubscribe: "subscribe",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever"
  }
}), Qet = U({
  react: j,
  tagName: "wy-file-table",
  elementClass: J.WyFileTable,
  events: {
    onFileOpen: "file-open",
    onOrder: "order",
    onEditName: "edit-name",
    onRename: "rename",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever",
    onSubscribe: "subscribe"
  }
}), Tet = U({
  react: j,
  tagName: "wy-file-versions",
  elementClass: J.WyFileVersions,
  events: {
    onFileVersionSelect: "file-version-select"
  }
}), Met = U({
  react: j,
  tagName: "wy-files-header",
  elementClass: J.WyFilesHeader,
  events: {
    onUploadFiles: "upload-files",
    onExternalBlobs: "external-blobs",
    onCreateFiles: "create-files",
    onOrder: "order",
    onView: "view",
    onShowTrashed: "show-trashed",
    onSubscribe: "subscribe"
  }
}), Aet = U({
  react: j,
  tagName: "wy-files-list",
  elementClass: J.WyFilesList,
  events: {
    onFileOpen: "file-open",
    onOrder: "order",
    onEditName: "edit-name",
    onRename: "rename",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever",
    onSubscribe: "subscribe",
    onWyAction: Oe,
    onWyPreviewOpen: pi,
    onWyPreviewClose: fi
  }
}), Ret = U({
  react: j,
  tagName: "wy-meeting-card",
  elementClass: J.WyMeetingCard
}), Eet = "vote", _et = "typing", Let = U({
  react: j,
  tagName: "wy-message",
  elementClass: J.WyMessage,
  events: {
    onVote: Eet,
    onWyAction: Oe,
    onWyPreviewOpen: pi,
    onWyPreviewClose: fi
  }
}), zet = U({
  react: j,
  tagName: "wy-message-typing",
  elementClass: J.WyMessageTyping,
  events: {
    onTyping: _et
  }
}), Iet = U({
  react: j,
  tagName: "wy-notification-list",
  elementClass: J.WyNotificationList,
  events: {
    onWyAction: Oe
  }
}), Det = U({
  react: j,
  tagName: "wy-notification-header",
  elementClass: J.WyNotificationHeader
}), Vet = U({
  react: j,
  tagName: "wy-notification-list-item",
  elementClass: J.WyNotificationListItem,
  events: {
    onSelect: "select",
    onMark: "mark",
    onHide: "hide",
    onClose: "close"
  }
}), Wet = U({
  react: j,
  tagName: "wy-pdf-viewer",
  elementClass: J.WyPdfViewer,
  events: {
    onFilePreviewLoaded: "file-preview-loaded"
  }
}), Fet = U({
  react: j,
  tagName: "wy-poll",
  elementClass: J.WyPoll,
  events: {
    onVote: "vote"
  }
}), qet = U({
  react: j,
  tagName: "wy-poll-option",
  elementClass: J.WyPollOption,
  events: {
    onVote: "vote"
  }
}), p3 = "edit", bW = "vote", $W = "subscribe", xW = "trash", kW = "restore", Zet = U({
  react: j,
  tagName: "wy-post-list",
  elementClass: J.WyPostList,
  events: {
    onEdit: p3,
    onWyAction: Oe,
    onWyPreviewOpen: pi,
    onWyPreviewClose: fi
  }
}), Bet = U({
  react: j,
  tagName: "wy-post",
  elementClass: J.WyPost,
  events: {
    onVote: bW,
    onSubscribe: $W,
    onTrash: xW,
    onRestore: kW,
    onWyAction: Oe,
    onWyPreviewOpen: pi,
    onWyPreviewClose: fi
  }
}), Net = U({
  react: j,
  tagName: "wy-post-view",
  elementClass: J.WyPostView,
  events: {
    onVote: bW,
    onSubscribe: $W,
    onTrash: xW,
    onEdit: p3,
    onWyAction: Oe,
    onWyPreviewOpen: pi,
    onWyPreviewClose: fi
  }
}), Xet = U({
  react: j,
  tagName: "wy-post-edit",
  elementClass: J.WyPostEdit,
  events: {
    onEdit: p3
  }
}), jet = U({
  react: j,
  tagName: "wy-post-trashed",
  elementClass: J.WyPostTrashed,
  events: {
    onRestore: kW
  }
}), tg = "file-preview-loaded", Uet = U({
  react: j,
  tagName: "wy-preview",
  elementClass: J.WyPreview,
  events: {
    onWyPreviewOpen: pi,
    onWyPreviewClose: fi,
    onWyAction: Oe
  }
}), Het = U({
  react: j,
  tagName: "wy-preview-embed",
  elementClass: J.WyPreviewEmbed,
  events: {
    onFilePreviewLoaded: tg
  }
}), Yet = U({
  react: j,
  tagName: "wy-preview-icon",
  elementClass: J.WyPreviewIcon,
  events: {
    onFilePreviewLoaded: tg
  }
}), Get = U({
  react: j,
  tagName: "wy-preview-image",
  elementClass: J.WyPreviewImage,
  events: {
    onFilePreviewLoaded: tg
  }
}), Ket = U({
  react: j,
  tagName: "wy-preview-item",
  elementClass: J.WyPreviewItem,
  events: {
    onFilePreviewLoaded: tg
  }
}), Jet = U({
  react: j,
  tagName: "wy-preview-media",
  elementClass: J.WyPreviewMedia,
  events: {
    onFilePreviewLoaded: tg
  }
}), tit = U({
  react: j,
  tagName: "wy-preview-text",
  elementClass: J.WyPreviewText,
  events: {
    onFilePreviewLoaded: tg
  }
}), eit = "close", iit = U({
  react: j,
  tagName: "wy-reactions",
  elementClass: J.WyReactions,
  events: {
    onClose: eit
  }
}), rit = U({
  react: j,
  tagName: "wy-reaction-item",
  elementClass: J.WyReactionItem
}), sit = U({
  react: j,
  tagName: "wy-typing",
  elementClass: J.WyTyping
}), nit = U({
  react: j,
  tagName: "wy-users-search",
  elementClass: J.WyUsersSearch,
  events: {
    onSubmit: "submit"
  }
}), Cit = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  WyAnnotation: ret,
  WyAnnotationList: set,
  WyAttachment: net,
  WyAttachmentList: aet,
  WyAvatar: Mtt,
  WyAvatarGroup: Att,
  WyAvatarHeader: Rtt,
  WyBadge: Ltt,
  WyButton: Ett,
  WyButtons: _tt,
  WyCloudFiles: cet,
  WyComment: det,
  WyCommentEditor: vet,
  WyCommentList: het,
  WyContainer: Gtt,
  WyContextDataProgress: uet,
  WyConversation: pet,
  WyConversationAppbar: fet,
  WyConversationItem: get,
  WyConversationList: yet,
  WyConversationNew: met,
  WyDropdown: ztt,
  WyDropdownDivider: Vtt,
  WyDropdownItem: Itt,
  WyDropdownOption: Dtt,
  WyEditor: wet,
  WyEmbed: bet,
  WyEmbedSelect: $et,
  WyEmpty: xet,
  WyFileGrid: ket,
  WyFileItem: Cet,
  WyFileMenu: Pet,
  WyFileTable: Qet,
  WyFileVersions: Tet,
  WyFilesHeader: Met,
  WyFilesList: Aet,
  WyIcon: Wtt,
  WyIconDisplay: qtt,
  WyIconStack: Ftt,
  WyImageGrid: Ztt,
  WyItem: Btt,
  WyItemList: Ntt,
  WyMeetingCard: Ret,
  WyMessage: Let,
  WyMessageEditor: Oet,
  WyMessageTyping: zet,
  WyNotificationHeader: Det,
  WyNotificationList: Iet,
  WyNotificationListitem: Vet,
  WyOverlay: Xtt,
  WyPdfViewer: Wet,
  WyPoll: Fet,
  WyPollOption: qet,
  WyPost: Bet,
  WyPostEdit: Xet,
  WyPostList: Zet,
  WyPostTrashed: jet,
  WyPostView: Net,
  WyPresence: jtt,
  WyPreview: Uet,
  WyPreviewEmbed: Het,
  WyPreviewIcon: Yet,
  WyPreviewImage: Get,
  WyPreviewItem: Ket,
  WyPreviewMedia: Jet,
  WyPreviewText: tit,
  WyProgressCircular: Utt,
  WyProgressLinear: Htt,
  WyReactionItem: rit,
  WyReactions: iit,
  WySearch: Ytt,
  WySkeleton: Ktt,
  WyTitlebar: Jtt,
  WyTitlebarText: tet,
  WyToast: iet,
  WyToasts: eet,
  WyTyping: sit,
  WyUpload: oet,
  WyUsersSearch: nit
}, Symbol.toStringTag, { value: "Module" }));
export {
  dU as AppTypeGuids,
  uU as AppTypeStrings,
  L as Feature,
  lit as MessengerTypes,
  Re as Weavy,
  Cit as WeavyComponents,
  ktt as WeavyContext,
  hit as WyChat,
  dit as WyComments,
  uit as WyComponent,
  pit as WyContext,
  fit as WyCopilot,
  mit as WyFiles,
  yit as WyMessenger,
  git as WyMessengerBadge,
  wit as WyMessengerButton,
  vit as WyMessengerConversations,
  Oit as WyMessengerNew,
  $it as WyNotificationBadge,
  xit as WyNotificationButton,
  kit as WyNotificationToasts,
  bit as WyNotifications,
  Sit as WyPosts,
  cit as useWeavy,
  Ctt as useWeavyContext
};
