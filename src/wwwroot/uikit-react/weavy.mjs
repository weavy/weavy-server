"use client";
var yD = Object.defineProperty;
var c = (n, t) => yD(n, "name", { value: t, configurable: !0 });
import N, { createContext as mD, useState as M3, useMemo as A3, useEffect as ok, useRef as gD } from "react";
var wD = Object.defineProperty, f = /* @__PURE__ */ c((n, t) => wD(n, "name", { value: t, configurable: !0 }), "f");
const PS = /* @__PURE__ */ f((n) => {
  n && requestAnimationFrame(() => n?.focus?.());
}, "autofocusRef");
async function gs(n, t = "wy-") {
  const e = [];
  for (let i = n; i = i.parentElement; )
    i.matches(":not(:defined)") && i.localName.startsWith(t) && e.push(customElements.whenDefined(i.localName));
  await Promise.all(e);
}
c(gs, "yx$1");
f(gs, "whenParentsDefined");
const X9 = /* @__PURE__ */ f((n, t) => {
  let e;
  const i = new ResizeObserver(() => {
    const { isConnected: s } = n;
    s !== e && (e = s, t(s, n));
  });
  return i.observe(n), i;
}, "observeConnected");
async function QS(n, t = !0) {
  if (n.isConnected === t)
    return t;
  {
    let e;
    const i = new Promise((r) => e = r), s = X9(n, (r) => {
      r === t && e?.(t);
    });
    return await i, s.disconnect(), t;
  }
}
c(QS, "Sx$1");
f(QS, "whenConnected");
async function N9() {
  we(), document.hidden && await new Promise((n) => {
    window.addEventListener(
      "visibilitychange",
      () => {
        document.hidden || n(!0);
      },
      { once: !0 }
    );
  });
}
c(N9, "bx$1");
f(N9, "whenDocumentVisible");
const TS = {
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  /* @ts-ignore */
  opacityProperty: !0,
  visibilityProperty: !0,
  // Legacy compatibility
  checkOpacity: !0,
  checkVisibilityCSS: !0
};
function MS(n, t = !0, e = TS, i) {
  n.checkVisibility(e) === t ? i(t) : requestAnimationFrame(() => MS(n, t, e, i));
}
c(MS, "td$1");
f(MS, "untilVisibility");
async function rO(n, t = !0, e = TS) {
  n.checkVisibility(e) !== t && await new Promise((i) => {
    MS(n, t, e, i);
  });
}
c(rO, "wx$1");
f(rO, "whenElementVisible");
function a1(n) {
  return n.ctrlKey || n.metaKey || n.button === 1;
}
c(a1, "xx$1");
f(a1, "isModifiedClick");
function lk(n) {
  return n.getRootNode() instanceof ShadowRoot;
}
c(lk, "kx$1");
f(lk, "isInShadowDom");
function aO() {
  return !!(document.body?.showPopover && !/native code/i.test(document.body.showPopover.toString()));
}
c(aO, "Px$1");
f(aO, "isPopoverPolyfilled");
function Qb() {
  return typeof window < "u";
}
c(Qb, "$x$1");
f(Qb, "isDomAvailable");
function we() {
  if (typeof window > "u")
    throw Error("DOM not available");
}
c(we, "ah$1");
f(we, "throwOnDomNotAvailable");
function j9(n, t) {
  if (we(), n) {
    for (let e = n; e = e.parentElement || e.parentNode || e.host; )
      if (e instanceof Element && t(e))
        return e;
  }
}
c(j9, "Eg$1");
f(j9, "getParent");
function B9(n) {
  return j9(n, (t) => {
    const e = getComputedStyle(t);
    return !!(t instanceof HTMLElement && (t.localName === "wy-overlay" || t.popover || e.position === "fixed" || // @ts-expect-error overlay not in CSSStyleDeclaration
    e.overlay === "auto"));
  });
}
c(B9, "Rx$1");
f(B9, "inOverlay");
let ck = [], U9 = [];
(() => {
  let n = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t) => t ? parseInt(t, 36) : 1);
  for (let t = 0, e = 0; t < n.length; t++)
    (t % 2 ? U9 : ck).push(e = e + n[t]);
})();
function H9(n) {
  if (n < 768) return !1;
  for (let t = 0, e = ck.length; ; ) {
    let i = t + e >> 1;
    if (n < ck[i]) e = i;
    else if (n >= U9[i]) t = i + 1;
    else return !0;
    if (t == e) return !1;
  }
}
c(H9, "Yg$1");
f(H9, "isExtendingChar");
function hk(n) {
  return n >= 127462 && n <= 127487;
}
c(hk, "Jc$1");
f(hk, "isRegionalIndicator");
const R3 = 8205;
function Y9(n, t, e = !0, i = !0) {
  return (e ? AS : G9)(n, t, i);
}
c(Y9, "Wg$1");
f(Y9, "findClusterBreak$1");
function AS(n, t, e) {
  if (t == n.length) return t;
  t && RS(n.charCodeAt(t)) && ES(n.charCodeAt(t - 1)) && t--;
  let i = pv(n, t);
  for (t += dk(i); t < n.length; ) {
    let s = pv(n, t);
    if (i == R3 || s == R3 || e && H9(s))
      t += dk(s), i = s;
    else if (hk(s)) {
      let r = 0, a = t - 2;
      for (; a >= 0 && hk(pv(n, a)); )
        r++, a -= 2;
      if (r % 2 == 0) break;
      t += 2;
    } else
      break;
  }
  return t;
}
c(AS, "rd$1");
f(AS, "nextClusterBreak");
function G9(n, t, e) {
  for (; t > 0; ) {
    let i = AS(n, t - 2, e);
    if (i < t) return i;
    t--;
  }
  return 0;
}
c(G9, "Vg$1");
f(G9, "prevClusterBreak");
function pv(n, t) {
  let e = n.charCodeAt(t);
  if (!ES(e) || t + 1 == n.length) return e;
  let i = n.charCodeAt(t + 1);
  return RS(i) ? (e - 55296 << 10) + (i - 56320) + 65536 : e;
}
c(pv, "Ro$1");
f(pv, "codePointAt$1");
function RS(n) {
  return n >= 56320 && n < 57344;
}
c(RS, "nd$1");
f(RS, "surrogateLow$1");
function ES(n) {
  return n >= 55296 && n < 56320;
}
c(ES, "sd$1");
f(ES, "surrogateHigh$1");
function dk(n) {
  return n < 65536 ? 1 : 2;
}
c(dk, "tu$1");
f(dk, "codePointSize$1");
var co;
const K9 = (co = class {
  /**
  Get the line description around the given position.
  */
  lineAt(t) {
    if (t < 0 || t > this.length)
      throw new RangeError(`Invalid position ${t} in document of length ${this.length}`);
    return this.lineInner(t, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(t) {
    if (t < 1 || t > this.lines)
      throw new RangeError(`Invalid line number ${t} in ${this.lines}-line document`);
    return this.lineInner(t, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(t, e, i) {
    [t, e] = Go(this, t, e);
    let s = [];
    return this.decompose(
      0,
      t,
      s,
      2
      /* Open.To */
    ), i.length && i.decompose(
      0,
      i.length,
      s,
      3
      /* Open.To */
    ), this.decompose(
      e,
      this.length,
      s,
      1
      /* Open.From */
    ), fv.from(s, this.length - (e - t) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(t) {
    return this.replace(this.length, this.length, t);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(t, e = this.length) {
    [t, e] = Go(this, t, e);
    let i = [];
    return this.decompose(t, e, i, 0), fv.from(i, e - t);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(t) {
    if (t == this)
      return !0;
    if (t.length != this.length || t.lines != this.lines)
      return !1;
    let e = this.scanIdentical(t, 1), i = this.length - this.scanIdentical(t, -1), s = new aw(this), r = new aw(t);
    for (let a = e, o = e; ; ) {
      if (s.next(a), r.next(a), a = 0, s.lineBreak != r.lineBreak || s.done != r.done || s.value != r.value)
        return !1;
      if (o += s.value.length, s.done || o >= i)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(t = 1) {
    return new aw(this, t);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(t, e = this.length) {
    return new s8(this, t, e);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(t, e) {
    let i;
    if (t == null)
      i = this.iter();
    else {
      e == null && (e = this.lines + 1);
      let s = this.line(t).from;
      i = this.iterRange(s, Math.max(s, e == this.lines + 1 ? this.length : e <= 1 ? 0 : this.line(e - 1).to));
    }
    return new a8(i);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let t = [];
    return this.flatten(t), t;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(t) {
    if (t.length == 0)
      throw new RangeError("A document must have at least one line");
    return t.length == 1 && !t[0] ? co.empty : t.length <= 32 ? new kn(t) : fv.from(kn.split(t, []));
  }
}, c(co, "Xs"), co);
f(K9, "Text");
let Ft = K9;
var yi;
const J9 = (yi = class extends Ft {
  constructor(t, e = e8(t)) {
    super(), this.text = t, this.length = e;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(t, e, i, s) {
    for (let r = 0; ; r++) {
      let a = this.text[r], o = s + a.length;
      if ((e ? i : o) >= t)
        return new vD(s, o, i, a);
      s = o + 1, i++;
    }
  }
  decompose(t, e, i, s) {
    let r = t <= 0 && e >= this.length ? this : new yi(uk(this.text, t, e), Math.min(e, this.length) - Math.max(0, t));
    if (s & 1) {
      let a = i.pop(), o = rw(r.text, a.text.slice(), 0, r.length);
      if (o.length <= 32)
        i.push(new yi(o, a.length + r.length));
      else {
        let l = o.length >> 1;
        i.push(new yi(o.slice(0, l)), new yi(o.slice(l)));
      }
    } else
      i.push(r);
  }
  replace(t, e, i) {
    if (!(i instanceof yi))
      return super.replace(t, e, i);
    [t, e] = Go(this, t, e);
    let s = rw(this.text, rw(i.text, uk(this.text, 0, t)), e), r = this.length + i.length - (e - t);
    return s.length <= 32 ? new yi(s, r) : fv.from(yi.split(s, []), r);
  }
  sliceString(t, e = this.length, i = `
`) {
    [t, e] = Go(this, t, e);
    let s = "";
    for (let r = 0, a = 0; r <= e && a < this.text.length; a++) {
      let o = this.text[a], l = r + o.length;
      r > t && a && (s += i), t < l && e > r && (s += o.slice(Math.max(0, t - r), e - r)), r = l + 1;
    }
    return s;
  }
  flatten(t) {
    for (let e of this.text)
      t.push(e);
  }
  scanIdentical() {
    return 0;
  }
  static split(t, e) {
    let i = [], s = -1;
    for (let r of t)
      i.push(r), s += r.length + 1, i.length == 32 && (e.push(new yi(i, s)), i = [], s = -1);
    return s > -1 && e.push(new yi(i, s)), e;
  }
}, c(yi, "Ae"), yi);
f(J9, "TextLeaf");
let kn = J9;
var $n;
const t8 = ($n = class extends Ft {
  constructor(t, e) {
    super(), this.children = t, this.length = e, this.lines = 0;
    for (let i of t)
      this.lines += i.lines;
  }
  lineInner(t, e, i, s) {
    for (let r = 0; ; r++) {
      let a = this.children[r], o = s + a.length, l = i + a.lines - 1;
      if ((e ? l : o) >= t)
        return a.lineInner(t, e, i, s);
      s = o + 1, i = l + 1;
    }
  }
  decompose(t, e, i, s) {
    for (let r = 0, a = 0; a <= e && r < this.children.length; r++) {
      let o = this.children[r], l = a + o.length;
      if (t <= l && e >= a) {
        let h = s & ((a <= t ? 1 : 0) | (l >= e ? 2 : 0));
        a >= t && l <= e && !h ? i.push(o) : o.decompose(t - a, e - a, i, h);
      }
      a = l + 1;
    }
  }
  replace(t, e, i) {
    if ([t, e] = Go(this, t, e), i.lines < this.lines)
      for (let s = 0, r = 0; s < this.children.length; s++) {
        let a = this.children[s], o = r + a.length;
        if (t >= r && e <= o) {
          let l = a.replace(t - r, e - r, i), h = this.lines - a.lines + l.lines;
          if (l.lines < h >> 4 && l.lines > h >> 6) {
            let u = this.children.slice();
            return u[s] = l, new $n(u, this.length - (e - t) + i.length);
          }
          return super.replace(r, o, l);
        }
        r = o + 1;
      }
    return super.replace(t, e, i);
  }
  sliceString(t, e = this.length, i = `
`) {
    [t, e] = Go(this, t, e);
    let s = "";
    for (let r = 0, a = 0; r < this.children.length && a <= e; r++) {
      let o = this.children[r], l = a + o.length;
      a > t && r && (s += i), t < l && e > a && (s += o.sliceString(t - a, e - a, i)), a = l + 1;
    }
    return s;
  }
  flatten(t) {
    for (let e of this.children)
      e.flatten(t);
  }
  scanIdentical(t, e) {
    if (!(t instanceof $n))
      return 0;
    let i = 0, [s, r, a, o] = e > 0 ? [0, 0, this.children.length, t.children.length] : [this.children.length - 1, t.children.length - 1, -1, -1];
    for (; ; s += e, r += e) {
      if (s == a || r == o)
        return i;
      let l = this.children[s], h = t.children[r];
      if (l != h)
        return i + l.scanIdentical(h, e);
      i += l.length + 1;
    }
  }
  static from(t, e = t.reduce((i, s) => i + s.length + 1, -1)) {
    let i = 0;
    for (let m of t)
      i += m.lines;
    if (i < 32) {
      let m = [];
      for (let g of t)
        g.flatten(m);
      return new kn(m, e);
    }
    let s = Math.max(
      32,
      i >> 5
      /* Tree.BranchShift */
    ), r = s << 1, a = s >> 1, o = [], l = 0, h = -1, u = [];
    function p(m) {
      let g;
      if (m.lines > r && m instanceof $n)
        for (let b of m.children)
          p(b);
      else m.lines > a && (l > a || !l) ? (y(), o.push(m)) : m instanceof kn && l && (g = u[u.length - 1]) instanceof kn && m.lines + g.lines <= 32 ? (l += m.lines, h += m.length + 1, u[u.length - 1] = new kn(g.text.concat(m.text), g.length + 1 + m.length)) : (l + m.lines > s && y(), l += m.lines, h += m.length + 1, u.push(m));
    }
    c(p, "u"), f(p, "add");
    function y() {
      l != 0 && (o.push(u.length == 1 ? u[0] : $n.from(u, h)), h = -1, l = u.length = 0);
    }
    c(y, "O"), f(y, "flush");
    for (let m of t)
      p(m);
    return y(), o.length == 1 ? o[0] : new $n(o, e);
  }
}, c($n, "yt"), $n);
f(t8, "TextNode");
let fv = t8;
Ft.empty = /* @__PURE__ */ new kn([""], 0);
function e8(n) {
  let t = -1;
  for (let e of n)
    t += e.length + 1;
  return t;
}
c(e8, "Ug$1");
f(e8, "textLength");
function rw(n, t, e = 0, i = 1e9) {
  for (let s = 0, r = 0, a = !0; r < n.length && s <= i; r++) {
    let o = n[r], l = s + o.length;
    l >= e && (l > i && (o = o.slice(0, i - s)), s < e && (o = o.slice(e - s)), a ? (t[t.length - 1] += o, a = !1) : t.push(o)), s = l + 1;
  }
  return t;
}
c(rw, "qn$1");
f(rw, "appendText");
function uk(n, t, e) {
  return rw(n, [""], t, e);
}
c(uk, "iu$1");
f(uk, "sliceText");
var bh;
const i8 = (bh = class {
  constructor(t, e = 1) {
    this.dir = e, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [t], this.offsets = [e > 0 ? 1 : (t instanceof kn ? t.text.length : t.children.length) << 1];
  }
  nextInner(t, e) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, s = this.nodes[i], r = this.offsets[i], a = r >> 1, o = s instanceof kn ? s.text.length : s.children.length;
      if (a == (e > 0 ? o : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        e > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((r & 1) == (e > 0 ? 0 : 1)) {
        if (this.offsets[i] += e, t == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        t--;
      } else if (s instanceof kn) {
        let l = s.text[a + (e < 0 ? -1 : 0)];
        if (this.offsets[i] += e, l.length > Math.max(0, t))
          return this.value = t == 0 ? l : e > 0 ? l.slice(t) : l.slice(0, l.length - t), this;
        t -= l.length;
      } else {
        let l = s.children[a + (e < 0 ? -1 : 0)];
        t > l.length ? (t -= l.length, this.offsets[i] += e) : (e < 0 && this.offsets[i]--, this.nodes.push(l), this.offsets.push(e > 0 ? 1 : (l instanceof kn ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(t = 0) {
    return t < 0 && (this.nextInner(-t, -this.dir), t = this.value.length), this.nextInner(t, this.dir);
  }
}, c(bh, "Nh"), bh);
f(i8, "RawTextCursor");
let aw = i8;
var $h;
const n8 = ($h = class {
  constructor(t, e, i) {
    this.value = "", this.done = !1, this.cursor = new aw(t, e > i ? -1 : 1), this.pos = e > i ? t.length : 0, this.from = Math.min(e, i), this.to = Math.max(e, i);
  }
  nextInner(t, e) {
    if (e < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    t += Math.max(0, e < 0 ? this.pos - this.to : this.from - this.pos);
    let i = e < 0 ? this.pos - this.from : this.to - this.pos;
    t > i && (t = i), i -= t;
    let { value: s } = this.cursor.next(t);
    return this.pos += (s.length + t) * e, this.value = s.length <= i ? s : e < 0 ? s.slice(s.length - i) : s.slice(0, i), this.done = !this.value, this;
  }
  next(t = 0) {
    return t < 0 ? t = Math.max(t, this.from - this.pos) : t > 0 && (t = Math.min(t, this.to - this.pos)), this.nextInner(t, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}, c($h, "Gh"), $h);
f(n8, "PartialTextCursor");
let s8 = n8;
var xh;
const r8 = (xh = class {
  constructor(t) {
    this.inner = t, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(t = 0) {
    let { done: e, lineBreak: i, value: s } = this.inner.next(t);
    return e && this.afterBreak ? (this.value = "", this.afterBreak = !1) : e ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = s, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}, c(xh, "Fh"), xh);
f(r8, "LineCursor");
let a8 = r8;
typeof Symbol < "u" && (Ft.prototype[Symbol.iterator] = function() {
  return this.iter();
}, aw.prototype[Symbol.iterator] = s8.prototype[Symbol.iterator] = a8.prototype[Symbol.iterator] = function() {
  return this;
});
var G0, kh;
let vD = (G0 = (kh = class {
  /**
  @internal
  */
  constructor(t, e, i, s) {
    this.from = t, this.to = e, this.number = i, this.text = s;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}, c(kh, "$i$1"), kh), f(G0, "Line"), G0);
function Go(n, t, e) {
  return t = Math.max(0, Math.min(n.length, t)), [t, Math.max(t, Math.min(n.length, e))];
}
c(Go, "Zi$1");
f(Go, "clip");
function Ui(n, t, e = !0, i = !0) {
  return Y9(n, t, e, i);
}
c(Ui, "oe$2");
f(Ui, "findClusterBreak");
function o8(n) {
  return n >= 56320 && n < 57344;
}
c(o8, "zg$1");
f(o8, "surrogateLow");
function l8(n) {
  return n >= 55296 && n < 56320;
}
c(l8, "jg$1");
f(l8, "surrogateHigh");
function br(n, t) {
  let e = n.charCodeAt(t);
  if (!l8(e) || t + 1 == n.length)
    return e;
  let i = n.charCodeAt(t + 1);
  return o8(i) ? (e - 55296 << 10) + (i - 56320) + 65536 : e;
}
c(br, "Vt$2");
f(br, "codePointAt");
function c8(n) {
  return n <= 65535 ? String.fromCharCode(n) : (n -= 65536, String.fromCharCode((n >> 10) + 55296, (n & 1023) + 56320));
}
c(c8, "qg$1");
f(c8, "fromCodePoint");
function Ua(n) {
  return n < 65536 ? 1 : 2;
}
c(Ua, "ci$1");
f(Ua, "codePointSize");
const pk = /\r\n?|\n/;
var wi = /* @__PURE__ */ (function(n) {
  return n[n.Simple = 0] = "Simple", n[n.TrackDel = 1] = "TrackDel", n[n.TrackBefore = 2] = "TrackBefore", n[n.TrackAfter = 3] = "TrackAfter", n;
})(wi || (wi = {})), Ds;
const h8 = (Ds = class {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(t) {
    this.sections = t;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let t = 0;
    for (let e = 0; e < this.sections.length; e += 2)
      t += this.sections[e];
    return t;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let t = 0;
    for (let e = 0; e < this.sections.length; e += 2) {
      let i = this.sections[e + 1];
      t += i < 0 ? this.sections[e] : i;
    }
    return t;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(t) {
    for (let e = 0, i = 0, s = 0; e < this.sections.length; ) {
      let r = this.sections[e++], a = this.sections[e++];
      a < 0 ? (t(i, s, r), s += r) : s += a, i += r;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(t, e = !1) {
    oO(this, t, e);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let t = [];
    for (let e = 0; e < this.sections.length; ) {
      let i = this.sections[e++], s = this.sections[e++];
      s < 0 ? t.push(i, s) : t.push(s, i);
    }
    return new Ds(t);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(t) {
    return this.empty ? t : t.empty ? this : _S(this, t);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(t, e = !1) {
    return t.empty ? this : lO(this, t, e);
  }
  mapPos(t, e = -1, i = wi.Simple) {
    let s = 0, r = 0;
    for (let a = 0; a < this.sections.length; ) {
      let o = this.sections[a++], l = this.sections[a++], h = s + o;
      if (l < 0) {
        if (h > t)
          return r + (t - s);
        r += o;
      } else {
        if (i != wi.Simple && h >= t && (i == wi.TrackDel && s < t && h > t || i == wi.TrackBefore && s < t || i == wi.TrackAfter && h > t))
          return null;
        if (h > t || h == t && e < 0 && !o)
          return t == s || e < 0 ? r : r + l;
        r += l;
      }
      s = h;
    }
    if (t > s)
      throw new RangeError(`Position ${t} is out of range for changeset of length ${s}`);
    return r;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(t, e = t) {
    for (let i = 0, s = 0; i < this.sections.length && s <= e; ) {
      let r = this.sections[i++], a = this.sections[i++], o = s + r;
      if (a >= 0 && s <= e && o >= t)
        return s < t && o > e ? "cover" : !0;
      s = o;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let t = "";
    for (let e = 0; e < this.sections.length; ) {
      let i = this.sections[e++], s = this.sections[e++];
      t += (t ? " " : "") + i + (s >= 0 ? ":" + s : "");
    }
    return t;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2 || t.some((e) => typeof e != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Ds(t);
  }
  /**
  @internal
  */
  static create(t) {
    return new Ds(t);
  }
}, c(Ds, "mi"), Ds);
f(h8, "ChangeDesc");
let ah = h8;
var Ni;
const d8 = (Ni = class extends ah {
  constructor(t, e) {
    super(t), this.inserted = e;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(t) {
    if (this.length != t.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return oO(this, (e, i, s, r, a) => t = t.replace(s, s + (i - e), a), !1), t;
  }
  mapDesc(t, e = !1) {
    return lO(this, t, e, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(t) {
    let e = this.sections.slice(), i = [];
    for (let s = 0, r = 0; s < e.length; s += 2) {
      let a = e[s], o = e[s + 1];
      if (o >= 0) {
        e[s] = o, e[s + 1] = a;
        let l = s >> 1;
        for (; i.length < l; )
          i.push(Ft.empty);
        i.push(a ? t.slice(r, r + a) : Ft.empty);
      }
      r += a;
    }
    return new Ni(e, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(t) {
    return this.empty ? t : t.empty ? this : _S(this, t, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(t, e = !1) {
    return t.empty ? this : lO(this, t, e, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(t, e = !1) {
    oO(this, t, e);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ah.create(this.sections);
  }
  /**
  @internal
  */
  filter(t) {
    let e = [], i = [], s = [], r = new fw(this);
    t: for (let a = 0, o = 0; ; ) {
      let l = a == t.length ? 1e9 : t[a++];
      for (; o < l || o == l && r.len == 0; ) {
        if (r.done)
          break t;
        let u = Math.min(r.len, l - o);
        ti(s, u, -1);
        let p = r.ins == -1 ? -1 : r.off == 0 ? r.ins : 0;
        ti(e, u, p), p > 0 && Es(i, e, r.text), r.forward(u), o += u;
      }
      let h = t[a++];
      for (; o < h; ) {
        if (r.done)
          break t;
        let u = Math.min(r.len, h - o);
        ti(e, u, -1), ti(s, u, r.ins == -1 ? -1 : r.off == 0 ? r.ins : 0), r.forward(u), o += u;
      }
    }
    return {
      changes: new Ni(e, i),
      filtered: ah.create(s)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let t = [];
    for (let e = 0; e < this.sections.length; e += 2) {
      let i = this.sections[e], s = this.sections[e + 1];
      s < 0 ? t.push(i) : s == 0 ? t.push([i]) : t.push([i].concat(this.inserted[e >> 1].toJSON()));
    }
    return t;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(t, e, i) {
    let s = [], r = [], a = 0, o = null;
    function l(u = !1) {
      if (!u && !s.length)
        return;
      a < e && ti(s, e - a, -1);
      let p = new Ni(s, r);
      o = o ? o.compose(p.map(o)) : p, s = [], r = [], a = 0;
    }
    c(l, "a"), f(l, "flush");
    function h(u) {
      if (Array.isArray(u))
        for (let p of u)
          h(p);
      else if (u instanceof Ni) {
        if (u.length != e)
          throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${e})`);
        l(), o = o ? o.compose(u.map(o)) : u;
      } else {
        let { from: p, to: y = p, insert: m } = u;
        if (p > y || p < 0 || y > e)
          throw new RangeError(`Invalid change range ${p} to ${y} (in doc of length ${e})`);
        let g = m ? typeof m == "string" ? Ft.of(m.split(i || pk)) : m : Ft.empty, b = g.length;
        if (p == y && b == 0)
          return;
        p < a && l(), p > a && ti(s, p - a, -1), ti(s, y - p, b), Es(r, s, g), a = y;
      }
    }
    return c(h, "h"), f(h, "process"), h(t), l(!o), o;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(t) {
    return new Ni(t ? [t, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(t) {
    if (!Array.isArray(t))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let e = [], i = [];
    for (let s = 0; s < t.length; s++) {
      let r = t[s];
      if (typeof r == "number")
        e.push(r, -1);
      else {
        if (!Array.isArray(r) || typeof r[0] != "number" || r.some((a, o) => o && typeof a != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (r.length == 1)
          e.push(r[0], 0);
        else {
          for (; i.length < s; )
            i.push(Ft.empty);
          i[s] = Ft.of(r.slice(1)), e.push(r[0], i[s].length);
        }
      }
    }
    return new Ni(e, i);
  }
  /**
  @internal
  */
  static createSet(t, e) {
    return new Ni(t, e);
  }
}, c(Ni, "it"), Ni);
f(d8, "ChangeSet");
let Tn = d8;
function ti(n, t, e, i = !1) {
  if (t == 0 && e <= 0)
    return;
  let s = n.length - 2;
  s >= 0 && e <= 0 && e == n[s + 1] ? n[s] += t : s >= 0 && t == 0 && n[s] == 0 ? n[s + 1] += e : i ? (n[s] += t, n[s + 1] += e) : n.push(t, e);
}
c(ti, "ae$2");
f(ti, "addSection");
function Es(n, t, e) {
  if (e.length == 0)
    return;
  let i = t.length - 2 >> 1;
  if (i < n.length)
    n[n.length - 1] = n[n.length - 1].append(e);
  else {
    for (; n.length < i; )
      n.push(Ft.empty);
    n.push(e);
  }
}
c(Es, "bt$2");
f(Es, "addInsert");
function oO(n, t, e) {
  let i = n.inserted;
  for (let s = 0, r = 0, a = 0; a < n.sections.length; ) {
    let o = n.sections[a++], l = n.sections[a++];
    if (l < 0)
      s += o, r += o;
    else {
      let h = s, u = r, p = Ft.empty;
      for (; h += o, u += l, l && i && (p = p.append(i[a - 2 >> 1])), !(e || a == n.sections.length || n.sections[a + 1] < 0); )
        o = n.sections[a++], l = n.sections[a++];
      t(s, h, r, u, p), s = h, r = u;
    }
  }
}
c(oO, "ll$1");
f(oO, "iterChanges");
function lO(n, t, e, i = !1) {
  let s = [], r = i ? [] : null, a = new fw(n), o = new fw(t);
  for (let l = -1; ; ) {
    if (a.done && o.len || o.done && a.len)
      throw new Error("Mismatched change set lengths");
    if (a.ins == -1 && o.ins == -1) {
      let h = Math.min(a.len, o.len);
      ti(s, h, -1), a.forward(h), o.forward(h);
    } else if (o.ins >= 0 && (a.ins < 0 || l == a.i || a.off == 0 && (o.len < a.len || o.len == a.len && !e))) {
      let h = o.len;
      for (ti(s, o.ins, -1); h; ) {
        let u = Math.min(a.len, h);
        a.ins >= 0 && l < a.i && a.len <= u && (ti(s, 0, a.ins), r && Es(r, s, a.text), l = a.i), a.forward(u), h -= u;
      }
      o.next();
    } else if (a.ins >= 0) {
      let h = 0, u = a.len;
      for (; u; )
        if (o.ins == -1) {
          let p = Math.min(u, o.len);
          h += p, u -= p, o.forward(p);
        } else if (o.ins == 0 && o.len < u)
          u -= o.len, o.next();
        else
          break;
      ti(s, h, l < a.i ? a.ins : 0), r && l < a.i && Es(r, s, a.text), l = a.i, a.forward(a.len - u);
    } else {
      if (a.done && o.done)
        return r ? Tn.createSet(s, r) : ah.create(s);
      throw new Error("Mismatched change set lengths");
    }
  }
}
c(lO, "al$1");
f(lO, "mapSet");
function _S(n, t, e = !1) {
  let i = [], s = e ? [] : null, r = new fw(n), a = new fw(t);
  for (let o = !1; ; ) {
    if (r.done && a.done)
      return s ? Tn.createSet(i, s) : ah.create(i);
    if (r.ins == 0)
      ti(i, r.len, 0, o), r.next();
    else if (a.len == 0 && !a.done)
      ti(i, 0, a.ins, o), s && Es(s, i, a.text), a.next();
    else {
      if (r.done || a.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(r.len2, a.len), h = i.length;
        if (r.ins == -1) {
          let u = a.ins == -1 ? -1 : a.off ? 0 : a.ins;
          ti(i, l, u, o), s && u && Es(s, i, a.text);
        } else a.ins == -1 ? (ti(i, r.off ? 0 : r.len, l, o), s && Es(s, i, r.textBit(l))) : (ti(i, r.off ? 0 : r.len, a.off ? 0 : a.ins, o), s && !a.off && Es(s, i, a.text));
        o = (r.ins > l || a.ins >= 0 && a.len > l) && (o || i.length > h), r.forward2(l), a.forward(l);
      }
    }
  }
}
c(_S, "od$1");
f(_S, "composeSets");
var Sh;
const u8 = (Sh = class {
  constructor(t) {
    this.set = t, this.i = 0, this.next();
  }
  next() {
    let { sections: t } = this.set;
    this.i < t.length ? (this.len = t[this.i++], this.ins = t[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: t } = this.set, e = this.i - 2 >> 1;
    return e >= t.length ? Ft.empty : t[e];
  }
  textBit(t) {
    let { inserted: e } = this.set, i = this.i - 2 >> 1;
    return i >= e.length && !t ? Ft.empty : e[i].slice(this.off, t == null ? void 0 : this.off + t);
  }
  forward(t) {
    t == this.len ? this.next() : (this.len -= t, this.off += t);
  }
  forward2(t) {
    this.ins == -1 ? this.forward(t) : t == this.ins ? this.next() : (this.ins -= t, this.off += t);
  }
}, c(Sh, "Hh"), Sh);
f(u8, "SectionIter");
let fw = u8;
var zr;
const p8 = (zr = class {
  constructor(t, e, i) {
    this.from = t, this.to = e, this.flags = i;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let t = this.flags & 7;
    return t == 7 ? null : t;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let t = this.flags >> 6;
    return t == 16777215 ? void 0 : t;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(t, e = -1) {
    let i, s;
    return this.empty ? i = s = t.mapPos(this.from, e) : (i = t.mapPos(this.from, 1), s = t.mapPos(this.to, -1)), i == this.from && s == this.to ? this : new zr(i, s, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(t, e = t) {
    if (t <= this.anchor && e >= this.anchor)
      return it.range(t, e);
    let i = Math.abs(t - this.anchor) > Math.abs(e - this.anchor) ? t : e;
    return it.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(t, e = !1) {
    return this.anchor == t.anchor && this.head == t.head && this.goalColumn == t.goalColumn && (!e || !this.empty || this.assoc == t.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(t) {
    if (!t || typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return it.range(t.anchor, t.head);
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new zr(t, e, i);
  }
}, c(zr, "Tr"), zr);
f(p8, "SelectionRange");
let D1 = p8;
var Fe;
const f8 = (Fe = class {
  constructor(t, e) {
    this.ranges = t, this.mainIndex = e;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(t, e = -1) {
    return t.empty ? this : Fe.create(this.ranges.map((i) => i.map(t, e)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(t, e = !1) {
    if (this.ranges.length != t.ranges.length || this.mainIndex != t.mainIndex)
      return !1;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(t.ranges[i], e))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new Fe([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(t, e = !0) {
    return Fe.create([t].concat(this.ranges), e ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(t, e = this.mainIndex) {
    let i = this.ranges.slice();
    return i[e] = t, Fe.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((t) => t.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(t) {
    if (!t || !Array.isArray(t.ranges) || typeof t.main != "number" || t.main >= t.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new Fe(t.ranges.map((e) => D1.fromJSON(e)), t.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(t, e = t) {
    return new Fe([Fe.range(t, e)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(t, e = 0) {
    if (t.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, s = 0; s < t.length; s++) {
      let r = t[s];
      if (r.empty ? r.from <= i : r.from < i)
        return Fe.normalized(t.slice(), e);
      i = r.to;
    }
    return new Fe(t, e);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(t, e = 0, i, s) {
    return D1.create(t, t, (e == 0 ? 0 : e < 0 ? 8 : 16) | (i == null ? 7 : Math.min(6, i)) | (s ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(t, e, i, s) {
    let r = (i ?? 16777215) << 6 | (s == null ? 7 : Math.min(6, s));
    return e < t ? D1.create(e, t, 48 | r) : D1.create(t, e, (e > t ? 8 : 0) | r);
  }
  /**
  @internal
  */
  static normalized(t, e = 0) {
    let i = t[e];
    t.sort((s, r) => s.from - r.from), e = t.indexOf(i);
    for (let s = 1; s < t.length; s++) {
      let r = t[s], a = t[s - 1];
      if (r.empty ? r.from <= a.to : r.from < a.to) {
        let o = a.from, l = Math.max(r.to, a.to);
        s <= e && e--, t.splice(--s, 2, r.anchor > r.head ? Fe.range(l, o) : Fe.range(o, l));
      }
    }
    return new Fe(t, e);
  }
}, c(Fe, "fe"), Fe);
f(f8, "EditorSelection");
let it = f8;
function zS(n, t) {
  for (let e of n.ranges)
    if (e.to > t)
      throw new RangeError("Selection points outside of document");
}
c(zS, "ld$1");
f(zS, "checkSelection");
let LS = 0;
var ho;
const y8 = (ho = class {
  constructor(t, e, i, s, r) {
    this.combine = t, this.compareInput = e, this.compare = i, this.isStatic = s, this.id = LS++, this.default = t([]), this.extensions = typeof r == "function" ? r(this) : r;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(t = {}) {
    return new ho(t.combine || ((e) => e), t.compareInput || ((e, i) => e === i), t.compare || (t.combine ? (e, i) => e === i : Tb), !!t.static, t.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(t) {
    return new yv([], this, 0, t);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(t, e) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new yv(t, this, 1, e);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(t, e) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new yv(t, this, 2, e);
  }
  from(t, e) {
    return e || (e = /* @__PURE__ */ f((i) => i, "get")), this.compute([t], (i) => e(i.field(t)));
  }
}, c(ho, "Es"), ho);
f(y8, "Facet");
let bt = y8;
function Tb(n, t) {
  return n == t || n.length == t.length && n.every((e, i) => e === t[i]);
}
c(Tb, "fh$1");
f(Tb, "sameArray$1");
var Ch;
const m8 = (Ch = class {
  constructor(t, e, i, s) {
    this.dependencies = t, this.facet = e, this.type = i, this.value = s, this.id = LS++;
  }
  dynamicSlot(t) {
    var e;
    let i = this.value, s = this.facet.compareInput, r = this.id, a = t[r] >> 1, o = this.type == 2, l = !1, h = !1, u = [];
    for (let p of this.dependencies)
      p == "doc" ? l = !0 : p == "selection" ? h = !0 : (((e = t[p.id]) !== null && e !== void 0 ? e : 1) & 1) == 0 && u.push(t[p.id]);
    return {
      create(p) {
        return p.values[a] = i(p), 1;
      },
      update(p, y) {
        if (l && y.docChanged || h && (y.docChanged || y.selection) || cO(p, u)) {
          let m = i(p);
          if (o ? !fk(m, p.values[a], s) : !s(m, p.values[a]))
            return p.values[a] = m, 1;
        }
        return 0;
      },
      reconfigure: /* @__PURE__ */ f((p, y) => {
        let m, g = y.config.address[r];
        if (g != null) {
          let b = yw(y, g);
          if (this.dependencies.every((S) => S instanceof bt ? y.facet(S) === p.facet(S) : S instanceof rr ? y.field(S, !1) == p.field(S, !1) : !0) || (o ? fk(m = i(p), b, s) : s(m = i(p), b)))
            return p.values[a] = b, 0;
        } else
          m = i(p);
        return p.values[a] = m, 1;
      }, "reconfigure")
    };
  }
}, c(Ch, "Kh"), Ch);
f(m8, "FacetProvider");
let yv = m8;
function fk(n, t, e) {
  if (n.length != t.length)
    return !1;
  for (let i = 0; i < n.length; i++)
    if (!e(n[i], t[i]))
      return !1;
  return !0;
}
c(fk, "ru$1");
f(fk, "compareArray");
function cO(n, t) {
  let e = !1;
  for (let i of t)
    oh(n, i) & 1 && (e = !0);
  return e;
}
c(cO, "hl$1");
f(cO, "ensureAll");
function g8(n, t, e) {
  let i = e.map((l) => n[l.id]), s = e.map((l) => l.type), r = i.filter((l) => !(l & 1)), a = n[t.id] >> 1;
  function o(l) {
    let h = [];
    for (let u = 0; u < i.length; u++) {
      let p = yw(l, i[u]);
      if (s[u] == 2)
        for (let y of p)
          h.push(y);
      else
        h.push(p);
    }
    return t.combine(h);
  }
  return c(o, "l"), f(o, "get"), {
    create(l) {
      for (let h of i)
        oh(l, h);
      return l.values[a] = o(l), 1;
    },
    update(l, h) {
      if (!cO(l, r))
        return 0;
      let u = o(l);
      return t.compare(u, l.values[a]) ? 0 : (l.values[a] = u, 1);
    },
    reconfigure(l, h) {
      let u = cO(l, i), p = h.config.facets[t.id], y = h.facet(t);
      if (p && !u && Tb(e, p))
        return l.values[a] = y, 0;
      let m = o(l);
      return t.compare(m, y) ? (l.values[a] = y, 0) : (l.values[a] = m, 1);
    }
  };
}
c(g8, "Bg$1");
f(g8, "dynamicFacetSlot");
const q1 = /* @__PURE__ */ bt.define({ static: !0 });
var uo;
const w8 = (uo = class {
  constructor(t, e, i, s, r) {
    this.id = t, this.createF = e, this.updateF = i, this.compareF = s, this.spec = r, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(t) {
    let e = new uo(LS++, t.create, t.update, t.compare || ((i, s) => i === s), t);
    return t.provide && (e.provides = t.provide(e)), e;
  }
  create(t) {
    return (t.facet(q1).find((i) => i.field == this)?.create || this.createF)(t);
  }
  /**
  @internal
  */
  slot(t) {
    let e = t[this.id] >> 1;
    return {
      create: /* @__PURE__ */ f((i) => (i.values[e] = this.create(i), 1), "create"),
      update: /* @__PURE__ */ f((i, s) => {
        let r = i.values[e], a = this.updateF(r, s);
        return this.compareF(r, a) ? 0 : (i.values[e] = a, 1);
      }, "update"),
      reconfigure: /* @__PURE__ */ f((i, s) => {
        let r = i.facet(q1), a = s.facet(q1), o;
        return (o = r.find((l) => l.field == this)) && o != a.find((l) => l.field == this) ? (i.values[e] = o.create(i), 1) : s.config.address[this.id] != null ? (i.values[e] = s.field(this), 0) : (i.values[e] = this.create(i), 1);
      }, "reconfigure")
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(t) {
    return [this, q1.of({ field: this, create: t })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}, c(uo, "Ys"), uo);
f(w8, "StateField");
let rr = w8;
const Ha = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Lc(n) {
  return (t) => new O8(t, n);
}
c(Lc, "nr$1");
f(Lc, "prec");
const Cl = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Lc(Ha.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Lc(Ha.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Lc(Ha.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Lc(Ha.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Lc(Ha.lowest)
};
var Ph;
const v8 = (Ph = class {
  constructor(t, e) {
    this.inner = t, this.prec = e;
  }
}, c(Ph, "Jh"), Ph);
f(v8, "PrecExtension");
let O8 = v8;
var po;
const b8 = (po = class {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(t) {
    return new yk(this, t);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(t) {
    return po.reconfigure.of({ compartment: this, extension: t });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(t) {
    return t.config.compartments.get(this);
  }
}, c(po, "Ws"), po);
f(b8, "Compartment");
let $8 = b8;
var Qh;
const x8 = (Qh = class {
  constructor(t, e) {
    this.compartment = t, this.inner = e;
  }
}, c(Qh, "ef"), Qh);
f(x8, "CompartmentInstance");
let yk = x8;
var fo;
const k8 = (fo = class {
  constructor(t, e, i, s, r, a) {
    for (this.base = t, this.compartments = e, this.dynamicSlots = i, this.address = s, this.staticValues = r, this.facets = a, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(t) {
    let e = this.address[t.id];
    return e == null ? t.default : this.staticValues[e >> 1];
  }
  static resolve(t, e, i) {
    let s = [], r = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ new Map();
    for (let y of S8(t, e, a))
      y instanceof rr ? s.push(y) : (r[y.facet.id] || (r[y.facet.id] = [])).push(y);
    let o = /* @__PURE__ */ Object.create(null), l = [], h = [];
    for (let y of s)
      o[y.id] = h.length << 1, h.push((m) => y.slot(m));
    let u = i?.config.facets;
    for (let y in r) {
      let m = r[y], g = m[0].facet, b = u && u[y] || [];
      if (m.every(
        (S) => S.type == 0
        /* Provider.Static */
      ))
        if (o[g.id] = l.length << 1 | 1, Tb(b, m))
          l.push(i.facet(g));
        else {
          let S = g.combine(m.map((x) => x.value));
          l.push(i && g.compare(S, i.facet(g)) ? i.facet(g) : S);
        }
      else {
        for (let S of m)
          S.type == 0 ? (o[S.id] = l.length << 1 | 1, l.push(S.value)) : (o[S.id] = h.length << 1, h.push((x) => S.dynamicSlot(x)));
        o[g.id] = h.length << 1, h.push((S) => g8(S, g, m));
      }
    }
    let p = h.map((y) => y(o));
    return new fo(t, a, p, o, l, r);
  }
}, c(fo, "Vs"), fo);
f(k8, "Configuration");
let E3 = k8;
function S8(n, t, e) {
  let i = [[], [], [], [], []], s = /* @__PURE__ */ new Map();
  function r(a, o) {
    let l = s.get(a);
    if (l != null) {
      if (l <= o)
        return;
      let h = i[l].indexOf(a);
      h > -1 && i[l].splice(h, 1), a instanceof yk && e.delete(a.compartment);
    }
    if (s.set(a, o), Array.isArray(a))
      for (let h of a)
        r(h, o);
    else if (a instanceof yk) {
      if (e.has(a.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let h = t.get(a.compartment) || a.inner;
      e.set(a.compartment, h), r(h, o);
    } else if (a instanceof O8)
      r(a.inner, a.prec);
    else if (a instanceof rr)
      i[o].push(a), a.provides && r(a.provides, o);
    else if (a instanceof yv)
      i[o].push(a), a.facet.extensions && r(a.facet.extensions, Ha.default);
    else {
      let h = a.extension;
      if (!h)
        throw new Error(`Unrecognized extension value in extension set (${a}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      r(h, o);
    }
  }
  return c(r, "s"), f(r, "inner"), r(n, Ha.default), i.reduce((a, o) => a.concat(o));
}
c(S8, "Dg$1");
f(S8, "flatten");
function oh(n, t) {
  if (t & 1)
    return 2;
  let e = t >> 1, i = n.status[e];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  n.status[e] = 4;
  let s = n.computeSlot(n, n.config.dynamicSlots[e]);
  return n.status[e] = 2 | s;
}
c(oh, "mr$1");
f(oh, "ensureAddr");
function yw(n, t) {
  return t & 1 ? n.config.staticValues[t >> 1] : n.values[t >> 1];
}
c(yw, "es$2");
f(yw, "getAddr");
const C8 = /* @__PURE__ */ bt.define(), mk = /* @__PURE__ */ bt.define({
  combine: /* @__PURE__ */ f((n) => n.some((t) => t), "combine"),
  static: !0
}), P8 = /* @__PURE__ */ bt.define({
  combine: /* @__PURE__ */ f((n) => n.length ? n[0] : void 0, "combine"),
  static: !0
}), Q8 = /* @__PURE__ */ bt.define(), T8 = /* @__PURE__ */ bt.define(), M8 = /* @__PURE__ */ bt.define(), A8 = /* @__PURE__ */ bt.define({
  combine: /* @__PURE__ */ f((n) => n.length ? n[0] : !1, "combine")
});
var Th;
const R8 = (Th = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.type = t, this.value = e;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new OD();
  }
}, c(Th, "tf"), Th);
f(R8, "Annotation");
let ar = R8;
var Mh;
const E8 = (Mh = class {
  /**
  Create an instance of this annotation.
  */
  of(t) {
    return new ar(this, t);
  }
}, c(Mh, "rf"), Mh);
f(E8, "AnnotationType");
let OD = E8;
var Ah;
const _8 = (Ah = class {
  /**
  @internal
  */
  constructor(t) {
    this.map = t;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(t) {
    return new Bt(this, t);
  }
}, c(Ah, "nf"), Ah);
f(_8, "StateEffectType");
let bD = _8;
var yo;
const z8 = (yo = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.type = t, this.value = e;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(t) {
    let e = this.type.map(this.value, t);
    return e === void 0 ? void 0 : e == this.value ? this : new yo(this.type, e);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(t) {
    return this.type == t;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(t = {}) {
    return new bD(t.map || ((e) => e));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(t, e) {
    if (!t.length)
      return t;
    let i = [];
    for (let s of t) {
      let r = s.map(e);
      r && i.push(r);
    }
    return i;
  }
}, c(yo, "Us"), yo);
f(z8, "StateEffect");
let Bt = z8;
Bt.reconfigure = /* @__PURE__ */ Bt.define();
Bt.appendConfig = /* @__PURE__ */ Bt.define();
var Gn;
const L8 = (Gn = class {
  constructor(t, e, i, s, r, a) {
    this.startState = t, this.changes = e, this.selection = i, this.effects = s, this.annotations = r, this.scrollIntoView = a, this._doc = null, this._state = null, i && zS(i, e.newLength), r.some((o) => o.type == Gn.time) || (this.annotations = r.concat(Gn.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(t, e, i, s, r, a) {
    return new Gn(t, e, i, s, r, a);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(t) {
    for (let e of this.annotations)
      if (e.type == t)
        return e.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(t) {
    let e = this.annotation(Gn.userEvent);
    return !!(e && (e == t || e.length > t.length && e.slice(0, t.length) == t && e[t.length] == "."));
  }
}, c(Gn, "qt"), Gn);
f(L8, "Transaction");
let vi = L8;
vi.time = /* @__PURE__ */ ar.define();
vi.userEvent = /* @__PURE__ */ ar.define();
vi.addToHistory = /* @__PURE__ */ ar.define();
vi.remote = /* @__PURE__ */ ar.define();
function I8(n, t) {
  let e = [];
  for (let i = 0, s = 0; ; ) {
    let r, a;
    if (i < n.length && (s == t.length || t[s] >= n[i]))
      r = n[i++], a = n[i++];
    else if (s < t.length)
      r = t[s++], a = t[s++];
    else
      return e;
    !e.length || e[e.length - 1] < r ? e.push(r, a) : e[e.length - 1] < a && (e[e.length - 1] = a);
  }
}
c(I8, "Ng$1");
f(I8, "joinRanges");
function IS(n, t, e) {
  var i;
  let s, r, a;
  return e ? (s = t.changes, r = Tn.empty(t.changes.length), a = n.changes.compose(t.changes)) : (s = t.changes.map(n.changes), r = n.changes.mapDesc(t.changes, !0), a = n.changes.compose(s)), {
    changes: a,
    selection: t.selection ? t.selection.map(r) : (i = n.selection) === null || i === void 0 ? void 0 : i.map(s),
    effects: Bt.mapEffects(n.effects, s).concat(Bt.mapEffects(t.effects, r)),
    annotations: n.annotations.length ? n.annotations.concat(t.annotations) : t.annotations,
    scrollIntoView: n.scrollIntoView || t.scrollIntoView
  };
}
c(IS, "dd$1");
f(IS, "mergeTransaction");
function hO(n, t, e) {
  let i = t.selection, s = to(t.annotations);
  return t.userEvent && (s = s.concat(vi.userEvent.of(t.userEvent))), {
    changes: t.changes instanceof Tn ? t.changes : Tn.of(t.changes || [], e, n.facet(P8)),
    selection: i && (i instanceof it ? i : it.single(i.anchor, i.head)),
    effects: to(t.effects),
    annotations: s,
    scrollIntoView: !!t.scrollIntoView
  };
}
c(hO, "Ol$1");
f(hO, "resolveTransactionInner");
function WS(n, t, e) {
  let i = hO(n, t.length ? t[0] : {}, n.doc.length);
  t.length && t[0].filter === !1 && (e = !1);
  for (let r = 1; r < t.length; r++) {
    t[r].filter === !1 && (e = !1);
    let a = !!t[r].sequential;
    i = IS(i, hO(n, t[r], a ? i.changes.newLength : n.doc.length), a);
  }
  let s = vi.create(n, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return V8(e ? W8(s) : s);
}
c(WS, "pd$1");
f(WS, "resolveTransaction");
function W8(n) {
  let t = n.startState, e = !0;
  for (let s of t.facet(Q8)) {
    let r = s(n);
    if (r === !1) {
      e = !1;
      break;
    }
    Array.isArray(r) && (e = e === !0 ? r : I8(e, r));
  }
  if (e !== !0) {
    let s, r;
    if (e === !1)
      r = n.changes.invertedDesc, s = Tn.empty(t.doc.length);
    else {
      let a = n.changes.filter(e);
      s = a.changes, r = a.filtered.mapDesc(a.changes).invertedDesc;
    }
    n = vi.create(t, s, n.selection && n.selection.map(r), Bt.mapEffects(n.effects, r), n.annotations, n.scrollIntoView);
  }
  let i = t.facet(T8);
  for (let s = i.length - 1; s >= 0; s--) {
    let r = i[s](n);
    r instanceof vi ? n = r : Array.isArray(r) && r.length == 1 && r[0] instanceof vi ? n = r[0] : n = WS(t, to(r), !1);
  }
  return n;
}
c(W8, "Gg$1");
f(W8, "filterTransaction");
function V8(n) {
  let t = n.startState, e = t.facet(M8), i = n;
  for (let s = e.length - 1; s >= 0; s--) {
    let r = e[s](n);
    r && Object.keys(r).length && (i = IS(i, hO(t, r, n.changes.newLength), !0));
  }
  return i == n ? n : vi.create(t, n.changes, n.selection, i.effects, i.annotations, i.scrollIntoView);
}
c(V8, "Fg$1");
f(V8, "extendTransaction");
const $D = [];
function to(n) {
  return n == null ? $D : Array.isArray(n) ? n : [n];
}
c(to, "wi$1");
f(to, "asArray");
var _s = /* @__PURE__ */ (function(n) {
  return n[n.Word = 0] = "Word", n[n.Space = 1] = "Space", n[n.Other = 2] = "Other", n;
})(_s || (_s = {}));
const xD = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let gk;
try {
  gk = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function D8(n) {
  if (gk)
    return gk.test(n);
  for (let t = 0; t < n.length; t++) {
    let e = n[t];
    if (/\w/.test(e) || e > "" && (e.toUpperCase() != e.toLowerCase() || xD.test(e)))
      return !0;
  }
  return !1;
}
c(D8, "Jg$1");
f(D8, "hasWordChar");
function q8(n) {
  return (t) => {
    if (!/\S/.test(t))
      return _s.Space;
    if (D8(t))
      return _s.Word;
    for (let e = 0; e < n.length; e++)
      if (t.indexOf(n[e]) > -1)
        return _s.Word;
    return _s.Other;
  };
}
c(q8, "e0$1");
f(q8, "makeCategorizer");
var oi;
const Z8 = (oi = class {
  constructor(t, e, i, s, r, a) {
    this.config = t, this.doc = e, this.selection = i, this.values = s, this.status = t.statusTemplate.slice(), this.computeSlot = r, a && (a._state = this);
    for (let o = 0; o < this.config.dynamicSlots.length; o++)
      oh(this, o << 1);
    this.computeSlot = null;
  }
  field(t, e = !0) {
    let i = this.config.address[t.id];
    if (i == null) {
      if (e)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return oh(this, i), yw(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...t) {
    return WS(this, t, !0);
  }
  /**
  @internal
  */
  applyTransaction(t) {
    let e = this.config, { base: i, compartments: s } = e;
    for (let o of t.effects)
      o.is($8.reconfigure) ? (e && (s = /* @__PURE__ */ new Map(), e.compartments.forEach((l, h) => s.set(h, l)), e = null), s.set(o.value.compartment, o.value.extension)) : o.is(Bt.reconfigure) ? (e = null, i = o.value) : o.is(Bt.appendConfig) && (e = null, i = to(i).concat(o.value));
    let r;
    e ? r = t.startState.values.slice() : (e = E3.resolve(i, s, this), r = new oi(e, this.doc, this.selection, e.dynamicSlots.map(() => null), (o, l) => l.reconfigure(o, this), null).values);
    let a = t.startState.facet(mk) ? t.newSelection : t.newSelection.asSingle();
    new oi(e, t.newDoc, a, r, (o, l) => l.update(o, t), t);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(t) {
    return typeof t == "string" && (t = this.toText(t)), this.changeByRange((e) => ({
      changes: { from: e.from, to: e.to, insert: t },
      range: it.cursor(e.from + t.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(t) {
    let e = this.selection, i = t(e.ranges[0]), s = this.changes(i.changes), r = [i.range], a = to(i.effects);
    for (let o = 1; o < e.ranges.length; o++) {
      let l = t(e.ranges[o]), h = this.changes(l.changes), u = h.map(s);
      for (let y = 0; y < o; y++)
        r[y] = r[y].map(u);
      let p = s.mapDesc(h, !0);
      r.push(l.range.map(p)), s = s.compose(u), a = Bt.mapEffects(a, u).concat(Bt.mapEffects(to(l.effects), p));
    }
    return {
      changes: s,
      selection: it.create(r, e.mainIndex),
      effects: a
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(t = []) {
    return t instanceof Tn ? t : Tn.of(t, this.doc.length, this.facet(oi.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(t) {
    return Ft.of(t.split(this.facet(oi.lineSeparator) || pk));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(t = 0, e = this.doc.length) {
    return this.doc.sliceString(t, e, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(t) {
    let e = this.config.address[t.id];
    return e == null ? t.default : (oh(this, e), yw(this, e));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(t) {
    let e = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (t)
      for (let i in t) {
        let s = t[i];
        s instanceof rr && this.config.address[s.id] != null && (e[i] = s.spec.toJSON(this.field(t[i]), this));
      }
    return e;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(t, e = {}, i) {
    if (!t || typeof t.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let s = [];
    if (i) {
      for (let r in i)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          let a = i[r], o = t[r];
          s.push(a.init((l) => a.spec.fromJSON(o, l)));
        }
    }
    return oi.create({
      doc: t.doc,
      selection: it.fromJSON(t.selection),
      extensions: e.extensions ? s.concat([e.extensions]) : s
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(t = {}) {
    let e = E3.resolve(t.extensions || [], /* @__PURE__ */ new Map()), i = t.doc instanceof Ft ? t.doc : Ft.of((t.doc || "").split(e.staticFacet(oi.lineSeparator) || pk)), s = t.selection ? t.selection instanceof it ? t.selection : it.single(t.selection.anchor, t.selection.head) : it.single(0);
    return zS(s, i.length), e.staticFacet(mk) || (s = s.asSingle()), new oi(e, i, s, e.dynamicSlots.map(() => null), (r, a) => a.create(r), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(oi.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(oi.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(A8);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(t, ...e) {
    for (let i of this.facet(oi.phrases))
      if (Object.prototype.hasOwnProperty.call(i, t)) {
        t = i[t];
        break;
      }
    return e.length && (t = t.replace(/\$(\$|\d*)/g, (i, s) => {
      if (s == "$")
        return "$";
      let r = +(s || 1);
      return !r || r > e.length ? i : e[r - 1];
    })), t;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(t, e, i = -1) {
    let s = [];
    for (let r of this.facet(C8))
      for (let a of r(this, e, i))
        Object.prototype.hasOwnProperty.call(a, t) && s.push(a[t]);
    return s;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(t) {
    let e = this.languageDataAt("wordChars", t);
    return q8(e.length ? e[0] : "");
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(t) {
    let { text: e, from: i, length: s } = this.doc.lineAt(t), r = this.charCategorizer(t), a = t - i, o = t - i;
    for (; a > 0; ) {
      let l = Ui(e, a, !1);
      if (r(e.slice(l, a)) != _s.Word)
        break;
      a = l;
    }
    for (; o < s; ) {
      let l = Ui(e, o);
      if (r(e.slice(o, l)) != _s.Word)
        break;
      o = l;
    }
    return a == o ? null : it.range(a + i, o + i);
  }
}, c(oi, "xe"), oi);
f(Z8, "EditorState");
let Ie = Z8;
Ie.allowMultipleSelections = mk;
Ie.tabSize = /* @__PURE__ */ bt.define({
  combine: /* @__PURE__ */ f((n) => n.length ? n[0] : 4, "combine")
});
Ie.lineSeparator = P8;
Ie.readOnly = A8;
Ie.phrases = /* @__PURE__ */ bt.define({
  compare(n, t) {
    let e = Object.keys(n), i = Object.keys(t);
    return e.length == i.length && e.every((s) => n[s] == t[s]);
  }
});
Ie.languageData = C8;
Ie.changeFilter = Q8;
Ie.transactionFilter = T8;
Ie.transactionExtender = M8;
$8.reconfigure = /* @__PURE__ */ Bt.define();
function VS(n, t, e = {}) {
  let i = {};
  for (let s of n)
    for (let r of Object.keys(s)) {
      let a = s[r], o = i[r];
      if (o === void 0)
        i[r] = a;
      else if (!(o === a || a === void 0)) if (Object.hasOwnProperty.call(e, r))
        i[r] = e[r](o, a);
      else
        throw new Error("Config merge conflict for field " + r);
    }
  for (let s in t)
    i[s] === void 0 && (i[s] = t[s]);
  return i;
}
c(VS, "md$1");
f(VS, "combineConfig");
var Rh;
const F8 = (Rh = class {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(t) {
    return this == t;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(t, e = t) {
    return wk.create(t, e, this);
  }
}, c(Rh, "sf"), Rh);
f(F8, "RangeValue");
let ta = F8;
ta.prototype.startSide = ta.prototype.endSide = 0;
ta.prototype.point = !1;
ta.prototype.mapMode = wi.TrackDel;
function Mb(n, t) {
  return n == t || n.constructor == t.constructor && n.eq(t);
}
c(Mb, "ch$1");
f(Mb, "cmpVal");
var Z1, Eh;
let wk = (Z1 = (Eh = class {
  constructor(t, e, i) {
    this.from = t, this.to = e, this.value = i;
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new Z1(t, e, i);
  }
}, c(Eh, "ti$1"), Eh), f(Z1, "Range"), Z1);
function dO(n, t) {
  return n.from - t.from || n.value.startSide - t.value.startSide;
}
c(dO, "ml$1");
f(dO, "cmpRange");
var mo;
const X8 = (mo = class {
  constructor(t, e, i, s) {
    this.from = t, this.to = e, this.value = i, this.maxPoint = s;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(t, e, i, s = 0) {
    let r = i ? this.to : this.from;
    for (let a = s, o = r.length; ; ) {
      if (a == o)
        return a;
      let l = a + o >> 1, h = r[l] - t || (i ? this.value[l].endSide : this.value[l].startSide) - e;
      if (l == a)
        return h >= 0 ? a : o;
      h >= 0 ? o = l : a = l + 1;
    }
  }
  between(t, e, i, s) {
    for (let r = this.findIndex(e, -1e9, !0), a = this.findIndex(i, 1e9, !1, r); r < a; r++)
      if (s(this.from[r] + t, this.to[r] + t, this.value[r]) === !1)
        return !1;
  }
  map(t, e) {
    let i = [], s = [], r = [], a = -1, o = -1;
    for (let l = 0; l < this.value.length; l++) {
      let h = this.value[l], u = this.from[l] + t, p = this.to[l] + t, y, m;
      if (u == p) {
        let g = e.mapPos(u, h.startSide, h.mapMode);
        if (g == null || (y = m = g, h.startSide != h.endSide && (m = e.mapPos(u, h.endSide), m < y)))
          continue;
      } else if (y = e.mapPos(u, h.startSide), m = e.mapPos(p, h.endSide), y > m || y == m && h.startSide > 0 && h.endSide <= 0)
        continue;
      (m - y || h.endSide - h.startSide) < 0 || (a < 0 && (a = y), h.point && (o = Math.max(o, m - y)), i.push(h), s.push(y - a), r.push(m - a));
    }
    return { mapped: i.length ? new mo(s, r, i, o) : null, pos: a };
  }
}, c(mo, "Is"), mo);
f(X8, "Chunk");
let kD = X8;
var Pi;
const N8 = (Pi = class {
  constructor(t, e, i, s) {
    this.chunkPos = t, this.chunk = e, this.nextLayer = i, this.maxPoint = s;
  }
  /**
  @internal
  */
  static create(t, e, i, s) {
    return new Pi(t, e, i, s);
  }
  /**
  @internal
  */
  get length() {
    let t = this.chunk.length - 1;
    return t < 0 ? 0 : Math.max(this.chunkEnd(t), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let t = this.nextLayer.size;
    for (let e of this.chunk)
      t += e.value.length;
    return t;
  }
  /**
  @internal
  */
  chunkEnd(t) {
    return this.chunkPos[t] + this.chunk[t].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(t) {
    let { add: e = [], sort: i = !1, filterFrom: s = 0, filterTo: r = this.length } = t, a = t.filter;
    if (e.length == 0 && !a)
      return this;
    if (i && (e = e.slice().sort(dO)), this.isEmpty)
      return e.length ? Pi.of(e) : this;
    let o = new H8(this, null, -1).goto(0), l = 0, h = [], u = new uO();
    for (; o.value || l < e.length; )
      if (l < e.length && (o.from - e[l].from || o.startSide - e[l].value.startSide) >= 0) {
        let p = e[l++];
        u.addInner(p.from, p.to, p.value) || h.push(p);
      } else o.rangeIndex == 1 && o.chunkIndex < this.chunk.length && (l == e.length || this.chunkEnd(o.chunkIndex) < e[l].from) && (!a || s > this.chunkEnd(o.chunkIndex) || r < this.chunkPos[o.chunkIndex]) && u.addChunk(this.chunkPos[o.chunkIndex], this.chunk[o.chunkIndex]) ? o.nextChunk() : ((!a || s > o.to || r < o.from || a(o.from, o.to, o.value)) && (u.addInner(o.from, o.to, o.value) || h.push(wk.create(o.from, o.to, o.value))), o.next());
    return u.finishInner(this.nextLayer.isEmpty && !h.length ? Pi.empty : this.nextLayer.update({ add: h, filter: a, filterFrom: s, filterTo: r }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(t) {
    if (t.empty || this.isEmpty)
      return this;
    let e = [], i = [], s = -1;
    for (let a = 0; a < this.chunk.length; a++) {
      let o = this.chunkPos[a], l = this.chunk[a], h = t.touchesRange(o, o + l.length);
      if (h === !1)
        s = Math.max(s, l.maxPoint), e.push(l), i.push(t.mapPos(o));
      else if (h === !0) {
        let { mapped: u, pos: p } = l.map(o, t);
        u && (s = Math.max(s, u.maxPoint), e.push(u), i.push(p));
      }
    }
    let r = this.nextLayer.map(t);
    return e.length == 0 ? r : new Pi(i, e, r || Pi.empty, s);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(t, e, i) {
    if (!this.isEmpty) {
      for (let s = 0; s < this.chunk.length; s++) {
        let r = this.chunkPos[s], a = this.chunk[s];
        if (e >= r && t <= r + a.length && a.between(r, t - r, e - r, i) === !1)
          return;
      }
      this.nextLayer.between(t, e, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(t = 0) {
    return Ok.from([this]).goto(t);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(t, e = 0) {
    return Ok.from(t).goto(e);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(t, e, i, s, r = -1) {
    let a = t.filter((p) => p.maxPoint > 0 || !p.isEmpty && p.maxPoint >= r), o = e.filter((p) => p.maxPoint > 0 || !p.isEmpty && p.maxPoint >= r), l = vk(a, o, i), h = new Fm(a, l, r), u = new Fm(o, l, r);
    i.iterGaps((p, y, m) => bk(h, p, u, y, m, s)), i.empty && i.length == 0 && bk(h, 0, u, 0, 0, s);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(t, e, i = 0, s) {
    s == null && (s = 999999999);
    let r = t.filter((u) => !u.isEmpty && e.indexOf(u) < 0), a = e.filter((u) => !u.isEmpty && t.indexOf(u) < 0);
    if (r.length != a.length)
      return !1;
    if (!r.length)
      return !0;
    let o = vk(r, a), l = new Fm(r, o, 0).goto(i), h = new Fm(a, o, 0).goto(i);
    for (; ; ) {
      if (l.to != h.to || !pO(l.active, h.active) || l.point && (!h.point || !Mb(l.point, h.point)))
        return !1;
      if (l.to > s)
        return !0;
      l.next(), h.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(t, e, i, s, r = -1) {
    let a = new Fm(t, null, r).goto(e), o = e, l = a.openStart;
    for (; ; ) {
      let h = Math.min(a.to, i);
      if (a.point) {
        let u = a.activeForPoint(a.to), p = a.pointFrom < e ? u.length + 1 : a.point.startSide < 0 ? u.length : Math.min(u.length, l);
        s.point(o, h, a.point, u, p, a.pointRank), l = Math.min(a.openEnd(h), u.length);
      } else h > o && (s.span(o, h, a.active, l), l = a.openEnd(h));
      if (a.to > i)
        return l + (a.point && a.to > i ? 1 : 0);
      o = a.to, a.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(t, e = !1) {
    let i = new uO();
    for (let s of t instanceof wk ? [t] : e ? j8(t) : t)
      i.add(s.from, s.to, s.value);
    return i.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(t) {
    if (!t.length)
      return Pi.empty;
    let e = t[t.length - 1];
    for (let i = t.length - 2; i >= 0; i--)
      for (let s = t[i]; s != Pi.empty; s = s.nextLayer)
        e = new Pi(s.chunkPos, s.chunk, e, Math.max(s.maxPoint, e.maxPoint));
    return e;
  }
}, c(Pi, "Ve"), Pi);
f(N8, "RangeSet");
let Qe = N8;
Qe.empty = /* @__PURE__ */ new Qe([], [], null, -1);
function j8(n) {
  if (n.length > 1)
    for (let t = n[0], e = 1; e < n.length; e++) {
      let i = n[e];
      if (dO(t, i) > 0)
        return n.slice().sort(dO);
      t = i;
    }
  return n;
}
c(j8, "t0$1");
f(j8, "lazySort");
Qe.empty.nextLayer = Qe.empty;
var go;
const B8 = (go = class {
  finishChunk(t) {
    this.chunks.push(new kD(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, t && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(t, e, i) {
    this.addInner(t, e, i) || (this.nextLayer || (this.nextLayer = new go())).add(t, e, i);
  }
  /**
  @internal
  */
  addInner(t, e, i) {
    let s = t - this.lastTo || i.startSide - this.last.endSide;
    if (s <= 0 && (t - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return s < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = t), this.from.push(t - this.chunkStart), this.to.push(e - this.chunkStart), this.last = i, this.lastFrom = t, this.lastTo = e, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, e - t)), !0);
  }
  /**
  @internal
  */
  addChunk(t, e) {
    if ((t - this.lastTo || e.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, e.maxPoint), this.chunks.push(e), this.chunkPos.push(t);
    let i = e.value.length - 1;
    return this.last = e.value[i], this.lastFrom = e.from[i] + t, this.lastTo = e.to[i] + t, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(Qe.empty);
  }
  /**
  @internal
  */
  finishInner(t) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return t;
    let e = Qe.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(t) : t, this.setMaxPoint);
    return this.from = null, e;
  }
}, c(go, "zs"), go);
f(B8, "RangeSetBuilder");
let uO = B8;
function vk(n, t, e) {
  let i = /* @__PURE__ */ new Map();
  for (let r of n)
    for (let a = 0; a < r.chunk.length; a++)
      r.chunk[a].maxPoint <= 0 && i.set(r.chunk[a], r.chunkPos[a]);
  let s = /* @__PURE__ */ new Set();
  for (let r of t)
    for (let a = 0; a < r.chunk.length; a++) {
      let o = i.get(r.chunk[a]);
      o != null && (e ? e.mapPos(o) : o) == r.chunkPos[a] && !e?.touchesRange(o, o + r.chunk[a].length) && s.add(r.chunk[a]);
    }
  return s;
}
c(vk, "nu$1");
f(vk, "findSharedChunks");
var _h;
const U8 = (_h = class {
  constructor(t, e, i, s = 0) {
    this.layer = t, this.skip = e, this.minPoint = i, this.rank = s;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(t, e = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(t, e, !1), this;
  }
  gotoInner(t, e, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let s = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(s) || this.layer.chunkEnd(this.chunkIndex) < t || s.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let s = this.layer.chunk[this.chunkIndex].findIndex(t - this.layer.chunkPos[this.chunkIndex], e, !0);
      (!i || this.rangeIndex < s) && this.setRangeIndex(s);
    }
    this.next();
  }
  forward(t, e) {
    (this.to - t || this.endSide - e) < 0 && this.gotoInner(t, e, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let t = this.layer.chunkPos[this.chunkIndex], e = this.layer.chunk[this.chunkIndex], i = t + e.from[this.rangeIndex];
        if (this.from = i, this.to = t + e.to[this.rangeIndex], this.value = e.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(t) {
    if (t == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = t;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(t) {
    return this.from - t.from || this.startSide - t.startSide || this.rank - t.rank || this.to - t.to || this.endSide - t.endSide;
  }
}, c(_h, "of"), _h);
f(U8, "LayerCursor");
let H8 = U8;
var wo;
const Y8 = (wo = class {
  constructor(t) {
    this.heap = t;
  }
  static from(t, e = null, i = -1) {
    let s = [];
    for (let r = 0; r < t.length; r++)
      for (let a = t[r]; !a.isEmpty; a = a.nextLayer)
        a.maxPoint >= i && s.push(new H8(a, e, i, r));
    return s.length == 1 ? s[0] : new wo(s);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(t, e = -1e9) {
    for (let i of this.heap)
      i.goto(t, e);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      mv(this.heap, i);
    return this.next(), this;
  }
  forward(t, e) {
    for (let i of this.heap)
      i.forward(t, e);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      mv(this.heap, i);
    (this.to - t || this.value.endSide - e) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let t = this.heap[0];
      this.from = t.from, this.to = t.to, this.value = t.value, this.rank = t.rank, t.value && t.next(), mv(this.heap, 0);
    }
  }
}, c(wo, "js"), wo);
f(Y8, "HeapCursor");
let Ok = Y8;
function mv(n, t) {
  for (let e = n[t]; ; ) {
    let i = (t << 1) + 1;
    if (i >= n.length)
      break;
    let s = n[i];
    if (i + 1 < n.length && s.compare(n[i + 1]) >= 0 && (s = n[i + 1], i++), e.compare(s) < 0)
      break;
    n[i] = e, n[t] = s, t = i;
  }
}
c(mv, "vo$1");
f(mv, "heapBubble");
var zh;
const G8 = (zh = class {
  constructor(t, e, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Ok.from(t, e, i);
  }
  goto(t, e = -1e9) {
    return this.cursor.goto(t, e), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = t, this.endSide = e, this.openStart = -1, this.next(), this;
  }
  forward(t, e) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - t || this.active[this.minActive].endSide - e) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(t, e);
  }
  removeActive(t) {
    fg(this.active, t), fg(this.activeTo, t), fg(this.activeRank, t), this.minActive = $k(this.active, this.activeTo);
  }
  addActive(t) {
    let e = 0, { value: i, to: s, rank: r } = this.cursor;
    for (; e < this.activeRank.length && (r - this.activeRank[e] || s - this.activeTo[e]) > 0; )
      e++;
    yg(this.active, e, i), yg(this.activeTo, e, s), yg(this.activeRank, e, r), t && yg(t, e, this.cursor.from), this.minActive = $k(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let t = this.to, e = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let s = this.minActive;
      if (s > -1 && (this.activeTo[s] - this.cursor.from || this.active[s].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[s] > t) {
          this.to = this.activeTo[s], this.endSide = this.active[s].endSide;
          break;
        }
        this.removeActive(s), i && fg(i, s);
      } else if (this.cursor.value)
        if (this.cursor.from > t) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let r = this.cursor.value;
          if (!r.point)
            this.addActive(i), this.cursor.next();
          else if (e && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = r, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = r.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let s = i.length - 1; s >= 0 && i[s] < t; s--)
        this.openStart++;
    }
  }
  activeForPoint(t) {
    if (!this.active.length)
      return this.active;
    let e = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > t || this.activeTo[i] == t && this.active[i].endSide >= this.point.endSide) && e.push(this.active[i]);
    return e.reverse();
  }
  openEnd(t) {
    let e = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > t; i--)
      e++;
    return e;
  }
}, c(zh, "lf"), zh);
f(G8, "SpanCursor");
let Fm = G8;
function bk(n, t, e, i, s, r) {
  n.goto(t), e.goto(i);
  let a = i + s, o = i, l = i - t, h = !!r.boundChange;
  for (let u = !1; ; ) {
    let p = n.to + l - e.to, y = p || n.endSide - e.endSide, m = y < 0 ? n.to + l : e.to, g = Math.min(m, a);
    if (n.point || e.point ? (n.point && e.point && Mb(n.point, e.point) && pO(n.activeForPoint(n.to), e.activeForPoint(e.to)) || r.comparePoint(o, g, n.point, e.point), u = !1) : (u && r.boundChange(o), g > o && !pO(n.active, e.active) && r.compareRange(o, g, n.active, e.active), h && g < a && (p || n.openEnd(m) != e.openEnd(m)) && (u = !0)), m > a)
      break;
    o = m, y <= 0 && n.next(), y >= 0 && e.next();
  }
}
c(bk, "su$1");
f(bk, "compare");
function pO(n, t) {
  if (n.length != t.length)
    return !1;
  for (let e = 0; e < n.length; e++)
    if (n[e] != t[e] && !Mb(n[e], t[e]))
      return !1;
  return !0;
}
c(pO, "Ql$1");
f(pO, "sameValues");
function fg(n, t) {
  for (let e = t, i = n.length - 1; e < i; e++)
    n[e] = n[e + 1];
  n.pop();
}
c(fg, "$n$1");
f(fg, "remove");
function yg(n, t, e) {
  for (let i = n.length - 1; i >= t; i--)
    n[i + 1] = n[i];
  n[t] = e;
}
c(yg, "Rn$1");
f(yg, "insert");
function $k(n, t) {
  let e = -1, i = 1e9;
  for (let s = 0; s < t.length; s++)
    (t[s] - i || n[s].endSide - n[e].endSide) < 0 && (e = s, i = t[s]);
  return e;
}
c($k, "ou$1");
f($k, "findMinIndex");
function ea(n, t, e = n.length) {
  let i = 0;
  for (let s = 0; s < e && s < n.length; )
    n.charCodeAt(s) == 9 ? (i += t - i % t, s++) : (i++, s = Ui(n, s));
  return i;
}
c(ea, "ut$1");
f(ea, "countColumn");
function K8(n, t, e, i) {
  for (let s = 0, r = 0; ; ) {
    if (r >= t)
      return s;
    if (s == n.length)
      break;
    r += n.charCodeAt(s) == 9 ? e - r % e : 1, s = Ui(n, s);
  }
  return n.length;
}
c(K8, "i0$1");
f(K8, "findColumn");
const xk = "ͼ", _3 = typeof Symbol > "u" ? "__" + xk : Symbol.for(xk), kk = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), z3 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
var Lh;
const J8 = (Lh = class {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(t, e) {
    this.rules = [];
    let { finish: i } = e || {};
    function s(a) {
      return /^@/.test(a) ? [a] : a.split(/,\s*/);
    }
    c(s, "n"), f(s, "splitSelector");
    function r(a, o, l, h) {
      let u = [], p = /^@(\w+)\b/.exec(a[0]), y = p && p[1] == "keyframes";
      if (p && o == null) return l.push(a[0] + ";");
      for (let m in o) {
        let g = o[m];
        if (/&/.test(m))
          r(
            m.split(/,\s*/).map((b) => a.map((S) => b.replace(/&/, S))).reduce((b, S) => b.concat(S)),
            g,
            l
          );
        else if (g && typeof g == "object") {
          if (!p) throw new RangeError("The value of a property (" + m + ") should be a primitive value.");
          r(s(m), g, u, y);
        } else g != null && u.push(m.replace(/_.*/, "").replace(/[A-Z]/g, (b) => "-" + b.toLowerCase()) + ": " + g + ";");
      }
      (u.length || y) && l.push((i && !p && !h ? a.map(i) : a).join(", ") + " {" + u.join(" ") + "}");
    }
    c(r, "s"), f(r, "render");
    for (let a in t) r(s(a), t[a], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let t = z3[_3] || 1;
    return z3[_3] = t + 1, xk + t.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(t, e, i) {
    let s = t[kk], r = i && i.nonce;
    s ? r && s.setNonce(r) : s = new SD(t, r), s.mount(Array.isArray(e) ? e : [e], t);
  }
}, c(Lh, "af"), Lh);
f(J8, "StyleModule");
let ia = J8, L3 = /* @__PURE__ */ new Map();
var Ih;
const t7 = (Ih = class {
  constructor(t, e) {
    let i = t.ownerDocument || t, s = i.defaultView;
    if (!t.head && t.adoptedStyleSheets && s.CSSStyleSheet) {
      let r = L3.get(i);
      if (r) return t[kk] = r;
      this.sheet = new s.CSSStyleSheet(), L3.set(i, this);
    } else
      this.styleTag = i.createElement("style"), e && this.styleTag.setAttribute("nonce", e);
    this.modules = [], t[kk] = this;
  }
  mount(t, e) {
    let i = this.sheet, s = 0, r = 0;
    for (let a = 0; a < t.length; a++) {
      let o = t[a], l = this.modules.indexOf(o);
      if (l < r && l > -1 && (this.modules.splice(l, 1), r--, l = -1), l == -1) {
        if (this.modules.splice(r++, 0, o), i) for (let h = 0; h < o.rules.length; h++)
          i.insertRule(o.rules[h], s++);
      } else {
        for (; r < l; ) s += this.modules[r++].rules.length;
        s += o.rules.length, r++;
      }
    }
    if (i)
      e.adoptedStyleSheets.indexOf(this.sheet) < 0 && (e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets]);
    else {
      let a = "";
      for (let l = 0; l < this.modules.length; l++)
        a += this.modules[l].getRules() + `
`;
      this.styleTag.textContent = a;
      let o = e.head || e;
      this.styleTag.parentNode != o && o.insertBefore(this.styleTag, o.firstChild);
    }
  }
  setNonce(t) {
    this.styleTag && this.styleTag.getAttribute("nonce") != t && this.styleTag.setAttribute("nonce", t);
  }
}, c(Ih, "hf"), Ih);
f(t7, "StyleSet");
let SD = t7;
var na = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, mw = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, CD = typeof navigator < "u" && /Mac/.test(navigator.platform), PD = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var ei = 0; ei < 10; ei++) na[48 + ei] = na[96 + ei] = String(ei);
for (var ei = 1; ei <= 24; ei++) na[ei + 111] = "F" + ei;
for (var ei = 65; ei <= 90; ei++)
  na[ei] = String.fromCharCode(ei + 32), mw[ei] = String.fromCharCode(ei);
for (var K0 in na) mw.hasOwnProperty(K0) || (mw[K0] = na[K0]);
function e7(n) {
  var t = CD && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || PD && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", e = !t && n.key || (n.shiftKey ? mw : na)[n.keyCode] || n.key || "Unidentified";
  return e == "Esc" && (e = "Escape"), e == "Del" && (e = "Delete"), e == "Left" && (e = "ArrowLeft"), e == "Up" && (e = "ArrowUp"), e == "Right" && (e = "ArrowRight"), e == "Down" && (e = "ArrowDown"), e;
}
c(e7, "s0$1");
f(e7, "keyName");
let mi = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, Sk = typeof document < "u" ? document : { documentElement: { style: {} } };
const Ck = /* @__PURE__ */ /Edge\/(\d+)/.exec(mi.userAgent), i7 = /* @__PURE__ */ /MSIE \d/.test(mi.userAgent), Pk = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(mi.userAgent), Ab = !!(i7 || Pk || Ck), I3 = !Ab && /* @__PURE__ */ /gecko\/(\d+)/i.test(mi.userAgent), J0 = !Ab && /* @__PURE__ */ /Chrome\/(\d+)/.exec(mi.userAgent), QD = "webkitFontSmoothing" in Sk.documentElement.style, Qk = !Ab && /* @__PURE__ */ /Apple Computer/.test(mi.vendor), W3 = Qk && (/* @__PURE__ */ /Mobile\/\w+/.test(mi.userAgent) || mi.maxTouchPoints > 2);
var nt = {
  mac: W3 || /* @__PURE__ */ /Mac/.test(mi.platform),
  windows: /* @__PURE__ */ /Win/.test(mi.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(mi.platform),
  ie: Ab,
  ie_version: i7 ? Sk.documentMode || 6 : Pk ? +Pk[1] : Ck ? +Ck[1] : 0,
  gecko: I3,
  gecko_version: I3 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(mi.userAgent) || [0, 0])[1] : 0,
  chrome: !!J0,
  chrome_version: J0 ? +J0[1] : 0,
  ios: W3,
  android: /* @__PURE__ */ /Android\b/.test(mi.userAgent),
  webkit_version: QD ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(mi.userAgent) || [0, 0])[1] : 0,
  safari: Qk,
  safari_version: Qk ? +(/* @__PURE__ */ /\bVersion\/(\d+(\.\d+)?)/.exec(mi.userAgent) || [0, 0])[1] : 0,
  tabSize: Sk.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
function Rb(n, t) {
  for (let e in n)
    e == "class" && t.class ? t.class += " " + n.class : e == "style" && t.style ? t.style += ";" + n.style : t[e] = n[e];
  return t;
}
c(Rb, "uh$1");
f(Rb, "combineAttrs");
const fO = /* @__PURE__ */ Object.create(null);
function Eb(n, t, e) {
  if (n == t)
    return !0;
  n || (n = fO), t || (t = fO);
  let i = Object.keys(n), s = Object.keys(t);
  if (i.length - 0 != s.length - 0)
    return !1;
  for (let r of i)
    if (r != e && (s.indexOf(r) == -1 || n[r] !== t[r]))
      return !1;
  return !0;
}
c(Eb, "Oh$1");
f(Eb, "attrsEq");
function n7(n, t) {
  for (let e = n.attributes.length - 1; e >= 0; e--) {
    let i = n.attributes[e].name;
    t[i] == null && n.removeAttribute(i);
  }
  for (let e in t) {
    let i = t[e];
    e == "style" ? n.style.cssText = i : n.getAttribute(e) != i && n.setAttribute(e, i);
  }
}
c(n7, "l0$1");
f(n7, "setAttrs");
function Tk(n, t, e) {
  let i = !1;
  if (t)
    for (let s in t)
      e && s in e || (i = !0, s == "style" ? n.style.cssText = "" : n.removeAttribute(s));
  if (e)
    for (let s in e)
      t && t[s] == e[s] || (i = !0, s == "style" ? n.style.cssText = e[s] : n.setAttribute(s, e[s]));
  return i;
}
c(Tk, "uu$1");
f(Tk, "updateAttrs");
function s7(n) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let e = 0; e < n.attributes.length; e++) {
    let i = n.attributes[e];
    t[i.name] = i.value;
  }
  return t;
}
c(s7, "a0$1");
f(s7, "getAttrs$1");
var Wh;
const r7 = (Wh = class {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(t) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(t, e) {
    return !1;
  }
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(t) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(t, e, i) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(t) {
  }
}, c(Wh, "ff"), Wh);
f(r7, "WidgetType");
let Pl = r7;
var cn = /* @__PURE__ */ (function(n) {
  return n[n.Text = 0] = "Text", n[n.WidgetBefore = 1] = "WidgetBefore", n[n.WidgetAfter = 2] = "WidgetAfter", n[n.WidgetRange = 3] = "WidgetRange", n;
})(cn || (cn = {})), Vh;
const a7 = (Vh = class extends ta {
  constructor(t, e, i, s) {
    super(), this.startSide = t, this.endSide = e, this.widget = i, this.spec = s;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(t) {
    return new DS(t);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(t) {
    let e = Math.max(-1e4, Math.min(1e4, t.side || 0)), i = !!t.block;
    return e += i && !t.inlineOrder ? e > 0 ? 3e8 : -4e8 : e > 0 ? 1e8 : -1e8, new gw(t, e, e, i, t.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(t) {
    let e = !!t.block, i, s;
    if (t.isBlockGap)
      i = -5e8, s = 4e8;
    else {
      let { start: r, end: a } = ZS(t, e);
      i = (r ? e ? -3e8 : -1 : 5e8) - 1, s = (a ? e ? 2e8 : 1 : -6e8) + 1;
    }
    return new gw(t, i, s, e, t.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(t) {
    return new qS(t);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(t, e = !1) {
    return Qe.of(t, e);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}, c(Vh, "cf"), Vh);
f(a7, "Decoration");
let Gt = a7;
Gt.none = Qe.empty;
var vo;
const o7 = (vo = class extends Gt {
  constructor(t) {
    let { start: e, end: i } = ZS(t);
    super(e ? -1 : 5e8, i ? 1 : -6e8, null, t), this.tagName = t.tagName || "span", this.attrs = t.class && t.attributes ? Rb(t.attributes, { class: t.class }) : t.class ? { class: t.class } : t.attributes || fO;
  }
  eq(t) {
    return this == t || t instanceof vo && this.tagName == t.tagName && Eb(this.attrs, t.attrs);
  }
  range(t, e = t) {
    if (t >= e)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(t, e);
  }
}, c(vo, "qs"), vo);
f(o7, "MarkDecoration");
let DS = o7;
DS.prototype.point = !1;
var Oo;
const l7 = (Oo = class extends Gt {
  constructor(t) {
    super(-2e8, -2e8, null, t);
  }
  eq(t) {
    return t instanceof Oo && this.spec.class == t.spec.class && Eb(this.spec.attributes, t.spec.attributes);
  }
  range(t, e = t) {
    if (e != t)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(t, e);
  }
}, c(Oo, "Bs"), Oo);
f(l7, "LineDecoration");
let qS = l7;
qS.prototype.mapMode = wi.TrackBefore;
qS.prototype.point = !0;
var bo;
const c7 = (bo = class extends Gt {
  constructor(t, e, i, s, r, a) {
    super(e, i, r, t), this.block = s, this.isReplace = a, this.mapMode = s ? e <= 0 ? wi.TrackBefore : wi.TrackAfter : wi.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? cn.WidgetRange : this.startSide <= 0 ? cn.WidgetBefore : cn.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(t) {
    return t instanceof bo && h7(this.widget, t.widget) && this.block == t.block && this.startSide == t.startSide && this.endSide == t.endSide;
  }
  range(t, e = t) {
    if (this.isReplace && (t > e || t == e && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && e != t)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(t, e);
  }
}, c(bo, "Ds"), bo);
f(c7, "PointDecoration");
let gw = c7;
gw.prototype.point = !0;
function ZS(n, t = !1) {
  let { inclusiveStart: e, inclusiveEnd: i } = n;
  return e == null && (e = n.inclusive), i == null && (i = n.inclusive), { start: e ?? t, end: i ?? t };
}
c(ZS, "Qd$1");
f(ZS, "getInclusive");
function h7(n, t) {
  return n == t || !!(n && t && n.compare(t));
}
c(h7, "h0$1");
f(h7, "widgetsEq");
function eo(n, t, e, i = 0) {
  let s = e.length - 1;
  s >= 0 && e[s] + i >= n ? e[s] = Math.max(e[s], t) : e.push(n, t);
}
c(eo, "xi$1");
f(eo, "addRange");
var Lr;
const d7 = (Lr = class extends ta {
  constructor(t, e) {
    super(), this.tagName = t, this.attributes = e;
  }
  eq(t) {
    return t == this || t instanceof Lr && this.tagName == t.tagName && Eb(this.attributes, t.attributes);
  }
  /**
  Create a block wrapper object with the given tag name and
  attributes.
  */
  static create(t) {
    return new Lr(t.tagName, t.attributes || fO);
  }
  /**
  Create a range set from the given block wrapper ranges.
  */
  static set(t, e = !1) {
    return Qe.of(t, e);
  }
}, c(Lr, "Ar"), Lr);
f(d7, "BlockWrapper");
let V3 = d7;
V3.prototype.startSide = V3.prototype.endSide = -1;
function Ko(n) {
  let t;
  return n.nodeType == 11 ? t = n.getSelection ? n : n.ownerDocument : t = n, t.getSelection();
}
c(Ko, "Xi$1");
f(Ko, "getSelection");
function yO(n, t) {
  return t ? n == t || n.contains(t.nodeType != 1 ? t.parentNode : t) : !1;
}
c(yO, "$l$1");
f(yO, "contains");
function lh(n, t) {
  if (!t.anchorNode)
    return !1;
  try {
    return yO(n, t.anchorNode);
  } catch {
    return !1;
  }
}
c(lh, "gr$1");
f(lh, "hasSelection");
function ch(n) {
  return n.nodeType == 3 ? Uy(n, 0, n.nodeValue.length).getClientRects() : n.nodeType == 1 ? n.getClientRects() : [];
}
c(ch, "Qr$1");
f(ch, "clientRectsFor");
function hh(n, t, e, i) {
  return e ? Mk(n, t, e, i, -1) || Mk(n, t, e, i, 1) : !1;
}
c(hh, "yr$1");
f(hh, "isEquivalentPosition");
function Bs(n) {
  for (var t = 0; ; t++)
    if (n = n.previousSibling, !n)
      return t;
}
c(Bs, "At$2");
f(Bs, "domIndex");
function ww(n) {
  return n.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(n.nodeName);
}
c(ww, "ns$2");
f(ww, "isBlockElement");
function Mk(n, t, e, i, s) {
  for (; ; ) {
    if (n == e && t == i)
      return !0;
    if (t == (s < 0 ? 0 : os(n))) {
      if (n.nodeName == "DIV")
        return !1;
      let r = n.parentNode;
      if (!r || r.nodeType != 1)
        return !1;
      t = Bs(n) + (s < 0 ? 0 : 1), n = r;
    } else if (n.nodeType == 1) {
      if (n = n.childNodes[t + (s < 0 ? -1 : 0)], n.nodeType == 1 && n.contentEditable == "false")
        return !1;
      t = s < 0 ? os(n) : 0;
    } else
      return !1;
  }
}
c(Mk, "Ou");
f(Mk, "scanFor");
function os(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
c(os, "dt$1");
f(os, "maxOffset");
function By(n, t) {
  let e = t ? n.left : n.right;
  return { left: e, right: e, top: n.top, bottom: n.bottom };
}
c(By, "Jr$1");
f(By, "flattenRect");
function u7(n) {
  let t = n.visualViewport;
  return t ? {
    left: 0,
    right: t.width,
    top: 0,
    bottom: t.height
  } : {
    left: 0,
    right: n.innerWidth,
    top: 0,
    bottom: n.innerHeight
  };
}
c(u7, "f0$1");
f(u7, "windowRect");
function FS(n, t) {
  let e = t.width / n.offsetWidth, i = t.height / n.offsetHeight;
  return (e > 0.995 && e < 1.005 || !isFinite(e) || Math.abs(t.width - n.offsetWidth) < 1) && (e = 1), (i > 0.995 && i < 1.005 || !isFinite(i) || Math.abs(t.height - n.offsetHeight) < 1) && (i = 1), { scaleX: e, scaleY: i };
}
c(FS, "yd$1");
f(FS, "getScale");
function p7(n, t, e, i, s, r, a, o) {
  let l = n.ownerDocument, h = l.defaultView || window;
  for (let u = n, p = !1; u && !p; )
    if (u.nodeType == 1) {
      let y, m = u == l.body, g = 1, b = 1;
      if (m)
        y = u7(h);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (p = !0), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
          u = u.assignedSlot || u.parentNode;
          continue;
        }
        let Q = u.getBoundingClientRect();
        ({ scaleX: g, scaleY: b } = FS(u, Q)), y = {
          left: Q.left,
          right: Q.left + u.clientWidth * g,
          top: Q.top,
          bottom: Q.top + u.clientHeight * b
        };
      }
      let S = 0, x = 0;
      if (s == "nearest")
        t.top < y.top ? (x = t.top - (y.top + a), e > 0 && t.bottom > y.bottom + x && (x = t.bottom - y.bottom + a)) : t.bottom > y.bottom && (x = t.bottom - y.bottom + a, e < 0 && t.top - x < y.top && (x = t.top - (y.top + a)));
      else {
        let Q = t.bottom - t.top, L = y.bottom - y.top;
        x = (s == "center" && Q <= L ? t.top + Q / 2 - L / 2 : s == "start" || s == "center" && e < 0 ? t.top - a : t.bottom - L + a) - y.top;
      }
      if (i == "nearest" ? t.left < y.left ? (S = t.left - (y.left + r), e > 0 && t.right > y.right + S && (S = t.right - y.right + r)) : t.right > y.right && (S = t.right - y.right + r, e < 0 && t.left < y.left + S && (S = t.left - (y.left + r))) : S = (i == "center" ? t.left + (t.right - t.left) / 2 - (y.right - y.left) / 2 : i == "start" == o ? t.left - r : t.right - (y.right - y.left) + r) - y.left, S || x)
        if (m)
          h.scrollBy(S, x);
        else {
          let Q = 0, L = 0;
          if (x) {
            let W = u.scrollTop;
            u.scrollTop += x / b, L = (u.scrollTop - W) * b;
          }
          if (S) {
            let W = u.scrollLeft;
            u.scrollLeft += S / g, Q = (u.scrollLeft - W) * g;
          }
          t = {
            left: t.left - Q,
            top: t.top - L,
            right: t.right - Q,
            bottom: t.bottom - L
          }, Q && Math.abs(Q - S) < 1 && (i = "nearest"), L && Math.abs(L - x) < 1 && (s = "nearest");
        }
      if (m)
        break;
      (t.top < y.top || t.bottom > y.bottom || t.left < y.left || t.right > y.right) && (t = {
        left: Math.max(t.left, y.left),
        right: Math.min(t.right, y.right),
        top: Math.max(t.top, y.top),
        bottom: Math.min(t.bottom, y.bottom)
      }), u = u.assignedSlot || u.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
}
c(p7, "c0$1");
f(p7, "scrollRectIntoView");
function f7(n) {
  let t = n.ownerDocument, e, i;
  for (let s = n.parentNode; s && !(s == t.body || e && i); )
    if (s.nodeType == 1)
      !i && s.scrollHeight > s.clientHeight && (i = s), !e && s.scrollWidth > s.clientWidth && (e = s), s = s.assignedSlot || s.parentNode;
    else if (s.nodeType == 11)
      s = s.host;
    else
      break;
  return { x: e, y: i };
}
c(f7, "u0$1");
f(f7, "scrollableParents");
var Dh;
const y7 = (Dh = class {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(t) {
    return this.anchorNode == t.anchorNode && this.anchorOffset == t.anchorOffset && this.focusNode == t.focusNode && this.focusOffset == t.focusOffset;
  }
  setRange(t) {
    let { anchorNode: e, focusNode: i } = t;
    this.set(e, Math.min(t.anchorOffset, e ? os(e) : 0), i, Math.min(t.focusOffset, i ? os(i) : 0));
  }
  set(t, e, i, s) {
    this.anchorNode = t, this.anchorOffset = e, this.focusNode = i, this.focusOffset = s;
  }
}, c(Dh, "uf"), Dh);
f(y7, "DOMSelectionState");
let TD = y7, Xa = null;
nt.safari && nt.safari_version >= 26 && (Xa = !1);
function XS(n) {
  if (n.setActive)
    return n.setActive();
  if (Xa)
    return n.focus(Xa);
  let t = [];
  for (let e = n; e && (t.push(e, e.scrollTop, e.scrollLeft), e != e.ownerDocument); e = e.parentNode)
    ;
  if (n.focus(Xa == null ? {
    get preventScroll() {
      return Xa = { preventScroll: !0 }, !0;
    }
  } : void 0), !Xa) {
    Xa = !1;
    for (let e = 0; e < t.length; ) {
      let i = t[e++], s = t[e++], r = t[e++];
      i.scrollTop != s && (i.scrollTop = s), i.scrollLeft != r && (i.scrollLeft = r);
    }
  }
}
c(XS, "Sd$1");
f(XS, "focusPreventScroll");
let D3;
function Uy(n, t, e = t) {
  let i = D3 || (D3 = document.createRange());
  return i.setEnd(n, e), i.setStart(n, t), i;
}
c(Uy, "en");
f(Uy, "textRange");
function io(n, t, e, i) {
  let s = { key: t, code: t, keyCode: e, which: e, cancelable: !0 };
  i && ({ altKey: s.altKey, ctrlKey: s.ctrlKey, shiftKey: s.shiftKey, metaKey: s.metaKey } = i);
  let r = new KeyboardEvent("keydown", s);
  r.synthetic = !0, n.dispatchEvent(r);
  let a = new KeyboardEvent("keyup", s);
  return a.synthetic = !0, n.dispatchEvent(a), r.defaultPrevented || a.defaultPrevented;
}
c(io, "ki$1");
f(io, "dispatchKey");
function m7(n) {
  for (; n; ) {
    if (n && (n.nodeType == 9 || n.nodeType == 11 && n.host))
      return n;
    n = n.assignedSlot || n.parentNode;
  }
  return null;
}
c(m7, "O0$1");
f(m7, "getRoot");
function g7(n, t) {
  let e = t.focusNode, i = t.focusOffset;
  if (!e || t.anchorNode != e || t.anchorOffset != i)
    return !1;
  for (i = Math.min(i, os(e)); ; )
    if (i) {
      if (e.nodeType != 1)
        return !1;
      let s = e.childNodes[i - 1];
      s.contentEditable == "false" ? i-- : (e = s, i = os(e));
    } else {
      if (e == n)
        return !0;
      i = Bs(e), e = e.parentNode;
    }
}
c(g7, "d0$1");
f(g7, "atElementStart");
function NS(n) {
  return n.scrollTop > Math.max(1, n.scrollHeight - n.clientHeight - 4);
}
c(NS, "bd");
f(NS, "isScrolledToBottom");
function jS(n, t) {
  for (let e = n, i = t; ; ) {
    if (e.nodeType == 3 && i > 0)
      return { node: e, offset: i };
    if (e.nodeType == 1 && i > 0) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[i - 1], i = os(e);
    } else if (e.parentNode && !ww(e))
      i = Bs(e), e = e.parentNode;
    else
      return null;
  }
}
c(jS, "wd$1");
f(jS, "textNodeBefore");
function BS(n, t) {
  for (let e = n, i = t; ; ) {
    if (e.nodeType == 3 && i < e.nodeValue.length)
      return { node: e, offset: i };
    if (e.nodeType == 1 && i < e.childNodes.length) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[i], i = 0;
    } else if (e.parentNode && !ww(e))
      i = Bs(e) + 1, e = e.parentNode;
    else
      return null;
  }
}
c(BS, "xd");
f(BS, "textNodeAfter");
var Ir;
const w7 = (Ir = class {
  constructor(t, e, i = !0) {
    this.node = t, this.offset = e, this.precise = i;
  }
  static before(t, e) {
    return new Ir(t.parentNode, Bs(t), e);
  }
  static after(t, e) {
    return new Ir(t.parentNode, Bs(t) + 1, e);
  }
}, c(Ir, "Lr"), Ir);
f(w7, "DOMPos");
let Pr = w7;
var le = /* @__PURE__ */ (function(n) {
  return n[n.LTR = 0] = "LTR", n[n.RTL = 1] = "RTL", n;
})(le || (le = {}));
const Jo = le.LTR, US = le.RTL;
function HS(n) {
  let t = [];
  for (let e = 0; e < n.length; e++)
    t.push(1 << +n[e]);
  return t;
}
c(HS, "kd$1");
f(HS, "dec");
const MD = /* @__PURE__ */ HS("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), AD = /* @__PURE__ */ HS("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Ak = /* @__PURE__ */ Object.create(null), Vn = [];
for (let n of ["()", "[]", "{}"]) {
  let t = /* @__PURE__ */ n.charCodeAt(0), e = /* @__PURE__ */ n.charCodeAt(1);
  Ak[t] = e, Ak[e] = -t;
}
function YS(n) {
  return n <= 247 ? MD[n] : 1424 <= n && n <= 1524 ? 2 : 1536 <= n && n <= 1785 ? AD[n - 1536] : 1774 <= n && n <= 2220 ? 4 : 8192 <= n && n <= 8204 ? 256 : 64336 <= n && n <= 65023 ? 4 : 1;
}
c(YS, "Pd$1");
f(YS, "charType");
const RD = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
var qh;
const v7 = (qh = class {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? US : Jo;
  }
  /**
  @internal
  */
  constructor(t, e, i) {
    this.from = t, this.to = e, this.level = i;
  }
  /**
  @internal
  */
  side(t, e) {
    return this.dir == e == t ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(t, e) {
    return t == (this.dir == e);
  }
  /**
  @internal
  */
  static find(t, e, i, s) {
    let r = -1;
    for (let a = 0; a < t.length; a++) {
      let o = t[a];
      if (o.from <= e && o.to >= e) {
        if (o.level == i)
          return a;
        (r < 0 || (s != 0 ? s < 0 ? o.from < e : o.to > e : t[r].level > o.level)) && (r = a);
      }
    }
    if (r < 0)
      throw new RangeError("Index out of range");
    return r;
  }
}, c(qh, "Of"), qh);
f(v7, "BidiSpan");
let zs = v7;
function GS(n, t) {
  if (n.length != t.length)
    return !1;
  for (let e = 0; e < n.length; e++) {
    let i = n[e], s = t[e];
    if (i.from != s.from || i.to != s.to || i.direction != s.direction || !GS(i.inner, s.inner))
      return !1;
  }
  return !0;
}
c(GS, "$d");
f(GS, "isolatesEq");
const jt = [];
function O7(n, t, e, i, s) {
  for (let r = 0; r <= i.length; r++) {
    let a = r ? i[r - 1].to : t, o = r < i.length ? i[r].from : e, l = r ? 256 : s;
    for (let h = a, u = l, p = l; h < o; h++) {
      let y = YS(n.charCodeAt(h));
      y == 512 ? y = u : y == 8 && p == 4 && (y = 16), jt[h] = y == 4 ? 2 : y, y & 7 && (p = y), u = y;
    }
    for (let h = a, u = l, p = l; h < o; h++) {
      let y = jt[h];
      if (y == 128)
        h < o - 1 && u == jt[h + 1] && u & 24 ? y = jt[h] = u : jt[h] = 256;
      else if (y == 64) {
        let m = h + 1;
        for (; m < o && jt[m] == 64; )
          m++;
        let g = h && u == 8 || m < e && jt[m] == 8 ? p == 1 ? 1 : 8 : 256;
        for (let b = h; b < m; b++)
          jt[b] = g;
        h = m - 1;
      } else y == 8 && p == 1 && (jt[h] = 1);
      u = y, y & 7 && (p = y);
    }
  }
}
c(O7, "Q0$1");
f(O7, "computeCharTypes");
function b7(n, t, e, i, s) {
  let r = s == 1 ? 2 : 1;
  for (let a = 0, o = 0, l = 0; a <= i.length; a++) {
    let h = a ? i[a - 1].to : t, u = a < i.length ? i[a].from : e;
    for (let p = h, y, m, g; p < u; p++)
      if (m = Ak[y = n.charCodeAt(p)])
        if (m < 0) {
          for (let b = o - 3; b >= 0; b -= 3)
            if (Vn[b + 1] == -m) {
              let S = Vn[b + 2], x = S & 2 ? s : S & 4 ? S & 1 ? r : s : 0;
              x && (jt[p] = jt[Vn[b]] = x), o = b;
              break;
            }
        } else {
          if (Vn.length == 189)
            break;
          Vn[o++] = p, Vn[o++] = y, Vn[o++] = l;
        }
      else if ((g = jt[p]) == 2 || g == 1) {
        let b = g == s;
        l = b ? 0 : 1;
        for (let S = o - 3; S >= 0; S -= 3) {
          let x = Vn[S + 2];
          if (x & 2)
            break;
          if (b)
            Vn[S + 2] |= 2;
          else {
            if (x & 4)
              break;
            Vn[S + 2] |= 4;
          }
        }
      }
  }
}
c(b7, "y0$1");
f(b7, "processBracketPairs");
function $7(n, t, e, i) {
  for (let s = 0, r = i; s <= e.length; s++) {
    let a = s ? e[s - 1].to : n, o = s < e.length ? e[s].from : t;
    for (let l = a; l < o; ) {
      let h = jt[l];
      if (h == 256) {
        let u = l + 1;
        for (; ; )
          if (u == o) {
            if (s == e.length)
              break;
            u = e[s++].to, o = s < e.length ? e[s].from : t;
          } else if (jt[u] == 256)
            u++;
          else
            break;
        let p = r == 1, y = (u < t ? jt[u] : i) == 1, m = p == y ? p ? 1 : 2 : i;
        for (let g = u, b = s, S = b ? e[b - 1].to : n; g > l; )
          g == S && (g = e[--b].from, S = b ? e[b - 1].to : n), jt[--g] = m;
        l = u;
      } else
        r = h, l++;
    }
  }
}
c($7, "S0$1");
f($7, "processNeutrals");
function mO(n, t, e, i, s, r, a) {
  let o = i % 2 ? 2 : 1;
  if (i % 2 == s % 2)
    for (let l = t, h = 0; l < e; ) {
      let u = !0, p = !1;
      if (h == r.length || l < r[h].from) {
        let b = jt[l];
        b != o && (u = !1, p = b == 16);
      }
      let y = !u && o == 1 ? [] : null, m = u ? i : i + 1, g = l;
      t: for (; ; )
        if (h < r.length && g == r[h].from) {
          if (p)
            break t;
          let b = r[h];
          if (!u)
            for (let S = b.to, x = h + 1; ; ) {
              if (S == e)
                break t;
              if (x < r.length && r[x].from == S)
                S = r[x++].to;
              else {
                if (jt[S] == o)
                  break t;
                break;
              }
            }
          if (h++, y)
            y.push(b);
          else {
            b.from > l && a.push(new zs(l, b.from, m));
            let S = b.direction == Jo != !(m % 2);
            gO(n, S ? i + 1 : i, s, b.inner, b.from, b.to, a), l = b.to;
          }
          g = b.to;
        } else {
          if (g == e || (u ? jt[g] != o : jt[g] == o))
            break;
          g++;
        }
      y ? mO(n, l, g, i + 1, s, y, a) : l < g && a.push(new zs(l, g, m)), l = g;
    }
  else
    for (let l = e, h = r.length; l > t; ) {
      let u = !0, p = !1;
      if (!h || l > r[h - 1].to) {
        let b = jt[l - 1];
        b != o && (u = !1, p = b == 16);
      }
      let y = !u && o == 1 ? [] : null, m = u ? i : i + 1, g = l;
      t: for (; ; )
        if (h && g == r[h - 1].to) {
          if (p)
            break t;
          let b = r[--h];
          if (!u)
            for (let S = b.from, x = h; ; ) {
              if (S == t)
                break t;
              if (x && r[x - 1].to == S)
                S = r[--x].from;
              else {
                if (jt[S - 1] == o)
                  break t;
                break;
              }
            }
          if (y)
            y.push(b);
          else {
            b.to < l && a.push(new zs(b.to, l, m));
            let S = b.direction == Jo != !(m % 2);
            gO(n, S ? i + 1 : i, s, b.inner, b.from, b.to, a), l = b.from;
          }
          g = b.from;
        } else {
          if (g == t || (u ? jt[g - 1] != o : jt[g - 1] == o))
            break;
          g--;
        }
      y ? mO(n, g, l, i + 1, s, y, a) : g < l && a.push(new zs(g, l, m)), l = g;
    }
}
c(mO, "Tl$1");
f(mO, "emitSpans");
function gO(n, t, e, i, s, r, a) {
  let o = t % 2 ? 2 : 1;
  O7(n, s, r, i, o), b7(n, s, r, i, o), $7(s, r, i, o), mO(n, s, r, t, e, i, a);
}
c(gO, "Al$1");
f(gO, "computeSectionOrder");
function x7(n, t, e) {
  if (!n)
    return [new zs(0, 0, t == US ? 1 : 0)];
  if (t == Jo && !e.length && !RD.test(n))
    return KS(n.length);
  if (e.length)
    for (; n.length > jt.length; )
      jt[jt.length] = 256;
  let i = [], s = t == Jo ? 0 : 1;
  return gO(n, s, s, e, 0, n.length, i), i;
}
c(x7, "b0$1");
f(x7, "computeOrder");
function KS(n) {
  return [new zs(0, n, 0)];
}
c(KS, "Rd$1");
f(KS, "trivialOrder");
let k7 = "";
function S7(n, t, e, i, s) {
  var r;
  let a = i.head - n.from, o = zs.find(t, a, (r = i.bidiLevel) !== null && r !== void 0 ? r : -1, i.assoc), l = t[o], h = l.side(s, e);
  if (a == h) {
    let y = o += s ? 1 : -1;
    if (y < 0 || y >= t.length)
      return null;
    l = t[o = y], a = l.side(!s, e), h = l.side(s, e);
  }
  let u = Ui(n.text, a, l.forward(s, e));
  (u < l.from || u > l.to) && (u = h), k7 = n.text.slice(Math.min(a, u), Math.max(a, u));
  let p = o == (s ? t.length - 1 : 0) ? null : t[o + (s ? 1 : -1)];
  return p && u == h && p.level + (s ? 0 : 1) < l.level ? it.cursor(p.side(!s, e) + n.from, p.forward(s, e) ? 1 : -1, p.level) : it.cursor(u + n.from, l.forward(s, e) ? -1 : 1, l.level);
}
c(S7, "w0$1");
f(S7, "moveVisually");
function C7(n, t, e) {
  for (let i = t; i < e; i++) {
    let s = YS(n.charCodeAt(i));
    if (s == 1)
      return Jo;
    if (s == 2 || s == 4)
      return US;
  }
  return Jo;
}
c(C7, "x0$1");
f(C7, "autoDirection");
const P7 = /* @__PURE__ */ bt.define(), Q7 = /* @__PURE__ */ bt.define(), T7 = /* @__PURE__ */ bt.define(), M7 = /* @__PURE__ */ bt.define(), Rk = /* @__PURE__ */ bt.define(), A7 = /* @__PURE__ */ bt.define(), R7 = /* @__PURE__ */ bt.define(), JS = /* @__PURE__ */ bt.define(), tC = /* @__PURE__ */ bt.define(), E7 = /* @__PURE__ */ bt.define({
  combine: /* @__PURE__ */ f((n) => n.some((t) => t), "combine")
}), ED = /* @__PURE__ */ bt.define({
  combine: /* @__PURE__ */ f((n) => n.some((t) => t), "combine")
}), _7 = /* @__PURE__ */ bt.define();
var Wr;
const z7 = (Wr = class {
  constructor(t, e = "nearest", i = "nearest", s = 5, r = 5, a = !1) {
    this.range = t, this.y = e, this.x = i, this.yMargin = s, this.xMargin = r, this.isSnapshot = a;
  }
  map(t) {
    return t.empty ? this : new Wr(this.range.map(t), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(t) {
    return this.range.to <= t.doc.length ? this : new Wr(it.cursor(t.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}, c(Wr, "_r"), Wr);
f(z7, "ScrollTarget");
let t2 = z7;
const F1 = /* @__PURE__ */ Bt.define({ map: /* @__PURE__ */ f((n, t) => n.map(t), "map") }), L7 = /* @__PURE__ */ Bt.define();
function Qi(n, t, e) {
  let i = n.facet(M7);
  i.length ? i[0](t) : window.onerror && window.onerror(String(t), e, void 0, void 0, t) || (e ? console.error(e + ":", t) : console.error(t));
}
c(Qi, "$e$1");
f(Qi, "logException");
const Ms = /* @__PURE__ */ bt.define({ combine: /* @__PURE__ */ f((n) => n.length ? n[0] : !0, "combine") });
let _D = 0;
const nh = /* @__PURE__ */ bt.define({
  combine(n) {
    return n.filter((t, e) => {
      for (let i = 0; i < e; i++)
        if (n[i].plugin == t.plugin)
          return !1;
      return !0;
    });
  }
});
var Vr;
const I7 = (Vr = class {
  constructor(t, e, i, s, r) {
    this.id = t, this.create = e, this.domEventHandlers = i, this.domEventObservers = s, this.baseExtensions = r(this), this.extension = this.baseExtensions.concat(nh.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(t) {
    return this.baseExtensions.concat(nh.of({ plugin: this, arg: t }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(t, e) {
    const { eventHandlers: i, eventObservers: s, provide: r, decorations: a } = e || {};
    return new Vr(_D++, t, i, s, (o) => {
      let l = [];
      return a && l.push(_b.of((h) => {
        let u = h.plugin(o);
        return u ? a(u) : Gt.none;
      })), r && l.push(r(o)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(t, e) {
    return Vr.define((i, s) => new t(i, s), e);
  }
}, c(Vr, "Mr"), Vr);
f(I7, "ViewPlugin");
let Us = I7;
var Zh;
const W7 = (Zh = class {
  constructor(t) {
    this.spec = t, this.mustUpdate = null, this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(t) {
    if (this.value) {
      if (this.mustUpdate) {
        let e = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(e);
          } catch (i) {
            if (Qi(e.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.plugin.create(t, this.spec.arg);
      } catch (e) {
        Qi(t.state, e, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(t) {
    var e;
    if (!((e = this.value) === null || e === void 0) && e.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        Qi(t.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}, c(Zh, "df"), Zh);
f(W7, "PluginInstance");
let e2 = W7;
const V7 = /* @__PURE__ */ bt.define(), eC = /* @__PURE__ */ bt.define(), _b = /* @__PURE__ */ bt.define(), D7 = /* @__PURE__ */ bt.define(), iC = /* @__PURE__ */ bt.define(), o1 = /* @__PURE__ */ bt.define(), q7 = /* @__PURE__ */ bt.define();
function Ek(n, t) {
  let e = n.state.facet(q7);
  if (!e.length)
    return e;
  let i = e.map((r) => r instanceof Function ? r(n) : r), s = [];
  return Qe.spans(i, t.from, t.to, {
    point() {
    },
    span(r, a, o, l) {
      let h = r - t.from, u = a - t.from, p = s;
      for (let y = o.length - 1; y >= 0; y--, l--) {
        let m = o[y].spec.bidiIsolate, g;
        if (m == null && (m = C7(t.text, h, u)), l > 0 && p.length && (g = p[p.length - 1]).to == h && g.direction == m)
          g.to = u, p = g.inner;
        else {
          let b = { from: h, to: u, direction: m, inner: [] };
          p.push(b), p = b.inner;
        }
      }
    }
  }), s;
}
c(Ek, "pu$1");
f(Ek, "getIsolatedRanges");
const Z7 = /* @__PURE__ */ bt.define();
function zb(n) {
  let t = 0, e = 0, i = 0, s = 0;
  for (let r of n.state.facet(Z7)) {
    let a = r(n);
    a && (a.left != null && (t = Math.max(t, a.left)), a.right != null && (e = Math.max(e, a.right)), a.top != null && (i = Math.max(i, a.top)), a.bottom != null && (s = Math.max(s, a.bottom)));
  }
  return { left: t, right: e, top: i, bottom: s };
}
c(zb, "yh$1");
f(zb, "getScrollMargins");
const mg = /* @__PURE__ */ bt.define();
var Dr;
const F7 = (Dr = class {
  constructor(t, e, i, s) {
    this.fromA = t, this.toA = e, this.fromB = i, this.toB = s;
  }
  join(t) {
    return new Dr(Math.min(this.fromA, t.fromA), Math.max(this.toA, t.toA), Math.min(this.fromB, t.fromB), Math.max(this.toB, t.toB));
  }
  addToSet(t) {
    let e = t.length, i = this;
    for (; e > 0; e--) {
      let s = t[e - 1];
      if (!(s.fromA > i.toA)) {
        if (s.toA < i.fromA)
          break;
        i = i.join(s), t.splice(e - 1, 1);
      }
    }
    return t.splice(e, 0, i), t;
  }
  // Extend a set to cover all the content in `ranges`, which is a
  // flat array with each pair of numbers representing fromB/toB
  // positions. These pairs are generated in unchanged ranges, so the
  // offset between doc A and doc B is the same for their start and
  // end points.
  static extendWithRanges(t, e) {
    if (e.length == 0)
      return t;
    let i = [];
    for (let s = 0, r = 0, a = 0; ; ) {
      let o = s < t.length ? t[s].fromB : 1e9, l = r < e.length ? e[r] : 1e9, h = Math.min(o, l);
      if (h == 1e9)
        break;
      let u = h + a, p = h, y = u;
      for (; ; )
        if (r < e.length && e[r] <= p) {
          let m = e[r + 1];
          r += 2, p = Math.max(p, m);
          for (let g = s; g < t.length && t[g].fromB <= p; g++)
            a = t[g].toA - t[g].toB;
          y = Math.max(y, m + a);
        } else if (s < t.length && t[s].fromB <= p) {
          let m = t[s++];
          p = Math.max(p, m.toB), y = Math.max(y, m.toA), a = m.toA - m.toB;
        } else
          break;
      i.push(new Dr(u, y, h, p));
    }
    return i;
  }
}, c(Dr, "Zr"), Dr);
f(F7, "ChangedRange");
let Ls = F7;
var $o;
const X7 = ($o = class {
  constructor(t, e, i) {
    this.view = t, this.state = e, this.transactions = i, this.flags = 0, this.startState = t.state, this.changes = Tn.empty(this.startState.doc.length);
    for (let r of i)
      this.changes = this.changes.compose(r.changes);
    let s = [];
    this.changes.iterChangedRanges((r, a, o, l) => s.push(new Ls(r, a, o, l))), this.changedRanges = s;
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new $o(t, e, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((t) => t.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}, c($o, "Ns"), $o);
f(X7, "ViewUpdate");
let q3 = X7;
const zD = [];
var Fh;
const N7 = (Fh = class {
  constructor(t, e, i = 0) {
    this.dom = t, this.length = e, this.flags = i, this.parent = null, t.cmTile = this;
  }
  get breakAfter() {
    return this.flags & 1;
  }
  get children() {
    return zD;
  }
  isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  isComposite() {
    return !1;
  }
  isLine() {
    return !1;
  }
  isText() {
    return !1;
  }
  isBlock() {
    return !1;
  }
  get domAttrs() {
    return null;
  }
  sync(t) {
    if (this.flags |= 2, this.flags & 4) {
      this.flags &= -5;
      let e = this.domAttrs;
      e && n7(this.dom, e);
    }
  }
  toString() {
    return this.constructor.name + (this.children.length ? `(${this.children})` : "") + (this.breakAfter ? "#" : "");
  }
  destroy() {
    this.parent = null;
  }
  setDOM(t) {
    this.dom = t, t.cmTile = this;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(t, e = this.posAtStart) {
    let i = e;
    for (let s of this.children) {
      if (s == t)
        return i;
      i += s.length + s.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(t) {
    return this.posBefore(t) + t.length;
  }
  covers(t) {
    return !0;
  }
  coordsIn(t, e) {
    return null;
  }
  domPosFor(t, e) {
    let i = Bs(this.dom), s = this.length ? t > 0 : e > 0;
    return new Pr(this.parent.dom, i + (s ? 1 : 0), t == 0 || t == this.length);
  }
  markDirty(t) {
    this.flags &= -3, t && (this.flags |= 4), this.parent && this.parent.flags & 2 && this.parent.markDirty(!1);
  }
  get overrideDOMText() {
    return null;
  }
  get root() {
    for (let t = this; t; t = t.parent)
      if (t instanceof Ib)
        return t;
    return null;
  }
  static get(t) {
    return t.cmTile;
  }
}, c(Fh, "pf"), Fh);
f(N7, "Tile");
let Pe = N7;
var Xh;
const j7 = (Xh = class extends Pe {
  constructor(t) {
    super(t, 0), this._children = [];
  }
  isComposite() {
    return !0;
  }
  get children() {
    return this._children;
  }
  get lastChild() {
    return this.children.length ? this.children[this.children.length - 1] : null;
  }
  append(t) {
    this.children.push(t), t.parent = this;
  }
  sync(t) {
    if (this.flags & 2)
      return;
    super.sync(t);
    let e = this.dom, i = null, s, r = t?.node == e ? t : null, a = 0;
    for (let o of this.children) {
      if (o.sync(t), a += o.length + o.breakAfter, s = i ? i.nextSibling : e.firstChild, r && s != o.dom && (r.written = !0), o.dom.parentNode == e)
        for (; s && s != o.dom; )
          s = _k(s);
      else
        e.insertBefore(o.dom, s);
      i = o.dom;
    }
    for (s = i ? i.nextSibling : e.firstChild, r && s && (r.written = !0); s; )
      s = _k(s);
    this.length = a;
  }
}, c(Xh, "mf"), Xh);
f(j7, "CompositeTile");
let Lb = j7;
function _k(n) {
  let t = n.nextSibling;
  return n.parentNode.removeChild(n), t;
}
c(_k, "mu$1");
f(_k, "rm$1");
var Nh;
const B7 = (Nh = class extends Lb {
  constructor(t, e) {
    super(e), this.view = t;
  }
  owns(t) {
    for (; t; t = t.parent)
      if (t == this)
        return !0;
    return !1;
  }
  isBlock() {
    return !0;
  }
  nearest(t) {
    for (; ; ) {
      if (!t)
        return null;
      let e = Pe.get(t);
      if (e && this.owns(e))
        return e;
      t = t.parentNode;
    }
  }
  blockTiles(t) {
    for (let e = [], i = this, s = 0, r = 0; ; )
      if (s == i.children.length) {
        if (!e.length)
          return;
        i = i.parent, i.breakAfter && r++, s = e.pop();
      } else {
        let a = i.children[s++];
        if (a instanceof dh)
          e.push(s), i = a, s = 0;
        else {
          let o = r + a.length, l = t(a, r);
          if (l !== void 0)
            return l;
          r = o + a.breakAfter;
        }
      }
  }
  // Find the block at the given position. If side < -1, make sure to
  // stay before block widgets at that position, if side > 1, after
  // such widgets (used for selection drawing, which needs to be able
  // to get coordinates for positions that aren't valid cursor positions).
  resolveBlock(t, e) {
    let i, s = -1, r, a = -1;
    if (this.blockTiles((o, l) => {
      let h = l + o.length;
      if (t >= l && t <= h) {
        if (o.isWidget() && e >= -1 && e <= 1) {
          if (o.flags & 32)
            return !0;
          o.flags & 16 && (i = void 0);
        }
        (l < t || t == h && (e < -1 ? o.length : o.covers(1))) && (!i || !o.isWidget() && i.isWidget()) && (i = o, s = t - l), (h > t || t == l && (e > 1 ? o.length : o.covers(-1))) && (!r || !o.isWidget() && r.isWidget()) && (r = o, a = t - l);
      }
    }), !i && !r)
      throw new Error("No tile at position " + t);
    return i && e < 0 || !r ? { tile: i, offset: s } : { tile: r, offset: a };
  }
}, c(Nh, "gf"), Nh);
f(B7, "DocTile");
let Ib = B7;
var xo;
const U7 = (xo = class extends Lb {
  constructor(t, e) {
    super(t), this.wrapper = e;
  }
  isBlock() {
    return !0;
  }
  covers(t) {
    return this.children.length ? t < 0 ? this.children[0].covers(-1) : this.lastChild.covers(1) : !1;
  }
  get domAttrs() {
    return this.wrapper.attributes;
  }
  static of(t, e) {
    let i = new xo(e || document.createElement(t.tagName), t);
    return e || (i.flags |= 4), i;
  }
}, c(xo, "Gs"), xo);
f(U7, "BlockWrapperTile");
let dh = U7;
var ko;
const H7 = (ko = class extends Lb {
  constructor(t, e) {
    super(t), this.attrs = e;
  }
  isLine() {
    return !0;
  }
  static start(t, e, i) {
    let s = new ko(e || document.createElement("div"), t);
    return (!e || !i) && (s.flags |= 4), s;
  }
  get domAttrs() {
    return this.attrs;
  }
  // Find the tile associated with a given position in this line.
  resolveInline(t, e, i) {
    let s = null, r = -1, a = null, o = -1;
    function l(u, p) {
      for (let y = 0, m = 0; y < u.children.length && m <= p; y++) {
        let g = u.children[y], b = m + g.length;
        b >= p && (g.isComposite() ? l(g, p - m) : (!a || a.isHidden && (e > 0 || i && G7(a, g))) && (b > p || g.flags & 32) ? (a = g, o = p - m) : (m < p || g.flags & 16 && !g.isHidden) && (s = g, r = p - m)), m = b;
      }
    }
    c(l, "a"), f(l, "scan"), l(this, t);
    let h = (e < 0 ? s : a) || s || a;
    return h ? { tile: h, offset: h == s ? r : o } : null;
  }
  coordsIn(t, e) {
    let i = this.resolveInline(t, e, !0);
    return i ? i.tile.coordsIn(Math.max(0, i.offset), e) : Y7(this);
  }
  domIn(t, e) {
    let i = this.resolveInline(t, e);
    if (i) {
      let { tile: s, offset: r } = i;
      if (this.dom.contains(s.dom))
        return s.isText() ? new Pr(s.dom, Math.min(s.dom.nodeValue.length, r)) : s.domPosFor(r, s.flags & 16 ? 1 : s.flags & 32 ? -1 : e);
      let a = i.tile.parent, o = !1;
      for (let l of a.children) {
        if (o)
          return new Pr(l.dom, 0);
        l == i.tile && (o = !0);
      }
    }
    return new Pr(this.dom, 0);
  }
}, c(ko, "Fs"), ko);
f(H7, "LineTile");
let wO = H7;
function Y7(n) {
  let t = n.dom.lastChild;
  if (!t)
    return n.dom.getBoundingClientRect();
  let e = ch(t);
  return e[e.length - 1] || null;
}
c(Y7, "R0$1");
f(Y7, "fallbackRect");
function G7(n, t) {
  let e = n.coordsIn(0, 1), i = t.coordsIn(0, 1);
  return e && i && i.top < e.bottom;
}
c(G7, "v0$1");
f(G7, "onSameLine");
var So;
const K7 = (So = class extends Lb {
  constructor(t, e) {
    super(t), this.mark = e;
  }
  get domAttrs() {
    return this.mark.attrs;
  }
  static of(t, e) {
    let i = new So(e || document.createElement(t.tagName), t);
    return e || (i.flags |= 4), i;
  }
}, c(So, "Hs"), So);
f(K7, "MarkTile");
let an = K7;
var Co;
const J7 = (Co = class extends Pe {
  constructor(t, e) {
    super(t, e.length), this.text = e;
  }
  sync(t) {
    this.flags & 2 || (super.sync(t), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text));
  }
  isText() {
    return !0;
  }
  toString() {
    return JSON.stringify(this.text);
  }
  coordsIn(t, e) {
    let i = this.dom.nodeValue.length;
    t > i && (t = i);
    let s = t, r = t, a = 0;
    t == 0 && e < 0 || t == i && e >= 0 ? nt.chrome || nt.gecko || (t ? (s--, a = 1) : r < i && (r++, a = -1)) : e < 0 ? s-- : r < i && r++;
    let o = Uy(this.dom, s, r).getClientRects();
    if (!o.length)
      return null;
    let l = o[(a ? a < 0 : e >= 0) ? 0 : o.length - 1];
    return nt.safari && !a && l.width == 0 && (l = Array.prototype.find.call(o, (h) => h.width) || l), a ? By(l, a < 0) : l || null;
  }
  static of(t, e) {
    let i = new Co(e || document.createTextNode(t), t);
    return e || (i.flags |= 2), i;
  }
}, c(Co, "Ks"), Co);
f(J7, "TextTile");
let gg = J7;
var Po;
const t6 = (Po = class extends Pe {
  constructor(t, e, i, s) {
    super(t, e, s), this.widget = i;
  }
  isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  covers(t) {
    return this.flags & 48 ? !1 : (this.flags & (t < 0 ? 64 : 128)) > 0;
  }
  coordsIn(t, e) {
    return this.coordsInWidget(t, e, !1);
  }
  coordsInWidget(t, e, i) {
    let s = this.widget.coordsAt(this.dom, t, e);
    if (s)
      return s;
    if (i)
      return By(this.dom.getBoundingClientRect(), this.length ? t == 0 : e <= 0);
    {
      let r = this.dom.getClientRects(), a = null;
      if (!r.length)
        return null;
      let o = this.flags & 16 ? !0 : this.flags & 32 ? !1 : t > 0;
      for (let l = o ? r.length - 1 : 0; a = r[l], !(t > 0 ? l == 0 : l == r.length - 1 || a.top < a.bottom); l += o ? -1 : 1)
        ;
      return By(a, !o);
    }
  }
  get overrideDOMText() {
    if (!this.length)
      return Ft.empty;
    let { root: t } = this;
    if (!t)
      return Ft.empty;
    let e = this.posAtStart;
    return t.view.state.doc.slice(e, e + this.length);
  }
  destroy() {
    super.destroy(), this.widget.destroy(this.dom);
  }
  static of(t, e, i, s, r) {
    return r || (r = t.toDOM(e), t.editable || (r.contentEditable = "false")), new Po(r, i, t, s);
  }
}, c(Po, "Js"), Po);
f(t6, "WidgetTile");
let vw = t6;
var jh;
const e6 = (jh = class extends Pe {
  constructor(t) {
    let e = document.createElement("img");
    e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), super(e, 0, t);
  }
  get isHidden() {
    return !0;
  }
  get overrideDOMText() {
    return Ft.empty;
  }
  coordsIn(t) {
    return this.dom.getBoundingClientRect();
  }
}, c(jh, "Qf"), jh);
f(e6, "WidgetBufferTile");
let vO = e6;
var Bh;
const i6 = (Bh = class {
  constructor(t) {
    this.index = 0, this.beforeBreak = !1, this.parents = [], this.tile = t;
  }
  // Advance by the given distance. If side is -1, stop leaving or
  // entering tiles, or skipping zero-length tiles, once the distance
  // has been traversed. When side is 1, leave, enter, or skip
  // everything at the end position.
  advance(t, e, i) {
    let { tile: s, index: r, beforeBreak: a, parents: o } = this;
    for (; t || e > 0; )
      if (s.isComposite())
        if (a) {
          if (!t)
            break;
          i && i.break(), t--, a = !1;
        } else if (r == s.children.length) {
          if (!t && !o.length)
            break;
          i && i.leave(s), a = !!s.breakAfter, { tile: s, index: r } = o.pop(), r++;
        } else {
          let l = s.children[r], h = l.breakAfter;
          (e > 0 ? l.length <= t : l.length < t) && (!i || i.skip(l, 0, l.length) !== !1 || !l.isComposite) ? (a = !!h, r++, t -= l.length) : (o.push({ tile: s, index: r }), s = l, r = 0, i && l.isComposite() && i.enter(l));
        }
      else if (r == s.length)
        a = !!s.breakAfter, { tile: s, index: r } = o.pop(), r++;
      else if (t) {
        let l = Math.min(t, s.length - r);
        i && i.skip(s, r, r + l), t -= l, r += l;
      } else
        break;
    return this.tile = s, this.index = r, this.beforeBreak = a, this;
  }
  get root() {
    return this.parents.length ? this.parents[0].tile : this.tile;
  }
}, c(Bh, "yf"), Bh);
f(i6, "TilePointer");
let LD = i6;
var Uh;
const n6 = (Uh = class {
  constructor(t, e, i, s) {
    this.from = t, this.to = e, this.wrapper = i, this.rank = s;
  }
}, c(Uh, "Sf"), Uh);
f(n6, "OpenWrapper");
let ID = n6;
var Hh;
const s6 = (Hh = class {
  constructor(t, e, i) {
    this.cache = t, this.root = e, this.blockWrappers = i, this.curLine = null, this.lastBlock = null, this.afterWidget = null, this.pos = 0, this.wrappers = [], this.wrapperPos = 0;
  }
  addText(t, e, i, s) {
    var r;
    this.flushBuffer();
    let a = this.ensureMarks(e, i), o = a.lastChild;
    if (o && o.isText() && !(o.flags & 8)) {
      this.cache.reused.set(
        o,
        2
        /* Reused.DOM */
      );
      let l = a.children[a.children.length - 1] = new gg(o.dom, o.text + t);
      l.parent = a;
    } else
      a.append(s || gg.of(t, (r = this.cache.find(gg)) === null || r === void 0 ? void 0 : r.dom));
    this.pos += t.length, this.afterWidget = null;
  }
  addComposition(t, e) {
    let i = this.curLine;
    i.dom != e.line.dom && (i.setDOM(this.cache.reused.has(e.line) ? gv(e.line.dom) : e.line.dom), this.cache.reused.set(
      e.line,
      2
      /* Reused.DOM */
    ));
    let s = i;
    for (let o = e.marks.length - 1; o >= 0; o--) {
      let l = e.marks[o], h = s.lastChild;
      if (h instanceof an && h.mark.eq(l.mark))
        h.dom != l.dom && h.setDOM(gv(l.dom)), s = h;
      else {
        if (this.cache.reused.get(l)) {
          let p = Pe.get(l.dom);
          p && p.setDOM(gv(l.dom));
        }
        let u = an.of(l.mark, l.dom);
        s.append(u), s = u;
      }
      this.cache.reused.set(
        l,
        2
        /* Reused.DOM */
      );
    }
    let r = Pe.get(t.text);
    r && this.cache.reused.set(
      r,
      2
      /* Reused.DOM */
    );
    let a = new gg(t.text, t.text.nodeValue);
    a.flags |= 8, s.append(a);
  }
  addInlineWidget(t, e, i) {
    let s = this.afterWidget && t.flags & 48 && (this.afterWidget.flags & 48) == (t.flags & 48);
    s || this.flushBuffer();
    let r = this.ensureMarks(e, i);
    !s && !(t.flags & 16) && r.append(this.getBuffer(1)), r.append(t), this.pos += t.length, this.afterWidget = t;
  }
  addMark(t, e, i) {
    this.flushBuffer(), this.ensureMarks(e, i).append(t), this.pos += t.length, this.afterWidget = null;
  }
  addBlockWidget(t) {
    this.getBlockPos().append(t), this.pos += t.length, this.lastBlock = t, this.endLine();
  }
  continueWidget(t) {
    let e = this.afterWidget || this.lastBlock;
    e.length += t, this.pos += t;
  }
  addLineStart(t, e) {
    var i;
    t || (t = c6);
    let s = wO.start(t, e || ((i = this.cache.find(wO)) === null || i === void 0 ? void 0 : i.dom), !!e);
    this.getBlockPos().append(this.lastBlock = this.curLine = s);
  }
  addLine(t) {
    this.getBlockPos().append(t), this.pos += t.length, this.lastBlock = t, this.endLine();
  }
  addBreak() {
    this.lastBlock.flags |= 1, this.endLine(), this.pos++;
  }
  addLineStartIfNotCovered(t) {
    this.blockPosCovered() || this.addLineStart(t);
  }
  ensureLine(t) {
    this.curLine || this.addLineStart(t);
  }
  ensureMarks(t, e) {
    var i;
    let s = this.curLine;
    for (let r = t.length - 1; r >= 0; r--) {
      let a = t[r], o;
      if (e > 0 && (o = s.lastChild) && o instanceof an && o.mark.eq(a))
        s = o, e--;
      else {
        let l = an.of(a, (i = this.cache.find(an, (h) => h.mark.eq(a))) === null || i === void 0 ? void 0 : i.dom);
        s.append(l), s = l, e = 0;
      }
    }
    return s;
  }
  endLine() {
    if (this.curLine) {
      this.flushBuffer();
      let t = this.curLine.lastChild;
      (!t || !zk(this.curLine, !1) || t.dom.nodeName != "BR" && t.isWidget() && !(nt.ios && zk(this.curLine, !0))) && this.curLine.append(this.cache.findWidget(
        i2,
        0,
        32
        /* TileFlag.After */
      ) || new vw(
        i2.toDOM(),
        0,
        i2,
        32
        /* TileFlag.After */
      )), this.curLine = this.afterWidget = null;
    }
  }
  updateBlockWrappers() {
    this.wrapperPos > this.pos + 1e4 && (this.blockWrappers.goto(this.pos), this.wrappers.length = 0);
    for (let t = this.wrappers.length - 1; t >= 0; t--)
      this.wrappers[t].to < this.pos && this.wrappers.splice(t, 1);
    for (let t = this.blockWrappers; t.value && t.from <= this.pos; t.next())
      if (t.to >= this.pos) {
        let e = new ID(t.from, t.to, t.value, t.rank), i = this.wrappers.length;
        for (; i > 0 && (this.wrappers[i - 1].rank - e.rank || this.wrappers[i - 1].to - e.to) < 0; )
          i--;
        this.wrappers.splice(i, 0, e);
      }
    this.wrapperPos = this.pos;
  }
  getBlockPos() {
    var t;
    this.updateBlockWrappers();
    let e = this.root;
    for (let i of this.wrappers) {
      let s = e.lastChild;
      if (i.from < this.pos && s instanceof dh && s.wrapper.eq(i.wrapper))
        e = s;
      else {
        let r = dh.of(i.wrapper, (t = this.cache.find(dh, (a) => a.wrapper.eq(i.wrapper))) === null || t === void 0 ? void 0 : t.dom);
        e.append(r), e = r;
      }
    }
    return e;
  }
  blockPosCovered() {
    let t = this.lastBlock;
    return t != null && !t.breakAfter && (!t.isWidget() || (t.flags & 160) > 0);
  }
  getBuffer(t) {
    let e = 2 | (t < 0 ? 16 : 32), i = this.cache.find(
      vO,
      void 0,
      1
      /* Reused.Full */
    );
    return i && (i.flags = e), i || new vO(e);
  }
  flushBuffer() {
    this.afterWidget && !(this.afterWidget.flags & 32) && (this.afterWidget.parent.append(this.getBuffer(-1)), this.afterWidget = null);
  }
}, c(Hh, "bf"), Hh);
f(s6, "TileBuilder");
let WD = s6;
var Yh;
const r6 = (Yh = class {
  constructor(t) {
    this.skipCount = 0, this.text = "", this.textOff = 0, this.cursor = t.iter();
  }
  skip(t) {
    this.textOff + t <= this.text.length ? this.textOff += t : (this.skipCount += t - (this.text.length - this.textOff), this.text = "", this.textOff = 0);
  }
  next(t) {
    if (this.textOff == this.text.length) {
      let { value: s, lineBreak: r, done: a } = this.cursor.next(this.skipCount);
      if (this.skipCount = 0, a)
        throw new Error("Ran out of text content when drawing inline views");
      this.text = s;
      let o = this.textOff = Math.min(t, s.length);
      return r ? null : s.slice(0, o);
    }
    let e = Math.min(this.text.length, this.textOff + t), i = this.text.slice(this.textOff, e);
    return this.textOff = e, i;
  }
}, c(Yh, "wf"), Yh);
f(r6, "TextStream");
let VD = r6;
const OO = [vw, wO, gg, an, vO, dh, Ib];
for (let n = 0; n < OO.length; n++)
  OO[n].bucket = n;
var Gh;
const a6 = (Gh = class {
  constructor(t) {
    this.view = t, this.buckets = OO.map(() => []), this.index = OO.map(() => 0), this.reused = /* @__PURE__ */ new Map();
  }
  // Put a tile in the cache.
  add(t) {
    let e = t.constructor.bucket, i = this.buckets[e];
    i.length < 6 ? i.push(t) : i[
      this.index[e] = (this.index[e] + 1) % 6
      /* C.Bucket */
    ] = t;
  }
  find(t, e, i = 2) {
    let s = t.bucket, r = this.buckets[s], a = this.index[s];
    for (let o = r.length - 1; o >= 0; o--) {
      let l = (o + a) % r.length, h = r[l];
      if ((!e || e(h)) && !this.reused.has(h))
        return r.splice(l, 1), l < a && this.index[s]--, this.reused.set(h, i), h;
    }
    return null;
  }
  findWidget(t, e, i) {
    let s = this.buckets[0];
    if (s.length)
      for (let r = 0, a = 0; ; r++) {
        if (r == s.length) {
          if (a)
            return null;
          a = 1, r = 0;
        }
        let o = s[r];
        if (!this.reused.has(o) && (a == 0 ? o.widget.compare(t) : o.widget.constructor == t.constructor && t.updateDOM(o.dom, this.view)))
          return s.splice(r, 1), r < this.index[0] && this.index[0]--, o.widget == t && o.length == e && (o.flags & 497) == i ? (this.reused.set(
            o,
            1
            /* Reused.Full */
          ), o) : (this.reused.set(
            o,
            2
            /* Reused.DOM */
          ), new vw(o.dom, e, t, o.flags & -498 | i));
      }
  }
  reuse(t) {
    return this.reused.set(
      t,
      1
      /* Reused.Full */
    ), t;
  }
  maybeReuse(t, e = 2) {
    if (!this.reused.has(t))
      return this.reused.set(t, e), t.dom;
  }
  clear() {
    for (let t = 0; t < this.buckets.length; t++)
      this.buckets[t].length = this.index[t] = 0;
  }
}, c(Gh, "xf"), Gh);
f(a6, "TileCache");
let DD = a6;
var Kh;
const o6 = (Kh = class {
  constructor(t, e, i, s, r) {
    this.view = t, this.decorations = s, this.disallowBlockEffectsFor = r, this.openWidget = !1, this.openMarks = 0, this.cache = new DD(t), this.text = new VD(t.state.doc), this.builder = new WD(this.cache, new Ib(t, t.contentDOM), Qe.iter(i)), this.cache.reused.set(
      e,
      2
      /* Reused.DOM */
    ), this.old = new LD(e), this.reuseWalker = {
      skip: /* @__PURE__ */ f((a, o, l) => {
        if (this.cache.add(a), a.isComposite())
          return !1;
      }, "skip"),
      enter: /* @__PURE__ */ f((a) => this.cache.add(a), "enter"),
      leave: /* @__PURE__ */ f(() => {
      }, "leave"),
      break: /* @__PURE__ */ f(() => {
      }, "break")
    };
  }
  run(t, e) {
    let i = e && this.getCompositionContext(e.text);
    for (let s = 0, r = 0, a = 0; ; ) {
      let o = a < t.length ? t[a++] : null, l = o ? o.fromA : this.old.root.length;
      if (l > s) {
        let h = l - s;
        this.preserve(h, !a, !o), s = l, r += h;
      }
      if (!o)
        break;
      e && o.fromA <= e.range.fromA && o.toA >= e.range.toA ? (this.forward(o.fromA, e.range.fromA, e.range.fromA < e.range.toA ? 1 : -1), this.emit(r, e.range.fromB), this.cache.clear(), this.builder.addComposition(e, i), this.text.skip(e.range.toB - e.range.fromB), this.forward(e.range.fromA, o.toA), this.emit(e.range.toB, o.toB)) : (this.forward(o.fromA, o.toA), this.emit(r, o.toB)), r = o.toB, s = o.toA;
    }
    return this.builder.curLine && this.builder.endLine(), this.builder.root;
  }
  preserve(t, e, i) {
    let s = d6(this.old), r = this.openMarks;
    this.old.advance(t, i ? 1 : -1, {
      skip: /* @__PURE__ */ f((a, o, l) => {
        if (a.isWidget())
          if (this.openWidget)
            this.builder.continueWidget(l - o);
          else {
            let h = l > 0 || o < a.length ? vw.of(a.widget, this.view, l - o, a.flags & 496, this.cache.maybeReuse(a)) : this.cache.reuse(a);
            h.flags & 256 ? (h.flags &= -2, this.builder.addBlockWidget(h)) : (this.builder.ensureLine(null), this.builder.addInlineWidget(h, s, r), r = s.length);
          }
        else if (a.isText())
          this.builder.ensureLine(null), !o && l == a.length ? this.builder.addText(a.text, s, r, this.cache.reuse(a)) : (this.cache.add(a), this.builder.addText(a.text.slice(o, l), s, r)), r = s.length;
        else if (a.isLine())
          a.flags &= -2, this.cache.reused.set(
            a,
            1
            /* Reused.Full */
          ), this.builder.addLine(a);
        else if (a instanceof vO)
          this.cache.add(a);
        else if (a instanceof an)
          this.builder.ensureLine(null), this.builder.addMark(a, s, r), this.cache.reused.set(
            a,
            1
            /* Reused.Full */
          ), r = s.length;
        else
          return !1;
        this.openWidget = !1;
      }, "skip"),
      enter: /* @__PURE__ */ f((a) => {
        a.isLine() ? this.builder.addLineStart(a.attrs, this.cache.maybeReuse(a)) : (this.cache.add(a), a instanceof an && s.unshift(a.mark)), this.openWidget = !1;
      }, "enter"),
      leave: /* @__PURE__ */ f((a) => {
        a.isLine() ? s.length && (s.length = r = 0) : a instanceof an && (s.shift(), r = Math.min(r, s.length));
      }, "leave"),
      break: /* @__PURE__ */ f(() => {
        this.builder.addBreak(), this.openWidget = !1;
      }, "break")
    }), this.text.skip(t);
  }
  emit(t, e) {
    let i = null, s = this.builder, r = 0, a = Qe.spans(this.decorations, t, e, {
      point: /* @__PURE__ */ f((o, l, h, u, p, y) => {
        if (h instanceof gw) {
          if (this.disallowBlockEffectsFor[y]) {
            if (h.block)
              throw new RangeError("Block decorations may not be specified via plugins");
            if (l > this.view.state.doc.lineAt(o).to)
              throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
          }
          if (r = u.length, p > u.length)
            s.continueWidget(l - o);
          else {
            let m = h.widget || (h.block ? Hy.block : Hy.inline), g = l6(h), b = this.cache.findWidget(m, l - o, g) || vw.of(m, this.view, l - o, g);
            h.block ? (h.startSide > 0 && s.addLineStartIfNotCovered(i), s.addBlockWidget(b)) : (s.ensureLine(i), s.addInlineWidget(b, u, p));
          }
          i = null;
        } else
          i = h6(i, h);
        l > o && this.text.skip(l - o);
      }, "point"),
      span: /* @__PURE__ */ f((o, l, h, u) => {
        for (let p = o; p < l; ) {
          let y = this.text.next(Math.min(512, l - p));
          y == null ? (s.addLineStartIfNotCovered(i), s.addBreak(), p++) : (s.ensureLine(i), s.addText(y, h, u), p += y.length), i = null;
        }
      }, "span")
    });
    s.addLineStartIfNotCovered(i), this.openWidget = a > r, this.openMarks = a;
  }
  forward(t, e, i = 1) {
    e - t <= 10 ? this.old.advance(e - t, i, this.reuseWalker) : (this.old.advance(5, -1, this.reuseWalker), this.old.advance(e - t - 10, -1), this.old.advance(5, i, this.reuseWalker));
  }
  getCompositionContext(t) {
    let e = [], i = null;
    for (let s = t.parentNode; ; s = s.parentNode) {
      let r = Pe.get(s);
      if (s == this.view.contentDOM)
        break;
      r instanceof an ? e.push(r) : r?.isLine() ? i = r : s.nodeName == "DIV" && !i && s != this.view.contentDOM ? i = new wO(s, c6) : e.push(an.of(new DS({ tagName: s.nodeName.toLowerCase(), attributes: s7(s) }), s));
    }
    return { line: i, marks: e };
  }
}, c(Kh, "kf"), Kh);
f(o6, "TileUpdate");
let qD = o6;
function zk(n, t) {
  let e = /* @__PURE__ */ f((i) => {
    for (let s of i.children)
      if ((t ? s.isText() : s.length) || e(s))
        return !0;
    return !1;
  }, "scan");
  return e(n);
}
c(zk, "gu$1");
f(zk, "hasContent");
function l6(n) {
  let t = n.isReplace ? (n.startSide < 0 ? 64 : 0) | (n.endSide > 0 ? 128 : 0) : n.startSide > 0 ? 32 : 16;
  return n.block && (t |= 256), t;
}
c(l6, "T0$1");
f(l6, "widgetFlags");
const c6 = { class: "cm-line" };
function h6(n, t) {
  let e = t.spec.attributes, i = t.spec.class;
  return !e && !i || (n || (n = { class: "cm-line" }), e && Rb(e, n), i && (n.class += " " + i)), n;
}
c(h6, "A0$1");
f(h6, "addLineDeco");
function d6(n) {
  let t = [];
  for (let e = n.parents.length; e > 1; e--) {
    let i = e == n.parents.length ? n.tile : n.parents[e].tile;
    i instanceof an && t.push(i.mark);
  }
  return t;
}
c(d6, "L0$1");
f(d6, "getMarks");
function gv(n) {
  let t = Pe.get(n);
  return t && t.setDOM(n.cloneNode()), n;
}
c(gv, "Lo$1");
f(gv, "freeNode");
var Jh;
const u6 = (Jh = class extends Pl {
  constructor(t) {
    super(), this.tag = t;
  }
  eq(t) {
    return t.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(t) {
    return t.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}, c(Jh, "Pf"), Jh);
f(u6, "NullWidget");
let Hy = u6;
Hy.inline = /* @__PURE__ */ new Hy("span");
Hy.block = /* @__PURE__ */ new Hy("div");
const i2 = /* @__PURE__ */ new class extends Pl {
  toDOM() {
    return document.createElement("br");
  }
  get isHidden() {
    return !0;
  }
  get editable() {
    return !0;
  }
}();
var td;
const p6 = (td = class {
  constructor(t) {
    this.view = t, this.decorations = [], this.blockWrappers = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.editContextFormatting = Gt.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.updateDeco(), this.tile = new Ib(t, t.contentDOM), this.updateInner([new Ls(0, 0, 0, t.state.doc.length)], null);
  }
  // Update the document view to a given state.
  update(t) {
    var e;
    let i = t.changedRanges;
    this.minWidth > 0 && i.length && (i.every(({ fromA: u, toA: p }) => p < this.minWidthFrom || u > this.minWidthTo) ? (this.minWidthFrom = t.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(t);
    let s = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((e = this.domChanged) === null || e === void 0) && e.newSel ? s = this.domChanged.newSel.head : !b6(t.changes, this.hasComposition) && !t.selectionSet && (s = t.state.selection.main.head));
    let r = s > -1 ? y6(this.view, t.changes, s) : null;
    if (this.domChanged = null, this.hasComposition) {
      let { from: u, to: p } = this.hasComposition;
      i = new Ls(u, p, t.changes.mapPos(u, -1), t.changes.mapPos(p, 1)).addToSet(i.slice());
    }
    this.hasComposition = r ? { from: r.range.fromB, to: r.range.toB } : null, (nt.ie || nt.chrome) && !r && t && t.state.doc.lines != t.startState.doc.lines && (this.forceSelection = !0);
    let a = this.decorations, o = this.blockWrappers;
    this.updateDeco();
    let l = g6(a, this.decorations, t.changes);
    l.length && (i = Ls.extendWithRanges(i, l));
    let h = v6(o, this.blockWrappers, t.changes);
    return h.length && (i = Ls.extendWithRanges(i, h)), r && !i.some((u) => u.fromA <= r.range.fromA && u.toA >= r.range.toA) && (i = r.range.addToSet(i.slice())), this.tile.flags & 2 && i.length == 0 ? !1 : (this.updateInner(i, r), t.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(t, e) {
    this.view.viewState.mustMeasureContent = !0;
    let { observer: i } = this.view;
    i.ignore(() => {
      if (e || t.length) {
        let a = this.tile, o = new qD(this.view, a, this.blockWrappers, this.decorations, this.dynamicDecorationMap);
        this.tile = o.run(t, e), bO(a, o.cache.reused);
      }
      this.tile.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.tile.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let r = nt.chrome || nt.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.tile.sync(r), r && (r.written || i.selectionRange.focusNode != r.node || !this.tile.dom.contains(r.node)) && (this.forceSelection = !0), this.tile.dom.style.height = "";
    });
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let r of this.tile.children)
        r.isWidget() && r.widget instanceof s2 && s.push(r.dom);
    i.updateGaps(s);
  }
  updateEditContextFormatting(t) {
    this.editContextFormatting = this.editContextFormatting.map(t.changes);
    for (let e of t.transactions)
      for (let i of e.effects)
        i.is(L7) && (this.editContextFormatting = i.value);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(t = !1, e = !1) {
    (t || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let { dom: i } = this.tile, s = this.view.root.activeElement, r = s == i, a = !r && !(this.view.state.facet(Ms) || i.tabIndex > -1) && lh(i, this.view.observer.selectionRange) && !(s && i.contains(s));
    if (!(r || e || a))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let l = this.view.state.selection.main, h, u;
    if (l.empty ? u = h = this.inlineDOMNearPos(l.anchor, l.assoc || 1) : (u = this.inlineDOMNearPos(l.head, l.head == l.from ? 1 : -1), h = this.inlineDOMNearPos(l.anchor, l.anchor == l.from ? 1 : -1)), nt.gecko && l.empty && !this.hasComposition && f6(h)) {
      let y = document.createTextNode("");
      this.view.observer.ignore(() => h.node.insertBefore(y, h.node.childNodes[h.offset] || null)), h = u = new Pr(y, 0), o = !0;
    }
    let p = this.view.observer.selectionRange;
    (o || !p.focusNode || (!hh(h.node, h.offset, p.anchorNode, p.anchorOffset) || !hh(u.node, u.offset, p.focusNode, p.focusOffset)) && !this.suppressWidgetCursorChange(p, l)) && (this.view.observer.ignore(() => {
      nt.android && nt.chrome && i.contains(p.focusNode) && O6(p.focusNode, i) && (i.blur(), i.focus({ preventScroll: !0 }));
      let y = Ko(this.view.root);
      if (y) if (l.empty) {
        if (nt.gecko) {
          let m = m6(h.node, h.offset);
          if (m && m != 3) {
            let g = (m == 1 ? jS : BS)(h.node, h.offset);
            g && (h = new Pr(g.node, g.offset));
          }
        }
        y.collapse(h.node, h.offset), l.bidiLevel != null && y.caretBidiLevel !== void 0 && (y.caretBidiLevel = l.bidiLevel);
      } else if (y.extend) {
        y.collapse(h.node, h.offset);
        try {
          y.extend(u.node, u.offset);
        } catch {
        }
      } else {
        let m = document.createRange();
        l.anchor > l.head && ([h, u] = [u, h]), m.setEnd(u.node, u.offset), m.setStart(h.node, h.offset), y.removeAllRanges(), y.addRange(m);
      }
      a && this.view.root.activeElement == i && (i.blur(), s && s.focus());
    }), this.view.observer.setSelectionRange(h, u)), this.impreciseAnchor = h.precise ? null : new Pr(p.anchorNode, p.anchorOffset), this.impreciseHead = u.precise ? null : new Pr(p.focusNode, p.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(t, e) {
    return this.hasComposition && e.empty && hh(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset) && this.posFromDOM(t.focusNode, t.focusOffset) == e.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: t } = this, e = t.state.selection.main, i = Ko(t.root), { anchorNode: s, anchorOffset: r } = t.observer.selectionRange;
    if (!i || !e.empty || !e.assoc || !i.modify)
      return;
    let a = this.lineAt(e.head, e.assoc);
    if (!a)
      return;
    let o = a.posAtStart;
    if (e.head == o || e.head == o + a.length)
      return;
    let l = this.coordsAt(e.head, -1), h = this.coordsAt(e.head, 1);
    if (!l || !h || l.bottom > h.top)
      return;
    let u = this.domAtPos(e.head + e.assoc, e.assoc);
    i.collapse(u.node, u.offset), i.modify("move", e.assoc < 0 ? "forward" : "backward", "lineboundary"), t.observer.readSelectionRange();
    let p = t.observer.selectionRange;
    t.docView.posFromDOM(p.anchorNode, p.anchorOffset) != e.from && i.collapse(s, r);
  }
  posFromDOM(t, e) {
    let i = this.tile.nearest(t);
    if (!i)
      return this.tile.dom.compareDocumentPosition(t) & 2 ? 0 : this.view.state.doc.length;
    let s = i.posAtStart;
    if (i.isComposite()) {
      let r;
      if (t == i.dom)
        r = i.dom.childNodes[e];
      else {
        let a = os(t) == 0 ? 0 : e == 0 ? -1 : 1;
        for (; ; ) {
          let o = t.parentNode;
          if (o == i.dom)
            break;
          a == 0 && o.firstChild != o.lastChild && (t == o.firstChild ? a = -1 : a = 1), t = o;
        }
        a < 0 ? r = t : r = t.nextSibling;
      }
      if (r == i.dom.firstChild)
        return s;
      for (; r && !Pe.get(r); )
        r = r.nextSibling;
      if (!r)
        return s + i.length;
      for (let a = 0, o = s; ; a++) {
        let l = i.children[a];
        if (l.dom == r)
          return o;
        o += l.length + l.breakAfter;
      }
    } else return i.isText() ? t == i.dom ? s + e : s + (e ? i.length : 0) : s;
  }
  domAtPos(t, e) {
    let { tile: i, offset: s } = this.tile.resolveBlock(t, e);
    return i.isWidget() ? i.domPosFor(t, e) : i.domIn(s, e);
  }
  inlineDOMNearPos(t, e) {
    let i, s = -1, r = !1, a, o = -1, l = !1;
    return this.tile.blockTiles((h, u) => {
      if (h.isWidget()) {
        if (h.flags & 32 && u >= t)
          return !0;
        h.flags & 16 && (r = !0);
      } else {
        let p = u + h.length;
        if (u <= t && (i = h, s = t - u, r = p < t), p >= t && !a && (a = h, o = t - u, l = u > t), u > t && a)
          return !0;
      }
    }), !i && !a ? this.domAtPos(t, e) : (r && a ? i = null : l && i && (a = null), i && e < 0 || !a ? i.domIn(s, e) : a.domIn(o, e));
  }
  coordsAt(t, e) {
    let { tile: i, offset: s } = this.tile.resolveBlock(t, e);
    return i.isWidget() ? i.widget instanceof s2 ? null : i.coordsInWidget(s, e, !0) : i.coordsIn(s, e);
  }
  lineAt(t, e) {
    let { tile: i } = this.tile.resolveBlock(t, e);
    return i.isLine() ? i : null;
  }
  coordsForChar(t) {
    let { tile: e, offset: i } = this.tile.resolveBlock(t, 1);
    if (!e.isLine())
      return null;
    function s(r, a) {
      if (r.isComposite())
        for (let o of r.children) {
          if (o.length >= a) {
            let l = s(o, a);
            if (l)
              return l;
          }
          if (a -= o.length, a < 0)
            break;
        }
      else if (r.isText() && a < r.length) {
        let o = Ui(r.text, a);
        if (o == a)
          return null;
        let l = Uy(r.dom, a, o).getClientRects();
        for (let h = 0; h < l.length; h++) {
          let u = l[h];
          if (h == l.length - 1 || u.top < u.bottom && u.left < u.right)
            return u;
        }
      }
      return null;
    }
    return c(s, "n"), f(s, "scan"), s(e, i);
  }
  measureVisibleLineHeights(t) {
    let e = [], { from: i, to: s } = t, r = this.view.contentDOM.clientWidth, a = r > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, o = -1, l = this.view.textDirection == le.LTR, h = 0, u = /* @__PURE__ */ f((p, y, m) => {
      for (let g = 0; g < p.children.length && !(y > s); g++) {
        let b = p.children[g], S = y + b.length, x = b.dom.getBoundingClientRect(), { height: Q } = x;
        if (m && !g && (h += x.top - m.top), b instanceof dh)
          S > i && u(b, y, x);
        else if (y >= i && (h > 0 && e.push(-h), e.push(Q + h), h = 0, a)) {
          let L = b.dom.lastChild, W = L ? ch(L) : [];
          if (W.length) {
            let R = W[W.length - 1], I = l ? R.right - x.left : x.right - R.left;
            I > o && (o = I, this.minWidth = r, this.minWidthFrom = y, this.minWidthTo = S);
          }
        }
        m && g == p.children.length - 1 && (h += m.bottom - x.bottom), y = S + b.breakAfter;
      }
    }, "scan");
    return u(this.tile, 0, null), e;
  }
  textDirectionAt(t) {
    let { tile: e } = this.tile.resolveBlock(t, 1);
    return getComputedStyle(e.dom).direction == "rtl" ? le.RTL : le.LTR;
  }
  measureTextSize() {
    let t = this.tile.blockTiles((a) => {
      if (a.isLine() && a.children.length && a.length <= 20) {
        let o = 0, l;
        for (let h of a.children) {
          if (!h.isText() || /[^ -~]/.test(h.text))
            return;
          let u = ch(h.dom);
          if (u.length != 1)
            return;
          o += u[0].width, l = u[0].height;
        }
        if (o)
          return {
            lineHeight: a.dom.getBoundingClientRect().height,
            charWidth: o / a.length,
            textHeight: l
          };
      }
    });
    if (t)
      return t;
    let e = document.createElement("div"), i, s, r;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.tile.dom.appendChild(e);
      let a = ch(e.firstChild)[0];
      i = e.getBoundingClientRect().height, s = a && a.width ? a.width / 27 : 7, r = a && a.height ? a.height : i, e.remove();
    }), { lineHeight: i, charWidth: s, textHeight: r };
  }
  computeBlockGapDeco() {
    let t = [], e = this.view.viewState;
    for (let i = 0, s = 0; ; s++) {
      let r = s == e.viewports.length ? null : e.viewports[s], a = r ? r.from - 1 : this.view.state.doc.length;
      if (a > i) {
        let o = (e.lineBlockAt(a).bottom - e.lineBlockAt(i).top) / this.view.scaleY;
        t.push(Gt.replace({
          widget: new s2(o),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, a));
      }
      if (!r)
        break;
      i = r.to + 1;
    }
    return Gt.set(t);
  }
  updateDeco() {
    let t = 1, e = this.view.state.facet(_b).map((r) => (this.dynamicDecorationMap[t++] = typeof r == "function") ? r(this.view) : r), i = !1, s = this.view.state.facet(iC).map((r, a) => {
      let o = typeof r == "function";
      return o && (i = !0), o ? r(this.view) : r;
    });
    for (s.length && (this.dynamicDecorationMap[t++] = i, e.push(Qe.join(s))), this.decorations = [
      this.editContextFormatting,
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; t < this.decorations.length; )
      this.dynamicDecorationMap[t++] = !1;
    this.blockWrappers = this.view.state.facet(D7).map((r) => typeof r == "function" ? r(this.view) : r);
  }
  scrollIntoView(t) {
    if (t.isSnapshot) {
      let h = this.view.viewState.lineBlockAt(t.range.head);
      this.view.scrollDOM.scrollTop = h.top - t.yMargin, this.view.scrollDOM.scrollLeft = t.xMargin;
      return;
    }
    for (let h of this.view.state.facet(_7))
      try {
        if (h(this.view, t.range, t))
          return !0;
      } catch (u) {
        Qi(this.view.state, u, "scroll handler");
      }
    let { range: e } = t, i = this.coordsAt(e.head, e.empty ? e.assoc : e.head > e.anchor ? -1 : 1), s;
    if (!i)
      return;
    !e.empty && (s = this.coordsAt(e.anchor, e.anchor > e.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, s.left),
      top: Math.min(i.top, s.top),
      right: Math.max(i.right, s.right),
      bottom: Math.max(i.bottom, s.bottom)
    });
    let r = zb(this.view), a = {
      left: i.left - r.left,
      top: i.top - r.top,
      right: i.right + r.right,
      bottom: i.bottom + r.bottom
    }, { offsetWidth: o, offsetHeight: l } = this.view.scrollDOM;
    p7(this.view.scrollDOM, a, e.head < e.anchor ? -1 : 1, t.x, t.y, Math.max(Math.min(t.xMargin, o), -o), Math.max(Math.min(t.yMargin, l), -l), this.view.textDirection == le.LTR);
  }
  lineHasWidget(t) {
    let e = /* @__PURE__ */ f((i) => i.isWidget() || i.children.some(e), "scan");
    return e(this.tile.resolveBlock(t, 1).tile);
  }
  destroy() {
    bO(this.tile);
  }
}, c(td, "$f"), td);
f(p6, "DocView");
let Z3 = p6;
function bO(n, t) {
  let e = t?.get(n);
  if (e != 1) {
    e == null && n.destroy();
    for (let i of n.children)
      bO(i, t);
  }
}
c(bO, "Yl$1");
f(bO, "destroyDropped");
function f6(n) {
  return n.node.nodeType == 1 && n.node.firstChild && (n.offset == 0 || n.node.childNodes[n.offset - 1].contentEditable == "false") && (n.offset == n.node.childNodes.length || n.node.childNodes[n.offset].contentEditable == "false");
}
c(f6, "_0$1");
f(f6, "betweenUneditable");
function nC(n, t) {
  let e = n.observer.selectionRange;
  if (!e.focusNode)
    return null;
  let i = jS(e.focusNode, e.focusOffset), s = BS(e.focusNode, e.focusOffset), r = i || s;
  if (s && i && s.node != i.node) {
    let o = Pe.get(s.node);
    if (!o || o.isText() && o.text != s.node.nodeValue)
      r = s;
    else if (n.docView.lastCompositionAfterCursor) {
      let l = Pe.get(i.node);
      !l || l.isText() && l.text != i.node.nodeValue || (r = s);
    }
  }
  if (n.docView.lastCompositionAfterCursor = r != i, !r)
    return null;
  let a = t - r.offset;
  return { from: a, to: a + r.node.nodeValue.length, node: r.node };
}
c(nC, "zd$1");
f(nC, "findCompositionNode");
function y6(n, t, e) {
  let i = nC(n, e);
  if (!i)
    return null;
  let { node: s, from: r, to: a } = i, o = s.nodeValue;
  if (/[\n\r]/.test(o) || n.state.doc.sliceString(i.from, i.to) != o)
    return null;
  let l = t.invertedDesc;
  return { range: new Ls(l.mapPos(r), l.mapPos(a), r, a), text: s };
}
c(y6, "M0$1");
f(y6, "findCompositionRange");
function m6(n, t) {
  return n.nodeType != 1 ? 0 : (t && n.childNodes[t - 1].contentEditable == "false" ? 1 : 0) | (t < n.childNodes.length && n.childNodes[t].contentEditable == "false" ? 2 : 0);
}
c(m6, "Z0$1");
f(m6, "nextToUneditable");
var n2, ed;
let ZD = (n2 = (ed = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t, e) {
    eo(t, e, this.changes);
  }
  comparePoint(t, e) {
    eo(t, e, this.changes);
  }
  boundChange(t) {
    eo(t, t, this.changes);
  }
}, c(ed, "Ri$1"), ed), f(n2, "DecorationComparator"), n2);
function g6(n, t, e) {
  let i = new ZD();
  return Qe.compare(n, t, e, i), i.changes;
}
c(g6, "X0$1");
f(g6, "findChangedDeco");
var id;
const w6 = (id = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t, e) {
    eo(t, e, this.changes);
  }
  comparePoint() {
  }
  boundChange(t) {
    eo(t, t, this.changes);
  }
}, c(id, "Rf"), id);
f(w6, "WrapperComparator");
let FD = w6;
function v6(n, t, e) {
  let i = new FD();
  return Qe.compare(n, t, e, i), i.changes;
}
c(v6, "E0$1");
f(v6, "findChangedWrappers");
function O6(n, t) {
  for (let e = n; e && e != t; e = e.assignedSlot || e.parentNode)
    if (e.nodeType == 1 && e.contentEditable == "false")
      return !0;
  return !1;
}
c(O6, "Y0$1");
f(O6, "inUneditable");
function b6(n, t) {
  let e = !1;
  return t && n.iterChangedRanges((i, s) => {
    i < t.to && s > t.from && (e = !0);
  }), e;
}
c(b6, "W0$1");
f(b6, "touchesComposition");
var nd;
const $6 = (nd = class extends Pl {
  constructor(t) {
    super(), this.height = t;
  }
  toDOM() {
    let t = document.createElement("div");
    return t.className = "cm-gap", this.updateDOM(t), t;
  }
  eq(t) {
    return t.height == this.height;
  }
  updateDOM(t) {
    return t.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}, c(nd, "vf"), nd);
f($6, "BlockGapWidget");
let s2 = $6;
function x6(n, t, e = 1) {
  let i = n.charCategorizer(t), s = n.doc.lineAt(t), r = t - s.from;
  if (s.length == 0)
    return it.cursor(t);
  r == 0 ? e = 1 : r == s.length && (e = -1);
  let a = r, o = r;
  e < 0 ? a = Ui(s.text, r, !1) : o = Ui(s.text, r);
  let l = i(s.text.slice(a, o));
  for (; a > 0; ) {
    let h = Ui(s.text, a, !1);
    if (i(s.text.slice(h, a)) != l)
      break;
    a = h;
  }
  for (; o < s.length; ) {
    let h = Ui(s.text, o);
    if (i(s.text.slice(o, h)) != l)
      break;
    o = h;
  }
  return it.range(a + s.from, o + s.from);
}
c(x6, "V0$1");
f(x6, "groupAt");
function k6(n, t, e, i, s) {
  let r = Math.round((i - t.left) * n.defaultCharacterWidth);
  if (n.lineWrapping && e.height > n.defaultLineHeight * 1.5) {
    let o = n.viewState.heightOracle.textHeight, l = Math.floor((s - e.top - (n.defaultLineHeight - o) * 0.5) / o);
    r += l * n.viewState.heightOracle.lineLength;
  }
  let a = n.state.sliceDoc(e.from, e.to);
  return e.from + K8(a, r, n.state.tabSize);
}
c(k6, "U0$1");
f(k6, "posAtCoordsImprecise");
function S6(n, t, e) {
  let i = n.lineBlockAt(t);
  if (Array.isArray(i.type)) {
    let s;
    for (let r of i.type) {
      if (r.from > t)
        break;
      if (!(r.to < t)) {
        if (r.from < t && r.to > t)
          return r;
        (!s || r.type == cn.Text && (s.type != r.type || (e < 0 ? r.from < t : r.to > t))) && (s = r);
      }
    }
    return s || i;
  }
  return i;
}
c(S6, "I0$1");
f(S6, "blockAt");
function C6(n, t, e, i) {
  let s = S6(n, t.head, t.assoc || -1), r = !i || s.type != cn.Text || !(n.lineWrapping || s.widgetLineBreaks) ? null : n.coordsAtPos(t.assoc < 0 && t.head > s.from ? t.head - 1 : t.head);
  if (r) {
    let a = n.dom.getBoundingClientRect(), o = n.textDirectionAt(s.from), l = n.posAtCoords({
      x: e == (o == le.LTR) ? a.right - 1 : a.left + 1,
      y: (r.top + r.bottom) / 2
    });
    if (l != null)
      return it.cursor(l, e ? -1 : 1);
  }
  return it.cursor(e ? s.to : s.from, e ? -1 : 1);
}
c(C6, "z0$1");
f(C6, "moveToLineBoundary");
function Lk(n, t, e, i) {
  let s = n.state.doc.lineAt(t.head), r = n.bidiSpans(s), a = n.textDirectionAt(s.from);
  for (let o = t, l = null; ; ) {
    let h = S7(s, r, a, o, e), u = k7;
    if (!h) {
      if (s.number == (e ? n.state.doc.lines : 1))
        return o;
      u = `
`, s = n.state.doc.line(s.number + (e ? 1 : -1)), r = n.bidiSpans(s), h = n.visualLineSide(s, !e);
    }
    if (l) {
      if (!l(u))
        return o;
    } else {
      if (!i)
        return h;
      l = i(u);
    }
    o = h;
  }
}
c(Lk, "Qu$1");
f(Lk, "moveByChar");
function P6(n, t, e) {
  let i = n.state.charCategorizer(t), s = i(e);
  return (r) => {
    let a = i(r);
    return s == _s.Space && (s = a), s == a;
  };
}
c(P6, "j0$1");
f(P6, "byGroup");
function Q6(n, t, e, i) {
  let s = t.head, r = e ? 1 : -1;
  if (s == (e ? n.state.doc.length : 0))
    return it.cursor(s, t.assoc);
  let a = t.goalColumn, o, l = n.contentDOM.getBoundingClientRect(), h = n.coordsAtPos(s, t.assoc || -1), u = n.documentTop;
  if (h)
    a == null && (a = h.left - l.left), o = r < 0 ? h.top : h.bottom;
  else {
    let g = n.viewState.lineBlockAt(s);
    a == null && (a = Math.min(l.right - l.left, n.defaultCharacterWidth * (s - g.from))), o = (r < 0 ? g.top : g.bottom) + u;
  }
  let p = l.left + a, y = i ?? n.viewState.heightOracle.textHeight >> 1, m = $O(n, { x: p, y: o + y * r }, !1, r);
  return it.cursor(m.pos, m.assoc, void 0, a);
}
c(Q6, "q0$1");
f(Q6, "moveVertically");
function uh(n, t, e) {
  for (; ; ) {
    let i = 0;
    for (let s of n)
      s.between(t - 1, t + 1, (r, a, o) => {
        if (t > r && t < a) {
          let l = i || e || (t - r < a - t ? -1 : 1);
          t = l < 0 ? r : a, i = l;
        }
      });
    if (!i)
      return t;
  }
}
c(uh, "xr$1");
f(uh, "skipAtomicRanges");
function sC(n, t) {
  let e = null;
  for (let i = 0; i < t.ranges.length; i++) {
    let s = t.ranges[i], r = null;
    if (s.empty) {
      let a = uh(n, s.from, 0);
      a != s.from && (r = it.cursor(a, -1));
    } else {
      let a = uh(n, s.from, -1), o = uh(n, s.to, 1);
      (a != s.from || o != s.to) && (r = it.range(s.from == s.anchor ? a : o, s.from == s.head ? a : o));
    }
    r && (e || (e = t.ranges.slice()), e[i] = r);
  }
  return e ? it.create(e, t.mainIndex) : t;
}
c(sC, "jd$1");
f(sC, "skipAtomsForSelection");
function wv(n, t, e) {
  let i = uh(n.state.facet(o1).map((s) => s(n)), e.from, t.head > e.from ? -1 : 1);
  return i == e.from ? e : it.cursor(i, i < e.from ? 1 : -1);
}
c(wv, "Mo$1");
f(wv, "skipAtoms");
var sd;
const T6 = (sd = class {
  constructor(t, e) {
    this.pos = t, this.assoc = e;
  }
}, c(sd, "Tf"), sd);
f(T6, "PosAssoc");
let Yn = T6;
function $O(n, t, e, i) {
  let s = n.contentDOM.getBoundingClientRect(), r = s.top + n.viewState.paddingTop, { x: a, y: o } = t, l = o - r, h;
  for (; ; ) {
    if (l < 0)
      return new Yn(0, 1);
    if (l > n.viewState.docHeight)
      return new Yn(n.state.doc.length, -1);
    if (h = n.elementAtHeight(l), i == null)
      break;
    if (h.type == cn.Text) {
      let y = n.docView.coordsAt(i < 0 ? h.from : h.to, i);
      if (y && (i < 0 ? y.top <= l + r : y.bottom >= l + r))
        break;
    }
    let p = n.viewState.heightOracle.textHeight / 2;
    l = i > 0 ? h.bottom + p : h.top - p;
  }
  if (n.viewport.from >= h.to || n.viewport.to <= h.from) {
    if (e)
      return null;
    if (h.type == cn.Text) {
      let p = k6(n, s, h, a, o);
      return new Yn(p, p == h.from ? 1 : -1);
    }
  }
  if (h.type != cn.Text)
    return l < (h.top + h.bottom) / 2 ? new Yn(h.from, 1) : new Yn(h.to, -1);
  let u = n.docView.lineAt(h.from, 2);
  return (!u || u.length != h.length) && (u = n.docView.lineAt(h.from, -2)), rC(n, u, h.from, a, o);
}
c($O, "Vl$1");
f($O, "posAtCoords");
function rC(n, t, e, i, s) {
  let r = -1, a = null, o = 1e9, l = 1e9, h = s, u = s, p = /* @__PURE__ */ f((y, m) => {
    for (let g = 0; g < y.length; g++) {
      let b = y[g];
      if (b.top == b.bottom)
        continue;
      let S = b.left > i ? b.left - i : b.right < i ? i - b.right : 0, x = b.top > s ? b.top - s : b.bottom < s ? s - b.bottom : 0;
      b.top <= u && b.bottom >= h && (h = Math.min(b.top, h), u = Math.max(b.bottom, u), x = 0), (r < 0 || (x - l || S - o) < 0) && (r >= 0 && l && o < S && a.top <= u - 2 && a.bottom >= h + 2 ? l = 0 : (r = m, o = S, l = x, a = b));
    }
  }, "checkRects");
  if (t.isText()) {
    for (let y = 0; y < t.length; ) {
      let m = Ui(t.text, y);
      if (p(Uy(t.dom, y, m).getClientRects(), y), !o && !l)
        break;
      y = m;
    }
    return i > (a.left + a.right) / 2 == (Ik(n, r + e) == le.LTR) ? new Yn(e + Ui(t.text, r), -1) : new Yn(e + r, 1);
  } else {
    if (!t.length)
      return new Yn(e, 1);
    for (let g = 0; g < t.children.length; g++) {
      let b = t.children[g];
      if (b.flags & 48)
        continue;
      let S = (b.dom.nodeType == 1 ? b.dom : Uy(b.dom, 0, b.length)).getClientRects();
      if (p(S, g), !o && !l)
        break;
    }
    let y = t.children[r], m = t.posBefore(y, e);
    return y.isComposite() || y.isText() ? rC(n, y, m, Math.max(a.left, Math.min(a.right, i)), s) : i > (a.left + a.right) / 2 == (Ik(n, r + e) == le.LTR) ? new Yn(m + y.length, -1) : new Yn(m, 1);
  }
}
c(rC, "qd$1");
f(rC, "posAtCoordsInline");
function Ik(n, t) {
  let e = n.state.doc.lineAt(t);
  return n.bidiSpans(e)[zs.find(n.bidiSpans(e), t - e.from, -1, 1)].dir;
}
c(Ik, "yu$1");
f(Ik, "dirAt");
const wg = "￿";
var rd;
const M6 = (rd = class {
  constructor(t, e) {
    this.points = t, this.view = e, this.text = "", this.lineSeparator = e.state.facet(Ie.lineSeparator);
  }
  append(t) {
    this.text += t;
  }
  lineBreak() {
    this.text += wg;
  }
  readRange(t, e) {
    if (!t)
      return this;
    let i = t.parentNode;
    for (let s = t; ; ) {
      this.findPointBefore(i, s);
      let r = this.text.length;
      this.readNode(s);
      let a = Pe.get(s), o = s.nextSibling;
      if (o == e) {
        a?.breakAfter && !o && i != this.view.contentDOM && this.lineBreak();
        break;
      }
      let l = Pe.get(o);
      (a && l ? a.breakAfter : (a ? a.breakAfter : ww(s)) || ww(o) && (s.nodeName != "BR" || a?.isWidget()) && this.text.length > r) && !R6(o, e) && this.lineBreak(), s = o;
    }
    return this.findPointBefore(i, e), this;
  }
  readTextNode(t) {
    let e = t.nodeValue;
    for (let i of this.points)
      i.node == t && (i.pos = this.text.length + Math.min(i.offset, e.length));
    for (let i = 0, s = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let r = -1, a = 1, o;
      if (this.lineSeparator ? (r = e.indexOf(this.lineSeparator, i), a = this.lineSeparator.length) : (o = s.exec(e)) && (r = o.index, a = o[0].length), this.append(e.slice(i, r < 0 ? e.length : r)), r < 0)
        break;
      if (this.lineBreak(), a > 1)
        for (let l of this.points)
          l.node == t && l.pos > this.text.length && (l.pos -= a - 1);
      i = r + a;
    }
  }
  readNode(t) {
    let e = Pe.get(t), i = e && e.overrideDOMText;
    if (i != null) {
      this.findPointInside(t, i.length);
      for (let s = i.iter(); !s.next().done; )
        s.lineBreak ? this.lineBreak() : this.append(s.value);
    } else t.nodeType == 3 ? this.readTextNode(t) : t.nodeName == "BR" ? t.nextSibling && this.lineBreak() : t.nodeType == 1 && this.readRange(t.firstChild, null);
  }
  findPointBefore(t, e) {
    for (let i of this.points)
      i.node == t && t.childNodes[i.offset] == e && (i.pos = this.text.length);
  }
  findPointInside(t, e) {
    for (let i of this.points)
      (t.nodeType == 3 ? i.node == t : t.contains(i.node)) && (i.pos = this.text.length + (A6(t, i.node, i.offset) ? e : 0));
  }
}, c(rd, "Af"), rd);
f(M6, "DOMReader");
let XD = M6;
function A6(n, t, e) {
  for (; ; ) {
    if (!t || e < os(t))
      return !1;
    if (t == n)
      return !0;
    e = Bs(t) + 1, t = t.parentNode;
  }
}
c(A6, "B0$1");
f(A6, "isAtEnd");
function R6(n, t) {
  let e;
  for (; !(n == t || !n); n = n.nextSibling) {
    let i = Pe.get(n);
    if (!i?.isWidget())
      return !1;
    i && (e || (e = [])).push(i);
  }
  if (e) {
    for (let i of e)
      if (i.overrideDOMText?.length)
        return !1;
  }
  return !0;
}
c(R6, "D0$1");
f(R6, "isEmptyToEnd");
var ad;
const E6 = (ad = class {
  constructor(t, e) {
    this.node = t, this.offset = e, this.pos = -1;
  }
}, c(ad, "Lf"), ad);
f(E6, "DOMPoint");
let F3 = E6;
var od;
const _6 = (od = class {
  constructor(t, e, i, s) {
    this.typeOver = s, this.bounds = null, this.text = "", this.domChanged = e > -1;
    let { impreciseHead: r, impreciseAnchor: a } = t.docView;
    if (t.state.readOnly && e > -1)
      this.newSel = null;
    else if (e > -1 && (this.bounds = aC(t.docView.tile, e, i, 0))) {
      let o = r || a ? [] : L6(t), l = new XD(o, t);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = I6(o, this.bounds.from);
    } else {
      let o = t.observer.selectionRange, l = r && r.node == o.focusNode && r.offset == o.focusOffset || !yO(t.contentDOM, o.focusNode) ? t.state.selection.main.head : t.docView.posFromDOM(o.focusNode, o.focusOffset), h = a && a.node == o.anchorNode && a.offset == o.anchorOffset || !yO(t.contentDOM, o.anchorNode) ? t.state.selection.main.anchor : t.docView.posFromDOM(o.anchorNode, o.anchorOffset), u = t.viewport;
      if ((nt.ios || nt.chrome) && t.state.selection.main.empty && l != h && (u.from > 0 || u.to < t.state.doc.length)) {
        let p = Math.min(l, h), y = Math.max(l, h), m = u.from - p, g = u.to - y;
        (m == 0 || m == 1 || p == 0) && (g == 0 || g == -1 || y == t.state.doc.length) && (l = 0, h = t.state.doc.length);
      }
      t.inputState.composing > -1 && t.state.selection.ranges.length > 1 ? this.newSel = t.state.selection.replaceRange(it.range(h, l)) : this.newSel = it.single(h, l);
    }
  }
}, c(od, "_f"), od);
f(_6, "DOMChange");
let ND = _6;
function aC(n, t, e, i) {
  if (n.isComposite()) {
    let s = -1, r = -1, a = -1, o = -1;
    for (let l = 0, h = i, u = i; l < n.children.length; l++) {
      let p = n.children[l], y = h + p.length;
      if (h < t && y > e)
        return aC(p, t, e, h);
      if (y >= t && s == -1 && (s = l, r = h), h > e && p.dom.parentNode == n.dom) {
        a = l, o = u;
        break;
      }
      u = y, h = y + p.breakAfter;
    }
    return {
      from: r,
      to: o < 0 ? i + n.length : o,
      startDOM: (s ? n.children[s - 1].dom.nextSibling : null) || n.dom.firstChild,
      endDOM: a < n.children.length && a >= 0 ? n.children[a].dom : null
    };
  } else return n.isText() ? { from: i, to: i + n.length, startDOM: n.dom, endDOM: n.dom.nextSibling } : null;
}
c(aC, "Bd$1");
f(aC, "domBoundsAround");
function oC(n, t) {
  let e, { newSel: i } = t, s = n.state.selection.main, r = n.inputState.lastKeyTime > Date.now() - 100 ? n.inputState.lastKeyCode : -1;
  if (t.bounds) {
    let { from: a, to: o } = t.bounds, l = s.from, h = null;
    (r === 8 || nt.android && t.text.length < o - a) && (l = s.to, h = "end");
    let u = lC(n.state.doc.sliceString(a, o, wg), t.text, l - a, h);
    u && (nt.chrome && r == 13 && u.toB == u.from + 2 && t.text.slice(u.from, u.toB) == wg + wg && u.toB--, e = {
      from: a + u.from,
      to: a + u.toA,
      insert: Ft.of(t.text.slice(u.from, u.toB).split(wg))
    });
  } else i && (!n.hasFocus && n.state.facet(Ms) || Ow(i, s)) && (i = null);
  if (!e && !i)
    return !1;
  if (!e && t.typeOver && !s.empty && i && i.main.empty ? e = { from: s.from, to: s.to, insert: n.state.doc.slice(s.from, s.to) } : (nt.mac || nt.android) && e && e.from == e.to && e.from == s.head - 1 && /^\. ?$/.test(e.insert.toString()) && n.contentDOM.getAttribute("autocorrect") == "off" ? (i && e.insert.length == 2 && (i = it.single(i.main.anchor - 1, i.main.head - 1)), e = { from: e.from, to: e.to, insert: Ft.of([e.insert.toString().replace(".", " ")]) }) : e && e.from >= s.from && e.to <= s.to && (e.from != s.from || e.to != s.to) && s.to - s.from - (e.to - e.from) <= 4 ? e = {
    from: s.from,
    to: s.to,
    insert: n.state.doc.slice(s.from, e.from).append(e.insert).append(n.state.doc.slice(e.to, s.to))
  } : n.state.doc.lineAt(s.from).to < s.to && n.docView.lineHasWidget(s.to) && n.inputState.insertingTextAt > Date.now() - 50 ? e = {
    from: s.from,
    to: s.to,
    insert: n.state.toText(n.inputState.insertingText)
  } : nt.chrome && e && e.from == e.to && e.from == s.head && e.insert.toString() == `
 ` && n.lineWrapping && (i && (i = it.single(i.main.anchor - 1, i.main.head - 1)), e = { from: s.from, to: s.to, insert: Ft.of([" "]) }), e)
    return Wb(n, e, i, r);
  if (i && !Ow(i, s)) {
    let a = !1, o = "select";
    return n.inputState.lastSelectionTime > Date.now() - 50 && (n.inputState.lastSelectionOrigin == "select" && (a = !0), o = n.inputState.lastSelectionOrigin, o == "select.pointer" && (i = sC(n.state.facet(o1).map((l) => l(n)), i))), n.dispatch({ selection: i, scrollIntoView: a, userEvent: o }), !0;
  } else
    return !1;
}
c(oC, "Dd$1");
f(oC, "applyDOMChange");
function Wb(n, t, e, i = -1) {
  if (nt.ios && n.inputState.flushIOSKey(t))
    return !0;
  let s = n.state.selection.main;
  if (nt.android && (t.to == s.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (t.from == s.from || t.from == s.from - 1 && n.state.sliceDoc(t.from, s.from) == " ") && t.insert.length == 1 && t.insert.lines == 2 && io(n.contentDOM, "Enter", 13) || (t.from == s.from - 1 && t.to == s.to && t.insert.length == 0 || i == 8 && t.insert.length < t.to - t.from && t.to > s.head) && io(n.contentDOM, "Backspace", 8) || t.from == s.from && t.to == s.to + 1 && t.insert.length == 0 && io(n.contentDOM, "Delete", 46)))
    return !0;
  let r = t.insert.toString();
  n.inputState.composing >= 0 && n.inputState.composing++;
  let a, o = /* @__PURE__ */ f(() => a || (a = z6(n, t, e)), "defaultInsert");
  return n.state.facet(A7).some((l) => l(n, t.from, t.to, r, o)) || n.dispatch(o()), !0;
}
c(Wb, "Sh$1");
f(Wb, "applyDOMChangeInner");
function z6(n, t, e) {
  let i, s = n.state, r = s.selection.main, a = -1;
  if (t.from == t.to && t.from < r.from || t.from > r.to) {
    let l = t.from < r.from ? -1 : 1, h = l < 0 ? r.from : r.to, u = uh(s.facet(o1).map((p) => p(n)), h, l);
    t.from == u && (a = u);
  }
  if (a > -1)
    i = {
      changes: t,
      selection: it.cursor(t.from + t.insert.length, -1)
    };
  else if (t.from >= r.from && t.to <= r.to && t.to - t.from >= (r.to - r.from) / 3 && (!e || e.main.empty && e.main.from == t.from + t.insert.length) && n.inputState.composing < 0) {
    let l = r.from < t.from ? s.sliceDoc(r.from, t.from) : "", h = r.to > t.to ? s.sliceDoc(t.to, r.to) : "";
    i = s.replaceSelection(n.state.toText(l + t.insert.sliceString(0, void 0, n.state.lineBreak) + h));
  } else {
    let l = s.changes(t), h = e && e.main.to <= l.newLength ? e.main : void 0;
    if (s.selection.ranges.length > 1 && (n.inputState.composing >= 0 || n.inputState.compositionPendingChange) && t.to <= r.to + 10 && t.to >= r.to - 10) {
      let u = n.state.sliceDoc(t.from, t.to), p, y = e && nC(n, e.main.head);
      if (y) {
        let g = t.insert.length - (t.to - t.from);
        p = { from: y.from, to: y.to - g };
      } else
        p = n.state.doc.lineAt(r.head);
      let m = r.to - t.to;
      i = s.changeByRange((g) => {
        if (g.from == r.from && g.to == r.to)
          return { changes: l, range: h || g.map(l) };
        let b = g.to - m, S = b - u.length;
        if (n.state.sliceDoc(S, b) != u || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        b >= p.from && S <= p.to)
          return { range: g };
        let x = s.changes({ from: S, to: b, insert: t.insert }), Q = g.to - r.to;
        return {
          changes: x,
          range: h ? it.range(Math.max(0, h.anchor + Q), Math.max(0, h.head + Q)) : g.map(x)
        };
      });
    } else
      i = {
        changes: l,
        selection: h && s.selection.replaceRange(h)
      };
  }
  let o = "input.type";
  return (n.composing || n.inputState.compositionPendingChange && n.inputState.compositionEndedAt > Date.now() - 50) && (n.inputState.compositionPendingChange = !1, o += ".compose", n.inputState.compositionFirstChange && (o += ".start", n.inputState.compositionFirstChange = !1)), s.update(i, { userEvent: o, scrollIntoView: !0 });
}
c(z6, "N0$1");
f(z6, "applyDefaultInsert");
function lC(n, t, e, i) {
  let s = Math.min(n.length, t.length), r = 0;
  for (; r < s && n.charCodeAt(r) == t.charCodeAt(r); )
    r++;
  if (r == s && n.length == t.length)
    return null;
  let a = n.length, o = t.length;
  for (; a > 0 && o > 0 && n.charCodeAt(a - 1) == t.charCodeAt(o - 1); )
    a--, o--;
  if (i == "end") {
    let l = Math.max(0, r - Math.min(a, o));
    e -= a + l - r;
  }
  if (a < r && n.length < t.length) {
    let l = e <= r && e >= a ? r - e : 0;
    r -= l, o = r + (o - a), a = r;
  } else if (o < r) {
    let l = e <= r && e >= o ? r - e : 0;
    r -= l, a = r + (a - o), o = r;
  }
  return { from: r, toA: a, toB: o };
}
c(lC, "Nd$1");
f(lC, "findDiff");
function L6(n) {
  let t = [];
  if (n.root.activeElement != n.contentDOM)
    return t;
  let { anchorNode: e, anchorOffset: i, focusNode: s, focusOffset: r } = n.observer.selectionRange;
  return e && (t.push(new F3(e, i)), (s != e || r != i) && t.push(new F3(s, r))), t;
}
c(L6, "G0$1");
f(L6, "selectionPoints");
function I6(n, t) {
  if (n.length == 0)
    return null;
  let e = n[0].pos, i = n.length == 2 ? n[1].pos : e;
  return e > -1 && i > -1 ? it.single(e + t, i + t) : null;
}
c(I6, "F0$1");
f(I6, "selectionFromPoints");
function Ow(n, t) {
  return t.head == n.main.head && t.anchor == n.main.anchor;
}
c(Ow, "as$2");
f(Ow, "sameSelPos");
var ld;
const W6 = (ld = class {
  setSelectionOrigin(t) {
    this.lastSelectionOrigin = t, this.lastSelectionTime = Date.now();
  }
  constructor(t) {
    this.view = t, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.insertingText = "", this.insertingTextAt = 0, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = t.hasFocus, nt.safari && t.contentDOM.addEventListener("input", () => null), nt.gecko && eT(t.contentDOM.ownerDocument);
  }
  handleEvent(t) {
    !B6(this.view, t) || this.ignoreDuringComposition(t) || t.type == "keydown" && this.keydown(t) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(t.type, t)) : this.runHandlers(t.type, t));
  }
  runHandlers(t, e) {
    let i = this.handlers[t];
    if (i) {
      for (let s of i.observers)
        s(this.view, e);
      for (let s of i.handlers) {
        if (e.defaultPrevented)
          break;
        if (s(this.view, e)) {
          e.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(t) {
    let e = V6(t), i = this.handlers, s = this.view.contentDOM;
    for (let r in e)
      if (r != "scroll") {
        let a = !e[r].handlers.length, o = i[r];
        o && a != !o.handlers.length && (s.removeEventListener(r, this.handleEvent), o = null), o || s.addEventListener(r, this.handleEvent, { passive: a });
      }
    for (let r in i)
      r != "scroll" && !e[r] && s.removeEventListener(r, this.handleEvent);
    this.handlers = e;
  }
  keydown(t) {
    if (this.lastKeyCode = t.keyCode, this.lastKeyTime = Date.now(), t.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && t.keyCode != 27 && q6.indexOf(t.keyCode) < 0 && (this.tabFocusMode = -1), nt.android && nt.chrome && !t.synthetic && (t.keyCode == 13 || t.keyCode == 8))
      return this.view.observer.delayAndroidKey(t.key, t.keyCode), !0;
    let e;
    return nt.ios && !t.synthetic && !t.altKey && !t.metaKey && ((e = D6.find((i) => i.keyCode == t.keyCode)) && !t.ctrlKey || BD.indexOf(t.key) > -1 && t.ctrlKey && !t.shiftKey) ? (this.pendingIOSKey = e || t, setTimeout(() => this.flushIOSKey(), 250), !0) : (t.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(t) {
    let e = this.pendingIOSKey;
    return !e || e.key == "Enter" && t && t.from < t.to && /^\S+$/.test(t.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, io(this.view.contentDOM, e.key, e.keyCode, e instanceof KeyboardEvent ? e : void 0));
  }
  ignoreDuringComposition(t) {
    return !/^key/.test(t.type) || t.synthetic ? !1 : this.composing > 0 ? !0 : nt.safari && !nt.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1;
  }
  startMouseSelection(t) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = t;
  }
  update(t) {
    this.view.observer.update(t), this.mouseSelection && this.mouseSelection.update(t), this.draggedContent && t.docChanged && (this.draggedContent = this.draggedContent.map(t.changes)), t.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}, c(ld, "Mf"), ld);
f(W6, "InputState");
let jD = W6;
function Wk(n, t) {
  return (e, i) => {
    try {
      return t.call(n, i, e);
    } catch (s) {
      Qi(e.state, s);
    }
  };
}
c(Wk, "Su$1");
f(Wk, "bindHandler");
function V6(n) {
  let t = /* @__PURE__ */ Object.create(null);
  function e(i) {
    return t[i] || (t[i] = { observers: [], handlers: [] });
  }
  c(e, "t"), f(e, "record");
  for (let i of n) {
    let s = i.spec, r = s && s.plugin.domEventHandlers, a = s && s.plugin.domEventObservers;
    if (r)
      for (let o in r) {
        let l = r[o];
        l && e(o).handlers.push(Wk(i.value, l));
      }
    if (a)
      for (let o in a) {
        let l = a[o];
        l && e(o).observers.push(Wk(i.value, l));
      }
  }
  for (let i in Mn)
    e(i).handlers.push(Mn[i]);
  for (let i in hn)
    e(i).observers.push(hn[i]);
  return t;
}
c(V6, "H0$1");
f(V6, "computeHandlers");
const D6 = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], BD = "dthko", q6 = [16, 17, 18, 20, 91, 92, 224, 225], X1 = 6;
function vg(n) {
  return Math.max(0, n) * 0.7 + 8;
}
c(vg, "An$1");
f(vg, "dragScrollSpeed");
function Z6(n, t) {
  return Math.max(Math.abs(n.clientX - t.clientX), Math.abs(n.clientY - t.clientY));
}
c(Z6, "J0$1");
f(Z6, "dist");
var cd;
const F6 = (cd = class {
  constructor(t, e, i, s) {
    this.view = t, this.startEvent = e, this.style = i, this.mustSelect = s, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = e, this.scrollParents = f7(t.contentDOM), this.atoms = t.state.facet(o1).map((a) => a(t));
    let r = t.contentDOM.ownerDocument;
    r.addEventListener("mousemove", this.move = this.move.bind(this)), r.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = e.shiftKey, this.multiple = t.state.facet(Ie.allowMultipleSelections) && X6(t, e), this.dragging = j6(t, e) && hC(e) == 1 ? null : !1;
  }
  start(t) {
    this.dragging === !1 && this.select(t);
  }
  move(t) {
    if (t.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && Z6(this.startEvent, t) < 10)
      return;
    this.select(this.lastEvent = t);
    let e = 0, i = 0, s = 0, r = 0, a = this.view.win.innerWidth, o = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: s, right: a } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: r, bottom: o } = this.scrollParents.y.getBoundingClientRect());
    let l = zb(this.view);
    t.clientX - l.left <= s + X1 ? e = -vg(s - t.clientX) : t.clientX + l.right >= a - X1 && (e = vg(t.clientX - a)), t.clientY - l.top <= r + X1 ? i = -vg(r - t.clientY) : t.clientY + l.bottom >= o - X1 && (i = vg(t.clientY - o)), this.setScrollSpeed(e, i);
  }
  up(t) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || t.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let t = this.view.contentDOM.ownerDocument;
    t.removeEventListener("mousemove", this.move), t.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(t, e) {
    this.scrollSpeed = { x: t, y: e }, t || e ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: t, y: e } = this.scrollSpeed;
    t && this.scrollParents.x && (this.scrollParents.x.scrollLeft += t, t = 0), e && this.scrollParents.y && (this.scrollParents.y.scrollTop += e, e = 0), (t || e) && this.view.win.scrollBy(t, e), this.dragging === !1 && this.select(this.lastEvent);
  }
  select(t) {
    let { view: e } = this, i = sC(this.atoms, this.style.get(t, this.extend, this.multiple));
    (this.mustSelect || !i.eq(e.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(t) {
    t.transactions.some((e) => e.isUserEvent("input.type")) ? this.destroy() : this.style.update(t) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}, c(cd, "Zf"), cd);
f(F6, "MouseSelection");
let UD = F6;
function X6(n, t) {
  let e = n.state.facet(P7);
  return e.length ? e[0](t) : nt.mac ? t.metaKey : t.ctrlKey;
}
c(X6, "e1");
f(X6, "addsSelectionRange");
function N6(n, t) {
  let e = n.state.facet(Q7);
  return e.length ? e[0](t) : nt.mac ? !t.altKey : !t.ctrlKey;
}
c(N6, "t1");
f(N6, "dragMovesSelection");
function j6(n, t) {
  let { main: e } = n.state.selection;
  if (e.empty)
    return !1;
  let i = Ko(n.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let s = i.getRangeAt(0).getClientRects();
  for (let r = 0; r < s.length; r++) {
    let a = s[r];
    if (a.left <= t.clientX && a.right >= t.clientX && a.top <= t.clientY && a.bottom >= t.clientY)
      return !0;
  }
  return !1;
}
c(j6, "i1");
f(j6, "isInPrimarySelection");
function B6(n, t) {
  if (!t.bubbles)
    return !0;
  if (t.defaultPrevented)
    return !1;
  for (let e = t.target, i; e != n.contentDOM; e = e.parentNode)
    if (!e || e.nodeType == 11 || (i = Pe.get(e)) && i.isWidget() && !i.isHidden && i.widget.ignoreEvent(t))
      return !1;
  return !0;
}
c(B6, "r1");
f(B6, "eventBelongsToEditor");
const Mn = /* @__PURE__ */ Object.create(null), hn = /* @__PURE__ */ Object.create(null), U6 = nt.ie && nt.ie_version < 15 || nt.ios && nt.webkit_version < 604;
function H6(n) {
  let t = n.dom.parentNode;
  if (!t)
    return;
  let e = t.appendChild(document.createElement("textarea"));
  e.style.cssText = "position: fixed; left: -10000px; top: 10px", e.focus(), setTimeout(() => {
    n.focus(), e.remove(), cC(n, e.value);
  }, 50);
}
c(H6, "n1");
f(H6, "capturePaste");
function l1(n, t, e) {
  for (let i of n.facet(t))
    e = i(e, n);
  return e;
}
c(l1, "bo$1");
f(l1, "textFilter");
function cC(n, t) {
  t = l1(n.state, JS, t);
  let { state: e } = n, i, s = 1, r = e.toText(t), a = r.lines == e.selection.ranges.length;
  if (qk != null && e.selection.ranges.every((o) => o.empty) && qk == r.toString()) {
    let o = -1;
    i = e.changeByRange((l) => {
      let h = e.doc.lineAt(l.from);
      if (h.from == o)
        return { range: l };
      o = h.from;
      let u = e.toText((a ? r.line(s++).text : t) + e.lineBreak);
      return {
        changes: { from: h.from, insert: u },
        range: it.cursor(l.from + u.length)
      };
    });
  } else a ? i = e.changeByRange((o) => {
    let l = r.line(s++);
    return {
      changes: { from: o.from, to: o.to, insert: l.text },
      range: it.cursor(o.from + l.length)
    };
  }) : i = e.replaceSelection(r);
  n.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
c(cC, "Kd$1");
f(cC, "doPaste");
hn.scroll = (n) => {
  n.inputState.lastScrollTop = n.scrollDOM.scrollTop, n.inputState.lastScrollLeft = n.scrollDOM.scrollLeft;
};
Mn.keydown = (n, t) => (n.inputState.setSelectionOrigin("select"), t.keyCode == 27 && n.inputState.tabFocusMode != 0 && (n.inputState.tabFocusMode = Date.now() + 2e3), !1);
hn.touchstart = (n, t) => {
  n.inputState.lastTouchTime = Date.now(), n.inputState.setSelectionOrigin("select.pointer");
};
hn.touchmove = (n) => {
  n.inputState.setSelectionOrigin("select.pointer");
};
Mn.mousedown = (n, t) => {
  if (n.observer.flush(), n.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let e = null;
  for (let i of n.state.facet(T7))
    if (e = i(n, t), e)
      break;
  if (!e && t.button == 0 && (e = Y6(n, t)), e) {
    let i = !n.hasFocus;
    n.inputState.startMouseSelection(new UD(n, t, e, i)), i && n.observer.ignore(() => {
      XS(n.contentDOM);
      let r = n.root.activeElement;
      r && !r.contains(n.contentDOM) && r.blur();
    });
    let s = n.inputState.mouseSelection;
    if (s)
      return s.start(t), s.dragging === !1;
  } else
    n.inputState.setSelectionOrigin("select.pointer");
  return !1;
};
function Vk(n, t, e, i) {
  if (i == 1)
    return it.cursor(t, e);
  if (i == 2)
    return x6(n.state, t, e);
  {
    let s = n.docView.lineAt(t, e), r = n.state.doc.lineAt(s ? s.posAtEnd : t), a = s ? s.posAtStart : r.from, o = s ? s.posAtEnd : r.to;
    return o < n.state.doc.length && o == r.to && o++, it.range(a, o);
  }
}
c(Vk, "bu$1");
f(Vk, "rangeForClick");
const HD = nt.ie && nt.ie_version <= 11;
let X3 = null, N3 = 0, j3 = 0;
function hC(n) {
  if (!HD)
    return n.detail;
  let t = X3, e = j3;
  return X3 = n, j3 = Date.now(), N3 = !t || e > Date.now() - 400 && Math.abs(t.clientX - n.clientX) < 2 && Math.abs(t.clientY - n.clientY) < 2 ? (N3 + 1) % 3 : 1;
}
c(hC, "Jd$1");
f(hC, "getClickType");
function Y6(n, t) {
  let e = n.posAndSideAtCoords({ x: t.clientX, y: t.clientY }, !1), i = hC(t), s = n.state.selection;
  return {
    update(r) {
      r.docChanged && (e.pos = r.changes.mapPos(e.pos), s = s.map(r.changes));
    },
    get(r, a, o) {
      let l = n.posAndSideAtCoords({ x: r.clientX, y: r.clientY }, !1), h, u = Vk(n, l.pos, l.assoc, i);
      if (e.pos != l.pos && !a) {
        let p = Vk(n, e.pos, e.assoc, i), y = Math.min(p.from, u.from), m = Math.max(p.to, u.to);
        u = y < u.from ? it.range(y, m) : it.range(m, y);
      }
      return a ? s.replaceRange(s.main.extend(u.from, u.to)) : o && i == 1 && s.ranges.length > 1 && (h = G6(s, l.pos)) ? h : o ? s.addRange(u) : it.create([u]);
    }
  };
}
c(Y6, "o1");
f(Y6, "basicMouseSelection");
function G6(n, t) {
  for (let e = 0; e < n.ranges.length; e++) {
    let { from: i, to: s } = n.ranges[e];
    if (i <= t && s >= t)
      return it.create(n.ranges.slice(0, e).concat(n.ranges.slice(e + 1)), n.mainIndex == e ? 0 : n.mainIndex - (n.mainIndex > e ? 1 : 0));
  }
  return null;
}
c(G6, "l1");
f(G6, "removeRangeAround");
Mn.dragstart = (n, t) => {
  let { selection: { main: e } } = n.state;
  if (t.target.draggable) {
    let s = n.docView.tile.nearest(t.target);
    if (s && s.isWidget()) {
      let r = s.posAtStart, a = r + s.length;
      (r >= e.to || a <= e.from) && (e = it.range(r, a));
    }
  }
  let { inputState: i } = n;
  return i.mouseSelection && (i.mouseSelection.dragging = !0), i.draggedContent = e, t.dataTransfer && (t.dataTransfer.setData("Text", l1(n.state, tC, n.state.sliceDoc(e.from, e.to))), t.dataTransfer.effectAllowed = "copyMove"), !1;
};
Mn.dragend = (n) => (n.inputState.draggedContent = null, !1);
function Dk(n, t, e, i) {
  if (e = l1(n.state, JS, e), !e)
    return;
  let s = n.posAtCoords({ x: t.clientX, y: t.clientY }, !1), { draggedContent: r } = n.inputState, a = i && r && N6(n, t) ? { from: r.from, to: r.to } : null, o = { from: s, insert: e }, l = n.state.changes(a ? [a, o] : o);
  n.focus(), n.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(s, -1), head: l.mapPos(s, 1) },
    userEvent: a ? "move.drop" : "input.drop"
  }), n.inputState.draggedContent = null;
}
c(Dk, "Pu$1");
f(Dk, "dropText");
Mn.drop = (n, t) => {
  if (!t.dataTransfer)
    return !1;
  if (n.state.readOnly)
    return !0;
  let e = t.dataTransfer.files;
  if (e && e.length) {
    let i = Array(e.length), s = 0, r = /* @__PURE__ */ f(() => {
      ++s == e.length && Dk(n, t, i.filter((a) => a != null).join(n.state.lineBreak), !1);
    }, "finishFile");
    for (let a = 0; a < e.length; a++) {
      let o = new FileReader();
      o.onerror = r, o.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(o.result) || (i[a] = o.result), r();
      }, o.readAsText(e[a]);
    }
    return !0;
  } else {
    let i = t.dataTransfer.getData("Text");
    if (i)
      return Dk(n, t, i, !0), !0;
  }
  return !1;
};
Mn.paste = (n, t) => {
  if (n.state.readOnly)
    return !0;
  n.observer.flush();
  let e = U6 ? null : t.clipboardData;
  return e ? (cC(n, e.getData("text/plain") || e.getData("text/uri-list")), !0) : (H6(n), !1);
};
function K6(n, t) {
  let e = n.dom.parentNode;
  if (!e)
    return;
  let i = e.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = t, i.focus(), i.selectionEnd = t.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), n.focus();
  }, 50);
}
c(K6, "a1");
f(K6, "captureCopy");
function J6(n) {
  let t = [], e = [], i = !1;
  for (let s of n.selection.ranges)
    s.empty || (t.push(n.sliceDoc(s.from, s.to)), e.push(s));
  if (!t.length) {
    let s = -1;
    for (let { from: r } of n.selection.ranges) {
      let a = n.doc.lineAt(r);
      a.number > s && (t.push(a.text), e.push({ from: a.from, to: Math.min(n.doc.length, a.to + 1) })), s = a.number;
    }
    i = !0;
  }
  return { text: l1(n, tC, t.join(n.lineBreak)), ranges: e, linewise: i };
}
c(J6, "h1$1");
f(J6, "copiedRange");
let qk = null;
Mn.copy = Mn.cut = (n, t) => {
  let e = Ko(n.root);
  if (e && !lh(n.contentDOM, e))
    return !1;
  let { text: i, ranges: s, linewise: r } = J6(n.state);
  if (!i && !r)
    return !1;
  qk = r ? i : null, t.type == "cut" && !n.state.readOnly && n.dispatch({
    changes: s,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let a = U6 ? null : t.clipboardData;
  return a ? (a.clearData(), a.setData("text/plain", i), !0) : (K6(n, i), !1);
};
const tT = /* @__PURE__ */ ar.define();
function dC(n, t) {
  let e = [];
  for (let i of n.facet(R7)) {
    let s = i(n, t);
    s && e.push(s);
  }
  return e.length ? n.update({ effects: e, annotations: tT.of(!0) }) : null;
}
c(dC, "tp");
f(dC, "focusChangeTransaction");
function uC(n) {
  setTimeout(() => {
    let t = n.hasFocus;
    if (t != n.inputState.notifiedFocused) {
      let e = dC(n.state, t);
      e ? n.dispatch(e) : n.update([]);
    }
  }, 10);
}
c(uC, "ip");
f(uC, "updateForFocusChange");
hn.focus = (n) => {
  n.inputState.lastFocusTime = Date.now(), !n.scrollDOM.scrollTop && (n.inputState.lastScrollTop || n.inputState.lastScrollLeft) && (n.scrollDOM.scrollTop = n.inputState.lastScrollTop, n.scrollDOM.scrollLeft = n.inputState.lastScrollLeft), uC(n);
};
hn.blur = (n) => {
  n.observer.clearSelectionRange(), uC(n);
};
hn.compositionstart = hn.compositionupdate = (n) => {
  n.observer.editContext || (n.inputState.compositionFirstChange == null && (n.inputState.compositionFirstChange = !0), n.inputState.composing < 0 && (n.inputState.composing = 0));
};
hn.compositionend = (n) => {
  n.observer.editContext || (n.inputState.composing = -1, n.inputState.compositionEndedAt = Date.now(), n.inputState.compositionPendingKey = !0, n.inputState.compositionPendingChange = n.observer.pendingRecords().length > 0, n.inputState.compositionFirstChange = null, nt.chrome && nt.android ? n.observer.flushSoon() : n.inputState.compositionPendingChange ? Promise.resolve().then(() => n.observer.flush()) : setTimeout(() => {
    n.inputState.composing < 0 && n.docView.hasComposition && n.update([]);
  }, 50));
};
hn.contextmenu = (n) => {
  n.inputState.lastContextMenu = Date.now();
};
Mn.beforeinput = (n, t) => {
  var e, i;
  if ((t.inputType == "insertText" || t.inputType == "insertCompositionText") && (n.inputState.insertingText = t.data, n.inputState.insertingTextAt = Date.now()), t.inputType == "insertReplacementText" && n.observer.editContext) {
    let r = (e = t.dataTransfer) === null || e === void 0 ? void 0 : e.getData("text/plain"), a = t.getTargetRanges();
    if (r && a.length) {
      let o = a[0], l = n.posAtDOM(o.startContainer, o.startOffset), h = n.posAtDOM(o.endContainer, o.endOffset);
      return Wb(n, { from: l, to: h, insert: n.state.toText(r) }, null), !0;
    }
  }
  let s;
  if (nt.chrome && nt.android && (s = D6.find((r) => r.inputType == t.inputType)) && (n.observer.delayAndroidKey(s.key, s.keyCode), s.key == "Backspace" || s.key == "Delete")) {
    let r = ((i = window.visualViewport) === null || i === void 0 ? void 0 : i.height) || 0;
    setTimeout(() => {
      var a;
      (((a = window.visualViewport) === null || a === void 0 ? void 0 : a.height) || 0) > r + 10 && n.hasFocus && (n.contentDOM.blur(), n.focus());
    }, 100);
  }
  return nt.ios && t.inputType == "deleteContentForward" && n.observer.flushSoon(), nt.safari && t.inputType == "insertText" && n.inputState.composing >= 0 && setTimeout(() => hn.compositionend(n, t), 20), !1;
};
const B3 = /* @__PURE__ */ new Set();
function eT(n) {
  B3.has(n) || (B3.add(n), n.addEventListener("copy", () => {
  }), n.addEventListener("cut", () => {
  }));
}
c(eT, "f1$1");
f(eT, "firefoxCopyCutHack");
const U3 = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let Yy = !1;
function Zk() {
  Yy = !1;
}
c(Zk, "vu$1");
f(Zk, "clearHeightChangeFlag");
var hd;
const iT = (hd = class {
  constructor(t) {
    this.lineWrapping = t, this.doc = Ft.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(t, e) {
    let i = this.doc.lineAt(e).number - this.doc.lineAt(t).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((e - t - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(t) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t - this.lineLength) / Math.max(1, this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(t) {
    return this.doc = t, this;
  }
  mustRefreshForWrapping(t) {
    return U3.indexOf(t) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(t) {
    let e = !1;
    for (let i = 0; i < t.length; i++) {
      let s = t[i];
      s < 0 ? i++ : this.heightSamples[Math.floor(s * 10)] || (e = !0, this.heightSamples[Math.floor(s * 10)] = !0);
    }
    return e;
  }
  refresh(t, e, i, s, r, a) {
    let o = U3.indexOf(t) > -1, l = Math.abs(e - this.lineHeight) > 0.3 || this.lineWrapping != o || Math.abs(i - this.charWidth) > 0.1;
    if (this.lineWrapping = o, this.lineHeight = e, this.charWidth = i, this.textHeight = s, this.lineLength = r, l) {
      this.heightSamples = {};
      for (let h = 0; h < a.length; h++) {
        let u = a[h];
        u < 0 ? h++ : this.heightSamples[Math.floor(u * 10)] = !0;
      }
    }
    return l;
  }
}, c(hd, "Cf"), hd);
f(iT, "HeightOracle");
let YD = iT;
var dd;
const nT = (dd = class {
  constructor(t, e) {
    this.from = t, this.heights = e, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}, c(dd, "Xf"), dd);
f(nT, "MeasuredHeights");
let GD = nT;
var Qo;
const sT = (Qo = class {
  /**
  @internal
  */
  constructor(t, e, i, s, r) {
    this.from = t, this.length = e, this.top = i, this.height = s, this._content = r;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? cn.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof gw ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(t) {
    let e = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(t._content) ? t._content : [t]);
    return new Qo(this.from, this.length + t.length, this.top, this.height + t.height, e);
  }
}, c(Qo, "eo"), Qo);
f(sT, "BlockInfo");
let As = sT;
var Yt = /* @__PURE__ */ (function(n) {
  return n[n.ByPos = 0] = "ByPos", n[n.ByHeight = 1] = "ByHeight", n[n.ByPosNoHeight = 2] = "ByPosNoHeight", n;
})(Yt || (Yt = {}));
const vv = 1e-3;
var qs;
const rT = (qs = class {
  constructor(t, e, i = 2) {
    this.length = t, this.height = e, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(t) {
    this.flags = (t ? 2 : 0) | this.flags & -3;
  }
  setHeight(t) {
    this.height != t && (Math.abs(this.height - t) > vv && (Yy = !0), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(t, e, i) {
    return qs.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(t, e) {
    e.push(this);
  }
  decomposeRight(t, e) {
    e.push(this);
  }
  applyChanges(t, e, i, s) {
    let r = this, a = i.doc;
    for (let o = s.length - 1; o >= 0; o--) {
      let { fromA: l, toA: h, fromB: u, toB: p } = s[o], y = r.lineAt(l, Yt.ByPosNoHeight, i.setDoc(e), 0, 0), m = y.to >= h ? y : r.lineAt(h, Yt.ByPosNoHeight, i, 0, 0);
      for (p += m.to - h, h = m.to; o > 0 && y.from <= s[o - 1].toA; )
        l = s[o - 1].fromA, u = s[o - 1].fromB, o--, l < y.from && (y = r.lineAt(l, Yt.ByPosNoHeight, i, 0, 0));
      u += y.from - l, l = y.from;
      let g = eq.build(i.setDoc(a), t, u, p);
      r = bw(r, r.replace(l, h, g));
    }
    return r.updateHeight(i, 0);
  }
  static empty() {
    return new Bn(0, 0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(t) {
    if (t.length == 1)
      return t[0];
    let e = 0, i = t.length, s = 0, r = 0;
    for (; ; )
      if (e == i)
        if (s > r * 2) {
          let o = t[e - 1];
          o.break ? t.splice(--e, 1, o.left, null, o.right) : t.splice(--e, 1, o.left, o.right), i += 1 + o.break, s -= o.size;
        } else if (r > s * 2) {
          let o = t[i];
          o.break ? t.splice(i, 1, o.left, null, o.right) : t.splice(i, 1, o.left, o.right), i += 2 + o.break, r -= o.size;
        } else
          break;
      else if (s < r) {
        let o = t[e++];
        o && (s += o.size);
      } else {
        let o = t[--i];
        o && (r += o.size);
      }
    let a = 0;
    return t[e - 1] == null ? (a = 1, e--) : t[e] == null && (a = 1, i++), new JD(qs.of(t.slice(0, e)), a, qs.of(t.slice(i)));
  }
}, c(qs, "gi"), qs);
f(rT, "HeightMap");
let Cn = rT;
function bw(n, t) {
  return n == t ? n : (n.constructor != t.constructor && (Yy = !0), t);
}
c(bw, "hs$2");
f(bw, "replace");
Cn.prototype.size = 1;
const KD = /* @__PURE__ */ Gt.replace({});
var ud;
const aT = (ud = class extends Cn {
  constructor(t, e, i) {
    super(t, e), this.deco = i, this.spaceAbove = 0;
  }
  mainBlock(t, e) {
    return new As(e, this.length, t + this.spaceAbove, this.height - this.spaceAbove, this.deco || 0);
  }
  blockAt(t, e, i, s) {
    return this.spaceAbove && t < i + this.spaceAbove ? new As(s, 0, i, this.spaceAbove, KD) : this.mainBlock(i, s);
  }
  lineAt(t, e, i, s, r) {
    let a = this.mainBlock(s, r);
    return this.spaceAbove ? this.blockAt(0, i, s, r).join(a) : a;
  }
  forEachLine(t, e, i, s, r, a) {
    t <= r + this.length && e >= r && a(this.lineAt(0, Yt.ByPos, i, s, r));
  }
  setMeasuredHeight(t) {
    let e = t.heights[t.index++];
    e < 0 ? (this.spaceAbove = -e, e = t.heights[t.index++]) : this.spaceAbove = 0, this.setHeight(e);
  }
  updateHeight(t, e = 0, i = !1, s) {
    return s && s.from <= e && s.more && this.setMeasuredHeight(s), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}, c(ud, "Ef"), ud);
f(aT, "HeightMapBlock");
let oT = aT;
var qr;
const lT = (qr = class extends oT {
  constructor(t, e, i) {
    super(t, e, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0, this.spaceAbove = i;
  }
  mainBlock(t, e) {
    return new As(e, this.length, t + this.spaceAbove, this.height - this.spaceAbove, this.breaks);
  }
  replace(t, e, i) {
    let s = i[0];
    return i.length == 1 && (s instanceof qr || s instanceof ph && s.flags & 4) && Math.abs(this.length - s.length) < 10 ? (s instanceof ph ? s = new qr(s.length, this.height, this.spaceAbove) : s.height = this.height, this.outdated || (s.outdated = !1), s) : Cn.of(i);
  }
  updateHeight(t, e = 0, i = !1, s) {
    return s && s.from <= e && s.more ? this.setMeasuredHeight(s) : (i || this.outdated) && (this.spaceAbove = 0, this.setHeight(Math.max(this.widgetHeight, t.heightForLine(this.length - this.collapsed)) + this.breaks * t.lineHeight)), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}, c(qr, "Cr"), qr);
f(lT, "HeightMapText");
let Bn = lT;
var li;
const cT = (li = class extends Cn {
  constructor(t) {
    super(t, 0);
  }
  heightMetrics(t, e) {
    let i = t.doc.lineAt(e).number, s = t.doc.lineAt(e + this.length).number, r = s - i + 1, a, o = 0;
    if (t.lineWrapping) {
      let l = Math.min(this.height, t.lineHeight * r);
      a = l / r, this.length > r + 1 && (o = (this.height - l) / (this.length - r - 1));
    } else
      a = this.height / r;
    return { firstLine: i, lastLine: s, perLine: a, perChar: o };
  }
  blockAt(t, e, i, s) {
    let { firstLine: r, lastLine: a, perLine: o, perChar: l } = this.heightMetrics(e, s);
    if (e.lineWrapping) {
      let h = s + (t < e.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (t - i) / this.height)) * this.length)), u = e.doc.lineAt(h), p = o + u.length * l, y = Math.max(i, t - p / 2);
      return new As(u.from, u.length, y, p, 0);
    } else {
      let h = Math.max(0, Math.min(a - r, Math.floor((t - i) / o))), { from: u, length: p } = e.doc.line(r + h);
      return new As(u, p, i + o * h, o, 0);
    }
  }
  lineAt(t, e, i, s, r) {
    if (e == Yt.ByHeight)
      return this.blockAt(t, i, s, r);
    if (e == Yt.ByPosNoHeight) {
      let { from: m, to: g } = i.doc.lineAt(t);
      return new As(m, g - m, 0, 0, 0);
    }
    let { firstLine: a, perLine: o, perChar: l } = this.heightMetrics(i, r), h = i.doc.lineAt(t), u = o + h.length * l, p = h.number - a, y = s + o * p + l * (h.from - r - p);
    return new As(h.from, h.length, Math.max(s, Math.min(y, s + this.height - u)), u, 0);
  }
  forEachLine(t, e, i, s, r, a) {
    t = Math.max(t, r), e = Math.min(e, r + this.length);
    let { firstLine: o, perLine: l, perChar: h } = this.heightMetrics(i, r);
    for (let u = t, p = s; u <= e; ) {
      let y = i.doc.lineAt(u);
      if (u == t) {
        let g = y.number - o;
        p += l * g + h * (t - r - g);
      }
      let m = l + h * y.length;
      a(new As(y.from, y.length, p, m, 0)), p += m, u = y.to + 1;
    }
  }
  replace(t, e, i) {
    let s = this.length - e;
    if (s > 0) {
      let r = i[i.length - 1];
      r instanceof li ? i[i.length - 1] = new li(r.length + s) : i.push(null, new li(s - 1));
    }
    if (t > 0) {
      let r = i[0];
      r instanceof li ? i[0] = new li(t + r.length) : i.unshift(new li(t - 1), null);
    }
    return Cn.of(i);
  }
  decomposeLeft(t, e) {
    e.push(new li(t - 1), null);
  }
  decomposeRight(t, e) {
    e.push(null, new li(this.length - t - 1));
  }
  updateHeight(t, e = 0, i = !1, s) {
    let r = e + this.length;
    if (s && s.from <= e + this.length && s.more) {
      let a = [], o = Math.max(e, s.from), l = -1;
      for (s.from > e && a.push(new li(s.from - e - 1).updateHeight(t, e)); o <= r && s.more; ) {
        let u = t.doc.lineAt(o).length;
        a.length && a.push(null);
        let p = s.heights[s.index++], y = 0;
        p < 0 && (y = -p, p = s.heights[s.index++]), l == -1 ? l = p : Math.abs(p - l) >= vv && (l = -2);
        let m = new Bn(u, p, y);
        m.outdated = !1, a.push(m), o += u + 1;
      }
      o <= r && a.push(null, new li(r - o).updateHeight(t, o));
      let h = Cn.of(a);
      return (l < 0 || Math.abs(h.height - this.height) >= vv || Math.abs(l - this.heightMetrics(t, e).perLine) >= vv) && (Yy = !0), bw(this, h);
    } else (i || this.outdated) && (this.setHeight(t.heightForGap(e, e + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}, c(li, "ke"), li);
f(cT, "HeightMapGap");
let ph = cT;
var pd;
const hT = (pd = class extends Cn {
  constructor(t, e, i) {
    super(t.length + e + i.length, t.height + i.height, e | (t.outdated || i.outdated ? 2 : 0)), this.left = t, this.right = i, this.size = t.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(t, e, i, s) {
    let r = i + this.left.height;
    return t < r ? this.left.blockAt(t, e, i, s) : this.right.blockAt(t, e, r, s + this.left.length + this.break);
  }
  lineAt(t, e, i, s, r) {
    let a = s + this.left.height, o = r + this.left.length + this.break, l = e == Yt.ByHeight ? t < a : t < o, h = l ? this.left.lineAt(t, e, i, s, r) : this.right.lineAt(t, e, i, a, o);
    if (this.break || (l ? h.to < o : h.from > o))
      return h;
    let u = e == Yt.ByPosNoHeight ? Yt.ByPosNoHeight : Yt.ByPos;
    return l ? h.join(this.right.lineAt(o, u, i, a, o)) : this.left.lineAt(o, u, i, s, r).join(h);
  }
  forEachLine(t, e, i, s, r, a) {
    let o = s + this.left.height, l = r + this.left.length + this.break;
    if (this.break)
      t < l && this.left.forEachLine(t, e, i, s, r, a), e >= l && this.right.forEachLine(t, e, i, o, l, a);
    else {
      let h = this.lineAt(l, Yt.ByPos, i, s, r);
      t < h.from && this.left.forEachLine(t, h.from - 1, i, s, r, a), h.to >= t && h.from <= e && a(h), e > h.to && this.right.forEachLine(h.to + 1, e, i, o, l, a);
    }
  }
  replace(t, e, i) {
    let s = this.left.length + this.break;
    if (e < s)
      return this.balanced(this.left.replace(t, e, i), this.right);
    if (t > this.left.length)
      return this.balanced(this.left, this.right.replace(t - s, e - s, i));
    let r = [];
    t > 0 && this.decomposeLeft(t, r);
    let a = r.length;
    for (let o of i)
      r.push(o);
    if (t > 0 && Fk(r, a - 1), e < this.length) {
      let o = r.length;
      this.decomposeRight(e, r), Fk(r, o);
    }
    return Cn.of(r);
  }
  decomposeLeft(t, e) {
    let i = this.left.length;
    if (t <= i)
      return this.left.decomposeLeft(t, e);
    e.push(this.left), this.break && (i++, t >= i && e.push(null)), t > i && this.right.decomposeLeft(t - i, e);
  }
  decomposeRight(t, e) {
    let i = this.left.length, s = i + this.break;
    if (t >= s)
      return this.right.decomposeRight(t - s, e);
    t < i && this.left.decomposeRight(t, e), this.break && t < s && e.push(null), e.push(this.right);
  }
  balanced(t, e) {
    return t.size > 2 * e.size || e.size > 2 * t.size ? Cn.of(this.break ? [t, null, e] : [t, e]) : (this.left = bw(this.left, t), this.right = bw(this.right, e), this.setHeight(t.height + e.height), this.outdated = t.outdated || e.outdated, this.size = t.size + e.size, this.length = t.length + this.break + e.length, this);
  }
  updateHeight(t, e = 0, i = !1, s) {
    let { left: r, right: a } = this, o = e + r.length + this.break, l = null;
    return s && s.from <= e + r.length && s.more ? l = r = r.updateHeight(t, e, i, s) : r.updateHeight(t, e, i), s && s.from <= o + a.length && s.more ? l = a = a.updateHeight(t, o, i, s) : a.updateHeight(t, o, i), l ? this.balanced(r, a) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}, c(pd, "Yf"), pd);
f(hT, "HeightMapBranch");
let JD = hT;
function Fk(n, t) {
  let e, i;
  n[t] == null && (e = n[t - 1]) instanceof ph && (i = n[t + 1]) instanceof ph && n.splice(t - 1, 3, new ph(e.length + 1 + i.length));
}
c(Fk, "Tu");
f(Fk, "mergeGaps");
const tq = 5;
var To;
const dT = (To = class {
  constructor(t, e) {
    this.pos = t, this.oracle = e, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(t, e) {
    if (this.lineStart > -1) {
      let i = Math.min(e, this.lineEnd), s = this.nodes[this.nodes.length - 1];
      s instanceof Bn ? s.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new Bn(i - this.pos, -1, 0)), this.writtenTo = i, e > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = e;
  }
  point(t, e, i) {
    if (t < e || i.heightRelevant) {
      let s = i.widget ? i.widget.estimatedHeight : 0, r = i.widget ? i.widget.lineBreaks : 0;
      s < 0 && (s = this.oracle.lineHeight);
      let a = e - t;
      i.block ? this.addBlock(new oT(a, s, i)) : (a || r || s >= tq) && this.addLineDeco(s, r, a);
    } else e > t && this.span(t, e);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: t, to: e } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = t, this.lineEnd = e, this.writtenTo < t && ((this.writtenTo < t - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, t - 1)), this.nodes.push(null)), this.pos > t && this.nodes.push(new Bn(this.pos - t, -1, 0)), this.writtenTo = this.pos;
  }
  blankContent(t, e) {
    let i = new ph(e - t);
    return this.oracle.doc.lineAt(t).to == e && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let t = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (t instanceof Bn)
      return t;
    let e = new Bn(0, -1, 0);
    return this.nodes.push(e), e;
  }
  addBlock(t) {
    this.enterLine();
    let e = t.deco;
    e && e.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(t), this.writtenTo = this.pos = this.pos + t.length, e && e.endSide > 0 && (this.covering = t);
  }
  addLineDeco(t, e, i) {
    let s = this.ensureLine();
    s.length += i, s.collapsed += i, s.widgetHeight = Math.max(s.widgetHeight, t), s.breaks += e, this.writtenTo = this.pos = this.pos + i;
  }
  finish(t) {
    let e = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(e instanceof Bn) && !this.isCovered ? this.nodes.push(new Bn(0, -1, 0)) : (this.writtenTo < this.pos || e == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = t;
    for (let s of this.nodes)
      s instanceof Bn && s.updateHeight(this.oracle, i), i += s ? s.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(t, e, i, s) {
    let r = new To(i, t);
    return Qe.spans(e, i, s, r, 0), r.finish(i);
  }
}, c(To, "to"), To);
f(dT, "NodeBuilder");
let eq = dT;
function uT(n, t, e) {
  let i = new iq();
  return Qe.compare(n, t, e, i, 0), i.changes;
}
c(uT, "O1$1");
f(uT, "heightRelevantDecoChanges");
var fd;
const pT = (fd = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(t, e, i, s) {
    (t < e || i && i.heightRelevant || s && s.heightRelevant) && eo(t, e, this.changes, 5);
  }
}, c(fd, "Wf"), fd);
f(pT, "DecorationComparator");
let iq = pT;
function fT(n, t) {
  let e = n.getBoundingClientRect(), i = n.ownerDocument, s = i.defaultView || window, r = Math.max(0, e.left), a = Math.min(s.innerWidth, e.right), o = Math.max(0, e.top), l = Math.min(s.innerHeight, e.bottom);
  for (let h = n.parentNode; h && h != i.body; )
    if (h.nodeType == 1) {
      let u = h, p = window.getComputedStyle(u);
      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && p.overflow != "visible") {
        let y = u.getBoundingClientRect();
        r = Math.max(r, y.left), a = Math.min(a, y.right), o = Math.max(o, y.top), l = Math.min(h == n.parentNode ? s.innerHeight : l, y.bottom);
      }
      h = p.position == "absolute" || p.position == "fixed" ? u.offsetParent : u.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
  return {
    left: r - e.left,
    right: Math.max(r, a) - e.left,
    top: o - (e.top + t),
    bottom: Math.max(o, l) - (e.top + t)
  };
}
c(fT, "d1$1");
f(fT, "visiblePixelRange");
function yT(n) {
  let t = n.getBoundingClientRect(), e = n.ownerDocument.defaultView || window;
  return t.left < e.innerWidth && t.right > 0 && t.top < e.innerHeight && t.bottom > 0;
}
c(yT, "p1$1");
f(yT, "inWindow");
function mT(n, t) {
  let e = n.getBoundingClientRect();
  return {
    left: 0,
    right: e.right - e.left,
    top: t,
    bottom: e.bottom - (e.top + t)
  };
}
c(mT, "m1$1");
f(mT, "fullPixelRange");
var yd;
const gT = (yd = class {
  constructor(t, e, i, s) {
    this.from = t, this.to = e, this.size = i, this.displaySize = s;
  }
  static same(t, e) {
    if (t.length != e.length)
      return !1;
    for (let i = 0; i < t.length; i++) {
      let s = t[i], r = e[i];
      if (s.from != r.from || s.to != r.to || s.size != r.size)
        return !1;
    }
    return !0;
  }
  draw(t, e) {
    return Gt.replace({
      widget: new nq(this.displaySize * (e ? t.scaleY : t.scaleX), e)
    }).range(this.from, this.to);
  }
}, c(yd, "Vf"), yd);
f(gT, "LineGap");
let r2 = gT;
var md;
const wT = (md = class extends Pl {
  constructor(t, e) {
    super(), this.size = t, this.vertical = e;
  }
  eq(t) {
    return t.size == this.size && t.vertical == this.vertical;
  }
  toDOM() {
    let t = document.createElement("div");
    return this.vertical ? t.style.height = this.size + "px" : (t.style.width = this.size + "px", t.style.height = "2px", t.style.display = "inline-block"), t;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}, c(md, "Uf"), md);
f(wT, "LineGapWidget");
let nq = wT;
var gd;
const vT = (gd = class {
  constructor(t) {
    this.state = t, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = Y3, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = le.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let e = t.facet(eC).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new YD(e), this.stateDeco = Xk(t), this.heightMap = Cn.empty().applyChanges(this.stateDeco, Ft.empty, this.heightOracle.setDoc(t.doc), [new Ls(0, 0, 0, t.doc.length)]);
    for (let i = 0; i < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); i++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = Gt.set(this.lineGaps.map((i) => i.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let t = [this.viewport], { main: e } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let s = i ? e.head : e.anchor;
      if (!t.some(({ from: r, to: a }) => s >= r && s <= a)) {
        let { from: r, to: a } = this.lineBlockAt(s);
        t.push(new N1(r, a));
      }
    }
    return this.viewports = t.sort((i, s) => i.from - s.from), this.updateScaler();
  }
  updateScaler() {
    let t = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? Y3 : new sq(this.heightOracle, this.heightMap, this.viewports), t.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (t) => {
      this.viewportLines.push(sh(t, this.scaler));
    });
  }
  update(t, e = null) {
    this.state = t.state;
    let i = this.stateDeco;
    this.stateDeco = Xk(this.state);
    let s = t.changedRanges, r = Ls.extendWithRanges(s, uT(i, this.stateDeco, t ? t.changes : Tn.empty(this.state.doc.length))), a = this.heightMap.height, o = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    Zk(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, t.startState.doc, this.heightOracle.setDoc(this.state.doc), r), (this.heightMap.height != a || Yy) && (t.flags |= 2), o ? (this.scrollAnchorPos = t.changes.mapPos(o.from, -1), this.scrollAnchorHeight = o.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = a);
    let l = r.length ? this.mapViewport(this.viewport, t.changes) : this.viewport;
    (e && (e.range.head < l.from || e.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, e));
    let h = l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, t.flags |= this.updateForViewport(), (h || !t.changes.empty || t.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t.changes))), t.flags |= this.computeVisibleRanges(t.changes), e && (this.scrollTarget = e), !this.mustEnforceCursorAssoc && (t.selectionSet || t.focusChanged) && t.view.lineWrapping && t.state.selection.main.empty && t.state.selection.main.assoc && !t.state.facet(ED) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(t) {
    let e = t.contentDOM, i = window.getComputedStyle(e), s = this.heightOracle, r = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? le.RTL : le.LTR;
    let a = this.heightOracle.mustRefreshForWrapping(r) || this.mustMeasureContent, o = e.getBoundingClientRect(), l = a || this.mustMeasureContent || this.contentDOMHeight != o.height;
    this.contentDOMHeight = o.height, this.mustMeasureContent = !1;
    let h = 0, u = 0;
    if (o.width && o.height) {
      let { scaleX: W, scaleY: R } = FS(e, o);
      (W > 5e-3 && Math.abs(this.scaleX - W) > 5e-3 || R > 5e-3 && Math.abs(this.scaleY - R) > 5e-3) && (this.scaleX = W, this.scaleY = R, h |= 16, a = l = !0);
    }
    let p = (parseInt(i.paddingTop) || 0) * this.scaleY, y = (parseInt(i.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != p || this.paddingBottom != y) && (this.paddingTop = p, this.paddingBottom = y, h |= 18), this.editorWidth != t.scrollDOM.clientWidth && (s.lineWrapping && (l = !0), this.editorWidth = t.scrollDOM.clientWidth, h |= 16);
    let m = t.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != m && (this.scrollAnchorHeight = -1, this.scrollTop = m), this.scrolledToBottom = NS(t.scrollDOM);
    let g = (this.printing ? mT : fT)(e, this.paddingTop), b = g.top - this.pixelViewport.top, S = g.bottom - this.pixelViewport.bottom;
    this.pixelViewport = g;
    let x = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (x != this.inView && (this.inView = x, x && (l = !0)), !this.inView && !this.scrollTarget && !yT(t.dom))
      return 0;
    let Q = o.width;
    if ((this.contentDOMWidth != Q || this.editorHeight != t.scrollDOM.clientHeight) && (this.contentDOMWidth = o.width, this.editorHeight = t.scrollDOM.clientHeight, h |= 16), l) {
      let W = t.docView.measureVisibleLineHeights(this.viewport);
      if (s.mustRefreshForHeights(W) && (a = !0), a || s.lineWrapping && Math.abs(Q - this.contentDOMWidth) > s.charWidth) {
        let { lineHeight: R, charWidth: I, textHeight: V } = t.docView.measureTextSize();
        a = R > 0 && s.refresh(r, R, I, V, Math.max(5, Q / I), W), a && (t.docView.minWidth = 0, h |= 16);
      }
      b > 0 && S > 0 ? u = Math.max(b, S) : b < 0 && S < 0 && (u = Math.min(b, S)), Zk();
      for (let R of this.viewports) {
        let I = R.from == this.viewport.from ? W : t.docView.measureVisibleLineHeights(R);
        this.heightMap = (a ? Cn.empty().applyChanges(this.stateDeco, Ft.empty, this.heightOracle, [new Ls(0, 0, 0, t.state.doc.length)]) : this.heightMap).updateHeight(s, 0, a, new GD(R.from, I));
      }
      Yy && (h |= 2);
    }
    let L = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return L && (h & 2 && (h |= this.updateScaler()), this.viewport = this.getViewport(u, this.scrollTarget), h |= this.updateForViewport()), (h & 2 || L) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(a ? [] : this.lineGaps, t)), h |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, t.docView.enforceCursorAssoc()), h;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(t, e) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, t / 1e3 / 2)), s = this.heightMap, r = this.heightOracle, { visibleTop: a, visibleBottom: o } = this, l = new N1(s.lineAt(a - i * 1e3, Yt.ByHeight, r, 0, 0).from, s.lineAt(o + (1 - i) * 1e3, Yt.ByHeight, r, 0, 0).to);
    if (e) {
      let { head: h } = e.range;
      if (h < l.from || h > l.to) {
        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), p = s.lineAt(h, Yt.ByPos, r, 0, 0), y;
        e.y == "center" ? y = (p.top + p.bottom) / 2 - u / 2 : e.y == "start" || e.y == "nearest" && h < l.from ? y = p.top : y = p.bottom - u, l = new N1(s.lineAt(y - 1e3 / 2, Yt.ByHeight, r, 0, 0).from, s.lineAt(y + u + 1e3 / 2, Yt.ByHeight, r, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(t, e) {
    let i = e.mapPos(t.from, -1), s = e.mapPos(t.to, 1);
    return new N1(this.heightMap.lineAt(i, Yt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(s, Yt.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: t, to: e }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: s } = this.heightMap.lineAt(t, Yt.ByPos, this.heightOracle, 0, 0), { bottom: r } = this.heightMap.lineAt(e, Yt.ByPos, this.heightOracle, 0, 0), { visibleTop: a, visibleBottom: o } = this;
    return (t == 0 || s <= a - Math.max(10, Math.min(
      -i,
      250
      /* VP.MaxCoverMargin */
    ))) && (e == this.state.doc.length || r >= o + Math.max(10, Math.min(
      i,
      250
      /* VP.MaxCoverMargin */
    ))) && s > a - 2 * 1e3 && r < o + 2 * 1e3;
  }
  mapLineGaps(t, e) {
    if (!t.length || e.empty)
      return t;
    let i = [];
    for (let s of t)
      e.touchesRange(s.from, s.to) || i.push(new r2(e.mapPos(s.from), e.mapPos(s.to), s.size, s.displaySize));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(t, e) {
    let i = this.heightOracle.lineWrapping, s = i ? 1e4 : 2e3, r = s >> 1, a = s << 1;
    if (this.defaultTextDirection != le.LTR && !i)
      return [];
    let o = [], l = /* @__PURE__ */ f((u, p, y, m) => {
      if (p - u < r)
        return;
      let g = this.state.selection.main, b = [g.from];
      g.empty || b.push(g.to);
      for (let x of b)
        if (x > u && x < p) {
          l(u, x - 10, y, m), l(x + 10, p, y, m);
          return;
        }
      let S = $T(t, (x) => x.from >= y.from && x.to <= y.to && Math.abs(x.from - u) < r && Math.abs(x.to - p) < r && !b.some((Q) => x.from < Q && x.to > Q));
      if (!S) {
        if (p < y.to && e && i && e.visibleRanges.some((L) => L.from <= p && L.to >= p)) {
          let L = e.moveToLineBoundary(it.cursor(p), !1, !0).head;
          L > u && (p = L);
        }
        let x = this.gapSize(y, u, p, m), Q = i || x < 2e6 ? x : 2e6;
        S = new r2(u, p, x, Q);
      }
      o.push(S);
    }, "addGap"), h = /* @__PURE__ */ f((u) => {
      if (u.length < a || u.type != cn.Text)
        return;
      let p = bT(u.from, u.to, this.stateDeco);
      if (p.total < a)
        return;
      let y = this.scrollTarget ? this.scrollTarget.range.head : null, m, g;
      if (i) {
        let b = s / this.heightOracle.lineLength * this.heightOracle.lineHeight, S, x;
        if (y != null) {
          let Q = bg(p, y), L = ((this.visibleBottom - this.visibleTop) / 2 + b) / u.height;
          S = Q - L, x = Q + L;
        } else
          S = (this.visibleTop - u.top - b) / u.height, x = (this.visibleBottom - u.top + b) / u.height;
        m = Og(p, S), g = Og(p, x);
      } else {
        let b = p.total * this.heightOracle.charWidth, S = s * this.heightOracle.charWidth, x = 0;
        if (b > 2e6)
          for (let I of t)
            I.from >= u.from && I.from < u.to && I.size != I.displaySize && I.from * this.heightOracle.charWidth + x < this.pixelViewport.left && (x = I.size - I.displaySize);
        let Q = this.pixelViewport.left + x, L = this.pixelViewport.right + x, W, R;
        if (y != null) {
          let I = bg(p, y), V = ((L - Q) / 2 + S) / b;
          W = I - V, R = I + V;
        } else
          W = (Q - S) / b, R = (L + S) / b;
        m = Og(p, W), g = Og(p, R);
      }
      m > u.from && l(u.from, m, u, p), g < u.to && l(g, u.to, u, p);
    }, "checkLine");
    for (let u of this.viewportLines)
      Array.isArray(u.type) ? u.type.forEach(h) : h(u);
    return o;
  }
  gapSize(t, e, i, s) {
    let r = bg(s, i) - bg(s, e);
    return this.heightOracle.lineWrapping ? t.height * r : s.total * this.heightOracle.charWidth * r;
  }
  updateLineGaps(t) {
    r2.same(t, this.lineGaps) || (this.lineGaps = t, this.lineGapDeco = Gt.set(t.map((e) => e.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(t) {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let i = [];
    Qe.spans(e, this.viewport.from, this.viewport.to, {
      span(r, a) {
        i.push({ from: r, to: a });
      },
      point() {
      }
    }, 20);
    let s = 0;
    if (i.length != this.visibleRanges.length)
      s = 12;
    else
      for (let r = 0; r < i.length && !(s & 8); r++) {
        let a = this.visibleRanges[r], o = i[r];
        (a.from != o.from || a.to != o.to) && (s |= 4, t && t.mapPos(a.from, -1) == o.from && t.mapPos(a.to, 1) == o.to || (s |= 8));
      }
    return this.visibleRanges = i, s;
  }
  lineBlockAt(t) {
    return t >= this.viewport.from && t <= this.viewport.to && this.viewportLines.find((e) => e.from <= t && e.to >= t) || sh(this.heightMap.lineAt(t, Yt.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(t) {
    return t >= this.viewportLines[0].top && t <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((e) => e.top <= t && e.bottom >= t) || sh(this.heightMap.lineAt(this.scaler.fromDOM(t), Yt.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(t) {
    let e = this.lineBlockAtHeight(t + 8);
    return e.from >= this.viewport.from || this.viewportLines[0].top - t > 200 ? e : this.viewportLines[0];
  }
  elementAtHeight(t) {
    return sh(this.heightMap.blockAt(this.scaler.fromDOM(t), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}, c(gd, "If"), gd);
f(vT, "ViewState");
let H3 = vT;
var wd;
const OT = (wd = class {
  constructor(t, e) {
    this.from = t, this.to = e;
  }
}, c(wd, "zf"), wd);
f(OT, "Viewport");
let N1 = OT;
function bT(n, t, e) {
  let i = [], s = n, r = 0;
  return Qe.spans(e, n, t, {
    span() {
    },
    point(a, o) {
      a > s && (i.push({ from: s, to: a }), r += a - s), s = o;
    }
  }, 20), s < t && (i.push({ from: s, to: t }), r += t - s), { total: r, ranges: i };
}
c(bT, "g1$1");
f(bT, "lineStructure");
function Og({ total: n, ranges: t }, e) {
  if (e <= 0)
    return t[0].from;
  if (e >= 1)
    return t[t.length - 1].to;
  let i = Math.floor(n * e);
  for (let s = 0; ; s++) {
    let { from: r, to: a } = t[s], o = a - r;
    if (i <= o)
      return r + i;
    i -= o;
  }
}
c(Og, "Ln$1");
f(Og, "findPosition");
function bg(n, t) {
  let e = 0;
  for (let { from: i, to: s } of n.ranges) {
    if (t <= s) {
      e += t - i;
      break;
    }
    e += s - i;
  }
  return e / n.total;
}
c(bg, "_n$1");
f(bg, "findFraction");
function $T(n, t) {
  for (let e of n)
    if (t(e))
      return e;
}
c($T, "Q1$1");
f($T, "find");
const Y3 = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1,
  eq(n) {
    return n == this;
  }
};
function Xk(n) {
  let t = n.facet(_b).filter((i) => typeof i != "function"), e = n.facet(iC).filter((i) => typeof i != "function");
  return e.length && t.push(Qe.join(e)), t;
}
c(Xk, "Lu$1");
f(Xk, "staticDeco");
var Mo;
const xT = (Mo = class {
  constructor(t, e, i) {
    let s = 0, r = 0, a = 0;
    this.viewports = i.map(({ from: o, to: l }) => {
      let h = e.lineAt(o, Yt.ByPos, t, 0, 0).top, u = e.lineAt(l, Yt.ByPos, t, 0, 0).bottom;
      return s += u - h, { from: o, to: l, top: h, bottom: u, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - s) / (e.height - s);
    for (let o of this.viewports)
      o.domTop = a + (o.top - r) * this.scale, a = o.domBottom = o.domTop + (o.bottom - o.top), r = o.bottom;
  }
  toDOM(t) {
    for (let e = 0, i = 0, s = 0; ; e++) {
      let r = e < this.viewports.length ? this.viewports[e] : null;
      if (!r || t < r.top)
        return s + (t - i) * this.scale;
      if (t <= r.bottom)
        return r.domTop + (t - r.top);
      i = r.bottom, s = r.domBottom;
    }
  }
  fromDOM(t) {
    for (let e = 0, i = 0, s = 0; ; e++) {
      let r = e < this.viewports.length ? this.viewports[e] : null;
      if (!r || t < r.domTop)
        return i + (t - s) / this.scale;
      if (t <= r.domBottom)
        return r.top + (t - r.domTop);
      i = r.bottom, s = r.domBottom;
    }
  }
  eq(t) {
    return t instanceof Mo ? this.scale == t.scale && this.viewports.length == t.viewports.length && this.viewports.every((e, i) => e.from == t.viewports[i].from && e.to == t.viewports[i].to) : !1;
  }
}, c(Mo, "io"), Mo);
f(xT, "BigScaler");
let sq = xT;
function sh(n, t) {
  if (t.scale == 1)
    return n;
  let e = t.toDOM(n.top), i = t.toDOM(n.bottom);
  return new As(n.from, n.length, e, i - e, Array.isArray(n._content) ? n._content.map((s) => sh(s, t)) : n._content);
}
c(sh, "Or$1");
f(sh, "scaleBlock");
const j1 = /* @__PURE__ */ bt.define({ combine: /* @__PURE__ */ f((n) => n.join(" "), "combine") }), Nk = /* @__PURE__ */ bt.define({ combine: /* @__PURE__ */ f((n) => n.indexOf(!0) > -1, "combine") }), jk = /* @__PURE__ */ ia.newName(), kT = /* @__PURE__ */ ia.newName(), ST = /* @__PURE__ */ ia.newName(), CT = { "&light": "." + kT, "&dark": "." + ST };
function xO(n, t, e) {
  return new ia(t, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (s) => {
        if (s == "&")
          return n;
        if (!e || !e[s])
          throw new RangeError(`Unsupported selector: ${s}`);
        return e[s];
      }) : n + " " + i;
    }
  });
}
c(xO, "ta$1");
f(xO, "buildTheme");
const rq = /* @__PURE__ */ xO("." + jk, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    zIndex: 200
  },
  ".cm-gutters-before": { insetInlineStart: 0 },
  ".cm-gutters-after": { insetInlineEnd: 0 },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    border: "0px solid #ddd",
    "&.cm-gutters-before": { borderRightWidth: "1px" },
    "&.cm-gutters-after": { borderLeftWidth: "1px" }
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, CT), aq = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, a2 = nt.ie && nt.ie_version <= 11;
var vd;
const PT = (vd = class {
  constructor(t) {
    this.view = t, this.active = !1, this.editContext = null, this.selectionRange = new TD(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = t.contentDOM, this.observer = new MutationObserver((e) => {
      for (let i of e)
        this.queue.push(i);
      (nt.ie && nt.ie_version <= 11 || nt.ios && t.composing) && e.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && nt.android && t.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(nt.chrome && nt.chrome_version < 126) && (this.editContext = new lq(t), t.state.facet(Ms) && (t.contentDOM.editContext = this.editContext.editContext)), a2 && (this.onCharData = (e) => {
      this.queue.push({
        target: e.target,
        type: "characterData",
        oldValue: e.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var e;
      ((e = this.view.docView) === null || e === void 0 ? void 0 : e.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(t.scrollDOM)), this.addWindowListeners(this.win = t.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((e) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), e.length > 0 && e[e.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((e) => {
      e.length > 0 && e[e.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(t) {
    this.view.inputState.runHandlers("scroll", t), this.intersecting && this.view.measure();
  }
  onScroll(t) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(t);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(t) {
    (t.type == "change" || !t.type) && !t.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(t) {
    if (this.gapIntersection && (t.length != this.gaps.length || this.gaps.some((e, i) => e != t[i]))) {
      this.gapIntersection.disconnect();
      for (let e of t)
        this.gapIntersection.observe(e);
      this.gaps = t;
    }
  }
  onSelectionChange(t) {
    let e = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, s = this.selectionRange;
    if (i.state.facet(Ms) ? i.root.activeElement != this.dom : !lh(this.dom, s))
      return;
    let r = s.anchorNode && i.docView.tile.nearest(s.anchorNode);
    if (r && r.isWidget() && r.widget.ignoreEvent(t)) {
      e || (this.selectionChanged = !1);
      return;
    }
    (nt.ie && nt.ie_version <= 11 || nt.android && nt.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    s.focusNode && hh(s.focusNode, s.focusOffset, s.anchorNode, s.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: t } = this, e = Ko(t.root);
    if (!e)
      return !1;
    let i = nt.safari && t.root.nodeType == 11 && t.root.activeElement == this.dom && QT(this.view, e) || e;
    if (!i || this.selectionRange.eq(i))
      return !1;
    let s = lh(this.dom, i);
    return s && !this.selectionChanged && t.inputState.lastFocusTime > Date.now() - 200 && t.inputState.lastTouchTime < Date.now() - 300 && g7(this.dom, i) ? (this.view.inputState.lastFocusTime = 0, t.docView.updateSelection(), !1) : (this.selectionRange.setRange(i), s && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(t, e) {
    this.selectionRange.set(t.node, t.offset, e.node, e.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let t = 0, e = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !e && t < this.scrollTargets.length && this.scrollTargets[t] == i ? t++ : e || (e = this.scrollTargets.slice(0, t)), e && e.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (t < this.scrollTargets.length && !e && (e = this.scrollTargets.slice(0, t)), e) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = e)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(t) {
    if (!this.active)
      return t();
    try {
      return this.stop(), t();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, aq), a2 && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), a2 && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(t, e) {
    var i;
    if (!this.delayedAndroidKey) {
      let s = /* @__PURE__ */ f(() => {
        let r = this.delayedAndroidKey;
        r && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = r.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && r.force && io(this.dom, r.key, r.keyCode));
      }, "flush");
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(s);
    }
    (!this.delayedAndroidKey || t == "Enter") && (this.delayedAndroidKey = {
      key: t,
      keyCode: e,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let t of this.observer.takeRecords())
      this.queue.push(t);
    return this.queue;
  }
  processRecords() {
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let e = -1, i = -1, s = !1;
    for (let r of t) {
      let a = this.readMutation(r);
      a && (a.typeOver && (s = !0), e == -1 ? { from: e, to: i } = a : (e = Math.min(a.from, e), i = Math.max(a.to, i)));
    }
    return { from: e, to: i, typeOver: s };
  }
  readChange() {
    let { from: t, to: e, typeOver: i } = this.processRecords(), s = this.selectionChanged && lh(this.dom, this.selectionRange);
    if (t < 0 && !s)
      return null;
    t > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let r = new ND(this.view, t, e, i);
    return this.view.docView.domChanged = { newSel: r.newSel ? r.newSel.main : null }, r;
  }
  // Apply pending changes, if any
  flush(t = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    t && this.readSelectionRange();
    let e = this.readChange();
    if (!e)
      return this.view.requestMeasure(), !1;
    let i = this.view.state, s = oC(this.view, e);
    return this.view.state == i && (e.domChanged || e.newSel && !Ow(this.view.state.selection, e.newSel.main)) && this.view.update([]), s;
  }
  readMutation(t) {
    let e = this.view.docView.tile.nearest(t.target);
    if (!e || e.isWidget())
      return null;
    if (e.markDirty(t.type == "attributes"), t.type == "childList") {
      let i = Bk(e, t.previousSibling || t.target.previousSibling, -1), s = Bk(e, t.nextSibling || t.target.nextSibling, 1);
      return {
        from: i ? e.posAfter(i) : e.posAtStart,
        to: s ? e.posBefore(s) : e.posAtEnd,
        typeOver: !1
      };
    } else return t.type == "characterData" ? { from: e.posAtStart, to: e.posAtEnd, typeOver: t.target.nodeValue == t.oldValue } : null;
  }
  setWindow(t) {
    t != this.win && (this.removeWindowListeners(this.win), this.win = t, this.addWindowListeners(this.win));
  }
  addWindowListeners(t) {
    t.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : t.addEventListener("beforeprint", this.onPrint), t.addEventListener("scroll", this.onScroll), t.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(t) {
    t.removeEventListener("scroll", this.onScroll), t.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : t.removeEventListener("beforeprint", this.onPrint), t.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(t) {
    this.editContext && (this.editContext.update(t), t.startState.facet(Ms) != t.state.facet(Ms) && (t.view.contentDOM.editContext = t.state.facet(Ms) ? this.editContext.editContext : null));
  }
  destroy() {
    var t, e, i;
    this.stop(), (t = this.intersection) === null || t === void 0 || t.disconnect(), (e = this.gapIntersection) === null || e === void 0 || e.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect();
    for (let s of this.scrollTargets)
      s.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}, c(vd, "jf"), vd);
f(PT, "DOMObserver");
let oq = PT;
function Bk(n, t, e) {
  for (; t; ) {
    let i = Pe.get(t);
    if (i && i.parent == n)
      return i;
    let s = t.parentNode;
    t = s != n.dom ? s : e > 0 ? t.nextSibling : t.previousSibling;
  }
  return null;
}
c(Bk, "_u$1");
f(Bk, "findChild");
function Uk(n, t) {
  let e = t.startContainer, i = t.startOffset, s = t.endContainer, r = t.endOffset, a = n.docView.domAtPos(n.state.selection.main.anchor, 1);
  return hh(a.node, a.offset, s, r) && ([e, i, s, r] = [s, r, e, i]), { anchorNode: e, anchorOffset: i, focusNode: s, focusOffset: r };
}
c(Uk, "Mu$1");
f(Uk, "buildSelectionRangeFromRange");
function QT(n, t) {
  if (t.getComposedRanges) {
    let s = t.getComposedRanges(n.root)[0];
    if (s)
      return Uk(n, s);
  }
  let e = null;
  function i(s) {
    s.preventDefault(), s.stopImmediatePropagation(), e = s.getTargetRanges()[0];
  }
  return c(i, "i"), f(i, "read"), n.contentDOM.addEventListener("beforeinput", i, !0), n.dom.ownerDocument.execCommand("indent"), n.contentDOM.removeEventListener("beforeinput", i, !0), e ? Uk(n, e) : null;
}
c(QT, "b1$1");
f(QT, "safariSelectionRangeHack");
var Od;
const TT = (Od = class {
  constructor(t) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(t.state);
    let e = this.editContext = new window.EditContext({
      text: t.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, t.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(t.state.selection.main.head)
    });
    this.handlers.textupdate = (i) => {
      let s = t.state.selection.main, { anchor: r, head: a } = s, o = this.toEditorPos(i.updateRangeStart), l = this.toEditorPos(i.updateRangeEnd);
      t.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: i.updateRangeStart, editorBase: o, drifted: !1 });
      let h = l - o > i.text.length;
      o == this.from && r < this.from ? o = r : l == this.to && r > this.to && (l = r);
      let u = lC(t.state.sliceDoc(o, l), i.text, (h ? s.from : s.to) - o, h ? "end" : null);
      if (!u) {
        let y = it.single(this.toEditorPos(i.selectionStart), this.toEditorPos(i.selectionEnd));
        Ow(y, s) || t.dispatch({ selection: y, userEvent: "select" });
        return;
      }
      let p = {
        from: u.from + o,
        to: u.toA + o,
        insert: Ft.of(i.text.slice(u.from, u.toB).split(`
`))
      };
      if ((nt.mac || nt.android) && p.from == a - 1 && /^\. ?$/.test(i.text) && t.contentDOM.getAttribute("autocorrect") == "off" && (p = { from: o, to: l, insert: Ft.of([i.text.replace(".", " ")]) }), this.pendingContextChange = p, !t.state.readOnly) {
        let y = this.to - this.from + (p.to - p.from + p.insert.length);
        Wb(t, p, it.single(this.toEditorPos(i.selectionStart, y), this.toEditorPos(i.selectionEnd, y)));
      }
      this.pendingContextChange && (this.revertPending(t.state), this.setSelection(t.state)), p.from < p.to && !p.insert.length && t.inputState.composing >= 0 && !/[\\p{Alphabetic}\\p{Number}_]/.test(e.text.slice(Math.max(0, i.updateRangeStart - 1), Math.min(e.text.length, i.updateRangeStart + 1))) && this.handlers.compositionend(i);
    }, this.handlers.characterboundsupdate = (i) => {
      let s = [], r = null;
      for (let a = this.toEditorPos(i.rangeStart), o = this.toEditorPos(i.rangeEnd); a < o; a++) {
        let l = t.coordsForChar(a);
        r = l && new DOMRect(l.left, l.top, l.right - l.left, l.bottom - l.top) || r || new DOMRect(), s.push(r);
      }
      e.updateCharacterBounds(i.rangeStart, s);
    }, this.handlers.textformatupdate = (i) => {
      let s = [];
      for (let r of i.getTextFormats()) {
        let a = r.underlineStyle, o = r.underlineThickness;
        if (!/none/i.test(a) && !/none/i.test(o)) {
          let l = this.toEditorPos(r.rangeStart), h = this.toEditorPos(r.rangeEnd);
          if (l < h) {
            let u = `text-decoration: underline ${/^[a-z]/.test(a) ? a + " " : a == "Dashed" ? "dashed " : a == "Squiggle" ? "wavy " : ""}${/thin/i.test(o) ? 1 : 2}px`;
            s.push(Gt.mark({ attributes: { style: u } }).range(l, h));
          }
        }
      }
      t.dispatch({ effects: L7.of(Gt.set(s)) });
    }, this.handlers.compositionstart = () => {
      t.inputState.composing < 0 && (t.inputState.composing = 0, t.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (t.inputState.composing = -1, t.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: i } = this.composing;
        this.composing = null, i && this.reset(t.state);
      }
    };
    for (let i in this.handlers)
      e.addEventListener(i, this.handlers[i]);
    this.measureReq = { read: /* @__PURE__ */ f((i) => {
      this.editContext.updateControlBounds(i.contentDOM.getBoundingClientRect());
      let s = Ko(i.root);
      s && s.rangeCount && this.editContext.updateSelectionBounds(s.getRangeAt(0).getBoundingClientRect());
    }, "read") };
  }
  applyEdits(t) {
    let e = 0, i = !1, s = this.pendingContextChange;
    return t.changes.iterChanges((r, a, o, l, h) => {
      if (i)
        return;
      let u = h.length - (a - r);
      if (s && a >= s.to)
        if (s.from == r && s.to == a && s.insert.eq(h)) {
          s = this.pendingContextChange = null, e += u, this.to += u;
          return;
        } else
          s = null, this.revertPending(t.state);
      if (r += e, a += e, a <= this.from)
        this.from += u, this.to += u;
      else if (r < this.to) {
        if (r < this.from || a > this.to || this.to - this.from + h.length > 3e4) {
          i = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(r), this.toContextPos(a), h.toString()), this.to += u;
      }
      e += u;
    }), s && !i && this.revertPending(t.state), !i;
  }
  update(t) {
    let e = this.pendingContextChange, i = t.startState.selection.main;
    this.composing && (this.composing.drifted || !t.changes.touchesRange(i.from, i.to) && t.transactions.some((s) => !s.isUserEvent("input.type") && s.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = t.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(t) || !this.rangeIsValid(t.state) ? (this.pendingContextChange = null, this.reset(t.state)) : (t.docChanged || t.selectionSet || e) && this.setSelection(t.state), (t.geometryChanged || t.docChanged || t.selectionSet) && t.view.requestMeasure(this.measureReq);
  }
  resetRange(t) {
    let { head: e } = t.selection.main;
    this.from = Math.max(
      0,
      e - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      t.doc.length,
      e + 1e4
      /* CxVp.Margin */
    );
  }
  reset(t) {
    this.resetRange(t), this.editContext.updateText(0, this.editContext.text.length, t.doc.sliceString(this.from, this.to)), this.setSelection(t);
  }
  revertPending(t) {
    let e = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(e.from), this.toContextPos(e.from + e.insert.length), t.doc.sliceString(e.from, e.to));
  }
  setSelection(t) {
    let { main: e } = t.selection, i = this.toContextPos(Math.max(this.from, Math.min(this.to, e.anchor))), s = this.toContextPos(e.head);
    (this.editContext.selectionStart != i || this.editContext.selectionEnd != s) && this.editContext.updateSelection(i, s);
  }
  rangeIsValid(t) {
    let { head: e } = t.selection.main;
    return !(this.from > 0 && e - this.from < 500 || this.to < t.doc.length && this.to - e < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(t, e = this.to - this.from) {
    t = Math.min(t, e);
    let i = this.composing;
    return i && i.drifted ? i.editorBase + (t - i.contextBase) : t + this.from;
  }
  toContextPos(t) {
    let e = this.composing;
    return e && e.drifted ? e.contextBase + (t - e.editorBase) : t - this.from;
  }
  destroy() {
    for (let t in this.handlers)
      this.editContext.removeEventListener(t, this.handlers[t]);
  }
}, c(Od, "qf"), Od);
f(TT, "EditContextManager");
let lq = TT;
var Zr;
const MT = (Zr = class {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(t = {}) {
    var e;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), t.parent && t.parent.appendChild(this.dom);
    let { dispatch: i } = t;
    this.dispatchTransactions = t.dispatchTransactions || i && ((s) => s.forEach((r) => i(r, this))) || ((s) => this.update(s)), this.dispatch = this.dispatch.bind(this), this._root = t.root || m7(t.parent) || document, this.viewState = new H3(t.state || Ie.create(t)), t.scrollTo && t.scrollTo.is(F1) && (this.viewState.scrollTarget = t.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(nh).map((s) => new e2(s));
    for (let s of this.plugins)
      s.update(this);
    this.observer = new oq(this), this.inputState = new jD(this), this.inputState.ensureHandlers(this.plugins), this.docView = new Z3(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((e = document.fonts) === null || e === void 0) && e.ready && document.fonts.ready.then(() => {
      this.viewState.mustMeasureContent = !0, this.requestMeasure();
    });
  }
  dispatch(...t) {
    let e = t.length == 1 && t[0] instanceof vi ? t : t.length == 1 && Array.isArray(t[0]) ? t[0] : [this.state.update(...t)];
    this.dispatchTransactions(e, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let e = !1, i = !1, s, r = this.state;
    for (let y of t) {
      if (y.startState != r)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      r = y.state;
    }
    if (this.destroyed) {
      this.viewState.state = r;
      return;
    }
    let a = this.hasFocus, o = 0, l = null;
    t.some((y) => y.annotation(tT)) ? (this.inputState.notifiedFocused = a, o = 1) : a != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = a, l = dC(r, a), l || (o = 1));
    let h = this.observer.delayedAndroidKey, u = null;
    if (h ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(r.doc) || !this.state.selection.eq(r.selection)) && (u = null)) : this.observer.clear(), r.facet(Ie.phrases) != this.state.facet(Ie.phrases))
      return this.setState(r);
    s = q3.create(this, r, t), s.flags |= o;
    let p = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let y of t) {
        if (p && (p = p.map(y.changes)), y.scrollIntoView) {
          let { main: m } = y.state.selection;
          p = new t2(m.empty ? m : it.cursor(m.head, m.head > m.anchor ? -1 : 1));
        }
        for (let m of y.effects)
          m.is(F1) && (p = m.value.clip(this.state));
      }
      this.viewState.update(s, p), this.bidiCache = K3.update(this.bidiCache, s.changes), s.empty || (this.updatePlugins(s), this.inputState.update(s)), e = this.docView.update(s), this.state.facet(mg) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(t), this.docView.updateSelection(e, t.some((y) => y.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (s.startState.facet(j1) != s.state.facet(j1) && (this.viewState.mustMeasureContent = !0), (e || i || p || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), e && this.docViewUpdate(), !s.empty)
      for (let y of this.state.facet(Rk))
        try {
          y(s);
        } catch (m) {
          Qi(this.state, m, "update listener");
        }
    (l || u) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), u && !oC(this, u) && h.force && io(this.contentDOM, h.key, h.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = t;
      return;
    }
    this.updateState = 2;
    let e = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new H3(t), this.plugins = t.facet(nh).map((i) => new e2(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView.destroy(), this.docView = new Z3(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    e && this.focus(), this.requestMeasure();
  }
  updatePlugins(t) {
    let e = t.startState.facet(nh), i = t.state.facet(nh);
    if (e != i) {
      let s = [];
      for (let r of i) {
        let a = e.indexOf(r);
        if (a < 0)
          s.push(new e2(r));
        else {
          let o = this.plugins[a];
          o.mustUpdate = t, s.push(o);
        }
      }
      for (let r of this.plugins)
        r.mustUpdate != t && r.destroy(this);
      this.plugins = s, this.pluginMap.clear();
    } else
      for (let s of this.plugins)
        s.mustUpdate = t;
    for (let s = 0; s < this.plugins.length; s++)
      this.plugins[s].update(this);
    e != i && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let t of this.plugins) {
      let e = t.value;
      if (e && e.docViewUpdate)
        try {
          e.docViewUpdate(this);
        } catch (i) {
          Qi(this.state, i, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(t = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, t && this.observer.forceFlush();
    let e = null, i = this.scrollDOM, s = i.scrollTop * this.scaleY, { scrollAnchorPos: r, scrollAnchorHeight: a } = this.viewState;
    Math.abs(s - this.viewState.scrollTop) > 1 && (a = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let o = 0; ; o++) {
        if (a < 0)
          if (NS(i))
            r = -1, a = this.viewState.heightMap.height;
          else {
            let m = this.viewState.scrollAnchorAt(s);
            r = m.from, a = m.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (o > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let h = [];
        l & 4 || ([this.measureRequests, h] = [h, this.measureRequests]);
        let u = h.map((m) => {
          try {
            return m.read(this);
          } catch (g) {
            return Qi(this.state, g), G3;
          }
        }), p = q3.create(this, this.state, []), y = !1;
        p.flags |= l, e ? e.flags |= l : e = p, this.updateState = 2, p.empty || (this.updatePlugins(p), this.inputState.update(p), this.updateAttrs(), y = this.docView.update(p), y && this.docViewUpdate());
        for (let m = 0; m < h.length; m++)
          if (u[m] != G3)
            try {
              let g = h[m];
              g.write && g.write(u[m], this);
            } catch (g) {
              Qi(this.state, g);
            }
        if (y && this.docView.updateSelection(!0), !p.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, a = -1;
              continue;
            } else {
              let m = (r < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(r).top) - a;
              if (m > 1 || m < -1) {
                s = s + m, i.scrollTop = s / this.scaleY, a = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (e && !e.empty)
      for (let o of this.state.facet(Rk))
        o(e);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return jk + " " + (this.state.facet(Nk) ? ST : kT) + " " + this.state.facet(j1);
  }
  updateAttrs() {
    let t = Hk(this, V7, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), e = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(Ms) ? "true" : "false",
      class: "cm-content",
      style: `${nt.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (e["aria-readonly"] = "true"), Hk(this, eC, e);
    let i = this.observer.ignore(() => {
      let s = Tk(this.contentDOM, this.contentAttrs, e), r = Tk(this.dom, this.editorAttrs, t);
      return s || r;
    });
    return this.editorAttrs = t, this.contentAttrs = e, i;
  }
  showAnnouncements(t) {
    let e = !0;
    for (let i of t)
      for (let s of i.effects)
        if (s.is(Zr.announce)) {
          e && (this.announceDOM.textContent = ""), e = !1;
          let r = this.announceDOM.appendChild(document.createElement("div"));
          r.textContent = s.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(mg);
    let t = this.state.facet(Zr.cspNonce);
    ia.mount(this.root, this.styleModules.concat(rq).reverse(), t ? { nonce: t } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(t) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), t) {
      if (this.measureRequests.indexOf(t) > -1)
        return;
      if (t.key != null) {
        for (let e = 0; e < this.measureRequests.length; e++)
          if (this.measureRequests[e].key === t.key) {
            this.measureRequests[e] = t;
            return;
          }
      }
      this.measureRequests.push(t);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(t) {
    let e = this.pluginMap.get(t);
    return (e === void 0 || e && e.plugin != t) && this.pluginMap.set(t, e = this.plugins.find((i) => i.plugin == t) || null), e && e.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(t) {
    return this.readMeasured(), this.viewState.elementAtHeight(t);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(t) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(t);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(t) {
    return this.viewState.lineBlockAt(t);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(t, e, i) {
    return wv(this, t, Lk(this, t, e, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(t, e) {
    return wv(this, t, Lk(this, t, e, (i) => P6(this, t.head, i)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(t, e) {
    let i = this.bidiSpans(t), s = this.textDirectionAt(t.from), r = i[e ? i.length - 1 : 0];
    return it.cursor(r.side(e, s) + t.from, r.forward(!e, s) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(t, e, i = !0) {
    return C6(this, t, e, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(t, e, i) {
    return wv(this, t, Q6(this, t, e, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(t, e = 1) {
    return this.docView.domAtPos(t, e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(t, e = 0) {
    return this.docView.posFromDOM(t, e);
  }
  posAtCoords(t, e = !0) {
    this.readMeasured();
    let i = $O(this, t, e);
    return i && i.pos;
  }
  posAndSideAtCoords(t, e = !0) {
    return this.readMeasured(), $O(this, t, e);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(t, e = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(t, e);
    if (!i || i.left == i.right)
      return i;
    let s = this.state.doc.lineAt(t), r = this.bidiSpans(s), a = r[zs.find(r, t - s.from, -1, e)];
    return By(i, a.dir == le.LTR == e > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(t) {
    return this.readMeasured(), this.docView.coordsForChar(t);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(t) {
    return !this.state.facet(E7) || t < this.viewport.from || t > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(t));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(t) {
    if (t.length > cq)
      return KS(t.length);
    let e = this.textDirectionAt(t.from), i;
    for (let r of this.bidiCache)
      if (r.from == t.from && r.dir == e && (r.fresh || GS(r.isolates, i = Ek(this, t))))
        return r.order;
    i || (i = Ek(this, t));
    let s = x7(t.text, e, i);
    return this.bidiCache.push(new K3(t.from, t.to, e, i, !0, s)), s;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var t;
    return (this.dom.ownerDocument.hasFocus() || nt.safari && ((t = this.inputState) === null || t === void 0 ? void 0 : t.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      XS(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(t) {
    this._root != t && (this._root = t, this.observer.setWindow((t.nodeType == 9 ? t : t.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let t of this.plugins)
      t.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(t, e = {}) {
    return F1.of(new t2(typeof t == "number" ? it.cursor(t) : t, e.y, e.x, e.yMargin, e.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: t, scrollLeft: e } = this.scrollDOM, i = this.viewState.scrollAnchorAt(t);
    return F1.of(new t2(it.cursor(i.from), "start", "start", i.top - t, e, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(t) {
    t == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof t == "boolean" ? this.inputState.tabFocusMode = t ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + t);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(t) {
    return Us.define(() => ({}), { eventHandlers: t });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(t) {
    return Us.define(() => ({}), { eventObservers: t });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(t, e) {
    let i = ia.newName(), s = [j1.of(i), mg.of(xO(`.${i}`, t))];
    return e && e.dark && s.push(Nk.of(!0)), s;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(t) {
    return Cl.lowest(mg.of(xO("." + jk, t, CT)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(t) {
    var e;
    let i = t.querySelector(".cm-content");
    return ((e = (i && Pe.get(i) || Pe.get(t))?.root) === null || e === void 0 ? void 0 : e.view) || null;
  }
}, c(Zr, "Xr"), Zr);
f(MT, "EditorView");
let kt = MT;
kt.styleModule = mg;
kt.inputHandler = A7;
kt.clipboardInputFilter = JS;
kt.clipboardOutputFilter = tC;
kt.scrollHandler = _7;
kt.focusChangeEffect = R7;
kt.perLineTextDirection = E7;
kt.exceptionSink = M7;
kt.updateListener = Rk;
kt.editable = Ms;
kt.mouseSelectionStyle = T7;
kt.dragMovesSelection = Q7;
kt.clickAddsSelectionRange = P7;
kt.decorations = _b;
kt.blockWrappers = D7;
kt.outerDecorations = iC;
kt.atomicRanges = o1;
kt.bidiIsolatedRanges = q7;
kt.scrollMargins = Z7;
kt.darkTheme = Nk;
kt.cspNonce = /* @__PURE__ */ bt.define({ combine: /* @__PURE__ */ f((n) => n.length ? n[0] : "", "combine") });
kt.contentAttributes = eC;
kt.editorAttributes = V7;
kt.lineWrapping = /* @__PURE__ */ kt.contentAttributes.of({ class: "cm-lineWrapping" });
kt.announce = /* @__PURE__ */ Bt.define();
const cq = 4096, G3 = {};
var Ao;
const AT = (Ao = class {
  constructor(t, e, i, s, r, a) {
    this.from = t, this.to = e, this.dir = i, this.isolates = s, this.fresh = r, this.order = a;
  }
  static update(t, e) {
    if (e.empty && !t.some((r) => r.fresh))
      return t;
    let i = [], s = t.length ? t[t.length - 1].dir : le.LTR;
    for (let r = Math.max(0, t.length - 10); r < t.length; r++) {
      let a = t[r];
      a.dir == s && !e.touchesRange(a.from, a.to) && i.push(new Ao(e.mapPos(a.from, 1), e.mapPos(a.to, -1), a.dir, a.isolates, !1, a.order));
    }
    return i;
  }
}, c(Ao, "ro"), Ao);
f(AT, "CachedOrder");
let K3 = AT;
function Hk(n, t, e) {
  for (let i = n.state.facet(t), s = i.length - 1; s >= 0; s--) {
    let r = i[s], a = typeof r == "function" ? r(n) : r;
    a && Rb(a, e);
  }
  return e;
}
c(Hk, "Cu$1");
f(Hk, "attrsFromFacet");
const hq = nt.mac ? "mac" : nt.windows ? "win" : nt.linux ? "linux" : "key";
function RT(n, t) {
  const e = n.split(/-(?!$)/);
  let i = e[e.length - 1];
  i == "Space" && (i = " ");
  let s, r, a, o;
  for (let l = 0; l < e.length - 1; ++l) {
    const h = e[l];
    if (/^(cmd|meta|m)$/i.test(h))
      o = !0;
    else if (/^a(lt)?$/i.test(h))
      s = !0;
    else if (/^(c|ctrl|control)$/i.test(h))
      r = !0;
    else if (/^s(hift)?$/i.test(h))
      a = !0;
    else if (/^mod$/i.test(h))
      t == "mac" ? o = !0 : r = !0;
    else
      throw new Error("Unrecognized modifier name: " + h);
  }
  return s && (i = "Alt-" + i), r && (i = "Ctrl-" + i), o && (i = "Meta-" + i), a && (i = "Shift-" + i), i;
}
c(RT, "k1$1");
f(RT, "normalizeKeyName");
function $g(n, t, e) {
  return t.altKey && (n = "Alt-" + n), t.ctrlKey && (n = "Ctrl-" + n), t.metaKey && (n = "Meta-" + n), e !== !1 && t.shiftKey && (n = "Shift-" + n), n;
}
c($g, "Zn$1");
f($g, "modifiers");
const dq = /* @__PURE__ */ Cl.default(/* @__PURE__ */ kt.domEventHandlers({
  keydown(n, t) {
    return zT(ET(t.state), n, t, "editor");
  }
})), Vb = /* @__PURE__ */ bt.define({ enables: dq }), J3 = /* @__PURE__ */ new WeakMap();
function ET(n) {
  let t = n.facet(Vb), e = J3.get(t);
  return e || J3.set(t, e = _T(t.reduce((i, s) => i.concat(s), []))), e;
}
c(ET, "$1$1");
f(ET, "getKeymap");
let Sr = null;
const uq = 4e3;
function _T(n, t = hq) {
  let e = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ f((a, o) => {
    let l = i[a];
    if (l == null)
      i[a] = o;
    else if (l != o)
      throw new Error("Key binding " + a + " is used both as a regular binding and as a multi-stroke prefix");
  }, "checkPrefix"), r = /* @__PURE__ */ f((a, o, l, h, u) => {
    var p, y;
    let m = e[a] || (e[a] = /* @__PURE__ */ Object.create(null)), g = o.split(/ (?!$)/).map((x) => RT(x, t));
    for (let x = 1; x < g.length; x++) {
      let Q = g.slice(0, x).join(" ");
      s(Q, !0), m[Q] || (m[Q] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(L) => {
          let W = Sr = { view: L, prefix: Q, scope: a };
          return setTimeout(() => {
            Sr == W && (Sr = null);
          }, uq), !0;
        }]
      });
    }
    let b = g.join(" ");
    s(b, !1);
    let S = m[b] || (m[b] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((y = (p = m._any) === null || p === void 0 ? void 0 : p.run) === null || y === void 0 ? void 0 : y.slice()) || []
    });
    l && S.run.push(l), h && (S.preventDefault = !0), u && (S.stopPropagation = !0);
  }, "add");
  for (let a of n) {
    let o = a.scope ? a.scope.split(" ") : ["editor"];
    if (a.any)
      for (let h of o) {
        let u = e[h] || (e[h] = /* @__PURE__ */ Object.create(null));
        u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: p } = a;
        for (let y in u)
          u[y].run.push((m) => p(m, Yk));
      }
    let l = a[t] || a.key;
    if (l)
      for (let h of o)
        r(h, l, a.run, a.preventDefault, a.stopPropagation), a.shift && r(h, "Shift-" + l, a.shift, a.preventDefault, a.stopPropagation);
  }
  return e;
}
c(_T, "v1$1");
f(_T, "buildKeymap");
let Yk = null;
function zT(n, t, e, i) {
  Yk = t;
  let s = e7(t), r = br(s, 0), a = Ua(r) == s.length && s != " ", o = "", l = !1, h = !1, u = !1;
  Sr && Sr.view == e && Sr.scope == i && (o = Sr.prefix + " ", q6.indexOf(t.keyCode) < 0 && (h = !0, Sr = null));
  let p = /* @__PURE__ */ new Set(), y = /* @__PURE__ */ f((S) => {
    if (S) {
      for (let x of S.run)
        if (!p.has(x) && (p.add(x), x(e)))
          return S.stopPropagation && (u = !0), !0;
      S.preventDefault && (S.stopPropagation && (u = !0), h = !0);
    }
    return !1;
  }, "runFor"), m = n[i], g, b;
  return m && (y(m[o + $g(s, t, !a)]) ? l = !0 : a && (t.altKey || t.metaKey || t.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(nt.windows && t.ctrlKey && t.altKey) && // Alt-combinations on macOS tend to be typed characters
  !(nt.mac && t.altKey && !(t.ctrlKey || t.metaKey)) && (g = na[t.keyCode]) && g != s ? (y(m[o + $g(g, t, !0)]) || t.shiftKey && (b = mw[t.keyCode]) != s && b != g && y(m[o + $g(b, t, !1)])) && (l = !0) : a && t.shiftKey && y(m[o + $g(s, t, !0)]) && (l = !0), !l && y(m._any) && (l = !0)), h && (l = !0), l && u && t.stopPropagation(), Yk = null, l;
}
c(zT, "T1$1");
f(zT, "runHandlers");
const LT = /* @__PURE__ */ Bt.define({
  map(n, t) {
    return n == null ? null : t.mapPos(n);
  }
}), xg = /* @__PURE__ */ rr.define({
  create() {
    return null;
  },
  update(n, t) {
    return n != null && (n = t.changes.mapPos(n)), t.effects.reduce((e, i) => i.is(LT) ? i.value : e, n);
  }
}), pq = /* @__PURE__ */ Us.fromClass(class {
  constructor(n) {
    this.view = n, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(n) {
    var t;
    let e = n.state.field(xg);
    e == null ? this.cursor != null && ((t = this.cursor) === null || t === void 0 || t.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (n.startState.field(xg) != e || n.docChanged || n.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: n } = this, t = n.state.field(xg), e = t != null && n.coordsAtPos(t);
    if (!e)
      return null;
    let i = n.scrollDOM.getBoundingClientRect();
    return {
      left: e.left - i.left + n.scrollDOM.scrollLeft * n.scaleX,
      top: e.top - i.top + n.scrollDOM.scrollTop * n.scaleY,
      height: e.bottom - e.top
    };
  }
  drawCursor(n) {
    if (this.cursor) {
      let { scaleX: t, scaleY: e } = this.view;
      n ? (this.cursor.style.left = n.left / t + "px", this.cursor.style.top = n.top / e + "px", this.cursor.style.height = n.height / e + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(n) {
    this.view.state.field(xg) != n && this.view.dispatch({ effects: LT.of(n) });
  }
}, {
  eventObservers: {
    dragover(n) {
      this.setDropPos(this.view.posAtCoords({ x: n.clientX, y: n.clientY }));
    },
    dragleave(n) {
      (n.target == this.view.contentDOM || !this.view.contentDOM.contains(n.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function fq() {
  return [xg, pq];
}
c(fq, "L1$1");
f(fq, "dropCursor");
function Gk(n, t, e, i, s) {
  t.lastIndex = 0;
  for (let r = n.iterRange(e, i), a = e, o; !r.next().done; a += r.value.length)
    if (!r.lineBreak)
      for (; o = t.exec(r.value); )
        s(a + o.index, o);
}
c(Gk, "Eu$1");
f(Gk, "iterMatches");
function IT(n, t) {
  let e = n.visibleRanges;
  if (e.length == 1 && e[0].from == n.viewport.from && e[0].to == n.viewport.to)
    return e;
  let i = [];
  for (let { from: s, to: r } of e)
    s = Math.max(n.state.doc.lineAt(s).from, s - t), r = Math.min(n.state.doc.lineAt(r).to, r + t), i.length && i[i.length - 1].to >= s ? i[i.length - 1].to = r : i.push({ from: s, to: r });
  return i;
}
c(IT, "_1$1");
f(IT, "matchRanges");
var bd;
const WT = (bd = class {
  /**
  Create a decorator.
  */
  constructor(t) {
    const { regexp: e, decoration: i, decorate: s, boundary: r, maxLength: a = 1e3 } = t;
    if (!e.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = e, s)
      this.addMatch = (o, l, h, u) => s(u, h, h + o[0].length, o, l);
    else if (typeof i == "function")
      this.addMatch = (o, l, h, u) => {
        let p = i(o, l, h);
        p && u(h, h + o[0].length, p);
      };
    else if (i)
      this.addMatch = (o, l, h, u) => u(h, h + o[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = r, this.maxLength = a;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(t) {
    let e = new uO(), i = e.add.bind(e);
    for (let { from: s, to: r } of IT(t, this.maxLength))
      Gk(t.state.doc, this.regexp, s, r, (a, o) => this.addMatch(o, t, a, i));
    return e.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(t, e) {
    let i = 1e9, s = -1;
    return t.docChanged && t.changes.iterChanges((r, a, o, l) => {
      l >= t.view.viewport.from && o <= t.view.viewport.to && (i = Math.min(o, i), s = Math.max(l, s));
    }), t.viewportMoved || s - i > 1e3 ? this.createDeco(t.view) : s > -1 ? this.updateRange(t.view, e.map(t.changes), i, s) : e;
  }
  updateRange(t, e, i, s) {
    for (let r of t.visibleRanges) {
      let a = Math.max(r.from, i), o = Math.min(r.to, s);
      if (o >= a) {
        let l = t.state.doc.lineAt(a), h = l.to < o ? t.state.doc.lineAt(o) : l, u = Math.max(r.from, l.from), p = Math.min(r.to, h.to);
        if (this.boundary) {
          for (; a > l.from; a--)
            if (this.boundary.test(l.text[a - 1 - l.from])) {
              u = a;
              break;
            }
          for (; o < h.to; o++)
            if (this.boundary.test(h.text[o - h.from])) {
              p = o;
              break;
            }
        }
        let y = [], m, g = /* @__PURE__ */ f((b, S, x) => y.push(x.range(b, S)), "add");
        if (l == h)
          for (this.regexp.lastIndex = u - l.from; (m = this.regexp.exec(l.text)) && m.index < p - l.from; )
            this.addMatch(m, t, m.index + l.from, g);
        else
          Gk(t.state.doc, this.regexp, u, p, (b, S) => this.addMatch(S, t, b, g));
        e = e.update({ filterFrom: u, filterTo: p, filter: /* @__PURE__ */ f((b, S) => b < u || S > p, "filter"), add: y });
      }
    }
    return e;
  }
}, c(bd, "Bf"), bd);
f(WT, "MatchDecorator");
let yq = WT;
var $d;
const VT = ($d = class extends Pl {
  constructor(t) {
    super(), this.content = t;
  }
  toDOM(t) {
    let e = document.createElement("span");
    return e.className = "cm-placeholder", e.style.pointerEvents = "none", e.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(t) : this.content.cloneNode(!0)), e.setAttribute("aria-hidden", "true"), e;
  }
  coordsAt(t) {
    let e = t.firstChild ? ch(t.firstChild) : [];
    if (!e.length)
      return null;
    let i = window.getComputedStyle(t.parentNode), s = By(e[0], i.direction != "rtl"), r = parseInt(i.lineHeight);
    return s.bottom - s.top > r * 1.5 ? { left: s.left, right: s.right, top: s.top, bottom: s.top + r } : s;
  }
  ignoreEvent() {
    return !1;
  }
}, c($d, "Df"), $d);
f(VT, "Placeholder");
let mq = VT;
function gq(n) {
  let t = Us.fromClass(class {
    constructor(e) {
      this.view = e, this.placeholder = n ? Gt.set([Gt.widget({ widget: new mq(n), side: 1 }).range(0)]) : Gt.none;
    }
    get decorations() {
      return this.view.state.doc.length ? Gt.none : this.placeholder;
    }
  }, { decorations: /* @__PURE__ */ f((e) => e.decorations, "decorations") });
  return typeof n == "string" ? [
    t,
    kt.contentAttributes.of({ "aria-placeholder": n })
  ] : t;
}
c(gq, "M1$1");
f(gq, "placeholder");
const B1 = "-10000px";
var xd;
const DT = (xd = class {
  constructor(t, e, i, s) {
    this.facet = e, this.createTooltipView = i, this.removeTooltipView = s, this.input = t.state.facet(e), this.tooltips = this.input.filter((a) => a);
    let r = null;
    this.tooltipViews = this.tooltips.map((a) => r = i(a, r));
  }
  update(t, e) {
    var i;
    let s = t.state.facet(this.facet), r = s.filter((l) => l);
    if (s === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(t);
      return !1;
    }
    let a = [], o = e ? [] : null;
    for (let l = 0; l < r.length; l++) {
      let h = r[l], u = -1;
      if (h) {
        for (let p = 0; p < this.tooltips.length; p++) {
          let y = this.tooltips[p];
          y && y.create == h.create && (u = p);
        }
        if (u < 0)
          a[l] = this.createTooltipView(h, l ? a[l - 1] : null), o && (o[l] = !!h.above);
        else {
          let p = a[l] = this.tooltipViews[u];
          o && (o[l] = e[u]), p.update && p.update(t);
        }
      }
    }
    for (let l of this.tooltipViews)
      a.indexOf(l) < 0 && (this.removeTooltipView(l), (i = l.destroy) === null || i === void 0 || i.call(l));
    return e && (o.forEach((l, h) => e[h] = l), e.length = o.length), this.input = s, this.tooltips = r, this.tooltipViews = a, !0;
  }
}, c(xd, "Nf"), xd);
f(DT, "TooltipViewManager");
let wq = DT;
function qT(n) {
  let t = n.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: t.clientHeight, right: t.clientWidth };
}
c(qT, "Z1$1");
f(qT, "windowSpace");
const o2 = /* @__PURE__ */ bt.define({
  combine: /* @__PURE__ */ f((n) => {
    var t, e, i;
    return {
      position: nt.ios ? "absolute" : ((t = n.find((s) => s.position)) === null || t === void 0 ? void 0 : t.position) || "fixed",
      parent: ((e = n.find((s) => s.parent)) === null || e === void 0 ? void 0 : e.parent) || null,
      tooltipSpace: ((i = n.find((s) => s.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || qT
    };
  }, "combine")
}), tQ = /* @__PURE__ */ new WeakMap(), ZT = /* @__PURE__ */ Us.fromClass(class {
  constructor(n) {
    this.view = n, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let t = n.state.facet(o2);
    this.position = t.position, this.parent = t.parent, this.classes = n.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new wq(n, FT, (e, i) => this.createTooltip(e, i), (e) => {
      this.resizeObserver && this.resizeObserver.unobserve(e.dom), e.dom.remove();
    }), this.above = this.manager.tooltips.map((e) => !!e.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((e) => {
      Date.now() > this.lastTransaction - 50 && e.length > 0 && e[e.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), n.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let n of this.manager.tooltipViews)
        this.intersectionObserver.observe(n.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(n) {
    n.transactions.length && (this.lastTransaction = Date.now());
    let t = this.manager.update(n, this.above);
    t && this.observeIntersection();
    let e = t || n.geometryChanged, i = n.state.facet(o2);
    if (i.position != this.position && !this.madeAbsolute) {
      this.position = i.position;
      for (let s of this.manager.tooltipViews)
        s.dom.style.position = this.position;
      e = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let s of this.manager.tooltipViews)
        this.container.appendChild(s.dom);
      e = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    e && this.maybeMeasure();
  }
  createTooltip(n, t) {
    let e = n.create(this.view), i = t ? t.dom : null;
    if (e.dom.classList.add("cm-tooltip"), n.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let s = document.createElement("div");
      s.className = "cm-tooltip-arrow", e.dom.appendChild(s);
    }
    return e.dom.style.position = this.position, e.dom.style.top = B1, e.dom.style.left = "0px", this.container.insertBefore(e.dom, i), e.mount && e.mount(this.view), this.resizeObserver && this.resizeObserver.observe(e.dom), e;
  }
  destroy() {
    var n, t, e;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let i of this.manager.tooltipViews)
      i.dom.remove(), (n = i.destroy) === null || n === void 0 || n.call(i);
    this.parent && this.container.remove(), (t = this.resizeObserver) === null || t === void 0 || t.disconnect(), (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let n = 1, t = 1, e = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: r } = this.manager.tooltipViews[0];
      if (nt.safari) {
        let a = r.getBoundingClientRect();
        e = Math.abs(a.top + 1e4) > 1 || Math.abs(a.left) > 1;
      } else
        e = !!r.offsetParent && r.offsetParent != this.container.ownerDocument.body;
    }
    if (e || this.position == "absolute")
      if (this.parent) {
        let r = this.parent.getBoundingClientRect();
        r.width && r.height && (n = r.width / this.parent.offsetWidth, t = r.height / this.parent.offsetHeight);
      } else
        ({ scaleX: n, scaleY: t } = this.view.viewState);
    let i = this.view.scrollDOM.getBoundingClientRect(), s = zb(this.view);
    return {
      visible: {
        left: i.left + s.left,
        top: i.top + s.top,
        right: i.right - s.right,
        bottom: i.bottom - s.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((r, a) => {
        let o = this.manager.tooltipViews[a];
        return o.getCoords ? o.getCoords(r.pos) : this.view.coordsAtPos(r.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: r }) => r.getBoundingClientRect()),
      space: this.view.state.facet(o2).tooltipSpace(this.view),
      scaleX: n,
      scaleY: t,
      makeAbsolute: e
    };
  }
  writeMeasure(n) {
    var t;
    if (n.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let o of this.manager.tooltipViews)
        o.dom.style.position = "absolute";
    }
    let { visible: e, space: i, scaleX: s, scaleY: r } = n, a = [];
    for (let o = 0; o < this.manager.tooltips.length; o++) {
      let l = this.manager.tooltips[o], h = this.manager.tooltipViews[o], { dom: u } = h, p = n.pos[o], y = n.size[o];
      if (!p || l.clip !== !1 && (p.bottom <= Math.max(e.top, i.top) || p.top >= Math.min(e.bottom, i.bottom) || p.right < Math.max(e.left, i.left) - 0.1 || p.left > Math.min(e.right, i.right) + 0.1)) {
        u.style.top = B1;
        continue;
      }
      let m = l.arrow ? h.dom.querySelector(".cm-tooltip-arrow") : null, g = m ? 7 : 0, b = y.right - y.left, S = (t = tQ.get(h)) !== null && t !== void 0 ? t : y.bottom - y.top, x = h.offset || Oq, Q = this.view.textDirection == le.LTR, L = y.width > i.right - i.left ? Q ? i.left : i.right - y.width : Q ? Math.max(i.left, Math.min(p.left - (m ? 14 : 0) + x.x, i.right - b)) : Math.min(Math.max(i.left, p.left - b + (m ? 14 : 0) - x.x), i.right - b), W = this.above[o];
      !l.strictSide && (W ? p.top - S - g - x.y < i.top : p.bottom + S + g + x.y > i.bottom) && W == i.bottom - p.bottom > p.top - i.top && (W = this.above[o] = !W);
      let R = (W ? p.top - i.top : i.bottom - p.bottom) - g;
      if (R < S && h.resize !== !1) {
        if (R < this.view.defaultLineHeight) {
          u.style.top = B1;
          continue;
        }
        tQ.set(h, S), u.style.height = (S = R) / r + "px";
      } else u.style.height && (u.style.height = "");
      let I = W ? p.top - S - g - x.y : p.bottom + g + x.y, V = L + b;
      if (h.overlap !== !0)
        for (let X of a)
          X.left < V && X.right > L && X.top < I + S && X.bottom > I && (I = W ? X.top - S - 2 - g : X.bottom + g + 2);
      if (this.position == "absolute" ? (u.style.top = (I - n.parent.top) / r + "px", Kk(u, (L - n.parent.left) / s)) : (u.style.top = I / r + "px", Kk(u, L / s)), m) {
        let X = p.left + (Q ? x.x : -x.x) - (L + 14 - 7);
        m.style.left = X / s + "px";
      }
      h.overlap !== !0 && a.push({ left: L, top: I, right: V, bottom: I + S }), u.classList.toggle("cm-tooltip-above", W), u.classList.toggle("cm-tooltip-below", !W), h.positioned && h.positioned(n.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let n of this.manager.tooltipViews)
        n.dom.style.top = B1;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function Kk(n, t) {
  let e = parseInt(n.style.left, 10);
  (isNaN(e) || Math.abs(t - e) > 1) && (n.style.left = t + "px");
}
c(Kk, "Wu$1");
f(Kk, "setLeftStyle");
const vq = /* @__PURE__ */ kt.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: "14px",
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), Oq = { x: 0, y: 0 }, FT = /* @__PURE__ */ bt.define({
  enables: [ZT, vq]
});
function pC(n, t) {
  let e = n.plugin(ZT);
  if (!e)
    return null;
  let i = e.manager.tooltips.indexOf(t);
  return i < 0 ? null : e.manager.tooltipViews[i];
}
c(pC, "hp");
f(pC, "getTooltip");
var kd;
const XT = (kd = class extends ta {
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(t) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(t) {
  }
}, c(kd, "Gf"), kd);
f(XT, "GutterMarker");
let Gy = XT;
Gy.prototype.elementClass = "";
Gy.prototype.toDOM = void 0;
Gy.prototype.mapMode = wi.TrackBefore;
Gy.prototype.startSide = Gy.prototype.endSide = -1;
Gy.prototype.point = !0;
const NT = 1024;
let bq = 0;
var Sd;
const jT = (Sd = class {
  constructor(t, e) {
    this.from = t, this.to = e;
  }
}, c(Sd, "Ff"), Sd);
f(jT, "Range");
let on = jT;
var Cd;
const BT = (Cd = class {
  /**
  Create a new node prop type.
  */
  constructor(t = {}) {
    this.id = bq++, this.perNode = !!t.perNode, this.deserialize = t.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    }), this.combine = t.combine || null;
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(t) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof t != "function" && (t = Be.match(t)), (e) => {
      let i = t(e);
      return i === void 0 ? null : [this, i];
    };
  }
}, c(Cd, "Hf"), Cd);
f(BT, "NodeProp");
let Pt = BT;
Pt.closedBy = new Pt({ deserialize: /* @__PURE__ */ f((n) => n.split(" "), "deserialize") });
Pt.openedBy = new Pt({ deserialize: /* @__PURE__ */ f((n) => n.split(" "), "deserialize") });
Pt.group = new Pt({ deserialize: /* @__PURE__ */ f((n) => n.split(" "), "deserialize") });
Pt.isolate = new Pt({ deserialize: /* @__PURE__ */ f((n) => {
  if (n && n != "rtl" && n != "ltr" && n != "auto")
    throw new RangeError("Invalid value for isolate: " + n);
  return n || "auto";
}, "deserialize") });
Pt.contextHash = new Pt({ perNode: !0 });
Pt.lookAhead = new Pt({ perNode: !0 });
Pt.mounted = new Pt({ perNode: !0 });
var Pd;
const UT = (Pd = class {
  constructor(t, e, i, s = !1) {
    this.tree = t, this.overlay = e, this.parser = i, this.bracketed = s;
  }
  /**
  @internal
  */
  static get(t) {
    return t && t.props && t.props[Pt.mounted.id];
  }
}, c(Pd, "Kf"), Pd);
f(UT, "MountedTree");
let fh = UT;
const $q = /* @__PURE__ */ Object.create(null);
var Ro;
const HT = (Ro = class {
  /**
  @internal
  */
  constructor(t, e, i, s = 0) {
    this.name = t, this.props = e, this.id = i, this.flags = s;
  }
  /**
  Define a node type.
  */
  static define(t) {
    let e = t.props && t.props.length ? /* @__PURE__ */ Object.create(null) : $q, i = (t.top ? 1 : 0) | (t.skipped ? 2 : 0) | (t.error ? 4 : 0) | (t.name == null ? 8 : 0), s = new Ro(t.name || "", e, t.id, i);
    if (t.props) {
      for (let r of t.props)
        if (Array.isArray(r) || (r = r(s)), r) {
          if (r[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          e[r[0].id] = r[1];
        }
    }
    return s;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(t) {
    return this.props[t.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(t) {
    if (typeof t == "string") {
      if (this.name == t)
        return !0;
      let e = this.prop(Pt.group);
      return e ? e.indexOf(t) > -1 : !1;
    }
    return this.id == t;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(t) {
    let e = /* @__PURE__ */ Object.create(null);
    for (let i in t)
      for (let s of i.split(" "))
        e[s] = t[i];
    return (i) => {
      for (let s = i.prop(Pt.group), r = -1; r < (s ? s.length : 0); r++) {
        let a = e[r < 0 ? i.name : s[r]];
        if (a)
          return a;
      }
    };
  }
}, c(Ro, "no"), Ro);
f(HT, "NodeType");
let Be = HT;
Be.none = new Be(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
var Eo;
const YT = (Eo = class {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(t) {
    this.types = t;
    for (let e = 0; e < t.length; e++)
      if (t[e].id != e)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...t) {
    let e = [];
    for (let i of this.types) {
      let s = null;
      for (let r of t) {
        let a = r(i);
        if (a) {
          s || (s = Object.assign({}, i.props));
          let o = a[1], l = a[0];
          l.combine && l.id in s && (o = l.combine(s[l.id], o)), s[l.id] = o;
        }
      }
      e.push(s ? new Be(i.name, s, i.id, i.flags) : i);
    }
    return new Eo(e);
  }
}, c(Eo, "so"), Eo);
f(YT, "NodeSet");
let Db = YT;
const U1 = /* @__PURE__ */ new WeakMap(), eQ = /* @__PURE__ */ new WeakMap();
var Zt;
(function(n) {
  n[n.ExcludeBuffers = 1] = "ExcludeBuffers", n[n.IncludeAnonymous = 2] = "IncludeAnonymous", n[n.IgnoreMounts = 4] = "IgnoreMounts", n[n.IgnoreOverlays = 8] = "IgnoreOverlays", n[n.EnterBracketed = 16] = "EnterBracketed";
})(Zt || (Zt = {}));
var Fr;
const GT = (Fr = class {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(t, e, i, s, r) {
    if (this.type = t, this.children = e, this.positions = i, this.length = s, this.props = null, r && r.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [a, o] of r)
        this.props[typeof a == "number" ? a : a.id] = o;
    }
  }
  /**
  @internal
  */
  toString() {
    let t = fh.get(this);
    if (t && !t.overlay)
      return t.tree.toString();
    let e = "";
    for (let i of this.children) {
      let s = i.toString();
      s && (e && (e += ","), e += s);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (e.length ? "(" + e + ")" : "") : e;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(t = 0) {
    return new SO(this.topNode, t);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(t, e = 0, i = 0) {
    let s = U1.get(this) || this.topNode, r = new SO(s);
    return r.moveTo(t, e), U1.set(this, r._tree), r;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new dn(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(t, e = 0) {
    let i = Jy(U1.get(this) || this.topNode, t, e, !1);
    return U1.set(this, i), i;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(t, e = 0) {
    let i = Jy(eQ.get(this) || this.topNode, t, e, !0);
    return eQ.set(this, i), i;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(t, e = 0) {
    return aM(this, t, e);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(t) {
    let { enter: e, leave: i, from: s = 0, to: r = this.length } = t, a = t.mode || 0, o = (a & Zt.IncludeAnonymous) > 0;
    for (let l = this.cursor(a | Zt.IncludeAnonymous); ; ) {
      let h = !1;
      if (l.from <= r && l.to >= s && (!o && l.type.isAnonymous || e(l) !== !1)) {
        if (l.firstChild())
          continue;
        h = !0;
      }
      for (; h && i && (o || !l.type.isAnonymous) && i(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        h = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(t) {
    return t.perNode ? this.props ? this.props[t.id] : void 0 : this.type.prop(t);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let t = [];
    if (this.props)
      for (let e in this.props)
        t.push([+e, this.props[e]]);
    return t;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(t = {}) {
    return this.children.length <= 8 ? this : Zb(Be.none, this.children, this.positions, 0, this.children.length, 0, this.length, (e, i, s) => new Fr(this.type, e, i, s, this.propValues), t.makeTree || ((e, i, s) => new Fr(Be.none, e, i, s)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(t) {
    return lM(t);
  }
}, c(Fr, "Er"), Fr);
f(GT, "Tree");
let zt = GT;
zt.empty = new zt(Be.none, [], [], 0);
var _o;
const KT = (_o = class {
  constructor(t, e) {
    this.buffer = t, this.index = e;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new _o(this.buffer, this.index);
  }
}, c(_o, "oo"), _o);
f(KT, "FlatBufferCursor");
let xq = KT;
var zo;
const JT = (zo = class {
  /**
  Create a tree buffer.
  */
  constructor(t, e, i) {
    this.buffer = t, this.length = e, this.set = i;
  }
  /**
  @internal
  */
  get type() {
    return Be.none;
  }
  /**
  @internal
  */
  toString() {
    let t = [];
    for (let e = 0; e < this.buffer.length; )
      t.push(this.childString(e)), e = this.buffer[e + 3];
    return t.join(",");
  }
  /**
  @internal
  */
  childString(t) {
    let e = this.buffer[t], i = this.buffer[t + 3], s = this.set.types[e], r = s.name;
    if (/\W/.test(r) && !s.isError && (r = JSON.stringify(r)), t += 4, i == t)
      return r;
    let a = [];
    for (; t < i; )
      a.push(this.childString(t)), t = this.buffer[t + 3];
    return r + "(" + a.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(t, e, i, s, r) {
    let { buffer: a } = this, o = -1;
    for (let l = t; l != e && !(fC(r, s, a[l + 1], a[l + 2]) && (o = l, i > 0)); l = a[l + 3])
      ;
    return o;
  }
  /**
  @internal
  */
  slice(t, e, i) {
    let s = this.buffer, r = new Uint16Array(e - t), a = 0;
    for (let o = t, l = 0; o < e; ) {
      r[l++] = s[o++], r[l++] = s[o++] - i;
      let h = r[l++] = s[o++] - i;
      r[l++] = s[o++] - t, a = Math.max(a, h);
    }
    return new zo(r, a, this.set);
  }
}, c(zo, "lo"), zo);
f(JT, "TreeBuffer");
let Ky = JT;
function fC(n, t, e, i) {
  switch (n) {
    case -2:
      return e < t;
    case -1:
      return i >= t && e < t;
    case 0:
      return e < t && i > t;
    case 1:
      return e <= t && i > t;
    case 2:
      return i > t;
    case 4:
      return !0;
  }
}
c(fC, "cp");
f(fC, "checkSide");
function Jy(n, t, e, i) {
  for (var s; n.from == n.to || (e < 1 ? n.from >= t : n.from > t) || (e > -1 ? n.to <= t : n.to < t); ) {
    let a = !i && n instanceof dn && n.index < 0 ? null : n.parent;
    if (!a)
      return n;
    n = a;
  }
  let r = i ? 0 : Zt.IgnoreOverlays;
  if (i)
    for (let a = n, o = a.parent; o; a = o, o = a.parent)
      a instanceof dn && a.index < 0 && ((s = o.enter(t, e, r)) === null || s === void 0 ? void 0 : s.from) != a.from && (n = o);
  for (; ; ) {
    let a = n.enter(t, e, r);
    if (!a)
      return n;
    n = a;
  }
}
c(Jy, "rn$1");
f(Jy, "resolveNode");
var Qd;
const tM = (Qd = class {
  cursor(t = 0) {
    return new SO(this, t);
  }
  getChild(t, e = null, i = null) {
    let s = Jk(this, t, e, i);
    return s.length ? s[0] : null;
  }
  getChildren(t, e = null, i = null) {
    return Jk(this, t, e, i);
  }
  resolve(t, e = 0) {
    return Jy(this, t, e, !1);
  }
  resolveInner(t, e = 0) {
    return Jy(this, t, e, !0);
  }
  matchContext(t) {
    return kO(this.parent, t);
  }
  enterUnfinishedNodesBefore(t) {
    let e = this.childBefore(t), i = this;
    for (; e; ) {
      let s = e.lastChild;
      if (!s || s.to != e.to)
        break;
      s.type.isError && s.from == s.to ? (i = e, e = s.prevSibling) : e = s;
    }
    return i;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}, c(Qd, "Jf"), Qd);
f(tM, "BaseNode");
let eM = tM;
var Zs;
const iM = (Zs = class extends eM {
  constructor(t, e, i, s) {
    super(), this._tree = t, this.from = e, this.index = i, this._parent = s;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(t, e, i, s, r = 0) {
    var a;
    for (let o = this; ; ) {
      for (let { children: l, positions: h } = o._tree, u = e > 0 ? l.length : -1; t != u; t += e) {
        let p = l[t], y = h[t] + o.from;
        if (!(!(r & Zt.EnterBracketed && p instanceof zt && ((a = fh.get(p)) === null || a === void 0 ? void 0 : a.overlay) === null && (y >= i || y + p.length <= i)) && !fC(s, i, y, y + p.length))) {
          if (p instanceof Ky) {
            if (r & Zt.ExcludeBuffers)
              continue;
            let m = p.findChild(0, p.buffer.length, e, i - y, s);
            if (m > -1)
              return new $w(new kq(o, p, t, y), null, m);
          } else if (r & Zt.IncludeAnonymous || !p.type.isAnonymous || qb(p)) {
            let m;
            if (!(r & Zt.IgnoreMounts) && (m = fh.get(p)) && !m.overlay)
              return new Zs(m.tree, y, t, o);
            let g = new Zs(p, y, t, o);
            return r & Zt.IncludeAnonymous || !g.type.isAnonymous ? g : g.nextChild(e < 0 ? p.children.length - 1 : 0, e, i, s, r);
          }
        }
      }
      if (r & Zt.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? t = o.index + e : t = e < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.nextChild(
      0,
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  prop(t) {
    return this._tree.prop(t);
  }
  enter(t, e, i = 0) {
    let s;
    if (!(i & Zt.IgnoreOverlays) && (s = fh.get(this._tree)) && s.overlay) {
      let r = t - this.from, a = i & Zt.EnterBracketed && s.bracketed;
      for (let { from: o, to: l } of s.overlay)
        if ((e > 0 || a ? o <= r : o < r) && (e < 0 || a ? l >= r : l > r))
          return new Zs(s.tree, s.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, t, e, i);
  }
  nextSignificantParent() {
    let t = this;
    for (; t.type.isAnonymous && t._parent; )
      t = t._parent;
    return t;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}, c(Zs, "Qi"), Zs);
f(iM, "TreeNode");
let dn = iM;
function Jk(n, t, e, i) {
  let s = n.cursor(), r = [];
  if (!s.firstChild())
    return r;
  if (e != null) {
    for (let a = !1; !a; )
      if (a = s.type.is(e), !s.nextSibling())
        return r;
  }
  for (; ; ) {
    if (i != null && s.type.is(i))
      return r;
    if (s.type.is(t) && r.push(s.node), !s.nextSibling())
      return i == null ? r : [];
  }
}
c(Jk, "Uu");
f(Jk, "getChildren");
function kO(n, t, e = t.length - 1) {
  for (let i = n; e >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (t[e] && t[e] != i.name)
        return !1;
      e--;
    }
  }
  return !0;
}
c(kO, "ha$1");
f(kO, "matchNodeContext");
var Td;
const nM = (Td = class {
  constructor(t, e, i, s) {
    this.parent = t, this.buffer = e, this.index = i, this.start = s;
  }
}, c(Td, "ec"), Td);
f(nM, "BufferContext");
let kq = nM;
var Kn;
const sM = (Kn = class extends eM {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(t, e, i) {
    super(), this.context = t, this._parent = e, this.index = i, this.type = t.buffer.set.types[t.buffer.buffer[i]];
  }
  child(t, e, i) {
    let { buffer: s } = this.context, r = s.findChild(this.index + 4, s.buffer[this.index + 3], t, e - this.context.start, i);
    return r < 0 ? null : new Kn(this.context, this, r);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.child(
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.child(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  prop(t) {
    return this.type.prop(t);
  }
  enter(t, e, i = 0) {
    if (i & Zt.ExcludeBuffers)
      return null;
    let { buffer: s } = this.context, r = s.findChild(this.index + 4, s.buffer[this.index + 3], e > 0 ? 1 : -1, t - this.context.start, e);
    return r < 0 ? null : new Kn(this.context, this, r);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(t) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + t,
      t,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: t } = this.context, e = t.buffer[this.index + 3];
    return e < (this._parent ? t.buffer[this._parent.index + 3] : t.buffer.length) ? new Kn(this.context, this._parent, e) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: t } = this.context, e = this._parent ? this._parent.index + 4 : 0;
    return this.index == e ? this.externalSibling(-1) : new Kn(this.context, this._parent, t.findChild(
      e,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let t = [], e = [], { buffer: i } = this.context, s = this.index + 4, r = i.buffer[this.index + 3];
    if (r > s) {
      let a = i.buffer[this.index + 1];
      t.push(i.slice(s, r, a)), e.push(0);
    }
    return new zt(this.type, t, e, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}, c(Kn, "Bt"), Kn);
f(sM, "BufferNode");
let $w = sM;
function yC(n) {
  if (!n.length)
    return null;
  let t = 0, e = n[0];
  for (let r = 1; r < n.length; r++) {
    let a = n[r];
    (a.from > e.from || a.to < e.to) && (e = a, t = r);
  }
  let i = e instanceof dn && e.index < 0 ? null : e.parent, s = n.slice();
  return i ? s[t] = i : s.splice(t, 1), new Sq(s, e);
}
c(yC, "up");
f(yC, "iterStack");
var Md;
const rM = (Md = class {
  constructor(t, e) {
    this.heads = t, this.node = e;
  }
  get next() {
    return yC(this.heads);
  }
}, c(Md, "tc"), Md);
f(rM, "StackIterator");
let Sq = rM;
function aM(n, t, e) {
  let i = n.resolveInner(t, e), s = null;
  for (let r = i instanceof dn ? i : i.context.parent; r; r = r.parent)
    if (r.index < 0) {
      let a = r.parent;
      (s || (s = [i])).push(a.resolve(t, e)), r = a;
    } else {
      let a = fh.get(r.tree);
      if (a && a.overlay && a.overlay[0].from <= t && a.overlay[a.overlay.length - 1].to >= t) {
        let o = new dn(a.tree, a.overlay[0].from + r.from, -1, r);
        (s || (s = [i])).push(Jy(o, t, e, !1));
      }
    }
  return s ? yC(s) : i;
}
c(aM, "W1$1");
f(aM, "stackIterator");
var Ad;
const oM = (Ad = class {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(t, e = 0) {
    if (this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, this.mode = e & ~Zt.EnterBracketed, t instanceof dn)
      this.yieldNode(t);
    else {
      this._tree = t.context.parent, this.buffer = t.context;
      for (let i = t._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = t, this.yieldBuf(t.index);
    }
  }
  yieldNode(t) {
    return t ? (this._tree = t, this.type = t.type, this.from = t.from, this.to = t.to, !0) : !1;
  }
  yieldBuf(t, e) {
    this.index = t;
    let { start: i, buffer: s } = this.buffer;
    return this.type = e || s.set.types[s.buffer[t]], this.from = i + s.buffer[t + 1], this.to = i + s.buffer[t + 2], !0;
  }
  /**
  @internal
  */
  yield(t) {
    return t ? t instanceof dn ? (this.buffer = null, this.yieldNode(t)) : (this.buffer = t.context, this.yieldBuf(t.index, t.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(t, e, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(t < 0 ? this._tree._tree.children.length - 1 : 0, t, e, i, this.mode));
    let { buffer: s } = this.buffer, r = s.findChild(this.index + 4, s.buffer[this.index + 3], t, e - this.buffer.start, i);
    return r < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(r));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(t) {
    return this.enterChild(
      1,
      t,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(t) {
    return this.enterChild(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(t, e, i = this.mode) {
    return this.buffer ? i & Zt.ExcludeBuffers ? !1 : this.enterChild(1, t, e) : this.yield(this._tree.enter(t, e, i));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Zt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let t = this.mode & Zt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(t);
  }
  /**
  @internal
  */
  sibling(t) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + t, t, 0, 4, this.mode)) : !1;
    let { buffer: e } = this.buffer, i = this.stack.length - 1;
    if (t < 0) {
      let s = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != s)
        return this.yieldBuf(e.findChild(
          s,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let s = e.buffer[this.index + 3];
      if (s < (i < 0 ? e.buffer.length : e.buffer[this.stack[i] + 3]))
        return this.yieldBuf(s);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + t, t, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(t) {
    let e, i, { buffer: s } = this;
    if (s) {
      if (t > 0) {
        if (this.index < s.buffer.buffer.length)
          return !1;
      } else
        for (let r = 0; r < this.index; r++)
          if (s.buffer.buffer[r + 3] < this.index)
            return !1;
      ({ index: e, parent: i } = s);
    } else
      ({ index: e, _parent: i } = this._tree);
    for (; i; { index: e, _parent: i } = i)
      if (e > -1)
        for (let r = e + t, a = t < 0 ? -1 : i._tree.children.length; r != a; r += t) {
          let o = i._tree.children[r];
          if (this.mode & Zt.IncludeAnonymous || o instanceof Ky || !o.type.isAnonymous || qb(o))
            return !1;
        }
    return !0;
  }
  move(t, e) {
    if (e && this.enterChild(
      t,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(t))
        return !0;
      if (this.atLastNode(t) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(t = !0) {
    return this.move(1, t);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(t = !0) {
    return this.move(-1, t);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(t, e = 0) {
    for (; (this.from == this.to || (e < 1 ? this.from >= t : this.from > t) || (e > -1 ? this.to <= t : this.to < t)) && this.parent(); )
      ;
    for (; this.enterChild(1, t, e); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let t = this.bufferNode, e = null, i = 0;
    if (t && t.context == this.buffer)
      t: for (let s = this.index, r = this.stack.length; r >= 0; ) {
        for (let a = t; a; a = a._parent)
          if (a.index == s) {
            if (s == this.index)
              return a;
            e = a, i = r + 1;
            break t;
          }
        s = this.stack[--r];
      }
    for (let s = i; s < this.stack.length; s++)
      e = new $w(this.buffer, e, this.stack[s]);
    return this.bufferNode = new $w(this.buffer, e, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(t, e) {
    for (let i = 0; ; ) {
      let s = !1;
      if (this.type.isAnonymous || t(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (s = !0);
      }
      for (; ; ) {
        if (s && e && e(this), s = this.type.isAnonymous, !i)
          return;
        if (this.nextSibling())
          break;
        this.parent(), i--, s = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(t) {
    if (!this.buffer)
      return kO(this.node.parent, t);
    let { buffer: e } = this.buffer, { types: i } = e.set;
    for (let s = t.length - 1, r = this.stack.length - 1; s >= 0; r--) {
      if (r < 0)
        return kO(this._tree, t, s);
      let a = i[e.buffer[this.stack[r]]];
      if (!a.isAnonymous) {
        if (t[s] && t[s] != a.name)
          return !1;
        s--;
      }
    }
    return !0;
  }
}, c(Ad, "ic"), Ad);
f(oM, "TreeCursor");
let SO = oM;
function qb(n) {
  return n.children.some((t) => t instanceof Ky || !t.type.isAnonymous || qb(t));
}
c(qb, "bh$1");
f(qb, "hasChild");
function lM(n) {
  var t;
  let { buffer: e, nodeSet: i, maxBufferLength: s = NT, reused: r = [], minRepeatType: a = i.types.length } = n, o = Array.isArray(e) ? new xq(e, e.length) : e, l = i.types, h = 0, u = 0;
  function p(R, I, V, X, J, mt) {
    let { id: at, start: G, end: $t, size: rt } = o, Rt = u, Qt = h;
    if (rt < 0)
      if (o.next(), rt == -1) {
        let _e = r[at];
        V.push(_e), X.push(G - R);
        return;
      } else if (rt == -3) {
        h = at;
        return;
      } else if (rt == -4) {
        u = at;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${rt}`);
    let It = l[at], Vt, Dt, xi = G - R;
    if ($t - G <= s && (Dt = S(o.pos - I, J))) {
      let _e = new Uint16Array(Dt.size - Dt.skip), oe = o.pos - Dt.size, te = _e.length;
      for (; o.pos > oe; )
        te = x(Dt.start, _e, te);
      Vt = new Ky(_e, $t - Dt.start, i), xi = Dt.start - R;
    } else {
      let _e = o.pos - rt;
      o.next();
      let oe = [], te = [], fe = at >= a ? at : -1, ki = 0, Vi = $t;
      for (; o.pos > _e; )
        fe >= 0 && o.id == fe && o.size >= 0 ? (o.end <= Vi - s && (g(oe, te, G, ki, o.end, Vi, fe, Rt, Qt), ki = oe.length, Vi = o.end), o.next()) : mt > 2500 ? y(G, _e, oe, te) : p(G, _e, oe, te, fe, mt + 1);
      if (fe >= 0 && ki > 0 && ki < oe.length && g(oe, te, G, ki, G, Vi, fe, Rt, Qt), oe.reverse(), te.reverse(), fe > -1 && ki > 0) {
        let nn = m(It, Qt);
        Vt = Zb(It, oe, te, 0, oe.length, 0, $t - G, nn, nn);
      } else
        Vt = b(It, oe, te, $t - G, Rt - $t, Qt);
    }
    V.push(Vt), X.push(xi);
  }
  c(p, "u"), f(p, "takeNode");
  function y(R, I, V, X) {
    let J = [], mt = 0, at = -1;
    for (; o.pos > I; ) {
      let { id: G, start: $t, end: rt, size: Rt } = o;
      if (Rt > 4)
        o.next();
      else {
        if (at > -1 && $t < at)
          break;
        at < 0 && (at = rt - s), J.push(G, $t, rt), mt++, o.next();
      }
    }
    if (mt) {
      let G = new Uint16Array(mt * 4), $t = J[J.length - 2];
      for (let rt = J.length - 3, Rt = 0; rt >= 0; rt -= 3)
        G[Rt++] = J[rt], G[Rt++] = J[rt + 1] - $t, G[Rt++] = J[rt + 2] - $t, G[Rt++] = Rt;
      V.push(new Ky(G, J[2] - $t, i)), X.push($t - R);
    }
  }
  c(y, "O"), f(y, "takeFlatNode");
  function m(R, I) {
    return (V, X, J) => {
      let mt = 0, at = V.length - 1, G, $t;
      if (at >= 0 && (G = V[at]) instanceof zt) {
        if (!at && G.type == R && G.length == J)
          return G;
        ($t = G.prop(Pt.lookAhead)) && (mt = X[at] + G.length + $t);
      }
      return b(R, V, X, J, mt, I);
    };
  }
  c(m, "d"), f(m, "makeBalanced");
  function g(R, I, V, X, J, mt, at, G, $t) {
    let rt = [], Rt = [];
    for (; R.length > X; )
      rt.push(R.pop()), Rt.push(I.pop() + V - J);
    R.push(b(i.types[at], rt, Rt, mt - J, G - mt, $t)), I.push(J - V);
  }
  c(g, "p"), f(g, "makeRepeatLeaf");
  function b(R, I, V, X, J, mt, at) {
    if (mt) {
      let G = [Pt.contextHash, mt];
      at = at ? [G].concat(at) : [G];
    }
    if (J > 25) {
      let G = [Pt.lookAhead, J];
      at = at ? [G].concat(at) : [G];
    }
    return new zt(R, I, V, X, at);
  }
  c(b, "m"), f(b, "makeTree");
  function S(R, I) {
    let V = o.fork(), X = 0, J = 0, mt = 0, at = V.end - s, G = { size: 0, start: 0, skip: 0 };
    t: for (let $t = V.pos - R; V.pos > $t; ) {
      let rt = V.size;
      if (V.id == I && rt >= 0) {
        G.size = X, G.start = J, G.skip = mt, mt += 4, X += 4, V.next();
        continue;
      }
      let Rt = V.pos - rt;
      if (rt < 0 || Rt < $t || V.start < at)
        break;
      let Qt = V.id >= a ? 4 : 0, It = V.start;
      for (V.next(); V.pos > Rt; ) {
        if (V.size < 0)
          if (V.size == -3 || V.size == -4)
            Qt += 4;
          else
            break t;
        else V.id >= a && (Qt += 4);
        V.next();
      }
      J = It, X += rt, mt += Qt;
    }
    return (I < 0 || X == R) && (G.size = X, G.start = J, G.skip = mt), G.size > 4 ? G : void 0;
  }
  c(S, "Q"), f(S, "findBufferSize");
  function x(R, I, V) {
    let { id: X, start: J, end: mt, size: at } = o;
    if (o.next(), at >= 0 && X < a) {
      let G = V;
      if (at > 4) {
        let $t = o.pos - (at - 4);
        for (; o.pos > $t; )
          V = x(R, I, V);
      }
      I[--V] = G, I[--V] = mt - R, I[--V] = J - R, I[--V] = X;
    } else at == -3 ? h = X : at == -4 && (u = X);
    return V;
  }
  c(x, "y"), f(x, "copyToBuffer");
  let Q = [], L = [];
  for (; o.pos > 0; )
    p(n.start || 0, n.bufferStart || 0, Q, L, -1, 0);
  let W = (t = n.length) !== null && t !== void 0 ? t : Q.length ? L[0] + Q[0].length : 0;
  return new zt(l[n.topID], Q.reverse(), L.reverse(), W);
}
c(lM, "V1$1");
f(lM, "buildTree");
const iQ = /* @__PURE__ */ new WeakMap();
function ow(n, t) {
  if (!n.isAnonymous || t instanceof Ky || t.type != n)
    return 1;
  let e = iQ.get(t);
  if (e == null) {
    e = 1;
    for (let i of t.children) {
      if (i.type != n || !(i instanceof zt)) {
        e = 1;
        break;
      }
      e += ow(n, i);
    }
    iQ.set(t, e);
  }
  return e;
}
c(ow, "Dn$1");
f(ow, "nodeSize");
function Zb(n, t, e, i, s, r, a, o, l) {
  let h = 0;
  for (let g = i; g < s; g++)
    h += ow(n, t[g]);
  let u = Math.ceil(
    h * 1.5 / 8
    /* Balance.BranchFactor */
  ), p = [], y = [];
  function m(g, b, S, x, Q) {
    for (let L = S; L < x; ) {
      let W = L, R = b[L], I = ow(n, g[L]);
      for (L++; L < x; L++) {
        let V = ow(n, g[L]);
        if (I + V >= u)
          break;
        I += V;
      }
      if (L == W + 1) {
        if (I > u) {
          let V = g[W];
          m(V.children, V.positions, 0, V.children.length, b[W] + Q);
          continue;
        }
        p.push(g[W]);
      } else {
        let V = b[L - 1] + g[L - 1].length - R;
        p.push(Zb(n, g, b, W, L, R, V, null, l));
      }
      y.push(R + Q - r);
    }
  }
  return c(m, "d"), f(m, "divide"), m(t, e, i, s, 0), (o || l)(p, y, a);
}
c(Zb, "wh$1");
f(Zb, "balanceRange");
var Rd;
const cM = (Rd = class {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(t, e, i) {
    let s = this.map.get(t);
    s || this.map.set(t, s = /* @__PURE__ */ new Map()), s.set(e, i);
  }
  getBuffer(t, e) {
    let i = this.map.get(t);
    return i && i.get(e);
  }
  /**
  Set the value for this syntax node.
  */
  set(t, e) {
    t instanceof $w ? this.setBuffer(t.context.buffer, t.index, e) : t instanceof dn && this.map.set(t.tree, e);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(t) {
    return t instanceof $w ? this.getBuffer(t.context.buffer, t.index) : t instanceof dn ? this.map.get(t.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(t, e) {
    t.buffer ? this.setBuffer(t.buffer.buffer, t.index, e) : this.map.set(t.tree, e);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(t) {
    return t.buffer ? this.getBuffer(t.buffer.buffer, t.index) : this.map.get(t.tree);
  }
}, c(Rd, "rc"), Rd);
f(cM, "NodeWeakMap");
let hM = cM;
var Xr;
const dM = (Xr = class {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(t, e, i, s, r = !1, a = !1) {
    this.from = t, this.to = e, this.tree = i, this.offset = s, this.open = (r ? 1 : 0) | (a ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(t, e = [], i = !1) {
    let s = [new Xr(0, t.length, t, 0, !1, i)];
    for (let r of e)
      r.to > t.length && s.push(r);
    return s;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(t, e, i = 128) {
    if (!e.length)
      return t;
    let s = [], r = 1, a = t.length ? t[0] : null;
    for (let o = 0, l = 0, h = 0; ; o++) {
      let u = o < e.length ? e[o] : null, p = u ? u.fromA : 1e9;
      if (p - l >= i)
        for (; a && a.from < p; ) {
          let y = a;
          if (l >= y.from || p <= y.to || h) {
            let m = Math.max(y.from, l) - h, g = Math.min(y.to, p) - h;
            y = m >= g ? null : new Xr(m, g, y.tree, y.offset + h, o > 0, !!u);
          }
          if (y && s.push(y), a.to > p)
            break;
          a = r < t.length ? t[r++] : null;
        }
      if (!u)
        break;
      l = u.toA, h = u.toA - u.toB;
    }
    return s;
  }
}, c(Xr, "Yr"), Xr);
f(dM, "TreeFragment");
let yh = dM;
var Ed;
const uM = (Ed = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(t, e, i) {
    return typeof t == "string" && (t = new Cq(t)), i = i ? i.length ? i.map((s) => new on(s.from, s.to)) : [new on(0, 0)] : [new on(0, t.length)], this.createParse(t, e || [], i);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(t, e, i) {
    let s = this.startParse(t, e, i);
    for (; ; ) {
      let r = s.advance();
      if (r)
        return r;
    }
  }
}, c(Ed, "nc"), Ed);
f(uM, "Parser");
let Fb = uM;
var _d;
const pM = (_d = class {
  constructor(t) {
    this.string = t;
  }
  get length() {
    return this.string.length;
  }
  chunk(t) {
    return this.string.slice(t);
  }
  get lineChunks() {
    return !1;
  }
  read(t, e) {
    return this.string.slice(t, e);
  }
}, c(_d, "sc"), _d);
f(pM, "StringInput");
let Cq = pM;
function mC(n) {
  return (t, e, i, s) => new Qq(t, n, e, i, s);
}
c(mC, "Op$1");
f(mC, "parseMixed");
var zd;
const fM = (zd = class {
  constructor(t, e, i, s, r, a) {
    this.parser = t, this.parse = e, this.overlay = i, this.bracketed = s, this.target = r, this.from = a;
  }
}, c(zd, "oc"), zd);
f(fM, "InnerParse");
let nQ = fM;
function t5(n) {
  if (!n.length || n.some((t) => t.from >= t.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(n));
}
c(t5, "zu$1");
f(t5, "checkRanges");
var Ld;
const yM = (Ld = class {
  constructor(t, e, i, s, r, a, o, l) {
    this.parser = t, this.predicate = e, this.mounts = i, this.index = s, this.start = r, this.bracketed = a, this.target = o, this.prev = l, this.depth = 0, this.ranges = [];
  }
}, c(Ld, "lc"), Ld);
f(yM, "ActiveOverlay");
let Pq = yM;
const e5 = new Pt({ perNode: !0 });
var Id;
const mM = (Id = class {
  constructor(t, e, i, s, r) {
    this.nest = e, this.input = i, this.fragments = s, this.ranges = r, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = t;
  }
  advance() {
    if (this.baseParse) {
      let i = this.baseParse.advance();
      if (!i)
        return null;
      if (this.baseParse = null, this.baseTree = i, this.startInner(), this.stoppedAt != null)
        for (let s of this.inner)
          s.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let i = this.baseTree;
      return this.stoppedAt != null && (i = new zt(i.type, i.children, i.positions, i.length, i.propValues.concat([[e5, this.stoppedAt]]))), i;
    }
    let t = this.inner[this.innerDone], e = t.parse.advance();
    if (e) {
      this.innerDone++;
      let i = Object.assign(/* @__PURE__ */ Object.create(null), t.target.props);
      i[Pt.mounted.id] = new fh(e, t.overlay, t.parser, t.bracketed), t.target.props = i;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let t = this.input.length;
    for (let e = this.innerDone; e < this.inner.length; e++)
      this.inner[e].from < t && (t = Math.min(t, this.inner[e].parse.parsedPos));
    return t;
  }
  stopAt(t) {
    if (this.stoppedAt = t, this.baseParse)
      this.baseParse.stopAt(t);
    else
      for (let e = this.innerDone; e < this.inner.length; e++)
        this.inner[e].parse.stopAt(t);
  }
  startInner() {
    let t = new Tq(this.fragments), e = null, i = null, s = new SO(new dn(this.baseTree, this.ranges[0].from, 0, null), Zt.IncludeAnonymous | Zt.IgnoreMounts);
    t: for (let r, a; ; ) {
      let o = !0, l;
      if (this.stoppedAt != null && s.from >= this.stoppedAt)
        o = !1;
      else if (t.hasNode(s)) {
        if (e) {
          let h = e.mounts.find((u) => u.frag.from <= s.from && u.frag.to >= s.to && u.mount.overlay);
          if (h)
            for (let u of h.mount.overlay) {
              let p = u.from + h.pos, y = u.to + h.pos;
              p >= s.from && y <= s.to && !e.ranges.some((m) => m.from < y && m.to > p) && e.ranges.push({ from: p, to: y });
            }
        }
        o = !1;
      } else if (i && (a = gM(i.ranges, s.from, s.to)))
        o = a != 2;
      else if (!s.type.isAnonymous && (r = this.nest(s, this.input)) && (s.from < s.to || !r.overlay)) {
        s.tree || (wM(s), e && e.depth++, i && i.depth++);
        let h = t.findMounts(s.from, r.parser);
        if (typeof r.overlay == "function")
          e = new Pq(r.parser, r.overlay, h, this.inner.length, s.from, !!r.bracketed, s.tree, e);
        else {
          let u = n5(this.ranges, r.overlay || (s.from < s.to ? [new on(s.from, s.to)] : []));
          u.length && t5(u), (u.length || !r.overlay) && this.inner.push(new nQ(r.parser, u.length ? r.parser.startParse(this.input, s5(h, u), u) : r.parser.startParse(""), r.overlay ? r.overlay.map((p) => new on(p.from - s.from, p.to - s.from)) : null, !!r.bracketed, s.tree, u.length ? u[0].from : s.from)), r.overlay ? u.length && (i = { ranges: u, depth: 0, prev: i }) : o = !1;
        }
      } else if (e && (l = e.predicate(s)) && (l === !0 && (l = new on(s.from, s.to)), l.from < l.to)) {
        let h = e.ranges.length - 1;
        h >= 0 && e.ranges[h].to == l.from ? e.ranges[h] = { from: e.ranges[h].from, to: l.to } : e.ranges.push(l);
      }
      if (o && s.firstChild())
        e && e.depth++, i && i.depth++;
      else
        for (; !s.nextSibling(); ) {
          if (!s.parent())
            break t;
          if (e && !--e.depth) {
            let h = n5(this.ranges, e.ranges);
            h.length && (t5(h), this.inner.splice(e.index, 0, new nQ(e.parser, e.parser.startParse(this.input, s5(e.mounts, h), h), e.ranges.map((u) => new on(u.from - e.start, u.to - e.start)), e.bracketed, e.target, h[0].from))), e = e.prev;
          }
          i && !--i.depth && (i = i.prev);
        }
    }
  }
}, c(Id, "ac"), Id);
f(mM, "MixedParse");
let Qq = mM;
function gM(n, t, e) {
  for (let i of n) {
    if (i.from >= e)
      break;
    if (i.to > t)
      return i.from <= t && i.to >= e ? 2 : 1;
  }
  return 0;
}
c(gM, "U1$1");
f(gM, "checkCover");
function i5(n, t, e, i, s, r) {
  if (t < e) {
    let a = n.buffer[t + 1];
    i.push(n.slice(t, e, a)), s.push(a - r);
  }
}
c(i5, "ju$1");
f(i5, "sliceBuf");
function wM(n) {
  let { node: t } = n, e = [], i = t.context.buffer;
  do
    e.push(n.index), n.parent();
  while (!n.tree);
  let s = n.tree, r = s.children.indexOf(i), a = s.children[r], o = a.buffer, l = [r];
  function h(u, p, y, m, g, b) {
    let S = e[b], x = [], Q = [];
    i5(a, u, S, x, Q, m);
    let L = o[S + 1], W = o[S + 2];
    l.push(x.length);
    let R = b ? h(S + 4, o[S + 3], a.set.types[o[S]], L, W - L, b - 1) : t.toTree();
    return x.push(R), Q.push(L - m), i5(a, o[S + 3], p, x, Q, m), new zt(y, x, Q, g);
  }
  c(h, "h"), f(h, "split"), s.children[r] = h(0, o.length, Be.none, 0, a.length, e.length - 1);
  for (let u of l) {
    let p = n.tree.children[u], y = n.tree.positions[u];
    n.yield(new dn(p, y + n.from, u, n._tree));
  }
}
c(wM, "I1$1");
f(wM, "materialize");
var Wd;
const vM = (Wd = class {
  constructor(t, e) {
    this.offset = e, this.done = !1, this.cursor = t.cursor(Zt.IncludeAnonymous | Zt.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(t) {
    let { cursor: e } = this, i = t - this.offset;
    for (; !this.done && e.from < i; )
      e.to >= t && e.enter(i, 1, Zt.IgnoreOverlays | Zt.ExcludeBuffers) || e.next(!1) || (this.done = !0);
  }
  hasNode(t) {
    if (this.moveTo(t.from), !this.done && this.cursor.from + this.offset == t.from && this.cursor.tree)
      for (let e = this.cursor.tree; ; ) {
        if (e == t.tree)
          return !0;
        if (e.children.length && e.positions[0] == 0 && e.children[0] instanceof zt)
          e = e.children[0];
        else
          break;
      }
    return !1;
  }
}, c(Wd, "hc"), Wd);
f(vM, "StructureCursor");
let sQ = vM;
var l2, Vd;
let Tq = (l2 = (Vd = class {
  constructor(t) {
    var e;
    if (this.fragments = t, this.curTo = 0, this.fragI = 0, t.length) {
      let i = this.curFrag = t[0];
      this.curTo = (e = i.tree.prop(e5)) !== null && e !== void 0 ? e : i.to, this.inner = new sQ(i.tree, -i.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(t) {
    for (; this.curFrag && t.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= t.from && this.curTo >= t.to && this.inner.hasNode(t);
  }
  nextFrag() {
    var t;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let e = this.curFrag = this.fragments[this.fragI];
      this.curTo = (t = e.tree.prop(e5)) !== null && t !== void 0 ? t : e.to, this.inner = new sQ(e.tree, -e.offset);
    }
  }
  findMounts(t, e) {
    var i;
    let s = [];
    if (this.inner) {
      this.inner.cursor.moveTo(t, 1);
      for (let r = this.inner.cursor.node; r; r = r.parent) {
        let a = (i = r.tree) === null || i === void 0 ? void 0 : i.prop(Pt.mounted);
        if (a && a.parser == e)
          for (let o = this.fragI; o < this.fragments.length; o++) {
            let l = this.fragments[o];
            if (l.from >= r.to)
              break;
            l.tree == this.curFrag.tree && s.push({
              frag: l,
              pos: r.from - l.offset,
              mount: a
            });
          }
      }
    }
    return s;
  }
}, c(Vd, "vi$1"), Vd), f(l2, "FragmentCursor"), l2);
function n5(n, t) {
  let e = null, i = t;
  for (let s = 1, r = 0; s < n.length; s++) {
    let a = n[s - 1].to, o = n[s].from;
    for (; r < i.length; r++) {
      let l = i[r];
      if (l.from >= o)
        break;
      l.to <= a || (e || (i = e = t.slice()), l.from < a ? (e[r] = new on(l.from, a), l.to > o && e.splice(r + 1, 0, new on(o, l.to))) : l.to > o ? e[r--] = new on(o, l.to) : e.splice(r--, 1));
    }
  }
  return i;
}
c(n5, "qu$1");
f(n5, "punchRanges");
function OM(n, t, e, i) {
  let s = 0, r = 0, a = !1, o = !1, l = -1e9, h = [];
  for (; ; ) {
    let u = s == n.length ? 1e9 : a ? n[s].to : n[s].from, p = r == t.length ? 1e9 : o ? t[r].to : t[r].from;
    if (a != o) {
      let y = Math.max(l, e), m = Math.min(u, p, i);
      y < m && h.push(new on(y, m));
    }
    if (l = Math.min(u, p), l == 1e9)
      break;
    u == l && (a ? (a = !1, s++) : a = !0), p == l && (o ? (o = !1, r++) : o = !0);
  }
  return h;
}
c(OM, "j1$1");
f(OM, "findCoverChanges");
function s5(n, t) {
  let e = [];
  for (let { pos: i, mount: s, frag: r } of n) {
    let a = i + (s.overlay ? s.overlay[0].from : 0), o = a + s.tree.length, l = Math.max(r.from, a), h = Math.min(r.to, o);
    if (s.overlay) {
      let u = s.overlay.map((y) => new on(y.from + i, y.to + i)), p = OM(t, u, l, h);
      for (let y = 0, m = l; ; y++) {
        let g = y == p.length, b = g ? h : p[y].from;
        if (b > m && e.push(new yh(m, b, s.tree, -a, r.from >= m || r.openStart, r.to <= b || r.openEnd)), g)
          break;
        m = p[y].to;
      }
    } else
      e.push(new yh(l, h, s.tree, -a, r.from >= a || r.openStart, r.to <= o || r.openEnd));
  }
  return e;
}
c(s5, "Bu$1");
f(s5, "enterFragments");
let Mq = 0;
var Nr;
const bM = (Nr = class {
  /**
  @internal
  */
  constructor(t, e, i, s) {
    this.name = t, this.set = e, this.base = i, this.modified = s, this.id = Mq++;
  }
  toString() {
    let { name: t } = this;
    for (let e of this.modified)
      e.name && (t = `${e.name}(${t})`);
    return t;
  }
  static define(t, e) {
    let i = typeof t == "string" ? t : "?";
    if (t instanceof Nr && (e = t), e?.base)
      throw new Error("Can not derive from a modified tag");
    let s = new Nr(i, [], null, []);
    if (s.set.push(s), e)
      for (let r of e.set)
        s.set.push(r);
    return s;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(t) {
    let e = new rQ(t);
    return (i) => i.modified.indexOf(e) > -1 ? i : rQ.get(i.base || i, i.modified.concat(e).sort((s, r) => s.id - r.id));
  }
}, c(Nr, "Wr"), Nr);
f(bM, "Tag");
let Un = bM, Aq = 0;
var Lo;
const $M = (Lo = class {
  constructor(t) {
    this.name = t, this.instances = [], this.id = Aq++;
  }
  static get(t, e) {
    if (!e.length)
      return t;
    let i = e[0].instances.find((o) => o.base == t && xM(e, o.modified));
    if (i)
      return i;
    let s = [], r = new Un(t.name, s, t, e);
    for (let o of e)
      o.instances.push(r);
    let a = kM(e);
    for (let o of t.set)
      if (!o.modified.length)
        for (let l of a)
          s.push(Lo.get(o, l));
    return r;
  }
}, c(Lo, "ao"), Lo);
f($M, "Modifier");
let rQ = $M;
function xM(n, t) {
  return n.length == t.length && n.every((e, i) => e == t[i]);
}
c(xM, "D1$1");
f(xM, "sameArray");
function kM(n) {
  let t = [[]];
  for (let e = 0; e < n.length; e++)
    for (let i = 0, s = t.length; i < s; i++)
      t.push(t[i].concat(n[e]));
  return t.sort((e, i) => i.length - e.length);
}
c(kM, "N1$1");
f(kM, "powerSet");
function Ql(n) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let e in n) {
    let i = n[e];
    Array.isArray(i) || (i = [i]);
    for (let s of e.split(" "))
      if (s) {
        let r = [], a = 2, o = s;
        for (let p = 0; ; ) {
          if (o == "..." && p > 0 && p + 3 == s.length) {
            a = 1;
            break;
          }
          let y = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(o);
          if (!y)
            throw new RangeError("Invalid path: " + s);
          if (r.push(y[0] == "*" ? "" : y[0][0] == '"' ? JSON.parse(y[0]) : y[0]), p += y[0].length, p == s.length)
            break;
          let m = s[p++];
          if (p == s.length && m == "!") {
            a = 0;
            break;
          }
          if (m != "/")
            throw new RangeError("Invalid path: " + s);
          o = s.slice(p);
        }
        let l = r.length - 1, h = r[l];
        if (!h)
          throw new RangeError("Invalid path: " + s);
        let u = new xw(i, a, l > 0 ? r.slice(0, l) : null);
        t[h] = u.sort(t[h]);
      }
  }
  return SM.add(t);
}
c(Ql, "er$1");
f(Ql, "styleTags");
const SM = new Pt({
  combine(n, t) {
    let e, i, s;
    for (; n || t; ) {
      if (!n || t && n.depth >= t.depth ? (s = t, t = t.next) : (s = n, n = n.next), e && e.mode == s.mode && !s.context && !e.context)
        continue;
      let r = new xw(s.tags, s.mode, s.context);
      e ? e.next = r : i = r, e = r;
    }
    return i;
  }
});
var c2, Dd;
let xw = (c2 = (Dd = class {
  constructor(t, e, i, s) {
    this.tags = t, this.mode = e, this.context = i, this.next = s;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(t) {
    return !t || t.depth < this.depth ? (this.next = t, this) : (t.next = this.sort(t.next), t);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}, c(Dd, "Ti$1"), Dd), f(c2, "Rule"), c2);
xw.empty = new xw([], 2, null);
function gC(n, t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r of n)
    if (!Array.isArray(r.tag))
      e[r.tag.id] = r.class;
    else
      for (let a of r.tag)
        e[a.id] = r.class;
  let { scope: i, all: s = null } = t || {};
  return {
    style: /* @__PURE__ */ f((r) => {
      let a = s;
      for (let o of r)
        for (let l of o.set) {
          let h = e[l.id];
          if (h) {
            a = a ? a + " " + h : h;
            break;
          }
        }
      return a;
    }, "style"),
    scope: i
  };
}
c(gC, "pp");
f(gC, "tagHighlighter");
function CM(n, t) {
  let e = null;
  for (let i of n) {
    let s = i.style(t);
    s && (e = e ? e + " " + s : s);
  }
  return e;
}
c(CM, "G1$1");
f(CM, "highlightTags");
function PM(n, t, e, i = 0, s = n.length) {
  let r = new Rq(i, Array.isArray(t) ? t : [t], e);
  r.highlightRange(n.cursor(), i, s, "", r.highlighters), r.flush(s);
}
c(PM, "F1$1");
f(PM, "highlightTree");
var qd;
const QM = (qd = class {
  constructor(t, e, i) {
    this.at = t, this.highlighters = e, this.span = i, this.class = "";
  }
  startSpan(t, e) {
    e != this.class && (this.flush(t), t > this.at && (this.at = t), this.class = e);
  }
  flush(t) {
    t > this.at && this.class && this.span(this.at, t, this.class);
  }
  highlightRange(t, e, i, s, r) {
    let { type: a, from: o, to: l } = t;
    if (o >= i || l <= e)
      return;
    a.isTop && (r = this.highlighters.filter((m) => !m.scope || m.scope(a)));
    let h = s, u = TM(t) || xw.empty, p = CM(r, u.tags);
    if (p && (h && (h += " "), h += p, u.mode == 1 && (s += (s ? " " : "") + p)), this.startSpan(Math.max(e, o), h), u.opaque)
      return;
    let y = t.tree && t.tree.prop(Pt.mounted);
    if (y && y.overlay) {
      let m = t.node.enter(y.overlay[0].from + o, 1), g = this.highlighters.filter((S) => !S.scope || S.scope(y.tree.type)), b = t.firstChild();
      for (let S = 0, x = o; ; S++) {
        let Q = S < y.overlay.length ? y.overlay[S] : null, L = Q ? Q.from + o : l, W = Math.max(e, x), R = Math.min(i, L);
        if (W < R && b)
          for (; t.from < R && (this.highlightRange(t, W, R, s, r), this.startSpan(Math.min(R, t.to), h), !(t.to >= L || !t.nextSibling())); )
            ;
        if (!Q || L > i)
          break;
        x = Q.to + o, x > e && (this.highlightRange(m.cursor(), Math.max(e, Q.from + o), Math.min(i, x), "", g), this.startSpan(Math.min(i, x), h));
      }
      b && t.parent();
    } else if (t.firstChild()) {
      y && (s = "");
      do
        if (!(t.to <= e)) {
          if (t.from >= i)
            break;
          this.highlightRange(t, e, i, s, r), this.startSpan(Math.min(i, t.to), h);
        }
      while (t.nextSibling());
      t.parent();
    }
  }
}, c(qd, "fc"), qd);
f(QM, "HighlightBuilder");
let Rq = QM;
function TM(n) {
  let t = n.type.prop(SM);
  for (; t && t.context && !n.matchContext(t.context); )
    t = t.next;
  return t || null;
}
c(TM, "H1$1");
f(TM, "getStyleTags");
const tt = Un.define, H1 = tt(), $r = tt(), aQ = tt($r), oQ = tt($r), xr = tt(), Y1 = tt(xr), h2 = tt(xr), Xn = tt(), Ma = tt(Xn), Dn = tt(), qn = tt(), r5 = tt(), Xm = tt(r5), G1 = tt(), T = {
  /**
  A comment.
  */
  comment: H1,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: tt(H1),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: tt(H1),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: tt(H1),
  /**
  Any kind of identifier.
  */
  name: $r,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: tt($r),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: aQ,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: tt(aQ),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: oQ,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: tt(oQ),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: tt($r),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: tt($r),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: tt($r),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: tt($r),
  /**
  A literal value.
  */
  literal: xr,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Y1,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: tt(Y1),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: tt(Y1),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: tt(Y1),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: h2,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: tt(h2),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: tt(h2),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: tt(xr),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: tt(xr),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: tt(xr),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: tt(xr),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: tt(xr),
  /**
  A language keyword.
  */
  keyword: Dn,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: tt(Dn),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: tt(Dn),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: tt(Dn),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: tt(Dn),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: tt(Dn),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: tt(Dn),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: tt(Dn),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: tt(Dn),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: tt(Dn),
  /**
  An operator.
  */
  operator: qn,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: tt(qn),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: tt(qn),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: tt(qn),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: tt(qn),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: tt(qn),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: tt(qn),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: tt(qn),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: tt(qn),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: tt(qn),
  /**
  Program or markup punctuation.
  */
  punctuation: r5,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: tt(r5),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Xm,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: tt(Xm),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: tt(Xm),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: tt(Xm),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: tt(Xm),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Xn,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Ma,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: tt(Ma),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: tt(Ma),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: tt(Ma),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: tt(Ma),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: tt(Ma),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: tt(Ma),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: tt(Xn),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: tt(Xn),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: tt(Xn),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: tt(Xn),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: tt(Xn),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: tt(Xn),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: tt(Xn),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: tt(Xn),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: tt(),
  /**
  Deleted text.
  */
  deleted: tt(),
  /**
  Changed text.
  */
  changed: tt(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: tt(),
  /**
  Metadata or meta-instruction.
  */
  meta: G1,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: tt(G1),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: tt(G1),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: tt(G1),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Un.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Un.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Un.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Un.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Un.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Un.defineModifier("special")
};
for (let n in T) {
  let t = T[n];
  t instanceof Un && (t.name = n);
}
gC([
  { tag: T.link, class: "tok-link" },
  { tag: T.heading, class: "tok-heading" },
  { tag: T.emphasis, class: "tok-emphasis" },
  { tag: T.strong, class: "tok-strong" },
  { tag: T.keyword, class: "tok-keyword" },
  { tag: T.atom, class: "tok-atom" },
  { tag: T.bool, class: "tok-bool" },
  { tag: T.url, class: "tok-url" },
  { tag: T.labelName, class: "tok-labelName" },
  { tag: T.inserted, class: "tok-inserted" },
  { tag: T.deleted, class: "tok-deleted" },
  { tag: T.literal, class: "tok-literal" },
  { tag: T.string, class: "tok-string" },
  { tag: T.number, class: "tok-number" },
  { tag: [T.regexp, T.escape, T.special(T.string)], class: "tok-string2" },
  { tag: T.variableName, class: "tok-variableName" },
  { tag: T.local(T.variableName), class: "tok-variableName tok-local" },
  { tag: T.definition(T.variableName), class: "tok-variableName tok-definition" },
  { tag: T.special(T.variableName), class: "tok-variableName2" },
  { tag: T.definition(T.propertyName), class: "tok-propertyName tok-definition" },
  { tag: T.typeName, class: "tok-typeName" },
  { tag: T.namespace, class: "tok-namespace" },
  { tag: T.className, class: "tok-className" },
  { tag: T.macroName, class: "tok-macroName" },
  { tag: T.propertyName, class: "tok-propertyName" },
  { tag: T.operator, class: "tok-operator" },
  { tag: T.comment, class: "tok-comment" },
  { tag: T.meta, class: "tok-meta" },
  { tag: T.invalid, class: "tok-invalid" },
  { tag: T.punctuation, class: "tok-punctuation" }
]);
var d2;
const Qr = /* @__PURE__ */ new Pt();
function c1(n) {
  return bt.define({
    combine: n ? (t) => t.concat(n) : void 0
  });
}
c(c1, "wo$1");
f(c1, "defineLanguageFacet");
const wC = /* @__PURE__ */ new Pt();
var Zd;
const MM = (Zd = class {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(t, e, i = [], s = "") {
    this.data = t, this.name = s, Ie.prototype.hasOwnProperty("tree") || Object.defineProperty(Ie.prototype, "tree", { get() {
      return re(this);
    } }), this.parser = e, this.extension = [
      tm.of(this),
      Ie.languageData.of((r, a, o) => {
        let l = a5(r, a, o), h = l.type.prop(Qr);
        if (!h)
          return [];
        let u = r.facet(h), p = l.type.prop(wC);
        if (p) {
          let y = l.resolve(a - l.from, o);
          for (let m of p)
            if (m.test(y, r)) {
              let g = r.facet(m.facet);
              return m.type == "replace" ? g : g.concat(u);
            }
        }
        return u;
      })
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(t, e, i = -1) {
    return a5(t, e, i).type.prop(Qr) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(t) {
    let e = t.facet(tm);
    if (e?.data == this.data)
      return [{ from: 0, to: t.doc.length }];
    if (!e || !e.allowsNesting)
      return [];
    let i = [], s = /* @__PURE__ */ f((r, a) => {
      if (r.prop(Qr) == this.data) {
        i.push({ from: a, to: a + r.length });
        return;
      }
      let o = r.prop(Pt.mounted);
      if (o) {
        if (o.tree.prop(Qr) == this.data) {
          if (o.overlay)
            for (let l of o.overlay)
              i.push({ from: l.from + a, to: l.to + a });
          else
            i.push({ from: a, to: a + r.length });
          return;
        } else if (o.overlay) {
          let l = i.length;
          if (s(o.tree, o.overlay[0].from + a), i.length > l)
            return;
        }
      }
      for (let l = 0; l < r.children.length; l++) {
        let h = r.children[l];
        h instanceof zt && s(h, r.positions[l] + a);
      }
    }, "explore");
    return s(re(t), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}, c(Zd, "cc"), Zd);
f(MM, "Language");
let Hi = MM;
Hi.setState = /* @__PURE__ */ Bt.define();
function a5(n, t, e) {
  let i = n.facet(tm), s = re(n).topNode;
  if (!i || i.allowsNesting)
    for (let r = s; r; r = r.enter(t, e, Zt.ExcludeBuffers | Zt.EnterBracketed))
      r.type.isTop && (s = r);
  return s;
}
c(a5, "Gu$1");
f(a5, "topNodeAt");
var jr;
const AM = (jr = class extends Hi {
  constructor(t, e, i) {
    super(t, e, [], i), this.parser = e;
  }
  /**
  Define a language from a parser.
  */
  static define(t) {
    let e = c1(t.languageData);
    return new jr(e, t.parser.configure({
      props: [Qr.add((i) => i.isTop ? e : void 0)]
    }), t.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(t, e) {
    return new jr(this.data, this.parser.configure(t), e || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}, c(jr, "Vr"), jr);
f(AM, "LRLanguage");
let vC = AM;
function re(n) {
  let t = n.field(Hi.state, !1);
  return t ? t.tree : zt.empty;
}
c(re, "F$2");
f(re, "syntaxTree");
var Fd;
const RM = (Fd = class {
  /**
  Create an input object for the given document.
  */
  constructor(t) {
    this.doc = t, this.cursorPos = 0, this.string = "", this.cursor = t.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(t) {
    return this.string = this.cursor.next(t - this.cursorPos).value, this.cursorPos = t + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(t) {
    return this.syncTo(t), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(t, e) {
    let i = this.cursorPos - this.string.length;
    return t < i || e >= this.cursorPos ? this.doc.sliceString(t, e) : this.string.slice(t - i, e - i);
  }
}, c(Fd, "uc"), Fd);
f(RM, "DocInput");
let Eq = RM, Nm = null;
var Br;
const EM = (Br = class {
  constructor(t, e, i = [], s, r, a, o, l) {
    this.parser = t, this.state = e, this.fragments = i, this.tree = s, this.treeLen = r, this.viewport = a, this.skipped = o, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new Br(t, e, [], zt.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new Eq(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(t, e) {
    return e != null && e >= this.state.doc.length && (e = void 0), this.tree != zt.empty && this.isDone(e ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof t == "number") {
        let s = Date.now() + t;
        t = /* @__PURE__ */ f(() => Date.now() > s, "until");
      }
      for (this.parse || (this.parse = this.startParse()), e != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > e) && e < this.state.doc.length && this.parse.stopAt(e); ; ) {
        let s = this.parse.advance();
        if (s)
          if (this.fragments = this.withoutTempSkipped(yh.addTree(s, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = s, this.parse = null, this.treeLen < (e ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (t())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let t, e;
    this.parse && (t = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > t) && this.parse.stopAt(t), this.withContext(() => {
      for (; !(e = this.parse.advance()); )
        ;
    }), this.treeLen = t, this.tree = e, this.fragments = this.withoutTempSkipped(yh.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(t) {
    let e = Nm;
    Nm = this;
    try {
      return t();
    } finally {
      Nm = e;
    }
  }
  withoutTempSkipped(t) {
    for (let e; e = this.tempSkipped.pop(); )
      t = o5(t, e.from, e.to);
    return t;
  }
  /**
  @internal
  */
  changes(t, e) {
    let { fragments: i, tree: s, treeLen: r, viewport: a, skipped: o } = this;
    if (this.takeTree(), !t.empty) {
      let l = [];
      if (t.iterChangedRanges((h, u, p, y) => l.push({ fromA: h, toA: u, fromB: p, toB: y })), i = yh.applyChanges(i, l), s = zt.empty, r = 0, a = { from: t.mapPos(a.from, -1), to: t.mapPos(a.to, 1) }, this.skipped.length) {
        o = [];
        for (let h of this.skipped) {
          let u = t.mapPos(h.from, 1), p = t.mapPos(h.to, -1);
          u < p && o.push({ from: u, to: p });
        }
      }
    }
    return new Br(this.parser, e, i, s, r, a, o, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(t) {
    if (this.viewport.from == t.from && this.viewport.to == t.to)
      return !1;
    this.viewport = t;
    let e = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: s, to: r } = this.skipped[i];
      s < t.to && r > t.from && (this.fragments = o5(this.fragments, s, r), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= e ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(t, e) {
    this.skipped.push({ from: t, to: e });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(t) {
    return new class extends Fb {
      createParse(e, i, s) {
        let r = s[0].from, a = s[s.length - 1].to;
        return {
          parsedPos: r,
          advance() {
            let o = Nm;
            if (o) {
              for (let l of s)
                o.tempSkipped.push(l);
              t && (o.scheduleOn = o.scheduleOn ? Promise.all([o.scheduleOn, t]) : t);
            }
            return this.parsedPos = a, new zt(Be.none, [], [], a - r);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(t) {
    t = Math.min(t, this.state.doc.length);
    let e = this.fragments;
    return this.treeLen >= t && e.length && e[0].from == 0 && e[0].to >= t;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Nm;
  }
}, c(Br, "Ur"), Br);
f(EM, "ParseContext");
let CO = EM;
function o5(n, t, e) {
  return yh.applyChanges(n, [{ fromA: t, toA: e, fromB: t, toB: e }]);
}
c(o5, "Fu$1");
f(o5, "cutFragments");
var Ur;
const _M = (Ur = class {
  constructor(t) {
    this.context = t, this.tree = t.tree;
  }
  apply(t) {
    if (!t.docChanged && this.tree == this.context.tree)
      return this;
    let e = this.context.changes(t.changes, t.state), i = this.context.treeLen == t.startState.doc.length ? void 0 : Math.max(t.changes.mapPos(this.context.treeLen), e.viewport.to);
    return e.work(20, i) || e.takeTree(), new Ur(e);
  }
  static init(t) {
    let e = Math.min(3e3, t.doc.length), i = CO.create(t.facet(tm).parser, t, { from: 0, to: e });
    return i.work(20, e) || i.takeTree(), new Ur(i);
  }
}, c(Ur, "Ir"), Ur);
f(_M, "LanguageState");
let l5 = _M;
Hi.state = /* @__PURE__ */ rr.define({
  create: l5.init,
  update(n, t) {
    for (let e of t.effects)
      if (e.is(Hi.setState))
        return e.value;
    return t.startState.facet(tm) != t.state.facet(tm) ? l5.init(t.state) : n.apply(t);
  }
});
let zM = /* @__PURE__ */ f((n) => {
  let t = setTimeout(
    () => n(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(t);
}, "requestIdle");
typeof requestIdleCallback < "u" && (zM = /* @__PURE__ */ f((n) => {
  let t = -1, e = setTimeout(
    () => {
      t = requestIdleCallback(n, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => t < 0 ? clearTimeout(e) : cancelIdleCallback(t);
}, "requestIdle"));
const u2 = typeof navigator < "u" && !((d2 = navigator.scheduling) === null || d2 === void 0) && d2.isInputPending ? () => navigator.scheduling.isInputPending() : null;
var p2, Xd;
const _q = /* @__PURE__ */ Us.fromClass((p2 = (Xd = class {
  constructor(t) {
    this.view = t, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(t) {
    let e = this.view.state.field(Hi.state).context;
    (e.updateViewport(t.view.viewport) || this.view.viewport.to > e.treeLen) && this.scheduleWork(), (t.docChanged || t.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(e);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: t } = this.view, e = t.field(Hi.state);
    (e.tree != e.context.tree || !e.context.isDone(t.doc.length)) && (this.working = zM(this.work));
  }
  work(t) {
    this.working = null;
    let e = Date.now();
    if (this.chunkEnd < e && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = e + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: s } } = this.view, r = i.field(Hi.state);
    if (r.tree == r.context.tree && r.context.isDone(
      s + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let a = Date.now() + Math.min(this.chunkBudget, 100, t && !u2 ? Math.max(25, t.timeRemaining() - 5) : 1e9), o = r.context.treeLen < s && i.doc.length > s + 1e3, l = r.context.work(() => u2 && u2() || Date.now() > a, s + (o ? 0 : 1e5));
    this.chunkBudget -= Date.now() - e, (l || this.chunkBudget <= 0) && (r.context.takeTree(), this.view.dispatch({ effects: Hi.setState.of(new l5(r.context)) })), this.chunkBudget > 0 && !(l && !o) && this.scheduleWork(), this.checkAsyncSchedule(r.context);
  }
  checkAsyncSchedule(t) {
    t.scheduleOn && (this.workScheduled++, t.scheduleOn.then(() => this.scheduleWork()).catch((e) => Qi(this.view.state, e)).then(() => this.workScheduled--), t.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, c(Xd, "Ai$1"), Xd), f(p2, "ParseWorker"), p2), {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), tm = /* @__PURE__ */ bt.define({
  combine(n) {
    return n.length ? n[0] : null;
  },
  enables: /* @__PURE__ */ f((n) => [
    Hi.state,
    _q,
    kt.contentAttributes.compute([n], (t) => {
      let e = t.facet(n);
      return e && e.name ? { "data-language": e.name } : {};
    })
  ], "enables")
});
var Nd;
const LM = (Nd = class {
  /**
  Create a language support object.
  */
  constructor(t, e = []) {
    this.language = t, this.support = e, this.extension = [t, e];
  }
}, c(Nd, "Oc"), Nd);
f(LM, "LanguageSupport");
let em = LM;
var Io;
const IM = (Io = class {
  constructor(t, e, i, s, r, a = void 0) {
    this.name = t, this.alias = e, this.extensions = i, this.filename = s, this.loadFunc = r, this.support = a, this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return this.loading || (this.loading = this.loadFunc().then((t) => this.support = t, (t) => {
      throw this.loading = null, t;
    }));
  }
  /**
  Create a language description.
  */
  static of(t) {
    let { load: e, support: i } = t;
    if (!e) {
      if (!i)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      e = /* @__PURE__ */ f(() => Promise.resolve(i), "load");
    }
    return new Io(t.name, (t.alias || []).concat(t.name).map((s) => s.toLowerCase()), t.extensions || [], t.filename, e, i);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(t, e) {
    for (let s of t)
      if (s.filename && s.filename.test(e))
        return s;
    let i = /\.([^.]+)$/.exec(e);
    if (i) {
      for (let s of t)
        if (s.extensions.indexOf(i[1]) > -1)
          return s;
    }
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(t, e, i = !0) {
    e = e.toLowerCase();
    for (let s of t)
      if (s.alias.some((r) => r == e))
        return s;
    if (i)
      for (let s of t)
        for (let r of s.alias) {
          let a = e.indexOf(r);
          if (a > -1 && (r.length > 2 || !/\w/.test(e[a - 1]) && !/\w/.test(e[a + r.length])))
            return s;
        }
    return null;
  }
}, c(Io, "ho"), Io);
f(IM, "LanguageDescription");
let lQ = IM;
const zq = /* @__PURE__ */ bt.define(), Xb = /* @__PURE__ */ bt.define({
  combine: /* @__PURE__ */ f((n) => {
    if (!n.length)
      return "  ";
    let t = n[0];
    if (!t || /\S/.test(t) || Array.from(t).some((e) => e != t[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(n[0]));
    return t;
  }, "combine")
});
function kw(n) {
  let t = n.facet(Xb);
  return t.charCodeAt(0) == 9 ? n.tabSize * t.length : t.length;
}
c(kw, "li$1");
f(kw, "getIndentUnit");
function c5(n, t) {
  let e = "", i = n.tabSize, s = n.facet(Xb)[0];
  if (s == "	") {
    for (; t >= i; )
      e += "	", t -= i;
    s = " ";
  }
  for (let r = 0; r < t; r++)
    e += s;
  return e;
}
c(c5, "Qs$1");
f(c5, "indentString");
function WM(n, t) {
  n instanceof Ie && (n = new OC(n));
  for (let i of n.state.facet(zq)) {
    let s = i(n, t);
    if (s !== void 0)
      return s;
  }
  let e = re(n.state);
  return e.length >= t ? DM(n, e, t) : null;
}
c(WM, "gp");
f(WM, "getIndentation");
var jd;
const VM = (jd = class {
  /**
  Create an indent context.
  */
  constructor(t, e = {}) {
    this.state = t, this.options = e, this.unit = kw(t);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(t, e = 1) {
    let i = this.state.doc.lineAt(t), { simulateBreak: s, simulateDoubleBreak: r } = this.options;
    return s != null && s >= i.from && s <= i.to ? r && s == t ? { text: "", from: t } : (e < 0 ? s < t : s <= t) ? { text: i.text.slice(s - i.from), from: s } : { text: i.text.slice(0, s - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(t, e = 1) {
    if (this.options.simulateDoubleBreak && t == this.options.simulateBreak)
      return "";
    let { text: i, from: s } = this.lineAt(t, e);
    return i.slice(t - s, Math.min(i.length, t + 100 - s));
  }
  /**
  Find the column for the given position.
  */
  column(t, e = 1) {
    let { text: i, from: s } = this.lineAt(t, e), r = this.countColumn(i, t - s), a = this.options.overrideIndentation ? this.options.overrideIndentation(s) : -1;
    return a > -1 && (r += a - this.countColumn(i, i.search(/\S|$/))), r;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(t, e = t.length) {
    return ea(t, this.state.tabSize, e);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(t, e = 1) {
    let { text: i, from: s } = this.lineAt(t, e), r = this.options.overrideIndentation;
    if (r) {
      let a = r(s);
      if (a > -1)
        return a;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}, c(jd, "dc"), jd);
f(VM, "IndentContext");
let OC = VM;
const km = /* @__PURE__ */ new Pt();
function DM(n, t, e) {
  let i = t.resolveStack(e), s = t.resolveInner(e, -1).resolve(e, 0).enterUnfinishedNodesBefore(e);
  if (s != i.node) {
    let r = [];
    for (let a = s; a && !(a.from < i.node.from || a.to > i.node.to || a.from == i.node.from && a.type == i.node.type); a = a.parent)
      r.push(a);
    for (let a = r.length - 1; a >= 0; a--)
      i = { node: r[a], next: i };
  }
  return bC(i, n, e);
}
c(DM, "eQ");
f(DM, "syntaxIndentation");
function bC(n, t, e) {
  for (let i = n; i; i = i.next) {
    let s = ZM(i.node);
    if (s)
      return s(Lq.create(t, e, i));
  }
  return 0;
}
c(bC, "Qp$1");
f(bC, "indentFor");
function qM(n) {
  return n.pos == n.options.simulateBreak && n.options.simulateDoubleBreak;
}
c(qM, "tQ");
f(qM, "ignoreClosed");
function ZM(n) {
  let t = n.type.prop(km);
  if (t)
    return t;
  let e = n.firstChild, i;
  if (e && (i = e.type.prop(Pt.closedBy))) {
    let s = n.lastChild, r = s && i.indexOf(s.name) > -1;
    return (a) => $C(a, !0, 1, void 0, r && !qM(a) ? s.from : void 0);
  }
  return n.parent == null ? FM : null;
}
c(ZM, "iQ");
f(ZM, "indentStrategy");
function FM() {
  return 0;
}
c(FM, "rQ");
f(FM, "topIndent");
var Wo;
const XM = (Wo = class extends OC {
  constructor(t, e, i) {
    super(t.state, t.options), this.base = t, this.pos = e, this.context = i;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new Wo(t, e, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(t) {
    let e = this.state.doc.lineAt(t.from);
    for (; ; ) {
      let i = t.resolve(e.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (NM(i, t))
        break;
      e = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(e.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return bC(this.context.next, this.base, this.pos);
  }
}, c(Wo, "fo"), Wo);
f(XM, "TreeIndentContext");
let Lq = XM;
function NM(n, t) {
  for (let e = t; e; e = e.parent)
    if (n == e)
      return !0;
  return !1;
}
c(NM, "nQ");
f(NM, "isParent");
function jM(n) {
  let t = n.node, e = t.childAfter(t.from), i = t.lastChild;
  if (!e)
    return null;
  let s = n.options.simulateBreak, r = n.state.doc.lineAt(e.from), a = s == null || s <= r.from ? r.to : Math.min(r.to, s);
  for (let o = e.to; ; ) {
    let l = t.childAfter(o);
    if (!l || l == i)
      return null;
    if (!l.type.isSkipped) {
      if (l.from >= a)
        return null;
      let h = /^ */.exec(r.text.slice(e.to - r.from))[0].length;
      return { from: e.from, to: e.to + h };
    }
    o = l.to;
  }
}
c(jM, "sQ");
f(jM, "bracketedAligned");
function BM({ closing: n, align: t = !0, units: e = 1 }) {
  return (i) => $C(i, t, e, n);
}
c(BM, "oQ");
f(BM, "delimitedIndent");
function $C(n, t, e, i, s) {
  let r = n.textAfter, a = r.match(/^\s*/)[0].length, o = i && r.slice(a, a + i.length) == i || s == n.pos + a, l = t ? jM(n) : null;
  return l ? o ? n.column(l.from) : n.column(l.to) : n.baseIndent + (o ? 0 : n.unit * e);
}
c($C, "yp");
f($C, "delimitedStrategy");
const Iq = /* @__PURE__ */ f((n) => n.baseIndent, "flatIndent");
function lw({ except: n, units: t = 1 } = {}) {
  return (e) => {
    let i = n && n.test(e.textAfter);
    return e.baseIndent + (i ? 0 : t * e.unit);
  };
}
c(lw, "Nn$1");
f(lw, "continuedIndent");
const Wq = /* @__PURE__ */ bt.define(), h1 = /* @__PURE__ */ new Pt();
function xC(n) {
  let t = n.firstChild, e = n.lastChild;
  return t && t.to < e.from ? { from: t.to, to: e.type.isError ? n.to : e.from } : null;
}
c(xC, "Sp$1");
f(xC, "foldInside");
var Vo;
const UM = (Vo = class {
  constructor(t, e) {
    this.specs = t;
    let i;
    function s(o) {
      let l = ia.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + l] = o, l;
    }
    c(s, "n"), f(s, "def");
    const r = typeof e.all == "string" ? e.all : e.all ? s(e.all) : void 0, a = e.scope;
    this.scope = a instanceof Hi ? (o) => o.prop(Qr) == a.data : a ? (o) => o == a : void 0, this.style = gC(t.map((o) => ({
      tag: o.tag,
      class: o.class || s(Object.assign({}, o, { tag: null }))
    })), {
      all: r
    }).style, this.module = i ? new ia(i) : null, this.themeType = e.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(t, e) {
    return new Vo(t, e || {});
  }
}, c(Vo, "co"), Vo);
f(UM, "HighlightStyle");
let HM = UM;
const h5 = /* @__PURE__ */ bt.define(), YM = /* @__PURE__ */ bt.define({
  combine(n) {
    return n.length ? [n[0]] : null;
  }
});
function Ov(n) {
  let t = n.facet(h5);
  return t.length ? t : n.facet(YM);
}
c(Ov, "Wo$1");
f(Ov, "getHighlighters");
function Vq(n, t) {
  let e = [qq], i;
  return n instanceof HM && (n.module && e.push(kt.styleModule.of(n.module)), i = n.themeType), t?.fallback ? e.push(YM.of(n)) : i ? e.push(h5.computeN([kt.darkTheme], (s) => s.facet(kt.darkTheme) == (i == "dark") ? [n] : [])) : e.push(h5.of(n)), e;
}
c(Vq, "hQ");
f(Vq, "syntaxHighlighting");
var Bd;
const GM = (Bd = class {
  constructor(t) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = re(t.state), this.decorations = this.buildDeco(t, Ov(t.state)), this.decoratedTo = t.viewport.to;
  }
  update(t) {
    let e = re(t.state), i = Ov(t.state), s = i != Ov(t.startState), { viewport: r } = t.view, a = t.changes.mapPos(this.decoratedTo, 1);
    e.length < r.to && !s && e.type == this.tree.type && a >= r.to ? (this.decorations = this.decorations.map(t.changes), this.decoratedTo = a) : (e != this.tree || t.viewportChanged || s) && (this.tree = e, this.decorations = this.buildDeco(t.view, i), this.decoratedTo = r.to);
  }
  buildDeco(t, e) {
    if (!e || !this.tree.length)
      return Gt.none;
    let i = new uO();
    for (let { from: s, to: r } of t.visibleRanges)
      PM(this.tree, e, (a, o, l) => {
        i.add(a, o, this.markCache[l] || (this.markCache[l] = Gt.mark({ class: l })));
      }, s, r);
    return i.finish();
  }
}, c(Bd, "pc"), Bd);
f(GM, "TreeHighlighter");
let Dq = GM;
const qq = /* @__PURE__ */ Cl.high(/* @__PURE__ */ Us.fromClass(Dq, {
  decorations: /* @__PURE__ */ f((n) => n.decorations, "decorations")
})), Zq = 1e4, Fq = "()[]{}", KM = /* @__PURE__ */ new Pt();
function PO(n, t, e) {
  let i = n.prop(t < 0 ? Pt.openedBy : Pt.closedBy);
  if (i)
    return i;
  if (n.name.length == 1) {
    let s = e.indexOf(n.name);
    if (s > -1 && s % 2 == (t < 0 ? 1 : 0))
      return [e[s + t]];
  }
  return null;
}
c(PO, "wa$1");
f(PO, "matchingNodes");
function QO(n) {
  let t = n.type.prop(KM);
  return t ? t(n.node) : n;
}
c(QO, "xa$1");
f(QO, "findHandle");
function Ga(n, t, e, i = {}) {
  let s = i.maxScanDistance || Zq, r = i.brackets || Fq, a = re(n), o = a.resolveInner(t, e);
  for (let l = o; l; l = l.parent) {
    let h = PO(l.type, e, r);
    if (h && l.from < l.to) {
      let u = QO(l);
      if (u && (e > 0 ? t >= u.from && t < u.to : t > u.from && t <= u.to))
        return JM(n, t, e, l, u, h, r);
    }
  }
  return tA(n, t, e, a, o.type, s, r);
}
c(Ga, "pi$1");
f(Ga, "matchBrackets");
function JM(n, t, e, i, s, r, a) {
  let o = i.parent, l = { from: s.from, to: s.to }, h = 0, u = o?.cursor();
  if (u && (e < 0 ? u.childBefore(i.from) : u.childAfter(i.to)))
    do
      if (e < 0 ? u.to <= i.from : u.from >= i.to) {
        if (h == 0 && r.indexOf(u.type.name) > -1 && u.from < u.to) {
          let p = QO(u);
          return { start: l, end: p ? { from: p.from, to: p.to } : void 0, matched: !0 };
        } else if (PO(u.type, e, a))
          h++;
        else if (PO(u.type, -e, a)) {
          if (h == 0) {
            let p = QO(u);
            return {
              start: l,
              end: p && p.from < p.to ? { from: p.from, to: p.to } : void 0,
              matched: !1
            };
          }
          h--;
        }
      }
    while (e < 0 ? u.prevSibling() : u.nextSibling());
  return { start: l, matched: !1 };
}
c(JM, "OQ");
f(JM, "matchMarkedBrackets");
function tA(n, t, e, i, s, r, a) {
  let o = e < 0 ? n.sliceDoc(t - 1, t) : n.sliceDoc(t, t + 1), l = a.indexOf(o);
  if (l < 0 || l % 2 == 0 != e > 0)
    return null;
  let h = { from: e < 0 ? t - 1 : t, to: e > 0 ? t + 1 : t }, u = n.doc.iterRange(t, e > 0 ? n.doc.length : 0), p = 0;
  for (let y = 0; !u.next().done && y <= r; ) {
    let m = u.value;
    e < 0 && (y += m.length);
    let g = t + y * e;
    for (let b = e > 0 ? 0 : m.length - 1, S = e > 0 ? m.length : -1; b != S; b += e) {
      let x = a.indexOf(m[b]);
      if (!(x < 0 || i.resolveInner(g + b, 1).type != s))
        if (x % 2 == 0 == e > 0)
          p++;
        else {
          if (p == 1)
            return { start: h, end: { from: g + b, to: g + b + 1 }, matched: x >> 1 == l >> 1 };
          p--;
        }
    }
    e > 0 && (y += m.length);
  }
  return u.done ? { start: h, matched: !1 } : null;
}
c(tA, "dQ");
f(tA, "matchPlainBrackets");
function d5(n, t, e, i = 0, s = 0) {
  t == null && (t = n.search(/[^\s\u00a0]/), t == -1 && (t = n.length));
  let r = s;
  for (let a = i; a < t; a++)
    n.charCodeAt(a) == 9 ? r += e - r % e : r++;
  return r;
}
c(d5, "Hu$1");
f(d5, "countCol");
var Ud;
const eA = (Ud = class {
  /**
  Create a stream.
  */
  constructor(t, e, i, s) {
    this.string = t, this.tabSize = e, this.indentUnit = i, this.overrideIndent = s, this.pos = 0, this.start = 0, this.lastColumnPos = 0, this.lastColumnValue = 0;
  }
  /**
  True if we are at the end of the line.
  */
  eol() {
    return this.pos >= this.string.length;
  }
  /**
  True if we are at the start of the line.
  */
  sol() {
    return this.pos == 0;
  }
  /**
  Get the next code unit after the current position, or undefined
  if we're at the end of the line.
  */
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  /**
  Read the next code unit and advance `this.pos`.
  */
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  /**
  Match the next character against the given string, regular
  expression, or predicate. Consume and return it if it matches.
  */
  eat(t) {
    let e = this.string.charAt(this.pos), i;
    if (typeof t == "string" ? i = e == t : i = e && (t instanceof RegExp ? t.test(e) : t(e)), i)
      return ++this.pos, e;
  }
  /**
  Continue matching characters that match the given string,
  regular expression, or predicate function. Return true if any
  characters were consumed.
  */
  eatWhile(t) {
    let e = this.pos;
    for (; this.eat(t); )
      ;
    return this.pos > e;
  }
  /**
  Consume whitespace ahead of `this.pos`. Return true if any was
  found.
  */
  eatSpace() {
    let t = this.pos;
    for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
      ++this.pos;
    return this.pos > t;
  }
  /**
  Move to the end of the line.
  */
  skipToEnd() {
    this.pos = this.string.length;
  }
  /**
  Move to directly before the given character, if found on the
  current line.
  */
  skipTo(t) {
    let e = this.string.indexOf(t, this.pos);
    if (e > -1)
      return this.pos = e, !0;
  }
  /**
  Move back `n` characters.
  */
  backUp(t) {
    this.pos -= t;
  }
  /**
  Get the column position at `this.pos`.
  */
  column() {
    return this.lastColumnPos < this.start && (this.lastColumnValue = d5(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue;
  }
  /**
  Get the indentation column of the current line.
  */
  indentation() {
    var t;
    return (t = this.overrideIndent) !== null && t !== void 0 ? t : d5(this.string, null, this.tabSize);
  }
  /**
  Match the input against the given string or regular expression
  (which should start with a `^`). Return true or the regexp match
  if it matches.
  
  Unless `consume` is set to `false`, this will move `this.pos`
  past the matched text.
  
  When matching a string `caseInsensitive` can be set to true to
  make the match case-insensitive.
  */
  match(t, e, i) {
    if (typeof t == "string") {
      let s = /* @__PURE__ */ f((a) => i ? a.toLowerCase() : a, "cased"), r = this.string.substr(this.pos, t.length);
      return s(r) == s(t) ? (e !== !1 && (this.pos += t.length), !0) : null;
    } else {
      let s = this.string.slice(this.pos).match(t);
      return s && s.index > 0 ? null : (s && e !== !1 && (this.pos += s[0].length), s);
    }
  }
  /**
  Get the current token.
  */
  current() {
    return this.string.slice(this.start, this.pos);
  }
}, c(Ud, "mc"), Ud);
f(eA, "StringStream");
let iA = eA;
function nA(n) {
  return {
    name: n.name || "",
    token: n.token,
    blankLine: n.blankLine || (() => {
    }),
    startState: n.startState || (() => !0),
    copyState: n.copyState || sA,
    indent: n.indent || (() => null),
    languageData: n.languageData || {},
    tokenTable: n.tokenTable || CC,
    mergeTokens: n.mergeTokens !== !1
  };
}
c(nA, "pQ");
f(nA, "fullParser");
function sA(n) {
  if (typeof n != "object")
    return n;
  let t = {};
  for (let e in n) {
    let i = n[e];
    t[e] = i instanceof Array ? i.slice() : i;
  }
  return t;
}
c(sA, "mQ");
f(sA, "defaultCopyState");
const cQ = /* @__PURE__ */ new WeakMap();
var Do;
const rA = (Do = class extends Hi {
  constructor(t) {
    let e = c1(t.languageData), i = nA(t), s, r = new class extends Fb {
      createParse(a, o, l) {
        return new Nq(s, a, o, l);
      }
    }();
    super(e, r, [], t.name), this.topNode = hA(e, this), s = this, this.streamParser = i, this.stateAfter = new Pt({ perNode: !0 }), this.tokenTable = t.tokenTable ? new cA(i.tokenTable) : Bq;
  }
  /**
  Define a stream language.
  */
  static define(t) {
    return new Do(t);
  }
  /**
  @internal
  */
  getIndent(t) {
    let e, { overrideIndentation: i } = t.options;
    i && (e = cQ.get(t.state), e != null && e < t.pos - 1e4 && (e = void 0));
    let s = Nb(this, t.node.tree, t.node.from, t.node.from, e ?? t.pos), r, a;
    if (s ? (a = s.state, r = s.pos + 1) : (a = this.streamParser.startState(t.unit), r = t.node.from), t.pos - r > 1e4)
      return null;
    for (; r < t.pos; ) {
      let l = t.state.doc.lineAt(r), h = Math.min(t.pos, l.to);
      if (l.length) {
        let u = i ? i(l.from) : -1, p = new iA(l.text, t.state.tabSize, t.unit, u < 0 ? void 0 : u);
        for (; p.pos < h - l.from; )
          SC(this.streamParser.token, p, a);
      } else
        this.streamParser.blankLine(a, t.unit);
      if (h == t.pos)
        break;
      r = l.to + 1;
    }
    let o = t.lineAt(t.pos);
    return i && e == null && cQ.set(t.state, o.from), this.streamParser.indent(a, /^\s*(.*)/.exec(o.text)[1], t);
  }
  get allowsNesting() {
    return !1;
  }
}, c(Do, "uo"), Do);
f(rA, "StreamLanguage");
let Xq = rA;
function Nb(n, t, e, i, s) {
  let r = e >= i && e + t.length <= s && t.prop(n.stateAfter);
  if (r)
    return { state: n.streamParser.copyState(r), pos: e + t.length };
  for (let a = t.children.length - 1; a >= 0; a--) {
    let o = t.children[a], l = e + t.positions[a], h = o instanceof zt && l < s && Nb(n, o, l, i, s);
    if (h)
      return h;
  }
  return null;
}
c(Nb, "kh$1");
f(Nb, "findState");
function kC(n, t, e, i, s) {
  if (s && e <= 0 && i >= t.length)
    return t;
  !s && e == 0 && t.type == n.topNode && (s = !0);
  for (let r = t.children.length - 1; r >= 0; r--) {
    let a = t.positions[r], o = t.children[r], l;
    if (a < i && o instanceof zt) {
      if (!(l = kC(n, o, e - a, i - a, s)))
        break;
      return s ? new zt(t.type, t.children.slice(0, r).concat(l), t.positions.slice(0, r + 1), a + l.length) : l;
    }
  }
  return null;
}
c(kC, "xp");
f(kC, "cutTree");
function aA(n, t, e, i, s) {
  for (let r of t) {
    let a = r.from + (r.openStart ? 25 : 0), o = r.to - (r.openEnd ? 25 : 0), l = a <= e && o > e && Nb(n, r.tree, 0 - r.offset, e, o), h;
    if (l && l.pos <= i && (h = kC(n, r.tree, e + r.offset, l.pos + r.offset, !1)))
      return { state: l.state, tree: h };
  }
  return { state: n.streamParser.startState(s ? kw(s) : 4), tree: zt.empty };
}
c(aA, "gQ");
f(aA, "findStartInFragments");
var f2, Hd;
let Nq = (f2 = (Hd = class {
  constructor(t, e, i, s) {
    this.lang = t, this.input = e, this.fragments = i, this.ranges = s, this.stoppedAt = null, this.chunks = [], this.chunkPos = [], this.chunk = [], this.chunkReused = void 0, this.rangeIndex = 0, this.to = s[s.length - 1].to;
    let r = CO.get(), a = s[0].from, { state: o, tree: l } = aA(t, i, a, this.to, r?.state);
    this.state = o, this.parsedPos = this.chunkStart = a + l.length;
    for (let h = 0; h < l.children.length; h++)
      this.chunks.push(l.children[h]), this.chunkPos.push(l.positions[h]);
    r && this.parsedPos < r.viewport.from - 1e5 && s.some((h) => h.from <= r.viewport.from && h.to >= r.viewport.from) && (this.state = this.lang.streamParser.startState(kw(r.state)), r.skipUntilInView(this.parsedPos, r.viewport.from), this.parsedPos = r.viewport.from), this.moveRangeIndex();
  }
  advance() {
    let t = CO.get(), e = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt), i = Math.min(
      e,
      this.chunkStart + 512
      /* C.ChunkSize */
    );
    for (t && (i = Math.min(i, t.viewport.to)); this.parsedPos < i; )
      this.parseLine(t);
    return this.chunkStart < this.parsedPos && this.finishChunk(), this.parsedPos >= e ? this.finish() : t && this.parsedPos >= t.viewport.to ? (t.skipUntilInView(this.parsedPos, e), this.finish()) : null;
  }
  stopAt(t) {
    this.stoppedAt = t;
  }
  lineAfter(t) {
    let e = this.input.chunk(t);
    if (this.input.lineChunks)
      e == `
` && (e = "");
    else {
      let i = e.indexOf(`
`);
      i > -1 && (e = e.slice(0, i));
    }
    return t + e.length <= this.to ? e : e.slice(0, this.to - t);
  }
  nextLine() {
    let t = this.parsedPos, e = this.lineAfter(t), i = t + e.length;
    for (let s = this.rangeIndex; ; ) {
      let r = this.ranges[s].to;
      if (r >= i || (e = e.slice(0, r - (i - e.length)), s++, s == this.ranges.length))
        break;
      let a = this.ranges[s].from, o = this.lineAfter(a);
      e += o, i = a + o.length;
    }
    return { line: e, end: i };
  }
  skipGapsTo(t, e, i) {
    for (; ; ) {
      let s = this.ranges[this.rangeIndex].to, r = t + e;
      if (i > 0 ? s > r : s >= r)
        break;
      let a = this.ranges[++this.rangeIndex].from;
      e += a - s;
    }
    return e;
  }
  moveRangeIndex() {
    for (; this.ranges[this.rangeIndex].to < this.parsedPos; )
      this.rangeIndex++;
  }
  emitToken(t, e, i, s) {
    let r = 4;
    if (this.ranges.length > 1) {
      s = this.skipGapsTo(e, s, 1), e += s;
      let o = this.chunk.length;
      s = this.skipGapsTo(i, s, -1), i += s, r += this.chunk.length - o;
    }
    let a = this.chunk.length - 4;
    return this.lang.streamParser.mergeTokens && r == 4 && a >= 0 && this.chunk[a] == t && this.chunk[a + 2] == e ? this.chunk[a + 2] = i : this.chunk.push(t, e, i, r), s;
  }
  parseLine(t) {
    let { line: e, end: i } = this.nextLine(), s = 0, { streamParser: r } = this.lang, a = new iA(e, t ? t.state.tabSize : 4, t ? kw(t.state) : 2);
    if (a.eol())
      r.blankLine(this.state, a.indentUnit);
    else
      for (; !a.eol(); ) {
        let o = SC(r.token, a, this.state);
        if (o && (s = this.emitToken(this.lang.tokenTable.resolve(o), this.parsedPos + a.start, this.parsedPos + a.pos, s)), a.start > 1e4)
          break;
      }
    this.parsedPos = i, this.moveRangeIndex(), this.parsedPos < this.to && this.parsedPos++;
  }
  finishChunk() {
    let t = zt.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet: jq,
      topID: 0,
      maxBufferLength: 512,
      reused: this.chunkReused
    });
    t = new zt(t.type, t.children, t.positions, t.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]), this.chunks.push(t), this.chunkPos.push(this.chunkStart - this.ranges[0].from), this.chunk = [], this.chunkReused = void 0, this.chunkStart = this.parsedPos;
  }
  finish() {
    return new zt(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
}, c(Hd, "Li"), Hd), f(f2, "Parse"), f2);
function SC(n, t, e) {
  t.start = t.pos;
  for (let i = 0; i < 10; i++) {
    let s = n(t, e);
    if (t.pos > t.start)
      return s;
  }
  throw new Error("Stream parser failed to advance stream.");
}
c(SC, "kp");
f(SC, "readToken$1");
const CC = /* @__PURE__ */ Object.create(null), Sw = [Be.none], jq = /* @__PURE__ */ new Db(Sw), hQ = [], dQ = /* @__PURE__ */ Object.create(null), oA = /* @__PURE__ */ Object.create(null);
for (let [n, t] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  oA[n] = /* @__PURE__ */ PC(CC, t);
var Yd;
const lA = (Yd = class {
  constructor(t) {
    this.extra = t, this.table = Object.assign(/* @__PURE__ */ Object.create(null), oA);
  }
  resolve(t) {
    return t ? this.table[t] || (this.table[t] = PC(this.extra, t)) : 0;
  }
}, c(Yd, "gc"), Yd);
f(lA, "TokenTable");
let cA = lA;
const Bq = /* @__PURE__ */ new cA(CC);
function bv(n, t) {
  hQ.indexOf(n) > -1 || (hQ.push(n), console.warn(t));
}
c(bv, "Vo$1");
f(bv, "warnForPart");
function PC(n, t) {
  let e = [];
  for (let o of t.split(" ")) {
    let l = [];
    for (let h of o.split(".")) {
      let u = n[h] || T[h];
      u ? typeof u == "function" ? l.length ? l = l.map(u) : bv(h, `Modifier ${h} used at start of tag`) : l.length ? bv(h, `Tag ${h} used as modifier`) : l = Array.isArray(u) ? u : [u] : bv(h, `Unknown highlighting tag ${h}`);
    }
    for (let h of l)
      e.push(h);
  }
  if (!e.length)
    return 0;
  let i = t.replace(/ /g, "_"), s = i + " " + e.map((o) => o.id), r = dQ[s];
  if (r)
    return r.id;
  let a = dQ[s] = Be.define({
    id: Sw.length,
    name: i,
    props: [Ql({ [i]: e })]
  });
  return Sw.push(a), a.id;
}
c(PC, "$p");
f(PC, "createTokenType");
function hA(n, t) {
  let e = Be.define({ id: Sw.length, name: "Document", props: [
    Qr.add(() => n),
    km.add(() => (i) => t.getIndent(i))
  ], top: !0 });
  return Sw.push(e), e;
}
c(hA, "bQ");
f(hA, "docID");
le.RTL, le.LTR;
var Gd;
const dA = (Gd = class {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(t, e, i, s) {
    this.state = t, this.pos = e, this.explicit = i, this.view = s, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(t) {
    let e = re(this.state).resolveInner(this.pos, -1);
    for (; e && t.indexOf(e.name) < 0; )
      e = e.parent;
    return e ? {
      from: e.from,
      to: this.pos,
      text: this.state.sliceDoc(e.from, this.pos),
      type: e.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(t) {
    let e = this.state.doc.lineAt(this.pos), i = Math.max(e.from, this.pos - 250), s = e.text.slice(i - e.from, this.pos - e.from), r = s.search(MC(t, !1));
    return r < 0 ? null : { from: i + r, to: this.pos, text: s.slice(r) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(t, e, i) {
    t == "abort" && this.abortListeners && (this.abortListeners.push(e), i && i.onDocChange && (this.abortOnDocChange = !0));
  }
}, c(Gd, "Qc"), Gd);
f(dA, "CompletionContext");
let QC = dA;
function u5(n) {
  let t = Object.keys(n).join(""), e = /\w/.test(t);
  return e && (t = t.replace(/\w/g, "")), `[${e ? "\\w" : ""}${t.replace(/[^\w\s]/g, "\\$&")}]`;
}
c(u5, "tO");
f(u5, "toSet");
function uA(n) {
  let t = /* @__PURE__ */ Object.create(null), e = /* @__PURE__ */ Object.create(null);
  for (let { label: s } of n) {
    t[s[0]] = !0;
    for (let r = 1; r < s.length; r++)
      e[s[r]] = !0;
  }
  let i = u5(t) + u5(e) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
c(uA, "wQ");
f(uA, "prefixMatch");
function TC(n) {
  let t = n.map((s) => typeof s == "string" ? { label: s } : s), [e, i] = t.every((s) => /^\w+$/.test(s.label)) ? [/\w*$/, /\w+$/] : uA(t);
  return (s) => {
    let r = s.matchBefore(i);
    return r || s.explicit ? { from: r ? r.from : s.pos, options: t, validFor: e } : null;
  };
}
c(TC, "Rp$1");
f(TC, "completeFromList");
function pA(n, t) {
  return (e) => {
    for (let i = re(e.state).resolveInner(e.pos, -1); i; i = i.parent) {
      if (n.indexOf(i.name) > -1)
        return null;
      if (i.type.isTop)
        break;
    }
    return t(e);
  };
}
c(pA, "xQ");
f(pA, "ifNotIn");
var Kd;
const fA = (Kd = class {
  constructor(t, e, i, s) {
    this.completion = t, this.source = e, this.match = i, this.score = s;
  }
}, c(Kd, "yc"), Kd);
f(fA, "Option");
let uQ = fA;
function Rr(n) {
  return n.selection.main.from;
}
c(Rr, "Jt$2");
f(Rr, "cur");
function MC(n, t) {
  var e;
  let { source: i } = n, s = t && i[0] != "^", r = i[i.length - 1] != "$";
  return !s && !r ? n : new RegExp(`${s ? "^" : ""}(?:${i})${r ? "$" : ""}`, (e = n.flags) !== null && e !== void 0 ? e : n.ignoreCase ? "i" : "");
}
c(MC, "vp");
f(MC, "ensureAnchor");
const AC = /* @__PURE__ */ ar.define();
function yA(n, t, e, i) {
  let { main: s } = n.selection, r = e - s.from, a = i - s.from;
  return {
    ...n.changeByRange((o) => {
      if (o != s && e != i && n.sliceDoc(o.from + r, o.from + a) != n.sliceDoc(e, i))
        return { range: o };
      let l = n.toText(t);
      return {
        changes: { from: o.from + r, to: i == s.from ? o.to : o.from + a, insert: l },
        range: it.cursor(o.from + r + l.length)
      };
    }),
    scrollIntoView: !0,
    userEvent: "input.complete"
  };
}
c(yA, "kQ");
f(yA, "insertCompletionText");
const pQ = /* @__PURE__ */ new WeakMap();
function mA(n) {
  if (!Array.isArray(n))
    return n;
  let t = pQ.get(n);
  return t || pQ.set(n, t = TC(n)), t;
}
c(mA, "PQ");
f(mA, "asSource");
const TO = /* @__PURE__ */ Bt.define(), Cw = /* @__PURE__ */ Bt.define();
var Jd;
const gA = (Jd = class {
  constructor(t) {
    this.pattern = t, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let e = 0; e < t.length; ) {
      let i = br(t, e), s = Ua(i);
      this.chars.push(i);
      let r = t.slice(e, e + s), a = r.toUpperCase();
      this.folded.push(br(a == r ? r.toLowerCase() : a, 0)), e += s;
    }
    this.astral = t.length != this.chars.length;
  }
  ret(t, e) {
    return this.score = t, this.matched = e, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(t) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (t.length < this.pattern.length)
      return null;
    let { chars: e, folded: i, any: s, precise: r, byWord: a } = this;
    if (e.length == 1) {
      let Q = br(t, 0), L = Ua(Q), W = L == t.length ? 0 : -100;
      if (Q != e[0]) if (Q == i[0])
        W += -200;
      else
        return null;
      return this.ret(W, [0, L]);
    }
    let o = t.indexOf(this.pattern);
    if (o == 0)
      return this.ret(t.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = e.length, h = 0;
    if (o < 0) {
      for (let Q = 0, L = Math.min(t.length, 200); Q < L && h < l; ) {
        let W = br(t, Q);
        (W == e[h] || W == i[h]) && (s[h++] = Q), Q += Ua(W);
      }
      if (h < l)
        return null;
    }
    let u = 0, p = 0, y = !1, m = 0, g = -1, b = -1, S = /[a-z]/.test(t), x = !0;
    for (let Q = 0, L = Math.min(t.length, 200), W = 0; Q < L && p < l; ) {
      let R = br(t, Q);
      o < 0 && (u < l && R == e[u] && (r[u++] = Q), m < l && (R == e[m] || R == i[m] ? (m == 0 && (g = Q), b = Q + 1, m++) : m = 0));
      let I, V = R < 255 ? R >= 48 && R <= 57 || R >= 97 && R <= 122 ? 2 : R >= 65 && R <= 90 ? 1 : 0 : (I = c8(R)) != I.toLowerCase() ? 1 : I != I.toUpperCase() ? 2 : 0;
      (!Q || V == 1 && S || W == 0 && V != 0) && (e[p] == R || i[p] == R && (y = !0) ? a[p++] = Q : a.length && (x = !1)), W = V, Q += Ua(R);
    }
    return p == l && a[0] == 0 && x ? this.result(-100 + (y ? -200 : 0), a, t) : m == l && g == 0 ? this.ret(-200 - t.length + (b == t.length ? 0 : -100), [0, b]) : o > -1 ? this.ret(-700 - t.length, [o, o + this.pattern.length]) : m == l ? this.ret(-900 - t.length, [g, b]) : p == l ? this.result(-100 + (y ? -200 : 0) + -700 + (x ? 0 : -1100), a, t) : e.length == 2 ? null : this.result((s[0] ? -700 : 0) + -200 + -1100, s, t);
  }
  result(t, e, i) {
    let s = [], r = 0;
    for (let a of e) {
      let o = a + (this.astral ? Ua(br(i, a)) : 1);
      r && s[r - 1] == a ? s[r - 1] = o : (s[r++] = a, s[r++] = o);
    }
    return this.ret(t - i.length, s);
  }
}, c(Jd, "Sc"), Jd);
f(gA, "FuzzyMatcher");
let Uq = gA;
var tu;
const wA = (tu = class {
  constructor(t) {
    this.pattern = t, this.matched = [], this.score = 0, this.folded = t.toLowerCase();
  }
  match(t) {
    if (t.length < this.pattern.length)
      return null;
    let e = t.slice(0, this.pattern.length), i = e == this.pattern ? 0 : e.toLowerCase() == this.folded ? -200 : null;
    return i == null ? null : (this.matched = [0, e.length], this.score = i + (t.length == this.pattern.length ? 0 : -100), this);
  }
}, c(tu, "bc"), tu);
f(wA, "StrictMatcher");
let Hq = wA;
const je = /* @__PURE__ */ bt.define({
  combine(n) {
    return VS(n, {
      activateOnTyping: !0,
      activateOnCompletion: /* @__PURE__ */ f(() => !1, "activateOnCompletion"),
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: /* @__PURE__ */ f(() => "", "tooltipClass"),
      optionClass: /* @__PURE__ */ f(() => "", "optionClass"),
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: vA,
      filterStrict: !1,
      compareCompletions: /* @__PURE__ */ f((t, e) => (t.sortText || t.label).localeCompare(e.sortText || e.label), "compareCompletions"),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: /* @__PURE__ */ f((t, e) => t && e, "defaultKeymap"),
      closeOnBlur: /* @__PURE__ */ f((t, e) => t && e, "closeOnBlur"),
      icons: /* @__PURE__ */ f((t, e) => t && e, "icons"),
      tooltipClass: /* @__PURE__ */ f((t, e) => (i) => p5(t(i), e(i)), "tooltipClass"),
      optionClass: /* @__PURE__ */ f((t, e) => (i) => p5(t(i), e(i)), "optionClass"),
      addToOptions: /* @__PURE__ */ f((t, e) => t.concat(e), "addToOptions"),
      filterStrict: /* @__PURE__ */ f((t, e) => t || e, "filterStrict")
    });
  }
});
function p5(n, t) {
  return n ? t ? n + " " + t : n : t;
}
c(p5, "rO");
f(p5, "joinClass");
function vA(n, t, e, i, s, r) {
  let a = n.textDirection == le.RTL, o = a, l = !1, h = "top", u, p, y = t.left - s.left, m = s.right - t.right, g = i.right - i.left, b = i.bottom - i.top;
  if (o && y < Math.min(g, m) ? o = !1 : !o && m < Math.min(g, y) && (o = !0), g <= (o ? y : m))
    u = Math.max(s.top, Math.min(e.top, s.bottom - b)) - t.top, p = Math.min(400, o ? y : m);
  else {
    l = !0, p = Math.min(
      400,
      (a ? t.right : s.right - t.left) - 30
      /* Info.Margin */
    );
    let Q = s.bottom - t.bottom;
    Q >= b || Q > t.top ? u = e.bottom - t.top : (h = "bottom", u = t.bottom - e.top);
  }
  let S = (t.bottom - t.top) / r.offsetHeight, x = (t.right - t.left) / r.offsetWidth;
  return {
    style: `${h}: ${u / S}px; max-width: ${p / x}px`,
    class: "cm-completionInfo-" + (l ? a ? "left-narrow" : "right-narrow" : o ? "left" : "right")
  };
}
c(vA, "$Q");
f(vA, "defaultPositionInfo");
function OA(n) {
  let t = n.addToOptions.slice();
  return n.icons && t.push({
    render(e) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), e.type && i.classList.add(...e.type.split(/\s+/g).map((s) => "cm-completionIcon-" + s)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), t.push({
    render(e, i, s, r) {
      let a = document.createElement("span");
      a.className = "cm-completionLabel";
      let o = e.displayLabel || e.label, l = 0;
      for (let h = 0; h < r.length; ) {
        let u = r[h++], p = r[h++];
        u > l && a.appendChild(document.createTextNode(o.slice(l, u)));
        let y = a.appendChild(document.createElement("span"));
        y.appendChild(document.createTextNode(o.slice(u, p))), y.className = "cm-completionMatchedText", l = p;
      }
      return l < o.length && a.appendChild(document.createTextNode(o.slice(l))), a;
    },
    position: 50
  }, {
    render(e) {
      if (!e.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = e.detail, i;
    },
    position: 80
  }), t.sort((e, i) => e.position - i.position).map((e) => e.render);
}
c(OA, "RQ");
f(OA, "optionContent");
function $v(n, t, e) {
  if (n <= e)
    return { from: 0, to: n };
  if (t < 0 && (t = 0), t <= n >> 1) {
    let s = Math.floor(t / e);
    return { from: s * e, to: (s + 1) * e };
  }
  let i = Math.floor((n - t) / e);
  return { from: n - (i + 1) * e, to: n - i * e };
}
c($v, "Uo$1");
f($v, "rangeAroundSelected");
var eu;
const bA = (eu = class {
  constructor(t, e, i) {
    this.view = t, this.stateField = e, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: /* @__PURE__ */ f(() => this.measureInfo(), "read"),
      write: /* @__PURE__ */ f((l) => this.placeInfo(l), "write"),
      key: this
    }, this.space = null, this.currentClass = "";
    let s = t.state.field(e), { options: r, selected: a } = s.open, o = t.state.facet(je);
    this.optionContent = OA(o), this.optionClass = o.optionClass, this.tooltipClass = o.tooltipClass, this.range = $v(r.length, a, o.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(t.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: h } = t.state.field(e).open;
      for (let u = l.target, p; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (p = /-(\d+)$/.exec(u.id)) && +p[1] < h.length) {
          this.applyCompletion(t, h[+p[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let h = t.state.field(this.stateField, !1);
      h && h.tooltip && t.state.facet(je).closeOnBlur && l.relatedTarget != t.contentDOM && t.dispatch({ effects: Cw.of(null) });
    }), this.showOptions(r, s.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(t, e) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t, e, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(t) {
    var e;
    let i = t.state.field(this.stateField), s = t.startState.field(this.stateField);
    if (this.updateTooltipClass(t.state), i != s) {
      let { options: r, selected: a, disabled: o } = i.open;
      (!s.open || s.open.options != r) && (this.range = $v(r.length, a, t.state.facet(je).maxRenderedOptions), this.showOptions(r, i.id)), this.updateSel(), o != ((e = s.open) === null || e === void 0 ? void 0 : e.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!o);
    }
  }
  updateTooltipClass(t) {
    let e = this.tooltipClass(t);
    if (e != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of e.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = e;
    }
  }
  positioned(t) {
    this.space = t, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let t = this.view.state.field(this.stateField), e = t.open;
    (e.selected > -1 && e.selected < this.range.from || e.selected >= this.range.to) && (this.range = $v(e.options.length, e.selected, this.view.state.facet(je).maxRenderedOptions), this.showOptions(e.options, t.id));
    let i = this.updateSelectedOption(e.selected);
    if (i) {
      this.destroyInfo();
      let { completion: s } = e.options[e.selected], { info: r } = s;
      if (!r)
        return;
      let a = typeof r == "string" ? document.createTextNode(r) : r(s);
      if (!a)
        return;
      "then" in a ? a.then((o) => {
        o && this.view.state.field(this.stateField, !1) == t && this.addInfoPane(o, s);
      }).catch((o) => Qi(this.view.state, o, "completion info")) : (this.addInfoPane(a, s), i.setAttribute("aria-describedby", this.info.id));
    }
  }
  addInfoPane(t, e) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", i.id = "cm-completionInfo-" + Math.floor(Math.random() * 65535).toString(16), t.nodeType != null)
      i.appendChild(t), this.infoDestroy = null;
    else {
      let { dom: s, destroy: r } = t;
      i.appendChild(s), this.infoDestroy = r || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(t) {
    let e = null;
    for (let i = this.list.firstChild, s = this.range.from; i; i = i.nextSibling, s++)
      i.nodeName != "LI" || !i.id ? s-- : s == t ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), e = i) : i.hasAttribute("aria-selected") && (i.removeAttribute("aria-selected"), i.removeAttribute("aria-describedby"));
    return e && xA(this.list, e), e;
  }
  measureInfo() {
    let t = this.dom.querySelector("[aria-selected]");
    if (!t || !this.info)
      return null;
    let e = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), s = t.getBoundingClientRect(), r = this.space;
    if (!r) {
      let a = this.dom.ownerDocument.documentElement;
      r = { left: 0, top: 0, right: a.clientWidth, bottom: a.clientHeight };
    }
    return s.top > Math.min(r.bottom, e.bottom) - 10 || s.bottom < Math.max(r.top, e.top) + 10 ? null : this.view.state.facet(je).positionInfo(this.view, e, s, i, r, this.dom);
  }
  placeInfo(t) {
    this.info && (t ? (t.style && (this.info.style.cssText = t.style), this.info.className = "cm-tooltip cm-completionInfo " + (t.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(t, e, i) {
    const s = document.createElement("ul");
    s.id = e, s.setAttribute("role", "listbox"), s.setAttribute("aria-expanded", "true"), s.setAttribute("aria-label", this.view.state.phrase("Completions")), s.addEventListener("mousedown", (a) => {
      a.target == s && a.preventDefault();
    });
    let r = null;
    for (let a = i.from; a < i.to; a++) {
      let { completion: o, match: l } = t[a], { section: h } = o;
      if (h) {
        let y = typeof h == "string" ? h : h.name;
        if (y != r && (a > i.from || i.from == 0))
          if (r = y, typeof h != "string" && h.header)
            s.appendChild(h.header(h));
          else {
            let m = s.appendChild(document.createElement("completion-section"));
            m.textContent = y;
          }
      }
      const u = s.appendChild(document.createElement("li"));
      u.id = e + "-" + a, u.setAttribute("role", "option");
      let p = this.optionClass(o);
      p && (u.className = p);
      for (let y of this.optionContent) {
        let m = y(o, this.view.state, this.view, l);
        m && u.appendChild(m);
      }
    }
    return i.from && s.classList.add("cm-completionListIncompleteTop"), i.to < t.length && s.classList.add("cm-completionListIncompleteBottom"), s;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}, c(eu, "wc"), eu);
f(bA, "CompletionTooltip");
let Yq = bA;
function $A(n, t) {
  return (e) => new Yq(e, n, t);
}
c($A, "vQ");
f($A, "completionTooltip");
function xA(n, t) {
  let e = n.getBoundingClientRect(), i = t.getBoundingClientRect(), s = e.height / n.offsetHeight;
  i.top < e.top ? n.scrollTop -= (e.top - i.top) / s : i.bottom > e.bottom && (n.scrollTop += (i.bottom - e.bottom) / s);
}
c(xA, "TQ");
f(xA, "scrollIntoView");
function f5(n) {
  return (n.boost || 0) * 100 + (n.apply ? 10 : 0) + (n.info ? 5 : 0) + (n.type ? 1 : 0);
}
c(f5, "nO");
f(f5, "score");
function kA(n, t) {
  let e = [], i = null, s = null, r = /* @__PURE__ */ f((u) => {
    e.push(u);
    let { section: p } = u.completion;
    if (p) {
      i || (i = []);
      let y = typeof p == "string" ? p : p.name;
      i.some((m) => m.name == y) || i.push(typeof p == "string" ? { name: y } : p);
    }
  }, "addOption"), a = t.facet(je);
  for (let u of n)
    if (u.hasResult()) {
      let p = u.result.getMatch;
      if (u.result.filter === !1)
        for (let y of u.result.options)
          r(new uQ(y, u.source, p ? p(y) : [], 1e9 - e.length));
      else {
        let y = t.sliceDoc(u.from, u.to), m, g = a.filterStrict ? new Hq(y) : new Uq(y);
        for (let b of u.result.options)
          if (m = g.match(b.label)) {
            let S = b.displayLabel ? p ? p(b, m.matched) : [] : m.matched, x = m.score + (b.boost || 0);
            if (r(new uQ(b, u.source, S, x)), typeof b.section == "object" && b.section.rank === "dynamic") {
              let { name: Q } = b.section;
              s || (s = /* @__PURE__ */ Object.create(null)), s[Q] = Math.max(x, s[Q] || -1e9);
            }
          }
      }
    }
  if (i) {
    let u = /* @__PURE__ */ Object.create(null), p = 0, y = /* @__PURE__ */ f((m, g) => (m.rank === "dynamic" && g.rank === "dynamic" ? s[g.name] - s[m.name] : 0) || (typeof m.rank == "number" ? m.rank : 1e9) - (typeof g.rank == "number" ? g.rank : 1e9) || (m.name < g.name ? -1 : 1), "cmp");
    for (let m of i.sort(y))
      p -= 1e5, u[m.name] = p;
    for (let m of e) {
      let { section: g } = m.completion;
      g && (m.score += u[typeof g == "string" ? g : g.name]);
    }
  }
  let o = [], l = null, h = a.compareCompletions;
  for (let u of e.sort((p, y) => y.score - p.score || h(p.completion, y.completion))) {
    let p = u.completion;
    !l || l.label != p.label || l.detail != p.detail || l.type != null && p.type != null && l.type != p.type || l.apply != p.apply || l.boost != p.boost ? o.push(u) : f5(u.completion) > f5(l) && (o[o.length - 1] = u), l = u.completion;
  }
  return o;
}
c(kA, "AQ");
f(kA, "sortOptions");
var Jn;
const SA = (Jn = class {
  constructor(t, e, i, s, r, a) {
    this.options = t, this.attrs = e, this.tooltip = i, this.timestamp = s, this.selected = r, this.disabled = a;
  }
  setSelected(t, e) {
    return t == this.selected || t >= this.options.length ? this : new Jn(this.options, y5(e, t), this.tooltip, this.timestamp, t, this.disabled);
  }
  static build(t, e, i, s, r, a) {
    if (s && !a && t.some((h) => h.isPending))
      return s.setDisabled();
    let o = kA(t, e);
    if (!o.length)
      return s && t.some((h) => h.isPending) ? s.setDisabled() : null;
    let l = e.facet(je).selectOnOpen ? 0 : -1;
    if (s && s.selected != l && s.selected != -1) {
      let h = s.options[s.selected].completion;
      for (let u = 0; u < o.length; u++)
        if (o[u].completion == h) {
          l = u;
          break;
        }
    }
    return new Jn(o, y5(i, l), {
      pos: t.reduce((h, u) => u.hasResult() ? Math.min(h, u.from) : h, 1e8),
      create: iZ,
      above: r.aboveCursor
    }, s ? s.timestamp : Date.now(), l, !1);
  }
  map(t) {
    return new Jn(this.options, this.attrs, { ...this.tooltip, pos: t.mapPos(this.tooltip.pos) }, this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new Jn(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}, c(Jn, "Dt"), Jn);
f(SA, "CompletionDialog");
let Gq = SA;
var Hr;
const CA = (Hr = class {
  constructor(t, e, i) {
    this.active = t, this.id = e, this.open = i;
  }
  static start() {
    return new Hr(eZ, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(t) {
    let { state: e } = t, i = e.facet(je), s = (i.override || e.languageDataAt("autocomplete", Rr(e)).map(mA)).map((o) => (this.active.find((l) => l.source == o) || new Ka(
      o,
      this.active.some(
        (l) => l.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(t, i));
    s.length == this.active.length && s.every((o, l) => o == this.active[l]) && (s = this.active);
    let r = this.open, a = t.effects.some((o) => o.is(EC));
    r && t.docChanged && (r = r.map(t.changes)), t.selection || s.some((o) => o.hasResult() && t.changes.touchesRange(o.from, o.to)) || !PA(s, this.active) || a ? r = Gq.build(s, e, this.id, r, i, a) : r && r.disabled && !s.some((o) => o.isPending) && (r = null), !r && s.every((o) => !o.isPending) && s.some((o) => o.hasResult()) && (s = s.map((o) => o.hasResult() ? new Ka(
      o.source,
      0
      /* State.Inactive */
    ) : o));
    for (let o of t.effects)
      o.is(RA) && (r = r && r.setSelected(o.value, this.id));
    return s == this.active && r == this.open ? this : new Hr(s, this.id, r);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? Jq : tZ;
  }
}, c(Hr, "zr"), Hr);
f(CA, "CompletionState");
let Kq = CA;
function PA(n, t) {
  if (n == t)
    return !0;
  for (let e = 0, i = 0; ; ) {
    for (; e < n.length && !n[e].hasResult(); )
      e++;
    for (; i < t.length && !t[i].hasResult(); )
      i++;
    let s = e == n.length, r = i == t.length;
    if (s || r)
      return s == r;
    if (n[e++].result != t[i++].result)
      return !1;
  }
}
c(PA, "LQ");
f(PA, "sameResults");
const Jq = {
  "aria-autocomplete": "list"
}, tZ = {};
function y5(n, t) {
  let e = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": n
  };
  return t > -1 && (e["aria-activedescendant"] = n + "-" + t), e;
}
c(y5, "sO");
f(y5, "makeAttrs");
const eZ = [];
function RC(n, t) {
  if (n.isUserEvent("input.complete")) {
    let i = n.annotation(AC);
    if (i && t.activateOnCompletion(i))
      return 12;
  }
  let e = n.isUserEvent("input.type");
  return e && t.activateOnTyping ? 5 : e ? 1 : n.isUserEvent("delete.backward") ? 2 : n.selection ? 8 : n.docChanged ? 16 : 0;
}
c(RC, "Tp$1");
f(RC, "getUpdateType");
var ts;
const QA = (ts = class {
  constructor(t, e, i = !1) {
    this.source = t, this.state = e, this.explicit = i;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(t, e) {
    let i = RC(t, e), s = this;
    (i & 8 || i & 16 && this.touches(t)) && (s = new ts(
      s.source,
      0
      /* State.Inactive */
    )), i & 4 && s.state == 0 && (s = new ts(
      this.source,
      1
      /* State.Pending */
    )), s = s.updateFor(t, i);
    for (let r of t.effects)
      if (r.is(TO))
        s = new ts(s.source, 1, r.value);
      else if (r.is(Cw))
        s = new ts(
          s.source,
          0
          /* State.Inactive */
        );
      else if (r.is(EC))
        for (let a of r.value)
          a.source == s.source && (s = a);
    return s;
  }
  updateFor(t, e) {
    return this.map(t.changes);
  }
  map(t) {
    return this;
  }
  touches(t) {
    return t.changes.touchesRange(Rr(t.state));
  }
}, c(ts, "Nt"), ts);
f(QA, "ActiveSource");
let Ka = QA;
var Fs;
const TA = (Fs = class extends Ka {
  constructor(t, e, i, s, r, a) {
    super(t, 3, e), this.limit = i, this.result = s, this.from = r, this.to = a;
  }
  hasResult() {
    return !0;
  }
  updateFor(t, e) {
    var i;
    if (!(e & 3))
      return this.map(t.changes);
    let s = this.result;
    s.map && !t.changes.empty && (s = s.map(s, t.changes));
    let r = t.changes.mapPos(this.from), a = t.changes.mapPos(this.to, 1), o = Rr(t.state);
    if (o > a || !s || e & 2 && (Rr(t.startState) == this.from || o < this.limit))
      return new Ka(
        this.source,
        e & 4 ? 1 : 0
        /* State.Inactive */
      );
    let l = t.changes.mapPos(this.limit);
    return AA(s.validFor, t.state, r, a) ? new Fs(this.source, this.explicit, l, s, r, a) : s.update && (s = s.update(s, r, a, new QC(t.state, o, !1))) ? new Fs(this.source, this.explicit, l, s, s.from, (i = s.to) !== null && i !== void 0 ? i : Rr(t.state)) : new Ka(this.source, 1, this.explicit);
  }
  map(t) {
    return t.empty ? this : (this.result.map ? this.result.map(this.result, t) : this.result) ? new Fs(this.source, this.explicit, t.mapPos(this.limit), this.result, t.mapPos(this.from), t.mapPos(this.to, 1)) : new Ka(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(t) {
    return t.changes.touchesRange(this.from, this.to);
  }
}, c(Fs, "yi"), Fs);
f(TA, "ActiveResult");
let MA = TA;
function AA(n, t, e, i) {
  if (!n)
    return !1;
  let s = t.sliceDoc(e, i);
  return typeof n == "function" ? n(s, e, i, t) : MC(n, !0).test(s);
}
c(AA, "CQ");
f(AA, "checkValid");
const EC = /* @__PURE__ */ Bt.define({
  map(n, t) {
    return n.map((e) => e.map(t));
  }
}), RA = /* @__PURE__ */ Bt.define(), gi = /* @__PURE__ */ rr.define({
  create() {
    return Kq.start();
  },
  update(n, t) {
    return n.update(t);
  },
  provide: /* @__PURE__ */ f((n) => [
    FT.from(n, (t) => t.tooltip),
    kt.contentAttributes.from(n, (t) => t.attrs)
  ], "provide")
});
function jb(n, t) {
  const e = t.completion.apply || t.completion.label;
  let i = n.state.field(gi).active.find((s) => s.source == t.source);
  return i instanceof MA ? (typeof e == "string" ? n.dispatch({
    ...yA(n.state, e, i.from, i.to),
    annotations: AC.of(t.completion)
  }) : e(n, t.completion, i.from, i.to), !0) : !1;
}
c(jb, "vh$1");
f(jb, "applyCompletion");
const iZ = /* @__PURE__ */ $A(gi, jb);
function kg(n, t = "option") {
  return (e) => {
    let i = e.state.field(gi, !1);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < e.state.facet(je).interactionDelay)
      return !1;
    let s = 1, r;
    t == "page" && (r = pC(e, i.open.tooltip)) && (s = Math.max(2, Math.floor(r.dom.offsetHeight / r.dom.querySelector("li").offsetHeight) - 1));
    let { length: a } = i.open.options, o = i.open.selected > -1 ? i.open.selected + s * (n ? 1 : -1) : n ? 0 : a - 1;
    return o < 0 ? o = t == "page" ? 0 : a - 1 : o >= a && (o = t == "page" ? a - 1 : 0), e.dispatch({ effects: RA.of(o) }), !0;
  };
}
c(kg, "Vn$1");
f(kg, "moveCompletionSelection");
const nZ = /* @__PURE__ */ f((n) => {
  let t = n.state.field(gi, !1);
  return n.state.readOnly || !t || !t.open || t.open.selected < 0 || t.open.disabled || Date.now() - t.open.timestamp < n.state.facet(je).interactionDelay ? !1 : jb(n, t.open.options[t.open.selected]);
}, "acceptCompletion"), y2 = /* @__PURE__ */ f((n) => n.state.field(gi, !1) ? (n.dispatch({ effects: TO.of(!0) }), !0) : !1, "startCompletion"), sZ = /* @__PURE__ */ f((n) => {
  let t = n.state.field(gi, !1);
  return !t || !t.active.some(
    (e) => e.state != 0
    /* State.Inactive */
  ) ? !1 : (n.dispatch({ effects: Cw.of(null) }), !0);
}, "closeCompletion");
var iu;
const EA = (iu = class {
  constructor(t, e) {
    this.active = t, this.context = e, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}, c(iu, "xc"), iu);
f(EA, "RunningQuery");
let rZ = EA;
const aZ = 50, oZ = 1e3, lZ = /* @__PURE__ */ Us.fromClass(class {
  constructor(n) {
    this.view = n, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let t of n.state.field(gi).active)
      t.isPending && this.startQuery(t);
  }
  update(n) {
    let t = n.state.field(gi), e = n.state.facet(je);
    if (!n.selectionSet && !n.docChanged && n.startState.field(gi) == t)
      return;
    let i = n.transactions.some((r) => {
      let a = RC(r, e);
      return a & 8 || (r.selection || r.docChanged) && !(a & 3);
    });
    for (let r = 0; r < this.running.length; r++) {
      let a = this.running[r];
      if (i || a.context.abortOnDocChange && n.docChanged || a.updates.length + n.transactions.length > aZ && Date.now() - a.time > oZ) {
        for (let o of a.context.abortListeners)
          try {
            o();
          } catch (l) {
            Qi(this.view.state, l);
          }
        a.context.abortListeners = null, this.running.splice(r--, 1);
      } else
        a.updates.push(...n.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), n.transactions.some((r) => r.effects.some((a) => a.is(TO))) && (this.pendingStart = !0);
    let s = this.pendingStart ? 50 : e.activateOnTypingDelay;
    if (this.debounceUpdate = t.active.some((r) => r.isPending && !this.running.some((a) => a.active.source == r.source)) ? setTimeout(() => this.startUpdate(), s) : -1, this.composing != 0)
      for (let r of n.transactions)
        r.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && r.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: n } = this.view, t = n.field(gi);
    for (let e of t.active)
      e.isPending && !this.running.some((i) => i.active.source == e.source) && this.startQuery(e);
    this.running.length && t.open && t.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(je).updateSyncTime));
  }
  startQuery(n) {
    let { state: t } = this.view, e = Rr(t), i = new QC(t, e, n.explicit, this.view), s = new rZ(n, i);
    this.running.push(s), Promise.resolve(n.source(i)).then((r) => {
      s.context.aborted || (s.done = r || null, this.scheduleAccept());
    }, (r) => {
      this.view.dispatch({ effects: Cw.of(null) }), Qi(this.view.state, r);
    });
  }
  scheduleAccept() {
    this.running.every((n) => n.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(je).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var n;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let t = [], e = this.view.state.facet(je), i = this.view.state.field(gi);
    for (let s = 0; s < this.running.length; s++) {
      let r = this.running[s];
      if (r.done === void 0)
        continue;
      if (this.running.splice(s--, 1), r.done) {
        let o = Rr(r.updates.length ? r.updates[0].startState : this.view.state), l = Math.min(o, r.done.from + (r.active.explicit ? 0 : 1)), h = new MA(r.active.source, r.active.explicit, l, r.done, r.done.from, (n = r.done.to) !== null && n !== void 0 ? n : o);
        for (let u of r.updates)
          h = h.update(u, e);
        if (h.hasResult()) {
          t.push(h);
          continue;
        }
      }
      let a = i.active.find((o) => o.source == r.active.source);
      if (a && a.isPending)
        if (r.done == null) {
          let o = new Ka(
            r.active.source,
            0
            /* State.Inactive */
          );
          for (let l of r.updates)
            o = o.update(l, e);
          o.isPending || t.push(o);
        } else
          this.startQuery(a);
    }
    (t.length || i.open && i.open.disabled) && this.view.dispatch({ effects: EC.of(t) });
  }
}, {
  eventHandlers: {
    blur(n) {
      let t = this.view.state.field(gi, !1);
      if (t && t.tooltip && this.view.state.facet(je).closeOnBlur) {
        let e = t.open && pC(this.view, t.open.tooltip);
        (!e || !e.dom.contains(n.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: Cw.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: TO.of(!1) }), 20), this.composing = 0;
    }
  }
}), cZ = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), hZ = /* @__PURE__ */ Cl.highest(/* @__PURE__ */ kt.domEventHandlers({
  keydown(n, t) {
    let e = t.state.field(gi, !1);
    if (!e || !e.open || e.open.disabled || e.open.selected < 0 || n.key.length > 1 || n.ctrlKey && !(cZ && n.altKey) || n.metaKey)
      return !1;
    let i = e.open.options[e.open.selected], s = e.active.find((a) => a.source == i.source), r = i.completion.commitCharacters || s.result.commitCharacters;
    return r && r.indexOf(n.key) > -1 && jb(t, i), !1;
  }
})), _A = /* @__PURE__ */ kt.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
var nu;
const zA = (nu = class {
  constructor(t, e, i, s) {
    this.field = t, this.line = e, this.from = i, this.to = s;
  }
}, c(nu, "kc"), nu);
f(zA, "FieldPos");
let dZ = zA;
var qo;
const LA = (qo = class {
  constructor(t, e, i) {
    this.field = t, this.from = e, this.to = i;
  }
  map(t) {
    let e = t.mapPos(this.from, -1, wi.TrackDel), i = t.mapPos(this.to, 1, wi.TrackDel);
    return e == null || i == null ? null : new qo(this.field, e, i);
  }
}, c(qo, "Oo"), qo);
f(LA, "FieldRange");
let uZ = LA;
var Zo;
const IA = (Zo = class {
  constructor(t, e) {
    this.lines = t, this.fieldPositions = e;
  }
  instantiate(t, e) {
    let i = [], s = [e], r = t.doc.lineAt(e), a = /^\s*/.exec(r.text)[0];
    for (let l of this.lines) {
      if (i.length) {
        let h = a, u = /^\t*/.exec(l)[0].length;
        for (let p = 0; p < u; p++)
          h += t.facet(Xb);
        s.push(e + h.length - u), l = h + l.slice(u);
      }
      i.push(l), e += l.length + 1;
    }
    let o = this.fieldPositions.map((l) => new uZ(l.field, s[l.line] + l.from, s[l.line] + l.to));
    return { text: i, ranges: o };
  }
  static parse(t) {
    let e = [], i = [], s = [], r;
    for (let a of t.split(/\r\n?|\n/)) {
      for (; r = /[#$]\{(?:(\d+)(?::([^{}]*))?|((?:\\[{}]|[^{}])*))\}/.exec(a); ) {
        let o = r[1] ? +r[1] : null, l = r[2] || r[3] || "", h = -1, u = l.replace(/\\[{}]/g, (p) => p[1]);
        for (let p = 0; p < e.length; p++)
          (o != null ? e[p].seq == o : u && e[p].name == u) && (h = p);
        if (h < 0) {
          let p = 0;
          for (; p < e.length && (o == null || e[p].seq != null && e[p].seq < o); )
            p++;
          e.splice(p, 0, { seq: o, name: u }), h = p;
          for (let y of s)
            y.field >= h && y.field++;
        }
        for (let p of s)
          if (p.line == i.length && p.from > r.index) {
            let y = r[2] ? 3 + (r[1] || "").length : 2;
            p.from -= y, p.to -= y;
          }
        s.push(new dZ(h, i.length, r.index, r.index + u.length)), a = a.slice(0, r.index) + l + a.slice(r.index + r[0].length);
      }
      a = a.replace(/\\([{}])/g, (o, l, h) => {
        for (let u of s)
          u.line == i.length && u.from > h && (u.from--, u.to--);
        return l;
      }), i.push(a);
    }
    return new Zo(i, s);
  }
}, c(Zo, "po"), Zo);
f(IA, "Snippet");
let pZ = IA, fZ = /* @__PURE__ */ Gt.widget({ widget: /* @__PURE__ */ new class extends Pl {
  toDOM() {
    let n = document.createElement("span");
    return n.className = "cm-snippetFieldPosition", n;
  }
  ignoreEvent() {
    return !1;
  }
}() }), yZ = /* @__PURE__ */ Gt.mark({ class: "cm-snippetField" });
var Fo;
const WA = (Fo = class {
  constructor(t, e) {
    this.ranges = t, this.active = e, this.deco = Gt.set(t.map((i) => (i.from == i.to ? fZ : yZ).range(i.from, i.to)), !0);
  }
  map(t) {
    let e = [];
    for (let i of this.ranges) {
      let s = i.map(t);
      if (!s)
        return null;
      e.push(s);
    }
    return new Fo(e, this.active);
  }
  selectionInsideField(t) {
    return t.ranges.every((e) => this.ranges.some((i) => i.field == this.active && i.from <= e.from && i.to >= e.to));
  }
}, c(Fo, "mo"), Fo);
f(WA, "ActiveSnippet");
let Bb = WA;
const d1 = /* @__PURE__ */ Bt.define({
  map(n, t) {
    return n && n.map(t);
  }
}), mZ = /* @__PURE__ */ Bt.define(), Pw = /* @__PURE__ */ rr.define({
  create() {
    return null;
  },
  update(n, t) {
    for (let e of t.effects) {
      if (e.is(d1))
        return e.value;
      if (e.is(mZ) && n)
        return new Bb(n.ranges, e.value);
    }
    return n && t.docChanged && (n = n.map(t.changes)), n && t.selection && !n.selectionInsideField(t.selection) && (n = null), n;
  },
  provide: /* @__PURE__ */ f((n) => kt.decorations.from(n, (t) => t ? t.deco : Gt.none), "provide")
});
function Ub(n, t) {
  return it.create(n.filter((e) => e.field == t).map((e) => it.range(e.from, e.to)));
}
c(Ub, "Th$1");
f(Ub, "fieldSelection");
function VA(n) {
  let t = pZ.parse(n);
  return (e, i, s, r) => {
    let { text: a, ranges: o } = t.instantiate(e.state, s), { main: l } = e.state.selection, h = {
      changes: { from: s, to: r == l.from ? l.to : r, insert: Ft.of(a) },
      scrollIntoView: !0,
      annotations: i ? [AC.of(i), vi.userEvent.of("input.complete")] : void 0
    };
    if (o.length && (h.selection = Ub(o, 0)), o.some((u) => u.field > 0)) {
      let u = new Bb(o, 0), p = h.effects = [d1.of(u)];
      e.state.field(Pw, !1) === void 0 && p.push(Bt.appendConfig.of([Pw, bZ, $Z, _A]));
    }
    e.dispatch(e.state.update(h));
  };
}
c(VA, "BQ");
f(VA, "snippet");
function _C(n) {
  return ({ state: t, dispatch: e }) => {
    let i = t.field(Pw, !1);
    if (!i || n < 0 && i.active == 0)
      return !1;
    let s = i.active + n, r = n > 0 && !i.ranges.some((a) => a.field == s + n);
    return e(t.update({
      selection: Ub(i.ranges, s),
      effects: d1.of(r ? null : new Bb(i.ranges, s)),
      scrollIntoView: !0
    })), !0;
  };
}
c(_C, "Mp$1");
f(_C, "moveField");
const gZ = /* @__PURE__ */ f(({ state: n, dispatch: t }) => n.field(Pw, !1) ? (t(n.update({ effects: d1.of(null) })), !0) : !1, "clearSnippet"), wZ = /* @__PURE__ */ _C(1), vZ = /* @__PURE__ */ _C(-1), OZ = [
  { key: "Tab", run: wZ, shift: vZ },
  { key: "Escape", run: gZ }
], fQ = /* @__PURE__ */ bt.define({
  combine(n) {
    return n.length ? n[0] : OZ;
  }
}), bZ = /* @__PURE__ */ Cl.highest(/* @__PURE__ */ Vb.compute([fQ], (n) => n.facet(fQ)));
function fi(n, t) {
  return { ...t, apply: VA(n) };
}
c(fi, "ge$2");
f(fi, "snippetCompletion");
const $Z = /* @__PURE__ */ kt.domEventHandlers({
  mousedown(n, t) {
    let e = t.state.field(Pw, !1), i;
    if (!e || (i = t.posAtCoords({ x: n.clientX, y: n.clientY })) == null)
      return !1;
    let s = e.ranges.find((r) => r.from <= i && r.to >= i);
    return !s || s.field == e.active ? !1 : (t.dispatch({
      selection: Ub(e.ranges, s.field),
      effects: d1.of(e.ranges.some((r) => r.field > s.field) ? new Bb(e.ranges, s.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), DA = /* @__PURE__ */ new class extends ta {
}();
DA.startSide = 1;
DA.endSide = -1;
function xZ(n = {}) {
  return [
    hZ,
    gi,
    je.of(n),
    lZ,
    SZ,
    _A
  ];
}
c(xZ, "JQ");
f(xZ, "autocompletion");
const kZ = [
  { key: "Ctrl-Space", run: y2 },
  { mac: "Alt-`", run: y2 },
  { mac: "Alt-i", run: y2 },
  { key: "Escape", run: sZ },
  { key: "ArrowDown", run: /* @__PURE__ */ kg(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ kg(!1) },
  { key: "PageDown", run: /* @__PURE__ */ kg(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ kg(!1, "page") },
  { key: "Enter", run: nZ }
], SZ = /* @__PURE__ */ Cl.highest(/* @__PURE__ */ Vb.computeN([je], (n) => n.facet(je).defaultKeymap ? [kZ] : []));
function CZ(n) {
  let t = n.field(gi, !1);
  return t && t.active.some((e) => e.isPending) ? "pending" : t && t.active.some(
    (e) => e.state != 0
    /* State.Inactive */
  ) ? "active" : null;
}
c(CZ, "iy$1");
f(CZ, "completionStatus");
var Xo;
const qA = (Xo = class {
  static create(t, e, i, s, r) {
    let a = s + (s << 8) + t + (e << 4) | 0;
    return new Xo(t, e, i, a, r, [], []);
  }
  constructor(t, e, i, s, r, a, o) {
    this.type = t, this.value = e, this.from = i, this.hash = s, this.end = r, this.children = a, this.positions = o, this.hashProp = [[Pt.contextHash, s]];
  }
  addChild(t, e) {
    t.prop(Pt.contextHash) != this.hash && (t = new zt(t.type, t.children, t.positions, t.length, this.hashProp)), this.children.push(t), this.positions.push(e);
  }
  toTree(t, e = this.end) {
    let i = this.children.length - 1;
    return i >= 0 && (e = Math.max(e, this.positions[i] + this.children[i].length + this.from)), new zt(t.types[this.type], this.children, this.positions, e - this.from).balance({
      makeTree: /* @__PURE__ */ f((s, r, a) => new zt(Be.none, s, r, a, this.hashProp), "makeTree")
    });
  }
}, c(Xo, "go"), Xo);
f(qA, "CompositeBlock");
let yQ = qA;
var H;
(function(n) {
  n[n.Document = 1] = "Document", n[n.CodeBlock = 2] = "CodeBlock", n[n.FencedCode = 3] = "FencedCode", n[n.Blockquote = 4] = "Blockquote", n[n.HorizontalRule = 5] = "HorizontalRule", n[n.BulletList = 6] = "BulletList", n[n.OrderedList = 7] = "OrderedList", n[n.ListItem = 8] = "ListItem", n[n.ATXHeading1 = 9] = "ATXHeading1", n[n.ATXHeading2 = 10] = "ATXHeading2", n[n.ATXHeading3 = 11] = "ATXHeading3", n[n.ATXHeading4 = 12] = "ATXHeading4", n[n.ATXHeading5 = 13] = "ATXHeading5", n[n.ATXHeading6 = 14] = "ATXHeading6", n[n.SetextHeading1 = 15] = "SetextHeading1", n[n.SetextHeading2 = 16] = "SetextHeading2", n[n.HTMLBlock = 17] = "HTMLBlock", n[n.LinkReference = 18] = "LinkReference", n[n.Paragraph = 19] = "Paragraph", n[n.CommentBlock = 20] = "CommentBlock", n[n.ProcessingInstructionBlock = 21] = "ProcessingInstructionBlock", n[n.Escape = 22] = "Escape", n[n.Entity = 23] = "Entity", n[n.HardBreak = 24] = "HardBreak", n[n.Emphasis = 25] = "Emphasis", n[n.StrongEmphasis = 26] = "StrongEmphasis", n[n.Link = 27] = "Link", n[n.Image = 28] = "Image", n[n.InlineCode = 29] = "InlineCode", n[n.HTMLTag = 30] = "HTMLTag", n[n.Comment = 31] = "Comment", n[n.ProcessingInstruction = 32] = "ProcessingInstruction", n[n.Autolink = 33] = "Autolink", n[n.HeaderMark = 34] = "HeaderMark", n[n.QuoteMark = 35] = "QuoteMark", n[n.ListMark = 36] = "ListMark", n[n.LinkMark = 37] = "LinkMark", n[n.EmphasisMark = 38] = "EmphasisMark", n[n.CodeMark = 39] = "CodeMark", n[n.CodeText = 40] = "CodeText", n[n.CodeInfo = 41] = "CodeInfo", n[n.LinkTitle = 42] = "LinkTitle", n[n.LinkLabel = 43] = "LinkLabel", n[n.URL = 44] = "URL";
})(H || (H = {}));
var su;
const ZA = (su = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.start = t, this.content = e, this.marks = [], this.parsers = [];
  }
}, c(su, "Pc"), su);
f(ZA, "LeafBlock");
let PZ = ZA;
var ru;
const FA = (ru = class {
  constructor() {
    this.text = "", this.baseIndent = 0, this.basePos = 0, this.depth = 0, this.markers = [], this.pos = 0, this.indent = 0, this.next = -1;
  }
  /**
  @internal
  */
  forward() {
    this.basePos > this.pos && this.forwardInner();
  }
  /**
  @internal
  */
  forwardInner() {
    let t = this.skipSpace(this.basePos);
    this.indent = this.countIndent(t, this.pos, this.indent), this.pos = t, this.next = t == this.text.length ? -1 : this.text.charCodeAt(t);
  }
  /**
  Skip whitespace after the given position, return the position of
  the next non-space character or the end of the line if there's
  only space after `from`.
  */
  skipSpace(t) {
    return mh(this.text, t);
  }
  /**
  @internal
  */
  reset(t) {
    for (this.text = t, this.baseIndent = this.basePos = this.pos = this.indent = 0, this.forwardInner(), this.depth = 1; this.markers.length; )
      this.markers.pop();
  }
  /**
  Move the line's base position forward to the given position.
  This should only be called by composite [block
  parsers](#BlockParser.parse) or [markup skipping
  functions](#NodeSpec.composite).
  */
  moveBase(t) {
    this.basePos = t, this.baseIndent = this.countIndent(t, this.pos, this.indent);
  }
  /**
  Move the line's base position forward to the given _column_.
  */
  moveBaseColumn(t) {
    this.baseIndent = t, this.basePos = this.findColumn(t);
  }
  /**
  Store a composite-block-level marker. Should be called from
  [markup skipping functions](#NodeSpec.composite) when they
  consume any non-whitespace characters.
  */
  addMarker(t) {
    this.markers.push(t);
  }
  /**
  Find the column position at `to`, optionally starting at a given
  position and column.
  */
  countIndent(t, e = 0, i = 0) {
    for (let s = e; s < t; s++)
      i += this.text.charCodeAt(s) == 9 ? 4 - i % 4 : 1;
    return i;
  }
  /**
  Find the position corresponding to the given column.
  */
  findColumn(t) {
    let e = 0;
    for (let i = 0; e < this.text.length && i < t; e++)
      i += this.text.charCodeAt(e) == 9 ? 4 - i % 4 : 1;
    return e;
  }
  /**
  @internal
  */
  scrub() {
    if (!this.baseIndent)
      return this.text;
    let t = "";
    for (let e = 0; e < this.basePos; e++)
      t += " ";
    return t + this.text.slice(this.basePos);
  }
}, c(ru, "$c"), ru);
f(FA, "Line");
let QZ = FA;
function m5(n, t, e) {
  if (e.pos == e.text.length || n != t.block && e.indent >= t.stack[e.depth + 1].value + e.baseIndent)
    return !0;
  if (e.indent >= e.baseIndent + 4)
    return !1;
  let i = (n.type == H.OrderedList ? Gb : Yb)(e, t, !1);
  return i > 0 && (n.type != H.BulletList || Hb(e, t, !1) < 0) && e.text.charCodeAt(e.pos + i - 1) == n.value;
}
c(m5, "lO");
f(m5, "skipForList");
const XA = {
  [H.Blockquote](n, t, e) {
    return e.next != 62 ? !1 : (e.markers.push(_t(H.QuoteMark, t.lineStart + e.pos, t.lineStart + e.pos + 1)), e.moveBase(e.pos + (Ki(e.text.charCodeAt(e.pos + 1)) ? 2 : 1)), n.end = t.lineStart + e.text.length, !0);
  },
  [H.ListItem](n, t, e) {
    return e.indent < e.baseIndent + n.value && e.next > -1 ? !1 : (e.moveBaseColumn(e.baseIndent + n.value), !0);
  },
  [H.OrderedList]: m5,
  [H.BulletList]: m5,
  [H.Document]() {
    return !0;
  }
};
function Ki(n) {
  return n == 32 || n == 9 || n == 10 || n == 13;
}
c(Ki, "Ye$1");
f(Ki, "space$2");
function mh(n, t = 0) {
  for (; t < n.length && Ki(n.charCodeAt(t)); )
    t++;
  return t;
}
c(mh, "Pr$1");
f(mh, "skipSpace");
function g5(n, t, e) {
  for (; t > e && Ki(n.charCodeAt(t - 1)); )
    t--;
  return t;
}
c(g5, "aO");
f(g5, "skipSpaceBack");
function zC(n) {
  if (n.next != 96 && n.next != 126)
    return -1;
  let t = n.pos + 1;
  for (; t < n.text.length && n.text.charCodeAt(t) == n.next; )
    t++;
  if (t < n.pos + 3)
    return -1;
  if (n.next == 96) {
    for (let e = t; e < n.text.length; e++)
      if (n.text.charCodeAt(e) == 96)
        return -1;
  }
  return t;
}
c(zC, "Xp$1");
f(zC, "isFencedCode");
function LC(n) {
  return n.next != 62 ? -1 : n.text.charCodeAt(n.pos + 1) == 32 ? 2 : 1;
}
c(LC, "Ep$1");
f(LC, "isBlockquote");
function Hb(n, t, e) {
  if (n.next != 42 && n.next != 45 && n.next != 95)
    return -1;
  let i = 1;
  for (let s = n.pos + 1; s < n.text.length; s++) {
    let r = n.text.charCodeAt(s);
    if (r == n.next)
      i++;
    else if (!Ki(r))
      return -1;
  }
  return e && n.next == 45 && VC(n) > -1 && n.depth == t.stack.length && t.parser.leafBlockParsers.indexOf(HA.SetextHeading) > -1 || i < 3 ? -1 : 1;
}
c(Hb, "Ah$1");
f(Hb, "isHorizontalRule");
function IC(n, t) {
  for (let e = n.stack.length - 1; e >= 0; e--)
    if (n.stack[e].type == t)
      return !0;
  return !1;
}
c(IC, "Yp$1");
f(IC, "inList");
function Yb(n, t, e) {
  return (n.next == 45 || n.next == 43 || n.next == 42) && (n.pos == n.text.length - 1 || Ki(n.text.charCodeAt(n.pos + 1))) && (!e || IC(t, H.BulletList) || n.skipSpace(n.pos + 2) < n.text.length) ? 1 : -1;
}
c(Yb, "Lh$1");
f(Yb, "isBulletList");
function Gb(n, t, e) {
  let i = n.pos, s = n.next;
  for (; s >= 48 && s <= 57; ) {
    if (i++, i == n.text.length)
      return -1;
    s = n.text.charCodeAt(i);
  }
  return i == n.pos || i > n.pos + 9 || s != 46 && s != 41 || i < n.text.length - 1 && !Ki(n.text.charCodeAt(i + 1)) || e && !IC(t, H.OrderedList) && (n.skipSpace(i + 1) == n.text.length || i > n.pos + 1 || n.next != 49) ? -1 : i + 1 - n.pos;
}
c(Gb, "_h$1");
f(Gb, "isOrderedList");
function WC(n) {
  if (n.next != 35)
    return -1;
  let t = n.pos + 1;
  for (; t < n.text.length && n.text.charCodeAt(t) == 35; )
    t++;
  if (t < n.text.length && n.text.charCodeAt(t) != 32)
    return -1;
  let e = t - n.pos;
  return e > 6 ? -1 : e;
}
c(WC, "Wp$1");
f(WC, "isAtxHeading");
function VC(n) {
  if (n.next != 45 && n.next != 61 || n.indent >= n.baseIndent + 4)
    return -1;
  let t = n.pos + 1;
  for (; t < n.text.length && n.text.charCodeAt(t) == n.next; )
    t++;
  let e = t;
  for (; t < n.text.length && Ki(n.text.charCodeAt(t)); )
    t++;
  return t == n.text.length ? e : -1;
}
c(VC, "Vp$1");
f(VC, "isSetextUnderline");
const w5 = /^[ \t]*$/, NA = /-->/, jA = /\?>/, v5 = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, NA],
  [/^\s*<\?/, jA],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, w5],
  [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, w5]
];
function DC(n, t, e) {
  if (n.next != 60)
    return -1;
  let i = n.text.slice(n.pos);
  for (let s = 0, r = v5.length - (e ? 1 : 0); s < r; s++)
    if (v5[s][0].test(i))
      return s;
  return -1;
}
c(DC, "zp$1");
f(DC, "isHTMLBlock");
function O5(n, t) {
  let e = n.countIndent(t, n.pos, n.indent), i = n.countIndent(n.skipSpace(t), t, e);
  return i >= e + 5 ? e + 1 : i;
}
c(O5, "hO");
f(O5, "getListIndent");
function gr(n, t, e) {
  let i = n.length - 1;
  i >= 0 && n[i].to == t && n[i].type == H.CodeText ? n[i].to = e : n.push(_t(H.CodeText, t, e));
}
c(gr, "Wt$2");
f(gr, "addCodeText");
const K1 = {
  LinkReference: void 0,
  IndentedCode(n, t) {
    let e = t.baseIndent + 4;
    if (t.indent < e)
      return !1;
    let i = t.findColumn(e), s = n.lineStart + i, r = n.lineStart + t.text.length, a = [], o = [];
    for (gr(a, s, r); n.nextLine() && t.depth >= n.stack.length; )
      if (t.pos == t.text.length) {
        gr(o, n.lineStart - 1, n.lineStart);
        for (let l of t.markers)
          o.push(l);
      } else {
        if (t.indent < e)
          break;
        {
          if (o.length) {
            for (let h of o)
              h.type == H.CodeText ? gr(a, h.from, h.to) : a.push(h);
            o = [];
          }
          gr(a, n.lineStart - 1, n.lineStart);
          for (let h of t.markers)
            a.push(h);
          r = n.lineStart + t.text.length;
          let l = n.lineStart + t.findColumn(t.baseIndent + 4);
          l < r && gr(a, l, r);
        }
      }
    return o.length && (o = o.filter((l) => l.type != H.CodeText), o.length && (t.markers = o.concat(t.markers))), n.addNode(n.buffer.writeElements(a, -s).finish(H.CodeBlock, r - s), s), !0;
  },
  FencedCode(n, t) {
    let e = zC(t);
    if (e < 0)
      return !1;
    let i = n.lineStart + t.pos, s = t.next, r = e - t.pos, a = t.skipSpace(e), o = g5(t.text, t.text.length, a), l = [_t(H.CodeMark, i, i + r)];
    a < o && l.push(_t(H.CodeInfo, n.lineStart + a, n.lineStart + o));
    for (let h = !0; n.nextLine() && t.depth >= n.stack.length; h = !1) {
      let u = t.pos;
      if (t.indent - t.baseIndent < 4)
        for (; u < t.text.length && t.text.charCodeAt(u) == s; )
          u++;
      if (u - t.pos >= r && t.skipSpace(u) == t.text.length) {
        for (let p of t.markers)
          l.push(p);
        l.push(_t(H.CodeMark, n.lineStart + t.pos, n.lineStart + u)), n.nextLine();
        break;
      } else {
        h || gr(l, n.lineStart - 1, n.lineStart);
        for (let m of t.markers)
          l.push(m);
        let p = n.lineStart + t.basePos, y = n.lineStart + t.text.length;
        p < y && gr(l, p, y);
      }
    }
    return n.addNode(n.buffer.writeElements(l, -i).finish(H.FencedCode, n.prevLineEnd() - i), i), !0;
  },
  Blockquote(n, t) {
    let e = LC(t);
    return e < 0 ? !1 : (n.startContext(H.Blockquote, t.pos), n.addNode(H.QuoteMark, n.lineStart + t.pos, n.lineStart + t.pos + 1), t.moveBase(t.pos + e), null);
  },
  HorizontalRule(n, t) {
    if (Hb(t, n, !1) < 0)
      return !1;
    let e = n.lineStart + t.pos;
    return n.nextLine(), n.addNode(H.HorizontalRule, e), !0;
  },
  BulletList(n, t) {
    let e = Yb(t, n, !1);
    if (e < 0)
      return !1;
    n.block.type != H.BulletList && n.startContext(H.BulletList, t.basePos, t.next);
    let i = O5(t, t.pos + 1);
    return n.startContext(H.ListItem, t.basePos, i - t.baseIndent), n.addNode(H.ListMark, n.lineStart + t.pos, n.lineStart + t.pos + e), t.moveBaseColumn(i), null;
  },
  OrderedList(n, t) {
    let e = Gb(t, n, !1);
    if (e < 0)
      return !1;
    n.block.type != H.OrderedList && n.startContext(H.OrderedList, t.basePos, t.text.charCodeAt(t.pos + e - 1));
    let i = O5(t, t.pos + e);
    return n.startContext(H.ListItem, t.basePos, i - t.baseIndent), n.addNode(H.ListMark, n.lineStart + t.pos, n.lineStart + t.pos + e), t.moveBaseColumn(i), null;
  },
  ATXHeading(n, t) {
    let e = WC(t);
    if (e < 0)
      return !1;
    let i = t.pos, s = n.lineStart + i, r = g5(t.text, t.text.length, i), a = r;
    for (; a > i && t.text.charCodeAt(a - 1) == t.next; )
      a--;
    (a == r || a == i || !Ki(t.text.charCodeAt(a - 1))) && (a = t.text.length);
    let o = n.buffer.write(H.HeaderMark, 0, e).writeElements(n.parser.parseInline(t.text.slice(i + e + 1, a), s + e + 1), -s);
    a < t.text.length && o.write(H.HeaderMark, a - i, r - i);
    let l = o.finish(H.ATXHeading1 - 1 + e, t.text.length - i);
    return n.nextLine(), n.addNode(l, s), !0;
  },
  HTMLBlock(n, t) {
    let e = DC(t, n, !1);
    if (e < 0)
      return !1;
    let i = n.lineStart + t.pos, s = v5[e][1], r = [], a = s != w5;
    for (; !s.test(t.text) && n.nextLine(); ) {
      if (t.depth < n.stack.length) {
        a = !1;
        break;
      }
      for (let h of t.markers)
        r.push(h);
    }
    a && n.nextLine();
    let o = s == NA ? H.CommentBlock : s == jA ? H.ProcessingInstructionBlock : H.HTMLBlock, l = n.prevLineEnd();
    return n.addNode(n.buffer.writeElements(r, -i).finish(o, l - i), i), !0;
  },
  SetextHeading: void 0
  // Specifies relative precedence for block-continue function
};
var au;
const BA = (au = class {
  constructor(t) {
    this.stage = 0, this.elts = [], this.pos = 0, this.start = t.start, this.advance(t.content);
  }
  nextLine(t, e, i) {
    if (this.stage == -1)
      return !1;
    let s = i.content + `
` + e.scrub(), r = this.advance(s);
    return r > -1 && r < s.length ? this.complete(t, i, r) : !1;
  }
  finish(t, e) {
    return (this.stage == 2 || this.stage == 3) && mh(e.content, this.pos) == e.content.length ? this.complete(t, e, e.content.length) : !1;
  }
  complete(t, e, i) {
    return t.addLeafElement(e, _t(H.LinkReference, this.start, this.start + i, this.elts)), !0;
  }
  nextStage(t) {
    return t ? (this.pos = t.to - this.start, this.elts.push(t), this.stage++, !0) : (t === !1 && (this.stage = -1), !1);
  }
  advance(t) {
    for (; ; ) {
      if (this.stage == -1)
        return -1;
      if (this.stage == 0) {
        if (!this.nextStage(XC(t, this.pos, this.start, !0)))
          return -1;
        if (t.charCodeAt(this.pos) != 58)
          return this.stage = -1;
        this.elts.push(_t(H.LinkMark, this.pos + this.start, this.pos + this.start + 1)), this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(ZC(t, mh(t, this.pos), this.start)))
          return -1;
      } else if (this.stage == 2) {
        let e = mh(t, this.pos), i = 0;
        if (e > this.pos) {
          let s = FC(t, e, this.start);
          if (s) {
            let r = xv(t, s.to - this.start);
            r > 0 && (this.nextStage(s), i = r);
          }
        }
        return i || (i = xv(t, this.pos)), i > 0 && i < t.length ? i : -1;
      } else
        return xv(t, this.pos);
    }
  }
}, c(au, "Rc"), au);
f(BA, "LinkReferenceParser");
let TZ = BA;
function xv(n, t) {
  for (; t < n.length; t++) {
    let e = n.charCodeAt(t);
    if (e == 10)
      break;
    if (!Ki(e))
      return -1;
  }
  return t;
}
c(xv, "zo$1");
f(xv, "lineEnd");
var ou;
const UA = (ou = class {
  nextLine(t, e, i) {
    let s = e.depth < t.stack.length ? -1 : VC(e), r = e.next;
    if (s < 0)
      return !1;
    let a = _t(H.HeaderMark, t.lineStart + e.pos, t.lineStart + s);
    return t.nextLine(), t.addLeafElement(i, _t(r == 61 ? H.SetextHeading1 : H.SetextHeading2, i.start, t.prevLineEnd(), [
      ...t.parser.parseInline(i.content, i.start),
      a
    ])), !0;
  }
  finish() {
    return !1;
  }
}, c(ou, "vc"), ou);
f(UA, "SetextHeadingParser");
let MZ = UA;
const HA = {
  LinkReference(n, t) {
    return t.content.charCodeAt(0) == 91 ? new TZ(t) : null;
  },
  SetextHeading() {
    return new MZ();
  }
}, AZ = [
  (n, t) => WC(t) >= 0,
  (n, t) => zC(t) >= 0,
  (n, t) => LC(t) >= 0,
  (n, t) => Yb(t, n, !0) >= 0,
  (n, t) => Gb(t, n, !0) >= 0,
  (n, t) => Hb(t, n, !0) >= 0,
  (n, t) => DC(t, n, !0) >= 0
], RZ = { text: "", end: 0 };
var lu;
const YA = (lu = class {
  /**
  @internal
  */
  constructor(t, e, i, s) {
    this.parser = t, this.input = e, this.ranges = s, this.line = new QZ(), this.atEnd = !1, this.reusePlaceholders = /* @__PURE__ */ new Map(), this.stoppedAt = null, this.rangeI = 0, this.to = s[s.length - 1].to, this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = s[0].from, this.block = yQ.create(H.Document, 0, this.lineStart, 0, 0), this.stack = [this.block], this.fragments = i.length ? new zZ(i, e) : null, this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
      return this.finish();
    let { line: t } = this;
    for (; ; ) {
      for (let i = 0; ; ) {
        let s = t.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
        for (; i < t.markers.length && (!s || t.markers[i].from < s.end); ) {
          let r = t.markers[i++];
          this.addNode(r.type, r.from, r.to);
        }
        if (!s)
          break;
        this.finishContext();
      }
      if (t.pos < t.text.length)
        break;
      if (!this.nextLine())
        return this.finish();
    }
    if (this.fragments && this.reuseFragment(t.basePos))
      return null;
    t: for (; ; ) {
      for (let i of this.parser.blockParsers)
        if (i) {
          let s = i(this, t);
          if (s != !1) {
            if (s == !0)
              return null;
            t.forward();
            continue t;
          }
        }
      break;
    }
    let e = new PZ(this.lineStart + t.pos, t.text.slice(t.pos));
    for (let i of this.parser.leafBlockParsers)
      if (i) {
        let s = i(this, e);
        s && e.parsers.push(s);
      }
    t: for (; this.nextLine() && t.pos != t.text.length; ) {
      if (t.indent < t.baseIndent + 4) {
        for (let i of this.parser.endLeafBlock)
          if (i(this, t, e))
            break t;
      }
      for (let i of e.parsers)
        if (i.nextLine(this, t, e))
          return null;
      e.content += `
` + t.scrub();
      for (let i of t.markers)
        e.marks.push(i);
    }
    return this.finishLeaf(e), null;
  }
  stopAt(t) {
    if (this.stoppedAt != null && this.stoppedAt < t)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = t;
  }
  reuseFragment(t) {
    if (!this.fragments.moveTo(this.absoluteLineStart + t, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
      return !1;
    let e = this.fragments.takeNodes(this);
    return e ? (this.absoluteLineStart += e, this.lineStart = jC(this.absoluteLineStart, this.ranges), this.moveRangeI(), this.absoluteLineStart < this.to ? (this.lineStart++, this.absoluteLineStart++, this.readLine()) : (this.atEnd = !0, this.readLine()), !0) : !1;
  }
  /**
  The number of parent blocks surrounding the current block.
  */
  get depth() {
    return this.stack.length;
  }
  /**
  Get the type of the parent block at the given depth. When no
  depth is passed, return the type of the innermost parent.
  */
  parentType(t = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[t].type];
  }
  /**
  Move to the next input line. This should only be called by
  (non-composite) [block parsers](#BlockParser.parse) that consume
  the line directly, or leaf block parser
  [`nextLine`](#LeafBlockParser.nextLine) methods when they
  consume the current line (and return true).
  */
  nextLine() {
    return this.lineStart += this.line.text.length, this.absoluteLineEnd >= this.to ? (this.absoluteLineStart = this.absoluteLineEnd, this.atEnd = !0, this.readLine(), !1) : (this.lineStart++, this.absoluteLineStart = this.absoluteLineEnd + 1, this.moveRangeI(), this.readLine(), !0);
  }
  /**
  Retrieve the text of the line after the current one, without
  actually moving the context's current line forward.
  */
  peekLine() {
    return this.scanLine(this.absoluteLineEnd + 1).text;
  }
  moveRangeI() {
    for (; this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to; )
      this.rangeI++, this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
  }
  /**
  @internal
  Collect the text for the next line.
  */
  scanLine(t) {
    let e = RZ;
    if (e.end = t, t >= this.to)
      e.text = "";
    else if (e.text = this.lineChunkAt(t), e.end += e.text.length, this.ranges.length > 1) {
      let i = this.absoluteLineStart, s = this.rangeI;
      for (; this.ranges[s].to < e.end; ) {
        s++;
        let r = this.ranges[s].from, a = this.lineChunkAt(r);
        e.end = r + a.length, e.text = e.text.slice(0, this.ranges[s - 1].to - i) + a, i = e.end - e.text.length;
      }
    }
    return e;
  }
  /**
  @internal
  Populate this.line with the content of the next line. Skip
  leading characters covered by composite blocks.
  */
  readLine() {
    let { line: t } = this, { text: e, end: i } = this.scanLine(this.absoluteLineStart);
    for (this.absoluteLineEnd = i, t.reset(e); t.depth < this.stack.length; t.depth++) {
      let s = this.stack[t.depth], r = this.parser.skipContextMarkup[s.type];
      if (!r)
        throw new Error("Unhandled block context " + H[s.type]);
      let a = this.line.markers.length;
      if (!r(s, this, t)) {
        this.line.markers.length > a && (s.end = this.line.markers[this.line.markers.length - 1].to);
        break;
      }
      t.forward();
    }
  }
  lineChunkAt(t) {
    let e = this.input.chunk(t), i;
    if (this.input.lineChunks)
      i = e == `
` ? "" : e;
    else {
      let s = e.indexOf(`
`);
      i = s < 0 ? e : e.slice(0, s);
    }
    return t + i.length > this.to ? i.slice(0, this.to - t) : i;
  }
  /**
  The end position of the previous line.
  */
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  /**
  @internal
  */
  startContext(t, e, i = 0) {
    this.block = yQ.create(t, i, this.lineStart + e, this.block.hash, this.lineStart + this.line.text.length), this.stack.push(this.block);
  }
  /**
  Start a composite block. Should only be called from [block
  parser functions](#BlockParser.parse) that return null.
  */
  startComposite(t, e, i = 0) {
    this.startContext(this.parser.getNodeType(t), e, i);
  }
  /**
  @internal
  */
  addNode(t, e, i) {
    typeof t == "number" && (t = new zt(this.parser.nodeSet.types[t], im, im, (i ?? this.prevLineEnd()) - e)), this.block.addChild(t, e - this.block.from);
  }
  /**
  Add a block element. Can be called by [block
  parsers](#BlockParser.parse).
  */
  addElement(t) {
    this.block.addChild(t.toTree(this.parser.nodeSet), t.from - this.block.from);
  }
  /**
  Add a block element from a [leaf parser](#LeafBlockParser). This
  makes sure any extra composite block markup (such as blockquote
  markers) inside the block are also added to the syntax tree.
  */
  addLeafElement(t, e) {
    this.addNode(this.buffer.writeElements(RO(e.children, t.marks), -e.from).finish(e.type, e.to - e.from), e.from);
  }
  /**
  @internal
  */
  finishContext() {
    let t = this.stack.pop(), e = this.stack[this.stack.length - 1];
    e.addChild(t.toTree(this.parser.nodeSet), t.from - e.from), this.block = e;
  }
  finish() {
    for (; this.stack.length > 1; )
      this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(t) {
    return this.ranges.length > 1 ? qC(this.ranges, 0, t.topNode, this.ranges[0].from, this.reusePlaceholders) : t;
  }
  /**
  @internal
  */
  finishLeaf(t) {
    for (let i of t.parsers)
      if (i.finish(this, t))
        return;
    let e = RO(this.parser.parseInline(t.content, t.start), t.marks);
    this.addNode(this.buffer.writeElements(e, -t.start).finish(H.Paragraph, t.content.length), t.start);
  }
  elt(t, e, i, s) {
    return typeof t == "string" ? _t(this.parser.getNodeType(t), e, i, s) : new nR(t, e);
  }
  /**
  @internal
  */
  get buffer() {
    return new eR(this.parser.nodeSet);
  }
}, c(lu, "Tc"), lu);
f(YA, "BlockContext");
let EZ = YA;
function qC(n, t, e, i, s) {
  let r = n[t].to, a = [], o = [], l = e.from + i;
  function h(u, p) {
    for (; p ? u >= r : u > r; ) {
      let y = n[t + 1].from - r;
      i += y, u += y, t++, r = n[t].to;
    }
  }
  c(h, "h"), f(h, "movePastNext");
  for (let u = e.firstChild; u; u = u.nextSibling) {
    h(u.from + i, !0);
    let p = u.from + i, y, m = s.get(u.tree);
    m ? y = m : u.to + i > r ? (y = qC(n, t, u, i, s), h(u.to + i, !1)) : y = u.toTree(), a.push(y), o.push(p - l);
  }
  return h(e.to + i, !1), new zt(e.type, a, o, e.to + i - l, e.tree ? e.tree.propValues : void 0);
}
c(qC, "qp$1");
f(qC, "injectGaps");
var No;
const GA = (No = class extends Fb {
  /**
  @internal
  */
  constructor(t, e, i, s, r, a, o, l, h) {
    super(), this.nodeSet = t, this.blockParsers = e, this.leafBlockParsers = i, this.blockNames = s, this.endLeafBlock = r, this.skipContextMarkup = a, this.inlineParsers = o, this.inlineNames = l, this.wrappers = h, this.nodeTypes = /* @__PURE__ */ Object.create(null);
    for (let u of t.types)
      this.nodeTypes[u.name] = u.id;
  }
  createParse(t, e, i) {
    let s = new EZ(this, t, e, i);
    for (let r of this.wrappers)
      s = r(s, t, e, i);
    return s;
  }
  /**
  Reconfigure the parser.
  */
  configure(t) {
    let e = MO(t);
    if (!e)
      return this;
    let { nodeSet: i, skipContextMarkup: s } = this, r = this.blockParsers.slice(), a = this.leafBlockParsers.slice(), o = this.blockNames.slice(), l = this.inlineParsers.slice(), h = this.inlineNames.slice(), u = this.endLeafBlock.slice(), p = this.wrappers;
    if (Ic(e.defineNodes)) {
      s = Object.assign({}, s);
      let y = i.types.slice(), m;
      for (let g of e.defineNodes) {
        let { name: b, block: S, composite: x, style: Q } = typeof g == "string" ? { name: g } : g;
        if (y.some((R) => R.name == b))
          continue;
        x && (s[y.length] = (R, I, V) => x(I, V, R.value));
        let L = y.length, W = x ? ["Block", "BlockContext"] : S ? L >= H.ATXHeading1 && L <= H.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"] : void 0;
        y.push(Be.define({
          id: L,
          name: b,
          props: W && [[Pt.group, W]]
        })), Q && (m || (m = {}), Array.isArray(Q) || Q instanceof Un ? m[b] = Q : Object.assign(m, Q));
      }
      i = new Db(y), m && (i = i.extend(Ql(m)));
    }
    if (Ic(e.props) && (i = i.extend(...e.props)), Ic(e.remove))
      for (let y of e.remove) {
        let m = this.blockNames.indexOf(y), g = this.inlineNames.indexOf(y);
        m > -1 && (r[m] = a[m] = void 0), g > -1 && (l[g] = void 0);
      }
    if (Ic(e.parseBlock))
      for (let y of e.parseBlock) {
        let m = o.indexOf(y.name);
        if (m > -1)
          r[m] = y.parse, a[m] = y.leaf;
        else {
          let g = y.before ? Sg(o, y.before) : y.after ? Sg(o, y.after) + 1 : o.length - 1;
          r.splice(g, 0, y.parse), a.splice(g, 0, y.leaf), o.splice(g, 0, y.name);
        }
        y.endLeaf && u.push(y.endLeaf);
      }
    if (Ic(e.parseInline))
      for (let y of e.parseInline) {
        let m = h.indexOf(y.name);
        if (m > -1)
          l[m] = y.parse;
        else {
          let g = y.before ? Sg(h, y.before) : y.after ? Sg(h, y.after) + 1 : h.length - 1;
          l.splice(g, 0, y.parse), h.splice(g, 0, y.name);
        }
      }
    return e.wrap && (p = p.concat(e.wrap)), new No(i, r, a, o, u, s, l, h, p);
  }
  /**
  @internal
  */
  getNodeType(t) {
    let e = this.nodeTypes[t];
    if (e == null)
      throw new RangeError(`Unknown node type '${t}'`);
    return e;
  }
  /**
  Parse the given piece of inline text at the given offset,
  returning an array of [`Element`](#Element) objects representing
  the inline content.
  */
  parseInline(t, e) {
    let i = new NC(this, t, e);
    t: for (let s = e; s < i.end; ) {
      let r = i.char(s);
      for (let a of this.inlineParsers)
        if (a) {
          let o = a(i, r, s);
          if (o >= 0) {
            s = o;
            continue t;
          }
        }
      s++;
    }
    return i.resolveMarkers(0);
  }
}, c(No, "Qo"), No);
f(GA, "MarkdownParser");
let KA = GA;
function Ic(n) {
  return n != null && n.length > 0;
}
c(Ic, "lr$1");
f(Ic, "nonEmpty");
function MO(n) {
  if (!Array.isArray(n))
    return n;
  if (n.length == 0)
    return null;
  let t = MO(n[0]);
  if (n.length == 1)
    return t;
  let e = MO(n.slice(1));
  if (!e || !t)
    return t || e;
  let i = /* @__PURE__ */ f((a, o) => (a || im).concat(o || im), "conc"), s = t.wrap, r = e.wrap;
  return {
    props: i(t.props, e.props),
    defineNodes: i(t.defineNodes, e.defineNodes),
    parseBlock: i(t.parseBlock, e.parseBlock),
    parseInline: i(t.parseInline, e.parseInline),
    remove: i(t.remove, e.remove),
    wrap: s ? r ? (a, o, l, h) => s(r(a, o, l, h), o, l, h) : s : r
  };
}
c(MO, "Ua$1");
f(MO, "resolveConfig");
function Sg(n, t) {
  let e = n.indexOf(t);
  if (e < 0)
    throw new RangeError(`Position specified relative to unknown parser ${t}`);
  return e;
}
c(Sg, "In$1");
f(Sg, "findName");
let JA = [Be.none];
for (let n = 1, t; t = H[n]; n++)
  JA[n] = Be.define({
    id: n,
    name: t,
    props: n >= H.Escape ? [] : [[Pt.group, n in XA ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
    top: t == "Document"
  });
const im = [];
var cu;
const tR = (cu = class {
  constructor(t) {
    this.nodeSet = t, this.content = [], this.nodes = [];
  }
  write(t, e, i, s = 0) {
    return this.content.push(t, e, i, 4 + s * 4), this;
  }
  writeElements(t, e = 0) {
    for (let i of t)
      i.writeTo(this, e);
    return this;
  }
  finish(t, e) {
    return zt.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: t,
      length: e
    });
  }
}, c(cu, "Ac"), cu);
f(tR, "Buffer");
let eR = tR;
var m2, hu;
let Qw = (m2 = (hu = class {
  /**
  @internal
  */
  constructor(t, e, i, s = im) {
    this.type = t, this.from = e, this.to = i, this.children = s;
  }
  /**
  @internal
  */
  writeTo(t, e) {
    let i = t.content.length;
    t.writeElements(this.children, e), t.content.push(this.type, this.from + e, this.to + e, t.content.length + 4 - i);
  }
  /**
  @internal
  */
  toTree(t) {
    return new eR(t).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
}, c(hu, "_i$1"), hu), f(m2, "Element"), m2);
var du;
const iR = (du = class {
  constructor(t, e) {
    this.tree = t, this.from = e;
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return im;
  }
  writeTo(t, e) {
    t.nodes.push(this.tree), t.content.push(t.nodes.length - 1, this.from + e, this.to + e, -1);
  }
  toTree() {
    return this.tree;
  }
}, c(du, "Lc"), du);
f(iR, "TreeElement");
let nR = iR;
function _t(n, t, e, i) {
  return new Qw(n, t, e, i);
}
c(_t, "W$1");
f(_t, "elt");
const sR = { resolve: "Emphasis", mark: "EmphasisMark" }, rR = { resolve: "Emphasis", mark: "EmphasisMark" }, Ya = {}, AO = {};
var uu;
const aR = (uu = class {
  constructor(t, e, i, s) {
    this.type = t, this.from = e, this.to = i, this.side = s;
  }
}, c(uu, "_c"), uu);
f(aR, "InlineDelimiter");
let Xi = aR;
const mQ = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
let Tw = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  Tw = new RegExp("[\\p{S}|\\p{P}]", "u");
} catch {
}
const g2 = {
  Escape(n, t, e) {
    if (t != 92 || e == n.end - 1)
      return -1;
    let i = n.char(e + 1);
    for (let s = 0; s < mQ.length; s++)
      if (mQ.charCodeAt(s) == i)
        return n.append(_t(H.Escape, e, e + 2));
    return -1;
  },
  Entity(n, t, e) {
    if (t != 38)
      return -1;
    let i = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(n.slice(e + 1, e + 31));
    return i ? n.append(_t(H.Entity, e, e + 1 + i[0].length)) : -1;
  },
  InlineCode(n, t, e) {
    if (t != 96 || e && n.char(e - 1) == 96)
      return -1;
    let i = e + 1;
    for (; i < n.end && n.char(i) == 96; )
      i++;
    let s = i - e, r = 0;
    for (; i < n.end; i++)
      if (n.char(i) == 96) {
        if (r++, r == s && n.char(i + 1) != 96)
          return n.append(_t(H.InlineCode, e, i + 1, [
            _t(H.CodeMark, e, e + s),
            _t(H.CodeMark, i + 1 - s, i + 1)
          ]));
      } else
        r = 0;
    return -1;
  },
  HTMLTag(n, t, e) {
    if (t != 60 || e == n.end - 1)
      return -1;
    let i = n.slice(e + 1, n.end), s = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(i);
    if (s)
      return n.append(_t(H.Autolink, e, e + 1 + s[0].length, [
        _t(H.LinkMark, e, e + 1),
        // url[0] includes the closing bracket, so exclude it from this slice
        _t(H.URL, e + 1, e + s[0].length),
        _t(H.LinkMark, e + s[0].length, e + 1 + s[0].length)
      ]));
    let r = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(i);
    if (r)
      return n.append(_t(H.Comment, e, e + 1 + r[0].length));
    let a = /^\?[^]*?\?>/.exec(i);
    if (a)
      return n.append(_t(H.ProcessingInstruction, e, e + 1 + a[0].length));
    let o = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(i);
    return o ? n.append(_t(H.HTMLTag, e, e + 1 + o[0].length)) : -1;
  },
  Emphasis(n, t, e) {
    if (t != 95 && t != 42)
      return -1;
    let i = e + 1;
    for (; n.char(i) == t; )
      i++;
    let s = n.slice(e - 1, e), r = n.slice(i, i + 1), a = Tw.test(s), o = Tw.test(r), l = /\s|^$/.test(s), h = /\s|^$/.test(r), u = !h && (!o || l || a), p = !l && (!a || h || o), y = u && (t == 42 || !p || a), m = p && (t == 42 || !u || o);
    return n.append(new Xi(t == 95 ? sR : rR, e, i, (y ? 1 : 0) | (m ? 2 : 0)));
  },
  HardBreak(n, t, e) {
    if (t == 92 && n.char(e + 1) == 10)
      return n.append(_t(H.HardBreak, e, e + 2));
    if (t == 32) {
      let i = e + 1;
      for (; n.char(i) == 32; )
        i++;
      if (n.char(i) == 10 && i >= e + 2)
        return n.append(_t(H.HardBreak, e, i + 1));
    }
    return -1;
  },
  Link(n, t, e) {
    return t == 91 ? n.append(new Xi(
      Ya,
      e,
      e + 1,
      1
      /* Mark.Open */
    )) : -1;
  },
  Image(n, t, e) {
    return t == 33 && n.char(e + 1) == 91 ? n.append(new Xi(
      AO,
      e,
      e + 2,
      1
      /* Mark.Open */
    )) : -1;
  },
  LinkEnd(n, t, e) {
    if (t != 93)
      return -1;
    for (let i = n.parts.length - 1; i >= 0; i--) {
      let s = n.parts[i];
      if (s instanceof Xi && (s.type == Ya || s.type == AO)) {
        if (!s.side || n.skipSpace(s.to) == e && !/[(\[]/.test(n.slice(e + 1, e + 2)))
          return n.parts[i] = null, -1;
        let r = n.takeContent(i), a = n.parts[i] = oR(n, r, s.type == Ya ? H.Link : H.Image, s.from, e + 1);
        if (s.type == Ya)
          for (let o = 0; o < i; o++) {
            let l = n.parts[o];
            l instanceof Xi && l.type == Ya && (l.side = 0);
          }
        return a.to;
      }
    }
    return -1;
  }
};
function oR(n, t, e, i, s) {
  let { text: r } = n, a = n.char(s), o = s;
  if (t.unshift(_t(H.LinkMark, i, i + (e == H.Image ? 2 : 1))), t.push(_t(H.LinkMark, s - 1, s)), a == 40) {
    let l = n.skipSpace(s + 1), h = ZC(r, l - n.offset, n.offset), u;
    h && (l = n.skipSpace(h.to), l != h.to && (u = FC(r, l - n.offset, n.offset), u && (l = n.skipSpace(u.to)))), n.char(l) == 41 && (t.push(_t(H.LinkMark, s, s + 1)), o = l + 1, h && t.push(h), u && t.push(u), t.push(_t(H.LinkMark, l, o)));
  } else if (a == 91) {
    let l = XC(r, s - n.offset, n.offset, !1);
    l && (t.push(l), o = l.to);
  }
  return _t(e, i, o, t);
}
c(oR, "sy$1");
f(oR, "finishLink");
function ZC(n, t, e) {
  if (n.charCodeAt(t) == 60) {
    for (let i = t + 1; i < n.length; i++) {
      let s = n.charCodeAt(i);
      if (s == 62)
        return _t(H.URL, t + e, i + 1 + e);
      if (s == 60 || s == 10)
        return !1;
    }
    return null;
  } else {
    let i = 0, s = t;
    for (let r = !1; s < n.length; s++) {
      let a = n.charCodeAt(s);
      if (Ki(a))
        break;
      if (r)
        r = !1;
      else if (a == 40)
        i++;
      else if (a == 41) {
        if (!i)
          break;
        i--;
      } else a == 92 && (r = !0);
    }
    return s > t ? _t(H.URL, t + e, s + e) : s == n.length ? null : !1;
  }
}
c(ZC, "Gp$1");
f(ZC, "parseURL");
function FC(n, t, e) {
  let i = n.charCodeAt(t);
  if (i != 39 && i != 34 && i != 40)
    return !1;
  let s = i == 40 ? 41 : i;
  for (let r = t + 1, a = !1; r < n.length; r++) {
    let o = n.charCodeAt(r);
    if (a)
      a = !1;
    else {
      if (o == s)
        return _t(H.LinkTitle, t + e, r + 1 + e);
      o == 92 && (a = !0);
    }
  }
  return null;
}
c(FC, "Fp$1");
f(FC, "parseLinkTitle");
function XC(n, t, e, i) {
  for (let s = !1, r = t + 1, a = Math.min(n.length, r + 999); r < a; r++) {
    let o = n.charCodeAt(r);
    if (s)
      s = !1;
    else {
      if (o == 93)
        return i ? !1 : _t(H.LinkLabel, t + e, r + 1 + e);
      if (i && !Ki(o) && (i = !1), o == 91)
        return !1;
      o == 92 && (s = !0);
    }
  }
  return null;
}
c(XC, "Hp$1");
f(XC, "parseLinkLabel");
var pu;
const lR = (pu = class {
  /**
  @internal
  */
  constructor(t, e, i) {
    this.parser = t, this.text = e, this.offset = i, this.parts = [];
  }
  /**
  Get the character code at the given (document-relative)
  position.
  */
  char(t) {
    return t >= this.end ? -1 : this.text.charCodeAt(t - this.offset);
  }
  /**
  The position of the end of this inline section.
  */
  get end() {
    return this.offset + this.text.length;
  }
  /**
  Get a substring of this inline section. Again uses
  document-relative positions.
  */
  slice(t, e) {
    return this.text.slice(t - this.offset, e - this.offset);
  }
  /**
  @internal
  */
  append(t) {
    return this.parts.push(t), t.to;
  }
  /**
  Add a [delimiter](#DelimiterType) at this given position. `open`
  and `close` indicate whether this delimiter is opening, closing,
  or both. Returns the end of the delimiter, for convenient
  returning from [parse functions](#InlineParser.parse).
  */
  addDelimiter(t, e, i, s, r) {
    return this.append(new Xi(t, e, i, (s ? 1 : 0) | (r ? 2 : 0)));
  }
  /**
  Returns true when there is an unmatched link or image opening
  token before the current position.
  */
  get hasOpenLink() {
    for (let t = this.parts.length - 1; t >= 0; t--) {
      let e = this.parts[t];
      if (e instanceof Xi && (e.type == Ya || e.type == AO))
        return !0;
    }
    return !1;
  }
  /**
  Add an inline element. Returns the end of the element.
  */
  addElement(t) {
    return this.append(t);
  }
  /**
  Resolve markers between this.parts.length and from, wrapping matched markers in the
  appropriate node and updating the content of this.parts. @internal
  */
  resolveMarkers(t) {
    for (let i = t; i < this.parts.length; i++) {
      let s = this.parts[i];
      if (!(s instanceof Xi && s.type.resolve && s.side & 2))
        continue;
      let r = s.type == sR || s.type == rR, a = s.to - s.from, o, l = i - 1;
      for (; l >= t; l--) {
        let g = this.parts[l];
        if (g instanceof Xi && g.side & 1 && g.type == s.type && // Ignore emphasis delimiters where the character count doesn't match
        !(r && (s.side & 1 || g.side & 2) && (g.to - g.from + a) % 3 == 0 && ((g.to - g.from) % 3 || a % 3))) {
          o = g;
          break;
        }
      }
      if (!o)
        continue;
      let h = s.type.resolve, u = [], p = o.from, y = s.to;
      if (r) {
        let g = Math.min(2, o.to - o.from, a);
        p = o.to - g, y = s.from + g, h = g == 1 ? "Emphasis" : "StrongEmphasis";
      }
      o.type.mark && u.push(this.elt(o.type.mark, p, o.to));
      for (let g = l + 1; g < i; g++)
        this.parts[g] instanceof Qw && u.push(this.parts[g]), this.parts[g] = null;
      s.type.mark && u.push(this.elt(s.type.mark, s.from, y));
      let m = this.elt(h, p, y, u);
      this.parts[l] = r && o.from != p ? new Xi(o.type, o.from, p, o.side) : null, (this.parts[i] = r && s.to != y ? new Xi(s.type, y, s.to, s.side) : null) ? this.parts.splice(i, 0, m) : this.parts[i] = m;
    }
    let e = [];
    for (let i = t; i < this.parts.length; i++) {
      let s = this.parts[i];
      s instanceof Qw && e.push(s);
    }
    return e;
  }
  /**
  Find an opening delimiter of the given type. Returns `null` if
  no delimiter is found, or an index that can be passed to
  [`takeContent`](#InlineContext.takeContent) otherwise.
  */
  findOpeningDelimiter(t) {
    for (let e = this.parts.length - 1; e >= 0; e--) {
      let i = this.parts[e];
      if (i instanceof Xi && i.type == t && i.side & 1)
        return e;
    }
    return null;
  }
  /**
  Remove all inline elements and delimiters starting from the
  given index (which you should get from
  [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
  resolve delimiters inside of them, and return them as an array
  of elements.
  */
  takeContent(t) {
    let e = this.resolveMarkers(t);
    return this.parts.length = t, e;
  }
  /**
  Return the delimiter at the given index. Mostly useful to get
  additional info out of a delimiter index returned by
  [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter).
  Returns null if there is no delimiter at this index.
  */
  getDelimiterAt(t) {
    let e = this.parts[t];
    return e instanceof Xi ? e : null;
  }
  /**
  Skip space after the given (document) position, returning either
  the position of the next non-space character or the end of the
  section.
  */
  skipSpace(t) {
    return mh(this.text, t - this.offset) + this.offset;
  }
  elt(t, e, i, s) {
    return typeof t == "string" ? _t(this.parser.getNodeType(t), e, i, s) : new nR(t, e);
  }
}, c(pu, "Mc"), pu);
f(lR, "InlineContext");
let NC = lR;
NC.linkStart = Ya;
NC.imageStart = AO;
function RO(n, t) {
  if (!t.length)
    return n;
  if (!n.length)
    return t;
  let e = n.slice(), i = 0;
  for (let s of t) {
    for (; i < e.length && e[i].to < s.to; )
      i++;
    if (i < e.length && e[i].from < s.from) {
      let r = e[i];
      r instanceof Qw && (e[i] = new Qw(r.type, r.from, r.to, RO(r.children, [s])));
    } else
      e.splice(i++, 0, s);
  }
  return e;
}
c(RO, "Ia$1");
f(RO, "injectMarks");
const _Z = [H.CodeBlock, H.ListItem, H.OrderedList, H.BulletList];
var w2, fu;
let zZ = (w2 = (fu = class {
  constructor(t, e) {
    this.fragments = t, this.input = e, this.i = 0, this.fragment = null, this.fragmentEnd = -1, this.cursor = null, t.length && (this.fragment = t[this.i++]);
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null, this.cursor = null, this.fragmentEnd = -1;
  }
  moveTo(t, e) {
    for (; this.fragment && this.fragment.to <= t; )
      this.nextFragment();
    if (!this.fragment || this.fragment.from > (t ? t - 1 : 0))
      return !1;
    if (this.fragmentEnd < 0) {
      let r = this.fragment.to;
      for (; r > 0 && this.input.read(r - 1, r) != `
`; )
        r--;
      this.fragmentEnd = r ? r - 1 : 0;
    }
    let i = this.cursor;
    i || (i = this.cursor = this.fragment.tree.cursor(), i.firstChild());
    let s = t + this.fragment.offset;
    for (; i.to <= s; )
      if (!i.parent())
        return !1;
    for (; ; ) {
      if (i.from >= s)
        return this.fragment.from <= e;
      if (!i.childAfter(s))
        return !1;
    }
  }
  matches(t) {
    let e = this.cursor.tree;
    return e && e.prop(Pt.contextHash) == t;
  }
  takeNodes(t) {
    let e = this.cursor, i = this.fragment.offset, s = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0), r = t.absoluteLineStart, a = r, o = t.block.children.length, l = a, h = o;
    for (; ; ) {
      if (e.to - i > s) {
        if (e.type.isAnonymous && e.firstChild())
          continue;
        break;
      }
      let u = jC(e.from - i, t.ranges);
      if (e.to - i <= t.ranges[t.rangeI].to)
        t.addNode(e.tree, u);
      else {
        let p = new zt(t.parser.nodeSet.types[H.Paragraph], [], [], 0, t.block.hashProp);
        t.reusePlaceholders.set(p, e.tree), t.addNode(p, u);
      }
      if (e.type.is("Block") && (_Z.indexOf(e.type.id) < 0 ? (a = e.to - i, o = t.block.children.length) : (a = l, o = h, l = e.to - i, h = t.block.children.length)), !e.nextSibling())
        break;
    }
    for (; t.block.children.length > o; )
      t.block.children.pop(), t.block.positions.pop();
    return a - r;
  }
}, c(fu, "Mi$1"), fu), f(w2, "FragmentCursor"), w2);
function jC(n, t) {
  let e = n;
  for (let i = 1; i < t.length; i++) {
    let s = t[i - 1].to, r = t[i].from;
    s < n && (e -= r - s);
  }
  return e;
}
c(jC, "Kp$1");
f(jC, "toRelative");
const LZ = Ql({
  "Blockquote/...": T.quote,
  HorizontalRule: T.contentSeparator,
  "ATXHeading1/... SetextHeading1/...": T.heading1,
  "ATXHeading2/... SetextHeading2/...": T.heading2,
  "ATXHeading3/...": T.heading3,
  "ATXHeading4/...": T.heading4,
  "ATXHeading5/...": T.heading5,
  "ATXHeading6/...": T.heading6,
  "Comment CommentBlock": T.comment,
  Escape: T.escape,
  Entity: T.character,
  "Emphasis/...": T.emphasis,
  "StrongEmphasis/...": T.strong,
  "Link/... Image/...": T.link,
  "OrderedList/... BulletList/...": T.list,
  "BlockQuote/...": T.quote,
  "InlineCode CodeText": T.monospace,
  "URL Autolink": T.url,
  "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": T.processingInstruction,
  "CodeInfo LinkLabel": T.labelName,
  LinkTitle: T.string,
  Paragraph: T.content
}), IZ = new KA(new Db(JA).extend(LZ), Object.keys(K1).map((n) => K1[n]), Object.keys(K1).map((n) => HA[n]), Object.keys(K1), AZ, XA, Object.keys(g2).map((n) => g2[n]), Object.keys(g2), []);
function cR(n, t, e) {
  let i = [];
  for (let s = n.firstChild, r = t; ; s = s.nextSibling) {
    let a = s ? s.from : e;
    if (a > r && i.push({ from: r, to: a }), !s)
      break;
    r = s.to;
  }
  return i;
}
c(cR, "fy$1");
f(cR, "leftOverSpace");
function hR(n) {
  let { codeParser: t, htmlParser: e } = n;
  return { wrap: mC((i, s) => {
    let r = i.type.id;
    if (t && (r == H.CodeBlock || r == H.FencedCode)) {
      let a = "";
      if (r == H.FencedCode) {
        let l = i.node.getChild(H.CodeInfo);
        l && (a = s.read(l.from, l.to));
      }
      let o = t(a);
      if (o)
        return { parser: o, overlay: /* @__PURE__ */ f((l) => l.type.id == H.CodeText, "overlay") };
    } else if (e && (r == H.HTMLBlock || r == H.HTMLTag || r == H.CommentBlock))
      return { parser: e, overlay: cR(i.node, i.from, i.to) };
    return null;
  }) };
}
c(hR, "cy$1");
f(hR, "parseCode");
const WZ = { resolve: "Strikethrough", mark: "StrikethroughMark" }, VZ = {
  defineNodes: [{
    name: "Strikethrough",
    style: { "Strikethrough/...": T.strikethrough }
  }, {
    name: "StrikethroughMark",
    style: T.processingInstruction
  }],
  parseInline: [{
    name: "Strikethrough",
    parse(n, t, e) {
      if (t != 126 || n.char(e + 1) != 126 || n.char(e + 2) == 126)
        return -1;
      let i = n.slice(e - 1, e), s = n.slice(e + 2, e + 3), r = /\s|^$/.test(i), a = /\s|^$/.test(s), o = Tw.test(i), l = Tw.test(s);
      return n.addDelimiter(WZ, e, e + 2, !a && (!l || r || o), !r && (!o || a || l));
    },
    after: "Emphasis"
  }]
};
function gh(n, t, e = 0, i, s = 0) {
  let r = 0, a = !0, o = -1, l = -1, h = !1, u = /* @__PURE__ */ f(() => {
    i.push(n.elt("TableCell", s + o, s + l, n.parser.parseInline(t.slice(o, l), s + o)));
  }, "parseCell");
  for (let p = e; p < t.length; p++) {
    let y = t.charCodeAt(p);
    y == 124 && !h ? ((!a || o > -1) && r++, a = !1, i && (o > -1 && u(), i.push(n.elt("TableDelimiter", p + s, p + s + 1))), o = l = -1) : (h || y != 32 && y != 9) && (o < 0 && (o = p), l = p + 1), h = !h && y == 92;
  }
  return o > -1 && (r++, i && u()), r;
}
c(gh, "$r$1");
f(gh, "parseRow");
function b5(n, t) {
  for (let e = t; e < n.length; e++) {
    let i = n.charCodeAt(e);
    if (i == 124)
      return !0;
    i == 92 && e++;
  }
  return !1;
}
c(b5, "cO");
f(b5, "hasPipe");
const dR = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
var yu;
const uR = (yu = class {
  constructor() {
    this.rows = null;
  }
  nextLine(t, e, i) {
    if (this.rows == null) {
      this.rows = !1;
      let s;
      if ((e.next == 45 || e.next == 58 || e.next == 124) && dR.test(s = e.text.slice(e.pos))) {
        let r = [];
        gh(t, i.content, 0, r, i.start) == gh(t, s, e.pos) && (this.rows = [
          t.elt("TableHeader", i.start, i.start + i.content.length, r),
          t.elt("TableDelimiter", t.lineStart + e.pos, t.lineStart + e.text.length)
        ]);
      }
    } else if (this.rows) {
      let s = [];
      gh(t, e.text, e.pos, s, t.lineStart), this.rows.push(t.elt("TableRow", t.lineStart + e.pos, t.lineStart + e.text.length, s));
    }
    return !1;
  }
  finish(t, e) {
    return this.rows ? (t.addLeafElement(e, t.elt("Table", e.start, e.start + e.content.length, this.rows)), !0) : !1;
  }
}, c(yu, "Zc"), yu);
f(uR, "TableParser");
let gQ = uR;
const DZ = {
  defineNodes: [
    { name: "Table", block: !0 },
    { name: "TableHeader", style: { "TableHeader/...": T.heading } },
    "TableRow",
    { name: "TableCell", style: T.content },
    { name: "TableDelimiter", style: T.processingInstruction }
  ],
  parseBlock: [{
    name: "Table",
    leaf(n, t) {
      return b5(t.content, 0) ? new gQ() : null;
    },
    endLeaf(n, t, e) {
      if (e.parsers.some((s) => s instanceof gQ) || !b5(t.text, t.basePos))
        return !1;
      let i = n.peekLine();
      return dR.test(i) && gh(n, t.text, t.basePos) == gh(n, i, t.basePos);
    },
    before: "SetextHeading"
  }]
};
var mu;
const pR = (mu = class {
  nextLine() {
    return !1;
  }
  finish(t, e) {
    return t.addLeafElement(e, t.elt("Task", e.start, e.start + e.content.length, [
      t.elt("TaskMarker", e.start, e.start + 3),
      ...t.parser.parseInline(e.content.slice(3), e.start + 3)
    ])), !0;
  }
}, c(mu, "Cc"), mu);
f(pR, "TaskParser");
let qZ = pR;
const ZZ = {
  defineNodes: [
    { name: "Task", block: !0, style: T.list },
    { name: "TaskMarker", style: T.atom }
  ],
  parseBlock: [{
    name: "TaskList",
    leaf(n, t) {
      return /^\[[ xX]\][ \t]/.test(t.content) && n.parentType().name == "ListItem" ? new qZ() : null;
    },
    after: "SetextHeading"
  }]
}, wQ = /(www\.)|(https?:\/\/)|([\w.+-]{1,100}@)|(mailto:|xmpp:)/gy, vQ = /[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy, FZ = /[\w-]+\.[\w-]+($|\/)/, OQ = /[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy, bQ = /\/[a-zA-Z\d@.]+/gy;
function $5(n, t, e, i) {
  let s = 0;
  for (let r = t; r < e; r++)
    n[r] == i && s++;
  return s;
}
c($5, "mO");
f($5, "count");
function fR(n, t) {
  vQ.lastIndex = t;
  let e = vQ.exec(n);
  if (!e || FZ.exec(e[0])[0].indexOf("_") > -1)
    return -1;
  let i = t + e[0].length;
  for (; ; ) {
    let s = n[i - 1], r;
    if (/[?!.,:*_~]/.test(s) || s == ")" && $5(n, t, i, ")") > $5(n, t, i, "("))
      i--;
    else if (s == ";" && (r = /&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(n.slice(t, i))))
      i = t + r.index;
    else
      break;
  }
  return i;
}
c(fR, "gy$1");
f(fR, "autolinkURLEnd");
function x5(n, t) {
  OQ.lastIndex = t;
  let e = OQ.exec(n);
  if (!e)
    return -1;
  let i = e[0][e[0].length - 1];
  return i == "_" || i == "-" ? -1 : t + e[0].length - (i == "." ? 1 : 0);
}
c(x5, "gO");
f(x5, "autolinkEmailEnd");
const XZ = {
  parseInline: [{
    name: "Autolink",
    parse(n, t, e) {
      let i = e - n.offset;
      if (i && /\w/.test(n.text[i - 1]))
        return -1;
      wQ.lastIndex = i;
      let s = wQ.exec(n.text), r = -1;
      if (!s)
        return -1;
      if (s[1] || s[2]) {
        if (r = fR(n.text, i + s[0].length), r > -1 && n.hasOpenLink) {
          let a = /([^\[\]]|\[[^\]]*\])*/.exec(n.text.slice(i, r));
          r = i + a[0].length;
        }
      } else s[3] ? r = x5(n.text, i) : (r = x5(n.text, i + s[0].length), r > -1 && s[0] == "xmpp:" && (bQ.lastIndex = r, s = bQ.exec(n.text), s && (r = s.index + s[0].length)));
      return r < 0 ? -1 : (n.addElement(n.elt("URL", e, r + n.offset)), r + n.offset);
    }
  }]
}, NZ = [DZ, ZZ, VZ, XZ];
function BC(n, t, e) {
  return (i, s, r) => {
    if (s != n || i.char(r + 1) == n)
      return -1;
    let a = [i.elt(e, r, r + 1)];
    for (let o = r + 1; o < i.end; o++) {
      let l = i.char(o);
      if (l == n)
        return i.addElement(i.elt(t, r, o + 1, a.concat(i.elt(e, o, o + 1))));
      if (l == 92 && a.push(i.elt("Escape", o, o++ + 2)), Ki(l))
        break;
    }
    return -1;
  };
}
c(BC, "em$1");
f(BC, "parseSubSuper");
const jZ = {
  defineNodes: [
    { name: "Superscript", style: T.special(T.content) },
    { name: "SuperscriptMark", style: T.processingInstruction }
  ],
  parseInline: [{
    name: "Superscript",
    parse: BC(94, "Superscript", "SuperscriptMark")
  }]
}, BZ = {
  defineNodes: [
    { name: "Subscript", style: T.special(T.content) },
    { name: "SubscriptMark", style: T.processingInstruction }
  ],
  parseInline: [{
    name: "Subscript",
    parse: BC(126, "Subscript", "SubscriptMark")
  }]
}, UZ = {
  defineNodes: [{ name: "Emoji", style: T.character }],
  parseInline: [{
    name: "Emoji",
    parse(n, t, e) {
      let i;
      return t != 58 || !(i = /^[a-zA-Z_0-9]+:/.exec(n.slice(e + 1, n.end))) ? -1 : n.addElement(n.elt("Emoji", e, e + 1 + i[0].length));
    }
  }]
};
var Yr;
const yR = (Yr = class {
  /**
  @internal
  */
  constructor(t, e, i, s, r, a, o, l, h, u = 0, p) {
    this.p = t, this.stack = e, this.state = i, this.reducePos = s, this.pos = r, this.score = a, this.buffer = o, this.bufferBase = l, this.curContext = h, this.lookAhead = u, this.parent = p;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((t, e) => e % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(t, e, i = 0) {
    let s = t.parser.context;
    return new Yr(t, [], e, i, i, 0, [], 0, s ? new $Q(s, s.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(t, e) {
    this.stack.push(this.state, e, this.bufferBase + this.buffer.length), this.state = t;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(t) {
    var e;
    let i = t >> 19, s = t & 65535, { parser: r } = this.p, a = this.reducePos < this.pos - 25;
    a && this.setLookAhead(this.pos);
    let o = r.dynamicPrecedence(s);
    if (o && (this.score += o), i == 0) {
      this.pushState(r.getGoto(this.state, s, !0), this.reducePos), s < r.minRepeatTerm && this.storeNode(s, this.reducePos, this.reducePos, a ? 8 : 4, !0), this.reduceContext(s, this.reducePos);
      return;
    }
    let l = this.stack.length - (i - 1) * 3 - (t & 262144 ? 6 : 0), h = l ? this.stack[l - 2] : this.p.ranges[0].from, u = this.reducePos - h;
    u >= 2e3 && !(!((e = this.p.parser.nodeSet.types[s]) === null || e === void 0) && e.isAnonymous) && (h == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = u) : this.p.lastBigReductionSize < u && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = h, this.p.lastBigReductionSize = u));
    let p = l ? this.stack[l - 1] : 0, y = this.bufferBase + this.buffer.length - p;
    if (s < r.minRepeatTerm || t & 131072) {
      let m = r.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(s, h, m, y + 4, !0);
    }
    if (t & 262144)
      this.state = this.stack[l];
    else {
      let m = this.stack[l - 3];
      this.state = r.getGoto(m, s, !0);
    }
    for (; this.stack.length > l; )
      this.stack.pop();
    this.reduceContext(s, h);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(t, e, i, s = 4, r = !1) {
    if (t == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let a = this, o = this.buffer.length;
      if (o == 0 && a.parent && (o = a.bufferBase - a.parent.bufferBase, a = a.parent), o > 0 && a.buffer[o - 4] == 0 && a.buffer[o - 1] > -1) {
        if (e == i)
          return;
        if (a.buffer[o - 2] >= e) {
          a.buffer[o - 2] = i;
          return;
        }
      }
    }
    if (!r || this.pos == i)
      this.buffer.push(t, e, i, s);
    else {
      let a = this.buffer.length;
      if (a > 0 && (this.buffer[a - 4] != 0 || this.buffer[a - 1] < 0)) {
        let o = !1;
        for (let l = a; l > 0 && this.buffer[l - 2] > i; l -= 4)
          if (this.buffer[l - 1] >= 0) {
            o = !0;
            break;
          }
        if (o)
          for (; a > 0 && this.buffer[a - 2] > i; )
            this.buffer[a] = this.buffer[a - 4], this.buffer[a + 1] = this.buffer[a - 3], this.buffer[a + 2] = this.buffer[a - 2], this.buffer[a + 3] = this.buffer[a - 1], a -= 4, s > 4 && (s -= 4);
      }
      this.buffer[a] = t, this.buffer[a + 1] = e, this.buffer[a + 2] = i, this.buffer[a + 3] = s;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(t, e, i, s) {
    if (t & 131072)
      this.pushState(t & 65535, this.pos);
    else if ((t & 262144) == 0) {
      let r = t, { parser: a } = this.p;
      (s > this.pos || e <= a.maxNode) && (this.pos = s, a.stateFlag(
        r,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = s)), this.pushState(r, i), this.shiftContext(e, i), e <= a.maxNode && this.buffer.push(e, i, s, 4);
    } else
      this.pos = s, this.shiftContext(e, i), e <= this.p.parser.maxNode && this.buffer.push(e, i, s, 4);
  }
  // Apply an action
  /**
  @internal
  */
  apply(t, e, i, s) {
    t & 65536 ? this.reduce(t) : this.shift(t, e, i, s);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(t, e) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != t) && (this.p.reused.push(t), i++);
    let s = this.pos;
    this.reducePos = this.pos = s + t.length, this.pushState(e, s), this.buffer.push(
      i,
      s,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, t, this, this.p.stream.reset(this.pos - t.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let t = this, e = t.buffer.length;
    for (; e > 0 && t.buffer[e - 2] > t.reducePos; )
      e -= 4;
    let i = t.buffer.slice(e), s = t.bufferBase + e;
    for (; t && s == t.bufferBase; )
      t = t.parent;
    return new Yr(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, s, this.curContext, this.lookAhead, t);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(t, e) {
    let i = t <= this.p.parser.maxNode;
    i && this.storeNode(t, this.pos, e, 4), this.storeNode(0, this.pos, e, i ? 8 : 4), this.pos = this.reducePos = e, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(t) {
    for (let e = new YZ(this); ; ) {
      let i = this.p.parser.stateSlot(
        e.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(e.state, t);
      if (i == 0)
        return !1;
      if ((i & 65536) == 0)
        return !0;
      e.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(t) {
    if (this.stack.length >= 300)
      return [];
    let e = this.p.parser.nextStates(this.state);
    if (e.length > 8 || this.stack.length >= 120) {
      let s = [];
      for (let r = 0, a; r < e.length; r += 2)
        (a = e[r + 1]) != this.state && this.p.parser.hasAction(a, t) && s.push(e[r], a);
      if (this.stack.length < 120)
        for (let r = 0; s.length < 8 && r < e.length; r += 2) {
          let a = e[r + 1];
          s.some((o, l) => l & 1 && o == a) || s.push(e[r], a);
        }
      e = s;
    }
    let i = [];
    for (let s = 0; s < e.length && i.length < 4; s += 2) {
      let r = e[s + 1];
      if (r == this.state)
        continue;
      let a = this.split();
      a.pushState(r, this.pos), a.storeNode(0, a.pos, a.pos, 4, !0), a.shiftContext(e[s], this.pos), a.reducePos = this.pos, a.score -= 200, i.push(a);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: t } = this.p, e = t.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((e & 65536) == 0)
      return !1;
    if (!t.validAction(this.state, e)) {
      let i = e >> 19, s = e & 65535, r = this.stack.length - i * 3;
      if (r < 0 || t.getGoto(this.stack[r], s, !1) < 0) {
        let a = this.findForcedReduction();
        if (a == null)
          return !1;
        e = a;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(e), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: t } = this.p, e = [], i = /* @__PURE__ */ f((s, r) => {
      if (!e.includes(s))
        return e.push(s), t.allActions(s, (a) => {
          if (!(a & 393216)) if (a & 65536) {
            let o = (a >> 19) - r;
            if (o > 1) {
              let l = a & 65535, h = this.stack.length - o * 3;
              if (h >= 0 && t.getGoto(this.stack[h], l, !1) >= 0)
                return o << 19 | 65536 | l;
            }
          } else {
            let o = i(a, r + 1);
            if (o != null)
              return o;
          }
        });
    }, "explore");
    return i(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: t } = this.p;
    return t.data[t.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !t.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(t) {
    if (this.state != t.state || this.stack.length != t.stack.length)
      return !1;
    for (let e = 0; e < this.stack.length; e += 3)
      if (this.stack[e] != t.stack[e])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(t) {
    return this.p.parser.dialect.flags[t];
  }
  shiftContext(t, e) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, t, this, this.p.stream.reset(e)));
  }
  reduceContext(t, e) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, t, this, this.p.stream.reset(e)));
  }
  /**
  @internal
  */
  emitContext() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(t) {
    if (t != this.curContext.context) {
      let e = new $Q(this.curContext.tracker, t);
      e.hash != this.curContext.hash && this.emitContext(), this.curContext = e;
    }
  }
  /**
  @internal
  */
  setLookAhead(t) {
    t > this.lookAhead && (this.emitLookAhead(), this.lookAhead = t);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}, c(Yr, "jr"), Yr);
f(yR, "Stack");
let HZ = yR;
var gu;
const mR = (gu = class {
  constructor(t, e) {
    this.tracker = t, this.context = e, this.hash = t.strict ? t.hash(e) : 0;
  }
}, c(gu, "Xc"), gu);
f(mR, "StackContext");
let $Q = mR;
var wu;
const gR = (wu = class {
  constructor(t) {
    this.start = t, this.state = t.state, this.stack = t.stack, this.base = this.stack.length;
  }
  reduce(t) {
    let e = t & 65535, i = t >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let s = this.start.p.parser.getGoto(this.stack[this.base - 3], e, !0);
    this.state = s;
  }
}, c(wu, "Ec"), wu);
f(gR, "SimulatedStack");
let YZ = gR;
var Gr;
const wR = (Gr = class {
  constructor(t, e, i) {
    this.stack = t, this.pos = e, this.index = i, this.buffer = t.buffer, this.index == 0 && this.maybeNext();
  }
  static create(t, e = t.bufferBase + t.buffer.length) {
    return new Gr(t, e, e - t.bufferBase);
  }
  maybeNext() {
    let t = this.stack.parent;
    t != null && (this.index = this.stack.bufferBase - t.bufferBase, this.stack = t, this.buffer = t.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new Gr(this.stack, this.pos, this.index);
  }
}, c(Gr, "qr"), Gr);
f(wR, "StackBufferCursor");
let GZ = wR;
function rh(n, t = Uint16Array) {
  if (typeof n != "string")
    return n;
  let e = null;
  for (let i = 0, s = 0; i < n.length; ) {
    let r = 0;
    for (; ; ) {
      let a = n.charCodeAt(i++), o = !1;
      if (a == 126) {
        r = 65535;
        break;
      }
      a >= 92 && a--, a >= 34 && a--;
      let l = a - 32;
      if (l >= 46 && (l -= 46, o = !0), r += l, o)
        break;
      r *= 46;
    }
    e ? e[s++] = r : e = new t(r);
  }
  return e;
}
c(rh, "pr$1");
f(rh, "decodeArray");
var vu;
const vR = (vu = class {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}, c(vu, "Yc"), vu);
f(vR, "CachedToken");
let kv = vR;
const xQ = new kv();
var Ou;
const OR = (Ou = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.input = t, this.ranges = e, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = xQ, this.rangeIndex = 0, this.pos = this.chunkPos = e[0].from, this.range = e[0], this.end = e[e.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(t, e) {
    let i = this.range, s = this.rangeIndex, r = this.pos + t;
    for (; r < i.from; ) {
      if (!s)
        return null;
      let a = this.ranges[--s];
      r -= i.from - a.to, i = a;
    }
    for (; e < 0 ? r > i.to : r >= i.to; ) {
      if (s == this.ranges.length - 1)
        return null;
      let a = this.ranges[++s];
      r += a.from - i.to, i = a;
    }
    return r;
  }
  /**
  @internal
  */
  clipPos(t) {
    if (t >= this.range.from && t < this.range.to)
      return t;
    for (let e of this.ranges)
      if (e.to > t)
        return Math.max(t, e.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(t) {
    let e = this.chunkOff + t, i, s;
    if (e >= 0 && e < this.chunk.length)
      i = this.pos + t, s = this.chunk.charCodeAt(e);
    else {
      let r = this.resolveOffset(t, 1);
      if (r == null)
        return -1;
      if (i = r, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        s = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let a = this.rangeIndex, o = this.range;
        for (; o.to <= i; )
          o = this.ranges[++a];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > o.to && (this.chunk2 = this.chunk2.slice(0, o.to - i)), s = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), s;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(t, e = 0) {
    let i = e ? this.resolveOffset(e, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = t, this.token.end = i;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(t, e) {
    this.token.value = t, this.token.end = e;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: t, chunkPos: e } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = t, this.chunk2Pos = e, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let t = this.input.chunk(this.pos), e = this.pos + t.length;
      this.chunk = e > this.range.to ? t.slice(0, this.range.to - this.pos) : t, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(t = 1) {
    for (this.chunkOff += t; this.pos + t >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      t -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += t, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(t, e) {
    if (e ? (this.token = e, e.start = t, e.lookAhead = t + 1, e.value = e.extended = -1) : this.token = xQ, this.pos != t) {
      if (this.pos = t, t == this.end)
        return this.setDone(), this;
      for (; t < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; t >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      t >= this.chunkPos && t < this.chunkPos + this.chunk.length ? this.chunkOff = t - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(t, e) {
    if (t >= this.chunkPos && e <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(t - this.chunkPos, e - this.chunkPos);
    if (t >= this.chunk2Pos && e <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(t - this.chunk2Pos, e - this.chunk2Pos);
    if (t >= this.range.from && e <= this.range.to)
      return this.input.read(t, e);
    let i = "";
    for (let s of this.ranges) {
      if (s.from >= e)
        break;
      s.to > t && (i += this.input.read(Math.max(s.from, t), Math.min(s.to, e)));
    }
    return i;
  }
}, c(Ou, "Wc"), Ou);
f(OR, "InputStream");
let KZ = OR;
var bu;
const bR = (bu = class {
  constructor(t, e) {
    this.data = t, this.id = e;
  }
  token(t, e) {
    let { parser: i } = e.p;
    UC(this.data, t, e, this.id, i.data, i.tokenPrecTable);
  }
}, c(bu, "Vc"), bu);
f(bR, "TokenGroup");
let wh = bR;
wh.prototype.contextual = wh.prototype.fallback = wh.prototype.extend = !1;
var $u;
const $R = ($u = class {
  constructor(t, e, i) {
    this.precTable = e, this.elseToken = i, this.data = typeof t == "string" ? rh(t) : t;
  }
  token(t, e) {
    let i = t.pos, s = 0;
    for (; ; ) {
      let r = t.next < 0, a = t.resolveOffset(1, 1);
      if (UC(this.data, t, e, 0, this.data, this.precTable), t.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (r || s++, a == null)
        break;
      t.reset(a, t.token);
    }
    s && (t.reset(i, t.token), t.acceptToken(this.elseToken, s));
  }
}, c($u, "Uc"), $u);
f($R, "LocalTokenGroup");
let EO = $R;
EO.prototype.contextual = wh.prototype.fallback = wh.prototype.extend = !1;
var xu;
const xR = (xu = class {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(t, e = {}) {
    this.token = t, this.contextual = !!e.contextual, this.fallback = !!e.fallback, this.extend = !!e.extend;
  }
}, c(xu, "Ic"), xu);
f(xR, "ExternalTokenizer");
let Ji = xR;
function UC(n, t, e, i, s, r) {
  let a = 0, o = 1 << i, { dialect: l } = e.p.parser;
  t: for (; (o & n[a]) != 0; ) {
    let h = n[a + 1];
    for (let m = a + 3; m < h; m += 2)
      if ((n[m + 1] & o) > 0) {
        let g = n[m];
        if (l.allows(g) && (t.token.value == -1 || t.token.value == g || kR(g, t.token.value, s, r))) {
          t.acceptToken(g);
          break;
        }
      }
    let u = t.next, p = 0, y = n[a + 2];
    if (t.next < 0 && y > p && n[h + y * 3 - 3] == 65535) {
      a = n[h + y * 3 - 1];
      continue t;
    }
    for (; p < y; ) {
      let m = p + y >> 1, g = h + m + (m << 1), b = n[g], S = n[g + 1] || 65536;
      if (u < b)
        y = m;
      else if (u >= S)
        p = m + 1;
      else {
        a = n[g + 2], t.advance();
        continue t;
      }
    }
    break;
  }
}
c(UC, "tm$1");
f(UC, "readToken");
function k5(n, t, e) {
  for (let i = t, s; (s = n[i]) != 65535; i++)
    if (s == e)
      return i - t;
  return -1;
}
c(k5, "yO");
f(k5, "findOffset");
function kR(n, t, e, i) {
  let s = k5(e, i, t);
  return s < 0 || k5(e, i, n) < s;
}
c(kR, "xy$1");
f(kR, "overrides");
const Di = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let v2 = null;
function S5(n, t, e) {
  let i = n.cursor(Zt.IncludeAnonymous);
  for (i.moveTo(t); ; )
    if (!(e < 0 ? i.childBefore(t) : i.childAfter(t)))
      for (; ; ) {
        if ((e < 0 ? i.to < t : i.from > t) && !i.type.isError)
          return e < 0 ? Math.max(0, Math.min(
            i.to - 1,
            t - 25
            /* Lookahead.Margin */
          )) : Math.min(n.length, Math.max(
            i.from + 1,
            t + 25
            /* Lookahead.Margin */
          ));
        if (e < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return e < 0 ? 0 : n.length;
      }
}
c(S5, "SO");
f(S5, "cutAt");
var ku;
const SR = (ku = class {
  constructor(t, e) {
    this.fragments = t, this.nodeSet = e, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let t = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (t) {
      for (this.safeFrom = t.openStart ? S5(t.tree, t.from + t.offset, 1) - t.offset : t.from, this.safeTo = t.openEnd ? S5(t.tree, t.to + t.offset, -1) - t.offset : t.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(t.tree), this.start.push(-t.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(t) {
    if (t < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= t; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let e = this.trees.length - 1;
      if (e < 0)
        return this.nextFragment(), null;
      let i = this.trees[e], s = this.index[e];
      if (s == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let r = i.children[s], a = this.start[e] + i.positions[s];
      if (a > t)
        return this.nextStart = a, null;
      if (r instanceof zt) {
        if (a == t) {
          if (a < this.safeFrom)
            return null;
          let o = a + r.length;
          if (o <= this.safeTo) {
            let l = r.prop(Pt.lookAhead);
            if (!l || o + l < this.fragment.to)
              return r;
          }
        }
        this.index[e]++, a + r.length >= Math.max(this.safeFrom, t) && (this.trees.push(r), this.start.push(a), this.index.push(0));
      } else
        this.index[e]++, this.nextStart = a + r.length;
    }
  }
}, c(ku, "zc"), ku);
f(SR, "FragmentCursor");
let JZ = SR;
var Su;
const CR = (Su = class {
  constructor(t, e) {
    this.stream = e, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = t.tokenizers.map((i) => new kv());
  }
  getActions(t) {
    let e = 0, i = null, { parser: s } = t.p, { tokenizers: r } = s, a = s.stateSlot(
      t.state,
      3
      /* ParseState.TokenizerMask */
    ), o = t.curContext ? t.curContext.hash : 0, l = 0;
    for (let h = 0; h < r.length; h++) {
      if ((1 << h & a) == 0)
        continue;
      let u = r[h], p = this.tokens[h];
      if (!(i && !u.fallback) && ((u.contextual || p.start != t.pos || p.mask != a || p.context != o) && (this.updateCachedToken(p, u, t), p.mask = a, p.context = o), p.lookAhead > p.end + 25 && (l = Math.max(p.lookAhead, l)), p.value != 0)) {
        let y = e;
        if (p.extended > -1 && (e = this.addActions(t, p.extended, p.end, e)), e = this.addActions(t, p.value, p.end, e), !u.extend && (i = p, e > y))
          break;
      }
    }
    for (; this.actions.length > e; )
      this.actions.pop();
    return l && t.setLookAhead(l), !i && t.pos == this.stream.end && (i = new kv(), i.value = t.p.parser.eofTerm, i.start = i.end = t.pos, e = this.addActions(t, i.value, i.end, e)), this.mainToken = i, this.actions;
  }
  getMainToken(t) {
    if (this.mainToken)
      return this.mainToken;
    let e = new kv(), { pos: i, p: s } = t;
    return e.start = i, e.end = Math.min(i + 1, s.stream.end), e.value = i == s.stream.end ? s.parser.eofTerm : 0, e;
  }
  updateCachedToken(t, e, i) {
    let s = this.stream.clipPos(i.pos);
    if (e.token(this.stream.reset(s, t), i), t.value > -1) {
      let { parser: r } = i.p;
      for (let a = 0; a < r.specialized.length; a++)
        if (r.specialized[a] == t.value) {
          let o = r.specializers[a](this.stream.read(t.start, t.end), i);
          if (o >= 0 && i.p.parser.dialect.allows(o >> 1)) {
            (o & 1) == 0 ? t.value = o >> 1 : t.extended = o >> 1;
            break;
          }
        }
    } else
      t.value = 0, t.end = this.stream.clipPos(s + 1);
  }
  putAction(t, e, i, s) {
    for (let r = 0; r < s; r += 3)
      if (this.actions[r] == t)
        return s;
    return this.actions[s++] = t, this.actions[s++] = e, this.actions[s++] = i, s;
  }
  addActions(t, e, i, s) {
    let { state: r } = t, { parser: a } = t.p, { data: o } = a;
    for (let l = 0; l < 2; l++)
      for (let h = a.stateSlot(
        r,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; h += 3) {
        if (o[h] == 65535)
          if (o[h + 1] == 1)
            h = Hn(o, h + 2);
          else {
            s == 0 && o[h + 1] == 2 && (s = this.putAction(Hn(o, h + 2), e, i, s));
            break;
          }
        o[h] == e && (s = this.putAction(Hn(o, h + 1), e, i, s));
      }
    return s;
  }
}, c(Su, "jc"), Su);
f(CR, "TokenCache");
let tF = CR;
var Cu;
const PR = (Cu = class {
  constructor(t, e, i, s) {
    this.parser = t, this.input = e, this.ranges = s, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new KZ(e, s), this.tokens = new tF(t, this.stream), this.topTerm = t.top[1];
    let { from: r } = s[0];
    this.stacks = [HZ.start(this, t.top[0], r)], this.fragments = i.length && this.stream.end - r > t.bufferLength * 4 ? new JZ(i, t.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let t = this.stacks, e = this.minStackPos, i = this.stacks = [], s, r;
    if (this.bigReductionCount > 300 && t.length == 1) {
      let [a] = t;
      for (; a.forceReduce() && a.stack.length && a.stack[a.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let a = 0; a < t.length; a++) {
      let o = t[a];
      for (; ; ) {
        if (this.tokens.mainToken = null, o.pos > e)
          i.push(o);
        else {
          if (this.advanceStack(o, i, t))
            continue;
          {
            s || (s = [], r = []), s.push(o);
            let l = this.tokens.getMainToken(o);
            r.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let a = s && RR(s);
      if (a)
        return Di && console.log("Finish with " + this.stackID(a)), this.stackToTree(a);
      if (this.parser.strict)
        throw Di && s && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + e);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && s) {
      let a = this.stoppedAt != null && s[0].pos > this.stoppedAt ? s[0] : this.runRecovery(s, r, i);
      if (a)
        return Di && console.log("Force-finish " + this.stackID(a)), this.stackToTree(a.forceAll());
    }
    if (this.recovering) {
      let a = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > a)
        for (i.sort((o, l) => l.score - o.score); i.length > a; )
          i.pop();
      i.some((o) => o.reducePos > e) && this.recovering--;
    } else if (i.length > 1) {
      t: for (let a = 0; a < i.length - 1; a++) {
        let o = i[a];
        for (let l = a + 1; l < i.length; l++) {
          let h = i[l];
          if (o.sameState(h) || o.buffer.length > 500 && h.buffer.length > 500)
            if ((o.score - h.score || o.buffer.length - h.buffer.length) > 0)
              i.splice(l--, 1);
            else {
              i.splice(a--, 1);
              continue t;
            }
        }
      }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let a = 1; a < i.length; a++)
      i[a].pos < this.minStackPos && (this.minStackPos = i[a].pos);
    return null;
  }
  stopAt(t) {
    if (this.stoppedAt != null && this.stoppedAt < t)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = t;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(t, e, i) {
    let s = t.pos, { parser: r } = this, a = Di ? this.stackID(t) + " -> " : "";
    if (this.stoppedAt != null && s > this.stoppedAt)
      return t.forceReduce() ? t : null;
    if (this.fragments) {
      let h = t.curContext && t.curContext.tracker.strict, u = h ? t.curContext.hash : 0;
      for (let p = this.fragments.nodeAt(s); p; ) {
        let y = this.parser.nodeSet.types[p.type.id] == p.type ? r.getGoto(t.state, p.type.id) : -1;
        if (y > -1 && p.length && (!h || (p.prop(Pt.contextHash) || 0) == u))
          return t.useNode(p, y), Di && console.log(a + this.stackID(t) + ` (via reuse of ${r.getName(p.type.id)})`), !0;
        if (!(p instanceof zt) || p.children.length == 0 || p.positions[0] > 0)
          break;
        let m = p.children[0];
        if (m instanceof zt && p.positions[0] == 0)
          p = m;
        else
          break;
      }
    }
    let o = r.stateSlot(
      t.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (o > 0)
      return t.reduce(o), Di && console.log(a + this.stackID(t) + ` (via always-reduce ${r.getName(
        o & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (t.stack.length >= 8400)
      for (; t.stack.length > 6e3 && t.forceReduce(); )
        ;
    let l = this.tokens.getActions(t);
    for (let h = 0; h < l.length; ) {
      let u = l[h++], p = l[h++], y = l[h++], m = h == l.length || !i, g = m ? t : t.split(), b = this.tokens.mainToken;
      if (g.apply(u, p, b ? b.start : g.pos, y), Di && console.log(a + this.stackID(g) + ` (via ${(u & 65536) == 0 ? "shift" : `reduce of ${r.getName(
        u & 65535
        /* Action.ValueMask */
      )}`} for ${r.getName(p)} @ ${s}${g == t ? "" : ", split"})`), m)
        return !0;
      g.pos > s ? e.push(g) : i.push(g);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(t, e) {
    let i = t.pos;
    for (; ; ) {
      if (!this.advanceStack(t, null, null))
        return !1;
      if (t.pos > i)
        return C5(t, e), !0;
    }
  }
  runRecovery(t, e, i) {
    let s = null, r = !1;
    for (let a = 0; a < t.length; a++) {
      let o = t[a], l = e[a << 1], h = e[(a << 1) + 1], u = Di ? this.stackID(o) + " -> " : "";
      if (o.deadEnd && (r || (r = !0, o.restart(), Di && console.log(u + this.stackID(o) + " (restarted)"), this.advanceFully(o, i))))
        continue;
      let p = o.split(), y = u;
      for (let m = 0; m < 10 && p.forceReduce() && (Di && console.log(y + this.stackID(p) + " (via force-reduce)"), !this.advanceFully(p, i)); m++)
        Di && (y = this.stackID(p) + " -> ");
      for (let m of o.recoverByInsert(l))
        Di && console.log(u + this.stackID(m) + " (via recover-insert)"), this.advanceFully(m, i);
      this.stream.end > o.pos ? (h == o.pos && (h++, l = 0), o.recoverByDelete(l, h), Di && console.log(u + this.stackID(o) + ` (via recover-delete ${this.parser.getName(l)})`), C5(o, i)) : (!s || s.score < o.score) && (s = o);
    }
    return s;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(t) {
    return t.close(), zt.build({
      buffer: GZ.create(t),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: t.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(t) {
    let e = (v2 || (v2 = /* @__PURE__ */ new WeakMap())).get(t);
    return e || v2.set(t, e = String.fromCodePoint(this.nextStackID++)), e + t;
  }
}, c(Cu, "qc"), Cu);
f(PR, "Parse");
let eF = PR;
function C5(n, t) {
  for (let e = 0; e < t.length; e++) {
    let i = t[e];
    if (i.pos == n.pos && i.sameState(n)) {
      t[e].score < n.score && (t[e] = n);
      return;
    }
  }
  t.push(n);
}
c(C5, "bO");
f(C5, "pushStackDedup");
var Pu;
const QR = (Pu = class {
  constructor(t, e, i) {
    this.source = t, this.flags = e, this.disabled = i;
  }
  allows(t) {
    return !this.disabled || this.disabled[t] == 0;
  }
}, c(Pu, "Bc"), Pu);
f(QR, "Dialect");
let iF = QR;
const O2 = /* @__PURE__ */ f((n) => n, "id");
var Qu;
const TR = (Qu = class {
  /**
  Define a context tracker.
  */
  constructor(t) {
    this.start = t.start, this.shift = t.shift || O2, this.reduce = t.reduce || O2, this.reuse = t.reuse || O2, this.hash = t.hash || (() => 0), this.strict = t.strict !== !1;
  }
}, c(Qu, "Dc"), Qu);
f(TR, "ContextTracker");
let MR = TR;
var Kr;
const AR = (Kr = class extends Fb {
  /**
  @internal
  */
  constructor(t) {
    if (super(), this.wrappers = [], t.version != 14)
      throw new RangeError(`Parser version (${t.version}) doesn't match runtime version (14)`);
    let e = t.nodeNames.split(" ");
    this.minRepeatTerm = e.length;
    for (let o = 0; o < t.repeatNodeCount; o++)
      e.push("");
    let i = Object.keys(t.topRules).map((o) => t.topRules[o][1]), s = [];
    for (let o = 0; o < e.length; o++)
      s.push([]);
    function r(o, l, h) {
      s[o].push([l, l.deserialize(String(h))]);
    }
    if (c(r, "s"), f(r, "setProp"), t.nodeProps)
      for (let o of t.nodeProps) {
        let l = o[0];
        typeof l == "string" && (l = Pt[l]);
        for (let h = 1; h < o.length; ) {
          let u = o[h++];
          if (u >= 0)
            r(u, l, o[h++]);
          else {
            let p = o[h + -u];
            for (let y = -u; y > 0; y--)
              r(o[h++], l, p);
            h++;
          }
        }
      }
    this.nodeSet = new Db(e.map((o, l) => Be.define({
      name: l >= this.minRepeatTerm ? void 0 : o,
      id: l,
      props: s[l],
      top: i.indexOf(l) > -1,
      error: l == 0,
      skipped: t.skippedNodes && t.skippedNodes.indexOf(l) > -1
    }))), t.propSources && (this.nodeSet = this.nodeSet.extend(...t.propSources)), this.strict = !1, this.bufferLength = NT;
    let a = rh(t.tokenData);
    this.context = t.context, this.specializerSpecs = t.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let o = 0; o < this.specializerSpecs.length; o++)
      this.specialized[o] = this.specializerSpecs[o].term;
    this.specializers = this.specializerSpecs.map(P5), this.states = rh(t.states, Uint32Array), this.data = rh(t.stateData), this.goto = rh(t.goto), this.maxTerm = t.maxTerm, this.tokenizers = t.tokenizers.map((o) => typeof o == "number" ? new wh(a, o) : o), this.topRules = t.topRules, this.dialects = t.dialects || {}, this.dynamicPrecedences = t.dynamicPrecedences || null, this.tokenPrecTable = t.tokenPrec, this.termNames = t.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(t, e, i) {
    let s = new eF(this, t, e, i);
    for (let r of this.wrappers)
      s = r(s, t, e, i);
    return s;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(t, e, i = !1) {
    let s = this.goto;
    if (e >= s[0])
      return -1;
    for (let r = s[e + 1]; ; ) {
      let a = s[r++], o = a & 1, l = s[r++];
      if (o && i)
        return l;
      for (let h = r + (a >> 1); r < h; r++)
        if (s[r] == t)
          return l;
      if (o)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(t, e) {
    let i = this.data;
    for (let s = 0; s < 2; s++)
      for (let r = this.stateSlot(
        t,
        s ? 2 : 1
        /* ParseState.Actions */
      ), a; ; r += 3) {
        if ((a = i[r]) == 65535)
          if (i[r + 1] == 1)
            a = i[r = Hn(i, r + 2)];
          else {
            if (i[r + 1] == 2)
              return Hn(i, r + 2);
            break;
          }
        if (a == e || a == 0)
          return Hn(i, r + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(t, e) {
    return this.states[t * 6 + e];
  }
  /**
  @internal
  */
  stateFlag(t, e) {
    return (this.stateSlot(
      t,
      0
      /* ParseState.Flags */
    ) & e) > 0;
  }
  /**
  @internal
  */
  validAction(t, e) {
    return !!this.allActions(t, (i) => i == e ? !0 : null);
  }
  /**
  @internal
  */
  allActions(t, e) {
    let i = this.stateSlot(
      t,
      4
      /* ParseState.DefaultReduce */
    ), s = i ? e(i) : void 0;
    for (let r = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); s == null; r += 3) {
      if (this.data[r] == 65535)
        if (this.data[r + 1] == 1)
          r = Hn(this.data, r + 2);
        else
          break;
      s = e(Hn(this.data, r + 1));
    }
    return s;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(t) {
    let e = [];
    for (let i = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = Hn(this.data, i + 2);
        else
          break;
      if ((this.data[i + 2] & 1) == 0) {
        let s = this.data[i + 1];
        e.some((r, a) => a & 1 && r == s) || e.push(this.data[i], s);
      }
    }
    return e;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(t) {
    let e = Object.assign(Object.create(Kr.prototype), this);
    if (t.props && (e.nodeSet = this.nodeSet.extend(...t.props)), t.top) {
      let i = this.topRules[t.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${t.top}`);
      e.top = i;
    }
    return t.tokenizers && (e.tokenizers = this.tokenizers.map((i) => {
      let s = t.tokenizers.find((r) => r.from == i);
      return s ? s.to : i;
    })), t.specializers && (e.specializers = this.specializers.slice(), e.specializerSpecs = this.specializerSpecs.map((i, s) => {
      let r = t.specializers.find((o) => o.from == i.external);
      if (!r)
        return i;
      let a = Object.assign(Object.assign({}, i), { external: r.to });
      return e.specializers[s] = P5(a), a;
    })), t.contextTracker && (e.context = t.contextTracker), t.dialect && (e.dialect = this.parseDialect(t.dialect)), t.strict != null && (e.strict = t.strict), t.wrap && (e.wrappers = e.wrappers.concat(t.wrap)), t.bufferLength != null && (e.bufferLength = t.bufferLength), e;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(t) {
    return this.termNames ? this.termNames[t] : String(t <= this.maxNode && this.nodeSet.types[t].name || t);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(t) {
    let e = this.dynamicPrecedences;
    return e == null ? 0 : e[t] || 0;
  }
  /**
  @internal
  */
  parseDialect(t) {
    let e = Object.keys(this.dialects), i = e.map(() => !1);
    if (t)
      for (let r of t.split(" ")) {
        let a = e.indexOf(r);
        a >= 0 && (i[a] = !0);
      }
    let s = null;
    for (let r = 0; r < e.length; r++)
      if (!i[r])
        for (let a = this.dialects[e[r]], o; (o = this.data[a++]) != 65535; )
          (s || (s = new Uint8Array(this.maxTerm + 1)))[o] = 1;
    return new iF(t, i, s);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(t) {
    return new Kr(t);
  }
}, c(Kr, "Br"), Kr);
f(AR, "LRParser");
let HC = AR;
function Hn(n, t) {
  return n[t] | n[t + 1] << 16;
}
c(Hn, "at$2");
f(Hn, "pair");
function RR(n) {
  let t = null;
  for (let e of n) {
    let i = e.p.stoppedAt;
    (e.pos == e.p.stream.end || i != null && e.pos > i) && e.p.parser.stateFlag(
      e.state,
      2
      /* StateFlag.Accepting */
    ) && (!t || t.score < e.score) && (t = e);
  }
  return t;
}
c(RR, "ky$1");
f(RR, "findFinished");
function P5(n) {
  if (n.external) {
    let t = n.extend ? 1 : 0;
    return (e, i) => n.external(e, i) << 1 | t;
  }
  return n.get;
}
c(P5, "wO");
f(P5, "getSpecializer");
const nF = 55, sF = 1, rF = 56, aF = 2, oF = 57, lF = 3, kQ = 4, cF = 5, YC = 6, ER = 7, _R = 8, zR = 9, LR = 10, hF = 11, dF = 12, uF = 13, b2 = 58, pF = 14, fF = 15, SQ = 59, IR = 21, yF = 23, WR = 24, mF = 25, Q5 = 27, VR = 28, gF = 29, wF = 32, vF = 35, OF = 37, bF = 38, $F = 0, xF = 1, kF = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, SF = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, CQ = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function DR(n) {
  return n == 45 || n == 46 || n == 58 || n >= 65 && n <= 90 || n == 95 || n >= 97 && n <= 122 || n >= 161;
}
c(DR, "Ny$1");
f(DR, "nameChar");
let PQ = null, QQ = null, TQ = 0;
function _O(n, t) {
  let e = n.pos + t;
  if (TQ == e && QQ == n) return PQ;
  let i = n.peek(t), s = "";
  for (; DR(i); )
    s += String.fromCharCode(i), i = n.peek(++t);
  return QQ = n, TQ = e, PQ = s ? s.toLowerCase() : i == CF || i == PF ? void 0 : null;
}
c(_O, "Ja$1");
f(_O, "tagNameAfter");
const qR = 60, zO = 62, GC = 47, CF = 63, PF = 33, QF = 45;
function T5(n, t) {
  this.name = n, this.parent = t;
}
c(T5, "TO");
f(T5, "ElementContext");
const TF = [YC, LR, ER, _R, zR], MF = new MR({
  start: null,
  shift(n, t, e, i) {
    return TF.indexOf(t) > -1 ? new T5(_O(i, 1) || "", n) : n;
  },
  reduce(n, t) {
    return t == IR && n ? n.parent : n;
  },
  reuse(n, t, e, i) {
    let s = t.type.id;
    return s == YC || s == OF ? new T5(_O(i, 1) || "", n) : n;
  },
  strict: !1
}), AF = new Ji((n, t) => {
  if (n.next != qR) {
    n.next < 0 && t.context && n.acceptToken(b2);
    return;
  }
  n.advance();
  let e = n.next == GC;
  e && n.advance();
  let i = _O(n, 0);
  if (i === void 0) return;
  if (!i) return n.acceptToken(e ? fF : pF);
  let s = t.context ? t.context.name : null;
  if (e) {
    if (i == s) return n.acceptToken(hF);
    if (s && SF[s]) return n.acceptToken(b2, -2);
    if (t.dialectEnabled($F)) return n.acceptToken(dF);
    for (let r = t.context; r; r = r.parent) if (r.name == i) return;
    n.acceptToken(uF);
  } else {
    if (i == "script") return n.acceptToken(ER);
    if (i == "style") return n.acceptToken(_R);
    if (i == "textarea") return n.acceptToken(zR);
    if (kF.hasOwnProperty(i)) return n.acceptToken(LR);
    s && CQ[s] && CQ[s][i] ? n.acceptToken(b2, -1) : n.acceptToken(YC);
  }
}, { contextual: !0 }), RF = new Ji((n) => {
  for (let t = 0, e = 0; ; e++) {
    if (n.next < 0) {
      e && n.acceptToken(SQ);
      break;
    }
    if (n.next == QF)
      t++;
    else if (n.next == zO && t >= 2) {
      e >= 3 && n.acceptToken(SQ, -2);
      break;
    } else
      t = 0;
    n.advance();
  }
});
function ZR(n) {
  for (; n; n = n.parent)
    if (n.name == "svg" || n.name == "math") return !0;
  return !1;
}
c(ZR, "iS");
f(ZR, "inForeignElement");
const EF = new Ji((n, t) => {
  if (n.next == GC && n.peek(1) == zO) {
    let e = t.dialectEnabled(xF) || ZR(t.context);
    n.acceptToken(e ? cF : kQ, 2);
  } else n.next == zO && n.acceptToken(kQ, 1);
});
function Kb(n, t, e) {
  let i = 2 + n.length;
  return new Ji((s) => {
    for (let r = 0, a = 0, o = 0; ; o++) {
      if (s.next < 0) {
        o && s.acceptToken(t);
        break;
      }
      if (r == 0 && s.next == qR || r == 1 && s.next == GC || r >= 2 && r < i && s.next == n.charCodeAt(r - 2))
        r++, a++;
      else if (r == i && s.next == zO) {
        o > a ? s.acceptToken(t, -a) : s.acceptToken(e, -(a - 2));
        break;
      } else if ((s.next == 10 || s.next == 13) && o) {
        s.acceptToken(t, 1);
        break;
      } else
        r = a = 0;
      s.advance();
    }
  });
}
c(Kb, "Ch$1");
f(Kb, "contentTokenizer");
const _F = Kb("script", nF, sF), zF = Kb("style", rF, aF), LF = Kb("textarea", oF, lF), IF = Ql({
  "Text RawText IncompleteTag IncompleteCloseTag": T.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": T.angleBracket,
  TagName: T.tagName,
  "MismatchedCloseTag/TagName": [T.tagName, T.invalid],
  AttributeName: T.attributeName,
  "AttributeValue UnquotedAttributeValue": T.attributeValue,
  Is: T.definitionOperator,
  "EntityReference CharacterReference": T.character,
  Comment: T.blockComment,
  ProcessingInst: T.processingInstruction,
  DoctypeDecl: T.documentMeta
}), WF = HC.deserialize({
  version: 14,
  states: ",xOVO!rOOO!ZQ#tO'#CrO!`Q#tO'#C{O!eQ#tO'#DOO!jQ#tO'#DRO!oQ#tO'#DTO!tOaO'#CqO#PObO'#CqO#[OdO'#CqO$kO!rO'#CqOOO`'#Cq'#CqO$rO$fO'#DUO$zQ#tO'#DWO%PQ#tO'#DXOOO`'#Dl'#DlOOO`'#DZ'#DZQVO!rOOO%UQ&rO,59^O%aQ&rO,59gO%lQ&rO,59jO%wQ&rO,59mO&SQ&rO,59oOOOa'#D_'#D_O&_OaO'#CyO&jOaO,59]OOOb'#D`'#D`O&rObO'#C|O&}ObO,59]OOOd'#Da'#DaO'VOdO'#DPO'bOdO,59]OOO`'#Db'#DbO'jO!rO,59]O'qQ#tO'#DSOOO`,59],59]OOOp'#Dc'#DcO'vO$fO,59pOOO`,59p,59pO(OQ#|O,59rO(TQ#|O,59sOOO`-E7X-E7XO(YQ&rO'#CtOOQW'#D['#D[O(hQ&rO1G.xOOOa1G.x1G.xOOO`1G/Z1G/ZO(sQ&rO1G/ROOOb1G/R1G/RO)OQ&rO1G/UOOOd1G/U1G/UO)ZQ&rO1G/XOOO`1G/X1G/XO)fQ&rO1G/ZOOOa-E7]-E7]O)qQ#tO'#CzOOO`1G.w1G.wOOOb-E7^-E7^O)vQ#tO'#C}OOOd-E7_-E7_O){Q#tO'#DQOOO`-E7`-E7`O*QQ#|O,59nOOOp-E7a-E7aOOO`1G/[1G/[OOO`1G/^1G/^OOO`1G/_1G/_O*VQ,UO,59`OOQW-E7Y-E7YOOOa7+$d7+$dOOO`7+$u7+$uOOOb7+$m7+$mOOOd7+$p7+$pOOO`7+$s7+$sO*bQ#|O,59fO*gQ#|O,59iO*lQ#|O,59lOOO`1G/Y1G/YO*qO7[O'#CwO+SOMhO'#CwOOQW1G.z1G.zOOO`1G/Q1G/QOOO`1G/T1G/TOOO`1G/W1G/WOOOO'#D]'#D]O+eO7[O,59cOOQW,59c,59cOOOO'#D^'#D^O+vOMhO,59cOOOO-E7Z-E7ZOOQW1G.}1G.}OOOO-E7[-E7[",
  stateData: ",c~O!_OS~OUSOVPOWQOXROYTO[]O][O^^O_^Oa^Ob^Oc^Od^Oy^O|_O!eZO~OgaO~OgbO~OgcO~OgdO~OgeO~O!XfOPmP![mP~O!YiOQpP![pP~O!ZlORsP![sP~OUSOVPOWQOXROYTOZqO[]O][O^^O_^Oa^Ob^Oc^Od^Oy^O!eZO~O![rO~P#gO!]sO!fuO~OgvO~OgwO~OS|OT}OiyO~OS!POT}OiyO~OS!ROT}OiyO~OS!TOT}OiyO~OS}OT}OiyO~O!XfOPmX![mX~OP!WO![!XO~O!YiOQpX![pX~OQ!ZO![!XO~O!ZlORsX![sX~OR!]O![!XO~O![!XO~P#gOg!_O~O!]sO!f!aO~OS!bO~OS!cO~Oj!dOShXThXihX~OS!fOT!gOiyO~OS!hOT!gOiyO~OS!iOT!gOiyO~OS!jOT!gOiyO~OS!gOT!gOiyO~Og!kO~Og!lO~Og!mO~OS!nO~Ol!qO!a!oO!c!pO~OS!rO~OS!sO~OS!tO~Ob!uOc!uOd!uO!a!wO!b!uO~Ob!xOc!xOd!xO!c!wO!d!xO~Ob!uOc!uOd!uO!a!{O!b!uO~Ob!xOc!xOd!xO!c!{O!d!xO~OT~cbd!ey|!e~",
  goto: "%q!aPPPPPPPPPPPPPPPPPPPPP!b!hP!nPP!zP!}#Q#T#Z#^#a#g#j#m#s#y!bP!b!bP$P$V$m$s$y%P%V%]%cPPPPPPPP%iX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 68,
  context: MF,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 22, 31, 34, 37, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 30, 33, 36, 38, "OpenTag"],
    ["group", -10, 14, 15, 18, 19, 20, 21, 40, 41, 42, 43, "Entity", 17, "Entity TextContent", -3, 29, 32, 35, "TextContent Entity"],
    ["isolate", -11, 22, 30, 31, 33, 34, 36, 37, 38, 39, 42, 43, "ltr", -3, 27, 28, 40, ""]
  ],
  propSources: [IF],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|caPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bXaP!b`!dpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UVaP!dpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pTaPOv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!dpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({WaP!b`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!b`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!b`!dpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYlWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]`aP!b`!dp!_^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljiSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebiSlWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXiSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vciSaP!b`!dpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!ahaP!dpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WiiSlWd!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zblWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOb!R!R7tP;=`<%l7S!Z8OYlWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{iiSlWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbiSlWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QciSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXiSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhiSlWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TalWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOc!R!RAwP;=`<%lAY!ZBRYlWc!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhiSlWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbiSlWc!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbiSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXiSc!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!cxaP!b`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYliSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_kiSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_XaP!b`!dp!fQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZiSgQaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!b`!dpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!b`!dpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!b`!dpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!b`!dp!ePOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!b`!dpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!b`!dpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!b`!dpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!b`!dpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!b`!dpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!b`!dpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!b`!dpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!dpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO|PP!-nP;=`<%l!-Sq!-xS!dp|POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!b`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!b`|POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!b`!dp|POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!b`!dpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!b`!dpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!b`!dpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!b`!dpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!b`!dpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!b`!dpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!b`!dpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!dpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOyPP!7TP;=`<%l!6Vq!7]V!dpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!dpyPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!b`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!b`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!b`yPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!b`!dpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!b`!dpyPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXjSaP!b`!dpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [_F, zF, LF, EF, AF, RF, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 16] },
  dialects: { noMatch: 0, selfClosing: 515 },
  tokenPrec: 517
});
function KC(n, t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let i of n.getChildren(WR)) {
    let s = i.getChild(mF), r = i.getChild(Q5) || i.getChild(VR);
    s && (e[t.read(s.from, s.to)] = r ? r.type.id == Q5 ? t.read(r.from + 1, r.to - 1) : t.read(r.from, r.to) : "");
  }
  return e;
}
c(KC, "fm$1");
f(KC, "getAttrs");
function M5(n, t) {
  let e = n.getChild(yF);
  return e ? t.read(e.from, e.to) : " ";
}
c(M5, "AO");
f(M5, "findTagName");
function Sv(n, t, e) {
  let i;
  for (let s of e)
    if (!s.attrs || s.attrs(i || (i = KC(n.node.parent.firstChild, t))))
      return { parser: s.parser };
  return null;
}
c(Sv, "No$1");
f(Sv, "maybeNest");
function JC(n = [], t = []) {
  let e = [], i = [], s = [], r = [];
  for (let o of n)
    (o.tag == "script" ? e : o.tag == "style" ? i : o.tag == "textarea" ? s : r).push(o);
  let a = t.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let o of t) (a[o.name] || (a[o.name] = [])).push(o);
  return mC((o, l) => {
    let h = o.type.id;
    if (h == gF) return Sv(o, l, e);
    if (h == wF) return Sv(o, l, i);
    if (h == vF) return Sv(o, l, s);
    if (h == IR && r.length) {
      let u = o.node, p = u.firstChild, y = p && M5(p, l), m;
      if (y) {
        for (let g of r)
          if (g.tag == y && (!g.attrs || g.attrs(m || (m = KC(p, l))))) {
            let b = u.lastChild, S = b.type.id == bF ? b.from : u.to;
            if (S > p.to)
              return { parser: g.parser, overlay: [{ from: p.to, to: S }] };
          }
      }
    }
    if (a && h == WR) {
      let u = o.node, p;
      if (p = u.firstChild) {
        let y = a[l.read(p.from, p.to)];
        if (y) for (let m of y) {
          if (m.tagName && m.tagName != M5(u.parent, l)) continue;
          let g = u.lastChild;
          if (g.type.id == Q5) {
            let b = g.from + 1, S = g.lastChild, x = g.to - (S && S.isError ? 0 : 1);
            if (x > b) return { parser: m.parser, overlay: [{ from: b, to: x }] };
          } else if (g.type.id == VR)
            return { parser: m.parser, overlay: [{ from: g.from, to: g.to }] };
        }
      }
    }
    return null;
  });
}
c(JC, "cm$1");
f(JC, "configureNesting");
const VF = 122, MQ = 1, DF = 123, qF = 124, FR = 2, ZF = 125, FF = 3, XF = 4, XR = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], NF = 58, jF = 40, NR = 95, BF = 91, Cv = 45, UF = 46, HF = 35, YF = 37, GF = 38, KF = 92, JF = 10, tX = 42;
function nm(n) {
  return n >= 65 && n <= 90 || n >= 97 && n <= 122 || n >= 161;
}
c(nm, "dn$1");
f(nm, "isAlpha");
function Jb(n) {
  return n >= 48 && n <= 57;
}
c(Jb, "Xh");
f(Jb, "isDigit");
function A5(n) {
  return Jb(n) || n >= 97 && n <= 102 || n >= 65 && n <= 70;
}
c(A5, "_O");
f(A5, "isHex");
const jR = /* @__PURE__ */ f((n, t, e) => (i, s) => {
  for (let r = !1, a = 0, o = 0; ; o++) {
    let { next: l } = i;
    if (nm(l) || l == Cv || l == NR || r && Jb(l))
      !r && (l != Cv || o > 0) && (r = !0), a === o && l == Cv && a++, i.advance();
    else if (l == KF && i.peek(1) != JF) {
      if (i.advance(), A5(i.next)) {
        do
          i.advance();
        while (A5(i.next));
        i.next == 32 && i.advance();
      } else i.next > -1 && i.advance();
      r = !0;
    } else {
      r && i.acceptToken(
        a == 2 && s.canShift(FR) ? t : l == jF ? e : n
      );
      break;
    }
  }
}, "identifierTokens"), eX = new Ji(
  jR(DF, FR, qF)
), iX = new Ji(
  jR(ZF, FF, XF)
), nX = new Ji((n) => {
  if (XR.includes(n.peek(-1))) {
    let { next: t } = n;
    (nm(t) || t == NR || t == HF || t == UF || t == tX || t == BF || t == NF && nm(n.peek(1)) || t == Cv || t == GF) && n.acceptToken(VF);
  }
}), sX = new Ji((n) => {
  if (!XR.includes(n.peek(-1))) {
    let { next: t } = n;
    if (t == YF && (n.advance(), n.acceptToken(MQ)), nm(t)) {
      do
        n.advance();
      while (nm(n.next) || Jb(n.next));
      n.acceptToken(MQ);
    }
  }
}), rX = Ql({
  "AtKeyword import charset namespace keyframes media supports": T.definitionKeyword,
  "from to selector": T.keyword,
  NamespaceName: T.namespace,
  KeyframeName: T.labelName,
  KeyframeRangeName: T.operatorKeyword,
  TagName: T.tagName,
  ClassName: T.className,
  PseudoClassName: T.constant(T.className),
  IdName: T.labelName,
  "FeatureName PropertyName": T.propertyName,
  AttributeName: T.attributeName,
  NumberLiteral: T.number,
  KeywordQuery: T.keyword,
  UnaryQueryOp: T.operatorKeyword,
  "CallTag ValueName": T.atom,
  VariableName: T.variableName,
  Callee: T.operatorKeyword,
  Unit: T.unit,
  "UniversalSelector NestingSelector": T.definitionOperator,
  "MatchOp CompareOp": T.compareOperator,
  "ChildOp SiblingOp, LogicOp": T.logicOperator,
  BinOp: T.arithmeticOperator,
  Important: T.modifier,
  Comment: T.blockComment,
  ColorLiteral: T.color,
  "ParenthesizedContent StringLiteral": T.string,
  ":": T.punctuation,
  "PseudoOp #": T.derefOperator,
  "; ,": T.separator,
  "( )": T.paren,
  "[ ]": T.squareBracket,
  "{ }": T.brace
}), aX = { __proto__: null, lang: 38, "nth-child": 38, "nth-last-child": 38, "nth-of-type": 38, "nth-last-of-type": 38, dir: 38, "host-context": 38, if: 84, url: 124, "url-prefix": 124, domain: 124, regexp: 124 }, oX = { __proto__: null, or: 98, and: 98, not: 106, only: 106, layer: 170 }, lX = { __proto__: null, selector: 112, layer: 166 }, cX = { __proto__: null, "@import": 162, "@media": 174, "@charset": 178, "@namespace": 182, "@keyframes": 188, "@supports": 200, "@scope": 204 }, hX = { __proto__: null, to: 207 }, dX = HC.deserialize({
  version: 14,
  states: "EbQYQdOOO#qQdOOP#xO`OOOOQP'#Cf'#CfOOQP'#Ce'#CeO#}QdO'#ChO$nQaO'#CcO$xQdO'#CkO%TQdO'#DpO%YQdO'#DrO%_QdO'#DuO%_QdO'#DxOOQP'#FV'#FVO&eQhO'#EhOOQS'#FU'#FUOOQS'#Ek'#EkQYQdOOO&lQdO'#EOO&PQhO'#EUO&lQdO'#EWO'aQdO'#EYO'lQdO'#E]O'tQhO'#EcO(VQdO'#EeO(bQaO'#CfO)VQ`O'#D{O)[Q`O'#F`O)gQdO'#F`QOQ`OOP)qO&jO'#CaPOOO)C@t)C@tOOQP'#Cj'#CjOOQP,59S,59SO#}QdO,59SO)|QdO,59VO%TQdO,5:[O%YQdO,5:^O%_QdO,5:aO%_QdO,5:cO%_QdO,5:dO%_QdO'#ErO*XQ`O,58}O*aQdO'#DzOOQS,58},58}OOQP'#Cn'#CnOOQO'#Dn'#DnOOQP,59V,59VO*hQ`O,59VO*mQ`O,59VOOQP'#Dq'#DqOOQP,5:[,5:[OOQO'#Ds'#DsO*rQpO,5:^O+]QaO,5:aO+sQaO,5:dOOQW'#DZ'#DZO,ZQhO'#DdO,xQhO'#FaO'tQhO'#DbO-WQ`O'#DhOOQW'#F['#F[O-]Q`O,5;SO-eQ`O'#DeOOQS-E8i-E8iOOQ['#Cs'#CsO-jQdO'#CtO.QQdO'#CzO.hQdO'#C}O/OQ!pO'#DPO1RQ!jO,5:jOOQO'#DU'#DUO*mQ`O'#DTO1cQ!nO'#FXO3`Q`O'#DVO3eQ`O'#DkOOQ['#FX'#FXO-`Q`O,5:pO3jQ!bO,5:rOOQS'#E['#E[O3rQ`O,5:tO3wQdO,5:tOOQO'#E_'#E_O4PQ`O,5:wO4UQhO,5:}O%_QdO'#DgOOQS,5;P,5;PO-eQ`O,5;PO4^QdO,5;PO4fQdO,5:gO4vQdO'#EtO5TQ`O,5;zO5TQ`O,5;zPOOO'#Ej'#EjP5`O&jO,58{POOO,58{,58{OOQP1G.n1G.nOOQP1G.q1G.qO*hQ`O1G.qO*mQ`O1G.qOOQP1G/v1G/vO5kQpO1G/xO5sQaO1G/{O6ZQaO1G/}O6qQaO1G0OO7XQaO,5;^OOQO-E8p-E8pOOQS1G.i1G.iO7cQ`O,5:fO7hQdO'#DoO7oQdO'#CrOOQP1G/x1G/xO&lQdO1G/xO7vQ!jO'#DZO8UQ!bO,59vO8^QhO,5:OOOQO'#F]'#F]O8XQ!bO,59zO'tQhO,59xO8fQhO'#EvO8sQ`O,5;{O9OQhO,59|O9uQhO'#DiOOQW,5:S,5:SOOQS1G0n1G0nOOQW,5:P,5:PO9|Q!fO'#FYOOQS'#FY'#FYOOQS'#Em'#EmO;^QdO,59`OOQ[,59`,59`O;tQdO,59fOOQ[,59f,59fO<[QdO,59iOOQ[,59i,59iOOQ[,59k,59kO&lQdO,59mO<rQhO'#EQOOQW'#EQ'#EQO=WQ`O1G0UO1[QhO1G0UOOQ[,59o,59oO'tQhO'#DXOOQ[,59q,59qO=]Q#tO,5:VOOQS1G0[1G0[OOQS1G0^1G0^OOQS1G0`1G0`O=hQ`O1G0`O=mQdO'#E`OOQS1G0c1G0cOOQS1G0i1G0iO=xQaO,5:RO-`Q`O1G0kOOQS1G0k1G0kO-eQ`O1G0kO>PQ!fO1G0ROOQO1G0R1G0ROOQO,5;`,5;`O>gQdO,5;`OOQO-E8r-E8rO>tQ`O1G1fPOOO-E8h-E8hPOOO1G.g1G.gOOQP7+$]7+$]OOQP7+%d7+%dO&lQdO7+%dOOQS1G0Q1G0QO?PQaO'#F_O?ZQ`O,5:ZO?`Q!fO'#ElO@^QdO'#FWO@hQ`O,59^O@mQ!bO7+%dO&lQdO1G/bO@uQhO1G/fOOQW1G/j1G/jOOQW1G/d1G/dOAWQhO,5;bOOQO-E8t-E8tOAfQhO'#DZOAtQhO'#F^OBPQ`O'#F^OBUQ`O,5:TOOQS-E8k-E8kOOQ[1G.z1G.zOOQ[1G/Q1G/QOOQ[1G/T1G/TOOQ[1G/X1G/XOBZQdO,5:lOOQS7+%p7+%pOB`Q`O7+%pOBeQhO'#DYOBmQ`O,59sO'tQhO,59sOOQ[1G/q1G/qOBuQ`O1G/qOOQS7+%z7+%zOBzQbO'#DPOOQO'#Eb'#EbOCYQ`O'#EaOOQO'#Ea'#EaOCeQ`O'#EwOCmQdO,5:zOOQS,5:z,5:zOOQ[1G/m1G/mOOQS7+&V7+&VO-`Q`O7+&VOCxQ!fO'#EsO&lQdO'#EsOEPQdO7+%mOOQO7+%m7+%mOOQO1G0z1G0zOEdQ!bO<<IOOElQdO'#EqOEvQ`O,5;yOOQP1G/u1G/uOOQS-E8j-E8jOFOQdO'#EpOFYQ`O,5;rOOQ]1G.x1G.xOOQP<<IO<<IOOFbQdO7+$|OOQO'#D]'#D]OFiQ!bO7+%QOFqQhO'#EoOF{Q`O,5;xO&lQdO,5;xOOQW1G/o1G/oOOQO'#ES'#ESOGTQ`O1G0WOOQS<<I[<<I[O&lQdO,59tOGnQhO1G/_OOQ[1G/_1G/_OGuQ`O1G/_OOQW-E8l-E8lOOQ[7+%]7+%]OOQO,5:{,5:{O=pQdO'#ExOCeQ`O,5;cOOQS,5;c,5;cOOQS-E8u-E8uOOQS1G0f1G0fOOQS<<Iq<<IqOG}Q!fO,5;_OOQS-E8q-E8qOOQO<<IX<<IXOOQPAN>jAN>jOIUQaO,5;]OOQO-E8o-E8oOI`QdO,5;[OOQO-E8n-E8nOOQW<<Hh<<HhOOQW<<Hl<<HlOIjQhO<<HlOI{QhO,5;ZOJWQ`O,5;ZOOQO-E8m-E8mOJ]QdO1G1dOBZQdO'#EuOJgQ`O7+%rOOQW7+%r7+%rOJoQ!bO1G/`OOQ[7+$y7+$yOJzQhO7+$yPKRQ`O'#EnOOQO,5;d,5;dOOQO-E8v-E8vOOQS1G0}1G0}OKWQ`OAN>WO&lQdO1G0uOK]Q`O7+'OOOQO,5;a,5;aOOQO-E8s-E8sOOQW<<I^<<I^OOQ[<<He<<HePOQW,5;Y,5;YOOQWG23rG23rOKeQdO7+&a",
  stateData: "Kx~O#sOS#tQQ~OW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#oRO~OQiOW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#ohO~O#m$SP~P!dO#tmO~O#ooO~O]qO`rOarOjsOmtO!juO!mwO#nvO~OpzO!^xO~P$SOc!QO#o|O#p}O~O#o!RO~O#o!TO~OW[OZ[O]TO`VOaVOjWOmXO!jYO!mZO#oRO~OS!]Oe!YO!V![O!Y!`O#q!XOp$TP~Ok$TP~P&POQ!jOe!cOm!dOp!eOr!mOt!mOz!kO!`!lO#o!bO#p!hO#}!fO~Ot!qO!`!lO#o!pO~Ot!sO#o!sO~OS!]Oe!YO!V![O!Y!`O#q!XO~Oe!vOpzO#Z!xO~O]YX`YX`!pXaYXjYXmYXpYX!^YX!jYX!mYX#nYX~O`!zO~Ok!{O#m$SXo$SX~O#m$SXo$SX~P!dO#u#OO#v#OO#w#QO~Oc#UO#o|O#p}O~OpzO!^xO~Oo$SP~P!dOe#`O~Oe#aO~Ol#bO!h#cO~O]qO`rOarOjsOmtO~Op!ia!^!ia!j!ia!m!ia#n!iad!ia~P*zOp!la!^!la!j!la!m!la#n!lad!la~P*zOR#gOS!]Oe!YOr#gOt#gO!V![O!Y!`O#q#dO#}!fO~O!R#iO!^#jOk$TXp$TX~Oe#mO~Ok#oOpzO~Oe!vO~O]#rO`#rOd#uOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl#wO~P&lO]#rO`#rOi#rOj#rOk#rOo#yO~P&lOP#zOSsXesXksXvsX!VsX!YsX!usX!wsX#qsX!TsXQsX]sX`sXdsXisXjsXmsXpsXrsXtsXzsX!`sX#osX#psX#}sXlsXosX!^sX!qsX#msX~Ov#{O!u#|O!w#}Ok$TP~P'tOe#aOS#{Xk#{Xv#{X!V#{X!Y#{X!u#{X!w#{X#q#{XQ#{X]#{X`#{Xd#{Xi#{Xj#{Xm#{Xp#{Xr#{Xt#{Xz#{X!`#{X#o#{X#p#{X#}#{Xl#{Xo#{X!^#{X!q#{X#m#{X~Oe$RO~Oe$TO~Ok$VOv#{O~Ok$WO~Ot$XO!`!lO~Op$YO~OpzO!R#iO~OpzO#Z$`O~O!q$bOk!oa#m!oao!oa~P&lOk#hX#m#hXo#hX~P!dOk!{O#m$Sao$Sa~O#u#OO#v#OO#w$hO~Ol$jO!h$kO~Op!ii!^!ii!j!ii!m!ii#n!iid!ii~P*zOp!ki!^!ki!j!ki!m!ki#n!kid!ki~P*zOp!li!^!li!j!li!m!li#n!lid!li~P*zOp#fa!^#fa~P$SOo$lO~Od$RP~P%_Od#zP~P&lO`!PXd}X!R}X!T!PX~O`$sO!T$tO~Od$uO!R#iO~Ok#jXp#jX!^#jX~P'tO!^#jOk$Tap$Ta~O!R#iOk!Uap!Ua!^!Uad!Ua`!Ua~OS!]Oe!YO!V![O!Y!`O#q$yO~Od$QP~P9dOv#{OQ#|X]#|X`#|Xd#|Xe#|Xi#|Xj#|Xk#|Xm#|Xp#|Xr#|Xt#|Xz#|X!`#|X#o#|X#p#|X#}#|Xl#|Xo#|X~O]#rO`#rOd%OOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl%PO~P&lO]#rO`#rOi#rOj#rOk#rOo%QO~P&lOe%SOS!tXk!tX!V!tX!Y!tX#q!tX~Ok%TO~Od%YOt%ZO!a%ZO~Ok%[O~Oo%cO#o%^O#}%]O~Od%dO~P$SOv#{O!^%hO!q%jOk!oi#m!oio!oi~P&lOk#ha#m#hao#ha~P!dOk!{O#m$Sio$Si~O!^%mOd$RX~P$SOd%oO~Ov#{OQ#`Xd#`Xe#`Xm#`Xp#`Xr#`Xt#`Xz#`X!^#`X!`#`X#o#`X#p#`X#}#`X~O!^%qOd#zX~P&lOd%sO~Ol%tOv#{O~OR#gOr#gOt#gO#q%vO#}!fO~O!R#iOk#jap#ja!^#ja~O`!PXd}X!R}X!^}X~O!R#iO!^%xOd$QX~O`%zO~Od%{O~O#o%|O~Ok&OO~O`&PO!R#iO~Od&ROk&QO~Od&UO~OP#zOpsX!^sXdsX~O#}%]Op#TX!^#TX~OpzO!^&WO~Oo&[O#o%^O#}%]O~Ov#{OQ#gXe#gXk#gXm#gXp#gXr#gXt#gXz#gX!^#gX!`#gX!q#gX#m#gX#o#gX#p#gX#}#gXo#gX~O!^%hO!q&`Ok!oq#m!oqo!oq~P&lOl&aOv#{O~Od#eX!^#eX~P%_O!^%mOd$Ra~Od#dX!^#dX~P&lO!^%qOd#za~Od&fO~P&lOd&gO!T&hO~Od#cX!^#cX~P9dO!^%xOd$Qa~O]&mOd&oO~OS#bae#ba!V#ba!Y#ba#q#ba~Od&qO~PG]Od&qOk&rO~Ov#{OQ#gae#gak#gam#gap#gar#gat#gaz#ga!^#ga!`#ga!q#ga#m#ga#o#ga#p#ga#}#gao#ga~Od#ea!^#ea~P$SOd#da!^#da~P&lOR#gOr#gOt#gO#q%vO#}%]O~O!R#iOd#ca!^#ca~O`&xO~O!^%xOd$Qi~P&lO]&mOd&|O~Ov#{Od|ik|i~Od&}O~PG]Ok'OO~Od'PO~O!^%xOd$Qq~Od#cq!^#cq~P&lO#s!a#t#}]#}v!m~",
  goto: "2h$UPPPPP$VP$YP$c$uP$cP%X$cPP%_PPP%e%o%oPPPPP%oPP%oP&]P%oP%o'W%oP't'w'}'}(^'}P'}P'}P'}'}P(m'}(yP(|PP)p)v$c)|$c*SP$cP$c$cP*Y*{+YP$YP+aP+dP$YP$YP$YP+j$YP+m+p+s+z$YP$YPP$YP,P,V,f,|-[-b-l-r-x.O.U.`.f.l.rPPPPPPPPPPP.x/R/w/z0|P1U1u2O2R2U2[RnQ_^OP`kz!{$dq[OPYZ`kuvwxz!v!{#`$d%mqSOPYZ`kuvwxz!v!{#`$d%mQpTR#RqQ!OVR#SrQ#S!QS$Q!i!jR$i#U!V!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'Q!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QU#g!Y$t&hU%`$Y%b&WR&V%_!V!iac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QR$S!kQ%W$RR&S%Xk!^]bf!Y![!g#i#j#m$P$R%X%xQ#e!YQ${#mQ%w$tQ&j%xR&w&hQ!ygQ#p!`Q$^!xR%f$`R#n!]!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QQ!qdR$X!rQ!PVR#TrQ#S!PR$i#TQ!SWR#VsQ!UXR#WtQ{UQ!wgQ#^yQ#o!_Q$U!nQ$[!uQ$_!yQ%e$^Q&Y%aQ&]%fR&v&XSjPzQ!}kQ$c!{R%k$dZiPkz!{$dR$P!gQ%}%SR&z&mR!rdR!teR$Z!tS%a$Y%bR&t&WV%_$Y%b&WQ#PmR$g#PQ`OSkPzU!a`k$dR$d!{Q$p#aY%p$p%u&d&l'QQ%u$sQ&d%qQ&l%zR'Q&xQ#t!cQ#v!dQ#x!eV$}#t#v#xQ%X$RR&T%XQ%y$zS&k%y&yR&y&lQ%r$pR&e%rQ%n$mR&c%nQyUR#]yQ%i$aR&_%iQ!|jS$e!|$fR$f!}Q&n%}R&{&nQ#k!ZR$x#kQ%b$YR&Z%bQ&X%aR&u&X__OP`kz!{$d^UOP`kz!{$dQ!VYQ!WZQ#XuQ#YvQ#ZwQ#[xQ$]!vQ$m#`R&b%mR$q#aQ!gaQ!oc[#q!c!d!e#t#v#xQ$a!zd$o#a$p$s%q%u%z&d&l&x'QQ$r#cQ%R#{S%g$a%iQ%l$kQ&^%hR&p&P]#s!c!d!e#t#v#xW!Z]b!g$PQ!ufQ#f!YQ#l![Q$v#iQ$w#jQ$z#mS%V$R%XR&i%xQ#h!YQ%w$tR&w&hR$|#mR$n#`QlPR#_zQ!_]Q!nbQ$O!gR%U$P",
  nodeNames: "⚠ Unit VariableName VariableName QueryCallee Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector . ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue AtKeyword # ; ] [ BracketedValue } { BracedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee IfExpression if ArgList IfBranch KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp ComparisonQuery CompareOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector ParenthesizedSelector CallQuery ArgList , CallLiteral CallTag ParenthesizedContent PseudoClassName ArgList IdSelector IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp Block Declaration PropertyName Important ImportStatement import Layer layer LayerName layer MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports ScopeStatement scope to AtRule Styles",
  maxTerm: 143,
  nodeProps: [
    ["isolate", -2, 5, 36, ""],
    ["openedBy", 20, "(", 28, "[", 31, "{"],
    ["closedBy", 21, ")", 29, "]", 32, "}"]
  ],
  propSources: [rX],
  skippedNodes: [0, 5, 106],
  repeatNodeCount: 15,
  tokenData: "JQ~R!YOX$qX^%i^p$qpq%iqr({rs-ust/itu6Wuv$qvw7Qwx7cxy9Qyz9cz{9h{|:R|}>t}!O?V!O!P?t!P!Q@]!Q![AU![!]BP!]!^B{!^!_C^!_!`DY!`!aDm!a!b$q!b!cEn!c!}$q!}#OG{#O#P$q#P#QH^#Q#R6W#R#o$q#o#pHo#p#q6W#q#rIQ#r#sIc#s#y$q#y#z%i#z$f$q$f$g%i$g#BY$q#BY#BZ%i#BZ$IS$q$IS$I_%i$I_$I|$q$I|$JO%i$JO$JT$q$JT$JU%i$JU$KV$q$KV$KW%i$KW&FU$q&FU&FV%i&FV;'S$q;'S;=`Iz<%lO$q`$tSOy%Qz;'S%Q;'S;=`%c<%lO%Q`%VS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q`%fP;=`<%l%Q~%nh#s~OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Q~'ah#s~!a`OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Qj)OUOy%Qz#]%Q#]#^)b#^;'S%Q;'S;=`%c<%lO%Qj)gU!a`Oy%Qz#a%Q#a#b)y#b;'S%Q;'S;=`%c<%lO%Qj*OU!a`Oy%Qz#d%Q#d#e*b#e;'S%Q;'S;=`%c<%lO%Qj*gU!a`Oy%Qz#c%Q#c#d*y#d;'S%Q;'S;=`%c<%lO%Qj+OU!a`Oy%Qz#f%Q#f#g+b#g;'S%Q;'S;=`%c<%lO%Qj+gU!a`Oy%Qz#h%Q#h#i+y#i;'S%Q;'S;=`%c<%lO%Qj,OU!a`Oy%Qz#T%Q#T#U,b#U;'S%Q;'S;=`%c<%lO%Qj,gU!a`Oy%Qz#b%Q#b#c,y#c;'S%Q;'S;=`%c<%lO%Qj-OU!a`Oy%Qz#h%Q#h#i-b#i;'S%Q;'S;=`%c<%lO%Qj-iS!qY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q~-xWOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c<%lO-u~.gOt~~.jRO;'S-u;'S;=`.s;=`O-u~.vXOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c;=`<%l-u<%lO-u~/fP;=`<%l-uj/nYjYOy%Qz!Q%Q!Q![0^![!c%Q!c!i0^!i#T%Q#T#Z0^#Z;'S%Q;'S;=`%c<%lO%Qj0cY!a`Oy%Qz!Q%Q!Q![1R![!c%Q!c!i1R!i#T%Q#T#Z1R#Z;'S%Q;'S;=`%c<%lO%Qj1WY!a`Oy%Qz!Q%Q!Q![1v![!c%Q!c!i1v!i#T%Q#T#Z1v#Z;'S%Q;'S;=`%c<%lO%Qj1}YrY!a`Oy%Qz!Q%Q!Q![2m![!c%Q!c!i2m!i#T%Q#T#Z2m#Z;'S%Q;'S;=`%c<%lO%Qj2tYrY!a`Oy%Qz!Q%Q!Q![3d![!c%Q!c!i3d!i#T%Q#T#Z3d#Z;'S%Q;'S;=`%c<%lO%Qj3iY!a`Oy%Qz!Q%Q!Q![4X![!c%Q!c!i4X!i#T%Q#T#Z4X#Z;'S%Q;'S;=`%c<%lO%Qj4`YrY!a`Oy%Qz!Q%Q!Q![5O![!c%Q!c!i5O!i#T%Q#T#Z5O#Z;'S%Q;'S;=`%c<%lO%Qj5TY!a`Oy%Qz!Q%Q!Q![5s![!c%Q!c!i5s!i#T%Q#T#Z5s#Z;'S%Q;'S;=`%c<%lO%Qj5zSrY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qd6ZUOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qd6tS!hS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qb7VSZQOy%Qz;'S%Q;'S;=`%c<%lO%Q~7fWOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z<%lO7c~8RRO;'S7c;'S;=`8[;=`O7c~8_XOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z;=`<%l7c<%lO7c~8}P;=`<%l7cj9VSeYOy%Qz;'S%Q;'S;=`%c<%lO%Q~9hOd~n9oUWQvWOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qj:YWvW!mQOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj:wU!a`Oy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Qj;bY!a`#}YOy%Qz!Q%Q!Q![;Z![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj<VY!a`Oy%Qz{%Q{|<u|}%Q}!O<u!O!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj<zU!a`Oy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj=eU!a`#}YOy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj>O[!a`#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj>yS!^YOy%Qz;'S%Q;'S;=`%c<%lO%Qj?[WvWOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj?yU]YOy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Q~@bTvWOy%Qz{@q{;'S%Q;'S;=`%c<%lO%Q~@xS!a`#t~Oy%Qz;'S%Q;'S;=`%c<%lO%QjAZ[#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%QjBUU`YOy%Qz![%Q![!]Bh!];'S%Q;'S;=`%c<%lO%QbBoSaQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjCQSkYOy%Qz;'S%Q;'S;=`%c<%lO%QhCcU!TWOy%Qz!_%Q!_!`Cu!`;'S%Q;'S;=`%c<%lO%QhC|S!TW!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QlDaS!TW!hSOy%Qz;'S%Q;'S;=`%c<%lO%QjDtV!jQ!TWOy%Qz!_%Q!_!`Cu!`!aEZ!a;'S%Q;'S;=`%c<%lO%QbEbS!jQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjEqYOy%Qz}%Q}!OFa!O!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjFfW!a`Oy%Qz!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjGV[iY!a`Oy%Qz}%Q}!OGO!O!Q%Q!Q![GO![!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjHQSmYOy%Qz;'S%Q;'S;=`%c<%lO%QnHcSl^Oy%Qz;'S%Q;'S;=`%c<%lO%QjHtSpYOy%Qz;'S%Q;'S;=`%c<%lO%QjIVSoYOy%Qz;'S%Q;'S;=`%c<%lO%QfIhU!mQOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Q`I}P;=`<%l$q",
  tokenizers: [nX, sX, eX, iX, 1, 2, 3, 4, new EO("m~RRYZ[z{a~~g~aO#v~~dP!P!Qg~lO#w~~", 28, 129)],
  topRules: { StyleSheet: [0, 6], Styles: [1, 105] },
  specialized: [{ term: 124, get: /* @__PURE__ */ f((n) => aX[n] || -1, "get") }, { term: 125, get: /* @__PURE__ */ f((n) => oX[n] || -1, "get") }, { term: 4, get: /* @__PURE__ */ f((n) => lX[n] || -1, "get") }, { term: 25, get: /* @__PURE__ */ f((n) => cX[n] || -1, "get") }, { term: 123, get: /* @__PURE__ */ f((n) => hX[n] || -1, "get") }],
  tokenPrec: 1963
});
let $2 = null;
function Pv() {
  if (!$2 && typeof document == "object" && document.body) {
    let { style: n } = document.body, t = [], e = /* @__PURE__ */ new Set();
    for (let i in n)
      i != "cssText" && i != "cssFloat" && typeof n[i] == "string" && (/[A-Z]/.test(i) && (i = i.replace(/[A-Z]/g, (s) => "-" + s.toLowerCase())), e.has(i) || (t.push(i), e.add(i)));
    $2 = t.sort().map((i) => ({ type: "property", label: i, apply: i + ": " }));
  }
  return $2 || [];
}
c(Pv, "Fo$1");
f(Pv, "properties");
const AQ = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((n) => ({ type: "class", label: n })), RQ = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((n) => ({ type: "keyword", label: n })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((n) => ({ type: "constant", label: n }))), uX = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((n) => ({ type: "type", label: n })), pX = /* @__PURE__ */ [
  "@charset",
  "@color-profile",
  "@container",
  "@counter-style",
  "@font-face",
  "@font-feature-values",
  "@font-palette-values",
  "@import",
  "@keyframes",
  "@layer",
  "@media",
  "@namespace",
  "@page",
  "@position-try",
  "@property",
  "@scope",
  "@starting-style",
  "@supports",
  "@view-transition"
].map((n) => ({ type: "keyword", label: n })), $s = /^(\w[\w-]*|-\w[\w-]*|)$/, fX = /^-(-[\w-]*)?$/;
function BR(n, t) {
  var e;
  if ((n.name == "(" || n.type.isError) && (n = n.parent || n), n.name != "ArgList")
    return !1;
  let i = (e = n.parent) === null || e === void 0 ? void 0 : e.firstChild;
  return i?.name != "Callee" ? !1 : t.sliceString(i.from, i.to) == "var";
}
c(BR, "WS");
f(BR, "isVarArg");
const EQ = /* @__PURE__ */ new hM(), yX = ["Declaration"];
function UR(n) {
  for (let t = n; ; ) {
    if (t.type.isTop)
      return t;
    if (!(t = t.parent))
      return n;
  }
}
c(UR, "US");
f(UR, "astTop");
function tP(n, t, e) {
  if (t.to - t.from > 4096) {
    let i = EQ.get(t);
    if (i)
      return i;
    let s = [], r = /* @__PURE__ */ new Set(), a = t.cursor(Zt.IncludeAnonymous);
    if (a.firstChild())
      do
        for (let o of tP(n, a.node, e))
          r.has(o.label) || (r.add(o.label), s.push(o));
      while (a.nextSibling());
    return EQ.set(t, s), s;
  } else {
    let i = [], s = /* @__PURE__ */ new Set();
    return t.cursor().iterate((r) => {
      var a;
      if (e(r) && r.matchContext(yX) && ((a = r.node.nextSibling) === null || a === void 0 ? void 0 : a.name) == ":") {
        let o = n.sliceString(r.from, r.to);
        s.has(o) || (s.add(o), i.push({ label: o, type: "variable" }));
      }
    }), i;
  }
}
c(tP, "mm$1");
f(tP, "variableNames");
const mX = /* @__PURE__ */ f((n) => (t) => {
  let { state: e, pos: i } = t, s = re(e).resolveInner(i, -1), r = s.type.isError && s.from == s.to - 1 && e.doc.sliceString(s.from, s.to) == "-";
  if (s.name == "PropertyName" || (r || s.name == "TagName") && /^(Block|Styles)$/.test(s.resolve(s.to).name))
    return { from: s.from, options: Pv(), validFor: $s };
  if (s.name == "ValueName")
    return { from: s.from, options: RQ, validFor: $s };
  if (s.name == "PseudoClassName")
    return { from: s.from, options: AQ, validFor: $s };
  if (n(s) || (t.explicit || r) && BR(s, e.doc))
    return {
      from: n(s) || r ? s.from : i,
      options: tP(e.doc, UR(s), n),
      validFor: fX
    };
  if (s.name == "TagName") {
    for (let { parent: l } = s; l; l = l.parent)
      if (l.name == "Block")
        return { from: s.from, options: Pv(), validFor: $s };
    return { from: s.from, options: uX, validFor: $s };
  }
  if (s.name == "AtKeyword")
    return { from: s.from, options: pX, validFor: $s };
  if (!t.explicit)
    return null;
  let a = s.resolve(i), o = a.childBefore(i);
  return o && o.name == ":" && a.name == "PseudoClassSelector" ? { from: i, options: AQ, validFor: $s } : o && o.name == ":" && a.name == "Declaration" || a.name == "ArgList" ? { from: i, options: RQ, validFor: $s } : a.name == "Block" || a.name == "Styles" ? { from: i, options: Pv(), validFor: $s } : null;
}, "defineCSSCompletionSource"), gX = /* @__PURE__ */ mX((n) => n.name == "VariableName"), LO = /* @__PURE__ */ vC.define({
  name: "css",
  parser: /* @__PURE__ */ dX.configure({
    props: [
      /* @__PURE__ */ km.add({
        Declaration: /* @__PURE__ */ lw()
      }),
      /* @__PURE__ */ h1.add({
        "Block KeyframeList": xC
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function HR() {
  return new em(LO, LO.data.of({ autocomplete: gX }));
}
c(HR, "ym$1");
f(HR, "css");
const wX = 316, vX = 317, _Q = 1, OX = 2, bX = 3, $X = 4, xX = 318, kX = 320, SX = 321, CX = 5, PX = 6, QX = 0, R5 = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], YR = 125, TX = 59, E5 = 47, MX = 42, AX = 43, RX = 45, EX = 60, _X = 44, zX = 63, LX = 46, IX = 91, WX = new MR({
  start: !1,
  shift(n, t) {
    return t == CX || t == PX || t == kX ? n : t == SX;
  },
  strict: !1
}), VX = new Ji((n, t) => {
  let { next: e } = n;
  (e == YR || e == -1 || t.context) && n.acceptToken(xX);
}, { contextual: !0, fallback: !0 }), DX = new Ji((n, t) => {
  let { next: e } = n, i;
  R5.indexOf(e) > -1 || e == E5 && ((i = n.peek(1)) == E5 || i == MX) || e != YR && e != TX && e != -1 && !t.context && n.acceptToken(wX);
}, { contextual: !0 }), qX = new Ji((n, t) => {
  n.next == IX && !t.context && n.acceptToken(vX);
}, { contextual: !0 }), ZX = new Ji((n, t) => {
  let { next: e } = n;
  if (e == AX || e == RX) {
    if (n.advance(), e == n.next) {
      n.advance();
      let i = !t.context && t.canShift(_Q);
      n.acceptToken(i ? _Q : OX);
    }
  } else e == zX && n.peek(1) == LX && (n.advance(), n.advance(), (n.next < 48 || n.next > 57) && n.acceptToken(bX));
}, { contextual: !0 });
function Qv(n, t) {
  return n >= 65 && n <= 90 || n >= 97 && n <= 122 || n == 95 || n >= 192 || !t && n >= 48 && n <= 57;
}
c(Qv, "Ho$1");
f(Qv, "identifierChar");
const FX = new Ji((n, t) => {
  if (n.next != EX || !t.dialectEnabled(QX) || (n.advance(), n.next == E5)) return;
  let e = 0;
  for (; R5.indexOf(n.next) > -1; )
    n.advance(), e++;
  if (Qv(n.next, !0)) {
    for (n.advance(), e++; Qv(n.next, !1); )
      n.advance(), e++;
    for (; R5.indexOf(n.next) > -1; )
      n.advance(), e++;
    if (n.next == _X) return;
    for (let i = 0; ; i++) {
      if (i == 7) {
        if (!Qv(n.next, !0)) return;
        break;
      }
      if (n.next != "extends".charCodeAt(i)) break;
      n.advance(), e++;
    }
  }
  n.acceptToken($X, -e);
}), XX = Ql({
  "get set async static": T.modifier,
  "for while do if else switch try catch finally return throw break continue default case defer": T.controlKeyword,
  "in of await yield void typeof delete instanceof as satisfies": T.operatorKeyword,
  "let var const using function class extends": T.definitionKeyword,
  "import export from": T.moduleKeyword,
  "with debugger new": T.keyword,
  TemplateString: T.special(T.string),
  super: T.atom,
  BooleanLiteral: T.bool,
  this: T.self,
  null: T.null,
  Star: T.modifier,
  VariableName: T.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": T.function(T.variableName),
  VariableDefinition: T.definition(T.variableName),
  Label: T.labelName,
  PropertyName: T.propertyName,
  PrivatePropertyName: T.special(T.propertyName),
  "CallExpression/MemberExpression/PropertyName": T.function(T.propertyName),
  "FunctionDeclaration/VariableDefinition": T.function(T.definition(T.variableName)),
  "ClassDeclaration/VariableDefinition": T.definition(T.className),
  "NewExpression/VariableName": T.className,
  PropertyDefinition: T.definition(T.propertyName),
  PrivatePropertyDefinition: T.definition(T.special(T.propertyName)),
  UpdateOp: T.updateOperator,
  "LineComment Hashbang": T.lineComment,
  BlockComment: T.blockComment,
  Number: T.number,
  String: T.string,
  Escape: T.escape,
  ArithOp: T.arithmeticOperator,
  LogicOp: T.logicOperator,
  BitOp: T.bitwiseOperator,
  CompareOp: T.compareOperator,
  RegExp: T.regexp,
  Equals: T.definitionOperator,
  Arrow: T.function(T.punctuation),
  ": Spread": T.punctuation,
  "( )": T.paren,
  "[ ]": T.squareBracket,
  "{ }": T.brace,
  "InterpolationStart InterpolationEnd": T.special(T.brace),
  ".": T.derefOperator,
  ", ;": T.separator,
  "@": T.meta,
  TypeName: T.typeName,
  TypeDefinition: T.definition(T.typeName),
  "type enum interface implements namespace module declare": T.definitionKeyword,
  "abstract global Privacy readonly override": T.modifier,
  "is keyof unique infer asserts": T.operatorKeyword,
  JSXAttributeValue: T.attributeValue,
  JSXText: T.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": T.angleBracket,
  "JSXIdentifier JSXNameSpacedName": T.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": T.attributeName,
  "JSXBuiltin/JSXIdentifier": T.standard(T.tagName)
}), NX = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, in: 52, out: 55, const: 56, extends: 60, this: 64, true: 72, false: 72, null: 84, void: 88, typeof: 92, super: 108, new: 142, delete: 154, yield: 163, await: 167, class: 172, public: 235, private: 235, protected: 235, readonly: 237, instanceof: 256, satisfies: 259, import: 292, keyof: 349, unique: 353, infer: 359, asserts: 395, is: 397, abstract: 417, implements: 419, type: 421, let: 424, var: 426, using: 429, interface: 435, enum: 439, namespace: 445, module: 447, declare: 451, global: 455, defer: 471, for: 476, of: 485, while: 488, with: 492, do: 496, if: 500, else: 502, switch: 506, case: 512, try: 518, catch: 522, finally: 526, return: 530, throw: 534, break: 538, continue: 542, debugger: 546 }, jX = { __proto__: null, async: 129, get: 131, set: 133, declare: 195, public: 197, private: 197, protected: 197, static: 199, abstract: 201, override: 203, readonly: 209, accessor: 211, new: 401 }, BX = { __proto__: null, "<": 193 }, UX = HC.deserialize({
  version: 14,
  states: "$F|Q%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#DaO.QQlO'#DgO.bQlO'#DrO%[QlO'#DzO0fQlO'#ESOOQ!0Lf'#E['#E[O1PQ`O'#EXOOQO'#Ep'#EpOOQO'#Il'#IlO1XQ`O'#GsO1dQ`O'#EoO1iQ`O'#EoO3hQ!0MxO'#JrO6[Q!0MxO'#JsO6uQ`O'#F]O6zQ,UO'#FtOOQ!0Lf'#Ff'#FfO7VO7dO'#FfO9XQMhO'#F|O9`Q`O'#F{OOQ!0Lf'#Js'#JsOOQ!0Lb'#Jr'#JrO9eQ`O'#GwOOQ['#K_'#K_O9pQ`O'#IYO9uQ!0LrO'#IZOOQ['#J`'#J`OOQ['#I_'#I_Q`QlOOQ`QlOOO9}Q!L^O'#DvO:UQlO'#EOO:]QlO'#EQO9kQ`O'#GsO:dQMhO'#CoO:rQ`O'#EnO:}Q`O'#EyO;hQMhO'#FeO;xQ`O'#GsOOQO'#K`'#K`O;}Q`O'#K`O<]Q`O'#G{O<]Q`O'#G|O<]Q`O'#HOO9kQ`O'#HRO=SQ`O'#HUO>kQ`O'#CeO>{Q`O'#HcO?TQ`O'#HiO?TQ`O'#HkO`QlO'#HmO?TQ`O'#HoO?TQ`O'#HrO?YQ`O'#HxO?_Q!0LsO'#IOO%[QlO'#IQO?jQ!0LsO'#ISO?uQ!0LsO'#IUO9uQ!0LrO'#IWO@QQ!0MxO'#CiOASQpO'#DlQOQ`OOO%[QlO'#EQOAjQ`O'#ETO:dQMhO'#EnOAuQ`O'#EnOBQQ!bO'#FeOOQ['#Cg'#CgOOQ!0Lb'#Dq'#DqOOQ!0Lb'#Jv'#JvO%[QlO'#JvOOQO'#Jy'#JyOOQO'#Ih'#IhOCQQpO'#EgOOQ!0Lb'#Ef'#EfOOQ!0Lb'#J}'#J}OC|Q!0MSO'#EgODWQpO'#EWOOQO'#Jx'#JxODlQpO'#JyOEyQpO'#EWODWQpO'#EgPFWO&2DjO'#CbPOOO)CD})CD}OOOO'#I`'#I`OFcO#tO,59UOOQ!0Lh,59U,59UOOOO'#Ia'#IaOFqO&jO,59UOGPQ!L^O'#DcOOOO'#Ic'#IcOGWO#@ItO,59{OOQ!0Lf,59{,59{OGfQlO'#IdOGyQ`O'#JtOIxQ!fO'#JtO+}QlO'#JtOJPQ`O,5:ROJgQ`O'#EpOJtQ`O'#KTOKPQ`O'#KSOKPQ`O'#KSOKXQ`O,5;^OK^Q`O'#KROOQ!0Ln,5:^,5:^OKeQlO,5:^OMcQ!0MxO,5:fONSQ`O,5:nONmQ!0LrO'#KQONtQ`O'#KPO9eQ`O'#KPO! YQ`O'#KPO! bQ`O,5;]O! gQ`O'#KPO!#lQ!fO'#JsOOQ!0Lh'#Ci'#CiO%[QlO'#ESO!$[Q!fO,5:sOOQS'#Jz'#JzOOQO-E<j-E<jO9kQ`O,5=_O!$rQ`O,5=_O!$wQlO,5;ZO!&zQMhO'#EkO!(eQ`O,5;ZO!(jQlO'#DyO!(tQpO,5;dO!(|QpO,5;dO%[QlO,5;dOOQ['#FT'#FTOOQ['#FV'#FVO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eOOQ['#FZ'#FZO!)[QlO,5;tOOQ!0Lf,5;y,5;yOOQ!0Lf,5;z,5;zOOQ!0Lf,5;|,5;|O%[QlO'#IpO!+_Q!0LrO,5<iO%[QlO,5;eO!&zQMhO,5;eO!+|QMhO,5;eO!-nQMhO'#E^O%[QlO,5;wOOQ!0Lf,5;{,5;{O!-uQ,UO'#FjO!.rQ,UO'#KXO!.^Q,UO'#KXO!.yQ,UO'#KXOOQO'#KX'#KXO!/_Q,UO,5<SOOOW,5<`,5<`O!/pQlO'#FvOOOW'#Io'#IoO7VO7dO,5<QO!/wQ,UO'#FxOOQ!0Lf,5<Q,5<QO!0hQ$IUO'#CyOOQ!0Lh'#C}'#C}O!0{O#@ItO'#DRO!1iQMjO,5<eO!1pQ`O,5<hO!3YQ(CWO'#GXO!3jQ`O'#GYO!3oQ`O'#GYO!5_Q(CWO'#G^O!6dQpO'#GbOOQO'#Gn'#GnO!,TQMhO'#GmOOQO'#Gp'#GpO!,TQMhO'#GoO!7VQ$IUO'#JlOOQ!0Lh'#Jl'#JlO!7aQ`O'#JkO!7oQ`O'#JjO!7wQ`O'#CuOOQ!0Lh'#C{'#C{O!8YQ`O'#C}OOQ!0Lh'#DV'#DVOOQ!0Lh'#DX'#DXO!8_Q`O,5<eO1SQ`O'#DZO!,TQMhO'#GPO!,TQMhO'#GRO!8gQ`O'#GTO!8lQ`O'#GUO!3oQ`O'#G[O!,TQMhO'#GaO<]Q`O'#JkO!8qQ`O'#EqO!9`Q`O,5<gOOQ!0Lb'#Cr'#CrO!9hQ`O'#ErO!:bQpO'#EsOOQ!0Lb'#KR'#KRO!:iQ!0LrO'#KaO9uQ!0LrO,5=cO`QlO,5>tOOQ['#Jh'#JhOOQ[,5>u,5>uOOQ[-E<]-E<]O!<hQ!0MxO,5:bO!:]QpO,5:`O!?RQ!0MxO,5:jO%[QlO,5:jO!AiQ!0MxO,5:lOOQO,5@z,5@zO!BYQMhO,5=_O!BhQ!0LrO'#JiO9`Q`O'#JiO!ByQ!0LrO,59ZO!CUQpO,59ZO!C^QMhO,59ZO:dQMhO,59ZO!CiQ`O,5;ZO!CqQ`O'#HbO!DVQ`O'#KdO%[QlO,5;}O!:]QpO,5<PO!D_Q`O,5=zO!DdQ`O,5=zO!DiQ`O,5=zO!DwQ`O,5=zO9uQ!0LrO,5=zO<]Q`O,5=jOOQO'#Cy'#CyO!EOQpO,5=gO!EWQMhO,5=hO!EcQ`O,5=jO!EhQ!bO,5=mO!EpQ`O'#K`O?YQ`O'#HWO9kQ`O'#HYO!EuQ`O'#HYO:dQMhO'#H[O!EzQ`O'#H[OOQ[,5=p,5=pO!FPQ`O'#H]O!FbQ`O'#CoO!FgQ`O,59PO!FqQ`O,59PO!HvQlO,59POOQ[,59P,59PO!IWQ!0LrO,59PO%[QlO,59PO!KcQlO'#HeOOQ['#Hf'#HfOOQ['#Hg'#HgO`QlO,5=}O!KyQ`O,5=}O`QlO,5>TO`QlO,5>VO!LOQ`O,5>XO`QlO,5>ZO!LTQ`O,5>^O!LYQlO,5>dOOQ[,5>j,5>jO%[QlO,5>jO9uQ!0LrO,5>lOOQ[,5>n,5>nO#!dQ`O,5>nOOQ[,5>p,5>pO#!dQ`O,5>pOOQ[,5>r,5>rO##QQpO'#D_O%[QlO'#JvO##sQpO'#JvO##}QpO'#DmO#$`QpO'#DmO#&qQlO'#DmO#&xQ`O'#JuO#'QQ`O,5:WO#'VQ`O'#EtO#'eQ`O'#KUO#'mQ`O,5;_O#'rQpO'#DmO#(PQpO'#EVOOQ!0Lf,5:o,5:oO%[QlO,5:oO#(WQ`O,5:oO?YQ`O,5;YO!CUQpO,5;YO!C^QMhO,5;YO:dQMhO,5;YO#(`Q`O,5@bO#(eQ07dO,5:sOOQO-E<f-E<fO#)kQ!0MSO,5;RODWQpO,5:rO#)uQpO,5:rODWQpO,5;RO!ByQ!0LrO,5:rOOQ!0Lb'#Ej'#EjOOQO,5;R,5;RO%[QlO,5;RO#*SQ!0LrO,5;RO#*_Q!0LrO,5;RO!CUQpO,5:rOOQO,5;X,5;XO#*mQ!0LrO,5;RPOOO'#I^'#I^P#+RO&2DjO,58|POOO,58|,58|OOOO-E<^-E<^OOQ!0Lh1G.p1G.pOOOO-E<_-E<_OOOO,59},59}O#+^Q!bO,59}OOOO-E<a-E<aOOQ!0Lf1G/g1G/gO#+cQ!fO,5?OO+}QlO,5?OOOQO,5?U,5?UO#+mQlO'#IdOOQO-E<b-E<bO#+zQ`O,5@`O#,SQ!fO,5@`O#,ZQ`O,5@nOOQ!0Lf1G/m1G/mO%[QlO,5@oO#,cQ`O'#IjOOQO-E<h-E<hO#,ZQ`O,5@nOOQ!0Lb1G0x1G0xOOQ!0Ln1G/x1G/xOOQ!0Ln1G0Y1G0YO%[QlO,5@lO#,wQ!0LrO,5@lO#-YQ!0LrO,5@lO#-aQ`O,5@kO9eQ`O,5@kO#-iQ`O,5@kO#-wQ`O'#ImO#-aQ`O,5@kOOQ!0Lb1G0w1G0wO!(tQpO,5:uO!)PQpO,5:uOOQS,5:w,5:wO#.iQdO,5:wO#.qQMhO1G2yO9kQ`O1G2yOOQ!0Lf1G0u1G0uO#/PQ!0MxO1G0uO#0UQ!0MvO,5;VOOQ!0Lh'#GW'#GWO#0rQ!0MzO'#JlO!$wQlO1G0uO#2}Q!fO'#JwO%[QlO'#JwO#3XQ`O,5:eOOQ!0Lh'#D_'#D_OOQ!0Lf1G1O1G1OO%[QlO1G1OOOQ!0Lf1G1f1G1fO#3^Q`O1G1OO#5rQ!0MxO1G1PO#5yQ!0MxO1G1PO#8aQ!0MxO1G1PO#8hQ!0MxO1G1PO#;OQ!0MxO1G1PO#=fQ!0MxO1G1PO#=mQ!0MxO1G1PO#=tQ!0MxO1G1PO#@[Q!0MxO1G1PO#@cQ!0MxO1G1PO#BpQ?MtO'#CiO#DkQ?MtO1G1`O#DrQ?MtO'#JsO#EVQ!0MxO,5?[OOQ!0Lb-E<n-E<nO#GdQ!0MxO1G1PO#HaQ!0MzO1G1POOQ!0Lf1G1P1G1PO#IdQMjO'#J|O#InQ`O,5:xO#IsQ!0MxO1G1cO#JgQ,UO,5<WO#JoQ,UO,5<XO#JwQ,UO'#FoO#K`Q`O'#FnOOQO'#KY'#KYOOQO'#In'#InO#KeQ,UO1G1nOOQ!0Lf1G1n1G1nOOOW1G1y1G1yO#KvQ?MtO'#JrO#LQQ`O,5<bO!)[QlO,5<bOOOW-E<m-E<mOOQ!0Lf1G1l1G1lO#LVQpO'#KXOOQ!0Lf,5<d,5<dO#L_QpO,5<dO#LdQMhO'#DTOOOO'#Ib'#IbO#LkO#@ItO,59mOOQ!0Lh,59m,59mO%[QlO1G2PO!8lQ`O'#IrO#LvQ`O,5<zOOQ!0Lh,5<w,5<wO!,TQMhO'#IuO#MdQMjO,5=XO!,TQMhO'#IwO#NVQMjO,5=ZO!&zQMhO,5=]OOQO1G2S1G2SO#NaQ!dO'#CrO#NtQ(CWO'#ErO$ |QpO'#GbO$!dQ!dO,5<sO$!kQ`O'#K[O9eQ`O'#K[O$!yQ`O,5<uO$#aQ!dO'#C{O!,TQMhO,5<tO$#kQ`O'#GZO$$PQ`O,5<tO$$UQ!dO'#GWO$$cQ!dO'#K]O$$mQ`O'#K]O!&zQMhO'#K]O$$rQ`O,5<xO$$wQlO'#JvO$%RQpO'#GcO#$`QpO'#GcO$%dQ`O'#GgO!3oQ`O'#GkO$%iQ!0LrO'#ItO$%tQpO,5<|OOQ!0Lp,5<|,5<|O$%{QpO'#GcO$&YQpO'#GdO$&kQpO'#GdO$&pQMjO,5=XO$'QQMjO,5=ZOOQ!0Lh,5=^,5=^O!,TQMhO,5@VO!,TQMhO,5@VO$'bQ`O'#IyO$'vQ`O,5@UO$(OQ`O,59aOOQ!0Lh,59i,59iO$(TQ`O,5@VO$)TQ$IYO,59uOOQ!0Lh'#Jp'#JpO$)vQMjO,5<kO$*iQMjO,5<mO@zQ`O,5<oOOQ!0Lh,5<p,5<pO$*sQ`O,5<vO$*xQMjO,5<{O$+YQ`O'#KPO!$wQlO1G2RO$+_Q`O1G2RO9eQ`O'#KSO9eQ`O'#EtO%[QlO'#EtO9eQ`O'#I{O$+dQ!0LrO,5@{OOQ[1G2}1G2}OOQ[1G4`1G4`OOQ!0Lf1G/|1G/|OOQ!0Lf1G/z1G/zO$-fQ!0MxO1G0UOOQ[1G2y1G2yO!&zQMhO1G2yO%[QlO1G2yO#.tQ`O1G2yO$/jQMhO'#EkOOQ!0Lb,5@T,5@TO$/wQ!0LrO,5@TOOQ[1G.u1G.uO!ByQ!0LrO1G.uO!CUQpO1G.uO!C^QMhO1G.uO$0YQ`O1G0uO$0_Q`O'#CiO$0jQ`O'#KeO$0rQ`O,5=|O$0wQ`O'#KeO$0|Q`O'#KeO$1[Q`O'#JRO$1jQ`O,5AOO$1rQ!fO1G1iOOQ!0Lf1G1k1G1kO9kQ`O1G3fO@zQ`O1G3fO$1yQ`O1G3fO$2OQ`O1G3fO!DiQ`O1G3fO9uQ!0LrO1G3fOOQ[1G3f1G3fO!EcQ`O1G3UO!&zQMhO1G3RO$2TQ`O1G3ROOQ[1G3S1G3SO!&zQMhO1G3SO$2YQ`O1G3SO$2bQpO'#HQOOQ[1G3U1G3UO!6_QpO'#I}O!EhQ!bO1G3XOOQ[1G3X1G3XOOQ[,5=r,5=rO$2jQMhO,5=tO9kQ`O,5=tO$%dQ`O,5=vO9`Q`O,5=vO!CUQpO,5=vO!C^QMhO,5=vO:dQMhO,5=vO$2xQ`O'#KcO$3TQ`O,5=wOOQ[1G.k1G.kO$3YQ!0LrO1G.kO@zQ`O1G.kO$3eQ`O1G.kO9uQ!0LrO1G.kO$5mQ!fO,5AQO$5zQ`O,5AQO9eQ`O,5AQO$6VQlO,5>PO$6^Q`O,5>POOQ[1G3i1G3iO`QlO1G3iOOQ[1G3o1G3oOOQ[1G3q1G3qO?TQ`O1G3sO$6cQlO1G3uO$:gQlO'#HtOOQ[1G3x1G3xO$:tQ`O'#HzO?YQ`O'#H|OOQ[1G4O1G4OO$:|QlO1G4OO9uQ!0LrO1G4UOOQ[1G4W1G4WOOQ!0Lb'#G_'#G_O9uQ!0LrO1G4YO9uQ!0LrO1G4[O$?TQ`O,5@bO!)[QlO,5;`O9eQ`O,5;`O?YQ`O,5:XO!)[QlO,5:XO!CUQpO,5:XO$?YQ?MtO,5:XOOQO,5;`,5;`O$?dQpO'#IeO$?zQ`O,5@aOOQ!0Lf1G/r1G/rO$@SQpO'#IkO$@^Q`O,5@pOOQ!0Lb1G0y1G0yO#$`QpO,5:XOOQO'#Ig'#IgO$@fQpO,5:qOOQ!0Ln,5:q,5:qO#(ZQ`O1G0ZOOQ!0Lf1G0Z1G0ZO%[QlO1G0ZOOQ!0Lf1G0t1G0tO?YQ`O1G0tO!CUQpO1G0tO!C^QMhO1G0tOOQ!0Lb1G5|1G5|O!ByQ!0LrO1G0^OOQO1G0m1G0mO%[QlO1G0mO$@mQ!0LrO1G0mO$@xQ!0LrO1G0mO!CUQpO1G0^ODWQpO1G0^O$AWQ!0LrO1G0mOOQO1G0^1G0^O$AlQ!0MxO1G0mPOOO-E<[-E<[POOO1G.h1G.hOOOO1G/i1G/iO$AvQ!bO,5<iO$BOQ!fO1G4jOOQO1G4p1G4pO%[QlO,5?OO$BYQ`O1G5zO$BbQ`O1G6YO$BjQ!fO1G6ZO9eQ`O,5?UO$BtQ!0MxO1G6WO%[QlO1G6WO$CUQ!0LrO1G6WO$CgQ`O1G6VO$CgQ`O1G6VO9eQ`O1G6VO$CoQ`O,5?XO9eQ`O,5?XOOQO,5?X,5?XO$DTQ`O,5?XO$+YQ`O,5?XOOQO-E<k-E<kOOQS1G0a1G0aOOQS1G0c1G0cO#.lQ`O1G0cOOQ[7+(e7+(eO!&zQMhO7+(eO%[QlO7+(eO$DcQ`O7+(eO$DnQMhO7+(eO$D|Q!0MzO,5=XO$GXQ!0MzO,5=ZO$IdQ!0MzO,5=XO$KuQ!0MzO,5=ZO$NWQ!0MzO,59uO%!]Q!0MzO,5<kO%$hQ!0MzO,5<mO%&sQ!0MzO,5<{OOQ!0Lf7+&a7+&aO%)UQ!0MxO7+&aO%)xQlO'#IfO%*VQ`O,5@cO%*_Q!fO,5@cOOQ!0Lf1G0P1G0PO%*iQ`O7+&jOOQ!0Lf7+&j7+&jO%*nQ?MtO,5:fO%[QlO7+&zO%*xQ?MtO,5:bO%+VQ?MtO,5:jO%+aQ?MtO,5:lO%+kQMhO'#IiO%+uQ`O,5@hOOQ!0Lh1G0d1G0dOOQO1G1r1G1rOOQO1G1s1G1sO%+}Q!jO,5<ZO!)[QlO,5<YOOQO-E<l-E<lOOQ!0Lf7+'Y7+'YOOOW7+'e7+'eOOOW1G1|1G1|O%,YQ`O1G1|OOQ!0Lf1G2O1G2OOOOO,59o,59oO%,_Q!dO,59oOOOO-E<`-E<`OOQ!0Lh1G/X1G/XO%,fQ!0MxO7+'kOOQ!0Lh,5?^,5?^O%-YQMhO1G2fP%-aQ`O'#IrPOQ!0Lh-E<p-E<pO%-}QMjO,5?aOOQ!0Lh-E<s-E<sO%.pQMjO,5?cOOQ!0Lh-E<u-E<uO%.zQ!dO1G2wO%/RQ!dO'#CrO%/iQMhO'#KSO$$wQlO'#JvOOQ!0Lh1G2_1G2_O%/sQ`O'#IqO%0[Q`O,5@vO%0[Q`O,5@vO%0dQ`O,5@vO%0oQ`O,5@vOOQO1G2a1G2aO%0}QMjO1G2`O$+YQ`O'#K[O!,TQMhO1G2`O%1_Q(CWO'#IsO%1lQ`O,5@wO!&zQMhO,5@wO%1tQ!dO,5@wOOQ!0Lh1G2d1G2dO%4UQ!fO'#CiO%4`Q`O,5=POOQ!0Lb,5<},5<}O%4hQpO,5<}OOQ!0Lb,5=O,5=OOCwQ`O,5<}O%4sQpO,5<}OOQ!0Lb,5=R,5=RO$+YQ`O,5=VOOQO,5?`,5?`OOQO-E<r-E<rOOQ!0Lp1G2h1G2hO#$`QpO,5<}O$$wQlO,5=PO%5RQ`O,5=OO%5^QpO,5=OO!,TQMhO'#IuO%6WQMjO1G2sO!,TQMhO'#IwO%6yQMjO1G2uO%7TQMjO1G5qO%7_QMjO1G5qOOQO,5?e,5?eOOQO-E<w-E<wOOQO1G.{1G.{O!,TQMhO1G5qO!,TQMhO1G5qO!:]QpO,59wO%[QlO,59wOOQ!0Lh,5<j,5<jO%7lQ`O1G2ZO!,TQMhO1G2bO%7qQ!0MxO7+'mOOQ!0Lf7+'m7+'mO!$wQlO7+'mO%8eQ`O,5;`OOQ!0Lb,5?g,5?gOOQ!0Lb-E<y-E<yO%8jQ!dO'#K^O#(ZQ`O7+(eO4UQ!fO7+(eO$DfQ`O7+(eO%8tQ!0MvO'#CiO%9XQ!0MvO,5=SO%9lQ`O,5=SO%9tQ`O,5=SOOQ!0Lb1G5o1G5oOOQ[7+$a7+$aO!ByQ!0LrO7+$aO!CUQpO7+$aO!$wQlO7+&aO%9yQ`O'#JQO%:bQ`O,5APOOQO1G3h1G3hO9kQ`O,5APO%:bQ`O,5APO%:jQ`O,5APOOQO,5?m,5?mOOQO-E=P-E=POOQ!0Lf7+'T7+'TO%:oQ`O7+)QO9uQ!0LrO7+)QO9kQ`O7+)QO@zQ`O7+)QO%:tQ`O7+)QOOQ[7+)Q7+)QOOQ[7+(p7+(pO%:yQ!0MvO7+(mO!&zQMhO7+(mO!E^Q`O7+(nOOQ[7+(n7+(nO!&zQMhO7+(nO%;TQ`O'#KbO%;`Q`O,5=lOOQO,5?i,5?iOOQO-E<{-E<{OOQ[7+(s7+(sO%<rQpO'#HZOOQ[1G3`1G3`O!&zQMhO1G3`O%[QlO1G3`O%<yQ`O1G3`O%=UQMhO1G3`O9uQ!0LrO1G3bO$%dQ`O1G3bO9`Q`O1G3bO!CUQpO1G3bO!C^QMhO1G3bO%=dQ`O'#JPO%=xQ`O,5@}O%>QQpO,5@}OOQ!0Lb1G3c1G3cOOQ[7+$V7+$VO@zQ`O7+$VO9uQ!0LrO7+$VO%>]Q`O7+$VO%[QlO1G6lO%[QlO1G6mO%>bQ!0LrO1G6lO%>lQlO1G3kO%>sQ`O1G3kO%>xQlO1G3kOOQ[7+)T7+)TO9uQ!0LrO7+)_O`QlO7+)aOOQ['#Kh'#KhOOQ['#JS'#JSO%?PQlO,5>`OOQ[,5>`,5>`O%[QlO'#HuO%?^Q`O'#HwOOQ[,5>f,5>fO9eQ`O,5>fOOQ[,5>h,5>hOOQ[7+)j7+)jOOQ[7+)p7+)pOOQ[7+)t7+)tOOQ[7+)v7+)vO%?cQpO1G5|O%?}Q?MtO1G0zO%@XQ`O1G0zOOQO1G/s1G/sO%@dQ?MtO1G/sO?YQ`O1G/sO!)[QlO'#DmOOQO,5?P,5?POOQO-E<c-E<cOOQO,5?V,5?VOOQO-E<i-E<iO!CUQpO1G/sOOQO-E<e-E<eOOQ!0Ln1G0]1G0]OOQ!0Lf7+%u7+%uO#(ZQ`O7+%uOOQ!0Lf7+&`7+&`O?YQ`O7+&`O!CUQpO7+&`OOQO7+%x7+%xO$AlQ!0MxO7+&XOOQO7+&X7+&XO%[QlO7+&XO%@nQ!0LrO7+&XO!ByQ!0LrO7+%xO!CUQpO7+%xO%@yQ!0LrO7+&XO%AXQ!0MxO7++rO%[QlO7++rO%AiQ`O7++qO%AiQ`O7++qOOQO1G4s1G4sO9eQ`O1G4sO%AqQ`O1G4sOOQS7+%}7+%}O#(ZQ`O<<LPO4UQ!fO<<LPO%BPQ`O<<LPOOQ[<<LP<<LPO!&zQMhO<<LPO%[QlO<<LPO%BXQ`O<<LPO%BdQ!0MzO,5?aO%DoQ!0MzO,5?cO%FzQ!0MzO1G2`O%I]Q!0MzO1G2sO%KhQ!0MzO1G2uO%MsQ!fO,5?QO%[QlO,5?QOOQO-E<d-E<dO%M}Q`O1G5}OOQ!0Lf<<JU<<JUO%NVQ?MtO1G0uO&!^Q?MtO1G1PO&!eQ?MtO1G1PO&$fQ?MtO1G1PO&$mQ?MtO1G1PO&&nQ?MtO1G1PO&(oQ?MtO1G1PO&(vQ?MtO1G1PO&(}Q?MtO1G1PO&+OQ?MtO1G1PO&+VQ?MtO1G1PO&+^Q!0MxO<<JfO&-UQ?MtO1G1PO&.RQ?MvO1G1PO&/UQ?MvO'#JlO&1[Q?MtO1G1cO&1iQ?MtO1G0UO&1sQMjO,5?TOOQO-E<g-E<gO!)[QlO'#FqOOQO'#KZ'#KZOOQO1G1u1G1uO&1}Q`O1G1tO&2SQ?MtO,5?[OOOW7+'h7+'hOOOO1G/Z1G/ZO&2^Q!dO1G4xOOQ!0Lh7+(Q7+(QP!&zQMhO,5?^O!,TQMhO7+(cO&2eQ`O,5?]O9eQ`O,5?]O$+YQ`O,5?]OOQO-E<o-E<oO&2sQ`O1G6bO&2sQ`O1G6bO&2{Q`O1G6bO&3WQMjO7+'zO&3hQ!dO,5?_O&3rQ`O,5?_O!&zQMhO,5?_OOQO-E<q-E<qO&3wQ!dO1G6cO&4RQ`O1G6cO&4ZQ`O1G2kO!&zQMhO1G2kOOQ!0Lb1G2i1G2iOOQ!0Lb1G2j1G2jO%4hQpO1G2iO!CUQpO1G2iOCwQ`O1G2iOOQ!0Lb1G2q1G2qO&4`QpO1G2iO&4nQ`O1G2kO$+YQ`O1G2jOCwQ`O1G2jO$$wQlO1G2kO&4vQ`O1G2jO&5jQMjO,5?aOOQ!0Lh-E<t-E<tO&6]QMjO,5?cOOQ!0Lh-E<v-E<vO!,TQMhO7++]O&6gQMjO7++]O&6qQMjO7++]OOQ!0Lh1G/c1G/cO&7OQ`O1G/cOOQ!0Lh7+'u7+'uO&7TQMjO7+'|O&7eQ!0MxO<<KXOOQ!0Lf<<KX<<KXO&8XQ`O1G0zO!&zQMhO'#IzO&8^Q`O,5@xO&:`Q!fO<<LPO!&zQMhO1G2nO&:gQ!0LrO1G2nOOQ[<<G{<<G{O!ByQ!0LrO<<G{O&:xQ!0MxO<<I{OOQ!0Lf<<I{<<I{OOQO,5?l,5?lO&;lQ`O,5?lO&;qQ`O,5?lOOQO-E=O-E=OO&<PQ`O1G6kO&<PQ`O1G6kO9kQ`O1G6kO@zQ`O<<LlOOQ[<<Ll<<LlO&<XQ`O<<LlO9uQ!0LrO<<LlO9kQ`O<<LlOOQ[<<LX<<LXO%:yQ!0MvO<<LXOOQ[<<LY<<LYO!E^Q`O<<LYO&<^QpO'#I|O&<iQ`O,5@|O!)[QlO,5@|OOQ[1G3W1G3WOOQO'#JO'#JOO9uQ!0LrO'#JOO&<qQpO,5=uOOQ[,5=u,5=uO&<xQpO'#EgO&=PQpO'#GeO&=UQ`O7+(zO&=ZQ`O7+(zOOQ[7+(z7+(zO!&zQMhO7+(zO%[QlO7+(zO&=cQ`O7+(zOOQ[7+(|7+(|O9uQ!0LrO7+(|O$%dQ`O7+(|O9`Q`O7+(|O!CUQpO7+(|O&=nQ`O,5?kOOQO-E<}-E<}OOQO'#H^'#H^O&=yQ`O1G6iO9uQ!0LrO<<GqOOQ[<<Gq<<GqO@zQ`O<<GqO&>RQ`O7+,WO&>WQ`O7+,XO%[QlO7+,WO%[QlO7+,XOOQ[7+)V7+)VO&>]Q`O7+)VO&>bQlO7+)VO&>iQ`O7+)VOOQ[<<Ly<<LyOOQ[<<L{<<L{OOQ[-E=Q-E=QOOQ[1G3z1G3zO&>nQ`O,5>aOOQ[,5>c,5>cO&>sQ`O1G4QO9eQ`O7+&fO!)[QlO7+&fOOQO7+%_7+%_O&>xQ?MtO1G6ZO?YQ`O7+%_OOQ!0Lf<<Ia<<IaOOQ!0Lf<<Iz<<IzO?YQ`O<<IzOOQO<<Is<<IsO$AlQ!0MxO<<IsO%[QlO<<IsOOQO<<Id<<IdO!ByQ!0LrO<<IdO&?SQ!0LrO<<IsO&?_Q!0MxO<= ^O&?oQ`O<= ]OOQO7+*_7+*_O9eQ`O7+*_OOQ[ANAkANAkO&?wQ!fOANAkO!&zQMhOANAkO#(ZQ`OANAkO4UQ!fOANAkO&@OQ`OANAkO%[QlOANAkO&@WQ!0MzO7+'zO&BiQ!0MzO,5?aO&DtQ!0MzO,5?cO&GPQ!0MzO7+'|O&IbQ!fO1G4lO&IlQ?MtO7+&aO&KpQ?MvO,5=XO&MwQ?MvO,5=ZO&NXQ?MvO,5=XO&NiQ?MvO,5=ZO&NyQ?MvO,59uO'#PQ?MvO,5<kO'%SQ?MvO,5<mO''hQ?MvO,5<{O')^Q?MtO7+'kO')kQ?MtO7+'mO')xQ`O,5<]OOQO7+'`7+'`OOQ!0Lh7+*d7+*dO')}QMjO<<K}OOQO1G4w1G4wO'*UQ`O1G4wO'*aQ`O1G4wO'*oQ`O7++|O'*oQ`O7++|O!&zQMhO1G4yO'*wQ!dO1G4yO'+RQ`O7++}O'+ZQ`O7+(VO'+fQ!dO7+(VOOQ!0Lb7+(T7+(TOOQ!0Lb7+(U7+(UO!CUQpO7+(TOCwQ`O7+(TO'+pQ`O7+(VO!&zQMhO7+(VO$+YQ`O7+(UO'+uQ`O7+(VOCwQ`O7+(UO'+}QMjO<<NwO!,TQMhO<<NwOOQ!0Lh7+$}7+$}O',XQ!dO,5?fOOQO-E<x-E<xO',cQ!0MvO7+(YO!&zQMhO7+(YOOQ[AN=gAN=gO9kQ`O1G5WOOQO1G5W1G5WO',sQ`O1G5WO',xQ`O7+,VO',xQ`O7+,VO9uQ!0LrOANBWO@zQ`OANBWOOQ[ANBWANBWO'-QQ`OANBWOOQ[ANAsANAsOOQ[ANAtANAtO'-VQ`O,5?hOOQO-E<z-E<zO'-bQ?MtO1G6hOOQO,5?j,5?jOOQO-E<|-E<|OOQ[1G3a1G3aO'-lQ`O,5=POOQ[<<Lf<<LfO!&zQMhO<<LfO&=UQ`O<<LfO'-qQ`O<<LfO%[QlO<<LfOOQ[<<Lh<<LhO9uQ!0LrO<<LhO$%dQ`O<<LhO9`Q`O<<LhO'-yQpO1G5VO'.UQ`O7+,TOOQ[AN=]AN=]O9uQ!0LrOAN=]OOQ[<= r<= rOOQ[<= s<= sO'.^Q`O<= rO'.cQ`O<= sOOQ[<<Lq<<LqO'.hQ`O<<LqO'.mQlO<<LqOOQ[1G3{1G3{O?YQ`O7+)lO'.tQ`O<<JQO'/PQ?MtO<<JQOOQO<<Hy<<HyOOQ!0LfAN?fAN?fOOQOAN?_AN?_O$AlQ!0MxOAN?_OOQOAN?OAN?OO%[QlOAN?_OOQO<<My<<MyOOQ[G27VG27VO!&zQMhOG27VO#(ZQ`OG27VO'/ZQ!fOG27VO4UQ!fOG27VO'/bQ`OG27VO'/jQ?MtO<<JfO'/wQ?MvO1G2`O'1mQ?MvO,5?aO'3pQ?MvO,5?cO'5sQ?MvO1G2sO'7vQ?MvO1G2uO'9yQ?MtO<<KXO':WQ?MtO<<I{OOQO1G1w1G1wO!,TQMhOANAiOOQO7+*c7+*cO':eQ`O7+*cO':pQ`O<= hO':xQ!dO7+*eOOQ!0Lb<<Kq<<KqO$+YQ`O<<KqOCwQ`O<<KqO';SQ`O<<KqO!&zQMhO<<KqOOQ!0Lb<<Ko<<KoO!CUQpO<<KoO';_Q!dO<<KqOOQ!0Lb<<Kp<<KpO';iQ`O<<KqO!&zQMhO<<KqO$+YQ`O<<KpO';nQMjOANDcO';xQ!0MvO<<KtOOQO7+*r7+*rO9kQ`O7+*rO'<YQ`O<= qOOQ[G27rG27rO9uQ!0LrOG27rO@zQ`OG27rO!)[QlO1G5SO'<bQ`O7+,SO'<jQ`O1G2kO&=UQ`OANBQOOQ[ANBQANBQO!&zQMhOANBQO'<oQ`OANBQOOQ[ANBSANBSO9uQ!0LrOANBSO$%dQ`OANBSOOQO'#H_'#H_OOQO7+*q7+*qOOQ[G22wG22wOOQ[ANE^ANE^OOQ[ANE_ANE_OOQ[ANB]ANB]O'<wQ`OANB]OOQ[<<MW<<MWO!)[QlOAN?lOOQOG24yG24yO$AlQ!0MxOG24yO#(ZQ`OLD,qOOQ[LD,qLD,qO!&zQMhOLD,qO'<|Q!fOLD,qO'=TQ?MvO7+'zO'>yQ?MvO,5?aO'@|Q?MvO,5?cO'CPQ?MvO7+'|O'DuQMjOG27TOOQO<<M}<<M}OOQ!0LbANA]ANA]O$+YQ`OANA]OCwQ`OANA]O'EVQ!dOANA]OOQ!0LbANAZANAZO'E^Q`OANA]O!&zQMhOANA]O'EiQ!dOANA]OOQ!0LbANA[ANA[OOQO<<N^<<N^OOQ[LD-^LD-^O9uQ!0LrOLD-^O'EsQ?MtO7+*nOOQO'#Gf'#GfOOQ[G27lG27lO&=UQ`OG27lO!&zQMhOG27lOOQ[G27nG27nO9uQ!0LrOG27nOOQ[G27wG27wO'E}Q?MtOG25WOOQOLD*eLD*eOOQ[!$(!]!$(!]O#(ZQ`O!$(!]O!&zQMhO!$(!]O'FXQ!0MzOG27TOOQ!0LbG26wG26wO$+YQ`OG26wO'HjQ`OG26wOCwQ`OG26wO'HuQ!dOG26wO!&zQMhOG26wOOQ[!$(!x!$(!xOOQ[LD-WLD-WO&=UQ`OLD-WOOQ[LD-YLD-YOOQ[!)9Ew!)9EwO#(ZQ`O!)9EwOOQ!0LbLD,cLD,cO$+YQ`OLD,cOCwQ`OLD,cO'H|Q`OLD,cO'IXQ!dOLD,cOOQ[!$(!r!$(!rOOQ[!.K;c!.K;cO'I`Q?MvOG27TOOQ!0Lb!$( }!$( }O$+YQ`O!$( }OCwQ`O!$( }O'KUQ`O!$( }OOQ!0Lb!)9Ei!)9EiO$+YQ`O!)9EiOCwQ`O!)9EiOOQ!0Lb!.K;T!.K;TO$+YQ`O!.K;TOOQ!0Lb!4/0o!4/0oO!)[QlO'#DzO1PQ`O'#EXO'KaQ!fO'#JrO'KhQ!L^O'#DvO'KoQlO'#EOO'KvQ!fO'#CiO'N^Q!fO'#CiO!)[QlO'#EQO'NnQlO,5;ZO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO'#IpO(!qQ`O,5<iO!)[QlO,5;eO(!yQMhO,5;eO($dQMhO,5;eO!)[QlO,5;wO!&zQMhO'#GmO(!yQMhO'#GmO!&zQMhO'#GoO(!yQMhO'#GoO1SQ`O'#DZO1SQ`O'#DZO!&zQMhO'#GPO(!yQMhO'#GPO!&zQMhO'#GRO(!yQMhO'#GRO!&zQMhO'#GaO(!yQMhO'#GaO!)[QlO,5:jO($kQpO'#D_O($uQpO'#JvO!)[QlO,5@oO'NnQlO1G0uO(%PQ?MtO'#CiO!)[QlO1G2PO!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO(%ZQ!dO'#CrO!&zQMhO,5<tO(!yQMhO,5<tO'NnQlO1G2RO!)[QlO7+&zO!&zQMhO1G2`O(!yQMhO1G2`O!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO!&zQMhO1G2bO(!yQMhO1G2bO'NnQlO7+'mO'NnQlO7+&aO!&zQMhOANAiO(!yQMhOANAiO(%nQ`O'#EoO(%sQ`O'#EoO(%{Q`O'#F]O(&QQ`O'#EyO(&VQ`O'#KTO(&bQ`O'#KRO(&mQ`O,5;ZO(&rQMjO,5<eO(&yQ`O'#GYO('OQ`O'#GYO('TQ`O,5<eO(']Q`O,5<gO('eQ`O,5;ZO('mQ?MtO1G1`O('tQ`O,5<tO('yQ`O,5<tO((OQ`O,5<vO((TQ`O,5<vO((YQ`O1G2RO((_Q`O1G0uO((dQMjO<<K}O((kQMjO<<K}O((rQMhO'#F|O9`Q`O'#F{OAuQ`O'#EnO!)[QlO,5;tO!3oQ`O'#GYO!3oQ`O'#GYO!3oQ`O'#G[O!3oQ`O'#G[O!,TQMhO7+(cO!,TQMhO7+(cO%.zQ!dO1G2wO%.zQ!dO1G2wO!&zQMhO,5=]O!&zQMhO,5=]",
  stateData: "()x~O'|OS'}OSTOS(ORQ~OPYOQYOSfOY!VOaqOdzOeyOl!POpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O$W|O$niO%h}O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO&W!WO&^!XO&`!YO&b!ZO&d![O&g!]O&m!^O&s!_O&u!`O&w!aO&y!bO&{!cO(TSO(VTO(YUO(aVO(o[O~OWtO~P`OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa!wOs!nO!S!oO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!xO#W!pO#X!pO#[!zO#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O(O!{O~OP]XR]X[]Xa]Xj]Xr]X!Q]X!S]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X'z]X(a]X(r]X(y]X(z]X~O!g%RX~P(qO_!}O(V#PO(W!}O(X#PO~O_#QO(X#PO(Y#PO(Z#QO~Ox#SO!U#TO(b#TO(c#VO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T<ZO(VTO(YUO(aVO(o[O~O![#ZO!]#WO!Y(hP!Y(vP~P+}O!^#cO~P`OPYOQYOSfOd!jOe!iOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(VTO(YUO(aVO(o[O~Op#mO![#iO!|]O#i#lO#j#iO(T<[O!k(sP~P.iO!l#oO(T#nO~O!x#sO!|]O%h#tO~O#k#uO~O!g#vO#k#uO~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!]$_O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa(fX'z(fX'w(fX!k(fX!Y(fX!_(fX%i(fX!g(fX~P1qO#S$dO#`$eO$Q$eOP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX!_(gX%i(gX~Oa(gX'z(gX'w(gX!Y(gX!k(gXv(gX!g(gX~P4UO#`$eO~O$]$hO$_$gO$f$mO~OSfO!_$nO$i$oO$k$qO~Oh%VOj%dOk%dOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T$sO(VTO(YUO(a$uO(y$}O(z%POg(^P~Ol%[O~P7eO!l%eO~O!S%hO!_%iO(T%gO~O!g%mO~Oa%nO'z%nO~O!Q%rO~P%[O(U!lO~P%[O%n%vO~P%[Oh%VO!l%eO(T%gO(U!lO~Oe%}O!l%eO(T%gO~Oj$RO~O!_&PO(T%gO(U!lO(VTO(YUO`)WP~O!Q&SO!l&RO%j&VO&T&WO~P;SO!x#sO~O%s&YO!S)SX!_)SX(T)SX~O(T&ZO~Ol!PO!u&`O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO~Od&eOe&dO!x&bO%h&cO%{&aO~P<bOd&hOeyOl!PO!_&gO!u&`O!xxO!|]O%h}O%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO~Ob&kO#`&nO%j&iO(U!lO~P=gO!l&oO!u&sO~O!l#oO~O!_XO~Oa%nO'x&{O'z%nO~Oa%nO'x'OO'z%nO~Oa%nO'x'QO'z%nO~O'w]X!Y]Xv]X!k]X&[]X!_]X%i]X!g]X~P(qO!b'_O!c'WO!d'WO(U!lO(VTO(YUO~Os'UO!S'TO!['XO(e'SO!^(iP!^(xP~P@nOn'bO!_'`O(T%gO~Oe'gO!l%eO(T%gO~O!Q&SO!l&RO~Os!nO!S!oO!|<VO#T!pO#U!pO#W!pO#X!pO(U!lO(VTO(YUO(e!mO(o!sO~O!b'mO!c'lO!d'lO#V!pO#['nO#]'nO~PBYOa%nOh%VO!g#vO!l%eO'z%nO(r'pO~O!p'tO#`'rO~PChOs!nO!S!oO(VTO(YUO(e!mO(o!sO~O!_XOs(mX!S(mX!b(mX!c(mX!d(mX!|(mX#T(mX#U(mX#V(mX#W(mX#X(mX#[(mX#](mX(U(mX(V(mX(Y(mX(e(mX(o(mX~O!c'lO!d'lO(U!lO~PDWO(P'xO(Q'xO(R'zO~O_!}O(V'|O(W!}O(X'|O~O_#QO(X'|O(Y'|O(Z#QO~Ov(OO~P%[Ox#SO!U#TO(b#TO(c(RO~O![(TO!Y'WX!Y'^X!]'WX!]'^X~P+}O!](VO!Y(hX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!](VO!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~O!Y(hX~PHRO!Y([O~O!Y(uX!](uX!g(uX!k(uX(r(uX~O#`(uX#k#dX!^(uX~PJUO#`(]O!Y(wX!](wX~O!](^O!Y(vX~O!Y(aO~O#`$eO~PJUO!^(bO~P`OR#zO!Q#yO!S#{O!l#xO(aVOP!na[!naj!nar!na!]!na!p!na#R!na#n!na#o!na#p!na#q!na#r!na#s!na#t!na#u!na#v!na#x!na#z!na#{!na(r!na(y!na(z!na~Oa!na'z!na'w!na!Y!na!k!nav!na!_!na%i!na!g!na~PKlO!k(cO~O!g#vO#`(dO(r'pO!](tXa(tX'z(tX~O!k(tX~PNXO!S%hO!_%iO!|]O#i(iO#j(hO(T%gO~O!](jO!k(sX~O!k(lO~O!S%hO!_%iO#j(hO(T%gO~OP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~O!g#vO!k(gX~P! uOR(nO!Q(mO!l#xO#S$dO!|!{a!S!{a~O!x!{a%h!{a!_!{a#i!{a#j!{a(T!{a~P!#vO!x(rO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~O#k(xO~O![(zO!k(kP~P%[O(e(|O(o[O~O!S)OO!l#xO(e(|O(o[O~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]$_Oa$qa'z$qa'w$qa!k$qa!Y$qa!_$qa%i$qa!g$qa~Ol)dO~P!&zOh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Og(pP~P!,TO!Q)iO!g)hO!_$^X$Z$^X$]$^X$_$^X$f$^X~O!g)hO!_({X$Z({X$]({X$_({X$f({X~O!Q)iO~P!.^O!Q)iO!_({X$Z({X$]({X$_({X$f({X~O!_)kO$Z)oO$])jO$_)jO$f)pO~O![)sO~P!)[O$]$hO$_$gO$f)wO~On$zX!Q$zX#S$zX'y$zX(y$zX(z$zX~OgmXg$zXnmX!]mX#`mX~P!0SOx)yO(b)zO(c)|O~On*VO!Q*OO'y*PO(y$}O(z%PO~Og)}O~P!1WOg*WO~Oh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S*YO!_*ZO!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op*`O![*^O(T*XO!k)OP~P!1uO#k*aO~O!l*bO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T*dO(VTO(YUO(a$uO(y$}O(z%PO~O![*gO!Y)PP~P!3tOr*sOs!nO!S*iO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO(e!mO~O!^*pO~P!5iO#S$dOn(`X!Q(`X'y(`X(y(`X(z(`X!](`X#`(`X~Og(`X$O(`X~P!6kOn*xO#`*wOg(_X!](_X~O!]*yOg(^X~Oj%dOk%dOl%dO(T&ZOg(^P~Os*|O~Og)}O(T&ZO~O!l+SO~O(T(vO~Op+WO!S%hO![#iO!_%iO!|]O#i#lO#j#iO(T%gO!k(sP~O!g#vO#k+XO~O!S%hO![+ZO!](^O!_%iO(T%gO!Y(vP~Os'[O!S+]O![+[O(VTO(YUO(e(|O~O!^(xP~P!9|O!]+^Oa)TX'z)TX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa!ja!]!ja'z!ja'w!ja!Y!ja!k!jav!ja!_!ja%i!ja!g!ja~P!:tOR#zO!Q#yO!S#{O!l#xO(aVOP!ra[!raj!rar!ra!]!ra!p!ra#R!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#v!ra#x!ra#z!ra#{!ra(r!ra(y!ra(z!ra~Oa!ra'z!ra'w!ra!Y!ra!k!rav!ra!_!ra%i!ra!g!ra~P!=[OR#zO!Q#yO!S#{O!l#xO(aVOP!ta[!taj!tar!ta!]!ta!p!ta#R!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#t!ta#u!ta#v!ta#x!ta#z!ta#{!ta(r!ta(y!ta(z!ta~Oa!ta'z!ta'w!ta!Y!ta!k!tav!ta!_!ta%i!ta!g!ta~P!?rOh%VOn+gO!_'`O%i+fO~O!g+iOa(]X!_(]X'z(]X!](]X~Oa%nO!_XO'z%nO~Oh%VO!l%eO~Oh%VO!l%eO(T%gO~O!g#vO#k(xO~Ob+tO%j+uO(T+qO(VTO(YUO!^)XP~O!]+vO`)WX~O[+zO~O`+{O~O!_&PO(T%gO(U!lO`)WP~O%j,OO~P;SOh%VO#`,SO~Oh%VOn,VO!_$|O~O!_,XO~O!Q,ZO!_XO~O%n%vO~O!x,`O~Oe,eO~Ob,fO(T#nO(VTO(YUO!^)VP~Oe%}O~O%j!QO(T&ZO~P=gO[,kO`,jO~OPYOQYOSfOdzOeyOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!iuO!lZO!oYO!pYO!qYO!svO!xxO!|]O$niO%h}O(VTO(YUO(aVO(o[O~O!_!eO!u!gO$W!kO(T!dO~P!FyO`,jOa%nO'z%nO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa,pOl!OO!uwO%l!OO%m!OO%n!OO~P!IcO!l&oO~O&^,vO~O!_,xO~O&o,zO&q,{OP&laQ&laS&laY&laa&lad&lae&lal&lap&lar&las&lat&laz&la|&la!O&la!S&la!W&la!X&la!_&la!i&la!l&la!o&la!p&la!q&la!s&la!u&la!x&la!|&la$W&la$n&la%h&la%j&la%l&la%m&la%n&la%q&la%s&la%v&la%w&la%y&la&W&la&^&la&`&la&b&la&d&la&g&la&m&la&s&la&u&la&w&la&y&la&{&la'w&la(T&la(V&la(Y&la(a&la(o&la!^&la&e&lab&la&j&la~O(T-QO~Oh!eX!]!RX!^!RX!g!RX!g!eX!l!eX#`!RX~O!]!eX!^!eX~P#!iO!g-VO#`-UOh(jX!]#hX!^#hX!g(jX!l(jX~O!](jX!^(jX~P##[Oh%VO!g-XO!l%eO!]!aX!^!aX~Os!nO!S!oO(VTO(YUO(e!mO~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(VTO(YUO(aVO(o[O~O(T=QO~P#$qO!]-]O!^(iX~O!^-_O~O!g-VO#`-UO!]#hX!^#hX~O!]-`O!^(xX~O!^-bO~O!c-cO!d-cO(U!lO~P#$`O!^-fO~P'_On-iO!_'`O~O!Y-nO~Os!{a!b!{a!c!{a!d!{a#T!{a#U!{a#V!{a#W!{a#X!{a#[!{a#]!{a(U!{a(V!{a(Y!{a(e!{a(o!{a~P!#vO!p-sO#`-qO~PChO!c-uO!d-uO(U!lO~PDWOa%nO#`-qO'z%nO~Oa%nO!g#vO#`-qO'z%nO~Oa%nO!g#vO!p-sO#`-qO'z%nO(r'pO~O(P'xO(Q'xO(R-zO~Ov-{O~O!Y'Wa!]'Wa~P!:tO![.PO!Y'WX!]'WX~P%[O!](VO!Y(ha~O!Y(ha~PHRO!](^O!Y(va~O!S%hO![.TO!_%iO(T%gO!Y'^X!]'^X~O#`.VO!](ta!k(taa(ta'z(ta~O!g#vO~P#,wO!](jO!k(sa~O!S%hO!_%iO#j.ZO(T%gO~Op.`O!S%hO![.]O!_%iO!|]O#i._O#j.]O(T%gO!]'aX!k'aX~OR.dO!l#xO~Oh%VOn.gO!_'`O%i.fO~Oa#ci!]#ci'z#ci'w#ci!Y#ci!k#civ#ci!_#ci%i#ci!g#ci~P!:tOn>]O!Q*OO'y*PO(y$}O(z%PO~O#k#_aa#_a#`#_a'z#_a!]#_a!k#_a!_#_a!Y#_a~P#/sO#k(`XP(`XR(`X[(`Xa(`Xj(`Xr(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X'z(`X(a(`X(r(`X!k(`X!Y(`X'w(`Xv(`X!_(`X%i(`X!g(`X~P!6kO!].tO!k(kX~P!:tO!k.wO~O!Y.yO~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mia#mij#mir#mi!]#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#n#mi~P#3cO#n$OO~P#3cOP$[OR#zOr$aO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO[#mia#mij#mi!]#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#r#mi~P#6QO#r$QO~P#6QOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO(aVOa#mi!]#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#v#mi~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO(aVO(z#}Oa#mi!]#mi#z#mi#{#mi'z#mi(r#mi(y#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#x$UO~P#;VO#x#mi~P#;VO#v$SO~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO(aVO(y#|O(z#}Oa#mi!]#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#z#mi~P#={O#z$WO~P#={OP]XR]X[]Xj]Xr]X!Q]X!S]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X!]]X!^]X~O$O]X~P#@jOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO#z<gO#{<hO(aVO(r$YO(y#|O(z#}O~O$O.{O~P#BwO#S$dO#`<nO$Q<nO$O(gX!^(gX~P! uOa'da!]'da'z'da'w'da!k'da!Y'dav'da!_'da%i'da!g'da~P!:tO[#mia#mij#mir#mi!]#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO(y#mi(z#mi~P#EyOn>]O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P#EyO!]/POg(pX~P!1WOg/RO~Oa$Pi!]$Pi'z$Pi'w$Pi!Y$Pi!k$Piv$Pi!_$Pi%i$Pi!g$Pi~P!:tO$]/SO$_/SO~O$]/TO$_/TO~O!g)hO#`/UO!_$cX$Z$cX$]$cX$_$cX$f$cX~O![/VO~O!_)kO$Z/XO$])jO$_)jO$f/YO~O!]<iO!^(fX~P#BwO!^/ZO~O!g)hO$f({X~O$f/]O~Ov/^O~P!&zOx)yO(b)zO(c/aO~O!S/dO~O(y$}On%aa!Q%aa'y%aa(z%aa!]%aa#`%aa~Og%aa$O%aa~P#L{O(z%POn%ca!Q%ca'y%ca(y%ca!]%ca#`%ca~Og%ca$O%ca~P#MnO!]fX!gfX!kfX!k$zX(rfX~P!0SOp%WO![/mO!](^O(T/lO!Y(vP!Y)PP~P!1uOr*sO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO~Os<}O!S/nO![+[O!^*pO(e<|O!^(xP~P$ [O!k/oO~P#/sO!]/pO!g#vO(r'pO!k)OX~O!k/uO~OnoX!QoX'yoX(yoX(zoX~O!g#vO!koX~P$#OOp/wO!S%hO![*^O!_%iO(T%gO!k)OP~O#k/xO~O!Y$zX!]$zX!g%RX~P!0SO!]/yO!Y)PX~P#/sO!g/{O~O!Y/}O~OpkO(T0OO~P.iOh%VOr0TO!g#vO!l%eO(r'pO~O!g+iO~Oa%nO!]0XO'z%nO~O!^0ZO~P!5iO!c0[O!d0[O(U!lO~P#$`Os!nO!S0]O(VTO(YUO(e!mO~O#[0_O~Og%aa!]%aa#`%aa$O%aa~P!1WOg%ca!]%ca#`%ca$O%ca~P!1WOj%dOk%dOl%dO(T&ZOg'mX!]'mX~O!]*yOg(^a~Og0hO~On0jO#`0iOg(_a!](_a~OR0kO!Q0kO!S0lO#S$dOn}a'y}a(y}a(z}a!]}a#`}a~Og}a$O}a~P$(cO!Q*OO'y*POn$sa(y$sa(z$sa!]$sa#`$sa~Og$sa$O$sa~P$)_O!Q*OO'y*POn$ua(y$ua(z$ua!]$ua#`$ua~Og$ua$O$ua~P$*QO#k0oO~Og%Ta!]%Ta#`%Ta$O%Ta~P!1WO!g#vO~O#k0rO~O!]+^Oa)Ta'z)Ta~OR#zO!Q#yO!S#{O!l#xO(aVOP!ri[!rij!rir!ri!]!ri!p!ri#R!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#t!ri#u!ri#v!ri#x!ri#z!ri#{!ri(r!ri(y!ri(z!ri~Oa!ri'z!ri'w!ri!Y!ri!k!riv!ri!_!ri%i!ri!g!ri~P$+oOh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op0{O%]0|O(T0zO~P$.VO!g+iOa(]a!_(]a'z(]a!](]a~O#k1SO~O[]X!]fX!^fX~O!]1TO!^)XX~O!^1VO~O[1WO~Ob1YO(T+qO(VTO(YUO~O!_&PO(T%gO`'uX!]'uX~O!]+vO`)Wa~O!k1]O~P!:tO[1`O~O`1aO~O#`1fO~On1iO!_$|O~O(e(|O!^)UP~Oh%VOn1rO!_1oO%i1qO~O[1|O!]1zO!^)VX~O!^1}O~O`2POa%nO'z%nO~O(T#nO(VTO(YUO~O#S$dO#`$eO$Q$eOP(gXR(gX[(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~Oj2SO&[2TOa(gX~P$3pOj2SO#`$eO&[2TO~Oa2VO~P%[Oa2XO~O&e2[OP&ciQ&ciS&ciY&cia&cid&cie&cil&cip&cir&cis&cit&ciz&ci|&ci!O&ci!S&ci!W&ci!X&ci!_&ci!i&ci!l&ci!o&ci!p&ci!q&ci!s&ci!u&ci!x&ci!|&ci$W&ci$n&ci%h&ci%j&ci%l&ci%m&ci%n&ci%q&ci%s&ci%v&ci%w&ci%y&ci&W&ci&^&ci&`&ci&b&ci&d&ci&g&ci&m&ci&s&ci&u&ci&w&ci&y&ci&{&ci'w&ci(T&ci(V&ci(Y&ci(a&ci(o&ci!^&cib&ci&j&ci~Ob2bO!^2`O&j2aO~P`O!_XO!l2dO~O&q,{OP&liQ&liS&liY&lia&lid&lie&lil&lip&lir&lis&lit&liz&li|&li!O&li!S&li!W&li!X&li!_&li!i&li!l&li!o&li!p&li!q&li!s&li!u&li!x&li!|&li$W&li$n&li%h&li%j&li%l&li%m&li%n&li%q&li%s&li%v&li%w&li%y&li&W&li&^&li&`&li&b&li&d&li&g&li&m&li&s&li&u&li&w&li&y&li&{&li'w&li(T&li(V&li(Y&li(a&li(o&li!^&li&e&lib&li&j&li~O!Y2jO~O!]!aa!^!aa~P#BwOs!nO!S!oO![2pO(e!mO!]'XX!^'XX~P@nO!]-]O!^(ia~O!]'_X!^'_X~P!9|O!]-`O!^(xa~O!^2wO~P'_Oa%nO#`3QO'z%nO~Oa%nO!g#vO#`3QO'z%nO~Oa%nO!g#vO!p3UO#`3QO'z%nO(r'pO~Oa%nO'z%nO~P!:tO!]$_Ov$qa~O!Y'Wi!]'Wi~P!:tO!](VO!Y(hi~O!](^O!Y(vi~O!Y(wi!](wi~P!:tO!](ti!k(tia(ti'z(ti~P!:tO#`3WO!](ti!k(tia(ti'z(ti~O!](jO!k(si~O!S%hO!_%iO!|]O#i3]O#j3[O(T%gO~O!S%hO!_%iO#j3[O(T%gO~On3dO!_'`O%i3cO~Oh%VOn3dO!_'`O%i3cO~O#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aav%aa!_%aa%i%aa!g%aa~P#L{O#k%caP%caR%ca[%caa%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%cav%ca!_%ca%i%ca!g%ca~P#MnO#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!]%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aa#`%aav%aa!_%aa%i%aa!g%aa~P#/sO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!]%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%ca#`%cav%ca!_%ca%i%ca!g%ca~P#/sO#k}aP}a[}aa}aj}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a'z}a(a}a(r}a!k}a!Y}a'w}av}a!_}a%i}a!g}a~P$(cO#k$saP$saR$sa[$saa$saj$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa'z$sa(a$sa(r$sa!k$sa!Y$sa'w$sav$sa!_$sa%i$sa!g$sa~P$)_O#k$uaP$uaR$ua[$uaa$uaj$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua'z$ua(a$ua(r$ua!k$ua!Y$ua'w$uav$ua!_$ua%i$ua!g$ua~P$*QO#k%TaP%TaR%Ta[%Taa%Taj%Tar%Ta!S%Ta!]%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta'z%Ta(a%Ta(r%Ta!k%Ta!Y%Ta'w%Ta#`%Tav%Ta!_%Ta%i%Ta!g%Ta~P#/sOa#cq!]#cq'z#cq'w#cq!Y#cq!k#cqv#cq!_#cq%i#cq!g#cq~P!:tO![3lO!]'YX!k'YX~P%[O!].tO!k(ka~O!].tO!k(ka~P!:tO!Y3oO~O$O!na!^!na~PKlO$O!ja!]!ja!^!ja~P#BwO$O!ra!^!ra~P!=[O$O!ta!^!ta~P!?rOg']X!]']X~P!,TO!]/POg(pa~OSfO!_4TO$d4UO~O!^4YO~Ov4ZO~P#/sOa$mq!]$mq'z$mq'w$mq!Y$mq!k$mqv$mq!_$mq%i$mq!g$mq~P!:tO!Y4]O~P!&zO!S4^O~O!Q*OO'y*PO(z%POn'ia(y'ia!]'ia#`'ia~Og'ia$O'ia~P%-fO!Q*OO'y*POn'ka(y'ka(z'ka!]'ka#`'ka~Og'ka$O'ka~P%.XO(r$YO~P#/sO!YfX!Y$zX!]fX!]$zX!g%RX#`fX~P!0SOp%WO(T=WO~P!1uOp4bO!S%hO![4aO!_%iO(T%gO!]'eX!k'eX~O!]/pO!k)Oa~O!]/pO!g#vO!k)Oa~O!]/pO!g#vO(r'pO!k)Oa~Og$|i!]$|i#`$|i$O$|i~P!1WO![4jO!Y'gX!]'gX~P!3tO!]/yO!Y)Pa~O!]/yO!Y)Pa~P#/sOP]XR]X[]Xj]Xr]X!Q]X!S]X!Y]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~Oj%YX!g%YX~P%2OOj4oO!g#vO~Oh%VO!g#vO!l%eO~Oh%VOr4tO!l%eO(r'pO~Or4yO!g#vO(r'pO~Os!nO!S4zO(VTO(YUO(e!mO~O(y$}On%ai!Q%ai'y%ai(z%ai!]%ai#`%ai~Og%ai$O%ai~P%5oO(z%POn%ci!Q%ci'y%ci(y%ci!]%ci#`%ci~Og%ci$O%ci~P%6bOg(_i!](_i~P!1WO#`5QOg(_i!](_i~P!1WO!k5VO~Oa$oq!]$oq'z$oq'w$oq!Y$oq!k$oqv$oq!_$oq%i$oq!g$oq~P!:tO!Y5ZO~O!]5[O!_)QX~P#/sOa$zX!_$zX%^]X'z$zX!]$zX~P!0SO%^5_OaoX!_oX'zoX!]oX~P$#OOp5`O(T#nO~O%^5_O~Ob5fO%j5gO(T+qO(VTO(YUO!]'tX!^'tX~O!]1TO!^)Xa~O[5kO~O`5lO~O[5pO~Oa%nO'z%nO~P#/sO!]5uO#`5wO!^)UX~O!^5xO~Or6OOs!nO!S*iO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!pO#W!pO#X!pO#[5}O#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O!^5|O~P%;eOn6TO!_1oO%i6SO~Oh%VOn6TO!_1oO%i6SO~Ob6[O(T#nO(VTO(YUO!]'sX!^'sX~O!]1zO!^)Va~O(VTO(YUO(e6^O~O`6bO~Oj6eO&[6fO~PNXO!k6gO~P%[Oa6iO~Oa6iO~P%[Ob2bO!^6nO&j2aO~P`O!g6pO~O!g6rOh(ji!](ji!^(ji!g(ji!l(jir(ji(r(ji~O!]#hi!^#hi~P#BwO#`6sO!]#hi!^#hi~O!]!ai!^!ai~P#BwOa%nO#`6|O'z%nO~Oa%nO!g#vO#`6|O'z%nO~O!](tq!k(tqa(tq'z(tq~P!:tO!](jO!k(sq~O!S%hO!_%iO#j7TO(T%gO~O!_'`O%i7WO~On7[O!_'`O%i7WO~O#k'iaP'iaR'ia['iaa'iaj'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia'z'ia(a'ia(r'ia!k'ia!Y'ia'w'iav'ia!_'ia%i'ia!g'ia~P%-fO#k'kaP'kaR'ka['kaa'kaj'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka'z'ka(a'ka(r'ka!k'ka!Y'ka'w'kav'ka!_'ka%i'ka!g'ka~P%.XO#k$|iP$|iR$|i[$|ia$|ij$|ir$|i!S$|i!]$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i'z$|i(a$|i(r$|i!k$|i!Y$|i'w$|i#`$|iv$|i!_$|i%i$|i!g$|i~P#/sO#k%aiP%aiR%ai[%aia%aij%air%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai'z%ai(a%ai(r%ai!k%ai!Y%ai'w%aiv%ai!_%ai%i%ai!g%ai~P%5oO#k%ciP%ciR%ci[%cia%cij%cir%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci'z%ci(a%ci(r%ci!k%ci!Y%ci'w%civ%ci!_%ci%i%ci!g%ci~P%6bO!]'Ya!k'Ya~P!:tO!].tO!k(ki~O$O#ci!]#ci!^#ci~P#BwOP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mij#mir#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#n#mi~P%NdO#n<_O~P%NdOP$[OR#zOr<kO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO[#mij#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#r#mi~P&!lO#r<aO~P&!lOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO(aVO#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#v#mi~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO(aVO(z#}O#z#mi#{#mi$O#mi(r#mi(y#mi!]#mi!^#mi~O#x<eO~P&&uO#x#mi~P&&uO#v<cO~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO(aVO(y#|O(z#}O#{#mi$O#mi(r#mi!]#mi!^#mi~O#z#mi~P&)UO#z<gO~P&)UOa#|y!]#|y'z#|y'w#|y!Y#|y!k#|yv#|y!_#|y%i#|y!g#|y~P!:tO[#mij#mir#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi!]#mi!^#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO(y#mi(z#mi~P&,QOn>^O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P&,QO#S$dOP(`XR(`X[(`Xj(`Xn(`Xr(`X!Q(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X$O(`X'y(`X(a(`X(r(`X(y(`X(z(`X!](`X!^(`X~O$O$Pi!]$Pi!^$Pi~P#BwO$O!ri!^!ri~P$+oOg']a!]']a~P!1WO!^7nO~O!]'da!^'da~P#BwO!Y7oO~P#/sO!g#vO(r'pO!]'ea!k'ea~O!]/pO!k)Oi~O!]/pO!g#vO!k)Oi~Og$|q!]$|q#`$|q$O$|q~P!1WO!Y'ga!]'ga~P#/sO!g7vO~O!]/yO!Y)Pi~P#/sO!]/yO!Y)Pi~O!Y7yO~Oh%VOr8OO!l%eO(r'pO~Oj8QO!g#vO~Or8TO!g#vO(r'pO~O!Q*OO'y*PO(z%POn'ja(y'ja!]'ja#`'ja~Og'ja$O'ja~P&5RO!Q*OO'y*POn'la(y'la(z'la!]'la#`'la~Og'la$O'la~P&5tOg(_q!](_q~P!1WO#`8VOg(_q!](_q~P!1WO!Y8WO~Og%Oq!]%Oq#`%Oq$O%Oq~P!1WOa$oy!]$oy'z$oy'w$oy!Y$oy!k$oyv$oy!_$oy%i$oy!g$oy~P!:tO!g6rO~O!]5[O!_)Qa~O!_'`OP$TaR$Ta[$Taj$Tar$Ta!Q$Ta!S$Ta!]$Ta!l$Ta!p$Ta#R$Ta#n$Ta#o$Ta#p$Ta#q$Ta#r$Ta#s$Ta#t$Ta#u$Ta#v$Ta#x$Ta#z$Ta#{$Ta(a$Ta(r$Ta(y$Ta(z$Ta~O%i7WO~P&8fO%^8[Oa%[i!_%[i'z%[i!]%[i~Oa#cy!]#cy'z#cy'w#cy!Y#cy!k#cyv#cy!_#cy%i#cy!g#cy~P!:tO[8^O~Ob8`O(T+qO(VTO(YUO~O!]1TO!^)Xi~O`8dO~O(e(|O!]'pX!^'pX~O!]5uO!^)Ua~O!^8nO~P%;eO(o!sO~P$&YO#[8oO~O!_1oO~O!_1oO%i8qO~On8tO!_1oO%i8qO~O[8yO!]'sa!^'sa~O!]1zO!^)Vi~O!k8}O~O!k9OO~O!k9RO~O!k9RO~P%[Oa9TO~O!g9UO~O!k9VO~O!](wi!^(wi~P#BwOa%nO#`9_O'z%nO~O!](ty!k(tya(ty'z(ty~P!:tO!](jO!k(sy~O%i9bO~P&8fO!_'`O%i9bO~O#k$|qP$|qR$|q[$|qa$|qj$|qr$|q!S$|q!]$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q'z$|q(a$|q(r$|q!k$|q!Y$|q'w$|q#`$|qv$|q!_$|q%i$|q!g$|q~P#/sO#k'jaP'jaR'ja['jaa'jaj'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja'z'ja(a'ja(r'ja!k'ja!Y'ja'w'jav'ja!_'ja%i'ja!g'ja~P&5RO#k'laP'laR'la['laa'laj'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la'z'la(a'la(r'la!k'la!Y'la'w'lav'la!_'la%i'la!g'la~P&5tO#k%OqP%OqR%Oq[%Oqa%Oqj%Oqr%Oq!S%Oq!]%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq'z%Oq(a%Oq(r%Oq!k%Oq!Y%Oq'w%Oq#`%Oqv%Oq!_%Oq%i%Oq!g%Oq~P#/sO!]'Yi!k'Yi~P!:tO$O#cq!]#cq!^#cq~P#BwO(y$}OP%aaR%aa[%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa$O%aa(a%aa(r%aa!]%aa!^%aa~On%aa!Q%aa'y%aa(z%aa~P&IyO(z%POP%caR%ca[%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca$O%ca(a%ca(r%ca!]%ca!^%ca~On%ca!Q%ca'y%ca(y%ca~P&LQOn>^O!Q*OO'y*PO(z%PO~P&IyOn>^O!Q*OO'y*PO(y$}O~P&LQOR0kO!Q0kO!S0lO#S$dOP}a[}aj}an}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a$O}a'y}a(a}a(r}a(y}a(z}a!]}a!^}a~O!Q*OO'y*POP$saR$sa[$saj$san$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa$O$sa(a$sa(r$sa(y$sa(z$sa!]$sa!^$sa~O!Q*OO'y*POP$uaR$ua[$uaj$uan$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua$O$ua(a$ua(r$ua(y$ua(z$ua!]$ua!^$ua~On>^O!Q*OO'y*PO(y$}O(z%PO~OP%TaR%Ta[%Taj%Tar%Ta!S%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta$O%Ta(a%Ta(r%Ta!]%Ta!^%Ta~P''VO$O$mq!]$mq!^$mq~P#BwO$O$oq!]$oq!^$oq~P#BwO!^9oO~O$O9pO~P!1WO!g#vO!]'ei!k'ei~O!g#vO(r'pO!]'ei!k'ei~O!]/pO!k)Oq~O!Y'gi!]'gi~P#/sO!]/yO!Y)Pq~Or9wO!g#vO(r'pO~O[9yO!Y9xO~P#/sO!Y9xO~Oj:PO!g#vO~Og(_y!](_y~P!1WO!]'na!_'na~P#/sOa%[q!_%[q'z%[q!]%[q~P#/sO[:UO~O!]1TO!^)Xq~O`:YO~O#`:ZO!]'pa!^'pa~O!]5uO!^)Ui~P#BwO!S:]O~O!_1oO%i:`O~O(VTO(YUO(e:eO~O!]1zO!^)Vq~O!k:hO~O!k:iO~O!k:jO~O!k:jO~P%[O#`:mO!]#hy!^#hy~O!]#hy!^#hy~P#BwO%i:rO~P&8fO!_'`O%i:rO~O$O#|y!]#|y!^#|y~P#BwOP$|iR$|i[$|ij$|ir$|i!S$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i$O$|i(a$|i(r$|i!]$|i!^$|i~P''VO!Q*OO'y*PO(z%POP'iaR'ia['iaj'ian'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia$O'ia(a'ia(r'ia(y'ia!]'ia!^'ia~O!Q*OO'y*POP'kaR'ka['kaj'kan'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka$O'ka(a'ka(r'ka(y'ka(z'ka!]'ka!^'ka~O(y$}OP%aiR%ai[%aij%ain%air%ai!Q%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai$O%ai'y%ai(a%ai(r%ai(z%ai!]%ai!^%ai~O(z%POP%ciR%ci[%cij%cin%cir%ci!Q%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci$O%ci'y%ci(a%ci(r%ci(y%ci!]%ci!^%ci~O$O$oy!]$oy!^$oy~P#BwO$O#cy!]#cy!^#cy~P#BwO!g#vO!]'eq!k'eq~O!]/pO!k)Oy~O!Y'gq!]'gq~P#/sOr:|O!g#vO(r'pO~O[;QO!Y;PO~P#/sO!Y;PO~Og(_!R!](_!R~P!1WOa%[y!_%[y'z%[y!]%[y~P#/sO!]1TO!^)Xy~O!]5uO!^)Uq~O(T;XO~O!_1oO%i;[O~O!k;_O~O%i;dO~P&8fOP$|qR$|q[$|qj$|qr$|q!S$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q$O$|q(a$|q(r$|q!]$|q!^$|q~P''VO!Q*OO'y*PO(z%POP'jaR'ja['jaj'jan'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja$O'ja(a'ja(r'ja(y'ja!]'ja!^'ja~O!Q*OO'y*POP'laR'la['laj'lan'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la$O'la(a'la(r'la(y'la(z'la!]'la!^'la~OP%OqR%Oq[%Oqj%Oqr%Oq!S%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq$O%Oq(a%Oq(r%Oq!]%Oq!^%Oq~P''VOg%e!Z!]%e!Z#`%e!Z$O%e!Z~P!1WO!Y;hO~P#/sOr;iO!g#vO(r'pO~O[;kO!Y;hO~P#/sO!]'pq!^'pq~P#BwO!]#h!Z!^#h!Z~P#BwO#k%e!ZP%e!ZR%e!Z[%e!Za%e!Zj%e!Zr%e!Z!S%e!Z!]%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z'z%e!Z(a%e!Z(r%e!Z!k%e!Z!Y%e!Z'w%e!Z#`%e!Zv%e!Z!_%e!Z%i%e!Z!g%e!Z~P#/sOr;tO!g#vO(r'pO~O!Y;uO~P#/sOr;|O!g#vO(r'pO~O!Y;}O~P#/sOP%e!ZR%e!Z[%e!Zj%e!Zr%e!Z!S%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z$O%e!Z(a%e!Z(r%e!Z!]%e!Z!^%e!Z~P''VOr<QO!g#vO(r'pO~Ov(fX~P1qO!Q%rO~P!)[O(U!lO~P!)[O!YfX!]fX#`fX~P%2OOP]XR]X[]Xj]Xr]X!Q]X!S]X!]]X!]fX!l]X!p]X#R]X#S]X#`]X#`fX#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~O!gfX!k]X!kfX(rfX~P'LTOP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_XO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]<iO!^$qa~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<tO!S${O!_$|O!i>WO!l$xO#j<zO$W%`O$t<vO$v<xO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Ol)dO~P(!yOr!eX(r!eX~P#!iOr(jX(r(jX~P##[O!^]X!^fX~P'LTO!YfX!Y$zX!]fX!]$zX#`fX~P!0SO#k<^O~O!g#vO#k<^O~O#`<nO~Oj<bO~O#`=OO!](wX!^(wX~O#`<nO!](uX!^(uX~O#k=PO~Og=RO~P!1WO#k=XO~O#k=YO~Og=RO(T&ZO~O!g#vO#k=ZO~O!g#vO#k=PO~O$O=[O~P#BwO#k=]O~O#k=^O~O#k=cO~O#k=dO~O#k=eO~O#k=fO~O$O=gO~P!1WO$O=hO~P!1WOl=sO~P7eOk#S#T#U#W#X#[#i#j#u$n$t$v$y%]%^%h%i%j%q%s%v%w%y%{~(OT#o!X'|(U#ps#n#qr!Q'}$]'}(T$_(e~",
  goto: "$9Y)]PPPPPP)^PP)aP)rP+W/]PPPP6mPP7TPP=QPPP@tPA^PA^PPPA^PCfPA^PA^PA^PCjPCoPD^PIWPPPI[PPPPI[L_PPPLeMVPI[PI[PP! eI[PPPI[PI[P!#lI[P!'S!(X!(bP!)U!)Y!)U!,gPPPPPPP!-W!(XPP!-h!/YP!2iI[I[!2n!5z!:h!:h!>gPPP!>oI[PPPPPPPPP!BOP!C]PPI[!DnPI[PI[I[I[I[I[PI[!FQP!I[P!LbP!Lf!Lp!Lt!LtP!IXP!Lx!LxP#!OP#!SI[PI[#!Y#%_CjA^PA^PA^A^P#&lA^A^#)OA^#+vA^#.SA^A^#.r#1W#1W#1]#1f#1W#1qPP#1WPA^#2ZA^#6YA^A^6mPPP#:_PPP#:x#:xP#:xP#;`#:xPP#;fP#;]P#;]#;y#;]#<e#<k#<n)aP#<q)aP#<z#<z#<zP)aP)aP)aP)aPP)aP#=Q#=TP#=T)aP#=XP#=[P)aP)aP)aP)aP)aP)a)aPP#=b#=h#=s#=y#>P#>V#>]#>k#>q#>{#?R#?]#?c#?s#?y#@k#@}#AT#AZ#Ai#BO#Cs#DR#DY#Et#FS#Gt#HS#HY#H`#Hf#Hp#Hv#H|#IW#Ij#IpPPPPPPPPPPP#IvPPPPPPP#Jk#Mx$ b$ i$ qPPP$']P$'f$*_$0x$0{$1O$1}$2Q$2X$2aP$2g$2jP$3W$3[$4S$5b$5g$5}PP$6S$6Y$6^$6a$6e$6i$7e$7|$8e$8i$8l$8o$8y$8|$9Q$9UR!|RoqOXst!Z#d%m&r&t&u&w,s,x2[2_Y!vQ'`-e1o5{Q%tvQ%|yQ&T|Q&j!VS'W!e-]Q'f!iS'l!r!yU*k$|*Z*oQ+o%}S+|&V&WQ,d&dQ-c'_Q-m'gQ-u'mQ0[*qQ1b,OQ1y,eR<{<Y%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_S#q]<V!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU+P%]<s<tQ+t&PQ,f&gQ,m&oQ0x+gQ0}+iQ1Y+uQ2R,kQ3`.gQ5`0|Q5f1TQ6[1zQ7Y3dQ8`5gR9e7['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S!S!nQ!r!v!y!z$|'W'_'`'l'm'n*k*o*q*r-]-c-e-u0[0_1o5{5}%[$ti#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q&X|Q'U!eS'[%i-`Q+t&PQ,P&WQ,f&gQ0n+SQ1Y+uQ1_+{Q2Q,jQ2R,kQ5f1TQ5o1aQ6[1zQ6_1|Q6`2PQ8`5gQ8c5lQ8|6bQ:X8dQ:f8yQ;V:YR<}*ZrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R,h&k&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'b'r(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>R>S[#]WZ#W#Z'X(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ%wxQ%{yW&Q|&V&W,OQ&_!TQ'c!hQ'e!iQ(q#sS+n%|%}Q+r&PQ,_&bQ,c&dS-l'f'gQ.i(rQ1R+oQ1X+uQ1Z+vQ1^+zQ1t,`S1x,d,eQ2|-mQ5e1TQ5i1WQ5n1`Q6Z1yQ8_5gQ8b5kQ8f5pQ:T8^R;T:U!U$zi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y!^%yy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{Q+h%wQ,T&[Q,W&]Q,b&dQ.h(qQ1s,_U1w,c,d,eQ3e.iQ6U1tS6Y1x1yQ8x6Z#f>T#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o>U<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hW%Ti%V*y>PS&[!Q&iQ&]!RQ&^!SU*}%[%d=sR,R&Y%]%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^T)z$u){V+P%]<s<tW'[!e%i*Z-`S(}#y#zQ+c%rQ+y&SS.b(m(nQ1j,XQ5T0kR8i5u'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S$i$^c#Y#e%q%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.|.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ'Y!eR2q-]!W!nQ!e!r!v!y!z$|'W'_'`'l'm'n*Z*k*o*q*r-]-c-e-u0[0_1o5{5}R1l,ZnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&y!^Q'v!xS(s#u<^Q+l%zQ,]&_Q,^&aQ-j'dQ-w'oS.r(x=PS0q+X=ZQ1P+mQ1n,[Q2c,zQ2e,{Q2m-WQ2z-kQ2}-oS5Y0r=eQ5a1QS5d1S=fQ6t2oQ6x2{Q6}3SQ8]5bQ9Y6vQ9Z6yQ9^7OR:l9V$d$]c#Y#e%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vS(o#p'iQ)P#zS+b%q.|S.c(n(pR3^.d'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS#q]<VQ&t!XQ&u!YQ&w![Q&x!]R2Z,vQ'a!hQ+e%wQ-h'cS.e(q+hQ2x-gW3b.h.i0w0yQ6w2yW7U3_3a3e5^U9a7V7X7ZU:q9c9d9fS;b:p:sQ;p;cR;x;qU!wQ'`-eT5y1o5{!Q_OXZ`st!V!Z#d#h%e%m&i&k&r&t&u&w(j,s,x.[2[2_]!pQ!r'`-e1o5{T#q]<V%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S(}#y#zS.b(m(n!s=l$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU$fd)_,mS(p#p'iU*v%R(w4OU0m+O.n7gQ5^0xQ7V3`Q9d7YR:s9em!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}Q't!uS(f#g2US-s'k'wQ/s*]Q0R*jQ3U-vQ4f/tQ4r0TQ4s0UQ4x0^Q7r4`S7}4t4vS8R4y4{Q9r7sQ9v7yQ9{8OQ:Q8TS:{9w9xS;g:|;PS;s;h;iS;{;t;uS<P;|;}R<S<QQ#wbQ's!uS(e#g2US(g#m+WQ+Y%fQ+j%xQ+p&OU-r'k't'wQ.W(fU/r*]*`/wQ0S*jQ0V*lQ1O+kQ1u,aS3R-s-vQ3Z.`S4e/s/tQ4n0PS4q0R0^Q4u0WQ6W1vQ7P3US7q4`4bQ7u4fU7|4r4x4{Q8P4wQ8v6XS9q7r7sQ9u7yQ9}8RQ:O8SQ:c8wQ:y9rS:z9v9xQ;S:QQ;^:dS;f:{;PS;r;g;hS;z;s;uS<O;{;}Q<R<PQ<T<SQ=o=jQ={=tR=|=uV!wQ'`-e%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S#wz!j!r=i$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=o>R%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Q%fj!^%xy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{S&Oz!jQ+k%yQ,a&dW1v,b,c,d,eU6X1w1x1yS8w6Y6ZQ:d8x!r=j$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ=t>QR=u>R%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Y#bWZ#W#Z(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ,n&o!p=k$Z$n)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=n'XU']!e%i*ZR2s-`%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ,m&oQ0x+gQ3`.gQ7Y3dR9e7[!b$Tc#Y%q(S(Y(t(y)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!P<d)^)q-Z.|2k2n3p3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!f$Vc#Y%q(S(Y(t(y)W)X)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!T<f)^)q-Z.|2k2n3p3v3w3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!^$Zc#Y%q(S(Y(t(y)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<WQ4_/kz>S)^)q-Z.|2k2n3p4P4X6u7b7k7l8k9X9g9m9n;W;`=vQ>X>ZR>Y>['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS$oh$pR4U/U'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$kf$qQ$ifS)j$l)nR)v$qT$jf$qT)l$l)n'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$oh$pQ$rhR)u$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_!s>Q$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S#glOPXZst!Z!`!o#S#d#o#{$n%m&k&n&o&r&t&u&w&{'T'b)O)s*i+]+g,p,s,x-i.g/V/n0]0l1r2S2T2V2X2[2_2a3d4T4z6T6e6f6i7[8t9T!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^Q+T%aQ/c*Oo4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!U$yi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>YQ*c$zU*l$|*Z*oQ+U%bQ0W*m#f=q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n=r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hQ=w>TQ=x>UQ=y>VR=z>W!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hnoOXst!Z#d%m&r&t&u&w,s,x2[2_S*f${*YQ-R'OQ-S'QR4i/y%[%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q,U&]Q1h,WQ5s1gR8h5tV*n$|*Z*oU*n$|*Z*oT5z1o5{S0P*i/nQ4w0]T8S4z:]Q+j%xQ0V*lQ1O+kQ1u,aQ6W1vQ8v6XQ:c8wR;^:d!U%Oi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Yx*R$v)e*S*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>OS0`*t0a#f<o#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<p<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!d=S(u)c*[*e.j.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[`=T3}7c7f7j9h:t:w;yS=_.l3iT=`7e9k!U%Qi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y|*T$v)e*U*t+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>OS0b*u0c#f<q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!h=U(u)c*[*e.k.l.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[d=V3}7d7e7j9h9i:t:u:w;yS=a.m3jT=b7f9lrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q&f!UR,p&ornOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R&f!UQ,Y&^R1d,RsnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q1p,_S6R1s1tU8p6P6Q6US:_8r8sS;Y:^:aQ;m;ZR;w;nQ&m!VR,i&iR6_1|R:f8yW&Q|&V&W,OR1Z+vQ&r!WR,s&sR,y&xT2],x2_R,}&yQ,|&yR2f,}Q'y!{R-y'ySsOtQ#dXT%ps#dQ#OTR'{#OQ#RUR'}#RQ){$uR/`){Q#UVR(Q#UQ#XWU(W#X(X.QQ(X#YR.Q(YQ-^'YR2r-^Q.u(yS3m.u3nR3n.vQ-e'`R2v-eY!rQ'`-e1o5{R'j!rQ/Q)eR4S/QU#_W%h*YU(_#_(`.RQ(`#`R.R(ZQ-a']R2t-at`OXst!V!Z#d%m&i&k&r&t&u&w,s,x2[2_S#hZ%eU#r`#h.[R.[(jQ(k#jQ.X(gW.a(k.X3X7RQ3X.YR7R3YQ)n$lR/W)nQ$phR)t$pQ$`cU)a$`-|<jQ-|<WR<j)qQ/q*]W4c/q4d7t9sU4d/r/s/tS7t4e4fR9s7u$e*Q$v(u)c)e*[*e*t*u+Q+R+V.l.m.o.p.q/_/g/i/k/v/|0d0e0v1e3f3g3h3}4R4[4g4h4l4|5O5R5S5W5r7]7^7_7`7e7f7h7i7j7p7w7z8U8X8Z9h9i9j9t9|:R:S:t:u:v:w:x:};R;e;j;v;y=p=}>O>Z>[Q/z*eU4k/z4m7xQ4m/|R7x4lS*o$|*ZR0Y*ox*S$v)e*t*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>O!d.j(u)c*[*e.l.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/h*S.j7ca7c3}7e7f7j9h:t:w;yQ0a*tQ3i.lU4}0a3i9kR9k7e|*U$v)e*t*u+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>O!h.k(u)c*[*e.l.m.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/j*U.k7de7d3}7e7f7j9h9i:t:u:w;yQ0c*uQ3j.mU5P0c3j9lR9l7fQ*z%UR0g*zQ5]0vR8Y5]Q+_%kR0u+_Q5v1jS8j5v:[R:[8kQ,[&_R1m,[Q5{1oR8m5{Q1{,fS6]1{8zR8z6_Q1U+rW5h1U5j8a:VQ5j1XQ8a5iR:V8bQ+w&QR1[+wQ2_,xR6m2_YrOXst#dQ&v!ZQ+a%mQ,r&rQ,t&tQ,u&uQ,w&wQ2Y,sS2],x2_R6l2[Q%opQ&z!_Q&}!aQ'P!bQ'R!cQ'q!uQ+`%lQ+l%zQ,Q&XQ,h&mQ-P&|W-p'k's't'wQ-w'oQ0X*nQ1P+mQ1c,PS2O,i,lQ2g-OQ2h-RQ2i-SQ2}-oW3P-r-s-v-xQ5a1QQ5m1_Q5q1eQ6V1uQ6a2QQ6k2ZU6z3O3R3UQ6}3SQ8]5bQ8e5oQ8g5rQ8l5zQ8u6WQ8{6`S9[6{7PQ9^7OQ:W8cQ:b8vQ:g8|Q:n9]Q;U:XQ;]:cQ;a:oQ;l;VR;o;^Q%zyQ'd!iQ'o!uU+m%{%|%}Q-W'VU-k'e'f'gS-o'k'uQ0Q*jS1Q+n+oQ2o-YS2{-l-mQ3S-tS4p0R0UQ5b1RQ6v2uQ6y2|Q7O3TU7{4r4s4vQ9z7}R;O9{S$wi>PR*{%VU%Ui%V>PR0f*yQ$viS(u#v+iS)c$b$cQ)e$dQ*[$xS*e${*YQ*t%OQ*u%QQ+Q%^Q+R%_Q+V%cQ.l<oQ.m<qQ.o<uQ.p<wQ.q<yQ/_)yQ/g*RQ/i*TQ/k*VQ/v*aS/|*g/mQ0d*wQ0e*xl0v+f,V.f1i1q3c6S7W8q9b:`:r;[;dQ1e,SQ3f=SQ3g=UQ3h=XS3}<l<mQ4R/PS4[/d4^Q4g/xQ4h/yQ4l/{Q4|0`Q5O0bQ5R0iQ5S0jQ5W0oQ5r1fQ7]=]Q7^=_Q7_=aQ7`=cQ7e<pQ7f<rQ7h<vQ7i<xQ7j<zQ7p4_Q7w4jQ7z4oQ8U5QQ8X5[Q8Z5_Q9h=YQ9i=TQ9j=VQ9t7vQ9|8QQ:R8VQ:S8[Q:t=^Q:u=`Q:v=bQ:w=dQ:x9pQ:}9yQ;R:PQ;e=gQ;j;QQ;v;kQ;y=hQ=p>PQ=}>XQ>O>YQ>Z>]R>[>^Q+O%]Q.n<sR7g<tnpOXst!Z#d%m&r&t&u&w,s,x2[2_Q!fPS#fZ#oQ&|!`W'h!o*i0]4zQ(P#SQ)Q#{Q)r$nS,l&k&nQ,q&oQ-O&{S-T'T/nQ-g'bQ.x)OQ/[)sQ0s+]Q0y+gQ2W,pQ2y-iQ3a.gQ4W/VQ5U0lQ6Q1rQ6c2SQ6d2TQ6h2VQ6j2XQ6o2aQ7Z3dQ7m4TQ8s6TQ9P6eQ9Q6fQ9S6iQ9f7[Q:a8tR:k9T#[cOPXZst!Z!`!o#d#o#{%m&k&n&o&r&t&u&w&{'T'b)O*i+]+g,p,s,x-i.g/n0]0l1r2S2T2V2X2[2_2a3d4z6T6e6f6i7[8t9TQ#YWQ#eYQ%quQ%svS%uw!gS(S#W(VQ(Y#ZQ(t#uQ(y#xQ)R$OQ)S$PQ)T$QQ)U$RQ)V$SQ)W$TQ)X$UQ)Y$VQ)Z$WQ)[$XQ)^$ZQ)`$_Q)b$aQ)g$eW)q$n)s/V4TQ+d%tQ+x&RS-Z'X2pQ-x'rS-}(T.PQ.S(]Q.U(dQ.s(xQ.v(zQ.z<UQ.|<XQ.}<YQ/O<]Q/b)}Q0p+XQ2k-UQ2n-XQ3O-qQ3V.VQ3k.tQ3p<^Q3q<_Q3r<`Q3s<aQ3t<bQ3u<cQ3v<dQ3w<eQ3x<fQ3y<gQ3z<hQ3{.{Q3|<kQ4P<nQ4Q<{Q4X<iQ5X0rQ5c1SQ6u=OQ6{3QQ7Q3WQ7a3lQ7b=PQ7k=RQ7l=ZQ8k5wQ9X6sQ9]6|Q9g=[Q9m=eQ9n=fQ:o9_Q;W:ZQ;`:mQ<W#SR=v>SR#[WR'Z!el!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}S'V!e-]U*j$|*Z*oS-Y'W'_S0U*k*qQ0^*rQ2u-cQ4v0[R4{0_R({#xQ!fQT-d'`-e]!qQ!r'`-e1o5{Q#p]R'i<VR)f$dY!uQ'`-e1o5{Q'k!rS'u!v!yS'w!z5}S-t'l'mQ-v'nR3T-uT#kZ%eS#jZ%eS%km,oU(g#h#i#lS.Y(h(iQ.^(jQ0t+^Q3Y.ZU3Z.[.]._S7S3[3]R9`7Td#^W#W#Z%h(T(^*Y+Z.T/mr#gZm#h#i#l%e(h(i(j+^.Z.[.]._3[3]7TS*]$x*bQ/t*^Q2U,oQ2l-VQ4`/pQ6q2dQ7s4aQ9W6rT=m'X+[V#aW%h*YU#`W%h*YS(U#W(^U(Z#Z+Z/mS-['X+[T.O(T.TV'^!e%i*ZQ$lfR)x$qT)m$l)nR4V/UT*_$x*bT*h${*YQ0w+fQ1g,VQ3_.fQ5t1iQ6P1qQ7X3cQ8r6SQ9c7WQ:^8qQ:p9bQ;Z:`Q;c:rQ;n;[R;q;dnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&l!VR,h&itmOXst!U!V!Z#d%m&i&r&t&u&w,s,x2[2_R,o&oT%lm,oR1k,XR,g&gQ&U|S+}&V&WR1^,OR+s&PT&p!W&sT&q!W&sT2^,x2_",
  nodeNames: "⚠ ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList in out const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration defer ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 380,
  context: WX,
  nodeProps: [
    ["isolate", -8, 5, 6, 14, 37, 39, 51, 53, 55, ""],
    ["group", -26, 9, 17, 19, 68, 207, 211, 215, 216, 218, 221, 224, 234, 237, 243, 245, 247, 249, 252, 258, 264, 266, 268, 270, 272, 274, 275, "Statement", -34, 13, 14, 32, 35, 36, 42, 51, 54, 55, 57, 62, 70, 72, 76, 80, 82, 84, 85, 110, 111, 120, 121, 136, 139, 141, 142, 143, 144, 145, 147, 148, 167, 169, 171, "Expression", -23, 31, 33, 37, 41, 43, 45, 173, 175, 177, 178, 180, 181, 182, 184, 185, 186, 188, 189, 190, 201, 203, 205, 206, "Type", -3, 88, 103, 109, "ClassItem"],
    ["openedBy", 23, "<", 38, "InterpolationStart", 56, "[", 60, "{", 73, "(", 160, "JSXStartCloseTag"],
    ["closedBy", -2, 24, 168, ">", 40, "InterpolationEnd", 50, "]", 61, "}", 74, ")", 165, "JSXEndTag"]
  ],
  propSources: [XX],
  skippedNodes: [0, 5, 6, 278],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$i&j(Wp(Z!b'|0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(X#S$i&j'}0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$i&j(Wp(Z!b'}0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$i&j!p),Q(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(V':f$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$i&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$d`$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$d``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$d`$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(Z!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$d`(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$i&j(Wp(Z!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$i&j(Wp(Z!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$i&j(Z!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$i&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(Z!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$i&j(WpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(WpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Wp(Z!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$i&j(o%1l(Wp(Z!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$i&j(Wp(Z!b$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$i&j(Wp(Z!b$]#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$i&j(Wp(Z!b#p(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$i&j$Q(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(z+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$i&j#z(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(Y';W$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$i&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$d`$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(WpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$d`(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$i&j(Wp(Z!b(U%&f#q(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$i&j(Wp(Z!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$i&j(Wp(Z!br+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!]+Jf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$i&j(Wp(Z!b!Q.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_![!L^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$i&j(Wp(Z!b#o(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$i&j(Z!b!X7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$i&j!X7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$i&j!X7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!X7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!X7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$i&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$i&j(Z!b!X7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(Z!b!X7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(Z!b!X7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(Z!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$i&j(Z!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$i&j(Wp!X7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$i&j(Wp!X7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Wp!X7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Wp!X7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(WpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$i&j(WpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$i&j(Wp(Z!b!X7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Wp(Z!b!X7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Wp(Z!b!X7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Wp(Z!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$i&j(Wp(Z!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$i&j(Wp(Z!b(O0/l!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$i&j(Wp(Z!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$i&j(Z!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$i&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(Z!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$i&j(WpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(WpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Wp(Z!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$i&j$Q(Ch(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Z#t$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!g$b$i&j$O)Lv(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#R-<U(Wp(Z!b$n7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$k&j(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#r(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$Q(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#s(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#`*!Y$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#k(Cl$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#s(Ch$f#|$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#s(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(r(Ct$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$i&j#{(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!|$Ip$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!S0,v$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$i&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$i&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$i&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$i&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$i&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!Y#)l$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#x(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$i&j(Wp(Z!b(a+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$i&j(Wp(Z!b(T,2j$_#t(e$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$i&j(Wp(Z!b$_#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!_#Hb(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(y+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!^(CdvBr$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!q7`$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$i&j(Wp(Z!b'|0/l$]#t(T,2j(e$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$i&j(Wp(Z!b'}0/l$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [DX, qX, ZX, FX, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, VX, new EO("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOx~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!U~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(c~~", 141, 340), new EO("j~RQYZXz{^~^O(Q~~aP!P!Qd~iO(R~~", 25, 323)],
  topRules: { Script: [0, 7], SingleExpression: [1, 276], SingleClassItem: [2, 277] },
  dialects: { jsx: 0, ts: 15175 },
  dynamicPrecedences: { 80: 1, 82: 1, 94: 1, 169: 1, 199: 1 },
  specialized: [{ term: 327, get: /* @__PURE__ */ f((n) => NX[n] || -1, "get") }, { term: 343, get: /* @__PURE__ */ f((n) => jX[n] || -1, "get") }, { term: 95, get: /* @__PURE__ */ f((n) => BX[n] || -1, "get") }],
  tokenPrec: 15201
}), GR = [
  /* @__PURE__ */ fi("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ fi("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fi("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fi("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fi("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fi(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ fi("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ fi(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ fi(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ fi('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ fi('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], HX = /* @__PURE__ */ GR.concat([
  /* @__PURE__ */ fi("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ fi("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ fi("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), zQ = /* @__PURE__ */ new hM(), KR = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function Wc(n) {
  return (t, e) => {
    let i = t.node.getChild("VariableDefinition");
    return i && e(i, n), !0;
  };
}
c(Wc, "ar");
f(Wc, "defID");
const YX = ["FunctionDeclaration"], GX = {
  FunctionDeclaration: /* @__PURE__ */ Wc("function"),
  ClassDeclaration: /* @__PURE__ */ Wc("class"),
  ClassExpression: /* @__PURE__ */ f(() => !0, "ClassExpression"),
  EnumDeclaration: /* @__PURE__ */ Wc("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ Wc("type"),
  NamespaceDeclaration: /* @__PURE__ */ Wc("namespace"),
  VariableDefinition(n, t) {
    n.matchContext(YX) || t(n, "variable");
  },
  TypeDefinition(n, t) {
    t(n, "type");
  },
  __proto__: null
};
function eP(n, t) {
  let e = zQ.get(t);
  if (e)
    return e;
  let i = [], s = !0;
  function r(a, o) {
    let l = n.sliceString(a.from, a.to);
    i.push({ label: l, type: o });
  }
  return c(r, "s"), f(r, "def"), t.cursor(Zt.IncludeAnonymous).iterate((a) => {
    if (s)
      s = !1;
    else if (a.name) {
      let o = GX[a.name];
      if (o && o(a, r) || KR.has(a.name))
        return !1;
    } else if (a.to - a.from > 8192) {
      for (let o of eP(n, a.node))
        i.push(o);
      return !1;
    }
  }), zQ.set(t, i), i;
}
c(eP, "xm$1");
f(eP, "getScope");
const IO = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, iP = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  "JSXText",
  "JSXAttributeValue",
  "JSXOpenTag",
  "JSXCloseTag",
  "JSXSelfClosingTag",
  ".",
  "?."
];
function JR(n) {
  let t = re(n.state).resolveInner(n.pos, -1);
  if (iP.indexOf(t.name) > -1)
    return null;
  let e = t.name == "VariableName" || t.to - t.from < 20 && IO.test(n.state.sliceDoc(t.from, t.to));
  if (!e && !n.explicit)
    return null;
  let i = [];
  for (let s = t; s; s = s.parent)
    KR.has(s.name) && (i = i.concat(eP(n.state.doc, s)));
  return {
    options: i,
    from: e ? t.from : n.pos,
    validFor: IO
  };
}
c(JR, "km$1");
f(JR, "localCompletionSource");
function Tv(n, t, e) {
  var i;
  let s = [];
  for (; ; ) {
    let r = t.firstChild, a;
    if (r?.name == "VariableName")
      return s.push(n(r)), { path: s.reverse(), name: e };
    if (r?.name == "MemberExpression" && ((i = a = r.lastChild) === null || i === void 0 ? void 0 : i.name) == "PropertyName")
      s.push(n(a)), t = r;
    else
      return null;
  }
}
c(Tv, "Ko$1");
f(Tv, "pathFor");
function tE(n) {
  let t = /* @__PURE__ */ f((i) => n.state.doc.sliceString(i.from, i.to), "read"), e = re(n.state).resolveInner(n.pos, -1);
  return e.name == "PropertyName" ? Tv(t, e.parent, t(e)) : (e.name == "." || e.name == "?.") && e.parent.name == "MemberExpression" ? Tv(t, e.parent, "") : iP.indexOf(e.name) > -1 ? null : e.name == "VariableName" || e.to - e.from < 20 && IO.test(t(e)) ? { path: [], name: t(e) } : e.name == "MemberExpression" ? Tv(t, e, "") : n.explicit ? { path: [], name: "" } : null;
}
c(tE, "Pm$1");
f(tE, "completionPath");
function eE(n, t) {
  let e = [], i = /* @__PURE__ */ new Set();
  for (let s = 0; ; s++) {
    for (let a of (Object.getOwnPropertyNames || Object.keys)(n)) {
      if (!/^[a-zA-Z_$\xaa-\uffdc][\w$\xaa-\uffdc]*$/.test(a) || i.has(a))
        continue;
      i.add(a);
      let o;
      try {
        o = n[a];
      } catch {
        continue;
      }
      e.push({
        label: a,
        type: typeof o == "function" ? /^[A-Z]/.test(a) ? "class" : t ? "function" : "method" : t ? "variable" : "property",
        boost: -s
      });
    }
    let r = Object.getPrototypeOf(n);
    if (!r)
      return e;
    n = r;
  }
}
c(eE, "wb$1");
f(eE, "enumeratePropertyCompletions");
function KX(n) {
  let t = /* @__PURE__ */ new Map();
  return (e) => {
    let i = tE(e);
    if (!i)
      return null;
    let s = n;
    for (let a of i.path)
      if (s = s[a], !s)
        return null;
    let r = t.get(s);
    return r || t.set(s, r = eE(s, !i.path.length)), {
      from: e.pos - i.name.length,
      options: r,
      validFor: IO
    };
  };
}
c(KX, "xb$1");
f(KX, "scopeCompletionSource");
const Pn = /* @__PURE__ */ vC.define({
  name: "javascript",
  parser: /* @__PURE__ */ UX.configure({
    props: [
      /* @__PURE__ */ km.add({
        IfStatement: /* @__PURE__ */ lw({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ lw({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: Iq,
        SwitchBody: /* @__PURE__ */ f((n) => {
          let t = n.textAfter, e = /^\s*\}/.test(t), i = /^\s*(case|default)\b/.test(t);
          return n.baseIndent + (e ? 0 : i ? 1 : 2) * n.unit;
        }, "SwitchBody"),
        Block: /* @__PURE__ */ BM({ closing: "}" }),
        ArrowFunction: /* @__PURE__ */ f((n) => n.baseIndent + n.unit, "ArrowFunction"),
        "TemplateString BlockComment": /* @__PURE__ */ f(() => null, "TemplateString BlockComment"),
        "Statement Property": /* @__PURE__ */ lw({ except: /^\s*{/ }),
        JSXElement(n) {
          let t = /^\s*<\//.test(n.textAfter);
          return n.lineIndent(n.node.from) + (t ? 0 : n.unit);
        },
        JSXEscape(n) {
          let t = /\s*\}/.test(n.textAfter);
          return n.lineIndent(n.node.from) + (t ? 0 : n.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(n) {
          return n.column(n.node.from) + n.unit;
        }
      }),
      /* @__PURE__ */ h1.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": xC,
        BlockComment(n) {
          return { from: n.from + 2, to: n.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), iE = {
  test: /* @__PURE__ */ f((n) => /^JSX/.test(n.name), "test"),
  facet: /* @__PURE__ */ c1({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, nE = /* @__PURE__ */ Pn.configure({ dialect: "ts" }, "typescript"), sE = /* @__PURE__ */ Pn.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ wC.add((n) => n.isTop ? [iE] : void 0)]
}), rE = /* @__PURE__ */ Pn.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ wC.add((n) => n.isTop ? [iE] : void 0)]
}, "typescript");
let aE = /* @__PURE__ */ f((n) => ({ label: n, type: "keyword" }), "kwCompletion");
const oE = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(aE), JX = /* @__PURE__ */ oE.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(aE));
function lE(n = {}) {
  let t = n.jsx ? n.typescript ? rE : sE : n.typescript ? nE : Pn, e = n.typescript ? HX.concat(JX) : GR.concat(oE);
  return new em(t, [
    Pn.data.of({
      autocomplete: pA(iP, TC(e))
    }),
    Pn.data.of({
      autocomplete: JR
    }),
    n.jsx ? eN : []
  ]);
}
c(lE, "Tm$1");
f(lE, "javascript");
function cE(n) {
  for (; ; ) {
    if (n.name == "JSXOpenTag" || n.name == "JSXSelfClosingTag" || n.name == "JSXFragmentTag")
      return n;
    if (n.name == "JSXEscape" || !n.parent)
      return null;
    n = n.parent;
  }
}
c(cE, "Pb$1");
f(cE, "findOpenTag");
function _5(n, t, e = n.length) {
  for (let i = t?.firstChild; i; i = i.nextSibling)
    if (i.name == "JSXIdentifier" || i.name == "JSXBuiltin" || i.name == "JSXNamespacedName" || i.name == "JSXMemberExpression")
      return n.sliceString(i.from, Math.min(i.to, e));
  return "";
}
c(_5, "YO");
f(_5, "elementName$1");
const tN = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), eN = /* @__PURE__ */ kt.inputHandler.of((n, t, e, i, s) => {
  if ((tN ? n.composing : n.compositionStarted) || n.state.readOnly || t != e || i != ">" && i != "/" || !Pn.isActiveAt(n.state, t, -1))
    return !1;
  let r = s(), { state: a } = r, o = a.changeByRange((l) => {
    var h;
    let { head: u } = l, p = re(a).resolveInner(u - 1, -1), y;
    if (p.name == "JSXStartTag" && (p = p.parent), !(a.doc.sliceString(u - 1, u) != i || p.name == "JSXAttributeValue" && p.to > u)) {
      if (i == ">" && p.name == "JSXFragmentTag")
        return { range: l, changes: { from: u, insert: "</>" } };
      if (i == "/" && p.name == "JSXStartCloseTag") {
        let m = p.parent, g = m.parent;
        if (g && m.from == u - 2 && ((y = _5(a.doc, g.firstChild, u)) || ((h = g.firstChild) === null || h === void 0 ? void 0 : h.name) == "JSXFragmentTag")) {
          let b = `${y}>`;
          return { range: it.cursor(u + b.length, -1), changes: { from: u, insert: b } };
        }
      } else if (i == ">") {
        let m = cE(p);
        if (m && m.name == "JSXOpenTag" && !/^\/?>|^<\//.test(a.doc.sliceString(u, u + 2)) && (y = _5(a.doc, m, u)))
          return { range: l, changes: { from: u, insert: `</${y}>` } };
      }
    }
    return { range: l };
  });
  return o.changes.empty ? !1 : (n.dispatch([
    r,
    a.update(o, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
});
function iN(n, t) {
  return t || (t = {
    parserOptions: { ecmaVersion: 2019, sourceType: "module" },
    env: { browser: !0, node: !0, es6: !0, es2015: !0, es2017: !0, es2020: !0 },
    rules: {}
  }, n.getRules().forEach((e, i) => {
    var s;
    !((s = e.meta.docs) === null || s === void 0) && s.recommended && (t.rules[i] = 2);
  })), (e) => {
    let { state: i } = e, s = [];
    for (let { from: r, to: a } of Pn.findRegions(i)) {
      let o = i.doc.lineAt(r), l = { line: o.number - 1, col: r - o.from, pos: r };
      for (let h of n.verify(i.sliceDoc(r, a), t))
        s.push(hE(h, i.doc, l));
    }
    return s;
  };
}
c(iN, "Rb$1");
f(iN, "esLint");
function z5(n, t, e, i) {
  return e.line(n + i.line).from + t + (n == 1 ? i.col - 1 : -1);
}
c(z5, "WO");
f(z5, "mapPos");
function hE(n, t, e) {
  let i = z5(n.line, n.column, t, e), s = {
    from: i,
    to: n.endLine != null && n.endColumn != 1 ? z5(n.endLine, n.endColumn, t, e) : i,
    message: n.message,
    source: n.ruleId ? "eslint:" + n.ruleId : "eslint",
    severity: n.severity == 1 ? "warning" : "error"
  };
  if (n.fix) {
    let { range: r, text: a } = n.fix, o = r[0] + e.pos - i, l = r[1] + e.pos - i;
    s.actions = [{
      name: "fix",
      apply(h, u) {
        h.dispatch({ changes: { from: u + o, to: u + l, insert: a }, scrollIntoView: !0 });
      }
    }];
  }
  return s;
}
c(hE, "vb$1");
f(hE, "translateDiagnostic");
const jm = ["_blank", "_self", "_top", "_parent"], x2 = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], k2 = ["get", "post", "put", "delete"], S2 = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], qi = ["true", "false"], ht = {}, nN = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: jm,
      hreflang: null
    }
  },
  abbr: ht,
  address: ht,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: ht,
  aside: ht,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: ht,
  base: { attrs: { href: null, target: jm } },
  bdi: ht,
  bdo: ht,
  blockquote: { attrs: { cite: null } },
  body: ht,
  br: ht,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: S2,
      formmethod: k2,
      formnovalidate: ["novalidate"],
      formtarget: jm,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: ht,
  center: ht,
  cite: ht,
  code: ht,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: ht,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: ht,
  div: ht,
  dl: ht,
  dt: ht,
  em: ht,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: ht,
  figure: ht,
  footer: ht,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": x2,
      autocomplete: ["on", "off"],
      enctype: S2,
      method: k2,
      novalidate: ["novalidate"],
      target: jm
    }
  },
  h1: ht,
  h2: ht,
  h3: ht,
  h4: ht,
  h5: ht,
  h6: ht,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: ht,
  hgroup: ht,
  hr: ht,
  html: {
    attrs: { manifest: null }
  },
  i: ht,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: S2,
      formmethod: k2,
      formnovalidate: ["novalidate"],
      formtarget: jm,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: ht,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: ht,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: ht,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: x2,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: ht,
  noscript: ht,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: ht,
  param: { attrs: { name: null, value: null } },
  pre: ht,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: ht,
  rt: ht,
  ruby: ht,
  samp: ht,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: x2
    }
  },
  section: ht,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: ht,
  source: { attrs: { src: null, type: null, media: null } },
  span: ht,
  strong: ht,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: ht,
  summary: ht,
  sup: ht,
  table: ht,
  tbody: ht,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: ht,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: ht,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: ht,
  time: { attrs: { datetime: null } },
  title: ht,
  tr: ht,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: ht,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: ht
}, dE = {
  accesskey: null,
  class: null,
  contenteditable: qi,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: qi,
  autocorrect: qi,
  autocapitalize: qi,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": qi,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": qi,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": qi,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": qi,
  "aria-hidden": qi,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": qi,
  "aria-multiselectable": qi,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": qi,
  "aria-relevant": null,
  "aria-required": qi,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, uE = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((n) => "on" + n);
for (let n of uE)
  dE[n] = null;
var Tu;
const pE = (Tu = class {
  constructor(t, e) {
    this.tags = { ...nN, ...t }, this.globalAttrs = { ...dE, ...e }, this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}, c(Tu, "Nc"), Tu);
f(pE, "Schema");
let Mw = pE;
Mw.default = /* @__PURE__ */ new Mw();
function tl(n, t, e = n.length) {
  if (!t)
    return "";
  let i = t.firstChild, s = i && i.getChild("TagName");
  return s ? n.sliceString(s.from, Math.min(s.to, e)) : "";
}
c(tl, "Ki$1");
f(tl, "elementName");
function el(n, t = !1) {
  for (; n; n = n.parent)
    if (n.name == "Element")
      if (t)
        t = !1;
      else
        return n;
  return null;
}
c(el, "Ji$1");
f(el, "findParentElement");
function nP(n, t, e) {
  return e.tags[tl(n, el(t))]?.children || e.allTags;
}
c(nP, "Mm$1");
f(nP, "allowedChildren");
function t0(n, t) {
  let e = [];
  for (let i = el(t); i && !i.type.isTop; i = el(i.parent)) {
    let s = tl(n, i);
    if (s && i.lastChild.name == "CloseTag")
      break;
    s && e.indexOf(s) < 0 && (t.name == "EndTag" || t.from >= i.firstChild.to) && e.push(s);
  }
  return e;
}
c(t0, "Ih$1");
f(t0, "openTags");
const fE = /^[:\-\.\w\u00b7-\uffff]*$/;
function L5(n, t, e, i, s) {
  let r = /\s*>/.test(n.sliceDoc(s, s + 5)) ? "" : ">", a = el(e, e.name == "StartTag" || e.name == "TagName");
  return {
    from: i,
    to: s,
    options: nP(n.doc, a, t).map((o) => ({ label: o, type: "type" })).concat(t0(n.doc, e).map((o, l) => ({
      label: "/" + o,
      apply: "/" + o + r,
      type: "type",
      boost: 99 - l
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
c(L5, "VO");
f(L5, "completeTag");
function I5(n, t, e, i) {
  let s = /\s*>/.test(n.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: e,
    to: i,
    options: t0(n.doc, t).map((r, a) => ({ label: r, apply: r + s, type: "type", boost: 99 - a })),
    validFor: fE
  };
}
c(I5, "UO");
f(I5, "completeCloseTag");
function yE(n, t, e, i) {
  let s = [], r = 0;
  for (let a of nP(n.doc, e, t))
    s.push({ label: "<" + a, type: "type" });
  for (let a of t0(n.doc, e))
    s.push({ label: "</" + a + ">", type: "type", boost: 99 - r++ });
  return { from: i, to: i, options: s, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
c(yE, "Ab$1");
f(yE, "completeStartTag");
function mE(n, t, e, i, s) {
  let r = el(e), a = r ? t.tags[tl(n.doc, r)] : null, o = a && a.attrs ? Object.keys(a.attrs) : [], l = a && a.globalAttrs === !1 ? o : o.length ? o.concat(t.globalAttrNames) : t.globalAttrNames;
  return {
    from: i,
    to: s,
    options: l.map((h) => ({ label: h, type: "property" })),
    validFor: fE
  };
}
c(mE, "Lb$1");
f(mE, "completeAttrName");
function gE(n, t, e, i, s) {
  var r;
  let a = (r = e.parent) === null || r === void 0 ? void 0 : r.getChild("AttributeName"), o = [], l;
  if (a) {
    let h = n.sliceDoc(a.from, a.to), u = t.globalAttrs[h];
    if (!u) {
      let p = el(e), y = p ? t.tags[tl(n.doc, p)] : null;
      u = y?.attrs && y.attrs[h];
    }
    if (u) {
      let p = n.sliceDoc(i, s).toLowerCase(), y = '"', m = '"';
      /^['"]/.test(p) ? (l = p[0] == '"' ? /^[^"]*$/ : /^[^']*$/, y = "", m = n.sliceDoc(s, s + 1) == p[0] ? "" : p[0], p = p.slice(1), i++) : l = /^[^\s<>='"]*$/;
      for (let g of u)
        o.push({ label: g, apply: y + g + m, type: "constant" });
    }
  }
  return { from: i, to: s, options: o, validFor: l };
}
c(gE, "_b$1");
f(gE, "completeAttrValue");
function sP(n, t) {
  let { state: e, pos: i } = t, s = re(e).resolveInner(i, -1), r = s.resolve(i);
  for (let a = i, o; r == s && (o = s.childBefore(a)); ) {
    let l = o.lastChild;
    if (!l || !l.type.isError || l.from < l.to)
      break;
    r = s = o, a = l.from;
  }
  return s.name == "TagName" ? s.parent && /CloseTag$/.test(s.parent.name) ? I5(e, s, s.from, i) : L5(e, n, s, s.from, i) : s.name == "StartTag" || s.name == "IncompleteTag" ? L5(e, n, s, i, i) : s.name == "StartCloseTag" || s.name == "IncompleteCloseTag" ? I5(e, s, i, i) : s.name == "OpenTag" || s.name == "SelfClosingTag" || s.name == "AttributeName" ? mE(e, n, s, s.name == "AttributeName" ? s.from : i, i) : s.name == "Is" || s.name == "AttributeValue" || s.name == "UnquotedAttributeValue" ? gE(e, n, s, s.name == "Is" ? i : s.from, i) : t.explicit && (r.name == "Element" || r.name == "Text" || r.name == "Document") ? yE(e, n, s, i) : null;
}
c(sP, "Cm$1");
f(sP, "htmlCompletionFor");
function wE(n) {
  return sP(Mw.default, n);
}
c(wE, "Xm$1");
f(wE, "htmlCompletionSource");
function vE(n) {
  let { extraTags: t, extraGlobalAttributes: e } = n, i = e || t ? new Mw(t, e) : Mw.default;
  return (s) => sP(i, s);
}
c(vE, "Em$1");
f(vE, "htmlCompletionSourceWith");
const sN = /* @__PURE__ */ Pn.parser.configure({ top: "SingleExpression" }), OE = [
  {
    tag: "script",
    attrs: /* @__PURE__ */ f((n) => n.type == "text/typescript" || n.lang == "ts", "attrs"),
    parser: nE.parser
  },
  {
    tag: "script",
    attrs: /* @__PURE__ */ f((n) => n.type == "text/babel" || n.type == "text/jsx", "attrs"),
    parser: sE.parser
  },
  {
    tag: "script",
    attrs: /* @__PURE__ */ f((n) => n.type == "text/typescript-jsx", "attrs"),
    parser: rE.parser
  },
  {
    tag: "script",
    attrs(n) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(n.type);
    },
    parser: sN
  },
  {
    tag: "script",
    attrs(n) {
      return !n.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(n.type);
    },
    parser: Pn.parser
  },
  {
    tag: "style",
    attrs(n) {
      return (!n.lang || n.lang == "css") && (!n.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(n.type));
    },
    parser: LO.parser
  }
], bE = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ LO.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ uE.map((n) => ({ name: n, parser: Pn.parser }))), $E = /* @__PURE__ */ vC.define({
  name: "html",
  parser: /* @__PURE__ */ WF.configure({
    props: [
      /* @__PURE__ */ km.add({
        Element(n) {
          let t = /^(\s*)(<\/)?/.exec(n.textAfter);
          return n.node.to <= n.pos + t[0].length ? n.continue() : n.lineIndent(n.node.from) + (t[2] ? 0 : n.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(n) {
          return n.column(n.node.from) + n.unit;
        },
        Document(n) {
          if (n.pos + /\s*/.exec(n.textAfter)[0].length < n.node.to)
            return n.continue();
          let t = null, e;
          for (let i = n.node; ; ) {
            let s = i.lastChild;
            if (!s || s.name != "Element" || s.to != i.to)
              break;
            t = i = s;
          }
          return t && !((e = t.lastChild) && (e.name == "CloseTag" || e.name == "SelfClosingTag")) ? n.lineIndent(t.from) + n.unit : null;
        }
      }),
      /* @__PURE__ */ h1.add({
        Element(n) {
          let t = n.firstChild, e = n.lastChild;
          return !t || t.name != "OpenTag" ? null : { from: t.to, to: e.name == "CloseTag" ? e.from : n.to };
        }
      }),
      /* @__PURE__ */ KM.add({
        "OpenTag CloseTag": /* @__PURE__ */ f((n) => n.getChild("TagName"), "OpenTag CloseTag")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-_"
  }
}), Mv = /* @__PURE__ */ $E.configure({
  wrap: /* @__PURE__ */ JC(OE, bE)
});
function xE(n = {}) {
  let t = "", e;
  n.matchClosingTags === !1 && (t = "noMatch"), n.selfClosingTags === !0 && (t = (t ? t + " " : "") + "selfClosing"), (n.nestedLanguages && n.nestedLanguages.length || n.nestedAttributes && n.nestedAttributes.length) && (e = JC((n.nestedLanguages || []).concat(OE), (n.nestedAttributes || []).concat(bE)));
  let i = e ? $E.configure({ wrap: e, dialect: t }) : t ? Mv.configure({ dialect: t }) : Mv;
  return new em(i, [
    Mv.data.of({ autocomplete: vE(n) }),
    n.autoCloseTags !== !1 ? rN : [],
    lE().support,
    HR().support
  ]);
}
c(xE, "Um$1");
f(xE, "html");
const LQ = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), rN = /* @__PURE__ */ kt.inputHandler.of((n, t, e, i, s) => {
  if (n.composing || n.state.readOnly || t != e || i != ">" && i != "/" || !Mv.isActiveAt(n.state, t, -1))
    return !1;
  let r = s(), { state: a } = r, o = a.changeByRange((l) => {
    var h, u, p;
    let y = a.doc.sliceString(l.from - 1, l.to) == i, { head: m } = l, g = re(a).resolveInner(m, -1), b;
    if (y && i == ">" && g.name == "EndTag") {
      let S = g.parent;
      if (((u = (h = S.parent) === null || h === void 0 ? void 0 : h.lastChild) === null || u === void 0 ? void 0 : u.name) != "CloseTag" && (b = tl(a.doc, S.parent, m)) && !LQ.has(b)) {
        let x = m + (a.doc.sliceString(m, m + 1) === ">" ? 1 : 0), Q = `</${b}>`;
        return { range: l, changes: { from: m, to: x, insert: Q } };
      }
    } else if (y && i == "/" && g.name == "IncompleteCloseTag") {
      let S = g.parent;
      if (g.from == m - 2 && ((p = S.lastChild) === null || p === void 0 ? void 0 : p.name) != "CloseTag" && (b = tl(a.doc, S, m)) && !LQ.has(b)) {
        let x = m + (a.doc.sliceString(m, m + 1) === ">" ? 1 : 0), Q = `${b}>`;
        return {
          range: it.cursor(m + Q.length, -1),
          changes: { from: m, to: x, insert: Q }
        };
      }
    }
    return { range: l };
  });
  return o.changes.empty ? !1 : (n.dispatch([
    r,
    a.update(o, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), kE = /* @__PURE__ */ c1({ commentTokens: { block: { open: "<!--", close: "-->" } } }), SE = /* @__PURE__ */ new Pt(), CE = /* @__PURE__ */ IZ.configure({
  props: [
    /* @__PURE__ */ h1.add((n) => !n.is("Block") || n.is("Document") || WO(n) != null || PE(n) ? void 0 : (t, e) => ({ from: e.doc.lineAt(t.from).to, to: t.to })),
    /* @__PURE__ */ SE.add(WO),
    /* @__PURE__ */ km.add({
      Document: /* @__PURE__ */ f(() => null, "Document")
    }),
    /* @__PURE__ */ Qr.add({
      Document: kE
    })
  ]
});
function WO(n) {
  let t = /^(?:ATX|Setext)Heading(\d)$/.exec(n.name);
  return t ? +t[1] : void 0;
}
c(WO, "ih$1");
f(WO, "isHeading");
function PE(n) {
  return n.name == "OrderedList" || n.name == "BulletList";
}
c(PE, "Cb$1");
f(PE, "isList");
function QE(n, t) {
  let e = n;
  for (; ; ) {
    let i = e.nextSibling, s;
    if (!i || (s = WO(i.type)) != null && s <= t)
      break;
    e = i;
  }
  return e.to;
}
c(QE, "Xb$1");
f(QE, "findSectionEnd");
const aN = /* @__PURE__ */ Wq.of((n, t, e) => {
  for (let i = re(n).resolveInner(e, -1); i && !(i.from < t); i = i.parent) {
    let s = i.type.prop(SE);
    if (s == null)
      continue;
    let r = QE(i, s);
    if (r > e)
      return { from: e, to: r };
  }
  return null;
});
function e0(n) {
  return new Hi(kE, n, [], "markdown");
}
c(e0, "zh$1");
f(e0, "mkLang");
const oN = /* @__PURE__ */ e0(CE), lN = /* @__PURE__ */ CE.configure([NZ, BZ, jZ, UZ, {
  props: [
    /* @__PURE__ */ h1.add({
      Table: /* @__PURE__ */ f((n, t) => ({ from: t.doc.lineAt(n.from).to, to: n.to }), "Table")
    })
  ]
}]), VO = /* @__PURE__ */ e0(lN);
function TE(n, t) {
  return (e) => {
    if (e && n) {
      let i = null;
      if (e = /\S*/.exec(e)[0], typeof n == "function" ? i = n(e) : i = lQ.matchLanguageName(n, e, !0), i instanceof lQ)
        return i.support ? i.support.language.parser : CO.getSkippingParser(i.load());
      if (i)
        return i.parser;
    }
    return t ? t.parser : null;
  };
}
c(TE, "Wb$1");
f(TE, "getCodeParser");
var Mu;
const ME = (Mu = class {
  constructor(t, e, i, s, r, a, o) {
    this.node = t, this.from = e, this.to = i, this.spaceBefore = s, this.spaceAfter = r, this.type = a, this.item = o;
  }
  blank(t, e = !0) {
    let i = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
    if (t != null) {
      for (; i.length < t; )
        i += " ";
      return i;
    } else {
      for (let s = this.to - this.from - i.length - this.spaceAfter.length; s > 0; s--)
        i += " ";
      return i + (e ? this.spaceAfter : "");
    }
  }
  marker(t, e) {
    let i = this.node.name == "OrderedList" ? String(+aP(this.item, t)[2] + e) : "";
    return this.spaceBefore + i + this.type + this.spaceAfter;
  }
}, c(Mu, "Gc"), Mu);
f(ME, "Context");
let C2 = ME;
function rP(n, t) {
  let e = [], i = [];
  for (let s = n; s; s = s.parent) {
    if (s.name == "FencedCode")
      return i;
    (s.name == "ListItem" || s.name == "Blockquote") && e.push(s);
  }
  for (let s = e.length - 1; s >= 0; s--) {
    let r = e[s], a, o = t.lineAt(r.from), l = r.from - o.from;
    if (r.name == "Blockquote" && (a = /^ *>( ?)/.exec(o.text.slice(l))))
      i.push(new C2(r, l, l + a[0].length, "", a[1], ">", null));
    else if (r.name == "ListItem" && r.parent.name == "OrderedList" && (a = /^( *)\d+([.)])( *)/.exec(o.text.slice(l)))) {
      let h = a[3], u = a[0].length;
      h.length >= 4 && (h = h.slice(0, h.length - 4), u -= 4), i.push(new C2(r.parent, l, l + u, a[1], h, a[2], r));
    } else if (r.name == "ListItem" && r.parent.name == "BulletList" && (a = /^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(o.text.slice(l)))) {
      let h = a[4], u = a[0].length;
      h.length > 4 && (h = h.slice(0, h.length - 4), u -= 4);
      let p = a[2];
      a[3] && (p += a[3].replace(/[xX]/, " ")), i.push(new C2(r.parent, l, l + u, a[1], h, p, r));
    }
  }
  return i;
}
c(rP, "Dm$1");
f(rP, "getContext");
function aP(n, t) {
  return /^(\s*)(\d+)(?=[.)])/.exec(t.sliceString(n.from, n.from + 10));
}
c(aP, "Nm$1");
f(aP, "itemNumber");
function Av(n, t, e, i = 0) {
  for (let s = -1, r = n; ; ) {
    if (r.name == "ListItem") {
      let o = aP(r, t), l = +o[2];
      if (s >= 0) {
        if (l != s + 1)
          return;
        e.push({ from: r.from + o[1].length, to: r.from + o[0].length, insert: String(s + 2 + i) });
      }
      s = l;
    }
    let a = r.nextSibling;
    if (!a)
      break;
    r = a;
  }
}
c(Av, "il$1");
f(Av, "renumberList");
function i0(n, t) {
  let e = /^[ \t]*/.exec(n)[0].length;
  if (!e || t.facet(Xb) != "	")
    return n;
  let i = ea(n, 4, e), s = "";
  for (let r = i; r > 0; )
    r >= 4 ? (s += "	", r -= 4) : (s += " ", r--);
  return s + n.slice(e);
}
c(i0, "jh");
f(i0, "normalizeIndent");
const cN = /* @__PURE__ */ f((n = {}) => ({ state: t, dispatch: e }) => {
  let i = re(t), { doc: s } = t, r = null, a = t.changeByRange((o) => {
    if (!o.empty || !VO.isActiveAt(t, o.from, -1) && !VO.isActiveAt(t, o.from, 1))
      return r = { range: o };
    let l = o.from, h = s.lineAt(l), u = rP(i.resolveInner(l, -1), s);
    for (; u.length && u[u.length - 1].from > l - h.from; )
      u.pop();
    if (!u.length)
      return r = { range: o };
    let p = u[u.length - 1];
    if (p.to - p.spaceAfter.length > l - h.from)
      return r = { range: o };
    let y = l >= p.to - p.spaceAfter.length && !/\S/.test(h.text.slice(p.to));
    if (p.item && y) {
      let x = p.node.firstChild, Q = p.node.getChild("ListItem", "ListItem");
      if (x.to >= l || Q && Q.to < l || h.from > 0 && !/[^\s>]/.test(s.lineAt(h.from - 1).text) || n.nonTightLists === !1) {
        let L = u.length > 1 ? u[u.length - 2] : null, W, R = "";
        L && L.item ? (W = h.from + L.from, R = L.marker(s, 1)) : W = h.from + (L ? L.to : 0);
        let I = [{ from: W, to: l, insert: R }];
        return p.node.name == "OrderedList" && Av(p.item, s, I, -2), L && L.node.name == "OrderedList" && Av(L.item, s, I), { range: it.cursor(W + R.length), changes: I };
      } else {
        let L = V5(u, t, h);
        return {
          range: it.cursor(l + L.length + 1),
          changes: { from: h.from, insert: L + t.lineBreak }
        };
      }
    }
    if (p.node.name == "Blockquote" && y && h.from) {
      let x = s.lineAt(h.from - 1), Q = />\s*$/.exec(x.text);
      if (Q && Q.index == p.from) {
        let L = t.changes([
          { from: x.from + Q.index, to: x.to },
          { from: h.from + p.from, to: h.to }
        ]);
        return { range: o.map(L), changes: L };
      }
    }
    let m = [];
    p.node.name == "OrderedList" && Av(p.item, s, m);
    let g = p.item && p.item.from < h.from, b = "";
    if (!g || /^[\s\d.)\-+*>]*/.exec(h.text)[0].length >= p.to)
      for (let x = 0, Q = u.length - 1; x <= Q; x++)
        b += x == Q && !g ? u[x].marker(s, 1) : u[x].blank(x < Q ? ea(h.text, 4, u[x + 1].from) - b.length : null);
    let S = l;
    for (; S > h.from && /\s/.test(h.text.charAt(S - h.from - 1)); )
      S--;
    return b = i0(b, t), AE(p.node, t.doc) && (b = V5(u, t, h) + t.lineBreak + b), m.push({ from: S, to: l, insert: t.lineBreak + b }), { range: it.cursor(S + b.length + 1), changes: m };
  });
  return r ? !1 : (e(t.update(a, { scrollIntoView: !0, userEvent: "input" })), !0);
}, "insertNewlineContinueMarkupCommand"), hN = /* @__PURE__ */ cN();
function W5(n) {
  return n.name == "QuoteMark" || n.name == "ListMark";
}
c(W5, "zO");
f(W5, "isMark");
function AE(n, t) {
  if (n.name != "OrderedList" && n.name != "BulletList")
    return !1;
  let e = n.firstChild, i = n.getChild("ListItem", "ListItem");
  if (!i)
    return !1;
  let s = t.lineAt(e.to), r = t.lineAt(i.from), a = /^[\s>]*$/.test(s.text);
  return s.number + (a ? 0 : 1) < r.number;
}
c(AE, "Vb$1");
f(AE, "nonTightList");
function V5(n, t, e) {
  let i = "";
  for (let s = 0, r = n.length - 2; s <= r; s++)
    i += n[s].blank(s < r ? ea(e.text, 4, n[s + 1].from) - i.length : null, s < r);
  return i0(i, t);
}
c(V5, "jO");
f(V5, "blankLine");
function RE(n, t) {
  let e = n.resolveInner(t, -1), i = t;
  W5(e) && (i = e.from, e = e.parent);
  for (let s; s = e.childBefore(i); )
    if (W5(s))
      i = s.from;
    else if (s.name == "OrderedList" || s.name == "BulletList")
      e = s.lastChild, i = e.to;
    else
      break;
  return e;
}
c(RE, "Ub$1");
f(RE, "contextNodeForDelete");
const dN = /* @__PURE__ */ f(({ state: n, dispatch: t }) => {
  let e = re(n), i = null, s = n.changeByRange((r) => {
    let a = r.from, { doc: o } = n;
    if (r.empty && VO.isActiveAt(n, r.from)) {
      let l = o.lineAt(a), h = rP(RE(e, a), o);
      if (h.length) {
        let u = h[h.length - 1], p = u.to - u.spaceAfter.length + (u.spaceAfter ? 1 : 0);
        if (a - l.from > p && !/\S/.test(l.text.slice(p, a - l.from)))
          return {
            range: it.cursor(l.from + p),
            changes: { from: l.from + p, to: a }
          };
        if (a - l.from == p && // Only apply this if we're on the line that has the
        // construct's syntax, or there's only indentation in the
        // target range
        (!u.item || l.from <= u.item.from || !/\S/.test(l.text.slice(0, u.to)))) {
          let y = l.from + u.from;
          if (u.item && u.node.from < u.item.from && /\S/.test(l.text.slice(u.from, u.to))) {
            let m = u.blank(ea(l.text, 4, u.to) - ea(l.text, 4, u.from));
            return y == l.from && (m = i0(m, n)), {
              range: it.cursor(y + m.length),
              changes: { from: y, to: l.from + u.to, insert: m }
            };
          }
          if (y < a)
            return { range: it.cursor(y), changes: { from: y, to: a } };
        }
      }
    }
    return i = { range: r };
  });
  return i ? !1 : (t(n.update(s, { scrollIntoView: !0, userEvent: "delete" })), !0);
}, "deleteMarkupBackward"), uN = [
  { key: "Enter", run: hN },
  { key: "Backspace", run: dN }
], EE = /* @__PURE__ */ xE({ matchClosingTags: !1 });
function pN(n = {}) {
  let { codeLanguages: t, defaultCodeLanguage: e, addKeymap: i = !0, base: { parser: s } = oN, completeHTMLTags: r = !0, pasteURLAsLink: a = !0, htmlTagLanguage: o = EE } = n;
  if (!(s instanceof KA))
    throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let l = n.extensions ? [n.extensions] : [], h = [o.support, aN], u;
  a && h.push(yN), e instanceof em ? (h.push(e.support), u = e.language) : e && (u = e);
  let p = t || u ? TE(t, u) : void 0;
  l.push(hR({ codeParser: p, htmlParser: o.language.parser })), i && h.push(Cl.high(Vb.of(uN)));
  let y = e0(s.configure(l));
  return r && h.push(y.data.of({ autocomplete: _E })), new em(y, h);
}
c(pN, "eg$1");
f(pN, "markdown");
function _E(n) {
  let { state: t, pos: e } = n, i = /<[:\-\.\w\u00b7-\uffff]*$/.exec(t.sliceDoc(e - 25, e));
  if (!i)
    return null;
  let s = re(t).resolveInner(e, -1);
  for (; s && !s.type.isTop; ) {
    if (s.name == "CodeBlock" || s.name == "FencedCode" || s.name == "ProcessingInstructionBlock" || s.name == "CommentBlock" || s.name == "Link" || s.name == "Image")
      return null;
    s = s.parent;
  }
  return {
    from: e - i[0].length,
    to: e,
    options: zE(),
    validFor: /^<[:\-\.\w\u00b7-\uffff]*$/
  };
}
c(_E, "Ib$1");
f(_E, "htmlTagCompletion");
let P2 = null;
function zE() {
  if (P2)
    return P2;
  let n = wE(new QC(Ie.create({ extensions: EE }), 0, !0));
  return P2 = n ? n.options : [];
}
c(zE, "zb$1");
f(zE, "htmlTagCompletions");
const fN = /code|horizontalrule|html|link|comment|processing|escape|entity|image|mark|url/i, yN = /* @__PURE__ */ kt.domEventHandlers({
  paste: /* @__PURE__ */ f((n, t) => {
    var e;
    let { main: i } = t.state.selection;
    if (i.empty)
      return !1;
    let s = (e = n.clipboardData) === null || e === void 0 ? void 0 : e.getData("text/plain");
    if (!s || !/^(https?:\/\/|mailto:|xmpp:|www\.)/.test(s) || (/^www\./.test(s) && (s = "https://" + s), !VO.isActiveAt(t.state, i.from, 1)))
      return !1;
    let r = re(t.state), a = !1;
    return r.iterate({
      from: i.from,
      to: i.to,
      enter: /* @__PURE__ */ f((o) => {
        (o.from > i.from || fN.test(o.name)) && (a = !0);
      }, "enter"),
      leave: /* @__PURE__ */ f((o) => {
        o.to < i.to && (a = !0);
      }, "leave")
    }), a ? !1 : (t.dispatch({
      changes: [{ from: i.from, insert: "[" }, { from: i.to, insert: `](${s})` }],
      userEvent: "input.paste",
      scrollIntoView: !0
    }), !0);
  }, "paste")
});
function mN(n) {
  return new em(Xq.define(n));
}
c(mN, "b$1");
f(mN, "legacy");
function gN(n) {
  return import(
    /* webpackIgnore: true */
    /* @vite-ignore */
    new URL("./@codemirror/lang-sql/dist/index-BV9u_JGn.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
  ).then((t) => t.sql({ dialect: t[n] }));
}
c(gN, "mt$1");
f(gN, "sql");
function wN(n) {
  const t = new CustomEvent("wy-submit", { bubbles: !0 });
  return n.dom.dispatchEvent(t);
}
c(wN, "ig$1");
f(wN, "softSubmit");
const IQ = new yq({
  regexp: /(\[(.+?)\])(\(@u(\d+)\))/g,
  decoration: /* @__PURE__ */ f((n) => Gt.replace({
    // NOTE: can't use backspace to go "up one row" when inclusive is false
    inclusive: !0,
    widget: new vN(n)
  }), "decoration")
});
var Au;
const LE = (Au = class extends Pl {
  constructor(t) {
    super(), this.match = t;
  }
  eq(t) {
    return t.match[1] === this.match[1];
  }
  toDOM() {
    we();
    const t = document.createElement("span");
    return t.className = "wy-mention", t.part = "wy-mention", t.innerHTML = "@" + (typeof this.match[5] < "u" ? this.match[5] : this.match[2]), t;
  }
  ignoreEvent() {
    return !1;
  }
}, c(Au, "Fc"), Au);
f(LE, "MentionWidget");
let vN = LE;
Us.fromClass(
  class {
    constructor(n) {
      this.mentions = IQ.createDeco(n);
    }
    update(n) {
      this.mentions = IQ.updateDeco(n, this.mentions);
    }
  },
  {
    decorations: /* @__PURE__ */ f((n) => n.mentions, "decorations"),
    provide: /* @__PURE__ */ f((n) => kt.atomicRanges.of((t) => t.plugin(n)?.mentions || Gt.none), "provide")
  }
);
function ON(n, t) {
  return ({ state: e, dispatch: i }) => {
    if (e.readOnly)
      return !1;
    let s = n(t, e);
    return s ? (i(e.update(s)), !0) : !1;
  };
}
c(ON, "qh");
f(ON, "command");
function oP(n, t) {
  let e = n.languageDataAt("commentTokens", t, 1);
  return e.length ? e[0] : {};
}
c(oP, "Bh");
f(oP, "getConfig");
const Bm = 50;
function IE(n, { open: t, close: e }, i, s) {
  let r = n.sliceDoc(i - Bm, i), a = n.sliceDoc(s, s + Bm), o = /\s*$/.exec(r)[0].length, l = /^\s*/.exec(a)[0].length, h = r.length - o;
  if (r.slice(h - t.length, h) == t && a.slice(l, l + e.length) == e)
    return {
      open: { pos: i - o, margin: o && 1 },
      close: { pos: s + l, margin: l && 1 }
    };
  let u, p;
  s - i <= 2 * Bm ? u = p = n.sliceDoc(i, s) : (u = n.sliceDoc(i, i + Bm), p = n.sliceDoc(s - Bm, s));
  let y = /^\s*/.exec(u)[0].length, m = /\s*$/.exec(p)[0].length, g = p.length - m - e.length;
  return u.slice(y, y + t.length) == t && p.slice(g, g + e.length) == e ? {
    open: {
      pos: i + y + t.length,
      margin: /\s/.test(u.charAt(y + t.length)) ? 1 : 0
    },
    close: {
      pos: s - m - e.length,
      margin: /\s/.test(p.charAt(g - 1)) ? 1 : 0
    }
  } : null;
}
c(IE, "tw$1");
f(IE, "findBlockComment");
function bN(n) {
  let t = [];
  for (let e of n.selection.ranges) {
    let i = n.doc.lineAt(e.from), s = e.to <= i.to ? i : n.doc.lineAt(e.to);
    s.from > i.from && s.from == e.to && (s = e.to == i.to + 1 ? i : n.doc.lineAt(e.to - 1));
    let r = t.length - 1;
    r >= 0 && t[r].to > i.from ? t[r].to = s.to : t.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: s.to });
  }
  return t;
}
c(bN, "iw$1");
f(bN, "selectedLineRanges");
function $N(n, t, e = t.selection.ranges) {
  let i = e.map((r) => oP(t, r.from).block);
  if (!i.every((r) => r))
    return null;
  let s = e.map((r, a) => IE(t, i[a], r.from, r.to));
  if (n != 2 && !s.every((r) => r))
    return { changes: t.changes(e.map((r, a) => s[a] ? [] : [{ from: r.from, insert: i[a].open + " " }, { from: r.to, insert: " " + i[a].close }])) };
  if (n != 1 && s.some((r) => r)) {
    let r = [];
    for (let a = 0, o; a < s.length; a++)
      if (o = s[a]) {
        let l = i[a], { open: h, close: u } = o;
        r.push({ from: h.pos - l.open.length, to: h.pos + h.margin }, { from: u.pos - u.margin, to: u.pos + l.close.length });
      }
    return { changes: r };
  }
  return null;
}
c($N, "rg$1");
f($N, "changeBlockComment");
function xN(n, t, e = t.selection.ranges) {
  let i = [], s = -1;
  for (let { from: r, to: a } of e) {
    let o = i.length, l = 1e9, h = oP(t, r).line;
    if (h) {
      for (let u = r; u <= a; ) {
        let p = t.doc.lineAt(u);
        if (p.from > s && (r == a || a > p.from)) {
          s = p.from;
          let y = /^\s*/.exec(p.text)[0].length, m = y == p.length, g = p.text.slice(y, y + h.length) == h ? y : -1;
          y < p.text.length && y < l && (l = y), i.push({ line: p, comment: g, token: h, indent: y, empty: m, single: !1 });
        }
        u = p.to + 1;
      }
      if (l < 1e9)
        for (let u = o; u < i.length; u++)
          i[u].indent < i[u].line.text.length && (i[u].indent = l);
      i.length == o + 1 && (i[o].single = !0);
    }
  }
  if (n != 2 && i.some((r) => r.comment < 0 && (!r.empty || r.single))) {
    let r = [];
    for (let { line: o, token: l, indent: h, empty: u, single: p } of i)
      (p || !u) && r.push({ from: o.from + h, insert: l + " " });
    let a = t.changes(r);
    return { changes: a, selection: t.selection.map(a, 1) };
  } else if (n != 1 && i.some((r) => r.comment >= 0)) {
    let r = [];
    for (let { line: a, comment: o, token: l } of i)
      if (o >= 0) {
        let h = a.from + o, u = h + l.length;
        a.text[u - a.from] == " " && u++, r.push({ from: h, to: u });
      }
    return { changes: r };
  }
  return null;
}
c(xN, "rw$1");
f(xN, "changeLineComment");
const D5 = /* @__PURE__ */ ar.define(), kN = /* @__PURE__ */ ar.define(), SN = /* @__PURE__ */ bt.define(), WE = /* @__PURE__ */ bt.define({
  combine(n) {
    return VS(n, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: /* @__PURE__ */ f((t, e) => e, "joinToEvent")
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: /* @__PURE__ */ f((t, e) => (i, s) => t(i, s) || e(i, s), "joinToEvent")
    });
  }
}), VE = /* @__PURE__ */ rr.define({
  create() {
    return cw.empty;
  },
  update(n, t) {
    let e = t.state.facet(WE), i = t.annotation(D5);
    if (i) {
      let l = Is.fromTransaction(t, i.selection), h = i.side, u = h == 0 ? n.undone : n.done;
      return l ? u = Aw(u, u.length, e.minDepth, l) : u = hP(u, t.startState.selection), new cw(h == 0 ? i.rest : u, h == 0 ? u : i.rest);
    }
    let s = t.annotation(kN);
    if ((s == "full" || s == "before") && (n = n.isolate()), t.annotation(vi.addToHistory) === !1)
      return t.changes.empty ? n : n.addMapping(t.changes.desc);
    let r = Is.fromTransaction(t), a = t.annotation(vi.time), o = t.annotation(vi.userEvent);
    return r ? n = n.addChanges(r, a, o, e, t) : t.selection && (n = n.addSelection(t.startState.selection, a, o, e.newGroupDelay)), (s == "full" || s == "after") && (n = n.isolate()), n;
  },
  toJSON(n) {
    return { done: n.done.map((t) => t.toJSON()), undone: n.undone.map((t) => t.toJSON()) };
  },
  fromJSON(n) {
    return new cw(n.done.map(Is.fromJSON), n.undone.map(Is.fromJSON));
  }
});
function CN(n = {}) {
  return [
    VE,
    WE.of(n),
    kt.domEventHandlers({
      beforeinput(t, e) {
        let i = t.inputType == "historyUndo" ? PN : t.inputType == "historyRedo" ? QN : null;
        return i ? (t.preventDefault(), i(e)) : !1;
      }
    })
  ];
}
c(CN, "ow$1");
f(CN, "history");
function lP(n, t) {
  return function({ state: e, dispatch: i }) {
    if (!t && e.readOnly)
      return !1;
    let s = e.field(VE, !1);
    if (!s)
      return !1;
    let r = s.pop(n, e, t);
    return r ? (i(r), !0) : !1;
  };
}
c(lP, "xo$1");
f(lP, "cmd");
const PN = /* @__PURE__ */ lP(0, !1), QN = /* @__PURE__ */ lP(1, !1);
var es;
const DE = (es = class {
  constructor(t, e, i, s, r) {
    this.changes = t, this.effects = e, this.mapped = i, this.startSelection = s, this.selectionsAfter = r;
  }
  setSelAfter(t) {
    return new es(this.changes, this.effects, this.mapped, this.startSelection, t);
  }
  toJSON() {
    var t, e, i;
    return {
      changes: (t = this.changes) === null || t === void 0 ? void 0 : t.toJSON(),
      mapped: (e = this.mapped) === null || e === void 0 ? void 0 : e.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
    };
  }
  static fromJSON(t) {
    return new es(t.changes && Tn.fromJSON(t.changes), [], t.mapped && ah.fromJSON(t.mapped), t.startSelection && it.fromJSON(t.startSelection), t.selectionsAfter.map(it.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(t, e) {
    let i = ln;
    for (let s of t.startState.facet(SN)) {
      let r = s(t);
      r.length && (i = i.concat(r));
    }
    return !i.length && t.changes.empty ? null : new es(t.changes.invert(t.startState.doc), i, void 0, e || t.startState.selection, ln);
  }
  static selection(t) {
    return new es(void 0, ln, void 0, void 0, t);
  }
}, c(es, "Gt"), es);
f(DE, "HistEvent");
let Is = DE;
function Aw(n, t, e, i) {
  let s = t + 1 > e + 20 ? t - e - 1 : 0, r = n.slice(s, t);
  return r.push(i), r;
}
c(Aw, "Cs$1");
f(Aw, "updateBranch");
function qE(n, t) {
  let e = [], i = !1;
  return n.iterChangedRanges((s, r) => e.push(s, r)), t.iterChangedRanges((s, r, a, o) => {
    for (let l = 0; l < e.length; ) {
      let h = e[l++], u = e[l++];
      o >= h && a <= u && (i = !0);
    }
  }), i;
}
c(qE, "hw$1");
f(qE, "isAdjacent");
function ZE(n, t) {
  return n.ranges.length == t.ranges.length && n.ranges.filter((e, i) => e.empty != t.ranges[i].empty).length === 0;
}
c(ZE, "fw$1");
f(ZE, "eqSelectionShape");
function cP(n, t) {
  return n.length ? t.length ? n.concat(t) : n : t;
}
c(cP, "lg$1");
f(cP, "conc");
const ln = [], TN = 200;
function hP(n, t) {
  if (n.length) {
    let e = n[n.length - 1], i = e.selectionsAfter.slice(Math.max(0, e.selectionsAfter.length - TN));
    return i.length && i[i.length - 1].eq(t) ? n : (i.push(t), Aw(n, n.length - 1, 1e9, e.setSelAfter(i)));
  } else
    return [Is.selection([t])];
}
c(hP, "ag$1");
f(hP, "addSelection");
function FE(n) {
  let t = n[n.length - 1], e = n.slice();
  return e[n.length - 1] = t.setSelAfter(t.selectionsAfter.slice(0, t.selectionsAfter.length - 1)), e;
}
c(FE, "uw$1");
f(FE, "popSelection");
function Rv(n, t) {
  if (!n.length)
    return n;
  let e = n.length, i = ln;
  for (; e; ) {
    let s = XE(n[e - 1], t, i);
    if (s.changes && !s.changes.empty || s.effects.length) {
      let r = n.slice(0, e);
      return r[e - 1] = s, r;
    } else
      t = s.mapped, e--, i = s.selectionsAfter;
  }
  return i.length ? [Is.selection(i)] : ln;
}
c(Rv, "nl$1");
f(Rv, "addMappingToBranch");
function XE(n, t, e) {
  let i = cP(n.selectionsAfter.length ? n.selectionsAfter.map((o) => o.map(t)) : ln, e);
  if (!n.changes)
    return Is.selection(i);
  let s = n.changes.map(t), r = t.mapDesc(n.changes, !0), a = n.mapped ? n.mapped.composeDesc(r) : r;
  return new Is(s, Bt.mapEffects(n.effects, t), a, n.startSelection.map(r), i);
}
c(XE, "Ow$1");
f(XE, "mapEvent");
const MN = /^(input\.type|delete)($|\.)/;
var is;
const NE = (is = class {
  constructor(t, e, i = 0, s = void 0) {
    this.done = t, this.undone = e, this.prevTime = i, this.prevUserEvent = s;
  }
  isolate() {
    return this.prevTime ? new is(this.done, this.undone) : this;
  }
  addChanges(t, e, i, s, r) {
    let a = this.done, o = a[a.length - 1];
    return o && o.changes && !o.changes.empty && t.changes && (!i || MN.test(i)) && (!o.selectionsAfter.length && e - this.prevTime < s.newGroupDelay && s.joinToEvent(r, qE(o.changes, t.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? a = Aw(a, a.length - 1, s.minDepth, new Is(t.changes.compose(o.changes), cP(Bt.mapEffects(t.effects, o.changes), o.effects), o.mapped, o.startSelection, ln)) : a = Aw(a, a.length, s.minDepth, t), new is(a, ln, e, i);
  }
  addSelection(t, e, i, s) {
    let r = this.done.length ? this.done[this.done.length - 1].selectionsAfter : ln;
    return r.length > 0 && e - this.prevTime < s && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && ZE(r[r.length - 1], t) ? this : new is(hP(this.done, t), this.undone, e, i);
  }
  addMapping(t) {
    return new is(Rv(this.done, t), Rv(this.undone, t), this.prevTime, this.prevUserEvent);
  }
  pop(t, e, i) {
    let s = t == 0 ? this.done : this.undone;
    if (s.length == 0)
      return null;
    let r = s[s.length - 1], a = r.selectionsAfter[0] || e.selection;
    if (i && r.selectionsAfter.length)
      return e.update({
        selection: r.selectionsAfter[r.selectionsAfter.length - 1],
        annotations: D5.of({ side: t, rest: FE(s), selection: a }),
        userEvent: t == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (r.changes) {
      let o = s.length == 1 ? ln : s.slice(0, s.length - 1);
      return r.mapped && (o = Rv(o, r.mapped)), e.update({
        changes: r.changes,
        selection: r.startSelection,
        effects: r.effects,
        annotations: D5.of({ side: t, rest: o, selection: a }),
        filter: !1,
        userEvent: t == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}, c(is, "Ft"), is);
f(NE, "HistoryState");
let cw = NE;
cw.empty = /* @__PURE__ */ new cw(ln, ln);
function u1(n, t) {
  return it.create(n.ranges.map(t), n.mainIndex);
}
c(u1, "ir$1");
f(u1, "updateSel");
function Sm(n, t) {
  return n.update({ selection: t, scrollIntoView: !0, userEvent: "select" });
}
c(Sm, "Ge$2");
f(Sm, "setSel");
function n0({ state: n, dispatch: t }, e) {
  let i = u1(n.selection, e);
  return i.eq(n.selection, !0) ? !1 : (t(Sm(n, i)), !0);
}
c(n0, "Fe$2");
f(n0, "moveSel");
function p1(n, t) {
  return it.cursor(t ? n.to : n.from);
}
c(p1, "ko$1");
f(p1, "rangeEnd");
function AN(n, t) {
  return n0(n, (e) => e.empty ? n.moveByChar(e, t) : p1(e, t));
}
c(AN, "hg$1");
f(AN, "cursorByChar");
function RN(n) {
  return n.textDirectionAt(n.state.selection.main.head) == le.LTR;
}
c(RN, "he$2");
f(RN, "ltrAtCursor");
function EN(n, t) {
  return n0(n, (e) => e.empty ? n.moveByGroup(e, t) : p1(e, t));
}
c(EN, "ug$1");
f(EN, "cursorByGroup");
function jE(n, t, e) {
  if (t.type.prop(e))
    return !0;
  let i = t.to - t.from;
  return i && (i > 2 || /[^\s,.;:]/.test(n.sliceDoc(t.from, t.to))) || t.firstChild;
}
c(jE, "Qw$1");
f(jE, "interestingNode");
function _N(n, t, e) {
  let i = re(n).resolveInner(t.head), s = e ? Pt.closedBy : Pt.openedBy;
  for (let l = t.head; ; ) {
    let h = e ? i.childAfter(l) : i.childBefore(l);
    if (!h)
      break;
    jE(n, h, s) ? i = h : l = e ? h.to : h.from;
  }
  let r = i.type.prop(s), a, o;
  return r && (a = e ? Ga(n, i.from, 1) : Ga(n, i.to, -1)) && a.matched ? o = e ? a.end.to : a.end.from : o = e ? i.to : i.from, it.cursor(o, e ? -1 : 1);
}
c(_N, "Po$1");
f(_N, "moveBySyntax");
function zN(n, t) {
  return n0(n, (e) => {
    if (!e.empty)
      return p1(e, t);
    let i = n.moveVertically(e, t);
    return i.head != e.head ? i : n.moveToLineBoundary(e, t);
  });
}
c(zN, "Og$1");
f(zN, "cursorByLine");
function dP(n) {
  let t = n.scrollDOM.clientHeight < n.scrollDOM.scrollHeight - 2, e = 0, i = 0, s;
  if (t) {
    for (let r of n.state.facet(kt.scrollMargins)) {
      let a = r(n);
      a?.top && (e = Math.max(a?.top, e)), a?.bottom && (i = Math.max(a?.bottom, i));
    }
    s = n.scrollDOM.clientHeight - e - i;
  } else
    s = (n.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: e,
    marginBottom: i,
    selfScroll: t,
    height: Math.max(n.defaultLineHeight, s - 5)
  };
}
c(dP, "mg$1");
f(dP, "pageInfo");
function LN(n, t) {
  let e = dP(n), { state: i } = n, s = u1(i.selection, (a) => a.empty ? n.moveVertically(a, t, e.height) : p1(a, t));
  if (s.eq(i.selection))
    return !1;
  let r;
  if (e.selfScroll) {
    let a = n.coordsAtPos(i.selection.main.head), o = n.scrollDOM.getBoundingClientRect(), l = o.top + e.marginTop, h = o.bottom - e.marginBottom;
    a && a.top > l && a.bottom < h && (r = kt.scrollIntoView(s.main.head, { y: "start", yMargin: a.top - l }));
  }
  return n.dispatch(Sm(i, s), { effects: r }), !0;
}
c(LN, "gg$1");
f(LN, "cursorByPage");
function IN(n, t, e) {
  let i = n.lineBlockAt(t.head), s = n.moveToLineBoundary(t, e);
  if (s.head == t.head && s.head != (e ? i.to : i.from) && (s = n.moveToLineBoundary(t, e, !1)), !e && s.head == i.from && i.length) {
    let r = /^\s*/.exec(n.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    r && t.head != i.from + r && (s = it.cursor(i.from + r));
  }
  return s;
}
c(IN, "Ct$1");
f(IN, "moveByLineBoundary");
function WN(n, t, e) {
  let i = !1, s = u1(n.selection, (r) => {
    let a = Ga(n, r.head, -1) || Ga(n, r.head, 1) || r.head > 0 && Ga(n, r.head - 1, 1) || r.head < n.doc.length && Ga(n, r.head + 1, -1);
    if (!a || !a.end)
      return r;
    i = !0;
    let o = a.start.from == r.head ? a.end.to : a.end.from;
    return it.cursor(o);
  });
  return i ? (t(Sm(n, s)), !0) : !1;
}
c(WN, "Rw$1");
f(WN, "toMatchingBracket");
function f1(n, t) {
  let e = u1(n.state.selection, (i) => {
    let s = t(i);
    return it.range(i.anchor, s.head, s.goalColumn, s.bidiLevel || void 0);
  });
  return e.eq(n.state.selection) ? !1 : (n.dispatch(Sm(n.state, e)), !0);
}
c(f1, "We$2");
f(f1, "extendSel");
function VN(n, t) {
  return f1(n, (e) => n.moveByChar(e, t));
}
c(VN, "Qg$1");
f(VN, "selectByChar");
function DN(n, t) {
  return f1(n, (e) => n.moveByGroup(e, t));
}
c(DN, "bg$1");
f(DN, "selectByGroup");
function qN(n, t) {
  return f1(n, (e) => n.moveVertically(e, t));
}
c(qN, "wg$1");
f(qN, "selectByLine");
function ZN(n, t) {
  return f1(n, (e) => n.moveVertically(e, t, dP(n).height));
}
c(ZN, "Pg$1");
f(ZN, "selectByPage");
function FN(n, t) {
  let { state: e } = n, i = e.selection, s = e.selection.ranges.slice();
  for (let r of e.selection.ranges) {
    let a = e.doc.lineAt(r.head);
    if (t ? a.to < n.state.doc.length : a.from > 0)
      for (let o = r; ; ) {
        let l = n.moveVertically(o, t);
        if (l.head < a.from || l.head > a.to) {
          s.some((h) => h.head == l.head) || s.push(l);
          break;
        } else {
          if (l.head == o.head)
            break;
          o = l;
        }
      }
  }
  return s.length == i.ranges.length ? !1 : (n.dispatch(Sm(e, it.create(s, s.length - 1))), !0);
}
c(FN, "$g$1");
f(FN, "addCursorVertically");
function XN(n, t) {
  if (n.state.readOnly)
    return !1;
  let e = "delete.selection", { state: i } = n, s = i.changeByRange((r) => {
    let { from: a, to: o } = r;
    if (a == o) {
      let l = t(r);
      l < a ? (e = "delete.backward", l = Cg(n, l, !1)) : l > a && (e = "delete.forward", l = Cg(n, l, !0)), a = Math.min(a, l), o = Math.max(o, l);
    } else
      a = Cg(n, a, !1), o = Cg(n, o, !0);
    return a == o ? { range: r } : { changes: { from: a, to: o }, range: it.cursor(a, a < r.head ? -1 : 1) };
  });
  return s.changes.empty ? !1 : (n.dispatch(i.update(s, {
    scrollIntoView: !0,
    userEvent: e,
    effects: e == "delete.selection" ? kt.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
c(XN, "wn$1");
f(XN, "deleteBy");
function Cg(n, t, e) {
  if (n instanceof kt)
    for (let i of n.state.facet(kt.atomicRanges).map((s) => s(n)))
      i.between(t, t, (s, r) => {
        s < t && r > t && (t = e ? r : s);
      });
  return t;
}
c(Cg, "jn$1");
f(Cg, "skipAtomic");
function uP(n) {
  let t = [], e = -1;
  for (let i of n.selection.ranges) {
    let s = n.doc.lineAt(i.from), r = n.doc.lineAt(i.to);
    if (!i.empty && i.to == r.from && (r = n.doc.lineAt(i.to - 1)), e >= s.number) {
      let a = t[t.length - 1];
      a.to = r.to, a.ranges.push(i);
    } else
      t.push({ from: s.from, to: r.to, ranges: [i] });
    e = r.number + 1;
  }
  return t;
}
c(uP, "$o$1");
f(uP, "selectedLineBlocks");
function NN(n, t, e) {
  if (n.readOnly)
    return !1;
  let i = [], s = [];
  for (let r of uP(n)) {
    if (e ? r.to == n.doc.length : r.from == 0)
      continue;
    let a = n.doc.lineAt(e ? r.to + 1 : r.from - 1), o = a.length + 1;
    if (e) {
      i.push({ from: r.to, to: a.to }, { from: r.from, insert: a.text + n.lineBreak });
      for (let l of r.ranges)
        s.push(it.range(Math.min(n.doc.length, l.anchor + o), Math.min(n.doc.length, l.head + o)));
    } else {
      i.push({ from: a.from, to: r.from }, { from: r.to, insert: n.lineBreak + a.text });
      for (let l of r.ranges)
        s.push(it.range(l.anchor - o, l.head - o));
    }
  }
  return i.length ? (t(n.update({
    changes: i,
    scrollIntoView: !0,
    selection: it.create(s, n.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
c(NN, "Lg$1");
f(NN, "moveLine");
function jN(n, t, e) {
  if (n.readOnly)
    return !1;
  let i = [];
  for (let r of uP(n))
    e ? i.push({ from: r.from, insert: n.doc.slice(r.from, r.to) + n.lineBreak }) : i.push({ from: r.to, insert: n.lineBreak + n.doc.slice(r.from, r.to) });
  let s = n.changes(i);
  return t(n.update({
    changes: s,
    selection: n.selection.map(s, e ? 1 : -1),
    scrollIntoView: !0,
    userEvent: "input.copyline"
  })), !0;
}
c(jN, "_g$1");
f(jN, "copyLine");
function BE(n, t) {
  if (/\(\)|\[\]|\{\}/.test(n.sliceDoc(t - 1, t + 1)))
    return { from: t, to: t };
  let e = re(n).resolveInner(t), i = e.childBefore(t), s = e.childAfter(t), r;
  return i && s && i.to <= t && s.from >= t && (r = i.type.prop(Pt.closedBy)) && r.indexOf(s.name) > -1 && n.doc.lineAt(i.to).from == n.doc.lineAt(s.from).from && !/\S/.test(n.sliceDoc(i.to, s.from)) ? { from: i.to, to: s.from } : null;
}
c(BE, "ix$1");
f(BE, "isBetweenBrackets");
function BN(n) {
  return ({ state: t, dispatch: e }) => {
    if (t.readOnly)
      return !1;
    let i = t.changeByRange((s) => {
      let { from: r, to: a } = s, o = t.doc.lineAt(r), l = !n && r == a && BE(t, r);
      n && (r = a = (a <= o.to ? o : t.doc.lineAt(a)).to);
      let h = new OC(t, { simulateBreak: r, simulateDoubleBreak: !!l }), u = WM(h, r);
      for (u == null && (u = ea(/^\s*/.exec(t.doc.lineAt(r).text)[0], t.tabSize)); a < o.to && /\s/.test(o.text[a - o.from]); )
        a++;
      l ? { from: r, to: a } = l : r > o.from && r < o.from + 100 && !/\S/.test(o.text.slice(0, r)) && (r = o.from);
      let p = ["", c5(t, u)];
      return l && p.push(c5(t, h.lineIndent(o.from, -1))), {
        changes: { from: r, to: a, insert: Ft.of(p) },
        range: it.cursor(r + 1 + p[1].length)
      };
    });
    return e(t.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
c(BN, "Mg$1");
f(BN, "newlineAndIndent");
function UN(n, t) {
  let e = -1;
  return n.changeByRange((i) => {
    let s = [];
    for (let a = i.from; a <= i.to; ) {
      let o = n.doc.lineAt(a);
      o.number > e && (i.empty || i.to > o.from) && (t(o, s, i), e = o.number), a = o.to + 1;
    }
    let r = n.changes(s);
    return {
      changes: s,
      range: it.range(r.mapPos(i.anchor, 1), r.mapPos(i.head, 1))
    };
  });
}
c(UN, "Dh$1");
f(UN, "changeBySelectedLine");
HM.define([
  { tag: T.meta, class: "code" },
  { tag: T.link, class: "wy-link" },
  { tag: T.heading, textDecoration: "underline", fontWeight: "bold" },
  { tag: T.emphasis, fontStyle: "italic" },
  { tag: T.strong, fontWeight: "bold" },
  { tag: T.strikethrough, textDecoration: "line-through" },
  { tag: T.keyword, class: "code token keyword" },
  { tag: [T.atom, T.bool], class: "code token builtin" },
  { tag: [T.url, T.contentSeparator, T.labelName], class: "code token prolog" },
  { tag: T.literal, class: "code token char" },
  { tag: T.inserted, class: "code token inserted" },
  { tag: T.deleted, class: "code token deleted" },
  { tag: T.string, class: "code token string" },
  { tag: [T.regexp, T.escape, T.special(T.string)], class: "code token regex" },
  { tag: T.definition(T.variableName), class: "code token constant" },
  { tag: T.local(T.variableName), class: "code token variable" },
  { tag: [T.typeName, T.namespace], class: "code token keyword" },
  { tag: T.className, class: "code token class-name" },
  { tag: [T.special(T.variableName), T.macroName], class: "code token function" },
  { tag: T.propertyName, class: "code token property" },
  { tag: T.comment, class: "code token comment" },
  { tag: T.invalid, color: "#f00", class: "code token" }
]);
function HN(n) {
  pP(n, "start");
  var t = {}, e = n.languageData || {}, i = !1;
  for (var s in n) if (s != e && n.hasOwnProperty(s))
    for (var r = t[s] = [], a = n[s], o = 0; o < a.length; o++) {
      var l = a[o];
      r.push(new YE(l, n)), (l.indent || l.dedent) && (i = !0);
    }
  return {
    name: e.name,
    startState: /* @__PURE__ */ f(function() {
      return { state: "start", pending: null, indent: i ? [] : null };
    }, "startState"),
    copyState: /* @__PURE__ */ f(function(h) {
      var u = { state: h.state, pending: h.pending, indent: h.indent && h.indent.slice(0) };
      return h.stack && (u.stack = h.stack.slice(0)), u;
    }, "copyState"),
    token: GE(t),
    indent: KE(t, e),
    mergeTokens: e.mergeTokens,
    languageData: e
  };
}
c(HN, "Tx$1");
f(HN, "simpleMode");
function pP(n, t) {
  if (!n.hasOwnProperty(t))
    throw new Error("Undefined state " + t + " in simple mode");
}
c(pP, "Zg$1");
f(pP, "ensureState");
function UE(n, t) {
  if (!n) return /(?:)/;
  var e = "";
  return n instanceof RegExp ? (n.ignoreCase && (e = "i"), n.unicode && (e += "u"), n = n.source) : n = String(n), new RegExp("^(?:" + n + ")", e);
}
c(UE, "ux$1");
f(UE, "toRegex");
function HE(n) {
  if (!n) return null;
  if (n.apply) return n;
  if (typeof n == "string") return n.replace(/\./g, " ");
  for (var t = [], e = 0; e < n.length; e++)
    t.push(n[e] && n[e].replace(/\./g, " "));
  return t;
}
c(HE, "Ox$1");
f(HE, "asToken");
function YE(n, t) {
  (n.next || n.push) && pP(t, n.next || n.push), this.regex = UE(n.regex), this.token = HE(n.token), this.data = n;
}
c(YE, "dx$1");
f(YE, "Rule");
function GE(n) {
  return function(t, e) {
    if (e.pending) {
      var i = e.pending.shift();
      return e.pending.length == 0 && (e.pending = null), t.pos += i.text.length, i.token;
    }
    for (var s = n[e.state], r = 0; r < s.length; r++) {
      var a = s[r], o = (!a.data.sol || t.sol()) && t.match(a.regex);
      if (o) {
        a.data.next ? e.state = a.data.next : a.data.push ? ((e.stack || (e.stack = [])).push(e.state), e.state = a.data.push) : a.data.pop && e.stack && e.stack.length && (e.state = e.stack.pop()), a.data.indent && e.indent.push(t.indentation() + t.indentUnit), a.data.dedent && e.indent.pop();
        var l = a.token;
        if (l && l.apply && (l = l(o)), o.length > 2 && a.token && typeof a.token != "string") {
          e.pending = [];
          for (var h = 2; h < o.length; h++)
            o[h] && e.pending.push({ text: o[h], token: a.token[h - 1] });
          return t.backUp(o[0].length - (o[1] ? o[1].length : 0)), l[0];
        } else return l && l.join ? l[0] : l;
      }
    }
    return t.next(), null;
  };
}
c(GE, "px$1");
f(GE, "tokenFunction");
function KE(n, t) {
  return function(e, i) {
    if (e.indent == null || t.dontIndentStates && t.dontIndentStates.indexOf(e.state) > -1)
      return null;
    var s = e.indent.length - 1, r = n[e.state];
    t: for (; ; ) {
      for (var a = 0; a < r.length; a++) {
        var o = r[a];
        if (o.data.dedent && o.data.dedentIfLineStart !== !1) {
          var l = o.regex.exec(i);
          if (l && l[0]) {
            s--, (o.next || o.push) && (r = n[o.next || o.push]), i = i.slice(l[0].length);
            continue t;
          }
        }
      }
      break;
    }
    return s < 0 ? 0 : e.indent[s];
  };
}
c(KE, "mx$1");
f(KE, "indentFunction");
var YN = Object.defineProperty, dt = /* @__PURE__ */ c((n, t) => YN(n, "name", { value: t, configurable: !0 }), "o$1");
const q5 = "lit-localize-status", GN = /* @__PURE__ */ dt((n, ...t) => ({
  strTag: !0,
  strings: n,
  values: t
}), "_str"), st = GN, KN = /* @__PURE__ */ dt((n) => typeof n != "string" && "strTag" in n, "isStrTagged"), JE = /* @__PURE__ */ dt((n, t, e) => {
  let i = n[0];
  for (let s = 1; s < n.length; s++)
    i += t[e ? e[s - 1] : s - 1], i += n[s];
  return i;
}, "joinStringsAndValues"), t_ = /* @__PURE__ */ dt(((n) => KN(n) ? JE(n.strings, n.values) : n), "defaultMsg");
let P = t_, WQ = !1;
function e_(n) {
  if (WQ)
    throw new Error("lit-localize can only be configured once");
  P = n, WQ = !0;
}
c(e_, "xt$1");
dt(e_, "_installMsgImplementation");
var Ru;
const i_ = (Ru = class {
  constructor(t) {
    this.__litLocalizeEventHandler = (e) => {
      e.detail.status === "ready" && this.host.requestUpdate();
    }, this.host = t;
  }
  hostConnected() {
    window.addEventListener(q5, this.__litLocalizeEventHandler);
  }
  hostDisconnected() {
    window.removeEventListener(q5, this.__litLocalizeEventHandler);
  }
}, c(Ru, "Be"), Ru);
dt(i_, "LocalizeController");
let JN = i_;
const tj = /* @__PURE__ */ dt((n) => n.addController(new JN(n)), "_updateWhenLocaleChanges"), ej = tj, St = /* @__PURE__ */ dt(() => (n, t) => (n.addInitializer(ej), n), "localized");
var Eu;
const n_ = (Eu = class {
  constructor() {
    this.settled = !1, this.promise = new Promise((t, e) => {
      this._resolve = t, this._reject = e;
    });
  }
  resolve(t) {
    this.settled = !0, this._resolve(t);
  }
  reject(t) {
    this.settled = !0, this._reject(t);
  }
}, c(Eu, "Ve"), Eu);
dt(n_, "Deferred");
let s_ = n_;
const Ps = [];
for (let n = 0; n < 256; n++)
  Ps[n] = (n >> 4 & 15).toString(16) + (n & 15).toString(16);
function r_(n) {
  let t = 0, e = 8997, i = 0, s = 33826, r = 0, a = 40164, o = 0, l = 52210;
  for (let h = 0; h < n.length; h++)
    e ^= n.charCodeAt(h), t = e * 435, i = s * 435, r = a * 435, o = l * 435, r += e << 8, o += s << 8, i += t >>> 16, e = t & 65535, r += i >>> 16, s = i & 65535, l = o + (r >>> 16) & 65535, a = r & 65535;
  return Ps[l >> 8] + Ps[l & 255] + Ps[a >> 8] + Ps[a & 255] + Ps[s >> 8] + Ps[s & 255] + Ps[e >> 8] + Ps[e & 255];
}
c(r_, "Ut$1");
dt(r_, "fnv1a64");
const ij = "", nj = "h", sj = "s";
function a_(n, t) {
  return (t ? nj : sj) + r_(typeof n == "string" ? n : n.join(ij));
}
c(a_, "jt$1");
dt(a_, "generateMsgId");
const VQ = /* @__PURE__ */ new WeakMap(), DQ = /* @__PURE__ */ new Map();
function o_(n, t, e) {
  if (n) {
    const i = e?.id ?? l_(t), s = n[i];
    if (s) {
      if (typeof s == "string")
        return s;
      if ("strTag" in s)
        return JE(
          s.strings,
          // Cast `template` because its type wasn't automatically narrowed (but
          // we know it must be the same type as `localized`).
          t.values,
          s.values
        );
      {
        let r = VQ.get(s);
        return r === void 0 && (r = s.values, VQ.set(s, r)), {
          ...s,
          values: r.map((a) => t.values[a])
        };
      }
    }
  }
  return t_(t);
}
c(o_, "Wt$1");
dt(o_, "runtimeMsg");
function l_(n) {
  const t = typeof n == "string" ? n : n.strings;
  let e = DQ.get(t);
  return e === void 0 && (e = a_(t, typeof n != "string" && !("strTag" in n)), DQ.set(t, e)), e;
}
c(l_, "Bt$1");
dt(l_, "generateId");
function Ev(n) {
  window.dispatchEvent(new CustomEvent(q5, { detail: n }));
}
c(Ev, "ve$1");
dt(Ev, "dispatchStatusEvent");
let DO = "", Q2, c_, qO, Z5, h_, Na = new s_();
Na.resolve();
let J1 = 0;
const rj = /* @__PURE__ */ dt((n) => (e_(((t, e) => o_(h_, t, e))), DO = c_ = n.sourceLocale, qO = new Set(n.targetLocales), qO.add(n.sourceLocale), Z5 = n.loadLocale, { getLocale: aj, setLocale: oj }), "configureLocalization"), aj = /* @__PURE__ */ dt(() => DO, "getLocale"), oj = /* @__PURE__ */ dt((n) => {
  if (n === (Q2 ?? DO))
    return Na.promise;
  if (!qO || !Z5)
    throw new Error("Internal error");
  if (!qO.has(n))
    throw new Error("Invalid locale code");
  J1++;
  const t = J1;
  return Q2 = n, Na.settled && (Na = new s_()), Ev({ status: "loading", loadingLocale: n }), (n === c_ ? (
    // We could switch to the source locale synchronously, but we prefer to
    // queue it on a microtask so that switching locales is consistently
    // asynchronous.
    Promise.resolve({ templates: void 0 })
  ) : Z5(n)).then((e) => {
    J1 === t && (DO = n, Q2 = void 0, h_ = e.templates, Ev({ status: "ready", readyLocale: n }), Na.resolve());
  }, (e) => {
    J1 === t && (Ev({
      status: "error",
      errorLocale: n,
      errorMessage: e.toString()
    }), Na.reject(e));
  }), Na.promise;
}, "setLocale");
var T2, _u;
const lj = (T2 = (_u = class {
  get shadowRoot() {
    return this.__host.__shadowRoot;
  }
  constructor(t) {
    this.ariaAtomic = "", this.ariaAutoComplete = "", this.ariaBrailleLabel = "", this.ariaBrailleRoleDescription = "", this.ariaBusy = "", this.ariaChecked = "", this.ariaColCount = "", this.ariaColIndex = "", this.ariaColSpan = "", this.ariaCurrent = "", this.ariaDescription = "", this.ariaDisabled = "", this.ariaExpanded = "", this.ariaHasPopup = "", this.ariaHidden = "", this.ariaInvalid = "", this.ariaKeyShortcuts = "", this.ariaLabel = "", this.ariaLevel = "", this.ariaLive = "", this.ariaModal = "", this.ariaMultiLine = "", this.ariaMultiSelectable = "", this.ariaOrientation = "", this.ariaPlaceholder = "", this.ariaPosInSet = "", this.ariaPressed = "", this.ariaReadOnly = "", this.ariaRequired = "", this.ariaRoleDescription = "", this.ariaRowCount = "", this.ariaRowIndex = "", this.ariaRowSpan = "", this.ariaSelected = "", this.ariaSetSize = "", this.ariaSort = "", this.ariaValueMax = "", this.ariaValueMin = "", this.ariaValueNow = "", this.ariaValueText = "", this.role = "", this.form = null, this.labels = [], this.states = /* @__PURE__ */ new Set(), this.validationMessage = "", this.validity = {}, this.willValidate = !0, this.__host = t;
  }
  checkValidity() {
    return console.warn("`ElementInternals.checkValidity()` was called on the server.This method always returns true."), !0;
  }
  reportValidity() {
    return !0;
  }
  setFormValue() {
  }
  setValidity() {
  }
}, c(_u, "O$1"), _u), dt(T2, "ElementInternals"), T2);
var Nn = /* @__PURE__ */ c(function(n, t, e, i, s) {
  if (typeof t == "function" ? n !== t || !0 : !t.has(n)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t.set(n, e), e;
}, "E"), Ge = /* @__PURE__ */ c(function(n, t, e, i) {
  if (typeof t == "function" ? n !== t || !i : !t.has(n)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e === "m" ? i : e === "a" ? i.call(n) : i ? i.value : t.get(n);
}, "_"), Cc, tv, ev, Um, M2, Hm, iv, Aa, Ym, dr, nv, qQ;
const ZQ = /* @__PURE__ */ dt((n) => typeof n == "boolean" ? n : n?.capture ?? !1, "isCaptureEventListener"), ZO = 0, F5 = 1, FO = 2, X5 = 3;
var zu;
const d_ = (zu = class {
  constructor() {
    this.__eventListeners = /* @__PURE__ */ new Map(), this.__captureEventListeners = /* @__PURE__ */ new Map();
  }
  addEventListener(t, e, i) {
    if (e == null)
      return;
    const s = ZQ(i) ? this.__captureEventListeners : this.__eventListeners;
    let r = s.get(t);
    if (r === void 0)
      r = /* @__PURE__ */ new Map(), s.set(t, r);
    else if (r.has(e))
      return;
    const a = typeof i == "object" && i ? i : {};
    a.signal?.addEventListener("abort", () => this.removeEventListener(t, e, i)), r.set(e, a ?? {});
  }
  removeEventListener(t, e, i) {
    if (e == null)
      return;
    const s = ZQ(i) ? this.__captureEventListeners : this.__eventListeners, r = s.get(t);
    r !== void 0 && (r.delete(e), r.size || s.delete(t));
  }
  dispatchEvent(t) {
    const e = [this];
    let i = this.__eventTargetParent;
    if (t.composed)
      for (; i; )
        e.push(i), i = i.__eventTargetParent;
    else
      for (; i && i !== this.__host; )
        e.push(i), i = i.__eventTargetParent;
    let s = !1, r = !1, a = ZO, o = null, l = null, h = null;
    const u = t.stopPropagation, p = t.stopImmediatePropagation;
    Object.defineProperties(t, {
      target: {
        get() {
          return o ?? l;
        },
        ...Nt
      },
      srcElement: {
        get() {
          return t.target;
        },
        ...Nt
      },
      currentTarget: {
        get() {
          return h;
        },
        ...Nt
      },
      eventPhase: {
        get() {
          return a;
        },
        ...Nt
      },
      composedPath: {
        value: /* @__PURE__ */ dt(() => e, "value"),
        ...Nt
      },
      stopPropagation: {
        value: /* @__PURE__ */ dt(() => {
          s = !0, u.call(t);
        }, "value"),
        ...Nt
      },
      stopImmediatePropagation: {
        value: /* @__PURE__ */ dt(() => {
          r = !0, p.call(t);
        }, "value"),
        ...Nt
      }
    });
    const y = /* @__PURE__ */ dt((x, Q, L) => {
      typeof x == "function" ? x(t) : typeof x?.handleEvent == "function" && x.handleEvent(t), Q.once && L.delete(x);
    }, "invokeEventListener"), m = /* @__PURE__ */ dt(() => (h = null, a = ZO, !t.defaultPrevented), "finishDispatch"), g = e.slice().reverse();
    o = !this.__host || !t.composed ? this : null;
    const b = /* @__PURE__ */ dt((x) => {
      for (l = this; l.__host && x.includes(l.__host); )
        l = l.__host;
    }, "retarget");
    for (const x of g) {
      !o && (!l || l === x.__host) && b(g.slice(g.indexOf(x))), h = x, a = x === t.target ? FO : F5;
      const Q = x.__captureEventListeners.get(t.type);
      if (Q) {
        for (const [L, W] of Q)
          if (y(L, W, Q), r)
            return m();
      }
      if (s)
        return m();
    }
    const S = t.bubbles ? e : [this];
    l = null;
    for (const x of S) {
      !o && (!l || x === l.__host) && b(S.slice(0, S.indexOf(x) + 1)), h = x, a = x === t.target ? FO : X5;
      const Q = x.__eventListeners.get(t.type);
      if (Q) {
        for (const [L, W] of Q)
          if (y(L, W, Q), r)
            return m();
      }
      if (s)
        return m();
    }
    return m();
  }
}, c(zu, "ze"), zu);
dt(d_, "EventTarget");
let cj = d_;
const hj = cj, Nt = { __proto__: null };
Nt.enumerable = !0;
Object.freeze(Nt);
var A2, Lu;
const fP = (dr = (A2 = (Lu = class {
  constructor(t, e = {}) {
    if (Cc.set(this, !1), tv.set(this, !1), ev.set(this, !1), Um.set(this, !1), M2.set(this, Date.now()), Hm.set(this, !1), iv.set(this, void 0), Aa.set(this, void 0), Ym.set(this, void 0), this.NONE = ZO, this.CAPTURING_PHASE = F5, this.AT_TARGET = FO, this.BUBBLING_PHASE = X5, arguments.length === 0)
      throw new Error("The type argument must be specified");
    if (typeof e != "object" || !e)
      throw new Error('The "options" argument must be an object');
    const { bubbles: i, cancelable: s, composed: r } = e;
    Nn(this, Cc, !!s), Nn(this, tv, !!i), Nn(this, ev, !!r), Nn(this, iv, `${t}`), Nn(this, Aa, null), Nn(this, Ym, !1);
  }
  initEvent(t, e, i) {
    throw new Error("Method not implemented.");
  }
  stopImmediatePropagation() {
    this.stopPropagation();
  }
  preventDefault() {
    Nn(this, Um, !0);
  }
  get target() {
    return Ge(this, Aa, "f");
  }
  get currentTarget() {
    return Ge(this, Aa, "f");
  }
  get srcElement() {
    return Ge(this, Aa, "f");
  }
  get type() {
    return Ge(this, iv, "f");
  }
  get cancelable() {
    return Ge(this, Cc, "f");
  }
  get defaultPrevented() {
    return Ge(this, Cc, "f") && Ge(this, Um, "f");
  }
  get timeStamp() {
    return Ge(this, M2, "f");
  }
  composedPath() {
    return Ge(this, Ym, "f") ? [Ge(this, Aa, "f")] : [];
  }
  get returnValue() {
    return !Ge(this, Cc, "f") || !Ge(this, Um, "f");
  }
  get bubbles() {
    return Ge(this, tv, "f");
  }
  get composed() {
    return Ge(this, ev, "f");
  }
  get eventPhase() {
    return Ge(this, Ym, "f") ? dr.AT_TARGET : dr.NONE;
  }
  get cancelBubble() {
    return Ge(this, Hm, "f");
  }
  set cancelBubble(t) {
    t && Nn(this, Hm, !0);
  }
  stopPropagation() {
    Nn(this, Hm, !0);
  }
  get isTrusted() {
    return !1;
  }
}, c(Lu, "U$1"), Lu), dt(A2, "Event"), A2), Cc = /* @__PURE__ */ new WeakMap(), tv = /* @__PURE__ */ new WeakMap(), ev = /* @__PURE__ */ new WeakMap(), Um = /* @__PURE__ */ new WeakMap(), M2 = /* @__PURE__ */ new WeakMap(), Hm = /* @__PURE__ */ new WeakMap(), iv = /* @__PURE__ */ new WeakMap(), Aa = /* @__PURE__ */ new WeakMap(), Ym = /* @__PURE__ */ new WeakMap(), dr.NONE = ZO, dr.CAPTURING_PHASE = F5, dr.AT_TARGET = FO, dr.BUBBLING_PHASE = X5, dr);
Object.defineProperties(fP.prototype, {
  initEvent: Nt,
  stopImmediatePropagation: Nt,
  preventDefault: Nt,
  target: Nt,
  currentTarget: Nt,
  srcElement: Nt,
  type: Nt,
  cancelable: Nt,
  defaultPrevented: Nt,
  timeStamp: Nt,
  composedPath: Nt,
  returnValue: Nt,
  bubbles: Nt,
  composed: Nt,
  eventPhase: Nt,
  cancelBubble: Nt,
  stopPropagation: Nt,
  isTrusted: Nt
});
var R2, Iu;
const u_ = (qQ = (R2 = (Iu = class extends fP {
  constructor(t, e = {}) {
    super(t, e), nv.set(this, void 0), Nn(this, nv, e?.detail ?? null);
  }
  initCustomEvent(t, e, i, s) {
    throw new Error("Method not implemented.");
  }
  get detail() {
    return Ge(this, nv, "f");
  }
}, c(Iu, "H$1"), Iu), dt(R2, "CustomEvent"), R2), nv = /* @__PURE__ */ new WeakMap(), qQ);
Object.defineProperties(u_.prototype, {
  detail: Nt
});
const dj = fP, uj = u_;
globalThis.Event ??= dj;
globalThis.CustomEvent ??= uj;
const FQ = /* @__PURE__ */ new WeakMap(), Gm = /* @__PURE__ */ dt((n) => {
  let t = FQ.get(n);
  return t === void 0 && FQ.set(n, t = /* @__PURE__ */ new Map()), t;
}, "attributesForElement");
var E2, Wu;
const pj = (E2 = (Wu = class extends hj {
  constructor() {
    super(...arguments), this.__shadowRootMode = null, this.__shadowRoot = null, this.__internals = null;
  }
  get attributes() {
    return Array.from(Gm(this)).map(([t, e]) => ({
      name: t,
      value: e
    }));
  }
  get shadowRoot() {
    return this.__shadowRootMode === "closed" ? null : this.__shadowRoot;
  }
  get localName() {
    return this.constructor.__localName;
  }
  get tagName() {
    return this.localName?.toUpperCase();
  }
  setAttribute(t, e) {
    Gm(this).set(t, String(e));
  }
  removeAttribute(t) {
    Gm(this).delete(t);
  }
  toggleAttribute(t, e) {
    if (this.hasAttribute(t)) {
      if (e === void 0 || !e)
        return this.removeAttribute(t), !1;
    } else
      return e === void 0 || e ? (this.setAttribute(t, ""), !0) : !1;
    return !0;
  }
  hasAttribute(t) {
    return Gm(this).has(t);
  }
  attachShadow(t) {
    const e = { host: this };
    return this.__shadowRootMode = t.mode, t && t.mode === "open" && (this.__shadowRoot = e), e;
  }
  attachInternals() {
    if (this.__internals !== null)
      throw new Error("Failed to execute 'attachInternals' on 'HTMLElement': ElementInternals for the specified element was already attached.");
    const t = new lj(this);
    return this.__internals = t, t;
  }
  getAttribute(t) {
    return Gm(this).get(t) ?? null;
  }
}, c(Wu, "I"), Wu), dt(E2, "Element"), E2);
var _2, Vu;
const fj = (_2 = (Vu = class extends pj {
}, c(Vu, "D"), Vu), dt(_2, "HTMLElement"), _2), p_ = fj;
globalThis.litServerRoot ??= Object.defineProperty(new p_(), "localName", {
  // Patch localName (and tagName) to return a unique name.
  get() {
    return "lit-server-root";
  }
});
function f_() {
  let n, t;
  return { promise: new Promise((e, i) => {
    n = e, t = i;
  }), resolve: n, reject: t };
}
c(f_, "Xt$1");
dt(f_, "promiseWithResolvers");
var Du;
const y_ = (Du = class {
  constructor() {
    this.__definitions = /* @__PURE__ */ new Map(), this.__reverseDefinitions = /* @__PURE__ */ new Map(), this.__pendingWhenDefineds = /* @__PURE__ */ new Map();
  }
  define(t, e) {
    if (this.__definitions.has(t))
      throw new Error(`Failed to execute 'define' on 'CustomElementRegistry': the name "${t}" has already been used with this registry`);
    if (this.__reverseDefinitions.has(e))
      throw new Error(`Failed to execute 'define' on 'CustomElementRegistry': the constructor has already been used with this registry for the tag name ${this.__reverseDefinitions.get(e)}`);
    e.__localName = t, this.__definitions.set(t, {
      ctor: e,
      // Note it's important we read `observedAttributes` in case it is a getter
      // with side-effects, as is the case in Lit, where it triggers class
      // finalization.
      //
      // TODO(aomarks) To be spec compliant, we should also capture the
      // registration-time lifecycle methods like `connectedCallback`. For them
      // to be actually accessible to e.g. the Lit SSR element renderer, though,
      // we'd need to introduce a new API for accessing them (since `get` only
      // returns the constructor).
      observedAttributes: e.observedAttributes ?? []
    }), this.__reverseDefinitions.set(e, t), this.__pendingWhenDefineds.get(t)?.resolve(e), this.__pendingWhenDefineds.delete(t);
  }
  get(t) {
    return this.__definitions.get(t)?.ctor;
  }
  getName(t) {
    return this.__reverseDefinitions.get(t) ?? null;
  }
  upgrade(t) {
    throw new Error("customElements.upgrade is not currently supported in SSR. Please file a bug if you need it.");
  }
  async whenDefined(t) {
    const e = this.__definitions.get(t);
    if (e)
      return e.ctor;
    let i = this.__pendingWhenDefineds.get(t);
    return i || (i = f_(), this.__pendingWhenDefineds.set(t, i)), i.promise;
  }
}, c(Du, "Fe"), Du);
dt(y_, "CustomElementRegistry");
let yj = y_;
const mj = yj, gj = new mj(), hw = globalThis, s0 = hw.ShadowRoot && (hw.ShadyCSS === void 0 || hw.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, yP = Symbol(), XQ = /* @__PURE__ */ new WeakMap();
var z2, qu;
let m_ = (z2 = (qu = class {
  constructor(t, e, i) {
    if (this._$cssResult$ = !0, i !== yP) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (s0 && t === void 0) {
      const i = e !== void 0 && e.length === 1;
      i && (t = XQ.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), i && XQ.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
}, c(qu, "j$1"), qu), dt(z2, "n"), z2);
const g_ = /* @__PURE__ */ dt((n) => new m_(typeof n == "string" ? n : n + "", void 0, yP), "r$2"), et = /* @__PURE__ */ dt((n, ...t) => {
  const e = n.length === 1 ? n[0] : t.reduce(((i, s, r) => i + ((a) => {
    if (a._$cssResult$ === !0) return a.cssText;
    if (typeof a == "number") return a;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + a + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s) + n[r + 1]), n[0]);
  return new m_(e, n, yP);
}, "i$2"), w_ = /* @__PURE__ */ dt((n, t) => {
  if (s0) n.adoptedStyleSheets = t.map(((e) => e instanceof CSSStyleSheet ? e : e.styleSheet));
  else for (const e of t) {
    const i = document.createElement("style"), s = hw.litNonce;
    s !== void 0 && i.setAttribute("nonce", s), i.textContent = e.cssText, n.appendChild(i);
  }
}, "S$1"), NQ = s0 || hw.CSSStyleSheet === void 0 ? (n) => n : (n) => n instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const i of t.cssRules) e += i.cssText;
  return g_(e);
})(n) : n, { is: wj, defineProperty: vj, getOwnPropertyDescriptor: Oj, getOwnPropertyNames: bj, getOwnPropertySymbols: $j, getPrototypeOf: xj } = Object, y1 = globalThis;
y1.customElements ??= gj;
const jQ = y1.trustedTypes, kj = jQ ? jQ.emptyScript : "", Sj = y1.reactiveElementPolyfillSupport, dw = /* @__PURE__ */ dt((n, t) => n, "f$1"), XO = { toAttribute(n, t) {
  switch (t) {
    case Boolean:
      n = n ? kj : null;
      break;
    case Object:
    case Array:
      n = n == null ? n : JSON.stringify(n);
  }
  return n;
}, fromAttribute(n, t) {
  let e = n;
  switch (t) {
    case Boolean:
      e = n !== null;
      break;
    case Number:
      e = n === null ? null : Number(n);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(n);
      } catch {
        e = null;
      }
  }
  return e;
} }, mP = /* @__PURE__ */ dt((n, t) => !wj(n, t), "m$1"), BQ = { attribute: !0, type: String, converter: XO, reflect: !1, useDefault: !1, hasChanged: mP };
Symbol.metadata ??= Symbol("metadata"), y1.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var L2, Zu;
let Vc = (L2 = (Zu = class extends (globalThis.HTMLElement ?? p_) {
  static addInitializer(t) {
    this._$Ei(), (this.l ??= []).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = BQ) {
    if (e.state && (e.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(t) && ((e = Object.create(e)).wrapped = !0), this.elementProperties.set(t, e), !e.noAccessor) {
      const i = Symbol(), s = this.getPropertyDescriptor(t, i, e);
      s !== void 0 && vj(this.prototype, t, s);
    }
  }
  static getPropertyDescriptor(t, e, i) {
    const { get: s, set: r } = Oj(this.prototype, t) ?? { get() {
      return this[e];
    }, set(a) {
      this[e] = a;
    } };
    return { get: s, set(a) {
      const o = s?.call(this);
      r?.call(this, a), this.requestUpdate(t, o, i);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? BQ;
  }
  static _$Ei() {
    if (this.hasOwnProperty(dw("elementProperties"))) return;
    const t = xj(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(dw("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(dw("properties"))) {
      const e = this.properties, i = [...bj(e), ...$j(e)];
      for (const s of i) this.createProperty(s, e[s]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0) for (const [i, s] of e) this.elementProperties.set(i, s);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, i] of this.elementProperties) {
      const s = this._$Eu(e, i);
      s !== void 0 && this._$Eh.set(s, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const i = new Set(t.flat(1 / 0).reverse());
      for (const s of i) e.unshift(NQ(s));
    } else t !== void 0 && e.push(NQ(t));
    return e;
  }
  static _$Eu(t, e) {
    const i = e.attribute;
    return i === !1 ? void 0 : typeof i == "string" ? i : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise(((t) => this.enableUpdating = t)), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach(((t) => t(this)));
  }
  addController(t) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t), this.renderRoot !== void 0 && this.isConnected && t.hostConnected?.();
  }
  removeController(t) {
    this._$EO?.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const i of e.keys()) this.hasOwnProperty(i) && (t.set(i, this[i]), delete this[i]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return w_(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(!0), this._$EO?.forEach(((t) => t.hostConnected?.()));
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    this._$EO?.forEach(((t) => t.hostDisconnected?.()));
  }
  attributeChangedCallback(t, e, i) {
    this._$AK(t, i);
  }
  _$ET(t, e) {
    const i = this.constructor.elementProperties.get(t), s = this.constructor._$Eu(t, i);
    if (s !== void 0 && i.reflect === !0) {
      const r = (i.converter?.toAttribute !== void 0 ? i.converter : XO).toAttribute(e, i.type);
      this._$Em = t, r == null ? this.removeAttribute(s) : this.setAttribute(s, r), this._$Em = null;
    }
  }
  _$AK(t, e) {
    const i = this.constructor, s = i._$Eh.get(t);
    if (s !== void 0 && this._$Em !== s) {
      const r = i.getPropertyOptions(s), a = typeof r.converter == "function" ? { fromAttribute: r.converter } : r.converter?.fromAttribute !== void 0 ? r.converter : XO;
      this._$Em = s;
      const o = a.fromAttribute(e, r.type);
      this[s] = o ?? this._$Ej?.get(s) ?? o, this._$Em = null;
    }
  }
  requestUpdate(t, e, i) {
    if (t !== void 0) {
      const s = this.constructor, r = this[t];
      if (i ??= s.getPropertyOptions(t), !((i.hasChanged ?? mP)(r, e) || i.useDefault && i.reflect && r === this._$Ej?.get(t) && !this.hasAttribute(s._$Eu(t, i)))) return;
      this.C(t, e, i);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$EP());
  }
  C(t, e, { useDefault: i, reflect: s, wrapped: r }, a) {
    i && !(this._$Ej ??= /* @__PURE__ */ new Map()).has(t) && (this._$Ej.set(t, a ?? e ?? this[t]), r !== !0 || a !== void 0) || (this._$AL.has(t) || (this.hasUpdated || i || (e = void 0), this._$AL.set(t, e)), s === !0 && this._$Em !== t && (this._$Eq ??= /* @__PURE__ */ new Set()).add(t));
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [s, r] of this._$Ep) this[s] = r;
        this._$Ep = void 0;
      }
      const i = this.constructor.elementProperties;
      if (i.size > 0) for (const [s, r] of i) {
        const { wrapped: a } = r, o = this[s];
        a !== !0 || this._$AL.has(s) || o === void 0 || this.C(s, void 0, r, o);
      }
    }
    let t = !1;
    const e = this._$AL;
    try {
      t = this.shouldUpdate(e), t ? (this.willUpdate(e), this._$EO?.forEach(((i) => i.hostUpdate?.())), this.update(e)) : this._$EM();
    } catch (i) {
      throw t = !1, this._$EM(), i;
    }
    t && this._$AE(e);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    this._$EO?.forEach(((e) => e.hostUpdated?.())), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$Eq &&= this._$Eq.forEach(((e) => this._$ET(e, this[e]))), this._$EM();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
}, c(Zu, "W"), Zu), dt(L2, "g"), L2);
Vc.elementStyles = [], Vc.shadowRootOptions = { mode: "open" }, Vc[dw("elementProperties")] = /* @__PURE__ */ new Map(), Vc[dw("finalized")] = /* @__PURE__ */ new Map(), Sj?.({ ReactiveElement: Vc }), (y1.reactiveElementVersions ??= []).push("2.1.1");
const r0 = globalThis, NO = r0.trustedTypes, UQ = NO ? NO.createPolicy("lit-html", { createHTML: /* @__PURE__ */ dt((n) => n, "createHTML") }) : void 0, v_ = "$lit$", Cr = `lit$${Math.random().toFixed(9).slice(2)}$`, O_ = "?" + Cr, Cj = `<${O_}>`, il = r0.document === void 0 ? { createTreeWalker: /* @__PURE__ */ dt(() => ({}), "createTreeWalker") } : document, Rw = /* @__PURE__ */ dt(() => il.createComment(""), "l"), Ew = /* @__PURE__ */ dt((n) => n === null || typeof n != "object" && typeof n != "function", "c"), gP = Array.isArray, Pj = /* @__PURE__ */ dt((n) => gP(n) || typeof n?.[Symbol.iterator] == "function", "u"), I2 = `[ 	
\f\r]`, Km = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, HQ = /-->/g, YQ = />/g, Ra = RegExp(`>|${I2}(?:([^\\s"'>=/]+)(${I2}*=${I2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), GQ = /'/g, KQ = /"/g, b_ = /^(?:script|style|textarea|title)$/i, $_ = /* @__PURE__ */ dt((n) => (t, ...e) => ({ _$litType$: n, strings: t, values: e }), "y"), v = $_(1), jO = $_(2), ls = Symbol.for("lit-noChange"), C = Symbol.for("lit-nothing"), JQ = /* @__PURE__ */ new WeakMap(), Ja = il.createTreeWalker(il, 129);
function wP(n, t) {
  if (!gP(n) || !n.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return UQ !== void 0 ? UQ.createHTML(t) : t;
}
c(wP, "Mt");
dt(wP, "P");
const Qj = /* @__PURE__ */ dt((n, t) => {
  const e = n.length - 1, i = [];
  let s, r = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", a = Km;
  for (let o = 0; o < e; o++) {
    const l = n[o];
    let h, u, p = -1, y = 0;
    for (; y < l.length && (a.lastIndex = y, u = a.exec(l), u !== null); ) y = a.lastIndex, a === Km ? u[1] === "!--" ? a = HQ : u[1] !== void 0 ? a = YQ : u[2] !== void 0 ? (b_.test(u[2]) && (s = RegExp("</" + u[2], "g")), a = Ra) : u[3] !== void 0 && (a = Ra) : a === Ra ? u[0] === ">" ? (a = s ?? Km, p = -1) : u[1] === void 0 ? p = -2 : (p = a.lastIndex - u[2].length, h = u[1], a = u[3] === void 0 ? Ra : u[3] === '"' ? KQ : GQ) : a === KQ || a === GQ ? a = Ra : a === HQ || a === YQ ? a = Km : (a = Ra, s = void 0);
    const m = a === Ra && n[o + 1].startsWith("/>") ? " " : "";
    r += a === Km ? l + Cj : p >= 0 ? (i.push(h), l.slice(0, p) + v_ + l.slice(p) + Cr + m) : l + Cr + (p === -2 ? o : m);
  }
  return [wP(n, r + (n[e] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), i];
}, "V");
var jo;
const x_ = (jo = class {
  constructor({ strings: t, _$litType$: e }, i) {
    let s;
    this.parts = [];
    let r = 0, a = 0;
    const o = t.length - 1, l = this.parts, [h, u] = Qj(t, e);
    if (this.el = jo.createElement(h, i), Ja.currentNode = this.el.content, e === 2 || e === 3) {
      const p = this.el.content.firstChild;
      p.replaceWith(...p.childNodes);
    }
    for (; (s = Ja.nextNode()) !== null && l.length < o; ) {
      if (s.nodeType === 1) {
        if (s.hasAttributes()) for (const p of s.getAttributeNames()) if (p.endsWith(v_)) {
          const y = u[a++], m = s.getAttribute(p).split(Cr), g = /([.?@])?(.*)/.exec(y);
          l.push({ type: 1, index: r, name: g[2], strings: m, ctor: g[1] === "." ? Mj : g[1] === "?" ? Aj : g[1] === "@" ? Rj : o0 }), s.removeAttribute(p);
        } else p.startsWith(Cr) && (l.push({ type: 6, index: r }), s.removeAttribute(p));
        if (b_.test(s.tagName)) {
          const p = s.textContent.split(Cr), y = p.length - 1;
          if (y > 0) {
            s.textContent = NO ? NO.emptyScript : "";
            for (let m = 0; m < y; m++) s.append(p[m], Rw()), Ja.nextNode(), l.push({ type: 2, index: ++r });
            s.append(p[y], Rw());
          }
        }
      } else if (s.nodeType === 8) if (s.data === O_) l.push({ type: 2, index: r });
      else {
        let p = -1;
        for (; (p = s.data.indexOf(Cr, p + 1)) !== -1; ) l.push({ type: 7, index: r }), p += Cr.length - 1;
      }
      r++;
    }
  }
  static createElement(t, e) {
    const i = il.createElement("template");
    return i.innerHTML = t, i;
  }
}, c(jo, "ge"), jo);
dt(x_, "N");
let N5 = x_;
function nl(n, t, e = n, i) {
  if (t === ls) return t;
  let s = i !== void 0 ? e._$Co?.[i] : e._$Cl;
  const r = Ew(t) ? void 0 : t._$litDirective$;
  return s?.constructor !== r && (s?._$AO?.(!1), r === void 0 ? s = void 0 : (s = new r(n), s._$AT(n, e, i)), i !== void 0 ? (e._$Co ??= [])[i] = s : e._$Cl = s), s !== void 0 && (t = nl(n, s._$AS(n, t.values), s, i)), t;
}
c(nl, "V");
dt(nl, "S");
var Fu;
const k_ = (Fu = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: i } = this._$AD, s = (t?.creationScope ?? il).importNode(e, !0);
    Ja.currentNode = s;
    let r = Ja.nextNode(), a = 0, o = 0, l = i[0];
    for (; l !== void 0; ) {
      if (a === l.index) {
        let h;
        l.type === 2 ? h = new a0(r, r.nextSibling, this, t) : l.type === 1 ? h = new l.ctor(r, l.name, l.strings, this, t) : l.type === 6 && (h = new Ej(r, this, t)), this._$AV.push(h), l = i[++o];
      }
      a !== l?.index && (r = Ja.nextNode(), a++);
    }
    return Ja.currentNode = il, s;
  }
  p(t) {
    let e = 0;
    for (const i of this._$AV) i !== void 0 && (i.strings !== void 0 ? (i._$AI(t, i, e), e += i.strings.length - 2) : i._$AI(t[e])), e++;
  }
}, c(Fu, "Ge"), Fu);
dt(k_, "M");
let Tj = k_;
var Bo;
const S_ = (Bo = class {
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(t, e, i, s) {
    this.type = 2, this._$AH = C, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = i, this.options = s, this._$Cv = s?.isConnected ?? !0;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && t?.nodeType === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = nl(this, t, e), Ew(t) ? t === C || t == null || t === "" ? (this._$AH !== C && this._$AR(), this._$AH = C) : t !== this._$AH && t !== ls && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : Pj(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== C && Ew(this._$AH) ? this._$AA.nextSibling.data = t : this.T(il.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    const { values: e, _$litType$: i } = t, s = typeof i == "number" ? this._$AC(t) : (i.el === void 0 && (i.el = N5.createElement(wP(i.h, i.h[0]), this.options)), i);
    if (this._$AH?._$AD === s) this._$AH.p(e);
    else {
      const r = new Tj(s, this), a = r.u(this.options);
      r.p(e), this.T(a), this._$AH = r;
    }
  }
  _$AC(t) {
    let e = JQ.get(t.strings);
    return e === void 0 && JQ.set(t.strings, e = new N5(t)), e;
  }
  k(t) {
    gP(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let i, s = 0;
    for (const r of t) s === e.length ? e.push(i = new Bo(this.O(Rw()), this.O(Rw()), this, this.options)) : i = e[s], i._$AI(r), s++;
    s < e.length && (this._$AR(i && i._$AB.nextSibling, s), e.length = s);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    for (this._$AP?.(!1, !0, e); t !== this._$AB; ) {
      const i = t.nextSibling;
      t.remove(), t = i;
    }
  }
  setConnected(t) {
    this._$AM === void 0 && (this._$Cv = t, this._$AP?.(t));
  }
}, c(Bo, "me"), Bo);
dt(S_, "k");
let a0 = S_;
var Xu;
const C_ = (Xu = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, i, s, r) {
    this.type = 1, this._$AH = C, this._$AN = void 0, this.element = t, this.name = e, this._$AM = s, this.options = r, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = C;
  }
  _$AI(t, e = this, i, s) {
    const r = this.strings;
    let a = !1;
    if (r === void 0) t = nl(this, t, e, 0), a = !Ew(t) || t !== this._$AH && t !== ls, a && (this._$AH = t);
    else {
      const o = t;
      let l, h;
      for (t = r[0], l = 0; l < r.length - 1; l++) h = nl(this, o[i + l], e, l), h === ls && (h = this._$AH[l]), a ||= !Ew(h) || h !== this._$AH[l], h === C ? t = C : t !== C && (t += (h ?? "") + r[l + 1]), this._$AH[l] = h;
    }
    a && !s && this.j(t);
  }
  j(t) {
    t === C ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}, c(Xu, "qe"), Xu);
dt(C_, "R");
let o0 = C_;
var Nu;
const P_ = (Nu = class extends o0 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === C ? void 0 : t;
  }
}, c(Nu, "Ke"), Nu);
dt(P_, "H");
let Mj = P_;
var ju;
const Q_ = (ju = class extends o0 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== C);
  }
}, c(ju, "Ze"), ju);
dt(Q_, "I");
let Aj = Q_;
var Bu;
const T_ = (Bu = class extends o0 {
  constructor(t, e, i, s, r) {
    super(t, e, i, s, r), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = nl(this, t, e, 0) ?? C) === ls) return;
    const i = this._$AH, s = t === C && i !== C || t.capture !== i.capture || t.once !== i.once || t.passive !== i.passive, r = t !== C && (i === C || s);
    s && this.element.removeEventListener(this.name, this, i), r && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    typeof this._$AH == "function" ? this._$AH.call(this.options?.host ?? this.element, t) : this._$AH.handleEvent(t);
  }
}, c(Bu, "Je"), Bu);
dt(T_, "L");
let Rj = T_;
var Uu;
const M_ = (Uu = class {
  constructor(t, e, i) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = i;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    nl(this, t);
  }
}, c(Uu, "Xe"), Uu);
dt(M_, "z");
let Ej = M_;
const _j = { I: a0 }, zj = r0.litHtmlPolyfillSupport;
zj?.(N5, a0), (r0.litHtmlVersions ??= []).push("3.3.1");
const Lj = /* @__PURE__ */ dt((n, t, e) => {
  const i = e?.renderBefore ?? t;
  let s = i._$litPart$;
  if (s === void 0) {
    const r = e?.renderBefore ?? null;
    i._$litPart$ = s = new a0(t.insertBefore(Rw(), r), r, void 0, e ?? {});
  }
  return s._$AI(n), s;
}, "j"), vP = globalThis;
var Hu;
const A_ = (Hu = class extends Vc {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    const t = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t.firstChild, t;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = Lj(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(!0);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(!1);
  }
  render() {
    return ls;
  }
}, c(Hu, "Qe"), Hu);
dt(A_, "i");
let pt = A_;
pt._$litElement$ = !0, pt.finalized = !0, vP.litElementHydrateSupport?.({ LitElement: pt });
const Ij = vP.litElementPolyfillSupport;
Ij?.({ LitElement: pt });
(vP.litElementVersions ??= []).push("4.2.1");
v`<strong>${0}</strong> redigerade <em>${1}</em>`, v`<strong>${0}</strong> nämnde dig i ett inlägg`, v`<strong>${0}</strong> kommenterade på <strong>${1}</strong>`, v`<strong>${0}</strong> reagerade med ${1} på <em>${2}</em>`, v`<strong>${0}</strong> svarade på ett inlägg`, v`<strong>${0}</strong> redigerade ett inlägg`, v`<strong>${0}</strong> nämnde dig i ett meddelande`, v`<strong>${0}</strong> nämnde dig i en kommentar`, v`<strong>${0}</strong> och <strong>${1}</strong> röstade i din omröstning`, v`<strong>${0}</strong> reagerade med ${1} på ditt inlägg`, v`<strong>${0}</strong> reagerade med ${1} på din kommentar`, v`Nytt meddelande från <strong>${0}</strong>`, v`<strong>${0}</strong> svarade på ditt inlägg`, v`<strong>${0}</strong> röstade i din omröstning`, v`<strong>${0}</strong> publicerade ett inlägg i <strong>${1}</strong>`, v`<strong>${0}</strong> gillade ditt meddelande`, v`<strong>${0}</strong>, <strong>${1}</strong> och <strong>${2}</strong> röstade i din omröstning`, v`<strong>${0}</strong> lade till <em>${1}</em> till <strong>${2}</strong>`, v`<strong>${0}</strong> skickade ett meddelande i <strong>${1}</strong>`, v`<strong>${0}</strong> reagerade med ${1} på ditt meddelande`, v`<strong>${0}</strong> gillade <em>${1}</em>`, v`<strong>${0}</strong> gillade ditt inlägg`, v`<strong>${0}</strong> gillade din kommentar`, v`<strong>${0}</strong> och ${1} andra röstade i din omröstning`, v`<strong>${0}</strong> kommenterade på <em>${1}</em>`, st`${0} svarade på ditt inlägg`, st`${0} röstade i din omröstning`, st`${0} skriver${1}`, st`${0} och ${1} röstade i din omröstning`, st`${0} kommenterade på ${1}`, st`${0} gillade ${1}`, st`${0} skickade ett meddelande i ${1}`, st`${0} redigerade ett inlägg`, st`Röster på ${0}`, st`${0} kommentarer`, st`Sedd av ${0} vid ${1}`, st`${0} och ${1} andra röstade i din omröstning`, st`Nytt meddelande från ${0}`, st`${0} reagerade med ${1} på ditt inlägg`, st`${0} nämnde dig i ett inlägg`, st`${0} nämnde dig i en kommentar`, st`${0} publicerade ett inlägg i ${1}`, st`${0} gillade ditt inlägg`, st`${0} nämnde dig i ett meddelande`, st`${0} reagerade med ${1} på din kommentar`, st`Öppna i ${0}`, st`${0} svarade på ett inlägg`, st`${0} lade till ${1} till ${2}`, st`${0} redigerade ${1}`, st`${0} gillade ditt meddelande`, st`${0}, ${1} och ${2} röstade i din omröstning`, st`Alternativ ${0}`, st`${0} reagerade med ${1} på ${2}`, st`${0} reagerade med ${1} på ditt meddelande`, st`${0} gillade din kommentar`, st`${0} skriver${1}`;
var Wj = Object.defineProperty, R_ = /* @__PURE__ */ c((n) => {
  throw TypeError(n);
}, "xw"), d = /* @__PURE__ */ c((n, t) => Wj(n, "name", { value: t, configurable: !0 }), "a"), OP = /* @__PURE__ */ c((n, t, e) => t.has(n) || R_("Cannot " + e), "Pp"), $ = /* @__PURE__ */ c((n, t, e) => (OP(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "y"), Z = /* @__PURE__ */ c((n, t, e) => t.has(n) ? R_("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "O"), _ = /* @__PURE__ */ c((n, t, e, i) => (OP(n, t, "write to private field"), t.set(n, e), e), "P"), vt = /* @__PURE__ */ c((n, t, e) => (OP(n, t, "access private method"), e), "st"), j5 = /* @__PURE__ */ c((n, t, e, i) => ({
  set _(s) {
    _(n, t, s);
  },
  get _() {
    return $(n, t, i);
  }
}), "kd");
function _w(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
c(_w, "Td");
d(_w, "isObject");
function Hs(n) {
  if (_w(n) === !1) return !1;
  const t = n.constructor;
  if (t === void 0) return !0;
  const e = t.prototype;
  return !(_w(e) === !1 || Object.prototype.hasOwnProperty.call(e, "isPrototypeOf") === !1);
}
c(Hs, "Sr");
d(Hs, "isPlainObject$1");
function BO(n) {
  return typeof n.toJSON == "function";
}
c(BO, "qp");
d(BO, "hasToJSON");
function E_(n) {
  return typeof n == "boolean" || typeof n == "number" || typeof n == "string" || n === null || Hs(n) || Array.isArray(n);
}
c(E_, "d1");
d(E_, "isJSONSerializable");
function no(n, t, e = !1) {
  n = n || {}, t = t || {};
  const i = {};
  for (const s in n)
    Object.prototype.hasOwnProperty.call(n, s) && (i[s] = n[s]);
  for (const s in t)
    Object.prototype.hasOwnProperty.call(t, s) && (e && i[s] && Hs(i[s]) && Hs(t[s]) ? i[s] = no(i[s], t[s], e) : i[s] = t[s]);
  return i;
}
c(no, "yn");
d(no, "assign");
function __(n) {
  return n ? Array.isArray(n) ? n : [n] : [];
}
c(__, "h1");
d(__, "asArray");
async function z_(n, t) {
  for (const e of n)
    if (await t(e))
      return e;
}
c(z_, "p1");
d(z_, "findAsyncSequential");
function so(n, t, e = !1, i = !1) {
  if (!i && (!Hs(n) || !Hs(t)) || i && (!_w(n) || !_w(t)))
    return !1;
  const s = Object.getOwnPropertyNames(n), r = Object.getOwnPropertyNames(t);
  if (!e && s.length !== r.length)
    return !1;
  for (let a = 0; a < s.length; a++) {
    const o = s[a], l = n[o], h = t[o];
    if (l !== h && !so(l, h, e))
      return !1;
  }
  return !0;
}
c(so, "wn");
d(so, "eqObjects");
function bP(n) {
  return Object.entries(n);
}
c(bP, "Df");
d(bP, "objectAsIterable");
function $P(n) {
  return n.charAt(0).toUpperCase() + n.substring(1).toLowerCase();
}
c($P, "Hf");
d($P, "toUpperCaseFirst");
const Vj = '\\s,.:;"', Dj = new RegExp(`^|[${Vj}]|$`, "g"), qj = ".!?", Zj = new RegExp(`^|(?<=[${qj}])|$`);
function xP(n) {
  return n.length > 0 ? n.replace(/([a-z\d])([A-Z]+)/g, "$1-$2").replace(/_|\s+/g, "-").toLowerCase() : n;
}
c(xP, "Vf");
d(xP, "toKebabCase");
function L_(n, t = 2) {
  if (!n)
    return null;
  let e = "";
  const i = n.split(Dj).filter((s) => s);
  return i.length == 1 ? e = i[0] : i.forEach((s) => {
    e += s.charAt(0);
  }), e.substring(0, t).toUpperCase();
}
c(L_, "m1");
d(L_, "getInitials");
function kP(n) {
  let t;
  const e = n.split(Zj).filter((i) => i);
  return e.length ? t = e[0] : t = n, t;
}
c(kP, "Uf");
d(kP, "getTitleFromText");
function SP(n, t = 256) {
  return n.length > t && (n = n.substring(0, t - 1) + "…"), n;
}
c(SP, "Bf");
d(SP, "truncateText");
const Fj = /^[\p{Extended_Pictographic}\p{Emoji_Presentation}]+$/u;
function I_(n) {
  return !!n?.match(Fj)?.length;
}
c(I_, "g1");
d(I_, "checkOnlyEmojis");
const Xj = {
  //mode: 'cors', // no-cors, *cors, same-origin
  // cache: 'default' means the server is in control of the caching which is preferred instead of using 'reload'
  //cache: 'default', // *default, no-cache, reload, force-cache, only-if-cached
  credentials: "omit",
  // include, *same-origin, omit
  headers: {
    // https://stackoverflow.com/questions/8163703/cross-domain-ajax-doesnt-send-x-requested-with-header
    "X-Requested-With": "XMLHttpRequest"
  },
  redirect: "manual"
  // manual, *follow, error
  //referrerPolicy: 'no-referrer-when-downgrade', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
};
function W_() {
  const n = /* @__PURE__ */ new WeakSet(), t = /* @__PURE__ */ d(function(e, i) {
    if (BO(i) && (i = i.toJSON()), !(i !== null && typeof i == "object"))
      return i;
    if (n.has(i))
      return "[Circular]";
    let s;
    if (n.add(i), Hs(i)) {
      const r = {};
      Object.keys(i).forEach((a) => {
        r[a] = t(a, i[a]);
      }), s = r;
    } else Array.isArray(i) && (s = i.map((r, a) => t(a, r)));
    return n.delete(i), s;
  }, "replacer");
  return t;
}
c(W_, "x1");
d(W_, "getCircularReferenceReplacer");
function sm() {
  return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
}
c(sm, "ol");
d(sm, "S4");
function V_(n) {
  if (n && n.ok && n.body) {
    const t = n.body.getReader();
    return new ReadableStream({
      start(e) {
        const i = /* @__PURE__ */ d(() => t.read().then(({ done: s, value: r }) => {
          if (s) {
            e.close();
            return;
          }
          return e.enqueue(r), i();
        }), "pump");
        return i();
      }
    });
  } else
    throw new Error("Could not parse text stream");
}
c(V_, "$1");
d(V_, "getTextStreamFromResponse");
function CP(n) {
  let t;
  try {
    if (t = window[n], t) {
      const e = "__storage_test__";
      t.setItem(e, e), t.removeItem(e);
    }
  } catch (e) {
    e instanceof DOMException && e.name === "QuotaExceededError" && // acknowledge QuotaExceededError only if there's something already stored
    t && t.length !== 0 && console.error("Storage not available:", n);
  }
  return t;
}
c(CP, "qf");
d(CP, "getStorage");
var Yu;
const D_ = (Yu = class extends Error {
  constructor() {
    super("Instance destroyed"), this.name = "DestroyError";
  }
}, c(Yu, "Ry"), Yu);
d(D_, "DestroyError");
let Ce = D_;
const Nj = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // AUTHENTICATION
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this._whenTokenFactory = new Promise((r) => {
        this._resolveTokenFactory = r;
      }), this._whenUrlAndTokenFactory = new Promise((r) => {
        this._resolveUrlAndTokenFactory = (a) => {
          r(a), this.configurationState = "configured";
        };
      }), this._whenTokenIsValid = new Promise((r) => {
        this._resolveTokenIsValid = r;
      }), this._tokenPromise = null, this._token = "", this._validTokenFromFactory = async (r = !1) => {
        const a = [this.whenTokenFactory()];
        this.tokenFactoryRetryDelay >= 0 && this.tokenFactoryRetryDelay < 1 / 0 && a.push(new Promise((l) => setTimeout(l, this.tokenFactoryRetryDelay))), await Promise.race(a);
        const o = await this.tokenFactory?.(r) ?? "";
        if (this._validateToken(o)) {
          if (r && o === this._token && this.tokenFactoryRetryDelay >= 0 && this.tokenFactoryRetryDelay < 1 / 0)
            return await new Promise((l) => setTimeout(l, this.tokenFactoryRetryDelay)), await this._validTokenFromFactory(!0);
        } else if (this._whenTokenFactory = new Promise((l) => {
          this._resolveTokenFactory = l;
        }), !r)
          return await this._validTokenFromFactory(!1);
        if (!o)
          throw new TypeError("Could not get a valid token from tokenFactory.");
        return this._resolveTokenFactory?.(!0), this.whenUrl().then(this._resolveUrlAndTokenFactory), o;
      }, Promise.all([this.whenUrl(), this.whenTokenFactory()]).then(() => {
        this.url && this.tokenFactory && this._resolveUrlAndTokenFactory?.(!0);
      });
    }
    async whenTokenFactory() {
      await this._whenTokenFactory;
    }
    async whenUrlAndTokenFactory() {
      await this._whenUrlAndTokenFactory;
    }
    async whenTokenIsValid() {
      await this._whenTokenIsValid;
    }
    /**
     * Async function returning an `access_token` string for _your_ authenticated user. A boolean `refresh` parameter is provided to let you now if a fresh token is needed from Weavy.
     */
    get tokenFactory() {
      return this._tokenFactory;
    }
    set tokenFactory(s) {
      if (this.isDestroyed)
        throw new Ce();
      this._tokenFactory && this._tokenFactory !== s && this.whenTokenFactory().then(() => {
        this.queryClient.refetchQueries({ stale: !0 });
      }), this._tokenFactory = s ?? void 0, this._tokenFactory && queueMicrotask(() => {
        this._resolveTokenFactory?.(!0);
      });
    }
    /**
     * An URL to an endpoint returning an JSON data containing an `access_token` string property for _your_ authenticated user. A boolean `refresh=true` query parameter is provided in the request to let you now if when a fresh token is needed from Weavy.
     */
    get tokenUrl() {
      return this._tokenUrl;
    }
    set tokenUrl(s) {
      if (this.isDestroyed)
        throw new Ce();
      try {
        if (typeof s == "string")
          s && (this._tokenUrl = new URL(s, window.location.toString()));
        else if (s instanceof URL)
          this._tokenUrl = s;
        else if (s == null)
          this._tokenUrl = void 0;
        else
          throw new Error();
      } catch (r) {
        throw new Error("Invalid url", r);
      }
      this._tokenUrl && !this.tokenFactory && (this.tokenFactory = async (r) => {
        if (!this.tokenUrl)
          throw new Error("tokenURL property is not valid");
        const a = new URL(this.tokenUrl);
        r ? a.searchParams.set("refresh", "true") : a.searchParams.delete("refresh");
        const o = await fetch(a);
        if (o.ok) {
          const l = await o.json();
          if (l.access_token === void 0)
            throw new Error("Token response does not contain required property: access_token");
          return l.access_token;
        } else
          throw new Error("Could not get access token from server!");
      });
    }
    _validateToken(s) {
      if (!s)
        return !1;
      if (typeof s != "string")
        throw new TypeError(`You have provided an invalid string access token of type ${typeof s}.`);
      if (typeof s == "string" && !s.startsWith("wyu_"))
        throw s.startsWith("wys_") ? new TypeError("You have provided an API key for authentication. Provide a user access token instead.") : new TypeError("You have provided an invalid string as access token.");
      return this._resolveTokenIsValid?.(s), !0;
    }
    async getToken(s = !1) {
      if (this.isDestroyed)
        throw new Ce();
      if (this._token && !s)
        return this._token;
      if (this._tokenPromise)
        return await this._tokenPromise;
      this._tokenPromise = new Promise((r, a) => {
        this._validTokenFromFactory(s).then(r).catch(a), this.tokenFactoryTimeout >= 0 && this.tokenFactoryTimeout < 1 / 0 && setTimeout(() => a(new Error("Token factory timeout.")), this.tokenFactoryTimeout), window.addEventListener("offline", () => a(new Error("Network changed.")), { once: !0 }), window.addEventListener("online", () => a(new Error("Network changed.")), { once: !0 });
      });
      try {
        const r = await this._tokenPromise;
        return this._tokenPromise = null, this._token = r, this._token;
      } catch (r) {
        throw this._tokenPromise = null, r;
      }
    }
  }, c(e, "t"), e), d(t, "WeavyAuthentication"), t;
}, "WeavyAuthenticationMixin");
var sv = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function q_(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
c(q_, "k1");
d(q_, "getDefaultExportFromCjs");
function _v(n) {
  throw new Error('Could not dynamically require "' + n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
c(_v, "Mp");
d(_v, "commonjsRequire");
var t9 = { exports: {} }, e9;
function Z_() {
  return e9 || (e9 = 1, (function(n, t) {
    var e;
    e = /* @__PURE__ */ d(() => (() => {
      var Bl, Ul, Hl, Yl, Gl, Kl, Jl, tc, ec, ic, nc, sc, Os, rc, ac, oc, lc, cc, bs, hc, dc, uc, pc, Qa, fc, yc, mc, gc, wc, vc, Oc, bc, Ta, $c, xc, kc;
      var i = { d: /* @__PURE__ */ d((B, w) => {
        for (var k in w) i.o(w, k) && !i.o(B, k) && Object.defineProperty(B, k, { enumerable: !0, get: w[k] });
      }, "d") };
      i.g = (function() {
        if (typeof globalThis == "object") return globalThis;
        try {
          return this || new Function("return this")();
        } catch {
          if (typeof window == "object") return window;
        }
      })(), i.o = (B, w) => Object.prototype.hasOwnProperty.call(B, w), i.r = (B) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(B, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(B, "t", { value: !0 });
      };
      var s, r = {};
      i.r(r), i.d(r, { AbortError: /* @__PURE__ */ d(() => p, "AbortError"), DefaultHttpClient: /* @__PURE__ */ d(() => r3, "DefaultHttpClient"), HttpClient: /* @__PURE__ */ d(() => J, "HttpClient"), HttpError: /* @__PURE__ */ d(() => o, "HttpError"), HttpResponse: /* @__PURE__ */ d(() => V, "HttpResponse"), HttpTransportType: /* @__PURE__ */ d(() => ke, "HttpTransportType"), HubConnection: /* @__PURE__ */ d(() => p3, "HubConnection"), HubConnectionBuilder: /* @__PURE__ */ d(() => fD, "HubConnectionBuilder"), HubConnectionState: /* @__PURE__ */ d(() => Kt, "HubConnectionState"), JsonHubProtocol: /* @__PURE__ */ d(() => P3, "JsonHubProtocol"), LogLevel: /* @__PURE__ */ d(() => s, "LogLevel"), MessageType: /* @__PURE__ */ d(() => Mt, "MessageType"), NullLogger: /* @__PURE__ */ d(() => at, "NullLogger"), Subject: /* @__PURE__ */ d(() => c3, "Subject"), TimeoutError: /* @__PURE__ */ d(() => h, "TimeoutError"), TransferFormat: /* @__PURE__ */ d(() => He, "TransferFormat"), VERSION: /* @__PURE__ */ d(() => G, "VERSION") });
      const a = (Bl = class extends Error {
        constructor(w, k) {
          const M = new.target.prototype;
          super(`${w}: Status code '${k}'`), this.statusCode = k, this.__proto__ = M;
        }
      }, c(Bl, "Kh"), Bl);
      d(a, "i");
      let o = a;
      const l = (Ul = class extends Error {
        constructor(w = "A timeout occurred.") {
          const k = new.target.prototype;
          super(w), this.__proto__ = k;
        }
      }, c(Ul, "Gh"), Ul);
      d(l, "n");
      let h = l;
      const u = (Hl = class extends Error {
        constructor(w = "An abort occurred.") {
          const k = new.target.prototype;
          super(w), this.__proto__ = k;
        }
      }, c(Hl, "Zh"), Hl);
      d(u, "r");
      let p = u;
      const y = (Yl = class extends Error {
        constructor(w, k) {
          const M = new.target.prototype;
          super(w), this.transport = k, this.errorType = "UnsupportedTransportError", this.__proto__ = M;
        }
      }, c(Yl, "Yh"), Yl);
      d(y, "o");
      let m = y;
      const g = (Gl = class extends Error {
        constructor(w, k) {
          const M = new.target.prototype;
          super(w), this.transport = k, this.errorType = "DisabledTransportError", this.__proto__ = M;
        }
      }, c(Gl, "Xh"), Gl);
      d(g, "h");
      let b = g;
      const S = (Kl = class extends Error {
        constructor(w, k) {
          const M = new.target.prototype;
          super(w), this.transport = k, this.errorType = "FailedToStartTransportError", this.__proto__ = M;
        }
      }, c(Kl, "Jh"), Kl);
      d(S, "c");
      let x = S;
      const Q = (Jl = class extends Error {
        constructor(w) {
          const k = new.target.prototype;
          super(w), this.errorType = "FailedToNegotiateWithServerError", this.__proto__ = k;
        }
      }, c(Jl, "tp"), Jl);
      d(Q, "a");
      let L = Q;
      const W = (tc = class extends Error {
        constructor(w, k) {
          const M = new.target.prototype;
          super(w), this.innerErrors = k, this.__proto__ = M;
        }
      }, c(tc, "ep"), tc);
      d(W, "l");
      let R = W;
      const I = (ec = class {
        constructor(w, k, M) {
          this.statusCode = w, this.statusText = k, this.content = M;
        }
      }, c(ec, "ip"), ec);
      d(I, "u");
      let V = I;
      const X = (ic = class {
        get(w, k) {
          return this.send({ ...k, method: "GET", url: w });
        }
        post(w, k) {
          return this.send({ ...k, method: "POST", url: w });
        }
        delete(w, k) {
          return this.send({ ...k, method: "DELETE", url: w });
        }
        getCookieString(w) {
          return "";
        }
      }, c(ic, "rp"), ic);
      d(X, "d");
      let J = X;
      (function(B) {
        B[B.Trace = 0] = "Trace", B[B.Debug = 1] = "Debug", B[B.Information = 2] = "Information", B[B.Warning = 3] = "Warning", B[B.Error = 4] = "Error", B[B.Critical = 5] = "Critical", B[B.None = 6] = "None";
      })(s || (s = {}));
      const mt = (nc = class {
        constructor() {
        }
        log(w, k) {
        }
      }, c(nc, "sp"), nc);
      d(mt, "f");
      let at = mt;
      at.instance = new at();
      const G = "9.0.6", $t = (sc = class {
        static isRequired(w, k) {
          if (w == null) throw new Error(`The '${k}' argument is required.`);
        }
        static isNotEmpty(w, k) {
          if (!w || w.match(/^\s*$/)) throw new Error(`The '${k}' argument should not be empty.`);
        }
        static isIn(w, k, M) {
          if (!(w in k)) throw new Error(`Unknown ${M} value: ${w}.`);
        }
      }, c(sc, "np"), sc);
      d($t, "w");
      let rt = $t;
      const Rt = (Os = class {
        static get isBrowser() {
          return !Os.isNode && typeof window == "object" && typeof window.document == "object";
        }
        static get isWebWorker() {
          return !Os.isNode && typeof self == "object" && "importScripts" in self;
        }
        static get isReactNative() {
          return !Os.isNode && typeof window == "object" && window.document === void 0;
        }
        static get isNode() {
          return typeof process < "u" && process.release && process.release.name === "node";
        }
      }, c(Os, "Ys"), Os);
      d(Rt, "g");
      let Qt = Rt;
      function It(B, w) {
        let k = "";
        return Vt(B) ? (k = `Binary data of length ${B.byteLength}`, w && (k += `. Content: '${(function(M) {
          const E = new Uint8Array(M);
          let D = "";
          return E.forEach(((q) => {
            D += `0x${q < 16 ? "0" : ""}${q.toString(16)} `;
          })), D.substr(0, D.length - 1);
        })(B)}'`)) : typeof B == "string" && (k = `String data of length ${B.length}`, w && (k += `. Content: '${B}'`)), k;
      }
      c(It, "q"), d(It, "m");
      function Vt(B) {
        return B && typeof ArrayBuffer < "u" && (B instanceof ArrayBuffer || B.constructor && B.constructor.name === "ArrayBuffer");
      }
      c(Vt, "R"), d(Vt, "y");
      async function Dt(B, w, k, M, E, D) {
        const q = {}, [lt, ct] = fe();
        q[lt] = ct, B.log(s.Trace, `(${w} transport) sending data. ${It(E, D.logMessageContent)}.`);
        const At = Vt(E) ? "arraybuffer" : "text", Ht = await k.post(M, { content: E, headers: { ...q, ...D.headers }, responseType: At, timeout: D.timeout, withCredentials: D.withCredentials });
        B.log(s.Trace, `(${w} transport) request complete. Response status: ${Ht.statusCode}.`);
      }
      c(Dt, "V"), d(Dt, "b");
      const xi = (rc = class {
        constructor(w, k) {
          this.i = w, this.h = k;
        }
        dispose() {
          const w = this.i.observers.indexOf(this.h);
          w > -1 && this.i.observers.splice(w, 1), this.i.observers.length === 0 && this.i.cancelCallback && this.i.cancelCallback().catch(((k) => {
          }));
        }
      }, c(rc, "ap"), rc);
      d(xi, "v");
      let _e = xi;
      const oe = (ac = class {
        constructor(w) {
          this.l = w, this.out = console;
        }
        log(w, k) {
          if (w >= this.l) {
            const M = `[${(/* @__PURE__ */ new Date()).toISOString()}] ${s[w]}: ${k}`;
            switch (w) {
              case s.Critical:
              case s.Error:
                this.out.error(M);
                break;
              case s.Warning:
                this.out.warn(M);
                break;
              case s.Information:
                this.out.info(M);
                break;
              default:
                this.out.log(M);
            }
          }
        }
      }, c(ac, "op"), ac);
      d(oe, "E");
      let te = oe;
      function fe() {
        let B = "X-SignalR-User-Agent";
        return Qt.isNode && (B = "User-Agent"), [B, ki(G, Vi(), Qt.isNode ? "NodeJS" : "Browser", nn())];
      }
      c(fe, "it"), d(fe, "$");
      function ki(B, w, k, M) {
        let E = "Microsoft SignalR/";
        const D = B.split(".");
        return E += `${D[0]}.${D[1]}`, E += ` (${B}; `, E += w && w !== "" ? `${w}; ` : "Unknown OS; ", E += `${k}`, E += M ? `; ${M}` : "; Unknown Runtime Version", E += ")", E;
      }
      c(ki, "J"), d(ki, "C");
      function Vi() {
        if (!Qt.isNode) return "";
        switch (process.platform) {
          case "win32":
            return "Windows NT";
          case "darwin":
            return "macOS";
          case "linux":
            return "Linux";
          default:
            return process.platform;
        }
      }
      c(Vi, "Pt"), d(Vi, "S");
      function nn() {
        if (Qt.isNode) return process.versions.node;
      }
      c(nn, "Mt"), d(nn, "k");
      function Ut(B) {
        return B.stack ? B.stack : B.message ? B.message : `${B}`;
      }
      c(Ut, "wt"), d(Ut, "P");
      const vn = (oc = class extends J {
        constructor(w) {
          if (super(), this.u = w, typeof fetch > "u" || Qt.isNode) {
            const k = _v;
            this.p = new (k("tough-cookie")).CookieJar(), typeof fetch > "u" ? this.m = k("node-fetch") : this.m = fetch, this.m = k("fetch-cookie")(this.m, this.p);
          } else this.m = fetch.bind((function() {
            if (typeof globalThis < "u") return globalThis;
            if (typeof self < "u") return self;
            if (typeof window < "u") return window;
            if (i.g !== void 0) return i.g;
            throw new Error("could not find global");
          })());
          if (typeof AbortController > "u") {
            const k = _v;
            this.v = k("abort-controller");
          } else this.v = AbortController;
        }
        async send(w) {
          if (w.abortSignal && w.abortSignal.aborted) throw new p();
          if (!w.method) throw new Error("No method defined.");
          if (!w.url) throw new Error("No url defined.");
          const k = new this.v();
          let M;
          w.abortSignal && (w.abortSignal.onabort = () => {
            k.abort(), M = new p();
          });
          let E, D = null;
          if (w.timeout) {
            const ct = w.timeout;
            D = setTimeout((() => {
              k.abort(), this.u.log(s.Warning, "Timeout from HTTP request."), M = new h();
            }), ct);
          }
          w.content === "" && (w.content = void 0), w.content && (w.headers = w.headers || {}, Vt(w.content) ? w.headers["Content-Type"] = "application/octet-stream" : w.headers["Content-Type"] = "text/plain;charset=UTF-8");
          try {
            E = await this.m(w.url, { body: w.content, cache: "no-cache", credentials: w.withCredentials === !0 ? "include" : "same-origin", headers: { "X-Requested-With": "XMLHttpRequest", ...w.headers }, method: w.method, mode: "cors", redirect: "follow", signal: k.signal });
          } catch (ct) {
            throw M || (this.u.log(s.Warning, `Error from HTTP request. ${ct}.`), ct);
          } finally {
            D && clearTimeout(D), w.abortSignal && (w.abortSignal.onabort = null);
          }
          if (!E.ok) {
            const ct = await jl(E, "text");
            throw new o(ct || E.statusText, E.status);
          }
          const q = jl(E, w.responseType), lt = await q;
          return new V(E.status, E.statusText, lt);
        }
        getCookieString(w) {
          let k = "";
          return Qt.isNode && this.p && this.p.getCookies(w, ((M, E) => k = E.join("; "))), k;
        }
      }, c(oc, "cp"), oc);
      d(vn, "T");
      let Ca = vn;
      function jl(B, w) {
        let k;
        switch (w) {
          case "arraybuffer":
            k = B.arrayBuffer();
            break;
          case "text":
          default:
            k = B.text();
            break;
          case "blob":
          case "document":
          case "json":
            throw new Error(`${w} is not supported.`);
        }
        return k;
      }
      c(jl, "Ot"), d(jl, "I");
      const n3 = (lc = class extends J {
        constructor(w) {
          super(), this.u = w;
        }
        send(w) {
          return w.abortSignal && w.abortSignal.aborted ? Promise.reject(new p()) : w.method ? w.url ? new Promise(((k, M) => {
            const E = new XMLHttpRequest();
            E.open(w.method, w.url, !0), E.withCredentials = w.withCredentials === void 0 || w.withCredentials, E.setRequestHeader("X-Requested-With", "XMLHttpRequest"), w.content === "" && (w.content = void 0), w.content && (Vt(w.content) ? E.setRequestHeader("Content-Type", "application/octet-stream") : E.setRequestHeader("Content-Type", "text/plain;charset=UTF-8"));
            const D = w.headers;
            D && Object.keys(D).forEach(((q) => {
              E.setRequestHeader(q, D[q]);
            })), w.responseType && (E.responseType = w.responseType), w.abortSignal && (w.abortSignal.onabort = () => {
              E.abort(), M(new p());
            }), w.timeout && (E.timeout = w.timeout), E.onload = () => {
              w.abortSignal && (w.abortSignal.onabort = null), E.status >= 200 && E.status < 300 ? k(new V(E.status, E.statusText, E.response || E.responseText)) : M(new o(E.response || E.responseText || E.statusText, E.status));
            }, E.onerror = () => {
              this.u.log(s.Warning, `Error from HTTP request. ${E.status}: ${E.statusText}.`), M(new o(E.statusText, E.status));
            }, E.ontimeout = () => {
              this.u.log(s.Warning, "Timeout from HTTP request."), M(new h());
            }, E.send(w.content);
          })) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."));
        }
      }, c(lc, "lp"), lc);
      d(n3, "_");
      let iD = n3;
      const s3 = (cc = class extends J {
        constructor(w) {
          if (super(), typeof fetch < "u" || Qt.isNode) this.$ = new Ca(w);
          else {
            if (typeof XMLHttpRequest > "u") throw new Error("No usable HttpClient found.");
            this.$ = new iD(w);
          }
        }
        send(w) {
          return w.abortSignal && w.abortSignal.aborted ? Promise.reject(new p()) : w.method ? w.url ? this.$.send(w) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."));
        }
        getCookieString(w) {
          return this.$.getCookieString(w);
        }
      }, c(cc, "dp"), cc);
      d(s3, "H");
      let r3 = s3;
      const a3 = (bs = class {
        static write(w) {
          return `${w}${bs.RecordSeparator}`;
        }
        static parse(w) {
          if (w[w.length - 1] !== bs.RecordSeparator) throw new Error("Message is incomplete.");
          const k = w.split(bs.RecordSeparator);
          return k.pop(), k;
        }
      }, c(bs, "Xs"), bs);
      d(a3, "D");
      let vs = a3;
      vs.RecordSeparatorCode = 30, vs.RecordSeparator = String.fromCharCode(vs.RecordSeparatorCode);
      const o3 = (hc = class {
        writeHandshakeRequest(w) {
          return vs.write(JSON.stringify(w));
        }
        parseHandshakeResponse(w) {
          let k, M;
          if (Vt(w)) {
            const q = new Uint8Array(w), lt = q.indexOf(vs.RecordSeparatorCode);
            if (lt === -1) throw new Error("Message is incomplete.");
            const ct = lt + 1;
            k = String.fromCharCode.apply(null, Array.prototype.slice.call(q.slice(0, ct))), M = q.byteLength > ct ? q.slice(ct).buffer : null;
          } else {
            const q = w, lt = q.indexOf(vs.RecordSeparator);
            if (lt === -1) throw new Error("Message is incomplete.");
            const ct = lt + 1;
            k = q.substring(0, ct), M = q.length > ct ? q.substring(ct) : null;
          }
          const E = vs.parse(k), D = JSON.parse(E[0]);
          if (D.type) throw new Error("Expected a handshake response from the server.");
          return [M, D];
        }
      }, c(hc, "hp"), hc);
      d(o3, "R");
      let nD = o3;
      var Mt, Kt;
      (function(B) {
        B[B.Invocation = 1] = "Invocation", B[B.StreamItem = 2] = "StreamItem", B[B.Completion = 3] = "Completion", B[B.StreamInvocation = 4] = "StreamInvocation", B[B.CancelInvocation = 5] = "CancelInvocation", B[B.Ping = 6] = "Ping", B[B.Close = 7] = "Close", B[B.Ack = 8] = "Ack", B[B.Sequence = 9] = "Sequence";
      })(Mt || (Mt = {}));
      const l3 = (dc = class {
        constructor() {
          this.observers = [];
        }
        next(w) {
          for (const k of this.observers) k.next(w);
        }
        error(w) {
          for (const k of this.observers) k.error && k.error(w);
        }
        complete() {
          for (const w of this.observers) w.complete && w.complete();
        }
        subscribe(w) {
          return this.observers.push(w), new _e(this, w);
        }
      }, c(dc, "pp"), dc);
      d(l3, "U");
      let c3 = l3;
      const h3 = (uc = class {
        constructor(w, k, M) {
          this.C = 1e5, this.S = [], this.k = 0, this.P = !1, this.T = 1, this.I = 0, this._ = 0, this.H = !1, this.D = w, this.R = k, this.C = M;
        }
        async A(w) {
          const k = this.D.writeMessage(w);
          let M = Promise.resolve();
          if (this.U(w)) {
            this.k++;
            let E = /* @__PURE__ */ d(() => {
            }, "t"), D = /* @__PURE__ */ d(() => {
            }, "i");
            Vt(k) ? this._ += k.byteLength : this._ += k.length, this._ >= this.C && (M = new Promise(((q, lt) => {
              E = q, D = lt;
            }))), this.S.push(new rD(k, this.k, E, D));
          }
          try {
            this.H || await this.R.send(k);
          } catch {
            this.L();
          }
          await M;
        }
        N(w) {
          let k = -1;
          for (let M = 0; M < this.S.length; M++) {
            const E = this.S[M];
            if (E.q <= w.sequenceId) k = M, Vt(E.M) ? this._ -= E.M.byteLength : this._ -= E.M.length, E.j();
            else {
              if (!(this._ < this.C)) break;
              E.j();
            }
          }
          k !== -1 && (this.S = this.S.slice(k + 1));
        }
        W(w) {
          if (this.P) return w.type === Mt.Sequence && (this.P = !1, !0);
          if (!this.U(w)) return !0;
          const k = this.T;
          return this.T++, k <= this.I ? (k === this.I && this.O(), !1) : (this.I = k, this.O(), !0);
        }
        F(w) {
          w.sequenceId > this.T ? this.R.stop(new Error("Sequence ID greater than amount of messages we've received.")) : this.T = w.sequenceId;
        }
        L() {
          this.H = !0, this.P = !0;
        }
        async B() {
          const w = this.S.length !== 0 ? this.S[0].q : this.k + 1;
          await this.R.send(this.D.writeMessage({ type: Mt.Sequence, sequenceId: w }));
          const k = this.S;
          for (const M of k) await this.R.send(M.M);
          this.H = !1;
        }
        X(w) {
          w != null || (w = new Error("Unable to reconnect to server."));
          for (const k of this.S) k.J(w);
        }
        U(w) {
          switch (w.type) {
            case Mt.Invocation:
            case Mt.StreamItem:
            case Mt.Completion:
            case Mt.StreamInvocation:
            case Mt.CancelInvocation:
              return !0;
            case Mt.Close:
            case Mt.Sequence:
            case Mt.Ping:
            case Mt.Ack:
              return !1;
          }
        }
        O() {
          this.V === void 0 && (this.V = setTimeout((async () => {
            try {
              this.H || await this.R.send(this.D.writeMessage({ type: Mt.Ack, sequenceId: this.I }));
            } catch {
            }
            clearTimeout(this.V), this.V = void 0;
          }), 1e3));
        }
      }, c(uc, "up"), uc);
      d(h3, "L");
      let sD = h3;
      const d3 = (pc = class {
        constructor(w, k, M, E) {
          this.M = w, this.q = k, this.j = M, this.J = E;
        }
      }, c(pc, "yp"), pc);
      d(d3, "N");
      let rD = d3;
      (function(B) {
        B.Disconnected = "Disconnected", B.Connecting = "Connecting", B.Connected = "Connected", B.Disconnecting = "Disconnecting", B.Reconnecting = "Reconnecting";
      })(Kt || (Kt = {}));
      const u3 = (Qa = class {
        static create(w, k, M, E, D, q, lt) {
          return new Qa(w, k, M, E, D, q, lt);
        }
        constructor(w, k, M, E, D, q, lt) {
          this.K = 0, this.G = () => {
            this.u.log(s.Warning, "The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep");
          }, rt.isRequired(w, "connection"), rt.isRequired(k, "logger"), rt.isRequired(M, "protocol"), this.serverTimeoutInMilliseconds = D ?? 3e4, this.keepAliveIntervalInMilliseconds = q ?? 15e3, this.Y = lt ?? 1e5, this.u = k, this.D = M, this.connection = w, this.Z = E, this.tt = new nD(), this.connection.onreceive = (ct) => this.et(ct), this.connection.onclose = (ct) => this.st(ct), this.it = {}, this.nt = {}, this.rt = [], this.ot = [], this.ht = [], this.ct = 0, this.lt = !1, this.ut = Kt.Disconnected, this.dt = !1, this.ft = this.D.writeMessage({ type: Mt.Ping });
        }
        get state() {
          return this.ut;
        }
        get connectionId() {
          return this.connection && this.connection.connectionId || null;
        }
        get baseUrl() {
          return this.connection.baseUrl || "";
        }
        set baseUrl(w) {
          if (this.ut !== Kt.Disconnected && this.ut !== Kt.Reconnecting) throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");
          if (!w) throw new Error("The HubConnection url must be a valid url.");
          this.connection.baseUrl = w;
        }
        start() {
          return this.wt = this.gt(), this.wt;
        }
        async gt() {
          if (this.ut !== Kt.Disconnected) return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));
          this.ut = Kt.Connecting, this.u.log(s.Debug, "Starting HubConnection.");
          try {
            await this.yt(), Qt.isBrowser && window.document.addEventListener("freeze", this.G), this.ut = Kt.Connected, this.dt = !0, this.u.log(s.Debug, "HubConnection connected successfully.");
          } catch (w) {
            return this.ut = Kt.Disconnected, this.u.log(s.Debug, `HubConnection failed to start successfully because of error '${w}'.`), Promise.reject(w);
          }
        }
        async yt() {
          this.bt = void 0, this.lt = !1;
          const w = new Promise(((k, M) => {
            this.vt = k, this.Et = M;
          }));
          await this.connection.start(this.D.transferFormat);
          try {
            let k = this.D.version;
            this.connection.features.reconnect || (k = 1);
            const M = { protocol: this.D.name, version: k };
            if (this.u.log(s.Debug, "Sending handshake request."), await this.$t(this.tt.writeHandshakeRequest(M)), this.u.log(s.Information, `Using HubProtocol '${this.D.name}'.`), this.Ct(), this.St(), this.kt(), await w, this.bt) throw this.bt;
            this.connection.features.reconnect && (this.Pt = new sD(this.D, this.connection, this.Y), this.connection.features.disconnected = this.Pt.L.bind(this.Pt), this.connection.features.resend = () => {
              if (this.Pt) return this.Pt.B();
            }), this.connection.features.inherentKeepAlive || await this.$t(this.ft);
          } catch (k) {
            throw this.u.log(s.Debug, `Hub handshake failed with error '${k}' during start(). Stopping HubConnection.`), this.Ct(), this.Tt(), await this.connection.stop(k), k;
          }
        }
        async stop() {
          const w = this.wt;
          this.connection.features.reconnect = !1, this.It = this._t(), await this.It;
          try {
            await w;
          } catch {
          }
        }
        _t(w) {
          if (this.ut === Kt.Disconnected) return this.u.log(s.Debug, `Call to HubConnection.stop(${w}) ignored because it is already in the disconnected state.`), Promise.resolve();
          if (this.ut === Kt.Disconnecting) return this.u.log(s.Debug, `Call to HttpConnection.stop(${w}) ignored because the connection is already in the disconnecting state.`), this.It;
          const k = this.ut;
          return this.ut = Kt.Disconnecting, this.u.log(s.Debug, "Stopping HubConnection."), this.Ht ? (this.u.log(s.Debug, "Connection stopped during reconnect delay. Done reconnecting."), clearTimeout(this.Ht), this.Ht = void 0, this.Dt(), Promise.resolve()) : (k === Kt.Connected && this.Rt(), this.Ct(), this.Tt(), this.bt = w || new p("The connection was stopped before the hub handshake could complete."), this.connection.stop(w));
        }
        async Rt() {
          try {
            await this.xt(this.At());
          } catch {
          }
        }
        stream(w, ...k) {
          const [M, E] = this.Ut(k), D = this.Lt(w, k, E);
          let q;
          const lt = new c3();
          return lt.cancelCallback = () => {
            const ct = this.Nt(D.invocationId);
            return delete this.it[D.invocationId], q.then((() => this.xt(ct)));
          }, this.it[D.invocationId] = (ct, At) => {
            At ? lt.error(At) : ct && (ct.type === Mt.Completion ? ct.error ? lt.error(new Error(ct.error)) : lt.complete() : lt.next(ct.item));
          }, q = this.xt(D).catch(((ct) => {
            lt.error(ct), delete this.it[D.invocationId];
          })), this.qt(M, q), lt;
        }
        $t(w) {
          return this.kt(), this.connection.send(w);
        }
        xt(w) {
          return this.Pt ? this.Pt.A(w) : this.$t(this.D.writeMessage(w));
        }
        send(w, ...k) {
          const [M, E] = this.Ut(k), D = this.xt(this.Mt(w, k, !0, E));
          return this.qt(M, D), D;
        }
        invoke(w, ...k) {
          const [M, E] = this.Ut(k), D = this.Mt(w, k, !1, E);
          return new Promise(((q, lt) => {
            this.it[D.invocationId] = (At, Ht) => {
              Ht ? lt(Ht) : At && (At.type === Mt.Completion ? At.error ? lt(new Error(At.error)) : q(At.result) : lt(new Error(`Unexpected message type: ${At.type}`)));
            };
            const ct = this.xt(D).catch(((At) => {
              lt(At), delete this.it[D.invocationId];
            }));
            this.qt(M, ct);
          }));
        }
        on(w, k) {
          w && k && (w = w.toLowerCase(), this.nt[w] || (this.nt[w] = []), this.nt[w].indexOf(k) === -1 && this.nt[w].push(k));
        }
        off(w, k) {
          if (!w) return;
          w = w.toLowerCase();
          const M = this.nt[w];
          if (M) if (k) {
            const E = M.indexOf(k);
            E !== -1 && (M.splice(E, 1), M.length === 0 && delete this.nt[w]);
          } else delete this.nt[w];
        }
        onclose(w) {
          w && this.rt.push(w);
        }
        onreconnecting(w) {
          w && this.ot.push(w);
        }
        onreconnected(w) {
          w && this.ht.push(w);
        }
        et(w) {
          if (this.Ct(), this.lt || (w = this.jt(w), this.lt = !0), w) {
            const k = this.D.parseMessages(w, this.u);
            for (const M of k) if (!this.Pt || this.Pt.W(M)) switch (M.type) {
              case Mt.Invocation:
                this.Wt(M).catch(((E) => {
                  this.u.log(s.Error, `Invoke client method threw error: ${Ut(E)}`);
                }));
                break;
              case Mt.StreamItem:
              case Mt.Completion: {
                const E = this.it[M.invocationId];
                if (E) {
                  M.type === Mt.Completion && delete this.it[M.invocationId];
                  try {
                    E(M);
                  } catch (D) {
                    this.u.log(s.Error, `Stream callback threw error: ${Ut(D)}`);
                  }
                }
                break;
              }
              case Mt.Ping:
                break;
              case Mt.Close: {
                this.u.log(s.Information, "Close message received from server.");
                const E = M.error ? new Error("Server returned an error on close: " + M.error) : void 0;
                M.allowReconnect === !0 ? this.connection.stop(E) : this.It = this._t(E);
                break;
              }
              case Mt.Ack:
                this.Pt && this.Pt.N(M);
                break;
              case Mt.Sequence:
                this.Pt && this.Pt.F(M);
                break;
              default:
                this.u.log(s.Warning, `Invalid message type: ${M.type}.`);
            }
          }
          this.St();
        }
        jt(w) {
          let k, M;
          try {
            [M, k] = this.tt.parseHandshakeResponse(w);
          } catch (E) {
            const D = "Error parsing handshake response: " + E;
            this.u.log(s.Error, D);
            const q = new Error(D);
            throw this.Et(q), q;
          }
          if (k.error) {
            const E = "Server returned handshake error: " + k.error;
            this.u.log(s.Error, E);
            const D = new Error(E);
            throw this.Et(D), D;
          }
          return this.u.log(s.Debug, "Server handshake complete."), this.vt(), M;
        }
        kt() {
          this.connection.features.inherentKeepAlive || (this.K = (/* @__PURE__ */ new Date()).getTime() + this.keepAliveIntervalInMilliseconds, this.Tt());
        }
        St() {
          if (!(this.connection.features && this.connection.features.inherentKeepAlive || (this.Ot = setTimeout((() => this.serverTimeout()), this.serverTimeoutInMilliseconds), this.Ft !== void 0))) {
            let w = this.K - (/* @__PURE__ */ new Date()).getTime();
            w < 0 && (w = 0), this.Ft = setTimeout((async () => {
              if (this.ut === Kt.Connected) try {
                await this.$t(this.ft);
              } catch {
                this.Tt();
              }
            }), w);
          }
        }
        serverTimeout() {
          this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."));
        }
        async Wt(w) {
          const k = w.target.toLowerCase(), M = this.nt[k];
          if (!M) return this.u.log(s.Warning, `No client method with the name '${k}' found.`), void (w.invocationId && (this.u.log(s.Warning, `No result given for '${k}' method and invocation ID '${w.invocationId}'.`), await this.xt(this.Bt(w.invocationId, "Client didn't provide a result.", null))));
          const E = M.slice(), D = !!w.invocationId;
          let q, lt, ct;
          for (const At of E) try {
            const Ht = q;
            q = await At.apply(this, w.arguments), D && q && Ht && (this.u.log(s.Error, `Multiple results provided for '${k}'. Sending error to server.`), ct = this.Bt(w.invocationId, "Client provided multiple results.", null)), lt = void 0;
          } catch (Ht) {
            lt = Ht, this.u.log(s.Error, `A callback for the method '${k}' threw error '${Ht}'.`);
          }
          ct ? await this.xt(ct) : D ? (lt ? ct = this.Bt(w.invocationId, `${lt}`, null) : q !== void 0 ? ct = this.Bt(w.invocationId, null, q) : (this.u.log(s.Warning, `No result given for '${k}' method and invocation ID '${w.invocationId}'.`), ct = this.Bt(w.invocationId, "Client didn't provide a result.", null)), await this.xt(ct)) : q && this.u.log(s.Error, `Result given for '${k}' method but server is not expecting a result.`);
        }
        st(w) {
          this.u.log(s.Debug, `HubConnection.connectionClosed(${w}) called while in state ${this.ut}.`), this.bt = this.bt || w || new p("The underlying connection was closed before the hub handshake could complete."), this.vt && this.vt(), this.Xt(w || new Error("Invocation canceled due to the underlying connection being closed.")), this.Ct(), this.Tt(), this.ut === Kt.Disconnecting ? this.Dt(w) : this.ut === Kt.Connected && this.Z ? this.Jt(w) : this.ut === Kt.Connected && this.Dt(w);
        }
        Dt(w) {
          if (this.dt) {
            this.ut = Kt.Disconnected, this.dt = !1, this.Pt && (this.Pt.X(w ?? new Error("Connection closed.")), this.Pt = void 0), Qt.isBrowser && window.document.removeEventListener("freeze", this.G);
            try {
              this.rt.forEach(((k) => k.apply(this, [w])));
            } catch (k) {
              this.u.log(s.Error, `An onclose callback called with error '${w}' threw error '${k}'.`);
            }
          }
        }
        async Jt(w) {
          const k = Date.now();
          let M = 0, E = w !== void 0 ? w : new Error("Attempting to reconnect due to a unknown error."), D = this.zt(M++, 0, E);
          if (D === null) return this.u.log(s.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."), void this.Dt(w);
          if (this.ut = Kt.Reconnecting, w ? this.u.log(s.Information, `Connection reconnecting because of error '${w}'.`) : this.u.log(s.Information, "Connection reconnecting."), this.ot.length !== 0) {
            try {
              this.ot.forEach(((q) => q.apply(this, [w])));
            } catch (q) {
              this.u.log(s.Error, `An onreconnecting callback called with error '${w}' threw error '${q}'.`);
            }
            if (this.ut !== Kt.Reconnecting) return void this.u.log(s.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.");
          }
          for (; D !== null; ) {
            if (this.u.log(s.Information, `Reconnect attempt number ${M} will start in ${D} ms.`), await new Promise(((q) => {
              this.Ht = setTimeout(q, D);
            })), this.Ht = void 0, this.ut !== Kt.Reconnecting) return void this.u.log(s.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting.");
            try {
              if (await this.yt(), this.ut = Kt.Connected, this.u.log(s.Information, "HubConnection reconnected successfully."), this.ht.length !== 0) try {
                this.ht.forEach(((q) => q.apply(this, [this.connection.connectionId])));
              } catch (q) {
                this.u.log(s.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${q}'.`);
              }
              return;
            } catch (q) {
              if (this.u.log(s.Information, `Reconnect attempt failed because of error '${q}'.`), this.ut !== Kt.Reconnecting) return this.u.log(s.Debug, `Connection moved to the '${this.ut}' from the reconnecting state during reconnect attempt. Done reconnecting.`), void (this.ut === Kt.Disconnecting && this.Dt());
              E = q instanceof Error ? q : new Error(q.toString()), D = this.zt(M++, Date.now() - k, E);
            }
          }
          this.u.log(s.Information, `Reconnect retries have been exhausted after ${Date.now() - k} ms and ${M} failed attempts. Connection disconnecting.`), this.Dt();
        }
        zt(w, k, M) {
          try {
            return this.Z.nextRetryDelayInMilliseconds({ elapsedMilliseconds: k, previousRetryCount: w, retryReason: M });
          } catch (E) {
            return this.u.log(s.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${w}, ${k}) threw error '${E}'.`), null;
          }
        }
        Xt(w) {
          const k = this.it;
          this.it = {}, Object.keys(k).forEach(((M) => {
            const E = k[M];
            try {
              E(null, w);
            } catch (D) {
              this.u.log(s.Error, `Stream 'error' callback called with '${w}' threw error: ${Ut(D)}`);
            }
          }));
        }
        Tt() {
          this.Ft && (clearTimeout(this.Ft), this.Ft = void 0);
        }
        Ct() {
          this.Ot && clearTimeout(this.Ot);
        }
        Mt(w, k, M, E) {
          if (M) return E.length !== 0 ? { target: w, arguments: k, streamIds: E, type: Mt.Invocation } : { target: w, arguments: k, type: Mt.Invocation };
          {
            const D = this.ct;
            return this.ct++, E.length !== 0 ? { target: w, arguments: k, invocationId: D.toString(), streamIds: E, type: Mt.Invocation } : { target: w, arguments: k, invocationId: D.toString(), type: Mt.Invocation };
          }
        }
        qt(w, k) {
          if (w.length !== 0) {
            k || (k = Promise.resolve());
            for (const M in w) w[M].subscribe({ complete: /* @__PURE__ */ d(() => {
              k = k.then((() => this.xt(this.Bt(M))));
            }, "complete"), error: /* @__PURE__ */ d((E) => {
              let D;
              D = E instanceof Error ? E.message : E && E.toString ? E.toString() : "Unknown error", k = k.then((() => this.xt(this.Bt(M, D))));
            }, "error"), next: /* @__PURE__ */ d((E) => {
              k = k.then((() => this.xt(this.Vt(M, E))));
            }, "next") });
          }
        }
        Ut(w) {
          const k = [], M = [];
          for (let E = 0; E < w.length; E++) {
            const D = w[E];
            if (this.Kt(D)) {
              const q = this.ct;
              this.ct++, k[q] = D, M.push(q.toString()), w.splice(E, 1);
            }
          }
          return [k, M];
        }
        Kt(w) {
          return w && w.subscribe && typeof w.subscribe == "function";
        }
        Lt(w, k, M) {
          const E = this.ct;
          return this.ct++, M.length !== 0 ? { target: w, arguments: k, invocationId: E.toString(), streamIds: M, type: Mt.StreamInvocation } : { target: w, arguments: k, invocationId: E.toString(), type: Mt.StreamInvocation };
        }
        Nt(w) {
          return { invocationId: w, type: Mt.CancelInvocation };
        }
        Vt(w, k) {
          return { invocationId: w, item: k, type: Mt.StreamItem };
        }
        Bt(w, k, M) {
          return k ? { error: k, invocationId: w, type: Mt.Completion } : { invocationId: w, result: M, type: Mt.Completion };
        }
        At() {
          return { type: Mt.Close };
        }
      }, c(Qa, "$d"), Qa);
      d(u3, "q");
      let p3 = u3;
      const aD = [0, 2e3, 1e4, 3e4, null], f3 = (fc = class {
        constructor(w) {
          this.Gt = w !== void 0 ? [...w, null] : aD;
        }
        nextRetryDelayInMilliseconds(w) {
          return this.Gt[w.previousRetryCount];
        }
      }, c(fc, "wp"), fc);
      d(f3, "j");
      let y3 = f3;
      const m3 = (yc = class {
      }, c(yc, "fp"), yc);
      d(m3, "W");
      let Pa = m3;
      Pa.Authorization = "Authorization", Pa.Cookie = "Cookie";
      const g3 = (mc = class extends J {
        constructor(w, k) {
          super(), this.Qt = w, this.Yt = k;
        }
        async send(w) {
          let k = !0;
          this.Yt && (!this.Zt || w.url && w.url.indexOf("/negotiate?") > 0) && (k = !1, this.Zt = await this.Yt()), this.te(w);
          const M = await this.Qt.send(w);
          return k && M.statusCode === 401 && this.Yt ? (this.Zt = await this.Yt(), this.te(w), await this.Qt.send(w)) : M;
        }
        te(w) {
          w.headers || (w.headers = {}), this.Zt ? w.headers[Pa.Authorization] = `Bearer ${this.Zt}` : this.Yt && w.headers[Pa.Authorization] && delete w.headers[Pa.Authorization];
        }
        getCookieString(w) {
          return this.Qt.getCookieString(w);
        }
      }, c(mc, "mp"), mc);
      d(g3, "O");
      let oD = g3;
      var ke, He;
      (function(B) {
        B[B.None = 0] = "None", B[B.WebSockets = 1] = "WebSockets", B[B.ServerSentEvents = 2] = "ServerSentEvents", B[B.LongPolling = 4] = "LongPolling";
      })(ke || (ke = {})), (function(B) {
        B[B.Text = 1] = "Text", B[B.Binary = 2] = "Binary";
      })(He || (He = {}));
      const w3 = (gc = class {
        constructor() {
          this.ee = !1, this.onabort = null;
        }
        abort() {
          this.ee || (this.ee = !0, this.onabort && this.onabort());
        }
        get signal() {
          return this;
        }
        get aborted() {
          return this.ee;
        }
      }, c(gc, "vp"), gc);
      d(w3, "X");
      let lD = w3;
      const v3 = (wc = class {
        get pollAborted() {
          return this.se.aborted;
        }
        constructor(w, k, M) {
          this.$ = w, this.u = k, this.se = new lD(), this.ie = M, this.ne = !1, this.onreceive = null, this.onclose = null;
        }
        async connect(w, k) {
          if (rt.isRequired(w, "url"), rt.isRequired(k, "transferFormat"), rt.isIn(k, He, "transferFormat"), this.re = w, this.u.log(s.Trace, "(LongPolling transport) Connecting."), k === He.Binary && typeof XMLHttpRequest < "u" && typeof new XMLHttpRequest().responseType != "string") throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");
          const [M, E] = fe(), D = { [M]: E, ...this.ie.headers }, q = { abortSignal: this.se.signal, headers: D, timeout: 1e5, withCredentials: this.ie.withCredentials };
          k === He.Binary && (q.responseType = "arraybuffer");
          const lt = `${w}&_=${Date.now()}`;
          this.u.log(s.Trace, `(LongPolling transport) polling: ${lt}.`);
          const ct = await this.$.get(lt, q);
          ct.statusCode !== 200 ? (this.u.log(s.Error, `(LongPolling transport) Unexpected response code: ${ct.statusCode}.`), this.oe = new o(ct.statusText || "", ct.statusCode), this.ne = !1) : this.ne = !0, this.he = this.ce(this.re, q);
        }
        async ce(w, k) {
          try {
            for (; this.ne; ) try {
              const M = `${w}&_=${Date.now()}`;
              this.u.log(s.Trace, `(LongPolling transport) polling: ${M}.`);
              const E = await this.$.get(M, k);
              E.statusCode === 204 ? (this.u.log(s.Information, "(LongPolling transport) Poll terminated by server."), this.ne = !1) : E.statusCode !== 200 ? (this.u.log(s.Error, `(LongPolling transport) Unexpected response code: ${E.statusCode}.`), this.oe = new o(E.statusText || "", E.statusCode), this.ne = !1) : E.content ? (this.u.log(s.Trace, `(LongPolling transport) data received. ${It(E.content, this.ie.logMessageContent)}.`), this.onreceive && this.onreceive(E.content)) : this.u.log(s.Trace, "(LongPolling transport) Poll timed out, reissuing.");
            } catch (M) {
              this.ne ? M instanceof h ? this.u.log(s.Trace, "(LongPolling transport) Poll timed out, reissuing.") : (this.oe = M, this.ne = !1) : this.u.log(s.Trace, `(LongPolling transport) Poll errored after shutdown: ${M.message}`);
            }
          } finally {
            this.u.log(s.Trace, "(LongPolling transport) Polling complete."), this.pollAborted || this.ae();
          }
        }
        async send(w) {
          return this.ne ? Dt(this.u, "LongPolling", this.$, this.re, w, this.ie) : Promise.reject(new Error("Cannot send until the transport is connected"));
        }
        async stop() {
          this.u.log(s.Trace, "(LongPolling transport) Stopping polling."), this.ne = !1, this.se.abort();
          try {
            await this.he, this.u.log(s.Trace, `(LongPolling transport) sending DELETE request to ${this.re}.`);
            const w = {}, [k, M] = fe();
            w[k] = M;
            const E = { headers: { ...w, ...this.ie.headers }, timeout: this.ie.timeout, withCredentials: this.ie.withCredentials };
            let D;
            try {
              await this.$.delete(this.re, E);
            } catch (q) {
              D = q;
            }
            D ? D instanceof o && (D.statusCode === 404 ? this.u.log(s.Trace, "(LongPolling transport) A 404 response was returned from sending a DELETE request.") : this.u.log(s.Trace, `(LongPolling transport) Error sending a DELETE request: ${D}`)) : this.u.log(s.Trace, "(LongPolling transport) DELETE request accepted.");
          } finally {
            this.u.log(s.Trace, "(LongPolling transport) Stop finished."), this.ae();
          }
        }
        ae() {
          if (this.onclose) {
            let w = "(LongPolling transport) Firing onclose event.";
            this.oe && (w += " Error: " + this.oe), this.u.log(s.Trace, w), this.onclose(this.oe);
          }
        }
      }, c(wc, "gp"), wc);
      d(v3, "J");
      let O3 = v3;
      const b3 = (vc = class {
        constructor(w, k, M, E) {
          this.$ = w, this.Zt = k, this.u = M, this.ie = E, this.onreceive = null, this.onclose = null;
        }
        async connect(w, k) {
          return rt.isRequired(w, "url"), rt.isRequired(k, "transferFormat"), rt.isIn(k, He, "transferFormat"), this.u.log(s.Trace, "(SSE transport) Connecting."), this.re = w, this.Zt && (w += (w.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(this.Zt)}`), new Promise(((M, E) => {
            let D, q = !1;
            if (k === He.Text) {
              if (Qt.isBrowser || Qt.isWebWorker) D = new this.ie.EventSource(w, { withCredentials: this.ie.withCredentials });
              else {
                const lt = this.$.getCookieString(w), ct = {};
                ct.Cookie = lt;
                const [At, Ht] = fe();
                ct[At] = Ht, D = new this.ie.EventSource(w, { withCredentials: this.ie.withCredentials, headers: { ...ct, ...this.ie.headers } });
              }
              try {
                D.onmessage = (lt) => {
                  if (this.onreceive) try {
                    this.u.log(s.Trace, `(SSE transport) data received. ${It(lt.data, this.ie.logMessageContent)}.`), this.onreceive(lt.data);
                  } catch (ct) {
                    return void this.le(ct);
                  }
                }, D.onerror = (lt) => {
                  q ? this.le() : E(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled."));
                }, D.onopen = () => {
                  this.u.log(s.Information, `SSE connected to ${this.re}`), this.ue = D, q = !0, M();
                };
              } catch (lt) {
                return void E(lt);
              }
            } else E(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));
          }));
        }
        async send(w) {
          return this.ue ? Dt(this.u, "SSE", this.$, this.re, w, this.ie) : Promise.reject(new Error("Cannot send until the transport is connected"));
        }
        stop() {
          return this.le(), Promise.resolve();
        }
        le(w) {
          this.ue && (this.ue.close(), this.ue = void 0, this.onclose && this.onclose(w));
        }
      }, c(vc, "bp"), vc);
      d(b3, "z");
      let cD = b3;
      const $3 = (Oc = class {
        constructor(w, k, M, E, D, q) {
          this.u = M, this.Yt = k, this.de = E, this.fe = D, this.$ = w, this.onreceive = null, this.onclose = null, this.pe = q;
        }
        async connect(w, k) {
          let M;
          return rt.isRequired(w, "url"), rt.isRequired(k, "transferFormat"), rt.isIn(k, He, "transferFormat"), this.u.log(s.Trace, "(WebSockets transport) Connecting."), this.Yt && (M = await this.Yt()), new Promise(((E, D) => {
            let q;
            w = w.replace(/^http/, "ws");
            const lt = this.$.getCookieString(w);
            let ct = !1;
            if (Qt.isNode || Qt.isReactNative) {
              const At = {}, [Ht, Sc] = fe();
              At[Ht] = Sc, M && (At[Pa.Authorization] = `Bearer ${M}`), lt && (At[Pa.Cookie] = lt), q = new this.fe(w, void 0, { headers: { ...At, ...this.pe } });
            } else M && (w += (w.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(M)}`);
            q || (q = new this.fe(w)), k === He.Binary && (q.binaryType = "arraybuffer"), q.onopen = (At) => {
              this.u.log(s.Information, `WebSocket connected to ${w}.`), this.we = q, ct = !0, E();
            }, q.onerror = (At) => {
              let Ht = null;
              Ht = typeof ErrorEvent < "u" && At instanceof ErrorEvent ? At.error : "There was an error with the transport", this.u.log(s.Information, `(WebSockets transport) ${Ht}.`);
            }, q.onmessage = (At) => {
              if (this.u.log(s.Trace, `(WebSockets transport) data received. ${It(At.data, this.de)}.`), this.onreceive) try {
                this.onreceive(At.data);
              } catch (Ht) {
                return void this.le(Ht);
              }
            }, q.onclose = (At) => {
              if (ct) this.le(At);
              else {
                let Ht = null;
                Ht = typeof ErrorEvent < "u" && At instanceof ErrorEvent ? At.error : "WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.", D(new Error(Ht));
              }
            };
          }));
        }
        send(w) {
          return this.we && this.we.readyState === this.fe.OPEN ? (this.u.log(s.Trace, `(WebSockets transport) sending data. ${It(w, this.de)}.`), this.we.send(w), Promise.resolve()) : Promise.reject("WebSocket is not in the OPEN state");
        }
        stop() {
          return this.we && this.le(void 0), Promise.resolve();
        }
        le(w) {
          this.we && (this.we.onclose = () => {
          }, this.we.onmessage = () => {
          }, this.we.onerror = () => {
          }, this.we.close(), this.we = void 0), this.u.log(s.Trace, "(WebSockets transport) socket closed."), this.onclose && (!this.ge(w) || w.wasClean !== !1 && w.code === 1e3 ? w instanceof Error ? this.onclose(w) : this.onclose() : this.onclose(new Error(`WebSocket closed with status code: ${w.code} (${w.reason || "no reason given"}).`)));
        }
        ge(w) {
          return w && typeof w.wasClean == "boolean" && typeof w.code == "number";
        }
      }, c(Oc, "xp"), Oc);
      d($3, "V");
      let hD = $3;
      const x3 = (bc = class {
        constructor(w, k = {}) {
          var M;
          if (this.me = () => {
          }, this.features = {}, this.ye = 1, rt.isRequired(w, "url"), this.u = (M = k.logger) === void 0 ? new te(s.Information) : M === null ? at.instance : M.log !== void 0 ? M : new te(M), this.baseUrl = this.be(w), (k = k || {}).logMessageContent = k.logMessageContent !== void 0 && k.logMessageContent, typeof k.withCredentials != "boolean" && k.withCredentials !== void 0) throw new Error("withCredentials option was not a 'boolean' or 'undefined' value");
          k.withCredentials = k.withCredentials === void 0 || k.withCredentials, k.timeout = k.timeout === void 0 ? 1e5 : k.timeout;
          let E = null, D = null;
          if (Qt.isNode) {
            const q = _v;
            E = q("ws"), D = q("eventsource");
          }
          Qt.isNode || typeof WebSocket > "u" || k.WebSocket ? Qt.isNode && !k.WebSocket && E && (k.WebSocket = E) : k.WebSocket = WebSocket, Qt.isNode || typeof EventSource > "u" || k.EventSource ? Qt.isNode && !k.EventSource && D !== void 0 && (k.EventSource = D) : k.EventSource = EventSource, this.$ = new oD(k.httpClient || new r3(this.u), k.accessTokenFactory), this.ut = "Disconnected", this.dt = !1, this.ie = k, this.onreceive = null, this.onclose = null;
        }
        async start(w) {
          if (w = w || He.Binary, rt.isIn(w, He, "transferFormat"), this.u.log(s.Debug, `Starting connection with transfer format '${He[w]}'.`), this.ut !== "Disconnected") return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."));
          if (this.ut = "Connecting", this.ve = this.yt(w), await this.ve, this.ut === "Disconnecting") {
            const k = "Failed to start the HttpConnection before stop() was called.";
            return this.u.log(s.Error, k), await this.It, Promise.reject(new p(k));
          }
          if (this.ut !== "Connected") {
            const k = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";
            return this.u.log(s.Error, k), Promise.reject(new p(k));
          }
          this.dt = !0;
        }
        send(w) {
          return this.ut !== "Connected" ? Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State.")) : (this.Ee || (this.Ee = new uD(this.transport)), this.Ee.send(w));
        }
        async stop(w) {
          return this.ut === "Disconnected" ? (this.u.log(s.Debug, `Call to HttpConnection.stop(${w}) ignored because the connection is already in the disconnected state.`), Promise.resolve()) : this.ut === "Disconnecting" ? (this.u.log(s.Debug, `Call to HttpConnection.stop(${w}) ignored because the connection is already in the disconnecting state.`), this.It) : (this.ut = "Disconnecting", this.It = new Promise(((k) => {
            this.me = k;
          })), await this._t(w), void await this.It);
        }
        async _t(w) {
          this.$e = w;
          try {
            await this.ve;
          } catch {
          }
          if (this.transport) {
            try {
              await this.transport.stop();
            } catch (k) {
              this.u.log(s.Error, `HttpConnection.transport.stop() threw error '${k}'.`), this.Ce();
            }
            this.transport = void 0;
          } else this.u.log(s.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.");
        }
        async yt(w) {
          let k = this.baseUrl;
          this.Yt = this.ie.accessTokenFactory, this.$.Yt = this.Yt;
          try {
            if (this.ie.skipNegotiation) {
              if (this.ie.transport !== ke.WebSockets) throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");
              this.transport = this.Se(ke.WebSockets), await this.ke(k, w);
            } else {
              let M = null, E = 0;
              do {
                if (M = await this.Pe(k), this.ut === "Disconnecting" || this.ut === "Disconnected") throw new p("The connection was stopped during negotiation.");
                if (M.error) throw new Error(M.error);
                if (M.ProtocolVersion) throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");
                if (M.url && (k = M.url), M.accessToken) {
                  const D = M.accessToken;
                  this.Yt = () => D, this.$.Zt = D, this.$.Yt = void 0;
                }
                E++;
              } while (M.url && E < 100);
              if (E === 100 && M.url) throw new Error("Negotiate redirection limit exceeded.");
              await this.Te(k, this.ie.transport, M, w);
            }
            this.transport instanceof O3 && (this.features.inherentKeepAlive = !0), this.ut === "Connecting" && (this.u.log(s.Debug, "The HttpConnection connected successfully."), this.ut = "Connected");
          } catch (M) {
            return this.u.log(s.Error, "Failed to start the connection: " + M), this.ut = "Disconnected", this.transport = void 0, this.me(), Promise.reject(M);
          }
        }
        async Pe(w) {
          const k = {}, [M, E] = fe();
          k[M] = E;
          const D = this.Ie(w);
          this.u.log(s.Debug, `Sending negotiation request: ${D}.`);
          try {
            const q = await this.$.post(D, { content: "", headers: { ...k, ...this.ie.headers }, timeout: this.ie.timeout, withCredentials: this.ie.withCredentials });
            if (q.statusCode !== 200) return Promise.reject(new Error(`Unexpected status code returned from negotiate '${q.statusCode}'`));
            const lt = JSON.parse(q.content);
            return (!lt.negotiateVersion || lt.negotiateVersion < 1) && (lt.connectionToken = lt.connectionId), lt.useStatefulReconnect && this.ie._e !== !0 ? Promise.reject(new L("Client didn't negotiate Stateful Reconnect but the server did.")) : lt;
          } catch (q) {
            let lt = "Failed to complete negotiation with the server: " + q;
            return q instanceof o && q.statusCode === 404 && (lt += " Either this is not a SignalR endpoint or there is a proxy blocking the connection."), this.u.log(s.Error, lt), Promise.reject(new L(lt));
          }
        }
        He(w, k) {
          return k ? w + (w.indexOf("?") === -1 ? "?" : "&") + `id=${k}` : w;
        }
        async Te(w, k, M, E) {
          let D = this.He(w, M.connectionToken);
          if (this.De(k)) return this.u.log(s.Debug, "Connection was provided an instance of ITransport, using that directly."), this.transport = k, await this.ke(D, E), void (this.connectionId = M.connectionId);
          const q = [], lt = M.availableTransports || [];
          let ct = M;
          for (const At of lt) {
            const Ht = this.Re(At, k, E, ct?.useStatefulReconnect === !0);
            if (Ht instanceof Error) q.push(`${At.transport} failed:`), q.push(Ht);
            else if (this.De(Ht)) {
              if (this.transport = Ht, !ct) {
                try {
                  ct = await this.Pe(w);
                } catch (Sc) {
                  return Promise.reject(Sc);
                }
                D = this.He(w, ct.connectionToken);
              }
              try {
                return await this.ke(D, E), void (this.connectionId = ct.connectionId);
              } catch (Sc) {
                if (this.u.log(s.Error, `Failed to start the transport '${At.transport}': ${Sc}`), ct = void 0, q.push(new x(`${At.transport} failed: ${Sc}`, ke[At.transport])), this.ut !== "Connecting") {
                  const T3 = "Failed to select transport before stop() was called.";
                  return this.u.log(s.Debug, T3), Promise.reject(new p(T3));
                }
              }
            }
          }
          return q.length > 0 ? Promise.reject(new R(`Unable to connect to the server with any of the available transports. ${q.join(" ")}`, q)) : Promise.reject(new Error("None of the transports supported by the client are supported by the server."));
        }
        Se(w) {
          switch (w) {
            case ke.WebSockets:
              if (!this.ie.WebSocket) throw new Error("'WebSocket' is not supported in your environment.");
              return new hD(this.$, this.Yt, this.u, this.ie.logMessageContent, this.ie.WebSocket, this.ie.headers || {});
            case ke.ServerSentEvents:
              if (!this.ie.EventSource) throw new Error("'EventSource' is not supported in your environment.");
              return new cD(this.$, this.$.Zt, this.u, this.ie);
            case ke.LongPolling:
              return new O3(this.$, this.u, this.ie);
            default:
              throw new Error(`Unknown transport: ${w}.`);
          }
        }
        ke(w, k) {
          return this.transport.onreceive = this.onreceive, this.features.reconnect ? this.transport.onclose = async (M) => {
            let E = !1;
            if (this.features.reconnect) {
              try {
                this.features.disconnected(), await this.transport.connect(w, k), await this.features.resend();
              } catch {
                E = !0;
              }
              E && this.Ce(M);
            } else this.Ce(M);
          } : this.transport.onclose = (M) => this.Ce(M), this.transport.connect(w, k);
        }
        Re(w, k, M, E) {
          const D = ke[w.transport];
          if (D == null) return this.u.log(s.Debug, `Skipping transport '${w.transport}' because it is not supported by this client.`), new Error(`Skipping transport '${w.transport}' because it is not supported by this client.`);
          if (!(function(q, lt) {
            return !q || !!(lt & q);
          })(k, D)) return this.u.log(s.Debug, `Skipping transport '${ke[D]}' because it was disabled by the client.`), new b(`'${ke[D]}' is disabled by the client.`, D);
          if (!(w.transferFormats.map(((q) => He[q])).indexOf(M) >= 0)) return this.u.log(s.Debug, `Skipping transport '${ke[D]}' because it does not support the requested transfer format '${He[M]}'.`), new Error(`'${ke[D]}' does not support ${He[M]}.`);
          if (D === ke.WebSockets && !this.ie.WebSocket || D === ke.ServerSentEvents && !this.ie.EventSource) return this.u.log(s.Debug, `Skipping transport '${ke[D]}' because it is not supported in your environment.'`), new m(`'${ke[D]}' is not supported in your environment.`, D);
          this.u.log(s.Debug, `Selecting transport '${ke[D]}'.`);
          try {
            return this.features.reconnect = D === ke.WebSockets ? E : void 0, this.Se(D);
          } catch (q) {
            return q;
          }
        }
        De(w) {
          return w && typeof w == "object" && "connect" in w;
        }
        Ce(w) {
          if (this.u.log(s.Debug, `HttpConnection.stopConnection(${w}) called while in state ${this.ut}.`), this.transport = void 0, w = this.$e || w, this.$e = void 0, this.ut !== "Disconnected") {
            if (this.ut === "Connecting") throw this.u.log(s.Warning, `Call to HttpConnection.stopConnection(${w}) was ignored because the connection is still in the connecting state.`), new Error(`HttpConnection.stopConnection(${w}) was called while the connection is still in the connecting state.`);
            if (this.ut === "Disconnecting" && this.me(), w ? this.u.log(s.Error, `Connection disconnected with error '${w}'.`) : this.u.log(s.Information, "Connection disconnected."), this.Ee && (this.Ee.stop().catch(((k) => {
              this.u.log(s.Error, `TransportSendQueue.stop() threw error '${k}'.`);
            })), this.Ee = void 0), this.connectionId = void 0, this.ut = "Disconnected", this.dt) {
              this.dt = !1;
              try {
                this.onclose && this.onclose(w);
              } catch (k) {
                this.u.log(s.Error, `HttpConnection.onclose(${w}) threw error '${k}'.`);
              }
            }
          } else this.u.log(s.Debug, `Call to HttpConnection.stopConnection(${w}) was ignored because the connection is already in the disconnected state.`);
        }
        be(w) {
          if (w.lastIndexOf("https://", 0) === 0 || w.lastIndexOf("http://", 0) === 0) return w;
          if (!Qt.isBrowser) throw new Error(`Cannot resolve '${w}'.`);
          const k = window.document.createElement("a");
          return k.href = w, this.u.log(s.Information, `Normalizing '${w}' to '${k.href}'.`), k.href;
        }
        Ie(w) {
          const k = new URL(w);
          k.pathname.endsWith("/") ? k.pathname += "negotiate" : k.pathname += "/negotiate";
          const M = new URLSearchParams(k.searchParams);
          return M.has("negotiateVersion") || M.append("negotiateVersion", this.ye.toString()), M.has("useStatefulReconnect") ? M.get("useStatefulReconnect") === "true" && (this.ie._e = !0) : this.ie._e === !0 && M.append("useStatefulReconnect", "true"), k.search = M.toString(), k.toString();
        }
      }, c(bc, "$p"), bc);
      d(x3, "K");
      let dD = x3;
      const k3 = (Ta = class {
        constructor(w) {
          this.xe = w, this.Ae = [], this.Ue = !0, this.Le = new V1(), this.Ne = new V1(), this.qe = this.Me();
        }
        send(w) {
          return this.je(w), this.Ne || (this.Ne = new V1()), this.Ne.promise;
        }
        stop() {
          return this.Ue = !1, this.Le.resolve(), this.qe;
        }
        je(w) {
          if (this.Ae.length && typeof this.Ae[0] != typeof w) throw new Error(`Expected data to be of type ${typeof this.Ae} but was of type ${typeof w}`);
          this.Ae.push(w), this.Le.resolve();
        }
        async Me() {
          for (; ; ) {
            if (await this.Le.promise, !this.Ue) {
              this.Ne && this.Ne.reject("Connection stopped.");
              break;
            }
            this.Le = new V1();
            const w = this.Ne;
            this.Ne = void 0;
            const k = typeof this.Ae[0] == "string" ? this.Ae.join("") : Ta.We(this.Ae);
            this.Ae.length = 0;
            try {
              await this.xe.send(k), w.resolve();
            } catch (M) {
              w.reject(M);
            }
          }
        }
        static We(w) {
          const k = w.map(((D) => D.byteLength)).reduce(((D, q) => D + q)), M = new Uint8Array(k);
          let E = 0;
          for (const D of w) M.set(new Uint8Array(D), E), E += D.byteLength;
          return M.buffer;
        }
      }, c(Ta, "Cd"), Ta);
      d(k3, "G");
      let uD = k3;
      const S3 = ($c = class {
        constructor() {
          this.promise = new Promise(((w, k) => [this.j, this.Oe] = [w, k]));
        }
        resolve() {
          this.j();
        }
        reject(w) {
          this.Oe(w);
        }
      }, c($c, "Cp"), $c);
      d(S3, "Q");
      let V1 = S3;
      const C3 = (xc = class {
        constructor() {
          this.name = "json", this.version = 2, this.transferFormat = He.Text;
        }
        parseMessages(w, k) {
          if (typeof w != "string") throw new Error("Invalid input for JSON hub protocol. Expected a string.");
          if (!w) return [];
          k === null && (k = at.instance);
          const M = vs.parse(w), E = [];
          for (const D of M) {
            const q = JSON.parse(D);
            if (typeof q.type != "number") throw new Error("Invalid payload.");
            switch (q.type) {
              case Mt.Invocation:
                this.U(q);
                break;
              case Mt.StreamItem:
                this.Fe(q);
                break;
              case Mt.Completion:
                this.Be(q);
                break;
              case Mt.Ping:
              case Mt.Close:
                break;
              case Mt.Ack:
                this.Xe(q);
                break;
              case Mt.Sequence:
                this.Je(q);
                break;
              default:
                k.log(s.Information, "Unknown message type '" + q.type + "' ignored.");
                continue;
            }
            E.push(q);
          }
          return E;
        }
        writeMessage(w) {
          return vs.write(JSON.stringify(w));
        }
        U(w) {
          this.ze(w.target, "Invalid payload for Invocation message."), w.invocationId !== void 0 && this.ze(w.invocationId, "Invalid payload for Invocation message.");
        }
        Fe(w) {
          if (this.ze(w.invocationId, "Invalid payload for StreamItem message."), w.item === void 0) throw new Error("Invalid payload for StreamItem message.");
        }
        Be(w) {
          if (w.result && w.error) throw new Error("Invalid payload for Completion message.");
          !w.result && w.error && this.ze(w.error, "Invalid payload for Completion message."), this.ze(w.invocationId, "Invalid payload for Completion message.");
        }
        Xe(w) {
          if (typeof w.sequenceId != "number") throw new Error("Invalid SequenceId for Ack message.");
        }
        Je(w) {
          if (typeof w.sequenceId != "number") throw new Error("Invalid SequenceId for Sequence message.");
        }
        ze(w, k) {
          if (typeof w != "string" || w === "") throw new Error(k);
        }
      }, c(xc, "kp"), xc);
      d(C3, "Y");
      let P3 = C3;
      const pD = { trace: s.Trace, debug: s.Debug, info: s.Information, information: s.Information, warn: s.Warning, warning: s.Warning, error: s.Error, critical: s.Critical, none: s.None }, Q3 = (kc = class {
        configureLogging(w) {
          if (rt.isRequired(w, "logging"), w.log !== void 0) this.logger = w;
          else if (typeof w == "string") {
            const k = (function(M) {
              const E = pD[M.toLowerCase()];
              if (E !== void 0) return E;
              throw new Error(`Unknown log level: ${M}`);
            })(w);
            this.logger = new te(k);
          } else this.logger = new te(w);
          return this;
        }
        withUrl(w, k) {
          return rt.isRequired(w, "url"), rt.isNotEmpty(w, "url"), this.url = w, this.httpConnectionOptions = typeof k == "object" ? { ...this.httpConnectionOptions, ...k } : { ...this.httpConnectionOptions, transport: k }, this;
        }
        withHubProtocol(w) {
          return rt.isRequired(w, "protocol"), this.protocol = w, this;
        }
        withAutomaticReconnect(w) {
          if (this.reconnectPolicy) throw new Error("A reconnectPolicy has already been set.");
          return w ? Array.isArray(w) ? this.reconnectPolicy = new y3(w) : this.reconnectPolicy = w : this.reconnectPolicy = new y3(), this;
        }
        withServerTimeout(w) {
          return rt.isRequired(w, "milliseconds"), this.Ve = w, this;
        }
        withKeepAliveInterval(w) {
          return rt.isRequired(w, "milliseconds"), this.Ke = w, this;
        }
        withStatefulReconnect(w) {
          return this.httpConnectionOptions === void 0 && (this.httpConnectionOptions = {}), this.httpConnectionOptions._e = !0, this.Y = w?.bufferSize, this;
        }
        build() {
          const w = this.httpConnectionOptions || {};
          if (w.logger === void 0 && (w.logger = this.logger), !this.url) throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");
          const k = new dD(this.url, w);
          return p3.create(k, this.logger || at.instance, this.protocol || new P3(), this.reconnectPolicy, this.Ve, this.Ke, this.Y);
        }
      }, c(kc, "_p"), kc);
      d(Q3, "tt");
      let fD = Q3;
      return Uint8Array.prototype.indexOf || Object.defineProperty(Uint8Array.prototype, "indexOf", { value: Array.prototype.indexOf, writable: !0 }), Uint8Array.prototype.slice || Object.defineProperty(Uint8Array.prototype, "slice", { value: /* @__PURE__ */ d(function(B, w) {
        return new Uint8Array(Array.prototype.slice.call(this, B, w));
      }, "value"), writable: !0 }), Uint8Array.prototype.forEach || Object.defineProperty(Uint8Array.prototype, "forEach", { value: Array.prototype.forEach, writable: !0 }), r;
    })(), "e"), n.exports = e();
  })(t9)), t9.exports;
}
c(Z_, "_1");
d(Z_, "requireSignalr_min");
var i9 = /* @__PURE__ */ Z_();
const jj = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this._whenConnectionRequested = new Promise((r) => {
        this._resolveConnectionRequested = r;
      }), this._whenConnectionCreated = new Promise((r) => {
        this._resolveConnectionCreated = r;
      }), this._connectionEventListeners = [], this.signalRAccessTokenRefresh = !1, this._whenConnectionStarted = new Promise((r, a) => {
        this._whenConnectionStartedResolve = r, this._whenConnectionStartedReject = a;
      }), this.whenConnectionRequested().then(() => {
        this.isDestroyed || this.createConnection();
      });
    }
    async whenConnectionRequested() {
      await this._whenConnectionRequested;
    }
    async whenConnectionCreated() {
      return await this._whenConnectionCreated;
    }
    get rtmConnection() {
      return this._connection;
    }
    async whenConnectionStarted() {
      return await this._whenConnectionStarted;
    }
    async createConnection() {
      if (this.isDestroyed)
        throw new Ce();
      if (this.networkStateIsPending = !0, await this.whenUrlAndTokenFactory(), this._connection) {
        const s = new URL("/hubs/rtm", this.url);
        this._connection.baseUrl !== s.toString() && (this.connectionState = "reconnecting", console.info(
          this.weavyId,
          "Reconnecting due to changed url.",
          this._connection.baseUrl,
          "=>",
          s.toString()
        ), await this.disconnect(), this._connection.baseUrl = s.toString(), this.connect());
      } else {
        this.connectionState = "connecting";
        const s = new URL("/hubs/rtm", this.url);
        this._connection = new i9.HubConnectionBuilder().configureLogging(i9.LogLevel.None).withUrl(s.toString(), {
          accessTokenFactory: /* @__PURE__ */ d(async () => {
            try {
              if (this.signalRAccessTokenRefresh) {
                const r = await this.getToken(!0);
                return this.signalRAccessTokenRefresh = !1, r;
              } else
                return await this.getToken();
            } catch (r) {
              throw console.error(r), r;
            }
          }, "accessTokenFactory")
        }).withAutomaticReconnect({
          nextRetryDelayInMilliseconds: /* @__PURE__ */ d((r) => !this.isDestroyed && window.navigator.onLine && document?.visibilityState !== "hidden" && r.elapsedMilliseconds < 6e4 ? [0, 2e3, 1e4][r.previousRetryCount] || 1e4 : null, "nextRetryDelayInMilliseconds")
        }).build(), this._connection.onclose(() => {
          console.info(this.weavyId, "SignalR closed."), this.connectionState = "disconnected", !this.isDestroyed && (this.networkStateIsPending = !0, this._whenConnectionStarted = new Promise((r, a) => {
            this._whenConnectionStartedResolve = r, this._whenConnectionStartedReject = a;
          }), this.connect());
        }), this._connection.onreconnecting(() => {
          console.info(this.weavyId, "SignalR reconnecting..."), this.connectionState = "reconnecting";
        }), this._connection.onreconnected((r) => {
          console.info(this.weavyId, `SignalR reconnected ${r}`), this.connectionState = "connected", this.networkStateIsPending = !1;
          for (let a = 0; a < this._connectionEventListeners.length; a++)
            this._connection?.invoke("Subscribe", this._connectionEventListeners[a].name);
        }), this._resolveConnectionCreated?.(this._connection), this.connect();
      }
      return this._connection;
    }
    async disconnect() {
      this._connection && (await this._connection.stop(), this.connectionState = "disconnected");
    }
    async connect() {
      if (this.isDestroyed)
        throw new Ce();
      let s;
      this._connection ? s = this._connection : s = await this.whenConnectionCreated(), console.info(this.weavyId, "Connecting SignalR...");
      try {
        if (!window.navigator.onLine)
          throw new Error();
        await Promise.race([s.start(), this.whenConnectionStarted()]), this.signalRAccessTokenRefresh = !1, this.networkStateIsPending = !1, this.connectionState = "connected", this._whenConnectionStartedResolve?.(s), console.info(this.weavyId, `SignalR connected ${s.connectionId}`);
      } catch (r) {
        if (r instanceof Ce)
          return console.warn(this.weavyId, "SignalR connection aborted."), s;
        window.navigator.onLine ? !this.signalRAccessTokenRefresh && window.document.visibilityState !== "hidden" && r.toString().includes("Unauthorized") ? (console.info(this.weavyId, "Retrying SignalR connect with fresh token."), this.signalRAccessTokenRefresh = !0) : (console.info(
          this.weavyId,
          "Server is probably down, retrying SignalR connect after a delay or when window regains focus."
        ), this.connectionState = "reconnecting", await new Promise((a) => {
          setTimeout(a, 5e3), window.addEventListener("visibilitychange", a, { once: !0 }), window.addEventListener("offline", a, { once: !0 }), window.addEventListener("online", a, { once: !0 });
        })) : (this.networkStateIsPending = !1, console.info(this.weavyId, "Offline, reconnecting SignalR when online."), await new Promise((a) => {
          window.addEventListener("online", a, { once: !0 });
        })), window.navigator.onLine && document?.visibilityState !== "hidden" && await new Promise((a) => setTimeout(a, 1e3)), this.checkVersion(), this.networkStateIsPending = !0, await this.connect();
      }
      return s;
    }
    async subscribe(s, r, a) {
      if (this.isDestroyed)
        throw new Ce();
      this._resolveConnectionRequested?.(!0);
      const o = s ? s + ":" + r : r;
      try {
        if (this._connectionEventListeners || await new Promise((l) => queueMicrotask(() => l(!0))), this._connectionEventListeners.some((l) => l.name === o && l.callback === a))
          throw new Error("Duplicate subscribe: " + o);
        if (this._connectionEventListeners.push({ name: o, callback: a }), await this.whenConnectionStarted(), !this._connection)
          throw new Error("Connection not created");
        if (this._connection.on(o, a), await this._connection.invoke("Subscribe", o) === !1)
          throw new Error("Could not subscribe to " + o);
        return !0;
      } catch (l) {
        l instanceof Ce || console.error(this.weavyId, "Error in Subscribe:", l);
        const h = this._connectionEventListeners.findIndex((u) => u.name === o && u.callback === a);
        return h !== -1 && (this._connectionEventListeners.splice(h, 1), this._connection?.off(o, a)), !1;
      }
    }
    async unsubscribe(s, r, a) {
      if (this.isDestroyed)
        throw new Ce();
      try {
        const o = s ? s + ":" + r : r, l = this._connectionEventListeners.findIndex((h) => h.name === o && h.callback === a);
        if (l !== -1) {
          if (this._connectionEventListeners.splice(l, 1), await this.whenConnectionStarted(), !this._connection)
            throw new Error("Connection not created");
          this._connection?.off(o, a), this._connectionEventListeners.some((h) => h.name === o) || await this._connection.invoke("Unsubscribe", o);
        }
      } catch (o) {
        o instanceof Ce || console.error(this.weavyId, "Error in Unsubscribe:", o);
      }
    }
    destroy() {
      super.destroy(), this.disconnect(), this._whenConnectionStartedReject && (this._whenConnectionStarted.catch(() => {
      }), this._whenConnectionStartedReject(new Ce()));
    }
  }, c(e, "t"), e), d(t, "WeavyConnection"), t;
}, "WeavyConnectionMixin");
var UO = /* @__PURE__ */ ((n) => (n.JSON = "application/json;charset=utf-8", n.FormData = "multipart/form-data;charset=utf-8", n.URLEncoded = "application/x-www-form-urlencoded;charset=utf-8", n.Text = "text/plain;charset=utf-8", n.Auto = "", n))(UO || {});
const Bj = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // FETCH
    async fetchOptions(s = {}, r = !0) {
      if (this.isDestroyed)
        throw new Ce();
      const a = {
        headers: {
          "X-Weavy-Source": `${ze.sourceName}@${ze.version}`,
          "Content-Type": UO.JSON
        },
        method: "GET"
      }, o = no(no(Xj, a, !0), s, !0);
      return r ? no(
        o,
        {
          headers: {
            Authorization: "Bearer " + await this.getToken()
          }
        },
        !0
      ) : o;
    }
    async fetch(s, r, a = !0) {
      if (this.isDestroyed)
        throw new Ce();
      const o = await this.fetchOptions(r);
      this.networkStateIsPending = !0;
      const l = await fetch(new URL(s, this.url), o);
      if (l.ok)
        this.networkStateIsPending = !1, this.serverState = "ok";
      else if (l.status === 401 || l.status === 403) {
        if (a)
          return await this.getToken(!0), await this.fetch(s, r, !1);
        this.networkStateIsPending = !1, this.serverState = "unauthorized";
      } else
        this.networkStateIsPending = !1;
      return l;
    }
    async upload(s, r, a, o = UO.JSON, l, h, u = !0) {
      if (this.isDestroyed)
        throw new Ce();
      const p = await this.getToken();
      return await new Promise((y, m) => {
        const g = new XMLHttpRequest();
        g.open(r, new URL(s, this.url), !0), g.setRequestHeader("Authorization", "Bearer " + p), g.setRequestHeader("X-Weavy-Source", `${ze.sourceName}@${ze.version}`), o && g.setRequestHeader("Content-Type", o), l && g.upload.addEventListener("progress", (b) => {
          l(b.loaded / b.total * 100 || 100);
        }), g.onload = (b) => {
          u && (g.status === 401 || g.status === 401) ? this.getToken(!0).then(() => this.upload(s, r, a, o, l, h, !1)).then(y).catch(m) : y(new Response(g.response, { status: g.status, statusText: g.statusText }));
        }, g.onerror = m, g.onabort = m, h?.addEventListener("abort", () => {
          g.abort();
        }), g.send(a);
      });
    }
    // DEPRECATED
    async get(s) {
      return console.warn(`weavy.get() is deprecated, use weavy.fetch("${s}") instead.`), this.fetch(s);
    }
    // DEPRECATED
    async post(s, r, a, o) {
      console.warn(
        `weavy.post() is deprecated, use weavy.fetch("${s}", { method: "${r}"}) instead.`
      );
      const l = o ? { "Content-Type": o } : void 0;
      return this.fetch(s, { method: r, body: a, headers: l });
    }
  }, c(e, "t"), e), d(t, "WeavyFetch"), t;
}, "WeavyFetchMixin"), F_ = "en", Uj = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    constructor() {
      super(...arguments), this._locales = /* @__PURE__ */ new Map([
        ["sv-SE", () => import(
          /* webpackIgnore: true */
          /* @vite-ignore */
          new URL("./es/locales/sv-SE-DNn-JJCG.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
        ).then((s) => s.svSE)]
      ]), this._locale = t.sourceLocale;
    }
    /**
     * The locale used in the Weavy source.
     */
    static get sourceLocale() {
      try {
        return F_;
      } catch {
        return "";
      }
    }
    get locales() {
      return Array.from(this._locales.entries());
    }
    set locales(s) {
      if (this.isDestroyed)
        throw new Ce();
      if (this.localization)
        throw new Error("Locales may only be configured once");
      if (s) {
        if (!Array.isArray(s))
          throw new TypeError("Provided locales have invalid format.");
        s.forEach((r) => {
          if (!Array.isArray(r) || r.length !== 2 || typeof r[0] != "string")
            throw new TypeError("Invalid locale provided: " + r[0]);
          this._locales.set(...r);
        }), this.configureLocalization();
      }
    }
    get localization() {
      return this._localization;
    }
    /**
     * Selected locale. The locale must be pre configured in `.locales`.
     */
    get locale() {
      return this._locale;
    }
    set locale(s) {
      if (this.isDestroyed)
        throw new Ce();
      !this._locale && !s || (s ||= t.sourceLocale, this._locale = s, this.localization ? this.localization.setLocale(this._locale) : queueMicrotask(() => {
        this.localization ? this.localization.setLocale(this._locale) : this._locale !== t.sourceLocale && (this._locales.has(this._locale) && this.configureLocalization(), this.localization ? this.localization.setLocale(this._locale) : console.error(
          this.weavyId,
          `You need to configure additional languages in config to use '${s}'.`
        ));
      }));
    }
    async loadLocale(s) {
      if (this.isDestroyed)
        throw new Ce();
      if (this._locales?.has(s)) {
        const r = this._locales.get(s);
        return console.info(
          this.weavyId,
          typeof r == "function" ? "loading locale" : "preloaded locale",
          s
        ), await (typeof r == "function" ? r() : r);
      } else
        throw new Error("The requested locale is not configured");
    }
    configureLocalization() {
      if (this.isDestroyed)
        throw new Ce();
      if (this._locales?.size && !this.localization) {
        const s = this._locales.keys();
        console.info(this.weavyId, "Configuring locales", s);
        const { getLocale: r, setLocale: a } = rj({
          sourceLocale: t.sourceLocale,
          targetLocales: s,
          loadLocale: /* @__PURE__ */ d((o) => this.loadLocale(o), "loadLocale")
        });
        this._localization = {
          getLocale: r,
          setLocale: a
        };
      }
    }
  }, c(e, "t"), e), d(t, "WeavyLocalization"), t;
}, "WeavyLocalizationMixin"), Hj = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this._configurationState = "pending", this._networkEvents = /* @__PURE__ */ new Set(), this._connectionState = "connecting", this._serverState = "ok", this._networkState = window.navigator.onLine ? "online" : "offline", this._networkStateIsPending = !1, window.addEventListener("online", () => {
        this.networkState = "online";
      }), window.addEventListener("offline", () => {
        this.networkState = "offline", this.networkStateIsPending = !1;
      }), queueMicrotask(() => this.requestConfigurationCheck());
    }
    get configurationState() {
      return this._configurationState;
    }
    set configurationState(s) {
      this._configurationState = s, this._configurationTimer && s === "configured" && (window.clearTimeout(this._configurationTimer), this._configurationTimer = null), this.triggerNetworkChange();
    }
    get networkState() {
      return this._networkState;
    }
    set networkState(s) {
      this._networkState = s, this.triggerNetworkChange();
    }
    get serverState() {
      return this._serverState;
    }
    set serverState(s) {
      this._serverState = s, this.triggerNetworkChange();
    }
    get connectionState() {
      return this._connectionState;
    }
    set connectionState(s) {
      this._connectionState = s, this.triggerNetworkChange();
    }
    get networkStateIsPending() {
      return this._networkStateIsPending;
    }
    set networkStateIsPending(s) {
      this._networkStateIsPending = s, this.triggerNetworkChange();
    }
    get network() {
      return {
        state: this._networkState === "online" ? (this._connectionState === "connected" || this._serverState === "ok") && this.configurationState !== "uninitialized" ? "online" : "unreachable" : "offline",
        isPending: this._networkStateIsPending
      };
    }
    requestConfigurationCheck() {
      !this._configurationTimer && this.configurationTimeout >= 0 && this.configurationTimeout < 1 / 0 && (this._configurationTimer = window.setTimeout(() => {
        this.configurationState === "pending" && (this.configurationState = "uninitialized", console.error("Weavy was not configured with required url and tokenFactory/tokenUrl within a reasonable time. Please check your configuration!")), this._configurationTimer = null;
      }, this.configurationTimeout));
    }
    triggerNetworkChange() {
      const s = this.network;
      this._networkEvents.forEach((r) => {
        r(s);
      });
    }
    addNetworkListener(s) {
      this._networkEvents.add(s);
    }
    removeNetworkListener(s) {
      this._networkEvents.delete(s);
    }
  }, c(e, "t"), e), d(t, "WeavyNetwork"), t;
}, "WeavyNetworkMixin");
var W2, Gu, Cm = (W2 = (Gu = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, c(Gu, "vn"), Gu), d(W2, "Subscribable"), W2), Yj = {
  // We need the wrapper function syntax below instead of direct references to
  // global setTimeout etc.
  //
  // BAD: `setTimeout: setTimeout`
  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
  //
  // If we use direct references here, then anything that wants to spy on or
  // replace the global setTimeout (like tests) won't work since we'll already
  // have a hard reference to the original implementation at the time when this
  // file was imported.
  setTimeout: /* @__PURE__ */ d((n, t) => setTimeout(n, t), "setTimeout"),
  clearTimeout: /* @__PURE__ */ d((n) => clearTimeout(n), "clearTimeout"),
  setInterval: /* @__PURE__ */ d((n, t) => setInterval(n, t), "setInterval"),
  clearInterval: /* @__PURE__ */ d((n) => clearInterval(n), "clearInterval")
}, Ea, n9, V2, Ku, Gj = (V2 = (Ku = class {
  constructor() {
    Z(this, Ea, Yj), Z(this, n9, !1);
  }
  setTimeoutProvider(t) {
    _(this, Ea, t);
  }
  setTimeout(t, e) {
    return $(this, Ea).setTimeout(t, e);
  }
  clearTimeout(t) {
    $(this, Ea).clearTimeout(t);
  }
  setInterval(t, e) {
    return $(this, Ea).setInterval(t, e);
  }
  clearInterval(t) {
    $(this, Ea).clearInterval(t);
  }
}, c(Ku, "gn"), Ku), Ea = /* @__PURE__ */ new WeakMap(), n9 = /* @__PURE__ */ new WeakMap(), d(V2, "TimeoutManager"), V2), Tr = new Gj();
function X_(n) {
  setTimeout(n, 0);
}
c(X_, "E1");
d(X_, "systemSetTimeoutZero");
var rm = typeof window > "u" || "Deno" in globalThis;
function Je() {
}
c(Je, "me");
d(Je, "noop$1");
function N_(n, t) {
  return typeof n == "function" ? n(t) : n;
}
c(N_, "L1");
d(N_, "functionalUpdate");
function HO(n) {
  return typeof n == "number" && n >= 0 && n !== 1 / 0;
}
c(HO, "Np");
d(HO, "isValidTimeout");
function PP(n, t) {
  return Math.max(n + (t || 0) - Date.now(), 0);
}
c(PP, "jf");
d(PP, "timeUntilStale");
function js(n, t) {
  return typeof n == "function" ? n(t) : n;
}
c(js, "Pr");
d(js, "resolveStaleTime");
function Bi(n, t) {
  return typeof n == "function" ? n(t) : n;
}
c(Bi, "Ye");
d(Bi, "resolveEnabled");
function B5(n, t) {
  const {
    type: e = "all",
    exact: i,
    fetchStatus: s,
    predicate: r,
    queryKey: a,
    stale: o
  } = n;
  if (a) {
    if (i) {
      if (t.queryHash !== l0(a, t.options))
        return !1;
    } else if (!am(t.queryKey, a))
      return !1;
  }
  if (e !== "all") {
    const l = t.isActive();
    if (e === "active" && !l || e === "inactive" && l)
      return !1;
  }
  return !(typeof o == "boolean" && t.isStale() !== o || s && s !== t.state.fetchStatus || r && !r(t));
}
c(B5, "_w");
d(B5, "matchQuery");
function U5(n, t) {
  const { exact: e, status: i, predicate: s, mutationKey: r } = n;
  if (r) {
    if (!t.options.mutationKey)
      return !1;
    if (e) {
      if (sa(t.options.mutationKey) !== sa(r))
        return !1;
    } else if (!am(t.options.mutationKey, r))
      return !1;
  }
  return !(i && t.state.status !== i || s && !s(t));
}
c(U5, "Pw");
d(U5, "matchMutation");
function l0(n, t) {
  return (t?.queryKeyHashFn || sa)(n);
}
c(l0, "Bu");
d(l0, "hashQueryKeyByOptions");
function sa(n) {
  return JSON.stringify(
    n,
    (t, e) => YO(e) ? Object.keys(e).sort().reduce((i, s) => (i[s] = e[s], i), {}) : e
  );
}
c(sa, "ws");
d(sa, "hashKey");
function am(n, t) {
  return n === t ? !0 : typeof n != typeof t ? !1 : n && t && typeof n == "object" && typeof t == "object" ? Object.keys(t).every((e) => am(n[e], t[e])) : !1;
}
c(am, "cl");
d(am, "partialMatchKey");
var Kj = Object.prototype.hasOwnProperty;
function Pm(n, t, e = 0) {
  if (n === t)
    return n;
  if (e > 500) return t;
  const i = H5(n) && H5(t);
  if (!i && !(YO(n) && YO(t))) return t;
  const s = (i ? n : Object.keys(n)).length, r = i ? t : Object.keys(t), a = r.length, o = i ? new Array(a) : {};
  let l = 0;
  for (let h = 0; h < a; h++) {
    const u = i ? h : r[h], p = n[u], y = t[u];
    if (p === y) {
      o[u] = p, (i ? h < s : Kj.call(n, u)) && l++;
      continue;
    }
    if (p === null || y === null || typeof p != "object" || typeof y != "object") {
      o[u] = y;
      continue;
    }
    const m = Pm(p, y, e + 1);
    o[u] = m, m === p && l++;
  }
  return s === a && l === s ? n : o;
}
c(Pm, "rd");
d(Pm, "replaceEqualDeep");
function zw(n, t) {
  if (!t || Object.keys(n).length !== Object.keys(t).length)
    return !1;
  for (const e in n)
    if (n[e] !== t[e])
      return !1;
  return !0;
}
c(zw, "Dd");
d(zw, "shallowEqualObjects");
function H5(n) {
  return Array.isArray(n) && n.length === Object.keys(n).length;
}
c(H5, "Mw");
d(H5, "isPlainArray");
function YO(n) {
  if (!Y5(n))
    return !1;
  const t = n.constructor;
  if (t === void 0)
    return !0;
  const e = t.prototype;
  return !(!Y5(e) || !e.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(n) !== Object.prototype);
}
c(YO, "jp");
d(YO, "isPlainObject");
function Y5(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
c(Y5, "Sw");
d(Y5, "hasObjectPrototype");
function j_(n) {
  return new Promise((t) => {
    Tr.setTimeout(t, n);
  });
}
c(j_, "I1");
d(j_, "sleep");
function GO(n, t, e) {
  return typeof e.structuralSharing == "function" ? e.structuralSharing(n, t) : e.structuralSharing !== !1 ? Pm(n, t) : t;
}
c(GO, "Wp");
d(GO, "replaceData");
function B_(n, t, e = 0) {
  const i = [...n, t];
  return e && i.length > e ? i.slice(1) : i;
}
c(B_, "T1");
d(B_, "addToEnd");
function U_(n, t, e = 0) {
  const i = [t, ...n];
  return e && i.length > e ? i.slice(0, -1) : i;
}
c(U_, "F1");
d(U_, "addToStart");
var QP = Symbol();
function TP(n, t) {
  return !n.queryFn && t?.initialPromise ? () => t.initialPromise : !n.queryFn || n.queryFn === QP ? () => Promise.reject(new Error(`Missing queryFn: '${n.queryHash}'`)) : n.queryFn;
}
c(TP, "Wf");
d(TP, "ensureQueryFn");
function H_(n, t, e) {
  let i = !1, s;
  return Object.defineProperty(n, "signal", {
    enumerable: !0,
    get: /* @__PURE__ */ d(() => (s ??= t(), i || (i = !0, s.aborted ? e() : s.addEventListener("abort", e, { once: !0 })), s), "get")
  }), n;
}
c(H_, "D1");
d(H_, "addConsumeAwareSignal");
var Pc, _a, Jm, D2, Ju, Jj = (D2 = (Ju = class extends Cm {
  constructor() {
    super(), Z(this, Pc), Z(this, _a), Z(this, Jm), _(this, Jm, (t) => {
      if (!rm && window.addEventListener) {
        const e = /* @__PURE__ */ d(() => t(), "listener");
        return window.addEventListener("visibilitychange", e, !1), () => {
          window.removeEventListener("visibilitychange", e);
        };
      }
    });
  }
  onSubscribe() {
    $(this, _a) || this.setEventListener($(this, Jm));
  }
  onUnsubscribe() {
    var t;
    this.hasListeners() || ((t = $(this, _a)) == null || t.call(this), _(this, _a, void 0));
  }
  setEventListener(t) {
    var e;
    _(this, Jm, t), (e = $(this, _a)) == null || e.call(this), _(this, _a, t((i) => {
      typeof i == "boolean" ? this.setFocused(i) : this.onFocus();
    }));
  }
  setFocused(t) {
    $(this, Pc) !== t && (_(this, Pc, t), this.onFocus());
  }
  onFocus() {
    const t = this.isFocused();
    this.listeners.forEach((e) => {
      e(t);
    });
  }
  isFocused() {
    return typeof $(this, Pc) == "boolean" ? $(this, Pc) : globalThis.document?.visibilityState !== "hidden";
  }
}, c(Ju, "xn"), Ju), Pc = /* @__PURE__ */ new WeakMap(), _a = /* @__PURE__ */ new WeakMap(), Jm = /* @__PURE__ */ new WeakMap(), d(D2, "FocusManager"), D2), MP = new Jj();
function KO() {
  let n, t;
  const e = new Promise((s, r) => {
    n = s, t = r;
  });
  e.status = "pending", e.catch(() => {
  });
  function i(s) {
    Object.assign(e, s), delete e.resolve, delete e.reject;
  }
  return c(i, "r"), d(i, "finalize"), e.resolve = (s) => {
    i({
      status: "fulfilled",
      value: s
    }), n(s);
  }, e.reject = (s) => {
    i({
      status: "rejected",
      reason: s
    }), t(s);
  }, e;
}
c(KO, "Qp");
d(KO, "pendingThenable");
function Y_(n) {
  let t;
  if (n.then((e) => (t = e, e), Je)?.catch(Je), t !== void 0)
    return { data: t };
}
c(Y_, "V1");
d(Y_, "tryResolveSync");
function AP(n) {
  return n;
}
c(AP, "Qf");
d(AP, "defaultTransformerFn");
function G_(n) {
  return {
    mutationKey: n.options.mutationKey,
    state: n.state,
    ...n.options.scope && { scope: n.options.scope },
    ...n.meta && { meta: n.meta }
  };
}
c(G_, "U1");
d(G_, "dehydrateMutation");
function K_(n, t, e) {
  const i = /* @__PURE__ */ d(() => {
    const s = n.promise?.then(t).catch((r) => e(r) ? Promise.reject(new Error("redacted")) : Promise.reject(r));
    return s?.catch(Je), s;
  }, "dehydratePromise");
  return {
    dehydratedAt: Date.now(),
    state: {
      ...n.state,
      ...n.state.data !== void 0 && {
        data: t(n.state.data)
      }
    },
    queryKey: n.queryKey,
    queryHash: n.queryHash,
    ...n.state.status === "pending" && {
      promise: i()
    },
    ...n.meta && { meta: n.meta }
  };
}
c(K_, "B1");
d(K_, "dehydrateQuery");
function J_(n) {
  return n.state.isPaused;
}
c(J_, "q1");
d(J_, "defaultShouldDehydrateMutation");
function tz(n) {
  return n.state.status === "success";
}
c(tz, "N1");
d(tz, "defaultShouldDehydrateQuery");
function ez(n) {
  return !0;
}
c(ez, "j1");
d(ez, "defaultShouldRedactErrors");
function iz(n, t = {}) {
  const e = t.shouldDehydrateMutation ?? n.getDefaultOptions().dehydrate?.shouldDehydrateMutation ?? J_, i = n.getMutationCache().getAll().flatMap(
    (l) => e(l) ? [G_(l)] : []
  ), s = t.shouldDehydrateQuery ?? n.getDefaultOptions().dehydrate?.shouldDehydrateQuery ?? tz, r = t.shouldRedactErrors ?? n.getDefaultOptions().dehydrate?.shouldRedactErrors ?? ez, a = t.serializeData ?? n.getDefaultOptions().dehydrate?.serializeData ?? AP, o = n.getQueryCache().getAll().flatMap(
    (l) => s(l) ? [K_(l, a, r)] : []
  );
  return { mutations: i, queries: o };
}
c(iz, "W1");
d(iz, "dehydrate");
function nz(n, t, e) {
  if (typeof t != "object" || t === null)
    return;
  const i = n.getMutationCache(), s = n.getQueryCache(), r = n.getDefaultOptions().hydrate?.deserializeData ?? AP, a = t.mutations || [], o = t.queries || [];
  a.forEach(({ state: l, ...h }) => {
    i.build(
      n,
      {
        ...n.getDefaultOptions().hydrate?.mutations,
        ...e?.defaultOptions?.mutations,
        ...h
      },
      l
    );
  }), o.forEach(
    ({ queryKey: l, state: h, queryHash: u, meta: p, promise: y, dehydratedAt: m }) => {
      const g = y ? Y_(y) : void 0, b = h.data === void 0 ? g?.data : h.data, S = b === void 0 ? b : r(b);
      let x = s.get(u);
      const Q = x?.state.status === "pending", L = x?.state.fetchStatus === "fetching";
      if (x) {
        const W = g && // We only need this undefined check to handle older dehydration
        // payloads that might not have dehydratedAt
        m !== void 0 && m > x.state.dataUpdatedAt;
        if (h.dataUpdatedAt > x.state.dataUpdatedAt || W) {
          const { fetchStatus: R, ...I } = h;
          x.setState({
            ...I,
            data: S
          });
        }
      } else
        x = s.build(
          n,
          {
            ...n.getDefaultOptions().hydrate?.queries,
            ...e?.defaultOptions?.queries,
            queryKey: l,
            queryHash: u,
            meta: p
          },
          // Reset fetch status to idle to avoid
          // query being stuck in fetching state upon hydration
          {
            ...h,
            data: S,
            fetchStatus: "idle",
            status: S !== void 0 ? "success" : h.status
          }
        );
      y && !Q && !L && // Only hydrate if dehydration is newer than any existing data,
      // this is always true for new queries
      (m === void 0 || m > x.state.dataUpdatedAt) && x.fetch(void 0, {
        // RSC transformed promises are not thenable
        initialPromise: Promise.resolve(y).then(r)
      }).catch(Je);
    }
  );
}
c(nz, "Q1");
d(nz, "hydrate");
var tB = X_;
function sz() {
  let n = [], t = 0, e = /* @__PURE__ */ d((o) => {
    o();
  }, "notifyFn"), i = /* @__PURE__ */ d((o) => {
    o();
  }, "batchNotifyFn"), s = tB;
  const r = /* @__PURE__ */ d((o) => {
    t ? n.push(o) : s(() => {
      e(o);
    });
  }, "schedule"), a = /* @__PURE__ */ d(() => {
    const o = n;
    n = [], o.length && s(() => {
      i(() => {
        o.forEach((l) => {
          e(l);
        });
      });
    });
  }, "flush");
  return {
    batch: /* @__PURE__ */ d((o) => {
      let l;
      t++;
      try {
        l = o();
      } finally {
        t--, t || a();
      }
      return l;
    }, "batch"),
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: /* @__PURE__ */ d((o) => (...l) => {
      r(() => {
        o(...l);
      });
    }, "batchCalls"),
    schedule: r,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: /* @__PURE__ */ d((o) => {
      e = o;
    }, "setNotifyFunction"),
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: /* @__PURE__ */ d((o) => {
      i = o;
    }, "setBatchNotifyFunction"),
    setScheduler: /* @__PURE__ */ d((o) => {
      s = o;
    }, "setScheduler")
  };
}
c(sz, "G1");
d(sz, "createNotifyManager");
var ii = sz(), tg, za, eg, q2, tp, eB = (q2 = (tp = class extends Cm {
  constructor() {
    super(), Z(this, tg, !0), Z(this, za), Z(this, eg), _(this, eg, (t) => {
      if (!rm && window.addEventListener) {
        const e = /* @__PURE__ */ d(() => t(!0), "onlineListener"), i = /* @__PURE__ */ d(() => t(!1), "offlineListener");
        return window.addEventListener("online", e, !1), window.addEventListener("offline", i, !1), () => {
          window.removeEventListener("online", e), window.removeEventListener("offline", i);
        };
      }
    });
  }
  onSubscribe() {
    $(this, za) || this.setEventListener($(this, eg));
  }
  onUnsubscribe() {
    var t;
    this.hasListeners() || ((t = $(this, za)) == null || t.call(this), _(this, za, void 0));
  }
  setEventListener(t) {
    var e;
    _(this, eg, t), (e = $(this, za)) == null || e.call(this), _(this, za, t(this.setOnline.bind(this)));
  }
  setOnline(t) {
    $(this, tg) !== t && (_(this, tg, t), this.listeners.forEach((e) => {
      e(t);
    }));
  }
  isOnline() {
    return $(this, tg);
  }
}, c(tp, "kn"), tp), tg = /* @__PURE__ */ new WeakMap(), za = /* @__PURE__ */ new WeakMap(), eg = /* @__PURE__ */ new WeakMap(), d(q2, "OnlineManager"), q2), JO = new eB();
function rz(n) {
  return Math.min(1e3 * 2 ** n, 3e4);
}
c(rz, "Y1");
d(rz, "defaultRetryDelay");
function RP(n) {
  return (n ?? "online") === "online" ? JO.isOnline() : !0;
}
c(RP, "Kf");
d(RP, "canFetch");
var Z2, ep, G5 = (Z2 = (ep = class extends Error {
  constructor(t) {
    super("CancelledError"), this.revert = t?.revert, this.silent = t?.silent;
  }
}, c(ep, "_n"), ep), d(Z2, "CancelledError"), Z2);
function EP(n) {
  let t = !1, e = 0, i;
  const s = KO(), r = /* @__PURE__ */ d(() => s.status !== "pending", "isResolved"), a = /* @__PURE__ */ d((b) => {
    if (!r()) {
      const S = new G5(b);
      y(S), n.onCancel?.(S);
    }
  }, "cancel"), o = /* @__PURE__ */ d(() => {
    t = !0;
  }, "cancelRetry"), l = /* @__PURE__ */ d(() => {
    t = !1;
  }, "continueRetry"), h = /* @__PURE__ */ d(() => MP.isFocused() && (n.networkMode === "always" || JO.isOnline()) && n.canRun(), "canContinue"), u = /* @__PURE__ */ d(() => RP(n.networkMode) && n.canRun(), "canStart"), p = /* @__PURE__ */ d((b) => {
    r() || (i?.(), s.resolve(b));
  }, "resolve"), y = /* @__PURE__ */ d((b) => {
    r() || (i?.(), s.reject(b));
  }, "reject"), m = /* @__PURE__ */ d(() => new Promise((b) => {
    i = /* @__PURE__ */ d((S) => {
      (r() || h()) && b(S);
    }, "continueFn"), n.onPause?.();
  }).then(() => {
    i = void 0, r() || n.onContinue?.();
  }), "pause"), g = /* @__PURE__ */ d(() => {
    if (r())
      return;
    let b;
    const S = e === 0 ? n.initialPromise : void 0;
    try {
      b = S ?? n.fn();
    } catch (x) {
      b = Promise.reject(x);
    }
    Promise.resolve(b).then(p).catch((x) => {
      if (r())
        return;
      const Q = n.retry ?? (rm ? 0 : 3), L = n.retryDelay ?? rz, W = typeof L == "function" ? L(e, x) : L, R = Q === !0 || typeof Q == "number" && e < Q || typeof Q == "function" && Q(e, x);
      if (t || !R) {
        y(x);
        return;
      }
      e++, n.onFail?.(e, x), j_(W).then(() => h() ? void 0 : m()).then(() => {
        t ? y(x) : g();
      });
    });
  }, "run");
  return {
    promise: s,
    status: /* @__PURE__ */ d(() => s.status, "status"),
    cancel: a,
    continue: /* @__PURE__ */ d(() => (i?.(), s), "continue"),
    cancelRetry: o,
    continueRetry: l,
    canStart: u,
    start: /* @__PURE__ */ d(() => (u() ? g() : m().then(g), s), "start")
  };
}
c(EP, "Gf");
d(EP, "createRetryer");
var Qc, F2, ip, az = (F2 = (ip = class {
  constructor() {
    Z(this, Qc);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), HO(this.gcTime) && _(this, Qc, Tr.setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t ?? (rm ? 1 / 0 : 300 * 1e3)
    );
  }
  clearGcTimeout() {
    $(this, Qc) && (Tr.clearTimeout($(this, Qc)), _(this, Qc, void 0));
  }
}, c(ip, "Pn"), ip), Qc = /* @__PURE__ */ new WeakMap(), d(F2, "Removable"), F2), Tc, ig, On, Mc, Ye, rv, Ac, Zn, xs, X2, np, iB = (X2 = (np = class extends az {
  constructor(t) {
    super(), Z(this, Zn), Z(this, Tc), Z(this, ig), Z(this, On), Z(this, Mc), Z(this, Ye), Z(this, rv), Z(this, Ac), _(this, Ac, !1), _(this, rv, t.defaultOptions), this.setOptions(t.options), this.observers = [], _(this, Mc, t.client), _(this, On, $(this, Mc).getQueryCache()), this.queryKey = t.queryKey, this.queryHash = t.queryHash, _(this, Tc, J5(this.options)), this.state = t.state ?? $(this, Tc), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return $(this, Ye)?.promise;
  }
  setOptions(t) {
    if (this.options = { ...$(this, rv), ...t }, this.updateGcTime(this.options.gcTime), this.state && this.state.data === void 0) {
      const e = J5(this.options);
      e.data !== void 0 && (this.setState(
        K5(e.data, e.dataUpdatedAt)
      ), _(this, Tc, e));
    }
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && $(this, On).remove(this);
  }
  setData(t, e) {
    const i = GO(this.state.data, t, this.options);
    return vt(this, Zn, xs).call(this, {
      data: i,
      type: "success",
      dataUpdatedAt: e?.updatedAt,
      manual: e?.manual
    }), i;
  }
  setState(t, e) {
    vt(this, Zn, xs).call(this, { type: "setState", state: t, setStateOptions: e });
  }
  cancel(t) {
    const e = $(this, Ye)?.promise;
    return $(this, Ye)?.cancel(t), e ? e.then(Je).catch(Je) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState($(this, Tc));
  }
  isActive() {
    return this.observers.some(
      (t) => Bi(t.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === QP || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (t) => js(t.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (t) => t.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(t = 0) {
    return this.state.data === void 0 ? !0 : t === "static" ? !1 : this.state.isInvalidated ? !0 : !PP(this.state.dataUpdatedAt, t);
  }
  onFocus() {
    this.observers.find((t) => t.shouldFetchOnWindowFocus())?.refetch({ cancelRefetch: !1 }), $(this, Ye)?.continue();
  }
  onOnline() {
    this.observers.find((t) => t.shouldFetchOnReconnect())?.refetch({ cancelRefetch: !1 }), $(this, Ye)?.continue();
  }
  addObserver(t) {
    this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), $(this, On).notify({ type: "observerAdded", query: this, observer: t }));
  }
  removeObserver(t) {
    this.observers.includes(t) && (this.observers = this.observers.filter((e) => e !== t), this.observers.length || ($(this, Ye) && ($(this, Ac) ? $(this, Ye).cancel({ revert: !0 }) : $(this, Ye).cancelRetry()), this.scheduleGc()), $(this, On).notify({ type: "observerRemoved", query: this, observer: t }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || vt(this, Zn, xs).call(this, { type: "invalidate" });
  }
  async fetch(t, e) {
    if (this.state.fetchStatus !== "idle" && // If the promise in the retryer is already rejected, we have to definitely
    // re-start the fetch; there is a chance that the query is still in a
    // pending state when that happens
    $(this, Ye)?.status() !== "rejected") {
      if (this.state.data !== void 0 && e?.cancelRefetch)
        this.cancel({ silent: !0 });
      else if ($(this, Ye))
        return $(this, Ye).continueRetry(), $(this, Ye).promise;
    }
    if (t && this.setOptions(t), !this.options.queryFn) {
      const o = this.observers.find((l) => l.options.queryFn);
      o && this.setOptions(o.options);
    }
    const i = new AbortController(), s = /* @__PURE__ */ d((o) => {
      Object.defineProperty(o, "signal", {
        enumerable: !0,
        get: /* @__PURE__ */ d(() => (_(this, Ac, !0), i.signal), "get")
      });
    }, "addSignalProperty"), r = /* @__PURE__ */ d(() => {
      const o = TP(this.options, e), l = (/* @__PURE__ */ d(() => {
        const h = {
          client: $(this, Mc),
          queryKey: this.queryKey,
          meta: this.meta
        };
        return s(h), h;
      }, "createQueryFnContext"))();
      return _(this, Ac, !1), this.options.persister ? this.options.persister(
        o,
        l,
        this
      ) : o(l);
    }, "fetchFn"), a = (/* @__PURE__ */ d(() => {
      const o = {
        fetchOptions: e,
        options: this.options,
        queryKey: this.queryKey,
        client: $(this, Mc),
        state: this.state,
        fetchFn: r
      };
      return s(o), o;
    }, "createFetchContext"))();
    this.options.behavior?.onFetch(a, this), _(this, ig, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== a.fetchOptions?.meta) && vt(this, Zn, xs).call(this, { type: "fetch", meta: a.fetchOptions?.meta }), _(this, Ye, EP({
      initialPromise: e?.initialPromise,
      fn: a.fetchFn,
      onCancel: /* @__PURE__ */ d((o) => {
        o instanceof G5 && o.revert && this.setState({
          ...$(this, ig),
          fetchStatus: "idle"
        }), i.abort();
      }, "onCancel"),
      onFail: /* @__PURE__ */ d((o, l) => {
        vt(this, Zn, xs).call(this, { type: "failed", failureCount: o, error: l });
      }, "onFail"),
      onPause: /* @__PURE__ */ d(() => {
        vt(this, Zn, xs).call(this, { type: "pause" });
      }, "onPause"),
      onContinue: /* @__PURE__ */ d(() => {
        vt(this, Zn, xs).call(this, { type: "continue" });
      }, "onContinue"),
      retry: a.options.retry,
      retryDelay: a.options.retryDelay,
      networkMode: a.options.networkMode,
      canRun: /* @__PURE__ */ d(() => !0, "canRun")
    }));
    try {
      const o = await $(this, Ye).start();
      if (o === void 0)
        throw new Error(`${this.queryHash} data is undefined`);
      return this.setData(o), $(this, On).config.onSuccess?.(o, this), $(this, On).config.onSettled?.(
        o,
        this.state.error,
        this
      ), o;
    } catch (o) {
      if (o instanceof G5) {
        if (o.silent)
          return $(this, Ye).promise;
        if (o.revert) {
          if (this.state.data === void 0)
            throw o;
          return this.state.data;
        }
      }
      throw vt(this, Zn, xs).call(this, {
        type: "error",
        error: o
      }), $(this, On).config.onError?.(
        o,
        this
      ), $(this, On).config.onSettled?.(
        this.state.data,
        o,
        this
      ), o;
    } finally {
      this.scheduleGc();
    }
  }
}, c(np, "Sn"), np), Tc = /* @__PURE__ */ new WeakMap(), ig = /* @__PURE__ */ new WeakMap(), On = /* @__PURE__ */ new WeakMap(), Mc = /* @__PURE__ */ new WeakMap(), Ye = /* @__PURE__ */ new WeakMap(), rv = /* @__PURE__ */ new WeakMap(), Ac = /* @__PURE__ */ new WeakMap(), Zn = /* @__PURE__ */ new WeakSet(), xs = /* @__PURE__ */ d(function(n) {
  const t = /* @__PURE__ */ d((e) => {
    switch (n.type) {
      case "failed":
        return {
          ...e,
          fetchFailureCount: n.failureCount,
          fetchFailureReason: n.error
        };
      case "pause":
        return {
          ...e,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...e,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...e,
          ..._P(e.data, this.options),
          fetchMeta: n.meta ?? null
        };
      case "success":
        const i = {
          ...e,
          ...K5(n.data, n.dataUpdatedAt),
          dataUpdateCount: e.dataUpdateCount + 1,
          ...!n.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
        return _(this, ig, n.manual ? i : void 0), i;
      case "error":
        const s = n.error;
        return {
          ...e,
          error: s,
          errorUpdateCount: e.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: e.fetchFailureCount + 1,
          fetchFailureReason: s,
          fetchStatus: "idle",
          status: "error",
          // flag existing data as invalidated if we get a background error
          // note that "no data" always means stale so we can set unconditionally here
          isInvalidated: !0
        };
      case "invalidate":
        return {
          ...e,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...e,
          ...n.state
        };
    }
  }, "reducer");
  this.state = t(this.state), ii.batch(() => {
    this.observers.forEach((e) => {
      e.onQueryUpdate();
    }), $(this, On).notify({ query: this, type: "updated", action: n });
  });
}, "#dispatch"), d(X2, "Query"), X2);
function _P(n, t) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: RP(t.networkMode) ? "fetching" : "paused",
    ...n === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
c(_P, "Yf");
d(_P, "fetchState");
function K5(n, t) {
  return {
    data: n,
    dataUpdatedAt: t ?? Date.now(),
    error: null,
    isInvalidated: !1,
    status: "success"
  };
}
c(K5, "Aw");
d(K5, "successState");
function J5(n) {
  const t = typeof n.initialData == "function" ? n.initialData() : n.initialData, e = t !== void 0, i = e ? typeof n.initialDataUpdatedAt == "function" ? n.initialDataUpdatedAt() : n.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: e ? i ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: e ? "success" : "pending",
    fetchStatus: "idle"
  };
}
c(J5, "zw");
d(J5, "getDefaultState$1");
var Zi, Lt, av, Si, Rc, ng, ur, La, ov, sg, rg, Ec, _c, Ia, ag, ye, og, N2, j2, B2, U2, H2, Y2, G2, s9, K2, sp, oz = (K2 = (sp = class extends Cm {
  constructor(t, e) {
    super(), Z(this, ye), Z(this, Zi), Z(this, Lt), Z(this, av), Z(this, Si), Z(this, Rc), Z(this, ng), Z(this, ur), Z(this, La), Z(this, ov), Z(this, sg), Z(this, rg), Z(this, Ec), Z(this, _c), Z(this, Ia), Z(this, ag, /* @__PURE__ */ new Set()), this.options = e, _(this, Zi, t), _(this, La, null), _(this, ur, KO()), this.bindMethods(), this.setOptions(e);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && ($(this, Lt).addObserver(this), tS($(this, Lt), this.options) ? vt(this, ye, og).call(this) : this.updateResult(), vt(this, ye, U2).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return tb(
      $(this, Lt),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return tb(
      $(this, Lt),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), vt(this, ye, H2).call(this), vt(this, ye, Y2).call(this), $(this, Lt).removeObserver(this);
  }
  setOptions(t) {
    const e = this.options, i = $(this, Lt);
    if (this.options = $(this, Zi).defaultQueryOptions(t), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof Bi(this.options.enabled, $(this, Lt)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    vt(this, ye, G2).call(this), $(this, Lt).setOptions(this.options), e._defaulted && !zw(this.options, e) && $(this, Zi).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: $(this, Lt),
      observer: this
    });
    const s = this.hasListeners();
    s && eS(
      $(this, Lt),
      i,
      this.options,
      e
    ) && vt(this, ye, og).call(this), this.updateResult(), s && ($(this, Lt) !== i || Bi(this.options.enabled, $(this, Lt)) !== Bi(e.enabled, $(this, Lt)) || js(this.options.staleTime, $(this, Lt)) !== js(e.staleTime, $(this, Lt))) && vt(this, ye, N2).call(this);
    const r = vt(this, ye, j2).call(this);
    s && ($(this, Lt) !== i || Bi(this.options.enabled, $(this, Lt)) !== Bi(e.enabled, $(this, Lt)) || r !== $(this, Ia)) && vt(this, ye, B2).call(this, r);
  }
  getOptimisticResult(t) {
    const e = $(this, Zi).getQueryCache().build($(this, Zi), t), i = this.createResult(e, t);
    return cz(this, i) && (_(this, Si, i), _(this, ng, this.options), _(this, Rc, $(this, Lt).state)), i;
  }
  getCurrentResult() {
    return $(this, Si);
  }
  trackResult(t, e) {
    return new Proxy(t, {
      get: /* @__PURE__ */ d((i, s) => (this.trackProp(s), e?.(s), s === "promise" && (this.trackProp("data"), !this.options.experimental_prefetchInRender && $(this, ur).status === "pending" && $(this, ur).reject(
        new Error(
          "experimental_prefetchInRender feature flag is not enabled"
        )
      )), Reflect.get(i, s)), "get")
    });
  }
  trackProp(t) {
    $(this, ag).add(t);
  }
  getCurrentQuery() {
    return $(this, Lt);
  }
  refetch({ ...t } = {}) {
    return this.fetch({
      ...t
    });
  }
  fetchOptimistic(t) {
    const e = $(this, Zi).defaultQueryOptions(t), i = $(this, Zi).getQueryCache().build($(this, Zi), e);
    return i.fetch().then(() => this.createResult(i, e));
  }
  fetch(t) {
    return vt(this, ye, og).call(this, {
      ...t,
      cancelRefetch: t.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), $(this, Si)));
  }
  createResult(t, e) {
    const i = $(this, Lt), s = this.options, r = $(this, Si), a = $(this, Rc), o = $(this, ng), l = t !== i ? t.state : $(this, av), { state: h } = t;
    let u = { ...h }, p = !1, y;
    if (e._optimisticResults) {
      const V = this.hasListeners(), X = !V && tS(t, e), J = V && eS(t, i, e, s);
      (X || J) && (u = {
        ...u,
        ..._P(h.data, t.options)
      }), e._optimisticResults === "isRestoring" && (u.fetchStatus = "idle");
    }
    let { error: m, errorUpdatedAt: g, status: b } = u;
    y = u.data;
    let S = !1;
    if (e.placeholderData !== void 0 && y === void 0 && b === "pending") {
      let V;
      r?.isPlaceholderData && e.placeholderData === o?.placeholderData ? (V = r.data, S = !0) : V = typeof e.placeholderData == "function" ? e.placeholderData(
        $(this, rg)?.state.data,
        $(this, rg)
      ) : e.placeholderData, V !== void 0 && (b = "success", y = GO(
        r?.data,
        V,
        e
      ), p = !0);
    }
    if (e.select && y !== void 0 && !S)
      if (r && y === a?.data && e.select === $(this, ov))
        y = $(this, sg);
      else
        try {
          _(this, ov, e.select), y = e.select(y), y = GO(r?.data, y, e), _(this, sg, y), _(this, La, null);
        } catch (V) {
          _(this, La, V);
        }
    $(this, La) && (m = $(this, La), y = $(this, sg), g = Date.now(), b = "error");
    const x = u.fetchStatus === "fetching", Q = b === "pending", L = b === "error", W = Q && x, R = y !== void 0, I = {
      status: b,
      fetchStatus: u.fetchStatus,
      isPending: Q,
      isSuccess: b === "success",
      isError: L,
      isInitialLoading: W,
      isLoading: W,
      data: y,
      dataUpdatedAt: u.dataUpdatedAt,
      error: m,
      errorUpdatedAt: g,
      failureCount: u.fetchFailureCount,
      failureReason: u.fetchFailureReason,
      errorUpdateCount: u.errorUpdateCount,
      isFetched: u.dataUpdateCount > 0 || u.errorUpdateCount > 0,
      isFetchedAfterMount: u.dataUpdateCount > l.dataUpdateCount || u.errorUpdateCount > l.errorUpdateCount,
      isFetching: x,
      isRefetching: x && !Q,
      isLoadingError: L && !R,
      isPaused: u.fetchStatus === "paused",
      isPlaceholderData: p,
      isRefetchError: L && R,
      isStale: c0(t, e),
      refetch: this.refetch,
      promise: $(this, ur),
      isEnabled: Bi(e.enabled, t) !== !1
    };
    if (this.options.experimental_prefetchInRender) {
      const V = I.data !== void 0, X = I.status === "error" && !V, J = /* @__PURE__ */ d((G) => {
        X ? G.reject(I.error) : V && G.resolve(I.data);
      }, "finalizeThenableIfPossible"), mt = /* @__PURE__ */ d(() => {
        const G = _(this, ur, I.promise = KO());
        J(G);
      }, "recreateThenable"), at = $(this, ur);
      switch (at.status) {
        case "pending":
          t.queryHash === i.queryHash && J(at);
          break;
        case "fulfilled":
          (X || I.data !== at.value) && mt();
          break;
        case "rejected":
          (!X || I.error !== at.reason) && mt();
          break;
      }
    }
    return I;
  }
  updateResult() {
    const t = $(this, Si), e = this.createResult($(this, Lt), this.options);
    if (_(this, Rc, $(this, Lt).state), _(this, ng, this.options), $(this, Rc).data !== void 0 && _(this, rg, $(this, Lt)), zw(e, t))
      return;
    _(this, Si, e);
    const i = /* @__PURE__ */ d(() => {
      if (!t)
        return !0;
      const { notifyOnChangeProps: s } = this.options, r = typeof s == "function" ? s() : s;
      if (r === "all" || !r && !$(this, ag).size)
        return !0;
      const a = new Set(
        r ?? $(this, ag)
      );
      return this.options.throwOnError && a.add("error"), Object.keys($(this, Si)).some((o) => {
        const l = o;
        return $(this, Si)[l] !== t[l] && a.has(l);
      });
    }, "shouldNotifyListeners");
    vt(this, ye, s9).call(this, { listeners: i() });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && vt(this, ye, U2).call(this);
  }
}, c(sp, "Ln"), sp), Zi = /* @__PURE__ */ new WeakMap(), Lt = /* @__PURE__ */ new WeakMap(), av = /* @__PURE__ */ new WeakMap(), Si = /* @__PURE__ */ new WeakMap(), Rc = /* @__PURE__ */ new WeakMap(), ng = /* @__PURE__ */ new WeakMap(), ur = /* @__PURE__ */ new WeakMap(), La = /* @__PURE__ */ new WeakMap(), ov = /* @__PURE__ */ new WeakMap(), sg = /* @__PURE__ */ new WeakMap(), rg = /* @__PURE__ */ new WeakMap(), Ec = /* @__PURE__ */ new WeakMap(), _c = /* @__PURE__ */ new WeakMap(), Ia = /* @__PURE__ */ new WeakMap(), ag = /* @__PURE__ */ new WeakMap(), ye = /* @__PURE__ */ new WeakSet(), og = /* @__PURE__ */ d(function(n) {
  vt(this, ye, G2).call(this);
  let t = $(this, Lt).fetch(
    this.options,
    n
  );
  return n?.throwOnError || (t = t.catch(Je)), t;
}, "#executeFetch"), N2 = /* @__PURE__ */ d(function() {
  vt(this, ye, H2).call(this);
  const n = js(
    this.options.staleTime,
    $(this, Lt)
  );
  if (rm || $(this, Si).isStale || !HO(n))
    return;
  const t = PP($(this, Si).dataUpdatedAt, n) + 1;
  _(this, Ec, Tr.setTimeout(() => {
    $(this, Si).isStale || this.updateResult();
  }, t));
}, "#updateStaleTimeout"), j2 = /* @__PURE__ */ d(function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval($(this, Lt)) : this.options.refetchInterval) ?? !1;
}, "#computeRefetchInterval"), B2 = /* @__PURE__ */ d(function(n) {
  vt(this, ye, Y2).call(this), _(this, Ia, n), !(rm || Bi(this.options.enabled, $(this, Lt)) === !1 || !HO($(this, Ia)) || $(this, Ia) === 0) && _(this, _c, Tr.setInterval(() => {
    (this.options.refetchIntervalInBackground || MP.isFocused()) && vt(this, ye, og).call(this);
  }, $(this, Ia)));
}, "#updateRefetchInterval"), U2 = /* @__PURE__ */ d(function() {
  vt(this, ye, N2).call(this), vt(this, ye, B2).call(this, vt(this, ye, j2).call(this));
}, "#updateTimers"), H2 = /* @__PURE__ */ d(function() {
  $(this, Ec) && (Tr.clearTimeout($(this, Ec)), _(this, Ec, void 0));
}, "#clearStaleTimeout"), Y2 = /* @__PURE__ */ d(function() {
  $(this, _c) && (Tr.clearInterval($(this, _c)), _(this, _c, void 0));
}, "#clearRefetchInterval"), G2 = /* @__PURE__ */ d(function() {
  const n = $(this, Zi).getQueryCache().build($(this, Zi), this.options);
  if (n === $(this, Lt))
    return;
  const t = $(this, Lt);
  _(this, Lt, n), _(this, av, n.state), this.hasListeners() && (t?.removeObserver(this), n.addObserver(this));
}, "#updateQuery"), s9 = /* @__PURE__ */ d(function(n) {
  ii.batch(() => {
    n.listeners && this.listeners.forEach((t) => {
      t($(this, Si));
    }), $(this, Zi).getQueryCache().notify({
      query: $(this, Lt),
      type: "observerResultsUpdated"
    });
  });
}, "#notify"), d(K2, "QueryObserver"), K2);
function lz(n, t) {
  return Bi(t.enabled, n) !== !1 && n.state.data === void 0 && !(n.state.status === "error" && t.retryOnMount === !1);
}
c(lz, "J1");
d(lz, "shouldLoadOnMount");
function tS(n, t) {
  return lz(n, t) || n.state.data !== void 0 && tb(n, t, t.refetchOnMount);
}
c(tS, "Rw");
d(tS, "shouldFetchOnMount");
function tb(n, t, e) {
  if (Bi(t.enabled, n) !== !1 && js(t.staleTime, n) !== "static") {
    const i = typeof e == "function" ? e(n) : e;
    return i === "always" || i !== !1 && c0(n, t);
  }
  return !1;
}
c(tb, "iu");
d(tb, "shouldFetchOn");
function eS(n, t, e, i) {
  return (n !== t || Bi(i.enabled, n) === !1) && (!e.suspense || n.state.status !== "error") && c0(n, e);
}
c(eS, "Ew");
d(eS, "shouldFetchOptionally");
function c0(n, t) {
  return Bi(t.enabled, n) !== !1 && n.isStaleByTime(js(t.staleTime, n));
}
c(c0, "ju");
d(c0, "isStale");
function cz(n, t) {
  return !zw(n.getCurrentResult(), t);
}
c(cz, "tg");
d(cz, "shouldAssignObserverCurrentProperties");
function Lw(n) {
  return {
    onFetch: /* @__PURE__ */ d((t, e) => {
      const i = t.options, s = t.fetchOptions?.meta?.fetchMore?.direction, r = t.state.data?.pages || [], a = t.state.data?.pageParams || [];
      let o = { pages: [], pageParams: [] }, l = 0;
      const h = /* @__PURE__ */ d(async () => {
        let u = !1;
        const p = /* @__PURE__ */ d((g) => {
          H_(
            g,
            () => t.signal,
            () => u = !0
          );
        }, "addSignalProperty"), y = TP(t.options, t.fetchOptions), m = /* @__PURE__ */ d(async (g, b, S) => {
          if (u)
            return Promise.reject();
          if (b == null && g.pages.length)
            return Promise.resolve(g);
          const x = (/* @__PURE__ */ d(() => {
            const R = {
              client: t.client,
              queryKey: t.queryKey,
              pageParam: b,
              direction: S ? "backward" : "forward",
              meta: t.options.meta
            };
            return p(R), R;
          }, "createQueryFnContext"))(), Q = await y(x), { maxPages: L } = t.options, W = S ? U_ : B_;
          return {
            pages: W(g.pages, Q, L),
            pageParams: W(g.pageParams, b, L)
          };
        }, "fetchPage");
        if (s && r.length) {
          const g = s === "backward", b = g ? zP : eb, S = {
            pages: r,
            pageParams: a
          }, x = b(i, S);
          o = await m(S, x, g);
        } else {
          const g = n ?? r.length;
          do {
            const b = l === 0 ? a[0] ?? i.initialPageParam : eb(i, o);
            if (l > 0 && b == null)
              break;
            o = await m(o, b), l++;
          } while (l < g);
        }
        return o;
      }, "fetchFn");
      t.options.persister ? t.fetchFn = () => t.options.persister?.(
        h,
        {
          client: t.client,
          queryKey: t.queryKey,
          meta: t.options.meta,
          signal: t.signal
        },
        e
      ) : t.fetchFn = h;
    }, "onFetch")
  };
}
c(Lw, "Vd");
d(Lw, "infiniteQueryBehavior");
function eb(n, { pages: t, pageParams: e }) {
  const i = t.length - 1;
  return t.length > 0 ? n.getNextPageParam(
    t[i],
    t,
    e[i],
    e
  ) : void 0;
}
c(eb, "ru");
d(eb, "getNextPageParam");
function zP(n, { pages: t, pageParams: e }) {
  return t.length > 0 ? n.getPreviousPageParam?.(t[0], t, e[0], e) : void 0;
}
c(zP, "tm");
d(zP, "getPreviousPageParam");
function hz(n, t) {
  return t ? eb(n, t) != null : !1;
}
c(hz, "eg");
d(hz, "hasNextPage");
function dz(n, t) {
  return !t || !n.getPreviousPageParam ? !1 : zP(n, t) != null;
}
c(dz, "ig");
d(dz, "hasPreviousPage");
var J2, rp, nB = (J2 = (rp = class extends oz {
  constructor(t, e) {
    super(t, e);
  }
  bindMethods() {
    super.bindMethods(), this.fetchNextPage = this.fetchNextPage.bind(this), this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
  }
  setOptions(t) {
    super.setOptions({
      ...t,
      behavior: Lw()
    });
  }
  getOptimisticResult(t) {
    return t.behavior = Lw(), super.getOptimisticResult(t);
  }
  fetchNextPage(t) {
    return this.fetch({
      ...t,
      meta: {
        fetchMore: { direction: "forward" }
      }
    });
  }
  fetchPreviousPage(t) {
    return this.fetch({
      ...t,
      meta: {
        fetchMore: { direction: "backward" }
      }
    });
  }
  createResult(t, e) {
    const { state: i } = t, s = super.createResult(t, e), { isFetching: r, isRefetching: a, isError: o, isRefetchError: l } = s, h = i.fetchMeta?.fetchMore?.direction, u = o && h === "forward", p = r && h === "forward", y = o && h === "backward", m = r && h === "backward";
    return {
      ...s,
      fetchNextPage: this.fetchNextPage,
      fetchPreviousPage: this.fetchPreviousPage,
      hasNextPage: hz(e, i.data),
      hasPreviousPage: dz(e, i.data),
      isFetchNextPageError: u,
      isFetchingNextPage: p,
      isFetchPreviousPageError: y,
      isFetchingPreviousPage: m,
      isRefetchError: l && !u && !y,
      isRefetching: a && !p && !m
    };
  }
}, c(rp, "On"), rp), d(J2, "InfiniteQueryObserver"), J2), lv, ks, Ci, zc, Ss, pr, t$, ap, sB = (t$ = (ap = class extends az {
  constructor(t) {
    super(), Z(this, Ss), Z(this, lv), Z(this, ks), Z(this, Ci), Z(this, zc), _(this, lv, t.client), this.mutationId = t.mutationId, _(this, Ci, t.mutationCache), _(this, ks, []), this.state = t.state || LP(), this.setOptions(t.options), this.scheduleGc();
  }
  setOptions(t) {
    this.options = t, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(t) {
    $(this, ks).includes(t) || ($(this, ks).push(t), this.clearGcTimeout(), $(this, Ci).notify({
      type: "observerAdded",
      mutation: this,
      observer: t
    }));
  }
  removeObserver(t) {
    _(this, ks, $(this, ks).filter((e) => e !== t)), this.scheduleGc(), $(this, Ci).notify({
      type: "observerRemoved",
      mutation: this,
      observer: t
    });
  }
  optionalRemove() {
    $(this, ks).length || (this.state.status === "pending" ? this.scheduleGc() : $(this, Ci).remove(this));
  }
  continue() {
    return $(this, zc)?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(t) {
    const e = /* @__PURE__ */ d(() => {
      vt(this, Ss, pr).call(this, { type: "continue" });
    }, "onContinue"), i = {
      client: $(this, lv),
      meta: this.options.meta,
      mutationKey: this.options.mutationKey
    };
    _(this, zc, EP({
      fn: /* @__PURE__ */ d(() => this.options.mutationFn ? this.options.mutationFn(t, i) : Promise.reject(new Error("No mutationFn found")), "fn"),
      onFail: /* @__PURE__ */ d((a, o) => {
        vt(this, Ss, pr).call(this, { type: "failed", failureCount: a, error: o });
      }, "onFail"),
      onPause: /* @__PURE__ */ d(() => {
        vt(this, Ss, pr).call(this, { type: "pause" });
      }, "onPause"),
      onContinue: e,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: /* @__PURE__ */ d(() => $(this, Ci).canRun(this), "canRun")
    }));
    const s = this.state.status === "pending", r = !$(this, zc).canStart();
    try {
      if (s)
        e();
      else {
        vt(this, Ss, pr).call(this, { type: "pending", variables: t, isPaused: r }), await $(this, Ci).config.onMutate?.(
          t,
          this,
          i
        );
        const o = await this.options.onMutate?.(
          t,
          i
        );
        o !== this.state.context && vt(this, Ss, pr).call(this, {
          type: "pending",
          context: o,
          variables: t,
          isPaused: r
        });
      }
      const a = await $(this, zc).start();
      return await $(this, Ci).config.onSuccess?.(
        a,
        t,
        this.state.context,
        this,
        i
      ), await this.options.onSuccess?.(
        a,
        t,
        this.state.context,
        i
      ), await $(this, Ci).config.onSettled?.(
        a,
        null,
        this.state.variables,
        this.state.context,
        this,
        i
      ), await this.options.onSettled?.(
        a,
        null,
        t,
        this.state.context,
        i
      ), vt(this, Ss, pr).call(this, { type: "success", data: a }), a;
    } catch (a) {
      try {
        await $(this, Ci).config.onError?.(
          a,
          t,
          this.state.context,
          this,
          i
        );
      } catch (o) {
        Promise.reject(o);
      }
      try {
        await this.options.onError?.(
          a,
          t,
          this.state.context,
          i
        );
      } catch (o) {
        Promise.reject(o);
      }
      try {
        await $(this, Ci).config.onSettled?.(
          void 0,
          a,
          this.state.variables,
          this.state.context,
          this,
          i
        );
      } catch (o) {
        Promise.reject(o);
      }
      try {
        await this.options.onSettled?.(
          void 0,
          a,
          t,
          this.state.context,
          i
        );
      } catch (o) {
        Promise.reject(o);
      }
      throw vt(this, Ss, pr).call(this, { type: "error", error: a }), a;
    } finally {
      $(this, Ci).runNext(this);
    }
  }
}, c(ap, "In"), ap), lv = /* @__PURE__ */ new WeakMap(), ks = /* @__PURE__ */ new WeakMap(), Ci = /* @__PURE__ */ new WeakMap(), zc = /* @__PURE__ */ new WeakMap(), Ss = /* @__PURE__ */ new WeakSet(), pr = /* @__PURE__ */ d(function(n) {
  const t = /* @__PURE__ */ d((e) => {
    switch (n.type) {
      case "failed":
        return {
          ...e,
          failureCount: n.failureCount,
          failureReason: n.error
        };
      case "pause":
        return {
          ...e,
          isPaused: !0
        };
      case "continue":
        return {
          ...e,
          isPaused: !1
        };
      case "pending":
        return {
          ...e,
          context: n.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: n.isPaused,
          status: "pending",
          variables: n.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...e,
          data: n.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...e,
          data: void 0,
          error: n.error,
          failureCount: e.failureCount + 1,
          failureReason: n.error,
          isPaused: !1,
          status: "error"
        };
    }
  }, "reducer");
  this.state = t(this.state), ii.batch(() => {
    $(this, ks).forEach((e) => {
      e.onMutationUpdate(n);
    }), $(this, Ci).notify({
      mutation: this,
      type: "updated",
      action: n
    });
  });
}, "#dispatch"), d(t$, "Mutation"), t$);
function LP() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
c(LP, "em");
d(LP, "getDefaultState");
var fr, Fn, cv, e$, op, rB = (e$ = (op = class extends Cm {
  constructor(t = {}) {
    super(), Z(this, fr), Z(this, Fn), Z(this, cv), this.config = t, _(this, fr, /* @__PURE__ */ new Set()), _(this, Fn, /* @__PURE__ */ new Map()), _(this, cv, 0);
  }
  build(t, e, i) {
    const s = new sB({
      client: t,
      mutationCache: this,
      mutationId: ++j5(this, cv)._,
      options: t.defaultMutationOptions(e),
      state: i
    });
    return this.add(s), s;
  }
  add(t) {
    $(this, fr).add(t);
    const e = Pg(t);
    if (typeof e == "string") {
      const i = $(this, Fn).get(e);
      i ? i.push(t) : $(this, Fn).set(e, [t]);
    }
    this.notify({ type: "added", mutation: t });
  }
  remove(t) {
    if ($(this, fr).delete(t)) {
      const e = Pg(t);
      if (typeof e == "string") {
        const i = $(this, Fn).get(e);
        if (i)
          if (i.length > 1) {
            const s = i.indexOf(t);
            s !== -1 && i.splice(s, 1);
          } else i[0] === t && $(this, Fn).delete(e);
      }
    }
    this.notify({ type: "removed", mutation: t });
  }
  canRun(t) {
    const e = Pg(t);
    if (typeof e == "string") {
      const i = $(this, Fn).get(e)?.find(
        (s) => s.state.status === "pending"
      );
      return !i || i === t;
    } else
      return !0;
  }
  runNext(t) {
    const e = Pg(t);
    return typeof e == "string" ? $(this, Fn).get(e)?.find((i) => i !== t && i.state.isPaused)?.continue() ?? Promise.resolve() : Promise.resolve();
  }
  clear() {
    ii.batch(() => {
      $(this, fr).forEach((t) => {
        this.notify({ type: "removed", mutation: t });
      }), $(this, fr).clear(), $(this, Fn).clear();
    });
  }
  getAll() {
    return Array.from($(this, fr));
  }
  find(t) {
    const e = { exact: !0, ...t };
    return this.getAll().find(
      (i) => U5(e, i)
    );
  }
  findAll(t = {}) {
    return this.getAll().filter((e) => U5(t, e));
  }
  notify(t) {
    ii.batch(() => {
      this.listeners.forEach((e) => {
        e(t);
      });
    });
  }
  resumePausedMutations() {
    const t = this.getAll().filter((e) => e.state.isPaused);
    return ii.batch(
      () => Promise.all(
        t.map((e) => e.continue().catch(Je))
      )
    );
  }
}, c(op, "Tn"), op), fr = /* @__PURE__ */ new WeakMap(), Fn = /* @__PURE__ */ new WeakMap(), cv = /* @__PURE__ */ new WeakMap(), d(e$, "MutationCache"), e$);
function Pg(n) {
  return n.options.scope?.id;
}
c(Pg, "Pd");
d(Pg, "scopeFor");
var yr, Wa, Fi, mr, Va, hv, i$, n$, lp, Xt = (n$ = (lp = class extends Cm {
  constructor(t, e) {
    super(), Z(this, Va), Z(this, yr), Z(this, Wa), Z(this, Fi), Z(this, mr), _(this, yr, t), this.setOptions(e), this.bindMethods(), vt(this, Va, hv).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);
  }
  setOptions(t) {
    const e = this.options;
    this.options = $(this, yr).defaultMutationOptions(t), zw(this.options, e) || $(this, yr).getMutationCache().notify({
      type: "observerOptionsUpdated",
      mutation: $(this, Fi),
      observer: this
    }), e?.mutationKey && this.options.mutationKey && sa(e.mutationKey) !== sa(this.options.mutationKey) ? this.reset() : $(this, Fi)?.state.status === "pending" && $(this, Fi).setOptions(this.options);
  }
  onUnsubscribe() {
    this.hasListeners() || $(this, Fi)?.removeObserver(this);
  }
  onMutationUpdate(t) {
    vt(this, Va, hv).call(this), vt(this, Va, i$).call(this, t);
  }
  getCurrentResult() {
    return $(this, Wa);
  }
  reset() {
    $(this, Fi)?.removeObserver(this), _(this, Fi, void 0), vt(this, Va, hv).call(this), vt(this, Va, i$).call(this);
  }
  mutate(t, e) {
    return _(this, mr, e), $(this, Fi)?.removeObserver(this), _(this, Fi, $(this, yr).getMutationCache().build($(this, yr), this.options)), $(this, Fi).addObserver(this), $(this, Fi).execute(t);
  }
}, c(lp, "Fn"), lp), yr = /* @__PURE__ */ new WeakMap(), Wa = /* @__PURE__ */ new WeakMap(), Fi = /* @__PURE__ */ new WeakMap(), mr = /* @__PURE__ */ new WeakMap(), Va = /* @__PURE__ */ new WeakSet(), hv = /* @__PURE__ */ d(function() {
  const n = $(this, Fi)?.state ?? LP();
  _(this, Wa, {
    ...n,
    isPending: n.status === "pending",
    isSuccess: n.status === "success",
    isError: n.status === "error",
    isIdle: n.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, "#updateResult"), i$ = /* @__PURE__ */ d(function(n) {
  ii.batch(() => {
    if ($(this, mr) && this.hasListeners()) {
      const t = $(this, Wa).variables, e = $(this, Wa).context, i = {
        client: $(this, yr),
        meta: this.options.meta,
        mutationKey: this.options.mutationKey
      };
      if (n?.type === "success") {
        try {
          $(this, mr).onSuccess?.(
            n.data,
            t,
            e,
            i
          );
        } catch (s) {
          Promise.reject(s);
        }
        try {
          $(this, mr).onSettled?.(
            n.data,
            null,
            t,
            e,
            i
          );
        } catch (s) {
          Promise.reject(s);
        }
      } else if (n?.type === "error") {
        try {
          $(this, mr).onError?.(
            n.error,
            t,
            e,
            i
          );
        } catch (s) {
          Promise.reject(s);
        }
        try {
          $(this, mr).onSettled?.(
            void 0,
            n.error,
            t,
            e,
            i
          );
        } catch (s) {
          Promise.reject(s);
        }
      }
    }
    this.listeners.forEach((t) => {
      t($(this, Wa));
    });
  });
}, "#notify"), d(n$, "MutationObserver"), n$), Cs, s$, cp, aB = (s$ = (cp = class extends Cm {
  constructor(t = {}) {
    super(), Z(this, Cs), this.config = t, _(this, Cs, /* @__PURE__ */ new Map());
  }
  build(t, e, i) {
    const s = e.queryKey, r = e.queryHash ?? l0(s, e);
    let a = this.get(r);
    return a || (a = new iB({
      client: t,
      queryKey: s,
      queryHash: r,
      options: t.defaultQueryOptions(e),
      state: i,
      defaultOptions: t.getQueryDefaults(s)
    }), this.add(a)), a;
  }
  add(t) {
    $(this, Cs).has(t.queryHash) || ($(this, Cs).set(t.queryHash, t), this.notify({
      type: "added",
      query: t
    }));
  }
  remove(t) {
    const e = $(this, Cs).get(t.queryHash);
    e && (t.destroy(), e === t && $(this, Cs).delete(t.queryHash), this.notify({ type: "removed", query: t }));
  }
  clear() {
    ii.batch(() => {
      this.getAll().forEach((t) => {
        this.remove(t);
      });
    });
  }
  get(t) {
    return $(this, Cs).get(t);
  }
  getAll() {
    return [...$(this, Cs).values()];
  }
  find(t) {
    const e = { exact: !0, ...t };
    return this.getAll().find(
      (i) => B5(e, i)
    );
  }
  findAll(t = {}) {
    const e = this.getAll();
    return Object.keys(t).length > 0 ? e.filter((i) => B5(t, i)) : e;
  }
  notify(t) {
    ii.batch(() => {
      this.listeners.forEach((e) => {
        e(t);
      });
    });
  }
  onFocus() {
    ii.batch(() => {
      this.getAll().forEach((t) => {
        t.onFocus();
      });
    });
  }
  onOnline() {
    ii.batch(() => {
      this.getAll().forEach((t) => {
        t.onOnline();
      });
    });
  }
}, c(cp, "Dn"), cp), Cs = /* @__PURE__ */ new WeakMap(), d(s$, "QueryCache"), s$), me, Da, qa, lg, cg, Za, hg, dg, r$, hp, oB = (r$ = (hp = class {
  constructor(t = {}) {
    Z(this, me), Z(this, Da), Z(this, qa), Z(this, lg), Z(this, cg), Z(this, Za), Z(this, hg), Z(this, dg), _(this, me, t.queryCache || new aB()), _(this, Da, t.mutationCache || new rB()), _(this, qa, t.defaultOptions || {}), _(this, lg, /* @__PURE__ */ new Map()), _(this, cg, /* @__PURE__ */ new Map()), _(this, Za, 0);
  }
  mount() {
    j5(this, Za)._++, $(this, Za) === 1 && (_(this, hg, MP.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), $(this, me).onFocus());
    })), _(this, dg, JO.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), $(this, me).onOnline());
    })));
  }
  unmount() {
    var t, e;
    j5(this, Za)._--, $(this, Za) === 0 && ((t = $(this, hg)) == null || t.call(this), _(this, hg, void 0), (e = $(this, dg)) == null || e.call(this), _(this, dg, void 0));
  }
  isFetching(t) {
    return $(this, me).findAll({ ...t, fetchStatus: "fetching" }).length;
  }
  isMutating(t) {
    return $(this, Da).findAll({ ...t, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(t) {
    const e = this.defaultQueryOptions({ queryKey: t });
    return $(this, me).get(e.queryHash)?.state.data;
  }
  ensureQueryData(t) {
    const e = this.defaultQueryOptions(t), i = $(this, me).build(this, e), s = i.state.data;
    return s === void 0 ? this.fetchQuery(t) : (t.revalidateIfStale && i.isStaleByTime(js(e.staleTime, i)) && this.prefetchQuery(e), Promise.resolve(s));
  }
  getQueriesData(t) {
    return $(this, me).findAll(t).map(({ queryKey: e, state: i }) => {
      const s = i.data;
      return [e, s];
    });
  }
  setQueryData(t, e, i) {
    const s = this.defaultQueryOptions({ queryKey: t }), r = $(this, me).get(
      s.queryHash
    )?.state.data, a = N_(e, r);
    if (a !== void 0)
      return $(this, me).build(this, s).setData(a, { ...i, manual: !0 });
  }
  setQueriesData(t, e, i) {
    return ii.batch(
      () => $(this, me).findAll(t).map(({ queryKey: s }) => [
        s,
        this.setQueryData(s, e, i)
      ])
    );
  }
  getQueryState(t) {
    const e = this.defaultQueryOptions({ queryKey: t });
    return $(this, me).get(
      e.queryHash
    )?.state;
  }
  removeQueries(t) {
    const e = $(this, me);
    ii.batch(() => {
      e.findAll(t).forEach((i) => {
        e.remove(i);
      });
    });
  }
  resetQueries(t, e) {
    const i = $(this, me);
    return ii.batch(() => (i.findAll(t).forEach((s) => {
      s.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...t
      },
      e
    )));
  }
  cancelQueries(t, e = {}) {
    const i = { revert: !0, ...e }, s = ii.batch(
      () => $(this, me).findAll(t).map((r) => r.cancel(i))
    );
    return Promise.all(s).then(Je).catch(Je);
  }
  invalidateQueries(t, e = {}) {
    return ii.batch(() => ($(this, me).findAll(t).forEach((i) => {
      i.invalidate();
    }), t?.refetchType === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...t,
        type: t?.refetchType ?? t?.type ?? "active"
      },
      e
    )));
  }
  refetchQueries(t, e = {}) {
    const i = {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }, s = ii.batch(
      () => $(this, me).findAll(t).filter((r) => !r.isDisabled() && !r.isStatic()).map((r) => {
        let a = r.fetch(void 0, i);
        return i.throwOnError || (a = a.catch(Je)), r.state.fetchStatus === "paused" ? Promise.resolve() : a;
      })
    );
    return Promise.all(s).then(Je);
  }
  fetchQuery(t) {
    const e = this.defaultQueryOptions(t);
    e.retry === void 0 && (e.retry = !1);
    const i = $(this, me).build(this, e);
    return i.isStaleByTime(
      js(e.staleTime, i)
    ) ? i.fetch(e) : Promise.resolve(i.state.data);
  }
  prefetchQuery(t) {
    return this.fetchQuery(t).then(Je).catch(Je);
  }
  fetchInfiniteQuery(t) {
    return t.behavior = Lw(t.pages), this.fetchQuery(t);
  }
  prefetchInfiniteQuery(t) {
    return this.fetchInfiniteQuery(t).then(Je).catch(Je);
  }
  ensureInfiniteQueryData(t) {
    return t.behavior = Lw(t.pages), this.ensureQueryData(t);
  }
  resumePausedMutations() {
    return JO.isOnline() ? $(this, Da).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return $(this, me);
  }
  getMutationCache() {
    return $(this, Da);
  }
  getDefaultOptions() {
    return $(this, qa);
  }
  setDefaultOptions(t) {
    _(this, qa, t);
  }
  setQueryDefaults(t, e) {
    $(this, lg).set(sa(t), {
      queryKey: t,
      defaultOptions: e
    });
  }
  getQueryDefaults(t) {
    const e = [...$(this, lg).values()], i = {};
    return e.forEach((s) => {
      am(t, s.queryKey) && Object.assign(i, s.defaultOptions);
    }), i;
  }
  setMutationDefaults(t, e) {
    $(this, cg).set(sa(t), {
      mutationKey: t,
      defaultOptions: e
    });
  }
  getMutationDefaults(t) {
    const e = [...$(this, cg).values()], i = {};
    return e.forEach((s) => {
      am(t, s.mutationKey) && Object.assign(i, s.defaultOptions);
    }), i;
  }
  defaultQueryOptions(t) {
    if (t._defaulted)
      return t;
    const e = {
      ...$(this, qa).queries,
      ...this.getQueryDefaults(t.queryKey),
      ...t,
      _defaulted: !0
    };
    return e.queryHash || (e.queryHash = l0(
      e.queryKey,
      e
    )), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.queryFn === QP && (e.enabled = !1), e;
  }
  defaultMutationOptions(t) {
    return t?._defaulted ? t : {
      ...$(this, qa).mutations,
      ...t?.mutationKey && this.getMutationDefaults(t.mutationKey),
      ...t,
      _defaulted: !0
    };
  }
  clear() {
    $(this, me).clear(), $(this, Da).clear();
  }
}, c(hp, "qn"), hp), me = /* @__PURE__ */ new WeakMap(), Da = /* @__PURE__ */ new WeakMap(), qa = /* @__PURE__ */ new WeakMap(), lg = /* @__PURE__ */ new WeakMap(), cg = /* @__PURE__ */ new WeakMap(), Za = /* @__PURE__ */ new WeakMap(), hg = /* @__PURE__ */ new WeakMap(), dg = /* @__PURE__ */ new WeakMap(), d(r$, "QueryClient"), r$);
function zv() {
}
c(zv, "Ap");
d(zv, "noop");
function uz({
  storage: n,
  key: t = "REACT_QUERY_OFFLINE_CACHE",
  throttleTime: e = 1e3,
  serialize: i = JSON.stringify,
  deserialize: s = JSON.parse,
  retry: r
}) {
  if (n) {
    const a = /* @__PURE__ */ d((o) => {
      try {
        n.setItem(t, i(o));
        return;
      } catch (l) {
        return l;
      }
    }, "trySave");
    return {
      persistClient: pz((o) => {
        let l = o, h = a(l), u = 0;
        for (; h && l; )
          u++, l = r?.({
            persistedClient: l,
            error: h,
            errorCount: u
          }), l && (h = a(l));
      }, e),
      restoreClient: /* @__PURE__ */ d(() => {
        const o = n.getItem(t);
        if (o)
          return s(o);
      }, "restoreClient"),
      removeClient: /* @__PURE__ */ d(() => {
        n.removeItem(t);
      }, "removeClient")
    };
  }
  return {
    persistClient: zv,
    restoreClient: zv,
    removeClient: zv
  };
}
c(uz, "cg");
d(uz, "createSyncStoragePersister");
function pz(n, t = 100) {
  let e = null, i;
  return function(...s) {
    i = s, e === null && (e = Tr.setTimeout(() => {
      n(...i), e = null;
    }, t));
  };
}
c(pz, "lg");
d(pz, "throttle$1");
var lB = ["added", "removed", "updated"];
function iS(n) {
  return lB.includes(n);
}
c(iS, "Lw");
d(iS, "isCacheEventType");
async function fz({
  queryClient: n,
  persister: t,
  maxAge: e = 1e3 * 60 * 60 * 24,
  buster: i = "",
  hydrateOptions: s
}) {
  try {
    const r = await t.restoreClient();
    if (r)
      if (r.timestamp) {
        const a = Date.now() - r.timestamp > e, o = r.buster !== i;
        if (a || o)
          return t.removeClient();
        nz(n, r.clientState, s);
      } else
        return t.removeClient();
  } catch (r) {
    throw await t.removeClient(), r;
  }
}
c(fz, "hg");
d(fz, "persistQueryClientRestore");
async function nS({
  queryClient: n,
  persister: t,
  buster: e = "",
  dehydrateOptions: i
}) {
  const s = {
    buster: e,
    timestamp: Date.now(),
    clientState: iz(n, i)
  };
  await t.persistClient(s);
}
c(nS, "Ow");
d(nS, "persistQueryClientSave");
function yz(n) {
  const t = n.queryClient.getQueryCache().subscribe((i) => {
    iS(i.type) && nS(n);
  }), e = n.queryClient.getMutationCache().subscribe((i) => {
    iS(i.type) && nS(n);
  });
  return () => {
    t(), e();
  };
}
c(yz, "pg");
d(yz, "persistQueryClientSubscribe");
const cB = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // QUERY CLIENT
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this._queryClient = new oB({
        defaultOptions: {
          queries: {
            staleTime: this.staleTime,
            gcTime: this.gcTime
          }
        }
      }), this.initQueryClient();
    }
    get queryClient() {
      return this._queryClient;
    }
    async initQueryClient() {
      if (this.isDestroyed)
        throw new Ce();
      await this.whenUrl();
      try {
        this._sessionStoragePersister = uz({
          key: "WEAVY_QUERY_OFFLINE_CACHE",
          storage: window.sessionStorage,
          throttleTime: this.staleTime
        });
        const s = {
          queryClient: this._queryClient,
          persister: this._sessionStoragePersister,
          maxAge: this.gcTime,
          // 24h - should match gcTime
          buster: this.cachePrefix,
          // Cache busting parameter (build hash or similar)
          hydrateOptions: void 0,
          dehydrateOptions: {
            shouldDehydrateMutation: /* @__PURE__ */ d((r) => {
              const a = r.state.context?.status?.state === "pending";
              return !!(r.state.context && !a || r.state.isPaused);
            }, "shouldDehydrateMutation")
          }
        };
        await fz(s), this._unsubscribeQueryClient = yz(s);
      } catch {
        console.warn(this.weavyId, "Query cache persister not available.");
      }
      this.host.isConnected && this._queryClient.mount(), this._hostIsConnectedObserver = X9(this.host, (s) => {
        this.isDestroyed || (s ? (console.info(this.weavyId, "Query client mounted"), this._queryClient.mount()) : (console.info(this.weavyId, "Query client unmounted"), this._queryClient.unmount()));
      });
    }
    async reset() {
      await super.reset(), await this._queryClient.cancelQueries(), await this._sessionStoragePersister?.removeClient(), await this.queryClient.resetQueries();
    }
    async disconnectQueryClient() {
      console.info(this.weavyId, "Query client disconnected"), await this._queryClient.cancelQueries(), await this._sessionStoragePersister?.removeClient(), this._unsubscribeQueryClient?.(), this._queryClient.unmount(), this._queryClient.clear();
    }
    destroy() {
      super.destroy(), this._hostIsConnectedObserver?.disconnect(), this.disconnectQueryClient();
    }
  }, c(e, "t"), e), d(t, "WeavyQuery"), t;
}, "WeavyQueryMixin"), hB = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s);
    }
    set annotations(s) {
      this._annotations = s, this.updateContext();
    }
    get annotations() {
      return this._annotations ?? ze.defaults.annotations;
    }
    set enterToSend(s) {
      this._enterToSend = s, this.updateContext();
    }
    get enterToSend() {
      return this._enterToSend ?? ze.defaults.enterToSend;
    }
    set reactions(s) {
      this._reactions = s, this.updateContext();
    }
    get reactions() {
      return this._reactions ?? ze.defaults.reactions;
    }
  }, c(e, "t"), e), d(t, "WeavySettings"), t;
}, "WeavySettingsMixin");
function pi(n) {
  return n < 0 ? -1 : n === 0 ? 0 : 1;
}
c(pi, "Re");
d(pi, "signum");
function vh(n, t, e) {
  return (1 - e) * n + e * t;
}
c(vh, "rl");
d(vh, "lerp");
function mz(n, t, e) {
  return e < n ? n : e > t ? t : e;
}
c(mz, "wg");
d(mz, "clampInt");
function Iw(n, t, e) {
  return e < n ? n : e > t ? t : e;
}
c(Iw, "Ud");
d(Iw, "clampDouble");
function om(n) {
  return n = n % 360, n < 0 && (n = n + 360), n;
}
c(om, "ll");
d(om, "sanitizeDegreesDouble");
function ib(n, t) {
  const e = n[0] * t[0][0] + n[1] * t[0][1] + n[2] * t[0][2], i = n[0] * t[1][0] + n[1] * t[1][1] + n[2] * t[1][2], s = n[0] * t[2][0] + n[1] * t[2][1] + n[2] * t[2][2];
  return [e, i, s];
}
c(ib, "nu");
d(ib, "matrixMultiply");
const dB = [
  [0.41233895, 0.35762064, 0.18051042],
  [0.2126, 0.7152, 0.0722],
  [0.01932141, 0.11916382, 0.95034478]
], uB = [
  [
    3.2413774792388685,
    -1.5376652402851851,
    -0.49885366846268053
  ],
  [
    -0.9691452513005321,
    1.8758853451067872,
    0.04156585616912061
  ],
  [
    0.05562093689691305,
    -0.20395524564742123,
    1.0571799111220335
  ]
], pB = [95.047, 100, 108.883];
function h0(n, t, e) {
  return (255 << 24 | (n & 255) << 16 | (t & 255) << 8 | e & 255) >>> 0;
}
c(h0, "Wu");
d(h0, "argbFromRgb");
function sS(n) {
  const t = Er(n[0]), e = Er(n[1]), i = Er(n[2]);
  return h0(t, e, i);
}
c(sS, "Iw");
d(sS, "argbFromLinrgb");
function gz(n) {
  return n >> 24 & 255;
}
c(gz, "gg");
d(gz, "alphaFromArgb");
function IP(n) {
  return n >> 16 & 255;
}
c(IP, "im");
d(IP, "redFromArgb");
function WP(n) {
  return n >> 8 & 255;
}
c(WP, "rm");
d(WP, "greenFromArgb");
function VP(n) {
  return n & 255;
}
c(VP, "sm");
d(VP, "blueFromArgb");
function wz(n, t, e) {
  const i = uB, s = i[0][0] * n + i[0][1] * t + i[0][2] * e, r = i[1][0] * n + i[1][1] * t + i[1][2] * e, a = i[2][0] * n + i[2][1] * t + i[2][2] * e, o = Er(s), l = Er(r), h = Er(a);
  return h0(o, l, h);
}
c(wz, "bg");
d(wz, "argbFromXyz");
function vz(n) {
  const t = ro(IP(n)), e = ro(WP(n)), i = ro(VP(n));
  return ib([t, e, i], dB);
}
c(vz, "xg");
d(vz, "xyzFromArgb");
function Oz(n) {
  const t = Ws(n), e = Er(t);
  return h0(e, e, e);
}
c(Oz, "$g");
d(Oz, "argbFromLstar");
function rS(n) {
  const t = vz(n)[1];
  return 116 * DP(t / 100) - 16;
}
c(rS, "Tw");
d(rS, "lstarFromArgb");
function Ws(n) {
  return 100 * $z((n + 16) / 116);
}
c(Ws, "kr");
d(Ws, "yFromLstar");
function nb(n) {
  return DP(n / 100) * 116 - 16;
}
c(nb, "au");
d(nb, "lstarFromY");
function ro(n) {
  const t = n / 255;
  return t <= 0.040449936 ? t / 12.92 * 100 : Math.pow((t + 0.055) / 1.055, 2.4) * 100;
}
c(ro, "fn");
d(ro, "linearized");
function Er(n) {
  const t = n / 100;
  let e = 0;
  return t <= 31308e-7 ? e = t * 12.92 : e = 1.055 * Math.pow(t, 1 / 2.4) - 0.055, mz(0, 255, Math.round(e * 255));
}
c(Er, "us");
d(Er, "delinearized");
function bz() {
  return pB;
}
c(bz, "Cg");
d(bz, "whitePointD65");
function DP(n) {
  const t = 0.008856451679035631, e = 24389 / 27;
  return n > t ? Math.pow(n, 1 / 3) : (e * n + 16) / 116;
}
c(DP, "nm");
d(DP, "labF");
function $z(n) {
  const t = 0.008856451679035631, e = 24389 / 27, i = n * n * n;
  return i > t ? i : (116 * n - 16) / e;
}
c($z, "kg");
d($z, "labInvf");
var Uo;
const xz = (Uo = class {
  /**
   * Create ViewingConditions from a simple, physically relevant, set of
   * parameters.
   *
   * @param whitePoint White point, measured in the XYZ color space.
   *     default = D65, or sunny day afternoon
   * @param adaptingLuminance The luminance of the adapting field. Informally,
   *     how bright it is in the room where the color is viewed. Can be
   *     calculated from lux by multiplying lux by 0.0586. default = 11.72,
   *     or 200 lux.
   * @param backgroundLstar The lightness of the area surrounding the color.
   *     measured by L* in L*a*b*. default = 50.0
   * @param surround A general description of the lighting surrounding the
   *     color. 0 is pitch dark, like watching a movie in a theater. 1.0 is a
   *     dimly light room, like watching TV at home at night. 2.0 means there
   *     is no difference between the lighting on the color and around it.
   *     default = 2.0
   * @param discountingIlluminant Whether the eye accounts for the tint of the
   *     ambient lighting, such as knowing an apple is still red in green light.
   *     default = false, the eye does not perform this process on
   *       self-luminous objects like displays.
   */
  static make(t = bz(), e = 200 / Math.PI * Ws(50) / 100, i = 50, s = 2, r = !1) {
    const a = t, o = a[0] * 0.401288 + a[1] * 0.650173 + a[2] * -0.051461, l = a[0] * -0.250268 + a[1] * 1.204414 + a[2] * 0.045854, h = a[0] * -2079e-6 + a[1] * 0.048952 + a[2] * 0.953127, u = 0.8 + s / 10, p = u >= 0.9 ? vh(0.59, 0.69, (u - 0.9) * 10) : vh(0.525, 0.59, (u - 0.8) * 10);
    let y = r ? 1 : u * (1 - 1 / 3.6 * Math.exp((-e - 42) / 92));
    y = y > 1 ? 1 : y < 0 ? 0 : y;
    const m = u, g = [
      y * (100 / o) + 1 - y,
      y * (100 / l) + 1 - y,
      y * (100 / h) + 1 - y
    ], b = 1 / (5 * e + 1), S = b * b * b * b, x = 1 - S, Q = S * e + 0.1 * x * x * Math.cbrt(5 * e), L = Ws(i) / t[1], W = 1.48 + Math.sqrt(L), R = 0.725 / Math.pow(L, 0.2), I = R, V = [
      Math.pow(Q * g[0] * o / 100, 0.42),
      Math.pow(Q * g[1] * l / 100, 0.42),
      Math.pow(Q * g[2] * h / 100, 0.42)
    ], X = [
      400 * V[0] / (V[0] + 27.13),
      400 * V[1] / (V[1] + 27.13),
      400 * V[2] / (V[2] + 27.13)
    ], J = (2 * X[0] + X[1] + 0.05 * X[2]) * R;
    return new Uo(L, J, R, I, p, m, g, Q, Math.pow(Q, 0.25), W);
  }
  /**
   * Parameters are intermediate values of the CAM16 conversion process. Their
   * names are shorthand for technical color science terminology, this class
   * would not benefit from documenting them individually. A brief overview
   * is available in the CAM16 specification, and a complete overview requires
   * a color science textbook, such as Fairchild's Color Appearance Models.
   */
  constructor(t, e, i, s, r, a, o, l, h, u) {
    this.n = t, this.aw = e, this.nbb = i, this.ncb = s, this.c = r, this.nc = a, this.rgbD = o, this.fl = l, this.fLRoot = h, this.z = u;
  }
}, c(Uo, "oh"), Uo);
d(xz, "ViewingConditions");
let Mr = xz;
Mr.DEFAULT = Mr.make();
var ji;
const kz = (ji = class {
  /**
   * All of the CAM16 dimensions can be calculated from 3 of the dimensions, in
   * the following combinations:
   *      -  {j or q} and {c, m, or s} and hue
   *      - jstar, astar, bstar
   * Prefer using a static method that constructs from 3 of those dimensions.
   * This constructor is intended for those methods to use to return all
   * possible dimensions.
   *
   * @param hue
   * @param chroma informally, colorfulness / color intensity. like saturation
   *     in HSL, except perceptually accurate.
   * @param j lightness
   * @param q brightness; ratio of lightness to white point's lightness
   * @param m colorfulness
   * @param s saturation; ratio of chroma to white point's chroma
   * @param jstar CAM16-UCS J coordinate
   * @param astar CAM16-UCS a coordinate
   * @param bstar CAM16-UCS b coordinate
   */
  constructor(t, e, i, s, r, a, o, l, h) {
    this.hue = t, this.chroma = e, this.j = i, this.q = s, this.m = r, this.s = a, this.jstar = o, this.astar = l, this.bstar = h;
  }
  /**
   * CAM16 instances also have coordinates in the CAM16-UCS space, called J*,
   * a*, b*, or jstar, astar, bstar in code. CAM16-UCS is included in the CAM16
   * specification, and is used to measure distances between colors.
   */
  distance(t) {
    const e = this.jstar - t.jstar, i = this.astar - t.astar, s = this.bstar - t.bstar, r = Math.sqrt(e * e + i * i + s * s);
    return 1.41 * Math.pow(r, 0.63);
  }
  /**
   * @param argb ARGB representation of a color.
   * @return CAM16 color, assuming the color was viewed in default viewing
   *     conditions.
   */
  static fromInt(t) {
    return ji.fromIntInViewingConditions(t, Mr.DEFAULT);
  }
  /**
   * @param argb ARGB representation of a color.
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   * @return CAM16 color.
   */
  static fromIntInViewingConditions(t, e) {
    const i = (t & 16711680) >> 16, s = (t & 65280) >> 8, r = t & 255, a = ro(i), o = ro(s), l = ro(r), h = 0.41233895 * a + 0.35762064 * o + 0.18051042 * l, u = 0.2126 * a + 0.7152 * o + 0.0722 * l, p = 0.01932141 * a + 0.11916382 * o + 0.95034478 * l, y = 0.401288 * h + 0.650173 * u - 0.051461 * p, m = -0.250268 * h + 1.204414 * u + 0.045854 * p, g = -2079e-6 * h + 0.048952 * u + 0.953127 * p, b = e.rgbD[0] * y, S = e.rgbD[1] * m, x = e.rgbD[2] * g, Q = Math.pow(e.fl * Math.abs(b) / 100, 0.42), L = Math.pow(e.fl * Math.abs(S) / 100, 0.42), W = Math.pow(e.fl * Math.abs(x) / 100, 0.42), R = pi(b) * 400 * Q / (Q + 27.13), I = pi(S) * 400 * L / (L + 27.13), V = pi(x) * 400 * W / (W + 27.13), X = (11 * R + -12 * I + V) / 11, J = (R + I - 2 * V) / 9, mt = (20 * R + 20 * I + 21 * V) / 20, at = (40 * R + 20 * I + V) / 20, G = Math.atan2(J, X) * 180 / Math.PI, $t = G < 0 ? G + 360 : G >= 360 ? G - 360 : G, rt = $t * Math.PI / 180, Rt = at * e.nbb, Qt = 100 * Math.pow(Rt / e.aw, e.c * e.z), It = 4 / e.c * Math.sqrt(Qt / 100) * (e.aw + 4) * e.fLRoot, Vt = $t < 20.14 ? $t + 360 : $t, Dt = 0.25 * (Math.cos(Vt * Math.PI / 180 + 2) + 3.8), xi = 5e4 / 13 * Dt * e.nc * e.ncb * Math.sqrt(X * X + J * J) / (mt + 0.305), _e = Math.pow(xi, 0.9) * Math.pow(1.64 - Math.pow(0.29, e.n), 0.73), oe = _e * Math.sqrt(Qt / 100), te = oe * e.fLRoot, fe = 50 * Math.sqrt(_e * e.c / (e.aw + 4)), ki = (1 + 100 * 7e-3) * Qt / (1 + 7e-3 * Qt), Vi = 1 / 0.0228 * Math.log(1 + 0.0228 * te), nn = Vi * Math.cos(rt), Ut = Vi * Math.sin(rt);
    return new ji($t, oe, Qt, It, te, fe, ki, nn, Ut);
  }
  /**
   * @param j CAM16 lightness
   * @param c CAM16 chroma
   * @param h CAM16 hue
   */
  static fromJch(t, e, i) {
    return ji.fromJchInViewingConditions(t, e, i, Mr.DEFAULT);
  }
  /**
   * @param j CAM16 lightness
   * @param c CAM16 chroma
   * @param h CAM16 hue
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   */
  static fromJchInViewingConditions(t, e, i, s) {
    const r = 4 / s.c * Math.sqrt(t / 100) * (s.aw + 4) * s.fLRoot, a = e * s.fLRoot, o = e / Math.sqrt(t / 100), l = 50 * Math.sqrt(o * s.c / (s.aw + 4)), h = i * Math.PI / 180, u = (1 + 100 * 7e-3) * t / (1 + 7e-3 * t), p = 1 / 0.0228 * Math.log(1 + 0.0228 * a), y = p * Math.cos(h), m = p * Math.sin(h);
    return new ji(i, e, t, r, a, l, u, y, m);
  }
  /**
   * @param jstar CAM16-UCS lightness.
   * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the Y axis.
   * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the X axis.
   */
  static fromUcs(t, e, i) {
    return ji.fromUcsInViewingConditions(t, e, i, Mr.DEFAULT);
  }
  /**
   * @param jstar CAM16-UCS lightness.
   * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the Y axis.
   * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the X axis.
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   */
  static fromUcsInViewingConditions(t, e, i, s) {
    const r = e, a = i, o = Math.sqrt(r * r + a * a), l = (Math.exp(o * 0.0228) - 1) / 0.0228 / s.fLRoot;
    let h = Math.atan2(a, r) * (180 / Math.PI);
    h < 0 && (h += 360);
    const u = t / (1 - (t - 100) * 7e-3);
    return ji.fromJchInViewingConditions(u, l, h, s);
  }
  /**
   *  @return ARGB representation of color, assuming the color was viewed in
   *     default viewing conditions, which are near-identical to the default
   *     viewing conditions for sRGB.
   */
  toInt() {
    return this.viewed(Mr.DEFAULT);
  }
  /**
   * @param viewingConditions Information about the environment where the color
   *     will be viewed.
   * @return ARGB representation of color
   */
  viewed(t) {
    const e = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100), i = Math.pow(e / Math.pow(1.64 - Math.pow(0.29, t.n), 0.73), 1 / 0.9), s = this.hue * Math.PI / 180, r = 0.25 * (Math.cos(s + 2) + 3.8), a = t.aw * Math.pow(this.j / 100, 1 / t.c / t.z), o = r * (5e4 / 13) * t.nc * t.ncb, l = a / t.nbb, h = Math.sin(s), u = Math.cos(s), p = 23 * (l + 0.305) * i / (23 * o + 11 * i * u + 108 * i * h), y = p * u, m = p * h, g = (460 * l + 451 * y + 288 * m) / 1403, b = (460 * l - 891 * y - 261 * m) / 1403, S = (460 * l - 220 * y - 6300 * m) / 1403, x = Math.max(0, 27.13 * Math.abs(g) / (400 - Math.abs(g))), Q = pi(g) * (100 / t.fl) * Math.pow(x, 1 / 0.42), L = Math.max(0, 27.13 * Math.abs(b) / (400 - Math.abs(b))), W = pi(b) * (100 / t.fl) * Math.pow(L, 1 / 0.42), R = Math.max(0, 27.13 * Math.abs(S) / (400 - Math.abs(S))), I = pi(S) * (100 / t.fl) * Math.pow(R, 1 / 0.42), V = Q / t.rgbD[0], X = W / t.rgbD[1], J = I / t.rgbD[2], mt = 1.86206786 * V - 1.01125463 * X + 0.14918677 * J, at = 0.38752654 * V + 0.62144744 * X - 897398e-8 * J, G = -0.0158415 * V - 0.03412294 * X + 1.04996444 * J;
    return wz(mt, at, G);
  }
  /// Given color expressed in XYZ and viewed in [viewingConditions], convert to
  /// CAM16.
  static fromXyzInViewingConditions(t, e, i, s) {
    const r = 0.401288 * t + 0.650173 * e - 0.051461 * i, a = -0.250268 * t + 1.204414 * e + 0.045854 * i, o = -2079e-6 * t + 0.048952 * e + 0.953127 * i, l = s.rgbD[0] * r, h = s.rgbD[1] * a, u = s.rgbD[2] * o, p = Math.pow(s.fl * Math.abs(l) / 100, 0.42), y = Math.pow(s.fl * Math.abs(h) / 100, 0.42), m = Math.pow(s.fl * Math.abs(u) / 100, 0.42), g = pi(l) * 400 * p / (p + 27.13), b = pi(h) * 400 * y / (y + 27.13), S = pi(u) * 400 * m / (m + 27.13), x = (11 * g + -12 * b + S) / 11, Q = (g + b - 2 * S) / 9, L = (20 * g + 20 * b + 21 * S) / 20, W = (40 * g + 20 * b + S) / 20, R = Math.atan2(Q, x) * 180 / Math.PI, I = R < 0 ? R + 360 : R >= 360 ? R - 360 : R, V = I * Math.PI / 180, X = W * s.nbb, J = 100 * Math.pow(X / s.aw, s.c * s.z), mt = 4 / s.c * Math.sqrt(J / 100) * (s.aw + 4) * s.fLRoot, at = I < 20.14 ? I + 360 : I, G = 1 / 4 * (Math.cos(at * Math.PI / 180 + 2) + 3.8), $t = 5e4 / 13 * G * s.nc * s.ncb * Math.sqrt(x * x + Q * Q) / (L + 0.305), rt = Math.pow($t, 0.9) * Math.pow(1.64 - Math.pow(0.29, s.n), 0.73), Rt = rt * Math.sqrt(J / 100), Qt = Rt * s.fLRoot, It = 50 * Math.sqrt(rt * s.c / (s.aw + 4)), Vt = (1 + 100 * 7e-3) * J / (1 + 7e-3 * J), Dt = Math.log(1 + 0.0228 * Qt) / 0.0228, xi = Dt * Math.cos(V), _e = Dt * Math.sin(V);
    return new ji(I, Rt, J, mt, Qt, It, Vt, xi, _e);
  }
  /// XYZ representation of CAM16 seen in [viewingConditions].
  xyzInViewingConditions(t) {
    const e = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100), i = Math.pow(e / Math.pow(1.64 - Math.pow(0.29, t.n), 0.73), 1 / 0.9), s = this.hue * Math.PI / 180, r = 0.25 * (Math.cos(s + 2) + 3.8), a = t.aw * Math.pow(this.j / 100, 1 / t.c / t.z), o = r * (5e4 / 13) * t.nc * t.ncb, l = a / t.nbb, h = Math.sin(s), u = Math.cos(s), p = 23 * (l + 0.305) * i / (23 * o + 11 * i * u + 108 * i * h), y = p * u, m = p * h, g = (460 * l + 451 * y + 288 * m) / 1403, b = (460 * l - 891 * y - 261 * m) / 1403, S = (460 * l - 220 * y - 6300 * m) / 1403, x = Math.max(0, 27.13 * Math.abs(g) / (400 - Math.abs(g))), Q = pi(g) * (100 / t.fl) * Math.pow(x, 1 / 0.42), L = Math.max(0, 27.13 * Math.abs(b) / (400 - Math.abs(b))), W = pi(b) * (100 / t.fl) * Math.pow(L, 1 / 0.42), R = Math.max(0, 27.13 * Math.abs(S) / (400 - Math.abs(S))), I = pi(S) * (100 / t.fl) * Math.pow(R, 1 / 0.42), V = Q / t.rgbD[0], X = W / t.rgbD[1], J = I / t.rgbD[2], mt = 1.86206786 * V - 1.01125463 * X + 0.14918677 * J, at = 0.38752654 * V + 0.62144744 * X - 897398e-8 * J, G = -0.0158415 * V - 0.03412294 * X + 1.04996444 * J;
    return [mt, at, G];
  }
}, c(ji, "wi"), ji);
d(kz, "Cam16");
let Qg = kz;
var xt;
const Sz = (xt = class {
  /**
   * Sanitizes a small enough angle in radians.
   *
   * @param angle An angle in radians; must not deviate too much
   * from 0.
   * @return A coterminal angle between 0 and 2pi.
   */
  static sanitizeRadians(t) {
    return (t + Math.PI * 8) % (Math.PI * 2);
  }
  /**
   * Delinearizes an RGB component, returning a floating-point
   * number.
   *
   * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents
   * linear R/G/B channel
   * @return 0.0 <= output <= 255.0, color channel converted to
   * regular RGB space
   */
  static trueDelinearized(t) {
    const e = t / 100;
    let i = 0;
    return e <= 31308e-7 ? i = e * 12.92 : i = 1.055 * Math.pow(e, 1 / 2.4) - 0.055, i * 255;
  }
  static chromaticAdaptation(t) {
    const e = Math.pow(Math.abs(t), 0.42);
    return pi(t) * 400 * e / (e + 27.13);
  }
  /**
   * Returns the hue of a linear RGB color in CAM16.
   *
   * @param linrgb The linear RGB coordinates of a color.
   * @return The hue of the color in CAM16, in radians.
   */
  static hueOf(t) {
    const e = ib(t, xt.SCALED_DISCOUNT_FROM_LINRGB), i = xt.chromaticAdaptation(e[0]), s = xt.chromaticAdaptation(e[1]), r = xt.chromaticAdaptation(e[2]), a = (11 * i + -12 * s + r) / 11, o = (i + s - 2 * r) / 9;
    return Math.atan2(o, a);
  }
  static areInCyclicOrder(t, e, i) {
    const s = xt.sanitizeRadians(e - t), r = xt.sanitizeRadians(i - t);
    return s < r;
  }
  /**
   * Solves the lerp equation.
   *
   * @param source The starting number.
   * @param mid The number in the middle.
   * @param target The ending number.
   * @return A number t such that lerp(source, target, t) = mid.
   */
  static intercept(t, e, i) {
    return (e - t) / (i - t);
  }
  static lerpPoint(t, e, i) {
    return [
      t[0] + (i[0] - t[0]) * e,
      t[1] + (i[1] - t[1]) * e,
      t[2] + (i[2] - t[2]) * e
    ];
  }
  /**
   * Intersects a segment with a plane.
   *
   * @param source The coordinates of point A.
   * @param coordinate The R-, G-, or B-coordinate of the plane.
   * @param target The coordinates of point B.
   * @param axis The axis the plane is perpendicular with. (0: R, 1:
   * G, 2: B)
   * @return The intersection point of the segment AB with the plane
   * R=coordinate, G=coordinate, or B=coordinate
   */
  static setCoordinate(t, e, i, s) {
    const r = xt.intercept(t[s], e, i[s]);
    return xt.lerpPoint(t, r, i);
  }
  static isBounded(t) {
    return 0 <= t && t <= 100;
  }
  /**
   * Returns the nth possible vertex of the polygonal intersection.
   *
   * @param y The Y value of the plane.
   * @param n The zero-based index of the point. 0 <= n <= 11.
   * @return The nth possible vertex of the polygonal intersection
   * of the y plane and the RGB cube, in linear RGB coordinates, if
   * it exists. If this possible vertex lies outside of the cube,
   * [-1.0, -1.0, -1.0] is returned.
   */
  static nthVertex(t, e) {
    const i = xt.Y_FROM_LINRGB[0], s = xt.Y_FROM_LINRGB[1], r = xt.Y_FROM_LINRGB[2], a = e % 4 <= 1 ? 0 : 100, o = e % 2 === 0 ? 0 : 100;
    if (e < 4) {
      const l = a, h = o, u = (t - l * s - h * r) / i;
      return xt.isBounded(u) ? [u, l, h] : [-1, -1, -1];
    } else if (e < 8) {
      const l = a, h = o, u = (t - h * i - l * r) / s;
      return xt.isBounded(u) ? [h, u, l] : [-1, -1, -1];
    } else {
      const l = a, h = o, u = (t - l * i - h * s) / r;
      return xt.isBounded(u) ? [l, h, u] : [-1, -1, -1];
    }
  }
  /**
   * Finds the segment containing the desired color.
   *
   * @param y The Y value of the color.
   * @param targetHue The hue of the color.
   * @return A list of two sets of linear RGB coordinates, each
   * corresponding to an endpoint of the segment containing the
   * desired color.
   */
  static bisectToSegment(t, e) {
    let i = [-1, -1, -1], s = i, r = 0, a = 0, o = !1, l = !0;
    for (let h = 0; h < 12; h++) {
      const u = xt.nthVertex(t, h);
      if (u[0] < 0)
        continue;
      const p = xt.hueOf(u);
      if (!o) {
        i = u, s = u, r = p, a = p, o = !0;
        continue;
      }
      (l || xt.areInCyclicOrder(r, p, a)) && (l = !1, xt.areInCyclicOrder(r, e, p) ? (s = u, a = p) : (i = u, r = p));
    }
    return [i, s];
  }
  static midpoint(t, e) {
    return [
      (t[0] + e[0]) / 2,
      (t[1] + e[1]) / 2,
      (t[2] + e[2]) / 2
    ];
  }
  static criticalPlaneBelow(t) {
    return Math.floor(t - 0.5);
  }
  static criticalPlaneAbove(t) {
    return Math.ceil(t - 0.5);
  }
  /**
   * Finds a color with the given Y and hue on the boundary of the
   * cube.
   *
   * @param y The Y value of the color.
   * @param targetHue The hue of the color.
   * @return The desired color, in linear RGB coordinates.
   */
  static bisectToLimit(t, e) {
    const i = xt.bisectToSegment(t, e);
    let s = i[0], r = xt.hueOf(s), a = i[1];
    for (let o = 0; o < 3; o++)
      if (s[o] !== a[o]) {
        let l = -1, h = 255;
        s[o] < a[o] ? (l = xt.criticalPlaneBelow(xt.trueDelinearized(s[o])), h = xt.criticalPlaneAbove(xt.trueDelinearized(a[o]))) : (l = xt.criticalPlaneAbove(xt.trueDelinearized(s[o])), h = xt.criticalPlaneBelow(xt.trueDelinearized(a[o])));
        for (let u = 0; u < 8 && !(Math.abs(h - l) <= 1); u++) {
          const p = Math.floor((l + h) / 2), y = xt.CRITICAL_PLANES[p], m = xt.setCoordinate(s, y, a, o), g = xt.hueOf(m);
          xt.areInCyclicOrder(r, e, g) ? (a = m, h = p) : (s = m, r = g, l = p);
        }
      }
    return xt.midpoint(s, a);
  }
  static inverseChromaticAdaptation(t) {
    const e = Math.abs(t), i = Math.max(0, 27.13 * e / (400 - e));
    return pi(t) * Math.pow(i, 1 / 0.42);
  }
  /**
   * Finds a color with the given hue, chroma, and Y.
   *
   * @param hueRadians The desired hue in radians.
   * @param chroma The desired chroma.
   * @param y The desired Y.
   * @return The desired color as a hexadecimal integer, if found; 0
   * otherwise.
   */
  static findResultByJ(t, e, i) {
    let s = Math.sqrt(i) * 11;
    const r = Mr.DEFAULT, a = 1 / Math.pow(1.64 - Math.pow(0.29, r.n), 0.73), o = 0.25 * (Math.cos(t + 2) + 3.8) * (5e4 / 13) * r.nc * r.ncb, l = Math.sin(t), h = Math.cos(t);
    for (let u = 0; u < 5; u++) {
      const p = s / 100, y = e === 0 || s === 0 ? 0 : e / Math.sqrt(p), m = Math.pow(y * a, 1 / 0.9), g = r.aw * Math.pow(p, 1 / r.c / r.z) / r.nbb, b = 23 * (g + 0.305) * m / (23 * o + 11 * m * h + 108 * m * l), S = b * h, x = b * l, Q = (460 * g + 451 * S + 288 * x) / 1403, L = (460 * g - 891 * S - 261 * x) / 1403, W = (460 * g - 220 * S - 6300 * x) / 1403, R = xt.inverseChromaticAdaptation(Q), I = xt.inverseChromaticAdaptation(L), V = xt.inverseChromaticAdaptation(W), X = ib([R, I, V], xt.LINRGB_FROM_SCALED_DISCOUNT);
      if (X[0] < 0 || X[1] < 0 || X[2] < 0)
        return 0;
      const J = xt.Y_FROM_LINRGB[0], mt = xt.Y_FROM_LINRGB[1], at = xt.Y_FROM_LINRGB[2], G = J * X[0] + mt * X[1] + at * X[2];
      if (G <= 0)
        return 0;
      if (u === 4 || Math.abs(G - i) < 2e-3)
        return X[0] > 100.01 || X[1] > 100.01 || X[2] > 100.01 ? 0 : sS(X);
      s = s - (G - i) * s / (2 * G);
    }
    return 0;
  }
  /**
   * Finds an sRGB color with the given hue, chroma, and L*, if
   * possible.
   *
   * @param hueDegrees The desired hue, in degrees.
   * @param chroma The desired chroma.
   * @param lstar The desired L*.
   * @return A hexadecimal representing the sRGB color. The color
   * has sufficiently close hue, chroma, and L* to the desired
   * values, if possible; otherwise, the hue and L* will be
   * sufficiently close, and chroma will be maximized.
   */
  static solveToInt(t, e, i) {
    if (e < 1e-4 || i < 1e-4 || i > 99.9999)
      return Oz(i);
    t = om(t);
    const s = t / 180 * Math.PI, r = Ws(i), a = xt.findResultByJ(s, e, r);
    if (a !== 0)
      return a;
    const o = xt.bisectToLimit(r, s);
    return sS(o);
  }
  /**
   * Finds an sRGB color with the given hue, chroma, and L*, if
   * possible.
   *
   * @param hueDegrees The desired hue, in degrees.
   * @param chroma The desired chroma.
   * @param lstar The desired L*.
   * @return An CAM16 object representing the sRGB color. The color
   * has sufficiently close hue, chroma, and L* to the desired
   * values, if possible; otherwise, the hue and L* will be
   * sufficiently close, and chroma will be maximized.
   */
  static solveToCam(t, e, i) {
    return Qg.fromInt(xt.solveToInt(t, e, i));
  }
}, c(xt, "lt"), xt);
d(Sz, "HctSolver");
let Ar = Sz;
Ar.SCALED_DISCOUNT_FROM_LINRGB = [
  [
    0.001200833568784504,
    0.002389694492170889,
    2795742885861124e-19
  ],
  [
    5891086651375999e-19,
    0.0029785502573438758,
    3270666104008398e-19
  ],
  [
    10146692491640572e-20,
    5364214359186694e-19,
    0.0032979401770712076
  ]
];
Ar.LINRGB_FROM_SCALED_DISCOUNT = [
  [
    1373.2198709594231,
    -1100.4251190754821,
    -7.278681089101213
  ],
  [
    -271.815969077903,
    559.6580465940733,
    -32.46047482791194
  ],
  [
    1.9622899599665666,
    -57.173814538844006,
    308.7233197812385
  ]
];
Ar.Y_FROM_LINRGB = [0.2126, 0.7152, 0.0722];
Ar.CRITICAL_PLANES = [
  0.015176349177441876,
  0.045529047532325624,
  0.07588174588720938,
  0.10623444424209313,
  0.13658714259697685,
  0.16693984095186062,
  0.19729253930674434,
  0.2276452376616281,
  0.2579979360165119,
  0.28835063437139563,
  0.3188300904430532,
  0.350925934958123,
  0.3848314933096426,
  0.42057480301049466,
  0.458183274052838,
  0.4976837250274023,
  0.5391024159806381,
  0.5824650784040898,
  0.6277969426914107,
  0.6751227633498623,
  0.7244668422128921,
  0.775853049866786,
  0.829304845476233,
  0.8848452951698498,
  0.942497089126609,
  1.0022825574869039,
  1.0642236851973577,
  1.1283421258858297,
  1.1946592148522128,
  1.2631959812511864,
  1.3339731595349034,
  1.407011200216447,
  1.4823302800086415,
  1.5599503113873272,
  1.6398909516233677,
  1.7221716113234105,
  1.8068114625156377,
  1.8938294463134073,
  1.9832442801866852,
  2.075074464868551,
  2.1693382909216234,
  2.2660538449872063,
  2.36523901573795,
  2.4669114995532007,
  2.5710888059345764,
  2.6777882626779785,
  2.7870270208169257,
  2.898822059350997,
  3.0131901897720907,
  3.1301480604002863,
  3.2497121605402226,
  3.3718988244681087,
  3.4967242352587946,
  3.624204428461639,
  3.754355295633311,
  3.887192587735158,
  4.022731918402185,
  4.160988767090289,
  4.301978482107941,
  4.445716283538092,
  4.592217266055746,
  4.741496401646282,
  4.893568542229298,
  5.048448422192488,
  5.20615066083972,
  5.3666897647573375,
  5.5300801301023865,
  5.696336044816294,
  5.865471690767354,
  6.037501145825082,
  6.212438385869475,
  6.390297286737924,
  6.571091626112461,
  6.7548350853498045,
  6.941541251256611,
  7.131223617812143,
  7.323895587840543,
  7.5195704746346665,
  7.7182615035334345,
  7.919981813454504,
  8.124744458384042,
  8.332562408825165,
  8.543448553206703,
  8.757415699253682,
  8.974476575321063,
  9.194643831691977,
  9.417930041841839,
  9.644347703669503,
  9.873909240696694,
  10.106627003236781,
  10.342513269534024,
  10.58158024687427,
  10.8238400726681,
  11.069304815507364,
  11.317986476196008,
  11.569896988756009,
  11.825048221409341,
  12.083451977536606,
  12.345119996613247,
  12.610063955123938,
  12.878295467455942,
  13.149826086772048,
  13.42466730586372,
  13.702830557985108,
  13.984327217668513,
  14.269168601521828,
  14.55736596900856,
  14.848930523210871,
  15.143873411576273,
  15.44220572664832,
  15.743938506781891,
  16.04908273684337,
  16.35764934889634,
  16.66964922287304,
  16.985093187232053,
  17.30399201960269,
  17.62635644741625,
  17.95219714852476,
  18.281524751807332,
  18.614349837764564,
  18.95068293910138,
  19.290534541298456,
  19.633915083172692,
  19.98083495742689,
  20.331304511189067,
  20.685334046541502,
  21.042933821039977,
  21.404114048223256,
  21.76888489811322,
  22.137256497705877,
  22.50923893145328,
  22.884842241736916,
  23.264076429332462,
  23.6469514538663,
  24.033477234264016,
  24.42366364919083,
  24.817520537484558,
  25.21505769858089,
  25.61628489293138,
  26.021211842414342,
  26.429848230738664,
  26.842203703840827,
  27.258287870275353,
  27.678110301598522,
  28.10168053274597,
  28.529008062403893,
  28.96010235337422,
  29.39497283293396,
  29.83362889318845,
  30.276079891419332,
  30.722335150426627,
  31.172403958865512,
  31.62629557157785,
  32.08401920991837,
  32.54558406207592,
  33.010999283389665,
  33.4802739966603,
  33.953417292456834,
  34.430438229418264,
  34.911345834551085,
  35.39614910352207,
  35.88485700094671,
  36.37747846067349,
  36.87402238606382,
  37.37449765026789,
  37.87891309649659,
  38.38727753828926,
  38.89959975977785,
  39.41588851594697,
  39.93615253289054,
  40.460400508064545,
  40.98864111053629,
  41.520882981230194,
  42.05713473317016,
  42.597404951718396,
  43.141702194811224,
  43.6900349931913,
  44.24241185063697,
  44.798841244188324,
  45.35933162437017,
  45.92389141541209,
  46.49252901546552,
  47.065252796817916,
  47.64207110610409,
  48.22299226451468,
  48.808024568002054,
  49.3971762874833,
  49.9904556690408,
  50.587870934119984,
  51.189430279724725,
  51.79514187861014,
  52.40501387947288,
  53.0190544071392,
  53.637271562750364,
  54.259673423945976,
  54.88626804504493,
  55.517063457223934,
  56.15206766869424,
  56.79128866487574,
  57.43473440856916,
  58.08241284012621,
  58.734331877617365,
  59.39049941699807,
  60.05092333227251,
  60.715611475655585,
  61.38457167773311,
  62.057811747619894,
  62.7353394731159,
  63.417162620860914,
  64.10328893648692,
  64.79372614476921,
  65.48848194977529,
  66.18756403501224,
  66.89098006357258,
  67.59873767827808,
  68.31084450182222,
  69.02730813691093,
  69.74813616640164,
  70.47333615344107,
  71.20291564160104,
  71.93688215501312,
  72.67524319850172,
  73.41800625771542,
  74.16517879925733,
  74.9167682708136,
  75.67278210128072,
  76.43322770089146,
  77.1981124613393,
  77.96744375590167,
  78.74122893956174,
  79.51947534912904,
  80.30219030335869,
  81.08938110306934,
  81.88105503125999,
  82.67721935322541,
  83.4778813166706,
  84.28304815182372,
  85.09272707154808,
  85.90692527145302,
  86.72564993000343,
  87.54890820862819,
  88.3767072518277,
  89.2090541872801,
  90.04595612594655,
  90.88742016217518,
  91.73345337380438,
  92.58406282226491,
  93.43925555268066,
  94.29903859396902,
  95.16341895893969,
  96.03240364439274,
  96.9059996312159,
  97.78421388448044,
  98.6670533535366,
  99.55452497210776
];
var Xs;
const Cz = (Xs = class {
  static from(t, e, i) {
    return new Xs(Ar.solveToInt(t, e, i));
  }
  /**
   * @param argb ARGB representation of a color.
   * @return HCT representation of a color in default viewing conditions
   */
  static fromInt(t) {
    return new Xs(t);
  }
  toInt() {
    return this.argb;
  }
  /**
   * A number, in degrees, representing ex. red, orange, yellow, etc.
   * Ranges from 0 <= hue < 360.
   */
  get hue() {
    return this.internalHue;
  }
  /**
   * @param newHue 0 <= newHue < 360; invalid values are corrected.
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set hue(t) {
    this.setInternalState(Ar.solveToInt(t, this.internalChroma, this.internalTone));
  }
  get chroma() {
    return this.internalChroma;
  }
  /**
   * @param newChroma 0 <= newChroma < ?
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set chroma(t) {
    this.setInternalState(Ar.solveToInt(this.internalHue, t, this.internalTone));
  }
  /** Lightness. Ranges from 0 to 100. */
  get tone() {
    return this.internalTone;
  }
  /**
   * @param newTone 0 <= newTone <= 100; invalid valids are corrected.
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set tone(t) {
    this.setInternalState(Ar.solveToInt(this.internalHue, this.internalChroma, t));
  }
  constructor(t) {
    this.argb = t;
    const e = Qg.fromInt(t);
    this.internalHue = e.hue, this.internalChroma = e.chroma, this.internalTone = rS(t), this.argb = t;
  }
  setInternalState(t) {
    const e = Qg.fromInt(t);
    this.internalHue = e.hue, this.internalChroma = e.chroma, this.internalTone = rS(t), this.argb = t;
  }
  /**
   * Translates a color into different [ViewingConditions].
   *
   * Colors change appearance. They look different with lights on versus off,
   * the same color, as in hex code, on white looks different when on black.
   * This is called color relativity, most famously explicated by Josef Albers
   * in Interaction of Color.
   *
   * In color science, color appearance models can account for this and
   * calculate the appearance of a color in different settings. HCT is based on
   * CAM16, a color appearance model, and uses it to make these calculations.
   *
   * See [ViewingConditions.make] for parameters affecting color appearance.
   */
  inViewingConditions(t) {
    const e = Qg.fromInt(this.toInt()).xyzInViewingConditions(t), i = Qg.fromXyzInViewingConditions(e[0], e[1], e[2], Mr.make());
    return Xs.from(i.hue, i.chroma, nb(e[1]));
  }
}, c(Xs, "pn"), Xs);
d(Cz, "Hct");
let Qn = Cz;
var xn;
const Pz = (xn = class {
  /**
   * Returns a contrast ratio, which ranges from 1 to 21.
   *
   * @param toneA Tone between 0 and 100. Values outside will be clamped.
   * @param toneB Tone between 0 and 100. Values outside will be clamped.
   */
  static ratioOfTones(t, e) {
    return t = Iw(0, 100, t), e = Iw(0, 100, e), xn.ratioOfYs(Ws(t), Ws(e));
  }
  static ratioOfYs(t, e) {
    const i = t > e ? t : e, s = i === e ? t : e;
    return (i + 5) / (s + 5);
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns -1 if ratio cannot be achieved with tone parameter.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in -1 being returned.
   * @param ratio Contrast ratio of return value and tone.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static lighter(t, e) {
    if (t < 0 || t > 100)
      return -1;
    const i = Ws(t), s = e * (i + 5) - 5, r = xn.ratioOfYs(s, i), a = Math.abs(r - e);
    if (r < e && a > 0.04)
      return -1;
    const o = nb(s) + 0.4;
    return o < 0 || o > 100 ? -1 : o;
  }
  /**
   * Returns a tone <= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns -1 if ratio cannot be achieved with tone parameter.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in -1 being returned.
   * @param ratio Contrast ratio of return value and tone.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static darker(t, e) {
    if (t < 0 || t > 100)
      return -1;
    const i = Ws(t), s = (i + 5) / e - 5, r = xn.ratioOfYs(i, s), a = Math.abs(r - e);
    if (r < e && a > 0.04)
      return -1;
    const o = nb(s) - 0.4;
    return o < 0 || o > 100 ? -1 : o;
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns 100 if ratio cannot be achieved with tone parameter.
   *
   * This method is unsafe because the returned value is guaranteed to be in
   * bounds for tone, i.e. between 0 and 100. However, that value may not reach
   * the ratio with tone. For example, there is no color lighter than T100.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in 100 being returned.
   * @param ratio Desired contrast ratio of return value and tone parameter.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static lighterUnsafe(t, e) {
    const i = xn.lighter(t, e);
    return i < 0 ? 100 : i;
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns 100 if ratio cannot be achieved with tone parameter.
   *
   * This method is unsafe because the returned value is guaranteed to be in
   * bounds for tone, i.e. between 0 and 100. However, that value may not reach
   * the [ratio with [tone]. For example, there is no color darker than T0.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in 0 being returned.
   * @param ratio Desired contrast ratio of return value and tone parameter.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static darkerUnsafe(t, e) {
    const i = xn.darker(t, e);
    return i < 0 ? 0 : i;
  }
}, c(xn, "hr"), xn);
d(Pz, "Contrast");
let sn = Pz;
var Ho;
const Qz = (Ho = class {
  /**
   * Returns true if a color is disliked.
   *
   * @param hct A color to be judged.
   * @return Whether the color is disliked.
   *
   * Disliked is defined as a dark yellow-green that is not neutral.
   */
  static isDisliked(t) {
    const e = Math.round(t.hue) >= 90 && Math.round(t.hue) <= 111, i = Math.round(t.chroma) > 16, s = Math.round(t.tone) < 65;
    return e && i && s;
  }
  /**
   * If a color is disliked, lighten it to make it likable.
   *
   * @param hct A color to be judged.
   * @return A new color if the original color is disliked, or the original
   *   color if it is acceptable.
   */
  static fixIfDisliked(t) {
    return Ho.isDisliked(t) ? Qn.from(t.hue, t.chroma, 70) : t;
  }
}, c(Ho, "ch"), Ho);
d(Qz, "DislikeAnalyzer");
let fB = Qz;
var Xe;
const Tz = (Xe = class {
  /**
   * Create a DynamicColor defined by a TonalPalette and HCT tone.
   *
   * @param args Functions with DynamicScheme as input. Must provide a palette
   * and tone. May provide a background DynamicColor and ToneDeltaConstraint.
   */
  static fromPalette(t) {
    return new Xe(t.name ?? "", t.palette, t.tone, t.isBackground ?? !1, t.background, t.secondBackground, t.contrastCurve, t.toneDeltaPair);
  }
  /**
   * The base constructor for DynamicColor.
   *
   * _Strongly_ prefer using one of the convenience constructors. This class is
   * arguably too flexible to ensure it can support any scenario. Functional
   * arguments allow  overriding without risks that come with subclasses.
   *
   * For example, the default behavior of adjust tone at max contrast
   * to be at a 7.0 ratio with its background is principled and
   * matches accessibility guidance. That does not mean it's the desired
   * approach for _every_ design system, and every color pairing,
   * always, in every case.
   *
   * @param name The name of the dynamic color. Defaults to empty.
   * @param palette Function that provides a TonalPalette given
   * DynamicScheme. A TonalPalette is defined by a hue and chroma, so this
   * replaces the need to specify hue/chroma. By providing a tonal palette, when
   * contrast adjustments are made, intended chroma can be preserved.
   * @param tone Function that provides a tone, given a DynamicScheme.
   * @param isBackground Whether this dynamic color is a background, with
   * some other color as the foreground. Defaults to false.
   * @param background The background of the dynamic color (as a function of a
   *     `DynamicScheme`), if it exists.
   * @param secondBackground A second background of the dynamic color (as a
   *     function of a `DynamicScheme`), if it
   * exists.
   * @param contrastCurve A `ContrastCurve` object specifying how its contrast
   * against its background should behave in various contrast levels options.
   * @param toneDeltaPair A `ToneDeltaPair` object specifying a tone delta
   * constraint between two colors. One of them must be the color being
   * constructed.
   */
  constructor(t, e, i, s, r, a, o, l) {
    if (this.name = t, this.palette = e, this.tone = i, this.isBackground = s, this.background = r, this.secondBackground = a, this.contrastCurve = o, this.toneDeltaPair = l, this.hctCache = /* @__PURE__ */ new Map(), !r && a)
      throw new Error(`Color ${t} has secondBackgrounddefined, but background is not defined.`);
    if (!r && o)
      throw new Error(`Color ${t} has contrastCurvedefined, but background is not defined.`);
    if (r && !o)
      throw new Error(`Color ${t} has backgrounddefined, but contrastCurve is not defined.`);
  }
  /**
   * Return a ARGB integer (i.e. a hex code).
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getArgb(t) {
    return this.getHct(t).toInt();
  }
  /**
   * Return a color, expressed in the HCT color space, that this
   * DynamicColor is under the conditions in scheme.
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getHct(t) {
    const e = this.hctCache.get(t);
    if (e != null)
      return e;
    const i = this.getTone(t), s = this.palette(t).getHct(i);
    return this.hctCache.size > 4 && this.hctCache.clear(), this.hctCache.set(t, s), s;
  }
  /**
   * Return a tone, T in the HCT color space, that this DynamicColor is under
   * the conditions in scheme.
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getTone(t) {
    const e = t.contrastLevel < 0;
    if (this.toneDeltaPair) {
      const i = this.toneDeltaPair(t), s = i.roleA, r = i.roleB, a = i.delta, o = i.polarity, l = i.stayTogether, h = this.background(t).getTone(t), u = o === "nearer" || o === "lighter" && !t.isDark || o === "darker" && t.isDark, p = u ? s : r, y = u ? r : s, m = this.name === p.name, g = t.isDark ? 1 : -1, b = p.contrastCurve.get(t.contrastLevel), S = y.contrastCurve.get(t.contrastLevel), x = p.tone(t);
      let Q = sn.ratioOfTones(h, x) >= b ? x : Xe.foregroundTone(h, b);
      const L = y.tone(t);
      let W = sn.ratioOfTones(h, L) >= S ? L : Xe.foregroundTone(h, S);
      return e && (Q = Xe.foregroundTone(h, b), W = Xe.foregroundTone(h, S)), (W - Q) * g >= a || (W = Iw(0, 100, Q + a * g), (W - Q) * g >= a || (Q = Iw(0, 100, W - a * g))), 50 <= Q && Q < 60 ? g > 0 ? (Q = 60, W = Math.max(W, Q + a * g)) : (Q = 49, W = Math.min(W, Q + a * g)) : 50 <= W && W < 60 && (l ? g > 0 ? (Q = 60, W = Math.max(W, Q + a * g)) : (Q = 49, W = Math.min(W, Q + a * g)) : g > 0 ? W = 60 : W = 49), m ? Q : W;
    } else {
      let i = this.tone(t);
      if (this.background == null)
        return i;
      const s = this.background(t).getTone(t), r = this.contrastCurve.get(t.contrastLevel);
      if (sn.ratioOfTones(s, i) >= r || (i = Xe.foregroundTone(s, r)), e && (i = Xe.foregroundTone(s, r)), this.isBackground && 50 <= i && i < 60 && (sn.ratioOfTones(49, s) >= r ? i = 49 : i = 60), this.secondBackground) {
        const [a, o] = [this.background, this.secondBackground], [l, h] = [a(t).getTone(t), o(t).getTone(t)], [u, p] = [Math.max(l, h), Math.min(l, h)];
        if (sn.ratioOfTones(u, i) >= r && sn.ratioOfTones(p, i) >= r)
          return i;
        const y = sn.lighter(u, r), m = sn.darker(p, r), g = [];
        return y !== -1 && g.push(y), m !== -1 && g.push(m), Xe.tonePrefersLightForeground(l) || Xe.tonePrefersLightForeground(h) ? y < 0 ? 100 : y : g.length === 1 ? g[0] : m < 0 ? 0 : m;
      }
      return i;
    }
  }
  /**
   * Given a background tone, find a foreground tone, while ensuring they reach
   * a contrast ratio that is as close to [ratio] as possible.
   *
   * @param bgTone Tone in HCT. Range is 0 to 100, undefined behavior when it
   *     falls outside that range.
   * @param ratio The contrast ratio desired between bgTone and the return
   *     value.
   */
  static foregroundTone(t, e) {
    const i = sn.lighterUnsafe(t, e), s = sn.darkerUnsafe(t, e), r = sn.ratioOfTones(i, t), a = sn.ratioOfTones(s, t);
    if (Xe.tonePrefersLightForeground(t)) {
      const o = Math.abs(r - a) < 0.1 && r < e && a < e;
      return r >= e || r >= a || o ? i : s;
    } else
      return a >= e || a >= r ? s : i;
  }
  /**
   * Returns whether [tone] prefers a light foreground.
   *
   * People prefer white foregrounds on ~T60-70. Observed over time, and also
   * by Andrew Somers during research for APCA.
   *
   * T60 used as to create the smallest discontinuity possible when skipping
   * down to T49 in order to ensure light foregrounds.
   * Since `tertiaryContainer` in dark monochrome scheme requires a tone of
   * 60, it should not be adjusted. Therefore, 60 is excluded here.
   */
  static tonePrefersLightForeground(t) {
    return Math.round(t) < 60;
  }
  /**
   * Returns whether [tone] can reach a contrast ratio of 4.5 with a lighter
   * color.
   */
  static toneAllowsLightForeground(t) {
    return Math.round(t) <= 49;
  }
  /**
   * Adjust a tone such that white has 4.5 contrast, if the tone is
   * reasonably close to supporting it.
   */
  static enableLightForeground(t) {
    return Xe.tonePrefersLightForeground(t) && !Xe.toneAllowsLightForeground(t) ? 49 : t;
  }
}, c(Xe, "ke"), Xe);
d(Tz, "DynamicColor");
let yt = Tz;
var Ns;
const Mz = (Ns = class {
  /**
   * @param argb ARGB representation of a color
   * @return Tones matching that color's hue and chroma.
   */
  static fromInt(t) {
    const e = Qn.fromInt(t);
    return Ns.fromHct(e);
  }
  /**
   * @param hct Hct
   * @return Tones matching that color's hue and chroma.
   */
  static fromHct(t) {
    return new Ns(t.hue, t.chroma, t);
  }
  /**
   * @param hue HCT hue
   * @param chroma HCT chroma
   * @return Tones matching hue and chroma.
   */
  static fromHueAndChroma(t, e) {
    const i = new yB(t, e).create();
    return new Ns(t, e, i);
  }
  constructor(t, e, i) {
    this.hue = t, this.chroma = e, this.keyColor = i, this.cache = /* @__PURE__ */ new Map();
  }
  /**
   * @param tone HCT tone, measured from 0 to 100.
   * @return ARGB representation of a color with that tone.
   */
  tone(t) {
    let e = this.cache.get(t);
    return e === void 0 && (e = Qn.from(this.hue, this.chroma, t).toInt(), this.cache.set(t, e)), e;
  }
  /**
   * @param tone HCT tone.
   * @return HCT representation of a color with that tone.
   */
  getHct(t) {
    return Qn.fromInt(this.tone(t));
  }
}, c(Ns, "un"), Ns);
d(Mz, "TonalPalette");
let Et = Mz;
var dp;
const Az = (dp = class {
  constructor(t, e) {
    this.hue = t, this.requestedChroma = e, this.chromaCache = /* @__PURE__ */ new Map(), this.maxChromaValue = 200;
  }
  /**
   * Creates a key color from a [hue] and a [chroma].
   * The key color is the first tone, starting from T50, matching the given hue
   * and chroma.
   *
   * @return Key color [Hct]
   */
  create() {
    let t = 0, e = 100;
    for (; t < e; ) {
      const i = Math.floor((t + e) / 2), s = this.maxChroma(i) < this.maxChroma(i + 1);
      if (this.maxChroma(i) >= this.requestedChroma - 0.01)
        if (Math.abs(t - 50) < Math.abs(e - 50))
          e = i;
        else {
          if (t === i)
            return Qn.from(this.hue, this.requestedChroma, t);
          t = i;
        }
      else
        s ? t = i + 1 : e = i;
    }
    return Qn.from(this.hue, this.requestedChroma, t);
  }
  // Find the maximum chroma for a given tone
  maxChroma(t) {
    if (this.chromaCache.has(t))
      return this.chromaCache.get(t);
    const e = Qn.from(this.hue, this.maxChromaValue, t).chroma;
    return this.chromaCache.set(t, e), e;
  }
}, c(dp, "Ey"), dp);
d(Az, "KeyColor");
let yB = Az;
var up;
const Rz = (up = class {
  /**
   * Creates a `ContrastCurve` object.
   *
   * @param low Value for contrast level -1.0
   * @param normal Value for contrast level 0.0
   * @param medium Value for contrast level 0.5
   * @param high Value for contrast level 1.0
   */
  constructor(t, e, i, s) {
    this.low = t, this.normal = e, this.medium = i, this.high = s;
  }
  /**
   * Returns the value at a given contrast level.
   *
   * @param contrastLevel The contrast level. 0.0 is the default (normal); -1.0
   *     is the lowest; 1.0 is the highest.
   * @return The value. For contrast ratios, a number between 1.0 and 21.0.
   */
  get(t) {
    return t <= -1 ? this.low : t < 0 ? vh(this.low, this.normal, (t - -1) / 1) : t < 0.5 ? vh(this.normal, this.medium, (t - 0) / 0.5) : t < 1 ? vh(this.medium, this.high, (t - 0.5) / 0.5) : this.high;
  }
}, c(up, "Ly"), up);
d(Rz, "ContrastCurve");
let Tt = Rz;
var pp;
const Ez = (pp = class {
  /**
   * Documents a constraint in tone distance between two DynamicColors.
   *
   * The polarity is an adjective that describes "A", compared to "B".
   *
   * For instance, ToneDeltaPair(A, B, 15, 'darker', stayTogether) states that
   * A's tone should be at least 15 darker than B's.
   *
   * 'nearer' and 'farther' describes closeness to the surface roles. For
   * instance, ToneDeltaPair(A, B, 10, 'nearer', stayTogether) states that A
   * should be 10 lighter than B in light mode, and 10 darker than B in dark
   * mode.
   *
   * @param roleA The first role in a pair.
   * @param roleB The second role in a pair.
   * @param delta Required difference between tones. Absolute value, negative
   * values have undefined behavior.
   * @param polarity The relative relation between tones of roleA and roleB,
   * as described above.
   * @param stayTogether Whether these two roles should stay on the same side of
   * the "awkward zone" (T50-59). This is necessary for certain cases where
   * one role has two backgrounds.
   */
  constructor(t, e, i, s, r) {
    this.roleA = t, this.roleB = e, this.delta = i, this.polarity = s, this.stayTogether = r;
  }
}, c(pp, "Oy"), pp);
d(Ez, "ToneDeltaPair");
let Ri = Ez;
var sl;
(function(n) {
  n[n.MONOCHROME = 0] = "MONOCHROME", n[n.NEUTRAL = 1] = "NEUTRAL", n[n.TONAL_SPOT = 2] = "TONAL_SPOT", n[n.VIBRANT = 3] = "VIBRANT", n[n.EXPRESSIVE = 4] = "EXPRESSIVE", n[n.FIDELITY = 5] = "FIDELITY", n[n.CONTENT = 6] = "CONTENT", n[n.RAINBOW = 7] = "RAINBOW", n[n.FRUIT_SALAD = 8] = "FRUIT_SALAD";
})(sl || (sl = {}));
function Tl(n) {
  return n.variant === sl.FIDELITY || n.variant === sl.CONTENT;
}
c(Tl, "Dc");
d(Tl, "isFidelity");
function ie(n) {
  return n.variant === sl.MONOCHROME;
}
c(ie, "Lt");
d(ie, "isMonochrome");
function _z(n, t, e, i) {
  let s = e, r = Qn.from(n, t, e);
  if (r.chroma < t) {
    let a = r.chroma;
    for (; r.chroma < t; ) {
      s += i ? -1 : 1;
      const o = Qn.from(n, t, s);
      if (a > o.chroma || Math.abs(o.chroma - t) < 0.4)
        break;
      const l = Math.abs(o.chroma - t), h = Math.abs(r.chroma - t);
      l < h && (r = o), a = Math.max(a, o.chroma);
    }
  }
  return s;
}
c(_z, "_g");
d(_z, "findDesiredChromaByTone");
var Jr;
const zz = (Jr = class {
  static highestSurface(t) {
    return t.isDark ? Jr.surfaceBright : Jr.surfaceDim;
  }
}, c(Jr, "al"), Jr);
d(zz, "MaterialDynamicColors");
let A = zz;
A.contentAccentToneDelta = 15;
A.primaryPaletteKeyColor = yt.fromPalette({
  name: "primary_palette_key_color",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.primaryPalette.keyColor.tone, "tone")
});
A.secondaryPaletteKeyColor = yt.fromPalette({
  name: "secondary_palette_key_color",
  palette: /* @__PURE__ */ d((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.secondaryPalette.keyColor.tone, "tone")
});
A.tertiaryPaletteKeyColor = yt.fromPalette({
  name: "tertiary_palette_key_color",
  palette: /* @__PURE__ */ d((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.tertiaryPalette.keyColor.tone, "tone")
});
A.neutralPaletteKeyColor = yt.fromPalette({
  name: "neutral_palette_key_color",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.neutralPalette.keyColor.tone, "tone")
});
A.neutralVariantPaletteKeyColor = yt.fromPalette({
  name: "neutral_variant_palette_key_color",
  palette: /* @__PURE__ */ d((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.neutralVariantPalette.keyColor.tone, "tone")
});
A.background = yt.fromPalette({
  name: "background",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 6 : 98, "tone"),
  isBackground: !0
});
A.onBackground = yt.fromPalette({
  name: "on_background",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ d((n) => A.background, "background"),
  contrastCurve: new Tt(3, 3, 4.5, 7)
});
A.surface = yt.fromPalette({
  name: "surface",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 6 : 98, "tone"),
  isBackground: !0
});
A.surfaceDim = yt.fromPalette({
  name: "surface_dim",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 6 : new Tt(87, 87, 80, 75).get(n.contrastLevel), "tone"),
  isBackground: !0
});
A.surfaceBright = yt.fromPalette({
  name: "surface_bright",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? new Tt(24, 24, 29, 34).get(n.contrastLevel) : 98, "tone"),
  isBackground: !0
});
A.surfaceContainerLowest = yt.fromPalette({
  name: "surface_container_lowest",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? new Tt(4, 4, 2, 0).get(n.contrastLevel) : 100, "tone"),
  isBackground: !0
});
A.surfaceContainerLow = yt.fromPalette({
  name: "surface_container_low",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? new Tt(10, 10, 11, 12).get(n.contrastLevel) : new Tt(96, 96, 96, 95).get(n.contrastLevel), "tone"),
  isBackground: !0
});
A.surfaceContainer = yt.fromPalette({
  name: "surface_container",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? new Tt(12, 12, 16, 20).get(n.contrastLevel) : new Tt(94, 94, 92, 90).get(n.contrastLevel), "tone"),
  isBackground: !0
});
A.surfaceContainerHigh = yt.fromPalette({
  name: "surface_container_high",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? new Tt(17, 17, 21, 25).get(n.contrastLevel) : new Tt(92, 92, 88, 85).get(n.contrastLevel), "tone"),
  isBackground: !0
});
A.surfaceContainerHighest = yt.fromPalette({
  name: "surface_container_highest",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? new Tt(22, 22, 26, 30).get(n.contrastLevel) : new Tt(90, 90, 84, 80).get(n.contrastLevel), "tone"),
  isBackground: !0
});
A.onSurface = yt.fromPalette({
  name: "on_surface",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ d((n) => A.highestSurface(n), "background"),
  contrastCurve: new Tt(4.5, 7, 11, 21)
});
A.surfaceVariant = yt.fromPalette({
  name: "surface_variant",
  palette: /* @__PURE__ */ d((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 30 : 90, "tone"),
  isBackground: !0
});
A.onSurfaceVariant = yt.fromPalette({
  name: "on_surface_variant",
  palette: /* @__PURE__ */ d((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 80 : 30, "tone"),
  background: /* @__PURE__ */ d((n) => A.highestSurface(n), "background"),
  contrastCurve: new Tt(3, 4.5, 7, 11)
});
A.inverseSurface = yt.fromPalette({
  name: "inverse_surface",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 90 : 20, "tone")
});
A.inverseOnSurface = yt.fromPalette({
  name: "inverse_on_surface",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 20 : 95, "tone"),
  background: /* @__PURE__ */ d((n) => A.inverseSurface, "background"),
  contrastCurve: new Tt(4.5, 7, 11, 21)
});
A.outline = yt.fromPalette({
  name: "outline",
  palette: /* @__PURE__ */ d((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 60 : 50, "tone"),
  background: /* @__PURE__ */ d((n) => A.highestSurface(n), "background"),
  contrastCurve: new Tt(1.5, 3, 4.5, 7)
});
A.outlineVariant = yt.fromPalette({
  name: "outline_variant",
  palette: /* @__PURE__ */ d((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 30 : 80, "tone"),
  background: /* @__PURE__ */ d((n) => A.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5)
});
A.shadow = yt.fromPalette({
  name: "shadow",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => 0, "tone")
});
A.scrim = yt.fromPalette({
  name: "scrim",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => 0, "tone")
});
A.surfaceTint = yt.fromPalette({
  name: "surface_tint",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 80 : 40, "tone"),
  isBackground: !0
});
A.primary = yt.fromPalette({
  name: "primary",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => ie(n) ? n.isDark ? 100 : 0 : n.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => A.highestSurface(n), "background"),
  contrastCurve: new Tt(3, 4.5, 7, 7),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(A.primaryContainer, A.primary, 10, "nearer", !1), "toneDeltaPair")
});
A.onPrimary = yt.fromPalette({
  name: "on_primary",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => ie(n) ? n.isDark ? 10 : 90 : n.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ d((n) => A.primary, "background"),
  contrastCurve: new Tt(4.5, 7, 11, 21)
});
A.primaryContainer = yt.fromPalette({
  name: "primary_container",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => Tl(n) ? n.sourceColorHct.tone : ie(n) ? n.isDark ? 85 : 25 : n.isDark ? 30 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => A.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(A.primaryContainer, A.primary, 10, "nearer", !1), "toneDeltaPair")
});
A.onPrimaryContainer = yt.fromPalette({
  name: "on_primary_container",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => Tl(n) ? yt.foregroundTone(A.primaryContainer.tone(n), 4.5) : ie(n) ? n.isDark ? 0 : 100 : n.isDark ? 90 : 30, "tone"),
  background: /* @__PURE__ */ d((n) => A.primaryContainer, "background"),
  contrastCurve: new Tt(3, 4.5, 7, 11)
});
A.inversePrimary = yt.fromPalette({
  name: "inverse_primary",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 40 : 80, "tone"),
  background: /* @__PURE__ */ d((n) => A.inverseSurface, "background"),
  contrastCurve: new Tt(3, 4.5, 7, 7)
});
A.secondary = yt.fromPalette({
  name: "secondary",
  palette: /* @__PURE__ */ d((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => A.highestSurface(n), "background"),
  contrastCurve: new Tt(3, 4.5, 7, 7),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(A.secondaryContainer, A.secondary, 10, "nearer", !1), "toneDeltaPair")
});
A.onSecondary = yt.fromPalette({
  name: "on_secondary",
  palette: /* @__PURE__ */ d((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => ie(n) ? n.isDark ? 10 : 100 : n.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ d((n) => A.secondary, "background"),
  contrastCurve: new Tt(4.5, 7, 11, 21)
});
A.secondaryContainer = yt.fromPalette({
  name: "secondary_container",
  palette: /* @__PURE__ */ d((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => {
    const t = n.isDark ? 30 : 90;
    return ie(n) ? n.isDark ? 30 : 85 : Tl(n) ? _z(n.secondaryPalette.hue, n.secondaryPalette.chroma, t, !n.isDark) : t;
  }, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => A.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(A.secondaryContainer, A.secondary, 10, "nearer", !1), "toneDeltaPair")
});
A.onSecondaryContainer = yt.fromPalette({
  name: "on_secondary_container",
  palette: /* @__PURE__ */ d((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => ie(n) ? n.isDark ? 90 : 10 : Tl(n) ? yt.foregroundTone(A.secondaryContainer.tone(n), 4.5) : n.isDark ? 90 : 30, "tone"),
  background: /* @__PURE__ */ d((n) => A.secondaryContainer, "background"),
  contrastCurve: new Tt(3, 4.5, 7, 11)
});
A.tertiary = yt.fromPalette({
  name: "tertiary",
  palette: /* @__PURE__ */ d((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => ie(n) ? n.isDark ? 90 : 25 : n.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => A.highestSurface(n), "background"),
  contrastCurve: new Tt(3, 4.5, 7, 7),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(A.tertiaryContainer, A.tertiary, 10, "nearer", !1), "toneDeltaPair")
});
A.onTertiary = yt.fromPalette({
  name: "on_tertiary",
  palette: /* @__PURE__ */ d((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => ie(n) ? n.isDark ? 10 : 90 : n.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ d((n) => A.tertiary, "background"),
  contrastCurve: new Tt(4.5, 7, 11, 21)
});
A.tertiaryContainer = yt.fromPalette({
  name: "tertiary_container",
  palette: /* @__PURE__ */ d((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => {
    if (ie(n))
      return n.isDark ? 60 : 49;
    if (!Tl(n))
      return n.isDark ? 30 : 90;
    const t = n.tertiaryPalette.getHct(n.sourceColorHct.tone);
    return fB.fixIfDisliked(t).tone;
  }, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => A.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(A.tertiaryContainer, A.tertiary, 10, "nearer", !1), "toneDeltaPair")
});
A.onTertiaryContainer = yt.fromPalette({
  name: "on_tertiary_container",
  palette: /* @__PURE__ */ d((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => ie(n) ? n.isDark ? 0 : 100 : Tl(n) ? yt.foregroundTone(A.tertiaryContainer.tone(n), 4.5) : n.isDark ? 90 : 30, "tone"),
  background: /* @__PURE__ */ d((n) => A.tertiaryContainer, "background"),
  contrastCurve: new Tt(3, 4.5, 7, 11)
});
A.error = yt.fromPalette({
  name: "error",
  palette: /* @__PURE__ */ d((n) => n.errorPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => A.highestSurface(n), "background"),
  contrastCurve: new Tt(3, 4.5, 7, 7),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(A.errorContainer, A.error, 10, "nearer", !1), "toneDeltaPair")
});
A.onError = yt.fromPalette({
  name: "on_error",
  palette: /* @__PURE__ */ d((n) => n.errorPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ d((n) => A.error, "background"),
  contrastCurve: new Tt(4.5, 7, 11, 21)
});
A.errorContainer = yt.fromPalette({
  name: "error_container",
  palette: /* @__PURE__ */ d((n) => n.errorPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 30 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => A.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(A.errorContainer, A.error, 10, "nearer", !1), "toneDeltaPair")
});
A.onErrorContainer = yt.fromPalette({
  name: "on_error_container",
  palette: /* @__PURE__ */ d((n) => n.errorPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => ie(n) ? n.isDark ? 90 : 10 : n.isDark ? 90 : 30, "tone"),
  background: /* @__PURE__ */ d((n) => A.errorContainer, "background"),
  contrastCurve: new Tt(3, 4.5, 7, 11)
});
A.primaryFixed = yt.fromPalette({
  name: "primary_fixed",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => ie(n) ? 40 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => A.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(A.primaryFixed, A.primaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
A.primaryFixedDim = yt.fromPalette({
  name: "primary_fixed_dim",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => ie(n) ? 30 : 80, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => A.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(A.primaryFixed, A.primaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
A.onPrimaryFixed = yt.fromPalette({
  name: "on_primary_fixed",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => ie(n) ? 100 : 10, "tone"),
  background: /* @__PURE__ */ d((n) => A.primaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ d((n) => A.primaryFixed, "secondBackground"),
  contrastCurve: new Tt(4.5, 7, 11, 21)
});
A.onPrimaryFixedVariant = yt.fromPalette({
  name: "on_primary_fixed_variant",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => ie(n) ? 90 : 30, "tone"),
  background: /* @__PURE__ */ d((n) => A.primaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ d((n) => A.primaryFixed, "secondBackground"),
  contrastCurve: new Tt(3, 4.5, 7, 11)
});
A.secondaryFixed = yt.fromPalette({
  name: "secondary_fixed",
  palette: /* @__PURE__ */ d((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => ie(n) ? 80 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => A.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(A.secondaryFixed, A.secondaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
A.secondaryFixedDim = yt.fromPalette({
  name: "secondary_fixed_dim",
  palette: /* @__PURE__ */ d((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => ie(n) ? 70 : 80, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => A.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(A.secondaryFixed, A.secondaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
A.onSecondaryFixed = yt.fromPalette({
  name: "on_secondary_fixed",
  palette: /* @__PURE__ */ d((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => 10, "tone"),
  background: /* @__PURE__ */ d((n) => A.secondaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ d((n) => A.secondaryFixed, "secondBackground"),
  contrastCurve: new Tt(4.5, 7, 11, 21)
});
A.onSecondaryFixedVariant = yt.fromPalette({
  name: "on_secondary_fixed_variant",
  palette: /* @__PURE__ */ d((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => ie(n) ? 25 : 30, "tone"),
  background: /* @__PURE__ */ d((n) => A.secondaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ d((n) => A.secondaryFixed, "secondBackground"),
  contrastCurve: new Tt(3, 4.5, 7, 11)
});
A.tertiaryFixed = yt.fromPalette({
  name: "tertiary_fixed",
  palette: /* @__PURE__ */ d((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => ie(n) ? 40 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => A.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(A.tertiaryFixed, A.tertiaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
A.tertiaryFixedDim = yt.fromPalette({
  name: "tertiary_fixed_dim",
  palette: /* @__PURE__ */ d((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => ie(n) ? 30 : 80, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => A.highestSurface(n), "background"),
  contrastCurve: new Tt(1, 1, 3, 4.5),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(A.tertiaryFixed, A.tertiaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
A.onTertiaryFixed = yt.fromPalette({
  name: "on_tertiary_fixed",
  palette: /* @__PURE__ */ d((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => ie(n) ? 100 : 10, "tone"),
  background: /* @__PURE__ */ d((n) => A.tertiaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ d((n) => A.tertiaryFixed, "secondBackground"),
  contrastCurve: new Tt(4.5, 7, 11, 21)
});
A.onTertiaryFixedVariant = yt.fromPalette({
  name: "on_tertiary_fixed_variant",
  palette: /* @__PURE__ */ d((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => ie(n) ? 90 : 30, "tone"),
  background: /* @__PURE__ */ d((n) => A.tertiaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ d((n) => A.tertiaryFixed, "secondBackground"),
  contrastCurve: new Tt(3, 4.5, 7, 11)
});
var fp;
const Lz = (fp = class {
  constructor(t) {
    this.sourceColorArgb = t.sourceColorArgb, this.variant = t.variant, this.contrastLevel = t.contrastLevel, this.isDark = t.isDark, this.sourceColorHct = Qn.fromInt(t.sourceColorArgb), this.primaryPalette = t.primaryPalette, this.secondaryPalette = t.secondaryPalette, this.tertiaryPalette = t.tertiaryPalette, this.neutralPalette = t.neutralPalette, this.neutralVariantPalette = t.neutralVariantPalette, this.errorPalette = Et.fromHueAndChroma(25, 84);
  }
  /**
   * Support design spec'ing Dynamic Color by schemes that specify hue
   * rotations that should be applied at certain breakpoints.
   * @param sourceColor the source color of the theme, in HCT.
   * @param hues The "breakpoints", i.e. the hues at which a rotation should
   * be apply.
   * @param rotations The rotation that should be applied when source color's
   * hue is >= the same index in hues array, and <= the hue at the next index
   * in hues array.
   */
  static getRotatedHue(t, e, i) {
    const s = t.hue;
    if (e.length !== i.length)
      throw new Error(`mismatch between hue length ${e.length} & rotations ${i.length}`);
    if (i.length === 1)
      return om(t.hue + i[0]);
    const r = e.length;
    for (let a = 0; a <= r - 2; a++) {
      const o = e[a], l = e[a + 1];
      if (o < s && s < l)
        return om(s + i[a]);
    }
    return s;
  }
  getArgb(t) {
    return t.getArgb(this);
  }
  getHct(t) {
    return t.getHct(this);
  }
  get primaryPaletteKeyColor() {
    return this.getArgb(A.primaryPaletteKeyColor);
  }
  get secondaryPaletteKeyColor() {
    return this.getArgb(A.secondaryPaletteKeyColor);
  }
  get tertiaryPaletteKeyColor() {
    return this.getArgb(A.tertiaryPaletteKeyColor);
  }
  get neutralPaletteKeyColor() {
    return this.getArgb(A.neutralPaletteKeyColor);
  }
  get neutralVariantPaletteKeyColor() {
    return this.getArgb(A.neutralVariantPaletteKeyColor);
  }
  get background() {
    return this.getArgb(A.background);
  }
  get onBackground() {
    return this.getArgb(A.onBackground);
  }
  get surface() {
    return this.getArgb(A.surface);
  }
  get surfaceDim() {
    return this.getArgb(A.surfaceDim);
  }
  get surfaceBright() {
    return this.getArgb(A.surfaceBright);
  }
  get surfaceContainerLowest() {
    return this.getArgb(A.surfaceContainerLowest);
  }
  get surfaceContainerLow() {
    return this.getArgb(A.surfaceContainerLow);
  }
  get surfaceContainer() {
    return this.getArgb(A.surfaceContainer);
  }
  get surfaceContainerHigh() {
    return this.getArgb(A.surfaceContainerHigh);
  }
  get surfaceContainerHighest() {
    return this.getArgb(A.surfaceContainerHighest);
  }
  get onSurface() {
    return this.getArgb(A.onSurface);
  }
  get surfaceVariant() {
    return this.getArgb(A.surfaceVariant);
  }
  get onSurfaceVariant() {
    return this.getArgb(A.onSurfaceVariant);
  }
  get inverseSurface() {
    return this.getArgb(A.inverseSurface);
  }
  get inverseOnSurface() {
    return this.getArgb(A.inverseOnSurface);
  }
  get outline() {
    return this.getArgb(A.outline);
  }
  get outlineVariant() {
    return this.getArgb(A.outlineVariant);
  }
  get shadow() {
    return this.getArgb(A.shadow);
  }
  get scrim() {
    return this.getArgb(A.scrim);
  }
  get surfaceTint() {
    return this.getArgb(A.surfaceTint);
  }
  get primary() {
    return this.getArgb(A.primary);
  }
  get onPrimary() {
    return this.getArgb(A.onPrimary);
  }
  get primaryContainer() {
    return this.getArgb(A.primaryContainer);
  }
  get onPrimaryContainer() {
    return this.getArgb(A.onPrimaryContainer);
  }
  get inversePrimary() {
    return this.getArgb(A.inversePrimary);
  }
  get secondary() {
    return this.getArgb(A.secondary);
  }
  get onSecondary() {
    return this.getArgb(A.onSecondary);
  }
  get secondaryContainer() {
    return this.getArgb(A.secondaryContainer);
  }
  get onSecondaryContainer() {
    return this.getArgb(A.onSecondaryContainer);
  }
  get tertiary() {
    return this.getArgb(A.tertiary);
  }
  get onTertiary() {
    return this.getArgb(A.onTertiary);
  }
  get tertiaryContainer() {
    return this.getArgb(A.tertiaryContainer);
  }
  get onTertiaryContainer() {
    return this.getArgb(A.onTertiaryContainer);
  }
  get error() {
    return this.getArgb(A.error);
  }
  get onError() {
    return this.getArgb(A.onError);
  }
  get errorContainer() {
    return this.getArgb(A.errorContainer);
  }
  get onErrorContainer() {
    return this.getArgb(A.onErrorContainer);
  }
  get primaryFixed() {
    return this.getArgb(A.primaryFixed);
  }
  get primaryFixedDim() {
    return this.getArgb(A.primaryFixedDim);
  }
  get onPrimaryFixed() {
    return this.getArgb(A.onPrimaryFixed);
  }
  get onPrimaryFixedVariant() {
    return this.getArgb(A.onPrimaryFixedVariant);
  }
  get secondaryFixed() {
    return this.getArgb(A.secondaryFixed);
  }
  get secondaryFixedDim() {
    return this.getArgb(A.secondaryFixedDim);
  }
  get onSecondaryFixed() {
    return this.getArgb(A.onSecondaryFixed);
  }
  get onSecondaryFixedVariant() {
    return this.getArgb(A.onSecondaryFixedVariant);
  }
  get tertiaryFixed() {
    return this.getArgb(A.tertiaryFixed);
  }
  get tertiaryFixedDim() {
    return this.getArgb(A.tertiaryFixedDim);
  }
  get onTertiaryFixed() {
    return this.getArgb(A.onTertiaryFixed);
  }
  get onTertiaryFixedVariant() {
    return this.getArgb(A.onTertiaryFixedVariant);
  }
}, c(fp, "Iy"), fp);
d(Lz, "DynamicScheme");
let ao = Lz;
var ns;
const Iz = (ns = class extends ao {
  constructor(t, e, i) {
    super({
      sourceColorArgb: t.toInt(),
      variant: sl.EXPRESSIVE,
      contrastLevel: i,
      isDark: e,
      primaryPalette: Et.fromHueAndChroma(om(t.hue + 240), 40),
      secondaryPalette: Et.fromHueAndChroma(ao.getRotatedHue(t, ns.hues, ns.secondaryRotations), 24),
      tertiaryPalette: Et.fromHueAndChroma(ao.getRotatedHue(t, ns.hues, ns.tertiaryRotations), 32),
      neutralPalette: Et.fromHueAndChroma(t.hue + 15, 8),
      neutralVariantPalette: Et.fromHueAndChroma(t.hue + 15, 12)
    });
  }
}, c(ns, "Gr"), ns);
d(Iz, "SchemeExpressive");
let qP = Iz;
qP.hues = [
  0,
  21,
  51,
  121,
  151,
  191,
  271,
  321,
  360
];
qP.secondaryRotations = [
  45,
  95,
  45,
  20,
  45,
  90,
  45,
  45,
  45
];
qP.tertiaryRotations = [
  120,
  120,
  20,
  45,
  20,
  15,
  20,
  120,
  120
];
var ss;
const Wz = (ss = class extends ao {
  constructor(t, e, i) {
    super({
      sourceColorArgb: t.toInt(),
      variant: sl.VIBRANT,
      contrastLevel: i,
      isDark: e,
      primaryPalette: Et.fromHueAndChroma(t.hue, 200),
      secondaryPalette: Et.fromHueAndChroma(ao.getRotatedHue(t, ss.hues, ss.secondaryRotations), 24),
      tertiaryPalette: Et.fromHueAndChroma(ao.getRotatedHue(t, ss.hues, ss.tertiaryRotations), 32),
      neutralPalette: Et.fromHueAndChroma(t.hue, 10),
      neutralVariantPalette: Et.fromHueAndChroma(t.hue, 12)
    });
  }
}, c(ss, "Zr"), ss);
d(Wz, "SchemeVibrant");
let ZP = Wz;
ZP.hues = [
  0,
  41,
  61,
  101,
  131,
  181,
  251,
  301,
  360
];
ZP.secondaryRotations = [
  18,
  15,
  10,
  12,
  15,
  18,
  15,
  12,
  12
];
ZP.tertiaryRotations = [
  35,
  30,
  20,
  25,
  30,
  35,
  30,
  25,
  25
];
function Vz(n) {
  n = n.replace("#", "");
  const t = n.length === 3, e = n.length === 6, i = n.length === 8;
  if (!t && !e && !i)
    throw new Error("unexpected hex " + n);
  let s = 0, r = 0, a = 0;
  return t ? (s = jn(n.slice(0, 1).repeat(2)), r = jn(n.slice(1, 2).repeat(2)), a = jn(n.slice(2, 3).repeat(2))) : e ? (s = jn(n.slice(0, 2)), r = jn(n.slice(2, 4)), a = jn(n.slice(4, 6))) : i && (s = jn(n.slice(2, 4)), r = jn(n.slice(4, 6)), a = jn(n.slice(6, 8))), (255 << 24 | (s & 255) << 16 | (r & 255) << 8 | a & 255) >>> 0;
}
c(Vz, "Pg");
d(Vz, "argbFromHex");
function jn(n) {
  return parseInt(n, 16);
}
c(jn, "Ii");
d(jn, "parseIntHex");
function Dz(n, t = !1) {
  const e = n.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+\.{0,1}\d*))?\)$/)?.slice(1).map((o, l) => l === 3 ? Math.round(parseFloat(o) * 255) : parseFloat(o));
  if (!e)
    throw new Error("Could not parse rgba color.");
  const [i, s, r, a] = e;
  return ((t ? 255 : a & 255) << 24 | (i & 255) << 16 | (s & 255) << 8 | r & 255) >>> 0;
}
c(Dz, "Mg");
d(Dz, "argbFromRgba");
function bn(n, t) {
  return Math.round(255 * t) << 24 | n & 16777215;
}
c(bn, "yi");
d(bn, "addAlphaToArgb");
function qz(n) {
  const t = IP(n), e = WP(n), i = VP(n), s = gz(n), r = [t.toString(16), e.toString(16), i.toString(16)];
  s !== 255 && r.push(s.toString(16));
  for (const [a, o] of r.entries())
    o.length === 1 && (r[a] = "0" + o);
  return "#" + r.join("");
}
c(qz, "Sg");
d(qz, "hexWithAlphaFromArgb");
function Zz(n) {
  we();
  const t = document.createElement("wy-compute-styles");
  t.setAttribute("style", `color: ${n} !important;`), document.documentElement.append(t);
  const e = window.getComputedStyle(t).color;
  return t.remove(), e;
}
c(Zz, "Ag");
d(Zz, "getComputedColor");
var yp;
const Fz = (yp = class extends ao {
  constructor(t, e, i) {
    super({
      sourceColorArgb: t.toInt(),
      variant: 2,
      contrastLevel: i,
      isDark: e,
      primaryPalette: Et.fromHueAndChroma(t.hue, 36),
      secondaryPalette: Et.fromHueAndChroma(t.hue, 16),
      tertiaryPalette: Et.fromHueAndChroma(om(t.hue - 6 * 22.5), 16),
      neutralPalette: Et.fromHueAndChroma(t.hue, 6),
      neutralVariantPalette: Et.fromHueAndChroma(t.hue, 8)
    }), this.allTones = {
      //"100": 100,
      98: 98,
      // MD3
      95: 95,
      90: 90,
      80: 80,
      70: 70,
      60: 60,
      50: 50,
      40: 40,
      30: 30,
      20: 20,
      10: 10
      //"0": 0
    }, this.namedColorToneMap = {
      red: { light: 60, dark: 60 },
      "deep-orange": { light: 60, dark: 60 },
      orange: { light: 70, dark: 70 },
      amber: { light: 70, dark: 70 },
      yellow: { light: 70, dark: 80 },
      lime: { light: 70, dark: 70 },
      "light-green": { light: 70, dark: 70 },
      green: { light: 60, dark: 60 },
      teal: { light: 60, dark: 60 },
      cyan: { light: 50, dark: 60 },
      "light-blue": { light: 60, dark: 70 },
      blue: { light: 70, dark: 80 },
      indigo: { light: 60, dark: 60 },
      "deep-purple": { light: 60, dark: 70 },
      purple: { light: 60, dark: 70 },
      pink: { light: 60, dark: 70 },
      gray: { light: 50, dark: 60 }
    };
    const s = t.hue, r = t.chroma, a = Math.max(48, r), o = Math.min(a, 84), l = 360 / 16, h = 27.4, u = -8, p = (s + 360 - h - u + l / 2) % l + h + u - l / 2;
    this.errorPalette = Et.fromHueAndChroma(p, 84), this.warningPalette = Et.fromHueAndChroma(p + 4 * l, o), this.namedColorPalettes = {
      red: Et.fromHueAndChroma(p, o),
      "deep-orange": Et.fromHueAndChroma(p + 1 * l, o),
      orange: Et.fromHueAndChroma(p + 2 * l, o),
      amber: Et.fromHueAndChroma(p + 3 * l, o),
      yellow: Et.fromHueAndChroma(p + 4 * l, o),
      lime: Et.fromHueAndChroma(p + 5 * l, o),
      "light-green": Et.fromHueAndChroma(p + 6 * l, o),
      green: Et.fromHueAndChroma(p + 7 * l, o),
      teal: Et.fromHueAndChroma(p + 8 * l, o),
      cyan: Et.fromHueAndChroma(p + 9 * l, o),
      "light-blue": Et.fromHueAndChroma(p + 10 * l, o),
      blue: Et.fromHueAndChroma(p + 11 * l, o),
      indigo: Et.fromHueAndChroma(p + 12 * l, o),
      "deep-purple": Et.fromHueAndChroma(p + 13 * l, o),
      purple: Et.fromHueAndChroma(p + 14 * l, o),
      pink: Et.fromHueAndChroma(p + 15 * l, o),
      gray: Et.fromHueAndChroma(s, 4)
    };
  }
  // Solid base colors
  get black() {
    return 0;
  }
  get white() {
    return 16777215;
  }
  // Custom transparency based surface container colors
  get surfaceLayerLowest() {
    return this.isDark ? bn(this.black, 0.5) : bn(this.white, 0.75);
  }
  get surfaceLayerLow() {
    return this.isDark ? bn(this.black, 0.25) : bn(this.white, 0.5);
  }
  get surfaceLayer() {
    return this.isDark ? bn(this.white, 0.05) : bn(this.black, 0.05);
  }
  get surfaceLayerHigh() {
    return this.isDark ? bn(this.white, 0.1) : bn(this.black, 0.075);
  }
  get surfaceLayerHighest() {
    return this.isDark ? bn(this.white, 0.15) : bn(this.black, 0.1);
  }
  // Custom Tokens
  get warning() {
    return this.warningPalette.tone(this.isDark ? 90 : 70);
  }
  get onWarning() {
    return this.warningPalette.tone(this.isDark ? 30 : 0);
  }
  get warningContainer() {
    return this.warningPalette.tone(this.isDark ? 50 : 90);
  }
  get onWarningContainer() {
    return this.warningPalette.tone(this.isDark ? 95 : 10);
  }
  get highlight() {
    return this.primaryPalette.tone(this.isDark ? 20 : 95);
  }
  get onHighlight() {
    return this.primaryPalette.tone(this.isDark ? 90 : 10);
  }
  // Named colors
  namedColor(t) {
    return this.namedColorPalettes[t].tone(this.namedColorToneMap[t][this.isDark ? "dark" : "light"]);
  }
  get red() {
    return this.namedColor(
      "red"
      /* Red */
    );
  }
  get deepOrange() {
    return this.namedColor(
      "deep-orange"
      /* DeepOrange */
    );
  }
  get orange() {
    return this.namedColor(
      "orange"
      /* Orange */
    );
  }
  get amber() {
    return this.namedColor(
      "amber"
      /* Amber */
    );
  }
  get yellow() {
    return this.namedColor(
      "yellow"
      /* Yellow */
    );
  }
  get lime() {
    return this.namedColor(
      "lime"
      /* Lime */
    );
  }
  get lightGreen() {
    return this.namedColor(
      "light-green"
      /* LightGreen */
    );
  }
  get green() {
    return this.namedColor(
      "green"
      /* Green */
    );
  }
  get teal() {
    return this.namedColor(
      "teal"
      /* Teal */
    );
  }
  get cyan() {
    return this.namedColor(
      "cyan"
      /* Cyan */
    );
  }
  get lightBlue() {
    return this.namedColor(
      "light-blue"
      /* LightBlue */
    );
  }
  get blue() {
    return this.namedColor(
      "blue"
      /* Blue */
    );
  }
  get indigo() {
    return this.namedColor(
      "indigo"
      /* Indigo */
    );
  }
  get deepPurple() {
    return this.namedColor(
      "deep-purple"
      /* DeepPurple */
    );
  }
  get purple() {
    return this.namedColor(
      "purple"
      /* Purple */
    );
  }
  get pink() {
    return this.namedColor(
      "pink"
      /* Pink */
    );
  }
  get gray() {
    return this.namedColor(
      "gray"
      /* Gray */
    );
  }
}, c(yp, "Ty"), yp);
d(Fz, "SchemeWeavy");
let r9 = Fz;
function sb(n) {
  return getComputedStyle(n).getPropertyValue("--wy-theme-color") || void 0;
}
c(sb, "lu");
d(sb, "getCSSThemeColor");
function Xz(n, t) {
  let e = sb(n);
  const i = new MutationObserver(() => {
    const a = sb(n);
    a !== e && (e = a, t(a));
  }), s = {
    attributes: !0,
    attributeFilter: ["class", "style"]
  };
  let r = n;
  for (; r && r !== document; )
    i.observe(r, s), r = r.parentNode;
  return () => i.disconnect();
}
c(Xz, "zg");
d(Xz, "observeCSSThemeColor");
function rb() {
  return we(), Array.from(document.head.querySelectorAll("meta[name='theme-color']")).filter((n) => {
    const t = n.getAttribute("media");
    return !t || window.matchMedia(t)?.matches;
  }).pop()?.getAttribute("content") || void 0;
}
c(rb, "du");
d(rb, "getMetaThemeColor");
function Nz(n) {
  we();
  const t = Array.from(document.head.querySelectorAll("meta[name='theme-color']"));
  if (!t)
    return () => {
    };
  let e = rb();
  const i = /* @__PURE__ */ d(() => {
    const o = rb();
    o !== e && (e = o, n(o));
  }, "checkChangedColor"), s = new MutationObserver(i), r = {
    attributes: !0,
    attributeFilter: ["content"]
  }, a = [];
  return t.forEach((o) => {
    s.observe(o, r);
    const l = o.getAttribute("media");
    if (l) {
      const h = window.matchMedia(l);
      h.addEventListener("change", i), a.push(h);
    }
  }), () => {
    s.disconnect(), a.forEach((o) => o.removeEventListener("change", i));
  };
}
c(Nz, "Rg");
d(Nz, "observeMetaThemeColor");
const ug = [], mB = 16;
function jz(n, t = !1) {
  if (ug.some((l) => l.seedColor === n)) {
    const l = ug.find((h) => h.seedColor === n)?.colors;
    if (l)
      return l;
  }
  const e = [];
  t && e.push(`--wy-theme-color:${n};`);
  let i = n;
  !n.startsWith("#") && !n.startsWith("rgb") && (i = Zz(n));
  const s = n.startsWith("#") ? Vz(i) : Dz(i), r = Qn.fromInt(s), a = {
    light: new r9(r, !1, 0),
    dark: new r9(r, !0, 0)
  }, o = {
    primary: "primary",
    onPrimary: "on-primary",
    primaryContainer: "primary-container",
    onPrimaryContainer: "on-primary-container",
    secondary: "secondary",
    onSecondary: "on-secondary",
    secondaryContainer: "secondary-container",
    onSecondaryContainer: "on-secondary-container",
    tertiary: "tertiary",
    onTertiary: "on-tertiary",
    tertiaryContainer: "tertiary-container",
    onTertiaryContainer: "on-tertiary-container",
    error: "error",
    onError: "on-error",
    errorContainer: "error-container",
    onErrorContainer: "on-error-container",
    background: "background",
    onBackground: "on-background",
    surface: "surface",
    onSurface: "on-surface",
    surfaceVariant: "surface-variant",
    onSurfaceVariant: "on-surface-variant",
    surfaceContainerLowest: "surface-container-lowest",
    surfaceContainerLow: "surface-container-low",
    surfaceContainer: "surface-container",
    surfaceContainerHigh: "surface-container-high",
    surfaceContainerHighest: "surface-container-highest",
    outline: "outline",
    outlineVariant: "outline-variant",
    shadow: "shadow",
    scrim: "scrim",
    // Custom surface layers
    surfaceLayerLowest: "surface-layer-lowest",
    surfaceLayerLow: "surface-layer-low",
    surfaceLayer: "surface-layer",
    surfaceLayerHigh: "surface-layer-high",
    surfaceLayerHighest: "surface-layer-highest",
    // Custom tokens
    warning: "warning",
    onWarning: "on-warning",
    warningContainer: "warning-container",
    onWarningContainer: "on-warning-container",
    highlight: "highlight",
    onHighlight: "on-highlight",
    // Named colors
    red: "red",
    deepOrange: "deep-orange",
    orange: "orange",
    amber: "amber",
    yellow: "yellow",
    lime: "lime",
    lightGreen: "light-green",
    green: "green",
    teal: "teal",
    cyan: "cyan",
    lightBlue: "light-blue",
    blue: "blue",
    indigo: "indigo",
    deepPurple: "deep-purple",
    purple: "purple",
    pink: "pink",
    gray: "gray"
  };
  for (const l in a) {
    const h = a[l];
    for (const u in o) {
      const p = o[u], y = qz(h[u]);
      e.push(`--wy-${p}-${l}:${y};`);
    }
  }
  return ug.unshift({ seedColor: n, colors: e }), ug.length = Math.min(ug.length, mB), e;
}
c(jz, "Lg");
d(jz, "generateThemeColors");
const gB = /* @__PURE__ */ d((n) => {
  if (we(), s0)
    document.adoptedStyleSheets = n.map((t) => t instanceof CSSStyleSheet ? t : t.styleSheet);
  else
    for (const t of n) {
      const e = document.createElement("style"), i = global.litNonce;
      i !== void 0 && e.setAttribute("nonce", i), e.textContent = t.cssText, (document.head || document.documentElement).appendChild(e);
    }
}, "adoptGlobalStyles"), Te = et`@property --wy-color-scheme{syntax:\"normal | light | dark\";inherits:true;initial-value:normal}:is(.wy-light,[part~=wy-light]) :where(wy-chat),:is(.wy-light,[part~=wy-light]) :where(wy-comments),:is(.wy-light,[part~=wy-light]) :where(wy-component),:is(.wy-light,[part~=wy-light]) :where(wy-copilot),:is(.wy-light,[part~=wy-light]) :where(wy-files),:is(.wy-light,[part~=wy-light]) :where(wy-messenger),:is(.wy-light,[part~=wy-light]) :where(wy-notification-toasts),:is(.wy-light,[part~=wy-light]) :where(wy-notifications),:is(.wy-light,[part~=wy-light]) :where(wy-posts),:host(:is(.wy-light,[part~=wy-light])),:host :is(.wy-light,[part~=wy-light]),::slotted(:is(.wy-light,[part~=wy-light])){color-scheme:light;--wy-primary:var(--wy-primary-light, #2f628c);--wy-on-primary:var(--wy-on-primary-light, #ffffff);--wy-primary-container:var(--wy-primary-container-light, #cee5ff);--wy-on-primary-container:var(--wy-on-primary-container-light, #0d4a73);--wy-secondary:var(--wy-secondary-light, #51606f);--wy-on-secondary:var(--wy-on-secondary-light, #ffffff);--wy-secondary-container:var(--wy-secondary-container-light, #d5e4f7);--wy-on-secondary-container:var(--wy-on-secondary-container-light, #3a4857);--wy-tertiary:var(--wy-tertiary-light, #645f41);--wy-on-tertiary:var(--wy-on-tertiary-light, #ffffff);--wy-tertiary-container:var(--wy-tertiary-container-light, #ebe3bd);--wy-on-tertiary-container:var(--wy-on-tertiary-container-light, #4c472b);--wy-error:var(--wy-error-light, #ba1821);--wy-on-error:var(--wy-on-error-light, #ffffff);--wy-error-container:var(--wy-error-container-light, #ffdad6);--wy-on-error-container:var(--wy-on-error-container-light, #930012);--wy-background:var(--wy-background-light, #f7f9ff);--wy-on-background:var(--wy-on-background-light, #181c20);--wy-surface:var(--wy-surface-light, #f7f9ff);--wy-on-surface:var(--wy-on-surface-light, #181c20);--wy-surface-variant:var(--wy-surface-variant-light, #dee3eb);--wy-on-surface-variant:var(--wy-on-surface-variant-light, #42474e);--wy-outline:var(--wy-outline-light, #72777f);--wy-outline-variant:var(--wy-outline-variant-light, #c2c7cf);--wy-surface-container-highest:var(--wy-surface-container-highest-light, #e0e2e8);--wy-surface-container-high:var(--wy-surface-container-high-light, #e6e8ee);--wy-surface-container:var(--wy-surface-container-light, #eceef3);--wy-surface-container-low:var(--wy-surface-container-low-light, #f1f3f9);--wy-surface-container-lowest:var(--wy-surface-container-lowest-light, #ffffff);--wy-surface-layer-highest:var(--wy-surface-layer-highest-light, rgba(0, 0, 0, .1019607843));--wy-surface-layer-high:var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039));--wy-surface-layer:var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922));--wy-surface-layer-low:var(--wy-surface-layer-low-light, rgba(255, 255, 255, .5019607843));--wy-surface-layer-lowest:var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078));--wy-warning:var(--wy-warning-light, #adb140);--wy-on-warning:var(--wy-on-warning-light, #000000);--wy-warning-container:var(--wy-warning-container-light, #e5e972);--wy-on-warning-container:var(--wy-on-warning-container-light, #1c1d00);--wy-highlight:var(--wy-highlight-light, #e8f2ff);--wy-on-highlight:var(--wy-on-highlight-light, #001d32);--wy-link:var(--wy-primary-light, #2f628c);--wy-presence-active:var(--wy-green-light, #00a38d);--wy-shade:var(--wy-shade-light, rgba(0, 0, 0, .3));--wy-shade-invert:var(--wy-shade-invert-light, rgba(255, 255, 255, .15));--wy-shade-opaque:var(--wy-shade-opaque-light, white);--wy-blue:var(--wy-blue-light, #8aa9fc);--wy-indigo:var(--wy-indigo-light, #9285de);--wy-purple:var(--wy-purple-light, #c675b6);--wy-pink:var(--wy-pink-light, #d57193);--wy-red:var(--wy-red-light, #db726b);--wy-orange:var(--wy-orange-light, #e79b3a);--wy-yellow:var(--wy-yellow-light, #adb140);--wy-green:var(--wy-green-light, #00a38d);--wy-teal:var(--wy-teal-light, #00a0a9);--wy-cyan:var(--wy-cyan-light, #0081a2);--wy-gray:var(--wy-gray-light, #76777a);--wy-code-text:var(--wy-code-text-light, #3b3b3b);--wy-code-variable:var(--wy-code-variable-light, #001080);--wy-code-operator:var(--wy-code-operator-light, #000000);--wy-code-prolog:var(--wy-code-prolog-light, #000080);--wy-code-comment:var(--wy-code-comment-light, #008000);--wy-code-builtin:var(--wy-code-builtin-light, #0070C1);--wy-code-number:var(--wy-code-number-light, #098658);--wy-code-inserted:var(--wy-code-inserted-light, #098658);--wy-code-constant:var(--wy-code-constant-light, #811F3F);--wy-code-hexcode:var(--wy-code-hexcode-light, #811F3F);--wy-code-regex:var(--wy-code-regex-light, #811F3F);--wy-code-char:var(--wy-code-char-light, #811F3F);--wy-code-tag:var(--wy-code-tag-light, #800000);--wy-code-attr-name:var(--wy-code-attr-name-light, #E50000);--wy-code-selector:var(--wy-code-selector-light, #E50000);--wy-code-property:var(--wy-code-property-light, #E50000);--wy-code-deleted:var(--wy-code-deleted-light, #A31515);--wy-code-string:var(--wy-code-string-light, #A31515);--wy-code-changed:var(--wy-code-changed-light, #0451A5);--wy-code-punctuation:var(--wy-code-punctuation-light, #000000);--wy-code-function:var(--wy-code-function-light, #0000FF);--wy-code-keyword:var(--wy-code-keyword-light, #AF00DB);--wy-code-class-name:var(--wy-code-class-name-light, #267F99)}:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-chat),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-comments),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-component),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-copilot),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-files),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-messenger),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-notification-toasts),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-notifications),:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]) :where(wy-posts),:host(:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light])),:host :is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light]),::slotted(:is(.wy-dark,[part~=wy-dark]):not(.wy-light,[part~=wy-light])){color-scheme:dark;--wy-primary:var(--wy-primary-dark, #9bcbfa);--wy-on-primary:var(--wy-on-primary-dark, #003353);--wy-primary-container:var(--wy-primary-container-dark, #0d4a73);--wy-on-primary-container:var(--wy-on-primary-container-dark, #cee5ff);--wy-secondary:var(--wy-secondary-dark, #b9c8da);--wy-on-secondary:var(--wy-on-secondary-dark, #233240);--wy-secondary-container:var(--wy-secondary-container-dark, #3a4857);--wy-on-secondary-container:var(--wy-on-secondary-container-dark, #d5e4f7);--wy-tertiary:var(--wy-tertiary-dark, #cfc7a2);--wy-on-tertiary:var(--wy-on-tertiary-dark, #353117);--wy-tertiary-container:var(--wy-tertiary-container-dark, #4c472b);--wy-on-tertiary-container:var(--wy-on-tertiary-container-dark, #ebe3bd);--wy-error:var(--wy-error-dark, #ffb3ad);--wy-on-error:var(--wy-on-error-dark, #680009);--wy-error-container:var(--wy-error-container-dark, #930012);--wy-on-error-container:var(--wy-on-error-container-dark, #ffdad6);--wy-background:var(--wy-background-dark, #101418);--wy-on-background:var(--wy-on-background-dark, #e0e2e8);--wy-surface:var(--wy-surface-dark, #101418);--wy-on-surface:var(--wy-on-surface-dark, #e0e2e8);--wy-surface-variant:var(--wy-surface-variant-dark, #42474e);--wy-on-surface-variant:var(--wy-on-surface-variant-dark, #c2c7cf);--wy-outline:var(--wy-outline-dark, #8c9198);--wy-outline-variant:var(--wy-outline-variant-dark, #42474e);--wy-surface-container-highest:var(--wy-surface-container-highest-dark, #323539);--wy-surface-container-high:var(--wy-surface-container-high-dark, #272a2f);--wy-surface-container:var(--wy-surface-container-dark, #1c2024);--wy-surface-container-low:var(--wy-surface-container-low-dark, #181c20);--wy-surface-container-lowest:var(--wy-surface-container-lowest-dark, #0b0f12);--wy-surface-layer-highest:var(--wy-surface-layer-highest-dark, rgba(255, 255, 255, .1490196078));--wy-surface-layer-high:var(--wy-surface-layer-high-dark, rgba(255, 255, 255, .1019607843));--wy-surface-layer:var(--wy-surface-layer-dark, rgba(255, 255, 255, .0509803922));--wy-surface-layer-low:var(--wy-surface-layer-low-dark, rgba(0, 0, 0, .2509803922));--wy-surface-layer-lowest:var(--wy-surface-layer-lowest-dark, rgba(0, 0, 0, .5019607843));--wy-warning:var(--wy-warning-dark, #e5e972);--wy-on-warning:var(--wy-on-warning-dark, #484a00);--wy-warning-container:var(--wy-warning-container-dark, #787c07);--wy-on-warning-container:var(--wy-on-warning-container-dark, #f4f87e);--wy-highlight:var(--wy-highlight-dark, #003353);--wy-on-highlight:var(--wy-on-highlight-dark, #cee5ff);--wy-link:var(--wy-primary-dark, #9bcbfa);--wy-presence-active:var(--wy-green-dark, #00a38d);--wy-shade:var(--wy-shade-dark, rgba(0, 0, 0, .5));--wy-shade-invert:var(--wy-shade-invert-dark, rgba(255, 255, 255, .25));--wy-shade-opaque:var(--wy-shade-opaque-dark, grey);--wy-blue:var(--wy-blue-dark, #b2c5ff);--wy-indigo:var(--wy-indigo-dark, #9285de);--wy-purple:var(--wy-purple-dark, #e48fd2);--wy-pink:var(--wy-pink-dark, #f58bad);--wy-red:var(--wy-red-dark, #db726b);--wy-orange:var(--wy-orange-dark, #e79b3a);--wy-yellow:var(--wy-yellow-dark, #c9cd59);--wy-green:var(--wy-green-dark, #00a38d);--wy-teal:var(--wy-teal-dark, #00a0a9);--wy-cyan:var(--wy-cyan-dark, #009dc4);--wy-gray:var(--wy-gray-dark, #909194);--wy-code-text:var(--wy-code-text-dark, #cccccc);--wy-code-variable:var(--wy-code-variable-dark, #9CDCFE);--wy-code-operator:var(--wy-code-operator-dark, #d4d4d4);--wy-code-prolog:var(--wy-code-prolog-dark, #569CD6);--wy-code-comment:var(--wy-code-comment-dark, #6a9955);--wy-code-builtin:var(--wy-code-builtin-dark, #4fc1ff);--wy-code-number:var(--wy-code-number-dark, #b5cea8);--wy-code-inserted:var(--wy-code-inserted-dark, #b5cea8);--wy-code-constant:var(--wy-code-constant-dark, #646695);--wy-code-hexcode:var(--wy-code-hexcode-dark, #646695);--wy-code-regex:var(--wy-code-regex-dark, #d16969);--wy-code-char:var(--wy-code-char-dark, #d16969);--wy-code-tag:var(--wy-code-tag-dark, #569cd6);--wy-code-attr-name:var(--wy-code-attr-name-dark, #9cdcfe);--wy-code-selector:var(--wy-code-selector-dark, #9cdcfe);--wy-code-property:var(--wy-code-property-dark, #9cdcfe);--wy-code-deleted:var(--wy-code-deleted-dark, #ce9178);--wy-code-string:var(--wy-code-string-dark, #ce9178);--wy-code-changed:var(--wy-code-changed-dark, #569cd6);--wy-code-punctuation:var(--wy-code-punctuation-dark, #D4D4D4);--wy-code-function:var(--wy-code-function-dark, #569cd6);--wy-code-keyword:var(--wy-code-keyword-dark, #C586C0);--wy-code-class-name:var(--wy-code-class-name-dark, #4ec9b0)}@container style(--wy-color-scheme: dark){:not(.wy-light):not([part~=wy-light]) :where(wy-chat),:not(.wy-light):not([part~=wy-light]) :where(wy-comments),:not(.wy-light):not([part~=wy-light]) :where(wy-component),:not(.wy-light):not([part~=wy-light]) :where(wy-copilot),:not(.wy-light):not([part~=wy-light]) :where(wy-files),:not(.wy-light):not([part~=wy-light]) :where(wy-messenger),:not(.wy-light):not([part~=wy-light]) :where(wy-notification-toasts),:not(.wy-light):not([part~=wy-light]) :where(wy-notifications),:not(.wy-light):not([part~=wy-light]) :where(wy-posts),:host(:not(.wy-light):not([part~=wy-light])),:host :not(.wy-light):not([part~=wy-light]),::slotted(:not(.wy-light):not([part~=wy-light])){color-scheme:dark;--wy-primary:var(--wy-primary-dark, #9bcbfa);--wy-on-primary:var(--wy-on-primary-dark, #003353);--wy-primary-container:var(--wy-primary-container-dark, #0d4a73);--wy-on-primary-container:var(--wy-on-primary-container-dark, #cee5ff);--wy-secondary:var(--wy-secondary-dark, #b9c8da);--wy-on-secondary:var(--wy-on-secondary-dark, #233240);--wy-secondary-container:var(--wy-secondary-container-dark, #3a4857);--wy-on-secondary-container:var(--wy-on-secondary-container-dark, #d5e4f7);--wy-tertiary:var(--wy-tertiary-dark, #cfc7a2);--wy-on-tertiary:var(--wy-on-tertiary-dark, #353117);--wy-tertiary-container:var(--wy-tertiary-container-dark, #4c472b);--wy-on-tertiary-container:var(--wy-on-tertiary-container-dark, #ebe3bd);--wy-error:var(--wy-error-dark, #ffb3ad);--wy-on-error:var(--wy-on-error-dark, #680009);--wy-error-container:var(--wy-error-container-dark, #930012);--wy-on-error-container:var(--wy-on-error-container-dark, #ffdad6);--wy-background:var(--wy-background-dark, #101418);--wy-on-background:var(--wy-on-background-dark, #e0e2e8);--wy-surface:var(--wy-surface-dark, #101418);--wy-on-surface:var(--wy-on-surface-dark, #e0e2e8);--wy-surface-variant:var(--wy-surface-variant-dark, #42474e);--wy-on-surface-variant:var(--wy-on-surface-variant-dark, #c2c7cf);--wy-outline:var(--wy-outline-dark, #8c9198);--wy-outline-variant:var(--wy-outline-variant-dark, #42474e);--wy-surface-container-highest:var(--wy-surface-container-highest-dark, #323539);--wy-surface-container-high:var(--wy-surface-container-high-dark, #272a2f);--wy-surface-container:var(--wy-surface-container-dark, #1c2024);--wy-surface-container-low:var(--wy-surface-container-low-dark, #181c20);--wy-surface-container-lowest:var(--wy-surface-container-lowest-dark, #0b0f12);--wy-surface-layer-highest:var(--wy-surface-layer-highest-dark, rgba(255, 255, 255, .1490196078));--wy-surface-layer-high:var(--wy-surface-layer-high-dark, rgba(255, 255, 255, .1019607843));--wy-surface-layer:var(--wy-surface-layer-dark, rgba(255, 255, 255, .0509803922));--wy-surface-layer-low:var(--wy-surface-layer-low-dark, rgba(0, 0, 0, .2509803922));--wy-surface-layer-lowest:var(--wy-surface-layer-lowest-dark, rgba(0, 0, 0, .5019607843));--wy-warning:var(--wy-warning-dark, #e5e972);--wy-on-warning:var(--wy-on-warning-dark, #484a00);--wy-warning-container:var(--wy-warning-container-dark, #787c07);--wy-on-warning-container:var(--wy-on-warning-container-dark, #f4f87e);--wy-highlight:var(--wy-highlight-dark, #003353);--wy-on-highlight:var(--wy-on-highlight-dark, #cee5ff);--wy-link:var(--wy-primary-dark, #9bcbfa);--wy-presence-active:var(--wy-green-dark, #00a38d);--wy-shade:var(--wy-shade-dark, rgba(0, 0, 0, .5));--wy-shade-invert:var(--wy-shade-invert-dark, rgba(255, 255, 255, .25));--wy-shade-opaque:var(--wy-shade-opaque-dark, grey);--wy-blue:var(--wy-blue-dark, #b2c5ff);--wy-indigo:var(--wy-indigo-dark, #9285de);--wy-purple:var(--wy-purple-dark, #e48fd2);--wy-pink:var(--wy-pink-dark, #f58bad);--wy-red:var(--wy-red-dark, #db726b);--wy-orange:var(--wy-orange-dark, #e79b3a);--wy-yellow:var(--wy-yellow-dark, #c9cd59);--wy-green:var(--wy-green-dark, #00a38d);--wy-teal:var(--wy-teal-dark, #00a0a9);--wy-cyan:var(--wy-cyan-dark, #009dc4);--wy-gray:var(--wy-gray-dark, #909194);--wy-code-text:var(--wy-code-text-dark, #cccccc);--wy-code-variable:var(--wy-code-variable-dark, #9CDCFE);--wy-code-operator:var(--wy-code-operator-dark, #d4d4d4);--wy-code-prolog:var(--wy-code-prolog-dark, #569CD6);--wy-code-comment:var(--wy-code-comment-dark, #6a9955);--wy-code-builtin:var(--wy-code-builtin-dark, #4fc1ff);--wy-code-number:var(--wy-code-number-dark, #b5cea8);--wy-code-inserted:var(--wy-code-inserted-dark, #b5cea8);--wy-code-constant:var(--wy-code-constant-dark, #646695);--wy-code-hexcode:var(--wy-code-hexcode-dark, #646695);--wy-code-regex:var(--wy-code-regex-dark, #d16969);--wy-code-char:var(--wy-code-char-dark, #d16969);--wy-code-tag:var(--wy-code-tag-dark, #569cd6);--wy-code-attr-name:var(--wy-code-attr-name-dark, #9cdcfe);--wy-code-selector:var(--wy-code-selector-dark, #9cdcfe);--wy-code-property:var(--wy-code-property-dark, #9cdcfe);--wy-code-deleted:var(--wy-code-deleted-dark, #ce9178);--wy-code-string:var(--wy-code-string-dark, #ce9178);--wy-code-changed:var(--wy-code-changed-dark, #569cd6);--wy-code-punctuation:var(--wy-code-punctuation-dark, #D4D4D4);--wy-code-function:var(--wy-code-function-dark, #569cd6);--wy-code-keyword:var(--wy-code-keyword-dark, #C586C0);--wy-code-class-name:var(--wy-code-class-name-dark, #4ec9b0)}}`, wB = et`@property --wy-component-color{syntax:\"<color>\";inherits:true;initial-value:currentColor}@property --wy-component-background-color{syntax:\"<color>\";inherits:true;initial-value:rgba(0,0,0,0)}`, vB = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), gB([wB, Te]);
    }
  }, c(e, "t"), e), d(t, "WeavyStyles"), t;
}, "WeavyStylesMixin"), OB = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this.version = ze.version, this.whenUrl().then(() => {
        this.isDestroyed || this.checkVersion();
      });
    }
    /**
     * Checks the version of the Weavy Context against the Weavy Environment version.
     *
     * @param {string} [version] - Optional version to check against the environment version.
     */
    async checkVersion(s = this.version) {
      await this.whenUrl(), this.networkStateIsPending = !0;
      let r;
      try {
        if (r = await fetch(new URL("/version", this.url), await this.fetchOptions({}, !1)), !r.ok)
          throw new Error("Could not verify environment version.");
        this.networkStateIsPending = !1, this.serverState = "ok";
      } catch (o) {
        this.networkStateIsPending = !1, this.serverState = "unreachable", console.warn("Could not check version: " + o.toString());
        return;
      }
      const a = await r.text();
      if (a.startsWith("v") && (!s || !a || s !== a))
        try {
          const o = s.split(".").slice(0, 2), l = a.split(".").slice(0, 2);
          if (o[0] !== l[0])
            throw new Error();
          o[1] !== l[1] && console.error(
            `Version inconsistency: ${ze.sourceName}@${this.version} ≠ ${this.url?.hostname}@${a} - This may cause unexpected errors!`
          );
        } catch {
          throw new Error(
            `Version mismatch! ${ze.sourceName}@${this.version} ≠ ${this.url?.hostname}@${a} - This will likely cause errors!`
          );
        }
    }
  }, c(e, "t"), e), d(t, "WeavyVersion"), t;
}, "WeavyVersionMixin");
var a$, mp;
let Bz = (a$ = (mp = class extends Event {
  constructor(t, e, i, s) {
    super("context-request", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e, this.callback = i, this.subscribe = s ?? !1;
  }
}, c(mp, "Nn"), mp), d(a$, "s"), a$);
var o$, gp;
let un = (o$ = (gp = class {
  constructor(t, e, i, s) {
    if (this.subscribe = !1, this.provided = !1, this.value = void 0, this.t = (r, a) => {
      this.unsubscribe && (this.unsubscribe !== a && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = r, this.host.requestUpdate(), this.provided && !this.subscribe || (this.provided = !0, this.callback && this.callback(r, a)), this.unsubscribe = a;
    }, this.host = t, e.context !== void 0) {
      const r = e;
      this.context = r.context, this.callback = r.callback, this.subscribe = r.subscribe ?? !1;
    } else this.context = e, this.callback = i, this.subscribe = s ?? !1;
    this.host.addController(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.host.dispatchEvent(new Bz(this.context, this.host, this.t, this.subscribe));
  }
}, c(gp, "jn"), gp), d(o$, "s"), o$);
var l$, wp;
let bB = (l$ = (wp = class {
  get value() {
    return this.o;
  }
  set value(t) {
    this.setValue(t);
  }
  setValue(t, e = !1) {
    const i = e || !Object.is(t, this.o);
    this.o = t, i && this.updateObservers();
  }
  constructor(t) {
    this.subscriptions = /* @__PURE__ */ new Map(), this.updateObservers = () => {
      for (const [e, { disposer: i }] of this.subscriptions) e(this.o, i);
    }, t !== void 0 && (this.value = t);
  }
  addCallback(t, e, i) {
    if (!i) return void t(this.value);
    this.subscriptions.has(t) || this.subscriptions.set(t, { disposer: /* @__PURE__ */ d(() => {
      this.subscriptions.delete(t);
    }, "disposer"), consumerHost: e });
    const { disposer: s } = this.subscriptions.get(t);
    t(this.value, s);
  }
  clearCallbacks() {
    this.subscriptions.clear();
  }
}, c(wp, "Wn"), wp), d(l$, "s"), l$);
var c$, vp;
let $B = (c$ = (vp = class extends Event {
  constructor(t, e) {
    super("context-provider", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e;
  }
}, c(vp, "Qn"), vp), d(c$, "e"), c$);
var h$, Op;
let aS = (h$ = (Op = class extends bB {
  constructor(t, e, i) {
    super(e.context !== void 0 ? e.initialValue : i), this.onContextRequest = (s) => {
      if (s.context !== this.context) return;
      const r = s.contextTarget ?? s.composedPath()[0];
      r !== this.host && (s.stopPropagation(), this.addCallback(s.callback, r, s.subscribe));
    }, this.onProviderRequest = (s) => {
      if (s.context !== this.context || (s.contextTarget ?? s.composedPath()[0]) === this.host) return;
      const r = /* @__PURE__ */ new Set();
      for (const [a, { consumerHost: o }] of this.subscriptions) r.has(a) || (r.add(a), o.dispatchEvent(new Bz(this.context, o, a, !0)));
      s.stopPropagation();
    }, this.host = t, e.context !== void 0 ? this.context = e.context : this.context = e, this.attachListeners(), this.host.addController?.(this);
  }
  attachListeners() {
    this.host.addEventListener("context-request", this.onContextRequest), this.host.addEventListener("context-provider", this.onProviderRequest);
  }
  hostConnected() {
    this.host.dispatchEvent(new $B(this.context, this.host));
  }
}, c(Op, "Kn"), Op), d(h$, "i"), h$);
function or({ context: n }) {
  return (t, e) => {
    const i = /* @__PURE__ */ new WeakMap();
    if (typeof e == "object") return { get() {
      return t.get.call(this);
    }, set(s) {
      return i.get(this).setValue(s), t.set.call(this, s);
    }, init(s) {
      return i.set(this, new aS(this, { context: n, initialValue: s })), s;
    } };
    {
      t.constructor.addInitializer(((a) => {
        i.set(a, new aS(a, { context: n }));
      }));
      const s = Object.getOwnPropertyDescriptor(t, e);
      let r;
      if (s === void 0) {
        const a = /* @__PURE__ */ new WeakMap();
        r = { get() {
          return a.get(this);
        }, set(o) {
          i.get(this).setValue(o), a.set(this, o);
        }, configurable: !0, enumerable: !0 };
      } else {
        const a = s.set;
        r = { ...s, set(o) {
          i.get(this).setValue(o), a?.call(this, o);
        } };
      }
      return void Object.defineProperty(t, e, r);
    }
  };
}
c(or, "Vr");
d(or, "e$4");
function Ve({ context: n, subscribe: t }) {
  return (e, i) => {
    typeof i == "object" ? i.addInitializer((function() {
      new un(this, { context: n, callback: /* @__PURE__ */ d((s) => {
        e.set.call(this, s);
      }, "callback"), subscribe: t });
    })) : e.constructor.addInitializer(((s) => {
      new un(s, { context: n, callback: /* @__PURE__ */ d((r) => {
        s[i] = r;
      }, "callback"), subscribe: t });
    }));
  };
}
c(Ve, "he");
d(Ve, "c$2");
var bp;
const Uz = (bp = class extends Event {
  /**
   *
   * @param context the context key to request
   * @param contextTarget the original context target of the requester
   * @param callback the callback that should be invoked when the context with the specified key is available
   * @param subscribe when, true indicates we want to subscribe to future updates
   */
  constructor(t, e, i, s) {
    super("context-request", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e, this.callback = i, this.subscribe = s ?? !1;
  }
}, c(bp, "Fy"), bp);
d(Uz, "ContextRequestEvent");
let xB = Uz;
var $p;
const Hz = ($p = class extends Event {
  /**
   *
   * @param context the context which this provider can provide
   * @param contextTarget the original context target of the provider
   */
  constructor(t, e) {
    super("context-provider", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e;
  }
}, c($p, "Dy"), $p);
d(Hz, "ContextProviderEvent");
let kB = Hz;
var xp;
const Yz = (xp = class extends aS {
  constructor(t, e, i) {
    e.context !== void 0 ? super(t, e) : super(t, e, i), e.context !== void 0 ? this._context = e.context : this._context = e, this.isAttached = !0, this.host instanceof pt || this.dispatchWhenConnected();
  }
  dispatchWhenConnected() {
    this.isAttached && (this.host.isConnected ? this.host.dispatchEvent(new kB(this._context, this.host)) : requestAnimationFrame(() => this.dispatchWhenConnected()));
  }
  detachListeners() {
    this.isAttached = !1, this.host.removeEventListener("context-request", this.onContextRequest), this.host.removeEventListener("context-provider", this.onProviderRequest);
  }
}, c(xp, "Hy"), xp);
d(Yz, "WyContextProvider");
let Gz = Yz;
const Me = Symbol.for("weavy-client");
function Kz(n, t) {
  return we(), new Gz(n, { context: Me, initialValue: t });
}
c(Kz, "Vg");
d(Kz, "createWeavyContextProvider");
const Dc = Qb() ? Kz(document.documentElement) : void 0, SB = /* @__PURE__ */ d((n) => {
  var i;
  var t, e;
  return e = (i = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), Z(this, t), this.host !== document.documentElement ? (Dc?.detachListeners(), _(this, t, new Gz(this.host, {
        context: Me,
        initialValue: this
      }))) : Dc?.setValue(this);
    }
    updateContext() {
      this.host !== document.documentElement ? $(this, t)?.updateObservers() : Dc?.updateObservers();
    }
    destroy() {
      super.destroy(), this.host !== document.documentElement ? $(this, t)?.detachListeners() : Dc?.value === this && Dc?.setValue(void 0);
    }
  }, c(i, "e"), i), t = /* @__PURE__ */ new WeakMap(), d(e, "WeavyContextProvider"), e;
}, "WeavyContextProviderMixin");
var Lv, Iv, wr, Tg, Ne;
const Mg = (Ne = class {
  // CONSTRUCTOR
  constructor(t) {
    Z(this, Lv), Z(this, Iv), Z(this, wr), Z(this, Tg), this.weavySid = sm(), this.weavyId = `${Ne.sourceName}#${this.weavySid}`, this.cloudFilePickerUrl = Ne.defaults.cloudFilePickerUrl, this.configurationTimeout = Ne.defaults.configurationTimeout, this.disableEnvironmentImports = Ne.defaults.disableEnvironmentImports, this.gcTime = Ne.defaults.gcTime, this.scrollBehavior = Ne.defaults.scrollBehavior, this.staleTime = Ne.defaults.staleTime, this.tokenFactoryRetryDelay = Ne.defaults.tokenFactoryRetryDelay, this.tokenFactoryTimeout = Ne.defaults.tokenFactoryTimeout, _(this, Iv, new Promise((i) => {
      _(this, Lv, i);
    })), _(this, Tg, !1), console.info(`${Ne.sourceName}@${Ne.version} #${this.weavySid}`), we(), this.host = document.documentElement;
    const e = {};
    for (const i in t) {
      const s = i;
      t[s] !== void 0 && Object.assign(e, { [s]: t[s] });
    }
    e?.host && (this.host = e.host, delete e.host), e && Object.assign(this, e);
  }
  async whenUrl() {
    await $(this, Iv);
  }
  /**
   * The URL to the weavy environment.
   */
  get url() {
    return $(this, wr);
  }
  set url(t) {
    var e;
    if (this.isDestroyed)
      throw new Ce();
    try {
      if (typeof t == "string")
        t && _(this, wr, new URL(t, window.location.toString()));
      else if (t instanceof URL)
        _(this, wr, t || void 0);
      else if (t == null)
        _(this, wr, void 0);
      else
        throw new Error();
    } catch {
      throw new TypeError("Invalid url");
    }
    t && !this.disableEnvironmentImports && globalThis.WEAVY_IMPORT_URL === void 0 && (globalThis.WEAVY_IMPORT_URL = new URL(
      "./uikit-web/",
      t
    ).href), $(this, wr) && ((e = $(this, Lv)) == null || e.call(this, $(this, wr)));
  }
  /**
   * Prefix to use for caches.
   */
  get cachePrefix() {
    return `${Ne.version}:${this.url}`;
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async reset() {
    console.info(this.weavyId, "is reset");
  }
  get isDestroyed() {
    return $(this, Tg);
  }
  destroy() {
    _(this, Tg, !0), console.info(this.weavyId, "was destroyed");
  }
}, c(Ne, "oe"), Ne);
Lv = /* @__PURE__ */ new WeakMap(), Iv = /* @__PURE__ */ new WeakMap(), wr = /* @__PURE__ */ new WeakMap(), Tg = /* @__PURE__ */ new WeakMap(), d(Mg, "WeavyClient"), Mg.version = "30.1.1", Mg.sourceName = "@weavy/uikit-web", Mg.defaults = {
  // StrictWeavyOptions
  cloudFilePickerUrl: "https://filebrowser.weavy.io/v14/",
  configurationTimeout: 5e3,
  disableEnvironmentImports: !1,
  gcTime: 1e3 * 60 * 60 * 24,
  // 24h,
  locale: F_,
  scrollBehavior: "auto",
  staleTime: 1e3 * 1,
  // 1s
  tokenFactoryRetryDelay: 2e3,
  tokenFactoryTimeout: 2e4,
  // WeavyComponentSettingProps
  annotations: "buttons-inline",
  enterToSend: "auto",
  reactions: "😍 😎 😉 😜 👍"
};
let ze = Mg;
var kp;
const Jz = (kp = class extends SB(
  Uj(
    jj(
      Hj(
        Nj(
          cB(OB(Bj(vB(hB(ze)))))
        )
      )
    )
  )
) {
}, c(kp, "Vy"), kp);
d(Jz, "Weavy");
let Se = Jz;
const FP = Symbol.for("weavy-app"), tL = Symbol.for("weavy-context-id"), eL = Symbol.for("weavy-data-blobs");
var z = /* @__PURE__ */ ((n) => (n.Attachments = "attachments", n.CloudFiles = "cloud_files", n.ContextData = "context_data", n.Comments = "comments", n.Embeds = "embeds", n.GoogleMeet = "google_meet", n.Meetings = "meetings", n.Mentions = "mentions", n.MicrosoftTeams = "microsoft_teams", n.Polls = "polls", n.Previews = "previews", n.Reactions = "reactions", n.Receipts = "receipts", n.Thumbnails = "thumbnails", n.Typing = "typing", n.Versions = "versions", n.WebDAV = "web_dav", n.ZoomMeetings = "zoom_meetings", n))(z || {});
const d0 = Symbol.for("weavy-features");
var ja, qc, Qs, Yo;
const iL = (Yo = class {
  /**
   * Creates a feature policy. All features are initially enabled unless `defaultFeatures` is specified.
   *
   * @constructor
   * @param componentFeatures - Available features.
   */
  constructor(t, e) {
    Z(this, ja), Z(this, qc), Z(this, Qs), _(this, ja, Object.keys(t)), _(this, qc, Object.entries(t).reduce(
      (i, [s, r]) => (r && i.push(s), i),
      []
    )), _(this, Qs, e ?? $(this, qc));
  }
  features() {
    return $(this, ja);
  }
  supportedFeature(...t) {
    return t.every((e) => $(this, ja).includes(e));
  }
  allowedFeatures() {
    return $(this, Qs);
  }
  allowsFeature(...t) {
    return t.every((e) => this.supportedFeature(e) ? $(this, Qs).includes(e) : !1);
  }
  allowsAnyFeature(...t) {
    return t.some((e) => this.supportedFeature(e) ? $(this, Qs).includes(e) : !1);
  }
  /**
   * Sets the allowed features.
   * @param allowedFeatures - Space separated string with features that will be enabled. Empty string will disable all features. `null` or `undefined` will enable all features.
   */
  setAllowedFeatures(t) {
    return _(this, Qs, typeof t == "string" ? XP(t, $(this, ja)) : $(this, qc)), $(this, Qs);
  }
  immutable() {
    const t = u0($(this, ja), $(this, qc));
    return new Yo(t, $(this, Qs));
  }
}, c(Yo, "lh"), Yo);
ja = /* @__PURE__ */ new WeakMap(), qc = /* @__PURE__ */ new WeakMap(), Qs = /* @__PURE__ */ new WeakMap(), d(iL, "ComponentFeatures");
let ni = iL;
function XP(n, t) {
  return n.split(" ").filter((e) => {
    if (e) {
      if (t.includes(e))
        return !0;
      console.warn("Unknown feature provided:", e);
    }
    return !1;
  });
}
c(XP, "lm");
d(XP, "featureListFromString");
function u0(n, t) {
  return t ??= n, Object.fromEntries(
    n.map((e) => [e, t.includes(e)])
  );
}
c(u0, "Ku");
d(u0, "featureConfigFromList");
const oS = Object.values(z), nL = Symbol.for("weavy-link");
var Wv, Sp;
const sL = (Sp = class {
  // PROPERTY INIT
  constructor(t) {
    Z(this, Wv), this.enterToSend = ze.defaults.enterToSend, this.reactions = ze.defaults.reactions, this.annotations = ze.defaults.annotations, _(this, Wv, t), Object.keys(this).forEach((e) => {
      e in t && Object.assign(this, { [e]: t[e] });
    });
  }
  /**
   * Provides a reference to the host.
   */
  get component() {
    return $(this, Wv);
  }
}, c(Sp, "Uy"), Sp);
Wv = /* @__PURE__ */ new WeakMap(), d(sL, "WeavyComponentSettings");
let a9 = sL;
const rL = Symbol.for("weavy-component-settings"), p0 = Symbol.for("weavy-user");
var Cp;
const aL = (Cp = class {
  constructor(t, e, i, s, r) {
    if (this.subscribe = !1, this.provided = !1, this.value = void 0, this._callback = (a, o) => {
      this.unsubscribe && (this.unsubscribe !== o && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = a, this.host.requestUpdate(), (!this.provided || this.subscribe) && (this.provided = !0, this.callback && this.callback(a, o)), this.unsubscribe = o;
    }, this.host = t, e.context !== void 0) {
      const a = e;
      this.context = a.context, this.callback = a.callback, this.subscribe = a.subscribe ?? !1, this.ref = a.ref ?? t;
    } else
      this.context = e, this.callback = i, this.subscribe = s ?? !1, this.ref = r ?? t;
    this.host.addController?.(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.ref.dispatchEvent(
      new xB(
        this.context,
        this.host,
        this._callback,
        this.subscribe
      )
    );
  }
}, c(Cp, "By"), Cp);
d(aL, "ContextConsumer");
let CB = aL;
var Pp;
const oL = (Pp = class {
  /**
   * @param host - The host element
   * @param context - The Context to use. Should be constructed using createContext().
   */
  constructor(t, e, i) {
    this.whenRef = new Promise((s) => this.resolveRef = s), t.addController(this), this.host = t, this.setRef(i), this.setContext(e);
  }
  /**
   * The DOM connected element that can subscribe to a context
   */
  get ref() {
    return this._ref;
  }
  set ref(t) {
    this._ref = t, t && this.resolveRef?.(t);
  }
  /** 
   * Set the DOM connected element that can subscribe to a context.
   * Wrapper function for React linting compatibility. 
   */
  setRef(t) {
    this.ref = t;
  }
  async setContext(t) {
    this.whenContext = new Promise((i) => this.resolveContext = i);
    const e = await this.whenRef;
    this.context = new CB(this.host, {
      context: t,
      subscribe: !0,
      callback: /* @__PURE__ */ d((i, s) => {
        this.resolveContext?.(i), this.host.requestUpdate();
      }, "callback"),
      ref: e
    }), await QS(e), this.context.dispatchRequest();
  }
  hostUpdate() {
    this.context?.value && this.resolveContext?.(this.context.value);
  }
}, c(Pp, "qy"), Pp);
d(oL, "ContextController");
let PB = oL;
var gt = /* @__PURE__ */ ((n) => (n.Chat = "d65dd4bc-418e-403c-9f56-f9cf4da931ed", n.Comments = "88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd", n.Files = "523edd88-4bbf-4547-b60f-2859a6d2ddc1", n.Posts = "5ebfa152-de85-48da-82dd-30a1b560c313", n.ChatRoom = "edb400ac-839b-45a7-b2a8-6a01820d1c44", n.PrivateChat = "7e14f418-8f15-46f4-b182-f619b671e470", n.AgentChat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", n))(gt || {}), Sn = /* @__PURE__ */ ((n) => (n.Chat = "chat", n.Comments = "comments", n.Files = "files", n.Posts = "posts", n.ChatRoom = "chat_room", n.PrivateChat = "private_chat", n.AgentChat = "agent_chat", n))(Sn || {}), lL = /* @__PURE__ */ ((n) => (n["d65dd4bc-418e-403c-9f56-f9cf4da931ed"] = "chat", n["88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd"] = "comments", n["523edd88-4bbf-4547-b60f-2859a6d2ddc1"] = "files", n["5ebfa152-de85-48da-82dd-30a1b560c313"] = "posts", n["edb400ac-839b-45a7-b2a8-6a01820d1c44"] = "chat_room", n["7e14f418-8f15-46f4-b182-f619b671e470"] = "private_chat", n["2352a1c6-abc6-420e-8b85-ca7d5aed8779"] = "agent_chat", n))(lL || {}), cL = /* @__PURE__ */ ((n) => (n.chat = "d65dd4bc-418e-403c-9f56-f9cf4da931ed", n.comments = "88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd", n.files = "523edd88-4bbf-4547-b60f-2859a6d2ddc1", n.posts = "5ebfa152-de85-48da-82dd-30a1b560c313", n.chat_room = "edb400ac-839b-45a7-b2a8-6a01820d1c44", n.private_chat = "7e14f418-8f15-46f4-b182-f619b671e470", n.agent_chat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", n))(cL || {}), hL = /* @__PURE__ */ ((n) => (n["2352a1c6-abc6-420e-8b85-ca7d5aed8779"] = "agent_chat", n))(hL || {}), dL = /* @__PURE__ */ ((n) => (n.agent_chat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", n))(dL || {}), kr = /* @__PURE__ */ ((n) => (n.None = "none", n.Read = "read", n.Write = "write", n.Admin = "admin", n))(kr || {}), rl = /* @__PURE__ */ ((n) => (n.List = "list", n.Read = "read", n.Create = "create", n.Update = "update", n.Delete = "delete", n.Admin = "admin", n))(rl || {}), ci = /* @__PURE__ */ ((n) => (n.App = "app", n.File = "file", n.Message = "message", n.User = "user", n.Comment = "comment", n.Post = "post", n))(ci || {});
function Qm(n, t, e, i, s, r = "GET") {
  return {
    // eslint-disable-next-line @tanstack/query/exhaustive-deps
    queryKey: t,
    queryFn: /* @__PURE__ */ d(async () => {
      const a = await n.fetch(e || "/api/" + t.join("/"), { method: r, body: s });
      if (a.ok)
        return await a.json();
      throw new Error(`Error calling ${e || "/api/" + t.join("/")}`);
    }, "queryFn"),
    ...i
  };
}
c(Qm, "sd");
d(Qm, "getApiOptions");
const uL = /* @__PURE__ */ d((n) => (t, e) => {
  e !== void 0 ? e.addInitializer((() => {
    customElements.define(n, t);
  })) : customElements.define(n, t);
}, "t$3"), QB = { attribute: !0, type: String, converter: XO, reflect: !1, hasChanged: mP }, TB = /* @__PURE__ */ d((n = QB, t, e) => {
  const { kind: i, metadata: s } = e;
  let r = globalThis.litPropertyMetadata.get(s);
  if (r === void 0 && globalThis.litPropertyMetadata.set(s, r = /* @__PURE__ */ new Map()), i === "setter" && ((n = Object.create(n)).wrapped = !0), r.set(e.name, n), i === "accessor") {
    const { name: a } = e;
    return { set(o) {
      const l = t.get.call(this);
      t.set.call(this, o), this.requestUpdate(a, l, n);
    }, init(o) {
      return o !== void 0 && this.C(a, void 0, n, o), o;
    } };
  }
  if (i === "setter") {
    const { name: a } = e;
    return function(o) {
      const l = this[a];
      t.call(this, o), this.requestUpdate(a, l, n);
    };
  }
  throw Error("Unsupported decorator location: " + i);
}, "r$3");
function O(n) {
  return (t, e) => typeof e == "object" ? TB(n, t, e) : ((i, s, r) => {
    const a = s.hasOwnProperty(r);
    return s.constructor.createProperty(r, i), a ? Object.getOwnPropertyDescriptor(s, r) : void 0;
  })(n, t, e);
}
c(O, "p");
d(O, "n$3");
function F(n) {
  return O({ ...n, state: !0, attribute: !1 });
}
c(F, "F");
d(F, "r$2");
const MB = /* @__PURE__ */ d((n, t, e) => (e.configurable = !0, e.enumerable = !0, Reflect.decorate && typeof t != "object" && Object.defineProperty(n, t, e), e), "e$3");
function Ml(n) {
  return (t, e) => {
    const { slot: i, selector: s } = n ?? {}, r = "slot" + (i ? `[name=${i}]` : ":not([name])");
    return MB(t, e, { get() {
      const a = this.renderRoot?.querySelector(r), o = a?.assignedElements(n) ?? [];
      return s === void 0 ? o : o.filter(((l) => l.matches(s)));
    } });
  };
}
c(Ml, "Hc");
d(Ml, "o$6");
var Qp;
const pL = (Qp = class {
  get result() {
    return this._result && this.observer ? this.observer.trackResult(this._result) : { isPending: !0 };
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenQueryClient = new Promise((e) => this.resolveQueryClient = e), this.setContext();
  }
  async setContext() {
    await gs(this.host), this.context = new un(this.host, {
      context: Me,
      subscribe: !0,
      callback: /* @__PURE__ */ d((t) => {
        t && (this.resolveContext?.(t), this.queryClient = t.queryClient, this.resolveQueryClient?.(t.queryClient));
      }, "callback")
    });
  }
  async trackQuery(t, e = !0) {
    this.observerUnsubscribe?.();
    const i = await this.whenQueryClient;
    if (!i)
      throw new Error("No QueryClient provided");
    const s = new oz(i, t);
    this.observer = s, this.observerSubscribe(e);
  }
  observerSubscribe(t = !0) {
    if (this.queryClient && this.observer) {
      t ? this._result = this.observer.getOptimisticResult(this.observer.options) : this._result = this.observer.getCurrentResult(), this.observerUnsubscribe = this.observer.subscribe(() => {
        if (this.observer) {
          const i = Pm(this.result, this.observer.getCurrentResult());
          i !== this._result && (this._result = i, this.host.requestUpdate());
        }
      }), this.observer.updateResult(), this.host.requestUpdate();
      let e;
      t ? e = this.observer.fetchOptimistic(this.observer.options) : e = this.queryClient.getQueryCache().get(this.observer.options.queryHash)?.promise, e?.catch(() => {
      }).finally(() => {
        this.observer?.updateResult();
      });
    }
  }
  untrackQuery() {
    this.observerUnsubscribe?.(), this.observerUnsubscribe = void 0, this._result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    this.observerUnsubscribe?.();
  }
}, c(Qp, "Ny"), Qp);
d(pL, "QueryController");
let gn = pL;
function ab(n) {
  return n.signal instanceof AbortSignal || typeof n.abort == "function";
}
c(ab, "fu");
d(ab, "hasAbort");
var Tp;
const fL = (Tp = class {
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenObserver = new Promise((e) => this.resolveObserver = e), this.setContext();
  }
  async setContext() {
    await gs(this.host), this.context = new un(this.host, { context: Me, subscribe: !0 });
  }
  hostUpdate() {
    this.context?.value && this.resolveContext?.();
  }
  async trackMutation(t, e) {
    if (e || (await this.whenContext, e = this.context?.value?.queryClient), !e)
      throw new Error("No QueryClient provided");
    return this.observerUnsubscribe?.(), this.observer && (this.whenObserver = new Promise((i) => this.resolveObserver = i)), this.observer = new Xt(e, { ...t }), this.observerSubscribe(), this.resolveObserver?.(this.observer), this.observer;
  }
  observerSubscribe() {
    this.observer && (this.result = this.observer.getCurrentResult(), this.observerUnsubscribe ??= this.observer.subscribe(() => {
      if (this.observer) {
        const t = Pm(this.result, this.observer.getCurrentResult());
        this.result !== t && (this.result = t, this.host.requestUpdate());
      }
    }), this.host.requestUpdate());
  }
  untrackMutation() {
    this.observerUnsubscribe?.(), this.observerUnsubscribe = void 0, this.result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  async mutate(t, e) {
    const i = await this.whenObserver, s = new AbortController();
    return i.mutate(
      {
        ...t,
        signal: s.signal,
        abort: s.abort.bind(s)
      },
      e
    );
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    this.observerUnsubscribe?.();
  }
}, c(Tp, "jy"), Tp);
d(fL, "MutationController");
let An = fL;
function NP(n) {
  if (n)
    return n.match(/^[0-9]+$/) ? parseInt(n) : n;
}
c(NP, "mm");
d(NP, "toIntOrString");
const Ke = [];
for (let n = 0; n < 256; ++n)
  Ke.push((n + 256).toString(16).slice(1));
function yL(n, t = 0) {
  return (Ke[n[t + 0]] + Ke[n[t + 1]] + Ke[n[t + 2]] + Ke[n[t + 3]] + "-" + Ke[n[t + 4]] + Ke[n[t + 5]] + "-" + Ke[n[t + 6]] + Ke[n[t + 7]] + "-" + Ke[n[t + 8]] + Ke[n[t + 9]] + "-" + Ke[n[t + 10]] + Ke[n[t + 11]] + Ke[n[t + 12]] + Ke[n[t + 13]] + Ke[n[t + 14]] + Ke[n[t + 15]]).toLowerCase();
}
c(yL, "jg");
d(yL, "unsafeStringify");
let d$;
const AB = new Uint8Array(16);
function mL() {
  if (!d$) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    d$ = crypto.getRandomValues.bind(crypto);
  }
  return d$(AB);
}
c(mL, "Qg");
d(mL, "rng");
const RB = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), o9 = { randomUUID: RB };
function gL(n, t, e) {
  n = n || {};
  const i = n.random ?? n.rng?.() ?? mL();
  if (i.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, yL(i);
}
c(gL, "Gg");
d(gL, "_v4");
function Oh(n, t, e) {
  return o9.randomUUID && !n ? o9.randomUUID() : gL(n);
}
c(Oh, "sl");
d(Oh, "v4");
function wL(n) {
  let t;
  if (n instanceof URL)
    t = { type: "url", item: n };
  else if (n instanceof File)
    t = { type: "file", item: n };
  else if (n instanceof Blob)
    t = {
      type: "file",
      item: new File([n], `${Oh()}`, { type: n.type })
    };
  else if (typeof n == "string")
    t = {
      type: "file",
      item: new File([n], `${Oh()}.data.txt`, { type: "text/plain;charset=UTF-8" })
    };
  else if (E_(n) || BO(n))
    try {
      const e = BO(n) ? n.toJSON() : JSON.stringify(n, W_(), 2);
      t = {
        type: "file",
        item: new File([e], `${Oh()}.json.txt`, { type: "text/plain;charset=UTF-8" })
      };
    } catch (e) {
      console.error("Could not serialize context data to JSON.", e);
    }
  return t;
}
c(wL, "Zg");
d(wL, "getContextDataRef");
const f0 = /* @__PURE__ */ d((n, t = 3) => {
  const e = [" B", " KB", " MB", " GB", " TB", " PB", " EB", " ZB", " YB"];
  let i = n, s = 0;
  for (; s < e.length - 1 && i >= 1024; )
    i = 100 * i / 1024 / 100, s++;
  return i.toLocaleString(void 0, { maximumSignificantDigits: t }) + e[s];
}, "fileSizeAsString");
function tn(n) {
  return n.lastIndexOf(".") === -1 ? "." : (n.substring(n.lastIndexOf("."), n.length) || n).toLowerCase();
}
c(tn, "ii");
d(tn, "getExtension");
function jP(n) {
  switch (n) {
    case ".aac":
    case ".aif":
    case ".aiff":
    case ".au":
    case ".gsm":
    case ".m4a":
    case ".mid":
    case ".midi":
    case ".mka":
    case ".mp3":
    case ".oga":
    case ".ogg":
    case ".ra":
    case ".ram":
    case ".snd":
    case ".spx":
    case ".wav":
    case ".wma":
      return !0;
    default:
      return !1;
  }
}
c(jP, "vm");
d(jP, "isAudio");
function vL(n) {
  switch (n) {
    case ".ai":
    case ".apng":
    case ".bmp":
    case ".emf":
    case ".eps":
    case ".gif":
    case ".heic":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".psd":
    case ".svg":
    case ".tif":
    case ".tiff":
    case ".webp":
    case ".wmf":
      return !0;
    default:
      return !1;
  }
}
c(vL, "Yg");
d(vL, "isImage");
function OL(n) {
  switch (tn(n)) {
    case ".apng":
    case ".bmp":
    case ".gif":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".svg":
    case ".webp":
      return !0;
    default:
      return !1;
  }
}
c(OL, "Xg");
d(OL, "isWebImage");
function BP(n) {
  switch (n) {
    case ".3g2":
    case ".asx":
    case ".asf":
    case ".avi":
    case ".flv":
    case ".mk3d":
    case ".mkv":
    case ".mov":
    case ".mp4":
    case ".mpeg":
    case ".mpg":
    case ".ogm":
    case ".ogv":
    case ".ogx":
    case ".qt":
    case ".rm":
    case ".rv":
    case ".smi":
    case ".smil":
    case ".swf":
    case ".webm":
    case ".wmv":
    case ".xaml":
      return !0;
    default:
      return !1;
  }
}
c(BP, "gm");
d(BP, "isVideo");
function bL(n) {
  switch (n) {
    case ".markdown":
    case ".md":
      return !0;
    default:
      return !1;
  }
}
c(bL, "Jg");
d(bL, "isMarkdown");
function UP(n) {
  switch (n) {
    case ".htm":
    case ".html":
    case ".xhtml":
    case ".xml":
      return !0;
    default:
      return !1;
  }
}
c(UP, "bm");
d(UP, "isMarkup");
function y0(n) {
  if (UP(n))
    return !0;
  switch (n) {
    case ".as":
    case ".as3":
    case ".asm":
    case ".aspx":
    case ".bat":
    case ".c":
    case ".cc":
    case ".cmake":
    case ".coffee":
    case ".cpp":
    case ".cs":
    case ".css":
    case ".cxx":
    case ".diff":
    case ".erb":
    case ".erl":
    case ".groovy":
    case ".gvy":
    case ".h":
    case ".haml":
    case ".hh":
    case ".hpp":
    case ".hxx":
    case ".java":
    case ".js":
    case ".json":
    case ".jsx":
    case ".less":
    case ".lst":
    case ".m":
    case ".make":
    case ".ml":
    case ".mm":
    case ".out":
    case ".patch":
    case ".php":
    case ".pl":
    case ".plist":
    case ".properties":
    case ".py":
    case ".rb":
    case ".sass":
    case ".scala":
    case ".scm":
    case ".script":
    case ".scss":
    case ".sh":
    case ".sml":
    case ".sql":
    case ".vb":
    case ".vi":
    case ".vim":
    case ".xsd":
    case ".xsl":
    case ".yaml":
    case ".yml":
      return !0;
    default:
      return !1;
  }
}
c(y0, "Gu");
d(y0, "isCode");
function HP(n) {
  if (y0(n) || bL(n))
    return !0;
  switch (n) {
    case ".txt":
      return !0;
    default:
      return !1;
  }
}
c(HP, "xm");
d(HP, "isText");
function lr(n) {
  const t = tn(n);
  if (t === "") return { icon: "file" };
  if (jP(t))
    return { icon: "file-music", color: "indigo" };
  if (vL(t))
    return { icon: "file-image", color: "cyan" };
  if (BP(t))
    return { icon: "file-video", color: "pink" };
  if (UP(t))
    return { icon: "file-xml", color: "purple" };
  if (y0(t))
    return { icon: "file-code", color: "purple" };
  if (HP(t))
    return { icon: "file-document" };
  switch (t) {
    case ".7z":
    case ".zip":
      return { icon: "file-compressed", color: "orange" };
    case ".doc":
    case ".docm":
    case ".docx":
    case ".dotm":
    case ".dotx":
      return { icon: "file-word", color: "native" };
    case ".eml":
    case ".msg":
      return { icon: "email", color: "" };
    case ".xls":
    case ".xlsm":
    case ".xlsx":
    case ".xltx":
      return { icon: "file-excel", color: "native" };
    case ".pdf":
      return { icon: "file-pdf", color: "native" };
    case ".ppt":
    case ".pptm":
    case ".pptx":
    case ".potx":
      return { icon: "file-powerpoint", color: "native" };
    case ".pages":
      return { icon: "file", color: "orange" };
    case ".numbers":
      return { icon: "file", color: "green" };
    case ".keynote":
      return { icon: "file", color: "blue" };
  }
  return { icon: "file" };
}
c(lr, "Ur");
d(lr, "getIcon");
function $L(n) {
  const t = tn(n);
  return t === "" ? "none" : OL(t) ? "image" : y0(t) ? "code" : HP(t) ? "text" : jP(t) ? "audio" : BP(t) ? "video" : "none";
}
c($L, "t0");
d($L, "getWebPreviewFormat");
function Tm(n) {
  switch (n) {
    case "Google Drive":
      return "google-drive";
    case "Dropbox":
      return "dropbox";
    case "OneDrive":
      return "onedrive";
    case "Box":
      return "box";
    default:
      return "";
  }
}
c(Tm, "nd");
d(Tm, "getProvider");
function m0(n) {
  let t = "file";
  switch (tn(n)) {
    case ".7z":
    case ".zip":
      t = "archive";
      break;
    case ".aac":
    case ".aif":
    case ".aiff":
    case ".au":
    case ".gsm":
    case ".m4a":
    case ".mid":
    case ".midi":
    case ".mka":
    case ".mp3":
    case ".oga":
    case ".ogg":
    case ".ra":
    case ".ram":
    case ".snd":
    case ".spx":
    case ".wav":
    case ".wma":
      t = "audio";
      break;
    case ".c":
    case ".cgi":
    case ".cpp":
    case ".cs":
    case ".cshtml":
    case ".css":
    case ".html":
    case ".java":
    case ".js":
    case ".json":
    case ".less":
    case ".php":
    case ".pl":
    case ".ps1":
    case ".py":
    case ".rb":
    case ".rs":
    case ".scss":
    case ".sh":
    case ".swift":
    case ".sql":
    case ".ts":
    case ".xml":
    case ".yaml":
    case ".yml":
      t = "code";
      break;
    case ".doc":
    case ".docm":
    case ".docx":
    case ".dotm":
    case ".dotx":
    case ".gdoc":
    case ".pages":
    case ".pdf":
      t = "document";
      break;
    case ".eml":
    case ".msg":
      t = "email";
      break;
    case ".gslides":
    case ".keynote":
    case ".ppt":
    case ".pptm":
    case ".pptx":
    case ".potx":
      t = "presentation";
      break;
    case ".gsheet":
    case ".numbers":
    case ".xls":
    case ".xlsm":
    case ".xlsx":
    case ".xltx":
      t = "spreadsheet";
      break;
    case ".ai":
    case ".apng":
    case ".bmp":
    case ".emf":
    case ".eps":
    case ".gif":
    case ".heic":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".psd":
    case ".svg":
    case ".tif":
    case ".tiff":
    case ".webp":
    case ".wmf":
      t = "image";
      break;
    case ".md":
    case ".markdown":
    case ".txt":
      t = "text";
      break;
    case ".3g2":
    case ".asx":
    case ".asf":
    case ".avi":
    case ".flv":
    case ".mk3d":
    case ".mkv":
    case ".mov":
    case ".mp4":
    case ".mpeg":
    case ".mpg":
    case ".ogm":
    case ".ogv":
    case ".ogx":
    case ".qt":
    case ".rm":
    case ".rv":
    case ".smi":
    case ".smil":
    case ".swf":
    case ".webm":
    case ".wmv":
    case ".xaml":
      t = "video";
      break;
  }
  return t;
}
c(m0, "Zu");
d(m0, "getKind");
function g0(n) {
  const t = n.target, e = t?.value.lastIndexOf(".");
  e === -1 ? t?.select() : e !== void 0 && t?.setSelectionRange(0, e);
}
c(g0, "Yu");
d(g0, "handleSelectFilename");
async function ob(n, t = "SHA-256") {
  return await new Promise((e) => {
    if (n) {
      const i = new FileReader();
      i.readAsArrayBuffer(n), i.onloadend = async () => {
        const s = await crypto.subtle.digest(t, i.result);
        let r = "";
        s && (r = Array.from(new Uint8Array(s)).map((a) => a.toString(16).padStart(2, "0")).join("")), e(r);
      };
    } else
      e("");
  });
}
c(ob, "mu");
d(ob, "getHash");
function Vv(n, t) {
  return n.findAll(t.filters).map((e) => t.select ? t.select(e) : e.state);
}
c(Vv, "Rp");
d(Vv, "getResult");
var Mp;
const xL = (Mp = class {
  constructor(t) {
    this.alwaysUpdate = !1, t.addController(this), this.host = t, this.setContext();
  }
  async setContext() {
    this.whenContext = new Promise((t) => this.resolveContext = t), await gs(this.host), this.context = new un(this.host, { context: Me, subscribe: !0 });
  }
  hostUpdate() {
    this.context?.value && this.resolveContext?.();
  }
  async trackMutationState(t, e) {
    if (e || (await this.whenContext, e = this.context?.value?.queryClient), !e)
      throw new Error("No QueryClient provided");
    return this.mutationCacheUnsubscribe?.(), this.options = t, this.mutationCache = e.getMutationCache(), this.mutationCacheSubscribe(), this.result;
  }
  mutationCacheSubscribe() {
    this.mutationCache && this.options && (this.result = Vv(this.mutationCache, this.options), this.mutationCacheUnsubscribe = this.mutationCache.subscribe((t) => {
      if (this.mutationCache && this.options && /added|removed|updated/.test(t.type)) {
        const e = Vv(this.mutationCache, this.options);
        this.result !== e && !so(this.result, e) && (this.result = e, this.host.requestUpdate());
      }
    }), this.host.requestUpdate());
  }
  get isMutating() {
    return !this.mutationCache || !this.options?.filters ? 0 : Vv(this.mutationCache, { filters: { ...this.options.filters, status: "pending" } }).length;
  }
  untrackMutationState() {
    this.mutationCacheUnsubscribe?.(), this.mutationCacheUnsubscribe = void 0, this.result = void 0, this.options = void 0, this.mutationCache = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.mutationCacheSubscribe();
  }
  hostDisconnected() {
    this.mutationCacheUnsubscribe?.();
  }
}, c(Mp, "Wy"), Mp);
d(xL, "MutationStateController");
let w0 = xL;
function se(n, t, e, i) {
  const s = n.getMutationCache(), r = s.find({
    mutationKey: t,
    predicate: /* @__PURE__ */ d((a) => a.state.variables === e, "predicate")
  });
  if (r && r.state.context) {
    const a = { ...r.state.context };
    i(a);
    const o = { ...r.state, context: a };
    r.state = o, s.notify({
      mutation: r,
      type: "updated",
      action: {
        type: "pending",
        context: r.state.context,
        variables: r.state.variables,
        isPaused: !1
      }
    });
  }
}
c(se, "Ft");
d(se, "updateMutationContext");
function YP(n, t, e) {
  const i = n.getMutationCache().find({ mutationKey: t, exact: !0, predicate: e });
  i && n.getMutationCache().remove(i);
}
c(YP, "$m");
d(YP, "removeMutation");
function kL(n, t) {
  const e = n.getMutationCache();
  e.findAll({ mutationKey: t, exact: !0 }).forEach((i) => {
    e.remove(i);
  });
}
c(kL, "e0");
d(kL, "removeMutations");
const GP = /* @__PURE__ */ d((n, t, e = 0, i = "application/octet-stream", s, r = Date.now()) => {
  const a = n && (n instanceof URL ? n.toString() : URL.createObjectURL(n));
  return {
    id: r,
    app: { id: -1 },
    name: t,
    kind: m0(t),
    size: e,
    media_type: i,
    embed_url: "",
    preview_format: $L(t),
    thumbnail_url: a,
    preview_url: a,
    download_url: a,
    rev: -1,
    created_by: s,
    created_at: (/* @__PURE__ */ new Date()).toUTCString(),
    is_subscribed: !1,
    is_trashed: !1,
    is_starred: !1
  };
}, "getTempFile");
function KP(n) {
  const t = n ? n.reduce(
    (e, i) => {
      const s = i.context?.file;
      return s && i.context?.status.progress && s.size ? {
        loaded: e.loaded + Math.floor(i.context.status.progress / 100 * s.size),
        total: e.total + s.size
      } : e;
    },
    { loaded: 0, total: 0 }
  ) : { loaded: 0, total: 0 };
  return {
    /** Loaded bytes */
    loaded: t.loaded,
    /** Total bytes */
    total: t.total,
    /** Progress of upload provided as 0-100 percent. */
    percent: t.total > 0 ? t.loaded / t.total * 100 : null
  };
}
c(KP, "Cm");
d(KP, "getFileMutationsTotalProgress");
function lb(n) {
  return n ? n.some((t) => t.context?.status.state === "conflict") ? "conflict" : n.some((t) => t.status === "error") ? "error" : n.every((t) => t.status === "success") ? "ok" : "pending" : "ok";
}
c(lb, "vu");
d(lb, "getFileMutationsTotalStatus");
function lS(n) {
  return n?.filter((t) => t.context?.status.state === "pending") || [];
}
c(lS, "Hw");
d(lS, "getPendingFileMutations");
function cS(n) {
  return n?.filter((t) => t.context?.status.state === "conflict" || t.status === "error") || [];
}
c(cS, "Vw");
d(cS, "getFileMutationsByConflictOrError");
function SL(n, t) {
  const e = n.queryClient;
  e.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "blobs"],
    exact: !0
  }).forEach((i) => {
    i.state.context?.status.state === "error" && e.getMutationCache().remove(i);
  }), e.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "files"],
    exact: !0
  }).forEach((i) => {
    i.state.context?.status.state === "conflict" && e.getMutationCache().remove(i);
  });
}
c(SL, "i0");
d(SL, "removeErroredFileMutations");
function cb(n, t, e) {
  const i = n.queryClient;
  i.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "blobs"],
    exact: !0,
    predicate: /* @__PURE__ */ d((s) => /error|success/.test(s.state.status) && (!e || s.state.variables?.blob?.name === e), "predicate")
  }).forEach((s) => {
    i.getMutationCache().remove(s);
  }), i.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "files"],
    exact: !0,
    predicate: /* @__PURE__ */ d((s) => /error|success/.test(s.state.status) && (!e || s.state.variables?.blob?.name === e), "predicate")
  }).forEach((s) => {
    i.getMutationCache().remove(s);
  });
}
c(cb, "gu");
d(cb, "removeSettledFileMutations");
function CL(n, t, e) {
  const i = n.queryClient, s = ["apps", e.id, "files"];
  return {
    mutationFn: /* @__PURE__ */ d(async ({ blob: r, replace: a = !1 }) => {
      const o = await n.fetch("/api/apps/" + e.id + "/files", {
        method: "POST",
        body: JSON.stringify({ blob_id: r.id, replace: a })
      });
      if (!o.ok) {
        const l = await o.json();
        throw new Error(l.detail || l.title, { cause: l });
      }
      return await o.json();
    }, "mutationFn"),
    mutationKey: s,
    onMutate: /* @__PURE__ */ d(async (r) => {
      await i.cancelQueries({ queryKey: s, exact: !0 }), PL(n, e, r.blob.name), cb(n, e, r.blob.name);
      let a;
      try {
        a = r.blob.thumbnail_url && new URL(r.blob.thumbnail_url) || void 0;
      } catch {
      }
      const o = GP(a, r.blob.name, r.blob.size, r.blob.media_type, t);
      return {
        type: r.replace ? "replace" : "create",
        file: o,
        status: { state: "pending" }
      };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((r, a, o) => (se(i, s, a, (l) => {
      l && (l.status.state = "ok", l.status.progress = void 0, l.status.text = void 0);
    }), i.invalidateQueries({ queryKey: s })), "onSuccess"),
    onError(r, a, o) {
      r?.cause?.status === 409 ? se(i, s, a, (l) => {
        l && (l.status.progress = void 0, l.status.state = "conflict", l.status.text = r.message);
      }) : se(i, s, a, (l) => {
        l && (l.status.state = "error", l.status.progress = void 0, l.status.text = r.message);
      });
    }
  };
}
c(CL, "r0");
d(CL, "getCreateFileMutationOptions");
function PL(n, t, e, i, s = "blobs") {
  const r = n.queryClient;
  r.getMutationCache().findAll({
    mutationKey: ["apps", t.id, s],
    exact: !0,
    status: "success",
    predicate: /* @__PURE__ */ d((a) => a.state.data?.name === e, "predicate")
  }).forEach((a) => {
    r.getMutationCache().remove(a);
  });
}
c(PL, "s0");
d(PL, "removeSuccessfulUploadBlobMutations");
async function JP(n, t, e, i) {
  const s = new FormData();
  s.append("blob", t);
  const r = await n.upload(
    "/api/blobs",
    "POST",
    s,
    UO.Auto,
    (a) => {
      e && e({ progress: a });
    },
    i
  );
  if (!r.ok) {
    const a = await r.json();
    throw new Error(a.detail || a.title, { cause: a });
  }
  return await r.json();
}
c(JP, "km");
d(JP, "uploadBlob");
function QL(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async (t) => await JP(n, t.file, t.onProgress), "mutationFn")
    // TODO: implement onmutate, onsuccess, onerror...
  };
}
c(QL, "n0");
d(QL, "getSimpleUploadBlobMutationOptions");
function v0(n, t, e, i, s = "blobs") {
  const r = n.queryClient, a = i ? ["apps", e, s, i] : ["apps", e, s];
  return {
    mutationFn: /* @__PURE__ */ d(async (o) => await JP(n, o.file, o.onProgress, o.signal), "mutationFn"),
    mutationKey: a,
    onMutate: /* @__PURE__ */ d(async (o) => {
      await r.cancelQueries({ queryKey: a, exact: !0 });
      const l = GP(o.file, o.file.name, o.file.size, o.file.type, t);
      o.onProgress = ({ progress: u }) => {
        se(r, a, o, (p) => {
          p.status.state = "pending", p.status.progress = u;
        });
      };
      const h = await ob(o.file);
      return { type: "upload", file: l, status: { state: "pending" }, sha256: h };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((o, l, h) => {
      se(r, a, l, (u) => {
        u.status.state = "ok", u.status.progress = void 0, u.status.text = void 0;
      });
    }, "onSuccess"),
    onError(o, l, h) {
      const u = o.cause;
      u && u.status === 409 ? se(r, a, l, (p) => {
        p.status.state = "conflict", p.status.progress = void 0, p.status.text = u.detail || u.title;
      }) : se(r, a, l, (p) => {
        p && (p.status.state = "error", p.status.progress = void 0, p.status.text = u.detail || u.title);
      });
    }
  };
}
c(v0, "Ju");
d(v0, "getUploadBlobMutationOptions");
var EB = Object.defineProperty, t4 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = void 0, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = a(t, e, s) || s);
  return s && EB(t, e, s), s;
}, "__decorateClass$1j"), Ag, Rg, Eg, _g, zg, Lg, vr, Ap;
const TL = (Ap = class extends pt {
  constructor() {
    super(...arguments), Z(this, Ag), Z(this, Rg), Z(this, Eg), Z(this, _g), Z(this, zg), Z(this, Lg), Z(this, vr), this.contextId = Oh(), _(this, Rg, new Promise((t) => {
      _(this, Ag, t);
    })), _(this, _g, new Promise((t) => {
      _(this, Eg, t);
    })), _(this, Lg, new Promise((t) => {
      _(this, zg, t);
    })), _(this, vr, new gn(this));
  }
  // PROPERTIES
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  // Promise.withResolvers() is available in ES2024, that needs to be set in TSConfig
  /**
   * Resolves when a contextual id is available.
   *
   * @internal
   * @returns {Promise<ContextIdType>}
   */
  async whenContextId() {
    return await $(this, Rg);
  }
  /**
   * Resolves when current user data is available.
   *
   * @returns {Promise<UserType>}
   */
  async whenUser() {
    return await $(this, _g);
  }
  /**
   * Resolves when a weavy context is available.
   *
   * @returns {Promise<WeavyType>}
   */
  async whenWeavy() {
    return await $(this, Lg);
  }
  connectedCallback() {
    super.connectedCallback(), this.contextId && this.requestUpdate("contextId"), this.user && this.requestUpdate("user"), this.weavy && this.requestUpdate("weavy");
  }
  async scheduleUpdate() {
    await gs(this), await super.scheduleUpdate();
  }
  async willUpdate(t) {
    var e, i, s;
    super.willUpdate(t), this.weavyContextConsumer ??= new un(this, { context: Me, subscribe: !0 }), this.weavyContextConsumer?.value && this.weavy !== this.weavyContextConsumer?.value && (this.weavy = this.weavyContextConsumer?.value), t.has("weavy") && this.weavy && await $(this, vr).trackQuery(Qm(this.weavy, ["user"])), $(this, vr).result?.isPending || (this.user && $(this, vr).result.data && this.user.id !== $(this, vr).result.data.id && (console.warn("User mismatch, resetting"), this.weavy?.reset()), this.user = $(this, vr).result?.data), t.has("contextId") && this.contextId && (t.get("contextId") && _(this, Rg, new Promise((r) => {
      _(this, Ag, r);
    })), (e = $(this, Ag)) == null || e.call(this, this.contextId)), t.has("user") && this.user && (t.get("user") && _(this, _g, new Promise((r) => {
      _(this, Eg, r);
    })), (i = $(this, Eg)) == null || i.call(this, this.user)), t.has("weavy") && this.weavy && (t.get("weavy") && _(this, Lg, new Promise((r) => {
      _(this, zg, r);
    })), (s = $(this, zg)) == null || s.call(this, this.weavy));
  }
}, c(Ap, "Qy"), Ap);
Ag = /* @__PURE__ */ new WeakMap(), Rg = /* @__PURE__ */ new WeakMap(), Eg = /* @__PURE__ */ new WeakMap(), _g = /* @__PURE__ */ new WeakMap(), zg = /* @__PURE__ */ new WeakMap(), Lg = /* @__PURE__ */ new WeakMap(), vr = /* @__PURE__ */ new WeakMap(), d(TL, "WeavyComponent");
let O0 = TL;
t4([
  F()
], O0.prototype, "weavy");
t4([
  or({ context: tL }),
  F()
], O0.prototype, "contextId");
t4([
  or({ context: p0 }),
  F()
], O0.prototype, "user");
var _B = Object.defineProperty, zB = Object.getOwnPropertyDescriptor, Ei = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? zB(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && _B(t, e, s), s;
}, "__decorateClass$1i"), Dv, qv, Zv, Fv, Ig, Wg, Vg, Dg, Zc, Fc, qg, Zg, Ts, Fg, Xc, Rp;
const ML = (Rp = class extends O0 {
  constructor() {
    super(), Z(this, Dv), Z(this, qv), Z(this, Zv), Z(this, Fv), Z(this, Ig), Z(this, Wg), Z(this, Vg), Z(this, Dg), Z(this, Zc), Z(this, Fc), Z(this, qg), Z(this, Zg), Z(this, Ts), Z(this, Fg), Z(this, Xc), this.storage = CP("localStorage"), this.storageLinkHandler = (t) => {
      t.storageArea === this.storage && t.key === "wy-link" && t.newValue && this.readStorageLink();
    }, this.linkEventHandler = async (t) => {
      !t.defaultPrevented && t.detail.link && (this.link && this.link.id === t.detail.link.id && (this.link = void 0, await this.updateComplete), this.link = t.detail.link, this.link || this.provideStorageLink(t.detail.link));
    }, this.notificationEventConsumer = (t) => {
      t.stopPropagation(), t.defaultPrevented || this.isConnected && this.checkVisibility(TS) && this.matchesLink(t.detail.link) && t.preventDefault();
    }, _(this, Wg, new Promise((t) => {
      _(this, Ig, t);
    })), _(this, Dg, new Promise((t) => {
      _(this, Vg, t);
    })), _(this, Fc, new Promise((t) => {
      _(this, Zc, t);
    })), _(this, Zg, new Promise((t) => {
      _(this, qg, t);
    })), _(this, Ts, /* @__PURE__ */ new Map()), _(this, Fg, new An(this)), _(this, Xc, new w0(this)), this.settings = new a9(this);
  }
  /**
   * Checks if an entity matches the component configuration.
   *
   * @internal
   * @param link - Entity to check for a match.
   * @returns True if the entity targets this component.
   */
  matchesLink(t) {
    return (
      // Type app match, like the Messenger
      t?.app?.type && this.componentTypes?.includes(t.app.type) ? t.agent ? t.agent === this.agent : !0 : !1
    );
  }
  set link(t) {
    const e = this._link;
    this._link = this.matchesLink(t) ? t : void 0, this.requestUpdate("link", e);
  }
  get link() {
    return this._link;
  }
  /**
   * Clears the link and resets the promise.
   *
   * @internal
   */
  clearLink() {
    this.link && (_(this, Fc, new Promise((t) => {
      _(this, Zc, t);
    })), this.link = void 0);
  }
  /**
   * Shares a link with other blocks that may consume it automatically.
   *
   * @param link - The entity to provide.
   * @internal
   */
  provideStorageLink(t) {
    this.storage?.setItem("wy-link", btoa(JSON.stringify(t)));
  }
  /**
   * Reads a link from storage and exposes it via the link property and context.
   *
   * @internal
   */
  readStorageLink() {
    if (!this.storage) {
      console.error("Storage not available");
      return;
    }
    const t = this.storage.getItem("wy-link");
    if (t)
      try {
        const e = JSON.parse(atob(t));
        e && (this.link = e);
      } catch (e) {
        console.error("Error parsing link", e);
      }
  }
  /**
   * Consumes a link in storage. Make sure to consume it after it has been used.
   *
   * @internal
   */
  consumeStorageLink() {
    this.storage?.removeItem("wy-link");
  }
  set agent(t) {
    this._agentUid = t || void 0;
  }
  get agent() {
    return this._agentUid;
  }
  set data(t) {
    console.warn(".data property array is deprecated. Use .contextualData string instead."), _(this, Dv, t);
  }
  /**
   * DEPRECATED: Use `.contextualData` property instead.
   *
   * Array with contextual data.
   *
   * *Note: Only the first item in the array is currently used.*
   * @internal
   * @deprecated
   */
  get data() {
    return $(this, Dv);
  }
  set annotations(t) {
    _(this, qv, t);
  }
  get annotations() {
    return $(this, qv) ?? this.weavy?.annotations ?? ze.defaults.annotations;
  }
  set enterToSend(t) {
    _(this, Zv, t);
  }
  get enterToSend() {
    return $(this, Zv) ?? this.weavy?.enterToSend ?? ze.defaults.enterToSend;
  }
  set reactions(t) {
    _(this, Fv, t);
  }
  get reactions() {
    return $(this, Fv) ?? this.weavy?.reactions ?? ze.defaults.reactions;
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  // Promise.withResolvers() is available in ES2024, that needs to be set in TSConfig
  // #resolveAgentUser?: (agent: AgentType) => void;
  // #whenAgentUser = new Promise<AgentType>((r) => {
  //   this.#resolveAgentUser = r;
  // });
  // async whenAgentUser() {
  //   return await this.#whenAgentUser;
  // }
  /**
   * Resolves when context data blob uploads has finished.
   *
   * @internal
   * @returns {Promise<ContextDataBlobsType>}
   */
  async whenContextDataBlobs() {
    return await $(this, Wg);
  }
  /**
   * Resolves when Weavy component features config is available.
   *
   * @internal
   * @returns {Promise<ComponentFeaturePolicy>}
   */
  async whenComponentFeatures() {
    return await $(this, Dg);
  }
  /**
   * Resolves when a provided link is available.
   *
   * @internal
   * @returns {Promise<LinkType>}
   */
  async whenLink() {
    return await $(this, Fc);
  }
  /**
   * Resolves when Weavy component settings are available.
   *
   * @internal
   * @returns {Promise<WeavyComponentSettingsType>}
   */
  async whenSettings() {
    return await $(this, Zg);
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("wy-link", this.linkEventHandler), window.addEventListener("storage", this.storageLinkHandler), this.componentFeatures && this.requestUpdate("componentFeatures"), this.contextDataBlobs && this.requestUpdate("contextDataBlobs"), this.link && this.requestUpdate("link"), this.settings && this.requestUpdate("settings");
  }
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("wy-link", this.linkEventHandler), window.removeEventListener("storage", this.storageLinkHandler), this.weavy?.host.removeEventListener("wy-notification", this.notificationEventConsumer, { capture: !0 });
  }
  async willUpdate(t) {
    var e, i, s, r;
    await super.willUpdate(t), t.has("bot") && typeof this.bot == "string" && console.error(`Using .bot property is deprecated. Use .agent = "${this.bot}"; instead`);
    const a = Object.keys(this.settings);
    if ((t.has("weavy") || a.find((o) => t.has(o))) && (this.settings = new a9(this)), t.has("features") && this.componentFeatures && (this.componentFeatures.setAllowedFeatures(this.features), this.componentFeatures instanceof ni && (this.componentFeatures = this.componentFeatures.immutable())), (t.has("weavy") || t.has("contextId") || t.has("user") || t.has("componentFeatures")) && this.weavy && this.contextId && this.user && this.componentFeatures?.allowsFeature(z.ContextData) && (await $(this, Fg).trackMutation(
      v0(this.weavy, this.user, this.contextId, void 0, "data")
    ), await $(this, Xc).trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.contextId, "data"],
          exact: !0
        }
      },
      this.weavy.queryClient
    )), t.has("contextualData") || t.has("data") || t.has("componentFeatures")) {
      const o = this.contextualData ? [this.contextualData] : this.data ? this.data : [], l = $(this, Ts);
      if (_(this, Ts, /* @__PURE__ */ new Map()), o.forEach((h) => {
        const u = l.get(h);
        if (u)
          $(this, Ts).set(h, u);
        else {
          const p = wL(h);
          p && $(this, Ts).set(h, p);
        }
      }), $(this, Ts) && this.componentFeatures?.allowsFeature(z.ContextData)) {
        for (const y of Array.from($(this, Ts).values()))
          if (y.type === "file") {
            const m = await ob(y.item);
            await z_(
              $(this, Xc).result ?? [],
              async (g) => (g.context?.sha256 ?? await ob(g.variables?.file)) === m
            ) || await $(this, Fg).mutate({ file: y.item });
          }
        const h = $(this, Xc).result, u = h?.some((y) => y.status === "pending"), p = h?.map((y) => y.data?.id).filter((y) => y).reverse() ?? [];
        u || (this.contextDataBlobs = p);
      } else
        this.contextDataBlobs = [];
    }
    (t.has("componentTypes") || t.has("agent")) && this.componentTypes && this.readStorageLink(), t.has("link") && this.link && (console.info("Opening notification link"), this.consumeStorageLink()), t.has("contextDataBlobs") && this.contextDataBlobs && (t.get("contextDataBlobs") && _(this, Wg, new Promise((o) => {
      _(this, Ig, o);
    })), (e = $(this, Ig)) == null || e.call(this, this.contextDataBlobs)), t.has("componentFeatures") && this.componentFeatures && (t.get("componentFeatures") && _(this, Dg, new Promise((o) => {
      _(this, Vg, o);
    })), (i = $(this, Vg)) == null || i.call(this, this.componentFeatures)), t.has("link") && this.link && (t.get("link") && _(this, Fc, new Promise((o) => {
      _(this, Zc, o);
    })), (s = $(this, Zc)) == null || s.call(this, this.link)), t.has("settings") && this.settings && (t.get("settings") && _(this, Zg, new Promise((o) => {
      _(this, qg, o);
    })), (r = $(this, qg)) == null || r.call(this, this.settings)), t.has("weavy") && this.weavy && this.weavy.host.addEventListener("wy-notification", this.notificationEventConsumer, { capture: !0 });
  }
}, c(Rp, "Ky"), Rp);
Dv = /* @__PURE__ */ new WeakMap(), qv = /* @__PURE__ */ new WeakMap(), Zv = /* @__PURE__ */ new WeakMap(), Fv = /* @__PURE__ */ new WeakMap(), Ig = /* @__PURE__ */ new WeakMap(), Wg = /* @__PURE__ */ new WeakMap(), Vg = /* @__PURE__ */ new WeakMap(), Dg = /* @__PURE__ */ new WeakMap(), Zc = /* @__PURE__ */ new WeakMap(), Fc = /* @__PURE__ */ new WeakMap(), qg = /* @__PURE__ */ new WeakMap(), Zg = /* @__PURE__ */ new WeakMap(), Ts = /* @__PURE__ */ new WeakMap(), Fg = /* @__PURE__ */ new WeakMap(), Xc = /* @__PURE__ */ new WeakMap(), d(ML, "WeavyTypeComponent");
let Ae = ML;
Ei([
  or({ context: eL }),
  F()
], Ae.prototype, "contextDataBlobs", 2);
Ei([
  or({ context: d0 }),
  F()
], Ae.prototype, "componentFeatures", 2);
Ei([
  or({ context: rL }),
  F()
], Ae.prototype, "settings", 2);
Ei([
  or({ context: nL })
], Ae.prototype, "_link", 2);
Ei([
  O({ type: Object })
], Ae.prototype, "link", 1);
Ei([
  F()
], Ae.prototype, "componentTypes", 2);
Ei([
  O()
], Ae.prototype, "features", 2);
Ei([
  O({ type: String })
], Ae.prototype, "agent", 1);
Ei([
  O({
    attribute: !0,
    type: String
  })
], Ae.prototype, "contextualData", 2);
Ei([
  O({
    attribute: !0,
    type: String,
    converter: {
      fromAttribute(n) {
        return __(n);
      }
    }
  })
], Ae.prototype, "data", 1);
Ei([
  O({ type: String })
], Ae.prototype, "annotations", 1);
Ei([
  O({ type: String })
], Ae.prototype, "enterToSend", 1);
Ei([
  O({ type: String })
], Ae.prototype, "reactions", 1);
Ei([
  O()
], Ae.prototype, "bot", 2);
const LB = new Map(bP(lL)), IB = new Map(bP(cL)), hb = new Map(Object.entries(hL));
new Map(Object.entries(dL));
var WB = Object.defineProperty, VB = Object.getOwnPropertyDescriptor, Al = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? VB(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && WB(t, e, s), s;
}, "__decorateClass$1h");
const _r = "unknown";
var Xg, Ng, Ba, Ep;
const AL = (Ep = class extends Ae {
  constructor() {
    super(...arguments), Z(this, Xg), Z(this, Ng), Z(this, Ba), this.appSubscribeMutation = new An(this), _(this, Ng, new Promise((t) => {
      _(this, Xg, t);
    })), _(this, Ba, new gn(this));
  }
  // @provide({ context: AgentContext })
  // @state()
  // agentUser: AgentType | undefined;
  /**
   * Sets the component to it's initial state and resets the app state.
   */
  reset() {
    this.app && (this.app = void 0), this._appName !== this._initialAppName && (this._appName = this._initialAppName);
  }
  /**
   * Checks if an entity matches the component configuration.
   *
   * @internal
   * @param link - Entity to check for a match.
   * @returns True if the entity targets this component.
   */
  matchesLink(t) {
    return (
      // Messenger conversation
      t?.app?.type && !this.appType && this.componentTypes?.includes(t.app.type) ? t.agent ? t.agent === this.agent : !0 : (
        // Normal contextual app
        !!(t && t.app && this.appType !== _r && (typeof this.uid == "string" && t.app?.uid === this.uid || // Normal app with app uid
        typeof this.uid == "number" && t.app?.id === this.uid || // Normal app with app id
        this.agent && t.app.type === this.appType && t.agent === this.agent))
      )
    );
  }
  set link(t) {
    const e = this._link;
    !this.uid && this.appType && this.appType !== _r ? this.whenApp().then(() => {
      this._link = this.matchesLink(t) ? t : void 0, this.requestUpdate("link", e);
    }) : (this._link = this.matchesLink(t) ? t : void 0, this.requestUpdate("link", e));
  }
  get link() {
    return this._link;
  }
  set name(t) {
    this._initialAppName = t, this._appName = t;
  }
  get name() {
    return this._appName;
  }
  /**
   * Subscribes or unsubscribes to notification updates from the app. Check `.app.is_subscribed` to see current state.
   *
   * @param subscribe - Set to `false` to unsubscribe from updates. Defaults to `true`.
   * @returns {Promise<void>}
   *
   * @example <caption>Toggle app subscription</caption>
   * ```js
   * // Wait for app data
   * await myWeavyComponent.whenApp();
   *
   * // Get current app subscription state
   * const isSubscribed = myWeavyComponent.app.is_subscribed;
   *
   * // Toggle the app subscription state
   * myWeavyComponent.subscribe(!isSubscribed);
   * ```
   */
  async subscribe(t = !0) {
    if (!this.uid)
      throw new Error(`Cannot ${t ? "subscribe" : "unsubscribe"} without a uid.`);
    await this.whenApp(), this.app?.id && this.appSubscribeMutation.mutate({ subscribe: t });
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  // Promise.withResolvers() is available in ES2024, that needs to be set in TSConfig
  /**
   * Resolves when app data is available.
   *
   * @returns {Promise<AppType>}
   */
  async whenApp() {
    return await $(this, Ng);
  }
  connectedCallback() {
    super.connectedCallback(), this.app && this.requestUpdate("app");
  }
  async willUpdate(t) {
    var e;
    if (await super.willUpdate(t), t.has("autoUid") && typeof this.autoUid == "string" && (console.error(`Using .autoUid property is deprecated. Use .generateUid = "${this.autoUid}"; instead`), this.generateUid = this.autoUid), (t.has("generateUid") || t.has("user") || t.has("agent")) && this.generateUid && this.user && (this.appType && hb.has(this.appType) && this.agent || this.appType && !hb.has(this.appType))) {
      const s = [this.generateUid];
      this.agent && s.push(this.agent), this.user && s.push(this.user.uid || this.user.id), this.uid = s.join("-");
    }
    const i = this.name;
    if ((t.has("appType") || t.has("uid") || t.has("agent") || t.has("weavy")) && this._appName !== this._initialAppName && (this._appName = this._initialAppName, this.requestUpdate("name", i)), t.has("appType") || t.has("uid") || t.has("agent") || t.has("name") || t.has("weavy"))
      if (this.appType && this.uid && this.weavy) {
        const s = this.name ? { name: this.name } : void 0, r = this.agent ? [this.agent] : void 0;
        await $(this, Ba).trackQuery(RL(this.weavy, this.uid, this.appType, r, s));
      } else
        $(this, Ba).untrackQuery();
    if ($(this, Ba).result?.isPending || (this.app = $(this, Ba).result?.data, this.app?.name && this._appName !== this.app.name && (this.name = this.app.name, this.requestUpdate("name", i))), t.has("uid") && (this.uid || t.get("uid")) && this.uid !== t.get("uid") && this.clearLink(), !this.link && (t.has("uid") && this.uid || t.has("app") && this.app) && this.appType && this.appType !== _r && this.readStorageLink(), t.has("app") && this.app) {
      const s = new CustomEvent("wy-app", {
        bubbles: !1,
        composed: !0,
        detail: {
          app: this.app
        }
      });
      this.dispatchEvent(s);
    }
    t.has("app") && this.app && (t.get("app") && _(this, Ng, new Promise((s) => {
      _(this, Xg, s);
    })), (e = $(this, Xg)) == null || e.call(this, this.app)), (t.has("weavy") || t.has("app")) && this.weavy && this.app && this.appSubscribeMutation.trackMutation(_L(this.weavy, this.app));
  }
}, c(Ep, "Gy"), Ep);
Xg = /* @__PURE__ */ new WeakMap(), Ng = /* @__PURE__ */ new WeakMap(), Ba = /* @__PURE__ */ new WeakMap(), d(AL, "WeavyAppComponent");
let _i = AL;
Al([
  or({ context: FP }),
  F()
], _i.prototype, "app", 2);
Al([
  O({ type: Object })
], _i.prototype, "link", 1);
Al([
  F()
], _i.prototype, "appType", 2);
Al([
  O()
], _i.prototype, "generateUid", 2);
Al([
  O({ converter: NP })
], _i.prototype, "uid", 2);
Al([
  O({ type: String })
], _i.prototype, "name", 1);
Al([
  O()
], _i.prototype, "autoUid", 2);
function RL(n, t, e = _r, i, s) {
  return {
    // eslint-disable-next-line @tanstack/query/exhaustive-deps
    queryKey: ["apps", t],
    queryFn: /* @__PURE__ */ d(async () => {
      const r = [];
      e === _r || typeof t == "number" ? r.push(
        // Get existing app
        n.fetch(`/api/apps/${t}`)
      ) : i?.length ? (r.push(
        // Get existing app
        n.fetch(`/api/apps/${t}`)
      ), r.push(
        // Create app with members
        n.fetch("/api/apps", { method: "POST", body: JSON.stringify({ type: e, members: i, uid: t, ...s }) })
      )) : r.push(
        // Get, update or create app (upsert) using app uid
        n.fetch(`/api/apps/${t}`, { method: "PUT", body: JSON.stringify({ type: e, ...s }) })
      );
      const a = (await Promise.allSettled(r)).findLast(
        (l) => l.status === "fulfilled" && l.value?.ok
      ), o = a?.status === "fulfilled" && a.value;
      if (o)
        return await o.json();
      throw new Error(`Error getting or creating app ${t}`);
    }, "queryFn")
  };
}
c(RL, "u0");
d(RL, "getOrCreateAppOptions");
function EL(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ name: t, members: e, type: i, uid: s }) => await (await n.fetch("/api/apps", {
      method: "POST",
      body: JSON.stringify({
        name: t,
        members: e,
        type: i,
        uid: s
      })
    })).json(), "mutationFn"),
    onSettled: /* @__PURE__ */ d(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
c(EL, "y0");
d(EL, "getCreateAppMutationOptions");
function e4(n) {
  return new Xt(n.queryClient, EL(n));
}
c(e4, "_m");
d(e4, "getCreateAppMutation");
function _L(n, t) {
  const e = n.queryClient, i = ["apps", t.uid || t.id];
  return {
    mutationFn: /* @__PURE__ */ d(async ({ subscribe: s }) => {
      if (t.id >= 1) {
        const r = await n.fetch(`/api/apps/${t.id}/${s ? "subscribe" : "unsubscribe"}`, {
          method: "POST"
        });
        if (!r.ok)
          throw await r.json();
      } else
        throw new Error(`Could not subscribe to app ${t.uid || t.id}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => {
      let r;
      return e.setQueryData(i, (a) => (r = a.is_subscribed, { ...a, is_subscribed: s.subscribe })), {
        previousSubscribe: r,
        subscribe: s.subscribe
      };
    }, "onMutate"),
    onError(s, r, a) {
      a && a.previousSubscribe !== void 0 && e.setQueryData(i, (o) => ({ ...o, is_subscribed: a?.previousSubscribe }));
    }
  };
}
c(_L, "w0");
d(_L, "getAppSubscribeMutationOptions");
function zL(n, t = [gt.ChatRoom, gt.PrivateChat], e) {
  const i = new URLSearchParams({
    count_only: "true",
    unread: "true",
    uid: "false"
  });
  e && i.append("member", e), t?.forEach((r) => i.append("type", r));
  const s = `/api/apps?${i.toString()}`;
  return Qm(n, ["apps", "unread", t, e], s);
}
c(zL, "f0");
d(zL, "getAppsUnreadOptions");
function LL(n, t = {}, e, i, s, r, a) {
  return {
    ...t,
    initialPageParam: 0,
    queryKey: ["apps", "list", e, i, r, a],
    queryFn: /* @__PURE__ */ d(async (o) => {
      const l = new URLSearchParams();
      i && l.append("member", i), o.pageParam && typeof o.pageParam == "number" && l.append("skip", o.pageParam?.toString()), e?.forEach((y) => l.append("type", y)), l.append("order_by", r);
      const h = s?.();
      h && l.append("q", h), l.append("uid", "false");
      const u = `/api/apps?${l.toString()}`, p = await (await n.fetch(u)).json();
      return p.data = p.data || [], p;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ d((o) => {
      if (o.end && o?.end < o?.count)
        return o.end;
    }, "getNextPageParam")
  };
}
c(LL, "m0");
d(LL, "getAppListOptions");
var hi = /* @__PURE__ */ ((n) => (n.Default = "", n.Select = "select", n.Star = "star", n.Unstar = "unstar", n.Subscribe = "subscribe", n.Unsubscribe = "unsubscribe", n.Pin = "pin", n.Unpin = "unpin", n.Download = "download", n.Preview = "preview", n))(hi || {}), _p;
const IL = (_p = class {
  get weavy() {
    return this.weavyContext?.value;
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenWeavyContext = new Promise((e) => this.resolveWeavyContext = e), this.setContexts();
  }
  /**
   * Initiates context consumers
   */
  async setContexts() {
    await gs(this.host), this.weavyContext = new un(this.host, { context: Me, subscribe: !0 });
  }
  /**
   * Dispatch a `wy-action` event on the host.
   *
   * @fires {WyActionEventType} wy-action - Emitted when a conversation app is created and should be selected.
   */
  dispatchActionEvent(t) {
    const e = new CustomEvent("wy-action", {
      detail: { action: hi.Select, app: t },
      bubbles: !0,
      composed: !0
    });
    return this.host.dispatchEvent(e);
  }
  /**
   * Create mutation controller.
   */
  async initMutation() {
    if (!this.addConversationMutation) {
      const t = await this.whenWeavyContext;
      this.addConversationMutation = e4(t);
    }
    return this.addConversationMutation;
  }
  /**
   * Create a conversation and trigger a `select` event.
   *
   * @param members - Array of members by id/uid for a new conversation.
   * @returns Whether the event was successful.
   * @fires {WyActionEventType} wy-action - Emitted when a conversation app is created and should be selected.
   */
  async create(t = []) {
    const e = await this.initMutation(), i = this.agent ?? this.host.agent, s = i ? { members: [i], type: Sn.AgentChat } : { members: t, type: t.length === 1 ? Sn.PrivateChat : Sn.ChatRoom }, r = await e.mutate(s);
    return this.dispatchActionEvent(r), r;
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
  }
}, c(_p, "Zy"), _p);
d(IL, "CreateConversationController");
let b0 = IL;
var jg, zp;
const WL = (zp = class {
  constructor(t) {
    Z(this, jg, !1), t.addController(this), this.host = t, t.addEventListener("dragstart", () => this.isDragActive = !0), t.addEventListener("dragenter", () => this.isDragActive = !0), t.addEventListener("dragover", (e) => {
      e.preventDefault(), this.isDragActive = !0;
    }), t.addEventListener("dragleave", () => this.isDragActive = !1), t.addEventListener("dragend", () => this.isDragActive = !1), t.addEventListener("drop", (e) => this.handleDrop(e));
  }
  get isDragActive() {
    return $(this, jg);
  }
  set isDragActive(t) {
    $(this, jg) !== t && (_(this, jg, t), this.host.requestUpdate());
  }
  handleDrop(t) {
    t.preventDefault();
    const e = [];
    t.dataTransfer?.items ? [...t.dataTransfer.items].forEach((i) => {
      if (i.kind === "file") {
        const s = i.getAsFile();
        s ? e.push(s) : console.error("Could not add file");
      }
    }) : t.dataTransfer?.files && [...t.dataTransfer.files].forEach((i) => {
      e.push(i);
    }), e.length && this.dispatchUploadFiles(e), this.isDragActive = !1;
  }
  dispatchUploadFiles(t) {
    const e = new CustomEvent("drop-files", { detail: { files: t } });
    return this.host.dispatchEvent(e);
  }
  hostDisconnected() {
  }
}, c(zp, "Yy"), zp);
jg = /* @__PURE__ */ new WeakMap(), d(WL, "DropZoneController");
let VL = WL;
function uw(n, t) {
  we();
  const e = no({}, window.history.state, !0);
  if (!e.weavy || !e.weavy[n] || !Object.hasOwn(e.weavy[n], t))
    throw new Error("Property not found");
  return e.weavy[n][t];
}
c(uw, "zd");
d(uw, "getBrowserStateProperty");
function db(n, t, e = "push", i) {
  if (we(), t) {
    const s = no({}, window.history.state, !0);
    s.weavy ??= {}, s.weavy[n] = t, i = i && String(i) || window.location.href;
    try {
      e === "replace" ? window.history.replaceState(s, "", i) : window.history.pushState(s, "", i);
    } catch (r) {
      console.warn("history: Could not push history state.", r, t);
    }
  }
}
c(db, "bu");
d(db, "setBrowserState");
function DL(n, t, e) {
  we();
  const i = `${typeof n}:${t}`;
  e.forEach((s) => {
    try {
      const r = uw(i, s), a = n[s];
      i4(a, r) && (n[s] = r);
    } catch {
    }
  });
}
c(DL, "v0");
d(DL, "restoreHistoryProperties");
function ub(n, t, e, i = "push") {
  we();
  const s = `${typeof n}:${t}`, r = {};
  e.forEach((a) => {
    r[a] = n[a];
  }), db(s, r, i);
}
c(ub, "xu");
d(ub, "pushHistoryProperties");
function qL(n, t, e) {
  ub(n, t, e, "replace");
}
c(qL, "g0");
d(qL, "updateHistoryProperties");
function i4(n, t) {
  return n && t && (Hs(n) || Hs(t)) ? n && Object.hasOwn(n, "id") || t && Object.hasOwn(t, "id") ? n.id !== t.id : !so(n, t) : n !== t;
}
c(i4, "Pm");
d(i4, "itemHasChanged");
var Lp;
const DB = (Lp = class {
  constructor(t, e, i) {
    if (this._backCount = 0, this.restoreHistory = (s) => {
      if (this.prefixKey && this.properties) {
        DL(this.host, this.prefixKey, this.properties);
        try {
          this._backCount = uw(this.prefixKey, "_backCount") || 0;
        } catch {
          this._backCount = 0;
        }
        this.updatePrevPropertyValues();
      }
    }, t.addController(this), this.host = t, i && (this.properties = i), e) {
      this.prefixKey = e;
      try {
        this._backCount = uw(this.prefixKey, "_backCount") || this._backCount;
      } catch {
      }
    }
  }
  get hasBackNavigation() {
    return this._backCount > 0;
  }
  back() {
    window.history.back();
  }
  backAll() {
    window.history.go(this._backCount * -1);
  }
  observe(t, e) {
    if (this.properties = t, e) {
      this.prefixKey = e;
      try {
        this._backCount = uw(this.prefixKey, "_hasBack") || this._backCount;
      } catch {
      }
    }
  }
  /**
   * Method to manually push history
   */
  pushCurrentState() {
    this.prefixKey && (ub(this.host, this.prefixKey, this.properties), this._backCount++, db(this.prefixKey, { _backCount: this._backCount }, "replace"));
  }
  updatePrevPropertyValues() {
    this.properties && this.properties.forEach((t) => {
      this.prevPropertyValues ??= {};
      const e = this.host[t];
      this.prevPropertyValues[t] !== e && (this.prevPropertyValues[t] = e && JSON.parse(JSON.stringify(e)));
    });
  }
  hostConnected() {
    window.addEventListener("popstate", this.restoreHistory);
  }
  hostUpdated() {
    this.prefixKey && this.properties && (this.prevPropertyValues ? this.properties.some(
      (t) => {
        const e = this.prevPropertyValues?.[t], i = this.host[t];
        return i4(e, i);
      }
    ) && (ub(
      this.prevPropertyValues,
      this.prefixKey,
      this.properties
    ), this._backCount++, db(this.prefixKey, { _backCount: this._backCount }, "replace")) : this.prevPropertyValues = {}, qL(this.host, this.prefixKey, this.properties), this.updatePrevPropertyValues());
  }
  hostDisconnected() {
    window.removeEventListener("popstate", this.restoreHistory);
  }
}, c(Lp, "Xy"), Lp);
d(DB, "HistoryController");
var Ip;
const ZL = (Ip = class {
  get result() {
    return this._result && this.observer ? this.observer.trackResult(this._result) : this.observer?.getCurrentResult() ?? { isPending: !0 };
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenQueryClient = new Promise((e) => this.resolveQueryClient = e), this.setContext();
  }
  async setContext() {
    await gs(this.host), this.context = new un(this.host, {
      context: Me,
      subscribe: !0,
      callback: /* @__PURE__ */ d((t) => {
        t && (this.resolveContext?.(t), this.queryClient = t.queryClient, this.resolveQueryClient?.(t.queryClient));
      }, "callback")
    });
  }
  async trackInfiniteQuery(t, e = !0) {
    this.observerUnsubscribe?.();
    const i = await this.whenQueryClient;
    if (!i)
      throw new Error("No QueryClient provided");
    const s = new nB(i, t);
    this.observer = s, this.observerSubscribe(e);
  }
  observerSubscribe(t = !0) {
    if (this.queryClient && this.observer) {
      t ? this._result = this.observer.getOptimisticResult(
        this.observer.options
      ) : this._result = this.observer.getCurrentResult(), this.observerUnsubscribe = this.observer.subscribe(() => {
        if (this.observer) {
          const i = Pm(this.result, this.observer.getCurrentResult());
          i !== this._result && (this._result = i, this.host.requestUpdate());
        }
      }), this.observer.updateResult(), this.host.requestUpdate();
      let e;
      t ? e = this.observer.fetchOptimistic(this.observer.options) : e = this.queryClient.getQueryCache().get(
        this.observer.options.queryHash
      )?.promise, e?.catch(() => {
      }).finally(() => {
        this.observer?.updateResult();
      });
    }
  }
  untrackInfiniteQuery() {
    this.observerUnsubscribe?.(), this.observerUnsubscribe = void 0, this._result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    this.observerUnsubscribe?.();
  }
}, c(Ip, "Jy"), Ip);
d(ZL, "InfiniteQueryController");
let Rl = ZL;
function pb(n, t = !1) {
  for (n && !t && (n = n.nextElementSibling); n; ) {
    if (!(n instanceof HTMLElement))
      continue;
    const e = getComputedStyle(n);
    if (e.display !== "none") {
      if (e.display === "contents") {
        if (n.shadowRoot && n.shadowRoot.firstElementChild instanceof HTMLElement) {
          const i = pb(n.shadowRoot.firstElementChild, !0);
          if (i)
            return i;
        }
        if (n.firstElementChild instanceof HTMLElement) {
          const i = pb(n.firstElementChild, !0);
          if (i)
            return i;
        }
      }
      if (/absolute|sticky|fixed/.test(e.position) === !1)
        return n;
      n = n.nextElementSibling;
    }
  }
  return null;
}
c(pb, "$u");
d(pb, "getNextPositionedChild");
function m1(n, t = !1) {
  if (we(), n) {
    let e = getComputedStyle(n);
    const i = e.position === "absolute", s = t ? /(auto|scroll|overlay|hidden)/ : /(auto|overlay|scroll)/;
    if (e.position === "fixed" && document.scrollingElement)
      return document.scrollingElement;
    for (let r = n; r = r.parentElement || r.parentNode || r.host; )
      if (r instanceof Element && (e = getComputedStyle(r), !(i && e.position === "static") && s.test(e.overflow + e.overflowY + e.overflowX)))
        return r;
  }
  return document.scrollingElement || n;
}
c(m1, "wh");
d(m1, "getScrollParent");
function FL(n) {
  if (n && n.isConnected) {
    const t = m1(n);
    return t.clientHeight !== t.scrollHeight;
  }
  return !1;
}
c(FL, "b0");
d(FL, "hasScroll");
function XL(n, t = 32) {
  if (n) {
    const e = m1(n);
    return Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) < t;
  }
  return !1;
}
c(XL, "x0");
d(XL, "isParentAtBottom");
async function NL(n, t = !1) {
  if (n) {
    const e = m1(n);
    Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) > 1 && (t ? e.scrollTo({
      top: e.scrollHeight,
      left: 0,
      behavior: "smooth"
    }) : e.scrollTop = e.scrollHeight), await new Promise((i) => {
      let s = e.scrollTop;
      const r = /* @__PURE__ */ d(() => {
        t && e.scrollTop === s && (e.scrollTop = e.scrollHeight), s = e.scrollTop, Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) > 1 ? requestAnimationFrame(r) : i(void 0);
      }, "scrollCheck");
      requestAnimationFrame(r);
    });
  }
}
c(NL, "$0");
d(NL, "scrollParentToBottom");
const qB = 0, ZB = void 0;
function jL(n, t, e = !1) {
  we(), t ??= /* @__PURE__ */ d(() => Promise.reject(new Error("No scroll function defined")), "whenNext");
  const i = e ? m1(n) : document.documentElement, s = i === document.documentElement ? document : i;
  let r = !1;
  const a = new IntersectionObserver(
    (o) => {
      o.forEach((l) => {
        if (l.isIntersecting && !r)
          if (r = !0, e && i && s instanceof HTMLElement) {
            const h = pb(l.target) || l.target, u = i.scrollHeight, p = h.offsetTop, y = /* @__PURE__ */ d(() => {
              queueMicrotask(() => {
                if (u !== i.scrollHeight) {
                  if (h?.isConnected) {
                    const m = h.offsetTop - p;
                    i.scrollTop += m;
                  }
                  requestAnimationFrame(() => r = !1);
                } else
                  queueMicrotask(() => {
                    if (u !== i.scrollHeight) {
                      if (h?.isConnected) {
                        const m = h.offsetTop - p;
                        i.scrollTop += m;
                      }
                      requestAnimationFrame(() => r = !1);
                    } else
                      requestAnimationFrame(() => {
                        if (a.takeRecords().length && h?.isConnected) {
                          const m = h.offsetTop - p;
                          i.scrollTop += m;
                        }
                        requestAnimationFrame(() => r = !1);
                      });
                  });
              });
            }, "afterNext");
            t().then(y);
          } else
            t().then(() => {
              requestAnimationFrame(() => r = !1);
            });
      });
    },
    { root: s, threshold: qB, rootMargin: ZB }
  );
  return a.observe(n), a;
}
c(jL, "_0");
d(jL, "createScroller");
var Wp;
const BL = (Wp = class {
  constructor(t, e = !1) {
    this.reverse = !1, this.isObservePending = !1, t.addController(this), this.host = t, this.reverse = e;
  }
  observe(t, e) {
    t && e && !t.isLoading && !this.isObservePending && (this.isObservePending = !0, requestAnimationFrame(() => {
      this.loadMoreRefElement = e, this.scroller?.disconnect(), this.scroller = jL(
        e,
        async () => {
          t.hasNextPage && !t.isFetching && (await t.fetchNextPage({ cancelRefetch: !1 }), this.reverse && await this.host.updateComplete);
        },
        this.reverse
      ), this.isObservePending = !1;
    }));
  }
  hostConnected() {
    this.loadMoreRefElement && this.scroller?.observe(this.loadMoreRefElement);
  }
  hostDisconnected() {
    this.scroller?.disconnect();
  }
}, c(Wp, "tw"), Wp);
d(BL, "InfiniteScrollController");
let El = BL;
var Vp;
const UL = (Vp = class extends El {
  constructor(t) {
    super(t, !0);
  }
}, c(Vp, "ew"), Vp);
d(UL, "ReverseInfiniteScrollController");
let FB = UL;
var Or, Nc, Dp;
const HL = (Dp = class {
  constructor(t) {
    if (Z(this, Or), Z(this, Nc), _(this, Or, /* @__PURE__ */ new Map()), this.keyPrefix = "WEAVY_OFFLINE_CACHE", t)
      _(this, Nc, t);
    else
      try {
        we(), _(this, Nc, window.sessionStorage);
      } catch {
        console.warn("Session storage not available.");
      }
  }
  resetPersistPropertiesCache() {
    $(this, Or).clear();
  }
  getStorageItem(t, e) {
    const i = $(this, Nc)?.getItem(`${t}-${e.toString()}`);
    if (i)
      return JSON.parse(i);
  }
  setStorageItem(t, e, i) {
    const s = JSON.stringify(i);
    s && $(this, Nc)?.setItem(`${t}-${e.toString()}`, s);
  }
  persistProperties(t, e, i, s, r) {
    const a = `${this.keyPrefix}:${s ? `${s}:` : ""}${typeof t}:${e}`, o = /* @__PURE__ */ new Map();
    for (const l of i) {
      if (!$(this, Or).has(l.name)) {
        const h = this.getStorageItem(a, l.name);
        h && (l.override || !t[l.name]) && (o.set(l.name, t[l.name]), t[l.name] = h), $(this, Or).set(l.name, h);
      }
      if (r?.(o), t[l.name] !== $(this, Or).get(l.name)) {
        const h = t[l.name];
        $(this, Or).set(l.name, h), this.setStorageItem(a, l.name, h);
      }
    }
  }
}, c(Dp, "iw"), Dp);
Or = /* @__PURE__ */ new WeakMap(), Nc = /* @__PURE__ */ new WeakMap(), d(HL, "PersistStorageCache");
let XB = HL;
var jc, Bg, qp;
const YL = (qp = class {
  constructor(t) {
    Z(this, jc), Z(this, Bg), _(this, jc, ""), this.properties = [], this.initialProperties = /* @__PURE__ */ new Map(), this.persistStorageCache = new XB(), t.addController(this), this.host = t;
  }
  get prefixKey() {
    return $(this, jc);
  }
  set prefixKey(t) {
    t !== $(this, jc) && (this.persistStorageCache.resetPersistPropertiesCache(), _(this, jc, t), this.host.requestUpdate());
  }
  get cachePrefix() {
    return $(this, Bg);
  }
  set cachePrefix(t) {
    t !== $(this, Bg) && (this.persistStorageCache.resetPersistPropertiesCache(), _(this, Bg, t), this.host.requestUpdate());
  }
  observe(t, e, i, s) {
    this.properties = t, this.callback = s;
    const r = !!(this.prefixKey && this.prefixKey !== e || this.cachePrefix && this.cachePrefix !== i);
    this.properties.forEach((a) => {
      r && this.initialProperties.has(a.name) ? this.host[a.name] = this.initialProperties.get(a.name) : this.initialProperties.has(a.name) || this.initialProperties.set(a.name, this.host[a.name]);
    }), e && (this.prefixKey = e), i && (this.cachePrefix = i);
  }
  hostUpdate() {
    this.prefixKey && this.properties && this.host.weavy && this.persistStorageCache.persistProperties(this.host, this.prefixKey, this.properties, this.cachePrefix ? `${this.host.weavy.cachePrefix}:${this.cachePrefix}` : this.host.weavy.cachePrefix, this.callback);
  }
}, c(qp, "rw"), qp);
jc = /* @__PURE__ */ new WeakMap(), Bg = /* @__PURE__ */ new WeakMap(), d(YL, "PersistStateController");
let g1 = YL;
var Zp;
const NB = (Zp = class {
  constructor(t) {
    this.observers = [], this.conditions = {}, this.resizer = new ResizeObserver((e) => {
      let i = !1;
      for (const s of e)
        i = this.checkConditions(s) || i;
      i && this.host.requestUpdate();
    }), t.addController(this), this.host = t;
  }
  checkConditions(t) {
    let e = !1;
    return this.observers.forEach((i) => {
      if (t.target === i.target) {
        const s = this.conditions[i.name], r = i.condition(t);
        s !== r && (this.conditions[i.name] = r, e = !0);
      }
    }), e;
  }
  observe(t) {
    const e = t.target, i = e.getBoundingClientRect();
    this.observers.push(t), this.resizer.observe(e), this.checkConditions({
      contentBoxSize: [
        {
          inlineSize: e.clientWidth,
          blockSize: e.clientHeight
        }
      ],
      borderBoxSize: [
        {
          inlineSize: i.width,
          blockSize: i.height
        }
      ],
      devicePixelContentBoxSize: [
        {
          inlineSize: i.width * window.devicePixelRatio,
          blockSize: i.height * window.devicePixelRatio
        }
      ],
      contentRect: i,
      target: e
    });
  }
  reset() {
    this.conditions = {}, this.observers.length = 0, this.resizer.disconnect();
  }
  hostConnected() {
    this.observers.forEach((t) => {
      this.resizer.observe(t.target);
    });
  }
  hostDisconnected() {
    this.resizer.disconnect();
  }
}, c(Zp, "sw"), Zp);
d(NB, "ResizeController");
var Fp;
const GL = (Fp = class {
  constructor(t, e) {
    this.additionalTargets = /* @__PURE__ */ new Set(), this.setExportParts = (i) => {
      (!this.host.hasAttribute("exportparts") || this.shadowParts) && (this.shadowParts ??= /* @__PURE__ */ new Set(), i.forEach((s) => {
        s.part.forEach((r) => this.shadowParts?.add(r)), s.getAttribute("exportparts")?.split(", ").forEach((r) => this.shadowParts?.add(r));
      }), this.shadowParts.size && this.host.setAttribute("exportparts", Array.from(this.shadowParts.values()).join(", ")));
    }, t.addController(this), this.host = t, this.addLocalName = e;
  }
  addPartsFrom(t) {
    t && !this.additionalTargets.has(t) && (this.setExportParts([t]), this.observer?.observe(t, {
      attributeFilter: ["part", "exportparts"]
    }), this.additionalTargets.add(t));
  }
  async hostConnected() {
    if (await this.host.updateComplete, lk(this.host) && this.host.shadowRoot) {
      const t = Array.from(this.host.shadowRoot.querySelectorAll("[part], [exportparts]"));
      this.setExportParts(t), this.observer = new MutationObserver((e) => {
        const i = e.flatMap((s) => s.type === "attributes" ? [s.target] : Array.from(s.addedNodes)).filter((s) => s instanceof Element);
        this.setExportParts(i);
      }), this.observer.observe(this.host.shadowRoot, {
        subtree: !0,
        childList: !0,
        attributeFilter: ["part", "exportparts"]
      }), Array.from(this.additionalTargets).forEach((e) => {
        this.observer?.observe(e, {
          attributeFilter: ["part", "exportparts"]
        });
      });
    }
  }
  hostUpdated() {
    lk(this.host) && this.addLocalName !== !1 && !this.host.part.contains(this.host.localName) && (this.addLocalName || getComputedStyle(this.host).display !== "contents") && this.host.part.add(this.host.localName);
  }
  hostDisconnected() {
    this.observer?.disconnect();
  }
}, c(Fp, "nw"), Fp);
d(GL, "ShadowPartsController");
let Y = GL;
var Xp;
const KL = (Xp = class {
  constructor(t) {
    this.delay = NaN, this.sleep = !1, t.addController(this), this.host = t;
  }
  createObserver(t) {
    this.scrollObserver?.disconnect(), this.swipeElement = t, this.scrollObserver = new IntersectionObserver(
      (e) => {
        e.forEach(async (i) => {
          i.isIntersecting && !this.sleep && i.intersectionRatio >= 1 && (this.sleep = !0, Number.isNaN(this.delay) || await new Promise((s) => {
            setTimeout(s, this.delay);
          }), i.target === this.prevElement && this.whenPrev && await this.whenPrev(), i.target === this.nextElement && this.whenNext && await this.whenNext(), await this.host.updateComplete);
        });
      },
      { root: t, threshold: 1, rootMargin: "0px" }
    );
  }
  observe(t, e) {
    this.prevElement && (this.scrollObserver?.unobserve(this.prevElement), this.prevElement = void 0), this.nextElement && (this.scrollObserver?.unobserve(this.nextElement), this.nextElement = void 0), t && (this.scrollObserver?.observe(t), this.prevElement = t), e && (this.scrollObserver?.observe(e), this.nextElement = e), this.sleep = !1;
  }
  clearObserver() {
    this.prevElement = void 0, this.nextElement = void 0, this.scrollObserver?.disconnect(), this.sleep = !1;
  }
  hostConnected() {
    this.scrollObserver && (this.prevElement && this.scrollObserver.observe(this.prevElement), this.nextElement && this.scrollObserver.observe(this.nextElement), this.sleep = !1);
  }
  hostDisconnected() {
    this.scrollObserver?.disconnect();
  }
}, c(Xp, "aw"), Xp);
d(KL, "SwipeScrollController");
let jB = KL;
var Ug, Xv, Np;
const JL = (Np = class {
  constructor(t, e) {
    Z(this, Ug), Z(this, Xv), _(this, Ug, !0), this.styles = [], t.addController(this), this.host = t, e && (this.styles = e);
  }
  get themeColor() {
    return $(this, Xv);
  }
  set themeColor(t) {
    _(this, Xv, t), this.checkThemeUpdate();
  }
  checkThemeUpdate() {
    const t = this.themeColor || sb(this.host) || rb();
    if (t && t !== this._resolvedThemeColor) {
      this._resolvedThemeColor = t, console.info("Configuring theme", this._resolvedThemeColor);
      const e = jz(this._resolvedThemeColor).join(""), i = et`
        :host {
          ${g_(e)};
        }
      `, s = this.host.renderRoot;
      w_(s, [...this.styles, i]);
    }
  }
  hostUpdate() {
    $(this, Ug) && (this.checkThemeUpdate(), _(this, Ug, !1));
  }
  hostConnected() {
    this.cssObserverDisconnect = Xz(this.host, () => this.checkThemeUpdate()), this.metaObserverDisconnect = Nz(() => this.checkThemeUpdate());
  }
  hostDisconnected() {
    this.cssObserverDisconnect?.(), this.metaObserverDisconnect?.();
  }
}, c(Np, "ow"), Np);
Ug = /* @__PURE__ */ new WeakMap(), Xv = /* @__PURE__ */ new WeakMap(), d(JL, "ThemeController");
let wn = JL;
var jp;
const tI = (jp = class {
  constructor(t) {
    this.registrationRequested = !1, this.typingTimeout = null, this.discardTime = 5 * 1e3, this.typingMembers = [], this.names = [], this.ellipsis = "", this.handleRealtimeTyping = (e) => {
      e.entity.id === this.appId && e.actor.id !== this.userId && (this.setTypers(e.actor), this.updateTyping());
    }, this.handleRealtimeStopTyping = (e) => {
      this.typingMembers.forEach((i, s) => {
        i.id === e.actor.id && this.typingMembers.splice(s, 1);
      }), this.updateTyping();
    }, t.addController(this), this.host = t, this.setContexts();
  }
  get weavy() {
    return this.weavyContext?.value;
  }
  get componentFeatures() {
    return this._componentFeatures;
  }
  get appId() {
    return this._appId;
  }
  set appId(t) {
    t !== this._appId && (this.typingMembers = [], this.unregisterRealtime(), this._appId = t, this.registerRealtime());
  }
  get userId() {
    return this._userId;
  }
  set userId(t) {
    t !== this._userId && (this.typingMembers = [], this.unregisterRealtime(), this._userId = t, this.registerRealtime());
  }
  async setContexts() {
    this.whenWeavyContext = new Promise((t) => this.resolveWeavyContext = t), this.whenComponentFeaturesContext = new Promise((t) => this.resolveComponentFeaturesContext = t), await gs(this.host), this.weavyContext = new un(this.host, { context: Me, subscribe: !0 }), this.componentFeaturesContext = new un(this.host, {
      context: d0,
      subscribe: !0
    });
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
    const t = this.componentFeaturesContext && this.componentFeaturesContext.value?.allowsFeature(z.Typing) !== this._componentFeatures?.allowsFeature(z.Typing);
    t && (this._componentFeatures = this.componentFeaturesContext?.value, this.componentFeaturesContext?.value && this.resolveComponentFeaturesContext?.(this.componentFeaturesContext.value), t && (this.unregisterRealtime(!0), this.registerRealtime()));
  }
  async registerRealtime() {
    !this.registrationRequested && this.appId && this._userId && (this.registrationRequested = !0, await Promise.all([this.whenWeavyContext, this.whenComponentFeaturesContext]), this.componentFeatures?.allowsFeature(z.Typing) && (this.weavy?.subscribe(`a${this.appId}`, "typing", this.handleRealtimeTyping), this.weavy?.subscribe(`a${this.appId}`, "message_created", this.handleRealtimeStopTyping)), this.registrationRequested = !1);
  }
  async unregisterRealtime(t = !1) {
    !this.registrationRequested && this.appId && this.userId && (!t && await this.whenWeavyContext, this.weavy?.unsubscribe(`a${this.appId}`, "typing", this.handleRealtimeTyping), this.weavy?.unsubscribe(`a${this.appId}`, "message_created", this.handleRealtimeStopTyping));
  }
  /**
   * @fires typing
   */
  updateTyping() {
    this.typingTimeout && (clearTimeout(this.typingTimeout), this.typingTimeout = null);
    const t = Date.now();
    if (this.typingMembers.forEach((i, s) => {
      t - i.time > this.discardTime && this.typingMembers.splice(s, 1);
    }), this.typingMembers.length) {
      const i = Date.now(), s = Math.round(
        (i - Math.max.apply(
          null,
          this.typingMembers.map((r) => r.time)
        )) / 1e3
      ) % 3 + 1;
      this.ellipsis = ".".repeat(s), this.names = this.typingMembers.map((r) => r.name).sort(), this.typingTimeout = window.setTimeout(() => this.updateTyping(), 1e3);
    } else
      this.names = [];
    this.host.requestUpdate();
    const e = new CustomEvent("typing", {
      bubbles: !0,
      composed: !1,
      detail: { count: this.typingMembers.length }
    });
    this.host.dispatchEvent(e);
  }
  setTypers(t) {
    this.typingMembers.forEach((i, s) => {
      i.id === t.id && this.typingMembers.splice(s, 1);
    });
    const e = { ...t, time: Date.now() };
    this.typingMembers.push(e);
  }
  hostDisconnected() {
    this.typingTimeout && (clearTimeout(this.typingTimeout), this.typingTimeout = null), this.typingMembers.length = 0, this.names.length = 0, this.weavy && this.unregisterRealtime(!0);
  }
}, c(jp, "cw"), jp);
d(tI, "TypingController");
let eI = tI;
var Hg, Bp;
const iI = (Bp = class {
  constructor(t) {
    Z(this, Hg), this.appTypes = [], _(this, Hg, 0), this.registrationRequested = !1, this.handleRefresh = () => {
      this.unreadQuery.result.refetch();
    }, t.addController(this), this.host = t, this.unreadQuery = new gn(t), this.whenWeavyContext = new Promise((e) => this.resolveWeavyContext = e), this.setContexts(), this.registerRealtime();
  }
  /**
   * The number of unread items for the current scope
   */
  get unread() {
    return $(this, Hg);
  }
  /**
   * Is the unread count pending?
   */
  get isUnreadPending() {
    return this.unreadQuery.result.isPending;
  }
  /**
   * The underlying query result for the unread count.
   */
  get unreadResult() {
    return this.unreadQuery.result;
  }
  get weavy() {
    return this.weavyContext?.value;
  }
  /**
   * Initiates context consumers
   */
  async setContexts() {
    await gs(this.host), this.weavyContext = new un(this.host, { context: Me, subscribe: !0 });
  }
  /**
   * Dispatch a `wy-unread` event on the host.
   *
   * @fires {WyUnreadEventType} wy-unread - Emitted when the number of unread items change.
   */
  dispatchUnreadEvent() {
    const t = new CustomEvent("wy-unread", {
      detail: { unread: this.unread },
      bubbles: !1,
      composed: !0
    });
    this.host.dispatchEvent(t);
  }
  /**
   * Register realtime handlers.
   */
  async registerRealtime() {
    this.registrationRequested || (this.registrationRequested = !0, await this.whenWeavyContext, this.weavy?.subscribe(null, "message_created", this.handleRefresh), this.weavy?.subscribe(null, "app_marked", this.handleRefresh), this.registrationRequested = !1);
  }
  /**
   * Unregister realtime handlers.
   *
   * @param skipAwait - Skip waiting for any context.
   */
  async unregisterRealtime(t = !1) {
    this.registrationRequested || (!t && await this.whenWeavyContext, this.weavy?.unsubscribe(null, "message_created", this.handleRefresh), this.weavy?.unsubscribe(null, "app_marked", this.handleRefresh));
  }
  async track(t, e) {
    this.appTypes = t, this.agent = e;
    const i = await this.whenWeavyContext;
    await this.unreadQuery.trackQuery(zL(i, t, this.agent), !0);
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
    const t = this.unreadQuery.result?.data?.count ?? 0;
    t !== this.unread && (_(this, Hg, t), this.dispatchUnreadEvent(), this.host.requestUpdate());
  }
  hostDisconnected() {
    this.weavy && this.unregisterRealtime(!0);
  }
}, c(Bp, "lw"), Bp);
Hg = /* @__PURE__ */ new WeakMap(), d(iI, "UnreadConversationsController");
let $0 = iI;
var qt = /* @__PURE__ */ ((n) => (n.All = "", n.Activity = "activity", n.Mention = "mention", n.Reaction = "reaction", n))(qt || {});
function nI(n, t, e = {}, i) {
  if (n) {
    if (n = JSON.parse(JSON.stringify(n)), n?.pages) {
      let s = -1;
      return {
        pages: [...n.pages.map((r, a) => {
          if (s >= 0)
            return r;
          const o = r.data || [], l = o.filter(
            (h) => h.id !== t.id && !0
          );
          return e && e.by ? (s = l.findIndex((h) => {
            let u = e.by && h[e.by], p = e.by && t[e.by];
            if (e.by === "updated_at" && (u ??= h.created_at, p ??= t.created_at), typeof u == "string" && typeof p == "string") {
              const y = u.localeCompare(p, void 0, {
                sensitivity: "base",
                numeric: !0
              });
              return e.descending ? y < 0 : y > 0;
            }
            return u && p && (e.descending ? u < p : u > p);
          }), s >= 0 ? (l.splice(s, 0, t), r.data = [...l], r.end && (r.end += 1 + l.length - o.length)) : n && a == n.pages.length - 1 && r.end === r.count ? (r.data = [...l, t], r.end && (r.end += 1 + l.length - o.length)) : r.data = [...l]) : a === 0 && (e.descending ? r.data = [t, ...l] : r.data = [...l, t], r.end && (r.end += 1 + l.length - o.length)), r;
        }) ?? []],
        pageParams: [...n.pageParams]
      };
    } else if (n?.data?.length) {
      let s = -1;
      const r = [
        ...n.data?.filter(
          (o) => o.id !== t.id && !0
        ) || []
      ];
      let a = n.count;
      return e && e.by ? (s = r.findIndex((o) => {
        let l = o[e.by], h = t[e.by];
        if (e.by === "updated_at" && (l ??= o.created_at, h ??= t.created_at), typeof l == "string" && typeof h == "string") {
          const u = l.localeCompare(h, void 0, {
            sensitivity: "base",
            numeric: !0
          });
          return e.descending ? u < 0 : u > 0;
        }
        return l && h && (e.descending ? l < h : l > h);
      }), s >= 0 ? r.splice(s, 0, t) : (r.push(t), a++)) : (e.descending ? r.unshift(t) : r.push(t), a++), {
        data: r,
        count: a
      };
    }
  }
  return n;
}
c(nI, "P0");
d(nI, "addToQueryData");
function n4(n, t, e) {
  const i = t === void 0 ? () => !0 : t instanceof Function ? t : (s) => s.id === t;
  return n && (n = JSON.parse(JSON.stringify(n)), n.pages ? {
    pages: n.pages.map((s) => (s.data && (s.data = [
      ...s.data.map((r) => (i(r) && (r = { ...r }, e(r)), r))
    ]), s)) ?? [],
    pageParams: n.pageParams
  } : n.data?.length ? {
    ...n,
    data: [
      ...n.data?.map((s) => (i(s) && (s = { ...s }, e(s)), s)) || []
    ]
  } : n.data ? {
    data: [
      ...n.data.map((s) => (i(s) && (s = { ...s }, e(s)), s))
    ],
    count: n.count
  } : n);
}
c(n4, "Mm");
d(n4, "updateQueryData");
function s4(n, t) {
  if (t !== void 0) {
    const e = t instanceof Function ? t : (i) => i.id === t;
    if (n) {
      if (n = JSON.parse(JSON.stringify(n)), n.pages)
        return {
          pages: n.pages.map((i) => (i.data && (i.data = [...i.data.filter((s) => !e(s))]), i)) ?? [],
          pageParams: n.pageParams
        };
      if (n.data?.length) {
        const i = n.data?.length;
        let s = n.count;
        const r = [...n.data?.filter((a) => !e(a)) || []];
        return i !== r.length && s--, {
          data: r,
          count: s
        };
      }
    }
  }
  return n;
}
c(s4, "Sm");
d(s4, "removeQueryData");
const ra = /* @__PURE__ */ d((n, t, e, i) => n.setQueryData(t, (s) => nI(s, e, i)), "addCacheItem"), ge = /* @__PURE__ */ d((n, t, e, i) => n.setQueryData(t, (s) => n4(
  s,
  e,
  i
)), "updateCacheItem"), Ct = /* @__PURE__ */ d((n, t, e, i) => {
  n.setQueriesData(t, (s) => n4(
    s,
    e,
    i
  ));
}, "updateCacheItems"), x0 = /* @__PURE__ */ d((n, t, e) => n.setQueryData(t, (i) => s4(
  i,
  e
)), "removeCacheItem"), BB = /* @__PURE__ */ d((n, t, e) => {
  n.setQueriesData(t, (i) => s4(i, e));
}, "removeCacheItems"), Ww = /* @__PURE__ */ d((n, t, e) => {
  n.setQueriesData(t, (i) => {
    const { count: s } = i;
    return { count: e(s) };
  });
}, "updateCacheItemsCount");
function Nv(n, t, e, i = 1) {
  if (!n)
    return;
  const s = n.getQueryData(t);
  s?.pages?.length && s.pages.length > 1 && n.setQueryData(
    t,
    (r) => ({
      pages: r.pages.slice(0, i),
      pageParams: r.pageParams.slice(0, i)
    }),
    e
  );
}
c(Nv, "Ep");
d(Nv, "keepPages");
function aa(n, t, e) {
  const i = n.getQueryCache().find({ queryKey: t });
  if (i && i.state.data) {
    const s = i.state.data.pages.flatMap((r) => r.data).filter((r) => r && r.id < 0).sort((r, a) => r && a ? r.id - a.id : 0);
    return s.length ? e ? s[s.length - 1] : s[0] : null;
  }
  return null;
}
c(aa, "gs");
d(aa, "getPendingCacheItem");
function w1(n, t, e) {
  const i = n.getQueryCache().find({ queryKey: t });
  return i && i.state.data ? i.state.data.pages.flatMap((s) => s.data).find((s) => s?.id === e) : null;
}
c(w1, "mh");
d(w1, "getCacheItem");
function cs(n) {
  return (n?.pages.flatMap((t) => t.data) || []).filter((t) => t);
}
c(cs, "Zi");
d(cs, "getFlatInfiniteResultData");
function hS(n) {
  return !n || !n?.pages.some((t) => t.data?.length);
}
c(hS, "qw");
d(hS, "isInfiniteResultDataEmpty");
function sI(n, t = qt.All, e, i = {}) {
  return {
    ...i,
    initialPageParam: 0,
    queryKey: ["notifications", "list", e, t],
    queryFn: /* @__PURE__ */ d(async (s) => {
      const r = new URLSearchParams({
        skip: s.pageParam?.toString() || "0",
        type: t
      }), a = `/api/${e ? `apps/${e.toString()}/` : ""}notifications?${r.toString()}`, o = await (await n.fetch(a)).json();
      return o.data = o.data || [], o;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ d((s) => {
      if (s.end && s.end < s.count)
        return s.end;
    }, "getNextPageParam")
  };
}
c(sI, "S0");
d(sI, "getNotificationsOptions");
function rI(n, t = qt.All, e) {
  const i = n.queryClient.getQueryData(["notifications", "list", e, t])?.pages.flatMap((r) => r.data);
  let s;
  return i?.forEach((r) => {
    s = s && r && s.id > r.id ? s : r;
  }), s;
}
c(rI, "A0");
d(rI, "getLastNotification");
function aI(n, t) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ notificationId: e }) => {
      const i = new URL(`/api/${t ? `apps/${t.toString()}/` : ""}notifications/mark`, n.url);
      e && i.searchParams.append("id", e.toString()), await n.fetch(i, { method: "PUT" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((e) => {
      const i = [];
      return Ct(
        n.queryClient,
        { queryKey: t ? ["notifications", "list", t] : ["notifications", "list"], exact: !1 },
        void 0,
        (s) => {
          i.push({ id: s.id, is_unread: s.is_unread }), s.is_unread = !1;
        }
      ), t && i.length && Ct(
        n.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        (s) => !!i.find((r) => r.id === s.id && s.is_unread),
        (s) => {
          s.is_unread = !1;
        }
      ), t || Ww(
        n.queryClient,
        { queryKey: ["notifications", "unread"], exact: !1 },
        () => 0
      ), Ww(
        n.queryClient,
        {
          queryKey: t ? ["apps", "notifications", "unread", t] : ["apps", "notifications", "unread"],
          exact: !1
        },
        () => 0
      ), { changedNotifications: i };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d(async () => {
      t && await n.queryClient.invalidateQueries({ queryKey: ["notifications", "unread"], exact: !1 });
    }, "onSuccess"),
    onSettled: /* @__PURE__ */ d(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["notifications", "list"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["notifications", "unread"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["apps", "notifications", "unread"], exact: !1 });
    }, "onSettled"),
    onError: /* @__PURE__ */ d((e, i, s) => {
      console.error(e.message);
    }, "onError")
  };
}
c(aI, "z0");
d(aI, "getMarkNotificationsMutationOptions");
function oI(n, t) {
  return new Xt(n.queryClient, aI(n, t));
}
c(oI, "R0");
d(oI, "getMarkNotificationsMutation");
function lI(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ markAsRead: t, notificationId: e }) => {
      const i = `/api/notifications/${e}/mark`;
      await n.fetch(i, { method: t ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((t) => {
      const e = /* @__PURE__ */ new Map();
      Ct(
        n.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        t.notificationId,
        (i) => {
          !!i.is_unread === t.markAsRead && e.set(i.id, i), i.is_unread = !t.markAsRead;
        }
      ), e.size && (Ww(
        n.queryClient,
        {
          queryKey: ["notifications", "unread"],
          predicate: /* @__PURE__ */ d((i) => i.queryKey[3] === "" || i.queryKey[3] === e.values().next().value?.type, "predicate"),
          exact: !1
        },
        (i) => Math.max(0, i + (t.markAsRead ? -1 : 1))
      ), e.forEach((i) => {
        i.link?.app && Ww(
          n.queryClient,
          {
            queryKey: ["apps", "notifications", "unread"],
            predicate: /* @__PURE__ */ d((s) => {
              const r = s.queryKey[3] === i.link?.app?.id || s.queryKey[3] === i.link?.app?.uid, a = s.queryKey[4] === "" || s.queryKey[4] === i.type;
              return r && a;
            }, "predicate"),
            exact: !1
          },
          (s) => Math.max(0, s + (t.markAsRead ? -1 : 1))
        );
      }));
    }, "onMutate"),
    onError: /* @__PURE__ */ d(async (t, e) => {
      Ct(
        n.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        e.notificationId,
        (i) => {
          i.is_unread = e.markAsRead;
        }
      ), await n.queryClient.invalidateQueries({ queryKey: ["notifications", "unread"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["apps", "notifications", "unread"], exact: !1 });
    }, "onError")
  };
}
c(lI, "E0");
d(lI, "getMarkNotificationMutationOptions");
function r4(n) {
  return new Xt(n.queryClient, lI(n));
}
c(r4, "Am");
d(r4, "getMarkNotificationMutation");
function cI(n, t = qt.All, e, i = {}) {
  const s = new URLSearchParams({
    type: t,
    count_only: "true",
    unread: "true"
  }), r = `/api/${e ? `apps/${e.toString()}/` : ""}notifications?${s.toString()}`;
  return Qm(n, e ? ["apps", "notifications", "unread", e, t] : ["notifications", "unread", t], r, i);
}
c(cI, "L0");
d(cI, "getUnreadOptions");
var Yg, Up;
const hI = (Up = class {
  constructor(t) {
    Z(this, Yg), this.typeFilter = qt.All, _(this, Yg, 0), this.registrationRequested = !1, this.handleRefresh = () => {
      this.unreadQuery.result.refetch();
    }, t.addController(this), this.host = t, this.unreadQuery = new gn(t), this.whenWeavyContext = new Promise((e) => this.resolveWeavyContext = e), this.setContexts(), this.registerRealtime();
  }
  /**
   * The number of unread notifications for the current scope
   */
  get unread() {
    return $(this, Yg);
  }
  /**
   * Is the unread count pending?
   */
  get isUnreadPending() {
    return this.unreadQuery.result.isPending;
  }
  /**
   * The underlying query result for the unread count.
   */
  get unreadResult() {
    return this.unreadQuery.result;
  }
  get weavy() {
    return this.weavyContext?.value;
  }
  /**
   * Initiates context consumers
   */
  async setContexts() {
    await gs(this.host), this.weavyContext = new un(this.host, { context: Me, subscribe: !0 });
  }
  /**
   * Dispatch a `wy-unread` event on the host.
   *
   * @fires {WyUnreadEventType} wy-unread - Emitted when the number of unread notifications change.
   */
  dispatchNotificationUnreadEvent() {
    const t = new CustomEvent("wy-unread", {
      detail: { unread: this.unread },
      bubbles: !1,
      composed: !0
    });
    this.host.dispatchEvent(t);
  }
  /**
   * Register realtime handlers.
   */
  async registerRealtime() {
    this.registrationRequested || (this.registrationRequested = !0, await this.whenWeavyContext, this.weavy?.subscribe(null, "notification_created", this.handleRefresh), this.weavy?.subscribe(null, "notification_updated", this.handleRefresh), this.weavy?.subscribe(null, "notifications_marked", this.handleRefresh), this.registrationRequested = !1);
  }
  /**
   * Unregister realtime handlers.
   *
   * @param skipAwait - Skip waiting for any context.
   */
  async unregisterRealtime(t = !1) {
    this.registrationRequested || (!t && await this.whenWeavyContext, this.weavy?.unsubscribe(null, "notification_created", this.handleRefresh), this.weavy?.unsubscribe(null, "notification_updated", this.handleRefresh), this.weavy?.unsubscribe(null, "notifications_marked", this.handleRefresh));
  }
  /**
   * Tracks unread data. Initiates the query data with the given filtering scope.
   *
   * @param typeFilter - The notification types to track.
   * @param appId - Optional app id for the filtering scope.
   */
  async track(t, e) {
    this.appId = e, this.typeFilter = t;
    const i = await this.whenWeavyContext;
    this.markNotificationsMutation = oI(i, this.appId), await this.unreadQuery.trackQuery(cI(i, this.typeFilter, this.appId), !0);
  }
  async markAllAsRead() {
    const t = await this.whenWeavyContext, e = rI(t, qt.All, this.appId)?.id;
    await this.markNotificationsMutation?.mutate({ notificationId: e });
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
    const t = this.unreadQuery.result?.data?.count ?? 0;
    t !== this.unread && (_(this, Yg, t), this.dispatchNotificationUnreadEvent(), this.host.requestUpdate());
  }
  hostDisconnected() {
    this.weavy && this.unregisterRealtime(!0);
  }
}, c(Up, "dw"), Up);
Yg = /* @__PURE__ */ new WeakMap(), d(hI, "UnreadNotificationsController");
let a4 = hI;
var UB = Object.defineProperty, dI = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = void 0, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = a(t, e, s) || s);
  return s && UB(t, e, s), s;
}, "__decorateClass$1g"), Hp;
const uI = (Hp = class extends _i {
  constructor() {
    super(...arguments), this.appType = _r;
  }
}, c(Hp, "hw"), Hp);
d(uI, "WeavyOptionalAppComponent");
let Mm = uI;
dI([
  F()
], Mm.prototype, "appType");
dI([
  O({ converter: NP })
], Mm.prototype, "uid");
var HB = Object.defineProperty, o4 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = void 0, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = a(t, e, s) || s);
  return s && HB(t, e, s), s;
}, "__decorateClass$1f"), Gg, jv, Kg, Bv, Jg, Uv, Yp;
const pI = (Yp = class extends pt {
  constructor() {
    super(...arguments), Z(this, Gg), Z(this, jv, new Promise((t) => {
      _(this, Gg, t);
    })), Z(this, Kg), Z(this, Bv, new Promise((t) => {
      _(this, Kg, t);
    })), Z(this, Jg), Z(this, Uv, new Promise((t) => {
      _(this, Jg, t);
    }));
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  /**
   * Resolves when a contextual id is available.
   *
   * @internal
   * @returns {Promise<ContextIdType>}
   */
  async whenContextId() {
    return await $(this, jv);
  }
  /**
   * Resolves when current user data is available.
   *
   * @internal
   * @returns {Promise<UserType>}
   */
  async whenUser() {
    return await $(this, Bv);
  }
  /**
   * Resolves when a weavy context is available.
   *
   * @internal
   * @returns {Promise<WeavyType>}
   */
  async whenWeavy() {
    return await $(this, Uv);
  }
  willUpdate(t) {
    var e, i, s;
    super.willUpdate(t), t.has("contextId") && this.contextId && (t.get("contextId") && _(this, jv, new Promise((r) => {
      _(this, Gg, r);
    })), (e = $(this, Gg)) == null || e.call(this, this.contextId)), t.has("user") && this.user && (t.get("user") && _(this, Bv, new Promise((r) => {
      _(this, Kg, r);
    })), (i = $(this, Kg)) == null || i.call(this, this.user)), t.has("weavy") && this.weavy && (t.get("weavy") && _(this, Uv, new Promise((r) => {
      _(this, Jg, r);
    })), (s = $(this, Jg)) == null || s.call(this, this.weavy));
  }
  connectedCallback() {
    super.connectedCallback(), this.contextId && this.requestUpdate("contextId"), this.user && this.requestUpdate("user"), this.weavy && this.requestUpdate("weavy");
  }
}, c(Yp, "pw"), Yp);
Gg = /* @__PURE__ */ new WeakMap(), jv = /* @__PURE__ */ new WeakMap(), Kg = /* @__PURE__ */ new WeakMap(), Bv = /* @__PURE__ */ new WeakMap(), Jg = /* @__PURE__ */ new WeakMap(), Uv = /* @__PURE__ */ new WeakMap(), d(pI, "WeavySubComponent");
let zi = pI;
o4([
  Ve({ context: tL, subscribe: !0 }),
  F()
], zi.prototype, "contextId");
o4([
  Ve({ context: p0, subscribe: !0 }),
  F()
], zi.prototype, "user");
o4([
  Ve({ context: Me, subscribe: !0 }),
  F()
], zi.prototype, "weavy");
var YB = Object.defineProperty, v1 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = void 0, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = a(t, e, s) || s);
  return s && YB(t, e, s), s;
}, "__decorateClass$1e"), tw, Hv, ew, Yv, iw, Gv, nw, Kv, sw, Jv, Gp;
const fI = (Gp = class extends zi {
  constructor() {
    super(...arguments), Z(this, tw), Z(this, Hv, new Promise((t) => {
      _(this, tw, t);
    })), Z(this, ew), Z(this, Yv, new Promise((t) => {
      _(this, ew, t);
    })), Z(this, iw), Z(this, Gv, new Promise((t) => {
      _(this, iw, t);
    })), Z(this, nw), Z(this, Kv, new Promise((t) => {
      _(this, nw, t);
    })), Z(this, sw), Z(this, Jv, new Promise((t) => {
      _(this, sw, t);
    }));
  }
  // PROMISES
  // TODO: Switch to Promise.withResolvers() when allowed by typescript
  /**
   * Resolves when app data is available.
   *
   * @returns {Promise<AppType>}
   */
  async whenApp() {
    return await $(this, Hv);
  }
  // #resolveAgentUser?: (agentUser: AgentType) => void;
  // #whenAgentUser = new Promise<AgentType>((r) => {
  //   this.#resolveAgentUser = r;
  // });
  // async whenAgentUser() {
  //   return await this.#whenAgentUser;
  // }
  /**
   * Resolves when context data blob uploads has finished.
   *
   * @internal
   * @returns {Promise<ContextDataBlobsType>}
   */
  async whenContextDataBlobs() {
    return await $(this, Yv);
  }
  /**
   * Resolves when weavy component features config is available.
   *
   * @internal
   * @returns {Promise<ComponentFeaturePolicy>}
   */
  async whenComponentFeatures() {
    return await $(this, Gv);
  }
  /**
   * Resolves when a provided link is available.
   *
   * @returns {Promise<LinkType>}
   */
  async whenLink() {
    return await $(this, Kv);
  }
  /**
   * Resolves when weavy component settings are available.
   *
   * @internal
   * @returns {Promise<WeavyComponentSettingsType>}
   */
  async whenSettings() {
    return await $(this, Jv);
  }
  willUpdate(t) {
    var e, i, s, r, a;
    super.willUpdate(t), t.has("app") && this.app && (t.get("app") && _(this, Hv, new Promise((o) => {
      _(this, tw, o);
    })), (e = $(this, tw)) == null || e.call(this, this.app)), t.has("contextDataBlobs") && this.contextDataBlobs && (t.get("contextDataBlobs") && _(this, Yv, new Promise((o) => {
      _(this, ew, o);
    })), (i = $(this, ew)) == null || i.call(this, this.contextDataBlobs)), t.has("componentFeatures") && this.componentFeatures && (t.get("componentFeatures") && _(this, Gv, new Promise((o) => {
      _(this, iw, o);
    })), (s = $(this, iw)) == null || s.call(this, this.componentFeatures)), t.has("link") && this.link && (t.get("link") && _(this, Kv, new Promise((o) => {
      _(this, nw, o);
    })), (r = $(this, nw)) == null || r.call(this, this.link)), t.has("settings") && this.settings && (t.get("settings") && _(this, Jv, new Promise((o) => {
      _(this, sw, o);
    })), (a = $(this, sw)) == null || a.call(this, this.settings));
  }
  connectedCallback() {
    super.connectedCallback(), this.app && this.requestUpdate("app"), this.contextDataBlobs && this.requestUpdate("contextDataBlobs"), this.componentFeatures && this.requestUpdate("componentFeatures"), this.link && this.requestUpdate("link"), this.settings && this.requestUpdate("settings");
  }
}, c(Gp, "uw"), Gp);
tw = /* @__PURE__ */ new WeakMap(), Hv = /* @__PURE__ */ new WeakMap(), ew = /* @__PURE__ */ new WeakMap(), Yv = /* @__PURE__ */ new WeakMap(), iw = /* @__PURE__ */ new WeakMap(), Gv = /* @__PURE__ */ new WeakMap(), nw = /* @__PURE__ */ new WeakMap(), Kv = /* @__PURE__ */ new WeakMap(), sw = /* @__PURE__ */ new WeakMap(), Jv = /* @__PURE__ */ new WeakMap(), d(fI, "WeavySubAppComponent");
let Oe = fI;
v1([
  Ve({ context: FP, subscribe: !0 }),
  F()
], Oe.prototype, "app");
v1([
  Ve({ context: eL, subscribe: !0 }),
  F()
], Oe.prototype, "contextDataBlobs");
v1([
  Ve({ context: d0, subscribe: !0 }),
  F()
], Oe.prototype, "componentFeatures");
v1([
  Ve({ context: nL, subscribe: !0 }),
  F()
], Oe.prototype, "link");
v1([
  Ve({ context: rL, subscribe: !0 }),
  F()
], Oe.prototype, "settings");
function yI(n) {
  return typeof n == "string" && n ? n = eval?.(`"use strict";(${n})`) : n = void 0, n;
}
c(yI, "F0");
d(yI, "indirectEvalObject");
function k0(n) {
  if (n)
    try {
      return new URL(n, window.location.toString());
    } catch {
      console.warn("Invalid url: ", n);
    }
}
c(k0, "iy");
d(k0, "toUrl");
const U = /* @__PURE__ */ d((n) => (t, e) => {
  e !== void 0 ? e.addInitializer(() => {
    !customElements.get(n) && customElements.define(
      n,
      t
    );
  }) : !customElements.get(n) && customElements.define(n, t);
}, "customElement"), ft = et`:host{display:contents}`;
var GB = Object.defineProperty, KB = Object.getOwnPropertyDescriptor, De = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? KB(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && GB(t, e, s), s;
}, "__decorateClass$1d");
function dS(n) {
  return n != null && n !== !1;
}
c(dS, "Nw");
d(dS, "acceptedValue");
var u$, Kp;
let ce = (u$ = (Kp = class extends pt {
  constructor() {
    super(), this.provider = !1, this.annotations = Se.defaults.annotations, this.cloudFilePickerUrl = Se.defaults.cloudFilePickerUrl, this.configurationTimeout = Se.defaults.configurationTimeout, this.disableEnvironmentImports = Se.defaults.disableEnvironmentImports, this.enterToSend = Se.defaults.enterToSend, this.locale = Se.defaults.locale, this.locales = Se.defaults.locales, this.gcTime = Se.defaults.gcTime, this.scrollBehavior = Se.defaults.scrollBehavior, this.staleTime = Se.defaults.staleTime, this.tokenFactory = Se.defaults.tokenFactory, this.tokenFactoryRetryDelay = Se.defaults.tokenFactoryRetryDelay, this.tokenFactoryTimeout = Se.defaults.tokenFactoryTimeout, this.tokenUrl = Se.defaults.tokenUrl, this.url = Se.defaults.url, this.reactions = Se.defaults.reactions, this.childElementCount && (this.provider = !0), this.weavy ??= new Se({ host: this.provider ? this : void 0 });
  }
  /** The semver version of the package. */
  get version() {
    return Se.version;
  }
  /** The Weavy source name; package name. */
  get sourceName() {
    return Se.sourceName;
  }
  willUpdate(t) {
    if (super.willUpdate(t), this.weavy) {
      const e = {};
      Array.from(t.keys()).forEach((i) => {
        i !== "weavy" && (dS(this[i]) || dS(t.get(i))) && Object.assign(e, { [i]: this[i] });
      }), Object.assign(this.weavy, e);
    }
  }
  render() {
    return v` <slot></slot> `;
  }
}, c(Kp, "ka"), Kp), d(u$, "WyContext"), u$);
ce.styles = [Te, ft];
De([
  O({ attribute: !0, type: Boolean })
], ce.prototype, "provider", 2);
De([
  O()
], ce.prototype, "annotations", 2);
De([
  O({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ d((n) => k0(n), "fromAttribute")
    }
  })
], ce.prototype, "cloudFilePickerUrl", 2);
De([
  O({ type: Number, attribute: !0 })
], ce.prototype, "configurationTimeout", 2);
De([
  O({ type: Boolean })
], ce.prototype, "disableEnvironmentImports", 2);
De([
  O({ attribute: !0 })
], ce.prototype, "enterToSend", 2);
De([
  O({ attribute: !0 })
], ce.prototype, "locale", 2);
De([
  O({ attribute: !0, type: Array })
], ce.prototype, "locales", 2);
De([
  O({ attribute: !0, type: Number })
], ce.prototype, "gcTime", 2);
De([
  O({ attribute: !0 })
], ce.prototype, "scrollBehavior", 2);
De([
  O({ attribute: !0, type: Number })
], ce.prototype, "staleTime", 2);
De([
  O({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ d((n) => yI(n), "fromAttribute")
    }
  })
], ce.prototype, "tokenFactory", 2);
De([
  O({ attribute: !0, type: Number })
], ce.prototype, "tokenFactoryRetryDelay", 2);
De([
  O({ attribute: !0, type: Number })
], ce.prototype, "tokenFactoryTimeout", 2);
De([
  O({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ d((n) => k0(n), "fromAttribute")
    }
  })
], ce.prototype, "tokenUrl", 2);
De([
  O({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ d((n) => k0(n), "fromAttribute")
    }
  })
], ce.prototype, "url", 2);
De([
  O({ attribute: !0 })
], ce.prototype, "reactions", 2);
De([
  F()
], ce.prototype, "weavy", 2);
ce = De([
  U("wy-context")
], ce);
const bi = et`:host{font-family:var(--wy-font-family, unset)}`;
var JB = Object.defineProperty, tU = Object.getOwnPropertyDescriptor, l4 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? tU(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && JB(t, e, s), s;
}, "__decorateClass$1c"), p$, Jp;
let al = (p$ = (Jp = class extends _i {
  constructor() {
    super(...arguments), this.appType = _r, this.componentFeatures = new ni(u0(oS)), this.theme = new wn(this, al.styles);
  }
  render() {
    return v`<slot></slot>`;
  }
}, c(Jp, "_a"), Jp), d(p$, "WyComponent"), p$);
al.styles = [Te, ft, bi];
l4([
  O({
    converter: {
      fromAttribute(n, t) {
        return IB.get(n) ?? n;
      }
    }
  })
], al.prototype, "appType", 2);
l4([
  O({
    converter: {
      fromAttribute(n, t) {
        const e = typeof n == "string" ? XP(n, oS) : oS;
        return new ni(u0(e));
      }
    }
  })
], al.prototype, "componentFeatures", 2);
al = l4([
  U("wy-component")
], al);
const ws = et`:host{position:relative;display:flex;flex-direction:column;flex:1;min-height:3rem;min-width:16rem;isolation:isolate;box-sizing:border-box;container-type:inline-size}`, _l = et`:host{padding:var(--wy-padding-outer, var(--wy-padding, 0));border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}`, zl = et`:host{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}:host:not(body){-webkit-overflow-scrolling:touch}`;
function mI(n, t, e = {}) {
  return {
    ...e,
    initialPageParam: 0,
    queryKey: ["messages", t],
    queryFn: /* @__PURE__ */ d(async (i) => {
      const s = i.pageParam, r = "/api/apps/" + t + "/messages?order_by=id+desc&skip=" + s, a = await (await n.fetch(r)).json();
      return a.data = a.data?.reverse() || [], a;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ d((i) => {
      if (i?.end && i?.end < i?.count)
        return i.end;
    }, "getNextPageParam"),
    select: /* @__PURE__ */ d((i) => ({
      // reverse scroll
      pages: [...i.pages].reverse(),
      pageParams: [...i.pageParams].reverse()
    }), "select")
  };
}
c(mI, "B0");
d(mI, "getMessagesOptions");
function gI(n, t) {
  return {
    mutationFn: /* @__PURE__ */ d(async (e) => await (await n.fetch("/api/apps/" + e.app_id + "/messages", {
      method: "POST",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        embed_id: e.embed_id || null,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ text: i.text })),
        metadata: e.metadata || null,
        context: e.context
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ d((e) => {
      const i = ["messages", e.app_id], s = aa(n.queryClient, i, !1), r = {
        id: s ? s.id - 1 : -1,
        app: { id: e.app_id },
        text: e.text,
        html: e.text,
        plain: e.text,
        created_by: e.user,
        created_at: (/* @__PURE__ */ new Date()).toUTCString(),
        attachments: { count: 0 },
        reactions: { count: 0 },
        is_starred: !1,
        is_subscribed: !0,
        is_trashed: !1
      };
      ra(n.queryClient, i, r);
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((e) => {
      Ct(
        n.queryClient,
        { queryKey: ["members", e.app.id] },
        e.created_by.id,
        (l) => {
          l.marked_id = e.id, l.marked_at = e.created_at;
        }
      );
      const i = ["messages", e.app.id], { queryClient: s } = n, r = w1(s, i, e.id), a = r ? null : aa(s, i, !0), o = /* @__PURE__ */ d((l, h) => {
        ge(s, i, l, (u) => {
          u.id = h.id, u.app = h.app, u.text = h.text, u.plain = h.plain, u.html = h.html, u.embed = h.embed, u.meeting = h.meeting, u.attachments = h.attachments, u.options = h.options, u.created_at = h.created_at, u.created_by = h.created_by, u.updated_at = h.updated_at, u.updated_by = h.updated_by;
        });
      }, "replaceCacheItem");
      r ? o(r.id, e) : a ? o(a.id, e) : ra(s, i, e);
    }, "onSuccess")
  };
}
c(gI, "q0");
d(gI, "getAddMessageMutationOptions");
const { I: eU } = _j, iU = /* @__PURE__ */ d((n) => n.strings === void 0, "f$1"), l9 = /* @__PURE__ */ d(() => document.createComment(""), "r$1"), pg = /* @__PURE__ */ d((n, t, e) => {
  const i = n._$AA.parentNode, s = t === void 0 ? n._$AB : t._$AA;
  if (e === void 0) {
    const r = i.insertBefore(l9(), s), a = i.insertBefore(l9(), s);
    e = new eU(r, a, n, n.options);
  } else {
    const r = e._$AB.nextSibling, a = e._$AM, o = a !== n;
    if (o) {
      let l;
      e._$AQ?.(n), e._$AM = n, e._$AP !== void 0 && (l = n._$AU) !== a._$AU && e._$AP(l);
    }
    if (r !== s || o) {
      let l = e._$AA;
      for (; l !== r; ) {
        const h = l.nextSibling;
        i.insertBefore(l, s), l = h;
      }
    }
  }
  return e;
}, "s$1"), Fa = /* @__PURE__ */ d((n, t, e = n) => (n._$AI(t, e), n), "v"), nU = {}, wI = /* @__PURE__ */ d((n, t = nU) => n._$AH = t, "m"), sU = /* @__PURE__ */ d((n) => n._$AH, "p"), f$ = /* @__PURE__ */ d((n) => {
  n._$AR(), n._$AA.remove();
}, "M"), O1 = { ATTRIBUTE: 1, CHILD: 2 }, Ll = /* @__PURE__ */ d((n) => (...t) => ({ _$litDirective$: n, values: t }), "e$2");
var y$, tf;
let Am = (y$ = (tf = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, i) {
    this._$Ct = t, this._$AM = e, this._$Ci = i;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
}, c(tf, "Pa"), tf), d(y$, "i"), y$);
const pw = /* @__PURE__ */ d((n, t) => {
  const e = n._$AN;
  if (e === void 0) return !1;
  for (const i of e) i._$AO?.(t, !1), pw(i, t);
  return !0;
}, "s"), fb = /* @__PURE__ */ d((n) => {
  let t, e;
  do {
    if ((t = n._$AM) === void 0) break;
    e = t._$AN, e.delete(n), n = t;
  } while (e?.size === 0);
}, "o$5"), vI = /* @__PURE__ */ d((n) => {
  for (let t; t = n._$AM; n = t) {
    let e = t._$AN;
    if (e === void 0) t._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(n)) break;
    e.add(n), rU(t);
  }
}, "r");
function OI(n) {
  this._$AN !== void 0 ? (fb(this), this._$AM = n, vI(this)) : this._$AM = n;
}
c(OI, "K0");
d(OI, "h$1");
function bI(n, t = !1, e = 0) {
  const i = this._$AH, s = this._$AN;
  if (s !== void 0 && s.size !== 0) if (t) if (Array.isArray(i)) for (let r = e; r < i.length; r++) pw(i[r], !1), fb(i[r]);
  else i != null && (pw(i, !1), fb(i));
  else pw(this, n);
}
c(bI, "G0");
d(bI, "n$2");
const rU = /* @__PURE__ */ d((n) => {
  n.type == O1.CHILD && (n._$AP ??= bI, n._$AQ ??= OI);
}, "c$1");
var ef;
const $I = (ef = class extends Am {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, e, i) {
    super._$AT(t, e, i), vI(this), this.isConnected = t._$AU;
  }
  _$AO(t, e = !0) {
    t !== this.isConnected && (this.isConnected = t, t ? this.reconnected?.() : this.disconnected?.()), e && (pw(this, t), fb(this));
  }
  setValue(t) {
    if (iU(this._$Ct)) this._$Ct._$AI(t, this);
    else {
      const e = [...this._$Ct._$AH];
      e[this._$Ci] = t, this._$Ct._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}, c(ef, "yw"), ef);
d($I, "f");
let aU = $I;
const wt = /* @__PURE__ */ d(() => new oU(), "e$1");
var nf;
const xI = (nf = class {
}, c(nf, "ww"), nf);
d(xI, "h");
let oU = xI;
const m$ = /* @__PURE__ */ new WeakMap(), ot = Ll(class extends aU {
  render(n) {
    return C;
  }
  update(n, [t]) {
    const e = t !== this.G;
    return e && this.G !== void 0 && this.rt(void 0), (e || this.lt !== this.ct) && (this.G = t, this.ht = n.options?.host, this.rt(this.ct = n.element)), C;
  }
  rt(n) {
    if (this.isConnected || (n = void 0), typeof this.G == "function") {
      const t = this.ht ?? globalThis;
      let e = m$.get(t);
      e === void 0 && (e = /* @__PURE__ */ new WeakMap(), m$.set(t, e)), e.get(this.G) !== void 0 && this.G.call(this.ht, void 0), e.set(this.G, n), n !== void 0 && this.G.call(this.ht, n);
    } else this.G.value = n;
  }
  get lt() {
    return typeof this.G == "function" ? m$.get(this.ht ?? globalThis)?.get(this.G) : this.G?.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
function kI(n, t, e) {
  const i = n.queryClient;
  return {
    mutationKey: ["apps", t, "polls"],
    mutationFn: /* @__PURE__ */ d(async ({ optionId: s }) => {
      const r = await n.fetch(`/api/options/${s}/vote`, { method: "POST" });
      if (!r.ok) {
        const a = await r.json();
        throw new Error(a.detail || a.title, { cause: a });
      }
      return await r.json();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => (Ct(i, { queryKey: e }, s.parentId, (r) => {
      r.options?.data && (r.options.data = r.options.data?.map((a) => {
        if (a.has_voted) {
          a.has_voted = !1;
          const o = a.votes?.count || 1;
          a.votes ? a.votes.count = o - 1 : a.votes = { count: o - 1 };
        } else if (!a.has_voted && a.id === s.optionId) {
          a.has_voted = !0;
          const o = a.votes?.count || 0;
          a.votes ? a.votes.count = o + 1 : a.votes = { count: o + 1 };
        }
        return a;
      }));
    }), { id: s.optionId }), "onMutate"),
    onSuccess: /* @__PURE__ */ d(async (s, r) => {
      const a = await (await n.fetch("/api/" + r.parentType + "/" + r.parentId)).json();
      Ct(
        i,
        { queryKey: e, exact: !1 },
        r.parentId,
        (o) => Object.assign(o, a)
      );
    }, "onSuccess")
    /*onError(error: Error, variables: MutatePollVariables) {
      updateCacheItems(queryClient, { queryKey: postsKey, exact: false }, variables.id, (existingPost: PostType) => Object.assign(existingPost, { is_subscribed: variables..is_subscribed }));
    },*/
  };
}
c(kI, "Y0");
d(kI, "getPollMutationOptions");
function S0(n, t, e) {
  return new Xt(n.queryClient, kI(n, t, e));
}
c(S0, "sy");
d(S0, "getPollMutation");
function SI(n, t) {
  return {
    queryKey: ["votes", t],
    enabled: !1,
    queryFn: /* @__PURE__ */ d(async () => await (await n.fetch(`/api/options/${t}`)).json(), "queryFn")
  };
}
c(SI, "X0");
d(SI, "getVotesOptions");
const lm = /* @__PURE__ */ d((n, t) => !!(n && t && t.indexOf(n) !== -1), "hasPermission");
function CI(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ app: t, messageId: e }) => {
      const i = e ? `/api/apps/${t.id}/mark?messageId=${e}` : `/api/apps/${t.id}/mark`;
      await n.fetch(i, { method: e ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d(async (t) => {
      await n.queryClient.cancelQueries({ queryKey: ["apps", t.app.id] }), await n.queryClient.cancelQueries({ queryKey: ["apps", "list"], exact: !1 }), await n.queryClient.cancelQueries({ queryKey: ["apps", "unread"], exact: !1 }), await n.queryClient.cancelQueries({ queryKey: ["members", t.app.id] }), n.queryClient.setQueryData(
        ["apps", t.app.id],
        (e) => e && { ...e, is_unread: !t.messageId || t.messageId < e.last_message.id }
      ), Ct(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.app.id,
        (e) => {
          e.is_unread = !t.messageId || t.messageId < e.last_message.id;
        }
      ), t.userId && Ct(n.queryClient, { queryKey: ["members", t.app.id] }, t.userId, (e) => {
        t.messageId ? (e.marked_at = (/* @__PURE__ */ new Date()).toISOString(), e.marked_id = t.messageId) : (e.marked_at = void 0, e.marked_id = void 0);
      }), Ww(
        n.queryClient,
        {
          queryKey: ["apps", "unread"],
          exact: !1,
          predicate: /* @__PURE__ */ d((e) => {
            const i = e.queryKey[2].includes(t.app.type), s = e.queryKey[2], r = !s || !!t.app.members.data?.find((a) => a.uid && a.uid === s);
            return i && r;
          }, "predicate")
        },
        (e) => Math.max(0, e + (t.messageId ? -1 : 1))
      );
    }, "onMutate"),
    onError: /* @__PURE__ */ d((t, e) => {
      console.error(t.message), Ct(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        e.app.id,
        (i) => {
          i.is_unread = !i.is_unread;
        }
      );
    }, "onError"),
    onSettled: /* @__PURE__ */ d(async (t, e, i) => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps", i.app.id] }), await n.queryClient.invalidateQueries({ queryKey: ["apps", "list"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["apps", "unread"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["members", i.app.id] });
    }, "onSettled")
  };
}
c(CI, "J0");
d(CI, "getMarkConversationMutationOptions");
function PI(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ appId: t, star: e }) => {
      await n.fetch(`/api/apps/${t}/stars`, { method: e ? "POST" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((t) => {
      Ct(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.appId,
        (e) => {
          e.is_starred = t.star;
        }
      );
    }, "onMutate"),
    onError: /* @__PURE__ */ d((t, e) => {
      console.error(t.message), Ct(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        e.appId,
        (i) => {
          i.is_starred = !e.star;
        }
      );
    }, "onError")
  };
}
c(PI, "tb");
d(PI, "getStarConversationMutationOptions");
function QI(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ appId: t, pin: e }) => {
      await n.fetch(`/api/apps/${t}/pin`, { method: e ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((t) => {
      Ct(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.appId,
        (e) => {
          e.is_pinned = t.pin;
        }
      );
    }, "onMutate"),
    onSettled: /* @__PURE__ */ d(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
c(QI, "eb");
d(QI, "getPinConversationMutationOptions");
function TI(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ appId: t, members: e }) => {
      await n.fetch(`/api/apps/${t}/members/${e.join(",")}`, { method: "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((t) => {
      x0(n.queryClient, ["apps", "list"], t.appId);
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((t, e) => {
      n.queryClient.removeQueries({ queryKey: ["apps", e.appId] }), n.queryClient.removeQueries({ queryKey: ["members", e.appId] });
    }, "onSuccess"),
    onSettled: /* @__PURE__ */ d(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] }), await n.queryClient.invalidateQueries({ queryKey: ["members"] });
    }, "onSettled")
  };
}
c(TI, "ib");
d(TI, "getLeaveConversationMutationOptions");
function MI(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ appId: t }) => {
      await n.fetch(`/api/apps/${t}/remove`, { method: "POST" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((t) => {
      x0(n.queryClient, ["apps", "list"], t.appId);
    }, "onMutate"),
    onSettled: /* @__PURE__ */ d(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
c(MI, "rb");
d(MI, "getRemoveConversationMutationOptions");
function AI(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ appId: t, userId: e, access: i }) => {
      await n.fetch(`/api/apps/${t}/members/${e}`, { method: "PUT", body: JSON.stringify({ access: i }) });
    }, "mutationFn"),
    onSettled: /* @__PURE__ */ d(async (t, e, i) => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] }), await n.queryClient.invalidateQueries({ queryKey: ["members", i.appId] });
    }, "onSettled")
  };
}
c(AI, "sb");
d(AI, "getUpdateMemberMutationOptions");
function RI(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ appId: t, members: e }) => {
      await n.fetch(`/api/apps/${t}/members`, {
        method: "PUT",
        body: JSON.stringify(
          e.map((i) => ({ id: i, access: "write" }))
        )
      });
    }, "mutationFn"),
    onSettled: /* @__PURE__ */ d(async (t, e, i) => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] }), await n.queryClient.invalidateQueries({ queryKey: ["members", i.appId] });
    }, "onSettled")
  };
}
c(RI, "nb");
d(RI, "getAddMembersToConversationMutationOptions");
function EI(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ appId: t, name: e, blobId: i }) => await (await n.fetch(`/api/apps/${t}`, {
      method: "PATCH",
      body: JSON.stringify({
        name: e,
        picture: i
      })
    })).json(), "mutationFn"),
    onMutate: /* @__PURE__ */ d((t) => {
      const e = /* @__PURE__ */ d((i) => {
        typeof t.name == "string" && (i.name = t.name), typeof t?.thumbnailUrl == "string" && (i.avatar_url = t.thumbnailUrl);
      }, "modifyAppItem");
      ge(n.queryClient, ["apps", t.appId], void 0, e), Ct(n.queryClient, { queryKey: ["apps", "list"], exact: !1 }, t.appId, e);
    }, "onMutate")
  };
}
c(EI, "ab");
d(EI, "getUpdateConversationMutationOptions");
function _I(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ appId: t }) => {
      await n.fetch(`/api/apps/${t}/trash`, { method: "POST" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((t) => {
      x0(n.queryClient, ["apps", "list"], t.appId);
    }, "onMutate"),
    onSettled: /* @__PURE__ */ d(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
c(_I, "ob");
d(_I, "getTrashConversationMutationOptions");
function c4(n) {
  return new Xt(n.queryClient, CI(n));
}
c(c4, "Lm");
d(c4, "getMarkConversationMutation");
function zI(n) {
  return new Xt(n.queryClient, PI(n));
}
c(zI, "cb");
d(zI, "getStarConversationMutation");
function LI(n) {
  return new Xt(n.queryClient, QI(n));
}
c(LI, "lb");
d(LI, "getPinConversationMutation");
function h4(n) {
  return new Xt(n.queryClient, TI(n));
}
c(h4, "Om");
d(h4, "getLeaveConversationMutation");
function II(n) {
  return new Xt(n.queryClient, MI(n));
}
c(II, "db");
d(II, "getRemoveConversationMutation");
function WI(n) {
  return new Xt(n.queryClient, AI(n));
}
c(WI, "hb");
d(WI, "getUpdateMemberMutation");
function VI(n) {
  return new Xt(n.queryClient, RI(n));
}
c(VI, "pb");
d(VI, "getAddMembersToConversationMutation");
function d4(n) {
  return new Xt(n.queryClient, EI(n));
}
c(d4, "Im");
d(d4, "getUpdateConversationMutation");
function DI(n) {
  return new Xt(n.queryClient, _I(n));
}
c(DI, "ub");
d(DI, "getTrashConversationMutation");
function u4(n, t, e = [gt.ChatRoom, gt.PrivateChat], i) {
  return Qm(n, ["apps", t], void 0, {
    initialData: /* @__PURE__ */ d(() => n?.queryClient.getQueryData(["apps", "list", e, i])?.pages.flatMap((s) => s.data).find((s) => s?.id === t), "initialData")
  });
}
c(u4, "Tm");
d(u4, "getConversationOptions");
function p4(n, t, e) {
  return {
    queryKey: ["members", t],
    queryFn: /* @__PURE__ */ d(async () => await (await n.fetch(`/api/apps/${t}/members`)).json(), "queryFn"),
    ...e
  };
}
c(p4, "Fm");
d(p4, "getMemberOptions");
function qI(n, t, e, i) {
  return {
    queryKey: ["search__members", e],
    initialPageParam: 0,
    enabled: !0,
    queryFn: /* @__PURE__ */ d(async (s) => {
      const r = t(), a = s.pageParam;
      let o;
      e ? o = await n.fetch(`/api/apps/${e}/members?q=${r}${i() !== void 0 ? `&agent=${!!i()}` : ""}&member=false&system=false&skip=${a}`) : o = await n.fetch(`/api/users?q=${r}${i() !== void 0 ? `&agent=${!!i()}` : ""}&system=false&skip=${a}`);
      const l = await o.json();
      return l.data = l.data || [], l;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ d((s) => {
      if (s.end && s.end < s.count)
        return s.end;
    }, "getNextPageParam")
  };
}
c(qI, "yb");
d(qI, "getInfiniteSearchMemberOptions");
const Ot = /* @__PURE__ */ d((n) => n ?? C, "o$3"), c9 = /* @__PURE__ */ d((n, t, e) => {
  const i = /* @__PURE__ */ new Map();
  for (let s = t; s <= e; s++) i.set(n[s], s);
  return i;
}, "u"), Mi = Ll(class extends Am {
  constructor(n) {
    if (super(n), n.type !== O1.CHILD) throw Error("repeat() can only be used in text expressions");
  }
  dt(n, t, e) {
    let i;
    e === void 0 ? e = t : t !== void 0 && (i = t);
    const s = [], r = [];
    let a = 0;
    for (const o of n) s[a] = i ? i(o, a) : a, r[a] = e(o, a), a++;
    return { values: r, keys: s };
  }
  render(n, t, e) {
    return this.dt(n, t, e).values;
  }
  update(n, [t, e, i]) {
    const s = sU(n), { values: r, keys: a } = this.dt(t, e, i);
    if (!Array.isArray(s)) return this.ut = a, r;
    const o = this.ut ??= [], l = [];
    let h, u, p = 0, y = s.length - 1, m = 0, g = r.length - 1;
    for (; p <= y && m <= g; ) if (s[p] === null) p++;
    else if (s[y] === null) y--;
    else if (o[p] === a[m]) l[m] = Fa(s[p], r[m]), p++, m++;
    else if (o[y] === a[g]) l[g] = Fa(s[y], r[g]), y--, g--;
    else if (o[p] === a[g]) l[g] = Fa(s[p], r[g]), pg(n, l[g + 1], s[p]), p++, g--;
    else if (o[y] === a[m]) l[m] = Fa(s[y], r[m]), pg(n, s[p], s[y]), y--, m++;
    else if (h === void 0 && (h = c9(a, m, g), u = c9(o, p, y)), h.has(o[p])) if (h.has(o[y])) {
      const b = u.get(a[m]), S = b !== void 0 ? s[b] : null;
      if (S === null) {
        const x = pg(n, s[p]);
        Fa(x, r[m]), l[m] = x;
      } else l[m] = Fa(S, r[m]), pg(n, s[p], S), s[b] = null;
      m++;
    } else f$(s[y]), y--;
    else f$(s[p]), p++;
    for (; m <= g; ) {
      const b = pg(n, l[g + 1]);
      Fa(b, r[m]), l[m++] = b;
    }
    for (; p <= y; ) {
      const b = s[p++];
      b !== null && f$(b);
    }
    return this.ut = a, wI(n, l), ls;
  }
}), tO = Ll(class extends Am {
  constructor() {
    super(...arguments), this.key = C;
  }
  render(n, t) {
    return this.key = n, t;
  }
  update(n, [t, e]) {
    return t !== this.key && (wI(n), this.key = t), e;
  }
});
function Ys(n) {
  n.stopPropagation();
}
c(Ys, "Rr");
d(Ys, "inputConsume");
function ZI(n) {
  n.key === "Escape" && (n.preventDefault(), n.stopPropagation(), n.target.value = "", n.target.dispatchEvent(new InputEvent("input", { data: "", inputType: "deleteContent" })));
}
c(ZI, "wb");
d(ZI, "inputClearOnEscape");
function Vw(n) {
  n.key === "Escape" && (n.preventDefault(), n.stopPropagation(), n.target.blur());
}
c(Vw, "Gd");
d(Vw, "inputBlurOnEscape");
function FI(n) {
  n.key === "Enter" && n.target.blur();
}
c(FI, "fb");
d(FI, "inputBlurOnEnter");
function XI(n) {
  n.target.value ? ZI(n) : Vw(n);
}
c(XI, "mb");
d(XI, "inputClearAndBlurOnEscape");
function f4(n) {
  n.key === "Enter" && (n.preventDefault(), n.stopPropagation(), n.target.click());
}
c(f4, "Dm");
d(f4, "clickOnEnter");
function NI(n) {
  n.key === " " && (n.preventDefault(), n.stopPropagation());
}
c(NI, "vb");
d(NI, "consumeOnSpace");
function Le(n) {
  f4(n), NI(n);
}
c(Le, "le");
d(Le, "clickOnEnterAndConsumeOnSpace");
function di(n) {
  n.key === " " && (n.preventDefault(), n.stopPropagation(), n.target.click());
}
c(di, "Me");
d(di, "clickOnSpace");
function C0(n) {
  f4(n), di(n);
}
c(C0, "ny");
d(C0, "clickOnEnterAndSpace");
const P0 = et`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-messages]{padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));flex:1 1 100%}[part~=wy-message-placeholder]{opacity:.5}[part~=wy-message-date-separator]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));pointer-events:none;position:sticky;display:block;top:calc(var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) + var(--wy-component-offset-top, 0px));z-index:10;align-self:center;justify-self:center;margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));background:var(--wy-surface-container-high, var(--wy-surface-container-high-light, #e6e8ee));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-message]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));display:flex;flex-direction:row;align-items:flex-start;margin-bottom:calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + .5*var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));scroll-margin-block:6rem}[part~=wy-message][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-message-meta]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:0 0 calc(.5*var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5*var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));color:var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}[part~=wy-message-bubble]{background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));display:flex;flex-direction:column;padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));max-width:min(32*var(--wy-size, 1rem),100% - 2*var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}[part~=wy-message-bubble-section]{flex:1 1 100%;display:block;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));clip-path:border-box}[part~=wy-message-author]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:calc(1lh + .5*var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5*var(--wy-size, 1rem)) 0 0}[part~=wy-message-content]{display:flex;flex-direction:column;width:100%;align-items:flex-start;flex-wrap:wrap;min-width:0;position:relative}[part~=wy-message-agent]{--wy-component-background-color: var(--wy-tertiary-container, var(--wy-tertiary-container-light, #ebe3bd));--wy-component-color: var(--wy-on-tertiary-container, var(--wy-on-tertiary-container-light, #4c472b))}[part~=wy-message-me]{margin-right:0;margin-left:calc(2.5*var(--wy-size, 1rem));align-items:flex-end;--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73))}[part~=wy-message-me] [part~=wy-message-meta]{margin:0 calc(.5*var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5*var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) 0}[part~=wy-message-me] [part~=wy-message-content]{align-items:flex-end}[part~=wy-message-bubble-emoji]{background:none;padding:0 0 var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-message-seenby]{display:flex;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));height:calc(1.125*var(--wy-size, 1rem));justify-content:flex-end;margin-top:calc(-.125*var(--wy-size, 1rem))}`, jI = et`[part~=wy-footerbar]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));position:absolute;bottom:0;left:0;right:0;z-index:1020}[part~=wy-footerbar]:after{content:\"\";background-color:var(--wy-component-background-color);color:var(--wy-component-color);position:absolute;width:100%;left:0;bottom:0;height:100%;z-index:-1}[part~=wy-footerbar-sticky]{position:sticky}[part~=wy-footerbar-floating]{--wy-component-border-radius: var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));border-radius:var(--wy-component-border-radius)}[part~=wy-footerbar-floating]:after{border-radius:var(--wy-component-border-radius)}`, Il = et`[part~=wy-pane]{display:flex;flex-direction:column;position:relative;min-height:0;height:100%;flex:1 1 auto}[part~=wy-pane-body]{display:flex;flex-direction:column;flex:1}[part~=wy-pane-group]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));display:flex;flex-direction:column;flex:1}[part~=wy-pane-group-fixed-size]{flex:0}[part~=wy-pane-toolbar]{display:flex;flex:1;justify-content:space-between;align-items:center;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}`, va = et`[part~=wy-pager]{position:relative;align-self:center;justify-self:center}[part~=wy-pager-bottom]{width:16px;height:256px;max-height:100%;margin-top:-256px;margin-inline:auto;pointer-events:none}[part~=wy-pager-top]{width:16px;height:256px;max-height:100%;margin-bottom:-256px;margin-inline:auto;pointer-events:none}`, y4 = et`[part~=wy-toasts]{background:none;border:none;padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin:0;box-sizing:border-box;width:100%;height:100%;display:flex;flex-direction:column;flex-wrap:wrap;align-content:flex-end;align-items:flex-end;justify-content:flex-end;pointer-events:none}[part~=wy-toasts][popover]{position:fixed;inset:0;z-index:1070}[part~=wy-toasts]>::slotted(*){pointer-events:auto}[part~=wy-toast]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background:var(--wy-component-background-color);color:var(--wy-component-color);gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));margin-top:0;margin-bottom:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));display:flex;cursor:pointer;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));padding:0;-webkit-user-select:none;user-select:none;box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));position:relative;overflow:hidden;min-height:calc(3*var(--wy-size, 1rem));max-width:calc(32*var(--wy-size, 1rem))}[part~=wy-toast][part~=wy-fade]{transition-property:opacity,min-height,padding-top,padding-bottom,margin-top,margin-bottom,height;transition-duration:var(--wy-transition-duration, .2s);transition-timing-function:var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))}[part~=wy-toast][part~=wy-fade]:not([part~=wy-show]){opacity:0;min-height:0;height:0;padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;pointer-events:none}[part~=wy-toast-action]{position:sticky;top:calc(4.5*var(--wy-size, 1rem));bottom:calc(4.5*var(--wy-size, 1rem));z-index:990;background-color:var(--wy-primary, var(--wy-primary-light, #2f628c));color:var(--wy-on-primary, var(--wy-on-primary-light, #ffffff));padding:calc(.5*var(--wy-size, 1rem)) calc(1*var(--wy-size, 1rem));margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:calc(.5*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));width:max-content;min-height:0;max-width:calc(100% - 3*var(--wy-size, 1rem));height:auto;align-self:center;text-align:center;box-shadow:none}[part~=wy-toast-primary]{background:var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73));color:var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff))}`;
var m4 = /* @__PURE__ */ ((n) => (n.Active = "active", n.Away = "away", n))(m4 || {}), sf;
const BI = (sf = class extends Am {
  constructor(t) {
    if (super(t), t.type !== O1.ATTRIBUTE || t.name !== "part" || t.strings?.length > 2)
      throw new Error(
        "`partMap()` can only be used in the `part` attribute and must be the only section in the attribute."
      );
  }
  render(t) {
    return " " + Object.keys(t).filter((e) => t[e]).join(" ") + " ";
  }
  update(t, [e]) {
    if (this._previousShadowParts === void 0) {
      this._previousShadowParts = /* @__PURE__ */ new Set(), t.strings !== void 0 && (this._staticShadowParts = new Set(
        t.strings.join(" ").split(/\s/).filter((s) => s !== "")
      ));
      for (const s in e)
        e[s] && !this._staticShadowParts?.has(s) && this._previousShadowParts.add(s);
      return this.render(e);
    }
    const i = t.element.part;
    for (const s of this._previousShadowParts)
      s in e || (i.remove(s), this._previousShadowParts.delete(s));
    for (const s in e) {
      const r = !!e[s];
      r !== this._previousShadowParts.has(s) && !this._staticShadowParts?.has(s) && (r ? (i.add(s), this._previousShadowParts.add(s)) : (i.remove(s), this._previousShadowParts.delete(s)));
    }
    return ls;
  }
}, c(sf, "fw"), sf);
d(BI, "ShadowPartMapDirective");
let lU = BI;
const ut = Ll(lU), ne = et`:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]){box-sizing:border-box;text-align:initial;font-size:var(--wy-font-size, var(--wy-size, 1em))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:before,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:after{box-sizing:inherit}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a){text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-light, #2f628c))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):hover{text-decoration:var(--wy-link-hover-decoration, var(--wy-link-decoration, none))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])):hover{text-decoration:none}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(p),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(p){margin-top:0;margin-bottom:calc(1*var(--wy-size, 1rem))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(label),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(label){cursor:inherit}:where(:host([hidden])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"])[hidden],:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *[hidden]{display:none!important}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where([role=button]),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where([role=button]){cursor:pointer}`, g4 = et`:host(wy-avatar){position:relative;display:inline-flex}[part~=wy-avatar-shape]{border-radius:var(--wy-avatar-border-radius, var(--wy-border-radius, 50%))}[part~=wy-avatar-img]{width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));object-fit:cover}[part~=wy-avatar-initials]{background-color:var(--wy-component-avatar-background-color, var(--wy-primary, var(--wy-primary-light, #2f628c)));color:var(--wy-component-avatar-color, var(--wy-on-primary, var(--wy-on-primary-light, #ffffff)));width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));display:flex;align-items:center;align-content:center;justify-content:center;justify-items:center;font-size:calc(var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem))))}[part~=wy-avatar-initials-text]{font-size:max(8px,var(--wy-avatar-font-size, .382em));font-weight:var(--wy-avatar-font-weight, var(--wy-font-weight-bold, unset));line-height:normal}[part~=wy-avatar-type-icon]{display:flex;position:absolute;z-index:1;bottom:0;right:-8.3333333333%;border-radius:50%;color:var(--wy-tertiary, var(--wy-tertiary-light, #645f41));stroke:var(--wy-on-tertiary, var(--wy-on-tertiary-light, #ffffff))}:host(wy-avatar-group){position:relative;display:inline-flex;flex-shrink:0;width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)))}[part~=wy-avatar-back]{position:absolute;top:0;left:0}[part~=wy-avatar-front]{position:absolute;bottom:0;right:0}:host(wy-avatar-header){padding:calc(1.5*var(--wy-size, 1rem));margin-left:auto;margin-right:auto;text-align:center;display:flex;flex-direction:column;justify-content:center;align-items:center}[part~=wy-avatar-description]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}`, UI = et`[part~=wy-presence]{width:calc(.75*var(--wy-size, 1rem));height:calc(.75*var(--wy-size, 1rem));border-radius:50%;position:absolute;bottom:0;right:-5%;box-sizing:border-box}[part~=wy-presence]:not([part~=wy-presence-active]){display:none}[part~=wy-presence]:after{content:\"\";position:absolute;width:100%;height:100%;top:0;left:0;border-radius:inherit;background-color:var(--wy-presence-active, var(--wy-green-light, #00a38d));background-clip:content-box;padding:calc(.125*var(--wy-size, 1rem));box-sizing:border-box}[part~=wy-presence-mask]{-webkit-mask-image:radial-gradient(circle calc(.75 * var(--wy-size, 1rem)) at bottom calc(.375 * var(--wy-size, 1rem)) right calc(.375 * var(--wy-size, 1rem) - 5%),rgba(0,0,0,0) calc(.375 * var(--wy-size, 1rem)),rgb(0,0,0) calc(.375 * var(--wy-size, 1rem) + 1px));mask-image:radial-gradient(circle calc(.75 * var(--wy-size, 1rem)) at bottom calc(.375 * var(--wy-size, 1rem)) right calc(.375 * var(--wy-size, 1rem) - 5%),#0000 calc(.375 * var(--wy-size, 1rem)),#000 calc(.375 * var(--wy-size, 1rem) + 1px))}[part~=wy-presence-in-text]{position:absolute;bottom:unset;right:unset}[part~=wy-presence-in-text]:after{left:calc(-.5*var(--wy-size, 1rem))}`;
var cU = Object.defineProperty, hU = Object.getOwnPropertyDescriptor, w4 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? hU(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && cU(t, e, s), s;
}, "__decorateClass$1b"), g$, rf;
let cm = (g$ = (rf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.placement = "avatar";
  }
  render() {
    const t = {
      "wy-presence": !0,
      "wy-presence-active": this.status === m4.Active,
      "wy-presence-in-text": this.placement === "text"
    };
    return v` <span part=${ut(t)} data-presence-id=${this.id}></span> `;
  }
}, c(rf, "Ma"), rf), d(g$, "WyPresence"), g$);
cm.styles = [
  ne,
  UI,
  ft
];
w4([
  O()
], cm.prototype, "placement", 2);
w4([
  O()
], cm.prototype, "status", 2);
cm = w4([
  U("wy-presence")
], cm);
var dU = "M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M1,10V12H9V10M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12Z", uU = "M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M6,10V7H4V10H1V12H4V15H6V12H9V10M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12Z", pU = "M13 14H11V9H13M13 18H11V16H13M1 21H23L12 2L1 21Z", fU = "M13,13H11V7H13M13,17H11V15H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", yU = "M13 13H11V7H13M11 15H13V17H11M15.73 3H8.27L3 8.27V15.73L8.27 21H15.73L21 15.73V8.27L15.73 3Z", mU = "M19.5,3.09L15,7.59V4H13V11H20V9H16.41L20.91,4.5L19.5,3.09M4,13V15H7.59L3.09,19.5L4.5,20.91L9,16.41V20H11V13H4Z", gU = "M10,21V19H6.41L10.91,14.5L9.5,13.09L5,17.59V14H3V21H10M14.5,10.91L19,6.41V10H21V3H14V5H17.59L13.09,9.5L14.5,10.91Z", h9 = "M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z", wU = "M4,11V13H16L10.5,18.5L11.92,19.92L19.84,12L11.92,4.08L10.5,5.5L16,11H4Z", vU = "M7.5,18A5.5,5.5 0 0,1 2,12.5A5.5,5.5 0 0,1 7.5,7H18A4,4 0 0,1 22,11A4,4 0 0,1 18,15H9.5A2.5,2.5 0 0,1 7,12.5A2.5,2.5 0 0,1 9.5,10H17V11.5H9.5A1,1 0 0,0 8.5,12.5A1,1 0 0,0 9.5,13.5H18A2.5,2.5 0 0,0 20.5,11A2.5,2.5 0 0,0 18,8.5H7.5A4,4 0 0,0 3.5,12.5A4,4 0 0,0 7.5,16.5H17V18H7.5Z", OU = "M12,3A9,9 0 0,0 3,12H0L4,16L8,12H5A7,7 0 0,1 12,5A7,7 0 0,1 19,12A7,7 0 0,1 12,19C10.5,19 9.09,18.5 7.94,17.7L6.5,19.14C8.04,20.3 9.94,21 12,21A9,9 0 0,0 21,12A9,9 0 0,0 12,3M14,12A2,2 0 0,0 12,10A2,2 0 0,0 10,12A2,2 0 0,0 12,14A2,2 0 0,0 14,12Z", bU = "M21,19V20H3V19L5,17V11C5,7.9 7.03,5.17 10,4.29C10,4.19 10,4.1 10,4A2,2 0 0,1 12,2A2,2 0 0,1 14,4C14,4.1 14,4.19 14,4.29C16.97,5.17 19,7.9 19,11V17L21,19M14,21A2,2 0 0,1 12,23A2,2 0 0,1 10,21", $U = "M20.84,22.73L18.11,20H3V19L5,17V11C5,9.86 5.29,8.73 5.83,7.72L1.11,3L2.39,1.73L22.11,21.46L20.84,22.73M19,15.8V11C19,7.9 16.97,5.17 14,4.29C14,4.19 14,4.1 14,4A2,2 0 0,0 12,2A2,2 0 0,0 10,4C10,4.1 10,4.19 10,4.29C9.39,4.47 8.8,4.74 8.26,5.09L19,15.8M12,23A2,2 0 0,0 14,21H10A2,2 0 0,0 12,23Z", xU = "M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3M9 17H7V10H9V17M13 17H11V7H13V17M17 17H15V13H17V17Z", w$ = "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z", kU = "M0.41,13.41L6,19L7.41,17.58L1.83,12M22.24,5.58L11.66,16.17L7.5,12L6.07,13.41L11.66,19L23.66,7M18,7L16.59,5.58L10.24,11.93L11.66,13.34L18,7Z", SU = "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41 10.59L10 14.17L17.59 6.58L19 8L10 17Z", CU = "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M12 20C7.59 20 4 16.41 4 12S7.59 4 12 4 20 7.59 20 12 16.41 20 12 20M16.59 7.58L10 14.17L7.41 11.59L6 13L10 17L18 9L16.59 7.58Z", PU = "M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3M19,5V19H5V5H19Z", QU = "M19,19H5V5H15V3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V11H19M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z", TU = "M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", MU = "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z", AU = "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z", RU = "M6.5 20Q4.22 20 2.61 18.43 1 16.85 1 14.58 1 12.63 2.17 11.1 3.35 9.57 5.25 9.15 5.88 6.85 7.75 5.43 9.63 4 12 4 14.93 4 16.96 6.04 19 8.07 19 11 20.73 11.2 21.86 12.5 23 13.78 23 15.5 23 17.38 21.69 18.69 20.38 20 18.5 20Z", EU = "M9,22A1,1 0 0,1 8,21V18H4A2,2 0 0,1 2,16V4C2,2.89 2.9,2 4,2H20A2,2 0 0,1 22,4V16A2,2 0 0,1 20,18H13.9L10.2,21.71C10,21.9 9.75,22 9.5,22V22H9Z", _U = "M9,22A1,1 0 0,1 8,21V18H4A2,2 0 0,1 2,16V4C2,2.89 2.9,2 4,2H20A2,2 0 0,1 22,4V16A2,2 0 0,1 20,18H13.9L10.2,21.71C10,21.9 9.75,22 9.5,22V22H9M10,16V19.08L13.08,16H20V4H4V16H10Z", zU = "M15,9H5V5H15M12,19A3,3 0 0,1 9,16A3,3 0 0,1 12,13A3,3 0 0,1 15,16A3,3 0 0,1 12,19M17,3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V7L17,3Z", LU = "M19,1L17.74,3.75L15,5L17.74,6.26L19,9L20.25,6.26L23,5L20.25,3.75M9,4L6.5,9.5L1,12L6.5,14.5L9,20L11.5,14.5L17,12L11.5,9.5M19,15L17.74,17.74L15,19L17.74,20.25L19,23L20.25,20.25L23,19L20.25,17.74", IU = "M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z", WU = "M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19M8.46,11.88L9.87,10.47L12,12.59L14.12,10.47L15.53,11.88L13.41,14L15.53,16.12L14.12,17.53L12,15.41L9.88,17.53L8.47,16.12L10.59,14L8.46,11.88M15.5,4L14.5,3H9.5L8.5,4H5V6H19V4H15.5Z", VU = "M14,14H16L12,10L8,14H10V18H14V14M6,7H18V19C18,19.5 17.8,20 17.39,20.39C17,20.8 16.5,21 16,21H8C7.5,21 7,20.8 6.61,20.39C6.2,20 6,19.5 6,19V7M19,4V6H5V4H8.5L9.5,3H14.5L15.5,4H19Z", DU = "M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z", qU = "M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z", ZU = "M17.9,17.39C17.64,16.59 16.89,16 16,16H15V13A1,1 0 0,0 14,12H8V10H10A1,1 0 0,0 11,9V7H13A2,2 0 0,0 15,5V4.59C17.93,5.77 20,8.64 20,12C20,14.08 19.2,15.97 17.9,17.39M11,19.93C7.05,19.44 4,16.08 4,12C4,11.38 4.08,10.78 4.21,10.21L9,15V16A2,2 0 0,0 11,18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", FU = "M20,8L12,13L4,8V6L12,11L20,6M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C22,4.89 21.1,4 20,4Z", XU = "M12,17.5C14.33,17.5 16.3,16.04 17.11,14H6.89C7.69,16.04 9.67,17.5 12,17.5M8.5,11A1.5,1.5 0 0,0 10,9.5A1.5,1.5 0 0,0 8.5,8A1.5,1.5 0 0,0 7,9.5A1.5,1.5 0 0,0 8.5,11M15.5,11A1.5,1.5 0 0,0 17,9.5A1.5,1.5 0 0,0 15.5,8A1.5,1.5 0 0,0 14,9.5A1.5,1.5 0 0,0 15.5,11M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2C6.47,2 2,6.5 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", NU = "M15 18H18V15H20V18H23V20H20V23H18V20H15V18M12 17.5C9.67 17.5 7.69 16.04 6.89 14H15.69C14.5 14.78 13.62 15.97 13.23 17.36C12.83 17.45 12.42 17.5 12 17.5M8.5 11C7.67 11 7 10.33 7 9.5C7 8.67 7.67 8 8.5 8C9.33 8 10 8.67 10 9.5C10 10.33 9.33 11 8.5 11M15.5 11C14.67 11 14 10.33 14 9.5C14 8.67 14.67 8 15.5 8C16.33 8 17 8.67 17 9.5C17 10.33 16.33 11 15.5 11M12 20L13.07 19.93C13.18 20.61 13.4 21.26 13.72 21.85C13.16 21.95 12.58 22 12 22C6.47 22 2 17.5 2 12C2 6.5 6.47 2 12 2C17.5 2 22 6.5 22 12C22 12.59 21.95 13.16 21.85 13.72C21.26 13.4 20.62 13.18 19.93 13.07L20 12C20 7.58 16.42 4 12 4C7.58 4 4 7.58 4 12C4 16.42 7.58 20 12 20Z", jU = "M13,9V3.5L18.5,9M6,2C4.89,2 4,2.89 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2H6Z", d9 = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M6.12,15.5L9.86,19.24L11.28,17.83L8.95,15.5L11.28,13.17L9.86,11.76L6.12,15.5M17.28,15.5L13.54,11.76L12.12,13.17L14.45,15.5L12.12,17.83L13.54,19.24L17.28,15.5Z", u9 = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M15,18V16H6V18H15M18,14V12H6V14H18Z", BU = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.8,20H14L12,16.6L10,20H8.2L11.1,15.5L8.2,11H10L12,14.4L14,11H15.8L12.9,15.5L15.8,20M13,9V3.5L18.5,9H13Z", UU = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M6,20H15L18,20V12L14,16L12,14L6,20M8,9A2,2 0 0,0 6,11A2,2 0 0,0 8,13A2,2 0 0,0 10,11A2,2 0 0,0 8,9Z", HU = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M13,13H11V18A2,2 0 0,1 9,20A2,2 0 0,1 7,18A2,2 0 0,1 9,16C9.4,16 9.7,16.1 10,16.3V11H13V13M13,9V3.5L18.5,9H13Z", YU = "M12.6,12.3H10.6V15.5H12.7C13.3,15.5 13.6,15.3 13.9,15C14.2,14.7 14.3,14.4 14.3,13.9C14.3,13.4 14.2,13.1 13.9,12.8C13.6,12.5 13.2,12.3 12.6,12.3M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.2,16C14.6,16.5 14.1,16.7 12.8,16.7H10.6V20H9V11H12.8C14.1,11 14.7,11.3 15.2,11.8C15.8,12.4 16,13 16,13.9C16,14.8 15.8,15.5 15.2,16M13,9V3.5L18.5,9H13Z", GU = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M13.5,16V19H10.5V16H8L12,12L16,16H13.5M13,9V3.5L18.5,9H13Z", KU = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M17,19V13L14,15.2V13H7V19H14V16.8L17,19Z", JU = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.2,20H13.8L12,13.2L10.2,20H8.8L6.6,11H8.1L9.5,17.8L11.3,11H12.6L14.4,17.8L15.8,11H17.3L15.2,20M13,9V3.5L18.5,9H13Z", tH = "M20,2H4C2.89,2 2,2.89 2,4V20C2,21.11 2.89,22 4,22H20C21.11,22 22,21.11 22,20V4C22,2.89 21.11,2 20,2M12,4L15,7H13V9H11V7H9M7,15L4,12L7,9V11H9V13H7M12,20L9,17H11V15H13V17H15M17,15V13H15V11H17V9L20,12", eH = "M17 4H20C21.1 4 22 4.9 22 6V8H20V6H17V4M4 8V6H7V4H4C2.9 4 2 4.9 2 6V8H4M20 16V18H17V20H20C21.1 20 22 19.1 22 18V16H20M7 18H4V16H2V18C2 19.1 2.9 20 4 20H7V18M18 8H6V16H18V8Z", iH = "M20 6H12L10 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V8C22 6.9 21.1 6 20 6M18 12H16V14H18V16H16V18H14V16H16V14H14V12H16V10H14V8H16V10H18V12Z", nH = "M17,7H22V17H17V19A1,1 0 0,0 18,20H20V22H17.5C16.95,22 16,21.55 16,21C16,21.55 15.05,22 14.5,22H12V20H14A1,1 0 0,0 15,19V5A1,1 0 0,0 14,4H12V2H14.5C15.05,2 16,2.45 16,3C16,2.45 16.95,2 17.5,2H20V4H18A1,1 0 0,0 17,5V7M2,7H13V9H4V15H13V17H2V7M20,15V9H17V15H20Z", sH = "M5,5H10V7H7V10H5V5M14,5H19V10H17V7H14V5M17,14H19V19H14V17H17V14M10,17V19H5V14H7V17H10Z", rH = "M14,14H19V16H16V19H14V14M5,14H10V19H8V16H5V14M8,5H10V10H5V8H8V5M19,8V10H14V5H16V8H19Z", aH = "M15.07,11.25L14.17,12.17C13.45,12.89 13,13.5 13,15H11V14.5C11,13.39 11.45,12.39 12.17,11.67L13.41,10.41C13.78,10.05 14,9.55 14,9C14,7.89 13.1,7 12,7A2,2 0 0,0 10,9H8A4,4 0 0,1 12,5A4,4 0 0,1 16,9C16,9.88 15.64,10.67 15.07,11.25M13,19H11V17H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12C22,6.47 17.5,2 12,2Z", oH = "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M11,17H13V11H11V17Z", lH = "M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z", cH = "M7,10L12,15L17,10H7Z", hH = "M7,15L12,10L17,15H7Z", dH = "M20,2H4A2,2 0 0,0 2,4V22L6,18H20A2,2 0 0,0 22,16V4C22,2.89 21.1,2 20,2Z", uH = "M20,2H4A2,2 0 0,0 2,4V22L6,18H20A2,2 0 0,0 22,16V4A2,2 0 0,0 20,2M6,9H18V11H6M14,14H6V12H14M18,8H6V6H18", pH = "M19,13H5V11H19V13Z", fH = "M21 2C22.05 2 22.92 2.81 23 3.85L23 4V16C23 17.05 22.18 17.92 21.15 18L21 18H14V20H16V22H8V20H10V18H3C1.95 18 1.08 17.18 1 16.15L1 16V4C1 2.94 1.81 2.08 2.85 2L3 2H21M21 4H3V16H21V4M12 11C14.21 11 16 11.9 16 13V14H8V13C8 11.9 9.79 11 12 11M12 6C13.11 6 14 6.9 14 8S13.11 10 12 10 10 9.11 10 8 10.9 6 12 6Z", yH = "M14,3V5H17.59L7.76,14.83L9.17,16.24L19,6.41V10H21V3M19,19H5V5H12V3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V12H19V19Z", mH = "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z", gH = "M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z", wH = "M2,5.27L3.28,4L20,20.72L18.73,22L12.8,16.07V22H11.2V16H6V14L8,12V11.27L2,5.27M16,12L18,14V16H17.82L8,6.18V4H7V2H17V4H16V12Z", vH = "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z", OH = "M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M13,7H11V11H7V13H11V17H13V13H17V11H13V7Z", bH = "M13,3A9,9 0 0,0 4,12H1L4.89,15.89L4.96,16.03L9,12H6A7,7 0 0,1 13,5A7,7 0 0,1 20,12A7,7 0 0,1 13,19C11.07,19 9.32,18.21 8.06,16.94L6.64,18.36C8.27,20 10.5,21 13,21A9,9 0 0,0 22,12A9,9 0 0,0 13,3Z", $H = "M4,3H5V5H3V4A1,1 0 0,1 4,3M20,3A1,1 0 0,1 21,4V5H19V3H20M15,5V3H17V5H15M11,5V3H13V5H11M7,5V3H9V5H7M21,20A1,1 0 0,1 20,21H19V19H21V20M15,21V19H17V21H15M11,21V19H13V21H11M7,21V19H9V21H7M4,21A1,1 0 0,1 3,20V19H5V21H4M3,15H5V17H3V15M21,15V17H19V15H21M3,11H5V13H3V11M21,11V13H19V11H21M3,7H5V9H3V7M21,7V9H19V7H21Z", xH = "M2,21L23,12L2,3V10L17,12L2,14V21Z", kH = "M13,19H14A1,1 0 0,1 15,20H15.73L13,17.27V19M22,20V21.18L20.82,20H22M21,22.72L19.73,24L17.73,22H15A1,1 0 0,1 14,23H10A1,1 0 0,1 9,22H2V20H9A1,1 0 0,1 10,19H11V17H4A1,1 0 0,1 3,16V12A1,1 0 0,1 4,11H6.73L4.73,9H4A1,1 0 0,1 3,8V7.27L1,5.27L2.28,4L21,22.72M4,3H20A1,1 0 0,1 21,4V8A1,1 0 0,1 20,9H9.82L7,6.18V5H5.82L3.84,3C3.89,3 3.94,3 4,3M20,11A1,1 0 0,1 21,12V16A1,1 0 0,1 20,17H17.82L11.82,11H20M9,7H10V5H9V7M9,15H10V14.27L9,13.27V15M5,13V15H7V13H5Z", SH = "M12 1L3 5V11C3 16.55 6.84 21.74 12 23C17.16 21.74 21 16.55 21 11V5L12 1M15.08 16L12 14.15L8.93 16L9.74 12.5L7.03 10.16L10.61 9.85L12 6.55L13.39 9.84L16.97 10.15L14.26 12.5L15.08 16Z", CH = "M21 11C21 16.55 17.16 21.74 12 23C6.84 21.74 3 16.55 3 11V5L12 1L21 5V11M12 21C15.75 20 19 15.54 19 11.22V6.3L12 3.18L5 6.3V11.22C5 15.54 8.25 20 12 21M15.05 16L11.97 14.15L8.9 16L9.71 12.5L7 10.16L10.58 9.85L11.97 6.55L13.37 9.84L16.95 10.15L14.23 12.5L15.05 16", PH = "M18 21L14 17H17V7H14L18 3L22 7H19V17H22M2 19V17H12V19M2 13V11H9V13M2 7V5H6V7H2Z", QH = "M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z", TH = "M12,1L9,9L1,12L9,15L12,23L15,15L23,12L15,9L12,1Z", MH = "M20.8 22.7L17.9 19.8L18.2 21L12 17.3L5.8 21L7.4 14L2 9.2L6.9 8.8L1.1 3L2.4 1.7L22.1 21.4L20.8 22.7M22 9.2L14.8 8.6L12 2L10 6.8L16.9 13.7L22 9.2Z", AH = "M21,9L17,5V8H10V10H17V13M7,11L3,15L7,19V16H14V14H7V11Z", RH = "M23,10C23,8.89 22.1,8 21,8H14.68L15.64,3.43C15.66,3.33 15.67,3.22 15.67,3.11C15.67,2.7 15.5,2.32 15.23,2.05L14.17,1L7.59,7.58C7.22,7.95 7,8.45 7,9V19A2,2 0 0,0 9,21H18C18.83,21 19.54,20.5 19.84,19.78L22.86,12.73C22.95,12.5 23,12.26 23,12V10M1,21H5V9H1V21Z", EH = "M5,9V21H1V9H5M9,21A2,2 0 0,1 7,19V9C7,8.45 7.22,7.95 7.59,7.59L14.17,1L15.23,2.06C15.5,2.33 15.67,2.7 15.67,3.11L15.64,3.43L14.69,8H21C22.11,8 23,8.9 23,10V12C23,12.26 22.95,12.5 22.86,12.73L19.84,19.78C19.54,20.5 18.83,21 18,21H9M9,19H18.03L21,12V10H12.21L13.34,4.68L9,9.03V19Z", _H = "M9,3V4H4V6H5V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V6H20V4H15V3H9M9,8H11V17H9V8M13,8H15V17H13V8Z", zH = "M17,10.5V7A1,1 0 0,0 16,6H4A1,1 0 0,0 3,7V17A1,1 0 0,0 4,18H16A1,1 0 0,0 17,17V13.5L21,17.5V6.5L17,10.5Z", LH = "M3 5V19H20V5H3M7 7V9H5V7H7M5 13V11H7V13H5M5 15H7V17H5V15M18 17H9V15H18V17M18 13H9V11H18V13M18 9H9V7H18V9Z", IH = "M4 5V18H21V5H4M14 7V10.5H11V7H14M6 7H9V10.5H6V7M6 16V12.5H9V16H6M11 16V12.5H14V16H11M19 16H16V12.5H19V16M16 10.5V7H19V10.5H16Z", WH = "M2.28,3L1,4.27L2.47,5.74C2.04,6 1.61,6.29 1.2,6.6L3,9C3.53,8.6 4.08,8.25 4.66,7.93L6.89,10.16C6.15,10.5 5.44,10.91 4.8,11.4L6.6,13.8C7.38,13.22 8.26,12.77 9.2,12.47L11.75,15C10.5,15.07 9.34,15.5 8.4,16.2L12,21L14.46,17.73L17.74,21L19,19.72M12,3C9.85,3 7.8,3.38 5.9,4.07L8.29,6.47C9.5,6.16 10.72,6 12,6C15.38,6 18.5,7.11 21,9L22.8,6.6C19.79,4.34 16.06,3 12,3M12,9C11.62,9 11.25,9 10.88,9.05L14.07,12.25C15.29,12.53 16.43,13.07 17.4,13.8L19.2,11.4C17.2,9.89 14.7,9 12,9Z";
const p9 = $H, f9 = {
  "zoom-meetings": '<path d="M21.5 12.5c0 .96-.08 1.91-.23 2.83a7.198 7.198 0 01-5.95 5.95 17.527 17.527 0 01-5.66 0 7.198 7.198 0 01-5.95-5.95 17.527 17.527 0 010-5.66c.49-3.05 2.9-5.46 5.95-5.95a17.527 17.527 0 015.66 0c3.05.49 5.46 2.9 5.95 5.95.15.92.23 1.86.23 2.83z" fill="#0b5cff"/><path d="M14.43 14.75c0 .53-.43.96-.96.96H9.29c-1.07 0-1.93-.86-1.93-1.93v-3.54c0-.53.43-.96.96-.96h4.18c1.07 0 1.93.86 1.93 1.93v3.54zM16.87 9.86l-1.41 1.06c-.24.18-.39.47-.39.77v1.61c0 .3.14.59.39.77l1.41 1.06c.32.24.77.01.77-.39v-4.5c0-.4-.45-.62-.77-.39z" fill="#fff"/>',
  "google-meet": '<path fill="#1e88e5" d="M3.5 9.07v5.86l2.09.42 2.1-.42V9.07l-2.1-.42-2.09.42z"/><path d="M17.73 12v5.86c0 .69-.56 1.26-1.26 1.26H7.69l-.42-2.09.42-2.09h5.86v-2.93l2.09-.42 2.09.42z" fill="#4caf50"/><path d="M17.73 6.14V12h-4.19V9.07H7.68l-.42-2.09.42-2.09h8.79c.69 0 1.26.56 1.26 1.26z" fill="#fbc02d"/><path d="M7.69 14.93v4.19H4.76c-.69 0-1.26-.56-1.26-1.26v-2.93h4.19z" fill="#1565c0"/><path fill="#e53935" d="M7.69 4.88v4.19H3.5l4.19-4.19z"/><path fill="#2e7d32" d="M18.15 12l-.42 3.54L13.55 12l4.18-3.54.42 3.54z"/><path d="M21.5 6.19v11.63c0 .35-.41.55-.68.33l-3.09-2.6V8.48l3.09-2.6c.27-.22.68-.03.68.33z" fill="#4caf50"/>',
  "webex-meetings": '<defs><radialGradient id="prefix__b" cx="-951.63" cy="549.04" fx="-951.63" fy="549.04" r=".05" gradientTransform="matrix(-87.16473 -146.04628 -122.52671 73.12756 -15652.44 -179117.85)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#007383"/><stop offset=".41" stop-color="#00717e" stop-opacity=".75"/><stop offset=".87" stop-color="#007281" stop-opacity="0"/></radialGradient><radialGradient id="prefix__c" cx="-952.67" cy="549.07" fx="-952.67" fy="549.07" r=".05" gradientTransform="rotate(-126.7 -53497.341 -58162.752) scale(138.69 -91.09)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#218970"/><stop offset=".46" stop-color="#267e6a"/><stop offset="1" stop-color="#026c51" stop-opacity="0"/></radialGradient><radialGradient id="prefix__d" cx="-952.61" cy="541.2" fx="-952.61" fy="541.2" r=".05" gradientTransform="matrix(-33.8827 -107.79009 -56.09397 17.63256 -1902.72 -112216.84)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#178697"/><stop offset=".41" stop-color="#17838f" stop-opacity=".79"/><stop offset=".87" stop-color="#007281" stop-opacity="0"/></radialGradient><radialGradient id="prefix__e" cx="-949.76" cy="547.24" fx="-949.76" fy="547.24" r=".05" gradientTransform="matrix(-146.98086 -246.36712 -75.94201 45.30646 -98045.43 -258761.67)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#25342f" stop-opacity=".3"/><stop offset="1" stop-color="#25342f" stop-opacity="0"/></radialGradient><radialGradient id="prefix__f" cx="-942.87" cy="563.62" fx="-942.87" fy="563.62" r=".05" gradientTransform="rotate(85.1 -69752.427 38265.017) scale(108.08 -61.22)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#056d4f"/><stop offset=".23" stop-color="#056c4e" stop-opacity=".75"/><stop offset=".6" stop-color="#056c4e" stop-opacity=".3"/><stop offset=".87" stop-color="#056c4f" stop-opacity="0"/></radialGradient><radialGradient id="prefix__g" cx="-940.36" cy="556.77" fx="-940.36" fy="556.77" r=".05" gradientTransform="matrix(68.96997 106.65216 55.9082 -36.1548 33735.1 120422.29)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#22b67b"/><stop offset=".41" stop-color="#24be82"/><stop offset="1" stop-color="#24be82" stop-opacity=".07"/></radialGradient><radialGradient id="prefix__i" cx="-940.77" cy="554.96" fx="-940.77" fy="554.96" r=".05" gradientTransform="rotate(49.69 -177135.555 122596.9) scale(165.85 -165.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></radialGradient><radialGradient id="prefix__j" cx="-944.1" cy="553.18" fx="-944.1" fy="553.18" r=".05" gradientTransform="rotate(48.05 -367132.581 263331.898) scale(336.36 -335.78)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00b8ff"/><stop offset=".75" stop-color="#00b9fc" stop-opacity="0"/></radialGradient><radialGradient id="prefix__k" cx="-951.17" cy="546.23" fx="-951.17" fy="546.23" r=".05" gradientTransform="matrix(-48.64247 -154.74493 -107.10322 33.66679 12252.88 -165563.53)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00bcff" stop-opacity=".76"/><stop offset=".57" stop-color="#00bafc" stop-opacity="0"/></radialGradient><radialGradient id="prefix__l" cx="-953.78" cy="550.07" fx="-953.78" fy="550.07" r=".05" gradientTransform="matrix(-72.9418 -88.45403 -61.91396 51.05608 -35502.54 -112443.2)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5fec50"/><stop offset="1" stop-color="#3cc08e" stop-opacity="0"/></radialGradient><radialGradient id="prefix__m" cx="-954.59" cy="523.18" fx="-954.59" fy="523.18" r=".05" gradientTransform="rotate(-79.11 -8961.313 -26349.067) scale(34.73 -23.99)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#28855b"/><stop offset="1" stop-color="#14795c" stop-opacity="0"/></radialGradient><radialGradient id="prefix__n" cx="-955.7" cy="534.72" fx="-955.7" fy="534.72" r=".05" gradientTransform="matrix(6.00138 -27.99393 -39.07222 -8.37636 26647.75 -22260.21)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#28855b"/><stop offset="1" stop-color="#14795c" stop-opacity="0"/></radialGradient><radialGradient id="prefix__o" cx="-954.99" cy="550.19" fx="-954.99" fy="550.19" r=".05" gradientTransform="matrix(-64.43177 -69.7019 -48.95728 45.25565 -34575.21 -91452.74)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5ff05b"/><stop offset=".81" stop-color="#5de955" stop-opacity="0"/></radialGradient><radialGradient id="prefix__p" cx="-938.28" cy="553.05" fx="-938.28" fy="553.05" r=".05" gradientTransform="matrix(66.96005 51.3617 71.4219 -93.11248 23342.15 99701.75)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".97" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__q" cx="-940.1" cy="550.5" fx="-940.1" fy="550.5" r=".05" gradientTransform="matrix(98.43675 14.71147 21.98813 -147.126 80455.97 94829.3)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".59" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__r" cx="-938.38" cy="551.97" fx="-938.38" fy="551.97" r=".05" gradientTransform="rotate(24.69 -231174.852 140478.806) scale(85.04 -151.66)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".76" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__s" cx="-945.2" cy="560.82" fx="-945.2" fy="560.82" r=".05" gradientTransform="rotate(95.79 -93552.04 41883.384) scale(153.04 -83.75)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".59" stop-color="#123aa8" stop-opacity="0"/><stop offset="1" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__t" cx="-945.05" cy="562.66" fx="-945.05" fy="562.66" r=".05" gradientTransform="rotate(93.66 -104350.43 63182.76) scale(184.18 -65.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__u" cx="-942.29" cy="567.94" fx="-942.29" fy="567.94" r=".05" gradientTransform="matrix(8.78957 97.33394 51.50044 -4.65066 -20951.98 94373.6)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__v" cx="-942.85" cy="562.23" fx="-942.85" fy="562.23" r=".05" gradientTransform="matrix(4.89377 101.88254 84.00315 -4.03496 -42611.94 98338.06)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__w" cx="-941.74" cy="549.74" fx="-941.74" fy="549.74" r=".05" gradientTransform="rotate(-23.2 244205.91 -321749.854) scale(113.62 -222.29)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".71" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__x" cx="-959.91" cy="553.32" fx="-959.91" fy="553.32" r=".05" gradientTransform="matrix(-70.50332 -26.36011 -45.18376 120.84945 -42670.87 -92159.05)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#1a3da0"/><stop offset=".71" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__y" cx="-940.3" cy="551.63" fx="-940.3" fy="551.63" r=".05" gradientTransform="matrix(137.44492 41.41855 41.86 -138.90985 106154.62 115588.85)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#1e3882"/><stop offset=".76" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__A" cx="-940.77" cy="554.96" fx="-940.77" fy="554.96" r=".05" gradientTransform="rotate(49.69 -177135.55 122596.884) scale(165.85 -165.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></radialGradient><radialGradient id="prefix__D" cx="-951.17" cy="546.23" fx="-951.17" fy="546.23" r=".05" gradientTransform="matrix(-48.64247 -154.74493 -107.10322 33.66679 12252.88 -165563.53)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00bcff" stop-opacity=".76"/><stop offset=".57" stop-color="#00bafc" stop-opacity="0"/></radialGradient><linearGradient id="prefix__a" x1="76.14" y1="-95.89" x2="64.37" y2="-99.75" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5cee64"/><stop offset="1" stop-color="#0bf"/></linearGradient><linearGradient id="prefix__h" x1="56.74" y1="-98.36" x2="65.09" y2="-98.43" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient><linearGradient id="prefix__z" x1="61.48" y1="-92.95" x2="67.9" y2="-97.04" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset=".23" stop-color="#1dc4ff"/><stop offset="1" stop-color="#1cc1ff" stop-opacity="0"/></linearGradient><linearGradient id="prefix__B" x1="63.13" y1="-92.11" x2="64.93" y2="-93.74" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#26fbff"/><stop offset=".64" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient><linearGradient id="prefix__C" x1="60.36" y1="-97.78" x2="62.85" y2="-97.95" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#26fbff"/><stop offset=".64" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient></defs><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__a)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__b)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__c)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__d)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__e)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__f)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__g)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__h)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__i)"/><path d="M15.37 5.44c-1.34 0-2.88.45-3.9 2.4-.59 1.12-.89 2.38-1.16 3.63-.09.41-.18.83-.28 1.22v5.66c.51-.14 1.05-.42 1.57-.95 1.96-1.99 2.28-7.2 3.26-8.19.11-.11.23-.18.36-.18.39 0 .7.5.99 1.1.32.67.71 1.43 1.84 1.43.52 0 1.72-.38 1.72-1.85 0-.88-1.47-4.28-4.39-4.28z" fill="url(#prefix__j)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__k)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__l)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__m)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__n)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__o)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="#316aff"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__p)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__q)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__r)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__s)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__t)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__u)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__v)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__w)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__x)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__y)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__z)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__A)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__B)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__C)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__D)"/>',
  "microsoft-teams": '<path d="M15.56 9.91h4.65c.44 0 .8.36.8.8v4.24c0 1.61-1.31 2.92-2.92 2.92h-.01c-1.61 0-2.92-1.31-2.92-2.92v-4.62c0-.23.19-.42.42-.42z" fill="#5059c9"/><circle cx="18.7" cy="7.19" r="1.88" fill="#5059c9"/><circle cx="12.84" cy="6.35" r="2.72" fill="#7b83eb"/><path d="M16.47 9.91H8.8a.79.79 0 00-.77.8v4.83c-.06 2.6 2 4.77 4.6 4.83 2.6-.06 4.67-2.23 4.6-4.83v-4.83a.783.783 0 00-.77-.8z" fill="#7b83eb"/><path d="M3.77 7.4h7.67c.42 0 .77.34.77.77v7.67c0 .42-.34.77-.77.77H3.77a.77.77 0 01-.77-.77V8.17c0-.42.34-.77.77-.77z" fill="#5a62c3"/><path d="M9.62 10.32H8.09v4.18h-.98v-4.18H5.58v-.81h4.04v.81z" fill="#fff"/>'
}, VH = {
  box: "M15.39,14.04V14.04C15.39,12.62 14.24,11.47 12.82,11.47C11.41,11.47 10.26,12.62 10.26,14.04V14.04C10.26,15.45 11.41,16.6 12.82,16.6C14.24,16.6 15.39,15.45 15.39,14.04M17.1,14.04C17.1,16.4 15.18,18.31 12.82,18.31C11.19,18.31 9.77,17.39 9.05,16.04C8.33,17.39 6.91,18.31 5.28,18.31C2.94,18.31 1.04,16.43 1,14.11V14.11H1V7H1V7C1,6.56 1.39,6.18 1.86,6.18C2.33,6.18 2.7,6.56 2.71,7V7H2.71V10.62C3.43,10.08 4.32,9.76 5.28,9.76C6.91,9.76 8.33,10.68 9.05,12.03C9.77,10.68 11.19,9.76 12.82,9.76C15.18,9.76 17.1,11.68 17.1,14.04V14.04M7.84,14.04V14.04C7.84,12.62 6.69,11.47 5.28,11.47C3.86,11.47 2.71,12.62 2.71,14.04V14.04C2.71,15.45 3.86,16.6 5.28,16.6C6.69,16.6 7.84,15.45 7.84,14.04M22.84,16.96V16.96C22.95,17.12 23,17.3 23,17.47C23,17.73 22.88,18 22.66,18.15C22.5,18.26 22.33,18.32 22.15,18.32C21.9,18.32 21.65,18.21 21.5,18L19.59,15.47L17.7,18V18C17.53,18.21 17.28,18.32 17.03,18.32C16.85,18.32 16.67,18.26 16.5,18.15C16.29,18 16.17,17.72 16.17,17.46C16.17,17.29 16.23,17.11 16.33,16.96V16.96H16.33V16.96L18.5,14.04L16.33,11.11V11.11H16.33V11.11C16.22,10.96 16.17,10.79 16.17,10.61C16.17,10.35 16.29,10.1 16.5,9.93C16.89,9.65 17.41,9.72 17.7,10.09V10.09L19.59,12.61L21.5,10.09C21.76,9.72 22.29,9.65 22.66,9.93C22.89,10.1 23,10.36 23,10.63C23,10.8 22.95,10.97 22.84,11.11V11.11H22.84V11.11L20.66,14.04L22.84,16.96V16.96H22.84Z",
  dropbox: "M3 6.2L8 9.39L13 6.2L8 3L3 6.2M13 6.2L18 9.39L23 6.2L18 3L13 6.2M3 12.55L8 15.74L13 12.55L8 9.35L3 12.55M18 9.35L13 12.55L18 15.74L23 12.55L18 9.35M8.03 16.8L13.04 20L18.04 16.8L13.04 13.61L8.03 16.8Z",
  "google-drive": "M7.71,3.5L1.15,15L4.58,21L11.13,9.5M9.73,15L6.3,21H19.42L22.85,15M22.28,14L15.42,2H8.58L8.57,2L15.43,14H22.28Z",
  onedrive: "M18.21 10.29Q19 10.34 19.7 10.68 20.39 11 20.9 11.57 21.41 12.12 21.71 12.83 22 13.54 22 14.34 22 15.18 21.68 15.92 21.36 16.66 20.8 17.21 20.25 17.76 19.5 18.08 18.78 18.41 17.94 18.41H7Q5.97 18.41 5.06 18 4.15 17.61 3.47 16.94 2.79 16.26 2.4 15.35 2 14.44 2 13.41 2 12.59 2.26 11.83 2.5 11.08 3 10.45 3.44 9.82 4.08 9.35 4.72 8.88 5.5 8.63 5.87 8.5 6.21 8.5 6.56 8.43 6.93 8.41H6.94Q7.37 7.75 7.95 7.23 8.5 6.71 9.2 6.34 9.87 6 10.62 5.78 11.37 5.59 12.16 5.59 13.22 5.59 14.2 5.94 15.18 6.29 16 6.91 16.8 7.53 17.37 8.39 17.95 9.26 18.21 10.29M12.16 6.84Q11.05 6.84 10.06 7.3 9.06 7.75 8.36 8.6 8.73 8.7 9.07 8.85 9.4 9 9.73 9.2L13.71 11.58L16 10.62Q16.21 10.53 16.44 10.45 16.67 10.38 16.92 10.33 16.68 9.55 16.21 8.91 15.74 8.27 15.11 7.81 14.5 7.35 13.73 7.1 13 6.84 12.16 6.84M4 15.66L12.27 12.18L9.08 10.26Q8.59 9.97 8.06 9.81 7.5 9.66 6.95 9.66 6.19 9.66 5.5 9.96 4.84 10.26 4.34 10.77 3.84 11.29 3.54 11.97 3.25 12.65 3.25 13.41 3.25 14 3.45 14.59 3.64 15.19 4 15.66M17.94 17.16Q18.41 17.16 18.84 17 19.27 16.86 19.64 16.58L13.61 13L5.03 16.59Q5.47 16.86 5.97 17 6.47 17.16 7 17.16M20.45 15.61Q20.75 15 20.75 14.34 20.75 13.7 20.5 13.17 20.26 12.65 19.85 12.28 19.43 11.91 18.88 11.71 18.32 11.5 17.7 11.5 17.35 11.5 17 11.6 16.66 11.68 16.33 11.81 16 11.93 15.67 12.08 15.35 12.23 15.04 12.37Z"
}, DH = {
  email: FU,
  file: jU,
  "file-upload": GU,
  "file-music": HU,
  "file-image": UU,
  "file-video": KU,
  "file-code": d9,
  "file-xml": d9,
  "file-document": u9,
  "file-word": JU,
  "file-excel": BU,
  "file-pdf": u9,
  "file-powerpoint": YU,
  "file-compressed": iH
}, y9 = {
  "account-minus": dU,
  "account-plus": uU,
  alert: pU,
  "alert-circle": fU,
  "alert-octagon": yU,
  "arrow-collapse": mU,
  "arrow-expand": gU,
  attachment: vU,
  back: h9,
  "backup-restore": OU,
  bell: bU,
  "bell-off": $U,
  agent: TH,
  check: w$,
  "check-all": kU,
  "check-circle-outline": CU,
  "checkbox-blank": PU,
  "checkbox-marked": QU,
  "circle-outline": TU,
  "check-circle": SU,
  close: MU,
  "close-circle": AU,
  cloud: RU,
  comment: EU,
  "comment-outline": _U,
  "content-save": zU,
  delete: IU,
  "delete-restore": VU,
  "delete-forever": WU,
  "dots-vertical": DU,
  download: qU,
  earth: ZU,
  emoticon: XU,
  "emoticon-plus": NU,
  "fit-screen": eH,
  "fit-width": tH,
  fullscreen: sH,
  "fullscreen-exit": rH,
  "help-circle": aH,
  information: oH,
  magnify: lH,
  meeting: fH,
  "menu-down": cH,
  "menu-up": hH,
  message: dH,
  "message-text": uH,
  minus: pH,
  next: wU,
  "open-in-new": yH,
  pencil: mH,
  pin: gH,
  unpin: wH,
  plus: vH,
  "plus-circle-outline": OH,
  poll: xU,
  previous: h9,
  read: w$,
  restore: bH,
  unread: w$,
  send: xH,
  "server-network-off": kH,
  "shield-star": SH,
  "shield-star-outline": CH,
  sort: PH,
  star: QH,
  unstar: MH,
  stars: LU,
  "swap-horizontal": AH,
  textbox: nH,
  "thumb-up": RH,
  "thumb-up-outline": EH,
  trashcan: _H,
  video: zH,
  "view-list-outline": LH,
  "view-module-outline": IH,
  "wifi-off": WH,
  ...DH,
  ...VH
}, m9 = {
  dropbox: "#0061fe",
  onedrive: "#0078d4",
  box: "#0161d5",
  "google-drive": "#1a73e8",
  zoom: "#4a8cff"
};
function uS(n) {
  return n && n in y9 ? y9[n] : "";
}
c(uS, "tf");
d(uS, "getIconMapping");
function HI(n) {
  return n && n in f9 ? f9[n] : "";
}
c(HI, "Y2");
d(HI, "getSvgMapping");
var af;
const YI = (af = class extends Am {
  constructor(t) {
    if (super(t), this.it = C, t.type !== O1.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(t) {
    if (t === C || t == null) return this._t = void 0, this.it = t;
    if (t === ls) return t;
    if (typeof t != "string") throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (t === this.it) return this._t;
    this.it = t;
    const e = [t];
    return e.raw = e, this._t = { _$litType$: this.constructor.resultType, strings: e, values: [] };
  }
}, c(af, "mw"), af);
d(YI, "e");
let yb = YI;
yb.directiveName = "unsafeHTML", yb.resultType = 1;
const ol = Ll(yb);
var of;
const GI = (of = class extends yb {
}, c(of, "vw"), of);
d(GI, "t");
let pS = GI;
pS.directiveName = "unsafeSVG", pS.resultType = 2;
const g9 = Ll(pS), v4 = et`[part~=wy-icon-wrapper]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative}[part~=wy-icon]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-icon][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon-first]{margin-left:calc(-.5*var(--wy-size, 1rem))}[part~=wy-icon-last]{margin-right:calc(-.5*var(--wy-size, 1rem))}[part~=wy-icon-inline]{vertical-align:-.25em}[part~=wy-icon-overlay]{position:absolute;bottom:0;right:0;border-radius:50%}:host(wy-icon-stack),[part~=wy-icon-stack]{display:inline-flex;position:relative;line-height:1}[part~=wy-icon-stack-layer]{position:absolute}[part~=wy-icon-stack-overlay]{position:absolute;bottom:0;right:0;border-radius:50%;width:calc(var(--wy-component-icon-width)/2);height:calc(var(--wy-component-icon-height)/2)}[part~=wy-icon-current-color]{fill:currentColor}[part~=wy-icon-state]{transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));align-self:center;justify-self:center;margin:auto;opacity:0}[part~=wy-icon-state][part~=wy-active]{opacity:1}[part~=wy-icon-display]{color:var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));border-radius:var(--wy-component-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;padding:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem))}[part~=wy-icon-display-fill]{flex:1 0 auto}[part~=wy-icon-display-icon]{color:var(--wy-component-color);--wy-component-icon-width: calc(4 * var(--wy-size, 1rem));--wy-component-icon-height: calc(4 * var(--wy-size, 1rem));padding:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem))}[part~=wy-icon-display-text],[part~=wy-icon-display-meta]{color:var(--wy-component-color);padding:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem));text-align:center;line-height:var(--wy-line-height, 1.5)}[part~=wy-icon-color-primary]{fill:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-icon-color-secondary]{fill:var(--wy-secondary, var(--wy-secondary-light, #51606f))}[part~=wy-icon-color-tertiary]{fill:var(--wy-tertiary, var(--wy-tertiary-light, #645f41))}[part~=wy-icon-color-surface]{fill:var(--wy-surface, var(--wy-surface-light, #f7f9ff))}[part~=wy-icon-color-surface-variant]{fill:var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb))}[part~=wy-icon-color-error]{fill:var(--wy-error, var(--wy-error-light, #ba1821))}[part~=wy-icon-color-warning]{fill:var(--wy-warning, var(--wy-warning-light, #adb140))}[part~=wy-icon-color-blue]{fill:var(--wy-blue, var(--wy-blue-light, #8aa9fc))}[part~=wy-icon-color-indigo]{fill:var(--wy-indigo, var(--wy-indigo-light, #9285de))}[part~=wy-icon-color-purple]{fill:var(--wy-purple, var(--wy-purple-light, #c675b6))}[part~=wy-icon-color-pink]{fill:var(--wy-pink, var(--wy-pink-light, #d57193))}[part~=wy-icon-color-red]{fill:var(--wy-red, var(--wy-red-light, #db726b))}[part~=wy-icon-color-orange]{fill:var(--wy-orange, var(--wy-orange-light, #e79b3a))}[part~=wy-icon-color-yellow]{fill:var(--wy-yellow, var(--wy-yellow-light, #adb140))}[part~=wy-icon-color-green]{fill:var(--wy-green, var(--wy-green-light, #00a38d))}[part~=wy-icon-color-teal]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a9))}[part~=wy-icon-color-cyan]{fill:var(--wy-cyan, var(--wy-cyan-light, #0081a2))}[part~=wy-icon-color-gray]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-icon-color-black]{fill:var(--wy-black, var(--wy-black, #000000))}[part~=wy-icon-color-white]{fill:var(--wy-white, var(--wy-white, #ffffff))}[part*=wy-kind-]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-kind-archive]{fill:var(--wy-orange, var(--wy-orange-light, #e79b3a))}[part~=wy-kind-audio]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a9))}[part~=wy-kind-code]{fill:var(--wy-green, var(--wy-green-light, #00a38d))}[part~=wy-kind-document]{fill:var(--wy-blue, var(--wy-blue-light, #8aa9fc))}[part~=wy-kind-email]{fill:var(--wy-red, var(--wy-red-light, #db726b))}[part~=wy-kind-presentation]{fill:var(--wy-orange, var(--wy-orange-light, #e79b3a))}[part~=wy-kind-spreadsheet]{fill:var(--wy-green, var(--wy-green-light, #00a38d))}[part~=wy-kind-image]{fill:var(--wy-pink, var(--wy-pink-light, #d57193))}[part~=wy-kind-text]{fill:var(--wy-cyan, var(--wy-cyan-light, #0081a2))}[part~=wy-kind-video]{fill:var(--wy-purple, var(--wy-purple-light, #c675b6))}[part~=wy-ext-pdf]{fill:var(--wy-red, var(--wy-red-light, #db726b))}[part~=wy-kind-text-icon]{width:calc(1.25*var(--wy-size, 1rem));height:calc(1.25*var(--wy-size, 1rem));vertical-align:calc(-.3125*var(--wy-size, 1rem))}`;
var qH = Object.defineProperty, ZH = Object.getOwnPropertyDescriptor, be = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? ZH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && qH(t, e, s), s;
}, "__decorateClass$1a"), v$, lf;
let he = (v$ = (lf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.color = "", this.size = 24, this.path = p9, this.inline = !1, this.first = !1, this.last = !1, this.layer = !1, this.state = !1, this.active = !1, this.uniqueId = `wy-icon-${sm()}`;
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("name") && this.name && (this.path = uS(this.name) || p9, this.overlayPath = uS(this.overlayName) || this.overlayPath, this.nativeIconColor = this.color === "native" && m9[this.name] || void 0, this.nativeOverlayColor = this.overlayName && m9[this.overlayName] || void 0);
  }
  render() {
    const t = this.kind ? xP(this.kind) : this.kind, e = this.ext?.startsWith(".") ? this.ext.substring(1) : this.ext, i = {
      "wy-icon-wrapper": !0,
      "wy-icon-stack-layer": this.layer
    }, s = {
      "wy-icon": !0,
      "wy-icon-current-color": !t && !this.color,
      ["wy-kind-" + t]: !!t,
      ["wy-ext-" + e]: !!e,
      ["wy-icon-color-" + this.color]: !!this.color,
      "wy-icon-first": this.first,
      "wy-icon-last": this.last,
      "wy-icon-inline": this.inline,
      "wy-icon-state": this.state,
      "wy-active": this.active
    }, r = this.size !== 24, a = this.size / 16, o = r ? `width: var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem))); height: var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem)));` : "", l = this.svg && HI(this.svg);
    return this.overlayPath ? [
      v`
          <style>
            .icon-mask-bg {
              width: var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem)));
              height: var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem)));
              fill: white;
            }

            .icon-mask {
              width: calc(var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem))));
              height: calc(var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem))));
              ry: calc(var(--wy-border-radius-pill, var(--wy-border-radius, 50%)));
              x: calc(var(--wy-component-icon-width, calc(${a} * var(--wy-size, 1rem))) / 2);
              y: calc(var(--wy-component-icon-height, calc(${a} * var(--wy-size, 1rem))) / 2);
              stroke: black;
              stroke-width: 4px;
              fill: black;
            }
          </style>
        `,
      v`
          <div part=${ut(i)}>
            <wy-icon-stack style="${o}">
              <svg
                part=${ut(s)}
                viewBox="0 0 24 24"
                width="${this.size}"
                height="${this.size}"
                style="mask-image: url(#${this.uniqueId}-mask); -webkit-mask-image: url(#${this.uniqueId}-mask);"
              >
                <defs>
                  <mask id="${this.uniqueId}-mask">
                    <rect class="icon-mask-bg" />
                    <rect class="icon-mask" />
                  </mask>
                </defs>
                ${l ? g9(l) : jO`
                    <path d="${this.path}" style="fill: ${Ot(this.nativeIconColor)}" />
                  `}
                <!--rect width="24" height="24" fill="transparent" /-->
              </svg>
              <svg part="wy-icon-stack-overlay" viewBox="0 0 24 24" width="${this.size / 2}" height="${this.size / 2}">
                <path d="${this.overlayPath}" style="fill: ${Ot(this.nativeOverlayColor)}" />
                <!--rect width="24" height="24" fill="transparent" /-->
              </svg>
            </wy-icon-stack>
            <slot></slot>
          </div>
        `
    ] : v`
      <div part=${ut(i)}>
        <svg
          part=${ut(s)}
          style="${o}"
          viewBox="0 0 24 24"
          width="${this.size}"
          height="${this.size}"
        >
          ${l ? g9(l) : jO`
            <path d="${this.path}" style="fill: ${Ot(this.nativeIconColor)}" />
          `}
          <!--rect width="24" height="24" fill="transparent" /-->
        </svg>
        <slot></slot>
      </div>
    `;
  }
}, c(lf, "Sa"), lf), d(v$, "WyIcon"), v$);
he.styles = [ne, v4, ft];
be([
  O()
], he.prototype, "name", 2);
be([
  O()
], he.prototype, "overlayName", 2);
be([
  O()
], he.prototype, "svg", 2);
be([
  O()
], he.prototype, "color", 2);
be([
  O({ type: Number })
], he.prototype, "size", 2);
be([
  O()
], he.prototype, "kind", 2);
be([
  O()
], he.prototype, "ext", 2);
be([
  O({ attribute: !1 })
], he.prototype, "path", 2);
be([
  O({ attribute: !1 })
], he.prototype, "overlayPath", 2);
be([
  O({ type: Boolean })
], he.prototype, "inline", 2);
be([
  O({ type: Boolean })
], he.prototype, "first", 2);
be([
  O({ type: Boolean })
], he.prototype, "last", 2);
be([
  O({ type: Boolean })
], he.prototype, "layer", 2);
be([
  O({ type: Boolean })
], he.prototype, "state", 2);
be([
  O({ type: Boolean })
], he.prototype, "active", 2);
be([
  F()
], he.prototype, "nativeIconColor", 2);
be([
  F()
], he.prototype, "nativeOverlayColor", 2);
he = be([
  U("wy-icon")
], he);
var O$, cf;
let mb = (O$ = (cf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this);
  }
  render() {
    return v`<slot></slot>`;
  }
}, c(cf, "Aa"), cf), d(O$, "WyIconStack"), O$);
mb.styles = [ne, v4];
mb = be([
  U("wy-icon-stack")
], mb);
var b$, hf;
let Dw = (b$ = (hf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.fill = !1;
  }
  render() {
    return v`
      <div part="wy-icon-display ${ut({ "wy-icon-display-fill": this.fill })}">
        <div part="wy-icon-display-icon">
          <slot></slot>
        </div>
        <div part="wy-icon-display-text">
          <slot name="text"></slot>
        </div>
        <div part="wy-icon-display-meta">
          <slot name="meta"></slot>
        </div>
      </div>
    `;
  }
}, c(hf, "za"), hf), d(b$, "WyIconDisplay"), b$);
Dw.styles = [ne, v4, ft];
be([
  O({ type: Boolean })
], Dw.prototype, "fill", 2);
Dw = be([
  U("wy-icon-display")
], Dw);
var FH = Object.defineProperty, XH = Object.getOwnPropertyDescriptor, en = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? XH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && FH(t, e, s), s;
}, "__decorateClass$19"), $$, df;
let hs = ($$ = (df = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.size = 32, this.src = "", this.name = "", this.description = "", this.isAgent = !1;
  }
  render() {
    const t = this.size / 16;
    let e;
    !this.src && this.name && (e = L_(this.name));
    const i = {
      "wy-avatar-shape": !0,
      "wy-avatar-img": !!this.src,
      "wy-avatar-initials": !this.src,
      "wy-presence-mask": this.presence === m4.Active
    };
    return v`
      ${this.src ? v`
            <img
              alt=""
              title="${this.name}${this.description ? ` • ${this.description}` : ""}"
              part=${ut(i)}
              style="--wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));"
              height="${this.size}"
              width="${this.size}"
              src="${this.src}"
              decoding="async"
              loading="lazy"
            />
          ` : v`
            <div
              part=${ut(i)}
              style="--wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));"
              title="${this.name}${this.description ? ` • ${this.description}` : ""}"
            >
              <span part="wy-avatar-initials-text">${e}</span>
            </div>
          `}
      ${this.isAgent ? v`<wy-icon part="wy-avatar-type-icon" name="agent" size="${this.size / 3 * 1.25}"></wy-icon>` : C}
      ${this.presence && !this.isAgent ? v`<wy-presence part="wy-avatar-presence" .status=${this.presence} id=${this.id}></wy-presence>` : C}
    `;
  }
}, c(df, "Ra"), df), d($$, "WyAvatar"), $$);
hs.styles = [ne, g4, UI];
en([
  O({ type: Number })
], hs.prototype, "size", 2);
en([
  O()
], hs.prototype, "src", 2);
en([
  O()
], hs.prototype, "name", 2);
en([
  O()
], hs.prototype, "description", 2);
en([
  O({ type: Boolean, reflect: !0 })
], hs.prototype, "isAgent", 2);
en([
  O()
], hs.prototype, "presence", 2);
hs = en([
  U("wy-avatar")
], hs);
var x$, uf;
let ll = (x$ = (uf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.size = 32, this.uniqueId = `wy-avatar-${sm()}`;
  }
  render() {
    if (!this.user)
      return C;
    const t = this.size / 16, e = (this.members || []).filter((r) => r.id !== this.user?.id).slice(0, 2).reverse(), i = e?.shift() || this.user, s = e?.shift() || (i !== this.user ? this.user : void 0);
    return [
      v`
        <style>
          :host {
            --wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));
          }

          [part~="wy-avatar-mask-bg"] {
            width: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            height: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            fill: white;
          }

          [part~="wy-avatar-mask"] {
            width: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            height: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            ry: var(--wy-avatar-border-radius, var(--wy-border-radius-pill, var(--wy-border-radius, 50%)));
            x: calc(${t / 3} * var(--wy-size, 1rem));
            y: calc(${t / 3} * var(--wy-size, 1rem));
            stroke: black;
            stroke-width: 4px;
            fill: black;
          }
        </style>
      `,
      v`
        <svg>
          <defs>
            <mask id="${this.uniqueId}-mask">
              <rect part="wy-avatar-mask-bg" />
              <rect part="wy-avatar-mask" />
            </mask>
          </defs>
        </svg>
      `,
      v`
        <wy-avatar
          part="wy-avatar-back"
          style="mask-image: url(#${this.uniqueId}-mask); -webkit-mask-image: url(#${this.uniqueId}-mask);"
          .src=${s?.avatar_url}
          .name=${s?.name}
          size=${this.size * 2 / 3}
        ></wy-avatar>
        <wy-avatar
          part="wy-avatar-front"
          .src=${i.avatar_url}
          .name=${i.name}
          .isAgent=${i.is_agent}
          size=${this.size * 2 / 3}
        ></wy-avatar>
      `
    ];
  }
}, c(uf, "Ea"), uf), d(x$, "WyAvatarGroup"), x$);
ll.styles = [ne, g4, ft];
en([
  O({ type: Number })
], ll.prototype, "size", 2);
en([
  O({
    type: Array,
    attribute: !1
  })
], ll.prototype, "members", 2);
en([
  Ve({ context: p0, subscribe: !0 }),
  F()
], ll.prototype, "user", 2);
ll = en([
  U("wy-avatar-group")
], ll);
var k$, pf;
let qw = (k$ = (pf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this);
  }
  render() {
    return v`
      <slot></slot>
      ${this.description ? v` <div part="wy-avatar-description">${this.description}</div> ` : C}
    `;
  }
}, c(pf, "La"), pf), d(k$, "WyAvatarHeader"), k$);
qw.styles = [ne, g4];
en([
  O()
], qw.prototype, "description", 2);
qw = en([
  U("wy-avatar-header")
], qw);
const NH = et`[part~=wy-empty]{display:flex;align-items:center;justify-content:center;flex:1;min-width:0;position:relative;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}`, KI = et`[part~=wy-progress]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative}[part~=wy-progress-padded]{margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-progress-overlay]{position:absolute!important}[part~=wy-progress-reveal]{overflow:hidden;opacity:1;interpolate-size:allow-keywords;height:auto;transition:width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),margin var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-progress-reveal]{width:0;height:0;opacity:0;margin:0}}`, jH = et`[part~=wy-progress-circular]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-progress-circular]:not([width]),[part~=wy-progress-circular][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress-circular]:not([height]),[part~=wy-progress-circular][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress-circular][part~=wy-primary]{color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-progress-remaining]{fill:none;stroke:var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb))}[part~=wy-progress-done]{fill:none;stroke:currentColor}[part~=wy-progress-overlay]{position:absolute;inset:0;margin:auto}[part~=wy-progress-indeterminate-circle]{stroke-dasharray:1,100;stroke-dashoffset:0;transform-origin:center;fill:none!important}[part~=wy-progress-indeterminate]{animation:wy-rotate 1.4s linear infinite}[part~=wy-progress-indeterminate] [part~=wy-progress-indeterminate-circle]{animation:wy-dash 1.4s ease-in-out infinite,wy-color 2.8s ease-in-out infinite}@keyframes wy-rotate{to{transform:rotate(360deg)}}@keyframes wy-dash{0%{stroke-dasharray:1,100;stroke-dashoffset:0}50%{stroke-dasharray:44.5,100;stroke-dashoffset:-17.5}to{stroke-dasharray:44.5,100;stroke-dashoffset:-62}}@keyframes wy-color{0%,to{stroke:var(--wy-primary, var(--wy-primary-light, #2f628c))}25%{stroke:var(--wy-primary, var(--wy-primary-light, #2f628c))}50%{stroke:#0000}75%{stroke:var(--wy-primary, var(--wy-primary-light, #2f628c))}}`;
var BH = Object.defineProperty, UH = Object.getOwnPropertyDescriptor, Oa = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? UH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && BH(t, e, s), s;
}, "__decorateClass$18"), S$, ff;
let Rn = (S$ = (ff = class extends pt {
  constructor() {
    super(...arguments), this.shadowParts = new Y(this), this.size = 24, this.indeterminate = !1, this.padded = !1, this.overlay = !1, this.value = 0, this.max = 1, this.reveal = !1;
  }
  render() {
    const t = {
      "wy-progress": !0,
      "wy-progress-reveal": this.reveal,
      "wy-progress-overlay": this.overlay,
      "wy-progress-padded": this.padded
    }, e = {
      "wy-progress-circular": !0,
      "wy-primary": !this.indeterminate,
      "wy-progress-indeterminate": this.indeterminate
    }, i = 10, s = Math.PI * (i * 2);
    let r;
    try {
      Number.isFinite(this.value) && Number.isFinite(this.max) && this.max > 0 && (r = this.value / this.max);
    } catch (a) {
      console.error(a);
    }
    return v`
      <div part="${ut(t)}">
        ${this.indeterminate || r === void 0 ? jO`
              <svg
                part="${ut(e)}"
                viewBox="0 0 24 24"
                width=${this.size}
                height=${this.size}
                role="progressbar"
                aria-label="${C}"
                aria-valuemin="0"
                aria-valuemax=${this.max}
                aria-valuenow=${C}
                xmlns="http://www.w3.org/2000/svg"
              >
                <circle
                  part="wy-progress-circle wy-progress-indeterminate-circle"
                  fill="none"
                  cx="12"
                  cy="12"
                  r=${i}
                  stroke-linecap="butt"
                  stroke-width="2"
                ></circle>
              </svg>
            ` : jO`
              <svg
                part="${ut(e)}"
                viewBox="0 0 24 24"
                width=${this.size}
                height=${this.size}
                transform="rotate(-90)"
                role="progressbar"
                aria-label="${C}"
                aria-valuemin="0"
                aria-valuemax=${this.max}
                aria-valuenow=${this.value}
                xmlns="http://www.w3.org/2000/svg"
              >
                <circle
                  part="wy-progress-circle wy-progress-remaining"
                  cx="12"
                  cy="12"
                  r=${i}
                  stroke-linecap="butt"
                  stroke-width="2"
                  fill="none"
                  stroke="#eee"
                ></circle>
                <circle
                  part="wy-progress-circle wy-progress-done"
                  cx="12"
                  cy="12"
                  r=${i}
                  stroke-dasharray=${s}
                  stroke-dashoffset=${s * (1 - r)}
                  stroke-linecap="butt"
                  stroke-width="2"
                  fill="none"
                  stroke="currentColor"
                  path-length="200"
                ></circle>
              </svg>
            `}
      </div>
    `;
  }
}, c(ff, "Oa"), ff), d(S$, "WyProgressCircular"), S$);
Rn.styles = [ne, KI, jH, ft];
Oa([
  O({ type: Number })
], Rn.prototype, "size", 2);
Oa([
  O({ type: Boolean })
], Rn.prototype, "indeterminate", 2);
Oa([
  O({ type: Boolean })
], Rn.prototype, "padded", 2);
Oa([
  O({ type: Boolean })
], Rn.prototype, "overlay", 2);
Oa([
  O({ type: Number })
], Rn.prototype, "value", 2);
Oa([
  O({ type: Number })
], Rn.prototype, "max", 2);
Oa([
  O({ type: Boolean })
], Rn.prototype, "reveal", 2);
Rn = Oa([
  U("wy-progress-circular")
], Rn);
var HH = Object.defineProperty, YH = Object.getOwnPropertyDescriptor, O4 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? YH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && HH(t, e, s), s;
}, "__decorateClass$17"), C$, yf;
let hm = (C$ = (yf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.noNetwork = !1, this.handleUpdate = () => this.requestUpdate();
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("weavy")) {
      const e = t.get("weavy");
      e && e !== this.weavy && e.removeNetworkListener(this.handleUpdate), this.weavy && e !== this.weavy && this.weavy.addNetworkListener(this.handleUpdate);
    }
  }
  render() {
    return v`
      <div part="wy-empty">
        ${this.weavy && !this.noNetwork && this.weavy?.network.state === "unreachable" ? v`
              <wy-icon-display>
                <wy-icon name="server-network-off"></wy-icon>
                <span slot="text">${P("The server is offline, try again in a few minutes...")}</span>
                <wy-progress-circular indeterminate slot="meta" ?hidden=${!this.weavy?.network.isPending}></wy-progress-circular>
              </wy-icon-display>
            ` : !this.noNetwork && this.weavy?.network.state === "offline" ? v`
              <wy-icon-display>
                <wy-icon name="wifi-off"></wy-icon>
                <span slot="text">${P("You are currently offline.")}</span>
                <wy-progress-circular indeterminate slot="meta" ?hidden=${!this.weavy?.network.isPending}></wy-progress-circular>
              </wy-icon-display>
            ` : v`
              <slot>
                <wy-icon-display>
                  <wy-icon name="information"></wy-icon>
                  <slot slot="text" name="title">
                    <span>${P("Nothing to see here yet.")}</span>
                  </slot>
                </wy-icon-display>
              </slot>
            `}
      </div>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.weavy?.addNetworkListener(this.handleUpdate);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.weavy?.removeNetworkListener(this.handleUpdate);
  }
}, c(yf, "Ia"), yf), d(C$, "WyEmpty"), C$);
hm.styles = [
  NH,
  ft
];
O4([
  Ve({ context: Me, subscribe: !0 }),
  F()
], hm.prototype, "weavy", 2);
O4([
  O({ type: Boolean })
], hm.prototype, "noNetwork", 2);
hm = O4([
  U("wy-empty"),
  St()
], hm);
const GH = et`@keyframes wy-bouncing{to{transform:translate3d(0,calc(-.25 * var(--wy-size, 1rem)),0)}}@keyframes wy-bouncing-fade{to{opacity:.2}}[part~=wy-bouncer]{width:calc(1.5*var(--wy-size, 1rem));height:calc(.75*var(--wy-size, 1rem))}[part~=wy-bouncer-dot]{position:relative;animation:wy-bouncing .6s infinite alternate,wy-bouncing-fade .6s infinite alternate;fill:currentColor}[part~=wy-bouncer-dot-start]{animation-delay:0s,.6s}[part~=wy-bouncer-dot-middle]{animation-delay:.3s,.3s}[part~=wy-bouncer-dot-end]{animation-delay:.6s,0s}`;
var KH = Object.defineProperty, JH = Object.getOwnPropertyDescriptor, cr = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? JH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && KH(t, e, s), s;
}, "__decorateClass$16"), P$, mf;
let pn = (P$ = (mf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.typing = new eI(this), this.isPrivateChat = !1, this.members = [], this.typingMembers = [], this.names = [];
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("conversationId") && (this.typing.appId = this.conversationId), t.has("userId") && (this.typing.userId = this.userId);
    const { typingMembers: e, names: i } = this.typing;
    this.typingMembers = e, this.names = i, e.length ? this.typingTime ||= /* @__PURE__ */ new Date() : this.typingTime = void 0;
  }
  render() {
    const t = this.typingMembers.map(
      (a) => this.members.find((o) => o.id === a.id)
    ).filter((a) => a), e = new Intl.ListFormat(this.weavy?.locale, { style: "long", type: "conjunction" }).format(
      this.names
    ), i = this.typingTime ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(this.typingTime) : "", s = this.typingTime ? new Intl.DateTimeFormat(this.weavy?.locale, { timeStyle: "short" }).format(this.typingTime) : "", r = v`
      <svg part="wy-bouncer" viewBox="0 0 32 16" xmlns="http://www.w3.org/2000/svg">
        <circle part="wy-bouncer-dot wy-bouncer-dot-start" cx="4" cy="10" r="4" />
        <circle part="wy-bouncer-dot wy-bouncer-dot-middle" cx="16" cy="10" r="4" />
        <circle part="wy-bouncer-dot wy-bouncer-dot-end" cx="28" cy="10" r="4" />
      </svg>
    `;
    return t.length ? v`
          <div part=${ut({ "wy-message": !0, "wy-message-agent": !!t[0]?.is_agent })}>
            <div part="wy-message-author">
              ${t.length > 1 ? v`
                    <wy-avatar-group
                      .size=${32}
                      .members=${t}
                      title=${e}
                    ></wy-avatar-group>
                  ` : v`
                    <wy-avatar
                      .size=${32}
                      .src=${t[0]?.avatar_url}
                      .description=${t[0]?.comment}
                      .name=${e}
                      .isAgent=${t[0]?.is_agent}
                    ></wy-avatar>
                  `}
            </div>

            <div part="wy-message-content">
              <div part="wy-message-meta">
                ${this.isPrivateChat ? v`
                      <time datetime=${Ot(this.typingTime?.toISOString())} title=${i}>${s}</time>
                    ` : e}
              </div>
              <div part="wy-message-bubble"> ${r} </div>
            </div>
          </div>
        ` : C;
  }
}, c(mf, "Ta"), mf), d(P$, "WyMessageTyping"), P$);
pn.styles = [ne, GH, P0];
cr([
  Ve({ context: Me, subscribe: !0 }),
  F()
], pn.prototype, "weavy", 2);
cr([
  O({ attribute: !0, type: Number })
], pn.prototype, "conversationId", 2);
cr([
  O({ attribute: !0, type: Number })
], pn.prototype, "userId", 2);
cr([
  O({ type: Boolean })
], pn.prototype, "isPrivateChat", 2);
cr([
  O({ attribute: !1 })
], pn.prototype, "members", 2);
cr([
  F()
], pn.prototype, "typingMembers", 2);
cr([
  F()
], pn.prototype, "names", 2);
cr([
  F()
], pn.prototype, "typingTime", 2);
pn = cr([
  U("wy-message-typing")
], pn);
const Q0 = et`:host(wy-item),[part~=wy-item]{--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));display:flex;clip-path:border-box;box-sizing:border-box}[part~=wy-item-rounded]{border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-item-rounded-outer]{border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-item-inner]{display:flex;position:relative;align-items:center;text-decoration:none;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));flex:1 1 100%;min-width:0}[part~=wy-item-inner-no-padding]{padding:0}[part~=wy-item-sm]{min-height:calc(2*var(--wy-size, 1rem));padding:0 var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-item-md]{min-height:calc(3*var(--wy-size, 1rem))}[part~=wy-item-lg]{min-height:calc(4.5*var(--wy-size, 1rem))}[part~=wy-item-top]{align-items:flex-start}[part~=wy-item-body]{width:100%;min-width:0;min-height:100%;display:flex}[part~=wy-item-rows]{display:flex;flex-direction:column;min-width:0;justify-content:space-evenly;flex:1 1 100%}[part~=wy-item-row]{display:flex;align-items:center;column-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));min-height:calc(var(--wy-button-line-height, var(--wy-line-height, 1.5))*var(--wy-size, 1rem))}[part~=wy-item-title] a:after{position:absolute;inset:0;z-index:1;content:\"\"}[part~=wy-item-title] a{color:inherit;text-decoration:none}[part~=wy-item-title]{color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset))}[part~=wy-item-title]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-item-image]{display:contents}[part~=wy-item-text]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-item-text]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-item-text-sm]{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))}[part~=wy-item-meta]{white-space:nowrap}[part~=wy-item-actions]{--wy-component-background-color: transparent;display:flex;align-items:center;justify-items:flex-end;flex:0 0 auto;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-item-actions-top]{align-self:flex-start;margin:calc(-.25*var(--wy-size, 1rem))}[part~=wy-item-actions-bottom]{align-self:flex-start;margin:calc(-.125*var(--wy-size, 1rem)) 0 calc(-.625*var(--wy-size, 1rem))}[part~=wy-item-left]{margin-right:auto}[part~=wy-item-right]{margin-left:auto}[part~=wy-read]{opacity:var(--wy-opacity-muted, 65%);--wy-component-color: var(--wy-outline, var(--wy-outline-light, #72777f))}[part~=wy-unread]{--wy-component-color: color.token(--wy-on-background)}[part~=wy-unread] [part~=wy-item-title],[part~=wy-unread] [part~=wy-item-text]{font-weight:var(--wy-font-weight-bold, 600);color:var(--wy-component-color)}[part~=wy-item-interactive]{background-color:var(--wy-component-background-color);color:var(--wy-component-color);-webkit-user-select:none;user-select:none;cursor:pointer}[part~=wy-item-interactive]:hover,[part~=wy-item-interactive]:focus{--wy-component-background-color: var(--wy-component-background-color-hover, var(--wy-surface-layer-high, var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039))));text-decoration:none}[part~=wy-item-interactive]:active{--wy-component-background-color: var(--wy-component-background-color-active, var(--wy-surface-layer-highest, var(--wy-surface-layer-highest-light, rgba(0, 0, 0, .1019607843))))}[part~=wy-item-interactive][part~=wy-disabled],[part~=wy-item-interactive]:disabled{opacity:var(--wy-opacity-disabled, 38%);pointer-events:none}[part~=wy-item-interactive][part~=wy-selected]{--wy-component-background-color: var(--wy-component-background-color-selected, var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff)));--wy-component-color: var(--wy-component-color-selected, var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73)));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-color:var(--wy-component-background-color)}[part~=wy-item-trashed]{text-decoration:line-through;opacity:var(--wy-opacity-disabled, 38%)}[part~=wy-item-trashed][part~=wy-item-interactive]:hover{opacity:1}[part~=wy-item-list]{display:flex;flex-direction:column;gap:var(--wy-border, 1px);min-width:0}[part~=wy-item-list-filled]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));--wy-component-background-color: var(--wy-surface-layer-low, var(--wy-surface-layer-low-light, rgba(255, 255, 255, .5019607843)));--wy-component-background-color-hover: var(--wy-surface-layer-lowest, var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078)));--wy-component-background-color-active: var(--wy-surface-layer-lowest, var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078)))}[part~=wy-item-list-rounded]{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));clip-path:content-box}[part~=wy-item-list-rounded-outer]{border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));clip-path:content-box}[part~=wy-item-list-bordered]{border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));gap:0}[part~=wy-item-list-bordered]>:not(slot),[part~=wy-item-list-bordered] ::slotted(*){border-left:none;border-right:none}[part~=wy-item-list-bordered]>:not(slot):not(:first-child),[part~=wy-item-list-bordered] ::slotted(*:not(:first-child)){border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}`, Rm = et`[part~=wy-title]{font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));font-size:var(--wy-headings-font-size, var(--wy-font-size, 1em));font-style:var(--wy-headings-font-style, unset);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.5));margin-block:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-meta]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-meta-sm]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))}[part~=wy-quote]{color:var(--wy-outline, var(--wy-outline-light, #72777f))}[part~=wy-quote]:before,[part~=wy-quote]:after{content:'\"'}`;
var tY = Object.defineProperty, eY = Object.getOwnPropertyDescriptor, $e = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? eY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && tY(t, e, s), s;
}, "__decorateClass$15"), Q$, gf;
let We = (Q$ = (gf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.size = "auto", this.align = "middle", this.actionsPosition = "end", this.rounded = !1, this.noPadding = !1, this.outer = !1, this.interactive = !1, this.selected = !1, this.disabled = !1, this.url = void 0, this.trashed = !1;
  }
  /**
   * If it has an url; handles ctrl click event for the item.
   * @param event MouseEvent
   */
  handleLinkClick(t) {
    if (this.disabled) {
      t.preventDefault(), t.stopPropagation();
      return;
    }
    a1(t) && t.stopPropagation();
  }
  render() {
    const t = !!this._slotActions.length, e = !!this._slotMeta.length, i = !!this._slotText.length || this.actionsPosition === "bottom" && t;
    return v`
      <div
        part=${ut({
      "wy-item-rounded": this.rounded,
      "wy-item-rounded-outer": this.outer,
      "wy-item-inner": !0,
      "wy-item-inner-no-padding": this.noPadding,
      "wy-item-interactive": this.interactive,
      "wy-item-sm": this.size === "sm",
      "wy-item-md": this.size === "md",
      "wy-item-lg": this.size === "lg",
      "wy-item-top": this.align === "top",
      "wy-item-middle": this.align === "middle",
      "wy-item-bottom": this.align === "bottom",
      "wy-read": this.status === "read",
      "wy-unread": this.status === "unread",
      "wy-selected": this.selected,
      "wy-disabled": this.disabled
    })}
      >
        <div part="wy-item-image"><slot name="image"></slot></div>
        <div part="wy-item-body">
          <slot name="content">
            <div part="wy-item-rows">
              <div part="wy-item-row wy-item-row-first">
                <div part="wy-item-title wy-item-left">
                  ${this.url ? v`<a href=${this.url} @click=${(s) => this.handleLinkClick(s)}><slot name="title"></slot></a>` : v`<slot name="title"></slot>`}
                </div>
                <div part="wy-item-meta wy-meta wy-meta-sm" ?hidden=${!e}
                  ><slot name="meta" @slotchange=${() => this.requestUpdate()}></slot
                ></div>
              </div>
              <div part="wy-item-row wy-item-row-second" ?hidden=${!i}>
                <div part="wy-item-text wy-item-left ${ut({ "wy-item-text-sm": this.size === "auto" })}"
                  ><slot name="text" @slotchange=${() => this.requestUpdate()}></slot
                ></div>
                ${this.actionsPosition === "bottom" ? v`
                      <div part="wy-item-actions wy-item-actions-bottom"
                        ><slot name="actions" @slotchange=${() => this.requestUpdate()}></slot
                      ></div>
                    ` : C}
              </div>
            </div>
          </slot>
        </div>
        ${this.actionsPosition !== "bottom" ? v`
              <div
                part="wy-item-actions ${ut({
      "wy-item-actions-top": this.align === "top" || this.actionsPosition === "top"
    })}"
                ?hidden=${!t}
                ><slot name="actions" @slotchange=${() => this.requestUpdate()}></slot
              ></div>
            ` : C}
      </div>
    `;
  }
}, c(gf, "Fa"), gf), d(Q$, "WyItem"), Q$);
We.styles = [ne, Q0, Rm];
$e([
  O()
], We.prototype, "size", 2);
$e([
  O()
], We.prototype, "align", 2);
$e([
  O()
], We.prototype, "actionsPosition", 2);
$e([
  O({ type: Boolean, reflect: !0 })
], We.prototype, "rounded", 2);
$e([
  O({ type: Boolean, reflect: !0 })
], We.prototype, "noPadding", 2);
$e([
  O({ type: Boolean, reflect: !0 })
], We.prototype, "outer", 2);
$e([
  O({ type: Boolean, reflect: !0 })
], We.prototype, "interactive", 2);
$e([
  O({ type: Boolean, reflect: !0 })
], We.prototype, "selected", 2);
$e([
  O({ type: Boolean, reflect: !0 })
], We.prototype, "disabled", 2);
$e([
  O({ reflect: !0 })
], We.prototype, "url", 2);
$e([
  O({ type: Boolean, reflect: !0 })
], We.prototype, "trashed", 2);
$e([
  O()
], We.prototype, "status", 2);
$e([
  Ml({ slot: "actions" })
], We.prototype, "_slotActions", 2);
$e([
  Ml({ slot: "meta" })
], We.prototype, "_slotMeta", 2);
$e([
  Ml({ slot: "text" })
], We.prototype, "_slotText", 2);
We = $e([
  U("wy-item")
], We);
var T$, wf;
let oa = (T$ = (wf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.outer = !1, this.bordered = !1, this.rounded = !1, this.filled = !1;
  }
  render() {
    const t = {
      "wy-item-list": !0,
      "wy-item-list-bordered": this.bordered,
      "wy-item-list-rounded": this.rounded,
      "wy-item-list-outer": this.outer,
      "wy-item-list-filled": this.filled
    };
    return v`<div part=${ut(t)}><slot></slot></div>`;
  }
}, c(wf, "Da"), wf), d(T$, "WyItemList"), T$);
oa.styles = [Q0, ft];
$e([
  O({ type: Boolean })
], oa.prototype, "outer", 2);
$e([
  O({ type: Boolean })
], oa.prototype, "bordered", 2);
$e([
  O({ type: Boolean })
], oa.prototype, "rounded", 2);
$e([
  O({ type: Boolean })
], oa.prototype, "filled", 2);
oa = $e([
  U("wy-item-list")
], oa);
const JI = et`[part~=wy-button]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c));color:var(--wy-component-color);background:var(--wy-component-background-color, transparent);height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;font-size:var(--wy-button-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-button-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));text-align:center;text-decoration:none;vertical-align:middle;cursor:pointer;-webkit-user-select:none;user-select:none;border:var(--wy-button-border-width, var(--wy-border-outline, 0)) solid var(--wy-outline, var(--wy-outline-light, #72777f));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem))));display:inline-flex;align-items:center;justify-content:center;gap:var(--wy-button-gap, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));position:relative}[part~=wy-button][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.8);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.5)}[part~=wy-button][part~=wy-disabled],[part~=wy-button]:disabled{opacity:var(--wy-opacity-disabled, 38%);cursor:unset;pointer-events:none}[part~=wy-button-state-layer]>*{z-index:3}[part~=wy-button-state-layer]:before{content:\"\";z-index:2;position:absolute;inset:0;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-button-state-layer]:hover:before{opacity:8%}[part~=wy-button-state-layer]:focus:before,[part~=wy-button-state-layer]:active:before,[part~=wy-button-state-layer][part~=wy-active]:before{opacity:12%}[part~=wy-button-icon]{--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));line-height:1;align-items:center;justify-content:center}[part~=wy-button-icon][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);padding:0;margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.5)}[part~=wy-button-icon][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*-.1)}[part~=wy-button-icon][part~=wy-active]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-button-icon-inline]{height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));width:auto;min-width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));background:var(--wy-component-background-color);color:currentColor;display:flex;padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-button-icon-inline][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);min-width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.25);margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*.5)}[part~=wy-button-icon-inline][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*-.1)}[part~=wy-button-inline]{border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));margin-inline:calc(-1*var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-button-inline][part~=wy-button-sm]{padding:calc(.5*var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin-inline:calc(-.5*var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-button-primary]{--wy-component-background-color: var(--wy-primary, var(--wy-primary-light, #2f628c));--wy-component-color: var(--wy-on-primary, var(--wy-on-primary-light, #ffffff))}[part~=wy-button-variant]{--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}[part~=wy-button-primary-text]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-button-inherit-color]{--wy-component-color: currentColor}[part~=wy-button-no-color]{--wy-component-background-color: transparent;--wy-component-color: unset}[part~=wy-button-link]{padding:0;color:var(--wy-link-color, var(--wy-primary, var(--wy-primary-light, #2f628c)));text-decoration:var(--wy-link-decoration, none)}[part~=wy-button-link]:hover,[part~=wy-button-link]:focus{text-decoration:var(--wy-link-hover-decoration, var(--wy-link-decoration, none))}[part~=wy-buttons]{display:flex;align-items:center;flex-wrap:wrap;gap:calc(.5*var(--wy-size, 1rem))}[part~=wy-buttons-reverse]{flex-direction:row-reverse}[part~=wy-buttons-floating]{position:sticky;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) 0;top:0;height:0;margin-bottom:calc(-1*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));z-index:1030;--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}[part~=wy-buttons-sticky]{position:sticky;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));top:var(--wy-component-offset-top, 0px);z-index:1021;--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e))}`, tW = et`[part~=wy-tabs]{display:flex;overflow-y:hidden;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));flex:1 1 auto}[part~=wy-tabs]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-tabs]{scrollbar-width:thin;scrollbar-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf)) rgba(0,0,0,0)}[part~=wy-tabs]::-webkit-scrollbar{height:.375rem;width:.375rem;background:#0000;z-index:999}[part~=wy-tabs]::-webkit-scrollbar-track{background:#0000}[part~=wy-tabs]::-webkit-scrollbar-thumb{background-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));opacity:75%;border:0 solid rgba(0,0,0,0);border-radius:0;background-clip:padding-box}[part~=wy-tabs]::-webkit-scrollbar-thumb:hover{background-color:var(--wy-outline, var(--wy-outline-light, #72777f));opacity:75%}[part~=wy-tabs]::-webkit-scrollbar-thumb:window-inactive{background-color:var(--wy-outline, var(--wy-outline-light, #72777f));opacity:50%}[part~=wy-tab]{--wy-component-color: var(--wy-primary, var(--wy-primary-light, #2f628c));--wy-component-background-color: transparent;color:var(--wy-component-color);background:var(--wy-component-background-color);border:none;border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));display:inline-flex;flex-direction:column;align-items:center;justify-content:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));position:relative;text-align:center;text-decoration:none;cursor:pointer;-webkit-user-select:none;user-select:none}[part~=wy-tab] .wy-tab-icon{position:relative;padding:calc(.25*var(--wy-size, 1rem)) calc(1*var(--wy-size, 1rem));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem))));display:inline-flex}[part~=wy-tab] .wy-tab-icon:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-tab]:hover .wy-tab-icon:before{opacity:8%}[part~=wy-tab]:focus .wy-tab-icon:before,[part~=wy-tab]:active .wy-tab-icon:before,[part~=wy-tab].wy-active .wy-tab-icon:before{opacity:12%}[part~=wy-tab] .wy-tab-label{font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));font-weight:var(--wy-font-weight, unset)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]{padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.5);margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) auto;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]:before{margin:calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*-.25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*0)}`;
var iY = Object.defineProperty, nY = Object.getOwnPropertyDescriptor, Li = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? nY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && iY(t, e, s), s;
}, "__decorateClass$14"), M$, vf;
let Yi = (M$ = (vf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this, !1), this.kind = "filled", this.active = !1, this.small = !1, this.disabled = !1;
  }
  render() {
    const t = {
      "wy-button": !0,
      "wy-active": !!this.active,
      "wy-disabled": !!this.disabled,
      "wy-button-inline": this.kind === "inline",
      "wy-button-icon": this.kind === "icon",
      "wy-button-icon-inline": this.kind === "icon-inline",
      "wy-button-link": this.kind === "link",
      "wy-button-primary": this.color === "primary",
      "wy-button-primary-text": this.color === "primary-text",
      "wy-button-inherit-color": this.color === "inherit",
      "wy-button-no-color": this.color === "none",
      "wy-button-variant": this.color === "variant",
      "wy-button-type-submit": this.type === "submit",
      "wy-button-type-reset": this.type === "reset",
      "wy-button-state-layer": this.kind !== "link" && !this.disabled,
      "wy-button-sm": !!this.small,
      "wy-tab": this.kind === "tab",
      "wy-tab-sm": this.kind === "tab" && !!this.small
    };
    return this.href ? v`
      <a href=${this.href} target=${Ot(this.target)} download=${Ot(this.download)} part=${ut(t)} aria-disabled=${this.disabled ? "true" : "false"}>
        <slot></slot>
      </a>
    ` : v`
      <button part=${ut(t)} type=${Ot(this.type)} ?disabled=${this.disabled} aria-disabled=${this.disabled ? "true" : "false"}>
        <slot></slot>
      </button>
    `;
  }
}, c(vf, "Ha"), vf), d(M$, "WyButton"), M$);
Yi.styles = [
  ne,
  JI,
  tW,
  ft,
  et`
      :host {
        position: relative;
      }
    `
];
Li([
  O()
], Yi.prototype, "type", 2);
Li([
  O()
], Yi.prototype, "kind", 2);
Li([
  O({ type: Boolean })
], Yi.prototype, "active", 2);
Li([
  O()
], Yi.prototype, "color", 2);
Li([
  O({ type: Boolean })
], Yi.prototype, "small", 2);
Li([
  O({ type: Boolean, reflect: !0 })
], Yi.prototype, "disabled", 2);
Li([
  O()
], Yi.prototype, "href", 2);
Li([
  O()
], Yi.prototype, "target", 2);
Li([
  O()
], Yi.prototype, "download", 2);
Yi = Li([
  U("wy-button")
], Yi);
var A$, Of;
let cl = (A$ = (Of = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.tabs = !1, this.position = "normal", this.reverse = !1;
  }
  render() {
    const t = {
      "wy-buttons": !this.tabs,
      "wy-buttons-reverse": this.reverse,
      "wy-tabs": this.tabs,
      "wy-buttons-floating": this.position === "floating",
      "wy-buttons-sticky": this.position === "sticky"
    };
    return v`<div part=${ut(t)}><slot></slot></div>`;
  }
}, c(Of, "Va"), Of), d(A$, "WyButtons"), A$);
cl.styles = [
  ne,
  JI,
  tW,
  ft
];
Li([
  O({ type: Boolean })
], cl.prototype, "tabs", 2);
Li([
  O({ type: String })
], cl.prototype, "position", 2);
Li([
  O({ type: Boolean })
], cl.prototype, "reverse", 2);
cl = Li([
  U("wy-buttons")
], cl);
const eW = "important", sY = " !" + eW, Zw = Ll(class extends Am {
  constructor(n) {
    if (super(n), n.type !== O1.ATTRIBUTE || n.name !== "style" || n.strings?.length > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(n) {
    return Object.keys(n).reduce(((t, e) => {
      const i = n[e];
      return i == null ? t : t + `${e = e.includes("-") ? e : e.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${i};`;
    }), "");
  }
  update(n, [t]) {
    const { style: e } = n.element;
    if (this.ft === void 0) return this.ft = new Set(Object.keys(t)), this.render(t);
    for (const i of this.ft) t[i] == null && (this.ft.delete(i), i.includes("-") ? e.removeProperty(i) : e[i] = null);
    for (const i in t) {
      const s = t[i];
      if (s != null) {
        this.ft.add(i);
        const r = typeof s == "string" && s.endsWith(sY);
        i.includes("-") || r ? e.setProperty(i, r ? s.slice(0, -11) : s, r ? eW : "") : e[i] = s;
      }
    }
    return ls;
  }
}), gb = Math.min, oo = Math.max, wb = Math.round, dv = Math.floor, rs = /* @__PURE__ */ d((n) => ({
  x: n,
  y: n
}), "createCoords"), rY = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, aY = {
  start: "end",
  end: "start"
};
function fS(n, t, e) {
  return oo(n, gb(t, e));
}
c(fS, "rf");
d(fS, "clamp");
function b1(n, t) {
  return typeof n == "function" ? n(t) : n;
}
c(b1, "bh");
d(b1, "evaluate");
function la(n) {
  return n.split("-")[0];
}
c(la, "Cs");
d(la, "getSide");
function $1(n) {
  return n.split("-")[1];
}
c($1, "xh");
d($1, "getAlignment");
function b4(n) {
  return n === "x" ? "y" : "x";
}
c(b4, "jm");
d(b4, "getOppositeAxis");
function $4(n) {
  return n === "y" ? "height" : "width";
}
c($4, "Wm");
d($4, "getAxisLength");
const oY = /* @__PURE__ */ new Set(["top", "bottom"]);
function Vs(n) {
  return oY.has(la(n)) ? "y" : "x";
}
c(Vs, "_r");
d(Vs, "getSideAxis");
function x4(n) {
  return b4(Vs(n));
}
c(x4, "Qm");
d(x4, "getAlignmentAxis");
function iW(n, t, e) {
  e === void 0 && (e = !1);
  const i = $1(n), s = x4(n), r = $4(s);
  let a = s === "x" ? i === (e ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return t.reference[r] > t.floating[r] && (a = Fw(a)), [a, Fw(a)];
}
c(iW, "g5");
d(iW, "getAlignmentSides");
function nW(n) {
  const t = Fw(n);
  return [vb(n), t, vb(t)];
}
c(nW, "b5");
d(nW, "getExpandedPlacements");
function vb(n) {
  return n.replace(/start|end/g, (t) => aY[t]);
}
c(vb, "Au");
d(vb, "getOppositeAlignmentPlacement");
const w9 = ["left", "right"], v9 = ["right", "left"], lY = ["top", "bottom"], cY = ["bottom", "top"];
function sW(n, t, e) {
  switch (n) {
    case "top":
    case "bottom":
      return e ? t ? v9 : w9 : t ? w9 : v9;
    case "left":
    case "right":
      return t ? lY : cY;
    default:
      return [];
  }
}
c(sW, "C5");
d(sW, "getSideList");
function rW(n, t, e, i) {
  const s = $1(n);
  let r = sW(la(n), e === "start", i);
  return s && (r = r.map((a) => a + "-" + s), t && (r = r.concat(r.map(vb)))), r;
}
c(rW, "k5");
d(rW, "getOppositeAxisPlacements");
function Fw(n) {
  return n.replace(/left|right|bottom|top/g, (t) => rY[t]);
}
c(Fw, "Jd");
d(Fw, "getOppositePlacement");
function aW(n) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...n
  };
}
c(aW, "_5");
d(aW, "expandPaddingObject");
function oW(n) {
  return typeof n != "number" ? aW(n) : {
    top: n,
    right: n,
    bottom: n,
    left: n
  };
}
c(oW, "P5");
d(oW, "getPaddingObject");
function Xw(n) {
  const {
    x: t,
    y: e,
    width: i,
    height: s
  } = n;
  return {
    width: i,
    height: s,
    top: e,
    left: t,
    right: t + i,
    bottom: e + s,
    x: t,
    y: e
  };
}
c(Xw, "th");
d(Xw, "rectToClientRect");
function yS(n, t, e) {
  let {
    reference: i,
    floating: s
  } = n;
  const r = Vs(t), a = x4(t), o = $4(a), l = la(t), h = r === "y", u = i.x + i.width / 2 - s.width / 2, p = i.y + i.height / 2 - s.height / 2, y = i[o] / 2 - s[o] / 2;
  let m;
  switch (l) {
    case "top":
      m = {
        x: u,
        y: i.y - s.height
      };
      break;
    case "bottom":
      m = {
        x: u,
        y: i.y + i.height
      };
      break;
    case "right":
      m = {
        x: i.x + i.width,
        y: p
      };
      break;
    case "left":
      m = {
        x: i.x - s.width,
        y: p
      };
      break;
    default:
      m = {
        x: i.x,
        y: i.y
      };
  }
  switch ($1(t)) {
    case "start":
      m[a] -= y * (e && h ? -1 : 1);
      break;
    case "end":
      m[a] += y * (e && h ? -1 : 1);
      break;
  }
  return m;
}
c(yS, "af");
d(yS, "computeCoordsFromPlacement");
const hY = /* @__PURE__ */ d(async (n, t, e) => {
  const {
    placement: i = "bottom",
    strategy: s = "absolute",
    middleware: r = [],
    platform: a
  } = e, o = r.filter(Boolean), l = await (a.isRTL == null ? void 0 : a.isRTL(t));
  let h = await a.getElementRects({
    reference: n,
    floating: t,
    strategy: s
  }), {
    x: u,
    y: p
  } = yS(h, i, l), y = i, m = {}, g = 0;
  for (let b = 0; b < o.length; b++) {
    const {
      name: S,
      fn: x
    } = o[b], {
      x: Q,
      y: L,
      data: W,
      reset: R
    } = await x({
      x: u,
      y: p,
      initialPlacement: i,
      placement: y,
      strategy: s,
      middlewareData: m,
      rects: h,
      platform: a,
      elements: {
        reference: n,
        floating: t
      }
    });
    u = Q ?? u, p = L ?? p, m = {
      ...m,
      [S]: {
        ...m[S],
        ...W
      }
    }, R && g <= 50 && (g++, typeof R == "object" && (R.placement && (y = R.placement), R.rects && (h = R.rects === !0 ? await a.getElementRects({
      reference: n,
      floating: t,
      strategy: s
    }) : R.rects), {
      x: u,
      y: p
    } = yS(h, y, l)), b = -1);
  }
  return {
    x: u,
    y: p,
    placement: y,
    strategy: s,
    middlewareData: m
  };
}, "computePosition$1");
async function k4(n, t) {
  var e;
  t === void 0 && (t = {});
  const {
    x: i,
    y: s,
    platform: r,
    rects: a,
    elements: o,
    strategy: l
  } = n, {
    boundary: h = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: p = "floating",
    altBoundary: y = !1,
    padding: m = 0
  } = b1(t, n), g = oW(m), b = o[y ? p === "floating" ? "reference" : "floating" : p], S = Xw(await r.getClippingRect({
    element: (e = await (r.isElement == null ? void 0 : r.isElement(b))) == null || e ? b : b.contextElement || await (r.getDocumentElement == null ? void 0 : r.getDocumentElement(o.floating)),
    boundary: h,
    rootBoundary: u,
    strategy: l
  })), x = p === "floating" ? {
    x: i,
    y: s,
    width: a.floating.width,
    height: a.floating.height
  } : a.reference, Q = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(o.floating)), L = await (r.isElement == null ? void 0 : r.isElement(Q)) ? await (r.getScale == null ? void 0 : r.getScale(Q)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, W = Xw(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: o,
    rect: x,
    offsetParent: Q,
    strategy: l
  }) : x);
  return {
    top: (S.top - W.top + g.top) / L.y,
    bottom: (W.bottom - S.bottom + g.bottom) / L.y,
    left: (S.left - W.left + g.left) / L.x,
    right: (W.right - S.right + g.right) / L.x
  };
}
c(k4, "Km");
d(k4, "detectOverflow");
const dY = /* @__PURE__ */ d(function(n) {
  return n === void 0 && (n = {}), {
    name: "flip",
    options: n,
    async fn(t) {
      var e, i;
      const {
        placement: s,
        middlewareData: r,
        rects: a,
        initialPlacement: o,
        platform: l,
        elements: h
      } = t, {
        mainAxis: u = !0,
        crossAxis: p = !0,
        fallbackPlacements: y,
        fallbackStrategy: m = "bestFit",
        fallbackAxisSideDirection: g = "none",
        flipAlignment: b = !0,
        ...S
      } = b1(n, t);
      if ((e = r.arrow) != null && e.alignmentOffset)
        return {};
      const x = la(s), Q = Vs(o), L = la(o) === o, W = await (l.isRTL == null ? void 0 : l.isRTL(h.floating)), R = y || (L || !b ? [Fw(o)] : nW(o)), I = g !== "none";
      !y && I && R.push(...rW(o, b, g, W));
      const V = [o, ...R], X = await k4(t, S), J = [];
      let mt = ((i = r.flip) == null ? void 0 : i.overflows) || [];
      if (u && J.push(X[x]), p) {
        const rt = iW(s, a, W);
        J.push(X[rt[0]], X[rt[1]]);
      }
      if (mt = [...mt, {
        placement: s,
        overflows: J
      }], !J.every((rt) => rt <= 0)) {
        var at, G;
        const rt = (((at = r.flip) == null ? void 0 : at.index) || 0) + 1, Rt = V[rt];
        if (Rt && (!(p === "alignment" && Q !== Vs(Rt)) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        mt.every((It) => Vs(It.placement) === Q ? It.overflows[0] > 0 : !0)))
          return {
            data: {
              index: rt,
              overflows: mt
            },
            reset: {
              placement: Rt
            }
          };
        let Qt = (G = mt.filter((It) => It.overflows[0] <= 0).sort((It, Vt) => It.overflows[1] - Vt.overflows[1])[0]) == null ? void 0 : G.placement;
        if (!Qt)
          switch (m) {
            case "bestFit": {
              var $t;
              const It = ($t = mt.filter((Vt) => {
                if (I) {
                  const Dt = Vs(Vt.placement);
                  return Dt === Q || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Dt === "y";
                }
                return !0;
              }).map((Vt) => [Vt.placement, Vt.overflows.filter((Dt) => Dt > 0).reduce((Dt, xi) => Dt + xi, 0)]).sort((Vt, Dt) => Vt[1] - Dt[1])[0]) == null ? void 0 : $t[0];
              It && (Qt = It);
              break;
            }
            case "initialPlacement":
              Qt = o;
              break;
          }
        if (s !== Qt)
          return {
            reset: {
              placement: Qt
            }
          };
      }
      return {};
    }
  };
}, "flip$1"), uY = /* @__PURE__ */ new Set(["left", "top"]);
async function lW(n, t) {
  const {
    placement: e,
    platform: i,
    elements: s
  } = n, r = await (i.isRTL == null ? void 0 : i.isRTL(s.floating)), a = la(e), o = $1(e), l = Vs(e) === "y", h = uY.has(a) ? -1 : 1, u = r && l ? -1 : 1, p = b1(t, n);
  let {
    mainAxis: y,
    crossAxis: m,
    alignmentAxis: g
  } = typeof p == "number" ? {
    mainAxis: p,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: p.mainAxis || 0,
    crossAxis: p.crossAxis || 0,
    alignmentAxis: p.alignmentAxis
  };
  return o && typeof g == "number" && (m = o === "end" ? g * -1 : g), l ? {
    x: m * u,
    y: y * h
  } : {
    x: y * h,
    y: m * u
  };
}
c(lW, "z5");
d(lW, "convertValueToCoords");
const pY = /* @__PURE__ */ d(function(n) {
  return n === void 0 && (n = 0), {
    name: "offset",
    options: n,
    async fn(t) {
      var e, i;
      const {
        x: s,
        y: r,
        placement: a,
        middlewareData: o
      } = t, l = await lW(t, n);
      return a === ((e = o.offset) == null ? void 0 : e.placement) && (i = o.arrow) != null && i.alignmentOffset ? {} : {
        x: s + l.x,
        y: r + l.y,
        data: {
          ...l,
          placement: a
        }
      };
    }
  };
}, "offset$1"), fY = /* @__PURE__ */ d(function(n) {
  return n === void 0 && (n = {}), {
    name: "shift",
    options: n,
    async fn(t) {
      const {
        x: e,
        y: i,
        placement: s
      } = t, {
        mainAxis: r = !0,
        crossAxis: a = !1,
        limiter: o = {
          fn: /* @__PURE__ */ d((S) => {
            let {
              x,
              y: Q
            } = S;
            return {
              x,
              y: Q
            };
          }, "fn")
        },
        ...l
      } = b1(n, t), h = {
        x: e,
        y: i
      }, u = await k4(t, l), p = Vs(la(s)), y = b4(p);
      let m = h[y], g = h[p];
      if (r) {
        const S = y === "y" ? "top" : "left", x = y === "y" ? "bottom" : "right", Q = m + u[S], L = m - u[x];
        m = fS(Q, m, L);
      }
      if (a) {
        const S = p === "y" ? "top" : "left", x = p === "y" ? "bottom" : "right", Q = g + u[S], L = g - u[x];
        g = fS(Q, g, L);
      }
      const b = o.fn({
        ...t,
        [y]: m,
        [p]: g
      });
      return {
        ...b,
        data: {
          x: b.x - e,
          y: b.y - i,
          enabled: {
            [y]: r,
            [p]: a
          }
        }
      };
    }
  };
}, "shift$1");
function x1() {
  return typeof window < "u";
}
c(x1, "$h");
d(x1, "hasWindow");
function Wl(n) {
  return S4(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
c(Wl, "Bc");
d(Wl, "getNodeName");
function Ti(n) {
  var t;
  return (n == null || (t = n.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
c(Ti, "je");
d(Ti, "getWindow");
function Ln(n) {
  var t;
  return (t = (S4(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : t.documentElement;
}
c(Ln, "Ei");
d(Ln, "getDocumentElement");
function S4(n) {
  return x1() ? n instanceof Node || n instanceof Ti(n).Node : !1;
}
c(S4, "Gm");
d(S4, "isNode");
function fn(n) {
  return x1() ? n instanceof Element || n instanceof Ti(n).Element : !1;
}
c(fn, "ci");
d(fn, "isElement");
function En(n) {
  return x1() ? n instanceof HTMLElement || n instanceof Ti(n).HTMLElement : !1;
}
c(En, "_i");
d(En, "isHTMLElement");
function mS(n) {
  return !x1() || typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof Ti(n).ShadowRoot;
}
c(mS, "of");
d(mS, "isShadowRoot");
const yY = /* @__PURE__ */ new Set(["inline", "contents"]);
function Em(n) {
  const {
    overflow: t,
    overflowX: e,
    overflowY: i,
    display: s
  } = yn(n);
  return /auto|scroll|overlay|hidden|clip/.test(t + i + e) && !yY.has(s);
}
c(Em, "cd");
d(Em, "isOverflowElement");
const mY = /* @__PURE__ */ new Set(["table", "td", "th"]);
function cW(n) {
  return mY.has(Wl(n));
}
c(cW, "I5");
d(cW, "isTableElement");
const gY = [":popover-open", ":modal"];
function k1(n) {
  return gY.some((t) => {
    try {
      return n.matches(t);
    } catch {
      return !1;
    }
  });
}
c(k1, "Ch");
d(k1, "isTopLayer");
const wY = ["transform", "translate", "scale", "rotate", "perspective"], vY = ["transform", "translate", "scale", "rotate", "perspective", "filter"], OY = ["paint", "layout", "strict", "content"];
function T0(n) {
  const t = M0(), e = fn(n) ? yn(n) : n;
  return wY.some((i) => e[i] ? e[i] !== "none" : !1) || (e.containerType ? e.containerType !== "normal" : !1) || !t && (e.backdropFilter ? e.backdropFilter !== "none" : !1) || !t && (e.filter ? e.filter !== "none" : !1) || vY.some((i) => (e.willChange || "").includes(i)) || OY.some((i) => (e.contain || "").includes(i));
}
c(T0, "py");
d(T0, "isContainingBlock");
function hW(n) {
  let t = Gs(n);
  for (; En(t) && !hl(t); ) {
    if (T0(t))
      return t;
    if (k1(t))
      return null;
    t = Gs(t);
  }
  return null;
}
c(hW, "V5");
d(hW, "getContainingBlock");
function M0() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
c(M0, "uy");
d(M0, "isWebKit");
const bY = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function hl(n) {
  return bY.has(Wl(n));
}
c(hl, "Cc");
d(hl, "isLastTraversableNode");
function yn(n) {
  return Ti(n).getComputedStyle(n);
}
c(yn, "li");
d(yn, "getComputedStyle$1");
function S1(n) {
  return fn(n) ? {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  } : {
    scrollLeft: n.scrollX,
    scrollTop: n.scrollY
  };
}
c(S1, "kh");
d(S1, "getNodeScroll");
function Gs(n) {
  if (Wl(n) === "html")
    return n;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    n.assignedSlot || // DOM Element detected.
    n.parentNode || // ShadowRoot detected.
    mS(n) && n.host || // Fallback.
    Ln(n)
  );
  return mS(t) ? t.host : t;
}
c(Gs, "Lr");
d(Gs, "getParentNode");
function C4(n) {
  const t = Gs(n);
  return hl(t) ? n.ownerDocument ? n.ownerDocument.body : n.body : En(t) && Em(t) ? t : C4(t);
}
c(C4, "Zm");
d(C4, "getNearestOverflowAncestor");
function dm(n, t, e) {
  var i;
  t === void 0 && (t = []), e === void 0 && (e = !0);
  const s = C4(n), r = s === ((i = n.ownerDocument) == null ? void 0 : i.body), a = Ti(s);
  if (r) {
    const o = Ob(a);
    return t.concat(a, a.visualViewport || [], Em(s) ? s : [], o && e ? dm(o) : []);
  }
  return t.concat(s, dm(s, [], e));
}
c(dm, "vl");
d(dm, "getOverflowAncestors");
function Ob(n) {
  return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null;
}
c(Ob, "zu");
d(Ob, "getFrameElement");
function P4(n) {
  const t = yn(n);
  let e = parseFloat(t.width) || 0, i = parseFloat(t.height) || 0;
  const s = En(n), r = s ? n.offsetWidth : e, a = s ? n.offsetHeight : i, o = wb(e) !== r || wb(i) !== a;
  return o && (e = r, i = a), {
    width: e,
    height: i,
    $: o
  };
}
c(P4, "Ym");
d(P4, "getCssDimensions");
function A0(n) {
  return fn(n) ? n : n.contextElement;
}
c(A0, "yy");
d(A0, "unwrapElement");
function lo(n) {
  const t = A0(n);
  if (!En(t))
    return rs(1);
  const e = t.getBoundingClientRect(), {
    width: i,
    height: s,
    $: r
  } = P4(t);
  let a = (r ? wb(e.width) : e.width) / i, o = (r ? wb(e.height) : e.height) / s;
  return (!a || !Number.isFinite(a)) && (a = 1), (!o || !Number.isFinite(o)) && (o = 1), {
    x: a,
    y: o
  };
}
c(lo, "mn");
d(lo, "getScale");
const $Y = /* @__PURE__ */ rs(0);
function Q4(n) {
  const t = Ti(n);
  return !M0() || !t.visualViewport ? $Y : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
c(Q4, "Xm");
d(Q4, "getVisualOffsets");
function dW(n, t, e) {
  return t === void 0 && (t = !1), !e || t && e !== Ti(n) ? !1 : t;
}
c(dW, "q5");
d(dW, "shouldAddVisualOffsets");
function ca(n, t, e, i) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  const s = n.getBoundingClientRect(), r = A0(n);
  let a = rs(1);
  t && (i ? fn(i) && (a = lo(i)) : a = lo(n));
  const o = dW(r, e, i) ? Q4(r) : rs(0);
  let l = (s.left + o.x) / a.x, h = (s.top + o.y) / a.y, u = s.width / a.x, p = s.height / a.y;
  if (r) {
    const y = Ti(r), m = i && fn(i) ? Ti(i) : i;
    let g = y, b = Ob(g);
    for (; b && i && m !== g; ) {
      const S = lo(b), x = b.getBoundingClientRect(), Q = yn(b), L = x.left + (b.clientLeft + parseFloat(Q.paddingLeft)) * S.x, W = x.top + (b.clientTop + parseFloat(Q.paddingTop)) * S.y;
      l *= S.x, h *= S.y, u *= S.x, p *= S.y, l += L, h += W, g = Ti(b), b = Ob(g);
    }
  }
  return Xw({
    width: u,
    height: p,
    x: l,
    y: h
  });
}
c(ca, "ks");
d(ca, "getBoundingClientRect");
function C1(n, t) {
  const e = S1(n).scrollLeft;
  return t ? t.left + e : ca(Ln(n)).left + e;
}
c(C1, "_h");
d(C1, "getWindowScrollBarX");
function T4(n, t) {
  const e = n.getBoundingClientRect(), i = e.left + t.scrollLeft - C1(n, e), s = e.top + t.scrollTop;
  return {
    x: i,
    y: s
  };
}
c(T4, "Jm");
d(T4, "getHTMLOffset");
function uW(n) {
  let {
    elements: t,
    rect: e,
    offsetParent: i,
    strategy: s
  } = n;
  const r = s === "fixed", a = Ln(i), o = t ? k1(t.floating) : !1;
  if (i === a || o && r)
    return e;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, h = rs(1);
  const u = rs(0), p = En(i);
  if ((p || !p && !r) && ((Wl(i) !== "body" || Em(a)) && (l = S1(i)), En(i))) {
    const m = ca(i);
    h = lo(i), u.x = m.x + i.clientLeft, u.y = m.y + i.clientTop;
  }
  const y = a && !p && !r ? T4(a, l) : rs(0);
  return {
    width: e.width * h.x,
    height: e.height * h.y,
    x: e.x * h.x - l.scrollLeft * h.x + u.x + y.x,
    y: e.y * h.y - l.scrollTop * h.y + u.y + y.y
  };
}
c(uW, "N5");
d(uW, "convertOffsetParentRelativeRectToViewportRelativeRect");
function pW(n) {
  return Array.from(n.getClientRects());
}
c(pW, "j5");
d(pW, "getClientRects");
function fW(n) {
  const t = Ln(n), e = S1(n), i = n.ownerDocument.body, s = oo(t.scrollWidth, t.clientWidth, i.scrollWidth, i.clientWidth), r = oo(t.scrollHeight, t.clientHeight, i.scrollHeight, i.clientHeight);
  let a = -e.scrollLeft + C1(n);
  const o = -e.scrollTop;
  return yn(i).direction === "rtl" && (a += oo(t.clientWidth, i.clientWidth) - s), {
    width: s,
    height: r,
    x: a,
    y: o
  };
}
c(fW, "W5");
d(fW, "getDocumentRect");
const O9 = 25;
function yW(n, t) {
  const e = Ti(n), i = Ln(n), s = e.visualViewport;
  let r = i.clientWidth, a = i.clientHeight, o = 0, l = 0;
  if (s) {
    r = s.width, a = s.height;
    const u = M0();
    (!u || u && t === "fixed") && (o = s.offsetLeft, l = s.offsetTop);
  }
  const h = C1(i);
  if (h <= 0) {
    const u = i.ownerDocument, p = u.body, y = getComputedStyle(p), m = u.compatMode === "CSS1Compat" && parseFloat(y.marginLeft) + parseFloat(y.marginRight) || 0, g = Math.abs(i.clientWidth - p.clientWidth - m);
    g <= O9 && (r -= g);
  } else h <= O9 && (r += h);
  return {
    width: r,
    height: a,
    x: o,
    y: l
  };
}
c(yW, "Q5");
d(yW, "getViewportRect");
const xY = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function mW(n, t) {
  const e = ca(n, !0, t === "fixed"), i = e.top + n.clientTop, s = e.left + n.clientLeft, r = En(n) ? lo(n) : rs(1), a = n.clientWidth * r.x, o = n.clientHeight * r.y, l = s * r.x, h = i * r.y;
  return {
    width: a,
    height: o,
    x: l,
    y: h
  };
}
c(mW, "G5");
d(mW, "getInnerBoundingClientRect");
function gS(n, t, e) {
  let i;
  if (t === "viewport")
    i = yW(n, e);
  else if (t === "document")
    i = fW(Ln(n));
  else if (fn(t))
    i = mW(t, e);
  else {
    const s = Q4(n);
    i = {
      x: t.x - s.x,
      y: t.y - s.y,
      width: t.width,
      height: t.height
    };
  }
  return Xw(i);
}
c(gS, "lf");
d(gS, "getClientRectFromClippingAncestor");
function M4(n, t) {
  const e = Gs(n);
  return e === t || !fn(e) || hl(e) ? !1 : yn(e).position === "fixed" || M4(e, t);
}
c(M4, "tv");
d(M4, "hasFixedPositionAncestor");
function gW(n, t) {
  const e = t.get(n);
  if (e)
    return e;
  let i = dm(n, [], !1).filter((o) => fn(o) && Wl(o) !== "body"), s = null;
  const r = yn(n).position === "fixed";
  let a = r ? Gs(n) : n;
  for (; fn(a) && !hl(a); ) {
    const o = yn(a), l = T0(a);
    !l && o.position === "fixed" && (s = null), (r ? !l && !s : !l && o.position === "static" && s && xY.has(s.position) || Em(a) && !l && M4(n, a)) ? i = i.filter((h) => h !== a) : s = o, a = Gs(a);
  }
  return t.set(n, i), i;
}
c(gW, "Z5");
d(gW, "getClippingElementAncestors");
function wW(n) {
  let {
    element: t,
    boundary: e,
    rootBoundary: i,
    strategy: s
  } = n;
  const r = [...e === "clippingAncestors" ? k1(t) ? [] : gW(t, this._c) : [].concat(e), i], a = r[0], o = r.reduce((l, h) => {
    const u = gS(t, h, s);
    return l.top = oo(u.top, l.top), l.right = gb(u.right, l.right), l.bottom = gb(u.bottom, l.bottom), l.left = oo(u.left, l.left), l;
  }, gS(t, a, s));
  return {
    width: o.right - o.left,
    height: o.bottom - o.top,
    x: o.left,
    y: o.top
  };
}
c(wW, "Y5");
d(wW, "getClippingRect");
function vW(n) {
  const {
    width: t,
    height: e
  } = P4(n);
  return {
    width: t,
    height: e
  };
}
c(vW, "X5");
d(vW, "getDimensions");
function OW(n, t, e) {
  const i = En(t), s = Ln(t), r = e === "fixed", a = ca(n, !0, r, t);
  let o = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = rs(0);
  function h() {
    l.x = C1(s);
  }
  if (c(h, "u"), d(h, "setLeftRTLScrollbarOffset"), i || !i && !r)
    if ((Wl(t) !== "body" || Em(s)) && (o = S1(t)), i) {
      const m = ca(t, !0, r, t);
      l.x = m.x + t.clientLeft, l.y = m.y + t.clientTop;
    } else s && h();
  r && !i && s && h();
  const u = s && !i && !r ? T4(s, o) : rs(0), p = a.left + o.scrollLeft - l.x - u.x, y = a.top + o.scrollTop - l.y - u.y;
  return {
    x: p,
    y,
    width: a.width,
    height: a.height
  };
}
c(OW, "J5");
d(OW, "getRectRelativeToOffsetParent");
function eO(n) {
  return yn(n).position === "static";
}
c(eO, "Tp");
d(eO, "isStaticPositioned");
function wS(n, t) {
  if (!En(n) || yn(n).position === "fixed")
    return null;
  if (t)
    return t(n);
  let e = n.offsetParent;
  return Ln(n) === e && (e = e.ownerDocument.body), e;
}
c(wS, "df");
d(wS, "getTrueOffsetParent");
function A4(n, t) {
  const e = Ti(n);
  if (k1(n))
    return e;
  if (!En(n)) {
    let s = Gs(n);
    for (; s && !hl(s); ) {
      if (fn(s) && !eO(s))
        return s;
      s = Gs(s);
    }
    return e;
  }
  let i = wS(n, t);
  for (; i && cW(i) && eO(i); )
    i = wS(i, t);
  return i && hl(i) && eO(i) && !T0(i) ? e : i || hW(n) || e;
}
c(A4, "ev");
d(A4, "getOffsetParent");
const kY = /* @__PURE__ */ d(async function(n) {
  const t = this.getOffsetParent || A4, e = this.getDimensions, i = await e(n.floating);
  return {
    reference: OW(n.reference, await t(n.floating), n.strategy),
    floating: {
      x: 0,
      y: 0,
      width: i.width,
      height: i.height
    }
  };
}, "getElementRects");
function bW(n) {
  return yn(n).direction === "rtl";
}
c(bW, "ex");
d(bW, "isRTL");
const SY = {
  convertOffsetParentRelativeRectToViewportRelativeRect: uW,
  getDocumentElement: Ln,
  getClippingRect: wW,
  getOffsetParent: A4,
  getElementRects: kY,
  getClientRects: pW,
  getDimensions: vW,
  getScale: lo,
  isElement: fn,
  isRTL: bW
};
function R4(n, t) {
  return n.x === t.x && n.y === t.y && n.width === t.width && n.height === t.height;
}
c(R4, "iv");
d(R4, "rectsAreEqual");
function $W(n, t) {
  let e = null, i;
  const s = Ln(n);
  function r() {
    var o;
    clearTimeout(i), (o = e) == null || o.disconnect(), e = null;
  }
  c(r, "n"), d(r, "cleanup");
  function a(o, l) {
    o === void 0 && (o = !1), l === void 0 && (l = 1), r();
    const h = n.getBoundingClientRect(), {
      left: u,
      top: p,
      width: y,
      height: m
    } = h;
    if (o || t(), !y || !m)
      return;
    const g = dv(p), b = dv(s.clientWidth - (u + y)), S = dv(s.clientHeight - (p + m)), x = dv(u), Q = {
      rootMargin: -g + "px " + -b + "px " + -S + "px " + -x + "px",
      threshold: oo(0, gb(1, l)) || 1
    };
    let L = !0;
    function W(R) {
      const I = R[0].intersectionRatio;
      if (I !== l) {
        if (!L)
          return a();
        I ? a(!1, I) : i = setTimeout(() => {
          a(!1, 1e-7);
        }, 1e3);
      }
      I === 1 && !R4(h, n.getBoundingClientRect()) && a(), L = !1;
    }
    c(W, "R"), d(W, "handleObserve");
    try {
      e = new IntersectionObserver(W, {
        ...Q,
        // Handle <iframe>s
        root: s.ownerDocument
      });
    } catch {
      e = new IntersectionObserver(W, Q);
    }
    e.observe(n);
  }
  return c(a, "o"), d(a, "refresh"), a(!0), r;
}
c($W, "rx");
d($W, "observeMove");
function E4(n, t, e, i) {
  i === void 0 && (i = {});
  const {
    ancestorScroll: s = !0,
    ancestorResize: r = !0,
    elementResize: a = typeof ResizeObserver == "function",
    layoutShift: o = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = i, h = A0(n), u = s || r ? [...h ? dm(h) : [], ...dm(t)] : [];
  u.forEach((x) => {
    s && x.addEventListener("scroll", e, {
      passive: !0
    }), r && x.addEventListener("resize", e);
  });
  const p = h && o ? $W(h, e) : null;
  let y = -1, m = null;
  a && (m = new ResizeObserver((x) => {
    let [Q] = x;
    Q && Q.target === h && m && (m.unobserve(t), cancelAnimationFrame(y), y = requestAnimationFrame(() => {
      var L;
      (L = m) == null || L.observe(t);
    })), e();
  }), h && !l && m.observe(h), m.observe(t));
  let g, b = l ? ca(n) : null;
  l && S();
  function S() {
    const x = ca(n);
    b && !R4(b, x) && e(), b = x, g = requestAnimationFrame(S);
  }
  return c(S, "I"), d(S, "frameLoop"), e(), () => {
    var x;
    u.forEach((Q) => {
      s && Q.removeEventListener("scroll", e), r && Q.removeEventListener("resize", e);
    }), p?.(), (x = m) == null || x.disconnect(), m = null, l && cancelAnimationFrame(g);
  };
}
c(E4, "rv");
d(E4, "autoUpdate");
const xW = pY, kW = fY, SW = dY, CW = /* @__PURE__ */ d((n, t, e) => {
  const i = /* @__PURE__ */ new Map(), s = {
    platform: SY,
    ...e
  }, r = {
    ...s.platform,
    _c: i
  };
  return hY(n, t, {
    ...s,
    platform: r
  });
}, "computePosition"), R0 = et`[part~=wy-dropdown-menu]{width:max-content;position:absolute;z-index:1000;min-width:calc(10*var(--wy-size, 1rem));border:none;padding:0;--wy-component-background-color: var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);font-size:var(--wy-font-size, var(--wy-size, 1em));text-align:left;background-clip:padding-box;border-radius:var(--wy-dropdown-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));box-shadow:var(--wy-dropdown-shadow, var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12)));overflow:hidden}[part~=wy-dropdown-menu]:not([popover]){display:block}[part~=wy-dropdown-item]{background-color:#0000;color:var(--wy-component-color, var(--wy-on-surface, var(--wy-on-surface-light, #181c20)));width:100%;min-height:calc(2.5*var(--wy-size, 1rem));padding:var(--wy-dropdown-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-dropdown-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));clear:both;font-family:var(--wy-font-family, unset),inherit;font-size:inherit;font-weight:var(--wy-font-weight, unset);line-height:1;text-align:inherit;text-decoration:none;white-space:nowrap;border:0;gap:var(--wy-dropdown-gap, var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));cursor:pointer;display:flex;align-items:center}[part~=wy-dropdown-item]:hover,[part~=wy-dropdown-item]:focus{--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));color:var(--wy-component-color);background-color:var(--wy-component-background-color);text-decoration:none}[part~=wy-dropdown-item][part~=wy-active],[part~=wy-dropdown-item]:active{--wy-component-color: var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73));--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));color:var(--wy-component-color);background-color:var(--wy-component-background-color);text-decoration:none}[part~=wy-dropdown-item][part~=wy-disabled],[part~=wy-dropdown-item]:disabled{color:var(--wy-component-color);background-color:var(--wy-component-background-color);pointer-events:none;opacity:var(--wy-opacity-disabled, 38%)}[part~=wy-dropdown-item]>img,[part~=wy-dropdown-item]>wy-icon{margin-right:calc(.5*var(--wy-size, 1rem));color:inherit}[part~=wy-dropdown-item]:active>wy-icon{color:inherit}[part~=wy-dropdown-item][part~=wy-dropdown-option] wy-icon{visibility:hidden}[part~=wy-dropdown-item][part~=wy-dropdown-option][part~=wy-selected] wy-icon{visibility:visible}[part~=wy-dropdown-divider]{height:0;margin:0;overflow:hidden;border:none;border-top:var(--wy-dropdown-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}`;
var CY = Object.defineProperty, PY = Object.getOwnPropertyDescriptor, ui = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? PY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && CY(t, e, s), s;
}, "__decorateClass$13"), R$, bf;
let Gi = (R$ = (bf = class extends pt {
  constructor() {
    super(), this.exportParts = new Y(this), this.directionX = "right", this.directionY = "down", this.icon = "dots-vertical", this.small = !1, this.disabled = !1, this._placement = "bottom-start", this.showMenu = !1, this.buttonRef = wt(), this.menuRef = wt(), this._documentClickHandler = (t) => {
      this.showMenu && (t.preventDefault(), this.menuRef.value?.popover || (this.showMenu = !1));
    }, this.addEventListener("click", (t) => {
      t.preventDefault();
    });
  }
  handleClose(t) {
    (t.type === "toggle" && t.newState === "closed" || t.type === "click") && (this.showMenu = !1, this.dispatchEvent(new CustomEvent("close")));
  }
  handleClickToggle(t) {
    t.stopPropagation(), this.showMenu = this.disabled ? !1 : !this.showMenu;
  }
  willUpdate(t) {
    if (super.willUpdate(t), (t.has("disabled") || t.has("showMenu")) && this.disabled && this.showMenu && (this.showMenu = !1), (t.has("directionX") || t.has("directionY")) && (this._placement = this.directionX === "right" && this.directionY === "down" ? "bottom-start" : this.directionX === "left" && this.directionY === "down" ? "bottom-end" : this.directionX === "right" && this.directionY === "up" ? "top-start" : "top-end"), t.has("showMenu") && (this.showMenu && !this.computePositionCleanup && this.buttonRef.value && this.menuRef.value ? this.computePositionCleanup = E4(this.buttonRef.value, this.menuRef.value, () => {
      if (this.buttonRef.value && this.menuRef.value) {
        const e = !this.menuRef.value.popover, i = e || !B9(this.buttonRef.value);
        CW(this.buttonRef.value, this.menuRef.value, {
          placement: this._placement,
          strategy: e ? "fixed" : "absolute",
          middleware: [
            SW(),
            xW(({ placement: s }) => s.includes("top") ? 9 : 13),
            kW({ mainAxis: !0, crossAxis: !0, padding: 4, altBoundary: i })
          ]
        }).then(({ x: s, y: r }) => {
          this.menuRef.value && Object.assign(this.menuRef.value.style, {
            marginLeft: `${s}px`,
            marginTop: `${r}px`,
            top: 0,
            left: 0,
            position: e ? "fixed" : void 0,
            zIndex: e ? 1075 : void 0
          });
        });
      }
    }) : !this.showMenu && this.computePositionCleanup && (this.computePositionCleanup?.(), this.computePositionCleanup = void 0)), this.showMenu) {
      requestAnimationFrame(() => {
        document.addEventListener("click", this._documentClickHandler, { once: !0, capture: !0 });
      });
      try {
        this.menuRef.value?.showPopover();
      } catch {
      }
    } else
      try {
        this.menuRef.value?.hidePopover();
      } catch {
      }
  }
  render() {
    const t = this._slotButton.length === 0 || this._slotButton.length === 1 && this._slotButton[0] instanceof he;
    return v`
      <span part="wy-dropdown">
        <span
          ${ot(this.buttonRef)}
          part="wy-dropdown-button-container"
          @click=${(e) => this.handleClickToggle(e)}
          @keydown=${Le}
          @keyup=${di}
        >
          <wy-button
            part="wy-dropdown-button"
            .kind=${t ? "icon" : void 0}
            ?small=${this.small}
            title=${this.title}
            ?active=${this.showMenu}
            ?disabled=${this.disabled}
          >
            <slot name="button-content" @slotchange=${() => this.requestUpdate()}>
              <wy-icon part="wy-dropdown-button-icon" name=${this.icon}></wy-icon>
            </slot>
          </wy-button>
        </span>

        <div
          ${ot(this.menuRef)}
          part="wy-dropdown-menu"
          @click=${(e) => this.handleClickToggle(e)}
          @keyup=${C0}
          ?hidden=${aO() && !this.showMenu}
          popover=${Ot(aO() ? void 0 : "auto")}
        >
          <slot></slot>
        </div>
      </span>
    `;
  }
  firstUpdated(t) {
    this.menuRef.value?.addEventListener(
      this.menuRef.value.popover ? "toggle" : "click",
      (e) => this.handleClose(e)
    );
  }
  disconnectedCallback() {
    this.computePositionCleanup?.(), super.disconnectedCallback();
  }
}, c(bf, "Ua"), bf), d(R$, "WyDropdown"), R$);
Gi.styles = [ne, R0];
ui([
  O()
], Gi.prototype, "directionX", 2);
ui([
  O()
], Gi.prototype, "directionY", 2);
ui([
  O()
], Gi.prototype, "icon", 2);
ui([
  O({ type: Boolean })
], Gi.prototype, "small", 2);
ui([
  O({ type: Boolean })
], Gi.prototype, "disabled", 2);
ui([
  F()
], Gi.prototype, "_placement", 2);
ui([
  F()
], Gi.prototype, "showMenu", 2);
ui([
  Ml({ slot: "button-content" })
], Gi.prototype, "_slotButton", 2);
ui([
  F()
], Gi.prototype, "computePositionCleanup", 2);
Gi = ui([
  U("wy-dropdown")
], Gi);
var E$, $f;
let Nw = (E$ = ($f = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.active = !1;
  }
  render() {
    return v`<div part="wy-dropdown-item ${ut({ "wy-active": this.active })}" tabindex="0"><slot></slot></div>`;
  }
}, c($f, "Ba"), $f), d(E$, "WyDropdownItem"), E$);
Nw.styles = [ne, R0, ft];
ui([
  O({ type: Boolean })
], Nw.prototype, "active", 2);
Nw = ui([
  U("wy-dropdown-item")
], Nw);
var _$, xf;
let um = (_$ = (xf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.active = !1, this.selected = !1;
  }
  render() {
    const t = {
      visibility: this.selected ? null : "hidden"
    };
    return v`
      <div
        part="wy-dropdown-item wy-dropdown-option ${ut({
      "wy-active": this.active,
      "wy-selected": this.selected
    })}"
        tabindex="0"
      >
        <slot name="icon" style=${Zw(t)}
          ><wy-icon part="wy-dropdown-option-icon" name="check"></wy-icon
        ></slot>
        <slot></slot>
      </div>
    `;
  }
}, c(xf, "qa"), xf), d(_$, "WyDropdownOption"), _$);
um.styles = [ne, R0, ft];
ui([
  O({ type: Boolean })
], um.prototype, "active", 2);
ui([
  O({ type: Boolean })
], um.prototype, "selected", 2);
um = ui([
  U("wy-dropdown-option")
], um);
var z$, kf;
let bb = (z$ = (kf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this);
  }
  render() {
    return v`<hr part="wy-dropdown-divider" />`;
  }
}, c(kf, "Na"), kf), d(z$, "WyDropdownDivider"), z$);
bb.styles = [ne, R0, ft];
bb = ui([
  U("wy-dropdown-divider")
], bb);
const PW = et`[part~=wy-placeholder]{cursor:wait;color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));background:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));opacity:.5;animation:wy-placeholder-glow 2s ease-in-out infinite;line-height:1.45}@keyframes wy-placeholder-glow{50%{opacity:.2}}`;
var QY = Object.defineProperty, TY = Object.getOwnPropertyDescriptor, QW = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? TY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && QY(t, e, s), s;
}, "__decorateClass$12"), L$, Sf;
let jw = (L$ = (Sf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.text = "";
  }
  render() {
    const t = this.text.trim();
    return v`
      <div part="wy-skeleton">
        ${t.length ? t.split(/(\n+)/).map((e) => {
      const i = e.split(/(\s+)/);
      return v`
                <div part="wy-placeholder-line">
                  ${i.map((s) => v` <span part="wy-placeholder">${s}</span> `)}
                </div>
              `;
    }) : C}
      </div>
    `;
  }
}, c(Sf, "ja"), Sf), d(L$, "WySkeleton"), L$);
jw.styles = [PW, ft];
QW([
  O()
], jw.prototype, "text", 2);
jw = QW([
  U("wy-skeleton")
], jw);
function _4(n) {
  const t = [n];
  for (; n && n.parent; )
    n = n.parent, t.push(n);
  return t;
}
c(_4, "dv");
d(_4, "getEntityChain");
function z4(n, t, e) {
  return n.type === t && (!e || n.id === e.id);
}
c(z4, "hv");
d(z4, "isEntityMatch");
function P1(n, t, e) {
  return _4(n).some((i) => i && z4(i, t, e));
}
c(P1, "Mh");
d(P1, "isEntityChainMatch");
function L4(n, t, e) {
  return _4(n).find((i) => i && z4(i, t, e));
}
c(L4, "pv");
d(L4, "getEntityChainMatch");
function I4(n, t, e, i) {
  const s = L4(n, i);
  return s && s.parent ? P1(s.parent, t, e) : !1;
}
c(I4, "uv");
d(I4, "hasEntityChildType");
async function W4(n, t, e) {
  let i;
  if (t && e?.link?.app?.id) {
    const r = await t.fetch(`/api/apps/${e.link.app.id}`);
    r.ok && (i = (await r.json()).metadata);
  }
  const s = new CustomEvent("wy-link", {
    bubbles: !0,
    composed: !0,
    cancelable: !0,
    detail: {
      link: e.link ? {
        ...e?.link,
        // HACK: pass along the agent uid so uikit can match the correct agent chat     
        agent: e.actor.is_agent && e.link?.app?.type && hb.has(e.link.app.type) ? e.actor.uid : void 0
      } : void 0,
      metadata: e.metadata,
      app_type: e?.link?.app?.type && LB.get(e.link.app.type) || _r,
      source_name: i?.source_name,
      source_url: i?.source_url,
      source_data: i?.source_data
    }
  });
  return n.dispatchEvent(s);
}
c(W4, "yv");
d(W4, "dispatchLinkEvent");
function V4(n) {
  const t = n.args;
  switch (n.template) {
    case "**{0}** added *{1}* to **{2}**": {
      const [e, i, s] = t;
      return {
        title: P(st`${e} added ${i} to ${s}`),
        titleHtml: P(v`<strong>${e}</strong> added <em>${i}</em> to <strong>${s}</strong>`)
      };
    }
    case "**{0}** edited *{1}*": {
      const [e, i] = t;
      return {
        title: P(st`${e} edited ${i}`),
        titleHtml: P(v`<strong>${e}</strong> edited <em>${i}</em>`)
      };
    }
    case '**{0}** commented on *{1}*: "{2}"': {
      const [e, i, s] = t;
      return {
        title: P(st`${e} commented on ${i}`),
        titleHtml: P(v`<strong>${e}</strong> commented on <em>${i}</em>`),
        detail: s
      };
    }
    case '**{0}** commented on **{1}**: "{2}"': {
      const [e, i, s] = t;
      return {
        title: P(st`${e} commented on ${i}`),
        titleHtml: P(v`<strong>${e}</strong> commented on <strong>${i}</strong>`),
        detail: s
      };
    }
    case '**{0}** replied to your post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(st`${e} replied to your post`),
        titleHtml: P(v`<strong>${e}</strong> replied to your post`),
        detail: i
      };
    }
    case '**{0}** replied to a post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(st`${e} replied to a post`),
        titleHtml: P(v`<strong>${e}</strong> replied to a post`),
        detail: i
      };
    }
    case '**{0}** mentioned you in a comment: "{1}"': {
      const [e, i] = t;
      return {
        title: P(st`${e} mentioned you in a comment`),
        titleHtml: P(v`<strong>${e}</strong> mentioned you in a comment`),
        detail: i
      };
    }
    case '**{0}** posted in **{1}**: "{2}"': {
      const [e, i, s] = t;
      return {
        title: P(st`${e} posted in ${i}`),
        titleHtml: P(v`<strong>${e}</strong> posted in <strong>${i}</strong>`),
        detail: s
      };
    }
    case '**{0}** mentioned you in a post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(st`${e} mentioned you in a post`),
        titleHtml: P(v`<strong>${e}</strong> mentioned you in a post`),
        detail: i
      };
    }
    case 'New message from **{0}**: "{1}"': {
      const [e, i] = t;
      return {
        title: P(st`New message from ${e}`),
        titleHtml: P(v`New message from <strong>${e}</strong>`),
        detail: i
      };
    }
    case '**{0}** sent a message in **{1}**: "{2}"': {
      const [e, i, s] = t;
      return {
        title: P(st`${e} sent a message in ${i}`),
        titleHtml: P(v`<strong>${e}</strong> sent a message in <strong>${i}</strong>`),
        detail: s
      };
    }
    case '**{0}** mentioned you in a message: "{1}"': {
      const [e, i] = t;
      return {
        title: P(st`${e} mentioned you in a message`),
        titleHtml: P(v`<strong>${e}</strong> mentioned you in a message`),
        detail: i
      };
    }
    case '**{0}** edited a post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(st`${e} edited a post`),
        titleHtml: P(v`<strong>${e}</strong> edited a post`),
        detail: i
      };
    }
    case "**{0}** liked *{1}*": {
      const [e, i] = t;
      return {
        title: P(st`${e} liked ${i}`),
        titleHtml: P(v`<strong>${e}</strong> liked <em>${i}</em>`)
      };
    }
    case "**{0}** reacted {2} to *{1}*": {
      const [e, i, s] = t;
      return {
        title: P(st`${e} reacted ${i} to ${s}`),
        titleHtml: P(v`<strong>${e}</strong> reacted ${i} to <em>${s}</em>`)
      };
    }
    case '**{0}** liked your comment: "{1}"': {
      const [e, i] = t;
      return {
        title: P(st`${e} liked your comment`),
        titleHtml: P(v`<strong>${e}</strong> liked your comment`),
        detail: i
      };
    }
    case '**{0}** reacted {1} to your comment: "{2}"': {
      const [e, i, s] = t;
      return {
        title: P(st`${e} reacted ${i} to your comment`),
        titleHtml: P(v`<strong>${e}</strong> reacted ${i} to your comment`),
        detail: s
      };
    }
    case '**{0}** liked your message: "{1}"': {
      const [e, i] = t;
      return {
        title: P(st`${e} liked your message`),
        titleHtml: P(v`<strong>${e}</strong> liked your message`),
        detail: i
      };
    }
    case '**{0}** reacted {1} to your message: "{2}"': {
      const [e, i, s] = t;
      return {
        title: P(st`${e} reacted ${i} to your message`),
        titleHtml: P(v`<strong>${e}</strong> reacted ${i} to your message`),
        detail: s
      };
    }
    case '**{0}** liked your post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(st`${e} liked your post`),
        titleHtml: P(v`<strong>${e}</strong> liked your post`),
        detail: i
      };
    }
    case '**{0}** reacted {1} to your post: "{2}"': {
      const [e, i, s] = t;
      return {
        title: P(st`${e} reacted ${i} to your post`),
        titleHtml: P(v`<strong>${e}</strong> reacted ${i} to your post`),
        detail: s
      };
    }
    case "**{0}** voted on your poll": {
      const [e] = t;
      return {
        title: P(st`${e} voted on your poll`),
        titleHtml: P(v`<strong>${e}</strong> voted on your poll`)
      };
    }
    case "**{0}** and **{1}** voted on your poll": {
      const [e, i] = t;
      return {
        title: P(st`${e} and ${i} voted on your poll`),
        titleHtml: P(v`<strong>${e}</strong> and <strong>${i}</strong> voted on your poll`)
      };
    }
    case "**{0}**, **{1}** and **{2}** voted on your poll": {
      const [e, i, s] = t;
      return {
        title: P(st`${e}, ${i} and ${s} voted on your poll`),
        titleHtml: P(
          v`<strong>${e}</strong>, <strong>${i}</strong> and <strong>${s}</strong> voted on your poll`
        )
      };
    }
    case "**{0}** and {1} others voted on your poll": {
      const [e, i] = t;
      return {
        title: P(st`${e} and ${i} others voted on your poll`),
        titleHtml: P(v`<strong>${e}</strong> and ${i} others voted on your poll`)
      };
    }
    default:
      return {
        title: n.plain,
        titleHtml: v`${ol(n.html)}`
      };
  }
}
c(V4, "wv");
d(V4, "getNotificationText");
const D4 = et`[part~=wy-code] pre,.wy-code pre,[part~=wy-content] pre{text-wrap:pretty}[part~=wy-code] .code,[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code .code,.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] .code,[part~=wy-content] code[class*=language-],[part~=wy-content] pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;word-wrap:break-word;line-height:1.25;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}@media print{[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] code[class*=language-],[part~=wy-content] pre[class*=language-]{text-shadow:none}}[part~=wy-code] pre[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}[part~=wy-code] :not(pre)>code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code :not(pre)>code[class*=language-],.wy-code pre[class*=language-],[part~=wy-content] :not(pre)>code[class*=language-],[part~=wy-content] pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));background:var(--wy-background, var(--wy-background-light, #f7f9ff))}[part~=wy-code] :not(pre)>code[class*=language-],.wy-code :not(pre)>code[class*=language-],[part~=wy-content] :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}[part~=wy-code] .token.variable,.wy-code .token.variable,[part~=wy-content] .token.variable{color:var(--wy-code-variable, var(--wy-code-variable-light, #001080))}[part~=wy-code] .token.operator,.wy-code .token.operator,[part~=wy-content] .token.operator{color:var(--wy-code-operator, var(--wy-code-operator-light, #000000))}[part~=wy-code] .token.prolog,.wy-code .token.prolog,[part~=wy-content] .token.prolog{color:var(--wy-code-prolog, var(--wy-code-prolog-light, #000080))}[part~=wy-code] .token.comment,.wy-code .token.comment,[part~=wy-content] .token.comment{color:var(--wy-code-comment, var(--wy-code-comment-light, #008000))}[part~=wy-code] .token.builtin,.wy-code .token.builtin,[part~=wy-content] .token.builtin{color:var(--wy-code-builtin, var(--wy-code-builtin-light, #0070C1))}[part~=wy-code] .token.number,.wy-code .token.number,[part~=wy-content] .token.number{color:var(--wy-code-number, var(--wy-code-number-light, #098658))}[part~=wy-code] .token.inserted,.wy-code .token.inserted,[part~=wy-content] .token.inserted{color:var(--wy-code-inserted, var(--wy-code-inserted-light, #098658))}[part~=wy-code] .token.constant,.wy-code .token.constant,[part~=wy-content] .token.constant{color:var(--wy-code-constant, var(--wy-code-constant-light, #811F3F))}[part~=wy-code] .token.hexcode,.wy-code .token.hexcode,[part~=wy-content] .token.hexcode{color:var(--wy-code-hexcode, var(--wy-code-hexcode-light, #811F3F))}[part~=wy-code] .token.regex,.wy-code .token.regex,[part~=wy-content] .token.regex{color:var(--wy-code-regex, var(--wy-code-regex-light, #811F3F))}[part~=wy-code] .token.char,.wy-code .token.char,[part~=wy-content] .token.char{color:var(--wy-code-char, var(--wy-code-char-light, #811F3F))}[part~=wy-code] .token.tag,.wy-code .token.tag,[part~=wy-content] .token.tag{color:var(--wy-code-tag, var(--wy-code-tag-light, #800000))}[part~=wy-code] .token.attr-name,.wy-code .token.attr-name,[part~=wy-content] .token.attr-name{color:var(--wy-code-attr-name, var(--wy-code-attr-name-light, #E50000))}[part~=wy-code] .token.selector,.wy-code .token.selector,[part~=wy-content] .token.selector{color:var(--wy-code-selector, var(--wy-code-selector-light, #E50000))}[part~=wy-code] .token.property,.wy-code .token.property,[part~=wy-content] .token.property{color:var(--wy-code-property, var(--wy-code-property-light, #E50000))}[part~=wy-code] .token.deleted,.wy-code .token.deleted,[part~=wy-content] .token.deleted{color:var(--wy-code-deleted, var(--wy-code-deleted-light, #A31515))}[part~=wy-code] .token.string,.wy-code .token.string,[part~=wy-content] .token.string{color:var(--wy-code-string, var(--wy-code-string-light, #A31515))}[part~=wy-code] .token.changed,.wy-code .token.changed,[part~=wy-content] .token.changed{color:var(--wy-code-changed, var(--wy-code-changed-light, #0451A5))}[part~=wy-code] .token.punctuation,.wy-code .token.punctuation,[part~=wy-content] .token.punctuation{color:var(--wy-code-punctuation, var(--wy-code-punctuation-light, #000000))}[part~=wy-code] .token.function,.wy-code .token.function,[part~=wy-content] .token.function{color:var(--wy-code-function, var(--wy-code-function-light, #0000FF))}[part~=wy-code] .token.keyword,.wy-code .token.keyword,[part~=wy-content] .token.keyword{color:var(--wy-code-keyword, var(--wy-code-keyword-light, #AF00DB))}[part~=wy-code] .token.class-name,.wy-code .token.class-name,[part~=wy-content] .token.class-name{color:var(--wy-code-class-name, var(--wy-code-class-name-light, #267F99))}[part~=wy-code] .token.important,[part~=wy-code] .token.bold,.wy-code .token.important,.wy-code .token.bold,[part~=wy-content] .token.important,[part~=wy-content] .token.bold{font-weight:700}[part~=wy-code] .token.italic,.wy-code .token.italic,[part~=wy-content] .token.italic{font-style:italic}[part~=wy-content]{overflow-wrap:break-word;min-width:0}[part~=wy-content]:empty{display:none}[part~=wy-content]>:first-child{margin-top:0}[part~=wy-content]>:last-child{margin-bottom:0}[part~=wy-content] b,[part~=wy-content] strong{font-weight:var(--wy-font-weight-bold, 600)}[part~=wy-content] blockquote{border-left:calc(2*var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));margin:var(--wy-gap, calc(.5 * var(--wy-size, 1rem))) 0;padding-left:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-content] blockquote>p{margin:0}[part~=wy-content] hr{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));border-width:var(--wy-border, 1px) 0 0 0;border-style:solid}[part~=wy-content] pre,[part~=wy-content] code{font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-content] :not(pre)>code{overflow-wrap:inherit}[part~=wy-content] pre>code{font-size:var(--wy-font-size, var(--wy-size, 1em));white-space:pre-wrap}[part~=wy-content] h1,[part~=wy-content] h2,[part~=wy-content] h3,[part~=wy-content] h4,[part~=wy-content] h5,[part~=wy-content] h6{font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.5))}[part~=wy-content] h1{font-size:var(--wy-h1-font-size, var(--wy-font-size-xxl, 1.5em));font-weight:var(--wy-h1-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h1-margin, 0 0 var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-content] h2{font-size:var(--wy-h2-font-size, var(--wy-font-size-xl, 1.25em));font-weight:var(--wy-h2-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h2-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content] h3{font-size:var(--wy-h3-font-size, var(--wy-font-size-lg, 1.125em));font-weight:var(--wy-h3-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h3-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content] h4{font-size:var(--wy-h4-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-h4-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h4-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 0)}[part~=wy-content] h5{font-size:var(--wy-h5-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-h5-font-weight, var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600)));margin:var(--wy-h5-margin, 0)}[part~=wy-content] h6{font-size:var(--wy-h6-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-h6-font-weight, inherit);margin:var(--wy-h6-margin, 0)}[part~=wy-content] table{display:block;width:100%;max-width:-moz-max-content;max-width:max-content;overflow-x:auto;white-space:nowrap;border-collapse:separate;border-spacing:0 0;margin-bottom:var(--wy-size, 1rem)}[part~=wy-content] table th,[part~=wy-content] table td{padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));border-color:inherit;border-style:solid}[part~=wy-content] table th{text-align:inherit;text-align:-webkit-match-parent;border-width:var(--wy-border, 1px) 0 var(--wy-border, 1px) var(--wy-border, 1px);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600))}[part~=wy-content] table th:first-child{border-top-left-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] table th:last-child{border-top-right-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-right-width:var(--wy-border, 1px)}[part~=wy-content] table td{border-width:0 0 var(--wy-border, 1px) var(--wy-border, 1px)}[part~=wy-content] table td:last-child{border-right-width:var(--wy-border, 1px)}[part~=wy-content] table tr:last-child td:first-child{border-bottom-left-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] table tr:last-child td:last-child{border-bottom-right-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] table>tbody{vertical-align:inherit}[part~=wy-content] table>thead{vertical-align:bottom}[part~=wy-content] img{max-width:100%;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin-block:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] ol{list-style-type:decimal}[part~=wy-content] ul{list-style-type:disc}[part~=wy-content] li{margin:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0}[part~=wy-content] ol,[part~=wy-content] ul{margin:var(--wy-size, 1rem) 0;padding:0 0 0 1.625em}[part~=wy-content] ol>li,[part~=wy-content] ul>li{padding-left:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-content] ol>li>:first-child,[part~=wy-content] ul>li>:first-child{margin-bottom:0;margin-top:0}[part~=wy-content] ol>li>:last-child,[part~=wy-content] ul>li>:last-child{margin-bottom:0}[part~=wy-content] .wy-hashtag{color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-content] .wy-mention{font-weight:var(--wy-font-weight-bold, 600)}[part~=wy-content] .wy-mention:before{content:\"@\"}[part~=wy-content-emoji] .wy-emoji{font-size:3em}`;
function E0(n) {
  const t = n;
  t && (t.complete && t.naturalHeight !== 0 ? !t.classList.contains("wy-loading") && !t.part.contains("wy-loading") ? (t.classList.add("wy-loading", "wy-loaded"), t.part.add("wy-loading", "wy-loaded")) : t.decode().then(() => {
    t.classList.add("wy-loaded"), t.part.add("wy-loaded");
  }) : (t.classList.add("wy-loading"), t.part.add("wy-loading")));
}
c(E0, "fy");
d(E0, "checkImageLoad");
function _0(n) {
  const t = n.target;
  t.tagName === "IMG" && (t.classList.contains("wy-loading") || t.part.contains("wy-loading")) && !t.classList.contains("wy-loaded") && !t.part.contains("wy-loaded") && (t.classList.add("wy-loaded"), t.part.add("wy-loaded"));
}
c(_0, "my");
d(_0, "imageLoaded");
const MY = et`[part~=wy-image]{padding:0;width:50%;position:relative;flex:auto;background-color:inherit;background-clip:content-box;max-height:var(--wy-image-max-size, calc(32 * var(--wy-size, 1rem)))}[part~=wy-image-filled]{position:relative;background-size:100%,100% 100%;background-position:center;background-clip:content-box;clip-path:content-box;align-items:center;justify-content:center}[part~=wy-image-filled]:after{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;z-index:1;-webkit-backdrop-filter:blur(32px);backdrop-filter:blur(32px);background-color:var(--wy-shade, var(--wy-shade-light, rgba(0, 0, 0, .3)))}[part~=wy-image-full-width]{flex-basis:100%!important}[part~=wy-image-grid]{display:flex;flex-wrap:wrap;justify-content:space-evenly;position:relative;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));overflow:hidden;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-image-grid-outer]{border-radius:0}[part~=wy-image-area]{display:flex;height:100%;cursor:pointer;align-items:center}[part~=wy-image-content]{position:absolute;height:auto;max-height:100%;width:100%;object-fit:contain;z-index:2}[part~=wy-image-content][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-image-content][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-image-content][part~=wy-loading][part~=wy-loaded]~[part~=wy-image-preview]{transition-delay:.15s;opacity:0}[part~=wy-image-icon]{object-fit:scale-down;object-position:center center}[part~=wy-image-grid-more]{position:absolute;z-index:3;line-height:100%;color:var(--wy-white, #ffffff);inset:0;display:flex;align-items:center;justify-content:center;font-size:calc(1.5*var(--wy-size, 1rem));background:rgba(0,0,0,var(--wy-opacity-disabled, 38%))}`;
var AY = Object.defineProperty, RY = Object.getOwnPropertyDescriptor, z0 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? RY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && AY(t, e, s), s;
}, "__decorateClass$11");
const b9 = 128;
var I$, Cf;
let dl = (I$ = (Cf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.images = [], this.limit = 3, this.outer = !1;
  }
  /**
   * Dispatch a `file-open` event.
   *
   * @internal
   * @param e - Event that will be prevented.
   * @param file - The file to open.
   */
  dispatchFileOpen(t, e) {
    if (a1(t)) {
      t.stopPropagation();
      return;
    }
    if (t.preventDefault(), !e.is_trashed) {
      const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
      this.dispatchEvent(i);
    }
  }
  render() {
    const t = this.images.length > this.limit ? this.images.length - this.limit : 0, e = this.images.slice(0, this.limit);
    return v`
      <div
        part=${ut({
      "wy-image-grid": !0,
      "wy-image-grid-outer": this.outer
    })}
      >
        ${e.map((i, s) => {
      const r = !i.width || i.width <= b9 || !i.height || i.height <= b9, a = i.width && i.height ? i.width / i.height : 1, o = 64, l = a.toPrecision(5), h = (a * o).toPrecision(5) + "px", u = r ? o + "px" : (100 / a).toPrecision(5) + "%", p = i.width + "px", y = this.images.length !== 2 && s === 0, m = tn(i.name), g = m === ".gif" || m === ".svg" ? i.download_url : i.preview_url;
      return g ? v`
                <a
                  href="${i.download_url ?? "#"}"
                  @click=${(b) => {
        !b.defaultPrevented && this.dispatchFileOpen(b, i);
      }}
                  part=${ut({
        "wy-image": !0,
        "wy-image-filled": !0,
        "wy-image-full-width": y
      })}
                  style=${Zw({
        flexBasis: h,
        flexGrow: l,
        flexShrink: l,
        width: p,
        backgroundImage: `linear-gradient(var(--wy-shade-invert, rgba(255,255,255,0.15))), url(${g}), linear-gradient(var(--wy-shade-opaque, white));`
      })}
                >
                  <div part="wy-image-area" style=${Zw({ paddingBottom: u })}>
                    <img
                      part=${ut({ "wy-image-content": !0, "wy-image-icon": r })}
                      src=${g}
                      ${ot(E0)}
                      @load=${_0}
                      alt=""
                      loading="lazy"
                      decoding="async"
                    />
                    ${s === e.length - 1 && t ? v`<span part="wy-image-grid-more">+${t}</span>` : ""}
                  </div>
                </a>
              ` : C;
    })}
      </div>
    `;
  }
}, c(Cf, "Wa"), Cf), d(I$, "WyImageGrid"), I$);
dl.styles = [MY, ft];
z0([
  O({ attribute: !1 })
], dl.prototype, "images", 2);
z0([
  O({ type: Number })
], dl.prototype, "limit", 2);
z0([
  O({ type: Boolean, reflect: !0 })
], dl.prototype, "outer", 2);
dl = z0([
  U("wy-image-grid")
], dl);
var EY = Object.defineProperty, _Y = Object.getOwnPropertyDescriptor, Q1 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? _Y(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && EY(t, e, s), s;
}, "__decorateClass$10"), W$, Pf;
let Bw = (W$ = (Pf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this);
  }
  /**
   * Triggers file-open event.
   *
   * @param e
   * @param file
   * @returns
   */
  dispatchFileOpen(t, e) {
    t.preventDefault();
    const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
    return this.dispatchEvent(i);
  }
  render() {
    const t = this.file.size && this.file.size > 0 ? f0(this.file.size) : null, e = tn(this.file.name), { icon: i } = lr(this.file.name), s = m0(this.file.name), r = Tm(this.file.provider);
    return v`    
      <wy-item
        @click=${(a) => {
      !a.defaultPrevented && !this.file.is_trashed && this.dispatchFileOpen(a, this.file);
    }}
        size="md"
        title=${this.file.name}
        url=${Ot(this.file.download_url ?? this.file.external_url)}
        interactive
      >
        <wy-icon slot="image" name=${i} .overlayName=${r} size="48" kind=${s} ext=${e}></wy-icon>
        <span slot="title">${this.file.name}</span>
        ${t ? v`<span slot="text" title="${t}">${t}</span>` : C}
      </wy-item>
    `;
  }
}, c(Pf, "Qa"), Pf), d(W$, "WyAttachment"), W$);
Bw.styles = [Q0, ft];
Q1([
  O({ attribute: !1 })
], Bw.prototype, "file", 2);
Bw = Q1([
  U("wy-attachment")
], Bw);
var V$, Qf;
let pm = (V$ = (Qf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.files = [], this.filled = !1;
  }
  dispatchFileOpen(t) {
    const e = new CustomEvent("file-open", { detail: { fileId: t.id } });
    return this.dispatchEvent(e);
  }
  render() {
    return v`
      <wy-item-list rounded ?filled=${this.filled}>
        ${this.files.map((t) => v`<wy-attachment @file-open=${() => this.dispatchFileOpen(t)} .file=${t}></wy-attachment>`)}
      </wy-item-list>
    `;
  }
}, c(Qf, "Ka"), Qf), d(V$, "WyAttachmentList"), V$);
pm.styles = [Q0, ft];
Q1([
  O({ attribute: !1 })
], pm.prototype, "files", 2);
Q1([
  O({ type: Boolean })
], pm.prototype, "filled", 2);
pm = Q1([
  U("wy-attachment-list")
], pm);
var zY = Object.defineProperty, LY = Object.getOwnPropertyDescriptor, L0 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? LY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && zY(t, e, s), s;
}, "__decorateClass$$"), D$, Tf;
let Uw = (D$ = (Tf = class extends zi {
  constructor() {
    super(...arguments), this.exportParts = new Y(this);
  }
  /**
   * Triggers file-open event.
   * @internal
   */
  dispatchFileOpen(t, e) {
    t.preventDefault();
    const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
    return this.dispatchEvent(i);
  }
  render() {
    const t = this.file.size && this.file.size > 0 ? f0(this.file.size) : null, e = tn(this.file.name), { icon: i } = lr(this.file.name), s = m0(this.file.name), r = Tm(this.file.provider), a = `${this.file.name}${t ? ` • ${t}` : ""}`;
    return v`
      <wy-button
        part="wy-annotation"
        @click=${(o) => {
      !o.defaultPrevented && !this.file.is_trashed && this.dispatchFileOpen(o, this.file);
    }}
        kind="filled"
        small
        title=${a}
      >
        <wy-icon
          part="wy-annotation-icon"
          name=${i}
          .overlayName=${r}
          size="24"
          kind=${s}
          ext=${e}
        ></wy-icon>
        <span part="wy-annotation-text">${this.file.name}</span>
      </wy-button>
    `;
  }
}, c(Tf, "Ga"), Tf), d(D$, "WyAnnotation"), D$);
Uw.styles = [ft];
L0([
  O({ type: Object, attribute: !1 })
], Uw.prototype, "file", 2);
Uw = L0([
  U("wy-annotation")
], Uw);
var q$, Mf;
let Hw = (q$ = (Mf = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.files = [];
  }
  render() {
    return this.settings?.annotations === "none" ? C : v`
      <div part="wy-annotations">
        ${this.files.map((t) => v`<wy-annotation .file=${t}></wy-annotation>`)}
      </div>
    `;
  }
}, c(Mf, "Za"), Mf), d(q$, "WyAnnotationList"), q$);
Hw.styles = [ft];
L0([
  O({ attribute: !1 })
], Hw.prototype, "files", 2);
Hw = L0([
  U("wy-annotation-list")
], Hw);
function as(n = "", t = "", e = "", i = !1) {
  if (we(), n) {
    const s = document.createElement("a");
    i && (/^(data:|blob:)/.test(n) ? s.download = e || "download" : n = n.includes("?d=1") || n.includes("&d=1") ? n : n.includes("?") ? n + "&d=1" : n + "?d=1"), t && (s.target = t), s.href = n, document.body.appendChild(s);
    try {
      s.click();
    } catch {
      if (console.warn("Could not open link normally, trying fallback"), /^(?:blob:|data:)/.test(n))
        console.error(`Could not ${i ? "download" : "open"} ${e}`);
      else
        try {
          window.open(n, t);
        } catch {
          console.error(`Could not ${i ? "download" : "open"} ${e}`);
        }
    }
    document.body.removeChild(s);
  }
}
c(as, "Wi");
d(as, "openUrl");
function vS(n, t) {
  return new URL(
    n,
    typeof WEAVY_IMPORT_URL == "string" && (!t || !new URL(t).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : t
  );
}
c(vS, "pf");
d(vS, "environmentUrl");
const TW = et`[part~=wy-embed]{display:flex;flex-direction:column;word-wrap:break-word;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));clip-path:border-box;--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));color:var(--wy-component-color)}[part~=wy-embed-interactive]{background-color:var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));-webkit-user-select:none;user-select:none;cursor:pointer}[part~=wy-embed-interactive]:active,[part~=wy-embed-interactive]:hover,[part~=wy-embed-interactive]:focus{background-color:var(--wy-surface-layer-high, var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039)))}[part~=wy-embed-interactive][part~=wy-disabled],[part~=wy-embed-interactive]:disabled{pointer-events:none;border-left:none;border-right:none;border-bottom:none;border-radius:0;background-color:#0000}[part~=wy-embed-area]{display:flex;justify-content:center;align-items:center}[part~=wy-embed-icon]{width:calc(3*var(--wy-size, 1rem));height:calc(3*var(--wy-size, 1rem));flex:0 0 auto;object-fit:contain}[part~=wy-embed-content]{display:flex;position:relative;padding:0;overflow:hidden;width:100%;flex-direction:column;align-items:center;justify-content:flex-start}[part~=wy-embed-content] iframe,[part~=wy-embed-content] embed,[part~=wy-embed-content] object,[part~=wy-embed-content] video{border:0;width:auto;height:auto;max-height:var(--wy-component-max-size, var(--wy-embed-content-max-size, calc(48 * var(--wy-size, 1rem))))}[part~=wy-embed-photo]{border-top-left-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-top-right-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-left-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-right-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));position:relative;background-size:cover;background-position:center;clip-path:border-box}[part~=wy-embed-photo]:after{border-top-left-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-top-right-radius:var(--wy-component-border-top-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-left-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));border-bottom-right-radius:var(--wy-component-border-bottom-radius, var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));content:\"\";position:absolute;width:100%;height:100%;z-index:1;-webkit-backdrop-filter:blur(32px);backdrop-filter:blur(32px);background-color:var(--wy-shade, var(--wy-shade-light, rgba(0, 0, 0, .3)))}[part~=wy-embed-photo-with-description]{--wy-component-border-bottom-radius: 0}[part~=wy-embed-image]{width:auto;height:auto;object-fit:contain;flex:0 1 auto;min-width:0;min-height:calc(3*var(--wy-size, 1rem));max-height:calc(var(--wy-component-max-size, var(--wy-embed-content-max-size, calc(48 * var(--wy-size, 1rem)))) - var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))*2 - var(--wy-button-line-height, var(--wy-line-height, 1.5))*var(--wy-size, 1rem));z-index:2}[part~=wy-embed-provider]{color:var(--wy-outline, var(--wy-outline-light, #72777f));text-transform:uppercase;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));margin-bottom:calc(.25*var(--wy-size, 1rem))}[part~=wy-embed-provider]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-embed-actions]{display:flex;justify-content:space-between}[part~=wy-embed-select]{display:flex;flex-direction:column;min-height:0;--wy-component-max-size: calc(12 * var(--wy-size, 1rem));--wy-component-background-color: transparent}[part~=wy-embed-select] wy-embed{border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));--wy-component-border-top-radius: 0;min-height:0;display:none}[part~=wy-embed-select] wy-embed:first-of-type{display:block}`;
var IY = Object.defineProperty, WY = Object.getOwnPropertyDescriptor, T1 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? WY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && IY(t, e, s), s;
}, "__decorateClass$_"), Z$, Af;
let fm = (Z$ = (Af = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.disabled = !1, this.embedContentRef = wt();
  }
  /**
   * Dispatch a wy-action event for this embed.
   *
   * @internal
   * @param {ActionType | string} [action=""] - Action to dispatch.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchActionEvent(t = hi.Default) {
    const e = new CustomEvent("wy-action", {
      detail: {
        action: t,
        embed: this.embed
      },
      bubbles: !0,
      composed: !0,
      cancelable: !0
    });
    return this.dispatchEvent(e);
  }
  render() {
    const t = this.embed.actions ? [...this.embed.actions] : [], e = t.shift(), i = t.length === 1 ? t.shift() : void 0, s = !!((this.embed.type === "photo" || this.embed.type === "link") && (this.embed.title || this.embed.description || this.embed.type === "photo" && this.embed.provider_name));
    return v`
      <slot name="before"></slot>
      <div
        part="wy-embed ${ut({
      "wy-embed-interactive": !!this.embed.url,
      "wy-disabled": this.disabled
    })}"
        title=${this.embed.url ? this.embed.url : this.embed.title || ""}
        @click=${() => this.embed.url && this.dispatchActionEvent(hi.Default) && as(this.embed.url, "_blank")}
        @keydown=${Le}
        @keyup=${di}
      >
        ${(this.embed.type === "video" || this.embed.type === "rich") && this.embed.html ? v`
              <div part="wy-embed-area">
                <div
                  ${ot(this.embedContentRef)}
                  part=${ut({
      "wy-embed-content": !0,
      "wy-embed-video": this.embed.type === "video",
      "wy-embed-rich": this.embed.type === "rich"
    })}
                  data-width=${Ot(this.embed.width)}
                  data-height=${Ot(this.embed.height)}
                >
                  ${ol(this.embed.html)}
                </div>
              </div>
            ` : C}
        ${this.embed.type === "photo" && this.embed.image && this.embed.thumbnail_url ? v`
              <div
                part="wy-embed-photo wy-embed-area ${ut({
      "wy-embed-photo-with-description": s
    })}"
                style="background-image: linear-gradient(var(--wy-shade-invert, rgba(255,255,255,0.15))), url(${this.embed.thumbnail_url}), linear-gradient(var(--wy-shade-opaque, white));"
              >
                <img
                  part="wy-embed-image"
                  src=${this.embed.thumbnail_url}
                  alt=${this.embed.provider_name || this.embed.title || ""}
                  width=${Ot(this.embed.image.width)}
                  height=${Ot(this.embed.image.height)}
                />
              </div>
            ` : C}
        ${s ? v`
              <wy-item size="auto">
                ${this.embed.type === "link" && this.embed.image && this.embed.thumbnail_url ? v`
                      <img
                        part="wy-embed-icon"
                        slot="image"
                        src=${this.embed.thumbnail_url}
                        alt=${this.embed.provider_name || this.embed.title || ""}
                        width=${Ot(this.embed.image.width)}
                        height=${Ot(this.embed.image.height)}
                      />
                    ` : C}
                ${this.embed.provider_name ? v`<span slot="meta" part="wy-embed-provider">${this.embed.provider_name}</span>` : C}
                ${this.embed.title ? v`<span slot="title">${this.embed.title}</span>` : C}
                ${this.embed.description ? v`<span slot="text">${this.embed.description}</span>` : C}
                ${i ? v`
                      <wy-button
                        slot="actions"
                        color="variant"
                        @click=${(r) => {
      r.stopPropagation(), this.dispatchActionEvent(i);
    }}
                      >
                        ${i}
                      </wy-button>
                    ` : C}
                ${e ? v`
                      <wy-button
                        slot="actions"
                        color="primary"
                        @click=${(r) => {
      r.stopPropagation(), this.dispatchActionEvent(e);
    }}
                      >
                        ${e}
                      </wy-button>
                    ` : C}
                ${t.length ? v`
                      <wy-dropdown slot="actions">
                        ${t.map(
      (r) => v`
                              <wy-dropdown-item
                                @click=${(a) => {
        a.preventDefault(), a.stopPropagation(), this.dispatchActionEvent(r);
      }}
                              >
                                ${r}
                              </wy-dropdown-item>
                            `
    )}
                      </wy-dropdown>
                    ` : C}
              </wy-item>
            ` : C}
      </div>
    `;
  }
  updated(t) {
    if (this.embedContentRef.value) {
      const e = this.embedContentRef.value.firstElementChild, { width: i, height: s } = this.embedContentRef.value.dataset, r = Number(s ?? ""), a = r > 128 && r < 256 ? r : 128;
      i && s && (e.style.aspectRatio = `${i} / ${s}`, e.style.minHeight = `${a}px`);
    }
  }
}, c(Af, "Ya"), Af), d(Z$, "WyEmbed"), Z$);
fm.styles = [ft, TW];
T1([
  O({ attribute: !1 })
], fm.prototype, "embed", 2);
T1([
  O({ type: Boolean, reflect: !0 })
], fm.prototype, "disabled", 2);
fm = T1([
  U("wy-embed")
], fm);
var F$, Rf;
let Yw = (F$ = (Rf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this);
  }
  /**
   * Dispatch a local embed-remove event for the embed with the given id.
  *
   * @internal
   * @param id - Embed id to remove.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchRemove(t) {
    const e = new CustomEvent("embed-remove", {
      detail: { id: t },
      bubbles: !1,
      composed: !1
    });
    return this.dispatchEvent(e);
  }
  /**
   * Dispatch a local embed-swap event to request rotating/swapping embeds.
  *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSwap() {
    const t = new CustomEvent("embed-swap", {
      detail: {},
      bubbles: !1,
      composed: !1
    });
    return this.dispatchEvent(t);
  }
  render() {
    return v`
      <div part="wy-embed-select">
        ${Mi(
      this.embeds,
      (t) => t.id,
      (t) => v`
            <wy-embed disabled .embed=${t}>
              <div part="wy-embed-actions" slot="before">
                ${this.embeds.length > 1 ? v`
                      <wy-button kind="icon" @click=${() => this.dispatchSwap()}>
                        <wy-icon name="swap-horizontal"></wy-icon>
                      </wy-button>
                    ` : v`<span></span>`}

                <wy-button kind="icon" @click=${() => this.dispatchRemove(t.id)}
                  ><wy-icon name="close-circle"></wy-icon
                ></wy-button>
              </div>
            </wy-embed>
          `
    )}
      </div>
    `;
  }
}, c(Rf, "Xa"), Rf), d(F$, "WyEmbedSelect"), F$);
Yw.styles = [ft, TW];
T1([
  O({ attribute: !1 })
], Yw.prototype, "embeds", 2);
Yw = T1([
  U("wy-embed-select")
], Yw);
function $b(n) {
  switch (n) {
    case "zoom":
      return "zoom-meetings";
    case "microsoft":
      return "microsoft-teams";
    case "google":
      return "google-meet";
  }
}
c($b, "Ru");
d($b, "getMeetingIconName");
function xb(n) {
  switch (n) {
    case "zoom":
      return P("Zoom meeting");
    case "microsoft":
      return P("Teams meeting");
    case "google":
      return P("Google Meet");
  }
}
c(xb, "Eu");
d(xb, "getMeetingTitle");
var VY = Object.defineProperty, DY = Object.getOwnPropertyDescriptor, MW = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? DY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && VY(t, e, s), s;
}, "__decorateClass$Z"), X$, Ef;
let Gw = (X$ = (Ef = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this);
  }
  render() {
    const t = ((/* @__PURE__ */ new Date()).getTime() - new Date(this.meeting.created_at).getTime()) / 36e5 > 2;
    return v`
      <wy-item-list rounded filled>
        ${t ? v`
              <wy-item part="wy-meeting" size="lg" disabled title="${P("Meeting ended")}">
                <wy-icon slot="image" svg="${$b(this.meeting.provider)}" size="48"></wy-icon>
                <span slot="title">${xb(this.meeting.provider)}</span>
                <span slot="text">${this.meeting.code}</span>
              </wy-item>
            ` : v`
              <wy-item
                interactive
                size="lg"
                part="wy-meeting"
                @click=${(e) => {
      e.preventDefault(), as(this.meeting.join_url, "_blank");
    }}
                url=${Ot(this.meeting.join_url)}
                title="${P("Join meeting")}"
              >
                <wy-icon
                  slot="image"
                  svg="${$b(this.meeting.provider)}"
                  size="48"
                  color="native"
                ></wy-icon>
                <span slot="title">${xb(this.meeting.provider)}</span>
                <span slot="text">${this.meeting.code}</span>
              </wy-item>
            `}
        </wy-item-list>
    `;
  }
}, c(Ef, "Ja"), Ef), d(X$, "WyMeetingCard"), X$);
Gw.styles = [ft];
MW([
  O({ attribute: !1 })
], Gw.prototype, "meeting", 2);
Gw = MW([
  U("wy-meeting-card"),
  St()
], Gw);
const q4 = et`[part~=wy-poll]{min-width:0;display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));box-sizing:border-box;width:100%}[part~=wy-poll-form]{display:flex;flex-direction:column;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-poll-form]:empty{display:none}[part~=wy-poll-option]{--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));display:flex;align-items:center;clip-path:border-box;overflow:hidden;position:relative;background-color:var(--wy-surface-layer-lowest, var(--wy-surface-layer-lowest-light, rgba(255, 255, 255, .7490196078)));border:var(--wy-border-outline, 0) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));cursor:pointer;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-poll-option]>:not([part~=wy-poll-meter]){z-index:1}[part=wy-poll-image]{display:flex;height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))*.6);padding:0;line-height:1;align-items:center;justify-content:center}[part~=wy-poll-title]{width:100%;min-width:0;min-height:100%;color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset));align-content:center}[part~=wy-poll-title]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-poll-amount]{min-width:3em;text-align:end}[part~=wy-poll-meter]{position:absolute;top:0;left:0;bottom:0;background-color:var(--wy-surface-layer-highest, var(--wy-surface-layer-highest-light, rgba(0, 0, 0, .1019607843)))}`, qY = et`[part~=wy-dialog]{background:none;border:none;padding:0;margin:0;width:100%;height:100%;max-width:100%;max-height:100%;container-type:inline-size;pointer-events:none}[part~=wy-dialog][popover]{position:fixed;inset:0;z-index:1055}[part~=wy-dialog-modal]{align-items:center;justify-content:center;overflow:visible}[part~=wy-dialog-modal][open]{display:flex}[part~=wy-dialog-modal]:popover-open{display:flex}[part~=wy-dialog-modal]:focus-visible{outline:none}[part~=wy-overlay]{--wy-component-background-color: var(--wy-background, var(--wy-background-light, #f7f9ff));--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;overflow:hidden;container-type:inline-size}[part~=wy-overlay]{interpolate-size:allow-keywords;transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) .01s,visibility .01s step-end var(--wy-transition-duration-fast, .1s)}[part~=wy-overlay]:not([part~=wy-open]){opacity:0;visibility:hidden}[part~=wy-overlay][part~=wy-open]{transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),visibility var(--wy-transition-duration, .2s) step-start,top var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),right var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),bottom var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),left var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));visibility:visible;opacity:1;transform:none;pointer-events:auto}@starting-style{[part~=wy-overlay][part~=wy-open]{opacity:0;visibility:hidden}}`, ZY = et`[part~=wy-modal]{width:100%;height:100%;border-radius:0}@container (inline-size >= 768px){[part~=wy-modal-centered]{border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level4, 0 calc(1 * var(--wy-size, 1rem)) calc(2.25 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .14), 0 calc(.375 * var(--wy-size, 1rem)) calc(1.875 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .12), 0 calc(.5 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) calc(-.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));margin-left:calc(4*var(--wy-size, 1rem));margin-top:auto;margin-right:calc(4*var(--wy-size, 1rem));margin-bottom:auto;width:calc(32*var(--wy-size, 1rem));max-height:calc(32*var(--wy-size, 1rem))}}@container (inline-size >= 768px){[part~=wy-modal-centered][part~=wy-maximized]{margin:0;width:100%;height:100%;max-width:calc(100% - 2*var(--wy-size, 1rem));max-height:calc(100% - 2*var(--wy-size, 1rem))}}`, FY = et`[part~=wy-sheet]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));position:fixed;z-index:1055;bottom:calc(.5*var(--wy-size, 1rem));left:calc(.5*var(--wy-size, 1rem));right:calc(.5*var(--wy-size, 1rem));max-height:max(50vh,50%);min-height:calc(3*var(--wy-size, 1rem));margin:calc(.5*var(--wy-size, 1rem)) auto;max-width:calc(32*var(--wy-size, 1rem));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12))}[part~=wy-sheet]:not([part~=wy-open]){transform:translateY(calc(32 * var(--wy-size, 1rem)))}@starting-style{[part~=wy-sheet][part~=wy-open]{transform:translateY(calc(32 * var(--wy-size, 1rem)))}}`, XY = et`[part~=wy-drawer]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));position:fixed;z-index:1055;box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));inset:0;border-radius:0}@container (inline-size >= 768px){[part~=wy-drawer]{top:var(--wy-padding-outer, 0px);right:var(--wy-padding-outer, 0px);bottom:var(--wy-padding-outer, 0px);left:auto;width:calc(24*var(--wy-size, 1rem));min-width:calc(24*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-outer, 0px)}}@container (inline-size >= 768px){[part~=wy-drawer][part~=wy-maximized]{width:calc(100% - 2*var(--wy-padding-outer, 0px))}}[part~=wy-drawer]:not([part~=wy-open]){transform:translate(calc(100% + var(--wy-padding-outer, 0px)))}@starting-style{[part~=wy-drawer][part~=wy-open]{transform:translate(calc(100% + var(--wy-padding-outer, 0px)))}}`, Z4 = et`[part~=wy-header]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));background-color:var(--wy-component-background-color);box-sizing:border-box}@supports (position: sticky){[part~=wy-header]{position:sticky;top:0;z-index:1020}}[part~=wy-header]{z-index:1022}[part~=wy-header-floating]{--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-component-border-radius)}[part~=wy-header-outer]{--wy-component-border-radius: var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));border-radius:var(--wy-component-border-radius)}`, AW = et`[part~=wy-titlebar]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));box-sizing:border-box;display:grid;align-items:center;justify-content:space-between;justify-items:center;min-height:var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));padding:calc(var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));flex:0 0 var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));grid-template-columns:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) minmax(0,max-content) var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));column-gap:calc(2*var(--wy-gap, calc(.5 * var(--wy-size, 1rem))) + var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));line-height:var(--wy-line-height, 1.5);color:var(--wy-component-color)}[part~=wy-titlebar-buttons],[part~=wy-titlebar-section]{display:flex;flex:0 0 auto;align-items:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));max-width:100%;box-shadow:var(--wy-component-box-shadow);border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem))));background-color:var(--wy-component-background-color)}[part~=wy-titlebar-lg]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));height:auto}[part~=wy-titlebar-buttons-first]{justify-content:flex-start}[part~=wy-titlebar-buttons-last]{justify-content:flex-end}[part~=wy-titlebar-text]{max-width:100%;display:block;color:inherit!important;-webkit-user-select:none;user-select:none;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-titlebar-text]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-titlebar-text-trashed]{text-decoration:line-through}`;
var NY = Object.defineProperty, jY = Object.getOwnPropertyDescriptor, ba = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? jY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && NY(t, e, s), s;
}, "__decorateClass$Y"), N$, _f;
let Ks = (N$ = (_f = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.header = !1, this.floating = !1, this.outer = !1, this.trashed = !1, this.size = "md";
  }
  /**
   * render function for the inner titlebar.
   * @internal
   * @returns
   */
  renderTitlebar() {
    return v`
      <nav part="wy-titlebar ${ut({ "wy-titlebar-lg": this.size === "lg" })}">
        <slot name="first">
          <div part="wy-titlebar-icon wy-titlebar-buttons wy-titlebar-buttons-first">
            <slot name="icon"></slot>
          </div>
        </slot>
        <slot name="middle">
          <div part="wy-titlebar-title wy-titlebar-section">
            <slot name="title-section">
              <wy-titlebar-text ?trashed=${this.trashed}><slot name="title"></slot></wy-titlebar-text>
            </slot>
          </div>
        </slot>
        <slot name="last">
          <div part="wy-titlebar-actions wy-titlebar-buttons wy-titlebar-buttons-last">
            <slot name="actions"></slot>
          </div>
        </slot>
      </nav>
    `;
  }
  render() {
    return this.header ? v`<header part="wy-header ${ut({ "wy-header-floating": this.floating, "wy-header-outer": this.outer })}"
          >${this.renderTitlebar()}</header
        >` : this.renderTitlebar();
  }
}, c(_f, "to"), _f), d(N$, "WyTitlebar"), N$);
Ks.styles = [Z4, AW, ft];
ba([
  O({ type: Boolean })
], Ks.prototype, "header", 2);
ba([
  O({ type: Boolean })
], Ks.prototype, "floating", 2);
ba([
  O({ type: Boolean })
], Ks.prototype, "outer", 2);
ba([
  O({ type: Boolean })
], Ks.prototype, "trashed", 2);
ba([
  O()
], Ks.prototype, "size", 2);
Ks = ba([
  U("wy-titlebar")
], Ks);
var j$, zf;
let Kw = (j$ = (zf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.trashed = !1;
  }
  render() {
    const t = {
      "wy-titlebar-text-trashed": this.trashed
    };
    return v` <slot part="wy-titlebar-text ${ut(t)}"></slot> `;
  }
}, c(zf, "eo"), zf), d(j$, "WyTitlebarText"), j$);
Kw.styles = [AW, ft];
ba([
  O({ type: Boolean })
], Kw.prototype, "trashed", 2);
Kw = ba([
  U("wy-titlebar-text")
], Kw);
var BY = Object.defineProperty, UY = Object.getOwnPropertyDescriptor, M1 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? UY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && BY(t, e, s), s;
}, "__decorateClass$X"), B$, Lf;
let ha = (B$ = (Lf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.viewportRef = wt(), this.show = !0, this.type = "modal", this.maximized = !1, this.noHeader = !1, this.handleClose = (t) => {
      if (this.isModal() || t?.type === "toggle" && t.newState === "closed" || t?.type === "close") {
        this.show = !1;
        const e = new CustomEvent("close");
        this.dispatchEvent(e);
      }
    };
  }
  /**
   * Close the modal.
   */
  close() {
    this.show = !1;
    try {
      this.type !== "modal" && this.viewportRef.value?.popover ? this.viewportRef.value?.hidePopover() : this.viewportRef.value?.close();
    } catch {
    }
  }
  /**
   * Checks whether the overlay is using the modal api.
   *
   * @param [type] - Optional type to check
   * @returns Whether the overlay is using the modal api.
   */
  isModal(t) {
    return t ??= this.type, t === "modal" || t === "full";
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("type") && this.viewportRef.value) {
      const e = !this.isModal(t.get("type")) && this.viewportRef.value.popover ? "toggle" : "close";
      this.viewportRef.value.removeEventListener(e, this.handleClose);
    }
  }
  render() {
    if (this.type === "none")
      return C;
    const t = {
      "wy-dialog": !0,
      "wy-dialog-modal": this.isModal()
    }, e = {
      "wy-overlay": !0,
      "wy-modal": this.isModal(),
      // modal, full
      "wy-modal-centered": this.type === "modal",
      "wy-sheet": this.type === "sheet",
      "wy-drawer": this.type === "drawer",
      "wy-maximized": this.maximized,
      "wy-open": this.show
    }, i = this.isModal() ? void 0 : "auto";
    return v`
      <dialog
        part=${ut(t)}
        tabindex="0"
        popover=${Ot(i)}
        ${ot(this.viewportRef)}
      >
        <div part=${ut(e)}>
          ${this.noHeader ? C : v`
                <slot name="header">
                  <wy-titlebar part="wy-overlay-titlebar" header>
                    <wy-button slot="icon" kind="icon" @click=${() => this.close()}>
                      <wy-icon name="close"></wy-icon>
                    </wy-button>
                    <slot slot="title" name="title"></slot>
                    <slot slot="actions" name="actions"></slot>
                  </wy-titlebar>
                </slot>
              `}
          <slot></slot>
        </div>
      </dialog>
    `;
  }
  updated(t) {
    if (t.has("type")) {
      const e = !this.isModal() && this.viewportRef.value?.popover ? "toggle" : "close";
      this.viewportRef.value?.addEventListener(e, this.handleClose), this.show && (!this.isModal(t.get("type")) && this.viewportRef.value?.popover ? this.viewportRef.value?.hidePopover() : this.viewportRef.value?.close(), this.requestUpdate("show"));
    }
    if (t.has("show"))
      try {
        this.show ? this.isModal() ? this.viewportRef.value?.showModal() : this.viewportRef.value?.popover ? this.viewportRef.value?.showPopover() : this.viewportRef.value?.show() : !this.isModal() && this.viewportRef.value?.popover ? this.viewportRef.value?.hidePopover() : this.viewportRef.value?.close();
      } catch {
      }
    t.has("show") && this.show && this.viewportRef.value?.focus();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.close();
  }
}, c(Lf, "io"), Lf), d(B$, "WyOverlay"), B$);
ha.styles = [Te, ft, qY, ZY, FY, XY];
M1([
  O({ type: Boolean, reflect: !0 })
], ha.prototype, "show", 2);
M1([
  O({ type: String })
], ha.prototype, "type", 2);
M1([
  O({ type: Boolean })
], ha.prototype, "maximized", 2);
M1([
  O({ type: Boolean })
], ha.prototype, "noHeader", 2);
ha = M1([
  U("wy-overlay")
], ha);
const HY = et`[part~=wy-container]{display:flex;flex-direction:column;position:relative;min-height:0;height:100%;flex:1 1 auto}[part~=wy-container-padded]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));gap:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-container-outer]{padding:var(--wy-padding-outer, var(--wy-padding, 0))}`, Vl = et`[part~=wy-scroll-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x-y]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;overflow-x:auto;touch-action:pan-y,pan-x}[part~=wy-scroll-x-always],[part~=wy-scroll-y-always]{overflow-y:scroll}`;
var YY = Object.defineProperty, GY = Object.getOwnPropertyDescriptor, _m = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? GY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && YY(t, e, s), s;
}, "__decorateClass$W"), U$, If;
let Js = (U$ = (If = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.scrollX = !1, this.scrollY = !1, this.padded = !1, this.outer = !1, this.scrollbars = !1;
  }
  render() {
    const t = {
      "wy-container": !0,
      "wy-container-padded": this.padded,
      "wy-container-outer": this.outer,
      "wy-scroll-x": this.scrollX && !this.scrollY,
      "wy-scroll-y": this.scrollY && !this.scrollX,
      "wy-scroll-x-y": this.scrollX && this.scrollY,
      "wy-scroll-x-always": this.scrollbars && this.scrollX,
      "wy-scroll-y-always": this.scrollbars && this.scrollY
    };
    return v`
      <div part=${ut(t)}>
        <slot></slot>
      </div>
    `;
  }
}, c(If, "ro"), If), d(U$, "WyContainer"), U$);
Js.styles = [Vl, ft, HY];
_m([
  O({ type: Boolean })
], Js.prototype, "scrollX", 2);
_m([
  O({ type: Boolean })
], Js.prototype, "scrollY", 2);
_m([
  O({ type: Boolean })
], Js.prototype, "padded", 2);
_m([
  O({ type: Boolean })
], Js.prototype, "outer", 2);
_m([
  O({ type: Boolean })
], Js.prototype, "scrollbars", 2);
Js = _m([
  U("wy-container")
], Js);
var KY = Object.defineProperty, JY = Object.getOwnPropertyDescriptor, zm = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? JY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && KY(t, e, s), s;
}, "__decorateClass$V"), H$, Wf;
let Jw = (H$ = (Wf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.pollOptions = [];
  }
  /**
   * Dispatch a `vote` event for the specified option.
   *
   * @param optionId - Identifier of the option to vote for.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  render() {
    const t = this.pollOptions.reduce((e, i) => e + (i.votes?.count || 0), 0);
    return v`
      <div part="wy-poll">
        ${this.pollOptions.map(
      (e) => v`<wy-poll-option
              @vote=${(i) => this.dispatchVote(i.detail.optionId)}
              .option=${e}
              .totalVotes=${t}
            ></wy-poll-option>`
    )}
      </div>
    `;
  }
}, c(Wf, "so"), Wf), d(H$, "WyPoll"), H$);
Jw.styles = [
  q4,
  ft
];
zm([
  O({ type: Array, attribute: !1 })
], Jw.prototype, "pollOptions", 2);
Jw = zm([
  U("wy-poll")
], Jw);
var Y$, Vf;
let ul = (Y$ = (Vf = class extends zi {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.totalVotes = 0, this.showSheet = !1, this.getVotesQuery = new gn(this);
  }
  async updated(t) {
    t.has("weavy") && this.weavy && this.option && this.option.id && await this.getVotesQuery.trackQuery(SI(this.weavy, this.option.id));
  }
  /**
   * Dispatch a `vote` event for the provided option id.
   *
   * @internal
   * @param optionId - Identifier of the option to vote for.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    if (!t)
      return;
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Toggle the voter sheet and refresh vote data.
   *
   * @internal
   * @param e - Triggering user event.
   */
  openSheet(t) {
    t.preventDefault(), t.stopPropagation(), this.getVotesQuery.observer?.refetch(), this.showSheet = !this.showSheet;
  }
  render() {
    if (!this.option || !this.option.id)
      return C;
    const { data: t, isLoading: e } = this.getVotesQuery.result ?? {}, i = this.totalVotes > 0 ? Math.round((this.option.votes?.count || 0) / this.totalVotes * 100) : 0;
    return v`
      <div
        part="wy-poll-option"
        tabindex="0"
        @click=${() => this.dispatchVote(this.option?.id)}
        @keydown=${Le}
        @keyup=${di}
      >
        <div part="wy-poll-meter" style="width: ${i + "%"}"></div>
        <div part="wy-poll-image">
          ${this.option.has_voted ? v`<wy-icon name="check-circle"></wy-icon>` : v`<wy-icon name="circle-outline"></wy-icon>`}
        </div>
        <div part="wy-poll-title">${this.option.text}</div>
        ${i > 0 ? v`<span
              part="wy-poll-amount"
              tabindex="0"
              @click=${(s) => this.openSheet(s)}
              @keydown=${Le}
              @keyup=${di}
            >
              ${i + "%"}
            </span>` : v`<span part="wy-poll-amount"></span>`}
      </div>

      ${this.weavy ? v`
            <wy-overlay type="sheet" .show=${this.showSheet} @close=${() => this.showSheet = !1}>
              <span slot="title">${P(st`Votes on ${this.option.text}`)}</span>
              <wy-container scrollY padded>
                ${this.showSheet && t && !e ? v`
                      ${t.votes?.data ? t.votes.data.map(
      (s) => v`
                              <wy-item>
                                <wy-avatar
                                  slot="image"
                                  .size=${32}
                                  .src=${s.avatar_url}
                                  .name=${s.name}
                                ></wy-avatar>
                                <span slot="title">${s.name}</span>
                              </wy-item>
                            `
    ) : C}
                    ` : C}
              </wy-container>
            </wy-overlay>
          ` : C}
    `;
  }
}, c(Vf, "no"), Vf), d(Y$, "WyPollOption"), Y$);
ul.styles = [q4, ft];
zm([
  O({ type: Number, attribute: !1 })
], ul.prototype, "totalVotes", 2);
zm([
  O({ attribute: !1 })
], ul.prototype, "option", 2);
zm([
  F()
], ul.prototype, "showSheet", 2);
ul = zm([
  U("wy-poll-option"),
  St()
], ul);
function RW(n, t, e, i, s, r, a) {
  return new Xt(n.queryClient, {
    mutationFn: /* @__PURE__ */ d(async () => await n.fetch(`/api/${s}/${i}/reactions`, {
      method: r ? "POST" : "DELETE",
      body: JSON.stringify({ content: r })
    }), "mutationFn"),
    onMutate: /* @__PURE__ */ d(() => {
      const o = e === "apps" && s === "posts" ? [s, t] : [e, t, s];
      ge(n.queryClient, o, i, (l) => {
        ym(l, r, a);
      });
    }, "onMutate")
  });
}
c(RW, "Ex");
d(RW, "reactionMutation");
function EW(n, t, e) {
  return {
    queryKey: [t, e, "reactions"],
    enabled: !1,
    queryFn: /* @__PURE__ */ d(async () => await (await n.fetch("/api/" + t + "/" + e + "/reactions")).json(), "queryFn")
  };
}
c(EW, "Lx");
d(EW, "getReactionListOptions");
function ym(n, t, e) {
  return !t && !n.reactions?.data || (n.reactions || (n.reactions = { count: 0, data: [] }), n.reactions.data || (n.reactions.data = []), t ? n.reactions.data = [
    ...n.reactions.data.filter((i) => i.created_by?.id !== e.id),
    { content: t, created_by: e }
  ] : n.reactions.data && (n.reactions.data = [...n.reactions.data.filter((i) => i.created_by?.id !== e.id)])), n;
}
c(ym, "Sl");
d(ym, "updateReaction");
const tG = et`[part~=wy-reaction]{font-size:calc(1.125*var(--wy-size, 1rem))}[part~=wy-reactions]{display:inline-flex;align-items:center;column-gap:calc(.25*var(--wy-size, 1rem))}[part~=wy-reactions] :first-child:not(:only-child){margin-left:calc(.25*var(--wy-size, 1rem))}[part~=wy-reactions] :last-child:not(:only-child){margin-right:calc(.25*var(--wy-size, 1rem))}[part~=wy-reaction-count]{margin:0 calc(.25*var(--wy-size, 1rem)) 0;line-height:1;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-reaction-menu]{width:max-content;position:absolute;z-index:1000;border:none;--wy-component-background-color: var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;margin:0;text-align:left;background-clip:padding-box;box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));overflow:hidden;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));font-size:calc(1.25*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))))}[part~=wy-reaction-picker]{display:flex;flex-direction:row;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-reactions-line]{display:flex;align-items:center;gap:calc(.1875*var(--wy-size, 1rem));justify-content:end}[part~=wy-reactions-line-reverse]{flex-direction:row-reverse;justify-content:start}[part~=wy-reactions-line-bottom]{position:absolute;bottom:calc(-1*var(--wy-size, 1rem));right:calc(.25*var(--wy-size, 1rem));z-index:1}[part~=wy-reactions-line-below]{position:relative;height:0;min-height:0;max-height:0;margin:calc(var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) - var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(-1*var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))) calc(-1*var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));padding-left:calc(.1875*var(--wy-size, 1rem));padding-right:calc(.1875*var(--wy-size, 1rem));gap:calc(.125*var(--wy-size, 1rem));flex:1 0 auto;justify-content:flex-end}`, _W = et`[part~=wy-emoji-icon]{display:inline-flex;justify-content:center;align-items:center;line-height:1;width:1em;height:1em;font-size:calc(1.25*var(--wy-size, 1rem))}[part~=wy-emoji-icon-sm]{width:calc(1.125*var(--wy-size, 1rem));height:calc(1.125*var(--wy-size, 1rem));font-size:calc(1.125*var(--wy-size, 1rem))}`;
var eG = Object.defineProperty, iG = Object.getOwnPropertyDescriptor, Re = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? iG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && eG(t, e, s), s;
}, "__decorateClass$U"), G$, Df;
let ve = (G$ = (Df = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.directionX = "left", this.directionY = "up", this.small = !1, this.reactions = [], this.emojis = "", this.parentType = "apps", this.entityType = "messages", this.line = !1, this.lineReverse = !1, this.lineBottom = !1, this.lineBelow = !1, this._placement = "bottom-start", this.show = !1, this.showSheet = !1, this.buttonRef = wt(), this.menuRef = wt(), this.reactionListQuery = new gn(this), this._documentClickHandler = (t) => {
      this.show && (t.preventDefault(), this.menuRef.value?.popover || (this.show = !1));
    }, this.handleReaction = async (t) => {
      if (!this.weavy || !this.parentId || !this.user)
        return;
      const e = RW(
        this.weavy,
        this.parentId,
        this.parentType,
        this.entityId,
        this.entityType,
        this.reactedEmoji === t ? void 0 : t,
        this.user
      );
      this.reactedEmoji = t, await e.mutate(), this.reactionListQuery.observer?.refetch();
    };
  }
  /**
   * Closes the picker when the popover hides.
   *
   * @internal
   */
  handleClose(t) {
    if (t.type === "toggle" && t.newState === "closed" || t.type === "click") {
      this.show = !1;
      const e = new CustomEvent("close");
      this.dispatchEvent(e);
    }
  }
  /**
   * Toggles the emoji picker visibility.
   *
   * @internal
   */
  handleClickToggle(t) {
    t.stopPropagation(), this.show = !this.show;
  }
  /**
   * Opens the detailed reaction sheet view.
   *
   * @internal
   */
  handleReactionsClick() {
    this.reactionListQuery.observer?.refetch(), this.showSheet = !this.showSheet, this.show = !1;
  }
  async willUpdate(t) {
    if (super.willUpdate(t), (t.has("weavy") || t.has("entityId") || t.has("showSheet")) && this.weavy && this.entityId && this.showSheet && await this.reactionListQuery.trackQuery(EW(this.weavy, this.entityType, this.entityId)), (t.has("reactions") || t.has("user")) && this.user && (this.reactedEmoji = this.reactions?.find((e) => e.created_by?.id === this.user?.id)?.content), (t.has("directionX") || t.has("directionY")) && (this._placement = this.directionX === "right" && this.directionY === "down" ? "bottom-start" : this.directionX === "left" && this.directionY === "down" ? "bottom-end" : this.directionX === "right" && this.directionY === "up" ? "top-start" : "top-end"), t.has("show") && (this.show && !this._computePositionCleanup && this.buttonRef.value && this.menuRef.value ? this._computePositionCleanup = E4(this.buttonRef.value, this.menuRef.value, () => {
      requestAnimationFrame(() => {
        this.buttonRef.value && this.menuRef.value && CW(this.buttonRef.value, this.menuRef.value, {
          placement: this._placement,
          strategy: this.menuRef.value.popover ? "absolute" : "fixed",
          middleware: [
            SW(),
            xW({ mainAxis: 0, alignmentAxis: -8 }),
            kW({ mainAxis: !0, crossAxis: !0, padding: 4, altBoundary: !0 })
          ]
        }).then(({ x: e, y: i }) => {
          this.menuRef.value && Object.assign(this.menuRef.value.style, {
            marginLeft: `${e}px`,
            marginTop: `${i}px`,
            top: 0,
            left: 0,
            position: this.menuRef.value.popover ? void 0 : "fixed",
            zIndex: this.menuRef.value.popover ? void 0 : 1075
          });
        });
      });
    }) : !this.show && this._computePositionCleanup && (this._computePositionCleanup(), this._computePositionCleanup = void 0)), this.show) {
      requestAnimationFrame(() => {
        document.addEventListener("click", this._documentClickHandler, { once: !0, capture: !0 });
      });
      try {
        this.menuRef.value?.showPopover();
      } catch {
      }
    } else
      try {
        this.menuRef.value?.hidePopover();
      } catch {
      }
    t.has("settings") && this.settings?.reactions && this.emojis != this.settings.reactions && (this.emojis = this.settings.reactions);
  }
  render() {
    const { data: t, isPending: e } = this.reactionListQuery.result ?? {};
    if (!this.emojis?.length)
      return C;
    const i = this.emojis?.length === 1 ? this.emojis[0] : "", s = [
      ...new Map(this.reactions?.map((h) => [h.content, h])).values()
    ], r = {
      "wy-emoji-icon": !0,
      "wy-emoji-icon-sm": this.small
    }, a = i ? v`
          ${this.reactions && this.reactions?.length > 1 ? v`<wy-button
                kind="icon-inline"
                ?active=${this.showSheet}
                ?small=${this.small}
                @click=${() => this.handleReactionsClick()}
              >
                <div part="wy-reactions">
                  <span part=${ut(r)}>
                    <small part="wy-reaction-count">${this.reactions.length}</small>
                  </span>
                </div>
              </wy-button>` : C}

          <div>
            <wy-button
              part="wy-reaction-menu-button"
              color="inherit"
              kind="icon"
              ?small=${this.small}
              ?active=${this.reactedEmoji === i}
              @click=${() => {
      this.handleReaction(i);
    }}
              @keydown=${Le}
              @keyup=${di}
              title=${P("React", { desc: "Button action to react" })}
            >
              <span part=${ut(r)} title=${i}>${i}</span>
            </wy-button>
          </div>
        ` : v`
          ${s.length ? v`
                <wy-button
                  kind="icon-inline"
                  ?active=${this.showSheet}
                  ?small=${this.small}
                  @click=${() => this.handleReactionsClick()}
                >
                  <div part="wy-reactions">
                    ${s.map((h) => v`<span part=${ut(r)} title="">${h.content}</span>`)}
                    ${this.reactions && this.reactions?.length > 1 ? v`<small part="wy-reaction-count">${this.reactions.length}</small>` : C}
                  </div>
                </wy-button>
              ` : C}

          <div ${ot(this.buttonRef)}>
            <wy-button
              part="wy-reaction-menu-button"
              color="inherit"
              kind="icon"
              ?active=${this.show}
              ?small=${this.small}
              @click=${(h) => this.handleClickToggle(h)}
              @keydown=${Le}
              @keyup=${di}
              title=${P("React", { desc: "Button action to react" })}
            >
              <wy-icon name="emoticon" size=${this.small ? 20 : 24}></wy-icon>
            </wy-button>
          </div>

          <div
            ${ot(this.menuRef)}
            part="wy-reaction-menu"
            @click=${(h) => this.handleClickToggle(h)}
            @keyup=${C0}
            ?hidden=${!this.show}
            popover=${Ot(aO() ? void 0 : "auto")}
          >
            <div part="wy-reaction-picker">
              ${this.emojis.split(" ").map(
      (h) => v`
                    <wy-button
                      kind="icon"
                      color="none"
                      ?active=${this.reactedEmoji === h}
                      @click=${() => {
        this.handleReaction(h);
      }}
                    >
                      <span part="wy-emoji-icon">${h}</span>
                    </wy-button>
                  `
    )}
            </div>
          </div>
        `, o = v`
      ${this.weavy && this.showSheet ? v`
            <wy-overlay type="sheet" .show=${this.showSheet} @close=${() => this.showSheet = !1}>
              <span slot="title">${P("Reactions")}</span>
              <wy-container scrollY padded>
                ${this.showSheet && t && !e ? v`
                      ${t.data?.map(
      (h) => v` <wy-reaction-item .reaction=${h}></wy-reaction-item> `
    )}
                    ` : C}
              </wy-container>
            </wy-overlay>
          ` : C}
    `, l = {
      "wy-reactions-line": !0,
      "wy-reactions-line-reverse": this.lineReverse,
      "wy-reactions-line-bottom": this.lineBottom,
      "wy-reactions-line-below": this.lineBelow
    };
    return this.line || this.lineReverse || this.lineBottom || this.lineBelow ? v`
          <div part=${ut(l)}>${a}</div>
          ${o}
        ` : [a, o];
  }
  firstUpdated(t) {
    this.menuRef.value?.addEventListener(
      this.menuRef.value.popover ? "toggle" : "click",
      (e) => this.handleClose(e)
    );
  }
  disconnectedCallback() {
    this._computePositionCleanup?.(), super.disconnectedCallback();
  }
}, c(Df, "ao"), Df), d(G$, "WyReactions"), G$);
ve.styles = [ne, tG, _W, ft];
Re([
  O()
], ve.prototype, "directionX", 2);
Re([
  O()
], ve.prototype, "directionY", 2);
Re([
  O({ type: Boolean })
], ve.prototype, "small", 2);
Re([
  O({ attribute: !1 })
], ve.prototype, "reactions", 2);
Re([
  O({ attribute: !1 })
], ve.prototype, "emojis", 2);
Re([
  O({ type: String })
], ve.prototype, "parentType", 2);
Re([
  O({ attribute: !0, type: Number })
], ve.prototype, "parentId", 2);
Re([
  O({ attribute: !0, type: String })
], ve.prototype, "entityType", 2);
Re([
  O({ attribute: !0, type: Number })
], ve.prototype, "entityId", 2);
Re([
  O({ type: Boolean })
], ve.prototype, "line", 2);
Re([
  O({ type: Boolean })
], ve.prototype, "lineReverse", 2);
Re([
  O({ type: Boolean })
], ve.prototype, "lineBottom", 2);
Re([
  O({ type: Boolean })
], ve.prototype, "lineBelow", 2);
Re([
  F()
], ve.prototype, "_placement", 2);
Re([
  F()
], ve.prototype, "reactedEmoji", 2);
Re([
  F()
], ve.prototype, "show", 2);
Re([
  F()
], ve.prototype, "showSheet", 2);
ve = Re([
  U("wy-reactions"),
  St()
], ve);
var K$, qf;
let t1 = (K$ = (qf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this);
  }
  render() {
    return v`
      <wy-item>
        <wy-avatar
          slot="image"
          .src=${this.reaction.created_by?.avatar_url}
          .name=${this.reaction.created_by?.name}
        ></wy-avatar>
        <span slot="title">${this.reaction.created_by?.name}</span>
        <span slot="actions" part="wy-emoji-icon">${this.reaction.content}</span>
      </wy-item>
    `;
  }
}, c(qf, "oo"), qf), d(K$, "WyReactionItem"), K$);
t1.styles = [ne, _W];
Re([
  O({ attribute: !1 })
], t1.prototype, "reaction", 2);
t1 = Re([
  U("wy-reaction-item")
], t1);
const nG = et`[part~=wy-preview]{--wy-component-background-color: var(--wy-background, var(--wy-background-light, #f7f9ff));--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;box-sizing:border-box;align-items:stretch;justify-content:stretch;position:relative;flex:1 1 100%;min-width:calc(16*var(--wy-size, 1rem));min-height:calc(16*var(--wy-size, 1rem));max-height:100%;max-width:100%}[part~=wy-preview-layout]{width:100%;height:100%}[part~=wy-preview-main]{display:flex;height:calc(100% - var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem))))));min-height:0}@container (inline-size < 768px){[part~=wy-preview-main]{flex-direction:column}}[part~=wy-preview-swiper]{display:flex;flex-direction:row;flex:1 1 100%;align-items:center;justify-content:start;min-width:calc(16*var(--wy-size, 1rem));min-height:calc(16*var(--wy-size, 1rem));max-height:100%;max-width:100%;overflow-x:scroll;scroll-snap-type:x mandatory;scroll-behavior:auto;overscroll-behavior-x:none;scrollbar-width:none}[part~=wy-preview-swiper]::-webkit-scrollbar{display:none}[part~=wy-preview-swiper-disabled]{overflow-x:hidden}[part~=wy-preview-area]{position:relative;min-width:100%;min-height:100%;width:100%;height:100%;flex:1 1 auto;display:flex;flex-direction:column;scroll-snap-stop:always;scroll-snap-align:center}[part~=wy-nav-prev],[part~=wy-nav-next]{--wy-component-background-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));background-color:var(--wy-component-background-color);position:absolute;top:50%;z-index:1000;border-radius:50%}[part~=wy-nav-prev]{left:calc(.5*var(--wy-size, 1rem))}[part~=wy-nav-next]{right:calc(.5*var(--wy-size, 1rem))}`, sG = et`[part~=wy-sidebar]{--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background:var(--wy-component-background-color);color:var(--wy-component-color);min-width:0;min-height:0;flex-grow:0;flex-shrink:0;flex-basis:calc(22*var(--wy-size, 1rem));z-index:10;display:flex;flex-direction:column;transition:flex-basis var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));position:relative;order:9999;overflow:clip}[part~=wy-sidebar]>*{transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) - var(--wy-transition-duration-fast, .1s));min-width:calc(22*var(--wy-size, 1rem))}[part~=wy-sidebar][hidden]{display:flex!important;flex-basis:0}[part~=wy-sidebar][hidden]>*{transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));opacity:0}@container (inline-size >= 768px){[part~=wy-sidebar]>*{min-width:calc(22*var(--wy-size, 1rem))}[part~=wy-sidebar] [part~=wy-sidebar-handle]{display:none}}@container (inline-size < 768px){[part~=wy-sidebar]{transition:flex-basis var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),margin-top var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));border-top-left-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-top-right-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));flex-basis:50vh}[part~=wy-sidebar]:not([hidden]){margin-top:calc(-1*var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-sidebar]:not([hidden])[part~=wy-maximized]{flex-basis:calc(100% - var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))*.5);margin-top:calc(-50% + var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))*2.5 - var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-sidebar]:not([hidden])[part~=wy-maximized]~* [part~=wy-nav-prev],[part~=wy-sidebar]:not([hidden])[part~=wy-maximized]~* [part~=wy-nav-next]{display:none}[part~=wy-sidebar]>*{min-height:var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))}}[part~=wy-sidebar-handle]{width:calc(4*var(--wy-size, 1rem));background-clip:content-box;background-color:var(--wy-on-surface-variant, var(--wy-on-surface-variant-light, #42474e));height:calc(1*var(--wy-size, 1rem));border:calc(.375*var(--wy-size, 1rem)) solid rgba(0,0,0,0);position:absolute;top:0;z-index:2;left:50%;margin-left:calc(-2*var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));cursor:pointer}`;
var rG = Object.defineProperty, aG = Object.getOwnPropertyDescriptor, I0 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? aG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && rG(t, e, s), s;
}, "__decorateClass$T"), J$, Zf;
let pl = (J$ = (Zf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this);
  }
  /**
   * Dispatch `file-preview-loaded` when the fallback content is ready.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  render() {
    const t = this.icon, e = Tm(this.provider);
    return v`
      <wy-icon-display fill>
        <wy-icon name=${t} .overlayName=${e}></wy-icon>
        <span slot="text">
          ${this.provider ? v`
                <p>${P("No preview available :(")} </p>
                <wy-button kind="filled" color="variant" href=${this.src} target="_blank">${P(st`Open in ${this.provider}`)}</wy-button>
              ` : v`<div>${P("No preview available :(")}</div>`}
        </span>
      </wy-icon-display>
    `;
  }
  updated(t) {
    (t.has("icon") || t.has("src")) && (this.icon || this.src) && this.dispatchLoaded();
  }
}, c(Zf, "co"), Zf), d(J$, "WyPreviewIcon"), J$);
pl.styles = [
  ft
];
I0([
  O()
], pl.prototype, "src", 2);
I0([
  O()
], pl.prototype, "icon", 2);
I0([
  O()
], pl.prototype, "provider", 2);
pl = I0([
  U("wy-preview-icon"),
  St()
], pl);
const oG = et`[part~=wy-content-image]{min-width:0;display:flex;align-items:center;justify-content:center;position:relative;margin:auto;box-sizing:border-box;max-height:100%;max-width:100%;transition:transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform-origin var(--wy-transition-duration, .2s) step-end}[part~=wy-content-image][part~=wy-zoom]{cursor:zoom-out;transition:transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform-origin var(--wy-transition-duration, .2s) step-start}[part~=wy-content-image-img]{min-width:0;min-height:0;width:100%;height:100%}[part~=wy-content-image-img][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-content-image-img][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-content-image-img][part~=wy-loading][part~=wy-loaded]~[part~=wy-content-progress]{display:none}[part~=wy-content-image-img]~[part~=wy-content-progress]{position:absolute}`;
var lG = Object.defineProperty, cG = Object.getOwnPropertyDescriptor, W0 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? cG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && lG(t, e, s), s;
}, "__decorateClass$S"), tx, Ff;
let fl = (tx = (Ff = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this);
  }
  /**
   * Dispatches the `file-preview-loaded` event once the image has loaded.
   *
   * @internal
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  render() {
    const t = !!(this.width && this.height), e = t ? { "--width": this.width, "--height": this.height } : {};
    return v`
      <div part="wy-content-image ${ut({ "wy-intrinsic-image": !t })}" style=${Zw(e)}>
        <img
          part="wy-content-image-img"
          src=${this.src}
          ${ot(E0)}
          @load=${(i) => {
      _0(i), this.dispatchLoaded();
    }}
          width=${Ot(this.width)}
          height=${Ot(this.height)}
          decoding="async"
          alt=${P("Preview")}
        />
        ${t ? v`<wy-progress-circular part="wy-content-progress" indeterminate overlay></wy-progress-circular>` : C}
      </div>
    `;
  }
}, c(Ff, "lo"), Ff), d(tx, "WyPreviewImage"), tx);
fl.styles = [oG, ft];
W0([
  O()
], fl.prototype, "src", 2);
W0([
  O({ type: Number })
], fl.prototype, "width", 2);
W0([
  O({ type: Number })
], fl.prototype, "height", 2);
fl = W0([
  U("wy-preview-image"),
  St()
], fl);
function F4(n) {
  (n.classList.contains("wy-loading") || n.part.contains("wy-loading")) && (n.classList.add("wy-loaded"), n.part.add("wy-loaded")), n.classList.add("wy-error"), n.part.add("wy-error"), n.outerHTML = n.outerHTML.replace(/<(video|audio)/, "<div").replace(/(video|audio)>/, "div>");
}
c(F4, "bv");
d(F4, "mediaFallback");
function zW(n) {
  const t = n.target;
  (t.tagName === "VIDEO" || t.tagName === "AUDIO") && (t.classList.contains("wy-loading") || t.part.contains("wy-loading")) && (t.classList.add("wy-loaded"), t.part.add("wy-loaded"));
}
c(zW, "Nx");
d(zW, "mediaLoaded");
function OS(n) {
  const t = n.target;
  if (t.tagName === "SOURCE" && t.parentNode) {
    const e = t.parentNode, i = parseInt(e.dataset.errors || "0") + 1;
    e.dataset.errors = i.toString(), e.querySelectorAll("source").length >= i && (console.warn(e.tagName.toLowerCase() + " source error, switching to fallback"), F4(e));
  }
}
c(OS, "uf");
d(OS, "mediaError");
function bS(n) {
  const t = n.target;
  (t.tagName === "VIDEO" || t.tagName === "AUDIO") && (t.tagName === "VIDEO" && !t.videoWidth || t.tagName === "AUDIO" && !t.duration) && (console.warn(t.tagName.toLowerCase() + " track not available, switching to fallback"), F4(t));
}
c(bS, "yf");
d(bS, "codecError");
const hG = et`[part~=wy-content-video]{box-sizing:border-box}[part~=wy-content-video]:not([part~=wy-error]){min-height:0;max-width:100%;max-height:100%;flex:1 1 auto}[part~=wy-content-video],[part~=wy-content-audio]{margin:auto}[part~=wy-content-video][part~=wy-loading]:not([part~=wy-loaded]),[part~=wy-content-audio][part~=wy-loading]:not([part~=wy-loaded]){visibility:hidden}[part~=wy-content-video][part~=wy-loading][part~=wy-loaded]~[part~=wy-content-progress],[part~=wy-content-audio][part~=wy-loading][part~=wy-loaded]~[part~=wy-content-progress]{display:none}[part~=wy-content-video]:focus,[part~=wy-content-audio]:focus{outline:none}`;
var dG = Object.defineProperty, uG = Object.getOwnPropertyDescriptor, Lm = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? uG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && dG(t, e, s), s;
}, "__decorateClass$R"), ex, Xf;
let tr = (ex = (Xf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.format = "", this.play = !1, this.name = "", this.handleLoaded = (t) => {
      zW(t), this.dispatchLoaded();
    };
  }
  /**
   * Dispatches the `file-preview-loaded` event after the media metadata becomes available.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  /**
   * Registers load and error listeners on the provided media element.
   *
   * @internal
   * @param mediaElement - Media element to observe.
   */
  registerLoading(t) {
    this.unregisterLoading(), t && (this.mediaElement = t, t.part.add("wy-loading"), t.addEventListener("error", OS, !0), t.addEventListener("loadedmetadata", this.handleLoaded, !0), t.addEventListener("loadedmetadata", bS, !0));
  }
  /**
   * Cleans up listeners and state from the previously registered media element.
   *
   * @internal
   */
  unregisterLoading() {
    this.mediaElement && (this.mediaElement.pause(), this.mediaElement.removeAttribute("autoplay"), this.mediaElement.setAttribute("preload", "none"), this.mediaElement.removeEventListener("error", OS, !0), this.mediaElement.removeEventListener("loadedmetadata", this.handleLoaded, !0), this.mediaElement.removeEventListener("loadedmetadata", bS, !0), this.mediaElement = void 0);
  }
  render() {
    return this.format === "video" ? v`
          <video ${ot((t) => this.registerLoading(t))} part="wy-content-video" controls crossorigin="use-credentials">
            <source src=${this.src} type=${Ot(this.mediaType)} />
            <wy-preview-icon src=${this.src} icon="file-video"></wy-preview-icon>
          </video>
          <wy-progress-circular part="wy-content-progress" indeterminate overlay></wy-progress-circular>
        ` : v`
          <audio ${ot((t) => this.registerLoading(t))} part="wy-content-audio" controls crossorigin="use-credentials">
            <source src=${this.src} type=${Ot(this.mediaType)} />
          </audio>
        `;
  }
  updated(t) {
    super.updated(t), t.has("play") && this.mediaElement && (this.play ? this.mediaElement.play() : this.mediaElement.pause());
  }
  disconnectedCallback() {
    this.unregisterLoading(), super.disconnectedCallback();
  }
}, c(Xf, "ho"), Xf), d(ex, "WyPreviewMedia"), ex);
tr.styles = [
  hG,
  ft
];
Lm([
  O()
], tr.prototype, "format", 2);
Lm([
  O()
], tr.prototype, "src", 2);
Lm([
  O({ type: Boolean })
], tr.prototype, "play", 2);
Lm([
  O()
], tr.prototype, "name", 2);
Lm([
  O()
], tr.prototype, "mediaType", 2);
tr = Lm([
  U("wy-preview-media")
], tr);
const pG = et`[part~=wy-content-code]{align-self:flex-start;box-sizing:border-box;width:100%;padding:calc(2*var(--wy-size, 1rem)) calc(3.5*var(--wy-size, 1rem));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}`, fG = et`[part~=wy-content-text],[part~=wy-content-html] pre,[part~=wy-content-html] code{word-break:break-word;white-space:pre-wrap}[part~=wy-content-html] hr{border-color:var(--wy-outline, var(--wy-outline-light, #72777f));border-width:var(--wy-border, 1px) 0 0 0;border-style:solid}[part~=wy-content-html] h1,[part~=wy-content-html] h2,[part~=wy-content-html] h3,[part~=wy-content-html] h4,[part~=wy-content-html] h5,[part~=wy-content-html] h6{font-family:var(--wy-document-headings-font-family, var(--wy-headings-font-family, var(--wy-font-family, unset)));line-height:var(--wy-document-headings-line-height, var(--wy-headings-line-height, var(--wy-line-height, 1.5)))}[part~=wy-content-html] h1{font-size:var(--wy-document-h1-font-size, calc(2 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h1-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h1-margin, 0 0 var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-content-html] h2{font-size:var(--wy-document-h2-font-size, calc(1.5 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h2-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h2-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content-html] h3{font-size:var(--wy-document-h3-font-size, calc(1.25 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h3-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h3-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-content-html] h4{font-size:var(--wy-document-h4-font-size, calc(1.125 * var(--wy-font-size, 1em)));font-weight:var(--wy-document-h4-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h4-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 0)}[part~=wy-content-html] h5{font-size:var(--wy-document-h5-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-document-h5-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h5-margin, var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0 0)}[part~=wy-content-html] h6{font-size:var(--wy-document-h6-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-document-h6-font-weight, var(--wy-font-weight-bold, 600));margin:var(--wy-document-h6-margin, 0)}`, yG = et`[part~=wy-document]{--wy-component-background-color: var(--wy-background, var(--wy-background-light, #f7f9ff));--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);align-self:flex-start;padding:calc(2*var(--wy-size, 1rem)) calc(3.5*var(--wy-size, 1rem));box-sizing:border-box;width:100%;min-height:100%;flex:1 0 auto}@container (inline-size >= 768px){[part~=wy-document]{padding:calc(3*var(--wy-size, 1rem)) calc(4*var(--wy-size, 1rem));margin:calc(2*var(--wy-size, 1rem)) auto;border-radius:calc(.125*var(--wy-size, 1rem));box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));width:120ch;min-height:170ch;max-width:calc(100% - 3.5*var(--wy-size, 1rem))}}`, mG = et`[part~=wy-code] pre,.wy-code pre{text-wrap:pretty}[part~=wy-code] .code,[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code .code,.wy-code code[class*=language-],.wy-code pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;word-wrap:break-word;line-height:1.25;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}@media print{[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code code[class*=language-],.wy-code pre[class*=language-]{text-shadow:none}}[part~=wy-code] pre[class*=language-],.wy-code pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}[part~=wy-code] :not(pre)>code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code :not(pre)>code[class*=language-],.wy-code pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));background:var(--wy-background, var(--wy-background-light, #f7f9ff))}[part~=wy-code] :not(pre)>code[class*=language-],.wy-code :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}[part~=wy-code] .token.variable,.wy-code .token.variable{color:var(--wy-code-variable, var(--wy-code-variable-light, #001080))}[part~=wy-code] .token.operator,.wy-code .token.operator{color:var(--wy-code-operator, var(--wy-code-operator-light, #000000))}[part~=wy-code] .token.prolog,.wy-code .token.prolog{color:var(--wy-code-prolog, var(--wy-code-prolog-light, #000080))}[part~=wy-code] .token.comment,.wy-code .token.comment{color:var(--wy-code-comment, var(--wy-code-comment-light, #008000))}[part~=wy-code] .token.builtin,.wy-code .token.builtin{color:var(--wy-code-builtin, var(--wy-code-builtin-light, #0070C1))}[part~=wy-code] .token.number,.wy-code .token.number{color:var(--wy-code-number, var(--wy-code-number-light, #098658))}[part~=wy-code] .token.inserted,.wy-code .token.inserted{color:var(--wy-code-inserted, var(--wy-code-inserted-light, #098658))}[part~=wy-code] .token.constant,.wy-code .token.constant{color:var(--wy-code-constant, var(--wy-code-constant-light, #811F3F))}[part~=wy-code] .token.hexcode,.wy-code .token.hexcode{color:var(--wy-code-hexcode, var(--wy-code-hexcode-light, #811F3F))}[part~=wy-code] .token.regex,.wy-code .token.regex{color:var(--wy-code-regex, var(--wy-code-regex-light, #811F3F))}[part~=wy-code] .token.char,.wy-code .token.char{color:var(--wy-code-char, var(--wy-code-char-light, #811F3F))}[part~=wy-code] .token.tag,.wy-code .token.tag{color:var(--wy-code-tag, var(--wy-code-tag-light, #800000))}[part~=wy-code] .token.attr-name,.wy-code .token.attr-name{color:var(--wy-code-attr-name, var(--wy-code-attr-name-light, #E50000))}[part~=wy-code] .token.selector,.wy-code .token.selector{color:var(--wy-code-selector, var(--wy-code-selector-light, #E50000))}[part~=wy-code] .token.property,.wy-code .token.property{color:var(--wy-code-property, var(--wy-code-property-light, #E50000))}[part~=wy-code] .token.deleted,.wy-code .token.deleted{color:var(--wy-code-deleted, var(--wy-code-deleted-light, #A31515))}[part~=wy-code] .token.string,.wy-code .token.string{color:var(--wy-code-string, var(--wy-code-string-light, #A31515))}[part~=wy-code] .token.changed,.wy-code .token.changed{color:var(--wy-code-changed, var(--wy-code-changed-light, #0451A5))}[part~=wy-code] .token.punctuation,.wy-code .token.punctuation{color:var(--wy-code-punctuation, var(--wy-code-punctuation-light, #000000))}[part~=wy-code] .token.function,.wy-code .token.function{color:var(--wy-code-function, var(--wy-code-function-light, #0000FF))}[part~=wy-code] .token.keyword,.wy-code .token.keyword{color:var(--wy-code-keyword, var(--wy-code-keyword-light, #AF00DB))}[part~=wy-code] .token.class-name,.wy-code .token.class-name{color:var(--wy-code-class-name, var(--wy-code-class-name-light, #267F99))}[part~=wy-code] .token.important,[part~=wy-code] .token.bold,.wy-code .token.important,.wy-code .token.bold{font-weight:700}[part~=wy-code] .token.italic,.wy-code .token.italic{font-style:italic}`;
var gG = Object.defineProperty, wG = Object.getOwnPropertyDescriptor, Dl = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? wG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && gG(t, e, s), s;
}, "__decorateClass$Q"), ix, Nf;
let ds = (ix = (Nf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.html = !1, this.code = !1, this.textOrHtmlContent = "", this.loading = !0;
  }
  /**
   * Dispatches the `file-preview-loaded` event when content becomes available.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  updated(t) {
    super.updated(t), (t.has("weavy") || t.has("src")) && this.weavy && (this.loading = !0, this.weavy.fetchOptions().then((e) => fetch(this.src, e)).then(V_).then((e) => new Response(e)).then((e) => e.text()).then((e) => {
      this.loading = !1, this.textOrHtmlContent = e, this.dispatchLoaded();
    }));
  }
  render() {
    return this.loading ? v` <wy-empty><wy-progress-circular part="wy-content-progress" indeterminate></wy-progress-circular></wy-empty> ` : this.html ? this.code ? v` <div part="wy-content-code wy-code">${ol(this.textOrHtmlContent)}</div> ` : v`
            <div part="wy-document wy-light">
              <div part="wy-content-html">${ol(this.textOrHtmlContent)}</div>
            </div>
          ` : this.code ? v` <div part="wy-content-code">${this.textOrHtmlContent}</div> ` : v`
          <div part="wy-document wy-light">
            <pre part="wy-content-text">${this.textOrHtmlContent}</pre>
          </div>
        `;
  }
}, c(Nf, "po"), Nf), d(ix, "WyPreviewText"), ix);
ds.styles = [Te, fG, pG, yG, mG, ft];
Dl([
  Ve({ context: Me, subscribe: !0 }),
  F()
], ds.prototype, "weavy", 2);
Dl([
  O()
], ds.prototype, "src", 2);
Dl([
  O({ type: Boolean })
], ds.prototype, "html", 2);
Dl([
  O({ type: Boolean })
], ds.prototype, "code", 2);
Dl([
  F()
], ds.prototype, "textOrHtmlContent", 2);
Dl([
  F()
], ds.prototype, "loading", 2);
ds = Dl([
  U("wy-preview-text")
], ds);
const vG = et`[part~=wy-content-embed]{border:0;display:block;box-sizing:border-box;width:100%;height:100%;top:0;left:0;flex:1 1 100%}[part~=wy-content-embed][part~=wy-loaded]{--wy-component-background-color: var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}[part~=wy-content-embed][part~=wy-loaded]~[part~=wy-content-embed-fallback],[part~=wy-content-embed][part~=wy-loaded]~[part~=wy-content-progress]{display:none}[part~=wy-content-embed][part~=wy-loading]:not([part~=wy-loaded]){position:absolute;visibility:hidden;z-index:-1;pointer-events:none}[part~=wy-content-embed][part~=wy-loading]:not([part~=wy-loaded]):not([part~=wy-fallback])~[part~=wy-content-embed-fallback]{display:none}[part~=wy-content-embed][part~=wy-loading]:not([part~=wy-loaded])[part~=wy-fallback]~[part~=wy-content-progress]{display:none}`;
var OG = Object.defineProperty, bG = Object.getOwnPropertyDescriptor, A1 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? bG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && OG(t, e, s), s;
}, "__decorateClass$P"), nx, jf;
let da = (nx = (jf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this);
  }
  /**
   * Emit `file-preview-loaded` once the preview has finished loading.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  /**
   * Attach load listeners and register the provided embed element.
   *
   * @internal
   * @param embedElement - Newly rendered embed element.
   */
  registerLoading(t) {
    if (this.unregisterLoading?.(), t) {
      this.embedElement = t, t.part.add("wy-loading");
      const e = window.setTimeout(() => {
        t.part.add("wy-fallback"), this.dispatchLoaded();
      }, 2500), i = /* @__PURE__ */ d((s) => {
        const r = s.target;
        r.tagName === "OBJECT" && r.part.contains("wy-loading") && !r.part.contains("wy-loaded") && (r.part.add("wy-loaded"), window.clearTimeout(e), this.dispatchLoaded());
      }, "embedLoaded");
      t.addEventListener("load", i, !0), this.unregisterLoading = () => {
        this.embedElement && (t.removeEventListener("load", i, !0), window.clearTimeout(e), this.embedElement = void 0);
      };
    }
  }
  render() {
    return v`
      <object title=${P("Preview")} ${ot((t) => this.registerLoading(t))} part="wy-content-embed" data=${this.src}></object>
      <wy-progress-circular part="wy-content-progress" indeterminate overlay></wy-progress-circular>
      <wy-preview-icon
        src=${this.src}
        icon=${this.icon}
        provider=${Ot(this.provider)}
        part="wy-content-embed-fallback"></wy-preview-icon>
    `;
  }
  disconnectedCallback() {
    this.unregisterLoading?.(), super.disconnectedCallback();
  }
}, c(jf, "uo"), jf), d(nx, "WyPreviewEmbed"), nx);
da.styles = [
  vG,
  ft
];
A1([
  O()
], da.prototype, "src", 2);
A1([
  O()
], da.prototype, "name", 2);
A1([
  O()
], da.prototype, "icon", 2);
A1([
  O()
], da.prototype, "provider", 2);
da = A1([
  U("wy-preview-embed"),
  St()
], da);
const $G = et`.wy-pdf-container{position:absolute;width:100%;height:100%;bottom:0;left:0}.wy-pdf-container{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-pdf-container:not(body){-webkit-overflow-scrolling:touch}.wy-pdf-container{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-pdf-container{overflow-y:auto;overflow-x:auto;touch-action:pan-y,pan-x}.wy-content-pdf .textLayer{position:absolute;text-align:initial;inset:0;overflow:clip;opacity:1;line-height:1;text-size-adjust:none;forced-color-adjust:none;transform-origin:0 0;caret-color:CanvasText;z-index:0}.wy-content-pdf .textLayer.highlighting{touch-action:none}.wy-content-pdf .textLayer :is(span,br){color:#0000;position:absolute;white-space:pre;cursor:text;transform-origin:0% 0%}.wy-content-pdf .textLayer>:not(.markedContent),.wy-content-pdf .textLayer .markedContent span:not(.markedContent){z-index:1}.wy-content-pdf .textLayer span.markedContent{top:0;height:0}.wy-content-pdf .textLayer span[role=img]{-webkit-user-select:none;user-select:none;cursor:default}.wy-content-pdf .textLayer .highlight{--highlight-bg-color: rgb(180 0 170 / .25);--highlight-selected-bg-color: rgb(0 100 0 / .25);--highlight-backdrop-filter: none;--highlight-selected-backdrop-filter: none}@media screen and (forced-colors:active){.wy-content-pdf .textLayer .highlight{--highlight-bg-color: transparent;--highlight-selected-bg-color: transparent;--highlight-backdrop-filter: var(--hcm-highlight-filter);--highlight-selected-backdrop-filter: var(--hcm-highlight-selected-filter)}}.wy-content-pdf .textLayer .highlight{margin:-1px;padding:1px;background-color:var(--highlight-bg-color);-webkit-backdrop-filter:var(--highlight-backdrop-filter);backdrop-filter:var(--highlight-backdrop-filter);border-radius:4px}.wy-content-pdf .textLayer .highlight.appended{position:initial}.wy-content-pdf .textLayer .highlight.begin{border-radius:4px 0 0 4px}.wy-content-pdf .textLayer .highlight.end{border-radius:0 4px 4px 0}.wy-content-pdf .textLayer .highlight.middle{border-radius:0}.wy-content-pdf .textLayer .highlight.selected{background-color:var(--highlight-selected-bg-color);-webkit-backdrop-filter:var(--highlight-selected-backdrop-filter);backdrop-filter:var(--highlight-selected-backdrop-filter)}.wy-content-pdf .textLayer ::selection{background:#0000ff40;background:color-mix(in srgb,AccentColor,transparent 75%)}.wy-content-pdf .textLayer br::selection{background:#0000}.wy-content-pdf .textLayer .endOfContent{display:block;position:absolute;inset:100% 0 0;z-index:0;cursor:default;-webkit-user-select:none;user-select:none}.wy-content-pdf .textLayer.selecting .endOfContent{top:0}.wy-content-pdf .annotationLayer{--annotation-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\");--input-focus-border-color: Highlight;--input-focus-outline: 1px solid Canvas;--input-unfocused-border-color: transparent;--input-disabled-border-color: transparent;--input-hover-border-color: black;--link-outline: none}@media screen and (forced-colors:active){.wy-content-pdf .annotationLayer{--input-focus-border-color: CanvasText;--input-unfocused-border-color: ActiveText;--input-disabled-border-color: GrayText;--input-hover-border-color: Highlight;--link-outline: 1.5px solid LinkText}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):required,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:required,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:required{outline:1.5px solid selectedItem}.wy-content-pdf .annotationLayer .linkAnnotation{outline:var(--link-outline)}.wy-content-pdf .annotationLayer .linkAnnotation:hover{-webkit-backdrop-filter:var(--hcm-highlight-filter);backdrop-filter:var(--hcm-highlight-filter)}.wy-content-pdf .annotationLayer .linkAnnotation>a:hover{opacity:0!important;background:none!important;box-shadow:none}.wy-content-pdf .annotationLayer .popupAnnotation .popup{outline:calc(1.5px*var(--scale-factor)) solid CanvasText!important;background-color:ButtonFace!important;color:ButtonText!important}.wy-content-pdf .annotationLayer .highlightArea:hover:after{position:absolute;top:0;left:0;width:100%;height:100%;-webkit-backdrop-filter:var(--hcm-highlight-filter);backdrop-filter:var(--hcm-highlight-filter);content:\"\";pointer-events:none}.wy-content-pdf .annotationLayer .popupAnnotation.focused .popup{outline:calc(3px*var(--scale-factor)) solid Highlight!important}}.wy-content-pdf .annotationLayer{position:absolute;top:0;left:0;pointer-events:none;transform-origin:0 0}.wy-content-pdf .annotationLayer[data-main-rotation=\"90\"] .norotate{transform:rotate(270deg) translate(-100%)}.wy-content-pdf .annotationLayer[data-main-rotation=\"180\"] .norotate{transform:rotate(180deg) translate(-100%,-100%)}.wy-content-pdf .annotationLayer[data-main-rotation=\"270\"] .norotate{transform:rotate(90deg) translateY(-100%)}.wy-content-pdf .annotationLayer.disabled section,.wy-content-pdf .annotationLayer.disabled .popup{pointer-events:none}.wy-content-pdf .annotationLayer .annotationContent{position:absolute;width:100%;height:100%;pointer-events:none}.wy-content-pdf .annotationLayer .annotationContent.freetext{background:#0000;border:none;inset:0;overflow:visible;white-space:nowrap;font:10px sans-serif;line-height:1.35;-webkit-user-select:none;user-select:none}.wy-content-pdf .annotationLayer section{position:absolute;text-align:initial;pointer-events:auto;box-sizing:border-box;transform-origin:0 0}.wy-content-pdf .annotationLayer section:has(div.annotationContent) canvas.annotationContent{display:none}.textLayer.selecting~.wy-content-pdf .annotationLayer section{pointer-events:none}.wy-content-pdf .annotationLayer :is(.linkAnnotation,.buttonWidgetAnnotation.pushButton)>a{position:absolute;font-size:1em;top:0;left:0;width:100%;height:100%}.wy-content-pdf .annotationLayer :is(.linkAnnotation,.buttonWidgetAnnotation.pushButton):not(.hasBorder)>a:hover{opacity:.2;background-color:#ff0;box-shadow:0 2px 10px #ff0}.wy-content-pdf .annotationLayer .linkAnnotation.hasBorder:hover{background-color:#ff03}.wy-content-pdf .annotationLayer .hasBorder{background-size:100% 100%}.wy-content-pdf .annotationLayer .textAnnotation img{position:absolute;cursor:pointer;width:100%;height:100%;top:0;left:0}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea),.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input{background-image:var(--annotation-unfocused-field-background);border:2px solid var(--input-unfocused-border-color);box-sizing:border-box;font:calc(9px*var(--scale-factor)) sans-serif;height:100%;margin:0;vertical-align:top;width:100%}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):required,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:required,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:required{outline:1.5px solid red}.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select option{padding:0}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input{border-radius:50%}.wy-content-pdf .annotationLayer .textWidgetAnnotation textarea{resize:none}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea)[disabled],.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select[disabled],.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input[disabled]{background:none;border:2px solid var(--input-disabled-border-color);cursor:not-allowed}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):hover,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:hover,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:hover{border:2px solid var(--input-hover-border-color)}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):hover,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:hover,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:hover{border-radius:2px}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):focus,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:focus{background:none;border:2px solid var(--input-focus-border-color);border-radius:2px;outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) :focus{background-image:none;background-color:#0000}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox :focus{border:2px solid var(--input-focus-border-color);border-radius:2px;outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton :focus{border:2px solid var(--input-focus-border-color);outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{background-color:CanvasText;content:\"\";display:block;position:absolute}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{height:80%;left:45%;width:1px}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{transform:rotate(45deg)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{transform:rotate(-45deg)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{border-radius:50%;height:50%;left:25%;top:25%;width:50%}.wy-content-pdf .annotationLayer .textWidgetAnnotation input.comb{font-family:monospace;padding-left:2px;padding-right:0}.wy-content-pdf .annotationLayer .textWidgetAnnotation input.comb:focus{width:103%}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input{appearance:none}.wy-content-pdf .annotationLayer .fileAttachmentAnnotation .popupTriggerArea{height:100%;width:100%}.wy-content-pdf .annotationLayer .popupAnnotation{position:absolute;font-size:calc(9px*var(--scale-factor));pointer-events:none;width:max-content;max-width:45%;height:auto}.wy-content-pdf .annotationLayer .popup{background-color:#ff9;box-shadow:0 calc(2px*var(--scale-factor)) calc(5px*var(--scale-factor)) #888;border-radius:calc(2px*var(--scale-factor));outline:1.5px solid #ffff4a;padding:calc(6px*var(--scale-factor));cursor:pointer;font:message-box;white-space:normal;word-wrap:break-word;pointer-events:auto}.wy-content-pdf .annotationLayer .popupAnnotation.focused .popup{outline-width:3px}.wy-content-pdf .annotationLayer .popup *{font-size:calc(9px*var(--scale-factor))}.wy-content-pdf .annotationLayer .popup>.header{display:inline-block}.wy-content-pdf .annotationLayer .popup>.header h1{display:inline}.wy-content-pdf .annotationLayer .popup>.header .popupDate{display:inline-block;margin-left:calc(5px*var(--scale-factor));width:fit-content}.wy-content-pdf .annotationLayer .popupContent{border-top:1px solid #333;margin-top:calc(2px*var(--scale-factor));padding-top:calc(2px*var(--scale-factor))}.wy-content-pdf .annotationLayer .richText>*{white-space:pre-wrap;font-size:calc(9px*var(--scale-factor))}.wy-content-pdf .annotationLayer .popupTriggerArea{cursor:pointer}.wy-content-pdf .annotationLayer section svg{position:absolute;width:100%;height:100%;top:0;left:0}.wy-content-pdf .annotationLayer .annotationTextContent{position:absolute;width:100%;height:100%;opacity:0;color:#0000;-webkit-user-select:none;user-select:none;pointer-events:none}.wy-content-pdf .annotationLayer .annotationTextContent span{width:100%;display:inline-block}.wy-content-pdf .annotationLayer svg.quadrilateralsContainer{contain:strict;width:0;height:0;position:absolute;top:0;left:0;z-index:-1}:host{--xfa-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\");--xfa-focus-outline: auto}@media screen and (forced-colors:active){:host{--xfa-focus-outline: 2px solid CanvasText}.wy-content-pdf .xfaLayer *:required{outline:1.5px solid selectedItem}}.wy-content-pdf .xfaLayer{background-color:#0000}.wy-content-pdf .xfaLayer .highlight{margin:-1px;padding:1px;background-color:#efcbed;border-radius:4px}.wy-content-pdf .xfaLayer .highlight.appended{position:initial}.wy-content-pdf .xfaLayer .highlight.begin{border-radius:4px 0 0 4px}.wy-content-pdf .xfaLayer .highlight.end{border-radius:0 4px 4px 0}.wy-content-pdf .xfaLayer .highlight.middle{border-radius:0}.wy-content-pdf .xfaLayer .highlight.selected{background-color:#cbdfcb}.wy-content-pdf .xfaPage{overflow:hidden;position:relative}.wy-content-pdf .xfaContentarea{position:absolute}.wy-content-pdf .xfaPrintOnly{display:none}.wy-content-pdf .xfaLayer{position:absolute;text-align:initial;top:0;left:0;transform-origin:0 0;line-height:1.2}.wy-content-pdf .xfaLayer *{color:inherit;font:inherit;font-style:inherit;font-weight:inherit;font-kerning:inherit;letter-spacing:-.01px;text-align:inherit;text-decoration:inherit;box-sizing:border-box;background-color:#0000;padding:0;margin:0;pointer-events:auto;line-height:inherit}.wy-content-pdf .xfaLayer *:required{outline:1.5px solid red}.wy-content-pdf .xfaLayer div,.wy-content-pdf .xfaLayer svg,.wy-content-pdf .xfaLayer svg *{pointer-events:none}.wy-content-pdf .xfaLayer a{color:#00f}.wy-content-pdf .xfaRich li{margin-left:3em}.wy-content-pdf .xfaFont{color:#000;font-weight:400;font-kerning:none;font-size:10px;font-style:normal;letter-spacing:0;text-decoration:none;vertical-align:0}.wy-content-pdf .xfaCaption{overflow:hidden;flex:0 0 auto}.wy-content-pdf .xfaCaptionForCheckButton{overflow:hidden;flex:1 1 auto}.wy-content-pdf .xfaLabel{height:100%;width:100%}.wy-content-pdf .xfaLeft{display:flex;flex-direction:row;align-items:center}.wy-content-pdf .xfaRight{display:flex;flex-direction:row-reverse;align-items:center}.wy-content-pdf :is(.xfaLeft,.xfaRight)>:is(.xfaCaption,.xfaCaptionForCheckButton){max-height:100%}.wy-content-pdf .xfaTop{display:flex;flex-direction:column;align-items:flex-start}.wy-content-pdf .xfaBottom{display:flex;flex-direction:column-reverse;align-items:flex-start}.wy-content-pdf :is(.xfaTop,.xfaBottom)>:is(.xfaCaption,.xfaCaptionForCheckButton){width:100%}.wy-content-pdf .xfaBorder{background-color:#0000;position:absolute;pointer-events:none}.wy-content-pdf .xfaWrapped{width:100%;height:100%}.wy-content-pdf :is(.xfaTextfield,.xfaSelect):focus{background-image:none;background-color:#0000;outline:var(--xfa-focus-outline);outline-offset:-1px}.wy-content-pdf :is(.xfaCheckbox,.xfaRadio):focus{outline:var(--xfa-focus-outline)}.wy-content-pdf .xfaTextfield,.wy-content-pdf .xfaSelect{height:100%;width:100%;flex:1 1 auto;border:none;resize:none;background-image:var(--xfa-unfocused-field-background)}.wy-content-pdf .xfaSelect{padding-inline:2px}.wy-content-pdf :is(.xfaTop,.xfaBottom)>:is(.xfaTextfield,.xfaSelect){flex:0 1 auto}.wy-content-pdf .xfaButton{cursor:pointer;width:100%;height:100%;border:none;text-align:center}.wy-content-pdf .xfaLink{width:100%;height:100%;position:absolute;top:0;left:0}.wy-content-pdf .xfaCheckbox,.wy-content-pdf .xfaRadio{width:100%;height:100%;flex:0 0 auto;border:none}.wy-content-pdf .xfaRich{white-space:pre-wrap;width:100%;height:100%}.wy-content-pdf .xfaImage{object-position:left top;object-fit:contain;width:100%;height:100%}.wy-content-pdf .xfaLrTb,.wy-content-pdf .xfaRlTb,.wy-content-pdf .xfaTb{display:flex;flex-direction:column;align-items:stretch}.wy-content-pdf .xfaLr{display:flex;flex-direction:row;align-items:stretch}.wy-content-pdf .xfaRl{display:flex;flex-direction:row-reverse;align-items:stretch}.wy-content-pdf .xfaTb>div{justify-content:left}.wy-content-pdf .xfaPosition,.wy-content-pdf .xfaArea{position:relative}.wy-content-pdf .xfaValignMiddle{display:flex;align-items:center}.wy-content-pdf .xfaTable{display:flex;flex-direction:column;align-items:stretch}.wy-content-pdf .xfaTable .xfaRow{display:flex;flex-direction:row;align-items:stretch}.wy-content-pdf .xfaTable .xfaRlRow{display:flex;flex-direction:row-reverse;align-items:stretch;flex:1}.wy-content-pdf .xfaTable .xfaRlRow>div{flex:1}.wy-content-pdf :is(.xfaNonInteractive,.xfaDisabled,.xfaReadOnly) :is(input,textarea){background:initial}@media print{.wy-content-pdf .xfaTextfield,.wy-content-pdf .xfaSelect{background:#0000}.wy-content-pdf .xfaSelect{appearance:none;text-indent:1px;text-overflow:\"\"}}:host{--viewer-container-height: 0;--pdfViewer-padding-bottom: 0;--page-margin: 1px auto -8px;--page-border: 9px solid transparent;--spreadHorizontalWrapped-margin-LR: -3.5px;--loading-icon-delay: .4s}@media screen and (forced-colors:active){:host{--pdfViewer-padding-bottom: 9px;--page-margin: 8px auto -1px;--page-border: 1px solid CanvasText;--spreadHorizontalWrapped-margin-LR: 3.5px}}.wy-content-pdf [data-main-rotation=\"90\"]{transform:rotate(90deg) translateY(-100%)}.wy-content-pdf [data-main-rotation=\"180\"]{transform:rotate(180deg) translate(-100%,-100%)}.wy-content-pdf [data-main-rotation=\"270\"]{transform:rotate(270deg) translate(-100%)}.wy-content-pdf #hiddenCopyElement,.wy-content-pdf .hiddenCanvasElement{position:absolute;top:0;left:0;width:0;height:0;display:none}.wy-content-pdf .pdfViewer{--scale-factor: 1;--page-bg-color: unset;padding-bottom:var(--pdfViewer-padding-bottom);--hcm-highlight-filter: none;--hcm-highlight-selected-filter: none}@media screen and (forced-colors:active){.wy-content-pdf .pdfViewer{--hcm-highlight-filter: invert(100%)}}.wy-content-pdf .pdfViewer.copyAll{cursor:wait}.wy-content-pdf .pdfViewer .canvasWrapper{overflow:hidden;width:100%;height:100%}.wy-content-pdf .pdfViewer .canvasWrapper canvas{position:absolute;top:0;left:0;margin:0;display:block;width:100%;height:100%;contain:content}.wy-content-pdf .pdfViewer .canvasWrapper canvas .structTree{contain:strict}.wy-content-pdf .pdfViewer .page{--scale-round-x: 1px;--scale-round-y: 1px;direction:ltr;width:816px;height:1056px;margin:var(--page-margin);position:relative;overflow:visible;border:var(--page-border);background-clip:content-box;background-color:var(--page-bg-color, rgb(255, 255, 255))}.wy-content-pdf .pdfViewer .dummyPage{position:relative;width:0;height:var(--viewer-container-height)}.wy-content-pdf .pdfViewer.noUserSelect{-webkit-user-select:none;user-select:none}.wy-content-pdf .pdfViewer.removePageBorders .page{margin:0 auto 10px;border:none}.wy-content-pdf .pdfViewer.singlePageView{display:inline-block}.wy-content-pdf .pdfViewer.singlePageView .page{margin:0;border:none}.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped),.wy-content-pdf .spread{margin-inline:3.5px;text-align:center}.wy-content-pdf .pdfViewer.scrollHorizontal,.wy-content-pdf .spread{white-space:nowrap}.wy-content-pdf .pdfViewer.removePageBorders,.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) .spread{margin-inline:0}.wy-content-pdf .spread :is(.page,.dummyPage),.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) :is(.page,.spread){display:inline-block;vertical-align:middle}.wy-content-pdf .spread .page,.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) .page{margin-inline:var(--spreadHorizontalWrapped-margin-LR)}.wy-content-pdf .pdfViewer.removePageBorders .spread .page,.wy-content-pdf .pdfViewer.removePageBorders:is(.scrollHorizontal,.scrollWrapped) .page{margin-inline:5px}.wy-content-pdf .pdfViewer .page.loadingIcon:after{position:absolute;top:0;left:0;content:\"\";width:100%;height:100%;display:none;transition-property:display;transition-delay:var(--loading-icon-delay);z-index:5;contain:strict}.wy-content-pdf .pdfViewer .page.loading:after{display:block}.wy-content-pdf .pdfViewer .page:not(.loading):after{transition-property:none;display:none}.wy-content-pdf .pdfPresentationMode .pdfViewer{padding-bottom:0}.wy-content-pdf .pdfPresentationMode .spread{margin:0}.wy-content-pdf .pdfPresentationMode .pdfViewer .page{margin:0 auto;border:2px solid rgba(0,0,0,0)}.wy-content-pdf .pdfViewer .page{box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));background-color:var(--wy-white, var(--wy-white, #ffffff))}.wy-content-pdf .pdfViewer .page.loadingIcon:after{background:url(\"data:image/svg+xml,%3Csvg viewBox='0 0 24 24' width='24' height='24' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cstyle type='text/css'%3Eg%7Banimation:rotate 2s linear infinite;transform-origin:center center%7Dcircle%7Bstroke-dasharray:1,100;stroke-dashoffset:0;animation:dash 1.5s ease-in-out infinite,color 6s ease-in-out infinite%7D@keyframes rotate%7B100%25%7Btransform:rotate(360deg)%7D%7D@keyframes dash%7B0%25%7Bstroke-dasharray:1,100;stroke-dashoffset:0%7D50%25%7Bstroke-dasharray:44.5,100;stroke-dashoffset:-17.5px%7D100%25%7Bstroke-dasharray:44.5,100;stroke-dashoffset:-62px%7D%7D@keyframes color%7B0%25,100%25%7Bstroke:%23216eb4%7D40%25%7Bstroke:%2328b7cf%7D66%25%7Bstroke:%23216eb4%7D80%25,90%25%7Bstroke:%2328b7cf%7D%7D%3C/style%3E%3Cg%3E%3Ccircle fill='none' cx='12' cy='12' r='11' stroke-linecap='butt' stroke-width='2' /%3E%3C/g%3E%3C/svg%3E\") center no-repeat}.wy-pdf-page-number{width:calc(3*var(--wy-size, 1rem))}.wy-pdf-zoom-level{width:calc(5*var(--wy-size, 1rem))}`, LW = et`[part~=wy-toolbar]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));--wy-component-background-color: var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));box-sizing:border-box;display:flex;flex-wrap:wrap;align-items:center;justify-content:flex-start;justify-items:center;min-height:var(--wy-toolbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));padding:calc(.5*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));flex:1 0 var(--wy-toolbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));column-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));line-height:var(--wy-line-height, 1.5);background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-component-border-radius)}[part~=wy-toolbar-center]{margin:0 auto;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-toolbar-buttons]{display:flex;flex:0 0 auto;align-items:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));max-width:100%}[part~=wy-toolbar-buttons-last]{margin-inline-start:auto}[part~=wy-toolbar-text]{margin-left:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-toolbar-center-text]{text-align:center}[part~=wy-toolbars-bottom]{position:absolute;z-index:1030;bottom:calc(var(--wy-footerbar-height, calc(4 * var(--wy-size, 1rem)))/2);left:0;right:0;min-height:var(--wy-toolbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;justify-content:center;justify-items:center;box-sizing:border-box}`, $a = et`[part~=wy-input]{--wy-component-background-color: var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border:var(--wy-input-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));margin:calc(-1*var(--wy-input-border-width, var(--wy-border, 1px)));display:block;max-width:100%;min-width:0;flex:1 1 auto;min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em))*1.5*var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*2 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))*2);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-input-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem))));background-clip:padding-box;appearance:none;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-input]:focus{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));color:var(--wy-component-color);border-color:var(--wy-primary, var(--wy-primary-light, #2f628c));outline:0}[part~=wy-input]::placeholder{color:var(--wy-outline, var(--wy-outline-light, #72777f));opacity:1}[part~=wy-input]:disabled{opacity:38%}[part~=wy-input]::file-selector-button,[part~=wy-input]::-webkit-file-upload-button{color:var(--wy-component-color);background-color:var(--wy-component-background-color);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));margin:calc(-1*var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) calc(-1*var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));margin-inline-end:var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));pointer-events:none;border-color:inherit;border-style:solid;border-width:0;border-inline-end-width:var(--wy-input-border-width, var(--wy-border, 1px));border-radius:0}[part~=wy-input]:hover:not(:disabled):not([readonly])::file-selector-button,[part~=wy-input]:hover:not(:disabled):not([readonly]) ::-webkit-file-upload-button{background-color:var(--wy-component-background-color)}[part~=wy-input][type=file]{overflow:hidden}[part~=wy-input][type=file]:not(:disabled):not([readonly]){cursor:pointer}[part~=wy-input]::-webkit-date-and-time-value{height:calc(var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem))))*1em)}[part~=wy-input][type=search]::-webkit-search-cancel-button{-webkit-appearance:none}[part~=wy-input-filled]{--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-input-filled-border-radius, var(--wy-border-radius-lg, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem)))));border-color:var(--wy-component-background-color)}[part~=wy-input-filled]:focus{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-label]{display:inline-block;font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));font-size:var(--wy-headings-font-size, var(--wy-font-size, 1em));font-style:var(--wy-headings-font-style, unset);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.5));margin-block:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-description]{color:var(--wy-outline, var(--wy-outline-light, #72777f));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));margin-top:calc(.25*var(--wy-size, 1rem))}[part~=wy-is-invalid],[part~=wy-is-invalid]:focus{border-color:var(--wy-error, var(--wy-error-light, #ba1821))}[part~=wy-invalid-feedback]{margin-top:calc(.25*var(--wy-size, 1rem));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));color:var(--wy-error, var(--wy-error-light, #ba1821))}[part~=wy-input-group]{position:relative;display:flex;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));align-items:center;flex:1 0 auto}[part~=wy-input-group-button-icon]{--wy-component-background-color: transparent}[part~=wy-input-group-input-with-overlay]{padding-right:calc(var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) + var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}[part~=wy-input-group-button-icon-overlay]{position:absolute;display:inline-flex;top:0;right:0;z-index:4;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));--wy-component-background-color: transparent}[part~=wy-input-group-input]:placeholder-shown~[part~=wy-input-group-button-icon][type=reset]{display:none}[part~=wy-input-group-input]:not(:placeholder-shown)~[part~=wy-input-group-button-icon][type=reset]+[part~=wy-input-group-button-icon]{display:none}[part~=wy-no-result]{text-align:center;padding:calc(1*var(--wy-size, 1rem))}`;
var xG = Object.defineProperty, kG = Object.getOwnPropertyDescriptor, V0 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? kG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && xG(t, e, s), s;
}, "__decorateClass$O"), sx, Bf;
let yl = (sx = (Bf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.whenPdfjs = new Promise((t) => {
      this.whenPdfjsResolve = t;
    }), this.MAX_CANVAS_PIXELS = 0, this.TEXT_LAYER_MODE = 0, this.MAX_IMAGE_SIZE = -1, this.CMAP_PACKED = !0, this.DEFAULT_SCALE_DELTA = 1.1, this.MIN_SCALE = 0.25, this.MAX_SCALE = 10, this.DEFAULT_SCALE_VALUE = "auto", this.ENABLE_XFA = !0, this.DEFAULT_WORKER_URL = "/pdfjs/pdf.worker.min.mjs", this.DEFAULT_CMAPS_URL = "/pdfjs/cmaps/", this.pageNumberRef = wt(), this.totalPagesRef = wt(), this.zoomLevelRef = wt(), this.viewerContainerRef = wt(), this.resizer = new ResizeObserver(() => {
      this.pdfViewer && (this.delayedResize && (clearTimeout(this.delayedResize), this.delayedResize = void 0), this.delayedResize = window.setTimeout(() => {
        this.pdfViewer && (this.pdfViewer.currentScaleValue = this.pdfViewer._currentScaleValue);
      }, 100));
    });
  }
  /**
   * Emit `file-preview-loaded` once the viewer has initialized.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded");
    return this.dispatchEvent(t);
  }
  ////////
  /**
   * Open the configured PDF source in the viewer.
   *
   * @internal
   */
  async open() {
    const { pdfjsLib: t } = await this.whenPdfjs;
    if (!this.pdfViewer || !this.pdfHistory || !this.l10n || !this.pdfLinkService)
      return;
    this.pdfLoadingTask && await this.close();
    const e = t.getDocument({
      url: this.src,
      maxImageSize: this.MAX_IMAGE_SIZE,
      enableXfa: this.ENABLE_XFA,
      cMapUrl: this.CMAP_URL?.toString() || "",
      cMapPacked: this.CMAP_PACKED
    });
    this.pdfLoadingTask = e, e.onProgress = (i) => {
    };
    try {
      const i = await e.promise;
      this.pdfDocument = i, this.pdfViewer.setDocument(i), this.pdfLinkService.setDocument(i), this.pdfHistory.initialize({
        // @ts-expect-error Type 'string | null' is not assignable to type 'string'.
        fingerprint: i.fingerprints[0]
      });
    } catch (i) {
      let s = "pdfjs-loading-error";
      i instanceof t.InvalidPDFException ? s = "pdfjs-invalid-file-error" : i instanceof t.MissingPDFException ? s = "pdfjs-missing-file-error" : i instanceof t.UnexpectedResponseException && (s = "pdfjs-unexpected-response-error"), await this.l10n.get(s, void 0, void 0).then((r) => {
        this.pdfViewError(t, r, { message: i?.message });
      });
    }
    this.dispatchLoaded();
  }
  /**
   * Close any currently loaded PDF and release resources.
   *
   * @internal
   */
  async close() {
    if (!this.pdfLoadingTask)
      return Promise.resolve();
    const t = this.pdfLoadingTask.destroy();
    return this.pdfLoadingTask = void 0, this.pdfDocument && (this.pdfDocument = void 0, this.pdfViewer?.setDocument(null), this.pdfLinkService?.setDocument(null, null), this.pdfHistory && this.pdfHistory.reset()), await t;
  }
  /**
   * Log a pdf.js related error with contextual metadata.
   *
   * @internal
   * @param pdfjsLib - pdf.js core library.
   * @param message - Human readable error.
   * @param moreInfo - Additional error metadata.
   */
  pdfViewError(t, e, i) {
    const s = [`PDF.js v${t?.version || "?"} (build: ${t?.build || "?"})`];
    i && (s.push(`Message: ${i.message}`), i.stack ? s.push(`Stack: ${i.stack}`) : (i.filename && s.push(`File: ${i.filename}`), i.lineNumber && s.push(`Line: ${i.lineNumber}`))), console.error(`${e}

${s.join(`
`)}`);
  }
  ///////
  /**
   * Navigate to the provided page number.
   *
   * @param pageNumber - One-based page index.
   */
  setPage(t) {
    this.pdfViewer && (this.pdfViewer.currentPageNumber = t);
  }
  /**
   * Increase zoom level by the configured delta.
   *
   * @param ticks - Number of zoom steps to apply.
   */
  zoomIn(t = 0) {
    if (this.pdfViewer) {
      let e = this.pdfViewer.currentScale;
      do
        e = parseFloat((e * this.DEFAULT_SCALE_DELTA).toFixed(2)), e = Math.ceil(e * 10) / 10, e = Math.min(this.MAX_SCALE, e);
      while (--t && e < this.MAX_SCALE);
      this.pdfViewer.currentScaleValue = e.toFixed(2);
    }
  }
  /**
   * Decrease zoom level by the configured delta.
   *
   * @param ticks - Number of zoom steps to apply.
   */
  zoomOut(t = 0) {
    if (this.pdfViewer) {
      let e = this.pdfViewer.currentScale;
      do
        e = parseFloat((e / this.DEFAULT_SCALE_DELTA).toFixed(2)), e = Math.floor(e * 10) / 10, e = Math.max(this.MIN_SCALE, e);
      while (--t && e > this.MIN_SCALE);
      this.pdfViewer.currentScaleValue = e.toFixed(2);
    }
  }
  /**
   * Apply an absolute zoom level or named scale preset.
   *
   * @param scale - Numeric zoom or preset name.
   */
  setScale(t) {
    this.pdfViewer && (this.pdfViewer.currentScaleValue = typeof t == "number" ? t.toFixed(2) : t);
  }
  /**
   * Validate and update the current page based on the input value.
   */
  updatePage() {
    if (this.pdfViewer && this.pageNumberRef.value) {
      const t = parseInt(this.pageNumberRef.value.value);
      isNaN(t) ? this.setPage(this.pdfViewer.currentPageNumber) : t > this.pdfViewer.pagesCount ? this.setPage(this.pdfViewer.pagesCount) : t <= 0 ? this.setPage(1) : this.setPage(t);
    }
  }
  /**
   * Select all text inside an input, aiding quick replacement.
   *
   * @param e - Input focus event.
   */
  select(t) {
    const e = t.target;
    e && e.setSelectionRange(0, e.value.length);
  }
  /**
   * Fit the PDF to the current viewport height.
   */
  fitToPage() {
    this.setScale("page-fit");
  }
  /**
   * Fit the PDF to the current viewport width.
   */
  fitToWidth() {
    this.setScale("page-width");
  }
  /**
   * Validate and persist zoom level from the input field.
   */
  updateZoom() {
    if (this.pdfViewer && this.zoomLevelRef.value) {
      const t = parseFloat(this.zoomLevelRef.value.value.replace("%", ""));
      isNaN(t) ? this.setScale(this.pdfViewer.currentScale + 1e-4) : this.setScale(t / 100);
    }
  }
  // clearDocument() {
  //   try {
  //     this.loadingTask?.destroy();
  //     //console.debug("loadingTask cleanup", loadingTask)
  //   } catch (e) {
  //     /* No worries */
  //   }
  //   try {
  //     // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  //     // @ts-ignore due to incorrect param type def?
  //     this.pdfViewer?.setDocument(null);
  //   } catch (e) {
  //     /* No worries */
  //   }
  //   try {
  //     this.pdfLinkService.setDocument(null, null);
  //   } catch (e) {
  //     /* No worries */
  //   }
  // }
  async willUpdate(t) {
    super.willUpdate(t), t.has("weavy") && this.weavy && (this.pdfjsLib || (await this.weavy.whenUrl(), this.pdfjsLib = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL("./es/pdfjs-dist/build/pdf.mjs-Bhye_tXX.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
    ), globalThis.pdfjsLib = this.pdfjsLib, this.pdfjsViewer = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL("./es/pdfjs-dist/web/pdf_viewer.mjs-bp-6p92T.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
    ), this.whenPdfjsResolve?.({
      pdfjsLib: this.pdfjsLib,
      pdfjsViewer: this.pdfjsViewer
    })), this.pdfjsLib && !this.WORKER_URL && (this.WORKER_URL = vS(this.DEFAULT_WORKER_URL, import.meta.url), this.WORKER_URL.searchParams.append("v", this.weavy.version), this.pdfjsLib.GlobalWorkerOptions.workerSrc = this.WORKER_URL.toString()), this.CMAP_URL || (this.CMAP_URL = vS(this.DEFAULT_CMAPS_URL, import.meta.url)));
  }
  update(t) {
    super.update(t), (t.has("weavy") || t.has("src") || t.has("pdfViewer")) && this.weavy && this.src && this.pdfViewer && this.open();
  }
  async updated() {
    if (this.weavy && this.viewerContainerRef.value && !this.pdfViewer) {
      const { pdfjsLib: t, pdfjsViewer: e } = await this.whenPdfjs;
      this.viewerContainerRef.value && !this.pdfViewer && (this.pdfEventBus = new e.EventBus(), this.pdfLinkService = new e.PDFLinkService({
        eventBus: this.pdfEventBus
      }), this.l10n = new e.GenericL10n(this.weavy?.locale), this.pdfViewer = new e.PDFViewer({
        container: this.viewerContainerRef.value,
        eventBus: this.pdfEventBus,
        linkService: this.pdfLinkService,
        //findController: this.pdfFindController,
        annotationEditorMode: t.AnnotationEditorType.DISABLE,
        l10n: this.l10n,
        maxCanvasPixels: this.MAX_CANVAS_PIXELS,
        textLayerMode: this.TEXT_LAYER_MODE
      }), this.pdfLinkService?.setViewer(this.pdfViewer), this.pdfHistory = new e.PDFHistory({
        eventBus: this.pdfEventBus,
        linkService: this.pdfLinkService
      }), this.pdfLinkService?.setHistory(this.pdfHistory), this.pdfEventBus?.on("scalechanging", () => {
        this.zoomLevelRef.value && this.pdfViewer ? this.zoomLevelRef.value.value = Math.round(this.pdfViewer.currentScale * 100).toFixed(0) + "%" : console.warn("Could not set zoom level");
      }), this.pdfEventBus?.on("pagechanging", () => {
        this.pageNumberRef.value && this.pdfViewer ? this.pageNumberRef.value.value = this.pdfViewer.currentPageNumber.toFixed(0) : console.warn("Could not set page number");
      }), this.pdfEventBus?.on("pagesinit", () => {
        this.isConnected && this.pdfViewer && this.pageNumberRef.value && this.totalPagesRef.value ? (this.pdfViewer.currentScaleValue = this.DEFAULT_SCALE_VALUE, this.pageNumberRef.value.value = "1", this.totalPagesRef.value.innerText = this.pdfViewer.pagesCount.toFixed(0), this.resizer.observe(this.pdfViewer.container)) : console.warn("Could not init pdf page");
      }));
    }
  }
  render() {
    return v`
      <div class="wy-content-pdf">
        <div part="wy-toolbars-bottom">
          <nav part="wy-toolbar wy-toolbar-center">
            <div part="wy-toolbar-buttons">
              <input
                type="text"
                part="wy-input wy-toolbar-center-text"
                class="wy-pdf-page-number"
                ${ot(this.pageNumberRef)}
                @keydown=${Vw}
                @keyup=${Ys}
                @change=${() => this.updatePage()}
                @click=${(t) => this.select(t)}
              />
              <span part="wy-toolbar-text">/</span>
              <span part="wy-toolbar-text" ${ot(this.totalPagesRef)}>1</span>
            </div>
            <div part="wy-toolbar-buttons">
              <wy-button kind="icon" class="btn-zoom-out" @click=${() => this.zoomOut()} title=${P("Zoom out")}>
                <wy-icon name="minus"></wy-icon>
              </wy-button>
              <input
                type="text"
                part="wy-input"
                class="wy-pdf-zoom-level"
                ${ot(this.zoomLevelRef)}
                @keydown=${Vw}
                @keyup=${Ys}
                @change=${() => this.updateZoom()}
                @click=${(t) => this.select(t)}
                value="100%"
              />
              <wy-button kind="icon" class="btn-zoom-in" @click=${() => this.zoomIn()} title=${P("Zoom in")}>
                <wy-icon name="plus"></wy-icon>
              </wy-button>
            </div>
            <div part="wy-toolbar-buttons">
              <wy-button kind="icon" class="btn-fit-page" @click=${() => this.fitToWidth()} title=${P("Fit to width")}>
                <wy-icon name="fit-width"></wy-icon>
              </wy-button>
              <wy-button kind="icon" @click=${() => this.fitToPage()} title=${P("Fit to screen")}>
                <wy-icon name="fit-screen"></wy-icon>
              </wy-button>
            </div>
          </nav>
        </div>
        <div ${ot(this.viewerContainerRef)} class="wy-pdf-container">
          <div class="pdfViewer"></div>
        </div>
      </div>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.pdfViewer && this.resizer.observe(this.pdfViewer.container);
  }
  disconnectedCallback() {
    this.resizer.unobserve(this);
    try {
      this.close(), this.pdfViewer?.cleanup();
    } catch {
    }
    this.pdfViewer = void 0, super.disconnectedCallback();
  }
}, c(Bf, "yo"), Bf), d(sx, "WyPdfViewer"), sx);
yl.styles = [
  $G,
  LW,
  $a,
  ft
];
V0([
  Ve({ context: Me, subscribe: !0 }),
  F()
], yl.prototype, "weavy", 2);
V0([
  O()
], yl.prototype, "src", 2);
V0([
  F()
], yl.prototype, "pdfViewer", 2);
yl = V0([
  U("wy-pdf-viewer"),
  St()
], yl);
var SG = Object.defineProperty, CG = Object.getOwnPropertyDescriptor, X4 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? CG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && SG(t, e, s), s;
}, "__decorateClass$N"), rx, Uf;
let mm = (rx = (Uf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.current = !1;
  }
  /**
   * Emits the `file-preview-loaded` event when the preview has finished loading.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchLoaded() {
    const t = new CustomEvent("file-preview-loaded", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  render() {
    const t = this.file;
    if (!t) return C;
    const { icon: e } = lr(t.name), i = tn(t.name);
    let s = t.preview_url || t.download_url || "";
    t.preview_format === "image" && (i === ".gif" || i === ".svg") && (s = t.download_url || "");
    const r = s, a = t.external_url, o = t.is_trashed ? "none" : t.preview_format, l = t.name, h = t.width, u = t.height, p = t.media_type, y = t.provider;
    return o === "image" ? v`<wy-preview-image
        src=${r}
        width=${Ot(h)}
        height=${Ot(u)}
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-image>` : o === "pdf" ? v`<wy-pdf-viewer src=${r} @file-preview-loaded=${() => this.dispatchLoaded()}></wy-pdf-viewer>` : o === "video" || o === "audio" ? v`<wy-preview-media
        format=${o}
        src=${r}
        name=${l}
        mediaType=${p}
        ?play=${this.current}
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-media>` : o === "text" ? v`<wy-preview-text src=${r} @file-preview-loaded=${() => this.dispatchLoaded()}></wy-preview-text>` : o === "code" ? v`<wy-preview-text
        src=${r}
        ?html=${!/^(?:blob:|data:)/.test(r)}
        code
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-text>` : o === "html" ? v`<wy-preview-text
        src=${r}
        html
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-text>` : o === "embed" ? v`<wy-preview-embed
        src=${r}
        name=${l}
        icon=${e}
        provider=${Ot(y)}
        @file-preview-loaded=${() => this.dispatchLoaded()}
      ></wy-preview-embed>` : o === "none" ? a ? v`<wy-preview-icon
            src=${a}
            icon=${e}
            provider=${Ot(y)}
            @file-preview-loaded=${() => this.dispatchLoaded()}
          ></wy-preview-icon>` : v`<wy-preview-icon
            src=${r}
            icon=${e}
            @file-preview-loaded=${() => this.dispatchLoaded()}
          ></wy-preview-icon>` : C;
  }
}, c(Uf, "wo"), Uf), d(rx, "WyPreviewItem"), rx);
mm.styles = [ft];
X4([
  O({ type: Object })
], mm.prototype, "file", 2);
X4([
  O({ type: Boolean })
], mm.prototype, "current", 2);
mm = X4([
  U("wy-preview-item")
], mm);
var PG = Object.defineProperty, QG = Object.getOwnPropertyDescriptor, R1 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? QG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && PG(t, e, s), s;
}, "__decorateClass$M"), ax, Hf;
let ml = (ax = (Hf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.small = !1, this.hasEventListener = {
      "edit-name": !1,
      subscribe: !1,
      trash: !1,
      restore: !1,
      "delete-forever": !1
    };
  }
  addEventListener(t, e, i) {
    if (this.hasEventListener) {
      const s = t;
      Object.prototype.hasOwnProperty.call(this.hasEventListener, s) && Object.assign(this.hasEventListener, {
        [s]: !0
      });
    }
    super.addEventListener(t, e, i);
  }
  /**
   * Open download URL for the current file.
   * @internal
   */
  triggerDownload() {
    this.file && as(this.file.download_url, "_top", this.file.name, !0);
  }
  /**
   * Open external provider URL for the current file.
   * @internal
   */
  triggerExternal() {
    this.file && as(this.file.external_url, "_blank", this.file.name);
  }
  /**
   * Open application-specific URL for the current file.
   * @internal
   */
  triggerApplication() {
    this.file && as(this.file.application_url, "_top", this.file.name);
  }
  /**
   * Emit an `edit-name` event for the current file.
   * @internal
   */
  dispatchEditName() {
    const t = new CustomEvent("edit-name", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `subscribe` event toggling subscription state.
   *
   * @internal
   * @param subscribe - Desired subscription setting.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", {
      detail: {
        file: this.file,
        subscribe: t
      }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `trash` event for the current file.
   * @internal
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `restore` event for the current file.
   * @internal
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `delete-forever` event for the current file.
   * @internal
   */
  dispatchDeleteForever() {
    const t = new CustomEvent("delete-forever", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  render() {
    if (!this.file)
      return C;
    const { icon: t } = lr(this.file.name), e = this.file.id >= 1, i = this.file.provider, s = this.file.provider || "app";
    return v`
      <wy-dropdown directionX="left" ?small=${this.small}>
        ${e && this.file.is_trashed ? v`
              ${this.hasEventListener.restore ? v`
                    <wy-dropdown-item @click=${() => this.dispatchRestore()}>
                      <wy-icon name="delete-restore"></wy-icon>
                      ${P("Restore")}
                    </wy-dropdown-item>
                  ` : C}
              ${this.hasEventListener.restore && this.hasEventListener["delete-forever"] ? v` <wy-dropdown-divider></wy-dropdown-divider> ` : C}
              ${this.hasEventListener["delete-forever"] ? v`
                    <wy-dropdown-item @click=${() => this.dispatchDeleteForever()}>
                      <wy-icon name="delete-forever"></wy-icon>
                      ${P("Delete")}
                    </wy-dropdown-item>
                  ` : C}
            ` : C}
        ${this.file.is_trashed ? C : v`
              ${this.file.external_url ? v`
                    <wy-dropdown-item @click=${() => this.triggerExternal()}>
                      <wy-icon name=${t}></wy-icon>
                      ${P(st`Open in ${i}`)}
                    </wy-dropdown-item>
                  ` : v`
                    ${this.componentFeatures?.allowsFeature(z.WebDAV) && this.file.application_url ? v`
                          <wy-dropdown-item @click=${() => this.triggerApplication()}>
                            <wy-icon
                              name=${this.file.provider ? xP(this.file.provider) : t}
                            ></wy-icon>
                            ${P(st`Open in ${s}`)}
                          </wy-dropdown-item>
                        ` : C}
                    <wy-dropdown-item @click=${() => this.triggerDownload()}>
                      <wy-icon name="download"></wy-icon>
                      ${P("Download")}
                    </wy-dropdown-item>
                  `}
              ${e ? v`
                    ${this.hasEventListener["edit-name"] ? v`
                          <wy-dropdown-item @click=${() => this.dispatchEditName()}>
                            <wy-icon name="textbox"></wy-icon>
                            ${P("Rename")}
                          </wy-dropdown-item>
                        ` : C}
                    ${this.hasEventListener.subscribe ? this.file.is_subscribed ? v`
                            <wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                              <wy-icon name="bell-off"></wy-icon>
                              ${P("Unsubscribe")}
                            </wy-dropdown-item>
                          ` : v`
                            <wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                              <wy-icon name="bell"></wy-icon>
                              ${P("Subscribe")}
                            </wy-dropdown-item>
                          ` : C}
                    ${this.hasEventListener.trash ? v`
                          <wy-dropdown-divider></wy-dropdown-divider>
                          <wy-dropdown-item @click=${() => this.dispatchTrash()}>
                            <wy-icon name="delete"></wy-icon>
                            ${P("Trash")}
                          </wy-dropdown-item>
                        ` : C}
                  ` : C}
            `}
        <slot></slot>
      </wy-dropdown>
    `;
  }
}, c(Hf, "fo"), Hf), d(ax, "WyFileMenu"), ax);
R1([
  Ve({ context: d0, subscribe: !0 }),
  F()
], ml.prototype, "componentFeatures", 2);
R1([
  O({ type: Object })
], ml.prototype, "file", 2);
R1([
  O({ type: Boolean })
], ml.prototype, "small", 2);
R1([
  O({ type: Object })
], ml.prototype, "hasEventListener", 2);
ml = R1([
  U("wy-file-menu"),
  St()
], ml);
function IW(n, t, e, i = {}) {
  return {
    ...i,
    initialPageParam: 0,
    queryKey: [t, e, "comments"],
    queryFn: /* @__PURE__ */ d(async (s) => {
      const r = s.pageParam, a = "/api/" + t + "/" + e + "/comments?order_by=id&skip=" + r, o = await (await n.fetch(a)).json();
      return o.data = o.data || [], o;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ d((s) => {
      if (s.end && s.end < s.count)
        return s.end;
    }, "getNextPageParam")
  };
}
c(IW, "d4");
d(IW, "getCommentsOptions");
function WW(n, t) {
  return {
    mutationFn: /* @__PURE__ */ d(async (e) => await (await n.fetch("/api/comments/" + e.id, {
      method: "PATCH",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        attachments: e.attachments,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ id: i.id, text: i.text })),
        embed_id: e.embed_id || null
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onSuccess: /* @__PURE__ */ d((e, i) => {
      i.id && ge(n.queryClient, [i.type, i.parent_id, "comments"], i.id, (s) => {
        s.text = e.text, s.html = e.html, s.attachments = e.attachments, s.meeting = e.meeting, s.updated_at = e.updated_at, s.updated_by = e.updated_by, s.options = e.options, s.embed = e.embed;
      });
    }, "onSuccess")
  };
}
c(WW, "h4");
d(WW, "getUpdateCommentMutationOptions");
function VW(n) {
  const t = n.queryClient;
  return {
    mutationFn: /* @__PURE__ */ d(async (e) => await (await n.fetch("/api/" + e.type + "/" + e.parent_id + "/comments", {
      method: "POST",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ text: i.text })),
        embed_id: e.embed_id,
        context: e.context
      })
    })).json(), "mutationFn"),
    onMutate: /* @__PURE__ */ d(async (e) => {
      const i = [e.type, e.parent_id, "comments"];
      await t.cancelQueries({ queryKey: i });
      const s = aa(n.queryClient, i, !1);
      if (e.user) {
        const r = {
          id: s ? s.id - 1 : -1,
          app: e.type === "apps" ? { id: e.parent_id } : { id: -1 },
          is_trashed: !1,
          text: e.text,
          html: e.text,
          plain: e.text,
          created_by: e.user,
          created_at: (/* @__PURE__ */ new Date()).toUTCString(),
          attachments: { count: 0 },
          reactions: { count: 0 },
          is_subscribed: !1,
          is_starred: !1
        };
        e.type === "files" ? r.parent = { type: ci.File, id: e.parent_id } : e.type === "posts" && (r.parent = { type: ci.Post, id: e.parent_id }), ra(t, i, r, { descending: !1 });
      }
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((e, i) => {
      const s = [i.type, e.parent?.id ?? e.app.id, "comments"];
      if (!w1(n.queryClient, s, e.id)) {
        const r = aa(n.queryClient, s, !0);
        r ? ge(n.queryClient, s, r.id, (a) => {
          a.id = e.id, a.app = e.app, a.text = e.text, a.html = e.html, a.embed = e.embed, a.meeting = e.meeting, a.attachments = e.attachments, a.options = e.options, a.created_at = e.created_at, a.created_by = e.created_by, a.updated_at = e.updated_at, a.updated_by = e.updated_by;
        }) : ra(n.queryClient, s, e), e.parent?.type === ci.Post && ge(t, ["posts", e.app.id], e.parent.id, (a) => {
          a.comments ? a.comments.count += 1 : a.comments = { count: 1 };
        });
      }
    }, "onSuccess")
  };
}
c(VW, "p4");
d(VW, "getAddCommentMutationOptions");
function DW(n, t, e) {
  const i = n.queryClient, s = {
    mutationKey: [t, e, "comments"],
    mutationFn: /* @__PURE__ */ d(async ({ id: r }) => {
      if (!(await n.fetch("/api/comments/" + r + "/trash", { method: "POST" })).ok)
        throw new Error();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((r) => {
      Ct(
        i,
        { queryKey: s.mutationKey, exact: !1 },
        r.id,
        (a) => Object.assign(a, { is_trashed: !0 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((r, a) => {
      Ct(
        i,
        { queryKey: s.mutationKey, exact: !1 },
        a.id,
        (o) => Object.assign(o, r)
      ), ge(i, [a.type, a.appId], a.parentId, (o) => {
        o.comments.count -= 1;
      });
    }, "onSuccess")
  };
  return s;
}
c(DW, "u4");
d(DW, "getTrashCommentMutationOptions");
function qW(n, t, e) {
  return new Xt(n.queryClient, DW(n, t, e));
}
c(qW, "y4");
d(qW, "getTrashCommentMutation");
function ZW(n, t, e) {
  const i = n.queryClient, s = {
    mutationKey: [t, e, "comments"],
    mutationFn: /* @__PURE__ */ d(async ({ id: r }) => {
      const a = await n.fetch("/api/comments/" + r + "/restore", { method: "POST" });
      if (!a.ok) {
        const o = await a.json();
        throw new Error(o.detail || o.title, { cause: o });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((r) => {
      Ct(
        i,
        { queryKey: s.mutationKey, exact: !1 },
        r.id,
        (a) => Object.assign(a, { is_trashed: !1 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((r, a) => {
      Ct(
        i,
        { queryKey: s.mutationKey, exact: !1 },
        a.id,
        (o) => Object.assign(o, r)
      ), ge(i, [a.type, a.appId], a.parentId, (o) => {
        o.comments.count += 1;
      });
    }, "onSuccess")
  };
  return s;
}
c(ZW, "w4");
d(ZW, "getRestoreCommentMutationOptions");
function FW(n, t, e) {
  return new Xt(n.queryClient, ZW(n, t, e));
}
c(FW, "f4");
d(FW, "getRestoreCommentMutation");
const N4 = et`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}:host(wy-comments){--wy-component-background-color: var(--wy-surface-container, var(--wy-surface-container-light, #eceef3));--wy-component-border-radius: var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-comment-list-padded]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-comments]{display:flex;flex-direction:column}[part~=wy-comment]{display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));margin-bottom:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-comment][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-comment-reveal]{interpolate-size:allow-keywords;overflow:hidden;transition:height var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),margin-bottom var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-duration-fast, .1s);height:auto;opacity:1}@starting-style{[part~=wy-comment-reveal]{height:0;margin-bottom:0;opacity:0}}[part~=wy-comment-skeleton]{transition-delay:var(--wy-transition-reveal-delay, 1s)}[part~=wy-comment-body]{display:flex;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));min-width:0;flex:1 1 100%}[part~=wy-comment-footer]{margin-left:calc(-1*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));margin-top:calc(-1*var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}::part(wy-trashed){text-decoration:line-through;color:var(--wy-outline, var(--wy-outline-light, #72777f))}wy-comment::part(wy-editor){padding-left:0;padding-right:0;margin-right:calc(-1*var(--wy-size, 1rem))}`, TG = 1e3 * 60 * 60, ox = TG * 24;
function ql(n, t, e, i = 7) {
  e ??= /* @__PURE__ */ new Date();
  const s = new Date(e.getFullYear(), e.getMonth(), e.getDate()), r = t.valueOf() - e.valueOf(), a = t.toDateString() === e.toDateString(), o = t.valueOf() > s.valueOf() - ox * i && t.valueOf() < s.valueOf() + ox * i;
  if (!a && o) {
    const l = Math.round(r / ox);
    return new Intl.RelativeTimeFormat(n, { numeric: "auto" }).format(l, "days");
  } else return a ? new Intl.DateTimeFormat(n, { timeStyle: "short" }).format(t) : new Intl.DateTimeFormat(n, { dateStyle: "short" }).format(t);
}
c(ql, "Wc");
d(ql, "relativeTime");
const XW = et`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}`;
var MG = Object.defineProperty, AG = Object.getOwnPropertyDescriptor, Zl = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? AG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && MG(t, e, s), s;
}, "__decorateClass$L"), lx, Yf;
let us = (lx = (Yf = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.location = "apps", this.highlight = !1, this.reveal = !1, this.editing = !1, this.previewAnnotationsRef = wt(), this.previewAttachmentsRef = wt(), this.highlightRef = wt(), this.updateCommentMutation = new An(this);
  }
  /**
   * Dispatch a poll vote event for this comment.
   *
   * @internal
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", {
      detail: { optionId: t, parentId: this.comment.id, parentType: "comments" }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Dispatch a trash event for this comment.
   *
   * @internal
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.comment.id } });
    return this.dispatchEvent(t);
  }
  /**
   * Dispatch a restore event for this comment.
   *
   * @internal
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", {
      detail: { id: this.comment.id }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Submit updated comment content via mutation and exit edit mode.
   *
   * @internal
   */
  updateComment(t) {
    this.updateCommentMutation.mutate({
      id: this.comment.id,
      type: this.location,
      parent_id: this.parentId,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      attachments: t.detail.attachments,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId
    }), this.editing = !1;
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("parentId") || t.has("weavy")) && this.parentId && this.weavy && await this.updateCommentMutation.trackMutation(
      WW(this.weavy, [this.location, this.parentId, "comments"])
    ), t.has("link") && (this.highlight = !!(this.link && P1(this.link, ci.Comment, { id: this.comment.id }))), t.has("highlight") && (this.highlight ? this.part.add("wy-highlight") : this.part.remove("wy-highlight"));
  }
  render() {
    const t = this.comment.attachments?.data?.filter((a) => a.kind === "image" && a.thumbnail_url) || [], e = this.comment.attachments?.data?.filter((a) => a.kind !== "image" || !a.thumbnail_url) || [], i = new Intl.DateTimeFormat(this.weavy?.locale, {
      dateStyle: "full",
      timeStyle: "short"
    }).format(new Date(this.comment.created_at)), s = ql(this.weavy?.locale, new Date(this.comment.created_at)), r = this.comment.id < 0;
    return v`
      <div part="wy-comment ${ut({ "wy-comment-reveal": this.reveal, "wy-comment-skeleton": r })}">
        ${r ? v`
              <wy-item align="top" part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src="${this.comment.created_by.avatar_url}"
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>
                <div slot="content" part="wy-comment-body">
                  <div part="wy-comment-title">
                    ${this.comment.created_by.name}
                    <small part="wy-meta">
                      ·
                      <time datetime=${this.comment.created_at} title=${i}>${s}</time>
                      ${this.comment.updated_at ? v`<time datetime=${this.comment.updated_at}> · ${P("edited")}</time>` : C}
                    </small>
                  </div>
                  ${this.comment.html ? v`<div part="wy-content"><wy-skeleton .text=${this.comment.text}></wy-skeleton></div>` : ""}
                </div>
              </wy-item>
            ` : this.comment.is_trashed ? v`
              <wy-item part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src="${this.comment.created_by.avatar_url}"
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>
                <span part="wy-trashed" slot="title">${P("Comment was trashed.")}</span>
                <wy-button small slot="actions" @click=${() => this.dispatchRestore()} color="variant"
                  >${P("Undo")}</wy-button
                >
              </wy-item>
            ` : this.editing ? v`
              <wy-item align="top" part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src="${this.comment.created_by.avatar_url}"
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>
                <wy-button small slot="actions" @click=${() => this.editing = !1} kind="icon">
                  <wy-icon name="close"></wy-icon>
                </wy-button>
                <div slot="content" part="wy-comment-body">
                  <div part="wy-comment-title">
                    ${this.comment.created_by.name}

                    <small part="wy-meta">
                      ·
                      <time datetime=${this.comment.created_at} title=${i}>${s}</time>
                    </small>
                  </div>
                  <wy-editor
                    editorLocation=${this.location}
                    .text=${this.comment.text}
                    .embed=${this.comment.embed}
                    .options=${this.comment.options?.data}
                    .attachments=${this.comment.attachments?.data ?? []}
                    .parentId=${this.comment.id}
                    .typing=${!1}
                    .draft=${!1}
                    placeholder=${P("Edit comment...")}
                    buttonText=${P("Update", { desc: "Button action to update" })}
                    @submit=${(a) => this.updateComment(a)}
                  ></wy-editor>
                </div>
              </wy-item>
            ` : v`
              <wy-item align="top" part="wy-comment-header">
                <wy-avatar
                  slot="image"
                  .src=${this.comment.created_by.avatar_url}
                  .size=${32}
                  .name=${this.comment.created_by.name}
                  .isAgent=${this.comment.created_by.is_agent}
                ></wy-avatar>

                ${this.user && this.user.id === this.comment.created_by.id ? v`
                      <wy-dropdown small slot="actions">
                        ${this.user.id === this.comment.created_by.id ? v`
                              <wy-dropdown-item @click=${() => this.editing = !0}>
                                <wy-icon name="pencil"></wy-icon>
                                ${P("Edit")}
                              </wy-dropdown-item>
                            ` : C}
                        ${this.user.id === this.comment.created_by.id ? v`
                              <wy-dropdown-item @click=${() => this.dispatchTrash()}>
                                <wy-icon name="trashcan"></wy-icon>
                                ${P("Trash")}
                              </wy-dropdown-item>
                            ` : C}
                      </wy-dropdown>
                    ` : C}

                <div slot="content" part="wy-comment-body">
                  <div part="wy-comment-title">
                    ${this.comment.created_by.name}
                    <small part="wy-meta">
                      ·
                      <time datetime=${this.comment.created_at} title=${i}>${s}</time>
                      ${this.comment.updated_at ? v`<time datetime=${this.comment.updated_at}> · ${P("edited")}</time>` : C}
                    </small>
                  </div>

                  <!-- image grid -->
                  ${t && t.length ? v`<wy-image-grid
                        part="wy-comment-images"
                        .images=${t}
                        @file-open=${(a) => {
      this.previewAttachmentsRef.value?.open(a.detail.fileId);
    }}
                      ></wy-image-grid>` : ""}

                  <!-- text content -->
                  ${this.comment.html ? v`<div part="wy-content">${ol(this.comment.html)}</div>` : ""}

                  <!-- annotations -->
                  ${this.comment.annotations?.data?.length ? v`<wy-annotation-list
                        .files=${this.comment.annotations.data}
                        @file-open=${(a) => {
      this.previewAnnotationsRef.value?.open(a.detail.fileId);
    }}
                      ></wy-annotation-list>` : C}

                  <!-- poll -->
                  ${this.comment.options?.data?.length ? v`
                        <wy-poll
                          .pollOptions=${this.comment.options.data}
                          @vote=${(a) => this.dispatchVote(a.detail.optionId)}
                        ></wy-poll>
                      ` : C}

                  <!-- embeds -->
                  ${this.comment.embed && this.componentFeatures?.allowsFeature(z.Embeds) ? v` <wy-embed .embed=${this.comment.embed}></wy-embed> ` : C}

                  <!-- files -->
                  ${e.length ? v`<wy-attachment-list
                        filled
                        .files=${e ?? []}
                        @file-open=${(a) => {
      this.previewAttachmentsRef.value?.open(a.detail.fileId);
    }}
                      ></wy-attachment-list>` : ""}

                  <!-- meeting -->
                  ${this.comment.meeting ? v`<wy-meeting-card .meeting=${this.comment.meeting}></wy-meeting-card>` : ""}

                  <div part="wy-comment-footer">
                    ${this.componentFeatures?.allowsFeature(z.Reactions) ? v` <wy-reactions
                          lineReverse
                          small
                          .reactions=${this.comment.reactions?.data}
                          parentType=${this.location}
                          parentId=${this.parentId}
                          entityId=${this.comment.id}
                          entityType="comments"
                        ></wy-reactions>` : C}
                    ${this.comment.annotations?.data?.length ? v`<wy-preview
                          ${ot(this.previewAnnotationsRef)}
                          .files=${this.comment.annotations.data}
                          .isAttachment=${!0}
                        ></wy-preview> ` : C}
                    ${this.comment.attachments?.data?.length ? v`<wy-preview
                          ${ot(this.previewAttachmentsRef)}
                          .files=${[...t, ...e]}
                          .isAttachment=${!0}
                        ></wy-preview> ` : C}
                  </div>
                </div>
              </wy-item>
            `}
      </div>
    `;
  }
  updated(t) {
    t.has("highlight") && this.highlight && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, c(Yf, "mo"), Yf), d(lx, "WyComment"), lx);
us.styles = [ne, N4, Rm, XW, D4, ft];
Zl([
  O({ type: Object, attribute: !1 })
], us.prototype, "comment", 2);
Zl([
  O({ type: Number })
], us.prototype, "parentId", 2);
Zl([
  O({ attribute: !1 })
], us.prototype, "location", 2);
Zl([
  F()
], us.prototype, "highlight", 2);
Zl([
  O({ type: Boolean, reflect: !0 })
], us.prototype, "reveal", 2);
Zl([
  F()
], us.prototype, "editing", 2);
us = Zl([
  U("wy-comment"),
  St()
], us);
const RG = et`[part~=wy-comment-editor]{position:relative;border-radius:var(--wy-padding-outer, var(--wy-padding, 0))}[part~=wy-comment-editor-bottom]{position:sticky;bottom:0;z-index:999;background-color:var(--wy-component-background-color);padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-radius:var(--wy-component-border-radius);color:var(--wy-component-color)}[part~=wy-comment-editor-inputs]{display:flex;flex-direction:row;align-items:flex-end;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-comment-editor-text]{flex:1 1 100%;display:flex;flex-direction:column}[part~=wy-editor-parts]{padding-top:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));min-height:0}[part~=wy-comment-editor] .cm-editor{flex:1 1 100%;max-height:calc(11.25*var(--wy-size, 1rem));background-color:var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:calc(1.25*var(--wy-size, 1rem));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid rgba(0,0,0,0);margin:calc(-1*var(--wy-input-border-width, var(--wy-border, 1px)))}[part~=wy-comment-editor] .cm-editor:focus{border-color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-comment-editor] .cm-editor .cm-content{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-comment-editor] [part~=wy-is-invalid]+.cm-editor,[part~=wy-comment-editor] [part~=wy-is-invalid] .cm-editor{border-color:var(--wy-error, var(--wy-error-light, #ba1821))!important}`;
var cx, $9;
function NW() {
  if ($9) return cx;
  $9 = 1;
  var n = "Expected a function", t = NaN, e = "[object Symbol]", i = /^\s+|\s+$/g, s = /^[-+]0x[0-9a-f]+$/i, r = /^0b[01]+$/i, a = /^0o[0-7]+$/i, o = parseInt, l = typeof sv == "object" && sv && sv.Object === Object && sv, h = typeof self == "object" && self && self.Object === Object && self, u = l || h || Function("return this")(), p = Object.prototype, y = p.toString, m = Math.max, g = Math.min, b = /* @__PURE__ */ d(function() {
    return u.Date.now();
  }, "now");
  function S(I, V, X) {
    var J, mt, at, G, $t, rt, Rt = 0, Qt = !1, It = !1, Vt = !0;
    if (typeof I != "function")
      throw new TypeError(n);
    V = R(V) || 0, Q(X) && (Qt = !!X.leading, It = "maxWait" in X, at = It ? m(R(X.maxWait) || 0, V) : at, Vt = "trailing" in X ? !!X.trailing : Vt);
    function Dt(Ut) {
      var vn = J, Ca = mt;
      return J = mt = void 0, Rt = Ut, G = I.apply(Ca, vn), G;
    }
    c(Dt, "Gt"), d(Dt, "invokeFunc");
    function xi(Ut) {
      return Rt = Ut, $t = setTimeout(te, V), Qt ? Dt(Ut) : G;
    }
    c(xi, "rt"), d(xi, "leadingEdge");
    function _e(Ut) {
      var vn = Ut - rt, Ca = Ut - Rt, jl = V - vn;
      return It ? g(jl, at - Ca) : jl;
    }
    c(_e, "gt"), d(_e, "remainingWait");
    function oe(Ut) {
      var vn = Ut - rt, Ca = Ut - Rt;
      return rt === void 0 || vn >= V || vn < 0 || It && Ca >= at;
    }
    c(oe, "ri"), d(oe, "shouldInvoke");
    function te() {
      var Ut = b();
      if (oe(Ut))
        return fe(Ut);
      $t = setTimeout(te, _e(Ut));
    }
    c(te, "qe"), d(te, "timerExpired");
    function fe(Ut) {
      return $t = void 0, Vt && J ? Dt(Ut) : (J = mt = void 0, G);
    }
    c(fe, "Li"), d(fe, "trailingEdge");
    function ki() {
      $t !== void 0 && clearTimeout($t), Rt = 0, J = rt = mt = $t = void 0;
    }
    c(ki, "Oi"), d(ki, "cancel");
    function Vi() {
      return $t === void 0 ? G : fe(b());
    }
    c(Vi, "Xc"), d(Vi, "flush");
    function nn() {
      var Ut = b(), vn = oe(Ut);
      if (J = arguments, mt = this, rt = Ut, vn) {
        if ($t === void 0)
          return xi(rt);
        if (It)
          return $t = setTimeout(te, V), Dt(rt);
      }
      return $t === void 0 && ($t = setTimeout(te, V)), G;
    }
    return c(nn, "ui"), d(nn, "debounced"), nn.cancel = ki, nn.flush = Vi, nn;
  }
  c(S, "I"), d(S, "debounce");
  function x(I, V, X) {
    var J = !0, mt = !0;
    if (typeof I != "function")
      throw new TypeError(n);
    return Q(X) && (J = "leading" in X ? !!X.leading : J, mt = "trailing" in X ? !!X.trailing : mt), S(I, V, {
      leading: J,
      maxWait: V,
      trailing: mt
    });
  }
  c(x, "A"), d(x, "throttle");
  function Q(I) {
    var V = typeof I;
    return !!I && (V == "object" || V == "function");
  }
  c(Q, "E"), d(Q, "isObject");
  function L(I) {
    return !!I && typeof I == "object";
  }
  c(L, "T"), d(L, "isObjectLike");
  function W(I) {
    return typeof I == "symbol" || L(I) && y.call(I) == e;
  }
  c(W, "q"), d(W, "isSymbol");
  function R(I) {
    if (typeof I == "number")
      return I;
    if (W(I))
      return t;
    if (Q(I)) {
      var V = typeof I.valueOf == "function" ? I.valueOf() : I;
      I = Q(V) ? V + "" : V;
    }
    if (typeof I != "string")
      return I === 0 ? I : +I;
    I = I.replace(i, "");
    var X = r.test(I);
    return X || a.test(I) ? o(I.slice(2), X ? 2 : 8) : s.test(I) ? t : +I;
  }
  return c(R, "R"), d(R, "toNumber"), cx = x, cx;
}
c(NW, "x4");
d(NW, "requireLodash_throttle");
var EG = NW();
const $S = /* @__PURE__ */ q_(EG);
function jW(n, t) {
  return new Xt(n.queryClient, {
    mutationFn: /* @__PURE__ */ d(async () => await n.fetch(`/api/apps/${t}/typing`, {
      method: "PUT",
      body: JSON.stringify({})
    }), "mutationFn")
  });
}
c(jW, "C4");
d(jW, "typingMutation");
function xS(n, t) {
  return new Xt(n.queryClient, {
    mutationFn: /* @__PURE__ */ d(async () => {
      const e = await n.fetch(`/x/${t}/meetings`, { method: "POST" });
      if (!e.ok)
        throw new Error("Failed to create meeting");
      return await e.json();
    }, "mutationFn")
  });
}
c(xS, "ff");
d(xS, "addMeetingMutation");
async function BW(n, t) {
  const e = await n.fetch("/api/blobs/external", { method: "POST", body: JSON.stringify(t) });
  if (!e.ok) {
    const i = await e.json();
    throw new Error(i.detail || i.title, { cause: i });
  }
  return await e.json();
}
c(BW, "k4");
d(BW, "externalBlob");
function UW(n, t, e, i) {
  const s = n.queryClient, r = ["apps", e, "blobs", i];
  return {
    mutationFn: /* @__PURE__ */ d(async (a) => await BW(n, a.externalBlob), "mutationFn"),
    mutationKey: r,
    onMutate: /* @__PURE__ */ d(async (a) => (await s.cancelQueries({ queryKey: r, exact: !0 }), { type: "attach", file: GP(void 0, a.externalBlob.name, a.externalBlob.size, void 0, t), status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ d((a, o, l) => {
      se(s, r, o, (h) => {
        h.status.state = "ok", h.status.progress = void 0, h.status.text = void 0;
      });
    }, "onSuccess"),
    onError(a, o, l) {
      const h = a.cause;
      h && h.status === 409 ? se(s, r, o, (u) => {
        u.status.state = "conflict", u.status.progress = void 0, u.status.text = h.detail || h.title;
      }) : se(s, r, o, (u) => {
        u && (u.status.state = "error", u.status.progress = void 0, u.status.text = h.detail || h.title);
      });
    }
  };
}
c(UW, "_4");
d(UW, "getExternalBlobMutationOptions");
function j4(n, t, e, i) {
  return new Xt(n.queryClient, UW(n, t, e, i));
}
c(j4, "Cv");
d(j4, "getExternalBlobMutation");
const _G = /(((https?|ftp):\/\/|(www|ftp)\.)[\w]+(.[\w]+)([\w\-.,@?^=%&amp;:/~+#]*[\w\-@?^=%&amp;/~+#]))/gim;
let Bc = [], e1 = [], kb = [], iO = [], Rs = {};
const zG = /* @__PURE__ */ d((n, t) => n.length === t.length && n.every((e, i) => e === t[i]), "arrayEquals");
function HW() {
  return !!Object.keys(Rs).length;
}
c(HW, "S4");
d(HW, "isFetchingEmbeds");
async function YW(n, t) {
  let e;
  try {
    const i = await t.fetch(`/api/embeds?url=${encodeURIComponent(n)}`);
    if (!i.ok)
      throw new Error();
    e = await i.json(), delete Rs[n], e1 = [...e1, n];
  } catch {
    kb = [...kb, n], delete Rs[n];
  }
  return e;
}
c(YW, "A4");
d(YW, "fetchEmbed");
const LG = /* @__PURE__ */ d(() => {
  Bc = [], e1 = [], kb = [], iO = [], Rs = {};
}, "clearEmbeds"), x9 = /* @__PURE__ */ d((n) => {
  e1 = n;
}, "initEmbeds"), IG = /* @__PURE__ */ d((n, t, e) => {
  let i = n.match(_G)?.map((s) => s) || null;
  if (i !== null && (i = i.map((s) => s.startsWith("//") ? "http:" + s : !s.startsWith("http://") && !s.startsWith("https://") ? "http://" + s : s)), !(i === null || i.length === 0) && (i.length !== Bc.length || !zG(i, Bc))) {
    Bc = i, i.forEach((s) => {
      !e1.includes(s) && !kb.includes(s) && !iO.includes(s) && typeof Rs[s] > "u" && (we(), Rs[s] = window.setTimeout(async () => {
        const r = await YW(s, e);
        r && t(r);
      }, 500));
    }), iO = iO.filter((s) => Bc.includes(s));
    for (const s in Rs)
      Bc.includes(s) || (we(), window.clearTimeout(Rs[s]), delete Rs[s]);
  }
}, "getEmbeds"), rn = Qb() ? window.navigator.userAgent : "", GW = rn.includes("iPad") || rn.includes("Android") && !rn.includes("Mobi") || !1, WG = rn.includes("Mobi") || GW || !1, VG = !WG && !GW, k9 = rn.includes("Windows") ? "Windows" : rn.includes("Macintosh") ? "Mac" : rn.includes("iPad") || rn.includes("iPhone") || rn.includes("iPod") ? "iOS" : rn.includes("Android") ? "Android" : void 0;
k9 === "Android" && rn.includes("; wv") || k9 === "iOS" && rn.includes("Safari");
const DG = et`[part~=wy-scroll-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;max-height:100%;overflow-x:hidden;overflow-anchor:none;touch-action:pan-y;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]:not(body){-webkit-overflow-scrolling:touch}[part~=wy-scroll-x-y]{overflow-x:auto;max-width:100%;overflow-y:hidden;overflow-anchor:none;touch-action:pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-scroll-x-y]{overflow-y:auto;overflow-x:auto;touch-action:pan-y,pan-x}[part~=wy-scroll-x-always],[part~=wy-scroll-y-always]{overflow-y:scroll}[part~=wy-code] pre,.wy-code pre,[part~=wy-editor] .cm-content pre{text-wrap:pretty}[part~=wy-code] .code,[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code .code,.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content .code,[part~=wy-editor] .cm-content code[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;word-wrap:break-word;line-height:1.25;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}@media print{[part~=wy-code] code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code code[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content code[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{text-shadow:none}}[part~=wy-code] pre[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}[part~=wy-code] :not(pre)>code[class*=language-],[part~=wy-code] pre[class*=language-],.wy-code :not(pre)>code[class*=language-],.wy-code pre[class*=language-],[part~=wy-editor] .cm-content :not(pre)>code[class*=language-],[part~=wy-editor] .cm-content pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));background:var(--wy-background, var(--wy-background-light, #f7f9ff))}[part~=wy-code] :not(pre)>code[class*=language-],.wy-code :not(pre)>code[class*=language-],[part~=wy-editor] .cm-content :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}[part~=wy-code] .token.variable,.wy-code .token.variable,[part~=wy-editor] .cm-content .token.variable{color:var(--wy-code-variable, var(--wy-code-variable-light, #001080))}[part~=wy-code] .token.operator,.wy-code .token.operator,[part~=wy-editor] .cm-content .token.operator{color:var(--wy-code-operator, var(--wy-code-operator-light, #000000))}[part~=wy-code] .token.prolog,.wy-code .token.prolog,[part~=wy-editor] .cm-content .token.prolog{color:var(--wy-code-prolog, var(--wy-code-prolog-light, #000080))}[part~=wy-code] .token.comment,.wy-code .token.comment,[part~=wy-editor] .cm-content .token.comment{color:var(--wy-code-comment, var(--wy-code-comment-light, #008000))}[part~=wy-code] .token.builtin,.wy-code .token.builtin,[part~=wy-editor] .cm-content .token.builtin{color:var(--wy-code-builtin, var(--wy-code-builtin-light, #0070C1))}[part~=wy-code] .token.number,.wy-code .token.number,[part~=wy-editor] .cm-content .token.number{color:var(--wy-code-number, var(--wy-code-number-light, #098658))}[part~=wy-code] .token.inserted,.wy-code .token.inserted,[part~=wy-editor] .cm-content .token.inserted{color:var(--wy-code-inserted, var(--wy-code-inserted-light, #098658))}[part~=wy-code] .token.constant,.wy-code .token.constant,[part~=wy-editor] .cm-content .token.constant{color:var(--wy-code-constant, var(--wy-code-constant-light, #811F3F))}[part~=wy-code] .token.hexcode,.wy-code .token.hexcode,[part~=wy-editor] .cm-content .token.hexcode{color:var(--wy-code-hexcode, var(--wy-code-hexcode-light, #811F3F))}[part~=wy-code] .token.regex,.wy-code .token.regex,[part~=wy-editor] .cm-content .token.regex{color:var(--wy-code-regex, var(--wy-code-regex-light, #811F3F))}[part~=wy-code] .token.char,.wy-code .token.char,[part~=wy-editor] .cm-content .token.char{color:var(--wy-code-char, var(--wy-code-char-light, #811F3F))}[part~=wy-code] .token.tag,.wy-code .token.tag,[part~=wy-editor] .cm-content .token.tag{color:var(--wy-code-tag, var(--wy-code-tag-light, #800000))}[part~=wy-code] .token.attr-name,.wy-code .token.attr-name,[part~=wy-editor] .cm-content .token.attr-name{color:var(--wy-code-attr-name, var(--wy-code-attr-name-light, #E50000))}[part~=wy-code] .token.selector,.wy-code .token.selector,[part~=wy-editor] .cm-content .token.selector{color:var(--wy-code-selector, var(--wy-code-selector-light, #E50000))}[part~=wy-code] .token.property,.wy-code .token.property,[part~=wy-editor] .cm-content .token.property{color:var(--wy-code-property, var(--wy-code-property-light, #E50000))}[part~=wy-code] .token.deleted,.wy-code .token.deleted,[part~=wy-editor] .cm-content .token.deleted{color:var(--wy-code-deleted, var(--wy-code-deleted-light, #A31515))}[part~=wy-code] .token.string,.wy-code .token.string,[part~=wy-editor] .cm-content .token.string{color:var(--wy-code-string, var(--wy-code-string-light, #A31515))}[part~=wy-code] .token.changed,.wy-code .token.changed,[part~=wy-editor] .cm-content .token.changed{color:var(--wy-code-changed, var(--wy-code-changed-light, #0451A5))}[part~=wy-code] .token.punctuation,.wy-code .token.punctuation,[part~=wy-editor] .cm-content .token.punctuation{color:var(--wy-code-punctuation, var(--wy-code-punctuation-light, #000000))}[part~=wy-code] .token.function,.wy-code .token.function,[part~=wy-editor] .cm-content .token.function{color:var(--wy-code-function, var(--wy-code-function-light, #0000FF))}[part~=wy-code] .token.keyword,.wy-code .token.keyword,[part~=wy-editor] .cm-content .token.keyword{color:var(--wy-code-keyword, var(--wy-code-keyword-light, #AF00DB))}[part~=wy-code] .token.class-name,.wy-code .token.class-name,[part~=wy-editor] .cm-content .token.class-name{color:var(--wy-code-class-name, var(--wy-code-class-name-light, #267F99))}[part~=wy-code] .token.important,[part~=wy-code] .token.bold,.wy-code .token.important,.wy-code .token.bold,[part~=wy-editor] .cm-content .token.important,[part~=wy-editor] .cm-content .token.bold{font-weight:700}[part~=wy-code] .token.italic,.wy-code .token.italic,[part~=wy-editor] .cm-content .token.italic{font-style:italic}[part~=wy-editor]{box-sizing:border-box}[part~=wy-editor] .cm-scroller{font-family:unset;line-height:1.5}[part~=wy-editor] .cm-widgetBuffer{vertical-align:unset}[part~=wy-editor] .cm-placeholder{pointer-events:none;color:var(--wy-outline, var(--wy-outline-light, #72777f))}[part~=wy-editor] .cm-content{caret-color:var(--wy-on-background, var(--wy-on-background-light, #181c20))}[part~=wy-editor] .cm-content ::part(wy-link){text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-light, #2f628c))}[part~=wy-editor] .wy-mention{font-weight:700}[part~=wy-editor] .cm-editor{box-sizing:border-box;flex-direction:column;position:relative!important;display:flex!important}[part~=wy-editor] .cm-editor.cm-focused{--wy-component-color: var(--wy-on-background, var(--wy-on-background-light, #181c20));color:var(--wy-component-color);border-color:var(--wy-primary, var(--wy-primary-light, #2f628c));outline:0}[part~=wy-editor] .cm-editor .cm-scroller{overflow:auto}[part~=wy-editor] .cm-editor .cm-line{display:block;padding:0px var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) 0px var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-editor] .cm-tooltip.cm-tooltip-autocomplete>ul{font-family:unset;max-height:calc(15*var(--wy-size, 1rem))}[part~=wy-editor] .cm-tooltip.cm-tooltip-autocomplete>ul>li{padding:0}[part~=wy-editor] .cm-tooltip{border:none;background-clip:padding-box;background-color:var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));overflow:hidden;z-index:1000}[part~=wy-editor] .cm-tooltip-autocomplete ul li[aria-selected] wy-item{background:var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));color:unset}[part~=wy-editor] .cm-tooltip-autocomplete .cm-completionLabel{display:none}[part~=wy-editor] .cm-tooltip-autocomplete ::part(wy-item-interactive):hover,[part~=wy-editor] .cm-tooltip-autocomplete ::part(wy-item-interactive):focus{background:var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb))}`, qG = et`[part~=wy-post-editor]{padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-editor-inputs]{display:flex;flex-direction:row;align-items:flex-end;justify-content:space-between;flex-wrap:wrap;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-editor-buttons]{display:flex;flex-direction:row;align-items:flex-end;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));flex:1 0 auto}[part~=wy-post-editor-text]{flex:1 1 100%;display:flex;flex-direction:column}[part~=wy-editor-parts]{display:flex;flex-direction:column;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));min-height:0}[part~=wy-post-editor] .cm-editor{flex:1 1 100%;max-height:11.25em;min-height:4em;background-color:var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid rgba(0,0,0,0);caret-color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-post-editor] .cm-editor:focus{border-color:var(--wy-primary, var(--wy-primary-light, #2f628c))}[part~=wy-post-editor] .cm-editor .cm-content{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-post-editor] .cm-editor .cm-line{padding:0}[part~=wy-post-editor] [part~=wy-is-invalid]+[data-editor-target] .cm-editor,[part~=wy-post-editor] [part~=wy-is-invalid] .cm-editor{border-color:var(--wy-error, var(--wy-error-light, #ba1821))!important}`, KW = et`[part~=wy-dragging]:after{content:attr(data-drag-title);background-color:#ffffff80;display:flex;justify-content:center;align-items:center;border:calc(.125*var(--wy-size, 1rem)) dashed var(--wy-outline, var(--wy-outline-light, #72777f));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));font-size:calc(1.5*var(--wy-size, 1rem));font-weight:var(--wy-font-weight-bold, 600);z-index:10000;position:absolute;inset:0}`;
var ZG = Object.defineProperty, FG = Object.getOwnPropertyDescriptor, Fl = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? FG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && ZG(t, e, s), s;
}, "__decorateClass$K"), hx, Gf;
let ps = (hx = (Gf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.status = {
      state: "ok"
    }, this.interactive = !1, this.rounded = !1, this.isRenaming = !1;
  }
  /**
   * Emit an `edit-name` event requesting rename mode for the provided file.
   *
   * @param file - File that should enter rename mode.
   * @returns Whether the event was not canceled.
   */
  dispatchEditName(t) {
    const e = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `rename` event with a new filename.
   *
   * @param file - File being renamed.
   * @param name - New filename to apply.
   * @returns Whether the event was not canceled.
   */
  dispatchRename(t, e) {
    const i = new CustomEvent("rename", { detail: { file: t, name: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit a `trash` event to move the file to the recycle bin.
   *
   * @param file - File slated for trashing.
   * @returns Whether the event was not canceled.
   */
  dispatchTrash(t) {
    const e = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `restore` event to recover the provided file.
   *
   * @param file - File to restore from trash.
   * @returns Whether the event was not canceled.
   */
  dispatchRestore(t) {
    const e = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `delete-forever` event to permanently remove the file.
   *
   * @param file - File targeted for permanent deletion.
   * @returns Whether the event was not canceled.
   */
  dispatchDeleteForever(t) {
    const e = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling subscription for the file.
   *
   * @param file - File whose subscription changes.
   * @param subscribe - Desired subscription state.
   * @returns Whether the event was not canceled.
   */
  dispatchSubscribe(t, e) {
    const i = new CustomEvent("subscribe", { detail: { file: t, subscribe: e } });
    return this.dispatchEvent(i);
  }
  render() {
    const t = this.file;
    if (!t) return C;
    const { icon: e } = lr(t.name), i = tn(t.name), s = /* @__PURE__ */ d((a) => {
      a.stopImmediatePropagation();
      const o = a.target;
      o.value && o.value !== t.name ? this.dispatchRename(t, o.value) : this.dispatchEditName({ id: NaN });
    }, "handleRename"), r = /* @__PURE__ */ d((a) => {
      const o = a.target;
      a.key === "Escape" ? (a.preventDefault(), o.value = t.name, o.blur()) : a.key === "Enter" && (a.preventDefault(), o.blur());
    }, "handleRenameKey");
    return v`
      <wy-item
        ?rounded=${this.rounded}
        ?interactive=${this.interactive && !t.is_trashed && !this.isRenaming}
        ?trashed=${t.is_trashed}
        title=${t.name}
        size="sm"
      >
        ${this.status.state === "error" ? v`<wy-icon
              slot="image"
              name="alert-octagon"
              color="error"
              title=${Ot(this.status.text)}
            ></wy-icon>` : this.status.state === "conflict" ? v`<wy-icon slot="image" name="alert" color="yellow" title=${Ot(this.status.text)}></wy-icon>` : v`<wy-icon slot="image" .name=${e} .size=${24} .kind=${t.kind} ext=${i}></wy-icon>`}
        ${this.isRenaming ? v`
              <input
                slot="title"
                type="text"
                maxlength="256"
                part="wy-input"
                .defaultValue=${t.name}
                @blur=${s}
                @keyup=${(a) => {
      Ys(a), r(a);
    }}
                @click=${(a) => a.preventDefault()}
                @focus=${g0}
                ${ot(PS)}
              />
            ` : v`
              <span slot="title" title=${t.name + (this.status.text ? `: ${this.status.text}` : "")}>
                <slot name="title"
                  >${this.title || t.name}${this.status.text ? v`: <em>${this.status.text}</em>` : C}</slot
                >
              </span>
            `}

        <slot slot="actions" name="actions">
          <wy-file-menu
            .file=${t}
            @edit-name=${(a) => this.dispatchEditName(a.detail.file)}
            @trash=${(a) => this.dispatchTrash(a.detail.file)}
            @restore=${(a) => this.dispatchRestore(a.detail.file)}
            @delete-forever=${(a) => this.dispatchDeleteForever(a.detail.file)}
            @subscribe=${(a) => this.dispatchSubscribe(a.detail.file, a.detail.subscribe)}
          >
          </wy-file-menu>
        </slot>
      </wy-item>
    `;
  }
}, c(Gf, "vo"), Gf), d(hx, "WyFileItem"), hx);
ps.styles = [$a];
Fl([
  O({ type: Object })
], ps.prototype, "file", 2);
Fl([
  O({ type: Object })
], ps.prototype, "status", 2);
Fl([
  O({ type: Boolean })
], ps.prototype, "interactive", 2);
Fl([
  O({ type: Boolean })
], ps.prototype, "rounded", 2);
Fl([
  O()
], ps.prototype, "actionType", 2);
Fl([
  F()
], ps.prototype, "isRenaming", 2);
ps = Fl([
  U("wy-file-item")
], ps);
const XG = /* @__PURE__ */ d((n) => {
  var p;
  var t, e, i, s, r, a, o, l, h, u;
  return u = (p = class extends n {
    /**
     * @constructor
     * @hideconstructor
     */
    constructor(...m) {
      super(...m), Z(this, s), Z(this, t, []), Z(this, e), Z(this, i, /* @__PURE__ */ new Set());
    }
    get eventParent() {
      return $(this, e);
    }
    set eventParent(m) {
      m?.eventChildren && m.eventChildren.add(this), _(this, e, m);
    }
    get eventChildren() {
      return $(this, i);
    }
    /**
     * Registers one or several event listeners. All event listeners are managed and automatically unregistered on destroy.
     *
     * When listening to weavy events, you may also listen to `before:` and `after:` events by simply adding the prefix to a weavy event.
     * Event handlers listening to weavy events may return modified data that is returned to the trigger. The data is passed on to the next event in the trigger event chain. If an event handler calls `event.stopPropagation()` or `return false`, the event chain will be stopped and the value is returned.
     *
     * @example <caption>Instance event</caption>
     * myInstance.on("before:options", function(options) { ... })
     * myInstance.on("options", function(options) { ... })
     * myInstance.on("after:options", function(options) { ... })
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#on
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string|Object} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     */
    on(...m) {
      const g = vt(this, s, h).call(this, m);
      if (m[3]) {
        const b = /* @__PURE__ */ d((...S) => {
          try {
            g.handler.apply(this, S);
          } catch {
            try {
              g.handler();
            } catch (x) {
              console.warn("Could not invoke one handler:", x);
            }
          }
          vt(this, s, o).call(this, g.events, g.selector, null, g.handler);
        }, "attachedHandler");
        vt(this, s, r).call(this, g.events, g.selector, b, g.handler);
      } else
        vt(this, s, r).call(this, g.events, g.selector, g.handler, g.handler);
    }
    /**
     * Registers one or several event listeners that are executed once. All event listeners are managed and automatically unregistered on destroy.
     *
     * Similar to {@link WeavyEvents#on}.
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#one
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string|Object} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {Function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     */
    one(m, g, b) {
      this.on(m, g, b, !0);
    }
    /**
     * Unregisters event listeners. The arguments must match the arguments provided on registration using .on() or .one().
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#off
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     * @returns {boolean} Was the handler removed?
     */
    off(...m) {
      const g = vt(this, s, h).call(this, m), b = vt(this, s, a).call(this, g.events, g.selector, g.handler);
      return vt(this, s, o).call(this, g.events, g.selector, b, g.handler);
    }
    /**
     * Clears all registered eventhandlers
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#clear
     */
    clearEventHandlers() {
      $(this, t).length = 0;
    }
    /**
     * Trigger a custom event. Events are per default triggered on the weavy instance using the weavy namespace.
     *
     * The trigger has an event chain that adds `before:` and `after:` events automatically for all events except when any custom `prefix:` is specified. This way you may customize the eventchain by specifying `before:`, `on:` and `after:` in your event name to fire them one at the time. The `on:` prefix will then be removed from the name when the event is fired.
     *
     * Eventhandlers listening to the event may return modified data that is returned by the trigger event. The data is passed on to the next event in the trigger event chain. If an event handler calls `event.stopPropagation()` or `return false`, the event chain will be stopped and the value is returned.
     *
     * @example
     * // Normal triggering
     * weavyEvents.triggerEvent("myevent");
     *
     * // Will trigger the following events on the root instance
     * // 1. before:myevent.event.weavy
     * // 2. myevent.event.weavy
     * // 3. after:myevent.event.weavy
     *
     * @example
     * // Custom triggering, one at the time
     * weavyEvents.triggerEvent("before:myevent");
     * weavyEvents.triggerEvent("on:myevent");
     * weavyEvents.triggerEvent("after:myevent");
     *
     * @example
     * // Advanced triggering with data handling
     *
     * function doSomething() {
     *     // Will trigger the events sequentially and check the response data in between
     *
     *     var myTriggerData = { counter: 123, label: "my label" };
     *
     *     // Custom triggering, one at the time
     *
     *     // 1. Trigger before: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("before:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("before:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     // ...
     *
     *     // 2. Continue with on: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("on:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("on:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     // ...
     *
     *     // 3. At last trigger after: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("after:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("after:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     console.log("myevent was fully executed", myTriggerData);
     *     return myTriggerData;
     * }
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#triggerEvent
     * @param {string} name - The name of the event.
     * @param {(Array/Object/JSON)} [data] - Data may be an array or plain object with data or a JSON encoded string.
     * @param {any} ...additionalData - Any raw extra data
     * @returns {data} The data passed to the event trigger including any modifications by event handlers. Returns false if the event is cancelled.
     */
    triggerEvent(m, g, ...b) {
      const S = /^(before|on|after):/.test(m), x = S ? m.split(":")[0] : "";
      m = m.replace(/^(before|on|after):/, "");
      const Q = "before:" + m, L = m, W = "after:" + m;
      if (g && typeof g == "string")
        try {
          g = JSON.parse(g);
        } catch {
          console.warn("Could not parse event data", m, g);
        }
      let R;
      if (S) {
        if (x === "before" || x === "after") {
          if ($(this, e) && (R = $(this, e).triggerEvent(
            x === "before" ? Q : W,
            g,
            ...b
          ), g = R || R === !1 ? R : g, g === !1) || (R = vt(this, s, l).call(this, x === "before" ? Q : W, g, ...b), g = R || R === !1 ? R : g, g === !1))
            return g;
        } else if (x === "on" && (R = vt(this, s, l).call(this, L, g, ...b), g = R || R === !1 ? R : g, g === !1 || $(this, e) && (R = $(this, e).triggerEvent("on:" + L, g, ...b), g = R || R === !1 ? R : g, g === !1)))
          return g;
      } else {
        if ($(this, e) && (R = $(this, e).triggerEvent(Q, g, ...b), g = R || R === !1 ? R : g, g === !1) || (R = vt(this, s, l).call(this, Q, g, ...b), g = R || R === !1 ? R : g, g === !1) || (R = vt(this, s, l).call(this, L, g, ...b), g = R || R === !1 ? R : g, g === !1) || $(this, e) && (R = $(this, e).triggerEvent("on:" + L, g, ...b), g = R || R === !1 ? R : g, g === !1) || $(this, e) && (R = $(this, e).triggerEvent(W, g, ...b), g = R || R === !1 ? R : g, g === !1))
          return g;
        R = vt(this, s, l).call(this, W, g, ...b), g = R || R === !1 ? R : g;
      }
      return g;
    }
  }, c(p, "f"), p), t = /* @__PURE__ */ new WeakMap(), e = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakSet(), /**
  * Saves a single event handler.
  *
  * @internal
  * @function
  * @param {string} event - One or more events. Multiple events are currently not registered individually.
  * @param {string|Object} [selector] - Optional refinement selector
  * @param {function} handler - The handler function. may be wrapped for once-handlers
  * @param {function} originalHandler - The original non-wrapped event handler.
  */
  r = /* @__PURE__ */ d(function(y, m, g, b) {
    $(this, t).push({
      events: y,
      selector: m,
      handler: g,
      originalHandler: b
    });
  }, "#registerEventHandler"), /**
  * Returns the event handler or wrapped event handler. The arguments must match the registered event handler.
  *
  * @internal
  * @function
  * @param {string} events - The events registered
  * @param {string|Object} [selector] - The optional selector for the handler.
  * @param {function} handler - The registered handler
  * @param {function} [originalHandler] - The original registered handler
  */
  a = /* @__PURE__ */ d(function(y, m, g, b) {
    const S = {
      events: y,
      selector: m,
      handler: g,
      originalHandler: b || g
    }, x = $(this, t).filter((Q) => so(S, Q, !0)).pop();
    return x && x.handler;
  }, "#getEventHandler"), /**
  * Unregister an event handler. Arguments must match the registered event handler.
  *
  * @internal
  * @function
  * @param {string} event - The events registered
  * @param {function} handler - The registered handler
  * @param {string|Object} [selector] - The optional selector for the handler.
  * @returns {boolean} - True if any handler was removed
  */
  o = /* @__PURE__ */ d(function(y, m, g, b) {
    const S = {
      events: y,
      selector: m,
      handler: g,
      originalHandler: b
    };
    let x = !1;
    return $(this, t).forEach((Q, L) => {
      so(S, Q, !0) && (x = !0, $(this, t).splice(L, 1));
    }), x;
  }, "#unregisterEventHandler"), /**
  * Triggers any local event handlers registered. Each handler may modify the data and return it or return false to cancel the event chain. .stopPropagation() and .preventDefault() may also be used.
  *
  * @example
  * weavyEvents.on("myevent", function(e, data) { ... })
  *
  * triggerHandler(this, "myevent", { key: 1 })
  *
  * @internal
  * @function
  * @param {any} eventName - The name of the event. Event names without prefix will also trigger handlers with the "on:" prefix.
  * @param {any} data - Any data to pass to the handler
  * @param {any} ...additionalData - Any extra data
  */
  l = /* @__PURE__ */ d(function(y, m, ...g) {
    let b = !1;
    return $(this, t).forEach((S) => {
      S.events.split(" ").forEach((x) => {
        if (x = x.indexOf("on:") === 0 ? x.split("on:")[1] : x, y === x && (!S.selector || so(S.selector, m, !0))) {
          const Q = S.handler(m, ...g);
          Q ? m = Q : Q === !1 && (b = !0);
        }
      });
    }), b ? !1 : m;
  }, "#triggerHandler"), /**
  * Extracts and normalizes all parts of the events arguments.
  *
  * @internal
  * @function
  * @param {Array.<Object>} eventArguments - The function argument list: `[context], events, [selector], handler`
  * @returns {Object}
  * @property {string} events - Event names with added namespace for local events.
  * @property {string|Object} selector - The optional selector.
  * @property {function} handler - The handler function
  * @
  */
  h = /* @__PURE__ */ d(function(y) {
    const m = typeof y[1] == "function" ? y[1] : y[2], g = typeof y[1] == "function" ? null : y[1];
    return { events: y[0], selector: g, handler: m };
  }, "#getEventArguments"), d(u, "WeavyEvents"), u;
}, "MixinWeavyEvents"), NG = XG(class {
});
function kS(n) {
  let t = "";
  try {
    t = /^((?:https?:\/\/[^/]+)|(?:file:\/\/))\/?/.exec(n)?.[1] || "";
  } catch {
    console.error(
      "Unable to resolve location origin. Make sure you are using http, https or file protocol and have a valid location URL."
    );
  }
  return t;
}
c(kS, "gf");
d(kS, "extractOrigin");
var Kf;
const JW = (Kf = class extends NG {
  constructor(t = {}) {
    super(), this.contentWindows = /* @__PURE__ */ new Set(), this.contentWindowsMapByWeavyId = /* @__PURE__ */ new Map(), this.contentWindowOrigins = /* @__PURE__ */ new WeakMap(), this.contentWindowNames = /* @__PURE__ */ new WeakMap(), this.contentWindowWeavyIds = /* @__PURE__ */ new WeakMap(), this.contentWindowDomain = /* @__PURE__ */ new WeakMap(), this.origin = Qb() ? kS(window.location.href) : "", this.timeout = 2e3, t?.timeout && (this.timeout = t.timeout), window.addEventListener("message", (e) => {
      if (e.data.name && e.data.weavyId !== void 0) {
        if (e.data.weavyMessageId && e.data.name !== "message-receipt" && e.data.name !== "unready")
          try {
            e.source?.postMessage(
              { name: "message-receipt", weavyId: e.data.weavyId, weavyMessageId: e.data.weavyMessageId },
              { targetOrigin: e.origin }
            );
          } catch {
            console.error("could not post back message-receipt to source");
          }
        switch (e.data.name) {
          case "register-child": {
            if ((!e.source || !this.contentWindowWeavyIds.has(e.source)) && console.warn("register-child: contentWindow not pre-registered", e.source), e.source && this.contentWindowOrigins.get(e.source) !== e.origin) {
              console.error(
                "register-child: " + this.contentWindowNames.get(e.source) + " has invalid origin",
                e.origin
              );
              return;
            }
            try {
              const i = e.source ? this.contentWindowWeavyIds.get(e.source) : void 0, s = e.source ? this.contentWindowNames.get(e.source) : void 0;
              s && e.source && e.source.postMessage(
                {
                  name: "register-window",
                  windowName: s,
                  weavyId: i || !0
                },
                { targetOrigin: e.origin }
              );
            } catch (i) {
              console.error("could not register frame window", i);
            }
            break;
          }
          case "ready": {
            e.source && this.contentWindowsMapByWeavyId.has(e.data.weavyId) && this.contentWindowNames.has(e.source) && this.contentWindowsMapByWeavyId.get(e.data.weavyId)?.get(this.contentWindowNames.get(e.source)) && (this.contentWindowDomain.set(e.source, e.origin), this.distributeMessage(e));
            break;
          }
          case "unready": {
            this.contentWindowsMapByWeavyId.has(e.data.weavyId) && this.distributeMessage(e, !0);
            break;
          }
          default: {
            (e.source === window || this.contentWindowsMapByWeavyId.size) && this.distributeMessage(e);
            break;
          }
        }
      }
    });
  }
  /**
   * The weavy console logging.
   */
  get console() {
    return console;
  }
  distributeMessage(t, e = !1) {
    const i = t.source === window && t.origin === this.origin;
    if (e ||= t.source && this.contentWindowOrigins.has(t.source) && t.origin === this.contentWindowOrigins.get(t.source) || !1, i || e) {
      e && !t.data.windowName && t.source && (t.data.windowName = this.contentWindowNames.get(t.source));
      const s = t.data.name;
      s && this.triggerEvent(s, t.data, t), this.triggerEvent("message", t.data, t);
    }
  }
  /**
   * Sends the id of a frame to the frame content scripts, so that the frame gets aware of which id it has.
   * The frame needs to have a unique name attribute.
   *
   * @category panels
   * @param {string} weavyId - The id of the group or entity which the contentWindow belongs to.
   * @param {Window} contentWindow - The frame window to send the data to.
   */
  registerContentWindow(t, e, i, s) {
    try {
      if (!e) {
        console.error("registerContentWindow() No valid contentWindow to register, must be a window and have a name.");
        return;
      }
    } catch {
      console.error("registerContentWindow() cannot access contentWindowName");
    }
    t.self && (t = t.self), this.console.log("registerContentWindow", t), (!i || i === "true") && (i = !0), this.contentWindowsMapByWeavyId.has(i) || this.contentWindowsMapByWeavyId.set(i, /* @__PURE__ */ new Map()), this.contentWindowsMapByWeavyId.get(i)?.set(e, t), this.contentWindows.add(t), this.contentWindowNames.set(t, e), this.contentWindowWeavyIds.set(t, i), this.contentWindowOrigins.set(t, s);
  }
  unregisterAll(t) {
    this.contentWindowsMapByWeavyId.has(t) && (this.contentWindowsMapByWeavyId.get(t)?.forEach((e, i) => {
      this.unregisterContentWindow(i, t);
    }), this.contentWindowsMapByWeavyId.get(t), this.contentWindowsMapByWeavyId.delete(t));
  }
  unregisterContentWindow(t, e) {
    if (this.contentWindowsMapByWeavyId.has(e)) {
      if (this.contentWindowsMapByWeavyId.get(e)?.has(t)) {
        const i = this.contentWindowsMapByWeavyId.get(e)?.get(t);
        if (i)
          try {
            this.contentWindows.delete(i), this.contentWindowNames.delete(i), this.contentWindowWeavyIds.delete(i), this.contentWindowOrigins.delete(i);
          } catch {
          }
      }
      if (this.contentWindowsMapByWeavyId.get(e)?.delete(t), this.contentWindowsMapByWeavyId.get(e)?.size === 0)
        try {
          this.contentWindowsMapByWeavyId.delete(e);
        } catch {
        }
    }
  }
  async whenPostMessage(t, e, i) {
    we(), i === null && (i = void 0);
    const s = t === window.self, r = s ? kS(window.location.href) : this.contentWindowOrigins.get(t);
    if (s || t && r === this.contentWindowDomain.get(t)) {
      e.weavyMessageId || (e.weavyMessageId = sm() + sm());
      let a;
      await Promise.race([
        new Promise((o, l) => {
          a = window.setTimeout(() => {
            l(new Error("postMessage() receipt timed out: " + e.weavyMessageId + ", " + e.name));
          }, this.timeout || 2e3);
        }),
        new Promise((o) => {
          this.on("message-receipt", { weavyId: e.weavyId, weavyMessageId: e.weavyMessageId }, () => {
            clearTimeout(a), o(void 0);
          }), t.postMessage(e, { targetOrigin: r, transfer: i });
        })
      ]);
    } else
      throw new Error("postMessage() Invalid window origin: " + r + ", " + e.name);
  }
  postToChildren(t, e) {
    if (typeof t != "object" || !t.name) {
      console.error("postToChildren() Invalid message format", t);
      return;
    }
    e === null && (e = void 0), t.distributeName = t.name, t.name = "distribute", t.weavyId = t.weavyId || !0, this.contentWindows.forEach((i) => {
      const s = this.contentWindowOrigins.get(i);
      if (s === this.contentWindowDomain.get(i))
        try {
          i.postMessage(t, { targetOrigin: s, transfer: e });
        } catch {
          console.warn(
            "postToChildren() could not distribute message to " + this.contentWindowNames.get(i)
          );
        }
    });
  }
  async postToFrame(t, e, i, s) {
    if (typeof i != "object" || !i.name) {
      console.error("postToFrame() Invalid message format", i);
      return;
    }
    const r = this.contentWindowsMapByWeavyId.get(e)?.get(t);
    if (!r)
      throw new Error(`postToFrame() Window not registered: ${e}, ${t}`);
    return i.weavyId = e, await this.whenPostMessage(r, i, s);
  }
  async postToSelf(t, e) {
    if (typeof t != "object" || !t.name) {
      console.error("postToSelf() Invalid message format", t);
      return;
    }
    return t.weavyId = t.weavyId || !0, await this.whenPostMessage(window.self, t, e);
  }
  postToSource(t, e, i) {
    if (t.source && t.data.weavyId !== void 0) {
      const s = t.source === window.self && t.origin === this.origin, r = this.contentWindowOrigins.has(t.source) && t.origin === this.contentWindowOrigins.get(t.source);
      if (i === null && (i = void 0), s || r) {
        e.weavyId = t.data.weavyId;
        try {
          t.source.postMessage(e, { targetOrigin: t.origin, transfer: i });
        } catch (a) {
          console.error("postToSource() Could not post message back to source", a);
        }
      }
    }
  }
}, c(Kf, "gw"), Kf);
d(JW, "WeavyPostalParent");
let jG = JW;
var BG = Object.defineProperty, UG = Object.getOwnPropertyDescriptor, D0 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? UG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && BG(t, e, s), s;
}, "__decorateClass$J"), dx, Jf;
let gl = (dx = (Jf = class extends zi {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.iframeVisible = !1, this.showOverlay = !1, this.isRegistered = !1, this.iframeElementRef = wt(), this.overlayRef = wt();
  }
  /**
   * Open the file picker overlay.
   */
  open() {
    this.showOverlay = !0;
  }
  /**
   * Close the file picker overlay.
   */
  close() {
    this.showOverlay = !1, this.iframeVisible = !1;
  }
  /**
   * Returns the topmost available window/frame origin used when building the iframe src.
   *
   * @internal
   */
  get origin() {
    let t = "";
    try {
      window.location.ancestorOrigins && 0 < window.location.ancestorOrigins.length ? t = window.location.ancestorOrigins[window.location.ancestorOrigins.length - 1] : window.top && (t = window.top.document.location.origin);
    } catch {
    }
    if (!t)
      try {
        t = window.self.document.location.origin;
      } catch {
        console.error("Filebrowser: Could not read current origin.");
      }
    return t;
  }
  /**
   * Trigger `external-blobs` event with any selected blobs.
   *
   * @internal
   * @param {ExternalBlobType[] | null} externalBlobs - The externally selected blobs.
   * @returns {boolean} Whether the event was successful.
   */
  dispatchExternalBlobs(t) {
    const e = new CustomEvent("external-blobs", {
      detail: { externalBlobs: t }
    });
    return this.dispatchEvent(e);
  }
  connectedCallback() {
    super.connectedCallback(), this.handleFiles = (t, e) => {
      e.source === this.iframeElementRef.value?.contentWindow?.self && (this.dispatchExternalBlobs(t.blobs), this.close());
    }, this.handleClose = (t, e) => {
      e.source === this.iframeElementRef.value?.contentWindow?.self && this.close();
    }, this.handleGoogleSelected = (t, e) => {
      e.source === this.iframeElementRef.value?.contentWindow?.self && this.overlayRef.value && (this.overlayRef.value.maximized = !0);
    }, this.weavyPostal || (this.weavyPostal = new jG()), this.weavyPostal.on("add-external-blobs", this.handleFiles), this.weavyPostal.on("request:file-browser-close", this.handleClose), this.weavyPostal.on("google-selected", this.handleGoogleSelected);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.weavyPostal?.off("add-external-blobs", this.handleFiles), this.weavyPostal?.off("request:file-browser-close", this.handleClose), this.weavyPostal?.off("google-selected", this.handleGoogleSelected);
  }
  updated() {
    this.weavy && (this.showOverlay && !this.src && (this.src = new URL(
      "?origin=" + this.origin + "&v=X&t=" + Date.now().toString() + "&weavyId=wy-filebrowser",
      this.weavy.cloudFilePickerUrl
    )), this.weavyPostal && !this.isRegistered && this.showOverlay && this.src ? this.iframeElementRef.value?.contentWindow && (this.weavyPostal.registerContentWindow(
      this.iframeElementRef.value?.contentWindow.self,
      "weavy-filebrowser",
      "wy-filebrowser",
      this.src.origin
    ), this.isRegistered = !0) : this.weavyPostal && this.isRegistered && !this.showOverlay && this.src && (this.weavyPostal.unregisterContentWindow("weavy-filebrowser", "wy-filebrowser"), this.isRegistered = !1, this.src = void 0));
  }
  render() {
    return this.weavy ? v`
      <wy-overlay
        ?noHeader=${this.iframeVisible}
        part="wy-cloud-files-overlay"
        .show=${this.showOverlay}
        ${ot(this.overlayRef)}
        @close=${() => this.close()}
      >
        ${this.showOverlay ? v`
              <wy-progress-circular
                part="wy-cloud-files-progress"
                indeterminate
                overlay
                ?hidden=${this.iframeVisible}
              ></wy-progress-circular>
              <iframe
                part="wy-cloud-picker-frame"
                ${ot(this.iframeElementRef)}
                @load=${() => this.iframeVisible = !0}
                src=${Ot(this.src?.toString())}
                id="weavy-filebrowser"
                name="weavy-filebrowser"
                title=${P("Cloud File Browser")}
              ></iframe>
            ` : C}
      </wy-overlay>
    ` : C;
  }
}, c(Jf, "go"), Jf), d(dx, "WyCloudFiles"), dx);
gl.styles = [
  ft,
  et`
      [part~="wy-cloud-picker-frame"] {
        flex: 1 1 100%;
        border: 0;
      }
    `
];
D0([
  F()
], gl.prototype, "src", 2);
D0([
  F()
], gl.prototype, "iframeVisible", 2);
D0([
  F()
], gl.prototype, "showOverlay", 2);
gl = D0([
  U("wy-cloud-files"),
  St()
], gl);
var HG = Object.defineProperty, YG = Object.getOwnPropertyDescriptor, Jt = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? YG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && HG(t, e, s), s;
}, "__decorateClass$I"), ux, ty;
let Wt = (ux = (ty = class extends Oe {
  constructor() {
    super(), this.exportParts = new Y(this), this.storage = CP("localStorage"), this.disabled = !1, this._placeholder = "", this.text = "", this.metadata = {}, this.options = [], this.attachments = [], this.buttonText = "", this.typing = !0, this.draft = !1, this.editorType = "posts", this.editorClass = "wy-post-editor", this.editorLocation = "apps", this.editorError = !1, this.showPolls = !1, this.pollOptions = [], this._embeds = [], this.draftKey = "", this.uploadBlobMutation = new An(
      this
    ), this.mutatingFiles = new w0(this), this.fileInputRef = wt(), this.cloudFilesRef = wt(), this.dropZone = new VL(this), this.keyMap = [], this.editorRef = wt(), this.editorInitialized = !1, this.throttledTyping = $S(
      async () => {
        this.weavy && this.app && !hb.has(this.app.type) && await jW(this.weavy, this.app.id).mutate();
      },
      2e3,
      { leading: !0, trailing: !1 }
    ), this.throttledDrafting = $S(
      () => {
        this.saveDraft();
      },
      500,
      { leading: !0, trailing: !0 }
    ), this.openFileInput = () => {
      this.fileInputRef.value?.click();
    }, this.openCloudFiles = () => {
      this.cloudFilesRef.value?.open();
    }, this.createMeeting = async (t) => {
      if (this.weavy && t.source === this.authWindow && this.weavy.url.origin === t.origin && t.data && t.data.name && t.data.name.endsWith("-authorized")) {
        const e = t.data.name.slice(0, -11), i = await xS(this.weavy, e).mutate();
        i.auth_url || (this.meeting = i);
      }
    }, this.addEventListener("drop-files", (t) => this.handleDropFiles(t)), this.addEventListener("keydown", Vw), this.addEventListener("keyup", Ys);
  }
  set placeholder(t) {
    this._placeholder = t;
  }
  get placeholder() {
    return this._placeholder;
  }
  /**
   * Select all content in the editor.
   *
   * @internal
   */
  selectAllContent() {
    this.editor?.dispatch({
      selection: {
        anchor: 0,
        head: this.editor.state.doc.length
      }
    });
  }
  /**
   * Place cursor at the end of the editor content.
   *
   * @internal
   */
  setCursorLast() {
    this.editor?.dispatch({
      selection: {
        anchor: this.editor.state.doc.length,
        head: this.editor.state.doc.length
      }
    });
  }
  /**
   * Focus the editor input.
   *
   * @internal
   */
  focusInput() {
    this.editor?.focus();
  }
  set embeds(t) {
    const e = t.filter((i) => i.type !== "link" || i.title || i.description);
    this._embeds = [...e];
  }
  get embeds() {
    return this._embeds;
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("app") && (this.mutationAppId = void 0), (t.has("weavy") || t.has("app") || t.has("user") || t.has("parentId")) && this.weavy && this.app && this.user) {
      if (this.mutationAppId = this.mutationAppId ?? this.app?.id ?? Date.now() * -1, this.draftKey = `draft-${this.editorType}-${this.parentId || this.mutationAppId}`, this.uploadBlobMutation.trackMutation(
        v0(
          this.weavy,
          this.user,
          this.mutationAppId,
          `${this.editorLocation}-${this.parentId || this.mutationAppId}`
        )
      ), this.mutatingFiles.trackMutationState(
        {
          filters: {
            mutationKey: [
              "apps",
              this.mutationAppId,
              "blobs",
              `${this.editorLocation}-${this.parentId || this.mutationAppId}`
            ],
            exact: !0
          }
        },
        this.weavy.queryClient
      ), this.externalBlobMutation = j4(
        this.weavy,
        this.user,
        this.mutationAppId,
        `${this.editorLocation}-${this.parentId || this.mutationAppId}`
      ), this.draft && this.storage) {
        const e = this.storage.getItem(this.draftKey);
        if (e) {
          const i = JSON.parse(e);
          this.text = i.text, this.embeds = i.embeds, this.meeting = i.meeting, i.pollOptions?.length > 0 && (this.showPolls = !0, this.pollOptions = i.pollOptions), x9(this.embeds.map((s) => s.url).filter((s) => typeof s == "string"));
        } else
          this.clearEditor();
      }
      this.embed && (this.embeds = [this.embed], x9(this.embeds.map((e) => e.url).filter((e) => typeof e == "string"))), this.options && this.options.length > 0 && (this.pollOptions = this.options, this.showPolls = !0);
    }
    t.has("text") && this.editor && this.editor.state.doc.toString() !== this.text && this.editor.dispatch({ changes: { from: 0, to: this.editor.state.doc.length, insert: this.text } });
  }
  updated(t) {
    if ((t.has("weavy") || t.has("app") || t.has("user") || t.has("parentId")) && this.weavy && this.user && this.editorRef.value && this.weavy.whenUrl().then(() => {
      import(
        /* webpackIgnore: true */
        /* @vite-ignore */
        new URL("./es/editor-M1x0pxVu.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
      ).then((e) => e.editor).then(
        ({
          weavyHighlighter: e,
          syntaxHighlighting: i,
          history: s,
          dropCursor: r,
          mentions: a,
          autocompletion: o,
          placeholder: l,
          keymap: h,
          weavyKeymap: u,
          defaultKeymap: p,
          historyKeymap: y,
          markdown: m,
          languages: g,
          EditorView: b,
          EditorState: S,
          weavyEnterSendKeymap: x,
          weavyModifierEnterSendKeymap: Q,
          Compartment: L
        }) => {
          this.editorInitialized || (this.editorInitialized = !0, this.editorEditable = new L(), this.editorPlaceholder = new L(), this.editorKeymap = new L(), this.EditorView = b, this.placeholderExtension = l, this.keymapFacet = h, this.keymaps = {
            weavyEnterSendKeymap: x,
            weavyModifierEnterSendKeymap: Q,
            weavyKeymap: u,
            defaultKeymap: [...p],
            historyKeymap: [...y]
          }, this.editorExtensions = [
            b.contentAttributes.of({
              spellcheck: "true",
              autocorrect: "on",
              autocapitalize: "on",
              enterkeyhint: this.settings?.enterToSend === "always" ? "send" : "enter"
            }),
            s(),
            r(),
            a,
            o({
              override: this.componentFeatures?.allowsFeature(z.Mentions) ? [(W) => this.autocomplete(W)] : [],
              //showMention
              closeOnBlur: !1,
              aboveCursor: this.editorType !== "posts",
              icons: !1,
              addToOptions: [
                {
                  render: /* @__PURE__ */ d(function(W, R) {
                    const I = document.createElement("wy-item");
                    I.interactive = !1, (!W.item?.access || W.item.access === kr.None) && (I.disabled = !0);
                    const V = document.createElement("wy-avatar");
                    V.slot = "image", V.src = W.item?.avatar_url || "", V.name = W.item?.name || "";
                    const X = document.createElement("span");
                    return X.slot = "title", X.innerText = W.item?.name || "", I.appendChild(V), I.appendChild(X), I;
                  }, "render"),
                  position: 10
                }
              ]
            }),
            i(e, { fallback: !0 }),
            b.lineWrapping,
            m({ codeLanguages: g }),
            b.domEventHandlers({
              paste: /* @__PURE__ */ d((W, R) => {
                let I = [];
                const V = W.clipboardData?.items || [];
                for (const X of V)
                  if (X.kind === "file") {
                    const J = X.getAsFile();
                    J && (I = [...I, J]);
                  }
                if (this.componentFeatures?.allowsFeature(z.Attachments) && I.length > 0) {
                  for (let X = 0; X < I.length; X++)
                    this.handleUploadFiles(I);
                  return !0;
                }
              }, "paste"),
              keyup: /* @__PURE__ */ d((W, R) => {
                this.text = R.state.doc.toString(), this.componentFeatures?.allowsFeature(z.Typing) && this.typing && R.state.doc.toString() !== "" && this.throttledTyping(), this.draft && this.throttledDrafting(), this.componentFeatures?.allowsFeature(z.Embeds) && R.state.doc.toString() !== "" && this.handleEmbeds(R.state.doc.toString());
              }, "keyup")
            }),
            // Compartments
            this.editorEditable.of(b.editable.of(!this.disabled)),
            this.editorPlaceholder.of(this.placeholderExtension(this.placeholder)),
            this.editorKeymap.of(this.keymapFacet.of(this.getKeymaps())),
            b.updateListener.of((W) => {
              this.setPlaceHolderText();
              const R = Array.from(
                (this.editor?.state).config.compartments.keys()
              );
              this.editorEditable = R[0], this.editorPlaceholder = R[1], this.editorKeymap = R[2];
            })
          ], this.editor || (this.editor = new b({
            state: S.create({
              doc: this.text,
              extensions: this.editorExtensions
            }),
            parent: this.editorRef.value
          }), this.editorRef.value?.addEventListener("wy-submit", this.submit.bind(this))));
        }
      );
    }), t.has("disabled") && this.editor && this.editorEditable && this.EditorView && this.editor.dispatch({
      // Update readonly state
      effects: this.editorEditable.reconfigure(this.EditorView.editable.of(!this.disabled))
    }), t.has("placeholder") && this.editor && this.editorPlaceholder && this.placeholderExtension) {
      const e = this.placeholderExtension(this.placeholder);
      this.editor.dispatch({
        // Update placeholder state
        effects: this.editorPlaceholder.reconfigure(e)
      }), this.setPlaceHolderText();
    }
    t.has("settings") && this.editor && this.editorKeymap && this.keymapFacet && (this.editor.dispatch({
      // Update readonly state
      effects: this.editorKeymap.reconfigure(this.keymapFacet.of(this.getKeymaps()))
    }), this.setEnterKeyHint());
  }
  /**
   * Update the visible placeholder text within the fallback DOM copy.
   *
   * @internal
   */
  setPlaceHolderText() {
    const t = this.renderRoot.querySelector(".cm-placeholder");
    t && this.editor && (t.setAttribute("aria-label", `placeholder ${this.placeholder}`), t.innerText = this.placeholder);
  }
  /**
   * Update contentEditable attribute on the fallback editor.
   *
   * @internal
   */
  setEditable() {
    const t = this.renderRoot.querySelector(".cm-content");
    t && this.editor && (t.contentEditable = String(!this.disabled));
  }
  /**
   * Update enter key hint on the content element.
   *
   * @internal
   */
  setEnterKeyHint() {
    const t = this.renderRoot.querySelector(".cm-content");
    t && this.editor && (t.enterKeyHint = this.settings?.enterToSend === "always" ? "send" : "enter");
  }
  /**
   * Compute and return keymaps for the current settings/editor type.
   *
   * @internal
   */
  getKeymaps() {
    if (!this.keymaps)
      return [];
    const { weavyEnterSendKeymap: t, weavyModifierEnterSendKeymap: e, weavyKeymap: i, defaultKeymap: s, historyKeymap: r } = this.keymaps;
    let a = this.settings?.enterToSend === "never" ? [] : [...e];
    return ((!this.settings?.enterToSend || this.settings?.enterToSend === "auto") && this.editorType === "messages" && VG || this.settings?.enterToSend === "always") && (a = [...t, ...a]), [...a, ...i, ...s, ...r];
  }
  connectedCallback() {
    super.connectedCallback(), window.addEventListener("message", this.createMeeting);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("message", this.createMeeting);
  }
  handleRemoveMeeting() {
    this.meeting = void 0;
  }
  /**
   * Autocomplete handler for mentions. Returns completion results or null.
   *
   * Called by the editor to resolve mention suggestions.
   *
   * @internal
   * @param context - Completion context from the editor
   * @returns Promise<CompletionResult | null>
   */
  async autocomplete(t) {
    if (!this.weavy || !this.app)
      return null;
    let e = t.matchBefore(/(?:^|\s)(?!\]\()@(?=\S)([^@]+)/);
    if (!t.explicit && !e) return null;
    e = t.matchBefore(/@[^@]+/);
    const i = e?.text.substring(1), s = await (await this.weavy.fetch(`/api/apps/${this.app.id}/members?member=null&q=${i}`)).json();
    let r = [];
    return s.data && (r = s.data.filter((a) => typeof a.name < "u").map((a) => ({
      item: a,
      label: a.name,
      apply: /* @__PURE__ */ d((o, l, h, u) => {
        const p = "[" + a.name + "](@u" + a.id.toString() + ")";
        let y = o.state.update({ changes: { from: h - 1, to: h } });
        o.dispatch(y), y = o.state.update({
          changes: { from: h - 1, to: u - 1, insert: p }
        }), o.dispatch(y);
      }, "apply")
    }))), {
      from: e ? e.from + 1 : t.pos,
      options: r,
      filter: !1
    };
  }
  /**
   * Handle files dropped on the editor.
   *
   * @internal
   * @param e - Drop files event
   */
  handleDropFiles(t) {
    const e = t.detail;
    e.files && this.handleUploadFiles(e.files);
  }
  /**
   * Upload array of File objects via the upload blob mutation controller.
   *
   * Preserves input value if provided and saves draft after each upload.
   *
   * @internal
   * @param files - FileList or array of File objects to upload
   * @param input - Optional input element to reset after upload
   */
  async handleUploadFiles(t, e) {
    if (t) {
      for (let i = 0; i < t.length; i++) {
        const s = { file: t[i] };
        await this.uploadBlobMutation.mutate(s), this.saveDraft();
      }
      e && (e.value = "");
    }
  }
  /**
   * Handle external blob imports (cloud/external sources).
   *
   * @internal
   * @param externalBlobs - Array of external blob descriptors
   */
  handleExternalBlobs(t) {
    if (t)
      for (let e = 0; e < t.length; e++) {
        const i = t[e];
        this.externalBlobMutation?.mutate({ externalBlob: i });
      }
  }
  /**
   * Handle removal/abortion of an upload mutation and clean cache state.
   *
   * @internal
   * @param mutation - Mutation state object to remove
   */
  handleRemoveUpload(t) {
    !this.weavy || !this.mutationAppId || (t.status === "pending" && ab(t.variables) && t.variables.abort?.(), YP(
      this.weavy.queryClient,
      ["apps", this.mutationAppId, "blobs", `${this.editorLocation}-${this.parentId || this.mutationAppId}`],
      (e) => e.state.data?.id === t.data?.id
    ));
  }
  /**
   * Persist draft to storage if draft mode is enabled.
   *
   * Saves editor text, embeds, poll options and ongoing file uploads to localStorage.
   *
   * @internal
   */
  saveDraft() {
    if (!this.draft || !this.storage) return;
    const t = this.mutatingFiles.result;
    let e = this.editor?.state.doc.toString();
    if (e === void 0 && (e = this.text), (!t || !t.length) && !this.meeting && !this.embeds.length && (!this.pollOptions.length || this.pollOptions.filter((i) => i.text.trim() !== "").length === 0) && e === "")
      this.storage.removeItem(this.draftKey);
    else {
      const i = {
        meeting: this.meeting,
        text: e,
        pollOptions: this.pollOptions.filter((s) => s.text.trim() !== ""),
        embeds: this.embeds
      };
      this.storage.setItem(this.draftKey, JSON.stringify(i));
    }
  }
  /**
   * Handle removal of an attachment reference from the editor state.
   *
   * @internal
   * @param attachment - Attachment to remove
   */
  handleRemoveAttachment(t) {
    this.attachments = this.attachments.filter((e) => e.id !== t.id);
  }
  /**
   * Submit the editor content by dispatching a `submit` event.
   *
   * Validates that there is content to submit and that no uploads/embeds are still processing.
   *
   * @internal
   */
  submit() {
    const t = this.mutatingFiles.result, e = t?.some((u) => u.status === "pending"), i = this.editor?.state.doc.toString().trim() ?? "", s = this.meeting?.id, r = t?.map((u) => u.data?.id).filter((u) => u), a = this.attachments?.map((u) => u.id) || [], o = this.pollOptions.filter((u) => u.text.trim() !== "");
    if (HW() || e || !this.contextDataBlobs || !i && !s && r?.length == 0 && o.length == 0 && a.length == 0 && this.embeds.length == 0)
      return;
    const l = this.contextDataBlobs.length ? this.contextDataBlobs : void 0, h = new CustomEvent("submit", {
      detail: { text: i, meetingId: s, blobs: r, attachments: a, pollOptions: o, embedId: this.embeds[0]?.id, contextData: l },
      bubbles: !0,
      composed: !0
    });
    this.dispatchEvent(h), this.resetEditor();
  }
  /**
   * Reset the editor state after a successful submit.
   *
   * Clears editor content, removes pending uploads from the query cache and deletes the stored draft.
   *
   * @internal
   */
  resetEditor() {
    this.clearEditor(), this.weavy && this.mutationAppId && kL(this.weavy.queryClient, [
      "apps",
      this.mutationAppId,
      "blobs",
      `${this.editorLocation}-${this.parentId || this.mutationAppId}`
    ]), this.storage?.removeItem(this.draftKey);
  }
  /**
   * Clear the editor UI and internal state (text, embeds, attachments, metadata).
   *
   * @internal
   */
  clearEditor() {
    this.editor?.dispatch({ changes: { from: 0, to: this.editor.state.doc.length, insert: "" } }), this.text = "", this.meeting = void 0, this.pollOptions = [], this.showPolls = !1, this.embeds = [], this.metadata = {}, LG();
  }
  /**
   * Create or initiate a meeting for the current user.
   *
   * If the meeting requires third-party auth, opens an auth popup; otherwise stores the created meeting.
   *
   * @internal
   * @param name - Provider key for the meeting (e.g. "zoom", "google", "microsoft")
   */
  async handleMeetingClick(t) {
    if (!this.weavy || !this.user)
      return;
    const e = await xS(this.weavy, t).mutate();
    e.auth_url ? this.authWindow = window.open(e.auth_url, "oauthwin", "height=640,width=480") : this.meeting = e;
  }
  /**
   * Add a discovered embed to the editor and persist draft.
   *
   * @internal
   * @param embed - Embed object to add.
   */
  setEmbeds(t) {
    this.embeds = [t, ...this.embeds], this.saveDraft();
  }
  /**
   * Scan content for embeds and add them via setEmbeds callback.
   *
   * @internal
   * @param content - Text content to scan for embed links.
   */
  handleEmbeds(t) {
    this.weavy && IG(t, this.setEmbeds.bind(this), this.weavy);
  }
  /**
   * Remove an embed by id from the editor embeds list and persist draft.
   *
   * @internal
   * @param e - Embed remove event containing embed id.
   */
  removeEmbed(t) {
    this.embeds = this.embeds.filter((e) => e.id !== t.detail.id), this.saveDraft();
  }
  /**
   * Cycle the primary embed (move first to the end) and persist draft.
   *
   * @internal
   */
  swapEmbed() {
    const t = this.embeds.shift();
    t && (this.embeds = [...this.embeds, t]), this.saveDraft();
  }
  /**
   * Toggle the poll UI in the editor and initialize default options when opened.
   *
   * @internal
   */
  openPolls() {
    this.showPolls ? this.showPolls = !1 : (this.pollOptions.length === 0 && (this.pollOptions = Array.from({ length: 3 }, () => ({ id: null, text: "" }))), this.showPolls = !0);
  }
  /**
   * Handle change to a poll option input and persist draft.
   *
   * @internal
   * @param e - Input event
   * @param index - Index of the poll option changed
   */
  handlePollOptionChange(t, e) {
    const i = [...this.pollOptions];
    i[e].text = t.target.value, this.pollOptions = i, this.saveDraft();
  }
  /**
   * Add a new poll option when focus reaches the last option (limit 5).
   *
   * @internal
   * @param e - Focus/keyboard event
   * @param index - Index of the poll option that triggered the add
   */
  handlePollOptionAdd(t, e) {
    if (e === this.pollOptions.length - 1 && this.pollOptions.length < 5) {
      const i = { id: null, text: "" };
      this.pollOptions = [...this.pollOptions, i], this.saveDraft();
    }
  }
  /**
   * Editor loading fallback dummy.
   * Hard copy of the rendered nodes when the editor is empty. Cleaned up to not be editable.
   */
  renderEditorDummy() {
    return this.editorInitialized ? C : v`
          <div class="cm-editor">
            <div class="cm-announced"></div>
            <div tabindex="-1" class="cm-scroller">
              <div class="cm-content cm-lineWrapping">
                <div class="cm-line"
                  ><img class="cm-widgetBuffer" aria-hidden="true" /><span class="cm-placeholder"
                    >${this.placeholder}</span
                  ><br
                /></div>
              </div>
            </div>
          </div>
        `;
  }
  renderTopSlot() {
    return C;
  }
  renderMiddleSlot() {
    return v`
      <!-- Input -->
      <div part=${ut({ "wy-post-editor-text": !0, "wy-is-invalid": this.editorError })} ${ot(this.editorRef)}>
        ${this.renderEditorDummy()}
      </div>

      <div part="wy-post-editor-inputs">
        <div part="wy-post-editor-buttons">
          ${this.componentFeatures?.allowsFeature(z.Attachments) ? v`<wy-button
                  kind="icon"
                  @click=${this.openFileInput}
                  title=${P("From device")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon name="attachment"></wy-icon>
                </wy-button>
                <input
                  type="file"
                  ${ot(this.fileInputRef)}
                  @click=${(t) => t.stopPropagation()}
                  @change=${(t) => this.handleUploadFiles(
      Array.from(t.target.files || []),
      t.target
    )}
                  multiple
                  hidden
                  tabindex="-1"
                  ?disabled=${this.disabled}
                />` : C}
          ${this.componentFeatures?.allowsFeature(z.CloudFiles) ? v`<wy-button
                kind="icon"
                @click=${this.openCloudFiles}
                title=${P("From cloud")}
                ?disabled=${this.disabled}
              >
                <wy-icon name="cloud"></wy-icon>
              </wy-button>` : C}
          ${this.componentFeatures?.allowsAnyFeature(z.Meetings, z.ZoomMeetings) ? v`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("zoom")}
                  title=${P("Zoom meeting")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="zoom-meetings"></wy-icon>
                </wy-button>
              ` : C}
          ${this.componentFeatures?.allowsAnyFeature(z.Meetings, z.GoogleMeet) ? v`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("google")}
                  title=${P("Google Meet")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="google-meet"></wy-icon>
                </wy-button>
              ` : C}
          ${this.componentFeatures?.allowsAnyFeature(z.Meetings, z.MicrosoftTeams) ? v`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("microsoft")}
                  title=${P("Microsoft Teams")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="microsoft-teams"></wy-icon>
                </wy-button>
              ` : C}
          ${this.componentFeatures?.allowsFeature(z.Polls) ? v`<wy-button
                kind="icon"
                @click=${() => this.openPolls()}
                title=${P("Poll")}
                ?disabled=${this.disabled}
              >
                <wy-icon name="poll"></wy-icon>
              </wy-button>` : C}
        </div>

        <!-- Button -->
        <wy-button @click="${() => this.submit()}" color="primary" title=${this.buttonText} ?disabled=${this.disabled}>
          ${this.buttonText}
        </wy-button>
      </div>
    `;
  }
  /**
   * Render the bottom slot which aggregates lists (polls, meetings, file uploads, attachments, embeds).
   *
   * @internal
   */
  renderBottomSlot() {
    return [this.renderLists()];
  }
  /**
   * Render the lists section (poll options, meetings, file uploads, attachments, embeds).
   *
   * @internal
   */
  renderLists() {
    const t = this.mutatingFiles.result, e = this.componentFeatures?.allowsFeature(z.Polls) && this.showPolls && this.pollOptions.length > 0 || !1, i = this.meeting?.provider === "zoom" && this.componentFeatures?.allowsAnyFeature(z.Meetings, z.ZoomMeetings) || this.meeting?.provider === "google" && this.componentFeatures?.allowsAnyFeature(z.Meetings, z.GoogleMeet) || this.meeting?.provider === "microsoft" && this.componentFeatures?.allowsAnyFeature(z.Meetings, z.MicrosoftTeams) || !1, s = t && t.length > 0 || !1, r = this.attachments && this.attachments.length > 0, a = this.componentFeatures?.allowsFeature(z.Embeds) && this.embeds.length > 0 || !1;
    return this.disabled || !(e || i || s || r || a) ? C : v` <div part="wy-editor-parts">
      <!-- polls -->
      ${e ? v`
            <div part="wy-poll-form">
              ${this.pollOptions.map((o, l) => {
      const h = l + 1;
      return v`<input
                  value="${o.text}"
                  part="wy-input"
                  type="text"
                  placeholder=${P(st`Option ${h}`)}
                  @change=${(u) => this.handlePollOptionChange(u, l)}
                  @keyup=${Ys}
                  @focus=${(u) => this.handlePollOptionAdd(u, l)}
                />`;
    })}
            </div>
          ` : C}

      <!-- meetings -->
      ${i && this.meeting ? v`
            <wy-item size="sm">
              <wy-icon slot="image" svg="${$b(this.meeting.provider)}"></wy-icon>
              <span slot="title">${xb(this.meeting.provider)}</span>
              <wy-button slot="actions" kind="icon" @click=${() => this.handleRemoveMeeting()}>
                <wy-icon name="close"></wy-icon>
              </wy-button>
            </wy-item>
          ` : C}

      <!-- blobs -->
      ${s && t ? v`<div>
            ${Mi(
      t,
      (o) => "mutation" + o.submittedAt,
      (o) => {
        if (o.context?.file) {
          const l = o.context.file, h = {
            ...o.context.status
          };
          return v`
                    <wy-file-item
                      .file=${o.context.file}
                      .status=${h}
                      title="${$P(o.context.type)}: ${l.name + (h.text ? `: ${h.text}` : "")}"
                    >
                      <span slot="title"
                        ><strong></strong> ${l.name}
                        ${h.text ? v`: <em>${h.text}</em>` : C}</span
                      >
                      ${h.state === "pending" ? v`
                            <wy-progress-circular
                              slot="actions"
                              padded
                              ?indeterminate=${!h.progress}
                              .max=${100}
                              .value=${h.progress || 0}
                            ></wy-progress-circular>
                          ` : C}
                      <wy-button
                        slot="actions"
                        kind="icon"
                        @click=${() => {
            this.handleRemoveUpload(o);
          }}
                        title=${P("Discard", { desc: "Button action to discard" })}
                      >
                        <wy-icon name="close"></wy-icon>
                      </wy-button>
                    </wy-file-item>
                  `;
        }
        return C;
      }
    )}
          </div>` : C}

      <!-- attachments -->
      ${r ? this.attachments.map(
      (o) => v`<wy-file-item .file=${o} title="${o.name}">
              <span slot="title">${o.name}</span>
              <wy-button
                slot="actions"
                kind="icon"
                @click=${() => this.handleRemoveAttachment(o)}
                title=${P("Remove", { desc: "Button action to remove" })}
              >
                <wy-icon name="close"></wy-icon>
              </wy-button>
            </wy-file-item>`
    ) : C}

      <!-- embeds -->
      ${a ? v`
            <wy-embed-select
              .embeds=${this.embeds}
              @embed-remove=${(o) => this.removeEmbed(o)}
              @embed-swap=${() => this.swapEmbed()}
            ></wy-embed-select>
          ` : C}
    </div>`;
  }
  /**
   * Render the cloud files picker if cloud files feature is enabled.
   *
   * @internal
   */
  renderCloudFiles() {
    return this.disabled ? C : v`
      <wy-cloud-files
        ${ot(this.cloudFilesRef)}
        @external-blobs=${(t) => this.handleExternalBlobs(t.detail.externalBlobs)}
      ></wy-cloud-files>
    `;
  }
  render() {
    const t = this.dropZone.isDragActive;
    return v`
      <div
        part=${ut({
      "wy-editor": !0,
      [this.editorClass]: !0,
      "wy-dragging": t
    })}
        data-drag-title=${P("Drop files here")}
      >
        ${this.renderTopSlot()} ${this.renderMiddleSlot()} ${this.renderBottomSlot()}
      </div>
      ${this.renderCloudFiles()}
    `;
  }
}, c(ty, "bo"), ty), d(ux, "WyEditor"), ux);
Wt.styles = [ne, DG, qG, q4, KW, $a];
Jt([
  O({ type: Boolean })
], Wt.prototype, "disabled", 2);
Jt([
  O({ attribute: !1 })
], Wt.prototype, "parentId", 2);
Jt([
  O()
], Wt.prototype, "placeholder", 1);
Jt([
  O()
], Wt.prototype, "text", 2);
Jt([
  O({ type: Object })
], Wt.prototype, "metadata", 2);
Jt([
  O({ attribute: !1 })
], Wt.prototype, "embed", 2);
Jt([
  O({ attribute: !1 })
], Wt.prototype, "options", 2);
Jt([
  O({ attribute: !1 })
], Wt.prototype, "attachments", 2);
Jt([
  O()
], Wt.prototype, "buttonText", 2);
Jt([
  O({ type: Boolean })
], Wt.prototype, "typing", 2);
Jt([
  O({ type: Boolean })
], Wt.prototype, "draft", 2);
Jt([
  O()
], Wt.prototype, "editorType", 2);
Jt([
  O()
], Wt.prototype, "editorClass", 2);
Jt([
  O()
], Wt.prototype, "editorLocation", 2);
Jt([
  F()
], Wt.prototype, "meeting", 2);
Jt([
  F()
], Wt.prototype, "editorError", 2);
Jt([
  F()
], Wt.prototype, "showPolls", 2);
Jt([
  F()
], Wt.prototype, "pollOptions", 2);
Jt([
  F()
], Wt.prototype, "embeds", 1);
Jt([
  F()
], Wt.prototype, "draftKey", 2);
Jt([
  F()
], Wt.prototype, "mutationAppId", 2);
Jt([
  F()
], Wt.prototype, "keyMap", 2);
Jt([
  F()
], Wt.prototype, "editorExtensions", 2);
Jt([
  F()
], Wt.prototype, "editor", 2);
Wt = Jt([
  U("wy-editor"),
  St()
], Wt);
var GG = Object.getOwnPropertyDescriptor, KG = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? GG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = a(s) || s);
  return s;
}, "__decorateClass$H"), px, ey;
let Sb = (px = (ey = class extends Wt {
  constructor() {
    super(), this.editorType = "comments", this.editorClass = "wy-comment-editor";
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("editorLocation") && (this.editorLocation === "files" ? this.editorClass = "wy-comment-editor wy-comment-editor-bottom" : this.editorLocation === "apps" && (this.editorClass = "wy-comment-editor wy-comment-editor-bottom"));
  }
  /**
   * Render the top slot for comment editor with no content.
   *
   * @internal
   */
  renderTopSlot() {
    return C;
  }
  /**
   * Render the primary middle slot containing the add-menu, editor and send button.
   *
   * Overrides the base implementation to provide message-specific controls and layout.
   *
   * @internal
   */
  renderMiddleSlot() {
    return v`<div part="wy-comment-editor-inputs">
      <!-- Add -->
      ${this.componentFeatures?.allowsAnyFeature(
      z.Attachments,
      z.CloudFiles,
      z.Meetings,
      z.ZoomMeetings,
      z.GoogleMeet,
      z.MicrosoftTeams,
      z.Polls
    ) ? v`<wy-dropdown icon="plus" directionY="up" ?disabled=${this.disabled}>
            ${this.componentFeatures?.allowsFeature(z.Attachments) ? v`<wy-dropdown-item @click=${this.openFileInput} title=${P("From device")}>
                    <wy-icon name="attachment"></wy-icon>
                    <span>${P("From device")}</span>
                  </wy-dropdown-item>
                  <input
                    type="file"
                    ${ot(this.fileInputRef)}
                    @click=${(t) => t.stopPropagation()}
                    @change=${(t) => this.handleUploadFiles(
      Array.from(t.target.files || []),
      t.target
    )}
                    multiple
                    hidden
                    tabindex="-1"
                  />` : C}
            ${this.componentFeatures?.allowsFeature(z.CloudFiles) ? v`<wy-dropdown-item @click=${this.openCloudFiles} title=${P("From cloud")}>
                  <wy-icon name="cloud"></wy-icon>
                  <span>${P("From cloud")}</span>
                </wy-dropdown-item>` : C}
            ${this.componentFeatures?.allowsAnyFeature(z.Meetings, z.ZoomMeetings) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("zoom")} title=${P("Zoom meeting")}>
                    <wy-icon svg="zoom-meetings"></wy-icon>
                    <span>${P("Zoom meeting")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsAnyFeature(z.Meetings, z.GoogleMeet) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("google")} title=${P("Google Meet")}>
                    <wy-icon svg="google-meet"></wy-icon>
                    <span>${P("Google Meet")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsAnyFeature(z.Meetings, z.MicrosoftTeams) ? v`
                  <wy-dropdown-item
                    @click=${() => this.handleMeetingClick("microsoft")}
                    title=${P("Microsoft Teams")}
                  >
                    <wy-icon svg="microsoft-teams"></wy-icon>
                    <span>${P("Microsoft Teams")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsFeature(z.Polls) ? v`<wy-dropdown-item @click=${() => this.openPolls()} title=${P("Poll")}>
                  <wy-icon name="poll"></wy-icon>
                  <span>${P("Poll")}</span>
                </wy-dropdown-item>` : C}
          </wy-dropdown>` : C}

      <!-- Input -->
      <div
        part=${ut({ "wy-comment-editor-text": !0, "wy-is-invalid": this.editorError })}
        ${ot(this.editorRef)}
      >
        ${this.renderEditorDummy()}
      </div>

      <!-- Button -->
      <wy-button kind="icon" @click="${() => this.submit()}" title=${this.buttonText} ?disabled=${this.disabled}>
        <wy-icon name="send"></wy-icon>
      </wy-button>
    </div>`;
  }
  /**
   * Render content that appears below the message editor.
   *
   * By default returns the same lists section used by the base editor.
   *
   * @internal
   */
  renderBottomSlot() {
    return [
      this.renderLists()
    ];
  }
}, c(ey, "xo"), ey), d(px, "WyCommentEditor"), px);
Sb.styles = [...Wt.styles, RG];
Sb = KG([
  U("wy-comment-editor"),
  St()
], Sb);
var JG = Object.defineProperty, tK = Object.getOwnPropertyDescriptor, tV = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$9"), Im = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? tK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && JG(t, e, s), s;
}, "__decorateClass$G"), eV = /* @__PURE__ */ d((n, t, e) => t.has(n) || tV("Cannot " + e), "__accessCheck$9"), uv = /* @__PURE__ */ d((n, t, e) => (eV(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$9"), fx = /* @__PURE__ */ d((n, t, e) => t.has(n) ? tV("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$9"), yx = /* @__PURE__ */ d((n, t, e, i) => (eV(n, t, "write to private field"), t.set(n, e), e), "__privateSet$8"), nO, SS, Uc, mx, iy;
let er = (mx = (iy = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.location = "apps", this.reveal = !1, this.padded = !1, fx(this, nO), fx(this, SS, new Promise((t) => {
      yx(this, nO, t);
    })), this.commentsQuery = new Rl(this), this.addCommentMutation = new An(this), this.infiniteScroll = new El(this), this.pagerRef = wt(), fx(this, Uc), this.handleRealtimeCommentCreated = () => {
      this.weavy?.queryClient.invalidateQueries({ queryKey: [this.location, this.parentId, "comments"] });
    }, this.handleRealtimeReactionAdded = (t) => {
      !this.weavy || t.entity.type !== ci.Comment || ge(
        this.weavy.queryClient,
        [this.location, this.parentId, "comments"],
        t.entity.id,
        (e) => {
          ym(e, t.reaction, t.actor);
        }
      );
    }, this.handleRealtimeReactionDeleted = (t) => {
      !this.weavy || t.entity.type !== ci.Comment || ge(
        this.weavy.queryClient,
        [this.location, this.parentId, "comments"],
        t.entity.id,
        (e) => {
          ym(e, void 0, t.actor);
        }
      );
    };
  }
  /**
   * Resolves when `parentId` is available.
   *
   * @returns Promise<number>
   */
  async whenParentId() {
    return await uv(this, SS);
  }
  async willUpdate(t) {
    var e, i;
    if (super.willUpdate(t), t.has("parentId") && this.parentId && ((e = uv(this, nO)) == null || e.call(this, this.parentId)), (t.has("parentId") || t.has("weavy") || t.has("componentFeatures")) && this.parentId && this.weavy && (await this.commentsQuery.trackInfiniteQuery(IW(this.weavy, this.location, this.parentId)), await this.addCommentMutation.trackMutation(VW(this.weavy)), this.removeCommentMutation = qW(this.weavy, this.location, this.parentId), this.restoreCommentMutation = FW(this.weavy, this.location, this.parentId)), (t.has("weavy") || t.has("app") || t.has("componentFeatures")) && this.weavy && this.app) {
      this.pollMutation = S0(this.weavy, this.app.id, [this.location, this.parentId, "comments"]), (i = uv(this, Uc)) == null || i.call(this);
      const s = `a${this.app.id}`;
      this.weavy.subscribe(s, "comment_created", this.handleRealtimeCommentCreated), this.componentFeatures?.allowsFeature(z.Reactions) && (this.weavy.subscribe(s, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(s, "reaction_removed", this.handleRealtimeReactionDeleted)), yx(this, Uc, () => {
        this.weavy?.unsubscribe(s, "comment_created", this.handleRealtimeCommentCreated), this.weavy?.unsubscribe(s, "reaction_added", this.handleRealtimeReactionAdded), this.weavy?.unsubscribe(s, "reaction_removed", this.handleRealtimeReactionDeleted), yx(this, Uc, void 0);
      });
    }
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.commentsQuery.result, this.pagerRef.value);
  }
  /**
   * Handle submit from the comment editor and trigger add comment mutation.
   *
   * @internal
   */
  async handleSubmit(t) {
    this.app && this.parentId && this.user && await this.addCommentMutation.mutate({
      app_id: this.app.id,
      parent_id: this.parentId,
      type: this.location,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      context: t.detail.contextData,
      user: this.user
    });
  }
  /**
   * Render comment items from a flattened page array.
   *
   * @internal
   */
  renderComments(t) {
    return t ? Mi(
      t,
      (e) => e.id,
      (e) => this.parentId ? v`<wy-comment
                id="comment-${e.id}"
                ?reveal=${this.reveal}
                .parentId=${this.parentId}
                .location=${this.location}
                .comment=${e}
                @trash=${async (i) => {
        const s = await this.whenApp(), r = await this.whenParentId();
        this.removeCommentMutation?.mutate({
          id: i.detail.id,
          appId: s.id,
          parentId: r,
          type: this.location
        });
      }}
                @restore=${async (i) => {
        const s = await this.whenApp(), r = await this.whenParentId();
        this.restoreCommentMutation?.mutate({
          id: i.detail.id,
          appId: s.id,
          parentId: r,
          type: this.location
        });
      }}
                @vote=${(i) => {
        i.detail.parentId && i.detail.parentType && this.pollMutation?.mutate({
          optionId: i.detail.optionId,
          parentType: i.detail.parentType,
          parentId: i.detail.parentId
        });
      }}
              ></wy-comment>` : C
    ) : C;
  }
  render() {
    const { data: t, hasNextPage: e, isPending: i } = this.commentsQuery.result ?? {}, s = cs(t);
    return v`
      ${s && s.length ? v`
            <div part="wy-comments">
              ${this.renderComments(s)}
              ${e ? v`<div ${ot(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
            </div>
          ` : v`
            <wy-empty noNetwork
              ><wy-progress-circular indeterminate padded reveal ?hidden=${!i}></wy-progress-circular
            ></wy-empty>
          `}

      <wy-comment-editor
        editorLocation=${this.location}
        .parentId=${this.parentId}
        .typing=${!1}
        .draft=${!0}
        ?disabled=${!lm(rl.Create, this.app?.permissions)}
        placeholder=${this.placeholder ?? P("Create a comment...")}
        buttonText=${P("Comment", { desc: "Button action to comment" })}
        @submit=${(r) => this.handleSubmit(r)}
      ></wy-comment-editor>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = uv(this, Uc)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(iy, "$o"), iy), d(mx, "WyCommentList"), mx);
nO = /* @__PURE__ */ new WeakMap();
SS = /* @__PURE__ */ new WeakMap();
Uc = /* @__PURE__ */ new WeakMap();
er.styles = [N4, va];
Im([
  O({ type: Number })
], er.prototype, "parentId", 2);
Im([
  O({ attribute: !1 })
], er.prototype, "location", 2);
Im([
  O()
], er.prototype, "placeholder", 2);
Im([
  O({ type: Boolean, reflect: !0 })
], er.prototype, "reveal", 2);
Im([
  O({ type: Boolean, reflect: !0 })
], er.prototype, "padded", 2);
er = Im([
  U("wy-comment-list"),
  St()
], er);
function q0(n, t) {
  return ["apps", n.id, "file", t.id, "versions"];
}
c(q0, "$y");
d(q0, "getFileVersionsKey");
function iV(n, t, e) {
  const i = n.queryClient, s = ["apps", t.id, "files"], r = q0(t, e), a = {
    mutationKey: s,
    mutationFn: /* @__PURE__ */ d(async ({ versionFile: o }) => {
      if (o.id >= 1 && o.rev) {
        if (!(await n.fetch(`/api/files/${o.id}/versions/${o.rev}/restore`, {
          method: "POST"
        })).ok)
          throw new Error();
      } else
        throw new Error(`Could not restore ${o.name} to version ${o.rev}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((o) => (Ct(
      i,
      { queryKey: a.mutationKey, exact: !1 },
      o.versionFile.id,
      (l) => Object.assign(l, o.versionFile, { status: "pending" })
    ), { type: "version", file: e, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ d((o, l) => {
      Ct(
        i,
        { queryKey: a.mutationKey, exact: !1 },
        l.versionFile.id,
        (h) => Object.assign(h, o, { status: "ok" })
      ), se(i, a.mutationKey, l, (h) => {
        h.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ d((o, l, h) => {
      h?.file && Ct(
        i,
        { queryKey: a.mutationKey, exact: !1 },
        l.versionFile.id,
        (u) => Object.assign(u, h.file, { status: "error" })
      ), se(i, a.mutationKey, l, (u) => {
        u.status.state = "error", u.status.text = o.message;
      });
    }, "onError"),
    onSettled: /* @__PURE__ */ d(async () => {
      await i.invalidateQueries({ queryKey: r });
    }, "onSettled")
  };
  return a;
}
c(iV, "K4");
d(iV, "getFileVersionRestoreMutationOptions");
function nV(n, t, e) {
  return new Xt(n.queryClient, iV(n, t, e));
}
c(nV, "G4");
d(nV, "getFileVersionRestoreMutation");
function sV(n, t, e) {
  const i = n.queryClient, s = q0(t, e);
  return {
    mutationKey: s,
    mutationFn: /* @__PURE__ */ d(async ({ versionFile: r }) => {
      if (r.id >= 1 && r.rev) {
        const a = await n.fetch(`/api/files/${r.id}/versions/${r.rev}`, {
          method: "DELETE"
        });
        if (!a.ok) {
          const o = await a.json();
          throw new Error(o.detail || o.title, { cause: o });
        }
      } else {
        const a = {
          status: 400,
          title: `Could not remove ${r.name} version ${r.rev}.`
        };
        throw new Error(a.detail || a.title, { cause: a });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((r) => {
      ge(
        i,
        s,
        /* @__PURE__ */ d((a) => a.id === r.versionFile.id && a.rev === r.versionFile.rev, "versionPredicate"),
        (a) => Object.assign(a, { status: "pending" })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((r, a) => {
      x0(i, s, /* @__PURE__ */ d((o) => o.id === a.versionFile.id && o.rev === a.versionFile.rev, "versionPredicate"));
    }, "onSuccess"),
    onError: /* @__PURE__ */ d((r, a) => {
      ge(
        i,
        s,
        /* @__PURE__ */ d((o) => o.id === a.versionFile.id && o.rev === a.versionFile.rev, "versionPredicate"),
        (o) => Object.assign(o, { status: void 0 })
      );
    }, "onError")
  };
}
c(sV, "Z4");
d(sV, "getFileVersionDeleteMutationOptions");
function rV(n, t, e) {
  return new Xt(n.queryClient, sV(n, t, e));
}
c(rV, "Y4");
d(rV, "getFileVersionDeleteMutation");
var eK = Object.defineProperty, iK = Object.getOwnPropertyDescriptor, B4 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? iK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && eK(t, e, s), s;
}, "__decorateClass$F"), gx, ny;
let i1 = (gx = (ny = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.fileVersionsQuery = new gn(this);
  }
  /**
   * Selects the provided version and emits `file-version-select`.
   *
   * @param versionFile - Version to select.
   */
  selectVersion(t) {
    this.activeVersion = t, this.dispatchFileVersionSelect(t);
  }
  /**
   * Emit a `file-version-select` event with the chosen version.
   *
   * @internal
   * @param versionFile - Version to announce.
   * @returns Whether the event was not canceled.
   */
  dispatchFileVersionSelect(t) {
    const e = new CustomEvent("file-version-select", {
      detail: { versionFile: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Revert the file to the supplied version.
   *
   * @internal
   * @param versionFile - Version to restore.
   */
  handleRevert(t) {
    this.fileVersionRestoreMutation?.mutate({ versionFile: t }), this.selectVersion(t);
  }
  /**
   * Remove the supplied version and adjust the active selection if needed.
   *
   * @internal
   * @param versionFile - Version to delete.
   */
  handleRemove(t) {
    this.fileVersionDeleteMutation?.mutate({ versionFile: t }), this.activeVersion === t && (this.activeVersion = this.file);
  }
  /**
   * Download the provided version via the browser.
   *
   * @internal
   * @param file - Version file to download.
   */
  triggerDownload(t) {
    as(t.download_url, "_top", t.name, !0);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("file") || t.has("app")) && this.weavy && this.file && this.app && (await this.fileVersionsQuery.trackQuery(
      Qm(
        this.weavy,
        q0(this.app, this.file),
        `/api/files/${this.file.id}/versions`
      )
    ), this.fileVersionRestoreMutation = nV(this.weavy, this.app, this.file), this.fileVersionDeleteMutation = rV(this.weavy, this.app, this.file));
  }
  render() {
    const { data: t, isPending: e } = this.fileVersionsQuery.result ?? { isPending: !0 };
    return e ? v`<wy-progress-circular indeterminate overlay></wy-progress-circular>` : t?.data ? v`
          <wy-item-list part="wy-versions">
            ${Mi(
      t.data,
      (i) => i.id,
      (i, s) => {
        const r = lr(i.name || "").icon, a = t.data ? t.data.length - s : NaN, o = tn(i.name), l = new Date(i.updated_at || i.created_at), h = !!this.file.external_url, u = new Intl.DateTimeFormat(this.weavy?.locale, {
          dateStyle: "full",
          timeStyle: "short"
        }).format(l), p = ql(this.weavy?.locale, new Date(l));
        return h ? v`
                      <wy-empty noNetwork>
                        <span slot="title">${P("Versions are not available for external cloud files.")}</span>
                      </wy-empty>
                    ` : v`
                      <wy-item
                        size="lg"
                        interactive
                        ?selected=${i.rev == this.activeVersion?.rev}
                        tabindex="0"
                        @click=${() => this.selectVersion(i)}
                        @keydown=${Le}
                        @keyup=${di}
                      >
                        <wy-icon
                          slot="image"
                          name=${r}
                          size="48"
                          kind=${i.kind}
                          ext=${o}
                        ></wy-icon>
                        <span slot="title">${a}. ${i.name}</span>
                        <span slot="text">
                          <time datetime=${i.updated_at || i.created_at} title=${u}
                            >${p}</time
                          >
                          ${i.updated_by ? v`· ${i.updated_by?.name}` : C}
                        </span>

                        <wy-dropdown slot="actions" directionX="left">
                          <wy-dropdown-item @click=${() => this.triggerDownload(i)}>
                            <wy-icon name="download"></wy-icon>
                            ${P("Download")}
                          </wy-dropdown-item>

                          ${s !== 0 ? v`
                                <wy-dropdown-divider></wy-dropdown-divider>
                                <wy-dropdown-item @click=${() => this.handleRevert(i)}>
                                  <wy-icon name="restore"></wy-icon>
                                  ${"Revert"}
                                </wy-dropdown-item>
                                <wy-dropdown-item @click=${() => this.handleRemove(i)}>
                                  <wy-icon name="delete"></wy-icon>
                                  ${P("Remove", { desc: "Button action to remove" })}
                                </wy-dropdown-item>
                              ` : C}
                        </wy-dropdown>
                      </wy-item>
                    `;
      }
    )}
          </wy-item-list>
        ` : C;
  }
}, c(ny, "Co"), ny), d(gx, "WyFileVersions"), gx);
B4([
  O({ attribute: !1 })
], i1.prototype, "file", 2);
B4([
  O({ attribute: !1 })
], i1.prototype, "activeVersion", 2);
i1 = B4([
  U("wy-file-versions"),
  St()
], i1);
var nK = Object.defineProperty, sK = Object.getOwnPropertyDescriptor, qe = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? sK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && nK(t, e, s), s;
}, "__decorateClass$E"), wx, sy;
let de = (wx = (sy = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.currentId = NaN, this.isAttachment = !1, this.filled = !1, this.showOverlay = !1, this.commentsOpen = !1, this.versionsOpen = !1, this.sidePanelMaximized = !1, this.persistState = new g1(this), this.swipeScroller = new jB(this), this.previewFileRef = wt(), this.nextRef = wt(), this.prevRef = wt(), this.loadingQueue = [], this.disableSwipeScroll = !1, this.handleKeys = (t) => {
      this.showOverlay && (t.key === "ArrowLeft" ? (t.stopPropagation(), this.setPrev()) : t.key === "ArrowRight" && (t.stopPropagation(), this.setNext()));
    };
  }
  /**
   * Moves a file to the front of the loading queue.
   *
   * @internal
   * @param file - File to prioritize.
   * @param state - Optional state override.
   */
  moveFirstInQueue(t, e) {
    let i = { file: t };
    const s = this.loadingQueue.filter((r) => r.file === t ? (i = r, !1) : !0);
    this.loadingQueue = [{ ...i, ...e }, ...s];
  }
  /**
   * Updates loading metadata for the supplied file.
   *
   * @internal
   * @param file - File whose state should change.
   * @param state - State patch to merge.
   */
  updateLoadingState(t, e) {
    t && (this.loadingQueue = this.loadingQueue.map((i) => t === i.file ? { ...i, ...e } : i));
  }
  /**
   * Marks the next unloaded item as loading.
   *
   * @internal
   */
  loadNextInQueue() {
    const t = this.loadingQueue.find((e) => !e.loaded);
    t && !t?.loading && this.updateLoadingState(t.file, { loading: !0 });
  }
  /**
   * Emits `wy-preview-open` with the current preview context.
   *
   * @internal
   */
  async dispatchOpen() {
    const t = await this.whenApp(), e = await this.whenComponentFeatures(), i = this.currentId, s = this.commentsOpen ? "comments" : this.versionsOpen ? "versions" : void 0, r = this.currentFile ? [this.currentFile] : [], a = this.isAttachment, o = this.contextDataBlobs, l = new CustomEvent("wy-preview-open", {
      detail: {
        fileId: i,
        tab: s,
        files: r,
        app: t,
        features: e.allowedFeatures().join(" "),
        isAttachment: a,
        contextDataBlobs: o
      },
      cancelable: !0,
      bubbles: !1,
      composed: !0
    });
    this.dispatchEvent(l) || (this.showOverlay = !1, this.commentsOpen = !1, this.versionsOpen = !1);
  }
  /**
   * Emits the `wy-preview-close` event.
   *
   * @internal
   */
  dispatchClose() {
    const t = new CustomEvent("wy-preview-close", {
      cancelable: !1,
      bubbles: !1,
      composed: !0
    });
    this.dispatchEvent(t);
  }
  /**
   * Opens the overlay for the provided file identifier.
   *
   * @param fileId - File to display.
   * @param showTab - Optional sidebar tab to activate.
   */
  async open(t, e) {
    await this.whenApp(), await this.updateComplete, t && (this.currentId = t), e && this.toggleSidebarTab(e, !0), this.showOverlay = !0;
  }
  /**
   * Closes the preview overlay.
   */
  close() {
    this.showOverlay = !1;
  }
  /**
   * Toggles sidebar visibility for comments or versions.
   *
   * @internal
   * @param tab - Sidebar to affect.
   * @param state - Forced open state; toggles when omitted.
   */
  toggleSidebarTab(t, e) {
    t === "comments" ? (this.versionsOpen = !1, this.commentsOpen = e !== void 0 ? e : !this.commentsOpen) : t === "versions" ? (this.commentsOpen = !1, this.versionsOpen = e !== void 0 ? e : !this.versionsOpen) : (this.commentsOpen = !1, this.versionsOpen = !1);
  }
  /**
   * Handles file version selection events.
   *
   * @internal
   * @param e - Version selection event.
   */
  handleVersionFile(t) {
    this.currentVersionFile = t.detail.versionFile;
  }
  /**
   * Scrolls to the previous preview area.
   *
   * @internal
   */
  scrollToPrev() {
    this.prevRef.value && (this.unblockSwipeScroll(), this.prevRef.value.scrollIntoView({ behavior: this.weavy?.scrollBehavior }));
  }
  /**
   * Scrolls to the next preview area.
   *
   * @internal
   */
  scrollToNext() {
    this.nextRef.value && (this.unblockSwipeScroll(), this.nextRef.value.scrollIntoView({ behavior: this.weavy?.scrollBehavior }));
  }
  /**
   * Disables swipe scrolling for a short duration.
   *
   * @internal
   * @param duration - Milliseconds before re-enabling.
   */
  blockSwipeScroll(t = 20) {
    window.clearTimeout(this.disableSwipeScrollTimeout), this.disableSwipeScroll = !0, this.disableSwipeScrollTimeout = window.setTimeout(() => this.disableSwipeScroll = !1, t);
  }
  /**
   * Re-enables swipe scrolling immediately.
   *
   * @internal
   */
  unblockSwipeScroll() {
    window.clearTimeout(this.disableSwipeScrollTimeout), this.disableSwipeScroll = !1;
  }
  /**
   * Selects the previous file when available.
   *
   * @internal
   */
  setPrev() {
    this.previousFile && (this.currentId = this.previousFile.id, this.blockSwipeScroll());
  }
  /**
   * Selects the next file when available.
   *
   * @internal
   */
  setNext() {
    this.nextFile && (this.currentId = this.nextFile.id, this.blockSwipeScroll());
  }
  /**
   * Registers swipe observers on the active scroll element.
   *
   * @internal
   */
  registerSwipeScroller() {
    this.swipeScrollElement && (this.swipeScroller.whenPrev ??= () => this.setPrev(), this.swipeScroller.whenNext ??= () => this.setNext(), this.swipeScroller.createObserver(this.swipeScrollElement));
  }
  async willUpdate(t) {
    if (super.willUpdate(t), (t.has("app") || t.has("user")) && this.app && this.user && !this.isAttachment && (this.persistState.observe(
      [
        { name: "commentsOpen", override: !0 },
        { name: "versionsOpen", override: !0 }
      ],
      `a${this.app.id}-preview`,
      `u${this.user.id}`
    ), this.commentsOpen && this.versionsOpen && (this.versionsOpen = !1)), t.has("queryResult") && this.queryResult) {
      const { data: e } = this.queryResult ?? {};
      this.files = e?.filter((i) => i && !i.is_trashed);
    }
    if (t.has("infiniteQueryResult") && this.infiniteQueryResult) {
      const { data: e } = this.infiniteQueryResult ?? {};
      this.files = cs(e).filter((i) => i && !i.is_trashed);
    }
    t.has("currentFile") && this.currentFile && this.currentFile.id !== this.currentId && (this.currentId = this.currentFile.id), (t.has("files") || t.has("currentId") || t.has("showOverlay")) && this.files && this.showOverlay && (this.currentFile = void 0, this.previousFile = void 0, this.nextFile = void 0, this.currentVersionFile = void 0, this.currentVersionFile = this.currentFile = this.files.find((e, i) => this.files && e.id === this.currentId ? (i >= 1 && (this.previousFile = this.files[i - 1]), i < this.files.length - 1 && (this.nextFile = this.files[i + 1]), this.infiniteQueryResult && i >= this.files.length - 2 && this.infiniteQueryResult.hasNextPage && !this.infiniteQueryResult.isFetchingNextPage && this.infiniteQueryResult.fetchNextPage(), this.infiniteQueryResult && i <= 1 && this.infiniteQueryResult.hasPreviousPage && !this.infiniteQueryResult.isFetchingPreviousPage && this.infiniteQueryResult.fetchPreviousPage(), !0) : !1)), t.has("currentFile") && this.currentFile && !this.files && (this.files = [this.currentFile]), t.has("previousFile") && this.previousFile && this.moveFirstInQueue(this.previousFile), t.has("nextFile") && this.nextFile && this.moveFirstInQueue(this.nextFile), t.has("currentVersionFile") && this.currentVersionFile && this.moveFirstInQueue(this.currentVersionFile, { loading: !0 }), t.has("loadingQueue") && this.loadNextInQueue(), t.has("showOverlay") && (this.showOverlay ? await this.dispatchOpen() : t.get("showOverlay") && this.dispatchClose());
  }
  /**
   * Renders the preview header for the active file.
   *
   * @internal
   * @param activeFile - File displayed in the main pane.
   */
  renderHeader(t) {
    return v`
      <wy-titlebar header ?trashed=${!!t?.is_trashed}>
        <wy-button slot="icon" kind="icon" @click=${() => this.close()}><wy-icon name="close"></wy-icon></wy-button>
        ${t ? v` <span slot="title">${t.name}</span> ` : C}
        ${t ? v`
              ${this.componentFeatures?.allowsFeature(z.Comments) && t.id >= 1 && !this.isAttachment ? v`
                    <wy-button
                      slot="actions"
                      kind="icon"
                      ?active=${this.commentsOpen}
                      @click=${() => this.toggleSidebarTab("comments")}
                      title=${P("Comments")}
                    >
                      <wy-icon-stack>
                        ${t.comments?.count && t.comments?.count > 0 ? v`<wy-icon name="comment" state ?active=${!this.commentsOpen}></wy-icon>
                              <wy-icon name="comment" layer state ?active=${this.commentsOpen}></wy-icon>` : v`<wy-icon name="comment-outline" state ?active=${!this.commentsOpen}></wy-icon>
                              <wy-icon name="comment" layer state ?active=${this.commentsOpen}></wy-icon>`}
                      </wy-icon-stack>
                    </wy-button>
                  ` : C}
              <wy-file-menu slot="actions" .file=${t}>
                ${this.componentFeatures?.allowsFeature(z.Versions) && t.id >= 1 && !this.isAttachment ? v`
                      <wy-dropdown-item ?active=${this.versionsOpen} @click=${() => this.toggleSidebarTab("versions")}>
                        <wy-icon name="backup-restore"></wy-icon>
                        ${P("Versions")}
                      </wy-dropdown-item>
                    ` : C}
              </wy-file-menu>
            ` : C}
      </wy-titlebar>
    `;
  }
  render() {
    let t = this.files === void 0;
    this.queryResult ? t = this.queryResult.isPending : this.infiniteQueryResult && (t = this.infiniteQueryResult.isPending);
    const e = [this.previousFile, this.currentVersionFile, this.nextFile].filter((s) => s);
    this.commentsOpen && this.versionsOpen && (this.versionsOpen = !1);
    const i = {
      "wy-preview-swiper-disabled": this.disableSwipeScroll
    };
    return this.weavy ? v`
      <wy-overlay
        part="wy-dark"
        maximized
        noHeader
        type=${this.filled ? "full" : "modal"}
        .show=${this.showOverlay}
        @keyup=${this.handleKeys}
        @close=${() => {
      this.showOverlay = !1;
    }}
      >
        ${this.showOverlay ? v`<div part="wy-preview-layout">
              ${this.renderHeader(this.currentFile)}

              <div part="wy-preview-main">
                ${this.isAttachment ? C : v` <aside
                        id="tab-comments"
                        part="wy-sidebar ${ut({
      "wy-active": this.commentsOpen,
      "wy-maximized": this.sidePanelMaximized
    })}"
                        ?hidden=${!this.commentsOpen}
                      >
                        <nav>
                          <wy-item size="md">
                            <span slot="title" part="wy-title">${P("Comments")}</span>
                            <wy-button
                              slot="actions"
                              kind="icon"
                              @click=${() => this.toggleSidebarTab("comments", !1)}
                            >
                              <wy-icon name="close"></wy-icon>
                            </wy-button>
                          </wy-item>
                          <button
                            @click=${() => this.sidePanelMaximized = !this.sidePanelMaximized}
                            part="wy-sidebar-handle"
                            title=${this.sidePanelMaximized ? P("Restore side panel") : P("Maximize side panel")}
                          ></button>
                        </nav>
                        <div part="wy-pane wy-scroll-y">
                          ${this.commentsOpen && this.currentFile && this.currentFile.id >= 1 && this.app && this.user ? v`
                                <wy-comment-list
                                  reveal
                                  .parentId=${this.currentFile.id}
                                  .location=${"files"}
                                ></wy-comment-list>
                              ` : C}
                        </div>
                      </aside>
                      <aside
                        id="tab-versions"
                        part="wy-sidebar ${ut({
      "wy-active": this.versionsOpen,
      "wy-maximized": this.sidePanelMaximized
    })}"
                        ?hidden=${!this.versionsOpen}
                      >
                        <nav>
                          <wy-item size="md">
                            <span slot="title" part="wy-title">${P("Versions")}</span>
                            <wy-button
                              slot="actions"
                              kind="icon"
                              @click=${() => this.toggleSidebarTab("versions", !1)}
                            >
                              <wy-icon name="close"></wy-icon>
                            </wy-button>
                          </wy-item>
                          <button
                            @click=${() => this.sidePanelMaximized = !this.sidePanelMaximized}
                            part="wy-sidebar-handle"
                            title=${this.sidePanelMaximized ? P("Restore side panel") : P("Maximize side panel")}
                          ></button>
                        </nav>
                        <div part="wy-pane wy-scroll-y">
                          <div part="wy-pane-body">
                            ${this.versionsOpen && this.currentFile && this.app ? v`
                                  <wy-file-versions
                                    .file=${this.currentFile}
                                    .activeVersion=${this.currentVersionFile}
                                    @file-version-select=${(s) => this.handleVersionFile(s)}
                                  ></wy-file-versions>
                                ` : C}
                          </div>
                        </div>
                      </aside>`}

                <div part="wy-preview">
                  <div
                    ${ot((s) => {
      s && (this.swipeScrollElement = s);
    })}
                    part="wy-preview-swiper ${ut(i)}"
                  >
                    ${Mi(
      e,
      (s) => "preview-area-" + s?.id,
      (s) => {
        const r = /* @__PURE__ */ d((l) => {
          l?.scrollIntoView(), requestAnimationFrame(() => l?.scrollIntoView());
        }, "currentPreviewFileCallback"), a = s === this.currentVersionFile ? r : s === this.nextFile ? this.nextRef : s === this.previousFile ? this.prevRef : void 0, o = this.loadingQueue.find((l) => l.file === s);
        return s ? v`
                              <div
                                id="preview-${s.id}"
                                ${ot(a)}
                                part="wy-preview-area wy-scroll-x-y"
                              >
                                ${!t && (o?.loading || o?.loaded) ? v`
                                      <wy-preview-item
                                        .file=${s}
                                        ?current=${s === this.currentVersionFile}
                                        @file-preview-loaded=${(l) => this.updateLoadingState(l.detail.file, { loaded: !0 })}
                                      ></wy-preview-item>
                                    ` : v` <wy-progress-circular indeterminate overlay></wy-progress-circular> `}
                              </div>
                            ` : C;
      }
    )}
                  </div>
                  ${this.currentFile ? v`
                        ${this.previousFile ? v`
                              <nav part="wy-nav-prev">
                                <wy-button kind="icon" @click=${() => this.scrollToPrev()}>
                                  <wy-icon name="previous"></wy-icon>
                                </wy-button>
                              </nav>
                            ` : C}
                        ${this.nextFile ? v`
                              <nav part="wy-nav-next">
                                <wy-button kind="icon" @click=${() => this.scrollToNext()}>
                                  <wy-icon name="next"></wy-icon>
                                </wy-button>
                              </nav>
                            ` : C}
                      ` : C}
                </div>
              </div>
            </div> ` : C}
      </wy-overlay>
    ` : C;
  }
  updated(t) {
    t.has("swipeScrollElement") && t.get("swipeScrollElement") !== this.swipeScrollElement && this.registerSwipeScroller(), !this.disableSwipeScroll && this.swipeScroller.swipeElement === this.swipeScrollElement ? this.swipeScroller.observe(this.prevRef.value, this.nextRef.value) : this.swipeScroller.clearObserver();
  }
}, c(sy, "ko"), sy), d(wx, "WyPreview"), wx);
de.styles = [nG, sG, Il, Vl, Rm, Te];
qe([
  O({ attribute: !1 })
], de.prototype, "files", 2);
qe([
  O({ attribute: !1 })
], de.prototype, "queryResult", 2);
qe([
  O({ attribute: !1 })
], de.prototype, "infiniteQueryResult", 2);
qe([
  O({ type: Object })
], de.prototype, "user", 2);
qe([
  O({ type: Number })
], de.prototype, "currentId", 2);
qe([
  O({ type: Boolean })
], de.prototype, "isAttachment", 2);
qe([
  O({ type: Boolean })
], de.prototype, "filled", 2);
qe([
  F()
], de.prototype, "currentFile", 2);
qe([
  F()
], de.prototype, "currentVersionFile", 2);
qe([
  F()
], de.prototype, "previousFile", 2);
qe([
  F()
], de.prototype, "nextFile", 2);
qe([
  F()
], de.prototype, "showOverlay", 2);
qe([
  F()
], de.prototype, "commentsOpen", 2);
qe([
  F()
], de.prototype, "versionsOpen", 2);
qe([
  F()
], de.prototype, "sidePanelMaximized", 2);
qe([
  F()
], de.prototype, "swipeScrollElement", 2);
qe([
  F()
], de.prototype, "loadingQueue", 2);
qe([
  F()
], de.prototype, "disableSwipeScroll", 2);
de = qe([
  U("wy-preview"),
  St()
], de);
var rK = Object.defineProperty, aK = Object.getOwnPropertyDescriptor, Ee = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? aK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && rK(t, e, s), s;
}, "__decorateClass$D"), vx, ry;
let ae = (vx = (ry = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.me = !1, this.isAgent = !1, this.isPrivateChat = !1, this.name = "", this.comment = "", this.avatar = "", this.createdAt = "", this.html = "", this.text = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.seenBy = [], this.highlight = !1, this.previewAnnotationsRef = wt(), this.previewAttachmentsRef = wt(), this.highlightRef = wt();
  }
  /**
   * Emit a `vote` event for the specified poll option.
   *
   * @internal
   * @param optionId - Identifier of the selected poll option.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", {
      detail: { optionId: t, parentId: this.messageId }
    });
    return this.dispatchEvent(e);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("link") && (this.highlight = !!(this.link && P1(this.link, ci.Message, { id: this.messageId })));
  }
  render() {
    const t = this.attachments?.filter((a) => a.kind === "image" && a.thumbnail_url) || [], e = this.attachments?.filter((a) => a.kind !== "image" || !a.thumbnail_url) || [], i = this.createdAt ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.createdAt)
    ) : "", s = this.createdAt ? new Intl.DateTimeFormat(this.weavy?.locale, { timeStyle: "short" }).format(new Date(this.createdAt)) : "", r = !this.annotations?.length && !this.attachments?.length && !this.embed && !this.meeting && !this.pollOptions?.length && I_(this.text);
    return v`
      <div
        part=${ut({ "wy-message": !0, "wy-message-me": this.me, "wy-message-agent": this.isAgent, "wy-highlight": this.highlight })}
        ${ot(this.highlightRef)}
      >
        ${this.me ? "" : v`
              <div part="wy-message-author">
                <wy-avatar
                  .src=${this.avatar}
                  .size=${32}
                  .name=${this.name}
                  .description=${this.comment}
                  .isAgent=${this.isAgent}
                ></wy-avatar>
              </div>
            `}

        <div part="wy-message-content">
          <div part="wy-message-meta">
            ${!this.isPrivateChat && !this.me ? v` <span>${this.name} · </span> ` : ""}
            <time datetime=${this.createdAt} title=${i}>${s}</time>
          </div>

          <div part=${ut({ "wy-message-bubble": !0, "wy-message-bubble-emoji": r })}>
            ${this.messageId < 0 ? v`<wy-skeleton .text=${this.text}></wy-skeleton>` : v`
                  ${t && t.length ? v`<wy-image-grid
                        part="wy-message-bubble-section"
                        .images=${t}
                        @file-open=${(a) => {
      this.previewAttachmentsRef.value?.open(a.detail.fileId);
    }}
                      ></wy-image-grid>` : C}


                  <!-- text -->
                  ${this.html ? v`<div part=${ut({ "wy-content": !0, "wy-message-bubble-section": !0, "wy-content-emoji": r })}>${ol(this.html)}</div>` : C}

                  ${this.annotations && this.annotations.length ? v`<wy-annotation-list
                        part="wy-message-bubble-section"
                        .files=${this.annotations}
                        @file-open=${(a) => {
      this.previewAnnotationsRef.value?.open(a.detail.fileId);
    }}
                      ></wy-annotation-list>` : C}

                  ${this.pollOptions && this.pollOptions.length ? v`<wy-poll
                        .pollOptions=${this.pollOptions}
                        @vote=${(a) => this.dispatchVote(a.detail.optionId)}
                      ></wy-poll>` : C}

                  ${this.componentFeatures?.allowsFeature(z.Embeds) && this.embed ? v` <wy-embed .embed=${this.embed}></wy-embed> ` : C}

                  ${e && e.length ? v`<wy-attachment-list
                        filled
                        part="wy-message-bubble-section"
                        .files=${e}
                        @file-open=${(a) => {
      this.previewAttachmentsRef.value?.open(a.detail.fileId);
    }}
                      ></wy-attachment-list>` : C}

                  ${this.meeting ? v`<wy-meeting-card .meeting=${this.meeting}></wy-meeting-card>` : C}

                  ${this.componentFeatures?.allowsFeature(z.Reactions) && this.conversation ? v`
                        ${tO(
      `reactions-${this.conversation.id}-${this.messageId}`,
      v`<wy-reactions
                            lineBelow
                            ?lineReverse=${!this.me}
                            small
                            directionX=${this.me ? "right" : "left"}
                            .reactions=${this.reactions}
                            parentId=${this.conversation.id}
                            parentType="apps"
                            entityId=${this.messageId}
                            entityType="messages"
                          ></wy-reactions>`
    )}
                      ` : C}
                `}
          </div>
        </div>
      </div>
      ${this.componentFeatures?.allowsFeature(z.Receipts) ? v`<div part="wy-message-seenby">
            ${this.seenBy && this.seenBy.length ? v`
                  ${this.seenBy.map((a) => {
      const o = a.marked_at ? new Intl.DateTimeFormat(this.weavy?.locale, {
        dateStyle: "full",
        timeStyle: "short"
      }).format(new Date(a.marked_at)) : "";
      return v`<wy-avatar
                      title=${P(st`Seen by ${a.name} at ${o}`)}
                      .name=${a.name}
                      .src=${a.avatar_url}
                      size=${18}
                    ></wy-avatar>`;
    })}
                ` : C}
          </div>` : C}
      ${this.annotations ? tO(
      `annotation-preview-message-${this.messageId}`,
      v`
              <wy-preview
                ${ot(this.previewAnnotationsRef)}
                .files=${this.annotations}
                .isAttachment=${!0}
              ></wy-preview>
            `
    ) : C}
      ${this.attachments ? tO(
      `preview-message-${this.messageId}`,
      v`
              <wy-preview
                ${ot(this.previewAttachmentsRef)}
                .files=${[...t, ...e]}
                .isAttachment=${!0}
              ></wy-preview>
            `
    ) : C}
    `;
  }
  updated(t) {
    t.has("highlight") && this.highlight && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, c(ry, "_o"), ry), d(vx, "WyMessage"), vx);
ae.styles = [ne, P0, D4, ft];
Ee([
  O({ attribute: !1 })
], ae.prototype, "conversation", 2);
Ee([
  O({ type: Number })
], ae.prototype, "messageId", 2);
Ee([
  O({ type: Boolean })
], ae.prototype, "me", 2);
Ee([
  O({ type: Boolean })
], ae.prototype, "isAgent", 2);
Ee([
  O({ type: Boolean })
], ae.prototype, "isPrivateChat", 2);
Ee([
  O()
], ae.prototype, "name", 2);
Ee([
  O()
], ae.prototype, "comment", 2);
Ee([
  O()
], ae.prototype, "avatar", 2);
Ee([
  O()
], ae.prototype, "createdAt", 2);
Ee([
  O()
], ae.prototype, "html", 2);
Ee([
  O()
], ae.prototype, "text", 2);
Ee([
  O({ type: Array })
], ae.prototype, "annotations", 2);
Ee([
  O({ type: Array })
], ae.prototype, "attachments", 2);
Ee([
  O({ attribute: !1 })
], ae.prototype, "meeting", 2);
Ee([
  O({ type: Array })
], ae.prototype, "pollOptions", 2);
Ee([
  O({ attribute: !1 })
], ae.prototype, "embed", 2);
Ee([
  O({ type: Array })
], ae.prototype, "reactions", 2);
Ee([
  O({ type: Array })
], ae.prototype, "seenBy", 2);
Ee([
  O({ type: Boolean })
], ae.prototype, "highlight", 2);
ae = Ee([
  U("wy-message"),
  St()
], ae);
var oK = Object.defineProperty, lK = Object.getOwnPropertyDescriptor, aV = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$8"), In = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? lK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && oK(t, e, s), s;
}, "__decorateClass$C"), oV = /* @__PURE__ */ d((n, t, e) => t.has(n) || aV("Cannot " + e), "__accessCheck$8"), S9 = /* @__PURE__ */ d((n, t, e) => (oV(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$8"), cK = /* @__PURE__ */ d((n, t, e) => t.has(n) ? aV("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$8"), C9 = /* @__PURE__ */ d((n, t, e, i) => (oV(n, t, "write to private field"), t.set(n, e), e), "__privateSet$7"), Hc, Ox, ay;
let Ai = (Ox = (ay = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.header = !1, this.lastReadMessagePosition = "below", this.showNewMessages = !1, this.isCreatingConversation = !1, this.showReadReceipts = !1, this.messagesQuery = new Rl(this), this.membersQuery = new gn(this), this.addMessageMutation = new An(this), this.infiniteScroll = new FB(this), this.pagerRef = wt(), this.bottomRef = wt(), this.editorRef = wt(), this.shouldBeAtBottom = !0, this.isTyping = !1, this.handleRealtimeMessage = async (t) => {
      if (!this.weavy || !this.conversation || !(this.conversationId && this.conversationId > 0) || !this.user)
        return;
      await this.messagesQuery.observer?.getCurrentQuery().promise;
      const e = t.message.app.uid ?? t.message.app.id, i = ["messages", t.message.app.id];
      let s = w1(this.weavy.queryClient, i, t.message.id);
      s || (t.message.created_by.id === this.user.id && (s = aa(this.weavy.queryClient, i, !0), s && ge(this.weavy.queryClient, i, s.id, (r) => {
        r.id = t.message.id, r.app = t.message.app, r.text = t.message.text, r.html = t.message.html, r.embed = t.message.embed, r.meeting = t.message.meeting, r.attachments = t.message.attachments, r.options = t.message.options, r.created_at = t.message.created_at, r.created_by = t.message.created_by, r.updated_at = t.message.updated_at, r.updated_by = t.message.updated_by;
      })), s || ra(this.weavy.queryClient, i, t.message)), this.weavy.queryClient.setQueryData(
        ["apps", e],
        (r) => r && { ...r, last_message: t.message }
      ), t.actor.id !== this.user.id && (this.isAtBottom ? (this.markAsRead(t.message.id), requestAnimationFrame(() => {
        this.scrollToBottom();
      })) : (this.weavy.queryClient.setQueryData(
        ["apps", e],
        (r) => r && { ...r, is_unread: !0 }
      ), this.lastReadMessagePosition = "above", this.lastReadMessageId = t.message.id, this.showNewMessages = !0), Ct(
        this.weavy.queryClient,
        { queryKey: ["members", t.message.app.id], exact: !1 },
        t.actor.id,
        (r) => {
          r.marked_id = t.message.id, r.marked_at = t.message.created_at;
        }
      ));
    }, this.handleRealtimeReactionAdded = (t) => {
      !this.weavy || !this.user || !this.conversation || Ct(
        this.weavy.queryClient,
        { queryKey: ["messages"], exact: !1 },
        t.entity.id,
        (e) => {
          e.reactions || (e.reactions = { count: 0 }), e.reactions.data = [
            ...(e.reactions.data || []).filter((i) => i.created_by?.id !== t.actor.id),
            { content: t.reaction, created_by: t.actor }
          ];
        }
      );
    }, this.handleRealtimeReactionDeleted = (t) => {
      !this.weavy || !this.conversation || !this.user || Ct(
        this.weavy.queryClient,
        { queryKey: ["messages"], exact: !1 },
        t.entity.id,
        (e) => {
          e.reactions && e.reactions.data && (e.reactions.data = e.reactions.data.filter((i) => i.created_by?.id !== t.actor.id));
        }
      );
    }, this.handleRealtimeMarked = (t) => {
      !this.weavy || !this.conversation || Ct(
        this.weavy.queryClient,
        { queryKey: ["members", this.conversation.id] },
        t.actor.id,
        (e) => {
          e.marked_id = t.marked_id, e.marked_at = t.marked_at;
        }
      );
    }, this.markAsReadHandler = () => {
      !document.hidden && this.isAtBottom && this.markAsRead();
    }, cK(this, Hc);
  }
  isPrivateChat(t) {
    return (t ?? this.conversation)?.type === gt.PrivateChat;
  }
  isChatRoom(t) {
    return (t ?? this.conversation)?.type === gt.ChatRoom;
  }
  /**
   * Read-only helper returning whether the viewport is currently scrolled to the bottom.
   *
   * @internal
   */
  get isAtBottom() {
    return this.bottomRef.value ? XL(this.bottomRef.value) : !0;
  }
  /**
   * Scroll the conversation to the bottom.
   *
   * @param smooth - Whether to perform a smooth scroll.
   * @returns Promise<void>
   *
   * @internal
   */
  async scrollToBottom(t = !1) {
    this.bottomRef.value && await rO(this.bottomRef.value), FL(this.bottomRef.value) && this.conversationId && this.conversationId > 0 && (requestAnimationFrame(() => {
      Nv(this.weavy?.queryClient, ["messages", this.conversationId], void 0, 1);
    }), await NL(this.bottomRef.value, t));
  }
  /**
   * Handle typing indicator events from child components.
   *
   * @internal
   * @param e - Typing event
   */
  handleTyping(t) {
    this.isTyping = !!t.detail.count, this.isTyping && this.isAtBottom && requestAnimationFrame(() => {
      this.scrollToBottom(!0);
    });
  }
  /**
   * Submit handler for the message editor. Adds a message and optionally creates a conversation first.
   *
   * @internal
   * @param e - Editor submit event
   * @returns Promise<MessageType>
   */
  async handleSubmit(t) {
    if (!this.user)
      throw new Error("Error submitting message. Missing user.");
    const e = {
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      blobs: t.detail.blobs,
      user: this.user,
      context: t.detail.contextData
    };
    if (this.agentInstructions && (e.metadata = {
      instructions: this.agentInstructions
    }), !this.conversation && this.weavy && this.createConversation && (this.isCreatingConversation = !0, await this.createConversation(e), await this.updateComplete), !this.conversation)
      throw new Error("Error submitting message. Missing conversation.");
    const i = await this.addMessageMutation.mutate({
      ...e,
      app_id: this.conversation.id
    });
    return this.showNewMessages = !1, requestAnimationFrame(() => {
      this.scrollToBottom();
    }), this.isCreatingConversation = !1, i;
  }
  /**
   * Set the editor text programmatically.
   *
   * @param text - Text to set in the editor.
   * @returns Promise<void>
   *
   * @internal
   */
  async setEditorText(t) {
    this.editorRef.value && (this.editorRef.value.text = t, await this.editorRef.value.updateComplete, await new Promise((e) => requestAnimationFrame(e)));
  }
  /**
   * Set metadata on the editor instance.
   *
   * @param metadata - Optional metadata object.
   * @returns Promise<void>
   *
   * @internal
   */
  async setEditorMetadata(t = {}) {
    await this.updateComplete, this.editorRef.value && (this.editorRef.value.metadata = t);
  }
  /**
   * Select all content in the editor.
   *
   * @internal
   */
  async selectAllInEditor() {
    this.editorRef.value && (await this.updateComplete, await this.editorRef.value.updateComplete, this.editorRef.value?.selectAllContent());
  }
  /**
   * Move the editor cursor to the end of the content.
   *
   * @internal
   */
  async setCursorLastInEditor() {
    this.editorRef.value && (await this.updateComplete, await this.editorRef.value.updateComplete, this.editorRef.value?.setCursorLast());
  }
  /**
   * Focus the editor input.
   *
   * @internal
   */
  focusEditor() {
    this.editorRef.value && this.editorRef.value?.focusInput();
  }
  /**
   * Sets the conversation title when the conversation is empty, based on message text.
   *
   * @internal
   * @param name - Title string to set.
   * @returns Promise<void>
   */
  async setEmptyConversationTitle(t) {
    !this.conversation || this.conversation.name || (t = SP(t), await this.updateConversationMutation?.mutate({ appId: this.conversation.id, name: t }));
  }
  /**
   * Mark the conversation as read. Respects visibility and component lifecycle.
   *
   * @param messageId - Optional message id to mark as read.
   * @returns Promise<void>
   *
   * @internal
   */
  async markAsRead(t) {
    await N9(), await Promise.race([rO(this), QS(this, !1)]), !(!this.componentFeatures?.allowsFeature(z.Receipts) || !this.isConnected) && this.conversation && this.conversation.last_message && await this.markConversationMutation?.mutate({
      app: this.conversation,
      messageId: t ?? this.conversation.last_message.id,
      userId: this.user?.id
    });
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("weavy") && this.weavy && (this.updateConversationMutation = d4(this.weavy), this.markConversationMutation = c4(this.weavy)), (t.has("weavy") || t.has("conversationId") || t.has("componentFeatures")) && this.weavy) {
      (e = S9(this, Hc)) == null || e.call(this);
      const i = t.get("conversationId");
      if (i && i > 0 && requestAnimationFrame(() => {
        Nv(this.weavy?.queryClient, ["messages", i], void 0, 1);
      }), this.conversationId && this.conversationId > 0) {
        await this.messagesQuery.trackInfiniteQuery(mI(this.weavy, this.conversationId)), await this.addMessageMutation.trackMutation(
          gI(this.weavy, ["messages", this.conversationId])
        ), await this.membersQuery.trackQuery(p4(this.weavy, this.conversationId, {})), this.pollMutation = S0(this.weavy, this.conversationId, ["messages", this.conversationId]), this.lastReadMessageId = void 0, this.showNewMessages = !1;
        const s = `a${this.conversationId}`;
        this.weavy.subscribe(s, "message_created", this.handleRealtimeMessage), this.componentFeatures?.allowsFeature(z.Reactions) && (this.weavy.subscribe(s, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(s, "reaction_removed", this.handleRealtimeReactionDeleted)), this.componentFeatures?.allowsFeature(z.Receipts) && this.weavy.subscribe(s, "app_marked", this.handleRealtimeMarked).then((r) => {
          this.showReadReceipts = r;
        }), C9(this, Hc, () => {
          this.weavy?.unsubscribe(s, "message_created", this.handleRealtimeMessage), this.weavy?.unsubscribe(s, "reaction_added", this.handleRealtimeReactionAdded), this.weavy?.unsubscribe(s, "reaction_removed", this.handleRealtimeReactionDeleted), this.weavy?.unsubscribe(s, "app_marked", this.handleRealtimeMarked), this.showReadReceipts = !1, C9(this, Hc, void 0);
        });
      } else
        this.messagesQuery.untrackInfiniteQuery(), this.addMessageMutation.untrackMutation(), this.membersQuery.untrackQuery();
    }
    if (t.has("showNewMessages") && this.showNewMessages && (this.shouldBeAtBottom = this.isAtBottom), t.has("conversationId") && t.get("conversationId") !== this.conversationId ? this.shouldBeAtBottom = !!this.conversationId : this.shouldBeAtBottom = this.isAtBottom, t.has("conversation")) {
      const i = t.get("conversation");
      if (i?.id !== this.conversation?.id || i?.is_unread !== this.conversation?.is_unread)
        if (this.componentFeatures?.allowsFeature(z.Receipts) && this.conversation?.is_unread) {
          const s = this.membersQuery.result.data?.data?.find(
            (r) => r.id === this.user?.id
          )?.marked_id;
          s && s < this.conversation.last_message.id && (this.lastReadMessagePosition = "below", this.lastReadMessageId = s, this.showNewMessages = !0), (i?.id !== this.conversation?.id || i?.last_message.id !== this.conversation?.last_message.id && (this.shouldBeAtBottom || this.isAtBottom)) && this.markAsRead();
        } else i?.id !== this.conversation?.id && (this.showNewMessages = !1);
    }
    if (this.conversation && !this.conversation?.name && !hS(this.messagesQuery.result.data)) {
      const i = cs(this.messagesQuery.result.data).find((s) => s.plain);
      i && this.setEmptyConversationTitle(kP(i.plain));
    }
  }
  renderConversationHeader() {
    if (!this.header)
      return v` <!-- Top of the conversation --> `;
    const { isPending: t, hasNextPage: e } = this.messagesQuery.result ?? {};
    if (!this.conversation || t || e)
      return C;
    const { data: i } = this.membersQuery.result ?? {}, s = this.user && this.isPrivateChat() ? (this.conversation?.members?.data || []).filter((r) => r.id !== this.user?.id)?.[0] ?? this.user : null;
    return v`
      <wy-avatar-header description=${Ot(s?.comment)}>
        ${this.conversation.avatar_url ? v`<wy-avatar .size=${96} src=${this.conversation.avatar_url}></wy-avatar>` : this.isChatRoom() ? v` <wy-avatar-group
              .members=${i?.data}
              title=${this.conversation.name}
              .size=${96}
            ></wy-avatar-group>` : s?.avatar_url ? v`
              <wy-avatar
                src=${Ot(s?.avatar_url)}
                name=${this.conversation.name}
                description=${Ot(s?.comment)}
                ?isAgent=${s?.is_agent}
                size=${96}
              ></wy-avatar>
            ` : C}
      </wy-avatar-header>
    `;
  }
  renderMessages() {
    const { isPending: t } = this.weavy?.network ?? { isPending: !0 }, {
      data: e,
      isPending: i
      //hasNextPage,
    } = this.messagesQuery.result ?? { isPending: t }, { data: s } = this.membersQuery.result ?? {}, r = cs(e);
    let a;
    return this.conversation && e && !hS(e) ? v`
          <div part="wy-messages">
            <div ${ot(this.pagerRef)} part="wy-pager wy-pager-top"></div>

            ${r && this.conversation && this.user ? Mi(
      r,
      (o) => o.id,
      (o, l) => {
        const h = new Date(o.created_at);
        let u = v``;
        if (a?.toDateString() !== h.toDateString()) {
          const m = new Intl.DateTimeFormat(this.weavy?.locale, {
            dateStyle: "short"
          }).format(h);
          a = h, u = v`<time part="wy-message-date-separator">${m}</time>`;
        }
        let p = v``;
        this.lastReadMessageId && this.lastReadMessageId === o.id && (p = v`<div
                        id="unread-marker"
                        part="wy-toast wy-toast-action wy-fade ${this.showNewMessages ? "wy-show" : ""}"
                        tabindex=${this.showNewMessages ? 0 : -1}
                        @click=${() => {
          let m = `#message-${this.lastReadMessageId}`;
          this.lastReadMessagePosition === "below" && (m += "~ wy-message"), this.renderRoot.querySelector(m)?.scrollIntoView({
            block: "start",
            inline: "nearest",
            behavior: "smooth"
          });
        }}
                        @keydown=${Le}
                        @keyup=${di}
                      >
                        ${P("New messages")}
                      </div>`);
        const y = s?.data?.find((m) => m.id === o.created_by.id) || o.created_by;
        return v`${[
          v`${u}`,
          v`${this.lastReadMessagePosition === "above" ? p : C}`,
          tO(
            `message-${o.id}`,
            v`<wy-message
                          id="message-${o.id}"
                          .conversation=${this.conversation}
                          .messageId=${o.id}
                          .me=${y.id === this.user?.id}
                          .isAgent=${y.is_agent || !1}
                          .isPrivateChat=${this.conversation?.type === gt.PrivateChat || this.conversation?.type === gt.AgentChat}
                          .name=${y.name}
                          .comment=${y.comment}
                          .avatar=${y.avatar_url}
                          .createdAt=${o.created_at}
                          .text=${o.plain}
                          .html=${o.html}
                          .annotations=${o.annotations?.data}
                          .attachments=${o.attachments?.data}
                          .meeting=${o.meeting}
                          .pollOptions=${o.options?.data}
                          .embed=${o.embed}
                          .reactions=${o.reactions?.data}
                          .seenBy=${this.showReadReceipts && s && s.data && s.data.length > 0 ? s.data.filter((m) => m.marked_id === o.id && m.id !== this.user?.id) : []}
                          @vote=${(m) => {
              m.detail.parentId && m.detail.parentType && m.detail.parentId && this.pollMutation?.mutate({
                optionId: m.detail.optionId,
                parentType: m.detail.parentType,
                parentId: m.detail.parentId
              });
            }}
                        ></wy-message>`
          ),
          v`${this.lastReadMessagePosition === "below" ? p : C}`
        ]}`;
      }
    ) : C}
            ${this.componentFeatures?.allowsFeature(z.Typing) ? v`
                  <wy-message-typing
                    .conversationId=${this.conversation.id}
                    .userId=${this.user?.id}
                    .isPrivateChat=${this.isPrivateChat()}
                    .members=${s?.data ?? []}
                    @typing=${(o) => this.handleTyping(o)}
                  ></wy-message-typing>
                ` : C}
          </div>
        ` : v`
          <div part="wy-messages">
            <wy-empty part="wy-pane">
              ${i && this.conversationId || this.isCreatingConversation ? v`<wy-progress-circular indeterminate overlay></wy-progress-circular>` : v` <slot name="empty">${this.conversationId ? P("Start the conversation!") : C}</slot> `}
            </wy-empty>
          </div>
        `;
  }
  render() {
    return v`
      ${this.renderConversationHeader()} ${this.renderMessages()}
      <div ${ot(this.bottomRef)}></div>
      <div part="wy-footerbar wy-footerbar-sticky wy-footerbar-floating">
        <slot name="footerbar"></slot>
        <wy-message-editor
          ${ot(this.editorRef)}
          .draft=${!0}
          placeholder=${this.placeholder ?? P("Type a message...")}
          ?disabled=${this.conversation && !lm(rl.Create, this.conversation?.permissions)}
          @submit=${(t) => this.handleSubmit(t)}
        ></wy-message-editor>
      </div>
    `;
  }
  updated() {
    this.shouldBeAtBottom && (Nv(this.weavy?.queryClient, ["messages", this.conversationId], void 0, 1), requestAnimationFrame(() => {
      this.scrollToBottom();
    })), this.bottomObserver || (this.bottomObserver = new IntersectionObserver((t) => {
      t.forEach((e) => {
        e.isIntersecting && !this.isTyping && this.conversation?.is_unread && this.markAsRead();
      });
    })), this.bottomRef && this.bottomRef.value && this.bottomObserver.observe(this.bottomRef.value), this.infiniteScroll.observe(this.messagesQuery.result, this.pagerRef.value);
  }
  // hook up observer
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("visibilitychange", this.markAsReadHandler), this.conversationId && this.requestUpdate("conversationId");
  }
  disconnectedCallback() {
    var t;
    (t = S9(this, Hc)) == null || t.call(this), this.bottomObserver && this.bottomObserver.disconnect(), document.removeEventListener("visibilitychange", this.markAsReadHandler), this.conversation = void 0, this.shouldBeAtBottom = this.isAtBottom, super.disconnectedCallback();
  }
}, c(ay, "Po"), ay), d(Ox, "WyConversation"), Ox);
Hc = /* @__PURE__ */ new WeakMap();
Ai.styles = [
  P0,
  va,
  Il,
  jI,
  y4,
  et`
      :host {
        position: relative;
        display: flex;
        flex-direction: column;
        flex: 1 1 auto;
      }
    `
];
In([
  or({ context: FP }),
  O({ attribute: !1 })
], Ai.prototype, "conversation", 2);
In([
  O({ type: Number })
], Ai.prototype, "conversationId", 2);
In([
  O({ type: Boolean })
], Ai.prototype, "header", 2);
In([
  O()
], Ai.prototype, "agentInstructions", 2);
In([
  O()
], Ai.prototype, "placeholder", 2);
In([
  F()
], Ai.prototype, "lastReadMessagePosition", 2);
In([
  F()
], Ai.prototype, "lastReadMessageId", 2);
In([
  F()
], Ai.prototype, "showNewMessages", 2);
In([
  F()
], Ai.prototype, "isCreatingConversation", 2);
In([
  F()
], Ai.prototype, "showReadReceipts", 2);
Ai = In([
  U("wy-conversation"),
  St()
], Ai);
const hK = et`:host{--_track-height: 4px;--_track-shape: 2px;--_active-indicator-height: 2px;--_active-indicator-color: var(--wy-primary, var(--wy-primary-light, #2f628c));--_warning-color: var(--wy-warning, var(--wy-warning-light, #adb140));--_error-color: var(--wy-error, var(--wy-error-light, #ba1821));--_track-color: var(--wy-surface-variant, var(--wy-surface-variant-light, #dee3eb));display:contents;position:relative}[part~=wy-progress-linear]{border-radius:var(--_track-shape);position:relative;min-width:80px;height:var(--_track-height);content-visibility:auto;contain:strict;flex:1;direction:ltr;inset:0;border-radius:inherit;overflow:hidden;display:flex;align-items:center}[part~=wy-progress-linear][part~=wy-progress-padded]{margin:calc(1*var(--wy-size, 1rem)) calc(2*var(--wy-size, 1rem))}[part~=wy-inactive-track],[part~=wy-bar],[part~=wy-bar-inner]{position:absolute}[part~=wy-bar]{animation:none;width:100%;height:var(--_active-indicator-height);transform-origin:left center;transition:transform .25s cubic-bezier(.4,0,.6,1)}[part~=wy-secondary-bar]{display:none}[part~=wy-bar-inner]{inset:0;animation:none;background:var(--_active-indicator-color)}[part~=wy-inactive-track]{background:var(--_track-color);inset:0;transition:transform .25s cubic-bezier(.4,0,.6,1);transform-origin:left center}[part~=wy-progress-indeterminate] [part~=wy-bar]{transition:none}[part~=wy-progress-indeterminate] [part~=wy-primary-bar]{inset-inline-start:-145.167%}[part~=wy-progress-indeterminate] [part~=wy-secondary-bar]{inset-inline-start:-54.8889%;display:block}[part~=wy-progress-indeterminate] [part~=wy-primary-bar]{animation:linear infinite 2s;animation-name:primary-indeterminate-translate}[part~=wy-progress-indeterminate] [part~=wy-primary-bar]>[part~=wy-bar-inner]{animation:linear infinite 2s primary-indeterminate-scale}[part~=wy-progress-indeterminate] [part~=wy-secondary-bar]{animation:linear infinite 2s;animation-name:secondary-indeterminate-translate}[part~=wy-progress-indeterminate] [part~=wy-secondary-bar]>[part~=wy-bar-inner]{animation:linear infinite 2s secondary-indeterminate-scale}@keyframes primary-indeterminate-scale{0%{transform:scaleX(.08)}36.65%{animation-timing-function:cubic-bezier(.334731,.12482,.785844,1);transform:scaleX(.08)}69.15%{animation-timing-function:cubic-bezier(.06,.11,.6,1);transform:scaleX(.661479)}to{transform:scaleX(.08)}}@keyframes secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(.205028,.057051,.57661,.453971);transform:scaleX(.08)}19.15%{animation-timing-function:cubic-bezier(.152313,.196432,.648374,1.00432);transform:scaleX(.457104)}44.15%{animation-timing-function:cubic-bezier(.257759,-.003163,.211762,1.38179);transform:scaleX(.72796)}to{transform:scaleX(.08)}}@keyframes primary-indeterminate-translate{0%{transform:translate(0)}20%{animation-timing-function:cubic-bezier(.5,0,.701732,.495819);transform:translate(0)}59.15%{animation-timing-function:cubic-bezier(.302435,.381352,.55,.956352);transform:translate(83.6714%)}to{transform:translate(200.611%)}}@keyframes secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(.15,0,.515058,.409685);transform:translate(0)}25%{animation-timing-function:cubic-bezier(.31033,.284058,.8,.733712);transform:translate(37.6519%)}48.35%{animation-timing-function:cubic-bezier(.4,.627035,.6,.902026);transform:translate(84.3862%)}to{transform:translate(160.278%)}}[part~=wy-progress-warning] [part~=wy-primary-bar],[part~=wy-progress-warning] [part~=wy-secondary-bar],[part~=wy-progress-warning] [part~=wy-bar-inner],[part~=wy-progress-error] [part~=wy-primary-bar],[part~=wy-progress-error] [part~=wy-secondary-bar],[part~=wy-progress-error] [part~=wy-bar-inner]{animation:none!important}[part~=wy-progress-warning] [part~=wy-secondary-bar],[part~=wy-progress-error] [part~=wy-secondary-bar]{display:none!important}[part~=wy-progress-warning] [part~=wy-primary-bar],[part~=wy-progress-error] [part~=wy-primary-bar]{transform:scaleX(1)!important}[part~=wy-progress-warning] [part~=wy-bar-inner]{background:var(--_warning-color)}[part~=wy-progress-error] [part~=wy-bar-inner]{background:var(--_error-color)}`;
var dK = Object.defineProperty, uK = Object.getOwnPropertyDescriptor, hr = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? uK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && dK(t, e, s), s;
}, "__decorateClass$B"), bx, oy;
let mn = (bx = (oy = class extends pt {
  constructor() {
    super(...arguments), this.shadowParts = new Y(this), this.padded = !1, this.overlay = !1, this.reveal = !1, this.value = 0, this.max = 1, this.indeterminate = !1, this.warning = !1, this.error = !1;
  }
  render() {
    let t;
    try {
      Number.isFinite(this.value) && Number.isFinite(this.max) && this.max > 0 && (t = this.value / this.max);
    } catch (r) {
      console.error(r);
    }
    const e = this.indeterminate || t === void 0, i = {
      transform: `scaleX(${(e ? 1 : this.value / this.max) * 100}%)`
    }, s = {
      "wy-progress": !0,
      "wy-progress-linear": !0,
      "wy-progress-indeterminate": e,
      "wy-progress-overlay": this.overlay,
      "wy-progress-padded": this.padded,
      "wy-progress-reveal": this.reveal,
      "wy-progress-warning": this.warning,
      "wy-progress-error": this.error
    };
    return v`
      <div
        part=${ut(s)}
        role="progressbar"
        aria-label="${C}"
        aria-valuemin="0"
        aria-valuemax=${this.max}
        aria-valuenow=${e ? C : this.value}
      >
        <div part="wy-inactive-track"></div>
        <div part="wy-bar wy-primary-bar" style=${Zw(i)}>
          <div part="wy-bar-inner"></div>
        </div>
        <div part="wy-bar wy-secondary-bar">
          <div part="wy-bar-inner"></div>
        </div>
      </div>
    `;
  }
}, c(oy, "Mo"), oy), d(bx, "WyProgressLinear"), bx);
mn.styles = [ne, KI, hK];
hr([
  O({ type: Boolean })
], mn.prototype, "padded", 2);
hr([
  O({ type: Boolean })
], mn.prototype, "overlay", 2);
hr([
  O({ type: Boolean })
], mn.prototype, "reveal", 2);
hr([
  O({ type: Number })
], mn.prototype, "value", 2);
hr([
  O({ type: Number })
], mn.prototype, "max", 2);
hr([
  O({ type: Boolean })
], mn.prototype, "indeterminate", 2);
hr([
  O({ type: Boolean })
], mn.prototype, "warning", 2);
hr([
  O({ type: Boolean })
], mn.prototype, "error", 2);
mn = hr([
  U("wy-progress-linear")
], mn);
var pK = Object.getOwnPropertyDescriptor, lV = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$7"), fK = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? pK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = a(s) || s);
  return s;
}, "__decorateClass$A"), yK = /* @__PURE__ */ d((n, t, e) => t.has(n) || lV("Cannot " + e), "__accessCheck$7"), P9 = /* @__PURE__ */ d((n, t, e) => (yK(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$7"), mK = /* @__PURE__ */ d((n, t, e) => t.has(n) ? lV("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$7"), sO, $x, ly;
let Cb = ($x = (ly = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), mK(this, sO, new w0(this));
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("contextId") || t.has("componentFeatures")) && this.weavy && this.contextId && this.componentFeatures?.allowsFeature(z.ContextData) && await P9(this, sO).trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.contextId, "data"],
          exact: !0
        }
      },
      this.weavy.queryClient
    );
  }
  render() {
    const { result: t, isMutating: e } = P9(this, sO), i = t?.filter((a) => a.variables?.file), s = KP(i), r = lb(i);
    return this.componentFeatures?.allowsFeature(z.ContextData) && t && t.length ? v`
          ${e || s.percent !== null && s.percent < 100 ? v`
                <wy-progress-linear
                  ?indeterminate=${s.percent === null}
                  overlay
                  reveal
                  ?warning=${r === "error"}
                  value=${s.percent ?? 0}
                  max=${100}
                ></wy-progress-linear>
              ` : C}
        ` : C;
  }
}, c(ly, "So"), ly), d($x, "WyContextDataProgress"), $x);
sO = /* @__PURE__ */ new WeakMap();
Cb.styles = [ft];
Cb = fK([
  U("wy-context-data-progress")
], Cb);
var gK = Object.defineProperty, wK = Object.getOwnPropertyDescriptor, U4 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? wK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && gK(t, e, s), s;
}, "__decorateClass$z"), xx, cy;
let wl = (xx = (cy = class extends _i {
  constructor() {
    super(...arguments), this.appType = gt.Chat, this.componentFeatures = new ni({
      // All available features as enabled/disabled by default
      [z.Attachments]: !0,
      [z.ContextData]: !0,
      [z.CloudFiles]: !0,
      [z.Embeds]: !0,
      [z.GoogleMeet]: !0,
      [z.Meetings]: !0,
      [z.Mentions]: !0,
      [z.MicrosoftTeams]: !0,
      [z.Polls]: !0,
      [z.Previews]: !0,
      [z.Reactions]: !0,
      [z.Receipts]: !1,
      [z.Typing]: !1,
      [z.ZoomMeetings]: !0
    }), this.theme = new wn(this, wl.styles);
  }
  render() {
    return v`
      <wy-buttons position="floating" reverse><slot name="actions"></slot></wy-buttons>
      <wy-conversation
        .agentInstructions=${this.instructions}
        .conversation=${this.app}
        .conversationId=${this.app?.id}
        .placeholder=${this.placeholder}
      >
        <wy-context-data-progress slot="footerbar"></wy-context-data-progress>
      </wy-conversation>
    `;
  }
}, c(cy, "Ao"), cy), d(xx, "WyChat"), xx);
wl.styles = [ws, _l, zl, Te, bi];
U4([
  O()
], wl.prototype, "instructions", 2);
U4([
  O()
], wl.prototype, "placeholder", 2);
wl = U4([
  U("wy-chat"),
  St()
], wl);
var vK = Object.defineProperty, OK = Object.getOwnPropertyDescriptor, cV = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? OK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && vK(t, e, s), s;
}, "__decorateClass$y"), kx, hy;
let gm = (kx = (hy = class extends _i {
  constructor() {
    super(...arguments), this.appType = gt.Comments, this.componentFeatures = new ni({
      // All available features as enabled/disabled by default
      [z.Attachments]: !0,
      [z.CloudFiles]: !0,
      [z.ContextData]: !0,
      [z.Embeds]: !0,
      [z.GoogleMeet]: !1,
      [z.Meetings]: !1,
      [z.Mentions]: !0,
      [z.MicrosoftTeams]: !1,
      [z.Polls]: !0,
      [z.Previews]: !0,
      [z.Reactions]: !0,
      [z.Typing]: !1,
      // Has no effect currently
      [z.ZoomMeetings]: !1
    }), this.theme = new wn(this, gm.styles);
  }
  render() {
    return v`
      <wy-buttons position="floating" reverse><slot name="actions"></slot></wy-buttons>
      <wy-comment-list .parentId=${this.app?.id} .location=${"apps"} .placeholder=${this.placeholder}></wy-comment-list>
      <wy-context-data-progress></wy-context-data-progress>
    `;
  }
}, c(hy, "zo"), hy), d(kx, "WyComments"), kx);
gm.styles = [ws, _l, zl, Te, bi, N4];
cV([
  O()
], gm.prototype, "placeholder", 2);
gm = cV([
  U("wy-comments"),
  St()
], gm);
function hV(n) {
  if (!this.weavy || !this.app)
    return;
  const t = {
    message: n.message,
    direction: n.message.created_by.id === this.user?.id ? "outbound" : "inbound"
  };
  n.message.created_by.is_agent && (t.agent = n.message.created_by.uid);
  const e = new CustomEvent("wy-message", {
    bubbles: !1,
    cancelable: !1,
    composed: !0,
    detail: t
  });
  this.dispatchEvent(e);
}
c(hV, "v3");
d(hV, "triggerMessageEvent");
var bK = Object.defineProperty, $K = Object.getOwnPropertyDescriptor, H4 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? $K(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && bK(t, e, s), s;
}, "__decorateClass$x"), Sx, dy;
let vl = (Sx = (dy = class extends _i {
  constructor() {
    super(...arguments), this.appType = gt.AgentChat, this.componentFeatures = new ni({
      // All available features as enabled/disabled by default
      [z.Attachments]: !1,
      [z.ContextData]: !0,
      [z.Embeds]: !0,
      [z.Mentions]: !1,
      [z.Previews]: !0,
      [z.Reactions]: !1,
      [z.Typing]: !0
    }), this.theme = new wn(this, vl.styles), this.conversationRef = wt(), this.handleRealtimeMessage = hV.bind(this);
  }
  /**
   * Sets the editor input to a suggested text. This replaces the text content of the editor. This can be used to create any custom suggestions.
   *
   * @param {string} text - The text suggestion to place in the editor.
   */
  async setSuggestion(t) {
    await this.conversationRef.value?.setEditorText(t);
  }
  async willUpdate(t) {
    if (await super.willUpdate(t), t.has("weavy") && this.weavy && (this.addConversationMutation = e4(this.weavy)), (t.has("app") || t.has("weavy")) && this.weavy && (this.unsubscribeToRealtime?.(), this.app)) {
      const e = `a${this.app.id}`;
      this.weavy.subscribe(e, "message_created", this.handleRealtimeMessage), this.unsubscribeToRealtime = () => {
        this.weavy?.unsubscribe(e, "message_created", this.handleRealtimeMessage), this.unsubscribeToRealtime = void 0;
      };
    }
    t.has("agent") && t.get("agent") && this.agent && this.reset();
  }
  render() {
    return this.agent ? v`
          <wy-buttons position="floating" reverse>
            <slot name="actions"></slot>
          </wy-buttons>
          <wy-conversation
            ${ot(this.conversationRef)}
            .conversation=${this.app}
            .conversationId=${this.app?.id}
            .placeholder=${this.placeholder ?? P("Ask anything...")}
            .agentInstructions=${this.instructions}
            .createConversation=${this.agent && this.addConversationMutation ? async (t) => {
      if (!this.agent || !this.addConversationMutation)
        throw new Error("Agent or addConversationMutation not defined");
      const e = {
        uid: `wy-copilot-${Oh()}`,
        name: SP(kP(this.name ?? t.text)),
        members: [this.agent],
        type: Sn.AgentChat
      }, i = await this.addConversationMutation.mutate(e);
      return this.app = i, await this.updateComplete, i;
    } : void 0}
          >
            <slot
              slot="empty"
              name="empty"
              @click=${async (t) => {
      t.target.matches(".suggestion") && (t.stopPropagation(), await this.setSuggestion(t.target.innerText), await this.conversationRef.value?.setCursorLastInEditor(), this.conversationRef.value?.focusEditor());
    }}
              @keydown=${Le}
              @keyup=${di}
            >
              <slot name="header">
                <wy-icon-display>
                  <slot name="icon">
                    <wy-icon name="stars"></wy-icon>
                  </slot>
                </wy-icon-display>
              </slot>
              <slot name="suggestions">
                <wy-item-list>
                  <slot name="suggestion-list">
                    <!--wy-button class="suggestion">Summarize this page</wy-button-->
                  </slot>
                </wy-item-list>
              </slot>
              <slot name="footer"></slot>
            </slot>
            <wy-context-data-progress slot="footerbar"></wy-context-data-progress>
          </wy-conversation>
        ` : v`
          <wy-empty>
            <wy-icon-display>
              <slot name="icon">
                <wy-icon name="stars"></wy-icon>
              </slot>
            </wy-icon-display>
          </wy-empty>
        `;
  }
}, c(dy, "Ro"), dy), d(Sx, "WyCopilot"), Sx);
vl.styles = [ws, _l, zl, Te, bi];
H4([
  O()
], vl.prototype, "instructions", 2);
H4([
  O()
], vl.prototype, "placeholder", 2);
vl = H4([
  U("wy-copilot"),
  St()
], vl);
var xK = Object.defineProperty, kK = Object.getOwnPropertyDescriptor, E1 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? kK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && xK(t, e, s), s;
}, "__decorateClass$w"), Cx, uy;
let ua = (Cx = (uy = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.order = { by: "name", descending: !1 }, this.view = "list", this.showTrashed = !1, this.showUploadSheet = !1, this.mutatingFiles = new w0(
      this
    ), this.previousFailedFileMutations = [], this.fileInputRef = wt(), this.cloudFilesRef = wt(), this.openFileInput = () => {
      this.fileInputRef.value?.click();
    }, this.openCloudFiles = () => {
      this.cloudFilesRef.value?.open();
    };
  }
  // remove file attachment
  /**
   * Remove (or abort) an ongoing upload mutation.
   *
   * @internal
   * @param mutationState - Mutation state to remove.
   */
  async handleRemoveMutation(t) {
    const e = await this.whenWeavy(), i = await this.whenApp();
    t.status === "pending" && ab(t.variables) && t.variables.abort?.();
    const s = t.status === "error" && !t.variables?.blob || t.status === "pending" ? ["apps", i.id, "blobs"] : ["apps", i.id, "files"];
    YP(
      e.queryClient,
      s,
      (r) => r.state.submittedAt === t.submittedAt
    );
  }
  /**
   * Retry an upload by replacing the existing file.
   *
   * @internal
   * @param mutation - Failed mutation carrying the blob data.
   */
  handleOverwriteUpload(t) {
    const e = t.variables?.blob;
    e && this.dispatchCreateFiles([e], !0);
  }
  /**
   * Dispatch an `upload-files` event with the selected files.
   *
   * @param files - Files chosen from the native picker.
   * @returns Whether the event was not canceled.
   */
  dispatchUploadFiles(t) {
    this.weavy && this.app && (SL(this.weavy, this.app), lb(this.mutatingFiles.result) === "ok" && cb(this.weavy, this.app));
    const e = new CustomEvent("upload-files", {
      detail: { files: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit an `external-blobs` event with selected cloud blobs.
   *
   * @internal
   * @param externalBlobs - Blobs returned from the cloud picker.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchExternalBlobs(t) {
    const e = new CustomEvent("external-blobs", {
      detail: { externalBlobs: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `create-files` event for programmatic uploads.
   *
   * @internal
   * @param blobs - Blobs to create files from.
   * @param replace - When true, replace the existing file.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchCreateFiles(t, e = !1) {
    const i = new CustomEvent("create-files", {
      detail: { blobs: t, replace: e }
    });
    return this.dispatchEvent(i);
  }
  /**
   * Emit an `order` event reflecting the chosen sort order.
   *
   * @internal
   * @param order - Order to apply.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `view` event for changing layout mode.
   *
   * @internal
   * @param view - Layout to activate.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchView(t) {
    const e = new CustomEvent("view", { detail: { view: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `show-trashed` event to toggle trashed visibility.
   *
   * @internal
   * @param showTrashed - Whether to show trashed files.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchShowTrashed(t) {
    const e = new CustomEvent("show-trashed", {
      detail: { showTrashed: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event to toggle app subscription.
   *
   * @internal
   * @param subscribe - Desired subscription state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", { detail: { subscribe: t } });
    return this.dispatchEvent(e);
  }
  async willUpdate(t) {
    super.willUpdate(t), t.has("app") && this.app && this.app.id !== t.get("app")?.id && this.weavy && cb(this.weavy, this.app), (t.has("weavy") || t.has("app")) && this.weavy && this.app && await this.mutatingFiles.trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.app.id],
          exact: !1
        }
      },
      this.weavy.queryClient
    );
  }
  renderFileMutation(t) {
    if (t.context?.file) {
      const e = t.context.file, i = {
        ...t.context.status
      };
      return t.context.status.state === "conflict" && (i.text = P("Replace existing file?")), v`
        <wy-file-item
          rounded
          .file=${t.context?.file}
          .status=${i}
          .actionType=${t.context.type}
          title="${$P(t.context.type)}: ${e.name}"
        >
          <span slot="title">${e.name}</span>
          ${t.context.status.state === "conflict" && i.text ? v`: <span slot="actions" title=${i.text}><em>${i.text}</em></span>` : C}
          ${i.state === "conflict" && t.variables?.blob ? v`
                <wy-button
                  slot="actions"
                  kind="icon"
                  @click=${() => this.handleOverwriteUpload(
        t
      )}
                  title=${P("Replace")}
                >
                  <wy-icon name="check"></wy-icon>
                </wy-button>
              ` : C}
          ${i.state === "pending" ? v`
                <wy-progress-circular
                  slot="actions"
                  padded
                  ?indeterminate=${!i.progress}
                  .max=${100}
                  .value=${i.progress || 0}
                ></wy-progress-circular>

                ${ab(t.variables) ? v`<wy-button slot="actions" kind="icon" @click=${() => this.handleRemoveMutation(t)}>
                      <wy-icon name="close"></wy-icon>
                    </wy-button>` : C}
              ` : v`<wy-button slot="actions" kind="icon" @click=${() => this.handleRemoveMutation(t)}>
                <wy-icon name="close"></wy-icon>
              </wy-button> `}
        </wy-file-item>
      `;
    }
    return C;
  }
  render() {
    const t = this.mutatingFiles.result, e = cS(t), i = lS(t), s = KP(t), r = lb(t);
    return v`
      <header part="wy-files-header wy-header wy-header-outer">
        <nav part="wy-files-header-toolbar wy-toolbar">
          <div part="wy-toolbar-buttons">
            ${lm(rl.Create, this.app?.permissions) ? v`
                  <wy-dropdown title=${P("Add files")}>
                    <wy-icon slot="button-content" name="plus" first></wy-icon>
                    <span slot="button-content">${P("Add files")}</span>
                    <wy-dropdown-item @click=${this.openFileInput} title=${P("From device")}>
                      <wy-icon name="attachment"></wy-icon>
                      <span>${P("From device")}</span>
                    </wy-dropdown-item>
                    <input
                      type="file"
                      data-testid="uploadFile"
                      ${ot(this.fileInputRef)}
                      @click=${(a) => a.stopPropagation()}
                      @change=${(a) => {
      this.dispatchUploadFiles(a.target.files) && (a.target.value = "");
    }}
                      multiple
                      hidden
                      tabindex="-1"
                    />
                    ${this.componentFeatures?.allowsFeature(z.CloudFiles) ? v`
                          <wy-dropdown-item @click=${this.openCloudFiles} title=${P("From cloud")}>
                            <wy-icon name="cloud"></wy-icon>
                            <span>${P("From cloud")}</span>
                          </wy-dropdown-item>
                        ` : C}
                  </wy-dropdown>
                ` : C}
            ${t?.length ? v`
                  <wy-button
                    kind="icon"
                    @click=${() => {
      this.showUploadSheet = !this.showUploadSheet;
    }}
                    title=${P(r === "conflict" ? "File conflict" : r === "error" ? "Upload error" : r === "pending" ? "Pending" : "All uploads finished")}
                  >
                    ${r === "conflict" ? v`<wy-icon name="alert" color="yellow"></wy-icon>` : r === "error" ? v`<wy-icon name="alert-octagon" color="error"></wy-icon>` : r === "pending" ? v`<wy-progress-circular
                          ?indeterminate=${s.percent === null}
                          .value=${s.loaded}
                          .max=${s.total}
                        ></wy-progress-circular>` : v`<wy-icon name="check"></wy-icon>`}
                  </wy-button>
                ` : C}
          </div>
          <div part="wy-toolbar-buttons wy-toolbar-buttons-last">
            <slot name="actions"></slot>

            <wy-dropdown icon="sort" title="Sort items by" directionX="left">
              <wy-dropdown-option
                ?selected=${this.order.by === "name"}
                @click=${() => this.dispatchOrder({ ...this.order, by: "name" })}
              >
                ${P("Name")}
              </wy-dropdown-option>
              <wy-dropdown-option
                ?selected=${this.order.by === "updated_at"}
                @click=${() => this.dispatchOrder({ ...this.order, by: "updated_at" })}
              >
                ${P("Modified")}
              </wy-dropdown-option>
              <wy-dropdown-option
                ?selected=${this.order.by === "size"}
                @click=${() => this.dispatchOrder({ ...this.order, by: "size" })}
              >
                ${P("Size")}
              </wy-dropdown-option>
              <wy-dropdown-divider></wy-dropdown-divider>
              <wy-dropdown-option
                ?selected=${!this.order.descending}
                @click=${() => this.dispatchOrder({ ...this.order, descending: !1 })}
              >
                ${P("Ascending")}
              </wy-dropdown-option>
              <wy-dropdown-option
                ?selected=${this.order.descending}
                @click=${() => this.dispatchOrder({ ...this.order, descending: !0 })}
              >
                ${P("Descending")}
              </wy-dropdown-option>
            </wy-dropdown>

            <wy-dropdown
              icon=${this.view === "grid" ? "view-module-outline" : "view-list-outline"}
              title="View options"
              directionX="left"
            >
              <wy-dropdown-option ?selected=${this.view === "list"} @click=${() => this.dispatchView("list")}>
                ${P("List view")}
              </wy-dropdown-option>
              <wy-dropdown-option ?selected=${this.view === "grid"} @click=${() => this.dispatchView("grid")}>
                ${P("Grid view")}
              </wy-dropdown-option>
              <wy-dropdown-divider></wy-dropdown-divider>
              <wy-dropdown-option ?selected=${!this.showTrashed} @click=${() => this.dispatchShowTrashed(!1)}>
                ${P("Hide trashed")}
              </wy-dropdown-option>
              <wy-dropdown-option ?selected=${this.showTrashed} @click=${() => this.dispatchShowTrashed(!0)}>
                ${P("Show trashed")}
              </wy-dropdown-option>
            </wy-dropdown>

            <wy-dropdown directionX="left" ?disabled=${!this.app}>
              ${this.app?.is_subscribed ? v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                    <wy-icon name="bell-off"></wy-icon>
                    ${P("Unsubscribe")}
                  </wy-dropdown-item>` : v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                    <wy-icon name="bell"></wy-icon>
                    ${P("Subscribe")}
                  </wy-dropdown-item>`}
              ${this.app?.archive_url ? v`<wy-dropdown-item
                    @click=${() => as(
      this.app?.archive_url,
      "_top",
      `${this.app?.uid ? this.app.uid : `${this.app?.type}-${this.app?.id}`}.zip`,
      !0
    )}
                  >
                    <wy-icon name="download"></wy-icon>
                    ${P("Download files")}
                  </wy-dropdown-item>` : C}
            </wy-dropdown>
          </div>
        </nav>

        <wy-context-data-progress></wy-context-data-progress>
      </header>

      ${this.weavy ? v`
            <wy-overlay
              type="sheet"
              .show=${this.showUploadSheet}
              @close=${() => {
      this.showUploadSheet = !1;
    }}
            >
              <span slot="title">${P("File actions")}</span>
              <wy-container scrollY padded>
                ${!e.length && !i.length ? v`
                      <wy-empty noNetwork><wy-container padded>${P("No pending uploads")}</wy-container></wy-empty>
                    ` : C}
                ${e.length ? v`
                      ${Mi(
      e,
      (a) => "mutation" + a.submittedAt,
      (a) => this.renderFileMutation(a)
    )}
                    ` : C}
                ${i.length ? v`
                      ${Mi(
      i,
      (a) => "mutation" + a.submittedAt,
      (a) => this.renderFileMutation(a)
    )}
                    ` : C}
              </wy-container>
            </wy-overlay>
          ` : C}

      <wy-cloud-files
        ${ot(this.cloudFilesRef)}
        @external-blobs=${(a) => this.dispatchExternalBlobs(a.detail.externalBlobs)}
      ></wy-cloud-files>
    `;
  }
  updated(t) {
    super.updated(t);
    const e = cS(this.mutatingFiles.result), i = lS(this.mutatingFiles.result);
    e.some(
      (s) => !this.previousFailedFileMutations.includes(s)
    ) ? this.showUploadSheet = !0 : this.showUploadSheet && !e.length && !i.length && setTimeout(() => {
      !e.length && !i.length && (this.showUploadSheet = !1);
    }, 1500), this.previousFailedFileMutations = e ?? [];
  }
}, c(uy, "Eo"), uy), d(Cx, "WyFilesHeader"), Cx);
ua.styles = [Z4, LW, ft];
E1([
  O({ type: Object })
], ua.prototype, "order", 2);
E1([
  O()
], ua.prototype, "view", 2);
E1([
  O({ type: Boolean })
], ua.prototype, "showTrashed", 2);
E1([
  F()
], ua.prototype, "showUploadSheet", 2);
ua = E1([
  U("wy-files-header"),
  St()
], ua);
function dV(n, t, e = {}, i = {}) {
  if (!n)
    throw new Error("useFileList must be used within a WeavyContext");
  return {
    ...i,
    queryKey: ["apps", t, "files", e],
    initialPageParam: 0,
    queryFn: /* @__PURE__ */ d(async (s) => {
      const r = s.pageParam, a = !!e?.trashed, o = e.order ? e.order.by + (e.order.descending ? "+desc" : "") : "";
      let l = "/api/apps/" + t + "/files?skip=" + r + "&order_by=" + o;
      return a && (l += "&trashed=null"), await (await n.fetch(l)).json();
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ d((s) => s.end && s.end < s.count ? s.end : null, "getNextPageParam")
  };
}
c(dV, "C3");
d(dV, "getInfiniteFileListOptions");
function uV(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ d(async ({ file: s }) => {
      if (s.id >= 1) {
        if (!(await n.fetch("/api/files/" + s.id + "/trash", { method: "POST" })).ok)
          throw new Error();
      } else
        throw new Error(`Could not trash ${s.name}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => (Ct(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      s.file.id,
      (r) => Object.assign(r, { is_trashed: !0 })
    ), { type: "trash", file: s.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ d((s, r) => {
      Ct(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, s)
      ), se(e, i.mutationKey, r, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError(s, r) {
      Ct(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { is_trashed: !1 })
      ), se(e, i.mutationKey, r, (a) => {
        a.status.state = "error", a.status.text = s.message;
      });
    }
  };
  return i;
}
c(uV, "k3");
d(uV, "getTrashFileMutationOptions");
function pV(n, t) {
  return new Xt(n.queryClient, uV(n, t));
}
c(pV, "_3");
d(pV, "getTrashFileMutation");
function fV(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ d(async ({ file: s }) => {
      if (s.id >= 1) {
        const r = await n.fetch("/api/files/" + s.id + "/restore", { method: "POST" });
        if (!r.ok) {
          const a = await r.json();
          throw new Error(a.detail || a.title, { cause: a });
        }
      } else {
        const r = { status: 400, title: `Could not restore ${s.name}.` };
        throw new Error(r.detail || r.title, { cause: r });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => (Ct(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      s.file.id,
      (r) => Object.assign(r, { status: "pending" })
    ), { type: "restore", file: s.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ d((s, r) => {
      Ct(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { is_trashed: !1, status: "ok" })
      ), se(e, i.mutationKey, r, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError(s, r) {
      Ct(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { is_trashed: !0 })
      ), se(e, i.mutationKey, r, (a) => {
        a.status.state = "error", a.status.text = s.message;
      });
    }
  };
  return i;
}
c(fV, "P3");
d(fV, "getRestoreFileMutationOptions");
function yV(n, t) {
  return new Xt(n.queryClient, fV(n, t));
}
c(yV, "M3");
d(yV, "getRestoreFileMutation");
function mV(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ d(async ({ file: s }) => {
      if (s.id >= 1 && s.is_trashed) {
        const r = await n.fetch("/api/files/" + s.id, { method: "DELETE" });
        if (!r.ok) {
          const a = await r.json();
          throw new Error(a.detail || a.title, { cause: a });
        }
      } else {
        const r = { status: 400, title: `Could not delete ${s.name} forever.` };
        throw new Error(r.detail || r.title, { cause: r });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => (Ct(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      s.file.id,
      (r) => Object.assign(r, { status: "pending" })
    ), { type: "delete-forever", file: s.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ d((s, r) => {
      BB(e, { queryKey: i.mutationKey, exact: !1 }, r.file.id), se(e, i.mutationKey, r, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError(s, r) {
      Ct(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { status: void 0 })
      ), se(e, i.mutationKey, r, (a) => {
        a.status.state = "error", a.status.text = s.message;
      });
    }
  };
  return i;
}
c(mV, "S3");
d(mV, "getDeleteForeverFileMutationOptions");
function gV(n, t) {
  return new Xt(n.queryClient, mV(n, t));
}
c(gV, "A3");
d(gV, "getDeleteForeverFileMutation");
function wV(n, t) {
  const e = n.queryClient, i = ["apps", t.id, "files"];
  return {
    mutationKey: i,
    mutationFn: /* @__PURE__ */ d(async ({ file: s, subscribe: r }) => {
      if (s.id >= 1) {
        const a = await n.fetch(`/api/files/${s.id}/${r ? "subscribe" : "unsubscribe"}`, {
          method: "POST"
        });
        if (!a.ok) {
          const o = await a.json();
          throw new Error(o.detail || o.title, { cause: o });
        }
      } else
        throw new Error(`Could not ${r ? "subscribe" : "unsubscribe"} to ${s.name}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => (Ct(
      e,
      { queryKey: i, exact: !1 },
      s.file.id,
      (r) => Object.assign(r, { is_subscribed: s.subscribe, status: "pending" })
    ), {
      type: s.subscribe ? "subscribe" : "unsubscribe",
      file: s.file,
      status: { state: "pending" }
    }), "onMutate"),
    onSuccess: /* @__PURE__ */ d((s, r) => {
      Ct(
        e,
        { queryKey: i, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { status: "ok" })
      ), se(e, i, r, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ d((s, r) => {
      Ct(
        e,
        { queryKey: i, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { is_subscribed: r.file.is_subscribed, status: "error" })
      ), se(e, i, r, (a) => {
        a.status.state = "error", a.status.text = s.message;
      });
    }, "onError")
  };
}
c(wV, "z3");
d(wV, "getSubscribeFileMutationOptions");
function vV(n, t) {
  return new Xt(n.queryClient, wV(n, t));
}
c(vV, "R3");
d(vV, "getSubscribeFileMutation");
function OV(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ d(async ({ file: s, name: r }) => {
      if (s.id >= 1) {
        const a = await n.fetch("/api/files/" + s.id, {
          method: "PATCH",
          body: JSON.stringify({
            name: r
          })
        });
        if (!a.ok) {
          const o = await a.json();
          throw new Error(o.detail || o.title, { cause: o });
        }
        return await a.json();
      } else
        throw new Error(`Could not rename ${s.name}`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => (Ct(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      s.file.id,
      (r) => Object.assign(r, { name: s.name })
    ), { type: "rename", file: s.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ d((s, r) => {
      Ct(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, s)
      ), se(e, i.mutationKey, r, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ d((s, r) => {
      Ct(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { name: r.file.name })
      ), se(e, i.mutationKey, r, (a) => {
        a.status.state = "error", a.status.text = s.message;
      });
    }, "onError")
  };
  return i;
}
c(OV, "E3");
d(OV, "getRenameFileMutationOptions");
function bV(n, t) {
  return new Xt(n.queryClient, OV(n, t));
}
c(bV, "L3");
d(bV, "getRenameFileMutation");
const SK = et`[part~=wy-grid]{display:grid;grid-auto-flow:dense;grid-template-columns:repeat(auto-fill,minmax(calc(10 * var(--wy-size, 1rem)),1fr));grid-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) 0}`, CK = et`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-card]{--wy-component-background-color: var(--wy-surface-layer-high, var(--wy-surface-layer-high-light, rgba(0, 0, 0, .0745098039)));--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-component-border-radius);position:relative;display:flex;flex-direction:column;min-width:0;word-wrap:break-word;background-clip:border-box;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-card][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-card-primary]{--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-container-light, #cee5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-on-primary-container-light, #0d4a73))}[part~=wy-trashed]{text-decoration:line-through;opacity:var(--wy-opacity-disabled, 38%)}[part~=wy-card-hover]{cursor:pointer;-webkit-user-select:none;user-select:none}[part~=wy-card-hover]:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-card-hover]:hover:before{opacity:var(--wy-opacity-state-hover, 8%)}[part~=wy-card-hover]:focus:before{opacity:var(--wy-opacity-state-focus, 12%)}[part~=wy-card-hover]:active:before,[part~=wy-card-hover][part~=wy-active]:before{opacity:var(--wy-opacity-state-active, 12%)}[part~=wy-card-actions]{position:absolute;top:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));right:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));align-items:center;display:flex}[part~=wy-card-icon]{--wy-component-icon-width: calc(6 * var(--wy-size, 1rem));--wy-component-icon-height: calc(6 * var(--wy-size, 1rem));display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;margin:auto}[part~=wy-card-image]{width:auto;height:auto;border-radius:var(--wy-component-border-radius);object-fit:cover;object-position:center;flex:1 1 100%;max-height:calc(10*var(--wy-size, 1rem))}[part~=wy-card-image][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-card-image][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-card-image-top]{object-position:top center}[part~=wy-card-title]{padding:0 var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:flex;align-items:center;justify-content:space-between;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));height:2.25rem;box-sizing:border-box}[part~=wy-input]{height:2.25rem;box-sizing:border-box;flex:0 1 auto}[part~=wy-card-text]{line-height:var(--wy-line-height, 1.5);flex:0 1 auto;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}[part~=wy-card-action]{flex:0 0 auto;white-space:nowrap}`, PK = et`[part~=wy-badge]{display:inline-block;text-align:center;vertical-align:middle;align-self:center;font-weight:var(--wy-font-weight-bold, 600);font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));line-height:normal;color:var(--wy-on-primary, var(--wy-on-primary-light, #ffffff));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));background-color:var(--wy-primary, var(--wy-primary-light, #2f628c));padding:.333333em;min-width:1lh}[part~=wy-badge]:empty{display:none!important}[part~=wy-badge-positioned]{margin:calc(-.5*(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + .333333em*2));position:absolute}[part~=wy-badge-positioned]:not(:empty){display:block}[part~=wy-badge-top-right]{top:0;right:0}[part~=wy-badge-bottom-right]{bottom:0;right:0}[part~=wy-badge-bottom-left]{bottom:0;left:0}[part~=wy-badge-top-left]{top:0;left:0}[part~=wy-badge-compact]{padding:calc(var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))*.25);max-width:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))*3 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));height:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));line-height:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-badge-compact]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-badge-compact][part~=wy-badge-positioned]{margin:calc(-.5*(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))*.5))}[part~=wy-badge-dot]{content-visibility:hidden;line-height:0;min-width:0;height:0;width:0;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-badge-dot][part~=wy-badge-positioned]{margin:calc(-1*var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}[part~=wy-badge-reveal]{opacity:1;transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-badge-reveal]{opacity:0}}`;
var QK = Object.defineProperty, TK = Object.getOwnPropertyDescriptor, Wm = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? TK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && QK(t, e, s), s;
}, "__decorateClass$v"), Px, py;
let ir = (Px = (py = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.appearance = "count", this.position = "inline", this.reveal = !1, this.count = NaN, this.limit = 99;
  }
  render() {
    const t = Number.isInteger(this.count) ? this.count > this.limit ? `${this.limit}+` : this.count : "", e = /^(top|bottom)-(right|left)$/.test(this.position), i = {
      "wy-badge": !0,
      "wy-badge-reveal": this.reveal,
      "wy-badge-compact": this.appearance === "compact",
      "wy-badge-dot": this.appearance === "dot",
      "wy-badge-positioned": e,
      [`wy-badge-${this.position}`]: e
    };
    return this.appearance !== "none" && t ? v`<span part=${ut(i)} title=${this.count}>${t}</span>` : C;
  }
}, c(py, "Lo"), py), d(Px, "WyBadge"), Px);
ir.styles = [PK, ft];
Wm([
  O({ type: String })
], ir.prototype, "appearance", 2);
Wm([
  O({ type: String })
], ir.prototype, "position", 2);
Wm([
  O({ type: Boolean })
], ir.prototype, "reveal", 2);
Wm([
  O({ type: Number })
], ir.prototype, "count", 2);
Wm([
  O({ type: Number })
], ir.prototype, "limit", 2);
ir = Wm([
  U("wy-badge")
], ir);
var MK = Object.defineProperty, AK = Object.getOwnPropertyDescriptor, Z0 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? AK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && MK(t, e, s), s;
}, "__decorateClass$u"), Qx, fy;
let Ol = (Qx = (fy = class extends zi {
  constructor() {
    super(), this.exportParts = new Y(this), this.isRenamingId = NaN, this.highlightId = NaN, this.highlightRef = wt(), this.addEventListener("edit-name", (t) => {
      this.isRenamingId = t.detail.file.id;
    }), this.addEventListener("rename", () => {
      this.isRenamingId = NaN;
    });
  }
  /**
   * Emit a `file-open` event requesting preview for the given file.
   *
   * @param fileId - Identifier of the file to open.
   * @param tab - Optional preview tab to activate.
   * @returns Whether the event was not canceled.
   */
  dispatchFileOpen(t, e) {
    const i = new CustomEvent("file-open", { detail: { fileId: t, tab: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit an `order` event with the selected sort order.
   *
   * @param order - Order to apply.
   * @returns Whether the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit an `edit-name` event to enter rename mode for the given file.
   *
   * @param file - File that should be renamed.
   * @returns Whether the event was not canceled.
   */
  dispatchEditName(t) {
    const e = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `rename` event containing the updated file name.
   *
   * @param file - File being renamed.
   * @param name - New filename.
   * @returns Whether the event was not canceled.
   */
  dispatchRename(t, e) {
    const i = new CustomEvent("rename", { detail: { file: t, name: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit a `trash` event to move the file to the recycle bin.
   *
   * @param file - File to trash.
   * @returns Whether the event was not canceled.
   */
  dispatchTrash(t) {
    const e = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `restore` event to recover a trashed file.
   *
   * @param file - File to restore.
   * @returns Whether the event was not canceled.
   */
  dispatchRestore(t) {
    const e = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `delete-forever` event to permanently remove a file.
   *
   * @param file - File to delete.
   * @returns Whether the event was not canceled.
   */
  dispatchDeleteForever(t) {
    const e = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling file subscription.
   *
   * @param file - File to subscribe or unsubscribe.
   * @param subscribe - Desired subscription state.
   * @returns Whether the event was not canceled.
   */
  dispatchSubscribe(t, e) {
    const i = new CustomEvent("subscribe", { detail: { file: t, subscribe: e } });
    return this.dispatchEvent(i);
  }
  render() {
    return this.files && this.files.length ? v`
        <div part="wy-grid">
          ${Mi(
      this.files,
      (t) => t.id,
      (t) => {
        const e = t.size && t.size > 0 ? f0(t.size) : C, i = t.updated_at || t.created_at, s = new Intl.DateTimeFormat(this.weavy?.locale, {
          dateStyle: "full",
          timeStyle: "short"
        }).format(new Date(i)), r = !!(this.isRenamingId && this.isRenamingId === t.id), { icon: a } = lr(t.name), o = tn(t.name), l = Tm(t.provider), h = /* @__PURE__ */ d((y) => {
          y.stopImmediatePropagation();
          const m = y.target;
          m.value && m.value !== t.name ? this.dispatchRename(t, m.value) : this.dispatchEditName({ id: NaN });
        }, "handleRename"), u = /* @__PURE__ */ d((y) => {
          const m = y.target;
          y.key === "Escape" ? (y.preventDefault(), m.value = t.name, m.blur()) : y.key === "Enter" && (y.preventDefault(), m.blur());
        }, "handleRenameKey"), p = !!(this.highlightId && this.highlightId === t.id);
        return v`
                <div
                  part=${ut({
          "wy-card": !0,
          "wy-trashed": t.is_trashed,
          "wy-card-hover": !t.is_trashed && !r,
          "wy-highlight": p
        })}
                  title="${t.name} • ${e} • ${s}"
                  tabindex="0"
                  @click=${(y) => {
          a1(y) && (y.stopPropagation(), y.preventDefault(), as(t.download_url ?? t.external_url, "_blank")), !y.defaultPrevented && !t.is_trashed && this.dispatchFileOpen(t.id);
        }}
                  @keydown=${Le}
                  @keyup=${di}
                  ${p && this.highlightRef ? ot(this.highlightRef) : C}
                >
                  <div part="wy-card-actions">
                    <wy-file-menu
                      small
                      .file=${t}
                      @edit-name=${(y) => this.dispatchEditName(y.detail.file)}
                      @trash=${(y) => this.dispatchTrash(y.detail.file)}
                      @restore=${(y) => this.dispatchRestore(y.detail.file)}
                      @delete-forever=${(y) => this.dispatchDeleteForever(y.detail.file)}
                      @subscribe=${(y) => this.dispatchSubscribe(y.detail.file, y.detail.subscribe)}
                    ></wy-file-menu>
                  </div>
                  ${!t.is_trashed && t.thumbnail_url ? v`
                        <img
                          part="wy-card-image ${ut({ "wy-card-image-top": t.kind !== "image" })}"
                          width=${Ot(t.width)}
                          height=${Ot(t.height)}
                          src=${t.thumbnail_url}
                          alt=${t.name}
                          ${ot(E0)}
                          @load=${_0}
                          loading="lazy"
                          decoding="async"
                        />
                      ` : v`
                        <div part="wy-card-icon ">
                          <wy-icon
                            name=${a}
                            .overlayName=${l}
                            size="96"
                            kind=${t.kind}
                            ext=${o}
                          ></wy-icon>
                        </div>
                      `}
                  ${r ? v`
                        <input
                          type="text"
                          name="filename"
                          maxlength="256"
                          part="wy-input"
                          .defaultValue=${t.name}
                          @blur=${h}
                          @keyup=${(y) => {
          Ys(y), u(y);
        }}
                          @click=${(y) => y.preventDefault()}
                          @focus=${g0}
                          ${ot(PS)}
                        />
                      ` : v`<div part="wy-card-title">
                        <div part="wy-card-text">${t.name}</div> ${t.comments?.count ? v`<wy-button
                              part="wy-card-button-icon"
                              small
                              color="none"
                              kind="inline"
                              @click=${(y) => {
          !y.defaultPrevented && !t.is_trashed && (y.target.blur(), this.dispatchFileOpen(t.id, "comments"), y.stopPropagation());
        }}
                              title=${P(st`${t.comments.count} comments`)}
                            >
                              <wy-badge count=${t.comments.count}></wy-badge>
                            </wy-button>` : C}
                      </div>`}
                </div>
              `;
      }
    )}
        </div>
      ` : C;
  }
  updated(t) {
    t.has("highlightId") && this.highlightId && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, c(fy, "Oo"), fy), d(Qx, "WyFileGrid"), Qx);
Ol.styles = [$a, SK, CK, ft];
Z0([
  O({ attribute: !1 })
], Ol.prototype, "files", 2);
Z0([
  F()
], Ol.prototype, "isRenamingId", 2);
Z0([
  F()
], Ol.prototype, "highlightId", 2);
Ol = Z0([
  uL("wy-file-grid"),
  St()
], Ol);
const RK = et`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-table]{table-layout:fixed;width:100%;vertical-align:top;border-collapse:collapse}[part~=wy-table] tr[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-table] th{font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600))}[part~=wy-table] th,[part~=wy-table] td{background-color:var(--wy-component-background-color);padding:var(--wy-table-cell-padding-y, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))) var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));box-shadow:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf)) 0 -1px 0 0 inset;line-height:1;vertical-align:middle;height:calc(calc(2 * var(--wy-size, 1rem)) + var(--wy-table-cell-padding-y, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*2)}[part~=wy-table]>tbody{vertical-align:inherit}[part~=wy-table]>thead{vertical-align:bottom}[part~=wy-table][part~=wy-table-interactive]>tbody>tr:hover>*{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-surface-layer, var(--wy-surface-layer-light, rgba(0, 0, 0, .0509803922)));color:var(--wy-component-color);cursor:pointer}[part~=wy-col-icon]{vertical-align:middle;text-align:center;padding:calc(var(--wy-table-cell-padding-y, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*.5) calc(var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*.5);width:calc(calc(2 * var(--wy-size, 1rem)) + var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))*2);font-size:var(--wy-font-size, var(--wy-size, 1em));font-weight:var(--wy-font-weight, unset);text-transform:none;letter-spacing:normal}[part~=wy-col-icon-content]{display:flex;justify-content:center;align-items:center}[part~=wy-trashed]{text-decoration:line-through}[part~=wy-sort-link]{display:inline-flex;align-items:center;color:var(--wy-primary, var(--wy-primary-light, #2f628c));cursor:pointer}`, EK = et`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}table thead{text-align:left;display:none}@container (inline-size >= 576px){table thead{display:table-header-group}}[part~=wy-col-name]{width:100%}[part~=wy-col-name]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-col-name] [part~=wy-input]{width:100%;box-sizing:border-box}[part~=wy-col-time]{width:calc(8*var(--wy-size, 1rem));display:none}@container (inline-size >= 768px){[part~=wy-col-time]{display:table-cell}}[part~=wy-col-time]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-col-kind]{width:calc(8*var(--wy-size, 1rem));display:none}@container (inline-size >= 768px){[part~=wy-col-kind]{display:table-cell}}[part~=wy-col-kind]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[part~=wy-col-size]{width:calc(6*var(--wy-size, 1rem));text-align:right;display:none}@container (inline-size >= 576px){[part~=wy-col-size]{display:table-cell}}[part~=wy-col-size]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}`;
var _K = Object.defineProperty, zK = Object.getOwnPropertyDescriptor, _1 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? zK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && _K(t, e, s), s;
}, "__decorateClass$t"), Tx, yy;
let pa = (Tx = (yy = class extends zi {
  constructor() {
    super(), this.exportParts = new Y(this), this.order = { by: "name", descending: !1 }, this.isRenamingId = NaN, this.highlightId = NaN, this.highlightRef = wt(), this.addEventListener("edit-name", (t) => {
      this.isRenamingId = t.detail.file.id;
    }), this.addEventListener("rename", () => {
      this.isRenamingId = NaN;
    });
  }
  /**
   * Emit a `file-open` event requesting preview for the supplied file.
   *
   * @param fileId - Identifier of the file to open.
   * @param tab - Optional preview tab to activate.
   * @returns Whether the event was not canceled.
   */
  dispatchFileOpen(t, e) {
    const i = new CustomEvent("file-open", { detail: { fileId: t, tab: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit an `order` event with the provided sort order.
   *
   * @param order - Order to apply.
   * @returns Whether the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit an `edit-name` event to enter rename mode for the specified file.
   *
   * @param file - File that should be renamed.
   * @returns Whether the event was not canceled.
   */
  dispatchEditName(t) {
    const e = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `rename` event carrying the updated filename.
   *
   * @param file - File being renamed.
   * @param name - New filename value.
   * @returns Whether the event was not canceled.
   */
  dispatchRename(t, e) {
    const i = new CustomEvent("rename", { detail: { file: t, name: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit a `trash` event to move the file to the recycle bin.
   *
   * @param file - File to trash.
   * @returns Whether the event was not canceled.
   */
  dispatchTrash(t) {
    const e = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `restore` event to recover a trashed file.
   *
   * @param file - File to restore.
   * @returns Whether the event was not canceled.
   */
  dispatchRestore(t) {
    const e = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `delete-forever` event to permanently remove the file.
   *
   * @param file - File targeted for permanent deletion.
   * @returns Whether the event was not canceled.
   */
  dispatchDeleteForever(t) {
    const e = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling subscription state for the file.
   *
   * @param file - File whose subscription changes.
   * @param subscribe - Desired subscription state.
   * @returns Whether the event was not canceled.
   */
  dispatchSubscribe(t, e) {
    const i = new CustomEvent("subscribe", { detail: { file: t, subscribe: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Render the complete file table layout.
   *
   * @param files - Files to render.
   * @param order - Current table order.
   * @param isRenamingId - File id in rename mode.
   * @param highlightId - File id to highlight.
   * @param highlightRef - Reference for scrolling highlighted rows.
   */
  renderFileTable(t, e, i, s, r) {
    return t && t.length ? v`
          <table part="wy-table wy-table-interactive">
            <thead>${this.renderFileTableHeaders.call(this, e)}</thead>
            <tbody>
              ${Mi(
      t,
      (a) => a.id,
      (a) => this.renderFileTableRow.call(this, this.weavy, { file: a }, i, s, r)
    )}
            </tbody>
          </table>
        ` : C;
  }
  /**
   * Render table header cells with sorting affordances.
   *
   * @param order - Current sort order.
   */
  renderFileTableHeaders(t) {
    const e = [
      { col: "icon", by: void 0, title: "" },
      // File icon
      { col: "name", by: "name", title: P("Name") },
      { col: "icon", by: void 0, title: "" },
      // Comments icon
      { col: "time", by: "updated_at", title: P("Modified") },
      { col: "kind", by: void 0, title: P("Kind") },
      { col: "size", by: "size", title: P("Size") },
      { col: "icon", by: void 0, title: "" }
      // Menu
    ];
    return v`
      <tr>
        ${e.map((i) => {
      if (i.title) {
        const s = i.by === t?.by, r = /* @__PURE__ */ d((a) => {
          a.preventDefault(), i.by && this.dispatchOrder({ by: i.by, descending: s && !t?.descending });
        }, "onHeaderClick");
        return v` <th part="wy-th ${`wy-col-${i.col}`}">
              ${i.by ? v`<div
                    part="wy-sort-link"
                    tabindex="0"
                    @click=${r}
                    @keydown=${Le}
                    @keyup=${di}
                    >${i.title}
                    ${s && v`<wy-icon name=${t?.descending ? "menu-down" : "menu-up"}></wy-icon>` || C}</div
                  >` : i.title}
            </th>`;
      } else
        return v`<th part="wy-th wy-col-icon"></th>`;
    })}
      </tr>
    `;
  }
  /**
   * Render a single file table row.
   *
   * @param weavy - Current Weavy context.
   * @param row - Row data containing the file.
   * @param isRenamingId - File id in rename mode.
   * @param highlightId - File id to highlight.
   * @param highlightRef - Reference for scrolling highlighted rows.
   */
  renderFileTableRow(t, { file: e }, i, s, r) {
    const a = e.size && e.size > 0 ? f0(e.size) : C, o = e.updated_at || e.created_at, l = new Intl.DateTimeFormat(t?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(o)
    ), h = new Intl.DateTimeFormat(t?.locale, { dateStyle: "short" }).format(
      new Date(o)
    ), u = !!(i && i === e.id), { icon: p } = lr(e.name), y = tn(e.name), m = Tm(e.provider), g = /* @__PURE__ */ d((x) => {
      x.stopImmediatePropagation();
      const Q = x.target;
      Q.value && Q.value !== e.name ? this.dispatchRename(e, Q.value) : this.dispatchEditName({ id: NaN });
    }, "handleRename"), b = /* @__PURE__ */ d((x) => {
      const Q = x.target;
      x.key === "Escape" ? (x.preventDefault(), Q.value = e.name, Q.blur()) : x.key === "Enter" && (x.preventDefault(), Q.blur());
    }, "handleRenameKey"), S = !!(s && s === e.id);
    return v`
      <tr
        part=${ut({ "wy-tr": !0, "wy-highlight": S, "wy-trashed": e.is_trashed })}
        @click=${(x) => {
      a1(x) && (x.stopPropagation(), x.preventDefault(), as(e.download_url ?? e.external_url, "_blank")), !x.defaultPrevented && !e.is_trashed && this.dispatchFileOpen(e.id);
    }}
        ${S && r ? ot(r) : C}
      >
        <td part="wy-td wy-col-icon"
          ><wy-icon part="wy-col-icon-content" name=${p} .overlayName=${m} size="24" kind=${e.kind} ext=${y}></wy-icon
        ></td>
        <td part="wy-td wy-col-name">
          ${u ? v`
                <input
                  type="text"
                  name="filename"
                  maxlength="256"
                  part="wy-input"
                  .defaultValue=${e.name}
                  @blur=${g}
                  @keyup=${(x) => {
      Ys(x), b(x);
    }}
                  @click=${(x) => x.preventDefault()}
                  @focus=${g0}
                  ${ot(PS)}
                />
              ` : v`${e.name}`}
        </td>
        <td part="wy-td wy-col-icon"
          >${e.comments?.count ? v`<wy-button
                part="wy-col-icon-content"
                kind="inline"
                @click=${(x) => {
      !x.defaultPrevented && !e.is_trashed && (x.target.blur(), this.dispatchFileOpen(e.id, "comments"), x.stopPropagation());
    }}
                title=${P(st`${e.comments.count} comments`)}
              >
                <wy-badge count=${e.comments.count}></wy-badge>
              </wy-button>` : C}</td
        >
        <td part="wy-td wy-col-time"
          ><time datetime="${o}" title=${l}>${h}</time></td
        >
        <td part="wy-td wy-col-kind">${e.kind}</td>
        <td part="wy-td wy-col-size">${a}</td>
        <td part="wy-td wy-col-icon">
          <wy-file-menu
            part="wy-col-icon-content"
            .file=${e}
            @edit-name=${(x) => this.dispatchEditName(x.detail.file)}
            @trash=${(x) => this.dispatchTrash(x.detail.file)}
            @restore=${(x) => this.dispatchRestore(x.detail.file)}
            @delete-forever=${(x) => this.dispatchDeleteForever(x.detail.file)}
            @subscribe=${(x) => this.dispatchSubscribe(x.detail.file, x.detail.subscribe)}
          >
          </wy-file-menu>
        </td>
      </tr>
    `;
  }
  render() {
    return this.files && this.files.length ? this.renderFileTable.call(
      this,
      this.files,
      this.order,
      this.isRenamingId,
      this.highlightId,
      this.highlightRef
    ) : C;
  }
  updated(t) {
    t.has("highlightId") && this.highlightId && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, c(yy, "Io"), yy), d(Tx, "WyFileTable"), Tx);
pa.styles = [$a, RK, EK, ft];
_1([
  O({ attribute: !1 })
], pa.prototype, "files", 2);
_1([
  O({ attribute: !1 })
], pa.prototype, "order", 2);
_1([
  F()
], pa.prototype, "isRenamingId", 2);
_1([
  F()
], pa.prototype, "highlightId", 2);
pa = _1([
  uL("wy-file-table"),
  St()
], pa);
var LK = Object.defineProperty, IK = Object.getOwnPropertyDescriptor, $V = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$6"), Vm = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? IK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && LK(t, e, s), s;
}, "__decorateClass$s"), xV = /* @__PURE__ */ d((n, t, e) => t.has(n) || $V("Cannot " + e), "__accessCheck$6"), Q9 = /* @__PURE__ */ d((n, t, e) => (xV(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$6"), WK = /* @__PURE__ */ d((n, t, e) => t.has(n) ? $V("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$6"), T9 = /* @__PURE__ */ d((n, t, e, i) => (xV(n, t, "write to private field"), t.set(n, e), e), "__privateSet$6"), Yc, Mx, my;
let nr = (Mx = (my = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.order = { by: "name", descending: !1 }, this.view = "list", this.showTrashed = !1, this.highlightId = NaN, this.highlightComment = !1, this.filesQuery = new Rl(this), this.previewRef = wt(), this.infiniteScroll = new El(this), this.pagerRef = wt(), this.handleRealtimeFileCreated = (t) => {
      !this.weavy || !this.app || (t.file.created_by = t.actor, this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) }));
    }, this.handleRealtimeFileUpdated = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileTrashed = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileRestored = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileDeleted = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeCommentCreated = () => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, WK(this, Yc);
  }
  /**
   * Resolve the query key used for the app file listing.
   *
   * @internal
   * @param app - App owning the files.
   */
  getFilesQueryKey(t) {
    return ["apps", t.id, "files"];
  }
  /**
   * Emit a `file-open` event requesting preview for the supplied file.
   *
   * @param fileId - Identifier of the file to open.
   * @param tab - Optional preview tab to activate.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchFileOpen(t, e) {
    const i = new CustomEvent("file-open", { detail: { fileId: t, tab: e } });
    return this.dispatchEvent(i);
  }
  /**
   * Emit an `order` event with the provided sort order.
   *
   * @param order - Order to apply.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("link") && (this.highlightId = this.link && L4(this.link, ci.File)?.id, this.highlightComment = this.link && this.highlightId ? I4(this.link, ci.File, { id: this.highlightId }, ci.Comment) : !1), t.has("highlightComment") && this.highlightComment && this.highlightId && this.dispatchFileOpen(this.highlightId, "comments"), (t.has("weavy") || t.has("app") || t.has("order") || t.has("showTrashed")) && this.weavy && this.app && await this.filesQuery.trackInfiniteQuery(
      dV(this.weavy, this.app.id, {
        order: this.order,
        trashed: this.showTrashed
      })
    ), (t.has("weavy") || t.has("app") || t.has("user")) && this.weavy && this.app && this.user) {
      this.renameFileMutation = bV(this.weavy, this.app), this.subscribeFileMutation = vV(this.weavy, this.app), this.trashFileMutation = pV(this.weavy, this.app), this.restoreFileMutation = yV(this.weavy, this.app), this.deleteForeverFileMutation = gV(this.weavy, this.app), (e = Q9(this, Yc)) == null || e.call(this);
      const i = `a${this.app.id}`;
      this.weavy.subscribe(i, "file_created", this.handleRealtimeFileCreated), this.weavy.subscribe(i, "file_updated", this.handleRealtimeFileUpdated), this.weavy.subscribe(i, "file_trashed", this.handleRealtimeFileTrashed), this.weavy.subscribe(i, "file_restored", this.handleRealtimeFileRestored), this.weavy.subscribe(i, "file_deleted", this.handleRealtimeFileDeleted), this.weavy.subscribe(i, "comment_created", this.handleRealtimeCommentCreated), T9(this, Yc, () => {
        this.weavy?.unsubscribe(i, "file_created", this.handleRealtimeFileCreated), this.weavy?.unsubscribe(i, "file_updated", this.handleRealtimeFileUpdated), this.weavy?.unsubscribe(i, "file_trashed", this.handleRealtimeFileTrashed), this.weavy?.unsubscribe(i, "file_restored", this.handleRealtimeFileRestored), this.weavy?.unsubscribe(i, "file_deleted", this.handleRealtimeFileDeleted), this.weavy?.unsubscribe(i, "comment_created", this.handleRealtimeCommentCreated), T9(this, Yc, void 0);
      });
    }
  }
  render() {
    const { data: t, hasNextPage: e, isPending: i } = this.filesQuery.result, s = cs(t);
    return s && s.length ? v`
        ${this.view === "grid" ? v`
              <wy-file-grid
                .files=${s}
                .highlightId=${this.highlightId}
                @file-open=${(r) => {
      this.previewRef.value?.open(r.detail.fileId, r.detail.tab);
    }}
                @order=${(r) => this.dispatchOrder(r.detail.order)}
                @rename=${(r) => {
      this.renameFileMutation?.mutate({ file: r.detail.file, name: r.detail.name });
    }}
                @subscribe=${(r) => {
      this.subscribeFileMutation?.mutate({
        file: r.detail.file,
        subscribe: r.detail.subscribe
      });
    }}
                @trash=${(r) => {
      this.trashFileMutation?.mutate({ file: r.detail.file });
    }}
                @restore=${(r) => {
      this.restoreFileMutation?.mutate({ file: r.detail.file });
    }}
                @delete-forever=${(r) => {
      this.deleteForeverFileMutation?.mutate({ file: r.detail.file });
    }}
              ></wy-file-grid>
            ` : v`
              <wy-file-table
                .files=${s}
                .order=${this.order}
                .highlightId=${this.highlightId}
                @file-open=${(r) => {
      this.previewRef.value?.open(r.detail.fileId, r.detail.tab);
    }}
                @order=${(r) => this.dispatchOrder(r.detail.order)}
                @rename=${(r) => {
      this.renameFileMutation?.mutate({ file: r.detail.file, name: r.detail.name });
    }}
                @subscribe=${(r) => {
      this.subscribeFileMutation?.mutate({
        file: r.detail.file,
        subscribe: r.detail.subscribe
      });
    }}
                @trash=${(r) => {
      this.trashFileMutation?.mutate({ file: r.detail.file });
    }}
                @restore=${(r) => {
      this.restoreFileMutation?.mutate({ file: r.detail.file });
    }}
                @delete-forever=${(r) => {
      this.deleteForeverFileMutation?.mutate({ file: r.detail.file });
    }}
              ></wy-file-table>
            `}
        ${e ? v`<div ${ot(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
        ${t ? v` <wy-preview ${ot(this.previewRef)} .infiniteQueryResult=${this.filesQuery.result}></wy-preview> ` : C}
      ` : v`
        <wy-empty>
          ${i ? v`<wy-progress-circular indeterminate padded reveal></wy-progress-circular>` : v` <wy-icon-display>
                <wy-icon name="file-upload"></wy-icon>
                <span slot="text">${P("Add some files to get started!")}</span>
              </wy-icon-display>`}
        </wy-empty>
      `;
  }
  updated() {
    this.infiniteScroll.observe(this.filesQuery.result, this.pagerRef.value);
  }
  disconnectedCallback() {
    var t;
    (t = Q9(this, Yc)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(my, "To"), my), d(Mx, "WyFilesList"), Mx);
Yc = /* @__PURE__ */ new WeakMap();
nr.styles = [va];
Vm([
  O({ type: Object })
], nr.prototype, "order", 2);
Vm([
  O()
], nr.prototype, "view", 2);
Vm([
  O({ type: Boolean })
], nr.prototype, "showTrashed", 2);
Vm([
  F()
], nr.prototype, "highlightId", 2);
Vm([
  F()
], nr.prototype, "highlightComment", 2);
nr = Vm([
  U("wy-files-list"),
  St()
], nr);
var VK = Object.defineProperty, DK = Object.getOwnPropertyDescriptor, F0 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? DK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && VK(t, e, s), s;
}, "__decorateClass$r"), Ax, gy;
let fa = (Ax = (gy = class extends _i {
  constructor() {
    super(), this.appType = gt.Files, this.componentFeatures = new ni({
      // All available features as enabled/disabled by default
      [z.Attachments]: !0,
      [z.CloudFiles]: !0,
      [z.Comments]: !0,
      [z.ContextData]: !0,
      [z.Embeds]: !0,
      [z.GoogleMeet]: !1,
      [z.Meetings]: !1,
      [z.Mentions]: !0,
      [z.MicrosoftTeams]: !1,
      [z.Polls]: !0,
      [z.Previews]: !0,
      [z.Reactions]: !0,
      [z.Typing]: !1,
      // Has no effect currently
      [z.Versions]: !0,
      [z.WebDAV]: !0,
      [z.ZoomMeetings]: !1
    }), this.theme = new wn(this, fa.styles), this.view = "list", this.order = { by: "name", descending: !1 }, this.showTrashed = !1, this.persistState = new g1(this), this.dropZone = new VL(this), this.uploadBlobMutation = new An(this), this.createFileMutation = new An(this), this.addEventListener("drop-files", (t) => this.handleBlobUpload(t));
  }
  /** @internal */
  handleBlobUpload(t) {
    const e = t.detail;
    if (e.files)
      for (let i = 0; i < e.files.length; i++) {
        const s = { file: e.files[i] };
        this.uploadBlobMutation.mutate(s).then((r) => this.handleCreateFile(r));
      }
  }
  /** @internal */
  handleExternalBlobs(t) {
    if (t.detail.externalBlobs)
      for (let e = 0; e < t.detail.externalBlobs.length; e++) {
        const i = t.detail.externalBlobs[e];
        this.externalBlobMutation?.mutate({ externalBlob: i }).then((s) => this.handleCreateFile(s));
      }
  }
  /** @internal */
  async handleCreateFile(t, e) {
    return await this.createFileMutation.mutate({ blob: t, replace: e });
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("uid") || t.has("weavy") || t.has("user")) && this.uid && this.weavy && this.user && this.persistState.observe(
      [
        { name: "view", override: !0 },
        { name: "order", override: !0 },
        { name: "showTrashed", override: !0 }
      ],
      this.uid.toString(),
      `u${this.user.id}`
    ), (t.has("weavy") || t.has("app") || t.has("user")) && this.weavy && this.app && this.user && (await this.uploadBlobMutation.trackMutation(v0(this.weavy, this.user, this.app.id)), await this.createFileMutation.trackMutation(CL(this.weavy, this.user, this.app)), this.externalBlobMutation = j4(this.weavy, this.user, this.app.id));
  }
  render() {
    const t = this.dropZone.isDragActive;
    return v`
      <div
        part="wy-files ${ut({ "wy-dragging": t })}"
        data-drag-title=${P("Drop files here")}
      >
        <wy-files-header
          .order=${this.order}
          .showTrashed=${this.showTrashed}
          .view=${this.view}
          @upload-files=${(e) => this.handleBlobUpload(e)}
          @external-blobs=${(e) => this.handleExternalBlobs(e)}
          @create-files=${(e) => e.detail.blobs.forEach((i) => this.handleCreateFile(i, e.detail.replace))}
          @order=${(e) => {
      this.order = e.detail.order;
    }}
          @show-trashed=${(e) => {
      this.showTrashed = e.detail.showTrashed;
    }}
          @view=${(e) => {
      this.view = e.detail.view;
    }}
          @subscribe=${(e) => this.subscribe(e.detail.subscribe)}
        >
          <slot name="actions" slot="actions"></slot>
        </wy-files-header>

        <wy-files-list
          .view=${this.view}
          .order=${this.order}
          .showTrashed=${this.showTrashed}
          @order=${(e) => {
      this.order = e.detail.order;
    }}
        ></wy-files-list>
      </div>
    `;
  }
}, c(gy, "Fo"), gy), d(Ax, "WyFiles"), Ax);
fa.styles = [
  KW,
  Te,
  ws,
  _l,
  bi,
  zl
];
F0([
  O()
], fa.prototype, "view", 2);
F0([
  O({ type: Object })
], fa.prototype, "order", 2);
F0([
  O({ type: Boolean })
], fa.prototype, "showTrashed", 2);
fa = F0([
  U("wy-files"),
  St()
], fa);
function kV(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["posts", t.id],
    mutationFn: /* @__PURE__ */ d(async ({ id: s }) => {
      if (!(await n.fetch("/api/posts/" + s + "/trash", { method: "POST" })).ok)
        throw new Error();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => {
      Ct(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        s.id,
        (r) => Object.assign(r, { is_trashed: !0 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((s, r) => {
      Ct(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.id,
        (a) => Object.assign(a, s)
      );
    }, "onSuccess")
  };
  return i;
}
c(kV, "Z3");
d(kV, "getTrashPostMutationOptions");
function SV(n, t) {
  return new Xt(n.queryClient, kV(n, t));
}
c(SV, "Y3");
d(SV, "getTrashPostMutation");
function CV(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["posts", t.id],
    mutationFn: /* @__PURE__ */ d(async ({ id: s }) => {
      const r = await n.fetch("/api/posts/" + s + "/restore", { method: "POST" });
      if (!r.ok) {
        const a = await r.json();
        throw new Error(a.detail || a.title, { cause: a });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => {
      Ct(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        s.id,
        (r) => Object.assign(r, { is_trashed: !1 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((s, r) => {
      Ct(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.id,
        (a) => Object.assign(a, { is_trashed: !1 })
      );
    }, "onSuccess")
  };
  return i;
}
c(CV, "X3");
d(CV, "getRestorePostMutationOptions");
function PV(n, t) {
  return new Xt(n.queryClient, CV(n, t));
}
c(PV, "J3");
d(PV, "getRestorePostMutation");
function QV(n, t) {
  const e = n.queryClient, i = ["posts", t.id];
  return {
    mutationKey: i,
    mutationFn: /* @__PURE__ */ d(async ({ id: s, subscribe: r }) => {
      const a = await n.fetch(
        `/api/posts/${s}/${r ? "subscribe" : "unsubscribe"}`,
        { method: "POST" }
      );
      if (!a.ok) {
        const o = await a.json();
        throw new Error(o.detail || o.title, { cause: o });
      }
      return await a.json();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => {
      Ct(
        e,
        { queryKey: i, exact: !1 },
        s.id,
        (r) => Object.assign(r, { is_subscribed: s.subscribe })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((s, r) => {
      Ct(
        e,
        { queryKey: i, exact: !1 },
        r.id,
        (a) => Object.assign(a, s)
      );
    }, "onSuccess")
  };
}
c(QV, "t$");
d(QV, "getSubscribePostMutationOptions");
function TV(n, t) {
  return new Xt(n.queryClient, QV(n, t));
}
c(TV, "e$");
d(TV, "getSubscribePostMutation");
function MV(n, t) {
  return {
    initialPageParam: 0,
    queryKey: ["posts", t],
    queryFn: /* @__PURE__ */ d(async (e) => {
      const i = e.pageParam, s = "/api/apps/" + t + "/posts?order_by=id+desc&skip=" + i, r = await (await n.fetch(s)).json();
      return r.data = r.data || [], r;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ d((e) => {
      if (e.end && e.end < e.count)
        return e.end;
    }, "getNextPageParam")
  };
}
c(MV, "i$");
d(MV, "getPostsOptions");
function AV(n, t) {
  return {
    mutationFn: /* @__PURE__ */ d(async (e) => await (await n.fetch("/api/posts/" + e.id, {
      method: "PATCH",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        attachments: e.attachments,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ id: i.id, text: i.text })),
        embed_id: e.embed_id || null
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ d((e) => {
      ge(n.queryClient, ["posts", e.app_id], e.id, (i) => {
        i.text = e.text, i.html = e.text;
      });
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((e, i) => {
      i.id && ge(n.queryClient, ["posts", i.app_id], i.id, (s) => {
        s.text = e.text, s.html = e.html, s.attachments = e.attachments, s.embed = e.embed, s.meeting = e.meeting, s.updated_at = e.updated_at, s.updated_by = e.updated_by, s.options = e.options;
      });
    }, "onSuccess")
  };
}
c(AV, "r$");
d(AV, "getUpdatePostMutationOptions");
function RV(n, t) {
  const e = n.queryClient;
  return {
    mutationFn: /* @__PURE__ */ d(async (i) => await (await n.fetch("/api/apps/" + i.app_id + "/posts", {
      method: "POST",
      body: JSON.stringify({
        text: i.text,
        blobs: i.blobs,
        meeting_id: i.meeting_id,
        options: i.poll_options.filter((s) => s.text.trim() !== "").map((s) => ({ text: s.text })),
        embed_id: i.embed_id,
        context: i.context
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ d(async (i) => {
      const s = ["posts", i.app_id];
      await e.cancelQueries({ queryKey: s });
      const r = aa(n.queryClient, s, !1);
      if (i.user) {
        const a = {
          id: r ? r.id - 1 : -1,
          app: { id: i.app_id },
          is_subscribed: !0,
          is_trashed: !1,
          text: i.text,
          html: i.text,
          plain: i.text,
          created_by: i.user,
          created_at: (/* @__PURE__ */ new Date()).toUTCString(),
          attachments: { count: 0 },
          reactions: { count: 0 },
          is_starred: !1,
          comments: { count: 0 }
        };
        ra(e, ["posts", i.app_id], a, { descending: !0 });
      }
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((i) => {
      const s = ["posts", i.app.id];
      if (!w1(n.queryClient, s, i.id)) {
        const r = aa(n.queryClient, s, !0);
        r ? ge(n.queryClient, s, r.id, (a) => {
          a.id = i.id, a.app = i.app, a.text = i.text, a.html = i.html, a.embed = i.embed, a.meeting = i.meeting, a.attachments = i.attachments, a.options = i.options, a.created_at = i.created_at, a.created_by = i.created_by, a.updated_at = i.updated_at, a.updated_by = i.updated_by;
        }) : ra(n.queryClient, s, i);
      }
    }, "onSuccess")
  };
}
c(RV, "s$");
d(RV, "getAddPostMutationOptions");
const X0 = et`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-highlight-light, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-on-highlight-light, #001d32))}}[part~=wy-posts]{display:flex;flex-direction:column;gap:var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-posts-header]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));color:var(--wy-component-color);display:flex;flex-direction:column;position:relative;--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-border-radius-outer, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-post]{--wy-component-color: var(--wy-on-surface, var(--wy-on-surface-light, #181c20));background-color:var(--wy-background, var(--wy-background-light, #f7f9ff));color:var(--wy-component-color);display:flex;flex-direction:column;position:relative;clip-path:border-box;--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-component-border-radius)}[part~=wy-post][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-post-images]{display:flex;flex-direction:column;margin-top:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-header]{display:flex;flex-direction:column;padding:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) 0;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-body]{display:flex;flex-direction:column;padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) 0;gap:var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-footer]{display:flex;align-items:center;justify-content:space-between;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-content]{padding:0 var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-post-comments]{background-color:var(--wy-surface-container-low, var(--wy-surface-container-low-light, #f1f3f9));border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf));interpolate-size:allow-keywords;padding:0 var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));height:0;visibility:hidden;transition:height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),padding var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));overflow:hidden}[part~=wy-post-comments][part~=wy-show]{height:auto;visibility:visible;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-post-trashed]{padding-bottom:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}::part(wy-trashed){text-decoration:line-through;color:var(--wy-outline, var(--wy-outline-light, #72777f))}`;
var qK = Object.defineProperty, ZK = Object.getOwnPropertyDescriptor, Y4 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? ZK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && qK(t, e, s), s;
}, "__decorateClass$q"), Rx, wy;
let wm = (Rx = (wy = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this);
  }
  /**
   * Emit a `restore` event requesting restoration of the trashed post.
   *
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  render() {
    return v`
      <div part="wy-post wy-post-trashed">
        <wy-item part="wy-post-header" size="md" noPadding>
          <wy-avatar
            slot="image"
            .src="${this.createdBy.avatar_url}"
            .isAgent=${this.createdBy.is_agent}
            .size=${48}
            .name=${this.createdBy.name}
          ></wy-avatar>
          <span part="wy-trashed" slot="title">${P("Post was trashed.")}</span>
          <wy-button small slot="actions" @click=${() => this.dispatchRestore()} color="variant"
            >${P("Undo")}</wy-button
          >
        </wy-item>
      </div>
    `;
  }
}, c(wy, "Do"), wy), d(Rx, "WyPostTrashed"), Rx);
wm.styles = [X0, ft];
Y4([
  O({ type: Number })
], wm.prototype, "postId", 2);
Y4([
  O({ attribute: !1 })
], wm.prototype, "createdBy", 2);
wm = Y4([
  U("wy-post-trashed"),
  St()
], wm);
var FK = Object.defineProperty, XK = Object.getOwnPropertyDescriptor, xe = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? XK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && FK(t, e, s), s;
}, "__decorateClass$p"), Ex, vy;
let ee = (Ex = (vy = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.html = "", this.text = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.commentCount = 0, this.seenBy = [], this.highlight = !1, this.showComments = !1, this.loadComments = !1, this.isCommentLinked = !1, this.previewAnnotationsRef = wt(), this.previewAttachmentsRef = wt(), this.highlightRef = wt();
  }
  /**
   * Emit a `vote` event for the specified poll option.
   *
   * @internal
   * @param optionId - Identifier of the selected poll option.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling post subscription state.
   *
   * @internal
   * @param subscribe - Desired subscription state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", {
      detail: { id: this.postId, subscribe: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `trash` event requesting the post to move into trash.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  /**
   * Emit an `edit` event toggling edit mode for this post.
   *
   * @internal
   * @param edit - Desired edit state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchEdit(t) {
    const e = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Toggle comment visibility and ensure comment data is loaded.
   *
   * @internal
   * @param e - Click event originating from the comment button.
   */
  handleCommentsClick(t) {
    t.preventDefault(), this.showComments = !this.showComments, this.loadComments = !0;
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("link") && (this.highlight = !!(this.link && P1(this.link, ci.Post, { id: this.postId })), this.isCommentLinked = !!(this.link && I4(this.link, ci.Post, { id: this.postId }, ci.Comment))), t.has("isCommentLinked") && this.isCommentLinked && (this.loadComments = !0, this.showComments = !0);
  }
  render() {
    const t = this.attachments?.filter((g) => g.kind === "image" && g.thumbnail_url), e = this.attachments?.filter((g) => g.kind !== "image" || !g.thumbnail_url), i = new Intl.DateTimeFormat(this.weavy?.locale, {
      dateStyle: "full",
      timeStyle: "short"
    }).format(new Date(this.createdAt)), s = ql(this.weavy?.locale, new Date(this.createdAt)), r = this.modifiedAt && this.weavy ? new Intl.DateTimeFormat(this.weavy.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.modifiedAt)
    ) : "", a = !!(t && t.length), o = !!this.html, l = !!(this.annotations && this.annotations.length), h = !!(this.pollOptions && this.pollOptions.length), u = !!(this.componentFeatures?.allowsFeature(z.Embeds) && this.embed), p = e && !!e.length, y = !!this.meeting, m = o || l || h || u || p || y;
    return this.postId < 0 ? v`
          <div part="wy-post">
            <wy-item part="wy-post-header" align="top" size="md" noPadding>
              <wy-avatar
                slot="image"
                .src="${this.createdBy.avatar_url}"
                .isAgent=${this.createdBy.is_agent}
                .size=${48}
                .name=${this.createdBy.name}
              ></wy-avatar>
              <span slot="title" part="wy-placeholder">${this.createdBy.name}</span>
              <time slot="text" part="wy-placeholder">${s}</time>
            </wy-item>
            <div part="wy-post-body">
              <div part="wy-content wy-post-content"><wy-skeleton .text=${this.text}></wy-skeleton></div>
            </div>
            <div part="wy-post-footer"></div>
          </div>
        ` : v`
          <div
            part=${ut({ "wy-post": !0, "wy-highlight": this.highlight && !this.isCommentLinked })}
            ${ot(this.highlightRef)}
          >
            <wy-item part="wy-post-header" align="top" size="md" noPadding>
              <wy-avatar
                slot="image"
                .src="${this.createdBy.avatar_url}"
                .isAgent=${this.createdBy.is_agent}
                .size=${48}
                .name=${this.createdBy.name}
              ></wy-avatar>
              <span slot="title">${this.createdBy.name}</span>
              <span slot="text">
                <time datetime=${this.createdAt} title=${i}>${s}</time>
                ${this.modifiedAt ? v`<time datetime="${this.modifiedAt}" title=${r}> · ${P("edited")}</time>` : C}
              </span>
              <wy-dropdown slot="actions">
                ${this.isSubscribed ? v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                        <wy-icon name="bell-off"></wy-icon>
                        ${P("Unsubscribe")}
                      </wy-dropdown-item>` : v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                        <wy-icon name="bell"></wy-icon>
                        ${P("Subscribe")}
                      </wy-dropdown-item>`}
                ${this.user && this.user.id === this.createdBy.id ? v`<wy-dropdown-item @click=${() => this.dispatchEdit(!0)}>
                        <wy-icon name="pencil"></wy-icon>
                        ${P("Edit")}
                      </wy-dropdown-item>` : C}
                ${this.user && this.user.id === this.createdBy.id ? v`<wy-dropdown-item @click=${() => this.dispatchTrash()}>
                        <wy-icon name="trashcan"></wy-icon>
                        ${P("Trash")}
                      </wy-dropdown-item>` : C}
              </wy-dropdown>
            </wy-item>

            <!-- image grid -->
            ${a ? v`<wy-image-grid
                    part="wy-post-images"
                    outer
                    .images=${t}
                    @file-open=${(g) => {
      this.previewAttachmentsRef.value?.open(g.detail.fileId);
    }}
                  ></wy-image-grid>` : ""}

            ${m ? v`
                    <div part="wy-post-body">
                      <!-- text content -->
                      ${o ? v`<div part="wy-content wy-post-content">${ol(this.html)}</div>` : ""}

                      <!-- annotations -->
                      ${l ? v`<wy-annotation-list
                            .files=${this.annotations}
                            @file-open=${(g) => {
      this.previewAnnotationsRef.value?.open(g.detail.fileId);
    }}
                          ></wy-annotation-list>` : C}

                      <!-- poll -->
                      ${h && this.pollOptions ? v`
                            <wy-poll
                              .pollOptions=${this.pollOptions}
                              @vote=${(g) => this.dispatchVote(g.detail.optionId)}
                            ></wy-poll>
                          ` : C}

                      <!-- embeds -->
                      ${u && this.embed ? v` <wy-embed .embed=${this.embed}></wy-embed> ` : C}

                      <!-- files -->
                      ${p ? v`<wy-attachment-list
                            filled
                            part="wy-post-attachments"
                            .files=${e ?? []}
                            @file-open=${(g) => {
      this.previewAttachmentsRef.value?.open(g.detail.fileId);
    }}
                          ></wy-attachment-list>` : C}
                      <!-- meeting -->
                      ${y && this.meeting ? v`<wy-meeting-card .meeting=${this.meeting}></wy-meeting-card>` : C}
                    </div>
                  ` : C}
          <div part="wy-post-footer">

            <!-- comment count -->
            ${this.componentFeatures?.allowsFeature(z.Comments) ? v` <wy-button
                    small
                    kind="inline"
                    ?active=${this.showComments}
                    part="wy-meta"
                    color="inherit"
                    @click=${(g) => this.handleCommentsClick(g)}
                  >
                    ${this.commentCount !== 1 ? P(st`${this.commentCount} comments`) : P("1 comment")}
                  </wy-button>` : C}

            <!-- reactions -->
            ${this.componentFeatures?.allowsFeature(z.Reactions) && this.app ? v`
                    <wy-reactions
                      line
                      small
                      .reactions=${this.reactions}
                      parentId=${this.app.id}
                      parentType="apps"
                      entityId=${this.postId}
                      entityType="posts"
                    ></wy-reactions>
                  ` : C}

          </div>

          <!-- comments -->
          <div part="wy-post-comments ${ut({ "wy-show": this.showComments })}">
            ${this.loadComments ? v`
                    <wy-comment-list
                      reveal
                      part="wy-post-comment-list"
                      .parentId=${this.postId}
                      .location=${"posts"}
                    ></wy-comment-list>
                  ` : C}
          </div>
        </div>

            ${this.annotations?.length ? v`<wy-preview
                    ${ot(this.previewAnnotationsRef)}
                    .files=${this.annotations}
                    .isAttachment=${!0}
                  ></wy-preview> ` : C}
            ${this.attachments?.length ? v`<wy-preview
                    ${ot(this.previewAttachmentsRef)}
                    .files=${[...t, ...e]}
                    .isAttachment=${!0}
                  ></wy-preview> ` : C}
          </div>
        `;
  }
  updated(t) {
    t.has("highlight") && this.highlight && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, c(vy, "Ho"), vy), d(Ex, "WyPostView"), Ex);
ee.styles = [X0, XW, D4, PW, P0, Rm, ft];
xe([
  O({ type: Number })
], ee.prototype, "postId", 2);
xe([
  O({ attribute: !1 })
], ee.prototype, "createdBy", 2);
xe([
  O()
], ee.prototype, "createdAt", 2);
xe([
  O()
], ee.prototype, "modifiedAt", 2);
xe([
  O({ type: Boolean })
], ee.prototype, "isSubscribed", 2);
xe([
  O({ type: Boolean })
], ee.prototype, "isTrashed", 2);
xe([
  O()
], ee.prototype, "html", 2);
xe([
  O()
], ee.prototype, "text", 2);
xe([
  O({ type: Array })
], ee.prototype, "annotations", 2);
xe([
  O({ type: Array })
], ee.prototype, "attachments", 2);
xe([
  O({ type: Array })
], ee.prototype, "pollOptions", 2);
xe([
  O({ attribute: !1 })
], ee.prototype, "meeting", 2);
xe([
  O({ attribute: !1 })
], ee.prototype, "embed", 2);
xe([
  O({ type: Array })
], ee.prototype, "reactions", 2);
xe([
  O({ attribute: !1 })
], ee.prototype, "commentCount", 2);
xe([
  O({ type: Array })
], ee.prototype, "seenBy", 2);
xe([
  O({ type: Boolean })
], ee.prototype, "highlight", 2);
xe([
  F()
], ee.prototype, "showComments", 2);
xe([
  F()
], ee.prototype, "loadComments", 2);
xe([
  F()
], ee.prototype, "isCommentLinked", 2);
ee = xe([
  U("wy-post-view"),
  St()
], ee);
var NK = Object.defineProperty, jK = Object.getOwnPropertyDescriptor, $i = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? jK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && NK(t, e, s), s;
}, "__decorateClass$o"), _x, Oy;
let Ue = (_x = (Oy = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.temp = !1, this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.text = "", this.attachments = [], this.pollOptions = [], this.reactions = [], this.seenBy = [], this.updatePostMutation = new An(this);
  }
  /**
   * Emit an `edit` event toggling edit mode for the post.
   *
   * @param edit - Desired edit state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchEdit(t) {
    const e = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(e);
  }
  /**
   * Handle editor submit events and trigger the post update mutation.
   *
   * @param e - Editor submit detail containing updated content.
   */
  async handleSubmit(t) {
    const e = await this.whenApp();
    this.updatePostMutation.mutate({
      id: this.postId,
      app_id: e.id,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      attachments: t.detail.attachments,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId
    }), this.dispatchEdit(!1);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && await this.updatePostMutation.trackMutation(AV(this.weavy, ["posts", this.app.id]));
  }
  render() {
    const t = ql(this.weavy?.locale, new Date(this.createdAt));
    return v`
      <div part="wy-post">
        <wy-item part="wy-post-header" align="top" size="md" noPadding>
          <wy-avatar
            slot="image"
            .src="${this.createdBy.avatar_url}"
            .isAgent=${this.createdBy.is_agent}
            .size=${48}
            .name=${this.createdBy.name}
          ></wy-avatar>
          <span slot="title" part="wy-placeholder">${this.createdBy.name}</span>
          <time slot="text" part="wy-placeholder">${t}</time>
          <wy-button slot="actions" kind="icon" @click=${() => this.dispatchEdit(!1)}>
            <wy-icon name="close"></wy-icon>
          </wy-button>
        </wy-item>

        <wy-editor
          editorLocation="apps"
          .text=${this.text}
          .embed=${this.embed}
          .options=${this.pollOptions}
          .attachments=${this.attachments ?? []}
          .parentId=${this.postId}
          .typing=${!1}
          .draft=${!1}
          placeholder=${P("Edit post...")}
          buttonText=${P("Update", { desc: "Button action to update" })}
          @submit=${(e) => this.handleSubmit(e)}
        ></wy-editor>
      </div>
    `;
  }
}, c(Oy, "Vo"), Oy), d(_x, "WyPostEdit"), _x);
Ue.styles = [X0, Rm, ft];
$i([
  O({ type: Number })
], Ue.prototype, "postId", 2);
$i([
  O({ type: Boolean })
], Ue.prototype, "temp", 2);
$i([
  O({ attribute: !1 })
], Ue.prototype, "createdBy", 2);
$i([
  O()
], Ue.prototype, "createdAt", 2);
$i([
  O()
], Ue.prototype, "modifiedAt", 2);
$i([
  O({ type: Boolean })
], Ue.prototype, "isSubscribed", 2);
$i([
  O({ type: Boolean })
], Ue.prototype, "isTrashed", 2);
$i([
  O()
], Ue.prototype, "text", 2);
$i([
  O({ type: Array })
], Ue.prototype, "attachments", 2);
$i([
  O({ type: Array })
], Ue.prototype, "pollOptions", 2);
$i([
  O({ attribute: !1 })
], Ue.prototype, "meeting", 2);
$i([
  O({ attribute: !1 })
], Ue.prototype, "embed", 2);
$i([
  O({ type: Array })
], Ue.prototype, "reactions", 2);
$i([
  O({ type: Array })
], Ue.prototype, "seenBy", 2);
Ue = $i([
  U("wy-post-edit"),
  St()
], Ue);
var BK = Object.defineProperty, UK = Object.getOwnPropertyDescriptor, Ze = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? UK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && BK(t, e, s), s;
}, "__decorateClass$n"), zx, by;
let ue = (zx = (by = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.html = "", this.text = "", this.plain = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.commentCount = 0, this.seenBy = [], this.editing = !1;
  }
  /**
   * Emit a `vote` event scoped to the post.
   *
   * @internal
   * @param optionId - Identifier of the selected poll option.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchVote(t) {
    const e = new CustomEvent("vote", {
      detail: { optionId: t, parentId: this.postId, parentType: "posts" }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `subscribe` event toggling post subscription.
   *
   * @internal
   * @param subscribe - Desired subscription state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", {
      detail: { id: this.postId, subscribe: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `trash` event requesting the post to be trashed.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  /**
   * Emit a `restore` event requesting the post to be restored.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  render() {
    return v`
      ${this.isTrashed ? v`<wy-post-trashed
            postId=${this.postId}
            .createdBy=${this.createdBy}
            @restore=${() => {
      this.dispatchRestore();
    }}
          ></wy-post-trashed> ` : C}
      ${!this.isTrashed && this.editing ? v`<wy-post-edit
            .postId=${this.postId}
            .createdBy=${this.createdBy}
            .createdAt=${this.createdAt}
            .text=${this.text}
            .embed=${this.embed}
            .pollOptions=${this.pollOptions}
            .attachments=${this.attachments}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}
          ></wy-post-edit> ` : C}
      ${!this.isTrashed && !this.editing ? v`<wy-post-view
            id="${this.id}"
            .postId=${this.postId}
            .createdBy=${this.createdBy}
            .createdAt=${this.createdAt}
            .modifiedAt=${this.modifiedAt}
            .isSubscribed=${this.isSubscribed}
            .isTrashed=${this.isTrashed}
            .html=${this.html}
            .text=${this.plain}
            .annotations=${this.annotations ?? []}
            .attachments=${this.attachments ?? []}
            .meeting=${this.meeting}
            .pollOptions=${this.pollOptions}
            .embed=${this.embed}
            .reactions=${this.reactions}
            .commentCount=${this.commentCount}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}
            @subscribe=${(t) => {
      this.dispatchSubscribe(t.detail.subscribe);
    }}
            @trash=${() => {
      this.dispatchTrash();
    }}
            @vote=${(t) => {
      this.dispatchVote(t.detail.optionId);
    }}
          ></wy-post-view> ` : C}
    `;
  }
}, c(by, "Uo"), by), d(zx, "WyPost"), zx);
ue.styles = [ne];
Ze([
  O({ type: Number })
], ue.prototype, "postId", 2);
Ze([
  O({ attribute: !1 })
], ue.prototype, "createdBy", 2);
Ze([
  O()
], ue.prototype, "createdAt", 2);
Ze([
  O()
], ue.prototype, "modifiedAt", 2);
Ze([
  O({ type: Boolean })
], ue.prototype, "isSubscribed", 2);
Ze([
  O({ type: Boolean })
], ue.prototype, "isTrashed", 2);
Ze([
  O()
], ue.prototype, "html", 2);
Ze([
  O()
], ue.prototype, "text", 2);
Ze([
  O()
], ue.prototype, "plain", 2);
Ze([
  O({ attribute: !1 })
], ue.prototype, "annotations", 2);
Ze([
  O({ attribute: !1 })
], ue.prototype, "attachments", 2);
Ze([
  O({ type: Array })
], ue.prototype, "pollOptions", 2);
Ze([
  O({ attribute: !1 })
], ue.prototype, "meeting", 2);
Ze([
  O({ attribute: !1 })
], ue.prototype, "embed", 2);
Ze([
  O({ type: Array })
], ue.prototype, "reactions", 2);
Ze([
  O({ attribute: !1 })
], ue.prototype, "commentCount", 2);
Ze([
  O({ type: Array })
], ue.prototype, "seenBy", 2);
Ze([
  F()
], ue.prototype, "editing", 2);
ue = Ze([
  U("wy-post")
], ue);
var HK = Object.defineProperty, YK = Object.getOwnPropertyDescriptor, EV = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$5"), _V = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? YK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && HK(t, e, s), s;
}, "__decorateClass$m"), zV = /* @__PURE__ */ d((n, t, e) => t.has(n) || EV("Cannot " + e), "__accessCheck$5"), M9 = /* @__PURE__ */ d((n, t, e) => (zV(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$5"), GK = /* @__PURE__ */ d((n, t, e) => t.has(n) ? EV("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$5"), A9 = /* @__PURE__ */ d((n, t, e, i) => (zV(n, t, "write to private field"), t.set(n, e), e), "__privateSet$5"), Gc, Lx, $y;
let n1 = (Lx = ($y = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.postsQuery = new Rl(this), this.infiniteScroll = new El(this), this.pagerRef = wt(), this.addPostMutation = new An(this), this.handleRealtimePostCreated = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp(), s = await this.whenUser();
      t.post.app.id !== i.id || t.post.created_by?.id === s.id || (t.post.created_by = t.actor, ra(e.queryClient, ["posts", i.id], t.post, {
        descending: !0
      }));
    }, this.handleRealtimeCommentCreated = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp(), s = await this.whenUser();
      t.actor.id === s.id || !t.comment.parent || (ge(e.queryClient, ["posts", i.id], t.comment.parent.id, (r) => {
        r.comments ? r.comments.count += 1 : r.comments = { count: 1 };
      }), await e.queryClient.invalidateQueries({ queryKey: ["posts", t.comment.app.id, "comments"] }));
    }, this.handleRealtimeReactionAdded = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp();
      t.entity.type === ci.Post && ge(e.queryClient, ["posts", i.id], t.entity.id, (s) => {
        ym(s, t.reaction, t.actor);
      });
    }, this.handleRealtimeReactionDeleted = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp();
      t.entity.type === ci.Post && ge(e.queryClient, ["posts", i.id], t.entity.id, (s) => {
        ym(s, void 0, t.actor);
      });
    }, GK(this, Gc);
  }
  /**
   * Handle editor submissions by dispatching the create-post mutation.
   *
   * @param e - Submitted editor data.
   */
  async handleSubmit(t) {
    const e = await this.whenApp(), i = await this.whenUser();
    this.addPostMutation.mutate({
      app_id: e.id,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      user: i,
      context: t.detail.contextData
    });
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && this.app?.id !== t.get("app")?.id && await this.postsQuery.trackInfiniteQuery(MV(this.weavy, this.app.id)), (t.has("weavy") || t.has("app") || t.has("componentFeatures")) && this.weavy && this.app && this.app?.id !== t.get("app")?.id) {
      await this.addPostMutation.trackMutation(RV(this.weavy, ["posts", this.app.id])), this.subscribePostMutation = TV(this.weavy, this.app), this.removePostMutation = SV(this.weavy, this.app), this.restorePostMutation = PV(this.weavy, this.app), this.pollMutation = S0(this.weavy, this.app.id, ["posts", this.app.id]), (e = M9(this, Gc)) == null || e.call(this);
      const i = `a${this.app.id}`;
      this.weavy.subscribe(i, "post_created", this.handleRealtimePostCreated), this.weavy.subscribe(i, "comment_created", this.handleRealtimeCommentCreated), this.componentFeatures?.allowsFeature(z.Reactions) && (this.weavy.subscribe(i, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(i, "reaction_removed", this.handleRealtimeReactionDeleted)), A9(this, Gc, () => {
        this.weavy?.unsubscribe(i, "post_created", this.handleRealtimePostCreated), this.weavy?.unsubscribe(i, "comment_created", this.handleRealtimeCommentCreated), this.weavy?.unsubscribe(i, "reaction_added", this.handleRealtimeReactionAdded), this.weavy?.unsubscribe(i, "reaction_removed", this.handleRealtimeReactionDeleted), A9(this, Gc, void 0);
      });
    }
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.postsQuery.result, this.pagerRef.value);
  }
  render() {
    const { data: t, isPending: e, hasNextPage: i } = this.postsQuery.result ?? {}, s = cs(t);
    return v`
      <div part="wy-posts">
        <div part="wy-posts-header">
          <wy-editor
            editorLocation="apps"
            ?disabled=${!lm(rl.Create, this.app?.permissions)}
            .typing=${!1}
            .draft=${!0}
            placeholder=${this.placeholder ?? P("Create a post...")}
            buttonText=${P("Post")}
            @submit=${(r) => this.handleSubmit(r)}
          ></wy-editor>
        </div>

        <!-- this.user ?? -->
        ${e ? v`<wy-empty><wy-progress-circular indeterminate padded></wy-progress-circular></wy-empty> ` : v`
              ${s ? Mi(
      s,
      (r) => r.id,
      (r) => v`<wy-post
                        id="post-${r.id}"
                        .postId=${r.id}
                        .createdBy=${r.created_by}
                        .createdAt=${r.created_at}
                        .modifiedAt=${r.updated_at}
                        .isSubscribed=${r.is_subscribed}
                        .isTrashed=${r.is_trashed}
                        .html=${r.html}
                        .text=${r.text}
                        .plain=${r.plain}
                        .annotations=${r.annotations?.data}
                        .attachments=${r.attachments?.data}
                        .meeting=${r.meeting}
                        .pollOptions=${r.options?.data}
                        .embed=${r.embed}
                        .reactions=${r.reactions?.data}
                        .commentCount=${r.comments?.count || 0}
                        @subscribe=${(a) => {
        this.subscribePostMutation?.mutate({
          id: a.detail.id,
          subscribe: a.detail.subscribe
        });
      }}
                        @trash=${(a) => {
        this.removePostMutation?.mutate({ id: a.detail.id });
      }}
                        @restore=${(a) => {
        this.restorePostMutation?.mutate({ id: a.detail.id });
      }}
                        @vote=${(a) => {
        a.detail.parentType && a.detail.parentId && this.pollMutation?.mutate({
          optionId: a.detail.optionId,
          parentType: a.detail.parentType,
          parentId: a.detail.parentId
        });
      }}
                      ></wy-post>`
    ) : v`<wy-empty></wy-empty>`}
              ${i ? v`<div ${ot(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
            `}
      </div>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = M9(this, Gc)) == null || t.call(this), super.disconnectedCallback();
  }
}, c($y, "Bo"), $y), d(Lx, "WyPostList"), Lx);
Gc = /* @__PURE__ */ new WeakMap();
n1.styles = [X0, Z4, va, ft];
_V([
  O()
], n1.prototype, "placeholder", 2);
n1 = _V([
  U("wy-post-list"),
  St()
], n1);
var KK = Object.defineProperty, JK = Object.getOwnPropertyDescriptor, LV = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? JK(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && KK(t, e, s), s;
}, "__decorateClass$l"), Ix, xy;
let vm = (Ix = (xy = class extends _i {
  constructor() {
    super(...arguments), this.appType = gt.Posts, this.componentFeatures = new ni({
      // All available features as enabled/disabled by default
      [z.Attachments]: !0,
      [z.CloudFiles]: !0,
      [z.Comments]: !0,
      [z.ContextData]: !0,
      [z.Embeds]: !0,
      [z.GoogleMeet]: !1,
      [z.Meetings]: !1,
      [z.Mentions]: !0,
      [z.MicrosoftTeams]: !1,
      [z.Polls]: !0,
      [z.Previews]: !0,
      [z.Reactions]: !0,
      [z.Typing]: !1,
      // Has no effect currently
      [z.ZoomMeetings]: !1
    }), this.theme = new wn(this, vm.styles);
  }
  render() {
    return v`
      <wy-buttons position="floating" reverse><slot name="actions"></slot></wy-buttons>
      <wy-post-list .placeholder=${this.placeholder}></wy-post-list>
      <wy-context-data-progress></wy-context-data-progress>
    `;
  }
}, c(xy, "qo"), xy), d(Ix, "WyPosts"), Ix);
vm.styles = [Te, ws, _l, zl, bi];
LV([
  O()
], vm.prototype, "placeholder", 2);
vm = LV([
  U("wy-posts"),
  St()
], vm);
const tJ = et`[part~=wy-notification] strong{font-weight:var(--wy-font-weight-bold, 600)}[part~=wy-notification] p{display:inline}[part~=wy-notification-text]{color:var(--wy-component-color)}[part~=wy-notification-text]{display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;overflow:hidden}[part~=wy-notification-text]{white-space:normal}`;
var eJ = Object.defineProperty, iJ = Object.getOwnPropertyDescriptor, z1 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? iJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && eJ(t, e, s), s;
}, "__decorateClass$k"), Wx, ky;
let ya = (Wx = (ky = class extends zi {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.selected = !1, this.standalone = !1;
  }
  /**
   * Emit a `select` event for the current notification.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchSelect(t) {
    const e = new CustomEvent("select", {
      detail: { notificationId: this.notificationId }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Emit a `mark` event toggling read status.
   *
   * @internal
   * @param e - Source event triggering the action.
   * @param markAsRead - Target read state.
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchMark(t, e) {
    if (t.stopPropagation(), e === !!this.notification.is_unread) {
      const i = new CustomEvent("mark", {
        detail: { notificationId: this.notificationId, markAsRead: e }
      });
      return this.dispatchEvent(i);
    }
    return !0;
  }
  /**
   * Emit a `hide` event when the toast should disappear.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchHide() {
    if (this.standalone) {
      const t = new CustomEvent("hide", {
        bubbles: !0
      });
      return this.dispatchEvent(t);
    }
    return !0;
  }
  /**
   * Emit a `close` event when the toast should close.
   *
   * @internal
   * @returns {boolean} True if the event was not canceled.
   */
  dispatchClose() {
    if (this.standalone) {
      const t = new CustomEvent("close", {
        bubbles: !0
      });
      return this.dispatchEvent(t);
    }
    return !0;
  }
  /**
   * Handle click interactions and trigger navigation plus dismissal.
   *
   * @internal
   */
  async handleClick(t) {
    this.dispatchSelect(t), this.dispatchMark(t, !0), this.dispatchHide(), await W4(this, this.weavy, this.notification), this.dispatchClose();
  }
  render() {
    const t = this.notification.created_at ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.notification.created_at)
    ) : "", e = this.notification.created_at ? ql(this.weavy?.locale, new Date(this.notification.created_at)) : "", i = this.notification.actor, { title: s, titleHtml: r, detail: a } = V4(this.notification);
    return v`
      <wy-item
        part="wy-notification"
        size="md"
        interactive
        outer
        status=${!this.standalone && !this.notification.is_unread ? "read" : void 0}
        ?selected=${!this.standalone && this.selected}
        align="top"
        actionsPosition=${this.standalone ? "end" : "bottom"}
        tabindex="0"
        @click=${(o) => this.handleClick(o)}
        @keydown=${Le}
        @keyup=${di}
      >
        <wy-avatar
          slot="image"
          src=${Ot(i?.avatar_url)}
          name=${Ot(i?.name)}
          description=${Ot(i?.comment)}
          presence=${i?.presence || "away"}
          ?isAgent=${i?.is_agent}
          id=${Ot(i?.id)}
          size=${48}
        ></wy-avatar>

        <div slot="title" part="wy-notification-text" title=${s + (a ? `: "${a}"` : "")}>
          ${r}${a ? v`: <q part="wy-quote">${a}</q> ` : C}
      </div>

        ${this.standalone ? C : v`
              <time slot="text" part="wy-meta" datetime=${this.notification.created_at.toString()} title=${t}>
                ${e}
              </time>
            `}
        ${this.standalone ? v`
              <wy-button
                slot="actions"
                kind="icon"
                @click=${(o) => this.dispatchMark(o, !!this.notification.is_unread) && this.dispatchClose()}
              >
                <wy-icon name="close"></wy-icon>
              </wy-button>
            ` : v`
              <wy-button
                small
                slot="actions"
                kind="icon"
                @click=${(o) => this.dispatchMark(o, !!this.notification.is_unread) && this.dispatchClose()}
                title=${this.notification.is_unread ? P("Mark as read") : P("Mark as unread")}
              >
                <wy-icon
                  name=${this.notification.is_unread ? "read" : "unread"}
                  color=${this.notification.is_unread ? "" : "secondary"}
                ></wy-icon>
              </wy-button>
            `}
      </wy-item>
    `;
  }
}, c(ky, "No"), ky), d(Wx, "WyNotificationListItem"), Wx);
ya.styles = [ne, Rm, tJ, ft];
z1([
  O({ type: Number })
], ya.prototype, "notificationId", 2);
z1([
  O({ type: Boolean, reflect: !0 })
], ya.prototype, "selected", 2);
z1([
  O({ type: Boolean })
], ya.prototype, "standalone", 2);
z1([
  O({ attribute: !1 })
], ya.prototype, "notification", 2);
ya = z1([
  U("wy-notification-list-item"),
  St()
], ya);
var nJ = Object.defineProperty, sJ = Object.getOwnPropertyDescriptor, IV = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$4"), Xl = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? sJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && nJ(t, e, s), s;
}, "__decorateClass$j"), WV = /* @__PURE__ */ d((n, t, e) => t.has(n) || IV("Cannot " + e), "__accessCheck$4"), R9 = /* @__PURE__ */ d((n, t, e) => (WV(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$4"), rJ = /* @__PURE__ */ d((n, t, e) => t.has(n) ? IV("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$4"), E9 = /* @__PURE__ */ d((n, t, e, i) => (WV(n, t, "write to private field"), t.set(n, e), e), "__privateSet$4"), Kc, Vx, Sy;
let Om = (Vx = (Sy = class extends Oe {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.typeFilter = qt.All, this.notificationsQuery = new Rl(this), this.infiniteScroll = new El(this), this.pagerRef = wt(), this.handleRefresh = (t) => {
      this.notificationsQuery.result.refetch();
    }, this.handlePresenceChange = (t) => {
      this.weavy && (Array.isArray(t) || (t = [parseInt(t)]), ge(this.weavy.queryClient, ["notifications", "list"], void 0, (e) => {
        const i = e.actor;
        i.presence = t.indexOf(i.id) != -1 ? "active" : "away", e.actor = i;
      }));
    }, rJ(this, Kc);
  }
  /**
   * Mark or unmark a notification as read.
   *
   * @param notificationId - Target notification id.
   * @param markAsRead - Desired read state.
   */
  async markAsRead(t, e = !0) {
    await this.markNotificationMutation?.mutate({ notificationId: t, markAsRead: e });
  }
  /**
   * Select the provided notification and emit a `wy-action` event.
   *
   * @internal
   * @param notification - Notification to select.
   */
  selectNotification(t) {
    this.notificationId = t.id, this.dispatchAction(hi.Select, t);
  }
  /**
   * Triggers `wy-action` event.
   *
   * @internal
   * @param action - The performed action.
   * @param notification - Selected notification payload.
   * @returns Whether the event was successful.
   */
  dispatchAction(t, e) {
    const i = new CustomEvent("wy-action", {
      detail: { action: t, notification: e },
      bubbles: !0,
      composed: !0
    });
    return this.dispatchEvent(i);
  }
  async willUpdate(t) {
    var e;
    super.willUpdate(t), (t.has("weavy") || t.has("typeFilter") || t.has("app")) && this.weavy && await this.notificationsQuery.trackInfiniteQuery(
      sI(this.weavy, this.typeFilter, this.app?.id)
    ), t.has("weavy") && this.weavy && (this.markNotificationMutation = r4(this.weavy), (e = R9(this, Kc)) == null || e.call(this), this.weavy.subscribe(null, "online", this.handlePresenceChange), this.weavy.subscribe(null, "notification_created", this.handleRefresh), this.weavy.subscribe(null, "notification_updated", this.handleRefresh), this.weavy.subscribe(null, "notifications_marked", this.handleRefresh), E9(this, Kc, () => {
      this.weavy?.unsubscribe(null, "online", this.handlePresenceChange), this.weavy?.unsubscribe(null, "notification_created", this.handleRefresh), this.weavy?.unsubscribe(null, "notification_updated", this.handleRefresh), this.weavy?.unsubscribe(null, "notifications_marked", this.handleRefresh), E9(this, Kc, void 0);
    }));
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.notificationsQuery.result, this.pagerRef.value);
  }
  /**
   * Render the notifications collection.
   *
   * @internal
   * @param user - Current user.
   * @param infiniteData - Notification pages.
   */
  renderNotifications(t, e) {
    if (e) {
      const i = cs(e);
      return Mi(
        i,
        (s) => s?.id,
        (s) => [
          v`<wy-notification-list-item
              notificationId=${s.id}
              .notification=${s}
              .selected=${this.notificationId == s.id}
              @select=${(r) => this.selectNotification(s)}
              @mark=${(r) => this.markAsRead(r.detail.notificationId, r.detail.markAsRead)}
            ></wy-notification-list-item>`
        ]
      );
    }
    return C;
  }
  render() {
    const { data: t, hasNextPage: e, isPending: i } = this.notificationsQuery.result ?? {};
    return v`
      ${this.user ? v`
            <div class="wy-notifications">
              ${!i && this.user && t ? t.pages[0]?.count ? this.renderNotifications(this.user, t) : v`
                      <div part="wy-pane-body">
                        <div part="wy-pane-group">
                          <slot name="empty">
                            <wy-empty>${P("No updates yet.")}</wy-empty>
                          </slot>
                        </div>
                      </div>
                    ` : v`<wy-empty><wy-progress-circular indeterminate padded></wy-progress-circular></wy-empty>`}
              ${e ? v`<div ${ot(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
            </div>
          ` : v`<wy-empty part="wy-pane"><wy-progress-circular indeterminate overlay></wy-progress-circular></wy-empty>`}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = R9(this, Kc)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Sy, "jo"), Sy), d(Vx, "WyNotificationList"), Vx);
Kc = /* @__PURE__ */ new WeakMap();
Om.styles = [
  Il,
  va,
  et`
      :host {
        position: relative;
      }
    `
];
Xl([
  O({ type: Number })
], Om.prototype, "notificationId", 2);
Xl([
  O()
], Om.prototype, "typeFilter", 2);
Om = Xl([
  U("wy-notification-list"),
  St()
], Om);
var Dx, Cy;
let bl = (Dx = (Cy = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.typeFilter = qt.All, this.activeFilter = qt.All;
  }
  /**
   * Trigger `filter` event.
   *
   * @param typeFilter - Filter to emit.
   * @returns Whether the event was dispatched successfully.
   */
  dispatchFilter(t) {
    const e = new CustomEvent("filter", {
      detail: { typeFilter: t }
    });
    return this.dispatchEvent(e);
  }
  render() {
    const t = !!this._slotDefault.length;
    return v`
      <div part="wy-pane-toolbar">
        <slot @slotchange=${() => this.requestUpdate()}></slot>
        ${t ? C : v`
              <wy-buttons tabs>
                <wy-button
                  ?active=${this.typeFilter === qt.All}
                  @click=${() => {
      this.dispatchFilter(qt.All) && (this.typeFilter = qt.All);
    }}
                  kind="tab"
                  small
                >
                  ${P("All")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === qt.Activity}
                  @click=${() => {
      this.dispatchFilter(qt.Activity) && (this.typeFilter = qt.Activity);
    }}
                  kind="tab"
                  small
                >
                  ${P("Activities")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === qt.Mention}
                  @click=${() => {
      this.dispatchFilter(qt.Mention) && (this.typeFilter = qt.Mention);
    }}
                  kind="tab"
                  small
                >
                  ${P("Mentions")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === qt.Reaction}
                  @click=${() => {
      this.dispatchFilter(qt.Reaction) && (this.typeFilter = qt.Reaction);
    }}
                  kind="tab"
                  small
                >
                  ${P("Reactions")}
                </wy-button>
              </wy-buttons>
            `}

        <slot name="actions" @slotchange=${() => this.requestUpdate()}></slot>
      </div>
    `;
  }
}, c(Cy, "Wo"), Cy), d(Dx, "WyNotificationHeader"), Dx);
bl.styles = [
  Il,
  va,
  et`
      :host {
        position: relative;
      }
    `
];
Xl([
  O()
], bl.prototype, "typeFilter", 2);
Xl([
  F()
], bl.prototype, "activeFilter", 2);
Xl([
  Ml({ flatten: !0, selector: ":not(slot)" })
], bl.prototype, "_slotDefault", 2);
bl = Xl([
  U("wy-notification-header"),
  St()
], bl);
var aJ = Object.defineProperty, oJ = Object.getOwnPropertyDescriptor, G4 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? oJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && aJ(t, e, s), s;
}, "__decorateClass$i"), qx, Py;
let $l = (qx = (Py = class extends Mm {
  constructor() {
    super(...arguments), this.unreadNotifications = new a4(this), this.theme = new wn(this, $l.styles), this.currentTypeFilter = qt.All, this.typeFilter = qt.All;
  }
  /** Current unread notification count. */
  get unread() {
    return this.unreadNotifications.unread;
  }
  /** Marks all tracked notifications as read. */
  async markAllAsRead() {
    await this.unreadNotifications.markAllAsRead();
  }
  async willUpdate(t) {
    await super.willUpdate(t), t.has("typeFilter") && (this.currentTypeFilter = this.typeFilter), (t.has("typeFilter") || t.has("app")) && await this.unreadNotifications.track(this.typeFilter, this.app?.id);
  }
  render() {
    const t = this.typeFilter === qt.All;
    return v`
      ${t ? v`
            <wy-notification-header
              @filter=${(e) => {
      this.currentTypeFilter = e.detail.typeFilter;
    }}
            >
              <slot name="actions" slot="actions">
                <wy-button kind="icon" @click=${() => this.markAllAsRead()} title=${P("Mark all as read")}>
                  <wy-icon name="check-all"></wy-icon>
                </wy-button>
              </slot>
            </wy-notification-header>
          ` : C}
      ${this.user ? v` <wy-notification-list typeFilter=${this.currentTypeFilter}></wy-notification-list> ` : v`
            <wy-empty>
              <wy-progress-circular indeterminate padded reveal></wy-progress-circular>
            </wy-empty>
          `}
    `;
  }
}, c(Py, "Qo"), Py), d(qx, "WyNotifications"), qx);
$l.styles = [Te, ws, _l, zl, bi];
G4([
  F()
], $l.prototype, "currentTypeFilter", 2);
G4([
  O()
], $l.prototype, "typeFilter", 2);
$l = G4([
  U("wy-notifications"),
  St()
], $l);
const VV = et`:host{display:inline-flex}`;
var lJ = Object.defineProperty, cJ = Object.getOwnPropertyDescriptor, N0 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? cJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && lJ(t, e, s), s;
}, "__decorateClass$h"), Zx, Qy;
let xl = (Zx = (Qy = class extends Mm {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.unreadNotifications = new a4(this), this.badge = "count", this.badgePosition = "inline", this.typeFilter = qt.All;
  }
  /** Current unread notification count. */
  get unread() {
    return this.unreadNotifications.unread;
  }
  /** Marks all tracked notifications as read. */
  async markAllAsRead() {
    await this.unreadNotifications.markAllAsRead();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("typeFilter") || t.has("app")) && await this.unreadNotifications.track(this.typeFilter, this.app?.id);
  }
  render() {
    return this.user && this.badge !== "none" ? v`
          <wy-badge
            appearance=${this.badge}
            position=${this.badgePosition}
            .count=${this.unreadNotifications.isUnreadPending ? NaN : this.unreadNotifications.unread}
          ></wy-badge>
        ` : C;
  }
}, c(Qy, "Ko"), Qy), d(Zx, "WyNotificationBadge"), Zx);
xl.styles = [VV, Te, bi];
N0([
  O({ type: String })
], xl.prototype, "badge", 2);
N0([
  O({ type: String })
], xl.prototype, "badgePosition", 2);
N0([
  O()
], xl.prototype, "typeFilter", 2);
xl = N0([
  U("wy-notification-badge")
], xl);
var hJ = Object.defineProperty, dJ = Object.getOwnPropertyDescriptor, xa = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? dJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && hJ(t, e, s), s;
}, "__decorateClass$g"), Fx, Ty;
let _n = (Fx = (Ty = class extends Mm {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.unreadNotifications = new a4(this), this.overlay = "sheet", this.badge = "compact", this.badgePosition = "top-right", this.typeFilter = qt.All, this.currentTypeFilter = qt.All, this.showNotificationList = !1;
  }
  set list(t) {
    console.warn(`.list is deprecated. Use .overlay = "${t}"; instead`), this.overlay = t;
  }
  get list() {
    return this.overlay;
  }
  /** Current unread notification count. */
  get unread() {
    return this.unreadNotifications.unread;
  }
  /** Marks all tracked notifications as read. */
  async markAllAsRead() {
    await this.unreadNotifications.markAllAsRead();
  }
  async willUpdate(t) {
    await super.willUpdate(t), t.has("typeFilter") && (this.currentTypeFilter = this.typeFilter), (t.has("typeFilter") || t.has("app")) && await this.unreadNotifications.track(this.typeFilter, this.app?.id);
  }
  render() {
    const t = this.typeFilter === qt.All;
    return v`
      <wy-button
        kind="icon"
        ?active=${this.showNotificationList}
        @click=${() => this.showNotificationList = !this.showNotificationList}
      >
        <wy-icon name="bell">
          ${this.user && this.badge !== "none" ? v`
                <wy-badge
                  appearance=${this.badge}
                  position=${this.badgePosition}
                  .count=${this.unreadNotifications.isUnreadPending ? NaN : this.unreadNotifications.unread}
                ></wy-badge>
              ` : C}
        </wy-icon>
      </wy-button>

      ${this.overlay !== "none" ? v`<wy-overlay
            type=${this.overlay}
            .show=${this.showNotificationList}
            @close=${() => this.showNotificationList = !1}
          >
            <slot name="actions" slot="actions">
              <wy-button kind="icon" @click=${() => this.markAllAsRead()} title=${P("Mark all as read")}>
                <wy-icon name="check-all"></wy-icon>
              </wy-button>
              ${this.app ? v`
                    <wy-dropdown>
                      ${this.app?.is_subscribed ? v`
                            <wy-dropdown-item @click=${() => this.subscribe(!1)}>
                              <wy-icon name="bell-off"></wy-icon>
                              ${P("Unsubscribe")}
                            </wy-dropdown-item>
                          ` : v`
                            <wy-dropdown-item @click=${() => this.subscribe(!0)}>
                              <wy-icon name="bell"></wy-icon>
                              ${P("Subscribe")}
                            </wy-dropdown-item>
                          `}
                    </wy-dropdown>
                  ` : C}
            </slot>
            <slot slot="title">${P("Notifications")}</slot>
            <wy-container scrollY>
              ${this.showNotificationList ? v`
                    ${t ? v`
                          <wy-notification-header
                            @filter=${(e) => {
      this.currentTypeFilter = e.detail.typeFilter;
    }}
                          ></wy-notification-header>
                        ` : C}
                    <wy-notification-list typeFilter=${this.currentTypeFilter}>
                      ${this.app && !this.app?.is_subscribed ? v`
                            <wy-empty slot="empty">
                              <div>${P("You are not subscribed to updates yet.")}</div>
                              <wy-button color="primary" @click=${() => this.subscribe(!0)}
                                >${P("Subscribe")}</wy-button
                              >
                            </wy-empty>
                          ` : C}
                    </wy-notification-list>
                  ` : C}
            </wy-container>
          </wy-overlay>` : C}
    `;
  }
}, c(Ty, "Go"), Ty), d(Fx, "WyNotificationButton"), Fx);
_n.styles = [ft, Te, bi];
xa([
  O({ type: String })
], _n.prototype, "overlay", 2);
xa([
  O({ type: String })
], _n.prototype, "list", 1);
xa([
  O({ type: String })
], _n.prototype, "badge", 2);
xa([
  O({ type: String })
], _n.prototype, "badgePosition", 2);
xa([
  O()
], _n.prototype, "typeFilter", 2);
xa([
  F()
], _n.prototype, "currentTypeFilter", 2);
xa([
  F()
], _n.prototype, "showNotificationList", 2);
_n = xa([
  U("wy-notification-button"),
  St()
], _n);
var uJ = Object.defineProperty, pJ = Object.getOwnPropertyDescriptor, L1 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? pJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && uJ(t, e, s), s;
}, "__decorateClass$f"), Xx, My;
let s1 = (Xx = (My = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.show = !1, this.viewportRef = wt();
  }
  /**
   * Close the popover layer.
   */
  close() {
    this.show = !1;
    try {
      this.viewportRef.value?.hidePopover();
    } catch {
    }
  }
  /**
   * Handler when popover is toggled.
   * @internal
   */
  handleClose(t) {
    if (t.type === "toggle" && t.newState === "closed" || t.type === "click") {
      this.show = !1;
      const e = new CustomEvent("hide");
      this.dispatchEvent(e);
    }
  }
  render() {
    return v`
      <div part="wy-toasts" tabindex="0" ${ot(this.viewportRef)} ?hidden=${!this.show} popover="auto">
        <slot></slot>
      </div>
    `;
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("show"))
      try {
        this.show ? this.viewportRef.value?.showPopover() : this.viewportRef.value?.hidePopover();
      } catch {
      }
    t.has("show") && this.show && this.viewportRef.value?.focus();
  }
  firstUpdated(t) {
    this.viewportRef.value?.addEventListener(this.viewportRef.value.popover ? "toggle" : "click", (e) => {
      this.handleClose(e);
    }), this.show && this.viewportRef.value?.showPopover();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
  }
}, c(My, "Zo"), My), d(Xx, "WyToasts"), Xx);
s1.styles = [
  y4,
  ft
];
L1([
  O({ type: Boolean })
], s1.prototype, "show", 2);
s1 = L1([
  U("wy-toasts")
], s1);
var Nx, Ay;
let sr = (Nx = (Ay = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.toastRef = wt(), this.show = !1, this.duration = sr.defaultDuration;
  }
  /**
   * Hide the toast.
   */
  hide() {
    this.show = !1;
  }
  /**
   * Hide and close the toast.
   * 
   * @param silent - Indicates that the toast should close silently.
   * @fires {ClosedEventType} closed - When the toast has been hidden and closed.
   */
  async close(t = !1) {
    this.show = !1, await new Promise((i) => requestAnimationFrame(i)), this.toastRef.value && await rO(this.toastRef.value, !1);
    const e = new CustomEvent("closed", { detail: { silent: t } });
    this.dispatchEvent(e);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("show") && (this.timeout && (window.clearTimeout(this.timeout), this.timeout = void 0), this.show && this.duration > 0 && this.duration < 1 / 0 && (this.timeout = window.setTimeout(() => this.close(!0), this.duration)));
  }
  render() {
    return v`
      <div
        ${ot(this.toastRef)}
        part="wy-toast wy-fade ${this.show ? "wy-show" : ""}"
        @hide=${(t) => {
      t.stopPropagation(), this.hide();
    }}
        @close=${() => this.close()}
        @keyup=${C0}
      >
        <slot></slot>
      </div>
    `;
  }
  firstUpdated() {
    requestAnimationFrame(() => {
      this.show = !0;
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.timeout && (window.clearTimeout(this.timeout), this.timeout = void 0);
  }
}, c(Ay, "Yo"), Ay), d(Nx, "WyToast"), Nx);
sr.styles = [
  y4,
  ft
];
sr.defaultDuration = 5e3;
L1([
  F()
], sr.prototype, "show", 2);
L1([
  O({ type: Number })
], sr.prototype, "duration", 2);
sr = L1([
  U("wy-toast")
], sr);
var fJ = Object.defineProperty, yJ = Object.getOwnPropertyDescriptor, DV = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$3"), Dm = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? yJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && fJ(t, e, s), s;
}, "__decorateClass$e"), qV = /* @__PURE__ */ d((n, t, e) => t.has(n) || DV("Cannot " + e), "__accessCheck$3"), _9 = /* @__PURE__ */ d((n, t, e) => (qV(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$3"), mJ = /* @__PURE__ */ d((n, t, e) => t.has(n) ? DV("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$3"), z9 = /* @__PURE__ */ d((n, t, e, i) => (qV(n, t, "write to private field"), t.set(n, e), e), "__privateSet$3"), Jc, jx, Ry;
let fs = (jx = (Ry = class extends Mm {
  constructor() {
    super(...arguments), this.theme = new wn(this, fs.styles), this.typeFilter = qt.All, this.appearance = "internal", this.requestUserPermission = !1, this.duration = sr.defaultDuration, this._notifications = [], this._nativeNotifications = [], this.handleEvent = async (t) => {
      if (this.typeFilter === qt.All || this.typeFilter === t.notification.type)
        if (t.action === "notification_deleted")
          this.removeNotification(t.notification.id), this.closeNativeNotification(t.notification.id);
        else {
          const { title: e, detail: i } = V4(t.notification), s = {
            ...t.notification,
            title: e,
            detail: i,
            lang: this.weavy?.locale
          }, r = new CustomEvent("wy-notification", {
            bubbles: !0,
            composed: !0,
            cancelable: !0,
            detail: s
          });
          (!this.requestUserPermission && this.appearance !== "native" || await this.hasUserPermission()) && this.dispatchEvent(r) && (t.action === "notification_created" && t.notification.is_unread ? await this.addOrUpdateNotification(t.notification) : await this.updateNotification(t.notification), await this.addOrUpdateNativeNotification(s));
        }
    }, mJ(this, Jc);
  }
  /** @internal */
  async addOrUpdateNotification(t) {
    if (!this.requestUserPermission || await this.hasUserPermission()) {
      const e = [...this._notifications], i = e.findIndex((s) => s.id === t.id);
      i !== -1 ? (e.splice(i, 1, t), this._notifications = e) : (e.push(t), this._notifications = e);
    }
  }
  /** @internal */
  async updateNotification(t) {
    if (!this.requestUserPermission || await this.hasUserPermission()) {
      const e = [...this._notifications], i = e.findIndex((s) => s.id === t.id);
      i !== -1 && (e.splice(i, 1, t), this._notifications = e);
    }
  }
  /** @internal */
  removeNotification(t) {
    const e = [...this._notifications], i = e.findIndex((s) => s.id === t);
    i !== -1 && (e.splice(i, 1), this._notifications = e);
  }
  /** @internal */
  async addOrUpdateNativeNotification(t) {
    if (this.appearance === "native" && await this.hasUserPermission()) {
      const e = this.removeNativeNotification(t.id), i = t.actor, s = new Notification(t.title, {
        tag: `wy-${t.id}`,
        lang: t.lang,
        body: t.detail,
        icon: i.avatar_url,
        // @ts-expect-error Property `renotify` not available in ts types yet
        renotify: e && t.is_unread
      });
      s.onclick = async () => {
        await this.markAsRead(t.id, !0), await W4(this, this.weavy, t);
      }, s.onclose = () => {
        this.removeNativeNotification(t.id);
      }, this._nativeNotifications = [...this._nativeNotifications, s];
    }
  }
  /** @internal */
  removeNativeNotification(t) {
    const e = [...this._nativeNotifications], i = e.findIndex(
      (s) => s.tag === `wy-${t}`
    );
    return i ? (e.splice(i, 1), this._nativeNotifications = e, !0) : !1;
  }
  /** @internal */
  closeNativeNotification(t) {
    const e = this._nativeNotifications.findIndex(
      (i) => i.tag === `wy-${t}`
    );
    return e ? (this._nativeNotifications[e].close(), !0) : !1;
  }
  /** Checks if the user has granted permission for desktop notifications. A request will be made if permission has not yet been granted. */
  async hasUserPermission() {
    if (!("Notification" in window))
      console.error("This browser does not support desktop notifications");
    else if (!window.isSecureContext)
      console.error(
        `Desktop notifications can only be used in secure contexts. 
        See https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts`
      );
    else {
      if (Notification.permission === "granted")
        return !0;
      if (Notification.permission !== "denied")
        return await Notification.requestPermission() === "granted";
    }
    return !1;
  }
  /** Clears queued internal toast notifications. */
  clearNotifications() {
    this._notifications = [];
  }
  /**
   * Marks a notification as read or unread.
   * @param notificationId - The ID of the notification to mark.
   * @param [markAsRead=true] - Whether to mark the notification as read (true) or unread (false).
   */
  async markAsRead(t, e = !0) {
    await this.markNotificationMutation?.mutate({ notificationId: t, markAsRead: e });
  }
  async willUpdate(t) {
    var e;
    await super.willUpdate(t), t.has("weavy") && this.weavy && (this.markNotificationMutation = r4(this.weavy), (e = _9(this, Jc)) == null || e.call(this), this.weavy.subscribe(null, "notification_created", this.handleEvent), this.weavy.subscribe(null, "notification_updated", this.handleEvent), z9(this, Jc, () => {
      this.weavy?.unsubscribe(null, "notification_created", this.handleEvent), this.weavy?.unsubscribe(null, "notification_updated", this.handleEvent), z9(this, Jc, void 0);
    })), (t.has("requestUserPermission") && this.requestUserPermission || t.has("appearance") && this.appearance === "native") && this.hasUserPermission();
  }
  render() {
    return v`
      ${this.user && this.appearance === "internal" ? v`
            <wy-toasts ?show=${!!this._notifications.length} @hide=${() => this.clearNotifications()}>
              ${Mi(
      this._notifications,
      (t) => t.id,
      (t) => v`
                    <wy-toast
                      duration=${this.duration}
                      @closed=${(e) => {
        e.detail.silent || this.markAsRead(t.id, !0), this.removeNotification(t.id);
      }}
                    >
                      <wy-notification-list-item standalone .notification=${t}></wy-notification-list-item>
                    </wy-toast>
                  `
    )}
            </wy-toasts>
          ` : C}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = _9(this, Jc)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Ry, "Xo"), Ry), d(jx, "WyNotificationToasts"), jx);
Jc = /* @__PURE__ */ new WeakMap();
fs.styles = [Te, ft, bi];
Dm([
  O()
], fs.prototype, "typeFilter", 2);
Dm([
  O()
], fs.prototype, "appearance", 2);
Dm([
  O({ type: Boolean })
], fs.prototype, "requestUserPermission", 2);
Dm([
  O({ type: Number })
], fs.prototype, "duration", 2);
Dm([
  F()
], fs.prototype, "_notifications", 2);
fs = Dm([
  U("wy-notification-toasts"),
  St()
], fs);
const Eet = new Map(
  Object.entries({
    [Sn.ChatRoom]: gt.ChatRoom,
    [Sn.PrivateChat]: gt.PrivateChat,
    [gt.ChatRoom]: Sn.ChatRoom,
    [gt.PrivateChat]: Sn.PrivateChat
  })
);
new Map(
  Object.entries({
    [Sn.AgentChat]: gt.AgentChat,
    [gt.AgentChat]: Sn.AgentChat
  })
);
const bm = {
  // All available features as enabled/disabled by default
  [z.Attachments]: !0,
  [z.CloudFiles]: !0,
  [z.ContextData]: !0,
  [z.Embeds]: !0,
  [z.GoogleMeet]: !0,
  [z.Meetings]: !0,
  [z.Mentions]: !0,
  [z.MicrosoftTeams]: !0,
  [z.Polls]: !0,
  [z.Previews]: !0,
  [z.Reactions]: !0,
  [z.Receipts]: !0,
  [z.Typing]: !0,
  [z.ZoomMeetings]: !0
}, K4 = {
  // All available features as enabled/disabled by default
  [z.Attachments]: !0,
  [z.ContextData]: !0,
  [z.Embeds]: !0,
  [z.Previews]: !0,
  [z.Reactions]: !1,
  [z.Receipts]: !0,
  [z.Typing]: !0
}, J4 = et`[part~=wy-messenger-layout]{display:flex;flex:1;align-items:stretch;position:relative;container-type:inline-size;align-self:stretch;min-height:0;min-width:0;box-sizing:border-box}[part~=wy-messenger-overlay-container]{--wy-padding-outer: var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));--wy-component-offset-top: calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem))))))}[part~=wy-messenger-conversation-list]{flex:0 1 100%;min-width:0;max-width:none;display:flex;flex-direction:column;padding:var(--wy-padding-outer, var(--wy-padding, 0));gap:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-messenger-conversation]{display:flex;flex-direction:column;overflow-anchor:none;height:100%;width:100%;flex:0 1 100%;box-sizing:border-box;padding:var(--wy-padding-outer, var(--wy-padding, 0));--wy-component-offset-top: var(--wy-titlebar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding-sm, calc(.25 * var(--wy-size, 1rem)))))}[part~=wy-close-conversation]{display:contents}@container (inline-size < 768px){[part~=wy-messenger-conversation-list]:not([data-conversation-id=\"\"]){display:none}[part~=wy-messenger-conversation][data-conversation-id=\"\"]{display:none}}@container (inline-size >= 768px){[part~=wy-messenger-conversation-list]{flex:0 1 50%;max-width:calc(24*var(--wy-size, 1rem));padding-right:var(--wy-padding-outer, calc(.5 * var(--wy-size, 1rem)));border-right:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-messenger-conversation]{min-width:max(50%,calc(16 * var(--wy-size, 1rem)));padding-left:var(--wy-padding-outer, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-close-conversation]{display:none}}`;
var gJ = Object.defineProperty, wJ = Object.getOwnPropertyDescriptor, t3 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? wJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && gJ(t, e, s), s;
}, "__decorateClass$d"), Bx, Ey;
let $m = (Bx = (Ey = class extends zi {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.uploadBlobMutation = new An(this), this.fileInputRef = wt(), this.openFileInput = () => {
      this.fileInputRef.value?.click();
    };
  }
  /**
   * Uploads the first selected file and resets the input.
   *
   * @internal
   */
  async handleBlobChange(t, e) {
    if (t && this.weavy) {
      const i = { file: t[0] };
      await this.uploadBlobMutation.trackMutation(QL(this.weavy));
      const s = await this.uploadBlobMutation.mutate(i);
      e && (e.value = "");
      const r = new CustomEvent("blob-uploaded", { detail: { blob: s } });
      this.dispatchEvent(r);
    }
  }
  render() {
    return v`
      <div part="wy-upload">
        <slot
          part="wy-upload-placeholder"
          name="placeholder"
          @click=${this.openFileInput}
          @keydown=${Le}
          @keyup=${di}
        ></slot>
        <input
          accept=${Ot(this.accept)}
          type="file"
          ${ot(this.fileInputRef)}
          @click=${(t) => t.stopPropagation()}
          @change=${(t) => this.handleBlobChange(t.target.files, t.target)}
          hidden
        />
        <slot part="wy-upload-action" name="action">
          ${this.label ? v`<wy-button part="wy-upload-button" @click=${this.openFileInput}>${this.label}</wy-button>` : C}
        </slot>
      </div>
    `;
  }
}, c(Ey, "Jo"), Ey), d(Bx, "WyUpload"), Bx);
$m.styles = [
  et`
      :host {
        display: contents;
      }

      [part~="wy-upload"] {
        text-align: center;
      }

      [part~="wy-upload-placeholder"] {
        cursor: pointer;
      }
    `
];
t3([
  O({ attribute: !1 })
], $m.prototype, "label", 2);
t3([
  O({ attribute: !1 })
], $m.prototype, "accept", 2);
$m = t3([
  U("wy-upload")
], $m);
var vJ = Object.defineProperty, OJ = Object.getOwnPropertyDescriptor, j0 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? OJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && vJ(t, e, s), s;
}, "__decorateClass$c"), Ux, _y;
let kl = (Ux = (_y = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.inputRef = wt(), this.compact = !1, this.query = "", this.throttledSearch = $S(
      () => {
        this.query = this.inputRef.value?.value || "";
      },
      250,
      { leading: !1, trailing: !0 }
    );
  }
  /**
   * Put focus on the input field.
   */
  focusInput() {
    this.inputRef.value?.focus();
  }
  /**
   * Clear the input field.
   */
  clear() {
    this.query = "";
  }
  willUpdate(t) {
    if (t.has("query")) {
      const e = new CustomEvent("search", {
        bubbles: !0,
        composed: !1,
        detail: { query: this.query }
      });
      this.dispatchEvent(e);
    }
  }
  render() {
    const t = {
      "wy-input": !0,
      "wy-input-group-input": !0,
      "wy-input-filled": !0,
      "wy-input-group-input-with-overlay": this.compact
    }, e = {
      "wy-input-group-button-icon": !0,
      "wy-input-group-button-icon-overlay": this.compact
    };
    return v`
      <div part="wy-input-group">
        <input
          part=${ut(t)}
          name="text"
          .value=${this.query || ""}
          ${ot(this.inputRef)}
          @input=${() => this.throttledSearch()}
          @keydown=${XI}
          @keyup=${Ys}
          placeholder=${this.placeholder || P("Search...")}
          size="4"
        />
        <wy-button type="reset" @click=${() => this.clear()} kind="icon" part=${ut(e)}>
          <wy-icon name="close-circle"></wy-icon>
        </wy-button>
        <wy-button kind="icon" part=${ut(e)}>
          <wy-icon name="magnify"></wy-icon>
        </wy-button>
      </div>
    `;
  }
}, c(_y, "tc"), _y), d(Ux, "WySearch"), Ux);
kl.styles = [$a, ft];
j0([
  O()
], kl.prototype, "placeholder", 2);
j0([
  O({ type: Boolean })
], kl.prototype, "compact", 2);
j0([
  F()
], kl.prototype, "query", 2);
kl = j0([
  U("wy-search"),
  St()
], kl);
var bJ = Object.defineProperty, $J = Object.getOwnPropertyDescriptor, ka = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? $J(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && bJ(t, e, s), s;
}, "__decorateClass$b"), Hx, zy;
let zn = (Hx = (zy = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.agentFilter = void 0, this.selected = [], this.select = [], this.text = "", this.peopleQuery = new Rl(this), this.searchRef = wt(), this.infiniteScroll = new El(this), this.pagerRef = wt();
  }
  /**
   * Emits the selected members via the `submit` event.
   *
   * @internal
   * @returns {boolean} `true` if the event was not canceled.
   */
  dispatchSubmit() {
    this.selected = [...this.selected, ...this.select];
    const t = new CustomEvent("submit", {
      detail: { members: this.selected }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Checks whether a member is currently selected.
   *
   * @internal
   */
  isChecked(t) {
    return this.select.find((e) => e.id === t) != null;
  }
  /**
   * Toggles selection state for the provided member.
   *
   * @internal
   */
  handleSelected(t, e) {
    e ? this.select = [...this.select, t] : (this.select = this.select.filter((i) => i.id !== t.id), this.selected = this.selected.filter((i) => i.id !== t.id));
  }
  /**
   * Renders the list of currently selected members.
   *
   * @internal
   */
  getSelected() {
    return this.selected.length > 0 ? v`
        ${this.selected.map((t) => v`
            <wy-item
              interactive
              @click=${() => this.handleSelected(t, !1)}
              @keydown=${Le}
              @keyup=${Le}
            >
              <wy-avatar
                slot="image"
                id=${t.id}
                .src=${t.avatar_url}
                .name=${t.name}
                .description=${t.comment}
                .presence=${t.presence}
                .isAgent=${t.is_agent}
                size=${32}
              ></wy-avatar>
              <span slot="title"> ${t.name} </span>
              <wy-button slot="actions" kind="icon" .active=${!1}
                ><wy-icon name="checkbox-marked"></wy-icon
              ></wy-button>
            </wy-item>
          `)}
      ` : C;
  }
  /**
   * Renders search results for the current query and filter.
   *
   * @internal
   */
  getSearchResult() {
    const { data: t, hasNextPage: e, isPending: i } = this.peopleQuery.result ?? { data: [], isPending: !0 }, s = cs(t), r = !!s.length, a = [];
    return i ? a.push(v`<wy-progress-circular indeterminate overlay></wy-progress-circular>`) : r || a.push(v`<div part="wy-pane-group">
        <div part="wy-no-result">
          ${this.text ? P("Your search did not match any people.") : P("No more users found.")}
        </div>
      </div>`), r && a.push(
      v` ${s.filter((o) => this.selected.find((l) => l.id === o.id) === void 0).map((o) => v` <wy-item
              interactive
              @click=${() => this.handleSelected(o, !this.isChecked(o.id))}
              @keydown=${Le}
              @keyup=${Le}
            >
              <wy-avatar
                slot="image"
                id=${o.id}
                .src=${o.avatar_url}
                .name=${o.name}
                .description=${o.comment}
                .presence=${o.presence}
                .isAgent=${o.is_agent}
                size=${32}
              ></wy-avatar>
              <span slot="title"> ${o.name} </span>
              <wy-button slot="actions" kind="icon" .active=${!1}
                ><wy-icon name="${this.isChecked(o.id) ? "checkbox-marked" : "checkbox-blank"}"></wy-icon
              ></wy-button>
            </wy-item>`) ?? C}`
    ), e && a.push(v`<div ${ot(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>`), a;
  }
  render() {
    return v`<div part="wy-pane wy-scroll-y wy-scroll-y-always">
      <div part="wy-pane-body">
        <div part="wy-pane-group wy-pane-group-fixed-size">
          <wy-search ${ot(this.searchRef)} @search=${(t) => this.text = t.detail.query}></wy-search>
        </div>
        <div>
          <wy-buttons tabs>
            <wy-button
              ?active=${this.agentFilter === void 0}
              @click=${() => this.agentFilter = void 0}
              kind="tab"
              small
              >${P("All")}</wy-button
            >
            <wy-button ?active=${this.agentFilter === !1} @click=${() => this.agentFilter = !1} kind="tab" small
              >${P("People")}</wy-button
            >
            <wy-button ?active=${this.agentFilter === !0} @click=${() => this.agentFilter = !0} kind="tab" small
              >${P("Agents")}</wy-button
            >
          </wy-buttons>
        </div>
        <div part="wy-pane-body"> ${this.getSelected()} ${this.getSearchResult()} </div>
      </div>
      <div part="wy-footerbar wy-footerbar-sticky">
        <div part="wy-pane-group">
          <wy-buttons reverse>
            <wy-button
              color="primary"
              @click=${() => this.dispatchSubmit()}
              ?disabled=${this.selected.length === 0 && this.select.length === 0 ? !0 : void 0}
              >${this.buttonTitle ?? P("Create")}</wy-button
            >
          </wy-buttons>
        </div>
      </div>
    </div>`;
  }
  async willUpdate(t) {
    super.willUpdate(t), t.has("weavy") && this.weavy && await this.peopleQuery.trackInfiniteQuery(
      qI(
        this.weavy,
        () => this.text,
        this.appId,
        () => this.agentFilter
      )
    );
  }
  async updated(t) {
    this.infiniteScroll.observe(this.peopleQuery.result, this.pagerRef.value), (t.has("text") || t.has("agentFilter")) && (this.select.length > 0 && (this.selected = [...this.selected, ...this.select], this.select = []), await this.peopleQuery.result?.refetch?.(), this.searchRef.value?.focusInput());
  }
}, c(zy, "ec"), zy), d(Hx, "WyUsersSearch"), Hx);
zn.styles = [Vl, jI, $a, va, ft, Il];
ka([
  Ve({ context: Me, subscribe: !0 }),
  F()
], zn.prototype, "weavy", 2);
ka([
  O({ attribute: !1 })
], zn.prototype, "appId", 2);
ka([
  O({ attribute: !1 })
], zn.prototype, "buttonTitle", 2);
ka([
  F()
], zn.prototype, "agentFilter", 2);
ka([
  F()
], zn.prototype, "selected", 2);
ka([
  F()
], zn.prototype, "select", 2);
ka([
  F()
], zn.prototype, "text", 2);
zn = ka([
  U("wy-users-search"),
  St()
], zn);
var xJ = Object.defineProperty, kJ = Object.getOwnPropertyDescriptor, ZV = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$2"), Nl = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? kJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && xJ(t, e, s), s;
}, "__decorateClass$a"), FV = /* @__PURE__ */ d((n, t, e) => t.has(n) || ZV("Cannot " + e), "__accessCheck$2"), L9 = /* @__PURE__ */ d((n, t, e) => (FV(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$2"), SJ = /* @__PURE__ */ d((n, t, e) => t.has(n) ? ZV("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$2"), I9 = /* @__PURE__ */ d((n, t, e, i) => (FV(n, t, "write to private field"), t.set(n, e), e), "__privateSet$2"), th, Yx, Ly;
let ys = (Yx = (Ly = class extends zi {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.showDetails = !1, this.showAddMembers = !1, this.conversationTitle = "", this.conversationTitleInput = "", this.membersQuery = new gn(this), this.handleRealtimeAppUpdated = (t) => {
      !this.conversationId || t.app.id !== this.conversationId || (this.conversationTitle = this.conversationTitleInput = t.app.name);
    }, this.handlePresenceChange = (t) => {
      if (!this.weavy)
        return;
      Array.isArray(t) || (t = [parseInt(t)]);
      const e = /* @__PURE__ */ d((i = []) => (i.forEach((s) => {
        s.presence = t.indexOf(s.id) != -1 ? "active" : "away";
      }), i), "updateMembersInApps");
      this.weavy.queryClient.setQueryData(["apps", this.conversationId], (i) => (i.members.data = e(i.members.data), i)), this.weavy.queryClient.setQueryData(["members", this.conversationId], (i) => e(i));
    }, SJ(this, th);
  }
  /** Checks whether the current or provided conversation is an agent chat. */
  isAgentChat(t) {
    return (t ?? this.conversation)?.type === gt.AgentChat;
  }
  /** Checks whether the current or provided conversation is a chat room. */
  isChatRoom(t) {
    return (t ?? this.conversation)?.type === gt.ChatRoom;
  }
  /** Checks whether the current or provided conversation is a private chat. */
  isPrivateChat(t) {
    return (t ?? this.conversation)?.type === gt.PrivateChat;
  }
  /**
   * Adds a list of members to the conversation.
   *
   * @internal
   */
  async addMembers(t) {
    this.showAddMembers = !1, this.showDetails = !0, !(!this.weavy || !this.conversationId) && (await this.addMembersMutation?.mutate({ appId: this.conversationId, members: t.map((e) => e.id) }), await this.membersQuery.result.refetch(), await this.weavy.queryClient.invalidateQueries({ queryKey: ["apps"] }));
  }
  /**
   * Handles saving the conversation name from the conversation name input.
   *
   * @internal
   */
  async handleSaveConversationName() {
    if (!this.weavy || !this.conversationId)
      return;
    const t = this.conversationTitleInput.trim() === "" ? null : this.conversationTitleInput.trim();
    await this.updateConversationMutation?.mutate({ appId: this.conversationId, name: t });
  }
  /**
   * Updates the avatar with an uploaded blob picture.
   *
   * @internal
   */
  async handleAvatarUploaded(t) {
    !this.weavy || !this.conversationId || await this.updateConversationMutation?.mutate({
      appId: this.conversationId,
      blobId: t.id,
      thumbnailUrl: t.thumbnail_url
    });
  }
  /**
   * Clears the set avatar for the conversation.
   *
   * @internal
   */
  async clearAvatar() {
    !this.weavy || !this.conversationId || await this.updateConversationMutation?.mutate({ appId: this.conversationId, blobId: null, thumbnailUrl: null });
  }
  /**
   * Updates the access for a member in the conversation.
   *
   * @internal
   */
  async updateMember(t, e) {
    !this.weavy || !this.conversationId || (await this.updateMemberMutation?.mutate({
      appId: this.conversationId,
      userId: t,
      access: e
    }), await this.membersQuery.result.refetch());
  }
  /**
   * Removes the current or provided member from the conversation.
   *
   * If no memberId is provided, the current user leaves the conversation and the component state is cleared.
   *
   * @internal
   */
  async leaveConversation(t) {
    !this.weavy || !this.conversationId || !this.user || (t && await this.leaveConversationMutation?.mutate({
      appId: this.conversationId,
      members: [t]
    }), !t || t === this.user.id ? (this.showDetails = !1, this.conversation = void 0, this.conversationId = void 0, this.dispatchAction(hi.Select, null)) : await this.membersQuery.result.refetch(), await this.weavy.queryClient.invalidateQueries({ queryKey: ["apps"] }));
  }
  /**
   * Triggers `wy-action` event.
   *
   * @param action - The performed action.
   * @param conversation - The conversation to select or `null` to clear.
   * @returns Whether the event was successful.
   *
   * @internal
   */
  dispatchAction(t, e) {
    this.conversationId = e?.id;
    const i = new CustomEvent("wy-action", { detail: { action: t, app: e }, bubbles: !0, composed: !0 });
    return this.dispatchEvent(i);
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("weavy") && this.weavy && (this.leaveConversationMutation = h4(this.weavy), this.addMembersMutation = VI(this.weavy), this.updateConversationMutation = d4(this.weavy), this.updateMemberMutation = WI(this.weavy)), t.has("conversationId") && (this.showDetails = !1), (t.has("weavy") || t.has("conversationId")) && this.weavy)
      if ((e = L9(this, th)) == null || e.call(this), this.conversationId) {
        await this.membersQuery.trackQuery(
          p4(this.weavy, this.conversationId, {
            initialData: /* @__PURE__ */ d(() => {
              if (this.conversationId)
                return this.weavy?.queryClient.getQueryData(["apps", this.conversationId])?.members;
            }, "initialData")
          })
        );
        const i = `a${this.conversationId}`;
        this.weavy.subscribe(i, "app_updated", this.handleRealtimeAppUpdated), this.weavy.subscribe(null, "online", this.handlePresenceChange), I9(this, th, () => {
          this.weavy?.unsubscribe(i, "app_updated", this.handleRealtimeAppUpdated), this.weavy?.unsubscribe(null, "online", this.handlePresenceChange), I9(this, th, void 0);
        });
      } else
        this.membersQuery.untrackQuery();
    t.has("conversation") && this.conversation && (this.conversationTitleInput = this.conversationTitle = this.conversation.name);
  }
  render() {
    const { data: t } = this.membersQuery.result ?? {}, e = (t?.data || []).filter((s) => s.access === kr.Admin).length, i = this.user && this.isPrivateChat() ? (this.conversation?.members?.data || []).filter((s) => s.id !== this.user?.id)?.[0] ?? this.user : null;
    return this.conversationId ? v`
          <wy-titlebar outer header floating part="wy-conversation-titlebar">
            <slot slot="icon" name="icon"><span></span></slot>
            ${this.conversation && this.user ? v`
                  ${this.conversation.type === gt.PrivateChat ? v`<wy-presence
                        slot="title-section"
                        placement="text"
                        .status=${i?.presence}
                        id=${Ot(i?.id)}
                      ></wy-presence>` : C}
                  <wy-titlebar-text slot="title-section">${this.conversationTitle}</wy-titlebar-text>
                ` : C}
            ${this.isChatRoom() ? v`<wy-button
                  slot="actions"
                  kind="icon"
                  @click=${() => this.showDetails = !0}
                  title="${P("Details")}"
                >
                  <wy-icon name="information"></wy-icon>
                </wy-button>` : C}
          </wy-titlebar>

          <!-- details modal -->
          ${this.weavy ? v`
                <wy-overlay
                  part="wy-conversation-details"
                  .show=${this.showDetails}
                  @close=${() => {
      this.showDetails = !1;
    }}
                >
                  <wy-titlebar header slot="header">
                    <wy-button
                      slot="icon"
                      kind="icon"
                      @click=${() => {
      this.showDetails = !1;
    }}
                    >
                      <wy-icon name="close"></wy-icon>
                    </wy-button>
                    <span slot="title">${this.conversationTitle}</span>
                  </wy-titlebar>
                  <div part="wy-scroll-y">
                    ${this.showDetails && this.conversation && this.user ? v`
                          <wy-avatar-header>
                            ${this.isChatRoom() ? v`
                                  <wy-upload
                                    @blob-uploaded=${(s) => this.handleAvatarUploaded(s.detail.blob)}
                                    .accept=${"image/*"}
                                    .label=${P("Select picture")}
                                  >
                                    <div slot="placeholder">
                                      ${this.conversation.avatar_url ? v`<wy-avatar .size=${96} src=${this.conversation.avatar_url}></wy-avatar>` : v`<wy-avatar-group
                                            .members=${t?.data}
                                            title=${this.conversation.name}
                                            .size=${96}
                                          ></wy-avatar-group>`}
                                    </div>
                                    ${this.conversation.avatar_url ? v`<div slot="action"
                                          ><wy-button @click=${() => this.clearAvatar()}
                                            >${P("Remove picture")}</wy-button
                                          ></div
                                        >` : C}
                                  </wy-upload>
                                ` : v`
                                  <wy-avatar
                                    src=${Ot(i?.avatar_url)}
                                    name=${Ot(i?.name)}
                                    presence=${i?.presence || "away"}
                                    ?isAgent=${i?.is_agent}
                                    id=${Ot(i?.id)}
                                    size=${96}
                                  ></wy-avatar>
                                `}
                          </wy-avatar-header>
                          ${this.isChatRoom() ? v`
                                <div part="wy-pane-group">
                                  <label part="wy-label" for="roomName">${P("Room name")}</label>

                                  <input
                                    id="roomName"
                                    part="wy-input"
                                    .value=${this.conversationTitleInput}
                                    @input=${(s) => {
      this.conversationTitleInput = s.target.value;
    }}
                                    @keyup=${FI}
                                    @blur=${() => this.handleSaveConversationName()}
                                  />

                                  <div part="wy-description">
                                    ${P("Changing the name of a group chat changes it for everyone.")}
                                  </div>
                                  <br />
                                  <label part="wy-label">${P("Members")}</label>
                                  ${t ? v`
                                        <wy-item-list>
                                          ${t.data?.map(
      (s) => v`
                                              <wy-item>
                                                <wy-avatar
                                                  slot="image"
                                                  .src=${s.avatar_url}
                                                  .name=${s.name}
                                                  .description=${s.comment}
                                                  .isAgent=${s.is_agent}
                                                  size=${32}
                                                ></wy-avatar>
                                                <span slot="title">
                                                  ${s.name}
                                                  ${s.access === kr.Admin ? v` <wy-icon
                                                        size="20"
                                                        inline
                                                        name="shield-star"
                                                        title=${P("Admin")}
                                                      ></wy-icon>` : C}
                                                </span>
                                                ${this.user && this.user.id === s.id && !lm(rl.Admin, this.conversation?.permissions) ? v` <wy-button
                                                      slot="actions"
                                                      @click=${() => this.leaveConversation(s.id)}
                                                      title=${P("Leave conversation")}
                                                      kind="icon"
                                                    >
                                                      <wy-icon name="close"></wy-icon>
                                                    </wy-button>` : lm(rl.Admin, this.conversation?.permissions) ? v`<wy-dropdown slot="actions">
                                                      <wy-dropdown-item
                                                        @click=${() => this.leaveConversation(s.id)}
                                                      >
                                                        <wy-icon name="account-minus"></wy-icon>
                                                        ${this.user && this.user.id === s.id ? P("Leave conversation") : P("Remove member")}
                                                      </wy-dropdown-item>
                                                      ${e > 1 && s.access === kr.Admin ? v`<wy-dropdown-item
                                                            @click=${() => this.updateMember(s.id, kr.Write)}
                                                          >
                                                            <wy-icon name="shield-star-outline"></wy-icon>
                                                            ${P("Remove as admin")}
                                                          </wy-dropdown-item>` : s.access !== kr.Admin ? v`<wy-dropdown-item
                                                            @click=${() => this.updateMember(s.id, kr.Admin)}
                                                          >
                                                            <wy-icon name="shield-star"></wy-icon>
                                                            ${P("Make admin")}
                                                          </wy-dropdown-item>` : C}
                                                    </wy-dropdown>` : C}
                                              </wy-item>
                                            `
    ) ?? C}
                                        </wy-item-list>
                                      ` : C}
                                  <div>
                                    <wy-button
                                      part="wy-conversation-details-add-members-button"
                                      kind="filled"
                                      color="primary"
                                      @click=${() => {
      this.showDetails = !1, this.showAddMembers = !0;
    }}
                                      title=${P("Add members")}
                                    >
                                      ${P("Add members")}
                                    </wy-button>
                                  </div>
                                </div>
                              ` : C}
                        ` : C}
                  </div>
                </wy-overlay>
              ` : C}

          <!-- add members modal -->
          ${this.weavy ? v`
                <wy-overlay
                  part="wy-conversation-add-members"
                  .show=${this.showAddMembers}
                  @close=${() => {
      this.showAddMembers = !1;
    }}
                >
                  <wy-titlebar header>
                    <wy-button
                      slot="icon"
                      kind="icon"
                      @click=${() => {
      this.showAddMembers = !1;
    }}
                    >
                      <wy-icon name="close"></wy-icon>
                    </wy-button>
                    <span slot="title">${P("Add members")}</span>
                  </wy-titlebar>
                  ${this.showAddMembers ? v`
                        <wy-users-search
                          .buttonTitle=${P("Add members")}
                          .appId=${this.conversationId}
                          @submit=${(s) => this.addMembers(s.detail.members)}
                        ></wy-users-search>
                      ` : C}
                </wy-overlay>
              ` : C}
        ` : C;
  }
  disconnectedCallback() {
    var t;
    (t = L9(this, th)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Ly, "ic"), Ly), d(Yx, "WyConversationHeader"), Yx);
th = /* @__PURE__ */ new WeakMap();
ys.styles = [$a, Il, Vl, ft];
Nl([
  O({ attribute: !1 })
], ys.prototype, "conversationId", 2);
Nl([
  O({ attribute: !1 })
], ys.prototype, "conversation", 2);
Nl([
  F()
], ys.prototype, "showDetails", 2);
Nl([
  F()
], ys.prototype, "showAddMembers", 2);
Nl([
  F()
], ys.prototype, "conversationTitle", 2);
Nl([
  F()
], ys.prototype, "conversationTitleInput", 2);
ys = Nl([
  U("wy-conversation-header"),
  St()
], ys);
var CJ = Object.defineProperty, PJ = Object.getOwnPropertyDescriptor, qm = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? PJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && CJ(t, e, s), s;
}, "__decorateClass$9"), Gx, Iy;
let ms = (Gx = (Iy = class extends Ae {
  constructor() {
    super(...arguments), this.componentFeatures = new ni(bm), this.theme = new wn(this, ms.styles), this.unreadConversationsController = new $0(this), this.createConversationController = new b0(this), this.componentTypes = [gt.ChatRoom, gt.PrivateChat], this.conversationId = null, this.conversationQuery = new gn(this), this.persistState = new g1(this), this.conversationListRef = wt(), this.conversationNewRef = wt();
  }
  set agent(t) {
    super.agent = t, this._agentUid ? (this.componentTypes = [gt.AgentChat], this.componentFeatures = new ni(
      K4,
      this.componentFeatures.allowedFeatures()
    )) : (this.componentTypes = [gt.ChatRoom, gt.PrivateChat], this.componentFeatures = new ni(
      bm,
      this.componentFeatures.allowedFeatures()
    )), this.conversationId = null;
  }
  get agent() {
    return super.agent;
  }
  /** Current unread conversation count. */
  get unread() {
    return this.unreadConversationsController.unread;
  }
  /**
   * Creates a new conversation.
   *
   * When in agent mode, a conversation is created instantly.
   *
   * @param members - Optional array of member ids or member uids.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select member dialog to let the user select members for creating a conversation.
   *
   * @returns Promise resolving to any selected member ids or uids.
   */
  async selectMembers() {
    return await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("weavy") || t.has("agent") || t.has("user")) && this.weavy && this.user && this.persistState.observe(
      [{ name: "conversationId", override: !1 }],
      this.agent || "messenger",
      `u${this.user?.id}`,
      (e) => {
        if (e.has("conversationId") && this.conversationId) {
          const i = new CustomEvent("wy-action", {
            detail: {
              action: hi.Select,
              app: { id: this.conversationId }
            },
            bubbles: !0,
            composed: !0
          });
          this.dispatchEvent(i);
        }
      }
    ), t.has("link") && this.link?.app && (this.conversationId = this.link.app.id), (t.has("conversationId") || t.has("weavy")) && this.weavy && (this.conversationId ? this.conversationQuery.trackQuery(
      u4(this.weavy, this.conversationId, this.componentTypes)
    ) : this.conversationQuery.untrackQuery()), t.has("agent") && (this.createConversationController.agent = this.agent), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversationsController.track(this.componentTypes, this.agent);
  }
  render() {
    const { isPending: t } = this.weavy?.network ?? { isPending: !0 }, { data: e } = this.conversationQuery.result ?? {}, i = this.conversationListRef.value?.conversationsQuery.result.data?.pages[0].count || 0;
    return v`
      <div part="wy-messenger-layout">
        <div
          part="wy-messenger-conversation-list"
          data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
        >
          <wy-container padded outer scrollY>
            <slot name="header"></slot>
            <wy-conversation-list
              ${ot(this.conversationListRef)}
              .conversationTypes=${this.componentTypes}
              .agent=${this.agent}
              conversationId=${Ot(this.conversationId !== null ? this.conversationId : void 0)}
              @wy-action=${(s) => {
      !s.defaultPrevented && s.detail.action === hi.Select && s.detail.app !== void 0 && (this.conversationId = s.detail.app?.id);
    }}
            >
              <wy-conversation-new
                slot="actions"
                .agent=${this.agent}
                @create=${async (s) => {
      const r = await this.createConversationController.create(s.detail.members);
      r && (this.conversationId = r.id);
    }}
                ${ot(this.conversationNewRef)}
              >
                <slot name="conversation-new"></slot>
              </wy-conversation-new>
              <slot name="actions" slot="actions"></slot>
            </wy-conversation-list>
          </wy-container>
        </div>

        <div
          part="wy-messenger-conversation wy-scroll-y"
          data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
        >
          <wy-conversation-header
            .conversationId=${this.conversationId || void 0}
            .conversation=${e}
            @wy-action=${(s) => {
      !s.defaultPrevented && s.detail.action === hi.Select && s.detail.app !== void 0 && (this.conversationId = s.detail.app?.id);
    }}
            ?hidden=${!this.conversationId}
          >
            <span slot="icon" part="wy-close-conversation">
              <wy-button kind="icon" @click=${() => this.conversationId = null}>
                <wy-icon name="back"></wy-icon>
              </wy-button>
              <wy-badge
                reveal
                .count=${this.unreadConversationsController.isUnreadPending ? NaN : this.unreadConversationsController.unread}
              ></wy-badge>
            </span>
          </wy-conversation-header>

          ${this.conversationId ? v`<wy-conversation
                .conversationId=${this.conversationId}
                .conversation=${e}
                .agentInstructions=${this.instructions}
                .placeholder=${this.placeholder ?? (this.agent ? P("Ask anything...") : void 0)}
                .header=${!this.agent}
              ></wy-conversation>` : i ? v`<wy-empty noNetwork>${P("Select a conversation")}</wy-empty>` : C}
        </div>

        <wy-context-data-progress></wy-context-data-progress>
      </div>
    `;
  }
}, c(Iy, "rc"), Iy), d(Gx, "WyMessenger"), Gx);
ms.styles = [Te, Vl, J4, ws, bi];
qm([
  O({ attribute: !1 })
], ms.prototype, "componentTypes", 2);
qm([
  O({ type: String })
], ms.prototype, "agent", 1);
qm([
  O()
], ms.prototype, "instructions", 2);
qm([
  O()
], ms.prototype, "placeholder", 2);
qm([
  O({ type: Number })
], ms.prototype, "conversationId", 2);
ms = qm([
  U("wy-messenger"),
  St()
], ms);
var QJ = Object.defineProperty, TJ = Object.getOwnPropertyDescriptor, Wn = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? TJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && QJ(t, e, s), s;
}, "__decorateClass$8"), Kx, Wy;
let Oi = (Kx = (Wy = class extends Ae {
  constructor() {
    super(...arguments), this.componentFeatures = new ni(bm), this.theme = new wn(this, Oi.styles), this.unreadConversationsController = new $0(this), this.createConversationController = new b0(this), this.overlay = "drawer", this.badge = "compact", this.badgePosition = "top-right", this.componentTypes = [gt.ChatRoom, gt.PrivateChat], this.conversationId = null, this.show = !1, this.maximized = !1, this.conversationQuery = new gn(this), this.persistState = new g1(this), this.conversationListRef = wt(), this.conversationNewRef = wt();
  }
  set agent(t) {
    super.agent = t, this._agentUid ? (this.componentTypes = [gt.AgentChat], this.componentFeatures = new ni(
      K4,
      this.componentFeatures.allowedFeatures()
    )) : (this.componentTypes = [gt.ChatRoom, gt.PrivateChat], this.componentFeatures = new ni(
      bm,
      this.componentFeatures.allowedFeatures()
    )), this.conversationId = null;
  }
  get agent() {
    return super.agent;
  }
  /** Current unread conversation count. */
  get unread() {
    return this.unreadConversationsController.unread;
  }
  /**
   * Creates a new conversation.
   *
   * - When in agent mode, a conversation is created instantly.
   *
   * @param members {(number|string)[] | undefined} - Optional array of member id or member uid.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select member dialog to let the user select members for creating a conversation.
   *
   * @returns Any selected member ids or uids.
   */
  async selectMembers() {
    return await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("weavy") || t.has("agent") || t.has("user")) && this.weavy && this.user && this.persistState.observe(
      [{ name: "conversationId", override: !1 }],
      this.agent || "messenger",
      `u${this.user?.id}`,
      (e) => {
        if (e.has("conversationId") && this.conversationId) {
          const i = new CustomEvent("wy-action", {
            detail: {
              action: hi.Select,
              app: { id: this.conversationId }
            },
            bubbles: !0,
            composed: !0
          });
          this.dispatchEvent(i);
        }
      }
    ), t.has("link") && this.link?.app && (this.conversationId = this.link.app.id), (t.has("conversationId") || t.has("weavy")) && this.weavy && (this.conversationId ? this.conversationQuery.trackQuery(u4(this.weavy, this.conversationId, this.componentTypes)) : this.conversationQuery.untrackQuery()), t.has("agent") && (this.createConversationController.agent = this.agent), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversationsController.track(this.componentTypes, this.agent);
  }
  render() {
    const { isPending: t } = this.weavy?.network ?? { isPending: !0 }, { data: e } = this.conversationQuery.result ?? {}, i = this.conversationListRef.value?.conversationsQuery.result.data?.pages[0].count || 0;
    return v`
      <wy-button kind="icon" ?active=${this.show} @click=${() => this.show = !this.show}>
        <wy-icon name="message-text">
          ${this.user && this.badge !== "none" ? v`
                <wy-badge
                  appearance=${this.badge}
                  position=${this.badgePosition}
                  .count=${this.unreadConversationsController.isUnreadPending ? NaN : this.unreadConversationsController.unread}
                ></wy-badge>
              ` : C}
        </wy-icon>
      </wy-button>

      ${this.overlay !== "none" ? v`<wy-overlay
            type=${this.overlay}
            .show=${this.show}
            .maximized=${this.maximized}
            @close=${() => this.show = !1}
            noHeader
          >
            <div part="wy-messenger-layout wy-messenger-overlay-container">
              <div
                part="wy-messenger-conversation-list wy-scroll-y"
                data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
              >
                <slot name="header">
                  <wy-titlebar floating header outer>
                    <wy-button kind="icon" slot="icon" @click=${() => this.show = !1}
                      ><wy-icon name="close"></wy-icon
                    ></wy-button>
                    <slot name="title" slot="title">${P("Conversations")}</slot>
                    <slot name="actions" slot="actions"></slot>
                    <wy-button kind="icon" slot="actions" @click=${() => this.maximized = !this.maximized}
                      ><wy-icon name=${this.maximized ? "arrow-collapse" : "arrow-expand"}></wy-icon
                    ></wy-button>
                  </wy-titlebar>
                </slot>

                <wy-conversation-list
                  ${ot(this.conversationListRef)}
                  .conversationTypes=${this.componentTypes}
                  .agent=${this.agent}
                  conversationId=${Ot(this.conversationId !== null ? this.conversationId : void 0)}
                  @wy-action=${(s) => {
      !s.defaultPrevented && s.detail.action === hi.Select && s.detail.app !== void 0 && (this.conversationId = s.detail.app?.id);
    }}
                >
                  <wy-conversation-new
                    slot="actions"
                    .agent=${this.agent}
                    @create=${async (s) => {
      const r = await this.createConversationController.create(s.detail.members);
      r && (this.conversationId = r.id);
    }}
                    ${ot(this.conversationNewRef)}
                  >
                    <slot name="conversation-new"></slot>
                  </wy-conversation-new>
                </wy-conversation-list>
              </div>

              <div
                part="wy-messenger-conversation wy-scroll-y"
                data-conversation-id=${this.conversationId !== null && this.conversationId !== void 0 ? this.conversationId : ""}
              >
                <wy-conversation-header
                  .conversationId=${this.conversationId || void 0}
                  .conversation=${e}
                  @wy-action=${(s) => {
      !s.defaultPrevented && s.detail.action === hi.Select && s.detail.app !== void 0 && (this.conversationId = s.detail.app?.id);
    }}
                  ?hidden=${!this.conversationId}
                >
                  <span slot="icon" part="wy-close-conversation">
                    <wy-button kind="icon" @click=${() => this.conversationId = null}>
                      <wy-icon name="back"></wy-icon>
                    </wy-button>
                    <wy-badge
                      reveal
                      .count=${this.unreadConversationsController.isUnreadPending ? NaN : this.unreadConversationsController.unread}
                    ></wy-badge>
                  </span>
                </wy-conversation-header>

                ${this.conversationId ? v`<wy-conversation
                      .conversationId=${this.conversationId}
                      .conversation=${e}
                      .agentInstructions=${this.instructions}
                      .placeholder=${this.placeholder ?? (this.agent ? P("Ask anything...") : void 0)}
                      .header=${!this.agent}
                    ></wy-conversation>` : i ? v`<wy-empty noNetwork>${P("Select a conversation")}</wy-empty>` : C}
              </div>

              <wy-context-data-progress></wy-context-data-progress>
            </div>
          </wy-overlay> ` : C}
    `;
  }
}, c(Wy, "sc"), Wy), d(Kx, "WyMessengerButton"), Kx);
Oi.styles = [Te, Vl, J4, ws, bi];
Wn([
  O({ type: String })
], Oi.prototype, "overlay", 2);
Wn([
  O({ type: String })
], Oi.prototype, "badge", 2);
Wn([
  O({ type: String })
], Oi.prototype, "badgePosition", 2);
Wn([
  O({ attribute: !1 })
], Oi.prototype, "componentTypes", 2);
Wn([
  O({ type: String })
], Oi.prototype, "agent", 1);
Wn([
  O()
], Oi.prototype, "instructions", 2);
Wn([
  O()
], Oi.prototype, "placeholder", 2);
Wn([
  O({ type: Number })
], Oi.prototype, "conversationId", 2);
Wn([
  F()
], Oi.prototype, "show", 2);
Wn([
  F()
], Oi.prototype, "maximized", 2);
Oi = Wn([
  U("wy-messenger-button"),
  St()
], Oi);
var MJ = Object.getOwnPropertyDescriptor, AJ = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? MJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = a(s) || s);
  return s;
}, "__decorateClass$7"), Jx, Vy;
let r1 = (Jx = (Vy = class extends Ae {
  constructor() {
    super(...arguments), this.theme = new wn(this, r1.styles), this.createConversationController = new b0(this), this.conversationNewRef = wt();
  }
  /**
   * Creates a new conversation.
   *
   * When in agent mode, the conversation is created instantly.
   *
   * @param members - Optional array of member ids or member uids.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select-member dialog.
   *
   * @returns Promise resolving to the selected member ids or uids.
   */
  async selectMembers() {
    return await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), t.has("agent") && (this.createConversationController.agent = this.agent);
  }
  render() {
    return v`
      <wy-conversation-new
        .agent=${this.agent}
        @create=${async (t) => {
      await this.createConversationController.create(t.detail.members);
    }}
        ${ot(this.conversationNewRef)}
      ></wy-conversation-new>
    `;
  }
}, c(Vy, "nc"), Vy), d(Jx, "WyMessengerNew"), Jx);
r1.styles = [Te, Vl, J4, ws, bi];
r1 = AJ([
  U("wy-messenger-new")
], r1);
var RJ = Object.defineProperty, EJ = Object.getOwnPropertyDescriptor, I1 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? EJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && RJ(t, e, s), s;
}, "__decorateClass$6"), tk, Dy;
let ma = (tk = (Dy = class extends Ae {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.unreadConversations = new $0(this), this.componentTypes = [gt.ChatRoom, gt.PrivateChat], this.badge = "count", this.badgePosition = "inline";
  }
  set agent(t) {
    super.agent = t, this._agentUid ? this.componentTypes = [gt.AgentChat] : this.componentTypes = [gt.ChatRoom, gt.PrivateChat];
  }
  get agent() {
    return super.agent;
  }
  /**
   * Current unread conversation count.
   */
  get unread() {
    return this.unreadConversations.unread;
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversations.track(this.componentTypes, this.agent);
  }
  render() {
    return this.user && this.badge !== "none" ? v`
          <wy-badge
            appearance=${this.badge}
            position=${this.badgePosition}
            .count=${this.unreadConversations.isUnreadPending ? NaN : this.unreadConversations.unread}
          ></wy-badge>
        ` : C;
  }
}, c(Dy, "ac"), Dy), d(tk, "WyMessengerBadge"), tk);
ma.styles = [VV, Te, bi];
I1([
  O({ attribute: !1 })
], ma.prototype, "componentTypes", 2);
I1([
  O({ type: String })
], ma.prototype, "badge", 2);
I1([
  O({ type: String })
], ma.prototype, "badgePosition", 2);
I1([
  O({ type: String })
], ma.prototype, "agent", 1);
ma = I1([
  U("wy-messenger-badge")
], ma);
const XV = et`[part~=wy-conversations]{position:relative;display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-conversation-list]{display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}`;
var _J = Object.defineProperty, zJ = Object.getOwnPropertyDescriptor, B0 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? zJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && _J(t, e, s), s;
}, "__decorateClass$5"), ek, qy;
let xm = (ek = (qy = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.typing = new eI(this);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("appId") && (this.typing.appId = this.appId), t.has("userId") && (this.typing.userId = this.userId);
  }
  render() {
    const { names: t, ellipsis: e } = this.typing;
    let i;
    if (t.length === 1) {
      const s = t[0];
      i = P(st`${s} is typing${e}`, { desc: "A is typing..." });
    } else if (t.length > 1) {
      const s = new Intl.ListFormat(this.weavy?.locale, { style: "long", type: "conjunction" }).format(
        t
      );
      i = P(st`${s} are typing${e}`, {
        desc: "A, B and C are typing..."
      });
    }
    return i ? v`<span>${i}</span>` : v`<slot></slot>`;
  }
}, c(qy, "oc"), qy), d(ek, "WyTyping"), ek);
B0([
  Ve({ context: Me, subscribe: !0 }),
  F()
], xm.prototype, "weavy", 2);
B0([
  O({ attribute: !0, type: Number })
], xm.prototype, "appId", 2);
B0([
  O({ attribute: !0, type: Number })
], xm.prototype, "userId", 2);
xm = B0([
  U("wy-typing"),
  St()
], xm);
var LJ = Object.defineProperty, IJ = Object.getOwnPropertyDescriptor, NV = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$1"), Ii = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? IJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && LJ(t, e, s), s;
}, "__decorateClass$4"), jV = /* @__PURE__ */ d((n, t, e) => t.has(n) || NV("Cannot " + e), "__accessCheck$1"), W9 = /* @__PURE__ */ d((n, t, e) => (jV(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$1"), WJ = /* @__PURE__ */ d((n, t, e) => t.has(n) ? NV("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$1"), V9 = /* @__PURE__ */ d((n, t, e, i) => (jV(n, t, "write to private field"), t.set(n, e), e), "__privateSet$1"), eh, ik, Zy;
let si = (ik = (Zy = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.unread = !1, this.avatarUrl = "", this.hideAvatar = !1, this.name = "", this.type = gt.PrivateChat, this.selected = !1, this.starred = !1, this.pinned = !1, this.handleMessageCreated = (t) => {
      !this.user || !this.weavy || (ge(this.weavy.queryClient, ["apps", t.message.app.id], void 0, (e) => {
        e.last_message = t.message, e.is_unread = t.message.created_by.id !== this.user?.id;
      }), Ct(
        this.weavy.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.message.app.id,
        (e) => {
          e.last_message = t.message, e.is_unread = t.message.created_by.id !== this.user?.id;
        }
      ));
    }, this.handleConversationUpdated = () => {
      this.weavy?.queryClient.invalidateQueries({ queryKey: ["apps"], exact: !1 });
    }, this.handleConversationMarked = (t) => {
      this.user && t.actor.id === this.user.id && this.weavy?.queryClient.invalidateQueries({ queryKey: ["apps"], exact: !1 });
    }, WJ(this, eh);
  }
  /**
   * Trigger `selected` event.
   *
   * @returns Whether the event was dispatched successfully.
   */
  dispatchSelected() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("selected", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Trigger `star` event.
   *
   * @param star - Whether the conversation should be starred.
   * @returns Whether the event was dispatched successfully.
   */
  dispatchStar(t) {
    if (!this.conversationId)
      return;
    const e = new CustomEvent("star", {
      detail: { id: this.conversationId, star: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Trigger `pin` event.
   *
   * @param pin - Whether the conversation should be pinned.
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchPin(t) {
    if (!this.conversationId)
      return;
    const e = new CustomEvent("pin", {
      detail: { id: this.conversationId, pin: t }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Trigger `mark` event for marking the conversation as read/unread.
   *
   * @param mark - Whether the conversation should be marked as read.
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchMarked(t) {
    if (!this.conversationId)
      return;
    const e = new CustomEvent("mark", {
      detail: { id: this.conversationId, messageId: t ? this.lastMessage?.id : null }
    });
    return this.dispatchEvent(e);
  }
  /**
   * Triggers `leave` event when the current user is leaving the conversation.
   *
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchLeaveConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("leave", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Triggers `remove` when the conversation should be removed.
   *
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchRemoveConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("remove", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  /**
   * Triggers `trash` event when the conversation should be trashed.
   *
   * @returns Whether the event was dispatched successfully.
   *
   * @internal
   */
  dispatchTrashConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("trash", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  willUpdate(t) {
    var e;
    if (super.willUpdate(t), (t.has("weavy") || t.has("conversationId")) && this.weavy && this.conversationId) {
      (e = W9(this, eh)) == null || e.call(this);
      const i = `a${this.conversationId}`;
      this.weavy.subscribe(i, "app_updated", this.handleConversationUpdated), this.weavy.subscribe(i, "member_added", this.handleConversationUpdated), this.weavy.subscribe(i, "message_created", this.handleMessageCreated), this.weavy.subscribe(i, "app_marked", this.handleConversationMarked), V9(this, eh, () => {
        this.weavy?.unsubscribe(i, "app_updated", this.handleConversationUpdated), this.weavy?.unsubscribe(i, "member_added", this.handleConversationUpdated), this.weavy?.unsubscribe(i, "message_created", this.handleMessageCreated), this.weavy?.unsubscribe(i, "app_marked", this.handleConversationMarked), V9(this, eh, void 0);
      });
    }
  }
  render() {
    const t = this.lastMessage?.created_at ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.lastMessage.created_at)
    ) : "", e = this.lastMessage?.created_at ? ql(this.weavy?.locale, new Date(this.lastMessage.created_at)) : "", i = this.type === gt.PrivateChat && this.user ? (this.members?.data || []).filter((s) => s.id !== this.user?.id)?.[0] ?? this.user : null;
    return v`
      <wy-item
        part="wy-conversation-item"
        size="lg"
        interactive
        outer
        status=${this.unread ? "unread" : void 0}
        ?selected=${this.selected}
        tabindex="0"
        actionsPosition="bottom"
        @click=${(s) => (s.preventDefault(), this.dispatchSelected())}
        @keydown=${Le}
        @keyup=${di}
      >
        ${this.type !== gt.AgentChat ? this.avatarUrl ? v`<wy-avatar slot="image" .size=${48} src=${this.avatarUrl}></wy-avatar>` : this.type == gt.ChatRoom ? v` <wy-avatar-group
                slot="image"
                .members=${this.members?.data}
                title=${this.name}
                .size=${48}
              ></wy-avatar-group>` : v`
                <wy-avatar
                  slot="image"
                  src=${Ot(i?.avatar_url)}
                  name=${Ot(i?.name)}
                  description=${Ot(i?.comment)}
                  presence=${i?.presence || "away"}
                  ?isAgent=${i?.is_agent}
                  id=${Ot(i?.id)}
                  size=${48}
                ></wy-avatar>
              ` : C}

        <span slot="title">${this.name || this.lastMessage?.plain || P("Untitled conversation")}</span>
        ${this.lastMessage ? v`
              <time slot="meta" datetime=${this.lastMessage.created_at.toString()} title=${t}
                >${e}</time
              >
            ` : C}
        <span slot="text">
          ${this.user ? v`
                <wy-typing appId=${this.conversationId} userId=${this.user.id}>
                  ${this.lastMessage ? v`
                        ${this.user.id === this.lastMessage.created_by.id ? v`${P("You")}: ` : C}
                        ${this.members.count > 2 && this.user.id !== this.lastMessage?.created_by.id ? v`${this.lastMessage?.created_by.name}: ` : C}
                      ` : C}
                  ${this.lastMessage?.text ? v`<span>${this.lastMessage.plain}</span>` : C}
                  ${!this.lastMessage?.text && (this.lastMessage?.attachments?.count || 0) > 0 ? v`<wy-icon kind="text-icon" name="attachment"></wy-icon>` : C}
                  ${!this.lastMessage?.text && this.lastMessage?.meeting?.id ? v`<wy-icon kind="text-icon" name="video"></wy-icon>` : C}
                  ${!this.lastMessage?.text && (this.lastMessage?.options?.count || 0) > 0 ? v`<wy-icon kind="text-icon" name="poll"></wy-icon>` : C}
                  ${this.lastMessage ? C : v`&nbsp;`}
                </wy-typing>
              ` : C}
        </span>

        ${this.starred ? v`<wy-button
              small
              slot="actions"
              kind="icon"
              @click=${(s) => {
      s.stopPropagation(), this.dispatchStar(!1);
    }}
            >
              <wy-icon name="star" size=${24} color="yellow"></wy-icon>
            </wy-button>` : C}
        ${this.pinned ? v`<wy-button
              small
              slot="actions"
              kind="icon"
              @click=${(s) => {
      s.stopPropagation(), this.dispatchPin(!1);
    }}
            >
              <wy-icon name="pin" size=${20} color=""></wy-icon>
            </wy-button>` : C}
 
        <wy-dropdown small slot="actions" directionX="left">
          <wy-dropdown-item @click=${() => this.dispatchMarked(this.unread)}>
            <wy-icon name=${this.unread ? "read" : "unread"}></wy-icon>
            ${this.unread ? P("Mark as read") : P("Mark as unread")}
          </wy-dropdown-item>
          <wy-dropdown-item @click=${() => this.dispatchPin(!this.pinned)}>
            <wy-icon name=${this.pinned ? "unpin" : "pin"}></wy-icon>
            ${this.pinned ? P("Unpin") : P("Pin")}
          </wy-dropdown-item>
          <wy-dropdown-item @click=${() => this.dispatchStar(!this.starred)}>
            <wy-icon name=${this.starred ? "unstar" : "star"}></wy-icon>
            ${this.starred ? P("Unstar") : P("Star")}
          </wy-dropdown-item>
          ${this.type === gt.PrivateChat ? v`<wy-dropdown-item @click=${() => this.dispatchRemoveConversation()}>
                <wy-icon name="trashcan"></wy-icon>
                ${P("Delete")}
              </wy-dropdown-item>` : C}
          ${this.type === gt.ChatRoom ? v`<wy-dropdown-item @click=${() => this.dispatchLeaveConversation()}>
                <wy-icon name="account-minus"></wy-icon>
                ${P("Leave")}
              </wy-dropdown-item>` : C}
          ${this.type === gt.AgentChat ? v`
                <wy-dropdown-item @click=${() => this.dispatchTrashConversation()}>
                  <wy-icon name="trashcan"></wy-icon>
                  ${P("Delete")}
                </wy-dropdown-item>
              ` : C}
        </wy-dropdown>
      </wy-item>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.weavy && this.requestUpdate("weavy");
  }
  disconnectedCallback() {
    var t;
    (t = W9(this, eh)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Zy, "cc"), Zy), d(ik, "WyConversationItem"), ik);
eh = /* @__PURE__ */ new WeakMap();
si.styles = [XV];
Ii([
  Ve({ context: Me, subscribe: !0 }),
  F()
], si.prototype, "weavy", 2);
Ii([
  Ve({ context: p0, subscribe: !0 }),
  F()
], si.prototype, "user", 2);
Ii([
  O({ attribute: !0, type: Number })
], si.prototype, "conversationId", 2);
Ii([
  O({ attribute: !0, type: Boolean, reflect: !0 })
], si.prototype, "unread", 2);
Ii([
  O({ attribute: !0 })
], si.prototype, "avatarUrl", 2);
Ii([
  O({ attribute: !0, type: Boolean, reflect: !0 })
], si.prototype, "hideAvatar", 2);
Ii([
  O({ attribute: !0 })
], si.prototype, "name", 2);
Ii([
  O({ attribute: !0, type: String })
], si.prototype, "type", 2);
Ii([
  O({ attribute: !0, type: Boolean, reflect: !0 })
], si.prototype, "selected", 2);
Ii([
  O({ attribute: !0, type: Boolean, reflect: !0 })
], si.prototype, "starred", 2);
Ii([
  O({ attribute: !0, type: Boolean, reflect: !0 })
], si.prototype, "pinned", 2);
Ii([
  O({ attribute: !1 })
], si.prototype, "members", 2);
Ii([
  O({ attribute: !1 })
], si.prototype, "lastMessage", 2);
si = Ii([
  U("wy-conversation-item"),
  St()
], si);
var VJ = Object.defineProperty, DJ = Object.getOwnPropertyDescriptor, BV = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError"), W1 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? DJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && VJ(t, e, s), s;
}, "__decorateClass$3"), UV = /* @__PURE__ */ d((n, t, e) => t.has(n) || BV("Cannot " + e), "__accessCheck"), D9 = /* @__PURE__ */ d((n, t, e) => (UV(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet"), qJ = /* @__PURE__ */ d((n, t, e) => t.has(n) ? BV("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd"), q9 = /* @__PURE__ */ d((n, t, e, i) => (UV(n, t, "write to private field"), t.set(n, e), e), "__privateSet"), ih, nk, Fy;
let ga = (nk = (Fy = class extends zi {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this.conversationTypes = [gt.ChatRoom, gt.PrivateChat], this.searchText = "", this.conversationsQuery = new Rl(this), this.infiniteScroll = new El(this), this.pagerRef = wt(), this.handleRefresh = () => {
      this.conversationsQuery.result.refetch();
    }, this.handlePresenceChange = (t) => {
      if (!this.weavy)
        return;
      Array.isArray(t) || (t = [parseInt(t)]);
      const e = /* @__PURE__ */ d((i) => {
        const s = i.members.data ?? [];
        s.forEach((r) => {
          r.presence = t.indexOf(r.id) != -1 ? "active" : "away";
        }), i.members.data = s;
      }, "updateMembersInApps");
      Ct(
        this.weavy.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        void 0,
        e
      );
    }, qJ(this, ih);
  }
  /**
   * Selects a conversation and triggers an action event.
   *
   * @param conversation - The conversation to select.
   */
  selectConversation(t) {
    this.conversationId = t?.id, this.dispatchAction(hi.Select, t);
  }
  /**
   * Triggers `wy-action` event.
   * @param action - The performed action.
   * @param app - The conversation to select.
   * @returns Whether the event was successful.
   */
  dispatchAction(t, e) {
    const i = new CustomEvent("wy-action", {
      detail: { action: t, app: e },
      bubbles: !0,
      composed: !0
    });
    return this.dispatchEvent(i);
  }
  /**
   * Marks a conversation as read.
   *
   * @param appId - The id of the conversation to mark.
   * @param messageId - Optional message id to set the marker to.
   */
  async handleMark(t, e) {
    await this.markConversationMutation?.mutate({ app: t, messageId: e, userId: this.user?.id });
  }
  /**
   * Sets a conversation as starred.
   *
   * @param appId -  The id of the conversation to star.
   * @param star - Whether to make the conversation starred.
   */
  async handleStar(t, e) {
    await this.starConversationMutation?.mutate({ appId: t, star: e });
  }
  /**
   * Sets a conversation as pinned.
   *
   * @param appId - The id of the conversation to pin.
   * @param pin - Whether to make the conversation pinned.
   */
  async handlePin(t, e) {
    await this.pinConversationMutation?.mutate({ appId: t, pin: e });
  }
  /**
   * Leave a conversation (for the current user).
   *
   * @param appId - The id of the conversation to leave.
   */
  async handleLeaveConversation(t) {
    this.conversationId === t && this.selectConversation(null);
    const e = await this.whenUser();
    await this.leaveConversationMutation?.mutate({ appId: t, members: [e.id] }), this.conversationsQuery.result.refetch();
  }
  /**
   * Remove a conversation.
   *
   * @param appId - The id of the conversation to remove.
   */
  async handleRemoveConversation(t) {
    this.conversationId === t && this.selectConversation(null), await this.removeConversationMutation?.mutate({ appId: t }), this.conversationsQuery.result.refetch();
  }
  /**
   * Trash a conversation.
   *
   * @param appId - The id of the conversation to trash.
   */
  async handleTrashConversation(t) {
    this.conversationId === t && this.selectConversation(null), await this.trashConversationMutation?.mutate({ appId: t }), this.conversationsQuery.result.refetch();
  }
  async willUpdate(t) {
    var e;
    super.willUpdate(t), (t.has("weavy") || t.has("conversationTypes")) && this.weavy && (await this.conversationsQuery.trackInfiniteQuery(
      LL(
        this.weavy,
        {},
        this.conversationTypes,
        this.agent,
        () => this.searchText,
        "pinned_at desc,rev desc",
        !1
      )
    ), this.markConversationMutation = c4(this.weavy), this.starConversationMutation = zI(this.weavy), this.pinConversationMutation = LI(this.weavy), this.leaveConversationMutation = h4(this.weavy), this.removeConversationMutation = II(this.weavy), this.trashConversationMutation = DI(this.weavy), (e = D9(this, ih)) == null || e.call(this), this.weavy.subscribe(null, "app_created", this.handleRefresh), this.weavy.subscribe(null, "message_created", this.handleRefresh), this.weavy.subscribe(null, "member_added", this.handleRefresh), this.weavy.subscribe(null, "online", this.handlePresenceChange), q9(this, ih, () => {
      this.weavy?.unsubscribe(null, "app_created", this.handleRefresh), this.weavy?.unsubscribe(null, "message_created", this.handleRefresh), this.weavy?.unsubscribe(null, "member_added", this.handleRefresh), this.weavy?.unsubscribe(null, "online", this.handlePresenceChange), q9(this, ih, void 0);
    }));
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.conversationsQuery.result, this.pagerRef.value);
  }
  async updated(t) {
    t.has("searchText") && t.get("searchText") !== void 0 && this.conversationsQuery.result && await this.conversationsQuery.result.refetch?.();
  }
  renderConversations(t) {
    if (t) {
      const e = cs(t);
      return Mi(
        e,
        (i) => i?.id,
        (i) => [
          v`<wy-conversation-item
              conversationId=${i?.id}
              .avatarUrl=${i?.avatar_url}
              .hideAvatar=${!!this.agent}
              .name=${i.name}
              .lastMessage=${i.last_message}
              .members=${i.members}
              .unread=${i.is_unread}
              .starred=${i.is_starred}
              .pinned=${i.is_pinned}
              .type=${i.type}
              .selected=${this.conversationId == i.id}
              @selected=${() => this.selectConversation(i)}
              @mark=${(s) => this.handleMark(i, s.detail.messageId)}
              @star=${(s) => this.handleStar(s.detail.id, s.detail.star)}
              @pin=${(s) => this.handlePin(s.detail.id, s.detail.pin)}
              @leave=${(s) => this.handleLeaveConversation(s.detail.id)}
              @remove=${(s) => this.handleRemoveConversation(s.detail.id)}
              @trash=${(s) => this.handleTrashConversation(s.detail.id)}
            ></wy-conversation-item>`
        ]
      );
    }
    return C;
  }
  render() {
    const { data: t, isPending: e, hasNextPage: i } = this.conversationsQuery.result ?? {};
    return v`
      <div part="wy-conversations">
        <wy-buttons part="wy-conversations-toolbar" position=${this.agent ? "floating" : "sticky"} ?reverse=${!!this.agent}>
          <slot name="navigation"></slot>
          ${this.agent ? C : v`
                <wy-search
                  compact
                  placeholder=${P("Search for conversations...")}
                  @search=${(s) => this.searchText = s.detail.query}
                ></wy-search>
              `}
          <slot name="actions"></slot>
        </wy-buttons>

        <div part="wy-conversation-list">
          ${!e && this.user && t ? t.pages[0]?.count || this.searchText ? this.renderConversations(t) : v`
                  <div part="wy-pane-body">
                    <div part="wy-pane-group">
                      <wy-empty noNetwork>${P("Create a conversation to get started.")}</wy-empty>
                    </div>
                  </div>
                ` : v`<wy-empty><wy-progress-circular indeterminate padded></wy-progress-circular></wy-empty>`}
          ${i ? v`<div ${ot(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : C}
        </div>
      </div>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = D9(this, ih)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Fy, "lc"), Fy), d(nk, "WyConversationList"), nk);
ih = /* @__PURE__ */ new WeakMap();
ga.styles = [XV, Il, ft, va];
W1([
  O({ type: Number })
], ga.prototype, "conversationId", 2);
W1([
  O({ type: Array })
], ga.prototype, "conversationTypes", 2);
W1([
  O()
], ga.prototype, "agent", 2);
W1([
  F()
], ga.prototype, "searchText", 2);
ga = W1([
  U("wy-conversation-list"),
  St()
], ga);
var ZJ = Object.defineProperty, FJ = Object.getOwnPropertyDescriptor, U0 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? FJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && ZJ(t, e, s), s;
}, "__decorateClass$2"), sk, Xy;
let wa = (sk = (Xy = class extends Ae {
  constructor() {
    super(...arguments), this.componentFeatures = new ni(bm), this.theme = new wn(this, wa.styles), this.unreadConversations = new $0(this), this.createConversationController = new b0(this), this.componentTypes = [gt.ChatRoom, gt.PrivateChat], this.conversationId = null, this.conversationQuery = new gn(this), this.persistState = new g1(this), this.conversationNewRef = wt();
  }
  set agent(t) {
    super.agent = t, this._agentUid ? (this.componentTypes = [gt.AgentChat], this.componentFeatures = new ni(
      K4,
      this.componentFeatures.allowedFeatures()
    )) : (this.componentTypes = [gt.ChatRoom, gt.PrivateChat], this.componentFeatures = new ni(
      bm,
      this.componentFeatures.allowedFeatures()
    )), this.conversationId = null;
  }
  get agent() {
    return super.agent;
  }
  /** Current unread conversation count. */
  get unread() {
    return this.unreadConversations.unread;
  }
  /**
   * Creates a new conversation.
   *
   * When in agent mode, a conversation is created instantly.
   *
   * @param members - Optional array of member id or member uid.
   */
  async createConversation(t) {
    return await this.createConversationController.create(t);
  }
  /**
   * Opens the select member dialog to let the user choose members.
   *
   * @returns Promise resolving to any selected member ids or uids.
   */
  async selectMembers() {
    return await this.conversationNewRef.value?.selectMembers();
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("weavy") || t.has("agent") || t.has("user")) && this.weavy && this.user && this.persistState.observe(
      [{ name: "conversationId", override: !1 }],
      this.agent || "messenger",
      `u${this.user?.id}`,
      (e) => {
        if (e.has("conversationId") && this.conversationId) {
          const i = new CustomEvent("wy-action", {
            detail: {
              action: hi.Select,
              app: { id: this.conversationId }
            },
            bubbles: !0,
            composed: !0
          });
          this.dispatchEvent(i);
        }
      }
    ), t.has("agent") && (this.createConversationController.agent = this.agent), t.has("link") && this.link?.app && (this.conversationId = this.link.app.id), (t.has("componentTypes") || t.has("agent")) && await this.unreadConversations.track(this.componentTypes, this.agent);
  }
  render() {
    return v`
      <wy-conversation-list
        .conversationTypes=${this.componentTypes}
        .agent=${this.agent}
        conversationId=${Ot(this.conversationId !== null ? this.conversationId : void 0)}
        @wy-action=${(t) => {
      !t.defaultPrevented && t.detail.action === hi.Select && t.detail.app !== void 0 && (this.conversationId = t.detail.app?.id);
    }}
      >
        <wy-conversation-new
          slot="actions"
          .agent=${this.agent}
          @wy-action=${(t) => {
      !t.defaultPrevented && t.detail.action === hi.Select && t.detail.app !== void 0 && (this.conversationId = t.detail.app?.id);
    }}
          ${ot(this.conversationNewRef)}
        >
          <slot name="conversation-new"></slot>
        </wy-conversation-new>
        <slot name="actions" slot="actions"></slot>
      </wy-conversation-list>
    `;
  }
}, c(Xy, "dc"), Xy), d(sk, "WyMessengerConversations"), sk);
wa.styles = [Te, ws, bi, _l, zl];
U0([
  O({ attribute: !1 })
], wa.prototype, "componentTypes", 2);
U0([
  O({ type: String })
], wa.prototype, "agent", 1);
U0([
  O({ type: Number })
], wa.prototype, "conversationId", 2);
wa = U0([
  U("wy-messenger-conversations"),
  St()
], wa);
var XJ = Object.defineProperty, NJ = Object.getOwnPropertyDescriptor, H0 = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? NJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && XJ(t, e, s), s;
}, "__decorateClass$1"), rk, Ny;
let Sl = (rk = (Ny = class extends zi {
  constructor() {
    super(...arguments), this.exportParts = new Y(this), this._whenMembers = this.createMembersPromise(), this.show = !1;
  }
  /**
   * Resolves when members are selected from the modal.
   *
   * @returns Promise<MemberIdType[]>
   */
  async whenMembers() {
    return this._whenMembers;
  }
  /**
   * Create an internal members promise and store resolve/reject handlers.
   *
   * @internal
   */
  createMembersPromise() {
    const t = new Promise((e, i) => {
      this._resolveMembers = e, this._rejectMembers = i;
    });
    return this._whenMembers = t, t;
  }
  /**
   * Open the new conversation dialog and return selected members.
   *
   * @returns Promise<MemberIdType[]>
   */
  async selectMembers() {
    return this.show = !0, await this.whenMembers();
  }
  /**
   * Close the new conversation dialog and resolve or reject the selection promise.
   *
   * @internal
   * @param members - Optional selected member ids to resolve the promise with.
   */
  close(t) {
    this.show = !1, t ? this._resolveMembers?.(t) : this._rejectMembers?.();
  }
  /**
   * Create a conversation by dispatching a `create` event and closing the dialog.
   *
   * @param members - Array of members by id/uid for a new conversation.
   */
  async submit(t = []) {
    await this.whenUser(), this.close(t);
    const e = new CustomEvent("create", {
      detail: { members: t }
    });
    this.dispatchEvent(e), this.createMembersPromise();
  }
  render() {
    return v`
      ${this.slotElements.length ? C : v`
            <wy-button
              part="wy-conversation-new-button"
              kind="icon"
              @click=${() => this.agent ? this.submit() : this.selectMembers()}
            >
              <wy-icon name="plus"></wy-icon>
            </wy-button>
          `}
      <slot></slot>

      ${!this.agent && this.weavy && this.user ? v`<wy-overlay
            part="wy-conversation-new-dialog"
            .show=${this.show}
            @close=${() => {
      this.show = !1;
    }}
          >
            <wy-titlebar header slot="header">
              <wy-button slot="icon" kind="icon" @click=${() => this.close()}>
                <wy-icon name="close"></wy-icon>
              </wy-button>
              <span slot="title">${P("New conversation")}</span>
            </wy-titlebar>
            ${this.show ? v`
                  <wy-users-search
                    @submit=${(t) => this.submit(t.detail.members.map((e) => e.id))}
                  ></wy-users-search>
                ` : C}
          </wy-overlay>` : C}
    `;
  }
}, c(Ny, "hc"), Ny), d(rk, "WyConversationNew"), rk);
Sl.styles = [ft];
H0([
  O()
], Sl.prototype, "agent", 2);
H0([
  F()
], Sl.prototype, "show", 2);
H0([
  Ml({ flatten: !0, selector: ":not(slot)" })
], Sl.prototype, "slotElements", 2);
Sl = H0([
  U("wy-conversation-new"),
  St()
], Sl);
const jJ = et`[part~=wy-message-editor-inputs]{display:flex;flex-direction:row;align-items:flex-end;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em))*1.5*var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*2 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))*2)}[part~=wy-message-editor-text]{flex:1 1 100%;display:flex;flex-direction:column;margin-inline:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-editor-parts]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));min-height:0}[part~=wy-message-editor] .cm-editor{flex:1 1 100%;max-height:11.25em;background-color:var(--wy-surface-container-lowest, var(--wy-surface-container-lowest-light, #ffffff));color:var(--wy-on-surface, var(--wy-on-surface-light, #181c20));border-radius:var(--wy-input-filled-border-radius, var(--wy-border-radius-lg, var(--wy-border-radius, calc(1.25 * var(--wy-size, 1rem)))));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid rgba(0,0,0,0);margin:calc(-1*var(--wy-input-border-width, var(--wy-border, 1px)))}[part~=wy-message-editor] .cm-editor:focus{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-message-editor] .cm-editor.cm-focused{border-color:var(--wy-outline-variant, var(--wy-outline-variant-light, #c2c7cf))}[part~=wy-message-editor] .cm-editor .cm-content{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)), inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em))*1.5*var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))*2 - var(--wy-input-border-width, var(--wy-border, 1px)));line-height:calc(1.5*var(--wy-size, 1rem))}[part~=wy-message-editor] [part~=wy-is-invalid]+[data-editor-target] .cm-editor,[part~=wy-message-editor] [part~=wy-is-invalid] .cm-editor{border-color:var(--wy-error, var(--wy-error-light, #ba1821))!important}`;
var BJ = Object.getOwnPropertyDescriptor, UJ = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? BJ(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = a(s) || s);
  return s;
}, "__decorateClass"), ak, jy;
let Pb = (ak = (jy = class extends Wt {
  constructor() {
    super(), this.editorType = "messages", this.editorClass = "wy-message-editor";
  }
  /**
   * Render content that appears above the message editor.
   *
   * By default returns the same lists section used by the base editor.
   *
   * @internal
   */
  renderTopSlot() {
    return [
      this.renderLists()
    ];
  }
  /**
   * Render the primary middle slot containing the add-menu, editor and send button.
   *
   * Overrides the base implementation to provide message-specific controls and layout.
   *
   * @internal
   */
  renderMiddleSlot() {
    return v` <div part="wy-message-editor-inputs">
      <!-- Add -->
      ${this.componentFeatures?.allowsAnyFeature(
      z.Attachments,
      z.CloudFiles,
      z.Polls,
      z.Meetings,
      z.ZoomMeetings,
      z.GoogleMeet,
      z.MicrosoftTeams
    ) ? v`<wy-dropdown icon="plus" directionY="up" ?disabled=${this.disabled}>
            ${this.componentFeatures?.allowsFeature(z.Attachments) ? v`
                  <wy-dropdown-item @click=${this.openFileInput} title=${P("From device")}>
                    <wy-icon name="attachment"></wy-icon>
                    <span>${P("From device")}</span>
                  </wy-dropdown-item>
                  <input
                    type="file"
                    ${ot(this.fileInputRef)}
                    @click=${(t) => t.stopPropagation()}
                    @change=${(t) => this.handleUploadFiles(
      Array.from(t.target.files || []),
      t.target
    )}
                    multiple
                    hidden
                    tabindex="-1"
                  />
                ` : C}
            ${this.componentFeatures?.allowsFeature(z.CloudFiles) ? v`
                  <wy-dropdown-item @click=${this.openCloudFiles} title=${P("From cloud")}>
                    <wy-icon name="cloud"></wy-icon>
                    <span>${P("From cloud")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsFeature(z.Polls) ? v`
                  <wy-dropdown-item @click=${() => this.openPolls()} title=${P("Poll")}>
                    <wy-icon name="poll"></wy-icon>
                    <span>${P("Poll")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsAnyFeature(z.Meetings, z.ZoomMeetings) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("zoom")} title=${P("Zoom meeting")}>
                    <wy-icon svg="zoom-meetings"></wy-icon>
                    <span>${P("Zoom meeting")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsAnyFeature(z.Meetings, z.GoogleMeet) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("google")} title=${P("Google Meet")}>
                    <wy-icon svg="google-meet"></wy-icon>
                    <span>${P("Google Meet")}</span>
                  </wy-dropdown-item>
                ` : C}
            ${this.componentFeatures?.allowsAnyFeature(z.Meetings, z.MicrosoftTeams) ? v`
                  <wy-dropdown-item
                    @click=${() => this.handleMeetingClick("microsoft")}
                    title=${P("Microsoft Teams")}
                  >
                    <wy-icon svg="microsoft-teams"></wy-icon>
                    <span>${P("Microsoft Teams")}</span>
                  </wy-dropdown-item>
                ` : C}
          </wy-dropdown>` : C}

      <!-- Input -->
      <div part="wy-message-editor-text" ${ot(this.editorRef)}> ${this.renderEditorDummy()} </div>

      <!-- Button -->
      <wy-button
        kind="icon"
        color="primary-text"
        title=${P("Send", { desc: "Button action to send" })}
        @click="${() => this.submit()}"
        ?disabled=${this.disabled}
      >
        <wy-icon name="send"></wy-icon>
      </wy-button>
    </div>`;
  }
  /**
   * Render the bottom slot for message editor with no content.
   *
   * @internal
   */
  renderBottomSlot() {
    return C;
  }
}, c(jy, "pc"), jy), d(ak, "WyMessageEditor"), ak);
Pb.styles = [...Wt.styles, jJ];
Pb = UJ([
  U("wy-message-editor"),
  St()
], Pb);
const K = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get WyAnnotation() {
    return Uw;
  },
  get WyAnnotationList() {
    return Hw;
  },
  get WyAttachment() {
    return Bw;
  },
  get WyAttachmentList() {
    return pm;
  },
  get WyAvatar() {
    return hs;
  },
  get WyAvatarGroup() {
    return ll;
  },
  get WyAvatarHeader() {
    return qw;
  },
  get WyBadge() {
    return ir;
  },
  get WyButton() {
    return Yi;
  },
  get WyButtons() {
    return cl;
  },
  get WyCloudFiles() {
    return gl;
  },
  get WyComment() {
    return us;
  },
  get WyCommentEditor() {
    return Sb;
  },
  get WyCommentList() {
    return er;
  },
  get WyContainer() {
    return Js;
  },
  get WyContextDataProgress() {
    return Cb;
  },
  get WyConversation() {
    return Ai;
  },
  get WyConversationHeader() {
    return ys;
  },
  get WyConversationItem() {
    return si;
  },
  get WyConversationList() {
    return ga;
  },
  get WyConversationNew() {
    return Sl;
  },
  get WyDropdown() {
    return Gi;
  },
  get WyDropdownDivider() {
    return bb;
  },
  get WyDropdownItem() {
    return Nw;
  },
  get WyDropdownOption() {
    return um;
  },
  get WyEditor() {
    return Wt;
  },
  get WyEmbed() {
    return fm;
  },
  get WyEmbedSelect() {
    return Yw;
  },
  get WyEmpty() {
    return hm;
  },
  get WyFileGrid() {
    return Ol;
  },
  get WyFileItem() {
    return ps;
  },
  get WyFileMenu() {
    return ml;
  },
  get WyFileTable() {
    return pa;
  },
  get WyFileVersions() {
    return i1;
  },
  get WyFilesHeader() {
    return ua;
  },
  get WyFilesList() {
    return nr;
  },
  get WyIcon() {
    return he;
  },
  get WyIconDisplay() {
    return Dw;
  },
  get WyIconStack() {
    return mb;
  },
  get WyImageGrid() {
    return dl;
  },
  get WyItem() {
    return We;
  },
  get WyItemList() {
    return oa;
  },
  get WyMeetingCard() {
    return Gw;
  },
  get WyMessage() {
    return ae;
  },
  get WyMessageEditor() {
    return Pb;
  },
  get WyMessageTyping() {
    return pn;
  },
  get WyNotificationHeader() {
    return bl;
  },
  get WyNotificationList() {
    return Om;
  },
  get WyNotificationListItem() {
    return ya;
  },
  get WyOverlay() {
    return ha;
  },
  get WyPdfViewer() {
    return yl;
  },
  get WyPoll() {
    return Jw;
  },
  get WyPollOption() {
    return ul;
  },
  get WyPost() {
    return ue;
  },
  get WyPostEdit() {
    return Ue;
  },
  get WyPostList() {
    return n1;
  },
  get WyPostTrashed() {
    return wm;
  },
  get WyPostView() {
    return ee;
  },
  get WyPresence() {
    return cm;
  },
  get WyPreview() {
    return de;
  },
  get WyPreviewEmbed() {
    return da;
  },
  get WyPreviewIcon() {
    return pl;
  },
  get WyPreviewImage() {
    return fl;
  },
  get WyPreviewItem() {
    return mm;
  },
  get WyPreviewMedia() {
    return tr;
  },
  get WyPreviewText() {
    return ds;
  },
  get WyProgressCircular() {
    return Rn;
  },
  get WyProgressLinear() {
    return mn;
  },
  get WyReactionItem() {
    return t1;
  },
  get WyReactions() {
    return ve;
  },
  get WySearch() {
    return kl;
  },
  get WySkeleton() {
    return jw;
  },
  get WyTitlebar() {
    return Ks;
  },
  get WyTitlebarText() {
    return Kw;
  },
  get WyToast() {
    return sr;
  },
  get WyToasts() {
    return s1;
  },
  get WyTyping() {
    return xm;
  },
  get WyUpload() {
    return $m;
  },
  get WyUsersSearch() {
    return zn;
  }
}, Symbol.toStringTag, { value: "Module" }));
ze.version = "1.0.0";
ze.sourceName = "@weavy/uikit-react";
const HJ = mD(null);
function _et(n, t = []) {
  const [e, i] = M3(), s = {
    ...n,
    cloudFilePickerUrl: n.cloudFilePickerUrl?.toString(),
    locales: A3(() => n.locales, [n.locales?.length]),
    tokenUrl: n.tokenUrl?.toString(),
    tokenFactory: A3(
      () => n.tokenFactory,
      [n.tokenFactory?.toString(), ...t]
    ),
    url: n.url?.toString()
  }, [r, a] = M3(s);
  return ok(() => {
    if (!e) {
      const l = Dc?.value ?? new Se(s);
      i(l);
    }
  }, []), ok(() => {
    if (e && !e.isDestroyed) {
      const o = {};
      Object.entries(s).forEach(([l, h]) => {
        h !== r[l] && Object.assign(o, { [l]: h });
      }), Object.keys(o).length && (a(s), Object.assign(e, o));
    }
  }, [s]), e;
}
c(_et, "useWeavy");
const HV = Promise.resolve(), i3 = class i3 {
  constructor(t, e) {
    this.o = [], this.t = !0, this.i = !1, this.l = t, this.h = e, this.u = new Promise(((i, s) => {
      this.p = i;
    }));
  }
  addController(t) {
    this.o.push(t);
  }
  removeController(t) {
    this.o?.splice(this.o.indexOf(t) >>> 0, 1);
  }
  requestUpdate() {
    this.t || (this.t = !0, HV.then((() => this.h(++this.l))));
  }
  get updateComplete() {
    return this.u;
  }
  m() {
    this.i = !0, this.o.forEach(((t) => t.hostConnected?.()));
  }
  _() {
    this.i = !1, this.o.forEach(((t) => t.hostDisconnected?.()));
  }
  v() {
    this.o.forEach(((t) => t.hostUpdate?.()));
  }
  C() {
    this.t = !1;
    const t = this.p;
    this.u = new Promise(((e, i) => {
      this.p = e;
    })), this.o.forEach(((e) => e.hostUpdated?.())), t(this.t);
  }
};
c(i3, "s");
let CS = i3;
const YJ = /* @__PURE__ */ c((n, t) => {
  const { useState: e, useLayoutEffect: i } = n, [s, r] = e(0);
  let a = !1;
  const [o] = e((() => {
    const l = new CS(s, r), h = t(l);
    return l.M = h, l.m(), a = !0, HV.then((() => {
      a && l._();
    })), l;
  }));
  return o.t = !0, i((() => (a = !1, o.i || o.m(), () => o._())), []), i((() => o.C())), o.v(), o.M;
}, "e$1");
function GJ(n, t) {
  const e = (typeof n == "function" ? n() : n && "current" in n ? n.current : n) || void 0, i = YJ(
    N,
    (s) => new PB(s, t ?? Me, e)
  );
  return ok(() => {
    e && i.setRef(e);
  }, [i, e]), i.context?.value;
}
c(GJ, "useWeavyContext");
const KJ = /* @__PURE__ */ new Set(["children", "localName", "ref", "style", "className"]), Z9 = /* @__PURE__ */ new WeakMap(), F9 = /* @__PURE__ */ c((n, t, e, i, s) => {
  const r = s?.[t];
  r === void 0 ? (n[t] = e, e == null && t in HTMLElement.prototype && n.removeAttribute(t)) : e !== i && ((a, o, l) => {
    let h = Z9.get(a);
    h === void 0 && Z9.set(a, h = /* @__PURE__ */ new Map());
    let u = h.get(o);
    l !== void 0 ? u === void 0 ? (h.set(o, u = { handleEvent: l }), a.addEventListener(o, u)) : u.handleEvent = l : u !== void 0 && (h.delete(o), a.removeEventListener(o, u));
  })(n, r, e);
}, "t"), j = /* @__PURE__ */ c(({ react: n, tagName: t, elementClass: e, events: i, displayName: s }) => {
  const r = new Set(Object.keys(i ?? {})), a = n.forwardRef(((o, l) => {
    const h = n.useRef(/* @__PURE__ */ new Map()), u = n.useRef(null), p = {}, y = {};
    for (const [m, g] of Object.entries(o)) KJ.has(m) ? p[m === "className" ? "class" : m] = g : r.has(m) || m in e.prototype ? y[m] = g : p[m] = g;
    return n.useLayoutEffect((() => {
      if (u.current === null) return;
      const m = /* @__PURE__ */ new Map();
      for (const g in y) F9(u.current, g, o[g], h.current.get(g), i), h.current.delete(g), m.set(g, o[g]);
      for (const [g, b] of h.current) F9(u.current, g, void 0, b, i);
      h.current = m;
    })), n.useLayoutEffect((() => {
      u.current?.removeAttribute("defer-hydration");
    }), []), p.suppressHydrationWarning = !0, n.createElement(t, { ...p, ref: n.useCallback(((m) => {
      u.current = m, typeof l == "function" ? l(m) : l !== null && (l.current = m);
    }), [l]) });
  }));
  return a.displayName = s ?? e.name, a;
}, "o"), pe = "wy-action", Wi = "wy-app", Y0 = "wy-link", YV = "wy-message", GV = "wy-notification", ri = "wy-preview-open", ai = "wy-preview-close", Sa = "wy-unread", JJ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  onWyAction: pe,
  onWyApp: Wi,
  onWyLink: Y0,
  onWyMessage: YV,
  onWyNotification: GV,
  onWyPreviewClose: ai,
  onWyPreviewOpen: ri,
  onWyUnread: Sa
}, Symbol.toStringTag, { value: "Module" })), zet = j({
  react: N,
  tagName: "wy-chat",
  elementClass: wl,
  events: {
    onWyApp: Wi,
    onWyAction: pe,
    onWyPreviewOpen: ri,
    onWyPreviewClose: ai
  }
}), Let = j({
  react: N,
  tagName: "wy-comments",
  elementClass: gm,
  events: {
    onWyApp: Wi,
    onWyAction: pe,
    onWyPreviewOpen: ri,
    onWyPreviewClose: ai
  }
}), Iet = j({
  react: N,
  tagName: "wy-component",
  elementClass: al,
  events: {
    ...JJ
  }
}), ttt = j({
  react: N,
  tagName: "wy-context",
  elementClass: ce
});
function Wet({
  children: n,
  ...t
}) {
  const e = gD(null), i = GJ(() => e.current);
  return /* @__PURE__ */ N.createElement(ttt, { ref: e, ...t }, /* @__PURE__ */ N.createElement(HJ.Provider, { value: i ?? null }, n));
}
c(Wet, "WyContext");
const Vet = j({
  react: N,
  tagName: "wy-copilot",
  elementClass: vl,
  events: {
    onWyApp: Wi,
    onWyAction: pe,
    onWyMessage: YV,
    onWyPreviewOpen: ri,
    onWyPreviewClose: ai
  }
}), Det = j({
  react: N,
  tagName: "wy-files",
  elementClass: fa,
  events: {
    onWyApp: Wi,
    onWyAction: pe,
    onWyPreviewOpen: ri,
    onWyPreviewClose: ai
  }
}), qet = j({
  react: N,
  tagName: "wy-messenger",
  elementClass: ms,
  events: {
    onWyAction: pe,
    onWyApp: Wi,
    onWyPreviewOpen: ri,
    onWyPreviewClose: ai,
    onWyUnread: Sa
  }
}), Zet = j({
  react: N,
  tagName: "wy-messenger-badge",
  elementClass: ma,
  events: {
    onWyUnread: Sa
  }
}), Fet = j({
  react: N,
  tagName: "wy-messenger-button",
  elementClass: Oi,
  events: {
    onWyAction: pe,
    onWyApp: Wi,
    onWyPreviewOpen: ri,
    onWyPreviewClose: ai,
    onWyUnread: Sa
  }
}), Xet = j({
  react: N,
  tagName: "wy-messenger-conversations",
  elementClass: wa,
  events: {
    onWyAction: pe,
    onWyApp: Wi,
    onWyUnread: Sa
  }
}), Net = j({
  react: N,
  tagName: "wy-messenger-new",
  elementClass: r1,
  events: {
    onWyApp: Wi
  }
}), jet = j({
  react: N,
  tagName: "wy-notifications",
  elementClass: $l,
  events: {
    onWyAction: pe,
    onWyApp: Wi,
    onWyLink: Y0,
    onWyUnread: Sa
  }
}), Bet = j({
  react: N,
  tagName: "wy-notification-badge",
  elementClass: xl,
  events: {
    onWyApp: Wi,
    onWyUnread: Sa
  }
}), Uet = j({
  react: N,
  tagName: "wy-notification-button",
  elementClass: _n,
  events: {
    onWyAction: pe,
    onWyApp: Wi,
    onWyLink: Y0,
    onWyUnread: Sa
  }
}), Het = j({
  react: N,
  tagName: "wy-notification-toasts",
  elementClass: fs,
  events: {
    onWyApp: Wi,
    onWyLink: Y0,
    onWyNotification: GV
  }
}), Yet = j({
  react: N,
  tagName: "wy-posts",
  elementClass: vm,
  events: {
    onWyAction: pe,
    onWyApp: Wi,
    onWyPreviewOpen: ri,
    onWyPreviewClose: ai
  }
}), ett = j({
  react: N,
  tagName: "wy-avatar",
  elementClass: K.WyAvatar
}), itt = j({
  react: N,
  tagName: "wy-avatar-group",
  elementClass: K.WyAvatarGroup
}), ntt = j({
  react: N,
  tagName: "wy-avatar-header",
  elementClass: K.WyAvatarHeader
}), stt = j({
  react: N,
  tagName: "wy-button",
  elementClass: K.WyButton
}), rtt = j({
  react: N,
  tagName: "wy-buttons",
  elementClass: K.WyButtons
}), att = j({
  react: N,
  tagName: "wy-badge",
  elementClass: K.WyBadge
}), ott = j({
  react: N,
  tagName: "wy-dropdown",
  elementClass: K.WyDropdown
}), ltt = j({
  react: N,
  tagName: "wy-dropdown-item",
  elementClass: K.WyDropdownItem
}), ctt = j({
  react: N,
  tagName: "wy-dropdown-option",
  elementClass: K.WyDropdownOption
}), htt = j({
  react: N,
  tagName: "wy-dropdown-divider",
  elementClass: K.WyDropdownDivider
}), dtt = j({
  react: N,
  tagName: "wy-icon",
  elementClass: K.WyIcon
}), utt = j({
  react: N,
  tagName: "wy-icon-stack",
  elementClass: K.WyIconStack
}), ptt = j({
  react: N,
  tagName: "wy-icon-display",
  elementClass: K.WyIconDisplay
}), ftt = j({
  react: N,
  tagName: "wy-image-grid",
  elementClass: K.WyImageGrid,
  events: {
    onFileOpen: "file-open"
  }
}), ytt = j({
  react: N,
  tagName: "wy-item",
  elementClass: K.WyItem
}), mtt = j({
  react: N,
  tagName: "wy-item-list",
  elementClass: K.WyItemList
}), gtt = j({
  react: N,
  tagName: "wy-overlay",
  elementClass: K.WyOverlay,
  events: {
    onClose: "close"
  }
}), wtt = j({
  react: N,
  tagName: "wy-presence",
  elementClass: K.WyPresence
}), vtt = j({
  react: N,
  tagName: "wy-progress-circular",
  elementClass: K.WyProgressCircular
}), Ott = j({
  react: N,
  tagName: "wy-progress-linear",
  elementClass: K.WyProgressLinear
}), btt = j({
  react: N,
  tagName: "wy-search",
  elementClass: K.WySearch,
  events: {
    onSearch: "search"
  }
}), $tt = j({
  react: N,
  tagName: "wy-container",
  elementClass: K.WyContainer
}), xtt = j({
  react: N,
  tagName: "wy-skeleton",
  elementClass: K.WySkeleton
}), ktt = j({
  react: N,
  tagName: "wy-titlebar",
  elementClass: K.WyTitlebar
}), Stt = j({
  react: N,
  tagName: "wy-titlebar-text",
  elementClass: K.WyTitlebarText
}), Ctt = j({
  react: N,
  tagName: "wy-toasts",
  elementClass: K.WyToasts,
  events: {
    onHide: "hide"
  }
}), Ptt = j({
  react: N,
  tagName: "wy-toast",
  elementClass: K.WyToast,
  events: {
    onClosed: "closed"
  }
}), Qtt = j({
  react: N,
  tagName: "wy-annotation",
  elementClass: K.WyAnnotation
}), Ttt = j({
  react: N,
  tagName: "wy-annotation-list",
  elementClass: K.WyAnnotationList,
  events: {
    onFileOpen: "file-open"
  }
}), Mtt = j({
  react: N,
  tagName: "wy-attachment",
  elementClass: K.WyAttachment,
  events: {
    onFileOpen: "file-open"
  }
}), Att = j({
  react: N,
  tagName: "wy-attachment-list",
  elementClass: K.WyAttachmentList,
  events: {
    onFileOpen: "file-open"
  }
}), Rtt = j({
  react: N,
  tagName: "wy-upload",
  elementClass: K.WyUpload,
  events: {
    onBlobUploaded: "blob-uploaded"
  }
}), Ett = j({
  react: N,
  tagName: "wy-cloud-files",
  elementClass: K.WyCloudFiles,
  events: {
    onExternalBlobs: "external-blobs"
  }
}), _tt = j({
  react: N,
  tagName: "wy-comment-list",
  elementClass: K.WyCommentList,
  events: {
    onWyPreviewOpen: ri,
    onWyPreviewClose: ai
  }
}), ztt = j({
  react: N,
  tagName: "wy-comment",
  elementClass: K.WyComment,
  events: {
    onVote: "vote",
    onTrash: "trash",
    onRestore: "restore",
    onWyPreviewOpen: ri,
    onWyPreviewClose: ai
  }
}), Ltt = j({
  react: N,
  tagName: "wy-context-data-progress",
  elementClass: K.WyContextDataProgress
}), Itt = j({
  react: N,
  tagName: "wy-conversation",
  elementClass: K.WyConversation,
  events: {
    onWyAction: pe,
    onWyPreviewOpen: ri,
    onWyPreviewClose: ai
  }
}), Wtt = j({
  react: N,
  tagName: "wy-conversation-header",
  elementClass: K.WyConversationHeader,
  events: {
    onWyAction: pe
  }
}), Vtt = j({
  react: N,
  tagName: "wy-conversation-new",
  elementClass: K.WyConversationNew,
  events: {
    onSelected: "create"
  }
}), Dtt = j({
  react: N,
  tagName: "wy-conversation-list",
  elementClass: K.WyConversationList,
  events: {
    onWyAction: pe
  }
}), qtt = j({
  react: N,
  tagName: "wy-conversation-item",
  elementClass: K.WyConversationItem,
  events: {
    onSelected: "selected",
    onStar: "star",
    onPin: "pin",
    onMark: "mark",
    onLeave: "leave",
    onRemove: "remove",
    onTrash: "trash"
  }
}), Ztt = j({
  react: N,
  tagName: "wy-editor",
  elementClass: K.WyEditor,
  events: {
    onSubmit: "submit"
  }
}), Ftt = j({
  react: N,
  tagName: "wy-comment-editor",
  elementClass: K.WyCommentEditor,
  events: {
    onSubmit: "submit"
  }
}), Xtt = j({
  react: N,
  tagName: "wy-message-editor",
  elementClass: K.WyMessageEditor,
  events: {
    onSubmit: "submit"
  }
}), Ntt = j({
  react: N,
  tagName: "wy-embed",
  elementClass: K.WyEmbed,
  events: {
    onWyAction: pe
  }
}), jtt = j({
  react: N,
  tagName: "wy-embed-select",
  elementClass: K.WyEmbedSelect,
  events: {
    onEmbedRemove: "embed-remove",
    onEmbedSwap: "embed-swap"
  }
}), Btt = j({
  react: N,
  tagName: "wy-empty",
  elementClass: K.WyEmpty
}), Utt = j({
  react: N,
  tagName: "wy-file-grid",
  elementClass: K.WyFileGrid,
  events: {
    onFileOpen: "file-open",
    onOrder: "order",
    onEditName: "edit-name",
    onRename: "rename",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever",
    onSubscribe: "subscribe"
  }
}), Htt = j({
  react: N,
  tagName: "wy-file-item",
  elementClass: K.WyFileItem,
  events: {
    onEditName: "edit-name",
    onRename: "rename",
    onSubscribe: "subscribe",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever"
  }
}), Ytt = j({
  react: N,
  tagName: "wy-file-menu",
  elementClass: K.WyFileMenu,
  events: {
    onEditName: "edit-name",
    onSubscribe: "subscribe",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever"
  }
}), Gtt = j({
  react: N,
  tagName: "wy-file-table",
  elementClass: K.WyFileTable,
  events: {
    onFileOpen: "file-open",
    onOrder: "order",
    onEditName: "edit-name",
    onRename: "rename",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever",
    onSubscribe: "subscribe"
  }
}), Ktt = j({
  react: N,
  tagName: "wy-file-versions",
  elementClass: K.WyFileVersions,
  events: {
    onFileVersionSelect: "file-version-select"
  }
}), Jtt = j({
  react: N,
  tagName: "wy-files-header",
  elementClass: K.WyFilesHeader,
  events: {
    onUploadFiles: "upload-files",
    onExternalBlobs: "external-blobs",
    onCreateFiles: "create-files",
    onOrder: "order",
    onView: "view",
    onShowTrashed: "show-trashed",
    onSubscribe: "subscribe"
  }
}), tet = j({
  react: N,
  tagName: "wy-files-list",
  elementClass: K.WyFilesList,
  events: {
    onFileOpen: "file-open",
    onOrder: "order",
    onEditName: "edit-name",
    onRename: "rename",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever",
    onSubscribe: "subscribe",
    onWyAction: pe,
    onWyPreviewOpen: ri,
    onWyPreviewClose: ai
  }
}), eet = j({
  react: N,
  tagName: "wy-meeting-card",
  elementClass: K.WyMeetingCard
}), iet = "vote", net = "typing", set = j({
  react: N,
  tagName: "wy-message",
  elementClass: K.WyMessage,
  events: {
    onVote: iet,
    onWyAction: pe,
    onWyPreviewOpen: ri,
    onWyPreviewClose: ai
  }
}), ret = j({
  react: N,
  tagName: "wy-message-typing",
  elementClass: K.WyMessageTyping,
  events: {
    onTyping: net
  }
}), aet = j({
  react: N,
  tagName: "wy-notification-list",
  elementClass: K.WyNotificationList,
  events: {
    onWyAction: pe
  }
}), oet = j({
  react: N,
  tagName: "wy-notification-header",
  elementClass: K.WyNotificationHeader
}), cet = j({
  react: N,
  tagName: "wy-notification-list-item",
  elementClass: K.WyNotificationListItem,
  events: {
    onSelect: "select",
    onMark: "mark",
    onHide: "hide",
    onClose: "close"
  }
}), het = j({
  react: N,
  tagName: "wy-pdf-viewer",
  elementClass: K.WyPdfViewer,
  events: {
    onFilePreviewLoaded: "file-preview-loaded"
  }
}), det = j({
  react: N,
  tagName: "wy-poll",
  elementClass: K.WyPoll,
  events: {
    onVote: "vote"
  }
}), uet = j({
  react: N,
  tagName: "wy-poll-option",
  elementClass: K.WyPollOption,
  events: {
    onVote: "vote"
  }
}), e3 = "edit", KV = "vote", JV = "subscribe", tD = "trash", eD = "restore", pet = j({
  react: N,
  tagName: "wy-post-list",
  elementClass: K.WyPostList,
  events: {
    onEdit: e3,
    onWyAction: pe,
    onWyPreviewOpen: ri,
    onWyPreviewClose: ai
  }
}), fet = j({
  react: N,
  tagName: "wy-post",
  elementClass: K.WyPost,
  events: {
    onVote: KV,
    onSubscribe: JV,
    onTrash: tD,
    onRestore: eD,
    onWyAction: pe,
    onWyPreviewOpen: ri,
    onWyPreviewClose: ai
  }
}), yet = j({
  react: N,
  tagName: "wy-post-view",
  elementClass: K.WyPostView,
  events: {
    onVote: KV,
    onSubscribe: JV,
    onTrash: tD,
    onEdit: e3,
    onWyAction: pe,
    onWyPreviewOpen: ri,
    onWyPreviewClose: ai
  }
}), met = j({
  react: N,
  tagName: "wy-post-edit",
  elementClass: K.WyPostEdit,
  events: {
    onEdit: e3
  }
}), get = j({
  react: N,
  tagName: "wy-post-trashed",
  elementClass: K.WyPostTrashed,
  events: {
    onRestore: eD
  }
}), Zm = "file-preview-loaded", wet = j({
  react: N,
  tagName: "wy-preview",
  elementClass: K.WyPreview,
  events: {
    onWyPreviewOpen: ri,
    onWyPreviewClose: ai,
    onWyAction: pe
  }
}), vet = j({
  react: N,
  tagName: "wy-preview-embed",
  elementClass: K.WyPreviewEmbed,
  events: {
    onFilePreviewLoaded: Zm
  }
}), Oet = j({
  react: N,
  tagName: "wy-preview-icon",
  elementClass: K.WyPreviewIcon,
  events: {
    onFilePreviewLoaded: Zm
  }
}), bet = j({
  react: N,
  tagName: "wy-preview-image",
  elementClass: K.WyPreviewImage,
  events: {
    onFilePreviewLoaded: Zm
  }
}), $et = j({
  react: N,
  tagName: "wy-preview-item",
  elementClass: K.WyPreviewItem,
  events: {
    onFilePreviewLoaded: Zm
  }
}), xet = j({
  react: N,
  tagName: "wy-preview-media",
  elementClass: K.WyPreviewMedia,
  events: {
    onFilePreviewLoaded: Zm
  }
}), ket = j({
  react: N,
  tagName: "wy-preview-text",
  elementClass: K.WyPreviewText,
  events: {
    onFilePreviewLoaded: Zm
  }
}), Cet = "close", Pet = j({
  react: N,
  tagName: "wy-reactions",
  elementClass: K.WyReactions,
  events: {
    onClose: Cet
  }
}), Qet = j({
  react: N,
  tagName: "wy-reaction-item",
  elementClass: K.WyReactionItem
}), Tet = j({
  react: N,
  tagName: "wy-typing",
  elementClass: K.WyTyping
}), Met = j({
  react: N,
  tagName: "wy-users-search",
  elementClass: K.WyUsersSearch,
  events: {
    onSubmit: "submit"
  }
}), Get = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  WyAnnotation: Qtt,
  WyAnnotationList: Ttt,
  WyAttachment: Mtt,
  WyAttachmentList: Att,
  WyAvatar: ett,
  WyAvatarGroup: itt,
  WyAvatarHeader: ntt,
  WyBadge: att,
  WyButton: stt,
  WyButtons: rtt,
  WyCloudFiles: Ett,
  WyComment: ztt,
  WyCommentEditor: Ftt,
  WyCommentList: _tt,
  WyContainer: $tt,
  WyContextDataProgress: Ltt,
  WyConversation: Itt,
  WyConversationAppbar: Wtt,
  WyConversationItem: qtt,
  WyConversationList: Dtt,
  WyConversationNew: Vtt,
  WyDropdown: ott,
  WyDropdownDivider: htt,
  WyDropdownItem: ltt,
  WyDropdownOption: ctt,
  WyEditor: Ztt,
  WyEmbed: Ntt,
  WyEmbedSelect: jtt,
  WyEmpty: Btt,
  WyFileGrid: Utt,
  WyFileItem: Htt,
  WyFileMenu: Ytt,
  WyFileTable: Gtt,
  WyFileVersions: Ktt,
  WyFilesHeader: Jtt,
  WyFilesList: tet,
  WyIcon: dtt,
  WyIconDisplay: ptt,
  WyIconStack: utt,
  WyImageGrid: ftt,
  WyItem: ytt,
  WyItemList: mtt,
  WyMeetingCard: eet,
  WyMessage: set,
  WyMessageEditor: Xtt,
  WyMessageTyping: ret,
  WyNotificationHeader: oet,
  WyNotificationList: aet,
  WyNotificationListitem: cet,
  WyOverlay: gtt,
  WyPdfViewer: het,
  WyPoll: det,
  WyPollOption: uet,
  WyPost: fet,
  WyPostEdit: met,
  WyPostList: pet,
  WyPostTrashed: get,
  WyPostView: yet,
  WyPresence: wtt,
  WyPreview: wet,
  WyPreviewEmbed: vet,
  WyPreviewIcon: Oet,
  WyPreviewImage: bet,
  WyPreviewItem: $et,
  WyPreviewMedia: xet,
  WyPreviewText: ket,
  WyProgressCircular: vtt,
  WyProgressLinear: Ott,
  WyReactionItem: Qet,
  WyReactions: Pet,
  WySearch: btt,
  WySkeleton: xtt,
  WyTitlebar: ktt,
  WyTitlebarText: Stt,
  WyToast: Ptt,
  WyToasts: Ctt,
  WyTyping: Tet,
  WyUpload: Rtt,
  WyUsersSearch: Met
}, Symbol.toStringTag, { value: "Module" }));
export {
  LB as AppTypeGuids,
  IB as AppTypeStrings,
  z as Feature,
  Eet as MessengerTypes,
  Se as Weavy,
  Get as WeavyComponents,
  HJ as WeavyContext,
  zet as WyChat,
  Let as WyComments,
  Iet as WyComponent,
  Wet as WyContext,
  Vet as WyCopilot,
  Det as WyFiles,
  qet as WyMessenger,
  Zet as WyMessengerBadge,
  Fet as WyMessengerButton,
  Xet as WyMessengerConversations,
  Net as WyMessengerNew,
  Bet as WyNotificationBadge,
  Uet as WyNotificationButton,
  Het as WyNotificationToasts,
  jet as WyNotifications,
  Yet as WyPosts,
  _et as useWeavy,
  GJ as useWeavyContext
};
