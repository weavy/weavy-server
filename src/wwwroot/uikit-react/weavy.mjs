"use client";
var EZ = Object.defineProperty;
var c = (n, t) => EZ(n, "name", { value: t, configurable: !0 });
import Y, { createContext as _Z, useState as NC, useMemo as HC, useEffect as v$, useRef as zZ } from "react";
var LZ = Object.defineProperty, f = /* @__PURE__ */ c((n, t) => LZ(n, "name", { value: t, configurable: !0 }), "c");
const Hk = /* @__PURE__ */ f((n) => {
  n && requestAnimationFrame(() => n?.focus?.());
}, "autofocusRef");
async function rl(n, t = "wy-") {
  const e = [];
  for (let i = n; i = i.parentElement; )
    i.matches(":not(:defined)") && i.localName.startsWith(t) && e.push(customElements.whenDefined(i.localName));
  await Promise.all(e);
}
c(rl, "Nw$1");
f(rl, "whenParentsDefined");
const f9 = /* @__PURE__ */ f((n, t) => {
  let e;
  const i = new ResizeObserver(() => {
    const { isConnected: s } = n;
    s !== e && (e = s, t(s, n));
  });
  return i.observe(n), i;
}, "observeConnected");
async function Yk(n, t = !0) {
  if (n.isConnected === t)
    return t;
  {
    let e;
    const i = new Promise((r) => e = r), s = f9(n, (r) => {
      r === t && e?.(t);
    });
    return await i, s.disconnect(), t;
  }
}
c(Yk, "Gw$1");
f(Yk, "whenConnected");
async function y9() {
  ii(), document.hidden && await new Promise((n) => {
    window.addEventListener(
      "visibilitychange",
      () => {
        document.hidden || n(!0);
      },
      { once: !0 }
    );
  });
}
c(y9, "Hw$1");
f(y9, "whenDocumentVisible");
const Gk = {
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  /* @ts-ignore */
  opacityProperty: !0,
  visibilityProperty: !0,
  // Legacy compatibility
  checkOpacity: !0,
  checkVisibilityCSS: !0
};
function Kk(n, t = !0, e = Gk, i) {
  n.checkVisibility(e) === t ? i(t) : requestAnimationFrame(() => Kk(n, t, e, i));
}
c(Kk, "Cd$1");
f(Kk, "untilVisibility");
async function X1(n, t = !0, e = Gk) {
  n.checkVisibility(e) !== t && await new Promise((i) => {
    Kk(n, t, e, i);
  });
}
c(X1, "Fw$1");
f(X1, "whenElementVisible");
function b$(n) {
  return n.getRootNode() instanceof ShadowRoot;
}
c(b$, "Kw$1");
f(b$, "isInShadowDom");
function N1() {
  return !!(document.body?.showPopover && !/native code/i.test(document.body.showPopover.toString()));
}
c(N1, "Jw$1");
f(N1, "isPopoverPolyfilled");
function ub() {
  return typeof window < "u";
}
c(ub, "ex$1");
f(ub, "isDomAvailable");
function ii() {
  if (typeof window > "u")
    throw Error("DOM not available");
}
c(ii, "Ed$1");
f(ii, "throwOnDomNotAvailable");
let O$ = [], m9 = [];
(() => {
  let n = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t) => t ? parseInt(t, 36) : 1);
  for (let t = 0, e = 0; t < n.length; t++)
    (t % 2 ? m9 : O$).push(e = e + n[t]);
})();
function w9(n) {
  if (n < 768) return !1;
  for (let t = 0, e = O$.length; ; ) {
    let i = t + e >> 1;
    if (n < O$[i]) e = i;
    else if (n >= m9[i]) t = i + 1;
    else return !0;
    if (t == e) return !1;
  }
}
c(w9, "wg$1");
f(w9, "isExtendingChar");
function $$(n) {
  return n >= 127462 && n <= 127487;
}
c($$, "Ac$1");
f($$, "isRegionalIndicator");
const YC = 8205;
function g9(n, t, e = !0, i = !0) {
  return (e ? Jk : v9)(n, t, i);
}
c(g9, "xg$1");
f(g9, "findClusterBreak$1");
function Jk(n, t, e) {
  if (t == n.length) return t;
  t && t5(n.charCodeAt(t)) && e5(n.charCodeAt(t - 1)) && t--;
  let i = Jg(n, t);
  for (t += x$(i); t < n.length; ) {
    let s = Jg(n, t);
    if (i == YC || s == YC || e && w9(s))
      t += x$(s), i = s;
    else if ($$(s)) {
      let r = 0, a = t - 2;
      for (; a >= 0 && $$(Jg(n, a)); )
        r++, a -= 2;
      if (r % 2 == 0) break;
      t += 2;
    } else
      break;
  }
  return t;
}
c(Jk, "Ud$1");
f(Jk, "nextClusterBreak");
function v9(n, t, e) {
  for (; t > 0; ) {
    let i = Jk(n, t - 2, e);
    if (i < t) return i;
    t--;
  }
  return 0;
}
c(v9, "kg$1");
f(v9, "prevClusterBreak");
function Jg(n, t) {
  let e = n.charCodeAt(t);
  if (!e5(e) || t + 1 == n.length) return e;
  let i = n.charCodeAt(t + 1);
  return t5(i) ? (e - 55296 << 10) + (i - 56320) + 65536 : e;
}
c(Jg, "Po$1");
f(Jg, "codePointAt$1");
function t5(n) {
  return n >= 56320 && n < 57344;
}
c(t5, "Wd$1");
f(t5, "surrogateLow$1");
function e5(n) {
  return n >= 55296 && n < 56320;
}
c(e5, "Xd");
f(e5, "surrogateHigh$1");
function x$(n) {
  return n < 65536 ? 1 : 2;
}
c(x$, "Lc$1");
f(x$, "codePointSize$1");
var Ga;
const b9 = (Ga = class {
  /**
  Get the line description around the given position.
  */
  lineAt(t) {
    if (t < 0 || t > this.length)
      throw new RangeError(`Invalid position ${t} in document of length ${this.length}`);
    return this.lineInner(t, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(t) {
    if (t < 1 || t > this.lines)
      throw new RangeError(`Invalid line number ${t} in ${this.lines}-line document`);
    return this.lineInner(t, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(t, e, i) {
    [t, e] = Lo(this, t, e);
    let s = [];
    return this.decompose(
      0,
      t,
      s,
      2
      /* Open.To */
    ), i.length && i.decompose(
      0,
      i.length,
      s,
      3
      /* Open.To */
    ), this.decompose(
      e,
      this.length,
      s,
      1
      /* Open.From */
    ), t1.from(s, this.length - (e - t) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(t) {
    return this.replace(this.length, this.length, t);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(t, e = this.length) {
    [t, e] = Lo(this, t, e);
    let i = [];
    return this.decompose(t, e, i, 0), t1.from(i, e - t);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(t) {
    if (t == this)
      return !0;
    if (t.length != this.length || t.lines != this.lines)
      return !1;
    let e = this.scanIdentical(t, 1), i = this.length - this.scanIdentical(t, -1), s = new Jm(this), r = new Jm(t);
    for (let a = e, o = e; ; ) {
      if (s.next(a), r.next(a), a = 0, s.lineBreak != r.lineBreak || s.done != r.done || s.value != r.value)
        return !1;
      if (o += s.value.length, s.done || o >= i)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(t = 1) {
    return new Jm(this, t);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(t, e = this.length) {
    return new P9(this, t, e);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(t, e) {
    let i;
    if (t == null)
      i = this.iter();
    else {
      e == null && (e = this.lines + 1);
      let s = this.line(t).from;
      i = this.iterRange(s, Math.max(s, e == this.lines + 1 ? this.length : e <= 1 ? 0 : this.line(e - 1).to));
    }
    return new Q9(i);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let t = [];
    return this.flatten(t), t;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(t) {
    if (t.length == 0)
      throw new RangeError("A document must have at least one line");
    return t.length == 1 && !t[0] ? Ga.empty : t.length <= 32 ? new mn(t) : t1.from(mn.split(t, []));
  }
}, c(Ga, "Ws"), Ga);
f(b9, "Text");
let Vt = b9;
var fi;
const O9 = (fi = class extends Vt {
  constructor(t, e = x9(t)) {
    super(), this.text = t, this.length = e;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(t, e, i, s) {
    for (let r = 0; ; r++) {
      let a = this.text[r], o = s + a.length;
      if ((e ? i : o) >= t)
        return new IZ(s, o, i, a);
      s = o + 1, i++;
    }
  }
  decompose(t, e, i, s) {
    let r = t <= 0 && e >= this.length ? this : new fi(k$(this.text, t, e), Math.min(e, this.length) - Math.max(0, t));
    if (s & 1) {
      let a = i.pop(), o = Km(r.text, a.text.slice(), 0, r.length);
      if (o.length <= 32)
        i.push(new fi(o, a.length + r.length));
      else {
        let l = o.length >> 1;
        i.push(new fi(o.slice(0, l)), new fi(o.slice(l)));
      }
    } else
      i.push(r);
  }
  replace(t, e, i) {
    if (!(i instanceof fi))
      return super.replace(t, e, i);
    [t, e] = Lo(this, t, e);
    let s = Km(this.text, Km(i.text, k$(this.text, 0, t)), e), r = this.length + i.length - (e - t);
    return s.length <= 32 ? new fi(s, r) : t1.from(fi.split(s, []), r);
  }
  sliceString(t, e = this.length, i = `
`) {
    [t, e] = Lo(this, t, e);
    let s = "";
    for (let r = 0, a = 0; r <= e && a < this.text.length; a++) {
      let o = this.text[a], l = r + o.length;
      r > t && a && (s += i), t < l && e > r && (s += o.slice(Math.max(0, t - r), e - r)), r = l + 1;
    }
    return s;
  }
  flatten(t) {
    for (let e of this.text)
      t.push(e);
  }
  scanIdentical() {
    return 0;
  }
  static split(t, e) {
    let i = [], s = -1;
    for (let r of t)
      i.push(r), s += r.length + 1, i.length == 32 && (e.push(new fi(i, s)), i = [], s = -1);
    return s > -1 && e.push(new fi(i, s)), e;
  }
}, c(fi, "Ze"), fi);
f(O9, "TextLeaf");
let mn = O9;
var fn;
const $9 = (fn = class extends Vt {
  constructor(t, e) {
    super(), this.children = t, this.length = e, this.lines = 0;
    for (let i of t)
      this.lines += i.lines;
  }
  lineInner(t, e, i, s) {
    for (let r = 0; ; r++) {
      let a = this.children[r], o = s + a.length, l = i + a.lines - 1;
      if ((e ? l : o) >= t)
        return a.lineInner(t, e, i, s);
      s = o + 1, i = l + 1;
    }
  }
  decompose(t, e, i, s) {
    for (let r = 0, a = 0; a <= e && r < this.children.length; r++) {
      let o = this.children[r], l = a + o.length;
      if (t <= l && e >= a) {
        let h = s & ((a <= t ? 1 : 0) | (l >= e ? 2 : 0));
        a >= t && l <= e && !h ? i.push(o) : o.decompose(t - a, e - a, i, h);
      }
      a = l + 1;
    }
  }
  replace(t, e, i) {
    if ([t, e] = Lo(this, t, e), i.lines < this.lines)
      for (let s = 0, r = 0; s < this.children.length; s++) {
        let a = this.children[s], o = r + a.length;
        if (t >= r && e <= o) {
          let l = a.replace(t - r, e - r, i), h = this.lines - a.lines + l.lines;
          if (l.lines < h >> 4 && l.lines > h >> 6) {
            let u = this.children.slice();
            return u[s] = l, new fn(u, this.length - (e - t) + i.length);
          }
          return super.replace(r, o, l);
        }
        r = o + 1;
      }
    return super.replace(t, e, i);
  }
  sliceString(t, e = this.length, i = `
`) {
    [t, e] = Lo(this, t, e);
    let s = "";
    for (let r = 0, a = 0; r < this.children.length && a <= e; r++) {
      let o = this.children[r], l = a + o.length;
      a > t && r && (s += i), t < l && e > a && (s += o.sliceString(t - a, e - a, i)), a = l + 1;
    }
    return s;
  }
  flatten(t) {
    for (let e of this.children)
      e.flatten(t);
  }
  scanIdentical(t, e) {
    if (!(t instanceof fn))
      return 0;
    let i = 0, [s, r, a, o] = e > 0 ? [0, 0, this.children.length, t.children.length] : [this.children.length - 1, t.children.length - 1, -1, -1];
    for (; ; s += e, r += e) {
      if (s == a || r == o)
        return i;
      let l = this.children[s], h = t.children[r];
      if (l != h)
        return i + l.scanIdentical(h, e);
      i += l.length + 1;
    }
  }
  static from(t, e = t.reduce((i, s) => i + s.length + 1, -1)) {
    let i = 0;
    for (let m of t)
      i += m.lines;
    if (i < 32) {
      let m = [];
      for (let w of t)
        w.flatten(m);
      return new mn(m, e);
    }
    let s = Math.max(
      32,
      i >> 5
      /* Tree.BranchShift */
    ), r = s << 1, a = s >> 1, o = [], l = 0, h = -1, u = [];
    function p(m) {
      let w;
      if (m.lines > r && m instanceof fn)
        for (let b of m.children)
          p(b);
      else m.lines > a && (l > a || !l) ? (y(), o.push(m)) : m instanceof mn && l && (w = u[u.length - 1]) instanceof mn && m.lines + w.lines <= 32 ? (l += m.lines, h += m.length + 1, u[u.length - 1] = new mn(w.text.concat(m.text), w.length + 1 + m.length)) : (l + m.lines > s && y(), l += m.lines, h += m.length + 1, u.push(m));
    }
    c(p, "u"), f(p, "add");
    function y() {
      l != 0 && (o.push(u.length == 1 ? u[0] : fn.from(u, h)), h = -1, l = u.length = 0);
    }
    c(y, "d"), f(y, "flush");
    for (let m of t)
      p(m);
    return y(), o.length == 1 ? o[0] : new fn(o, e);
  }
}, c(fn, "yt"), fn);
f($9, "TextNode");
let t1 = $9;
Vt.empty = /* @__PURE__ */ new mn([""], 0);
function x9(n) {
  let t = -1;
  for (let e of n)
    t += e.length + 1;
  return t;
}
c(x9, "Pg$1");
f(x9, "textLength");
function Km(n, t, e = 0, i = 1e9) {
  for (let s = 0, r = 0, a = !0; r < n.length && s <= i; r++) {
    let o = n[r], l = s + o.length;
    l >= e && (l > i && (o = o.slice(0, i - s)), s < e && (o = o.slice(e - s)), a ? (t[t.length - 1] += o, a = !1) : t.push(o)), s = l + 1;
  }
  return t;
}
c(Km, "Bn$1");
f(Km, "appendText");
function k$(n, t, e) {
  return Km(n, [""], t, e);
}
c(k$, "Mc$1");
f(k$, "sliceText");
var Nc;
const k9 = (Nc = class {
  constructor(t, e = 1) {
    this.dir = e, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [t], this.offsets = [e > 0 ? 1 : (t instanceof mn ? t.text.length : t.children.length) << 1];
  }
  nextInner(t, e) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, s = this.nodes[i], r = this.offsets[i], a = r >> 1, o = s instanceof mn ? s.text.length : s.children.length;
      if (a == (e > 0 ? o : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        e > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((r & 1) == (e > 0 ? 0 : 1)) {
        if (this.offsets[i] += e, t == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        t--;
      } else if (s instanceof mn) {
        let l = s.text[a + (e < 0 ? -1 : 0)];
        if (this.offsets[i] += e, l.length > Math.max(0, t))
          return this.value = t == 0 ? l : e > 0 ? l.slice(t) : l.slice(0, l.length - t), this;
        t -= l.length;
      } else {
        let l = s.children[a + (e < 0 ? -1 : 0)];
        t > l.length ? (t -= l.length, this.offsets[i] += e) : (e < 0 && this.offsets[i]--, this.nodes.push(l), this.offsets.push(e > 0 ? 1 : (l instanceof mn ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(t = 0) {
    return t < 0 && (this.nextInner(-t, -this.dir), t = this.value.length), this.nextInner(t, this.dir);
  }
}, c(Nc, "Eh"), Nc);
f(k9, "RawTextCursor");
let Jm = k9;
var Hc;
const S9 = (Hc = class {
  constructor(t, e, i) {
    this.value = "", this.done = !1, this.cursor = new Jm(t, e > i ? -1 : 1), this.pos = e > i ? t.length : 0, this.from = Math.min(e, i), this.to = Math.max(e, i);
  }
  nextInner(t, e) {
    if (e < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    t += Math.max(0, e < 0 ? this.pos - this.to : this.from - this.pos);
    let i = e < 0 ? this.pos - this.from : this.to - this.pos;
    t > i && (t = i), i -= t;
    let { value: s } = this.cursor.next(t);
    return this.pos += (s.length + t) * e, this.value = s.length <= i ? s : e < 0 ? s.slice(s.length - i) : s.slice(0, i), this.done = !this.value, this;
  }
  next(t = 0) {
    return t < 0 ? t = Math.max(t, this.from - this.pos) : t > 0 && (t = Math.min(t, this.to - this.pos)), this.nextInner(t, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}, c(Hc, "Vh"), Hc);
f(S9, "PartialTextCursor");
let P9 = S9;
var Yc;
const C9 = (Yc = class {
  constructor(t) {
    this.inner = t, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(t = 0) {
    let { done: e, lineBreak: i, value: s } = this.inner.next(t);
    return e && this.afterBreak ? (this.value = "", this.afterBreak = !1) : e ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = s, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}, c(Yc, "Uh"), Yc);
f(C9, "LineCursor");
let Q9 = C9;
typeof Symbol < "u" && (Vt.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Jm.prototype[Symbol.iterator] = P9.prototype[Symbol.iterator] = Q9.prototype[Symbol.iterator] = function() {
  return this;
});
var yO, Gc;
let IZ = (yO = (Gc = class {
  /**
  @internal
  */
  constructor(t, e, i, s) {
    this.from = t, this.to = e, this.number = i, this.text = s;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}, c(Gc, "Ti$1"), Gc), f(yO, "Line"), yO);
function Lo(n, t, e) {
  return t = Math.max(0, Math.min(n.length, t)), [t, Math.max(t, Math.min(n.length, e))];
}
c(Lo, "Vi$1");
f(Lo, "clip");
function wn(n, t, e = !0, i = !0) {
  return g9(n, t, e, i);
}
c(wn, "pe$2");
f(wn, "findClusterBreak");
function M9(n) {
  return n >= 56320 && n < 57344;
}
c(M9, "$g$1");
f(M9, "surrogateLow");
function T9(n) {
  return n >= 55296 && n < 56320;
}
c(T9, "vg$1");
f(T9, "surrogateHigh");
function pr(n, t) {
  let e = n.charCodeAt(t);
  if (!T9(e) || t + 1 == n.length)
    return e;
  let i = n.charCodeAt(t + 1);
  return M9(i) ? (e - 55296 << 10) + (i - 56320) + 65536 : e;
}
c(pr, "Wt$2");
f(pr, "codePointAt");
function A9(n) {
  return n <= 65535 ? String.fromCharCode(n) : (n -= 65536, String.fromCharCode((n >> 10) + 55296, (n & 1023) + 56320));
}
c(A9, "Tg$1");
f(A9, "fromCodePoint");
function Wa(n) {
  return n < 65536 ? 1 : 2;
}
c(Wa, "ui$1");
f(Wa, "codePointSize");
const S$ = /\r\n?|\n/;
var wi = /* @__PURE__ */ function(n) {
  return n[n.Simple = 0] = "Simple", n[n.TrackDel = 1] = "TrackDel", n[n.TrackBefore = 2] = "TrackBefore", n[n.TrackAfter = 3] = "TrackAfter", n;
}(wi || (wi = {})), Ts;
const R9 = (Ts = class {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(t) {
    this.sections = t;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let t = 0;
    for (let e = 0; e < this.sections.length; e += 2)
      t += this.sections[e];
    return t;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let t = 0;
    for (let e = 0; e < this.sections.length; e += 2) {
      let i = this.sections[e + 1];
      t += i < 0 ? this.sections[e] : i;
    }
    return t;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(t) {
    for (let e = 0, i = 0, s = 0; e < this.sections.length; ) {
      let r = this.sections[e++], a = this.sections[e++];
      a < 0 ? (t(i, s, r), s += r) : s += a, i += r;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(t, e = !1) {
    H1(this, t, e);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let t = [];
    for (let e = 0; e < this.sections.length; ) {
      let i = this.sections[e++], s = this.sections[e++];
      s < 0 ? t.push(i, s) : t.push(s, i);
    }
    return new Ts(t);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(t) {
    return this.empty ? t : t.empty ? this : i5(this, t);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(t, e = !1) {
    return t.empty ? this : Y1(this, t, e);
  }
  mapPos(t, e = -1, i = wi.Simple) {
    let s = 0, r = 0;
    for (let a = 0; a < this.sections.length; ) {
      let o = this.sections[a++], l = this.sections[a++], h = s + o;
      if (l < 0) {
        if (h > t)
          return r + (t - s);
        r += o;
      } else {
        if (i != wi.Simple && h >= t && (i == wi.TrackDel && s < t && h > t || i == wi.TrackBefore && s < t || i == wi.TrackAfter && h > t))
          return null;
        if (h > t || h == t && e < 0 && !o)
          return t == s || e < 0 ? r : r + l;
        r += l;
      }
      s = h;
    }
    if (t > s)
      throw new RangeError(`Position ${t} is out of range for changeset of length ${s}`);
    return r;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(t, e = t) {
    for (let i = 0, s = 0; i < this.sections.length && s <= e; ) {
      let r = this.sections[i++], a = this.sections[i++], o = s + r;
      if (a >= 0 && s <= e && o >= t)
        return s < t && o > e ? "cover" : !0;
      s = o;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let t = "";
    for (let e = 0; e < this.sections.length; ) {
      let i = this.sections[e++], s = this.sections[e++];
      t += (t ? " " : "") + i + (s >= 0 ? ":" + s : "");
    }
    return t;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2 || t.some((e) => typeof e != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Ts(t);
  }
  /**
  @internal
  */
  static create(t) {
    return new Ts(t);
  }
}, c(Ts, "yi"), Ts);
f(R9, "ChangeDesc");
let zc = R9;
var Di;
const E9 = (Di = class extends zc {
  constructor(t, e) {
    super(t), this.inserted = e;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(t) {
    if (this.length != t.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return H1(this, (e, i, s, r, a) => t = t.replace(s, s + (i - e), a), !1), t;
  }
  mapDesc(t, e = !1) {
    return Y1(this, t, e, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(t) {
    let e = this.sections.slice(), i = [];
    for (let s = 0, r = 0; s < e.length; s += 2) {
      let a = e[s], o = e[s + 1];
      if (o >= 0) {
        e[s] = o, e[s + 1] = a;
        let l = s >> 1;
        for (; i.length < l; )
          i.push(Vt.empty);
        i.push(a ? t.slice(r, r + a) : Vt.empty);
      }
      r += a;
    }
    return new Di(e, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(t) {
    return this.empty ? t : t.empty ? this : i5(this, t, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(t, e = !1) {
    return t.empty ? this : Y1(this, t, e, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(t, e = !1) {
    H1(this, t, e);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return zc.create(this.sections);
  }
  /**
  @internal
  */
  filter(t) {
    let e = [], i = [], s = [], r = new hw(this);
    t: for (let a = 0, o = 0; ; ) {
      let l = a == t.length ? 1e9 : t[a++];
      for (; o < l || o == l && r.len == 0; ) {
        if (r.done)
          break t;
        let u = Math.min(r.len, l - o);
        Je(s, u, -1);
        let p = r.ins == -1 ? -1 : r.off == 0 ? r.ins : 0;
        Je(e, u, p), p > 0 && ks(i, e, r.text), r.forward(u), o += u;
      }
      let h = t[a++];
      for (; o < h; ) {
        if (r.done)
          break t;
        let u = Math.min(r.len, h - o);
        Je(e, u, -1), Je(s, u, r.ins == -1 ? -1 : r.off == 0 ? r.ins : 0), r.forward(u), o += u;
      }
    }
    return {
      changes: new Di(e, i),
      filtered: zc.create(s)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let t = [];
    for (let e = 0; e < this.sections.length; e += 2) {
      let i = this.sections[e], s = this.sections[e + 1];
      s < 0 ? t.push(i) : s == 0 ? t.push([i]) : t.push([i].concat(this.inserted[e >> 1].toJSON()));
    }
    return t;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(t, e, i) {
    let s = [], r = [], a = 0, o = null;
    function l(u = !1) {
      if (!u && !s.length)
        return;
      a < e && Je(s, e - a, -1);
      let p = new Di(s, r);
      o = o ? o.compose(p.map(o)) : p, s = [], r = [], a = 0;
    }
    c(l, "a"), f(l, "flush");
    function h(u) {
      if (Array.isArray(u))
        for (let p of u)
          h(p);
      else if (u instanceof Di) {
        if (u.length != e)
          throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${e})`);
        l(), o = o ? o.compose(u.map(o)) : u;
      } else {
        let { from: p, to: y = p, insert: m } = u;
        if (p > y || p < 0 || y > e)
          throw new RangeError(`Invalid change range ${p} to ${y} (in doc of length ${e})`);
        let w = m ? typeof m == "string" ? Vt.of(m.split(i || S$)) : m : Vt.empty, b = w.length;
        if (p == y && b == 0)
          return;
        p < a && l(), p > a && Je(s, p - a, -1), Je(s, y - p, b), ks(r, s, w), a = y;
      }
    }
    return c(h, "h"), f(h, "process"), h(t), l(!o), o;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(t) {
    return new Di(t ? [t, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(t) {
    if (!Array.isArray(t))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let e = [], i = [];
    for (let s = 0; s < t.length; s++) {
      let r = t[s];
      if (typeof r == "number")
        e.push(r, -1);
      else {
        if (!Array.isArray(r) || typeof r[0] != "number" || r.some((a, o) => o && typeof a != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (r.length == 1)
          e.push(r[0], 0);
        else {
          for (; i.length < s; )
            i.push(Vt.empty);
          i[s] = Vt.of(r.slice(1)), e.push(r[0], i[s].length);
        }
      }
    }
    return new Di(e, i);
  }
  /**
  @internal
  */
  static createSet(t, e) {
    return new Di(t, e);
  }
}, c(Di, "Ke"), Di);
f(E9, "ChangeSet");
let $n = E9;
function Je(n, t, e, i = !1) {
  if (t == 0 && e <= 0)
    return;
  let s = n.length - 2;
  s >= 0 && e <= 0 && e == n[s + 1] ? n[s] += t : s >= 0 && t == 0 && n[s] == 0 ? n[s + 1] += e : i ? (n[s] += t, n[s + 1] += e) : n.push(t, e);
}
c(Je, "ae$2");
f(Je, "addSection");
function ks(n, t, e) {
  if (e.length == 0)
    return;
  let i = t.length - 2 >> 1;
  if (i < n.length)
    n[n.length - 1] = n[n.length - 1].append(e);
  else {
    for (; n.length < i; )
      n.push(Vt.empty);
    n.push(e);
  }
}
c(ks, "St$2");
f(ks, "addInsert");
function H1(n, t, e) {
  let i = n.inserted;
  for (let s = 0, r = 0, a = 0; a < n.sections.length; ) {
    let o = n.sections[a++], l = n.sections[a++];
    if (l < 0)
      s += o, r += o;
    else {
      let h = s, u = r, p = Vt.empty;
      for (; h += o, u += l, l && i && (p = p.append(i[a - 2 >> 1])), !(e || a == n.sections.length || n.sections[a + 1] < 0); )
        o = n.sections[a++], l = n.sections[a++];
      t(s, h, r, u, p), s = h, r = u;
    }
  }
}
c(H1, "nl$1");
f(H1, "iterChanges");
function Y1(n, t, e, i = !1) {
  let s = [], r = i ? [] : null, a = new hw(n), o = new hw(t);
  for (let l = -1; ; ) {
    if (a.done && o.len || o.done && a.len)
      throw new Error("Mismatched change set lengths");
    if (a.ins == -1 && o.ins == -1) {
      let h = Math.min(a.len, o.len);
      Je(s, h, -1), a.forward(h), o.forward(h);
    } else if (o.ins >= 0 && (a.ins < 0 || l == a.i || a.off == 0 && (o.len < a.len || o.len == a.len && !e))) {
      let h = o.len;
      for (Je(s, o.ins, -1); h; ) {
        let u = Math.min(a.len, h);
        a.ins >= 0 && l < a.i && a.len <= u && (Je(s, 0, a.ins), r && ks(r, s, a.text), l = a.i), a.forward(u), h -= u;
      }
      o.next();
    } else if (a.ins >= 0) {
      let h = 0, u = a.len;
      for (; u; )
        if (o.ins == -1) {
          let p = Math.min(u, o.len);
          h += p, u -= p, o.forward(p);
        } else if (o.ins == 0 && o.len < u)
          u -= o.len, o.next();
        else
          break;
      Je(s, h, l < a.i ? a.ins : 0), r && l < a.i && ks(r, s, a.text), l = a.i, a.forward(a.len - u);
    } else {
      if (a.done && o.done)
        return r ? $n.createSet(s, r) : zc.create(s);
      throw new Error("Mismatched change set lengths");
    }
  }
}
c(Y1, "sl$1");
f(Y1, "mapSet");
function i5(n, t, e = !1) {
  let i = [], s = e ? [] : null, r = new hw(n), a = new hw(t);
  for (let o = !1; ; ) {
    if (r.done && a.done)
      return s ? $n.createSet(i, s) : zc.create(i);
    if (r.ins == 0)
      Je(i, r.len, 0, o), r.next();
    else if (a.len == 0 && !a.done)
      Je(i, 0, a.ins, o), s && ks(s, i, a.text), a.next();
    else {
      if (r.done || a.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(r.len2, a.len), h = i.length;
        if (r.ins == -1) {
          let u = a.ins == -1 ? -1 : a.off ? 0 : a.ins;
          Je(i, l, u, o), s && u && ks(s, i, a.text);
        } else a.ins == -1 ? (Je(i, r.off ? 0 : r.len, l, o), s && ks(s, i, r.textBit(l))) : (Je(i, r.off ? 0 : r.len, a.off ? 0 : a.ins, o), s && !a.off && ks(s, i, a.text));
        o = (r.ins > l || a.ins >= 0 && a.len > l) && (o || i.length > h), r.forward2(l), a.forward(l);
      }
    }
  }
}
c(i5, "Yd");
f(i5, "composeSets");
var Kc;
const _9 = (Kc = class {
  constructor(t) {
    this.set = t, this.i = 0, this.next();
  }
  next() {
    let { sections: t } = this.set;
    this.i < t.length ? (this.len = t[this.i++], this.ins = t[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: t } = this.set, e = this.i - 2 >> 1;
    return e >= t.length ? Vt.empty : t[e];
  }
  textBit(t) {
    let { inserted: e } = this.set, i = this.i - 2 >> 1;
    return i >= e.length && !t ? Vt.empty : e[i].slice(this.off, t == null ? void 0 : this.off + t);
  }
  forward(t) {
    t == this.len ? this.next() : (this.len -= t, this.off += t);
  }
  forward2(t) {
    this.ins == -1 ? this.forward(t) : t == this.ins ? this.next() : (this.ins -= t, this.off += t);
  }
}, c(Kc, "Wh"), Kc);
f(_9, "SectionIter");
let hw = _9;
var Cr;
const z9 = (Cr = class {
  constructor(t, e, i) {
    this.from = t, this.to = e, this.flags = i;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let t = this.flags & 7;
    return t == 7 ? null : t;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let t = this.flags >> 6;
    return t == 16777215 ? void 0 : t;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(t, e = -1) {
    let i, s;
    return this.empty ? i = s = t.mapPos(this.from, e) : (i = t.mapPos(this.from, 1), s = t.mapPos(this.to, -1)), i == this.from && s == this.to ? this : new Cr(i, s, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(t, e = t) {
    if (t <= this.anchor && e >= this.anchor)
      return J.range(t, e);
    let i = Math.abs(t - this.anchor) > Math.abs(e - this.anchor) ? t : e;
    return J.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(t, e = !1) {
    return this.anchor == t.anchor && this.head == t.head && (!e || !this.empty || this.assoc == t.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(t) {
    if (!t || typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return J.range(t.anchor, t.head);
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new Cr(t, e, i);
  }
}, c(Cr, "$r"), Cr);
f(z9, "SelectionRange");
let Cg = z9;
var De;
const L9 = (De = class {
  constructor(t, e) {
    this.ranges = t, this.mainIndex = e;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(t, e = -1) {
    return t.empty ? this : De.create(this.ranges.map((i) => i.map(t, e)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(t, e = !1) {
    if (this.ranges.length != t.ranges.length || this.mainIndex != t.mainIndex)
      return !1;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(t.ranges[i], e))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new De([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(t, e = !0) {
    return De.create([t].concat(this.ranges), e ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(t, e = this.mainIndex) {
    let i = this.ranges.slice();
    return i[e] = t, De.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((t) => t.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(t) {
    if (!t || !Array.isArray(t.ranges) || typeof t.main != "number" || t.main >= t.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new De(t.ranges.map((e) => Cg.fromJSON(e)), t.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(t, e = t) {
    return new De([De.range(t, e)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(t, e = 0) {
    if (t.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, s = 0; s < t.length; s++) {
      let r = t[s];
      if (r.empty ? r.from <= i : r.from < i)
        return De.normalized(t.slice(), e);
      i = r.to;
    }
    return new De(t, e);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(t, e = 0, i, s) {
    return Cg.create(t, t, (e == 0 ? 0 : e < 0 ? 8 : 16) | (i == null ? 7 : Math.min(6, i)) | (s ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(t, e, i, s) {
    let r = (i ?? 16777215) << 6 | (s == null ? 7 : Math.min(6, s));
    return e < t ? Cg.create(e, t, 48 | r) : Cg.create(t, e, (e > t ? 8 : 0) | r);
  }
  /**
  @internal
  */
  static normalized(t, e = 0) {
    let i = t[e];
    t.sort((s, r) => s.from - r.from), e = t.indexOf(i);
    for (let s = 1; s < t.length; s++) {
      let r = t[s], a = t[s - 1];
      if (r.empty ? r.from <= a.to : r.from < a.to) {
        let o = a.from, l = Math.max(r.to, a.to);
        s <= e && e--, t.splice(--s, 2, r.anchor > r.head ? De.range(l, o) : De.range(o, l));
      }
    }
    return new De(t, e);
  }
}, c(De, "fe"), De);
f(L9, "EditorSelection");
let J = L9;
function n5(n, t) {
  for (let e of n.ranges)
    if (e.to > t)
      throw new RangeError("Selection points outside of document");
}
c(n5, "Id$1");
f(n5, "checkSelection");
let s5 = 0;
var Ka;
const I9 = (Ka = class {
  constructor(t, e, i, s, r) {
    this.combine = t, this.compareInput = e, this.compare = i, this.isStatic = s, this.id = s5++, this.default = t([]), this.extensions = typeof r == "function" ? r(this) : r;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(t = {}) {
    return new Ka(t.combine || ((e) => e), t.compareInput || ((e, i) => e === i), t.compare || (t.combine ? (e, i) => e === i : pb), !!t.static, t.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(t) {
    return new e1([], this, 0, t);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(t, e) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new e1(t, this, 1, e);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(t, e) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new e1(t, this, 2, e);
  }
  from(t, e) {
    return e || (e = /* @__PURE__ */ f((i) => i, "get")), this.compute([t], (i) => e(i.field(t)));
  }
}, c(Ka, "Xs"), Ka);
f(I9, "Facet");
let gt = I9;
function pb(n, t) {
  return n == t || n.length == t.length && n.every((e, i) => e === t[i]);
}
c(pb, "ih");
f(pb, "sameArray$1");
var Jc;
const Z9 = (Jc = class {
  constructor(t, e, i, s) {
    this.dependencies = t, this.facet = e, this.type = i, this.value = s, this.id = s5++;
  }
  dynamicSlot(t) {
    var e;
    let i = this.value, s = this.facet.compareInput, r = this.id, a = t[r] >> 1, o = this.type == 2, l = !1, h = !1, u = [];
    for (let p of this.dependencies)
      p == "doc" ? l = !0 : p == "selection" ? h = !0 : (((e = t[p.id]) !== null && e !== void 0 ? e : 1) & 1) == 0 && u.push(t[p.id]);
    return {
      create(p) {
        return p.values[a] = i(p), 1;
      },
      update(p, y) {
        if (l && y.docChanged || h && (y.docChanged || y.selection) || G1(p, u)) {
          let m = i(p);
          if (o ? !P$(m, p.values[a], s) : !s(m, p.values[a]))
            return p.values[a] = m, 1;
        }
        return 0;
      },
      reconfigure: /* @__PURE__ */ f((p, y) => {
        let m, w = y.config.address[r];
        if (w != null) {
          let b = dw(y, w);
          if (this.dependencies.every(($) => $ instanceof gt ? y.facet($) === p.facet($) : $ instanceof Xs ? y.field($, !1) == p.field($, !1) : !0) || (o ? P$(m = i(p), b, s) : s(m = i(p), b)))
            return p.values[a] = b, 0;
        } else
          m = i(p);
        return p.values[a] = m, 1;
      }, "reconfigure")
    };
  }
}, c(Jc, "Xh"), Jc);
f(Z9, "FacetProvider");
let e1 = Z9;
function P$(n, t, e) {
  if (n.length != t.length)
    return !1;
  for (let i = 0; i < n.length; i++)
    if (!e(n[i], t[i]))
      return !1;
  return !0;
}
c(P$, "_c$1");
f(P$, "compareArray");
function G1(n, t) {
  let e = !1;
  for (let i of t)
    Lc(n, i) & 1 && (e = !0);
  return e;
}
c(G1, "ol$1");
f(G1, "ensureAll");
function V9(n, t, e) {
  let i = e.map((l) => n[l.id]), s = e.map((l) => l.type), r = i.filter((l) => !(l & 1)), a = n[t.id] >> 1;
  function o(l) {
    let h = [];
    for (let u = 0; u < i.length; u++) {
      let p = dw(l, i[u]);
      if (s[u] == 2)
        for (let y of p)
          h.push(y);
      else
        h.push(p);
    }
    return t.combine(h);
  }
  return c(o, "l"), f(o, "get"), {
    create(l) {
      for (let h of i)
        Lc(l, h);
      return l.values[a] = o(l), 1;
    },
    update(l, h) {
      if (!G1(l, r))
        return 0;
      let u = o(l);
      return t.compare(u, l.values[a]) ? 0 : (l.values[a] = u, 1);
    },
    reconfigure(l, h) {
      let u = G1(l, i), p = h.config.facets[t.id], y = h.facet(t);
      if (p && !u && pb(e, p))
        return l.values[a] = y, 0;
      let m = o(l);
      return t.compare(m, y) ? (l.values[a] = y, 0) : (l.values[a] = m, 1);
    }
  };
}
c(V9, "Ag$1");
f(V9, "dynamicFacetSlot");
const Qg = /* @__PURE__ */ gt.define({ static: !0 });
var Ja;
const D9 = (Ja = class {
  constructor(t, e, i, s, r) {
    this.id = t, this.createF = e, this.updateF = i, this.compareF = s, this.spec = r, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(t) {
    let e = new Ja(s5++, t.create, t.update, t.compare || ((i, s) => i === s), t);
    return t.provide && (e.provides = t.provide(e)), e;
  }
  create(t) {
    return (t.facet(Qg).find((i) => i.field == this)?.create || this.createF)(t);
  }
  /**
  @internal
  */
  slot(t) {
    let e = t[this.id] >> 1;
    return {
      create: /* @__PURE__ */ f((i) => (i.values[e] = this.create(i), 1), "create"),
      update: /* @__PURE__ */ f((i, s) => {
        let r = i.values[e], a = this.updateF(r, s);
        return this.compareF(r, a) ? 0 : (i.values[e] = a, 1);
      }, "update"),
      reconfigure: /* @__PURE__ */ f((i, s) => {
        let r = i.facet(Qg), a = s.facet(Qg), o;
        return (o = r.find((l) => l.field == this)) && o != a.find((l) => l.field == this) ? (i.values[e] = o.create(i), 1) : s.config.address[this.id] != null ? (i.values[e] = s.field(this), 0) : (i.values[e] = this.create(i), 1);
      }, "reconfigure")
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(t) {
    return [this, Qg.of({ field: this, create: t })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}, c(Ja, "Ys"), Ja);
f(D9, "StateField");
let Xs = D9;
const qa = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function lc(n) {
  return (t) => new q9(t, n);
}
c(lc, "rr$1");
f(lc, "prec");
const al = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ lc(qa.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ lc(qa.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ lc(qa.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ lc(qa.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ lc(qa.lowest)
};
var th;
const W9 = (th = class {
  constructor(t, e) {
    this.inner = t, this.prec = e;
  }
}, c(th, "Yh"), th);
f(W9, "PrecExtension");
let q9 = W9;
var to;
const j9 = (to = class {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(t) {
    return new C$(this, t);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(t) {
    return to.reconfigure.of({ compartment: this, extension: t });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(t) {
    return t.config.compartments.get(this);
  }
}, c(to, "Is"), to);
f(j9, "Compartment");
let F9 = j9;
var eh;
const U9 = (eh = class {
  constructor(t, e) {
    this.compartment = t, this.inner = e;
  }
}, c(eh, "Ih"), eh);
f(U9, "CompartmentInstance");
let C$ = U9;
var eo;
const B9 = (eo = class {
  constructor(t, e, i, s, r, a) {
    for (this.base = t, this.compartments = e, this.dynamicSlots = i, this.address = s, this.staticValues = r, this.facets = a, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(t) {
    let e = this.address[t.id];
    return e == null ? t.default : this.staticValues[e >> 1];
  }
  static resolve(t, e, i) {
    let s = [], r = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ new Map();
    for (let y of X9(t, e, a))
      y instanceof Xs ? s.push(y) : (r[y.facet.id] || (r[y.facet.id] = [])).push(y);
    let o = /* @__PURE__ */ Object.create(null), l = [], h = [];
    for (let y of s)
      o[y.id] = h.length << 1, h.push((m) => y.slot(m));
    let u = i?.config.facets;
    for (let y in r) {
      let m = r[y], w = m[0].facet, b = u && u[y] || [];
      if (m.every(
        ($) => $.type == 0
        /* Provider.Static */
      ))
        if (o[w.id] = l.length << 1 | 1, pb(b, m))
          l.push(i.facet(w));
        else {
          let $ = w.combine(m.map((x) => x.value));
          l.push(i && w.compare($, i.facet(w)) ? i.facet(w) : $);
        }
      else {
        for (let $ of m)
          $.type == 0 ? (o[$.id] = l.length << 1 | 1, l.push($.value)) : (o[$.id] = h.length << 1, h.push((x) => $.dynamicSlot(x)));
        o[w.id] = h.length << 1, h.push(($) => V9($, w, m));
      }
    }
    let p = h.map((y) => y(o));
    return new eo(t, a, p, o, l, r);
  }
}, c(eo, "js"), eo);
f(B9, "Configuration");
let GC = B9;
function X9(n, t, e) {
  let i = [[], [], [], [], []], s = /* @__PURE__ */ new Map();
  function r(a, o) {
    let l = s.get(a);
    if (l != null) {
      if (l <= o)
        return;
      let h = i[l].indexOf(a);
      h > -1 && i[l].splice(h, 1), a instanceof C$ && e.delete(a.compartment);
    }
    if (s.set(a, o), Array.isArray(a))
      for (let h of a)
        r(h, o);
    else if (a instanceof C$) {
      if (e.has(a.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let h = t.get(a.compartment) || a.inner;
      e.set(a.compartment, h), r(h, o);
    } else if (a instanceof q9)
      r(a.inner, a.prec);
    else if (a instanceof Xs)
      i[o].push(a), a.provides && r(a.provides, o);
    else if (a instanceof e1)
      i[o].push(a), a.facet.extensions && r(a.facet.extensions, qa.default);
    else {
      let h = a.extension;
      if (!h)
        throw new Error(`Unrecognized extension value in extension set (${a}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      r(h, o);
    }
  }
  return c(r, "s"), f(r, "inner"), r(n, qa.default), i.reduce((a, o) => a.concat(o));
}
c(X9, "Zg$1");
f(X9, "flatten");
function Lc(n, t) {
  if (t & 1)
    return 2;
  let e = t >> 1, i = n.status[e];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  n.status[e] = 4;
  let s = n.computeSlot(n, n.config.dynamicSlots[e]);
  return n.status[e] = 2 | s;
}
c(Lc, "mr$1");
f(Lc, "ensureAddr");
function dw(n, t) {
  return t & 1 ? n.config.staticValues[t >> 1] : n.values[t >> 1];
}
c(dw, "rs$2");
f(dw, "getAddr");
const N9 = /* @__PURE__ */ gt.define(), Q$ = /* @__PURE__ */ gt.define({
  combine: /* @__PURE__ */ f((n) => n.some((t) => t), "combine"),
  static: !0
}), H9 = /* @__PURE__ */ gt.define({
  combine: /* @__PURE__ */ f((n) => n.length ? n[0] : void 0, "combine"),
  static: !0
}), Y9 = /* @__PURE__ */ gt.define(), G9 = /* @__PURE__ */ gt.define(), K9 = /* @__PURE__ */ gt.define(), J9 = /* @__PURE__ */ gt.define({
  combine: /* @__PURE__ */ f((n) => n.length ? n[0] : !1, "combine")
});
var ih;
const tQ = (ih = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.type = t, this.value = e;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new ZZ();
  }
}, c(ih, "jh"), ih);
f(tQ, "Annotation");
let Ns = tQ;
var nh;
const eQ = (nh = class {
  /**
  Create an instance of this annotation.
  */
  of(t) {
    return new Ns(this, t);
  }
}, c(nh, "qh"), nh);
f(eQ, "AnnotationType");
let ZZ = eQ;
var sh;
const iQ = (sh = class {
  /**
  @internal
  */
  constructor(t) {
    this.map = t;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(t) {
    return new Bt(this, t);
  }
}, c(sh, "Dh"), sh);
f(iQ, "StateEffectType");
let VZ = iQ;
var io;
const nQ = (io = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.type = t, this.value = e;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(t) {
    let e = this.type.map(this.value, t);
    return e === void 0 ? void 0 : e == this.value ? this : new io(this.type, e);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(t) {
    return this.type == t;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(t = {}) {
    return new VZ(t.map || ((e) => e));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(t, e) {
    if (!t.length)
      return t;
    let i = [];
    for (let s of t) {
      let r = s.map(e);
      r && i.push(r);
    }
    return i;
  }
}, c(io, "qs"), io);
f(nQ, "StateEffect");
let Bt = nQ;
Bt.reconfigure = /* @__PURE__ */ Bt.define();
Bt.appendConfig = /* @__PURE__ */ Bt.define();
var Bn;
const sQ = (Bn = class {
  constructor(t, e, i, s, r, a) {
    this.startState = t, this.changes = e, this.selection = i, this.effects = s, this.annotations = r, this.scrollIntoView = a, this._doc = null, this._state = null, i && n5(i, e.newLength), r.some((o) => o.type == Bn.time) || (this.annotations = r.concat(Bn.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(t, e, i, s, r, a) {
    return new Bn(t, e, i, s, r, a);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(t) {
    for (let e of this.annotations)
      if (e.type == t)
        return e.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(t) {
    let e = this.annotation(Bn.userEvent);
    return !!(e && (e == t || e.length > t.length && e.slice(0, t.length) == t && e[t.length] == "."));
  }
}, c(Bn, "jt"), Bn);
f(sQ, "Transaction");
let gi = sQ;
gi.time = /* @__PURE__ */ Ns.define();
gi.userEvent = /* @__PURE__ */ Ns.define();
gi.addToHistory = /* @__PURE__ */ Ns.define();
gi.remote = /* @__PURE__ */ Ns.define();
function rQ(n, t) {
  let e = [];
  for (let i = 0, s = 0; ; ) {
    let r, a;
    if (i < n.length && (s == t.length || t[s] >= n[i]))
      r = n[i++], a = n[i++];
    else if (s < t.length)
      r = t[s++], a = t[s++];
    else
      return e;
    !e.length || e[e.length - 1] < r ? e.push(r, a) : e[e.length - 1] < a && (e[e.length - 1] = a);
  }
}
c(rQ, "Lg$1");
f(rQ, "joinRanges");
function r5(n, t, e) {
  var i;
  let s, r, a;
  return e ? (s = t.changes, r = $n.empty(t.changes.length), a = n.changes.compose(t.changes)) : (s = t.changes.map(n.changes), r = n.changes.mapDesc(t.changes, !0), a = n.changes.compose(s)), {
    changes: a,
    selection: t.selection ? t.selection.map(r) : (i = n.selection) === null || i === void 0 ? void 0 : i.map(s),
    effects: Bt.mapEffects(n.effects, s).concat(Bt.mapEffects(t.effects, r)),
    annotations: n.annotations.length ? n.annotations.concat(t.annotations) : t.annotations,
    scrollIntoView: n.scrollIntoView || t.scrollIntoView
  };
}
c(r5, "Gd");
f(r5, "mergeTransaction");
function K1(n, t, e) {
  let i = t.selection, s = Ba(t.annotations);
  return t.userEvent && (s = s.concat(gi.userEvent.of(t.userEvent))), {
    changes: t.changes instanceof $n ? t.changes : $n.of(t.changes || [], e, n.facet(H9)),
    selection: i && (i instanceof J ? i : J.single(i.anchor, i.head)),
    effects: Ba(t.effects),
    annotations: s,
    scrollIntoView: !!t.scrollIntoView
  };
}
c(K1, "fl$1");
f(K1, "resolveTransactionInner");
function a5(n, t, e) {
  let i = K1(n, t.length ? t[0] : {}, n.doc.length);
  t.length && t[0].filter === !1 && (e = !1);
  for (let r = 1; r < t.length; r++) {
    t[r].filter === !1 && (e = !1);
    let a = !!t[r].sequential;
    i = r5(i, K1(n, t[r], a ? i.changes.newLength : n.doc.length), a);
  }
  let s = gi.create(n, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return oQ(e ? aQ(s) : s);
}
c(a5, "Hd$1");
f(a5, "resolveTransaction");
function aQ(n) {
  let t = n.startState, e = !0;
  for (let s of t.facet(Y9)) {
    let r = s(n);
    if (r === !1) {
      e = !1;
      break;
    }
    Array.isArray(r) && (e = e === !0 ? r : rQ(e, r));
  }
  if (e !== !0) {
    let s, r;
    if (e === !1)
      r = n.changes.invertedDesc, s = $n.empty(t.doc.length);
    else {
      let a = n.changes.filter(e);
      s = a.changes, r = a.filtered.mapDesc(a.changes).invertedDesc;
    }
    n = gi.create(t, s, n.selection && n.selection.map(r), Bt.mapEffects(n.effects, r), n.annotations, n.scrollIntoView);
  }
  let i = t.facet(G9);
  for (let s = i.length - 1; s >= 0; s--) {
    let r = i[s](n);
    r instanceof gi ? n = r : Array.isArray(r) && r.length == 1 && r[0] instanceof gi ? n = r[0] : n = a5(t, Ba(r), !1);
  }
  return n;
}
c(aQ, "Mg$1");
f(aQ, "filterTransaction");
function oQ(n) {
  let t = n.startState, e = t.facet(K9), i = n;
  for (let s = e.length - 1; s >= 0; s--) {
    let r = e[s](n);
    r && Object.keys(r).length && (i = r5(i, K1(t, r, n.changes.newLength), !0));
  }
  return i == n ? n : gi.create(t, n.changes, n.selection, i.effects, i.annotations, i.scrollIntoView);
}
c(oQ, "_g$1");
f(oQ, "extendTransaction");
const DZ = [];
function Ba(n) {
  return n == null ? DZ : Array.isArray(n) ? n : [n];
}
c(Ba, "Ri");
f(Ba, "asArray");
var Ss = /* @__PURE__ */ function(n) {
  return n[n.Word = 0] = "Word", n[n.Space = 1] = "Space", n[n.Other = 2] = "Other", n;
}(Ss || (Ss = {}));
const WZ = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let M$;
try {
  M$ = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function lQ(n) {
  if (M$)
    return M$.test(n);
  for (let t = 0; t < n.length; t++) {
    let e = n[t];
    if (/\w/.test(e) || e > "" && (e.toUpperCase() != e.toLowerCase() || WZ.test(e)))
      return !0;
  }
  return !1;
}
c(lQ, "Vg$1");
f(lQ, "hasWordChar");
function cQ(n) {
  return (t) => {
    if (!/\S/.test(t))
      return Ss.Space;
    if (lQ(t))
      return Ss.Word;
    for (let e = 0; e < n.length; e++)
      if (t.indexOf(n[e]) > -1)
        return Ss.Word;
    return Ss.Other;
  };
}
c(cQ, "Ug$1");
f(cQ, "makeCategorizer");
var oi;
const hQ = (oi = class {
  constructor(t, e, i, s, r, a) {
    this.config = t, this.doc = e, this.selection = i, this.values = s, this.status = t.statusTemplate.slice(), this.computeSlot = r, a && (a._state = this);
    for (let o = 0; o < this.config.dynamicSlots.length; o++)
      Lc(this, o << 1);
    this.computeSlot = null;
  }
  field(t, e = !0) {
    let i = this.config.address[t.id];
    if (i == null) {
      if (e)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Lc(this, i), dw(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...t) {
    return a5(this, t, !0);
  }
  /**
  @internal
  */
  applyTransaction(t) {
    let e = this.config, { base: i, compartments: s } = e;
    for (let o of t.effects)
      o.is(F9.reconfigure) ? (e && (s = /* @__PURE__ */ new Map(), e.compartments.forEach((l, h) => s.set(h, l)), e = null), s.set(o.value.compartment, o.value.extension)) : o.is(Bt.reconfigure) ? (e = null, i = o.value) : o.is(Bt.appendConfig) && (e = null, i = Ba(i).concat(o.value));
    let r;
    e ? r = t.startState.values.slice() : (e = GC.resolve(i, s, this), r = new oi(e, this.doc, this.selection, e.dynamicSlots.map(() => null), (o, l) => l.reconfigure(o, this), null).values);
    let a = t.startState.facet(Q$) ? t.newSelection : t.newSelection.asSingle();
    new oi(e, t.newDoc, a, r, (o, l) => l.update(o, t), t);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(t) {
    return typeof t == "string" && (t = this.toText(t)), this.changeByRange((e) => ({
      changes: { from: e.from, to: e.to, insert: t },
      range: J.cursor(e.from + t.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(t) {
    let e = this.selection, i = t(e.ranges[0]), s = this.changes(i.changes), r = [i.range], a = Ba(i.effects);
    for (let o = 1; o < e.ranges.length; o++) {
      let l = t(e.ranges[o]), h = this.changes(l.changes), u = h.map(s);
      for (let y = 0; y < o; y++)
        r[y] = r[y].map(u);
      let p = s.mapDesc(h, !0);
      r.push(l.range.map(p)), s = s.compose(u), a = Bt.mapEffects(a, u).concat(Bt.mapEffects(Ba(l.effects), p));
    }
    return {
      changes: s,
      selection: J.create(r, e.mainIndex),
      effects: a
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(t = []) {
    return t instanceof $n ? t : $n.of(t, this.doc.length, this.facet(oi.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(t) {
    return Vt.of(t.split(this.facet(oi.lineSeparator) || S$));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(t = 0, e = this.doc.length) {
    return this.doc.sliceString(t, e, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(t) {
    let e = this.config.address[t.id];
    return e == null ? t.default : (Lc(this, e), dw(this, e));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(t) {
    let e = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (t)
      for (let i in t) {
        let s = t[i];
        s instanceof Xs && this.config.address[s.id] != null && (e[i] = s.spec.toJSON(this.field(t[i]), this));
      }
    return e;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(t, e = {}, i) {
    if (!t || typeof t.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let s = [];
    if (i) {
      for (let r in i)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          let a = i[r], o = t[r];
          s.push(a.init((l) => a.spec.fromJSON(o, l)));
        }
    }
    return oi.create({
      doc: t.doc,
      selection: J.fromJSON(t.selection),
      extensions: e.extensions ? s.concat([e.extensions]) : s
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(t = {}) {
    let e = GC.resolve(t.extensions || [], /* @__PURE__ */ new Map()), i = t.doc instanceof Vt ? t.doc : Vt.of((t.doc || "").split(e.staticFacet(oi.lineSeparator) || S$)), s = t.selection ? t.selection instanceof J ? t.selection : J.single(t.selection.anchor, t.selection.head) : J.single(0);
    return n5(s, i.length), e.staticFacet(Q$) || (s = s.asSingle()), new oi(e, i, s, e.dynamicSlots.map(() => null), (r, a) => a.create(r), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(oi.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(oi.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(J9);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(t, ...e) {
    for (let i of this.facet(oi.phrases))
      if (Object.prototype.hasOwnProperty.call(i, t)) {
        t = i[t];
        break;
      }
    return e.length && (t = t.replace(/\$(\$|\d*)/g, (i, s) => {
      if (s == "$")
        return "$";
      let r = +(s || 1);
      return !r || r > e.length ? i : e[r - 1];
    })), t;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(t, e, i = -1) {
    let s = [];
    for (let r of this.facet(N9))
      for (let a of r(this, e, i))
        Object.prototype.hasOwnProperty.call(a, t) && s.push(a[t]);
    return s;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(t) {
    return cQ(this.languageDataAt("wordChars", t).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(t) {
    let { text: e, from: i, length: s } = this.doc.lineAt(t), r = this.charCategorizer(t), a = t - i, o = t - i;
    for (; a > 0; ) {
      let l = wn(e, a, !1);
      if (r(e.slice(l, a)) != Ss.Word)
        break;
      a = l;
    }
    for (; o < s; ) {
      let l = wn(e, o);
      if (r(e.slice(o, l)) != Ss.Word)
        break;
      o = l;
    }
    return a == o ? null : J.range(a + i, o + i);
  }
}, c(oi, "ke"), oi);
f(hQ, "EditorState");
let ze = hQ;
ze.allowMultipleSelections = Q$;
ze.tabSize = /* @__PURE__ */ gt.define({
  combine: /* @__PURE__ */ f((n) => n.length ? n[0] : 4, "combine")
});
ze.lineSeparator = H9;
ze.readOnly = J9;
ze.phrases = /* @__PURE__ */ gt.define({
  compare(n, t) {
    let e = Object.keys(n), i = Object.keys(t);
    return e.length == i.length && e.every((s) => n[s] == t[s]);
  }
});
ze.languageData = N9;
ze.changeFilter = Y9;
ze.transactionFilter = G9;
ze.transactionExtender = K9;
F9.reconfigure = /* @__PURE__ */ Bt.define();
function o5(n, t, e = {}) {
  let i = {};
  for (let s of n)
    for (let r of Object.keys(s)) {
      let a = s[r], o = i[r];
      if (o === void 0)
        i[r] = a;
      else if (!(o === a || a === void 0)) if (Object.hasOwnProperty.call(e, r))
        i[r] = e[r](o, a);
      else
        throw new Error("Config merge conflict for field " + r);
    }
  for (let s in t)
    i[s] === void 0 && (i[s] = t[s]);
  return i;
}
c(o5, "Fd$1");
f(o5, "combineConfig");
var rh;
const dQ = (rh = class {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(t) {
    return this == t;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(t, e = t) {
    return T$.create(t, e, this);
  }
}, c(rh, "Bh"), rh);
f(dQ, "RangeValue");
let Io = dQ;
Io.prototype.startSide = Io.prototype.endSide = 0;
Io.prototype.point = !1;
Io.prototype.mapMode = wi.TrackDel;
var Mg, ah;
let T$ = (Mg = (ah = class {
  constructor(t, e, i) {
    this.from = t, this.to = e, this.value = i;
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new Mg(t, e, i);
  }
}, c(ah, "ti$1"), ah), f(Mg, "Range"), Mg);
function J1(n, t) {
  return n.from - t.from || n.value.startSide - t.value.startSide;
}
c(J1, "dl$1");
f(J1, "cmpRange");
var no;
const uQ = (no = class {
  constructor(t, e, i, s) {
    this.from = t, this.to = e, this.value = i, this.maxPoint = s;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(t, e, i, s = 0) {
    let r = i ? this.to : this.from;
    for (let a = s, o = r.length; ; ) {
      if (a == o)
        return a;
      let l = a + o >> 1, h = r[l] - t || (i ? this.value[l].endSide : this.value[l].startSide) - e;
      if (l == a)
        return h >= 0 ? a : o;
      h >= 0 ? o = l : a = l + 1;
    }
  }
  between(t, e, i, s) {
    for (let r = this.findIndex(e, -1e9, !0), a = this.findIndex(i, 1e9, !1, r); r < a; r++)
      if (s(this.from[r] + t, this.to[r] + t, this.value[r]) === !1)
        return !1;
  }
  map(t, e) {
    let i = [], s = [], r = [], a = -1, o = -1;
    for (let l = 0; l < this.value.length; l++) {
      let h = this.value[l], u = this.from[l] + t, p = this.to[l] + t, y, m;
      if (u == p) {
        let w = e.mapPos(u, h.startSide, h.mapMode);
        if (w == null || (y = m = w, h.startSide != h.endSide && (m = e.mapPos(u, h.endSide), m < y)))
          continue;
      } else if (y = e.mapPos(u, h.startSide), m = e.mapPos(p, h.endSide), y > m || y == m && h.startSide > 0 && h.endSide <= 0)
        continue;
      (m - y || h.endSide - h.startSide) < 0 || (a < 0 && (a = y), h.point && (o = Math.max(o, m - y)), i.push(h), s.push(y - a), r.push(m - a));
    }
    return { mapped: i.length ? new no(s, r, i, o) : null, pos: a };
  }
}, c(no, "Ds"), no);
f(uQ, "Chunk");
let qZ = uQ;
var Si;
const pQ = (Si = class {
  constructor(t, e, i, s) {
    this.chunkPos = t, this.chunk = e, this.nextLayer = i, this.maxPoint = s;
  }
  /**
  @internal
  */
  static create(t, e, i, s) {
    return new Si(t, e, i, s);
  }
  /**
  @internal
  */
  get length() {
    let t = this.chunk.length - 1;
    return t < 0 ? 0 : Math.max(this.chunkEnd(t), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let t = this.nextLayer.size;
    for (let e of this.chunk)
      t += e.value.length;
    return t;
  }
  /**
  @internal
  */
  chunkEnd(t) {
    return this.chunkPos[t] + this.chunk[t].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(t) {
    let { add: e = [], sort: i = !1, filterFrom: s = 0, filterTo: r = this.length } = t, a = t.filter;
    if (e.length == 0 && !a)
      return this;
    if (i && (e = e.slice().sort(J1)), this.isEmpty)
      return e.length ? Si.of(e) : this;
    let o = new wQ(this, null, -1).goto(0), l = 0, h = [], u = new tv();
    for (; o.value || l < e.length; )
      if (l < e.length && (o.from - e[l].from || o.startSide - e[l].value.startSide) >= 0) {
        let p = e[l++];
        u.addInner(p.from, p.to, p.value) || h.push(p);
      } else o.rangeIndex == 1 && o.chunkIndex < this.chunk.length && (l == e.length || this.chunkEnd(o.chunkIndex) < e[l].from) && (!a || s > this.chunkEnd(o.chunkIndex) || r < this.chunkPos[o.chunkIndex]) && u.addChunk(this.chunkPos[o.chunkIndex], this.chunk[o.chunkIndex]) ? o.nextChunk() : ((!a || s > o.to || r < o.from || a(o.from, o.to, o.value)) && (u.addInner(o.from, o.to, o.value) || h.push(T$.create(o.from, o.to, o.value))), o.next());
    return u.finishInner(this.nextLayer.isEmpty && !h.length ? Si.empty : this.nextLayer.update({ add: h, filter: a, filterFrom: s, filterTo: r }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(t) {
    if (t.empty || this.isEmpty)
      return this;
    let e = [], i = [], s = -1;
    for (let a = 0; a < this.chunk.length; a++) {
      let o = this.chunkPos[a], l = this.chunk[a], h = t.touchesRange(o, o + l.length);
      if (h === !1)
        s = Math.max(s, l.maxPoint), e.push(l), i.push(t.mapPos(o));
      else if (h === !0) {
        let { mapped: u, pos: p } = l.map(o, t);
        u && (s = Math.max(s, u.maxPoint), e.push(u), i.push(p));
      }
    }
    let r = this.nextLayer.map(t);
    return e.length == 0 ? r : new Si(i, e, r || Si.empty, s);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(t, e, i) {
    if (!this.isEmpty) {
      for (let s = 0; s < this.chunk.length; s++) {
        let r = this.chunkPos[s], a = this.chunk[s];
        if (e >= r && t <= r + a.length && a.between(r, t - r, e - r, i) === !1)
          return;
      }
      this.nextLayer.between(t, e, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(t = 0) {
    return R$.from([this]).goto(t);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(t, e = 0) {
    return R$.from(t).goto(e);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(t, e, i, s, r = -1) {
    let a = t.filter((p) => p.maxPoint > 0 || !p.isEmpty && p.maxPoint >= r), o = e.filter((p) => p.maxPoint > 0 || !p.isEmpty && p.maxPoint >= r), l = A$(a, o, i), h = new Zy(a, l, r), u = new Zy(o, l, r);
    i.iterGaps((p, y, m) => E$(h, p, u, y, m, s)), i.empty && i.length == 0 && E$(h, 0, u, 0, 0, s);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(t, e, i = 0, s) {
    s == null && (s = 999999999);
    let r = t.filter((u) => !u.isEmpty && e.indexOf(u) < 0), a = e.filter((u) => !u.isEmpty && t.indexOf(u) < 0);
    if (r.length != a.length)
      return !1;
    if (!r.length)
      return !0;
    let o = A$(r, a), l = new Zy(r, o, 0).goto(i), h = new Zy(a, o, 0).goto(i);
    for (; ; ) {
      if (l.to != h.to || !ev(l.active, h.active) || l.point && (!h.point || !l.point.eq(h.point)))
        return !1;
      if (l.to > s)
        return !0;
      l.next(), h.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(t, e, i, s, r = -1) {
    let a = new Zy(t, null, r).goto(e), o = e, l = a.openStart;
    for (; ; ) {
      let h = Math.min(a.to, i);
      if (a.point) {
        let u = a.activeForPoint(a.to), p = a.pointFrom < e ? u.length + 1 : a.point.startSide < 0 ? u.length : Math.min(u.length, l);
        s.point(o, h, a.point, u, p, a.pointRank), l = Math.min(a.openEnd(h), u.length);
      } else h > o && (s.span(o, h, a.active, l), l = a.openEnd(h));
      if (a.to > i)
        return l + (a.point && a.to > i ? 1 : 0);
      o = a.to, a.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(t, e = !1) {
    let i = new tv();
    for (let s of t instanceof T$ ? [t] : e ? fQ(t) : t)
      i.add(s.from, s.to, s.value);
    return i.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(t) {
    if (!t.length)
      return Si.empty;
    let e = t[t.length - 1];
    for (let i = t.length - 2; i >= 0; i--)
      for (let s = t[i]; s != Si.empty; s = s.nextLayer)
        e = new Si(s.chunkPos, s.chunk, e, Math.max(s.maxPoint, e.maxPoint));
    return e;
  }
}, c(Si, "We"), Si);
f(pQ, "RangeSet");
let hi = pQ;
hi.empty = /* @__PURE__ */ new hi([], [], null, -1);
function fQ(n) {
  if (n.length > 1)
    for (let t = n[0], e = 1; e < n.length; e++) {
      let i = n[e];
      if (J1(t, i) > 0)
        return n.slice().sort(J1);
      t = i;
    }
  return n;
}
c(fQ, "Wg$1");
f(fQ, "lazySort");
hi.empty.nextLayer = hi.empty;
var so;
const yQ = (so = class {
  finishChunk(t) {
    this.chunks.push(new qZ(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, t && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(t, e, i) {
    this.addInner(t, e, i) || (this.nextLayer || (this.nextLayer = new so())).add(t, e, i);
  }
  /**
  @internal
  */
  addInner(t, e, i) {
    let s = t - this.lastTo || i.startSide - this.last.endSide;
    if (s <= 0 && (t - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return s < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = t), this.from.push(t - this.chunkStart), this.to.push(e - this.chunkStart), this.last = i, this.lastFrom = t, this.lastTo = e, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, e - t)), !0);
  }
  /**
  @internal
  */
  addChunk(t, e) {
    if ((t - this.lastTo || e.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, e.maxPoint), this.chunks.push(e), this.chunkPos.push(t);
    let i = e.value.length - 1;
    return this.last = e.value[i], this.lastFrom = e.from[i] + t, this.lastTo = e.to[i] + t, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(hi.empty);
  }
  /**
  @internal
  */
  finishInner(t) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return t;
    let e = hi.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(t) : t, this.setMaxPoint);
    return this.from = null, e;
  }
}, c(so, "Bs"), so);
f(yQ, "RangeSetBuilder");
let tv = yQ;
function A$(n, t, e) {
  let i = /* @__PURE__ */ new Map();
  for (let r of n)
    for (let a = 0; a < r.chunk.length; a++)
      r.chunk[a].maxPoint <= 0 && i.set(r.chunk[a], r.chunkPos[a]);
  let s = /* @__PURE__ */ new Set();
  for (let r of t)
    for (let a = 0; a < r.chunk.length; a++) {
      let o = i.get(r.chunk[a]);
      o != null && (e ? e.mapPos(o) : o) == r.chunkPos[a] && !e?.touchesRange(o, o + r.chunk[a].length) && s.add(r.chunk[a]);
    }
  return s;
}
c(A$, "Cc$1");
f(A$, "findSharedChunks");
var oh;
const mQ = (oh = class {
  constructor(t, e, i, s = 0) {
    this.layer = t, this.skip = e, this.minPoint = i, this.rank = s;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(t, e = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(t, e, !1), this;
  }
  gotoInner(t, e, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let s = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(s) || this.layer.chunkEnd(this.chunkIndex) < t || s.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let s = this.layer.chunk[this.chunkIndex].findIndex(t - this.layer.chunkPos[this.chunkIndex], e, !0);
      (!i || this.rangeIndex < s) && this.setRangeIndex(s);
    }
    this.next();
  }
  forward(t, e) {
    (this.to - t || this.endSide - e) < 0 && this.gotoInner(t, e, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let t = this.layer.chunkPos[this.chunkIndex], e = this.layer.chunk[this.chunkIndex], i = t + e.from[this.rangeIndex];
        if (this.from = i, this.to = t + e.to[this.rangeIndex], this.value = e.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(t) {
    if (t == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = t;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(t) {
    return this.from - t.from || this.startSide - t.startSide || this.rank - t.rank || this.to - t.to || this.endSide - t.endSide;
  }
}, c(oh, "zh"), oh);
f(mQ, "LayerCursor");
let wQ = mQ;
var ro;
const gQ = (ro = class {
  constructor(t) {
    this.heap = t;
  }
  static from(t, e = null, i = -1) {
    let s = [];
    for (let r = 0; r < t.length; r++)
      for (let a = t[r]; !a.isEmpty; a = a.nextLayer)
        a.maxPoint >= i && s.push(new wQ(a, e, i, r));
    return s.length == 1 ? s[0] : new ro(s);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(t, e = -1e9) {
    for (let i of this.heap)
      i.goto(t, e);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      i1(this.heap, i);
    return this.next(), this;
  }
  forward(t, e) {
    for (let i of this.heap)
      i.forward(t, e);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      i1(this.heap, i);
    (this.to - t || this.value.endSide - e) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let t = this.heap[0];
      this.from = t.from, this.to = t.to, this.value = t.value, this.rank = t.rank, t.value && t.next(), i1(this.heap, 0);
    }
  }
}, c(ro, "zs"), ro);
f(gQ, "HeapCursor");
let R$ = gQ;
function i1(n, t) {
  for (let e = n[t]; ; ) {
    let i = (t << 1) + 1;
    if (i >= n.length)
      break;
    let s = n[i];
    if (i + 1 < n.length && s.compare(n[i + 1]) >= 0 && (s = n[i + 1], i++), e.compare(s) < 0)
      break;
    n[i] = e, n[t] = s, t = i;
  }
}
c(i1, "Ro$1");
f(i1, "heapBubble");
var lh;
const vQ = (lh = class {
  constructor(t, e, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = R$.from(t, e, i);
  }
  goto(t, e = -1e9) {
    return this.cursor.goto(t, e), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = t, this.endSide = e, this.openStart = -1, this.next(), this;
  }
  forward(t, e) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - t || this.active[this.minActive].endSide - e) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(t, e);
  }
  removeActive(t) {
    hm(this.active, t), hm(this.activeTo, t), hm(this.activeRank, t), this.minActive = _$(this.active, this.activeTo);
  }
  addActive(t) {
    let e = 0, { value: i, to: s, rank: r } = this.cursor;
    for (; e < this.activeRank.length && (r - this.activeRank[e] || s - this.activeTo[e]) > 0; )
      e++;
    dm(this.active, e, i), dm(this.activeTo, e, s), dm(this.activeRank, e, r), t && dm(t, e, this.cursor.from), this.minActive = _$(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let t = this.to, e = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let s = this.minActive;
      if (s > -1 && (this.activeTo[s] - this.cursor.from || this.active[s].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[s] > t) {
          this.to = this.activeTo[s], this.endSide = this.active[s].endSide;
          break;
        }
        this.removeActive(s), i && hm(i, s);
      } else if (this.cursor.value)
        if (this.cursor.from > t) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let r = this.cursor.value;
          if (!r.point)
            this.addActive(i), this.cursor.next();
          else if (e && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = r, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = r.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let s = i.length - 1; s >= 0 && i[s] < t; s--)
        this.openStart++;
    }
  }
  activeForPoint(t) {
    if (!this.active.length)
      return this.active;
    let e = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > t || this.activeTo[i] == t && this.active[i].endSide >= this.point.endSide) && e.push(this.active[i]);
    return e.reverse();
  }
  openEnd(t) {
    let e = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > t; i--)
      e++;
    return e;
  }
}, c(lh, "Nh"), lh);
f(vQ, "SpanCursor");
let Zy = vQ;
function E$(n, t, e, i, s, r) {
  n.goto(t), e.goto(i);
  let a = i + s, o = i, l = i - t;
  for (; ; ) {
    let h = n.to + l - e.to, u = h || n.endSide - e.endSide, p = u < 0 ? n.to + l : e.to, y = Math.min(p, a);
    if (n.point || e.point ? n.point && e.point && (n.point == e.point || n.point.eq(e.point)) && ev(n.activeForPoint(n.to), e.activeForPoint(e.to)) || r.comparePoint(o, y, n.point, e.point) : y > o && !ev(n.active, e.active) && r.compareRange(o, y, n.active, e.active), p > a)
      break;
    (h || n.openEnd != e.openEnd) && r.boundChange && r.boundChange(p), o = p, u <= 0 && n.next(), u >= 0 && e.next();
  }
}
c(E$, "Ec$1");
f(E$, "compare");
function ev(n, t) {
  if (n.length != t.length)
    return !1;
  for (let e = 0; e < n.length; e++)
    if (n[e] != t[e] && !n[e].eq(t[e]))
      return !1;
  return !0;
}
c(ev, "pl$1");
f(ev, "sameValues");
function hm(n, t) {
  for (let e = t, i = n.length - 1; e < i; e++)
    n[e] = n[e + 1];
  n.pop();
}
c(hm, "$n$1");
f(hm, "remove");
function dm(n, t, e) {
  for (let i = n.length - 1; i >= t; i--)
    n[i + 1] = n[i];
  n[t] = e;
}
c(dm, "vn$1");
f(dm, "insert");
function _$(n, t) {
  let e = -1, i = 1e9;
  for (let s = 0; s < t.length; s++)
    (t[s] - i || n[s].endSide - n[e].endSide) < 0 && (e = s, i = t[s]);
  return e;
}
c(_$, "Vc$1");
f(_$, "findMinIndex");
function Nr(n, t, e = n.length) {
  let i = 0;
  for (let s = 0; s < e && s < n.length; )
    n.charCodeAt(s) == 9 ? (i += t - i % t, s++) : (i++, s = wn(n, s));
  return i;
}
c(Nr, "dt$2");
f(Nr, "countColumn");
function bQ(n, t, e, i) {
  for (let s = 0, r = 0; ; ) {
    if (r >= t)
      return s;
    if (s == n.length)
      break;
    r += n.charCodeAt(s) == 9 ? e - r % e : 1, s = wn(n, s);
  }
  return n.length;
}
c(bQ, "Xg$1");
f(bQ, "findColumn");
const z$ = "ͼ", KC = typeof Symbol > "u" ? "__" + z$ : Symbol.for(z$), L$ = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), JC = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
var ch;
const OQ = (ch = class {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(t, e) {
    this.rules = [];
    let { finish: i } = e || {};
    function s(a) {
      return /^@/.test(a) ? [a] : a.split(/,\s*/);
    }
    c(s, "n"), f(s, "splitSelector");
    function r(a, o, l, h) {
      let u = [], p = /^@(\w+)\b/.exec(a[0]), y = p && p[1] == "keyframes";
      if (p && o == null) return l.push(a[0] + ";");
      for (let m in o) {
        let w = o[m];
        if (/&/.test(m))
          r(
            m.split(/,\s*/).map((b) => a.map(($) => b.replace(/&/, $))).reduce((b, $) => b.concat($)),
            w,
            l
          );
        else if (w && typeof w == "object") {
          if (!p) throw new RangeError("The value of a property (" + m + ") should be a primitive value.");
          r(s(m), w, u, y);
        } else w != null && u.push(m.replace(/_.*/, "").replace(/[A-Z]/g, (b) => "-" + b.toLowerCase()) + ": " + w + ";");
      }
      (u.length || y) && l.push((i && !p && !h ? a.map(i) : a).join(", ") + " {" + u.join(" ") + "}");
    }
    c(r, "s"), f(r, "render");
    for (let a in t) r(s(a), t[a], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let t = JC[KC] || 1;
    return JC[KC] = t + 1, z$ + t.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(t, e, i) {
    let s = t[L$], r = i && i.nonce;
    s ? r && s.setNonce(r) : s = new jZ(t, r), s.mount(Array.isArray(e) ? e : [e], t);
  }
}, c(ch, "Gh"), ch);
f(OQ, "StyleModule");
let Hr = OQ, t4 = /* @__PURE__ */ new Map();
var hh;
const $Q = (hh = class {
  constructor(t, e) {
    let i = t.ownerDocument || t, s = i.defaultView;
    if (!t.head && t.adoptedStyleSheets && s.CSSStyleSheet) {
      let r = t4.get(i);
      if (r) return t[L$] = r;
      this.sheet = new s.CSSStyleSheet(), t4.set(i, this);
    } else
      this.styleTag = i.createElement("style"), e && this.styleTag.setAttribute("nonce", e);
    this.modules = [], t[L$] = this;
  }
  mount(t, e) {
    let i = this.sheet, s = 0, r = 0;
    for (let a = 0; a < t.length; a++) {
      let o = t[a], l = this.modules.indexOf(o);
      if (l < r && l > -1 && (this.modules.splice(l, 1), r--, l = -1), l == -1) {
        if (this.modules.splice(r++, 0, o), i) for (let h = 0; h < o.rules.length; h++)
          i.insertRule(o.rules[h], s++);
      } else {
        for (; r < l; ) s += this.modules[r++].rules.length;
        s += o.rules.length, r++;
      }
    }
    if (i)
      e.adoptedStyleSheets.indexOf(this.sheet) < 0 && (e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets]);
    else {
      let a = "";
      for (let l = 0; l < this.modules.length; l++)
        a += this.modules[l].getRules() + `
`;
      this.styleTag.textContent = a;
      let o = e.head || e;
      this.styleTag.parentNode != o && o.insertBefore(this.styleTag, o.firstChild);
    }
  }
  setNonce(t) {
    this.styleTag && this.styleTag.getAttribute("nonce") != t && this.styleTag.setAttribute("nonce", t);
  }
}, c(hh, "Hh"), hh);
f($Q, "StyleSet");
let jZ = $Q;
var Yr = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, uw = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, FZ = typeof navigator < "u" && /Mac/.test(navigator.platform), UZ = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var ti = 0; ti < 10; ti++) Yr[48 + ti] = Yr[96 + ti] = String(ti);
for (var ti = 1; ti <= 24; ti++) Yr[ti + 111] = "F" + ti;
for (var ti = 65; ti <= 90; ti++)
  Yr[ti] = String.fromCharCode(ti + 32), uw[ti] = String.fromCharCode(ti);
for (var mO in Yr) uw.hasOwnProperty(mO) || (uw[mO] = Yr[mO]);
function xQ(n) {
  var t = FZ && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || UZ && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", e = !t && n.key || (n.shiftKey ? uw : Yr)[n.keyCode] || n.key || "Unidentified";
  return e == "Esc" && (e = "Escape"), e == "Del" && (e = "Delete"), e == "Left" && (e = "ArrowLeft"), e == "Up" && (e = "ArrowUp"), e == "Right" && (e = "ArrowRight"), e == "Down" && (e = "ArrowDown"), e;
}
c(xQ, "jg$1");
f(xQ, "keyName");
let yi = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, I$ = typeof document < "u" ? document : { documentElement: { style: {} } };
const Z$ = /* @__PURE__ */ /Edge\/(\d+)/.exec(yi.userAgent), kQ = /* @__PURE__ */ /MSIE \d/.test(yi.userAgent), V$ = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(yi.userAgent), fb = !!(kQ || V$ || Z$), e4 = !fb && /* @__PURE__ */ /gecko\/(\d+)/i.test(yi.userAgent), wO = !fb && /* @__PURE__ */ /Chrome\/(\d+)/.exec(yi.userAgent), BZ = "webkitFontSmoothing" in I$.documentElement.style, D$ = !fb && /* @__PURE__ */ /Apple Computer/.test(yi.vendor), i4 = D$ && (/* @__PURE__ */ /Mobile\/\w+/.test(yi.userAgent) || yi.maxTouchPoints > 2);
var tt = {
  mac: i4 || /* @__PURE__ */ /Mac/.test(yi.platform),
  windows: /* @__PURE__ */ /Win/.test(yi.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(yi.platform),
  ie: fb,
  ie_version: kQ ? I$.documentMode || 6 : V$ ? +V$[1] : Z$ ? +Z$[1] : 0,
  gecko: e4,
  gecko_version: e4 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(yi.userAgent) || [0, 0])[1] : 0,
  chrome: !!wO,
  chrome_version: wO ? +wO[1] : 0,
  ios: i4,
  android: /* @__PURE__ */ /Android\b/.test(yi.userAgent),
  webkit_version: BZ ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(yi.userAgent) || [0, 0])[1] : 0,
  safari: D$,
  safari_version: D$ ? +(/* @__PURE__ */ /\bVersion\/(\d+(\.\d+)?)/.exec(yi.userAgent) || [0, 0])[1] : 0,
  tabSize: I$.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
function jf(n) {
  let t;
  return n.nodeType == 11 ? t = n.getSelection ? n : n.ownerDocument : t = n, t.getSelection();
}
c(jf, "Fr");
f(jf, "getSelection");
function iv(n, t) {
  return t ? n == t || n.contains(t.nodeType != 1 ? t.parentNode : t) : !1;
}
c(iv, "xl$1");
f(iv, "contains");
function tw(n, t) {
  if (!t.anchorNode)
    return !1;
  try {
    return iv(n, t.anchorNode);
  } catch {
    return !1;
  }
}
c(tw, "zn$1");
f(tw, "hasSelection");
function Zo(n) {
  return n.nodeType == 3 ? Kr(n, 0, n.nodeValue.length).getClientRects() : n.nodeType == 1 ? n.getClientRects() : [];
}
c(Zo, "Wi$1");
f(Zo, "clientRectsFor");
function Ic(n, t, e, i) {
  return e ? W$(n, t, e, i, -1) || W$(n, t, e, i, 1) : !1;
}
c(Ic, "gr$1");
f(Ic, "isEquivalentPosition");
function Gr(n) {
  for (var t = 0; ; t++)
    if (n = n.previousSibling, !n)
      return t;
}
c(Gr, "ri$1");
f(Gr, "domIndex");
function pw(n) {
  return n.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(n.nodeName);
}
c(pw, "ss$2");
f(pw, "isBlockElement");
function W$(n, t, e, i, s) {
  for (; ; ) {
    if (n == e && t == i)
      return !0;
    if (t == (s < 0 ? 0 : xn(n))) {
      if (n.nodeName == "DIV")
        return !1;
      let r = n.parentNode;
      if (!r || r.nodeType != 1)
        return !1;
      t = Gr(n) + (s < 0 ? 0 : 1), n = r;
    } else if (n.nodeType == 1) {
      if (n = n.childNodes[t + (s < 0 ? -1 : 0)], n.nodeType == 1 && n.contentEditable == "false")
        return !1;
      t = s < 0 ? xn(n) : 0;
    } else
      return !1;
  }
}
c(W$, "jc$1");
f(W$, "scanFor");
function xn(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
c(xn, "nt$2");
f(xn, "maxOffset");
function $y(n, t) {
  let e = t ? n.left : n.right;
  return { left: e, right: e, top: n.top, bottom: n.bottom };
}
c($y, "gn$1");
f($y, "flattenRect");
function SQ(n) {
  let t = n.visualViewport;
  return t ? {
    left: 0,
    right: t.width,
    top: 0,
    bottom: t.height
  } : {
    left: 0,
    right: n.innerWidth,
    top: 0,
    bottom: n.innerHeight
  };
}
c(SQ, "Dg$1");
f(SQ, "windowRect");
function l5(n, t) {
  let e = t.width / n.offsetWidth, i = t.height / n.offsetHeight;
  return (e > 0.995 && e < 1.005 || !isFinite(e) || Math.abs(t.width - n.offsetWidth) < 1) && (e = 1), (i > 0.995 && i < 1.005 || !isFinite(i) || Math.abs(t.height - n.offsetHeight) < 1) && (i = 1), { scaleX: e, scaleY: i };
}
c(l5, "Jd");
f(l5, "getScale");
function PQ(n, t, e, i, s, r, a, o) {
  let l = n.ownerDocument, h = l.defaultView || window;
  for (let u = n, p = !1; u && !p; )
    if (u.nodeType == 1) {
      let y, m = u == l.body, w = 1, b = 1;
      if (m)
        y = SQ(h);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (p = !0), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
          u = u.assignedSlot || u.parentNode;
          continue;
        }
        let C = u.getBoundingClientRect();
        ({ scaleX: w, scaleY: b } = l5(u, C)), y = {
          left: C.left,
          right: C.left + u.clientWidth * w,
          top: C.top,
          bottom: C.top + u.clientHeight * b
        };
      }
      let $ = 0, x = 0;
      if (s == "nearest")
        t.top < y.top ? (x = t.top - (y.top + a), e > 0 && t.bottom > y.bottom + x && (x = t.bottom - y.bottom + a)) : t.bottom > y.bottom && (x = t.bottom - y.bottom + a, e < 0 && t.top - x < y.top && (x = t.top - (y.top + a)));
      else {
        let C = t.bottom - t.top, R = y.bottom - y.top;
        x = (s == "center" && C <= R ? t.top + C / 2 - R / 2 : s == "start" || s == "center" && e < 0 ? t.top - a : t.bottom - R + a) - y.top;
      }
      if (i == "nearest" ? t.left < y.left ? ($ = t.left - (y.left + r), e > 0 && t.right > y.right + $ && ($ = t.right - y.right + r)) : t.right > y.right && ($ = t.right - y.right + r, e < 0 && t.left < y.left + $ && ($ = t.left - (y.left + r))) : $ = (i == "center" ? t.left + (t.right - t.left) / 2 - (y.right - y.left) / 2 : i == "start" == o ? t.left - r : t.right - (y.right - y.left) + r) - y.left, $ || x)
        if (m)
          h.scrollBy($, x);
        else {
          let C = 0, R = 0;
          if (x) {
            let E = u.scrollTop;
            u.scrollTop += x / b, R = (u.scrollTop - E) * b;
          }
          if ($) {
            let E = u.scrollLeft;
            u.scrollLeft += $ / w, C = (u.scrollLeft - E) * w;
          }
          t = {
            left: t.left - C,
            top: t.top - R,
            right: t.right - C,
            bottom: t.bottom - R
          }, C && Math.abs(C - $) < 1 && (i = "nearest"), R && Math.abs(R - x) < 1 && (s = "nearest");
        }
      if (m)
        break;
      (t.top < y.top || t.bottom > y.bottom || t.left < y.left || t.right > y.right) && (t = {
        left: Math.max(t.left, y.left),
        right: Math.min(t.right, y.right),
        top: Math.max(t.top, y.top),
        bottom: Math.min(t.bottom, y.bottom)
      }), u = u.assignedSlot || u.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
}
c(PQ, "Bg$1");
f(PQ, "scrollRectIntoView");
function CQ(n) {
  let t = n.ownerDocument, e, i;
  for (let s = n.parentNode; s && !(s == t.body || e && i); )
    if (s.nodeType == 1)
      !i && s.scrollHeight > s.clientHeight && (i = s), !e && s.scrollWidth > s.clientWidth && (e = s), s = s.assignedSlot || s.parentNode;
    else if (s.nodeType == 11)
      s = s.host;
    else
      break;
  return { x: e, y: i };
}
c(CQ, "zg$1");
f(CQ, "scrollableParents");
var dh;
const QQ = (dh = class {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(t) {
    return this.anchorNode == t.anchorNode && this.anchorOffset == t.anchorOffset && this.focusNode == t.focusNode && this.focusOffset == t.focusOffset;
  }
  setRange(t) {
    let { anchorNode: e, focusNode: i } = t;
    this.set(e, Math.min(t.anchorOffset, e ? xn(e) : 0), i, Math.min(t.focusOffset, i ? xn(i) : 0));
  }
  set(t, e, i, s) {
    this.anchorNode = t, this.anchorOffset = e, this.focusNode = i, this.focusOffset = s;
  }
}, c(dh, "Fh"), dh);
f(QQ, "DOMSelectionState");
let XZ = QQ, Ia = null;
tt.safari && tt.safari_version >= 26 && (Ia = !1);
function c5(n) {
  if (n.setActive)
    return n.setActive();
  if (Ia)
    return n.focus(Ia);
  let t = [];
  for (let e = n; e && (t.push(e, e.scrollTop, e.scrollLeft), e != e.ownerDocument); e = e.parentNode)
    ;
  if (n.focus(Ia == null ? {
    get preventScroll() {
      return Ia = { preventScroll: !0 }, !0;
    }
  } : void 0), !Ia) {
    Ia = !1;
    for (let e = 0; e < t.length; ) {
      let i = t[e++], s = t[e++], r = t[e++];
      i.scrollTop != s && (i.scrollTop = s), i.scrollLeft != r && (i.scrollLeft = r);
    }
  }
}
c(c5, "eO");
f(c5, "focusPreventScroll");
let n4;
function Kr(n, t, e = t) {
  let i = n4 || (n4 = document.createRange());
  return i.setEnd(n, e), i.setStart(n, t), i;
}
c(Kr, "ni$1");
f(Kr, "textRange");
function Xa(n, t, e, i) {
  let s = { key: t, code: t, keyCode: e, which: e, cancelable: !0 };
  i && ({ altKey: s.altKey, ctrlKey: s.ctrlKey, shiftKey: s.shiftKey, metaKey: s.metaKey } = i);
  let r = new KeyboardEvent("keydown", s);
  r.synthetic = !0, n.dispatchEvent(r);
  let a = new KeyboardEvent("keyup", s);
  return a.synthetic = !0, n.dispatchEvent(a), r.defaultPrevented || a.defaultPrevented;
}
c(Xa, "$i$1");
f(Xa, "dispatchKey");
function MQ(n) {
  for (; n; ) {
    if (n && (n.nodeType == 9 || n.nodeType == 11 && n.host))
      return n;
    n = n.assignedSlot || n.parentNode;
  }
  return null;
}
c(MQ, "Ng$1");
f(MQ, "getRoot");
function h5(n) {
  for (; n.attributes.length; )
    n.removeAttributeNode(n.attributes[0]);
}
c(h5, "tO");
f(h5, "clearAttributes");
function TQ(n, t) {
  let e = t.focusNode, i = t.focusOffset;
  if (!e || t.anchorNode != e || t.anchorOffset != i)
    return !1;
  for (i = Math.min(i, xn(e)); ; )
    if (i) {
      if (e.nodeType != 1)
        return !1;
      let s = e.childNodes[i - 1];
      s.contentEditable == "false" ? i-- : (e = s, i = xn(e));
    } else {
      if (e == n)
        return !0;
      i = Gr(e), e = e.parentNode;
    }
}
c(TQ, "Gg$1");
f(TQ, "atElementStart");
function d5(n) {
  return n.scrollTop > Math.max(1, n.scrollHeight - n.clientHeight - 4);
}
c(d5, "iO");
f(d5, "isScrolledToBottom");
function u5(n, t) {
  for (let e = n, i = t; ; ) {
    if (e.nodeType == 3 && i > 0)
      return { node: e, offset: i };
    if (e.nodeType == 1 && i > 0) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[i - 1], i = xn(e);
    } else if (e.parentNode && !pw(e))
      i = Gr(e), e = e.parentNode;
    else
      return null;
  }
}
c(u5, "rO");
f(u5, "textNodeBefore");
function p5(n, t) {
  for (let e = n, i = t; ; ) {
    if (e.nodeType == 3 && i < e.nodeValue.length)
      return { node: e, offset: i };
    if (e.nodeType == 1 && i < e.childNodes.length) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[i], i = 0;
    } else if (e.parentNode && !pw(e))
      i = Gr(e) + 1, e = e.parentNode;
    else
      return null;
  }
}
c(p5, "nO");
f(p5, "textNodeAfter");
var Qr;
const AQ = (Qr = class {
  constructor(t, e, i = !0) {
    this.node = t, this.offset = e, this.precise = i;
  }
  static before(t, e) {
    return new Qr(t.parentNode, Gr(t), e);
  }
  static after(t, e) {
    return new Qr(t.parentNode, Gr(t) + 1, e);
  }
}, c(Qr, "vr"), Qr);
f(AQ, "DOMPos");
let ji = AQ;
const f5 = [];
var Mr;
const RQ = (Mr = class {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(t) {
    let e = this.posAtStart;
    for (let i of this.children) {
      if (i == t)
        return e;
      e += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(t) {
    return this.posBefore(t) + t.length;
  }
  sync(t, e) {
    if (this.flags & 2) {
      let i = this.dom, s = null, r;
      for (let a of this.children) {
        if (a.flags & 7) {
          if (!a.dom && (r = s ? s.nextSibling : i.firstChild)) {
            let o = Mr.get(r);
            (!o || !o.parent && o.canReuseDOM(a)) && a.reuseDOM(r);
          }
          a.sync(t, e), a.flags &= -8;
        }
        if (r = s ? s.nextSibling : i.firstChild, e && !e.written && e.node == i && r != a.dom && (e.written = !0), a.dom.parentNode == i)
          for (; r && r != a.dom; )
            r = q$(r);
        else
          i.insertBefore(a.dom, r);
        s = a.dom;
      }
      for (r = s ? s.nextSibling : i.firstChild, r && e && e.node == i && (e.written = !0); r; )
        r = q$(r);
    } else if (this.flags & 1)
      for (let i of this.children)
        i.flags & 7 && (i.sync(t, e), i.flags &= -8);
  }
  reuseDOM(t) {
  }
  localPosFromDOM(t, e) {
    let i;
    if (t == this.dom)
      i = this.dom.childNodes[e];
    else {
      let s = xn(t) == 0 ? 0 : e == 0 ? -1 : 1;
      for (; ; ) {
        let r = t.parentNode;
        if (r == this.dom)
          break;
        s == 0 && r.firstChild != r.lastChild && (t == r.firstChild ? s = -1 : s = 1), t = r;
      }
      s < 0 ? i = t : i = t.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !Mr.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let s = 0, r = 0; ; s++) {
      let a = this.children[s];
      if (a.dom == i)
        return r;
      r += a.length + a.breakAfter;
    }
  }
  domBoundsAround(t, e, i = 0) {
    let s = -1, r = -1, a = -1, o = -1;
    for (let l = 0, h = i, u = i; l < this.children.length; l++) {
      let p = this.children[l], y = h + p.length;
      if (h < t && y > e)
        return p.domBoundsAround(t, e, h);
      if (y >= t && s == -1 && (s = l, r = h), h > e && p.dom.parentNode == this.dom) {
        a = l, o = u;
        break;
      }
      u = y, h = y + p.breakAfter;
    }
    return {
      from: r,
      to: o < 0 ? i + this.length : o,
      startDOM: (s ? this.children[s - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: a < this.children.length && a >= 0 ? this.children[a].dom : null
    };
  }
  markDirty(t = !1) {
    this.flags |= 2, this.markParentsDirty(t);
  }
  markParentsDirty(t) {
    for (let e = this.parent; e; e = e.parent) {
      if (t && (e.flags |= 2), e.flags & 1)
        return;
      e.flags |= 1, t = !1;
    }
  }
  setParent(t) {
    this.parent != t && (this.parent = t, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(t) {
    this.dom != t && (this.dom && (this.dom.cmView = null), this.dom = t, t.cmView = this);
  }
  get rootView() {
    for (let t = this; ; ) {
      let e = t.parent;
      if (!e)
        return t;
      t = e;
    }
  }
  replaceChildren(t, e, i = f5) {
    this.markDirty();
    for (let s = t; s < e; s++) {
      let r = this.children[s];
      r.parent == this && i.indexOf(r) < 0 && r.destroy();
    }
    i.length < 250 ? this.children.splice(t, e - t, ...i) : this.children = [].concat(this.children.slice(0, t), i, this.children.slice(e));
    for (let s = 0; s < i.length; s++)
      i[s].setParent(this);
  }
  ignoreMutation(t) {
    return !1;
  }
  ignoreEvent(t) {
    return !1;
  }
  childCursor(t = this.length) {
    return new _Q(this.children, t, this.children.length);
  }
  childPos(t, e = 1) {
    return this.childCursor().findPos(t, e);
  }
  toString() {
    let t = this.constructor.name.replace("View", "");
    return t + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (t == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(t) {
    return t.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(t, e, i, s, r, a) {
    return !1;
  }
  become(t) {
    return !1;
  }
  canReuseDOM(t) {
    return t.constructor == this.constructor && !((this.flags | t.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let t of this.children)
      t.parent == this && t.destroy();
    this.parent = null;
  }
}, c(Mr, "Tr"), Mr);
f(RQ, "ContentView");
let te = RQ;
te.prototype.breakAfter = 0;
function q$(n) {
  let t = n.nextSibling;
  return n.parentNode.removeChild(n), t;
}
c(q$, "Dc$1");
f(q$, "rm$1");
var uh;
const EQ = (uh = class {
  constructor(t, e, i) {
    this.children = t, this.pos = e, this.i = i, this.off = 0;
  }
  findPos(t, e = 1) {
    for (; ; ) {
      if (t > this.pos || t == this.pos && (e > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = t - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}, c(uh, "Kh"), uh);
f(EQ, "ChildCursor");
let _Q = EQ;
function y5(n, t, e, i, s, r, a, o, l) {
  let { children: h } = n, u = h.length ? h[t] : null, p = r.length ? r[r.length - 1] : null, y = p ? p.breakAfter : a;
  if (!(t == i && u && !a && !y && r.length < 2 && u.merge(e, s, r.length ? p : null, e == 0, o, l))) {
    if (i < h.length) {
      let m = h[i];
      m && (s < m.length || m.breakAfter && p?.breakAfter) ? (t == i && (m = m.split(s), s = 0), !y && p && m.merge(0, s, p, !0, 0, l) ? r[r.length - 1] = m : ((s || m.children.length && !m.children[0].length) && m.merge(0, s, null, !1, 0, l), r.push(m))) : m?.breakAfter && (p ? p.breakAfter = 1 : a = 1), i++;
    }
    for (u && (u.breakAfter = a, e > 0 && (!a && r.length && u.merge(e, u.length, r[0], !1, o, 0) ? u.breakAfter = r.shift().breakAfter : (e < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(e, u.length, null, !1, o, 0), t++)); t < i && r.length; )
      if (h[i - 1].become(r[r.length - 1]))
        i--, r.pop(), l = r.length ? 0 : o;
      else if (h[t].become(r[0]))
        t++, r.shift(), o = r.length ? 0 : l;
      else
        break;
    !r.length && t && i < h.length && !h[t - 1].breakAfter && h[i].merge(0, 0, h[t - 1], !1, o, l) && t--, (t < i || r.length) && n.replaceChildren(t, i, r);
  }
}
c(y5, "sO");
f(y5, "replaceRange");
function m5(n, t, e, i, s, r) {
  let a = n.childCursor(), { i: o, off: l } = a.findPos(e, 1), { i: h, off: u } = a.findPos(t, -1), p = t - e;
  for (let y of i)
    p += y.length;
  n.length += p, y5(n, h, u, o, l, i, 0, s, r);
}
c(m5, "oO");
f(m5, "mergeChildrenInto");
const NZ = 256;
var Tr;
const zQ = (Tr = class extends te {
  constructor(t) {
    super(), this.text = t;
  }
  get length() {
    return this.text.length;
  }
  createDOM(t) {
    this.setDOM(t || document.createTextNode(this.text));
  }
  sync(t, e) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (e && e.node == this.dom && (e.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(t) {
    t.nodeType == 3 && this.createDOM(t);
  }
  merge(t, e, i) {
    return this.flags & 8 || i && (!(i instanceof Tr) || this.length - (e - t) + i.length > NZ || i.flags & 8) ? !1 : (this.text = this.text.slice(0, t) + (i ? i.text : "") + this.text.slice(e), this.markDirty(), !0);
  }
  split(t) {
    let e = new Tr(this.text.slice(t));
    return this.text = this.text.slice(0, t), this.markDirty(), e.flags |= this.flags & 8, e;
  }
  localPosFromDOM(t, e) {
    return t == this.dom ? e : e ? this.text.length : 0;
  }
  domAtPos(t) {
    return new ji(this.dom, t);
  }
  domBoundsAround(t, e, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(t, e) {
    return IQ(this.dom, t, e);
  }
}, c(Tr, "Ar"), Tr);
f(zQ, "TextView");
let Jr = zQ;
var Ar;
const LQ = (Ar = class extends te {
  constructor(t, e = [], i = 0) {
    super(), this.mark = t, this.children = e, this.length = i;
    for (let s of e)
      s.setParent(this);
  }
  setAttrs(t) {
    if (h5(t), this.mark.class && (t.className = this.mark.class), this.mark.attrs)
      for (let e in this.mark.attrs)
        t.setAttribute(e, this.mark.attrs[e]);
    return t;
  }
  canReuseDOM(t) {
    return super.canReuseDOM(t) && !((this.flags | t.flags) & 8);
  }
  reuseDOM(t) {
    t.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(t), this.flags |= 6);
  }
  sync(t, e) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(t, e);
  }
  merge(t, e, i, s, r, a) {
    return i && (!(i instanceof Ar && i.mark.eq(this.mark)) || t && r <= 0 || e < this.length && a <= 0) ? !1 : (m5(this, t, e, i ? i.children.slice() : [], r - 1, a - 1), this.markDirty(), !0);
  }
  split(t) {
    let e = [], i = 0, s = -1, r = 0;
    for (let o of this.children) {
      let l = i + o.length;
      l > t && e.push(i < t ? o.split(t - i) : o), s < 0 && i >= t && (s = r), i = l, r++;
    }
    let a = this.length - t;
    return this.length = t, s > -1 && (this.children.length = s, this.markDirty()), new Ar(this.mark, e, a);
  }
  domAtPos(t) {
    return w5(this, t);
  }
  coordsAt(t, e) {
    return v5(this, t, e);
  }
}, c(Ar, "Zr"), Ar);
f(LQ, "MarkView");
let Ff = LQ;
function IQ(n, t, e) {
  let i = n.nodeValue.length;
  t > i && (t = i);
  let s = t, r = t, a = 0;
  t == 0 && e < 0 || t == i && e >= 0 ? tt.chrome || tt.gecko || (t ? (s--, a = 1) : r < i && (r++, a = -1)) : e < 0 ? s-- : r < i && r++;
  let o = Kr(n, s, r).getClientRects();
  if (!o.length)
    return null;
  let l = o[(a ? a < 0 : e >= 0) ? 0 : o.length - 1];
  return tt.safari && !a && l.width == 0 && (l = Array.prototype.find.call(o, (h) => h.width) || l), a ? $y(l, a < 0) : l || null;
}
c(IQ, "Fg$1");
f(IQ, "textCoords");
var Xn;
const ZQ = (Xn = class extends te {
  static create(t, e, i) {
    return new Xn(t, e, i);
  }
  constructor(t, e, i) {
    super(), this.widget = t, this.length = e, this.side = i, this.prevWidget = null;
  }
  split(t) {
    let e = Xn.create(this.widget, this.length - t, this.side);
    return this.length -= t, e;
  }
  sync(t) {
    (!this.dom || !this.widget.updateDOM(this.dom, t)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(t, e, i, s, r, a) {
    return i && (!(i instanceof Xn) || !this.widget.compare(i.widget) || t > 0 && r <= 0 || e < this.length && a <= 0) ? !1 : (this.length = t + (i ? i.length : 0) + (this.length - e), !0);
  }
  become(t) {
    return t instanceof Xn && t.side == this.side && this.widget.constructor == t.widget.constructor ? (this.widget.compare(t.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Vt.empty;
    let t = this;
    for (; t.parent; )
      t = t.parent;
    let { view: e } = t, i = e && e.state.doc, s = this.posAtStart;
    return i ? i.slice(s, s + this.length) : Vt.empty;
  }
  domAtPos(t) {
    return (this.length ? t == 0 : this.side > 0) ? ji.before(this.dom) : ji.after(this.dom, t == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t, e) {
    let i = this.widget.coordsAt(this.dom, t, e);
    if (i)
      return i;
    let s = this.dom.getClientRects(), r = null;
    if (!s.length)
      return null;
    let a = this.side ? this.side < 0 : t > 0;
    for (let o = a ? s.length - 1 : 0; r = s[o], !(t > 0 ? o == 0 : o == s.length - 1 || r.top < r.bottom); o += a ? -1 : 1)
      ;
    return $y(r, !a);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}, c(Xn, "qt"), Xn);
f(ZQ, "WidgetView");
let VQ = ZQ;
var Rr;
const DQ = (Rr = class extends te {
  constructor(t) {
    super(), this.side = t;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(t) {
    return t instanceof Rr && t.side == this.side;
  }
  split() {
    return new Rr(this.side);
  }
  sync() {
    if (!this.dom) {
      let t = document.createElement("img");
      t.className = "cm-widgetBuffer", t.setAttribute("aria-hidden", "true"), this.setDOM(t);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(t) {
    return this.side > 0 ? ji.before(this.dom) : ji.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Vt.empty;
  }
  get isHidden() {
    return !0;
  }
}, c(Rr, "Lr"), Rr);
f(DQ, "WidgetBufferView");
let j$ = DQ;
Jr.prototype.children = VQ.prototype.children = j$.prototype.children = f5;
function w5(n, t) {
  let e = n.dom, { children: i } = n, s = 0;
  for (let r = 0; s < i.length; s++) {
    let a = i[s], o = r + a.length;
    if (!(o == r && a.getSide() <= 0)) {
      if (t > r && t < o && a.dom.parentNode == e)
        return a.domAtPos(t - r);
      if (t <= r)
        break;
      r = o;
    }
  }
  for (let r = s; r > 0; r--) {
    let a = i[r - 1];
    if (a.dom.parentNode == e)
      return a.domAtPos(a.length);
  }
  for (let r = s; r < i.length; r++) {
    let a = i[r];
    if (a.dom.parentNode == e)
      return a.domAtPos(0);
  }
  return new ji(e, 0);
}
c(w5, "lO");
f(w5, "inlineDOMAtPos");
function g5(n, t, e) {
  let i, { children: s } = n;
  e > 0 && t instanceof Ff && s.length && (i = s[s.length - 1]) instanceof Ff && i.mark.eq(t.mark) ? g5(i, t.children[0], e - 1) : (s.push(t), t.setParent(n)), n.length += t.length;
}
c(g5, "aO");
f(g5, "joinInlineInto");
function v5(n, t, e) {
  let i = null, s = -1, r = null, a = -1;
  function o(h, u) {
    for (let p = 0, y = 0; p < h.children.length && y <= u; p++) {
      let m = h.children[p], w = y + m.length;
      w >= u && (m.children.length ? o(m, u - y) : (!r || r.isHidden && (e > 0 || qQ(r, m))) && (w > u || y == w && m.getSide() > 0) ? (r = m, a = u - y) : (y < u || y == w && m.getSide() < 0 && !m.isHidden) && (i = m, s = u - y)), y = w;
    }
  }
  c(o, "l"), f(o, "scan"), o(n, t);
  let l = (e < 0 ? i : r) || i || r;
  return l ? l.coordsAt(Math.max(0, l == i ? s : a), e) : WQ(n);
}
c(v5, "hO");
f(v5, "coordsInChildren");
function WQ(n) {
  let t = n.dom.lastChild;
  if (!t)
    return n.dom.getBoundingClientRect();
  let e = Zo(t);
  return e[e.length - 1] || null;
}
c(WQ, "Kg$1");
f(WQ, "fallbackRect");
function qQ(n, t) {
  let e = n.coordsAt(0, 1), i = t.coordsAt(0, 1);
  return e && i && i.top < e.bottom;
}
c(qQ, "Jg$1");
f(qQ, "onSameLine");
function nv(n, t) {
  for (let e in n)
    e == "class" && t.class ? t.class += " " + n.class : e == "style" && t.style ? t.style += ";" + n.style : t[e] = n[e];
  return t;
}
c(nv, "Pl");
f(nv, "combineAttrs");
const s4 = /* @__PURE__ */ Object.create(null);
function fw(n, t, e) {
  if (n == t)
    return !0;
  n || (n = s4), t || (t = s4);
  let i = Object.keys(n), s = Object.keys(t);
  if (i.length - (e && i.indexOf(e) > -1 ? 1 : 0) != s.length - (e && s.indexOf(e) > -1 ? 1 : 0))
    return !1;
  for (let r of i)
    if (r != e && (s.indexOf(r) == -1 || n[r] !== t[r]))
      return !1;
  return !0;
}
c(fw, "as$2");
f(fw, "attrsEq");
function sv(n, t, e) {
  let i = !1;
  if (t)
    for (let s in t)
      e && s in e || (i = !0, s == "style" ? n.style.cssText = "" : n.removeAttribute(s));
  if (e)
    for (let s in e)
      t && t[s] == e[s] || (i = !0, s == "style" ? n.style.cssText = e[s] : n.setAttribute(s, e[s]));
  return i;
}
c(sv, "Rl$1");
f(sv, "updateAttrs");
function jQ(n) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let e = 0; e < n.attributes.length; e++) {
    let i = n.attributes[e];
    t[i.name] = i.value;
  }
  return t;
}
c(jQ, "e0$1");
f(jQ, "getAttrs$1");
var ph;
const FQ = (ph = class {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(t) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(t, e) {
    return !1;
  }
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(t) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(t, e, i) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(t) {
  }
}, c(ph, "Jh"), ph);
f(FQ, "WidgetType");
let xy = FQ;
var es = /* @__PURE__ */ function(n) {
  return n[n.Text = 0] = "Text", n[n.WidgetBefore = 1] = "WidgetBefore", n[n.WidgetAfter = 2] = "WidgetAfter", n[n.WidgetRange = 3] = "WidgetRange", n;
}(es || (es = {})), fh;
const UQ = (fh = class extends Io {
  constructor(t, e, i, s) {
    super(), this.startSide = t, this.endSide = e, this.widget = i, this.spec = s;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(t) {
    return new b5(t);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(t) {
    let e = Math.max(-1e4, Math.min(1e4, t.side || 0)), i = !!t.block;
    return e += i && !t.inlineOrder ? e > 0 ? 3e8 : -4e8 : e > 0 ? 1e8 : -1e8, new Uf(t, e, e, i, t.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(t) {
    let e = !!t.block, i, s;
    if (t.isBlockGap)
      i = -5e8, s = 4e8;
    else {
      let { start: r, end: a } = $5(t, e);
      i = (r ? e ? -3e8 : -1 : 5e8) - 1, s = (a ? e ? 2e8 : 1 : -6e8) + 1;
    }
    return new Uf(t, i, s, e, t.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(t) {
    return new O5(t);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(t, e = !1) {
    return hi.of(t, e);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}, c(fh, "ef"), fh);
f(UQ, "Decoration");
let ee = UQ;
ee.none = hi.empty;
var ao;
const BQ = (ao = class extends ee {
  constructor(t) {
    let { start: e, end: i } = $5(t);
    super(e ? -1 : 5e8, i ? 1 : -6e8, null, t), this.tagName = t.tagName || "span", this.class = t.class || "", this.attrs = t.attributes || null;
  }
  eq(t) {
    var e, i;
    return this == t || t instanceof ao && this.tagName == t.tagName && (this.class || ((e = this.attrs) === null || e === void 0 ? void 0 : e.class)) == (t.class || ((i = t.attrs) === null || i === void 0 ? void 0 : i.class)) && fw(this.attrs, t.attrs, "class");
  }
  range(t, e = t) {
    if (t >= e)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(t, e);
  }
}, c(ao, "Ns"), ao);
f(BQ, "MarkDecoration");
let b5 = BQ;
b5.prototype.point = !1;
var oo;
const XQ = (oo = class extends ee {
  constructor(t) {
    super(-2e8, -2e8, null, t);
  }
  eq(t) {
    return t instanceof oo && this.spec.class == t.spec.class && fw(this.spec.attributes, t.spec.attributes);
  }
  range(t, e = t) {
    if (e != t)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(t, e);
  }
}, c(oo, "Gs"), oo);
f(XQ, "LineDecoration");
let O5 = XQ;
O5.prototype.mapMode = wi.TrackBefore;
O5.prototype.point = !0;
var lo;
const NQ = (lo = class extends ee {
  constructor(t, e, i, s, r, a) {
    super(e, i, r, t), this.block = s, this.isReplace = a, this.mapMode = s ? e <= 0 ? wi.TrackBefore : wi.TrackAfter : wi.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? es.WidgetRange : this.startSide <= 0 ? es.WidgetBefore : es.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(t) {
    return t instanceof lo && HQ(this.widget, t.widget) && this.block == t.block && this.startSide == t.startSide && this.endSide == t.endSide;
  }
  range(t, e = t) {
    if (this.isReplace && (t > e || t == e && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && e != t)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(t, e);
  }
}, c(lo, "Hs"), lo);
f(NQ, "PointDecoration");
let Uf = NQ;
Uf.prototype.point = !0;
function $5(n, t = !1) {
  let { inclusiveStart: e, inclusiveEnd: i } = n;
  return e == null && (e = n.inclusive), i == null && (i = n.inclusive), { start: e ?? t, end: i ?? t };
}
c($5, "fO");
f($5, "getInclusive");
function HQ(n, t) {
  return n == t || !!(n && t && n.compare(t));
}
c(HQ, "t0$1");
f(HQ, "widgetsEq");
function ew(n, t, e, i = 0) {
  let s = e.length - 1;
  s >= 0 && e[s] + i >= n ? e[s] = Math.max(e[s], t) : e.push(n, t);
}
c(ew, "Nn$1");
f(ew, "addRange");
var Nn;
const YQ = (Nn = class extends te {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(t, e, i, s, r, a) {
    if (i) {
      if (!(i instanceof Nn))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return s && this.setDeco(i ? i.attrs : null), m5(this, t, e, i ? i.children.slice() : [], r, a), !0;
  }
  split(t) {
    let e = new Nn();
    if (e.breakAfter = this.breakAfter, this.length == 0)
      return e;
    let { i, off: s } = this.childPos(t);
    s && (e.append(this.children[i].split(s), 0), this.children[i].merge(s, this.children[i].length, null, !1, 0, 0), i++);
    for (let r = i; r < this.children.length; r++)
      e.append(this.children[r], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = t, e;
  }
  transferDOM(t) {
    this.dom && (this.markDirty(), t.setDOM(this.dom), t.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(t) {
    fw(this.attrs, t) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = t);
  }
  append(t, e) {
    g5(this, t, e);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(t) {
    let e = t.spec.attributes, i = t.spec.class;
    e && (this.attrs = nv(e, this.attrs || {})), i && (this.attrs = nv({ class: i }, this.attrs || {}));
  }
  domAtPos(t) {
    return w5(this, t);
  }
  reuseDOM(t) {
    t.nodeName == "DIV" && (this.setDOM(t), this.flags |= 6);
  }
  sync(t, e) {
    var i;
    this.dom ? this.flags & 4 && (h5(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (sv(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(t, e);
    let s = this.dom.lastChild;
    for (; s && te.get(s) instanceof Ff; )
      s = s.lastChild;
    if (!s || !this.length || s.nodeName != "BR" && ((i = te.get(s)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!tt.ios || !this.children.some((r) => r instanceof Jr))) {
      let r = document.createElement("BR");
      r.cmIgnore = !0, this.dom.appendChild(r);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let t = 0, e;
    for (let i of this.children) {
      if (!(i instanceof Jr) || /[^ -~]/.test(i.text))
        return null;
      let s = Zo(i.dom);
      if (s.length != 1)
        return null;
      t += s[0].width, e = s[0].height;
    }
    return t ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: t / this.length,
      textHeight: e
    } : null;
  }
  coordsAt(t, e) {
    let i = v5(this, t, e);
    if (!this.children.length && i && this.parent) {
      let { heightOracle: s } = this.parent.view.viewState, r = i.bottom - i.top;
      if (Math.abs(r - s.lineHeight) < 2 && s.textHeight < r) {
        let a = (r - s.textHeight) / 2;
        return { top: i.top + a, bottom: i.bottom - a, left: i.left, right: i.left };
      }
    }
    return i;
  }
  become(t) {
    return t instanceof Nn && this.children.length == 0 && t.children.length == 0 && fw(this.attrs, t.attrs) && this.breakAfter == t.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(t, e) {
    for (let i = 0, s = 0; i < t.children.length; i++) {
      let r = t.children[i], a = s + r.length;
      if (a >= e) {
        if (r instanceof Nn)
          return r;
        if (a > e)
          break;
      }
      s = a + r.breakAfter;
    }
    return null;
  }
}, c(Nn, "Dt"), Nn);
f(YQ, "LineView");
let pi = YQ;
var As;
const GQ = (As = class extends te {
  constructor(t, e, i) {
    super(), this.widget = t, this.length = e, this.deco = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(t, e, i, s, r, a) {
    return i && (!(i instanceof As) || !this.widget.compare(i.widget) || t > 0 && r <= 0 || e < this.length && a <= 0) ? !1 : (this.length = t + (i ? i.length : 0) + (this.length - e), !0);
  }
  domAtPos(t) {
    return t == 0 ? ji.before(this.dom) : ji.after(this.dom, t == this.length);
  }
  split(t) {
    let e = this.length - t;
    this.length = t;
    let i = new As(this.widget, e, this.deco);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return f5;
  }
  sync(t) {
    (!this.dom || !this.widget.updateDOM(this.dom, t)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Vt.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(t) {
    return t instanceof As && t.widget.constructor == this.widget.constructor ? (t.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, this.deco = t.deco, this.breakAfter = t.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(t, e) {
    return this.widget.coordsAt(this.dom, t, e) || (this.widget instanceof F$ ? null : $y(this.dom.getBoundingClientRect(), this.length ? t == 0 : e <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(t) {
    let { startSide: e, endSide: i } = this.deco;
    return e == i ? !1 : t < 0 ? e < 0 : i > 0;
  }
}, c(As, "bi"), As);
f(GQ, "BlockWidgetView");
let iw = GQ;
var yh;
const KQ = (yh = class extends xy {
  constructor(t) {
    super(), this.height = t;
  }
  toDOM() {
    let t = document.createElement("div");
    return t.className = "cm-gap", this.updateDOM(t), t;
  }
  eq(t) {
    return t.height == this.height;
  }
  updateDOM(t) {
    return t.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}, c(yh, "tf"), yh);
f(KQ, "BlockGapWidget");
let F$ = KQ;
var co;
const JQ = (co = class {
  constructor(t, e, i, s) {
    this.doc = t, this.pos = e, this.end = i, this.disallowBlockEffectsFor = s, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = t.iter(), this.skip = e;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let t = this.content[this.content.length - 1];
    return !(t.breakAfter || t instanceof iw && t.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new pi()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(t = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(um(new j$(-1), t), t.length), this.pendingBuffer = 0);
  }
  addBlockWidget(t) {
    this.flushBuffer(), this.curLine = null, this.content.push(t);
  }
  finish(t) {
    this.pendingBuffer && t <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(t && this.content.length && this.content[this.content.length - 1] instanceof iw) && this.getLine();
  }
  buildText(t, e, i) {
    for (; t > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: a, lineBreak: o, done: l } = this.cursor.next(this.skip);
        if (this.skip = 0, l)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, t--;
          continue;
        } else
          this.text = a, this.textOff = 0;
      }
      let s = Math.min(this.text.length - this.textOff, t), r = Math.min(
        s,
        512
        /* T.Chunk */
      );
      this.flushBuffer(e.slice(e.length - i)), this.getLine().append(um(new Jr(this.text.slice(this.textOff, this.textOff + r)), e), i), this.atCursorPos = !0, this.textOff += r, t -= r, i = s <= r ? 0 : e.length;
    }
  }
  span(t, e, i, s) {
    this.buildText(e - t, i, s), this.pos = e, this.openStart < 0 && (this.openStart = s);
  }
  point(t, e, i, s, r, a) {
    if (this.disallowBlockEffectsFor[a] && i instanceof Uf) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (e > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let o = e - t;
    if (i instanceof Uf)
      if (i.block)
        i.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new iw(i.widget || Bf.block, o, i));
      else {
        let l = VQ.create(i.widget || Bf.inline, o, o ? 0 : i.startSide), h = this.atCursorPos && !l.isEditable && r <= s.length && (t < e || i.startSide > 0), u = !l.isEditable && (t < e || r > s.length || i.startSide <= 0), p = this.getLine();
        this.pendingBuffer == 2 && !h && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(s), h && (p.append(um(new j$(1), s), r), r = s.length + Math.max(0, r - s.length)), p.append(um(l, s), r), this.atCursorPos = u, this.pendingBuffer = u ? t < e || r > s.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = s.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    o && (this.textOff + o <= this.text.length ? this.textOff += o : (this.skip += o - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = e), this.openStart < 0 && (this.openStart = r);
  }
  static build(t, e, i, s, r) {
    let a = new co(t, e, i, r);
    return a.openEnd = hi.spans(s, e, i, a), a.openStart < 0 && (a.openStart = a.openEnd), a.finish(a.openEnd), a;
  }
}, c(co, "Fs"), co);
f(JQ, "ContentBuilder");
let gO = JQ;
function um(n, t) {
  for (let e of t)
    n = new Ff(e, [n], n.length);
  return n;
}
c(um, "Tn$1");
f(um, "wrapMarks");
var mh;
const t7 = (mh = class extends xy {
  constructor(t) {
    super(), this.tag = t;
  }
  eq(t) {
    return t.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(t) {
    return t.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}, c(mh, "rf"), mh);
f(t7, "NullWidget");
let Bf = t7;
Bf.inline = /* @__PURE__ */ new Bf("span");
Bf.block = /* @__PURE__ */ new Bf("div");
var Qe = /* @__PURE__ */ function(n) {
  return n[n.LTR = 0] = "LTR", n[n.RTL = 1] = "RTL", n;
}(Qe || (Qe = {}));
const Vo = Qe.LTR, x5 = Qe.RTL;
function k5(n) {
  let t = [];
  for (let e = 0; e < n.length; e++)
    t.push(1 << +n[e]);
  return t;
}
c(k5, "cO");
f(k5, "dec");
const HZ = /* @__PURE__ */ k5("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), YZ = /* @__PURE__ */ k5("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), U$ = /* @__PURE__ */ Object.create(null), En = [];
for (let n of ["()", "[]", "{}"]) {
  let t = /* @__PURE__ */ n.charCodeAt(0), e = /* @__PURE__ */ n.charCodeAt(1);
  U$[t] = e, U$[e] = -t;
}
function S5(n) {
  return n <= 247 ? HZ[n] : 1424 <= n && n <= 1524 ? 2 : 1536 <= n && n <= 1785 ? YZ[n - 1536] : 1774 <= n && n <= 2220 ? 4 : 8192 <= n && n <= 8204 ? 256 : 64336 <= n && n <= 65023 ? 4 : 1;
}
c(S5, "uO");
f(S5, "charType");
const GZ = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
var wh;
const e7 = (wh = class {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? x5 : Vo;
  }
  /**
  @internal
  */
  constructor(t, e, i) {
    this.from = t, this.to = e, this.level = i;
  }
  /**
  @internal
  */
  side(t, e) {
    return this.dir == e == t ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(t, e) {
    return t == (this.dir == e);
  }
  /**
  @internal
  */
  static find(t, e, i, s) {
    let r = -1;
    for (let a = 0; a < t.length; a++) {
      let o = t[a];
      if (o.from <= e && o.to >= e) {
        if (o.level == i)
          return a;
        (r < 0 || (s != 0 ? s < 0 ? o.from < e : o.to > e : t[r].level > o.level)) && (r = a);
      }
    }
    if (r < 0)
      throw new RangeError("Index out of range");
    return r;
  }
}, c(wh, "nf"), wh);
f(e7, "BidiSpan");
let br = e7;
function P5(n, t) {
  if (n.length != t.length)
    return !1;
  for (let e = 0; e < n.length; e++) {
    let i = n[e], s = t[e];
    if (i.from != s.from || i.to != s.to || i.direction != s.direction || !P5(i.inner, s.inner))
      return !1;
  }
  return !0;
}
c(P5, "dO");
f(P5, "isolatesEq");
const Ut = [];
function i7(n, t, e, i, s) {
  for (let r = 0; r <= i.length; r++) {
    let a = r ? i[r - 1].to : t, o = r < i.length ? i[r].from : e, l = r ? 256 : s;
    for (let h = a, u = l, p = l; h < o; h++) {
      let y = S5(n.charCodeAt(h));
      y == 512 ? y = u : y == 8 && p == 4 && (y = 16), Ut[h] = y == 4 ? 2 : y, y & 7 && (p = y), u = y;
    }
    for (let h = a, u = l, p = l; h < o; h++) {
      let y = Ut[h];
      if (y == 128)
        h < o - 1 && u == Ut[h + 1] && u & 24 ? y = Ut[h] = u : Ut[h] = 256;
      else if (y == 64) {
        let m = h + 1;
        for (; m < o && Ut[m] == 64; )
          m++;
        let w = h && u == 8 || m < e && Ut[m] == 8 ? p == 1 ? 1 : 8 : 256;
        for (let b = h; b < m; b++)
          Ut[b] = w;
        h = m - 1;
      } else y == 8 && p == 1 && (Ut[h] = 1);
      u = y, y & 7 && (p = y);
    }
  }
}
c(i7, "s0$1");
f(i7, "computeCharTypes");
function n7(n, t, e, i, s) {
  let r = s == 1 ? 2 : 1;
  for (let a = 0, o = 0, l = 0; a <= i.length; a++) {
    let h = a ? i[a - 1].to : t, u = a < i.length ? i[a].from : e;
    for (let p = h, y, m, w; p < u; p++)
      if (m = U$[y = n.charCodeAt(p)])
        if (m < 0) {
          for (let b = o - 3; b >= 0; b -= 3)
            if (En[b + 1] == -m) {
              let $ = En[b + 2], x = $ & 2 ? s : $ & 4 ? $ & 1 ? r : s : 0;
              x && (Ut[p] = Ut[En[b]] = x), o = b;
              break;
            }
        } else {
          if (En.length == 189)
            break;
          En[o++] = p, En[o++] = y, En[o++] = l;
        }
      else if ((w = Ut[p]) == 2 || w == 1) {
        let b = w == s;
        l = b ? 0 : 1;
        for (let $ = o - 3; $ >= 0; $ -= 3) {
          let x = En[$ + 2];
          if (x & 2)
            break;
          if (b)
            En[$ + 2] |= 2;
          else {
            if (x & 4)
              break;
            En[$ + 2] |= 4;
          }
        }
      }
  }
}
c(n7, "o0$1");
f(n7, "processBracketPairs");
function s7(n, t, e, i) {
  for (let s = 0, r = i; s <= e.length; s++) {
    let a = s ? e[s - 1].to : n, o = s < e.length ? e[s].from : t;
    for (let l = a; l < o; ) {
      let h = Ut[l];
      if (h == 256) {
        let u = l + 1;
        for (; ; )
          if (u == o) {
            if (s == e.length)
              break;
            u = e[s++].to, o = s < e.length ? e[s].from : t;
          } else if (Ut[u] == 256)
            u++;
          else
            break;
        let p = r == 1, y = (u < t ? Ut[u] : i) == 1, m = p == y ? p ? 1 : 2 : i;
        for (let w = u, b = s, $ = b ? e[b - 1].to : n; w > l; )
          w == $ && (w = e[--b].from, $ = b ? e[b - 1].to : n), Ut[--w] = m;
        l = u;
      } else
        r = h, l++;
    }
  }
}
c(s7, "l0$1");
f(s7, "processNeutrals");
function rv(n, t, e, i, s, r, a) {
  let o = i % 2 ? 2 : 1;
  if (i % 2 == s % 2)
    for (let l = t, h = 0; l < e; ) {
      let u = !0, p = !1;
      if (h == r.length || l < r[h].from) {
        let b = Ut[l];
        b != o && (u = !1, p = b == 16);
      }
      let y = !u && o == 1 ? [] : null, m = u ? i : i + 1, w = l;
      t: for (; ; )
        if (h < r.length && w == r[h].from) {
          if (p)
            break t;
          let b = r[h];
          if (!u)
            for (let $ = b.to, x = h + 1; ; ) {
              if ($ == e)
                break t;
              if (x < r.length && r[x].from == $)
                $ = r[x++].to;
              else {
                if (Ut[$] == o)
                  break t;
                break;
              }
            }
          if (h++, y)
            y.push(b);
          else {
            b.from > l && a.push(new br(l, b.from, m));
            let $ = b.direction == Vo != !(m % 2);
            av(n, $ ? i + 1 : i, s, b.inner, b.from, b.to, a), l = b.to;
          }
          w = b.to;
        } else {
          if (w == e || (u ? Ut[w] != o : Ut[w] == o))
            break;
          w++;
        }
      y ? rv(n, l, w, i + 1, s, y, a) : l < w && a.push(new br(l, w, m)), l = w;
    }
  else
    for (let l = e, h = r.length; l > t; ) {
      let u = !0, p = !1;
      if (!h || l > r[h - 1].to) {
        let b = Ut[l - 1];
        b != o && (u = !1, p = b == 16);
      }
      let y = !u && o == 1 ? [] : null, m = u ? i : i + 1, w = l;
      t: for (; ; )
        if (h && w == r[h - 1].to) {
          if (p)
            break t;
          let b = r[--h];
          if (!u)
            for (let $ = b.from, x = h; ; ) {
              if ($ == t)
                break t;
              if (x && r[x - 1].to == $)
                $ = r[--x].from;
              else {
                if (Ut[$ - 1] == o)
                  break t;
                break;
              }
            }
          if (y)
            y.push(b);
          else {
            b.to < l && a.push(new br(b.to, l, m));
            let $ = b.direction == Vo != !(m % 2);
            av(n, $ ? i + 1 : i, s, b.inner, b.from, b.to, a), l = b.from;
          }
          w = b.from;
        } else {
          if (w == t || (u ? Ut[w - 1] != o : Ut[w - 1] == o))
            break;
          w--;
        }
      y ? rv(n, w, l, i + 1, s, y, a) : w < l && a.push(new br(w, l, m)), l = w;
    }
}
c(rv, "vl$1");
f(rv, "emitSpans");
function av(n, t, e, i, s, r, a) {
  let o = t % 2 ? 2 : 1;
  i7(n, s, r, i, o), n7(n, s, r, i, o), s7(s, r, i, o), rv(n, s, r, t, e, i, a);
}
c(av, "Tl$1");
f(av, "computeSectionOrder");
function r7(n, t, e) {
  if (!n)
    return [new br(0, 0, t == x5 ? 1 : 0)];
  if (t == Vo && !e.length && !GZ.test(n))
    return C5(n.length);
  if (e.length)
    for (; n.length > Ut.length; )
      Ut[Ut.length] = 256;
  let i = [], s = t == Vo ? 0 : 1;
  return av(n, s, s, e, 0, n.length, i), i;
}
c(r7, "a0$1");
f(r7, "computeOrder");
function C5(n) {
  return [new br(0, n, 0)];
}
c(C5, "OO");
f(C5, "trivialOrder");
let a7 = "";
function o7(n, t, e, i, s) {
  var r;
  let a = i.head - n.from, o = br.find(t, a, (r = i.bidiLevel) !== null && r !== void 0 ? r : -1, i.assoc), l = t[o], h = l.side(s, e);
  if (a == h) {
    let y = o += s ? 1 : -1;
    if (y < 0 || y >= t.length)
      return null;
    l = t[o = y], a = l.side(!s, e), h = l.side(s, e);
  }
  let u = wn(n.text, a, l.forward(s, e));
  (u < l.from || u > l.to) && (u = h), a7 = n.text.slice(Math.min(a, u), Math.max(a, u));
  let p = o == (s ? t.length - 1 : 0) ? null : t[o + (s ? 1 : -1)];
  return p && u == h && p.level + (s ? 0 : 1) < l.level ? J.cursor(p.side(!s, e) + n.from, p.forward(s, e) ? 1 : -1, p.level) : J.cursor(u + n.from, l.forward(s, e) ? -1 : 1, l.level);
}
c(o7, "h0$1");
f(o7, "moveVisually");
function l7(n, t, e) {
  for (let i = t; i < e; i++) {
    let s = S5(n.charCodeAt(i));
    if (s == 1)
      return Vo;
    if (s == 2 || s == 4)
      return x5;
  }
  return Vo;
}
c(l7, "f0$1");
f(l7, "autoDirection");
const c7 = /* @__PURE__ */ gt.define(), h7 = /* @__PURE__ */ gt.define(), d7 = /* @__PURE__ */ gt.define(), u7 = /* @__PURE__ */ gt.define(), B$ = /* @__PURE__ */ gt.define(), p7 = /* @__PURE__ */ gt.define(), f7 = /* @__PURE__ */ gt.define(), Q5 = /* @__PURE__ */ gt.define(), M5 = /* @__PURE__ */ gt.define(), y7 = /* @__PURE__ */ gt.define({
  combine: /* @__PURE__ */ f((n) => n.some((t) => t), "combine")
}), KZ = /* @__PURE__ */ gt.define({
  combine: /* @__PURE__ */ f((n) => n.some((t) => t), "combine")
}), m7 = /* @__PURE__ */ gt.define();
var Er;
const w7 = (Er = class {
  constructor(t, e = "nearest", i = "nearest", s = 5, r = 5, a = !1) {
    this.range = t, this.y = e, this.x = i, this.yMargin = s, this.xMargin = r, this.isSnapshot = a;
  }
  map(t) {
    return t.empty ? this : new Er(this.range.map(t), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(t) {
    return this.range.to <= t.doc.length ? this : new Er(J.cursor(t.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}, c(Er, "Mr"), Er);
f(w7, "ScrollTarget");
let vO = w7;
const Tg = /* @__PURE__ */ Bt.define({ map: /* @__PURE__ */ f((n, t) => n.map(t), "map") }), g7 = /* @__PURE__ */ Bt.define();
function Ci(n, t, e) {
  let i = n.facet(u7);
  i.length ? i[0](t) : window.onerror && window.onerror(String(t), e, void 0, void 0, t) || (e ? console.error(e + ":", t) : console.error(t));
}
c(Ci, "$e$2");
f(Ci, "logException");
const $s = /* @__PURE__ */ gt.define({ combine: /* @__PURE__ */ f((n) => n.length ? n[0] : !0, "combine") });
let JZ = 0;
const Rc = /* @__PURE__ */ gt.define({
  combine(n) {
    return n.filter((t, e) => {
      for (let i = 0; i < e; i++)
        if (n[i].plugin == t.plugin)
          return !1;
      return !0;
    });
  }
});
var _r;
const v7 = (_r = class {
  constructor(t, e, i, s, r) {
    this.id = t, this.create = e, this.domEventHandlers = i, this.domEventObservers = s, this.baseExtensions = r(this), this.extension = this.baseExtensions.concat(Rc.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(t) {
    return this.baseExtensions.concat(Rc.of({ plugin: this, arg: t }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(t, e) {
    const { eventHandlers: i, eventObservers: s, provide: r, decorations: a } = e || {};
    return new _r(JZ++, t, i, s, (o) => {
      let l = [];
      return a && l.push(yw.of((h) => {
        let u = h.plugin(o);
        return u ? a(u) : ee.none;
      })), r && l.push(r(o)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(t, e) {
    return _r.define((i, s) => new t(i, s), e);
  }
}, c(_r, "_r"), _r);
f(v7, "ViewPlugin");
let Zs = v7;
var gh;
const b7 = (gh = class {
  constructor(t) {
    this.spec = t, this.mustUpdate = null, this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(t) {
    if (this.value) {
      if (this.mustUpdate) {
        let e = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(e);
          } catch (i) {
            if (Ci(e.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.plugin.create(t, this.spec.arg);
      } catch (e) {
        Ci(t.state, e, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(t) {
    var e;
    if (!((e = this.value) === null || e === void 0) && e.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        Ci(t.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}, c(gh, "sf"), gh);
f(b7, "PluginInstance");
let bO = b7;
const O7 = /* @__PURE__ */ gt.define(), T5 = /* @__PURE__ */ gt.define(), yw = /* @__PURE__ */ gt.define(), $7 = /* @__PURE__ */ gt.define(), Kw = /* @__PURE__ */ gt.define(), x7 = /* @__PURE__ */ gt.define();
function X$(n, t) {
  let e = n.state.facet(x7);
  if (!e.length)
    return e;
  let i = e.map((r) => r instanceof Function ? r(n) : r), s = [];
  return hi.spans(i, t.from, t.to, {
    point() {
    },
    span(r, a, o, l) {
      let h = r - t.from, u = a - t.from, p = s;
      for (let y = o.length - 1; y >= 0; y--, l--) {
        let m = o[y].spec.bidiIsolate, w;
        if (m == null && (m = l7(t.text, h, u)), l > 0 && p.length && (w = p[p.length - 1]).to == h && w.direction == m)
          w.to = u, p = w.inner;
        else {
          let b = { from: h, to: u, direction: m, inner: [] };
          p.push(b), p = b.inner;
        }
      }
    }
  }), s;
}
c(X$, "zc$1");
f(X$, "getIsolatedRanges");
const k7 = /* @__PURE__ */ gt.define();
function yb(n) {
  let t = 0, e = 0, i = 0, s = 0;
  for (let r of n.state.facet(k7)) {
    let a = r(n);
    a && (a.left != null && (t = Math.max(t, a.left)), a.right != null && (e = Math.max(e, a.right)), a.top != null && (i = Math.max(i, a.top)), a.bottom != null && (s = Math.max(s, a.bottom)));
  }
  return { left: t, right: e, top: i, bottom: s };
}
c(yb, "ah");
f(yb, "getScrollMargins");
const pm = /* @__PURE__ */ gt.define();
var Rs;
const S7 = (Rs = class {
  constructor(t, e, i, s) {
    this.fromA = t, this.toA = e, this.fromB = i, this.toB = s;
  }
  join(t) {
    return new Rs(Math.min(this.fromA, t.fromA), Math.max(this.toA, t.toA), Math.min(this.fromB, t.fromB), Math.max(this.toB, t.toB));
  }
  addToSet(t) {
    let e = t.length, i = this;
    for (; e > 0; e--) {
      let s = t[e - 1];
      if (!(s.fromA > i.toA)) {
        if (s.toA < i.fromA)
          break;
        i = i.join(s), t.splice(e - 1, 1);
      }
    }
    return t.splice(e, 0, i), t;
  }
  static extendWithRanges(t, e) {
    if (e.length == 0)
      return t;
    let i = [];
    for (let s = 0, r = 0, a = 0, o = 0; ; s++) {
      let l = s == t.length ? null : t[s], h = a - o, u = l ? l.fromB : 1e9;
      for (; r < e.length && e[r] < u; ) {
        let p = e[r], y = e[r + 1], m = Math.max(o, p), w = Math.min(u, y);
        if (m <= w && new Rs(m + h, w + h, m, w).addToSet(i), y > u)
          break;
        r += 2;
      }
      if (!l)
        return i;
      new Rs(l.fromA, l.toA, l.fromB, l.toB).addToSet(i), a = l.toA, o = l.toB;
    }
  }
}, c(Rs, "Si"), Rs);
f(S7, "ChangedRange");
let kr = S7;
var ho;
const P7 = (ho = class {
  constructor(t, e, i) {
    this.view = t, this.state = e, this.transactions = i, this.flags = 0, this.startState = t.state, this.changes = $n.empty(this.startState.doc.length);
    for (let r of i)
      this.changes = this.changes.compose(r.changes);
    let s = [];
    this.changes.iterChangedRanges((r, a, o, l) => s.push(new kr(r, a, o, l))), this.changedRanges = s;
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new ho(t, e, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((t) => t.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}, c(ho, "Ks"), ho);
f(P7, "ViewUpdate");
let r4 = P7;
var vh;
const C7 = (vh = class extends te {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(t) {
    super(), this.view = t, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = ee.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(t.contentDOM), this.children = [new pi()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new kr(0, 0, 0, t.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(t) {
    var e;
    let i = t.changedRanges;
    this.minWidth > 0 && i.length && (i.every(({ fromA: h, toA: u }) => u < this.minWidthFrom || h > this.minWidthTo) ? (this.minWidthFrom = t.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(t);
    let s = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((e = this.domChanged) === null || e === void 0) && e.newSel ? s = this.domChanged.newSel.head : !E7(t.changes, this.hasComposition) && !t.selectionSet && (s = t.state.selection.main.head));
    let r = s > -1 ? M7(this.view, t.changes, s) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: h, to: u } = this.hasComposition;
      i = new kr(h, u, t.changes.mapPos(h, -1), t.changes.mapPos(u, 1)).addToSet(i.slice());
    }
    this.hasComposition = r ? { from: r.range.fromB, to: r.range.toB } : null, (tt.ie || tt.chrome) && !r && t && t.state.doc.lines != t.startState.doc.lines && (this.forceSelection = !0);
    let a = this.decorations, o = this.updateDeco(), l = A7(a, o, t.changes);
    return i = kr.extendWithRanges(i, l), !(this.flags & 7) && i.length == 0 ? !1 : (this.updateInner(i, t.startState.doc.length, r), t.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(t, e, i) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(t, e, i);
    let { observer: s } = this.view;
    s.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let a = tt.chrome || tt.ios ? { node: s.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, a), this.flags &= -8, a && (a.written || s.selectionRange.focusNode != a.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (a) => a.flags &= -9
      /* ViewFlag.Composition */
    );
    let r = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let a of this.children)
        a instanceof iw && a.widget instanceof F$ && r.push(a.dom);
    s.updateGaps(r);
  }
  updateChildren(t, e, i) {
    let s = i ? i.range.addToSet(t.slice()) : t, r = this.childCursor(e);
    for (let a = s.length - 1; ; a--) {
      let o = a >= 0 ? s[a] : null;
      if (!o)
        break;
      let { fromA: l, toA: h, fromB: u, toB: p } = o, y, m, w, b;
      if (i && i.range.fromB < p && i.range.toB > u) {
        let E = gO.build(this.view.state.doc, u, i.range.fromB, this.decorations, this.dynamicDecorationMap), A = gO.build(this.view.state.doc, i.range.toB, p, this.decorations, this.dynamicDecorationMap);
        m = E.breakAtStart, w = E.openStart, b = A.openEnd;
        let I = this.compositionView(i);
        A.breakAtStart ? I.breakAfter = 1 : A.content.length && I.merge(I.length, I.length, A.content[0], !1, A.openStart, 0) && (I.breakAfter = A.content[0].breakAfter, A.content.shift()), E.content.length && I.merge(0, 0, E.content[E.content.length - 1], !0, 0, E.openEnd) && E.content.pop(), y = E.content.concat(I).concat(A.content);
      } else
        ({ content: y, breakAtStart: m, openStart: w, openEnd: b } = gO.build(this.view.state.doc, u, p, this.decorations, this.dynamicDecorationMap));
      let { i: $, off: x } = r.findPos(h, 1), { i: C, off: R } = r.findPos(l, -1);
      y5(this, C, R, $, x, y, m, w, b);
    }
    i && this.fixCompositionDOM(i);
  }
  updateEditContextFormatting(t) {
    this.editContextFormatting = this.editContextFormatting.map(t.changes);
    for (let e of t.transactions)
      for (let i of e.effects)
        i.is(g7) && (this.editContextFormatting = i.value);
  }
  compositionView(t) {
    let e = new Jr(t.text.nodeValue);
    e.flags |= 8;
    for (let { deco: s } of t.marks)
      e = new Ff(s, [e], e.length);
    let i = new pi();
    return i.append(e, 0), i;
  }
  fixCompositionDOM(t) {
    let e = /* @__PURE__ */ f((r, a) => {
      a.flags |= 8 | (a.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(a);
      let o = te.get(r);
      o && o != a && (o.dom = null), a.setDOM(r);
    }, "fix"), i = this.childPos(t.range.fromB, 1), s = this.children[i.i];
    e(t.line, s);
    for (let r = t.marks.length - 1; r >= -1; r--)
      i = s.childPos(i.off, 1), s = s.children[i.i], e(r >= 0 ? t.marks[r].node : t.text, s);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(t = !1, e = !1) {
    (t || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let i = this.view.root.activeElement, s = i == this.dom, r = !s && !(this.view.state.facet($s) || this.dom.tabIndex > -1) && tw(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i));
    if (!(s || e || r))
      return;
    let a = this.forceSelection;
    this.forceSelection = !1;
    let o = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(o.anchor)), h = o.empty ? l : this.moveToLine(this.domAtPos(o.head));
    if (tt.gecko && o.empty && !this.hasComposition && Q7(l)) {
      let p = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(p, l.node.childNodes[l.offset] || null)), l = h = new ji(p, 0), a = !0;
    }
    let u = this.view.observer.selectionRange;
    (a || !u.focusNode || (!Ic(l.node, l.offset, u.anchorNode, u.anchorOffset) || !Ic(h.node, h.offset, u.focusNode, u.focusOffset)) && !this.suppressWidgetCursorChange(u, o)) && (this.view.observer.ignore(() => {
      tt.android && tt.chrome && this.dom.contains(u.focusNode) && R7(u.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let p = jf(this.view.root);
      if (p) if (o.empty) {
        if (tt.gecko) {
          let y = T7(l.node, l.offset);
          if (y && y != 3) {
            let m = (y == 1 ? u5 : p5)(l.node, l.offset);
            m && (l = new ji(m.node, m.offset));
          }
        }
        p.collapse(l.node, l.offset), o.bidiLevel != null && p.caretBidiLevel !== void 0 && (p.caretBidiLevel = o.bidiLevel);
      } else if (p.extend) {
        p.collapse(l.node, l.offset);
        try {
          p.extend(h.node, h.offset);
        } catch {
        }
      } else {
        let y = document.createRange();
        o.anchor > o.head && ([l, h] = [h, l]), y.setEnd(h.node, h.offset), y.setStart(l.node, l.offset), p.removeAllRanges(), p.addRange(y);
      }
      r && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus());
    }), this.view.observer.setSelectionRange(l, h)), this.impreciseAnchor = l.precise ? null : new ji(u.anchorNode, u.anchorOffset), this.impreciseHead = h.precise ? null : new ji(u.focusNode, u.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(t, e) {
    return this.hasComposition && e.empty && Ic(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset) && this.posFromDOM(t.focusNode, t.focusOffset) == e.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: t } = this, e = t.state.selection.main, i = jf(t.root), { anchorNode: s, anchorOffset: r } = t.observer.selectionRange;
    if (!i || !e.empty || !e.assoc || !i.modify)
      return;
    let a = pi.find(this, e.head);
    if (!a)
      return;
    let o = a.posAtStart;
    if (e.head == o || e.head == o + a.length)
      return;
    let l = this.coordsAt(e.head, -1), h = this.coordsAt(e.head, 1);
    if (!l || !h || l.bottom > h.top)
      return;
    let u = this.domAtPos(e.head + e.assoc);
    i.collapse(u.node, u.offset), i.modify("move", e.assoc < 0 ? "forward" : "backward", "lineboundary"), t.observer.readSelectionRange();
    let p = t.observer.selectionRange;
    t.docView.posFromDOM(p.anchorNode, p.anchorOffset) != e.from && i.collapse(s, r);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(t) {
    let e = this.dom, i;
    if (t.node != e)
      return t;
    for (let s = t.offset; !i && s < e.childNodes.length; s++) {
      let r = te.get(e.childNodes[s]);
      r instanceof pi && (i = r.domAtPos(0));
    }
    for (let s = t.offset - 1; !i && s >= 0; s--) {
      let r = te.get(e.childNodes[s]);
      r instanceof pi && (i = r.domAtPos(r.length));
    }
    return i ? new ji(i.node, i.offset, !0) : t;
  }
  nearest(t) {
    for (let e = t; e; ) {
      let i = te.get(e);
      if (i && i.rootView == this)
        return i;
      e = e.parentNode;
    }
    return null;
  }
  posFromDOM(t, e) {
    let i = this.nearest(t);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(t, e) + i.posAtStart;
  }
  domAtPos(t) {
    let { i: e, off: i } = this.childCursor().findPos(t, -1);
    for (; e < this.children.length - 1; ) {
      let s = this.children[e];
      if (i < s.length || s instanceof pi)
        break;
      e++, i = 0;
    }
    return this.children[e].domAtPos(i);
  }
  coordsAt(t, e) {
    let i = null, s = 0;
    for (let r = this.length, a = this.children.length - 1; a >= 0; a--) {
      let o = this.children[a], l = r - o.breakAfter, h = l - o.length;
      if (l < t)
        break;
      if (h <= t && (h < t || o.covers(-1)) && (l > t || o.covers(1)) && (!i || o instanceof pi && !(i instanceof pi && e >= 0)))
        i = o, s = h;
      else if (i && h == t && l == t && o instanceof iw && Math.abs(e) < 2) {
        if (o.deco.startSide < 0)
          break;
        a && (i = null);
      }
      r = h;
    }
    return i ? i.coordsAt(t - s, e) : null;
  }
  coordsForChar(t) {
    let { i: e, off: i } = this.childPos(t, 1), s = this.children[e];
    if (!(s instanceof pi))
      return null;
    for (; s.children.length; ) {
      let { i: o, off: l } = s.childPos(i, 1);
      for (; ; o++) {
        if (o == s.children.length)
          return null;
        if ((s = s.children[o]).length)
          break;
      }
      i = l;
    }
    if (!(s instanceof Jr))
      return null;
    let r = wn(s.text, i);
    if (r == i)
      return null;
    let a = Kr(s.dom, i, r).getClientRects();
    for (let o = 0; o < a.length; o++) {
      let l = a[o];
      if (o == a.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(t) {
    let e = [], { from: i, to: s } = t, r = this.view.contentDOM.clientWidth, a = r > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, o = -1, l = this.view.textDirection == Qe.LTR;
    for (let h = 0, u = 0; u < this.children.length; u++) {
      let p = this.children[u], y = h + p.length;
      if (y > s)
        break;
      if (h >= i) {
        let m = p.dom.getBoundingClientRect();
        if (e.push(m.height), a) {
          let w = p.dom.lastChild, b = w ? Zo(w) : [];
          if (b.length) {
            let $ = b[b.length - 1], x = l ? $.right - m.left : m.right - $.left;
            x > o && (o = x, this.minWidth = r, this.minWidthFrom = h, this.minWidthTo = y);
          }
        }
      }
      h = y + p.breakAfter;
    }
    return e;
  }
  textDirectionAt(t) {
    let { i: e } = this.childPos(t, 1);
    return getComputedStyle(this.children[e].dom).direction == "rtl" ? Qe.RTL : Qe.LTR;
  }
  measureTextSize() {
    for (let r of this.children)
      if (r instanceof pi) {
        let a = r.measureTextSize();
        if (a)
          return a;
      }
    let t = document.createElement("div"), e, i, s;
    return t.className = "cm-line", t.style.width = "99999px", t.style.position = "absolute", t.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(t);
      let r = Zo(t.firstChild)[0];
      e = t.getBoundingClientRect().height, i = r ? r.width / 27 : 7, s = r ? r.height : e, t.remove();
    }), { lineHeight: e, charWidth: i, textHeight: s };
  }
  childCursor(t = this.length) {
    let e = this.children.length;
    return e && (t -= this.children[--e].length), new _Q(this.children, t, e);
  }
  computeBlockGapDeco() {
    let t = [], e = this.view.viewState;
    for (let i = 0, s = 0; ; s++) {
      let r = s == e.viewports.length ? null : e.viewports[s], a = r ? r.from - 1 : this.length;
      if (a > i) {
        let o = (e.lineBlockAt(a).bottom - e.lineBlockAt(i).top) / this.view.scaleY;
        t.push(ee.replace({
          widget: new F$(o),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, a));
      }
      if (!r)
        break;
      i = r.to + 1;
    }
    return ee.set(t);
  }
  updateDeco() {
    let t = 1, e = this.view.state.facet(yw).map((r) => (this.dynamicDecorationMap[t++] = typeof r == "function") ? r(this.view) : r), i = !1, s = this.view.state.facet($7).map((r, a) => {
      let o = typeof r == "function";
      return o && (i = !0), o ? r(this.view) : r;
    });
    for (s.length && (this.dynamicDecorationMap[t++] = i, e.push(hi.join(s))), this.decorations = [
      this.editContextFormatting,
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; t < this.decorations.length; )
      this.dynamicDecorationMap[t++] = !1;
    return this.decorations;
  }
  scrollIntoView(t) {
    if (t.isSnapshot) {
      let h = this.view.viewState.lineBlockAt(t.range.head);
      this.view.scrollDOM.scrollTop = h.top - t.yMargin, this.view.scrollDOM.scrollLeft = t.xMargin;
      return;
    }
    for (let h of this.view.state.facet(m7))
      try {
        if (h(this.view, t.range, t))
          return !0;
      } catch (u) {
        Ci(this.view.state, u, "scroll handler");
      }
    let { range: e } = t, i = this.coordsAt(e.head, e.empty ? e.assoc : e.head > e.anchor ? -1 : 1), s;
    if (!i)
      return;
    !e.empty && (s = this.coordsAt(e.anchor, e.anchor > e.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, s.left),
      top: Math.min(i.top, s.top),
      right: Math.max(i.right, s.right),
      bottom: Math.max(i.bottom, s.bottom)
    });
    let r = yb(this.view), a = {
      left: i.left - r.left,
      top: i.top - r.top,
      right: i.right + r.right,
      bottom: i.bottom + r.bottom
    }, { offsetWidth: o, offsetHeight: l } = this.view.scrollDOM;
    PQ(this.view.scrollDOM, a, e.head < e.anchor ? -1 : 1, t.x, t.y, Math.max(Math.min(t.xMargin, o), -o), Math.max(Math.min(t.yMargin, l), -l), this.view.textDirection == Qe.LTR);
  }
}, c(vh, "of"), vh);
f(C7, "DocView");
let a4 = C7;
function Q7(n) {
  return n.node.nodeType == 1 && n.node.firstChild && (n.offset == 0 || n.node.childNodes[n.offset - 1].contentEditable == "false") && (n.offset == n.node.childNodes.length || n.node.childNodes[n.offset].contentEditable == "false");
}
c(Q7, "d0$1");
f(Q7, "betweenUneditable");
function A5(n, t) {
  let e = n.observer.selectionRange;
  if (!e.focusNode)
    return null;
  let i = u5(e.focusNode, e.focusOffset), s = p5(e.focusNode, e.focusOffset), r = i || s;
  if (s && i && s.node != i.node) {
    let o = te.get(s.node);
    if (!o || o instanceof Jr && o.text != s.node.nodeValue)
      r = s;
    else if (n.docView.lastCompositionAfterCursor) {
      let l = te.get(i.node);
      !l || l instanceof Jr && l.text != i.node.nodeValue || (r = s);
    }
  }
  if (n.docView.lastCompositionAfterCursor = r != i, !r)
    return null;
  let a = t - r.offset;
  return { from: a, to: a + r.node.nodeValue.length, node: r.node };
}
c(A5, "TO");
f(A5, "findCompositionNode");
function M7(n, t, e) {
  let i = A5(n, e);
  if (!i)
    return null;
  let { node: s, from: r, to: a } = i, o = s.nodeValue;
  if (/[\n\r]/.test(o) || n.state.doc.sliceString(i.from, i.to) != o)
    return null;
  let l = t.invertedDesc, h = new kr(l.mapPos(r), l.mapPos(a), r, a), u = [];
  for (let p = s.parentNode; ; p = p.parentNode) {
    let y = te.get(p);
    if (y instanceof Ff)
      u.push({ node: p, deco: y.mark });
    else {
      if (y instanceof pi || p.nodeName == "DIV" && p.parentNode == n.contentDOM)
        return { range: h, text: s, marks: u, line: p };
      if (p != n.contentDOM)
        u.push({ node: p, deco: new b5({
          inclusive: !0,
          attributes: jQ(p),
          tagName: p.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
c(M7, "O0$1");
f(M7, "findCompositionRange");
function T7(n, t) {
  return n.nodeType != 1 ? 0 : (t && n.childNodes[t - 1].contentEditable == "false" ? 1 : 0) | (t < n.childNodes.length && n.childNodes[t].contentEditable == "false" ? 2 : 0);
}
c(T7, "p0$1");
f(T7, "nextToUneditable");
var OO, bh;
let tV = (OO = (bh = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t, e) {
    ew(t, e, this.changes);
  }
  comparePoint(t, e) {
    ew(t, e, this.changes);
  }
  boundChange(t) {
    ew(t, t, this.changes);
  }
}, c(bh, "Ai$1"), bh), f(OO, "DecorationComparator"), OO);
function A7(n, t, e) {
  let i = new tV();
  return hi.compare(n, t, e, i), i.changes;
}
c(A7, "g0$1");
f(A7, "findChangedDeco");
function R7(n, t) {
  for (let e = n; e && e != t; e = e.assignedSlot || e.parentNode)
    if (e.nodeType == 1 && e.contentEditable == "false")
      return !0;
  return !1;
}
c(R7, "y0$1");
f(R7, "inUneditable");
function E7(n, t) {
  let e = !1;
  return t && n.iterChangedRanges((i, s) => {
    i < t.to && s > t.from && (e = !0);
  }), e;
}
c(E7, "b0$1");
f(E7, "touchesComposition");
function _7(n, t, e = 1) {
  let i = n.charCategorizer(t), s = n.doc.lineAt(t), r = t - s.from;
  if (s.length == 0)
    return J.cursor(t);
  r == 0 ? e = 1 : r == s.length && (e = -1);
  let a = r, o = r;
  e < 0 ? a = wn(s.text, r, !1) : o = wn(s.text, r);
  let l = i(s.text.slice(a, o));
  for (; a > 0; ) {
    let h = wn(s.text, a, !1);
    if (i(s.text.slice(h, a)) != l)
      break;
    a = h;
  }
  for (; o < s.length; ) {
    let h = wn(s.text, o);
    if (i(s.text.slice(o, h)) != l)
      break;
    o = h;
  }
  return J.range(a + s.from, o + s.from);
}
c(_7, "S0$1");
f(_7, "groupAt");
function z7(n, t) {
  return t.left > n ? t.left - n : Math.max(0, n - t.right);
}
c(z7, "Q0$1");
f(z7, "getdx");
function L7(n, t) {
  return t.top > n ? t.top - n : Math.max(0, n - t.bottom);
}
c(L7, "w0$1");
f(L7, "getdy");
function n1(n, t) {
  return n.top < t.bottom - 1 && n.bottom > t.top + 1;
}
c(n1, "To$1");
f(n1, "yOverlap");
function N$(n, t) {
  return t < n.top ? { top: t, left: n.left, right: n.right, bottom: n.bottom } : n;
}
c(N$, "Nc$1");
f(N$, "upTop");
function H$(n, t) {
  return t > n.bottom ? { top: n.top, left: n.left, right: n.right, bottom: t } : n;
}
c(H$, "Gc$1");
f(H$, "upBot");
function ov(n, t, e) {
  let i, s, r, a, o = !1, l, h, u, p;
  for (let w = n.firstChild; w; w = w.nextSibling) {
    let b = Zo(w);
    for (let $ = 0; $ < b.length; $++) {
      let x = b[$];
      s && n1(s, x) && (x = N$(H$(x, s.bottom), s.top));
      let C = z7(t, x), R = L7(e, x);
      if (C == 0 && R == 0)
        return w.nodeType == 3 ? Y$(w, t, e) : ov(w, t, e);
      (!i || a > R || a == R && r > C) && (i = w, s = x, r = C, a = R, o = C ? t < x.left ? $ > 0 : $ < b.length - 1 : !0), C == 0 ? e > x.bottom && (!u || u.bottom < x.bottom) ? (l = w, u = x) : e < x.top && (!p || p.top > x.top) && (h = w, p = x) : u && n1(u, x) ? u = H$(u, x.bottom) : p && n1(p, x) && (p = N$(p, x.top));
    }
  }
  if (u && u.bottom >= e ? (i = l, s = u) : p && p.top <= e && (i = h, s = p), !i)
    return { node: n, offset: 0 };
  let y = Math.max(s.left, Math.min(s.right, t));
  if (i.nodeType == 3)
    return Y$(i, y, e);
  if (o && i.contentEditable != "false")
    return ov(i, y, e);
  let m = Array.prototype.indexOf.call(n.childNodes, i) + (t >= (s.left + s.right) / 2 ? 1 : 0);
  return { node: n, offset: m };
}
c(ov, "Zl$1");
f(ov, "domPosAtCoords");
function Y$(n, t, e) {
  let i = n.nodeValue.length, s = -1, r = 1e9, a = 0;
  for (let o = 0; o < i; o++) {
    let l = Kr(n, o, o + 1).getClientRects();
    for (let h = 0; h < l.length; h++) {
      let u = l[h];
      if (u.top == u.bottom)
        continue;
      a || (a = t - u.left);
      let p = (u.top > e ? u.top - e : e - u.bottom) - 1;
      if (u.left - 1 <= t && u.right + 1 >= t && p < r) {
        let y = t >= (u.left + u.right) / 2, m = y;
        if ((tt.chrome || tt.gecko) && Kr(n, o).getBoundingClientRect().left == u.right && (m = !y), p <= 0)
          return { node: n, offset: o + (m ? 1 : 0) };
        s = o + (m ? 1 : 0), r = p;
      }
    }
  }
  return { node: n, offset: s > -1 ? s : a > 0 ? n.nodeValue.length : 0 };
}
c(Y$, "Hc$1");
f(Y$, "domPosInText");
function R5(n, t, e, i = -1) {
  var s, r;
  let a = n.contentDOM.getBoundingClientRect(), o = a.top + n.viewState.paddingTop, l, { docHeight: h } = n.viewState, { x: u, y: p } = t, y = p - o;
  if (y < 0)
    return 0;
  if (y > h)
    return n.state.doc.length;
  for (let E = n.viewState.heightOracle.textHeight / 2, A = !1; l = n.elementAtHeight(y), l.type != es.Text; )
    for (; y = i > 0 ? l.bottom + E : l.top - E, !(y >= 0 && y <= h); ) {
      if (A)
        return e ? null : 0;
      A = !0, i = -i;
    }
  p = o + y;
  let m = l.from;
  if (m < n.viewport.from)
    return n.viewport.from == 0 ? 0 : e ? null : G$(n, a, l, u, p);
  if (m > n.viewport.to)
    return n.viewport.to == n.state.doc.length ? n.state.doc.length : e ? null : G$(n, a, l, u, p);
  let w = n.dom.ownerDocument, b = n.root.elementFromPoint ? n.root : w, $ = b.elementFromPoint(u, p);
  $ && !n.contentDOM.contains($) && ($ = null), $ || (u = Math.max(a.left + 1, Math.min(a.right - 1, u)), $ = b.elementFromPoint(u, p), $ && !n.contentDOM.contains($) && ($ = null));
  let x, C = -1;
  if ($ && ((s = n.docView.nearest($)) === null || s === void 0 ? void 0 : s.isEditable) != !1) {
    if (w.caretPositionFromPoint) {
      let E = w.caretPositionFromPoint(u, p);
      E && ({ offsetNode: x, offset: C } = E);
    } else if (w.caretRangeFromPoint) {
      let E = w.caretRangeFromPoint(u, p);
      E && ({ startContainer: x, startOffset: C } = E);
    }
    x && (!n.contentDOM.contains(x) || tt.safari && I7(x, C, u) || tt.chrome && Z7(x, C, u)) && (x = void 0), x && (C = Math.min(xn(x), C));
  }
  if (!x || !n.docView.dom.contains(x)) {
    let E = pi.find(n.docView, m);
    if (!E)
      return y > l.top + l.height / 2 ? l.to : l.from;
    ({ node: x, offset: C } = ov(E.dom, u, p));
  }
  let R = n.docView.nearest(x);
  if (!R)
    return null;
  if (R.isWidget && ((r = R.dom) === null || r === void 0 ? void 0 : r.nodeType) == 1) {
    let E = R.dom.getBoundingClientRect();
    return t.y < E.top || t.y <= E.bottom && t.x <= (E.left + E.right) / 2 ? R.posAtStart : R.posAtEnd;
  } else
    return R.localPosFromDOM(x, C) + R.posAtStart;
}
c(R5, "AO");
f(R5, "posAtCoords");
function G$(n, t, e, i, s) {
  let r = Math.round((i - t.left) * n.defaultCharacterWidth);
  if (n.lineWrapping && e.height > n.defaultLineHeight * 1.5) {
    let o = n.viewState.heightOracle.textHeight, l = Math.floor((s - e.top - (n.defaultLineHeight - o) * 0.5) / o);
    r += l * n.viewState.heightOracle.lineLength;
  }
  let a = n.state.sliceDoc(e.from, e.to);
  return e.from + bQ(a, r, n.state.tabSize);
}
c(G$, "Fc$1");
f(G$, "posAtCoordsImprecise");
function E5(n, t, e) {
  let i, s = n;
  if (n.nodeType != 3 || t != (i = n.nodeValue.length))
    return !1;
  for (; ; ) {
    let r = s.nextSibling;
    if (r) {
      if (r.nodeName == "BR")
        break;
      return !1;
    } else {
      let a = s.parentNode;
      if (!a || a.nodeName == "DIV")
        break;
      s = a;
    }
  }
  return Kr(n, i - 1, i).getBoundingClientRect().right > e;
}
c(E5, "ZO");
f(E5, "isEndOfLineBefore");
function I7(n, t, e) {
  return E5(n, t, e);
}
c(I7, "x0$1");
f(I7, "isSuspiciousSafariCaretResult");
function Z7(n, t, e) {
  if (t != 0)
    return E5(n, t, e);
  for (let s = n; ; ) {
    let r = s.parentNode;
    if (!r || r.nodeType != 1 || r.firstChild != s)
      return !1;
    if (r.classList.contains("cm-line"))
      break;
    s = r;
  }
  let i = n.nodeType == 1 ? n.getBoundingClientRect() : Kr(n, 0, Math.max(n.nodeValue.length, 1)).getBoundingClientRect();
  return e - i.left > 5;
}
c(Z7, "k0$1");
f(Z7, "isSuspiciousChromeCaretResult");
function V7(n, t, e) {
  let i = n.lineBlockAt(t);
  if (Array.isArray(i.type)) {
    let s;
    for (let r of i.type) {
      if (r.from > t)
        break;
      if (!(r.to < t)) {
        if (r.from < t && r.to > t)
          return r;
        (!s || r.type == es.Text && (s.type != r.type || (e < 0 ? r.from < t : r.to > t))) && (s = r);
      }
    }
    return s || i;
  }
  return i;
}
c(V7, "P0$1");
f(V7, "blockAt");
function D7(n, t, e, i) {
  let s = V7(n, t.head, t.assoc || -1), r = !i || s.type != es.Text || !(n.lineWrapping || s.widgetLineBreaks) ? null : n.coordsAtPos(t.assoc < 0 && t.head > s.from ? t.head - 1 : t.head);
  if (r) {
    let a = n.dom.getBoundingClientRect(), o = n.textDirectionAt(s.from), l = n.posAtCoords({
      x: e == (o == Qe.LTR) ? a.right - 1 : a.left + 1,
      y: (r.top + r.bottom) / 2
    });
    if (l != null)
      return J.cursor(l, e ? -1 : 1);
  }
  return J.cursor(e ? s.to : s.from, e ? -1 : 1);
}
c(D7, "R0$1");
f(D7, "moveToLineBoundary");
function K$(n, t, e, i) {
  let s = n.state.doc.lineAt(t.head), r = n.bidiSpans(s), a = n.textDirectionAt(s.from);
  for (let o = t, l = null; ; ) {
    let h = o7(s, r, a, o, e), u = a7;
    if (!h) {
      if (s.number == (e ? n.state.doc.lines : 1))
        return o;
      u = `
`, s = n.state.doc.line(s.number + (e ? 1 : -1)), r = n.bidiSpans(s), h = n.visualLineSide(s, !e);
    }
    if (l) {
      if (!l(u))
        return o;
    } else {
      if (!i)
        return h;
      l = i(u);
    }
    o = h;
  }
}
c(K$, "Kc$1");
f(K$, "moveByChar");
function W7(n, t, e) {
  let i = n.state.charCategorizer(t), s = i(e);
  return (r) => {
    let a = i(r);
    return s == Ss.Space && (s = a), s == a;
  };
}
c(W7, "$0$1");
f(W7, "byGroup");
function q7(n, t, e, i) {
  let s = t.head, r = e ? 1 : -1;
  if (s == (e ? n.state.doc.length : 0))
    return J.cursor(s, t.assoc);
  let a = t.goalColumn, o, l = n.contentDOM.getBoundingClientRect(), h = n.coordsAtPos(s, t.assoc || -1), u = n.documentTop;
  if (h)
    a == null && (a = h.left - l.left), o = r < 0 ? h.top : h.bottom;
  else {
    let m = n.viewState.lineBlockAt(s);
    a == null && (a = Math.min(l.right - l.left, n.defaultCharacterWidth * (s - m.from))), o = (r < 0 ? m.top : m.bottom) + u;
  }
  let p = l.left + a, y = i ?? n.viewState.heightOracle.textHeight >> 1;
  for (let m = 0; ; m += 10) {
    let w = o + (y + m) * r, b = R5(n, { x: p, y: w }, !1, r);
    if (w < l.top || w > l.bottom || (r < 0 ? b < s : b > s)) {
      let $ = n.docView.coordsForChar(b), x = !$ || w < $.top ? -1 : 1;
      return J.cursor(b, x, void 0, a);
    }
  }
}
c(q7, "v0$1");
f(q7, "moveVertically");
function Zc(n, t, e) {
  for (; ; ) {
    let i = 0;
    for (let s of n)
      s.between(t - 1, t + 1, (r, a, o) => {
        if (t > r && t < a) {
          let l = i || e || (t - r < a - t ? -1 : 1);
          t = l < 0 ? r : a, i = l;
        }
      });
    if (!i)
      return t;
  }
}
c(Zc, "Qr$1");
f(Zc, "skipAtomicRanges");
function _5(n, t) {
  let e = null;
  for (let i = 0; i < t.ranges.length; i++) {
    let s = t.ranges[i], r = null;
    if (s.empty) {
      let a = Zc(n, s.from, 0);
      a != s.from && (r = J.cursor(a, -1));
    } else {
      let a = Zc(n, s.from, -1), o = Zc(n, s.to, 1);
      (a != s.from || o != s.to) && (r = J.range(s.from == s.anchor ? a : o, s.from == s.head ? a : o));
    }
    r && (e || (e = t.ranges.slice()), e[i] = r);
  }
  return e ? J.create(e, t.mainIndex) : t;
}
c(_5, "LO");
f(_5, "skipAtomsForSelection");
function s1(n, t, e) {
  let i = Zc(n.state.facet(Kw).map((s) => s(n)), e.from, t.head > e.from ? -1 : 1);
  return i == e.from ? e : J.cursor(i, i < e.from ? 1 : -1);
}
c(s1, "Ao$1");
f(s1, "skipAtoms");
const fm = "￿";
var Oh;
const j7 = (Oh = class {
  constructor(t, e) {
    this.points = t, this.text = "", this.lineSeparator = e.facet(ze.lineSeparator);
  }
  append(t) {
    this.text += t;
  }
  lineBreak() {
    this.text += fm;
  }
  readRange(t, e) {
    if (!t)
      return this;
    let i = t.parentNode;
    for (let s = t; ; ) {
      this.findPointBefore(i, s);
      let r = this.text.length;
      this.readNode(s);
      let a = s.nextSibling;
      if (a == e)
        break;
      let o = te.get(s), l = te.get(a);
      (o && l ? o.breakAfter : (o ? o.breakAfter : pw(s)) || pw(a) && (s.nodeName != "BR" || s.cmIgnore) && this.text.length > r) && !U7(a, e) && this.lineBreak(), s = a;
    }
    return this.findPointBefore(i, e), this;
  }
  readTextNode(t) {
    let e = t.nodeValue;
    for (let i of this.points)
      i.node == t && (i.pos = this.text.length + Math.min(i.offset, e.length));
    for (let i = 0, s = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let r = -1, a = 1, o;
      if (this.lineSeparator ? (r = e.indexOf(this.lineSeparator, i), a = this.lineSeparator.length) : (o = s.exec(e)) && (r = o.index, a = o[0].length), this.append(e.slice(i, r < 0 ? e.length : r)), r < 0)
        break;
      if (this.lineBreak(), a > 1)
        for (let l of this.points)
          l.node == t && l.pos > this.text.length && (l.pos -= a - 1);
      i = r + a;
    }
  }
  readNode(t) {
    if (t.cmIgnore)
      return;
    let e = te.get(t), i = e && e.overrideDOMText;
    if (i != null) {
      this.findPointInside(t, i.length);
      for (let s = i.iter(); !s.next().done; )
        s.lineBreak ? this.lineBreak() : this.append(s.value);
    } else t.nodeType == 3 ? this.readTextNode(t) : t.nodeName == "BR" ? t.nextSibling && this.lineBreak() : t.nodeType == 1 && this.readRange(t.firstChild, null);
  }
  findPointBefore(t, e) {
    for (let i of this.points)
      i.node == t && t.childNodes[i.offset] == e && (i.pos = this.text.length);
  }
  findPointInside(t, e) {
    for (let i of this.points)
      (t.nodeType == 3 ? i.node == t : t.contains(i.node)) && (i.pos = this.text.length + (F7(t, i.node, i.offset) ? e : 0));
  }
}, c(Oh, "lf"), Oh);
f(j7, "DOMReader");
let eV = j7;
function F7(n, t, e) {
  for (; ; ) {
    if (!t || e < xn(t))
      return !1;
    if (t == n)
      return !0;
    e = Gr(t) + 1, t = t.parentNode;
  }
}
c(F7, "T0$1");
f(F7, "isAtEnd");
function U7(n, t) {
  let e;
  for (; !(n == t || !n); n = n.nextSibling) {
    let i = te.get(n);
    if (!(i?.isWidget || n.cmIgnore))
      return !1;
    i && (e || (e = [])).push(i);
  }
  if (e) {
    for (let i of e)
      if (i.overrideDOMText?.length)
        return !1;
  }
  return !0;
}
c(U7, "A0$1");
f(U7, "isEmptyToEnd");
var $h;
const B7 = ($h = class {
  constructor(t, e) {
    this.node = t, this.offset = e, this.pos = -1;
  }
}, c($h, "af"), $h);
f(B7, "DOMPoint");
let o4 = B7;
var xh;
const X7 = (xh = class {
  constructor(t, e, i, s) {
    this.typeOver = s, this.bounds = null, this.text = "", this.domChanged = e > -1;
    let { impreciseHead: r, impreciseAnchor: a } = t.docView;
    if (t.state.readOnly && e > -1)
      this.newSel = null;
    else if (e > -1 && (this.bounds = t.docView.domBoundsAround(e, i, 0))) {
      let o = r || a ? [] : H7(t), l = new eV(o, t.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = Y7(o, this.bounds.from);
    } else {
      let o = t.observer.selectionRange, l = r && r.node == o.focusNode && r.offset == o.focusOffset || !iv(t.contentDOM, o.focusNode) ? t.state.selection.main.head : t.docView.posFromDOM(o.focusNode, o.focusOffset), h = a && a.node == o.anchorNode && a.offset == o.anchorOffset || !iv(t.contentDOM, o.anchorNode) ? t.state.selection.main.anchor : t.docView.posFromDOM(o.anchorNode, o.anchorOffset), u = t.viewport;
      if ((tt.ios || tt.chrome) && t.state.selection.main.empty && l != h && (u.from > 0 || u.to < t.state.doc.length)) {
        let p = Math.min(l, h), y = Math.max(l, h), m = u.from - p, w = u.to - y;
        (m == 0 || m == 1 || p == 0) && (w == 0 || w == -1 || y == t.state.doc.length) && (l = 0, h = t.state.doc.length);
      }
      this.newSel = J.single(h, l);
    }
  }
}, c(xh, "hf"), xh);
f(X7, "DOMChange");
let iV = X7;
function z5(n, t) {
  let e, { newSel: i } = t, s = n.state.selection.main, r = n.inputState.lastKeyTime > Date.now() - 100 ? n.inputState.lastKeyCode : -1;
  if (t.bounds) {
    let { from: a, to: o } = t.bounds, l = s.from, h = null;
    (r === 8 || tt.android && t.text.length < o - a) && (l = s.to, h = "end");
    let u = L5(n.state.doc.sliceString(a, o, fm), t.text, l - a, h);
    u && (tt.chrome && r == 13 && u.toB == u.from + 2 && t.text.slice(u.from, u.toB) == fm + fm && u.toB--, e = {
      from: a + u.from,
      to: a + u.toA,
      insert: Vt.of(t.text.slice(u.from, u.toB).split(fm))
    });
  } else i && (!n.hasFocus && n.state.facet($s) || i.main.eq(s)) && (i = null);
  if (!e && !i)
    return !1;
  if (!e && t.typeOver && !s.empty && i && i.main.empty ? e = { from: s.from, to: s.to, insert: n.state.doc.slice(s.from, s.to) } : (tt.mac || tt.android) && e && e.from == e.to && e.from == s.head - 1 && /^\. ?$/.test(e.insert.toString()) && n.contentDOM.getAttribute("autocorrect") == "off" ? (i && e.insert.length == 2 && (i = J.single(i.main.anchor - 1, i.main.head - 1)), e = { from: e.from, to: e.to, insert: Vt.of([e.insert.toString().replace(".", " ")]) }) : e && e.from >= s.from && e.to <= s.to && (e.from != s.from || e.to != s.to) && s.to - s.from - (e.to - e.from) <= 4 ? e = {
    from: s.from,
    to: s.to,
    insert: n.state.doc.slice(s.from, e.from).append(e.insert).append(n.state.doc.slice(e.to, s.to))
  } : tt.chrome && e && e.from == e.to && e.from == s.head && e.insert.toString() == `
 ` && n.lineWrapping && (i && (i = J.single(i.main.anchor - 1, i.main.head - 1)), e = { from: s.from, to: s.to, insert: Vt.of([" "]) }), e)
    return mb(n, e, i, r);
  if (i && !i.main.eq(s)) {
    let a = !1, o = "select";
    return n.inputState.lastSelectionTime > Date.now() - 50 && (n.inputState.lastSelectionOrigin == "select" && (a = !0), o = n.inputState.lastSelectionOrigin, o == "select.pointer" && (i = _5(n.state.facet(Kw).map((l) => l(n)), i))), n.dispatch({ selection: i, scrollIntoView: a, userEvent: o }), !0;
  } else
    return !1;
}
c(z5, "MO");
f(z5, "applyDOMChange");
function mb(n, t, e, i = -1) {
  if (tt.ios && n.inputState.flushIOSKey(t))
    return !0;
  let s = n.state.selection.main;
  if (tt.android && (t.to == s.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (t.from == s.from || t.from == s.from - 1 && n.state.sliceDoc(t.from, s.from) == " ") && t.insert.length == 1 && t.insert.lines == 2 && Xa(n.contentDOM, "Enter", 13) || (t.from == s.from - 1 && t.to == s.to && t.insert.length == 0 || i == 8 && t.insert.length < t.to - t.from && t.to > s.head) && Xa(n.contentDOM, "Backspace", 8) || t.from == s.from && t.to == s.to + 1 && t.insert.length == 0 && Xa(n.contentDOM, "Delete", 46)))
    return !0;
  let r = t.insert.toString();
  n.inputState.composing >= 0 && n.inputState.composing++;
  let a, o = /* @__PURE__ */ f(() => a || (a = N7(n, t, e)), "defaultInsert");
  return n.state.facet(p7).some((l) => l(n, t.from, t.to, r, o)) || n.dispatch(o()), !0;
}
c(mb, "hh");
f(mb, "applyDOMChangeInner");
function N7(n, t, e) {
  let i, s = n.state, r = s.selection.main, a = -1;
  if (t.from == t.to && t.from < r.from || t.from > r.to) {
    let l = t.from < r.from ? -1 : 1, h = l < 0 ? r.from : r.to, u = Zc(s.facet(Kw).map((p) => p(n)), h, l);
    t.from == u && (a = u);
  }
  if (a > -1)
    i = {
      changes: t,
      selection: J.cursor(t.from + t.insert.length, -1)
    };
  else if (t.from >= r.from && t.to <= r.to && t.to - t.from >= (r.to - r.from) / 3 && (!e || e.main.empty && e.main.from == t.from + t.insert.length) && n.inputState.composing < 0) {
    let l = r.from < t.from ? s.sliceDoc(r.from, t.from) : "", h = r.to > t.to ? s.sliceDoc(t.to, r.to) : "";
    i = s.replaceSelection(n.state.toText(l + t.insert.sliceString(0, void 0, n.state.lineBreak) + h));
  } else {
    let l = s.changes(t), h = e && e.main.to <= l.newLength ? e.main : void 0;
    if (s.selection.ranges.length > 1 && n.inputState.composing >= 0 && t.to <= r.to && t.to >= r.to - 10) {
      let u = n.state.sliceDoc(t.from, t.to), p, y = e && A5(n, e.main.head);
      if (y) {
        let b = t.insert.length - (t.to - t.from);
        p = { from: y.from, to: y.to - b };
      } else
        p = n.state.doc.lineAt(r.head);
      let m = r.to - t.to, w = r.to - r.from;
      i = s.changeByRange((b) => {
        if (b.from == r.from && b.to == r.to)
          return { changes: l, range: h || b.map(l) };
        let $ = b.to - m, x = $ - u.length;
        if (b.to - b.from != w || n.state.sliceDoc(x, $) != u || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        b.to >= p.from && b.from <= p.to)
          return { range: b };
        let C = s.changes({ from: x, to: $, insert: t.insert }), R = b.to - r.to;
        return {
          changes: C,
          range: h ? J.range(Math.max(0, h.anchor + R), Math.max(0, h.head + R)) : b.map(C)
        };
      });
    } else
      i = {
        changes: l,
        selection: h && s.selection.replaceRange(h)
      };
  }
  let o = "input.type";
  return (n.composing || n.inputState.compositionPendingChange && n.inputState.compositionEndedAt > Date.now() - 50) && (n.inputState.compositionPendingChange = !1, o += ".compose", n.inputState.compositionFirstChange && (o += ".start", n.inputState.compositionFirstChange = !1)), s.update(i, { userEvent: o, scrollIntoView: !0 });
}
c(N7, "Z0$1");
f(N7, "applyDefaultInsert");
function L5(n, t, e, i) {
  let s = Math.min(n.length, t.length), r = 0;
  for (; r < s && n.charCodeAt(r) == t.charCodeAt(r); )
    r++;
  if (r == s && n.length == t.length)
    return null;
  let a = n.length, o = t.length;
  for (; a > 0 && o > 0 && n.charCodeAt(a - 1) == t.charCodeAt(o - 1); )
    a--, o--;
  if (i == "end") {
    let l = Math.max(0, r - Math.min(a, o));
    e -= a + l - r;
  }
  if (a < r && n.length < t.length) {
    let l = e <= r && e >= a ? r - e : 0;
    r -= l, o = r + (o - a), a = r;
  } else if (o < r) {
    let l = e <= r && e >= o ? r - e : 0;
    r -= l, a = r + (a - o), o = r;
  }
  return { from: r, toA: a, toB: o };
}
c(L5, "_O");
f(L5, "findDiff");
function H7(n) {
  let t = [];
  if (n.root.activeElement != n.contentDOM)
    return t;
  let { anchorNode: e, anchorOffset: i, focusNode: s, focusOffset: r } = n.observer.selectionRange;
  return e && (t.push(new o4(e, i)), (s != e || r != i) && t.push(new o4(s, r))), t;
}
c(H7, "L0$1");
f(H7, "selectionPoints");
function Y7(n, t) {
  if (n.length == 0)
    return null;
  let e = n[0].pos, i = n.length == 2 ? n[1].pos : e;
  return e > -1 && i > -1 ? J.single(e + t, i + t) : null;
}
c(Y7, "M0$1");
f(Y7, "selectionFromPoints");
var kh;
const G7 = (kh = class {
  setSelectionOrigin(t) {
    this.lastSelectionOrigin = t, this.lastSelectionTime = Date.now();
  }
  constructor(t) {
    this.view = t, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = t.hasFocus, tt.safari && t.contentDOM.addEventListener("input", () => null), tt.gecko && y8(t.contentDOM.ownerDocument);
  }
  handleEvent(t) {
    !a8(this.view, t) || this.ignoreDuringComposition(t) || t.type == "keydown" && this.keydown(t) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(t.type, t)) : this.runHandlers(t.type, t));
  }
  runHandlers(t, e) {
    let i = this.handlers[t];
    if (i) {
      for (let s of i.observers)
        s(this.view, e);
      for (let s of i.handlers) {
        if (e.defaultPrevented)
          break;
        if (s(this.view, e)) {
          e.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(t) {
    let e = K7(t), i = this.handlers, s = this.view.contentDOM;
    for (let r in e)
      if (r != "scroll") {
        let a = !e[r].handlers.length, o = i[r];
        o && a != !o.handlers.length && (s.removeEventListener(r, this.handleEvent), o = null), o || s.addEventListener(r, this.handleEvent, { passive: a });
      }
    for (let r in i)
      r != "scroll" && !e[r] && s.removeEventListener(r, this.handleEvent);
    this.handlers = e;
  }
  keydown(t) {
    if (this.lastKeyCode = t.keyCode, this.lastKeyTime = Date.now(), t.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && t.keyCode != 27 && t8.indexOf(t.keyCode) < 0 && (this.tabFocusMode = -1), tt.android && tt.chrome && !t.synthetic && (t.keyCode == 13 || t.keyCode == 8))
      return this.view.observer.delayAndroidKey(t.key, t.keyCode), !0;
    let e;
    return tt.ios && !t.synthetic && !t.altKey && !t.metaKey && ((e = J7.find((i) => i.keyCode == t.keyCode)) && !t.ctrlKey || sV.indexOf(t.key) > -1 && t.ctrlKey && !t.shiftKey) ? (this.pendingIOSKey = e || t, setTimeout(() => this.flushIOSKey(), 250), !0) : (t.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(t) {
    let e = this.pendingIOSKey;
    return !e || e.key == "Enter" && t && t.from < t.to && /^\S+$/.test(t.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, Xa(this.view.contentDOM, e.key, e.keyCode, e instanceof KeyboardEvent ? e : void 0));
  }
  ignoreDuringComposition(t) {
    return !/^key/.test(t.type) || t.synthetic ? !1 : this.composing > 0 ? !0 : tt.safari && !tt.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1;
  }
  startMouseSelection(t) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = t;
  }
  update(t) {
    this.view.observer.update(t), this.mouseSelection && this.mouseSelection.update(t), this.draggedContent && t.docChanged && (this.draggedContent = this.draggedContent.map(t.changes)), t.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}, c(kh, "ff"), kh);
f(G7, "InputState");
let nV = G7;
function J$(n, t) {
  return (e, i) => {
    try {
      return t.call(n, i, e);
    } catch (s) {
      Ci(e.state, s);
    }
  };
}
c(J$, "Jc$1");
f(J$, "bindHandler");
function K7(n) {
  let t = /* @__PURE__ */ Object.create(null);
  function e(i) {
    return t[i] || (t[i] = { observers: [], handlers: [] });
  }
  c(e, "t"), f(e, "record");
  for (let i of n) {
    let s = i.spec, r = s && s.plugin.domEventHandlers, a = s && s.plugin.domEventObservers;
    if (r)
      for (let o in r) {
        let l = r[o];
        l && e(o).handlers.push(J$(i.value, l));
      }
    if (a)
      for (let o in a) {
        let l = a[o];
        l && e(o).observers.push(J$(i.value, l));
      }
  }
  for (let i in kn)
    e(i).handlers.push(kn[i]);
  for (let i in nn)
    e(i).observers.push(nn[i]);
  return t;
}
c(K7, "_0$1");
f(K7, "computeHandlers");
const J7 = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], sV = "dthko", t8 = [16, 17, 18, 20, 91, 92, 224, 225], Ag = 6;
function ym(n) {
  return Math.max(0, n) * 0.7 + 8;
}
c(ym, "Ln$1");
f(ym, "dragScrollSpeed");
function e8(n, t) {
  return Math.max(Math.abs(n.clientX - t.clientX), Math.abs(n.clientY - t.clientY));
}
c(e8, "E0$1");
f(e8, "dist");
var Sh;
const i8 = (Sh = class {
  constructor(t, e, i, s) {
    this.view = t, this.startEvent = e, this.style = i, this.mustSelect = s, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = e, this.scrollParents = CQ(t.contentDOM), this.atoms = t.state.facet(Kw).map((a) => a(t));
    let r = t.contentDOM.ownerDocument;
    r.addEventListener("mousemove", this.move = this.move.bind(this)), r.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = e.shiftKey, this.multiple = t.state.facet(ze.allowMultipleSelections) && n8(t, e), this.dragging = r8(t, e) && Z5(e) == 1 ? null : !1;
  }
  start(t) {
    this.dragging === !1 && this.select(t);
  }
  move(t) {
    if (t.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && e8(this.startEvent, t) < 10)
      return;
    this.select(this.lastEvent = t);
    let e = 0, i = 0, s = 0, r = 0, a = this.view.win.innerWidth, o = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: s, right: a } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: r, bottom: o } = this.scrollParents.y.getBoundingClientRect());
    let l = yb(this.view);
    t.clientX - l.left <= s + Ag ? e = -ym(s - t.clientX) : t.clientX + l.right >= a - Ag && (e = ym(t.clientX - a)), t.clientY - l.top <= r + Ag ? i = -ym(r - t.clientY) : t.clientY + l.bottom >= o - Ag && (i = ym(t.clientY - o)), this.setScrollSpeed(e, i);
  }
  up(t) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || t.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let t = this.view.contentDOM.ownerDocument;
    t.removeEventListener("mousemove", this.move), t.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(t, e) {
    this.scrollSpeed = { x: t, y: e }, t || e ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: t, y: e } = this.scrollSpeed;
    t && this.scrollParents.x && (this.scrollParents.x.scrollLeft += t, t = 0), e && this.scrollParents.y && (this.scrollParents.y.scrollTop += e, e = 0), (t || e) && this.view.win.scrollBy(t, e), this.dragging === !1 && this.select(this.lastEvent);
  }
  select(t) {
    let { view: e } = this, i = _5(this.atoms, this.style.get(t, this.extend, this.multiple));
    (this.mustSelect || !i.eq(e.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(t) {
    t.transactions.some((e) => e.isUserEvent("input.type")) ? this.destroy() : this.style.update(t) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}, c(Sh, "cf"), Sh);
f(i8, "MouseSelection");
let rV = i8;
function n8(n, t) {
  let e = n.state.facet(c7);
  return e.length ? e[0](t) : tt.mac ? t.metaKey : t.ctrlKey;
}
c(n8, "V0$1");
f(n8, "addsSelectionRange");
function s8(n, t) {
  let e = n.state.facet(h7);
  return e.length ? e[0](t) : tt.mac ? !t.altKey : !t.ctrlKey;
}
c(s8, "U0$1");
f(s8, "dragMovesSelection");
function r8(n, t) {
  let { main: e } = n.state.selection;
  if (e.empty)
    return !1;
  let i = jf(n.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let s = i.getRangeAt(0).getClientRects();
  for (let r = 0; r < s.length; r++) {
    let a = s[r];
    if (a.left <= t.clientX && a.right >= t.clientX && a.top <= t.clientY && a.bottom >= t.clientY)
      return !0;
  }
  return !1;
}
c(r8, "W0$1");
f(r8, "isInPrimarySelection");
function a8(n, t) {
  if (!t.bubbles)
    return !0;
  if (t.defaultPrevented)
    return !1;
  for (let e = t.target, i; e != n.contentDOM; e = e.parentNode)
    if (!e || e.nodeType == 11 || (i = te.get(e)) && i.ignoreEvent(t))
      return !1;
  return !0;
}
c(a8, "X0$1");
f(a8, "eventBelongsToEditor");
const kn = /* @__PURE__ */ Object.create(null), nn = /* @__PURE__ */ Object.create(null), o8 = tt.ie && tt.ie_version < 15 || tt.ios && tt.webkit_version < 604;
function l8(n) {
  let t = n.dom.parentNode;
  if (!t)
    return;
  let e = t.appendChild(document.createElement("textarea"));
  e.style.cssText = "position: fixed; left: -10000px; top: 10px", e.focus(), setTimeout(() => {
    n.focus(), e.remove(), I5(n, e.value);
  }, 50);
}
c(l8, "Y0$1");
f(l8, "capturePaste");
function Jw(n, t, e) {
  for (let i of n.facet(t))
    e = i(e, n);
  return e;
}
c(Jw, "bo$1");
f(Jw, "textFilter");
function I5(n, t) {
  t = Jw(n.state, Q5, t);
  let { state: e } = n, i, s = 1, r = e.toText(t), a = r.lines == e.selection.ranges.length;
  if (nx != null && e.selection.ranges.every((o) => o.empty) && nx == r.toString()) {
    let o = -1;
    i = e.changeByRange((l) => {
      let h = e.doc.lineAt(l.from);
      if (h.from == o)
        return { range: l };
      o = h.from;
      let u = e.toText((a ? r.line(s++).text : t) + e.lineBreak);
      return {
        changes: { from: h.from, insert: u },
        range: J.cursor(l.from + u.length)
      };
    });
  } else a ? i = e.changeByRange((o) => {
    let l = r.line(s++);
    return {
      changes: { from: o.from, to: o.to, insert: l.text },
      range: J.cursor(o.from + l.length)
    };
  }) : i = e.replaceSelection(r);
  n.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
c(I5, "UO");
f(I5, "doPaste");
nn.scroll = (n) => {
  n.inputState.lastScrollTop = n.scrollDOM.scrollTop, n.inputState.lastScrollLeft = n.scrollDOM.scrollLeft;
};
kn.keydown = (n, t) => (n.inputState.setSelectionOrigin("select"), t.keyCode == 27 && n.inputState.tabFocusMode != 0 && (n.inputState.tabFocusMode = Date.now() + 2e3), !1);
nn.touchstart = (n, t) => {
  n.inputState.lastTouchTime = Date.now(), n.inputState.setSelectionOrigin("select.pointer");
};
nn.touchmove = (n) => {
  n.inputState.setSelectionOrigin("select.pointer");
};
kn.mousedown = (n, t) => {
  if (n.observer.flush(), n.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let e = null;
  for (let i of n.state.facet(d7))
    if (e = i(n, t), e)
      break;
  if (!e && t.button == 0 && (e = h8(n, t)), e) {
    let i = !n.hasFocus;
    n.inputState.startMouseSelection(new rV(n, t, e, i)), i && n.observer.ignore(() => {
      c5(n.contentDOM);
      let r = n.root.activeElement;
      r && !r.contains(n.contentDOM) && r.blur();
    });
    let s = n.inputState.mouseSelection;
    if (s)
      return s.start(t), s.dragging === !1;
  } else
    n.inputState.setSelectionOrigin("select.pointer");
  return !1;
};
function tx(n, t, e, i) {
  if (i == 1)
    return J.cursor(t, e);
  if (i == 2)
    return _7(n.state, t, e);
  {
    let s = pi.find(n.docView, t), r = n.state.doc.lineAt(s ? s.posAtEnd : t), a = s ? s.posAtStart : r.from, o = s ? s.posAtEnd : r.to;
    return o < n.state.doc.length && o == r.to && o++, J.range(a, o);
  }
}
c(tx, "eu$1");
f(tx, "rangeForClick");
let l4 = /* @__PURE__ */ f((n, t, e) => t >= e.top && t <= e.bottom && n >= e.left && n <= e.right, "inside");
function c8(n, t, e, i) {
  let s = pi.find(n.docView, t);
  if (!s)
    return 1;
  let r = t - s.posAtStart;
  if (r == 0)
    return 1;
  if (r == s.length)
    return -1;
  let a = s.coordsAt(r, -1);
  if (a && l4(e, i, a))
    return -1;
  let o = s.coordsAt(r, 1);
  return o && l4(e, i, o) ? 1 : a && a.bottom >= i ? -1 : 1;
}
c(c8, "I0$1");
f(c8, "findPositionSide");
function ex(n, t) {
  let e = n.posAtCoords({ x: t.clientX, y: t.clientY }, !1);
  return { pos: e, bias: c8(n, e, t.clientX, t.clientY) };
}
c(ex, "iu$1");
f(ex, "queryPos");
const aV = tt.ie && tt.ie_version <= 11;
let c4 = null, h4 = 0, d4 = 0;
function Z5(n) {
  if (!aV)
    return n.detail;
  let t = c4, e = d4;
  return c4 = n, d4 = Date.now(), h4 = !t || e > Date.now() - 400 && Math.abs(t.clientX - n.clientX) < 2 && Math.abs(t.clientY - n.clientY) < 2 ? (h4 + 1) % 3 : 1;
}
c(Z5, "WO");
f(Z5, "getClickType");
function h8(n, t) {
  let e = ex(n, t), i = Z5(t), s = n.state.selection;
  return {
    update(r) {
      r.docChanged && (e.pos = r.changes.mapPos(e.pos), s = s.map(r.changes));
    },
    get(r, a, o) {
      let l = ex(n, r), h, u = tx(n, l.pos, l.bias, i);
      if (e.pos != l.pos && !a) {
        let p = tx(n, e.pos, e.bias, i), y = Math.min(p.from, u.from), m = Math.max(p.to, u.to);
        u = y < u.from ? J.range(y, m) : J.range(m, y);
      }
      return a ? s.replaceRange(s.main.extend(u.from, u.to)) : o && i == 1 && s.ranges.length > 1 && (h = d8(s, l.pos)) ? h : o ? s.addRange(u) : J.create([u]);
    }
  };
}
c(h8, "q0$1");
f(h8, "basicMouseSelection");
function d8(n, t) {
  for (let e = 0; e < n.ranges.length; e++) {
    let { from: i, to: s } = n.ranges[e];
    if (i <= t && s >= t)
      return J.create(n.ranges.slice(0, e).concat(n.ranges.slice(e + 1)), n.mainIndex == e ? 0 : n.mainIndex - (n.mainIndex > e ? 1 : 0));
  }
  return null;
}
c(d8, "D0$1");
f(d8, "removeRangeAround");
kn.dragstart = (n, t) => {
  let { selection: { main: e } } = n.state;
  if (t.target.draggable) {
    let s = n.docView.nearest(t.target);
    if (s && s.isWidget) {
      let r = s.posAtStart, a = r + s.length;
      (r >= e.to || a <= e.from) && (e = J.range(r, a));
    }
  }
  let { inputState: i } = n;
  return i.mouseSelection && (i.mouseSelection.dragging = !0), i.draggedContent = e, t.dataTransfer && (t.dataTransfer.setData("Text", Jw(n.state, M5, n.state.sliceDoc(e.from, e.to))), t.dataTransfer.effectAllowed = "copyMove"), !1;
};
kn.dragend = (n) => (n.inputState.draggedContent = null, !1);
function ix(n, t, e, i) {
  if (e = Jw(n.state, Q5, e), !e)
    return;
  let s = n.posAtCoords({ x: t.clientX, y: t.clientY }, !1), { draggedContent: r } = n.inputState, a = i && r && s8(n, t) ? { from: r.from, to: r.to } : null, o = { from: s, insert: e }, l = n.state.changes(a ? [a, o] : o);
  n.focus(), n.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(s, -1), head: l.mapPos(s, 1) },
    userEvent: a ? "move.drop" : "input.drop"
  }), n.inputState.draggedContent = null;
}
c(ix, "ou$1");
f(ix, "dropText");
kn.drop = (n, t) => {
  if (!t.dataTransfer)
    return !1;
  if (n.state.readOnly)
    return !0;
  let e = t.dataTransfer.files;
  if (e && e.length) {
    let i = Array(e.length), s = 0, r = /* @__PURE__ */ f(() => {
      ++s == e.length && ix(n, t, i.filter((a) => a != null).join(n.state.lineBreak), !1);
    }, "finishFile");
    for (let a = 0; a < e.length; a++) {
      let o = new FileReader();
      o.onerror = r, o.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(o.result) || (i[a] = o.result), r();
      }, o.readAsText(e[a]);
    }
    return !0;
  } else {
    let i = t.dataTransfer.getData("Text");
    if (i)
      return ix(n, t, i, !0), !0;
  }
  return !1;
};
kn.paste = (n, t) => {
  if (n.state.readOnly)
    return !0;
  n.observer.flush();
  let e = o8 ? null : t.clipboardData;
  return e ? (I5(n, e.getData("text/plain") || e.getData("text/uri-list")), !0) : (l8(n), !1);
};
function u8(n, t) {
  let e = n.dom.parentNode;
  if (!e)
    return;
  let i = e.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = t, i.focus(), i.selectionEnd = t.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), n.focus();
  }, 50);
}
c(u8, "B0$1");
f(u8, "captureCopy");
function p8(n) {
  let t = [], e = [], i = !1;
  for (let s of n.selection.ranges)
    s.empty || (t.push(n.sliceDoc(s.from, s.to)), e.push(s));
  if (!t.length) {
    let s = -1;
    for (let { from: r } of n.selection.ranges) {
      let a = n.doc.lineAt(r);
      a.number > s && (t.push(a.text), e.push({ from: a.from, to: Math.min(n.doc.length, a.to + 1) })), s = a.number;
    }
    i = !0;
  }
  return { text: Jw(n, M5, t.join(n.lineBreak)), ranges: e, linewise: i };
}
c(p8, "z0$1");
f(p8, "copiedRange");
let nx = null;
kn.copy = kn.cut = (n, t) => {
  let { text: e, ranges: i, linewise: s } = p8(n.state);
  if (!e && !s)
    return !1;
  nx = s ? e : null, t.type == "cut" && !n.state.readOnly && n.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let r = o8 ? null : t.clipboardData;
  return r ? (r.clearData(), r.setData("text/plain", e), !0) : (u8(n, e), !1);
};
const f8 = /* @__PURE__ */ Ns.define();
function V5(n, t) {
  let e = [];
  for (let i of n.facet(f7)) {
    let s = i(n, t);
    s && e.push(s);
  }
  return e.length ? n.update({ effects: e, annotations: f8.of(!0) }) : null;
}
c(V5, "YO");
f(V5, "focusChangeTransaction");
function D5(n) {
  setTimeout(() => {
    let t = n.hasFocus;
    if (t != n.inputState.notifiedFocused) {
      let e = V5(n.state, t);
      e ? n.dispatch(e) : n.update([]);
    }
  }, 10);
}
c(D5, "IO");
f(D5, "updateForFocusChange");
nn.focus = (n) => {
  n.inputState.lastFocusTime = Date.now(), !n.scrollDOM.scrollTop && (n.inputState.lastScrollTop || n.inputState.lastScrollLeft) && (n.scrollDOM.scrollTop = n.inputState.lastScrollTop, n.scrollDOM.scrollLeft = n.inputState.lastScrollLeft), D5(n);
};
nn.blur = (n) => {
  n.observer.clearSelectionRange(), D5(n);
};
nn.compositionstart = nn.compositionupdate = (n) => {
  n.observer.editContext || (n.inputState.compositionFirstChange == null && (n.inputState.compositionFirstChange = !0), n.inputState.composing < 0 && (n.inputState.composing = 0));
};
nn.compositionend = (n) => {
  n.observer.editContext || (n.inputState.composing = -1, n.inputState.compositionEndedAt = Date.now(), n.inputState.compositionPendingKey = !0, n.inputState.compositionPendingChange = n.observer.pendingRecords().length > 0, n.inputState.compositionFirstChange = null, tt.chrome && tt.android ? n.observer.flushSoon() : n.inputState.compositionPendingChange ? Promise.resolve().then(() => n.observer.flush()) : setTimeout(() => {
    n.inputState.composing < 0 && n.docView.hasComposition && n.update([]);
  }, 50));
};
nn.contextmenu = (n) => {
  n.inputState.lastContextMenu = Date.now();
};
kn.beforeinput = (n, t) => {
  var e, i;
  if (t.inputType == "insertReplacementText" && n.observer.editContext) {
    let r = (e = t.dataTransfer) === null || e === void 0 ? void 0 : e.getData("text/plain"), a = t.getTargetRanges();
    if (r && a.length) {
      let o = a[0], l = n.posAtDOM(o.startContainer, o.startOffset), h = n.posAtDOM(o.endContainer, o.endOffset);
      return mb(n, { from: l, to: h, insert: n.state.toText(r) }, null), !0;
    }
  }
  let s;
  if (tt.chrome && tt.android && (s = J7.find((r) => r.inputType == t.inputType)) && (n.observer.delayAndroidKey(s.key, s.keyCode), s.key == "Backspace" || s.key == "Delete")) {
    let r = ((i = window.visualViewport) === null || i === void 0 ? void 0 : i.height) || 0;
    setTimeout(() => {
      var a;
      (((a = window.visualViewport) === null || a === void 0 ? void 0 : a.height) || 0) > r + 10 && n.hasFocus && (n.contentDOM.blur(), n.focus());
    }, 100);
  }
  return tt.ios && t.inputType == "deleteContentForward" && n.observer.flushSoon(), tt.safari && t.inputType == "insertText" && n.inputState.composing >= 0 && setTimeout(() => nn.compositionend(n, t), 20), !1;
};
const u4 = /* @__PURE__ */ new Set();
function y8(n) {
  u4.has(n) || (u4.add(n), n.addEventListener("copy", () => {
  }), n.addEventListener("cut", () => {
  }));
}
c(y8, "N0$1");
f(y8, "firefoxCopyCutHack");
const p4 = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let Xf = !1;
function sx() {
  Xf = !1;
}
c(sx, "hu$1");
f(sx, "clearHeightChangeFlag");
var Ph;
const m8 = (Ph = class {
  constructor(t) {
    this.lineWrapping = t, this.doc = Vt.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(t, e) {
    let i = this.doc.lineAt(e).number - this.doc.lineAt(t).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((e - t - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(t) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t - this.lineLength) / Math.max(1, this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(t) {
    return this.doc = t, this;
  }
  mustRefreshForWrapping(t) {
    return p4.indexOf(t) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(t) {
    let e = !1;
    for (let i = 0; i < t.length; i++) {
      let s = t[i];
      s < 0 ? i++ : this.heightSamples[Math.floor(s * 10)] || (e = !0, this.heightSamples[Math.floor(s * 10)] = !0);
    }
    return e;
  }
  refresh(t, e, i, s, r, a) {
    let o = p4.indexOf(t) > -1, l = Math.round(e) != Math.round(this.lineHeight) || this.lineWrapping != o;
    if (this.lineWrapping = o, this.lineHeight = e, this.charWidth = i, this.textHeight = s, this.lineLength = r, l) {
      this.heightSamples = {};
      for (let h = 0; h < a.length; h++) {
        let u = a[h];
        u < 0 ? h++ : this.heightSamples[Math.floor(u * 10)] = !0;
      }
    }
    return l;
  }
}, c(Ph, "uf"), Ph);
f(m8, "HeightOracle");
let oV = m8;
var Ch;
const w8 = (Ch = class {
  constructor(t, e) {
    this.from = t, this.heights = e, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}, c(Ch, "df"), Ch);
f(w8, "MeasuredHeights");
let lV = w8;
var uo;
const g8 = (uo = class {
  /**
  @internal
  */
  constructor(t, e, i, s, r) {
    this.from = t, this.length = e, this.top = i, this.height = s, this._content = r;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? es.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof Uf ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(t) {
    let e = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(t._content) ? t._content : [t]);
    return new uo(this.from, this.length + t.length, this.top, this.height + t.height, e);
  }
}, c(uo, "Js"), uo);
f(g8, "BlockInfo");
let wr = g8;
var Jt = /* @__PURE__ */ function(n) {
  return n[n.ByPos = 0] = "ByPos", n[n.ByHeight = 1] = "ByHeight", n[n.ByPosNoHeight = 2] = "ByPosNoHeight", n;
}(Jt || (Jt = {}));
const r1 = 1e-3;
var Es;
const v8 = (Es = class {
  constructor(t, e, i = 2) {
    this.length = t, this.height = e, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(t) {
    this.flags = (t ? 2 : 0) | this.flags & -3;
  }
  setHeight(t) {
    this.height != t && (Math.abs(this.height - t) > r1 && (Xf = !0), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(t, e, i) {
    return Es.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(t, e) {
    e.push(this);
  }
  decomposeRight(t, e) {
    e.push(this);
  }
  applyChanges(t, e, i, s) {
    let r = this, a = i.doc;
    for (let o = s.length - 1; o >= 0; o--) {
      let { fromA: l, toA: h, fromB: u, toB: p } = s[o], y = r.lineAt(l, Jt.ByPosNoHeight, i.setDoc(e), 0, 0), m = y.to >= h ? y : r.lineAt(h, Jt.ByPosNoHeight, i, 0, 0);
      for (p += m.to - h, h = m.to; o > 0 && y.from <= s[o - 1].toA; )
        l = s[o - 1].fromA, u = s[o - 1].fromB, o--, l < y.from && (y = r.lineAt(l, Jt.ByPosNoHeight, i, 0, 0));
      u += y.from - l, l = y.from;
      let w = dV.build(i.setDoc(a), t, u, p);
      r = mw(r, r.replace(l, h, w));
    }
    return r.updateHeight(i, 0);
  }
  static empty() {
    return new qn(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(t) {
    if (t.length == 1)
      return t[0];
    let e = 0, i = t.length, s = 0, r = 0;
    for (; ; )
      if (e == i)
        if (s > r * 2) {
          let o = t[e - 1];
          o.break ? t.splice(--e, 1, o.left, null, o.right) : t.splice(--e, 1, o.left, o.right), i += 1 + o.break, s -= o.size;
        } else if (r > s * 2) {
          let o = t[i];
          o.break ? t.splice(i, 1, o.left, null, o.right) : t.splice(i, 1, o.left, o.right), i += 2 + o.break, r -= o.size;
        } else
          break;
      else if (s < r) {
        let o = t[e++];
        o && (s += o.size);
      } else {
        let o = t[--i];
        o && (r += o.size);
      }
    let a = 0;
    return t[e - 1] == null ? (a = 1, e--) : t[e] == null && (a = 1, i++), new cV(Es.of(t.slice(0, e)), a, Es.of(t.slice(i)));
  }
}, c(Es, "Qi"), Es);
f(v8, "HeightMap");
let vn = v8;
function mw(n, t) {
  return n == t ? n : (n.constructor != t.constructor && (Xf = !0), t);
}
c(mw, "cs$2");
f(mw, "replace");
vn.prototype.size = 1;
var Qh;
const b8 = (Qh = class extends vn {
  constructor(t, e, i) {
    super(t, e), this.deco = i;
  }
  blockAt(t, e, i, s) {
    return new wr(s, this.length, i, this.height, this.deco || 0);
  }
  lineAt(t, e, i, s, r) {
    return this.blockAt(0, i, s, r);
  }
  forEachLine(t, e, i, s, r, a) {
    t <= r + this.length && e >= r && a(this.blockAt(0, i, s, r));
  }
  updateHeight(t, e = 0, i = !1, s) {
    return s && s.from <= e && s.more && this.setHeight(s.heights[s.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}, c(Qh, "Of"), Qh);
f(b8, "HeightMapBlock");
let O8 = b8;
var zr;
const $8 = (zr = class extends O8 {
  constructor(t, e) {
    super(t, e, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(t, e, i, s) {
    return new wr(s, this.length, i, this.height, this.breaks);
  }
  replace(t, e, i) {
    let s = i[0];
    return i.length == 1 && (s instanceof zr || s instanceof Vc && s.flags & 4) && Math.abs(this.length - s.length) < 10 ? (s instanceof Vc ? s = new zr(s.length, this.height) : s.height = this.height, this.outdated || (s.outdated = !1), s) : vn.of(i);
  }
  updateHeight(t, e = 0, i = !1, s) {
    return s && s.from <= e && s.more ? this.setHeight(s.heights[s.index++]) : (i || this.outdated) && this.setHeight(Math.max(this.widgetHeight, t.heightForLine(this.length - this.collapsed)) + this.breaks * t.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}, c(zr, "Cr"), zr);
f($8, "HeightMapText");
let qn = $8;
var li;
const x8 = (li = class extends vn {
  constructor(t) {
    super(t, 0);
  }
  heightMetrics(t, e) {
    let i = t.doc.lineAt(e).number, s = t.doc.lineAt(e + this.length).number, r = s - i + 1, a, o = 0;
    if (t.lineWrapping) {
      let l = Math.min(this.height, t.lineHeight * r);
      a = l / r, this.length > r + 1 && (o = (this.height - l) / (this.length - r - 1));
    } else
      a = this.height / r;
    return { firstLine: i, lastLine: s, perLine: a, perChar: o };
  }
  blockAt(t, e, i, s) {
    let { firstLine: r, lastLine: a, perLine: o, perChar: l } = this.heightMetrics(e, s);
    if (e.lineWrapping) {
      let h = s + (t < e.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (t - i) / this.height)) * this.length)), u = e.doc.lineAt(h), p = o + u.length * l, y = Math.max(i, t - p / 2);
      return new wr(u.from, u.length, y, p, 0);
    } else {
      let h = Math.max(0, Math.min(a - r, Math.floor((t - i) / o))), { from: u, length: p } = e.doc.line(r + h);
      return new wr(u, p, i + o * h, o, 0);
    }
  }
  lineAt(t, e, i, s, r) {
    if (e == Jt.ByHeight)
      return this.blockAt(t, i, s, r);
    if (e == Jt.ByPosNoHeight) {
      let { from: m, to: w } = i.doc.lineAt(t);
      return new wr(m, w - m, 0, 0, 0);
    }
    let { firstLine: a, perLine: o, perChar: l } = this.heightMetrics(i, r), h = i.doc.lineAt(t), u = o + h.length * l, p = h.number - a, y = s + o * p + l * (h.from - r - p);
    return new wr(h.from, h.length, Math.max(s, Math.min(y, s + this.height - u)), u, 0);
  }
  forEachLine(t, e, i, s, r, a) {
    t = Math.max(t, r), e = Math.min(e, r + this.length);
    let { firstLine: o, perLine: l, perChar: h } = this.heightMetrics(i, r);
    for (let u = t, p = s; u <= e; ) {
      let y = i.doc.lineAt(u);
      if (u == t) {
        let w = y.number - o;
        p += l * w + h * (t - r - w);
      }
      let m = l + h * y.length;
      a(new wr(y.from, y.length, p, m, 0)), p += m, u = y.to + 1;
    }
  }
  replace(t, e, i) {
    let s = this.length - e;
    if (s > 0) {
      let r = i[i.length - 1];
      r instanceof li ? i[i.length - 1] = new li(r.length + s) : i.push(null, new li(s - 1));
    }
    if (t > 0) {
      let r = i[0];
      r instanceof li ? i[0] = new li(t + r.length) : i.unshift(new li(t - 1), null);
    }
    return vn.of(i);
  }
  decomposeLeft(t, e) {
    e.push(new li(t - 1), null);
  }
  decomposeRight(t, e) {
    e.push(null, new li(this.length - t - 1));
  }
  updateHeight(t, e = 0, i = !1, s) {
    let r = e + this.length;
    if (s && s.from <= e + this.length && s.more) {
      let a = [], o = Math.max(e, s.from), l = -1;
      for (s.from > e && a.push(new li(s.from - e - 1).updateHeight(t, e)); o <= r && s.more; ) {
        let u = t.doc.lineAt(o).length;
        a.length && a.push(null);
        let p = s.heights[s.index++];
        l == -1 ? l = p : Math.abs(p - l) >= r1 && (l = -2);
        let y = new qn(u, p);
        y.outdated = !1, a.push(y), o += u + 1;
      }
      o <= r && a.push(null, new li(r - o).updateHeight(t, o));
      let h = vn.of(a);
      return (l < 0 || Math.abs(h.height - this.height) >= r1 || Math.abs(l - this.heightMetrics(t, e).perLine) >= r1) && (Xf = !0), mw(this, h);
    } else (i || this.outdated) && (this.setHeight(t.heightForGap(e, e + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}, c(li, "Pe"), li);
f(x8, "HeightMapGap");
let Vc = x8;
var Mh;
const k8 = (Mh = class extends vn {
  constructor(t, e, i) {
    super(t.length + e + i.length, t.height + i.height, e | (t.outdated || i.outdated ? 2 : 0)), this.left = t, this.right = i, this.size = t.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(t, e, i, s) {
    let r = i + this.left.height;
    return t < r ? this.left.blockAt(t, e, i, s) : this.right.blockAt(t, e, r, s + this.left.length + this.break);
  }
  lineAt(t, e, i, s, r) {
    let a = s + this.left.height, o = r + this.left.length + this.break, l = e == Jt.ByHeight ? t < a : t < o, h = l ? this.left.lineAt(t, e, i, s, r) : this.right.lineAt(t, e, i, a, o);
    if (this.break || (l ? h.to < o : h.from > o))
      return h;
    let u = e == Jt.ByPosNoHeight ? Jt.ByPosNoHeight : Jt.ByPos;
    return l ? h.join(this.right.lineAt(o, u, i, a, o)) : this.left.lineAt(o, u, i, s, r).join(h);
  }
  forEachLine(t, e, i, s, r, a) {
    let o = s + this.left.height, l = r + this.left.length + this.break;
    if (this.break)
      t < l && this.left.forEachLine(t, e, i, s, r, a), e >= l && this.right.forEachLine(t, e, i, o, l, a);
    else {
      let h = this.lineAt(l, Jt.ByPos, i, s, r);
      t < h.from && this.left.forEachLine(t, h.from - 1, i, s, r, a), h.to >= t && h.from <= e && a(h), e > h.to && this.right.forEachLine(h.to + 1, e, i, o, l, a);
    }
  }
  replace(t, e, i) {
    let s = this.left.length + this.break;
    if (e < s)
      return this.balanced(this.left.replace(t, e, i), this.right);
    if (t > this.left.length)
      return this.balanced(this.left, this.right.replace(t - s, e - s, i));
    let r = [];
    t > 0 && this.decomposeLeft(t, r);
    let a = r.length;
    for (let o of i)
      r.push(o);
    if (t > 0 && rx(r, a - 1), e < this.length) {
      let o = r.length;
      this.decomposeRight(e, r), rx(r, o);
    }
    return vn.of(r);
  }
  decomposeLeft(t, e) {
    let i = this.left.length;
    if (t <= i)
      return this.left.decomposeLeft(t, e);
    e.push(this.left), this.break && (i++, t >= i && e.push(null)), t > i && this.right.decomposeLeft(t - i, e);
  }
  decomposeRight(t, e) {
    let i = this.left.length, s = i + this.break;
    if (t >= s)
      return this.right.decomposeRight(t - s, e);
    t < i && this.left.decomposeRight(t, e), this.break && t < s && e.push(null), e.push(this.right);
  }
  balanced(t, e) {
    return t.size > 2 * e.size || e.size > 2 * t.size ? vn.of(this.break ? [t, null, e] : [t, e]) : (this.left = mw(this.left, t), this.right = mw(this.right, e), this.setHeight(t.height + e.height), this.outdated = t.outdated || e.outdated, this.size = t.size + e.size, this.length = t.length + this.break + e.length, this);
  }
  updateHeight(t, e = 0, i = !1, s) {
    let { left: r, right: a } = this, o = e + r.length + this.break, l = null;
    return s && s.from <= e + r.length && s.more ? l = r = r.updateHeight(t, e, i, s) : r.updateHeight(t, e, i), s && s.from <= o + a.length && s.more ? l = a = a.updateHeight(t, o, i, s) : a.updateHeight(t, o, i), l ? this.balanced(r, a) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}, c(Mh, "pf"), Mh);
f(k8, "HeightMapBranch");
let cV = k8;
function rx(n, t) {
  let e, i;
  n[t] == null && (e = n[t - 1]) instanceof Vc && (i = n[t + 1]) instanceof Vc && n.splice(t - 1, 3, new Vc(e.length + 1 + i.length));
}
c(rx, "fu$1");
f(rx, "mergeGaps");
const hV = 5;
var po;
const S8 = (po = class {
  constructor(t, e) {
    this.pos = t, this.oracle = e, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(t, e) {
    if (this.lineStart > -1) {
      let i = Math.min(e, this.lineEnd), s = this.nodes[this.nodes.length - 1];
      s instanceof qn ? s.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new qn(i - this.pos, -1)), this.writtenTo = i, e > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = e;
  }
  point(t, e, i) {
    if (t < e || i.heightRelevant) {
      let s = i.widget ? i.widget.estimatedHeight : 0, r = i.widget ? i.widget.lineBreaks : 0;
      s < 0 && (s = this.oracle.lineHeight);
      let a = e - t;
      i.block ? this.addBlock(new O8(a, s, i)) : (a || r || s >= hV) && this.addLineDeco(s, r, a);
    } else e > t && this.span(t, e);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: t, to: e } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = t, this.lineEnd = e, this.writtenTo < t && ((this.writtenTo < t - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, t - 1)), this.nodes.push(null)), this.pos > t && this.nodes.push(new qn(this.pos - t, -1)), this.writtenTo = this.pos;
  }
  blankContent(t, e) {
    let i = new Vc(e - t);
    return this.oracle.doc.lineAt(t).to == e && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let t = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (t instanceof qn)
      return t;
    let e = new qn(0, -1);
    return this.nodes.push(e), e;
  }
  addBlock(t) {
    this.enterLine();
    let e = t.deco;
    e && e.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(t), this.writtenTo = this.pos = this.pos + t.length, e && e.endSide > 0 && (this.covering = t);
  }
  addLineDeco(t, e, i) {
    let s = this.ensureLine();
    s.length += i, s.collapsed += i, s.widgetHeight = Math.max(s.widgetHeight, t), s.breaks += e, this.writtenTo = this.pos = this.pos + i;
  }
  finish(t) {
    let e = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(e instanceof qn) && !this.isCovered ? this.nodes.push(new qn(0, -1)) : (this.writtenTo < this.pos || e == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = t;
    for (let s of this.nodes)
      s instanceof qn && s.updateHeight(this.oracle, i), i += s ? s.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(t, e, i, s) {
    let r = new po(i, t);
    return hi.spans(e, i, s, r, 0), r.finish(i);
  }
}, c(po, "eo"), po);
f(S8, "NodeBuilder");
let dV = S8;
function P8(n, t, e) {
  let i = new uV();
  return hi.compare(n, t, e, i, 0), i.changes;
}
c(P8, "H0$1");
f(P8, "heightRelevantDecoChanges");
var Th;
const C8 = (Th = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(t, e, i, s) {
    (t < e || i && i.heightRelevant || s && s.heightRelevant) && ew(t, e, this.changes, 5);
  }
}, c(Th, "mf"), Th);
f(C8, "DecorationComparator");
let uV = C8;
function Q8(n, t) {
  let e = n.getBoundingClientRect(), i = n.ownerDocument, s = i.defaultView || window, r = Math.max(0, e.left), a = Math.min(s.innerWidth, e.right), o = Math.max(0, e.top), l = Math.min(s.innerHeight, e.bottom);
  for (let h = n.parentNode; h && h != i.body; )
    if (h.nodeType == 1) {
      let u = h, p = window.getComputedStyle(u);
      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && p.overflow != "visible") {
        let y = u.getBoundingClientRect();
        r = Math.max(r, y.left), a = Math.min(a, y.right), o = Math.max(o, y.top), l = Math.min(h == n.parentNode ? s.innerHeight : l, y.bottom);
      }
      h = p.position == "absolute" || p.position == "fixed" ? u.offsetParent : u.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
  return {
    left: r - e.left,
    right: Math.max(r, a) - e.left,
    top: o - (e.top + t),
    bottom: Math.max(o, l) - (e.top + t)
  };
}
c(Q8, "F0$1");
f(Q8, "visiblePixelRange");
function M8(n) {
  let t = n.getBoundingClientRect(), e = n.ownerDocument.defaultView || window;
  return t.left < e.innerWidth && t.right > 0 && t.top < e.innerHeight && t.bottom > 0;
}
c(M8, "K0$1");
f(M8, "inWindow");
function T8(n, t) {
  let e = n.getBoundingClientRect();
  return {
    left: 0,
    right: e.right - e.left,
    top: t,
    bottom: e.bottom - (e.top + t)
  };
}
c(T8, "J0$1");
f(T8, "fullPixelRange");
var Ah;
const A8 = (Ah = class {
  constructor(t, e, i, s) {
    this.from = t, this.to = e, this.size = i, this.displaySize = s;
  }
  static same(t, e) {
    if (t.length != e.length)
      return !1;
    for (let i = 0; i < t.length; i++) {
      let s = t[i], r = e[i];
      if (s.from != r.from || s.to != r.to || s.size != r.size)
        return !1;
    }
    return !0;
  }
  draw(t, e) {
    return ee.replace({
      widget: new pV(this.displaySize * (e ? t.scaleY : t.scaleX), e)
    }).range(this.from, this.to);
  }
}, c(Ah, "gf"), Ah);
f(A8, "LineGap");
let $O = A8;
var Rh;
const R8 = (Rh = class extends xy {
  constructor(t, e) {
    super(), this.size = t, this.vertical = e;
  }
  eq(t) {
    return t.size == this.size && t.vertical == this.vertical;
  }
  toDOM() {
    let t = document.createElement("div");
    return this.vertical ? t.style.height = this.size + "px" : (t.style.width = this.size + "px", t.style.height = "2px", t.style.display = "inline-block"), t;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}, c(Rh, "yf"), Rh);
f(R8, "LineGapWidget");
let pV = R8;
var Eh;
const E8 = (Eh = class {
  constructor(t) {
    this.state = t, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = y4, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = Qe.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let e = t.facet(T5).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new oV(e), this.stateDeco = t.facet(yw).filter((i) => typeof i != "function"), this.heightMap = vn.empty().applyChanges(this.stateDeco, Vt.empty, this.heightOracle.setDoc(t.doc), [new kr(0, 0, 0, t.doc.length)]);
    for (let i = 0; i < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); i++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = ee.set(this.lineGaps.map((i) => i.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let t = [this.viewport], { main: e } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let s = i ? e.head : e.anchor;
      if (!t.some(({ from: r, to: a }) => s >= r && s <= a)) {
        let { from: r, to: a } = this.lineBlockAt(s);
        t.push(new Rg(r, a));
      }
    }
    return this.viewports = t.sort((i, s) => i.from - s.from), this.updateScaler();
  }
  updateScaler() {
    let t = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? y4 : new fV(this.heightOracle, this.heightMap, this.viewports), t.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (t) => {
      this.viewportLines.push(Ec(t, this.scaler));
    });
  }
  update(t, e = null) {
    this.state = t.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(yw).filter((u) => typeof u != "function");
    let s = t.changedRanges, r = kr.extendWithRanges(s, P8(i, this.stateDeco, t ? t.changes : $n.empty(this.state.doc.length))), a = this.heightMap.height, o = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    sx(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, t.startState.doc, this.heightOracle.setDoc(this.state.doc), r), (this.heightMap.height != a || Xf) && (t.flags |= 2), o ? (this.scrollAnchorPos = t.changes.mapPos(o.from, -1), this.scrollAnchorHeight = o.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = a);
    let l = r.length ? this.mapViewport(this.viewport, t.changes) : this.viewport;
    (e && (e.range.head < l.from || e.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, e));
    let h = l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, t.flags |= this.updateForViewport(), (h || !t.changes.empty || t.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t.changes))), t.flags |= this.computeVisibleRanges(t.changes), e && (this.scrollTarget = e), !this.mustEnforceCursorAssoc && t.selectionSet && t.view.lineWrapping && t.state.selection.main.empty && t.state.selection.main.assoc && !t.state.facet(KZ) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(t) {
    let e = t.contentDOM, i = window.getComputedStyle(e), s = this.heightOracle, r = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? Qe.RTL : Qe.LTR;
    let a = this.heightOracle.mustRefreshForWrapping(r), o = e.getBoundingClientRect(), l = a || this.mustMeasureContent || this.contentDOMHeight != o.height;
    this.contentDOMHeight = o.height, this.mustMeasureContent = !1;
    let h = 0, u = 0;
    if (o.width && o.height) {
      let { scaleX: E, scaleY: A } = l5(e, o);
      (E > 5e-3 && Math.abs(this.scaleX - E) > 5e-3 || A > 5e-3 && Math.abs(this.scaleY - A) > 5e-3) && (this.scaleX = E, this.scaleY = A, h |= 16, a = l = !0);
    }
    let p = (parseInt(i.paddingTop) || 0) * this.scaleY, y = (parseInt(i.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != p || this.paddingBottom != y) && (this.paddingTop = p, this.paddingBottom = y, h |= 18), this.editorWidth != t.scrollDOM.clientWidth && (s.lineWrapping && (l = !0), this.editorWidth = t.scrollDOM.clientWidth, h |= 16);
    let m = t.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != m && (this.scrollAnchorHeight = -1, this.scrollTop = m), this.scrolledToBottom = d5(t.scrollDOM);
    let w = (this.printing ? T8 : Q8)(e, this.paddingTop), b = w.top - this.pixelViewport.top, $ = w.bottom - this.pixelViewport.bottom;
    this.pixelViewport = w;
    let x = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (x != this.inView && (this.inView = x, x && (l = !0)), !this.inView && !this.scrollTarget && !M8(t.dom))
      return 0;
    let C = o.width;
    if ((this.contentDOMWidth != C || this.editorHeight != t.scrollDOM.clientHeight) && (this.contentDOMWidth = o.width, this.editorHeight = t.scrollDOM.clientHeight, h |= 16), l) {
      let E = t.docView.measureVisibleLineHeights(this.viewport);
      if (s.mustRefreshForHeights(E) && (a = !0), a || s.lineWrapping && Math.abs(C - this.contentDOMWidth) > s.charWidth) {
        let { lineHeight: A, charWidth: I, textHeight: Z } = t.docView.measureTextSize();
        a = A > 0 && s.refresh(r, A, I, Z, Math.max(5, C / I), E), a && (t.docView.minWidth = 0, h |= 16);
      }
      b > 0 && $ > 0 ? u = Math.max(b, $) : b < 0 && $ < 0 && (u = Math.min(b, $)), sx();
      for (let A of this.viewports) {
        let I = A.from == this.viewport.from ? E : t.docView.measureVisibleLineHeights(A);
        this.heightMap = (a ? vn.empty().applyChanges(this.stateDeco, Vt.empty, this.heightOracle, [new kr(0, 0, 0, t.state.doc.length)]) : this.heightMap).updateHeight(s, 0, a, new lV(A.from, I));
      }
      Xf && (h |= 2);
    }
    let R = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return R && (h & 2 && (h |= this.updateScaler()), this.viewport = this.getViewport(u, this.scrollTarget), h |= this.updateForViewport()), (h & 2 || R) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(a ? [] : this.lineGaps, t)), h |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, t.docView.enforceCursorAssoc()), h;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(t, e) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, t / 1e3 / 2)), s = this.heightMap, r = this.heightOracle, { visibleTop: a, visibleBottom: o } = this, l = new Rg(s.lineAt(a - i * 1e3, Jt.ByHeight, r, 0, 0).from, s.lineAt(o + (1 - i) * 1e3, Jt.ByHeight, r, 0, 0).to);
    if (e) {
      let { head: h } = e.range;
      if (h < l.from || h > l.to) {
        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), p = s.lineAt(h, Jt.ByPos, r, 0, 0), y;
        e.y == "center" ? y = (p.top + p.bottom) / 2 - u / 2 : e.y == "start" || e.y == "nearest" && h < l.from ? y = p.top : y = p.bottom - u, l = new Rg(s.lineAt(y - 1e3 / 2, Jt.ByHeight, r, 0, 0).from, s.lineAt(y + u + 1e3 / 2, Jt.ByHeight, r, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(t, e) {
    let i = e.mapPos(t.from, -1), s = e.mapPos(t.to, 1);
    return new Rg(this.heightMap.lineAt(i, Jt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(s, Jt.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: t, to: e }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: s } = this.heightMap.lineAt(t, Jt.ByPos, this.heightOracle, 0, 0), { bottom: r } = this.heightMap.lineAt(e, Jt.ByPos, this.heightOracle, 0, 0), { visibleTop: a, visibleBottom: o } = this;
    return (t == 0 || s <= a - Math.max(10, Math.min(
      -i,
      250
      /* VP.MaxCoverMargin */
    ))) && (e == this.state.doc.length || r >= o + Math.max(10, Math.min(
      i,
      250
      /* VP.MaxCoverMargin */
    ))) && s > a - 2 * 1e3 && r < o + 2 * 1e3;
  }
  mapLineGaps(t, e) {
    if (!t.length || e.empty)
      return t;
    let i = [];
    for (let s of t)
      e.touchesRange(s.from, s.to) || i.push(new $O(e.mapPos(s.from), e.mapPos(s.to), s.size, s.displaySize));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(t, e) {
    let i = this.heightOracle.lineWrapping, s = i ? 1e4 : 2e3, r = s >> 1, a = s << 1;
    if (this.defaultTextDirection != Qe.LTR && !i)
      return [];
    let o = [], l = /* @__PURE__ */ f((u, p, y, m) => {
      if (p - u < r)
        return;
      let w = this.state.selection.main, b = [w.from];
      w.empty || b.push(w.to);
      for (let x of b)
        if (x > u && x < p) {
          l(u, x - 10, y, m), l(x + 10, p, y, m);
          return;
        }
      let $ = L8(t, (x) => x.from >= y.from && x.to <= y.to && Math.abs(x.from - u) < r && Math.abs(x.to - p) < r && !b.some((C) => x.from < C && x.to > C));
      if (!$) {
        if (p < y.to && e && i && e.visibleRanges.some((R) => R.from <= p && R.to >= p)) {
          let R = e.moveToLineBoundary(J.cursor(p), !1, !0).head;
          R > u && (p = R);
        }
        let x = this.gapSize(y, u, p, m), C = i || x < 2e6 ? x : 2e6;
        $ = new $O(u, p, x, C);
      }
      o.push($);
    }, "addGap"), h = /* @__PURE__ */ f((u) => {
      if (u.length < a || u.type != es.Text)
        return;
      let p = z8(u.from, u.to, this.stateDeco);
      if (p.total < a)
        return;
      let y = this.scrollTarget ? this.scrollTarget.range.head : null, m, w;
      if (i) {
        let b = s / this.heightOracle.lineLength * this.heightOracle.lineHeight, $, x;
        if (y != null) {
          let C = wm(p, y), R = ((this.visibleBottom - this.visibleTop) / 2 + b) / u.height;
          $ = C - R, x = C + R;
        } else
          $ = (this.visibleTop - u.top - b) / u.height, x = (this.visibleBottom - u.top + b) / u.height;
        m = mm(p, $), w = mm(p, x);
      } else {
        let b = p.total * this.heightOracle.charWidth, $ = s * this.heightOracle.charWidth, x = 0;
        if (b > 2e6)
          for (let I of t)
            I.from >= u.from && I.from < u.to && I.size != I.displaySize && I.from * this.heightOracle.charWidth + x < this.pixelViewport.left && (x = I.size - I.displaySize);
        let C = this.pixelViewport.left + x, R = this.pixelViewport.right + x, E, A;
        if (y != null) {
          let I = wm(p, y), Z = ((R - C) / 2 + $) / b;
          E = I - Z, A = I + Z;
        } else
          E = (C - $) / b, A = (R + $) / b;
        m = mm(p, E), w = mm(p, A);
      }
      m > u.from && l(u.from, m, u, p), w < u.to && l(w, u.to, u, p);
    }, "checkLine");
    for (let u of this.viewportLines)
      Array.isArray(u.type) ? u.type.forEach(h) : h(u);
    return o;
  }
  gapSize(t, e, i, s) {
    let r = wm(s, i) - wm(s, e);
    return this.heightOracle.lineWrapping ? t.height * r : s.total * this.heightOracle.charWidth * r;
  }
  updateLineGaps(t) {
    $O.same(t, this.lineGaps) || (this.lineGaps = t, this.lineGapDeco = ee.set(t.map((e) => e.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(t) {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let i = [];
    hi.spans(e, this.viewport.from, this.viewport.to, {
      span(r, a) {
        i.push({ from: r, to: a });
      },
      point() {
      }
    }, 20);
    let s = 0;
    if (i.length != this.visibleRanges.length)
      s = 12;
    else
      for (let r = 0; r < i.length && !(s & 8); r++) {
        let a = this.visibleRanges[r], o = i[r];
        (a.from != o.from || a.to != o.to) && (s |= 4, t && t.mapPos(a.from, -1) == o.from && t.mapPos(a.to, 1) == o.to || (s |= 8));
      }
    return this.visibleRanges = i, s;
  }
  lineBlockAt(t) {
    return t >= this.viewport.from && t <= this.viewport.to && this.viewportLines.find((e) => e.from <= t && e.to >= t) || Ec(this.heightMap.lineAt(t, Jt.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(t) {
    return t >= this.viewportLines[0].top && t <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((e) => e.top <= t && e.bottom >= t) || Ec(this.heightMap.lineAt(this.scaler.fromDOM(t), Jt.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(t) {
    let e = this.lineBlockAtHeight(t + 8);
    return e.from >= this.viewport.from || this.viewportLines[0].top - t > 200 ? e : this.viewportLines[0];
  }
  elementAtHeight(t) {
    return Ec(this.heightMap.blockAt(this.scaler.fromDOM(t), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}, c(Eh, "bf"), Eh);
f(E8, "ViewState");
let f4 = E8;
var _h;
const _8 = (_h = class {
  constructor(t, e) {
    this.from = t, this.to = e;
  }
}, c(_h, "Sf"), _h);
f(_8, "Viewport");
let Rg = _8;
function z8(n, t, e) {
  let i = [], s = n, r = 0;
  return hi.spans(e, n, t, {
    span() {
    },
    point(a, o) {
      a > s && (i.push({ from: s, to: a }), r += a - s), s = o;
    }
  }, 20), s < t && (i.push({ from: s, to: t }), r += t - s), { total: r, ranges: i };
}
c(z8, "ey$1");
f(z8, "lineStructure");
function mm({ total: n, ranges: t }, e) {
  if (e <= 0)
    return t[0].from;
  if (e >= 1)
    return t[t.length - 1].to;
  let i = Math.floor(n * e);
  for (let s = 0; ; s++) {
    let { from: r, to: a } = t[s], o = a - r;
    if (i <= o)
      return r + i;
    i -= o;
  }
}
c(mm, "Mn$1");
f(mm, "findPosition");
function wm(n, t) {
  let e = 0;
  for (let { from: i, to: s } of n.ranges) {
    if (t <= s) {
      e += t - i;
      break;
    }
    e += s - i;
  }
  return e / n.total;
}
c(wm, "_n$1");
f(wm, "findFraction");
function L8(n, t) {
  for (let e of n)
    if (t(e))
      return e;
}
c(L8, "ty$1");
f(L8, "find");
const y4 = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1,
  eq(n) {
    return n == this;
  }
};
var fo;
const I8 = (fo = class {
  constructor(t, e, i) {
    let s = 0, r = 0, a = 0;
    this.viewports = i.map(({ from: o, to: l }) => {
      let h = e.lineAt(o, Jt.ByPos, t, 0, 0).top, u = e.lineAt(l, Jt.ByPos, t, 0, 0).bottom;
      return s += u - h, { from: o, to: l, top: h, bottom: u, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - s) / (e.height - s);
    for (let o of this.viewports)
      o.domTop = a + (o.top - r) * this.scale, a = o.domBottom = o.domTop + (o.bottom - o.top), r = o.bottom;
  }
  toDOM(t) {
    for (let e = 0, i = 0, s = 0; ; e++) {
      let r = e < this.viewports.length ? this.viewports[e] : null;
      if (!r || t < r.top)
        return s + (t - i) * this.scale;
      if (t <= r.bottom)
        return r.domTop + (t - r.top);
      i = r.bottom, s = r.domBottom;
    }
  }
  fromDOM(t) {
    for (let e = 0, i = 0, s = 0; ; e++) {
      let r = e < this.viewports.length ? this.viewports[e] : null;
      if (!r || t < r.domTop)
        return i + (t - s) / this.scale;
      if (t <= r.domBottom)
        return r.top + (t - r.domTop);
      i = r.bottom, s = r.domBottom;
    }
  }
  eq(t) {
    return t instanceof fo ? this.scale == t.scale && this.viewports.length == t.viewports.length && this.viewports.every((e, i) => e.from == t.viewports[i].from && e.to == t.viewports[i].to) : !1;
  }
}, c(fo, "to"), fo);
f(I8, "BigScaler");
let fV = I8;
function Ec(n, t) {
  if (t.scale == 1)
    return n;
  let e = t.toDOM(n.top), i = t.toDOM(n.bottom);
  return new wr(n.from, n.length, e, i - e, Array.isArray(n._content) ? n._content.map((s) => Ec(s, t)) : n._content);
}
c(Ec, "dr$1");
f(Ec, "scaleBlock");
const Eg = /* @__PURE__ */ gt.define({ combine: /* @__PURE__ */ f((n) => n.join(" "), "combine") }), ax = /* @__PURE__ */ gt.define({ combine: /* @__PURE__ */ f((n) => n.indexOf(!0) > -1, "combine") }), ox = /* @__PURE__ */ Hr.newName(), Z8 = /* @__PURE__ */ Hr.newName(), V8 = /* @__PURE__ */ Hr.newName(), D8 = { "&light": "." + Z8, "&dark": "." + V8 };
function lv(n, t, e) {
  return new Hr(t, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (s) => {
        if (s == "&")
          return n;
        if (!e || !e[s])
          throw new RangeError(`Unsupported selector: ${s}`);
        return e[s];
      }) : n + " " + i;
    }
  });
}
c(lv, "Bl$1");
f(lv, "buildTheme");
const yV = /* @__PURE__ */ lv("." + ox, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    zIndex: 200
  },
  ".cm-gutters-before": { insetInlineStart: 0 },
  ".cm-gutters-after": { insetInlineEnd: 0 },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    border: "0px solid #ddd",
    "&.cm-gutters-before": { borderRightWidth: "1px" },
    "&.cm-gutters-after": { borderLeftWidth: "1px" }
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, D8), mV = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, xO = tt.ie && tt.ie_version <= 11;
var zh;
const W8 = (zh = class {
  constructor(t) {
    this.view = t, this.active = !1, this.editContext = null, this.selectionRange = new XZ(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = t.contentDOM, this.observer = new MutationObserver((e) => {
      for (let i of e)
        this.queue.push(i);
      (tt.ie && tt.ie_version <= 11 || tt.ios && t.composing) && e.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && tt.android && t.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(tt.chrome && tt.chrome_version < 126) && (this.editContext = new gV(t), t.state.facet($s) && (t.contentDOM.editContext = this.editContext.editContext)), xO && (this.onCharData = (e) => {
      this.queue.push({
        target: e.target,
        type: "characterData",
        oldValue: e.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var e;
      ((e = this.view.docView) === null || e === void 0 ? void 0 : e.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(t.scrollDOM)), this.addWindowListeners(this.win = t.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((e) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), e.length > 0 && e[e.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((e) => {
      e.length > 0 && e[e.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(t) {
    this.view.inputState.runHandlers("scroll", t), this.intersecting && this.view.measure();
  }
  onScroll(t) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(t);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(t) {
    (t.type == "change" || !t.type) && !t.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(t) {
    if (this.gapIntersection && (t.length != this.gaps.length || this.gaps.some((e, i) => e != t[i]))) {
      this.gapIntersection.disconnect();
      for (let e of t)
        this.gapIntersection.observe(e);
      this.gaps = t;
    }
  }
  onSelectionChange(t) {
    let e = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, s = this.selectionRange;
    if (i.state.facet($s) ? i.root.activeElement != this.dom : !tw(this.dom, s))
      return;
    let r = s.anchorNode && i.docView.nearest(s.anchorNode);
    if (r && r.ignoreEvent(t)) {
      e || (this.selectionChanged = !1);
      return;
    }
    (tt.ie && tt.ie_version <= 11 || tt.android && tt.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    s.focusNode && Ic(s.focusNode, s.focusOffset, s.anchorNode, s.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: t } = this, e = jf(t.root);
    if (!e)
      return !1;
    let i = tt.safari && t.root.nodeType == 11 && t.root.activeElement == this.dom && q8(this.view, e) || e;
    if (!i || this.selectionRange.eq(i))
      return !1;
    let s = tw(this.dom, i);
    return s && !this.selectionChanged && t.inputState.lastFocusTime > Date.now() - 200 && t.inputState.lastTouchTime < Date.now() - 300 && TQ(this.dom, i) ? (this.view.inputState.lastFocusTime = 0, t.docView.updateSelection(), !1) : (this.selectionRange.setRange(i), s && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(t, e) {
    this.selectionRange.set(t.node, t.offset, e.node, e.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let t = 0, e = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !e && t < this.scrollTargets.length && this.scrollTargets[t] == i ? t++ : e || (e = this.scrollTargets.slice(0, t)), e && e.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (t < this.scrollTargets.length && !e && (e = this.scrollTargets.slice(0, t)), e) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = e)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(t) {
    if (!this.active)
      return t();
    try {
      return this.stop(), t();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, mV), xO && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), xO && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(t, e) {
    var i;
    if (!this.delayedAndroidKey) {
      let s = /* @__PURE__ */ f(() => {
        let r = this.delayedAndroidKey;
        r && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = r.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && r.force && Xa(this.dom, r.key, r.keyCode));
      }, "flush");
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(s);
    }
    (!this.delayedAndroidKey || t == "Enter") && (this.delayedAndroidKey = {
      key: t,
      keyCode: e,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let t of this.observer.takeRecords())
      this.queue.push(t);
    return this.queue;
  }
  processRecords() {
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let e = -1, i = -1, s = !1;
    for (let r of t) {
      let a = this.readMutation(r);
      a && (a.typeOver && (s = !0), e == -1 ? { from: e, to: i } = a : (e = Math.min(a.from, e), i = Math.max(a.to, i)));
    }
    return { from: e, to: i, typeOver: s };
  }
  readChange() {
    let { from: t, to: e, typeOver: i } = this.processRecords(), s = this.selectionChanged && tw(this.dom, this.selectionRange);
    if (t < 0 && !s)
      return null;
    t > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let r = new iV(this.view, t, e, i);
    return this.view.docView.domChanged = { newSel: r.newSel ? r.newSel.main : null }, r;
  }
  // Apply pending changes, if any
  flush(t = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    t && this.readSelectionRange();
    let e = this.readChange();
    if (!e)
      return this.view.requestMeasure(), !1;
    let i = this.view.state, s = z5(this.view, e);
    return this.view.state == i && (e.domChanged || e.newSel && !e.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), s;
  }
  readMutation(t) {
    let e = this.view.docView.nearest(t.target);
    if (!e || e.ignoreMutation(t))
      return null;
    if (e.markDirty(t.type == "attributes"), t.type == "attributes" && (e.flags |= 4), t.type == "childList") {
      let i = lx(e, t.previousSibling || t.target.previousSibling, -1), s = lx(e, t.nextSibling || t.target.nextSibling, 1);
      return {
        from: i ? e.posAfter(i) : e.posAtStart,
        to: s ? e.posBefore(s) : e.posAtEnd,
        typeOver: !1
      };
    } else return t.type == "characterData" ? { from: e.posAtStart, to: e.posAtEnd, typeOver: t.target.nodeValue == t.oldValue } : null;
  }
  setWindow(t) {
    t != this.win && (this.removeWindowListeners(this.win), this.win = t, this.addWindowListeners(this.win));
  }
  addWindowListeners(t) {
    t.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : t.addEventListener("beforeprint", this.onPrint), t.addEventListener("scroll", this.onScroll), t.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(t) {
    t.removeEventListener("scroll", this.onScroll), t.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : t.removeEventListener("beforeprint", this.onPrint), t.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(t) {
    this.editContext && (this.editContext.update(t), t.startState.facet($s) != t.state.facet($s) && (t.view.contentDOM.editContext = t.state.facet($s) ? this.editContext.editContext : null));
  }
  destroy() {
    var t, e, i;
    this.stop(), (t = this.intersection) === null || t === void 0 || t.disconnect(), (e = this.gapIntersection) === null || e === void 0 || e.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect();
    for (let s of this.scrollTargets)
      s.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}, c(zh, "Qf"), zh);
f(W8, "DOMObserver");
let wV = W8;
function lx(n, t, e) {
  for (; t; ) {
    let i = te.get(t);
    if (i && i.parent == n)
      return i;
    let s = t.parentNode;
    t = s != n.dom ? s : e > 0 ? t.nextSibling : t.previousSibling;
  }
  return null;
}
c(lx, "uu$1");
f(lx, "findChild");
function cx(n, t) {
  let e = t.startContainer, i = t.startOffset, s = t.endContainer, r = t.endOffset, a = n.docView.domAtPos(n.state.selection.main.anchor);
  return Ic(a.node, a.offset, s, r) && ([e, i, s, r] = [s, r, e, i]), { anchorNode: e, anchorOffset: i, focusNode: s, focusOffset: r };
}
c(cx, "du$1");
f(cx, "buildSelectionRangeFromRange");
function q8(n, t) {
  if (t.getComposedRanges) {
    let s = t.getComposedRanges(n.root)[0];
    if (s)
      return cx(n, s);
  }
  let e = null;
  function i(s) {
    s.preventDefault(), s.stopImmediatePropagation(), e = s.getTargetRanges()[0];
  }
  return c(i, "i"), f(i, "read"), n.contentDOM.addEventListener("beforeinput", i, !0), n.dom.ownerDocument.execCommand("indent"), n.contentDOM.removeEventListener("beforeinput", i, !0), e ? cx(n, e) : null;
}
c(q8, "ny$1");
f(q8, "safariSelectionRangeHack");
var Lh;
const j8 = (Lh = class {
  constructor(t) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(t.state);
    let e = this.editContext = new window.EditContext({
      text: t.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, t.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(t.state.selection.main.head)
    });
    this.handlers.textupdate = (i) => {
      let s = t.state.selection.main, { anchor: r, head: a } = s, o = this.toEditorPos(i.updateRangeStart), l = this.toEditorPos(i.updateRangeEnd);
      t.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: i.updateRangeStart, editorBase: o, drifted: !1 });
      let h = l - o > i.text.length;
      o == this.from && r < this.from ? o = r : l == this.to && r > this.to && (l = r);
      let u = L5(t.state.sliceDoc(o, l), i.text, (h ? s.from : s.to) - o, h ? "end" : null);
      if (!u) {
        let y = J.single(this.toEditorPos(i.selectionStart), this.toEditorPos(i.selectionEnd));
        y.main.eq(s) || t.dispatch({ selection: y, userEvent: "select" });
        return;
      }
      let p = {
        from: u.from + o,
        to: u.toA + o,
        insert: Vt.of(i.text.slice(u.from, u.toB).split(`
`))
      };
      if ((tt.mac || tt.android) && p.from == a - 1 && /^\. ?$/.test(i.text) && t.contentDOM.getAttribute("autocorrect") == "off" && (p = { from: o, to: l, insert: Vt.of([i.text.replace(".", " ")]) }), this.pendingContextChange = p, !t.state.readOnly) {
        let y = this.to - this.from + (p.to - p.from + p.insert.length);
        mb(t, p, J.single(this.toEditorPos(i.selectionStart, y), this.toEditorPos(i.selectionEnd, y)));
      }
      this.pendingContextChange && (this.revertPending(t.state), this.setSelection(t.state)), p.from < p.to && !p.insert.length && t.inputState.composing >= 0 && !/[\\p{Alphabetic}\\p{Number}_]/.test(e.text.slice(Math.max(0, i.updateRangeStart - 1), Math.min(e.text.length, i.updateRangeStart + 1))) && this.handlers.compositionend(i);
    }, this.handlers.characterboundsupdate = (i) => {
      let s = [], r = null;
      for (let a = this.toEditorPos(i.rangeStart), o = this.toEditorPos(i.rangeEnd); a < o; a++) {
        let l = t.coordsForChar(a);
        r = l && new DOMRect(l.left, l.top, l.right - l.left, l.bottom - l.top) || r || new DOMRect(), s.push(r);
      }
      e.updateCharacterBounds(i.rangeStart, s);
    }, this.handlers.textformatupdate = (i) => {
      let s = [];
      for (let r of i.getTextFormats()) {
        let a = r.underlineStyle, o = r.underlineThickness;
        if (!/none/i.test(a) && !/none/i.test(o)) {
          let l = this.toEditorPos(r.rangeStart), h = this.toEditorPos(r.rangeEnd);
          if (l < h) {
            let u = `text-decoration: underline ${/^[a-z]/.test(a) ? a + " " : a == "Dashed" ? "dashed " : a == "Squiggle" ? "wavy " : ""}${/thin/i.test(o) ? 1 : 2}px`;
            s.push(ee.mark({ attributes: { style: u } }).range(l, h));
          }
        }
      }
      t.dispatch({ effects: g7.of(ee.set(s)) });
    }, this.handlers.compositionstart = () => {
      t.inputState.composing < 0 && (t.inputState.composing = 0, t.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (t.inputState.composing = -1, t.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: i } = this.composing;
        this.composing = null, i && this.reset(t.state);
      }
    };
    for (let i in this.handlers)
      e.addEventListener(i, this.handlers[i]);
    this.measureReq = { read: /* @__PURE__ */ f((i) => {
      this.editContext.updateControlBounds(i.contentDOM.getBoundingClientRect());
      let s = jf(i.root);
      s && s.rangeCount && this.editContext.updateSelectionBounds(s.getRangeAt(0).getBoundingClientRect());
    }, "read") };
  }
  applyEdits(t) {
    let e = 0, i = !1, s = this.pendingContextChange;
    return t.changes.iterChanges((r, a, o, l, h) => {
      if (i)
        return;
      let u = h.length - (a - r);
      if (s && a >= s.to)
        if (s.from == r && s.to == a && s.insert.eq(h)) {
          s = this.pendingContextChange = null, e += u, this.to += u;
          return;
        } else
          s = null, this.revertPending(t.state);
      if (r += e, a += e, a <= this.from)
        this.from += u, this.to += u;
      else if (r < this.to) {
        if (r < this.from || a > this.to || this.to - this.from + h.length > 3e4) {
          i = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(r), this.toContextPos(a), h.toString()), this.to += u;
      }
      e += u;
    }), s && !i && this.revertPending(t.state), !i;
  }
  update(t) {
    let e = this.pendingContextChange, i = t.startState.selection.main;
    this.composing && (this.composing.drifted || !t.changes.touchesRange(i.from, i.to) && t.transactions.some((s) => !s.isUserEvent("input.type") && s.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = t.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(t) || !this.rangeIsValid(t.state) ? (this.pendingContextChange = null, this.reset(t.state)) : (t.docChanged || t.selectionSet || e) && this.setSelection(t.state), (t.geometryChanged || t.docChanged || t.selectionSet) && t.view.requestMeasure(this.measureReq);
  }
  resetRange(t) {
    let { head: e } = t.selection.main;
    this.from = Math.max(
      0,
      e - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      t.doc.length,
      e + 1e4
      /* CxVp.Margin */
    );
  }
  reset(t) {
    this.resetRange(t), this.editContext.updateText(0, this.editContext.text.length, t.doc.sliceString(this.from, this.to)), this.setSelection(t);
  }
  revertPending(t) {
    let e = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(e.from), this.toContextPos(e.from + e.insert.length), t.doc.sliceString(e.from, e.to));
  }
  setSelection(t) {
    let { main: e } = t.selection, i = this.toContextPos(Math.max(this.from, Math.min(this.to, e.anchor))), s = this.toContextPos(e.head);
    (this.editContext.selectionStart != i || this.editContext.selectionEnd != s) && this.editContext.updateSelection(i, s);
  }
  rangeIsValid(t) {
    let { head: e } = t.selection.main;
    return !(this.from > 0 && e - this.from < 500 || this.to < t.doc.length && this.to - e < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(t, e = this.to - this.from) {
    t = Math.min(t, e);
    let i = this.composing;
    return i && i.drifted ? i.editorBase + (t - i.contextBase) : t + this.from;
  }
  toContextPos(t) {
    let e = this.composing;
    return e && e.drifted ? e.contextBase + (t - e.editorBase) : t - this.from;
  }
  destroy() {
    for (let t in this.handlers)
      this.editContext.removeEventListener(t, this.handlers[t]);
  }
}, c(Lh, "wf"), Lh);
f(j8, "EditContextManager");
let gV = j8;
var Lr;
const F8 = (Lr = class {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(t = {}) {
    var e;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), t.parent && t.parent.appendChild(this.dom);
    let { dispatch: i } = t;
    this.dispatchTransactions = t.dispatchTransactions || i && ((s) => s.forEach((r) => i(r, this))) || ((s) => this.update(s)), this.dispatch = this.dispatch.bind(this), this._root = t.root || MQ(t.parent) || document, this.viewState = new f4(t.state || ze.create(t)), t.scrollTo && t.scrollTo.is(Tg) && (this.viewState.scrollTarget = t.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Rc).map((s) => new bO(s));
    for (let s of this.plugins)
      s.update(this);
    this.observer = new wV(this), this.inputState = new nV(this), this.inputState.ensureHandlers(this.plugins), this.docView = new a4(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((e = document.fonts) === null || e === void 0) && e.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...t) {
    let e = t.length == 1 && t[0] instanceof gi ? t : t.length == 1 && Array.isArray(t[0]) ? t[0] : [this.state.update(...t)];
    this.dispatchTransactions(e, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let e = !1, i = !1, s, r = this.state;
    for (let y of t) {
      if (y.startState != r)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      r = y.state;
    }
    if (this.destroyed) {
      this.viewState.state = r;
      return;
    }
    let a = this.hasFocus, o = 0, l = null;
    t.some((y) => y.annotation(f8)) ? (this.inputState.notifiedFocused = a, o = 1) : a != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = a, l = V5(r, a), l || (o = 1));
    let h = this.observer.delayedAndroidKey, u = null;
    if (h ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(r.doc) || !this.state.selection.eq(r.selection)) && (u = null)) : this.observer.clear(), r.facet(ze.phrases) != this.state.facet(ze.phrases))
      return this.setState(r);
    s = r4.create(this, r, t), s.flags |= o;
    let p = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let y of t) {
        if (p && (p = p.map(y.changes)), y.scrollIntoView) {
          let { main: m } = y.state.selection;
          p = new vO(m.empty ? m : J.cursor(m.head, m.head > m.anchor ? -1 : 1));
        }
        for (let m of y.effects)
          m.is(Tg) && (p = m.value.clip(this.state));
      }
      this.viewState.update(s, p), this.bidiCache = w4.update(this.bidiCache, s.changes), s.empty || (this.updatePlugins(s), this.inputState.update(s)), e = this.docView.update(s), this.state.facet(pm) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(t), this.docView.updateSelection(e, t.some((y) => y.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (s.startState.facet(Eg) != s.state.facet(Eg) && (this.viewState.mustMeasureContent = !0), (e || i || p || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), e && this.docViewUpdate(), !s.empty)
      for (let y of this.state.facet(B$))
        try {
          y(s);
        } catch (m) {
          Ci(this.state, m, "update listener");
        }
    (l || u) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), u && !z5(this, u) && h.force && Xa(this.contentDOM, h.key, h.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = t;
      return;
    }
    this.updateState = 2;
    let e = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new f4(t), this.plugins = t.facet(Rc).map((i) => new bO(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView.destroy(), this.docView = new a4(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    e && this.focus(), this.requestMeasure();
  }
  updatePlugins(t) {
    let e = t.startState.facet(Rc), i = t.state.facet(Rc);
    if (e != i) {
      let s = [];
      for (let r of i) {
        let a = e.indexOf(r);
        if (a < 0)
          s.push(new bO(r));
        else {
          let o = this.plugins[a];
          o.mustUpdate = t, s.push(o);
        }
      }
      for (let r of this.plugins)
        r.mustUpdate != t && r.destroy(this);
      this.plugins = s, this.pluginMap.clear();
    } else
      for (let s of this.plugins)
        s.mustUpdate = t;
    for (let s = 0; s < this.plugins.length; s++)
      this.plugins[s].update(this);
    e != i && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let t of this.plugins) {
      let e = t.value;
      if (e && e.docViewUpdate)
        try {
          e.docViewUpdate(this);
        } catch (i) {
          Ci(this.state, i, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(t = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, t && this.observer.forceFlush();
    let e = null, i = this.scrollDOM, s = i.scrollTop * this.scaleY, { scrollAnchorPos: r, scrollAnchorHeight: a } = this.viewState;
    Math.abs(s - this.viewState.scrollTop) > 1 && (a = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let o = 0; ; o++) {
        if (a < 0)
          if (d5(i))
            r = -1, a = this.viewState.heightMap.height;
          else {
            let m = this.viewState.scrollAnchorAt(s);
            r = m.from, a = m.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (o > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let h = [];
        l & 4 || ([this.measureRequests, h] = [h, this.measureRequests]);
        let u = h.map((m) => {
          try {
            return m.read(this);
          } catch (w) {
            return Ci(this.state, w), m4;
          }
        }), p = r4.create(this, this.state, []), y = !1;
        p.flags |= l, e ? e.flags |= l : e = p, this.updateState = 2, p.empty || (this.updatePlugins(p), this.inputState.update(p), this.updateAttrs(), y = this.docView.update(p), y && this.docViewUpdate());
        for (let m = 0; m < h.length; m++)
          if (u[m] != m4)
            try {
              let w = h[m];
              w.write && w.write(u[m], this);
            } catch (w) {
              Ci(this.state, w);
            }
        if (y && this.docView.updateSelection(!0), !p.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, a = -1;
              continue;
            } else {
              let m = (r < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(r).top) - a;
              if (m > 1 || m < -1) {
                s = s + m, i.scrollTop = s / this.scaleY, a = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (e && !e.empty)
      for (let o of this.state.facet(B$))
        o(e);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return ox + " " + (this.state.facet(ax) ? V8 : Z8) + " " + this.state.facet(Eg);
  }
  updateAttrs() {
    let t = hx(this, O7, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), e = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet($s) ? "true" : "false",
      class: "cm-content",
      style: `${tt.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (e["aria-readonly"] = "true"), hx(this, T5, e);
    let i = this.observer.ignore(() => {
      let s = sv(this.contentDOM, this.contentAttrs, e), r = sv(this.dom, this.editorAttrs, t);
      return s || r;
    });
    return this.editorAttrs = t, this.contentAttrs = e, i;
  }
  showAnnouncements(t) {
    let e = !0;
    for (let i of t)
      for (let s of i.effects)
        if (s.is(Lr.announce)) {
          e && (this.announceDOM.textContent = ""), e = !1;
          let r = this.announceDOM.appendChild(document.createElement("div"));
          r.textContent = s.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(pm);
    let t = this.state.facet(Lr.cspNonce);
    Hr.mount(this.root, this.styleModules.concat(yV).reverse(), t ? { nonce: t } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(t) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), t) {
      if (this.measureRequests.indexOf(t) > -1)
        return;
      if (t.key != null) {
        for (let e = 0; e < this.measureRequests.length; e++)
          if (this.measureRequests[e].key === t.key) {
            this.measureRequests[e] = t;
            return;
          }
      }
      this.measureRequests.push(t);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(t) {
    let e = this.pluginMap.get(t);
    return (e === void 0 || e && e.plugin != t) && this.pluginMap.set(t, e = this.plugins.find((i) => i.plugin == t) || null), e && e.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(t) {
    return this.readMeasured(), this.viewState.elementAtHeight(t);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(t) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(t);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(t) {
    return this.viewState.lineBlockAt(t);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(t, e, i) {
    return s1(this, t, K$(this, t, e, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(t, e) {
    return s1(this, t, K$(this, t, e, (i) => W7(this, t.head, i)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(t, e) {
    let i = this.bidiSpans(t), s = this.textDirectionAt(t.from), r = i[e ? i.length - 1 : 0];
    return J.cursor(r.side(e, s) + t.from, r.forward(!e, s) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(t, e, i = !0) {
    return D7(this, t, e, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(t, e, i) {
    return s1(this, t, q7(this, t, e, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(t) {
    return this.docView.domAtPos(t);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(t, e = 0) {
    return this.docView.posFromDOM(t, e);
  }
  posAtCoords(t, e = !0) {
    return this.readMeasured(), R5(this, t, e);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(t, e = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(t, e);
    if (!i || i.left == i.right)
      return i;
    let s = this.state.doc.lineAt(t), r = this.bidiSpans(s), a = r[br.find(r, t - s.from, -1, e)];
    return $y(i, a.dir == Qe.LTR == e > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(t) {
    return this.readMeasured(), this.docView.coordsForChar(t);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(t) {
    return !this.state.facet(y7) || t < this.viewport.from || t > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(t));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(t) {
    if (t.length > vV)
      return C5(t.length);
    let e = this.textDirectionAt(t.from), i;
    for (let r of this.bidiCache)
      if (r.from == t.from && r.dir == e && (r.fresh || P5(r.isolates, i = X$(this, t))))
        return r.order;
    i || (i = X$(this, t));
    let s = r7(t.text, e, i);
    return this.bidiCache.push(new w4(t.from, t.to, e, i, !0, s)), s;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var t;
    return (this.dom.ownerDocument.hasFocus() || tt.safari && ((t = this.inputState) === null || t === void 0 ? void 0 : t.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      c5(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(t) {
    this._root != t && (this._root = t, this.observer.setWindow((t.nodeType == 9 ? t : t.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let t of this.plugins)
      t.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(t, e = {}) {
    return Tg.of(new vO(typeof t == "number" ? J.cursor(t) : t, e.y, e.x, e.yMargin, e.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: t, scrollLeft: e } = this.scrollDOM, i = this.viewState.scrollAnchorAt(t);
    return Tg.of(new vO(J.cursor(i.from), "start", "start", i.top - t, e, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(t) {
    t == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof t == "boolean" ? this.inputState.tabFocusMode = t ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + t);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(t) {
    return Zs.define(() => ({}), { eventHandlers: t });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(t) {
    return Zs.define(() => ({}), { eventObservers: t });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(t, e) {
    let i = Hr.newName(), s = [Eg.of(i), pm.of(lv(`.${i}`, t))];
    return e && e.dark && s.push(ax.of(!0)), s;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(t) {
    return al.lowest(pm.of(lv("." + ox, t, D8)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(t) {
    var e;
    let i = t.querySelector(".cm-content");
    return ((e = (i && te.get(i) || te.get(t))?.rootView) === null || e === void 0 ? void 0 : e.view) || null;
  }
}, c(Lr, "Er"), Lr);
f(F8, "EditorView");
let $t = F8;
$t.styleModule = pm;
$t.inputHandler = p7;
$t.clipboardInputFilter = Q5;
$t.clipboardOutputFilter = M5;
$t.scrollHandler = m7;
$t.focusChangeEffect = f7;
$t.perLineTextDirection = y7;
$t.exceptionSink = u7;
$t.updateListener = B$;
$t.editable = $s;
$t.mouseSelectionStyle = d7;
$t.dragMovesSelection = h7;
$t.clickAddsSelectionRange = c7;
$t.decorations = yw;
$t.outerDecorations = $7;
$t.atomicRanges = Kw;
$t.bidiIsolatedRanges = x7;
$t.scrollMargins = k7;
$t.darkTheme = ax;
$t.cspNonce = /* @__PURE__ */ gt.define({ combine: /* @__PURE__ */ f((n) => n.length ? n[0] : "", "combine") });
$t.contentAttributes = T5;
$t.editorAttributes = O7;
$t.lineWrapping = /* @__PURE__ */ $t.contentAttributes.of({ class: "cm-lineWrapping" });
$t.announce = /* @__PURE__ */ Bt.define();
const vV = 4096, m4 = {};
var yo;
const U8 = (yo = class {
  constructor(t, e, i, s, r, a) {
    this.from = t, this.to = e, this.dir = i, this.isolates = s, this.fresh = r, this.order = a;
  }
  static update(t, e) {
    if (e.empty && !t.some((r) => r.fresh))
      return t;
    let i = [], s = t.length ? t[t.length - 1].dir : Qe.LTR;
    for (let r = Math.max(0, t.length - 10); r < t.length; r++) {
      let a = t[r];
      a.dir == s && !e.touchesRange(a.from, a.to) && i.push(new yo(e.mapPos(a.from, 1), e.mapPos(a.to, -1), a.dir, a.isolates, !1, a.order));
    }
    return i;
  }
}, c(yo, "io"), yo);
f(U8, "CachedOrder");
let w4 = U8;
function hx(n, t, e) {
  for (let i = n.state.facet(t), s = i.length - 1; s >= 0; s--) {
    let r = i[s], a = typeof r == "function" ? r(n) : r;
    a && nv(a, e);
  }
  return e;
}
c(hx, "pu$1");
f(hx, "attrsFromFacet");
const bV = tt.mac ? "mac" : tt.windows ? "win" : tt.linux ? "linux" : "key";
function B8(n, t) {
  const e = n.split(/-(?!$)/);
  let i = e[e.length - 1];
  i == "Space" && (i = " ");
  let s, r, a, o;
  for (let l = 0; l < e.length - 1; ++l) {
    const h = e[l];
    if (/^(cmd|meta|m)$/i.test(h))
      o = !0;
    else if (/^a(lt)?$/i.test(h))
      s = !0;
    else if (/^(c|ctrl|control)$/i.test(h))
      r = !0;
    else if (/^s(hift)?$/i.test(h))
      a = !0;
    else if (/^mod$/i.test(h))
      t == "mac" ? o = !0 : r = !0;
    else
      throw new Error("Unrecognized modifier name: " + h);
  }
  return s && (i = "Alt-" + i), r && (i = "Ctrl-" + i), o && (i = "Meta-" + i), a && (i = "Shift-" + i), i;
}
c(B8, "ly$1");
f(B8, "normalizeKeyName");
function gm(n, t, e) {
  return t.altKey && (n = "Alt-" + n), t.ctrlKey && (n = "Ctrl-" + n), t.metaKey && (n = "Meta-" + n), e !== !1 && t.shiftKey && (n = "Shift-" + n), n;
}
c(gm, "En$1");
f(gm, "modifiers");
const OV = /* @__PURE__ */ al.default(/* @__PURE__ */ $t.domEventHandlers({
  keydown(n, t) {
    return H8(X8(t.state), n, t, "editor");
  }
})), wb = /* @__PURE__ */ gt.define({ enables: OV }), g4 = /* @__PURE__ */ new WeakMap();
function X8(n) {
  let t = n.facet(wb), e = g4.get(t);
  return e || g4.set(t, e = N8(t.reduce((i, s) => i.concat(s), []))), e;
}
c(X8, "hy$1");
f(X8, "getKeymap");
let gr = null;
const $V = 4e3;
function N8(n, t = bV) {
  let e = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ f((a, o) => {
    let l = i[a];
    if (l == null)
      i[a] = o;
    else if (l != o)
      throw new Error("Key binding " + a + " is used both as a regular binding and as a multi-stroke prefix");
  }, "checkPrefix"), r = /* @__PURE__ */ f((a, o, l, h, u) => {
    var p, y;
    let m = e[a] || (e[a] = /* @__PURE__ */ Object.create(null)), w = o.split(/ (?!$)/).map((x) => B8(x, t));
    for (let x = 1; x < w.length; x++) {
      let C = w.slice(0, x).join(" ");
      s(C, !0), m[C] || (m[C] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(R) => {
          let E = gr = { view: R, prefix: C, scope: a };
          return setTimeout(() => {
            gr == E && (gr = null);
          }, $V), !0;
        }]
      });
    }
    let b = w.join(" ");
    s(b, !1);
    let $ = m[b] || (m[b] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((y = (p = m._any) === null || p === void 0 ? void 0 : p.run) === null || y === void 0 ? void 0 : y.slice()) || []
    });
    l && $.run.push(l), h && ($.preventDefault = !0), u && ($.stopPropagation = !0);
  }, "add");
  for (let a of n) {
    let o = a.scope ? a.scope.split(" ") : ["editor"];
    if (a.any)
      for (let h of o) {
        let u = e[h] || (e[h] = /* @__PURE__ */ Object.create(null));
        u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: p } = a;
        for (let y in u)
          u[y].run.push((m) => p(m, dx));
      }
    let l = a[t] || a.key;
    if (l)
      for (let h of o)
        r(h, l, a.run, a.preventDefault, a.stopPropagation), a.shift && r(h, "Shift-" + l, a.shift, a.preventDefault, a.stopPropagation);
  }
  return e;
}
c(N8, "cy$1");
f(N8, "buildKeymap");
let dx = null;
function H8(n, t, e, i) {
  dx = t;
  let s = xQ(t), r = pr(s, 0), a = Wa(r) == s.length && s != " ", o = "", l = !1, h = !1, u = !1;
  gr && gr.view == e && gr.scope == i && (o = gr.prefix + " ", t8.indexOf(t.keyCode) < 0 && (h = !0, gr = null));
  let p = /* @__PURE__ */ new Set(), y = /* @__PURE__ */ f(($) => {
    if ($) {
      for (let x of $.run)
        if (!p.has(x) && (p.add(x), x(e)))
          return $.stopPropagation && (u = !0), !0;
      $.preventDefault && ($.stopPropagation && (u = !0), h = !0);
    }
    return !1;
  }, "runFor"), m = n[i], w, b;
  return m && (y(m[o + gm(s, t, !a)]) ? l = !0 : a && (t.altKey || t.metaKey || t.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(tt.windows && t.ctrlKey && t.altKey) && // Alt-combinations on macOS tend to be typed characters
  !(tt.mac && t.altKey && !(t.ctrlKey || t.metaKey)) && (w = Yr[t.keyCode]) && w != s ? (y(m[o + gm(w, t, !0)]) || t.shiftKey && (b = uw[t.keyCode]) != s && b != w && y(m[o + gm(b, t, !1)])) && (l = !0) : a && t.shiftKey && y(m[o + gm(s, t, !0)]) && (l = !0), !l && y(m._any) && (l = !0)), h && (l = !0), l && u && t.stopPropagation(), dx = null, l;
}
c(H8, "uy$1");
f(H8, "runHandlers");
const Y8 = /* @__PURE__ */ Bt.define({
  map(n, t) {
    return n == null ? null : t.mapPos(n);
  }
}), vm = /* @__PURE__ */ Xs.define({
  create() {
    return null;
  },
  update(n, t) {
    return n != null && (n = t.changes.mapPos(n)), t.effects.reduce((e, i) => i.is(Y8) ? i.value : e, n);
  }
}), xV = /* @__PURE__ */ Zs.fromClass(class {
  constructor(n) {
    this.view = n, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(n) {
    var t;
    let e = n.state.field(vm);
    e == null ? this.cursor != null && ((t = this.cursor) === null || t === void 0 || t.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (n.startState.field(vm) != e || n.docChanged || n.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: n } = this, t = n.state.field(vm), e = t != null && n.coordsAtPos(t);
    if (!e)
      return null;
    let i = n.scrollDOM.getBoundingClientRect();
    return {
      left: e.left - i.left + n.scrollDOM.scrollLeft * n.scaleX,
      top: e.top - i.top + n.scrollDOM.scrollTop * n.scaleY,
      height: e.bottom - e.top
    };
  }
  drawCursor(n) {
    if (this.cursor) {
      let { scaleX: t, scaleY: e } = this.view;
      n ? (this.cursor.style.left = n.left / t + "px", this.cursor.style.top = n.top / e + "px", this.cursor.style.height = n.height / e + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(n) {
    this.view.state.field(vm) != n && this.view.dispatch({ effects: Y8.of(n) });
  }
}, {
  eventObservers: {
    dragover(n) {
      this.setDropPos(this.view.posAtCoords({ x: n.clientX, y: n.clientY }));
    },
    dragleave(n) {
      (n.target == this.view.contentDOM || !this.view.contentDOM.contains(n.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function kV() {
  return [vm, xV];
}
c(kV, "Oy$1");
f(kV, "dropCursor");
function ux(n, t, e, i, s) {
  t.lastIndex = 0;
  for (let r = n.iterRange(e, i), a = e, o; !r.next().done; a += r.value.length)
    if (!r.lineBreak)
      for (; o = t.exec(r.value); )
        s(a + o.index, o);
}
c(ux, "gu$1");
f(ux, "iterMatches");
function G8(n, t) {
  let e = n.visibleRanges;
  if (e.length == 1 && e[0].from == n.viewport.from && e[0].to == n.viewport.to)
    return e;
  let i = [];
  for (let { from: s, to: r } of e)
    s = Math.max(n.state.doc.lineAt(s).from, s - t), r = Math.min(n.state.doc.lineAt(r).to, r + t), i.length && i[i.length - 1].to >= s ? i[i.length - 1].to = r : i.push({ from: s, to: r });
  return i;
}
c(G8, "py$1");
f(G8, "matchRanges");
var Ih;
const K8 = (Ih = class {
  /**
  Create a decorator.
  */
  constructor(t) {
    const { regexp: e, decoration: i, decorate: s, boundary: r, maxLength: a = 1e3 } = t;
    if (!e.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = e, s)
      this.addMatch = (o, l, h, u) => s(u, h, h + o[0].length, o, l);
    else if (typeof i == "function")
      this.addMatch = (o, l, h, u) => {
        let p = i(o, l, h);
        p && u(h, h + o[0].length, p);
      };
    else if (i)
      this.addMatch = (o, l, h, u) => u(h, h + o[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = r, this.maxLength = a;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(t) {
    let e = new tv(), i = e.add.bind(e);
    for (let { from: s, to: r } of G8(t, this.maxLength))
      ux(t.state.doc, this.regexp, s, r, (a, o) => this.addMatch(o, t, a, i));
    return e.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(t, e) {
    let i = 1e9, s = -1;
    return t.docChanged && t.changes.iterChanges((r, a, o, l) => {
      l >= t.view.viewport.from && o <= t.view.viewport.to && (i = Math.min(o, i), s = Math.max(l, s));
    }), t.viewportMoved || s - i > 1e3 ? this.createDeco(t.view) : s > -1 ? this.updateRange(t.view, e.map(t.changes), i, s) : e;
  }
  updateRange(t, e, i, s) {
    for (let r of t.visibleRanges) {
      let a = Math.max(r.from, i), o = Math.min(r.to, s);
      if (o >= a) {
        let l = t.state.doc.lineAt(a), h = l.to < o ? t.state.doc.lineAt(o) : l, u = Math.max(r.from, l.from), p = Math.min(r.to, h.to);
        if (this.boundary) {
          for (; a > l.from; a--)
            if (this.boundary.test(l.text[a - 1 - l.from])) {
              u = a;
              break;
            }
          for (; o < h.to; o++)
            if (this.boundary.test(h.text[o - h.from])) {
              p = o;
              break;
            }
        }
        let y = [], m, w = /* @__PURE__ */ f((b, $, x) => y.push(x.range(b, $)), "add");
        if (l == h)
          for (this.regexp.lastIndex = u - l.from; (m = this.regexp.exec(l.text)) && m.index < p - l.from; )
            this.addMatch(m, t, m.index + l.from, w);
        else
          ux(t.state.doc, this.regexp, u, p, (b, $) => this.addMatch($, t, b, w));
        e = e.update({ filterFrom: u, filterTo: p, filter: /* @__PURE__ */ f((b, $) => b < u || $ > p, "filter"), add: y });
      }
    }
    return e;
  }
}, c(Ih, "xf"), Ih);
f(K8, "MatchDecorator");
let SV = K8;
var Zh;
const J8 = (Zh = class extends xy {
  constructor(t) {
    super(), this.content = t;
  }
  toDOM(t) {
    let e = document.createElement("span");
    return e.className = "cm-placeholder", e.style.pointerEvents = "none", e.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(t) : this.content.cloneNode(!0)), e.setAttribute("aria-hidden", "true"), e;
  }
  coordsAt(t) {
    let e = t.firstChild ? Zo(t.firstChild) : [];
    if (!e.length)
      return null;
    let i = window.getComputedStyle(t.parentNode), s = $y(e[0], i.direction != "rtl"), r = parseInt(i.lineHeight);
    return s.bottom - s.top > r * 1.5 ? { left: s.left, right: s.right, top: s.top, bottom: s.top + r } : s;
  }
  ignoreEvent() {
    return !1;
  }
}, c(Zh, "kf"), Zh);
f(J8, "Placeholder");
let PV = J8;
function CV(n) {
  let t = Zs.fromClass(class {
    constructor(e) {
      this.view = e, this.placeholder = n ? ee.set([ee.widget({ widget: new PV(n), side: 1 }).range(0)]) : ee.none;
    }
    get decorations() {
      return this.view.state.doc.length ? ee.none : this.placeholder;
    }
  }, { decorations: /* @__PURE__ */ f((e) => e.decorations, "decorations") });
  return typeof n == "string" ? [
    t,
    $t.contentAttributes.of({ "aria-placeholder": n })
  ] : t;
}
c(CV, "my$1");
f(CV, "placeholder");
const Vy = "-10000px";
var Vh;
const t6 = (Vh = class {
  constructor(t, e, i, s) {
    this.facet = e, this.createTooltipView = i, this.removeTooltipView = s, this.input = t.state.facet(e), this.tooltips = this.input.filter((a) => a);
    let r = null;
    this.tooltipViews = this.tooltips.map((a) => r = i(a, r));
  }
  update(t, e) {
    var i;
    let s = t.state.facet(this.facet), r = s.filter((l) => l);
    if (s === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(t);
      return !1;
    }
    let a = [], o = e ? [] : null;
    for (let l = 0; l < r.length; l++) {
      let h = r[l], u = -1;
      if (h) {
        for (let p = 0; p < this.tooltips.length; p++) {
          let y = this.tooltips[p];
          y && y.create == h.create && (u = p);
        }
        if (u < 0)
          a[l] = this.createTooltipView(h, l ? a[l - 1] : null), o && (o[l] = !!h.above);
        else {
          let p = a[l] = this.tooltipViews[u];
          o && (o[l] = e[u]), p.update && p.update(t);
        }
      }
    }
    for (let l of this.tooltipViews)
      a.indexOf(l) < 0 && (this.removeTooltipView(l), (i = l.destroy) === null || i === void 0 || i.call(l));
    return e && (o.forEach((l, h) => e[h] = l), e.length = o.length), this.input = s, this.tooltips = r, this.tooltipViews = a, !0;
  }
}, c(Vh, "Pf"), Vh);
f(t6, "TooltipViewManager");
let QV = t6;
function e6(n) {
  let t = n.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: t.clientHeight, right: t.clientWidth };
}
c(e6, "gy$1");
f(e6, "windowSpace");
const kO = /* @__PURE__ */ gt.define({
  combine: /* @__PURE__ */ f((n) => {
    var t, e, i;
    return {
      position: tt.ios ? "absolute" : ((t = n.find((s) => s.position)) === null || t === void 0 ? void 0 : t.position) || "fixed",
      parent: ((e = n.find((s) => s.parent)) === null || e === void 0 ? void 0 : e.parent) || null,
      tooltipSpace: ((i = n.find((s) => s.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || e6
    };
  }, "combine")
}), v4 = /* @__PURE__ */ new WeakMap(), i6 = /* @__PURE__ */ Zs.fromClass(class {
  constructor(n) {
    this.view = n, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let t = n.state.facet(kO);
    this.position = t.position, this.parent = t.parent, this.classes = n.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new QV(n, n6, (e, i) => this.createTooltip(e, i), (e) => {
      this.resizeObserver && this.resizeObserver.unobserve(e.dom), e.dom.remove();
    }), this.above = this.manager.tooltips.map((e) => !!e.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((e) => {
      Date.now() > this.lastTransaction - 50 && e.length > 0 && e[e.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), n.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let n of this.manager.tooltipViews)
        this.intersectionObserver.observe(n.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(n) {
    n.transactions.length && (this.lastTransaction = Date.now());
    let t = this.manager.update(n, this.above);
    t && this.observeIntersection();
    let e = t || n.geometryChanged, i = n.state.facet(kO);
    if (i.position != this.position && !this.madeAbsolute) {
      this.position = i.position;
      for (let s of this.manager.tooltipViews)
        s.dom.style.position = this.position;
      e = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let s of this.manager.tooltipViews)
        this.container.appendChild(s.dom);
      e = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    e && this.maybeMeasure();
  }
  createTooltip(n, t) {
    let e = n.create(this.view), i = t ? t.dom : null;
    if (e.dom.classList.add("cm-tooltip"), n.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let s = document.createElement("div");
      s.className = "cm-tooltip-arrow", e.dom.appendChild(s);
    }
    return e.dom.style.position = this.position, e.dom.style.top = Vy, e.dom.style.left = "0px", this.container.insertBefore(e.dom, i), e.mount && e.mount(this.view), this.resizeObserver && this.resizeObserver.observe(e.dom), e;
  }
  destroy() {
    var n, t, e;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let i of this.manager.tooltipViews)
      i.dom.remove(), (n = i.destroy) === null || n === void 0 || n.call(i);
    this.parent && this.container.remove(), (t = this.resizeObserver) === null || t === void 0 || t.disconnect(), (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let n = 1, t = 1, e = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: r } = this.manager.tooltipViews[0];
      if (tt.gecko)
        e = r.offsetParent != this.container.ownerDocument.body;
      else if (r.style.top == Vy && r.style.left == "0px") {
        let a = r.getBoundingClientRect();
        e = Math.abs(a.top + 1e4) > 1 || Math.abs(a.left) > 1;
      }
    }
    if (e || this.position == "absolute")
      if (this.parent) {
        let r = this.parent.getBoundingClientRect();
        r.width && r.height && (n = r.width / this.parent.offsetWidth, t = r.height / this.parent.offsetHeight);
      } else
        ({ scaleX: n, scaleY: t } = this.view.viewState);
    let i = this.view.scrollDOM.getBoundingClientRect(), s = yb(this.view);
    return {
      visible: {
        left: i.left + s.left,
        top: i.top + s.top,
        right: i.right - s.right,
        bottom: i.bottom - s.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((r, a) => {
        let o = this.manager.tooltipViews[a];
        return o.getCoords ? o.getCoords(r.pos) : this.view.coordsAtPos(r.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: r }) => r.getBoundingClientRect()),
      space: this.view.state.facet(kO).tooltipSpace(this.view),
      scaleX: n,
      scaleY: t,
      makeAbsolute: e
    };
  }
  writeMeasure(n) {
    var t;
    if (n.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let o of this.manager.tooltipViews)
        o.dom.style.position = "absolute";
    }
    let { visible: e, space: i, scaleX: s, scaleY: r } = n, a = [];
    for (let o = 0; o < this.manager.tooltips.length; o++) {
      let l = this.manager.tooltips[o], h = this.manager.tooltipViews[o], { dom: u } = h, p = n.pos[o], y = n.size[o];
      if (!p || l.clip !== !1 && (p.bottom <= Math.max(e.top, i.top) || p.top >= Math.min(e.bottom, i.bottom) || p.right < Math.max(e.left, i.left) - 0.1 || p.left > Math.min(e.right, i.right) + 0.1)) {
        u.style.top = Vy;
        continue;
      }
      let m = l.arrow ? h.dom.querySelector(".cm-tooltip-arrow") : null, w = m ? 7 : 0, b = y.right - y.left, $ = (t = v4.get(h)) !== null && t !== void 0 ? t : y.bottom - y.top, x = h.offset || TV, C = this.view.textDirection == Qe.LTR, R = y.width > i.right - i.left ? C ? i.left : i.right - y.width : C ? Math.max(i.left, Math.min(p.left - (m ? 14 : 0) + x.x, i.right - b)) : Math.min(Math.max(i.left, p.left - b + (m ? 14 : 0) - x.x), i.right - b), E = this.above[o];
      !l.strictSide && (E ? p.top - $ - w - x.y < i.top : p.bottom + $ + w + x.y > i.bottom) && E == i.bottom - p.bottom > p.top - i.top && (E = this.above[o] = !E);
      let A = (E ? p.top - i.top : i.bottom - p.bottom) - w;
      if (A < $ && h.resize !== !1) {
        if (A < this.view.defaultLineHeight) {
          u.style.top = Vy;
          continue;
        }
        v4.set(h, $), u.style.height = ($ = A) / r + "px";
      } else u.style.height && (u.style.height = "");
      let I = E ? p.top - $ - w - x.y : p.bottom + w + x.y, Z = R + b;
      if (h.overlap !== !0)
        for (let j of a)
          j.left < Z && j.right > R && j.top < I + $ && j.bottom > I && (I = E ? j.top - $ - 2 - w : j.bottom + w + 2);
      if (this.position == "absolute" ? (u.style.top = (I - n.parent.top) / r + "px", px(u, (R - n.parent.left) / s)) : (u.style.top = I / r + "px", px(u, R / s)), m) {
        let j = p.left + (C ? x.x : -x.x) - (R + 14 - 7);
        m.style.left = j / s + "px";
      }
      h.overlap !== !0 && a.push({ left: R, top: I, right: Z, bottom: I + $ }), u.classList.toggle("cm-tooltip-above", E), u.classList.toggle("cm-tooltip-below", !E), h.positioned && h.positioned(n.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let n of this.manager.tooltipViews)
        n.dom.style.top = Vy;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function px(n, t) {
  let e = parseInt(n.style.left, 10);
  (isNaN(e) || Math.abs(t - e) > 1) && (n.style.left = t + "px");
}
c(px, "bu$1");
f(px, "setLeftStyle");
const MV = /* @__PURE__ */ $t.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), TV = { x: 0, y: 0 }, n6 = /* @__PURE__ */ gt.define({
  enables: [i6, MV]
});
function W5(n, t) {
  let e = n.plugin(i6);
  if (!e)
    return null;
  let i = e.manager.tooltips.indexOf(t);
  return i < 0 ? null : e.manager.tooltipViews[i];
}
c(W5, "GO");
f(W5, "getTooltip");
var Dh;
const s6 = (Dh = class extends Io {
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(t) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(t) {
  }
}, c(Dh, "Rf"), Dh);
f(s6, "GutterMarker");
let Nf = s6;
Nf.prototype.elementClass = "";
Nf.prototype.toDOM = void 0;
Nf.prototype.mapMode = wi.TrackBefore;
Nf.prototype.startSide = Nf.prototype.endSide = -1;
Nf.prototype.point = !0;
const r6 = 1024;
let AV = 0;
var Wh;
const a6 = (Wh = class {
  constructor(t, e) {
    this.from = t, this.to = e;
  }
}, c(Wh, "$f"), Wh);
f(a6, "Range");
let Ki = a6;
var qh;
const o6 = (qh = class {
  /**
  Create a new node prop type.
  */
  constructor(t = {}) {
    this.id = AV++, this.perNode = !!t.perNode, this.deserialize = t.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(t) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof t != "function" && (t = Ue.match(t)), (e) => {
      let i = t(e);
      return i === void 0 ? null : [this, i];
    };
  }
}, c(qh, "vf"), qh);
f(o6, "NodeProp");
let xt = o6;
xt.closedBy = new xt({ deserialize: /* @__PURE__ */ f((n) => n.split(" "), "deserialize") });
xt.openedBy = new xt({ deserialize: /* @__PURE__ */ f((n) => n.split(" "), "deserialize") });
xt.group = new xt({ deserialize: /* @__PURE__ */ f((n) => n.split(" "), "deserialize") });
xt.isolate = new xt({ deserialize: /* @__PURE__ */ f((n) => {
  if (n && n != "rtl" && n != "ltr" && n != "auto")
    throw new RangeError("Invalid value for isolate: " + n);
  return n || "auto";
}, "deserialize") });
xt.contextHash = new xt({ perNode: !0 });
xt.lookAhead = new xt({ perNode: !0 });
xt.mounted = new xt({ perNode: !0 });
var jh;
const l6 = (jh = class {
  constructor(t, e, i) {
    this.tree = t, this.overlay = e, this.parser = i;
  }
  /**
  @internal
  */
  static get(t) {
    return t && t.props && t.props[xt.mounted.id];
  }
}, c(jh, "Tf"), jh);
f(l6, "MountedTree");
let ww = l6;
const RV = /* @__PURE__ */ Object.create(null);
var mo;
const c6 = (mo = class {
  /**
  @internal
  */
  constructor(t, e, i, s = 0) {
    this.name = t, this.props = e, this.id = i, this.flags = s;
  }
  /**
  Define a node type.
  */
  static define(t) {
    let e = t.props && t.props.length ? /* @__PURE__ */ Object.create(null) : RV, i = (t.top ? 1 : 0) | (t.skipped ? 2 : 0) | (t.error ? 4 : 0) | (t.name == null ? 8 : 0), s = new mo(t.name || "", e, t.id, i);
    if (t.props) {
      for (let r of t.props)
        if (Array.isArray(r) || (r = r(s)), r) {
          if (r[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          e[r[0].id] = r[1];
        }
    }
    return s;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(t) {
    return this.props[t.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(t) {
    if (typeof t == "string") {
      if (this.name == t)
        return !0;
      let e = this.prop(xt.group);
      return e ? e.indexOf(t) > -1 : !1;
    }
    return this.id == t;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(t) {
    let e = /* @__PURE__ */ Object.create(null);
    for (let i in t)
      for (let s of i.split(" "))
        e[s] = t[i];
    return (i) => {
      for (let s = i.prop(xt.group), r = -1; r < (s ? s.length : 0); r++) {
        let a = e[r < 0 ? i.name : s[r]];
        if (a)
          return a;
      }
    };
  }
}, c(mo, "ro"), mo);
f(c6, "NodeType");
let Ue = c6;
Ue.none = new Ue(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
var wo;
const h6 = (wo = class {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(t) {
    this.types = t;
    for (let e = 0; e < t.length; e++)
      if (t[e].id != e)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...t) {
    let e = [];
    for (let i of this.types) {
      let s = null;
      for (let r of t) {
        let a = r(i);
        a && (s || (s = Object.assign({}, i.props)), s[a[0].id] = a[1]);
      }
      e.push(s ? new Ue(i.name, s, i.id, i.flags) : i);
    }
    return new wo(e);
  }
}, c(wo, "no"), wo);
f(h6, "NodeSet");
let gb = h6;
const _g = /* @__PURE__ */ new WeakMap(), b4 = /* @__PURE__ */ new WeakMap();
var Yt;
(function(n) {
  n[n.ExcludeBuffers = 1] = "ExcludeBuffers", n[n.IncludeAnonymous = 2] = "IncludeAnonymous", n[n.IgnoreMounts = 4] = "IgnoreMounts", n[n.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Yt || (Yt = {}));
var Ir;
const d6 = (Ir = class {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(t, e, i, s, r) {
    if (this.type = t, this.children = e, this.positions = i, this.length = s, this.props = null, r && r.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [a, o] of r)
        this.props[typeof a == "number" ? a : a.id] = o;
    }
  }
  /**
  @internal
  */
  toString() {
    let t = ww.get(this);
    if (t && !t.overlay)
      return t.tree.toString();
    let e = "";
    for (let i of this.children) {
      let s = i.toString();
      s && (e && (e += ","), e += s);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (e.length ? "(" + e + ")" : "") : e;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(t = 0) {
    return new hv(this.topNode, t);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(t, e = 0, i = 0) {
    let s = _g.get(this) || this.topNode, r = new hv(s);
    return r.moveTo(t, e), _g.set(this, r._tree), r;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new sn(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(t, e = 0) {
    let i = Yf(_g.get(this) || this.topNode, t, e, !1);
    return _g.set(this, i), i;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(t, e = 0) {
    let i = Yf(b4.get(this) || this.topNode, t, e, !0);
    return b4.set(this, i), i;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(t, e = 0) {
    return b6(this, t, e);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(t) {
    let { enter: e, leave: i, from: s = 0, to: r = this.length } = t, a = t.mode || 0, o = (a & Yt.IncludeAnonymous) > 0;
    for (let l = this.cursor(a | Yt.IncludeAnonymous); ; ) {
      let h = !1;
      if (l.from <= r && l.to >= s && (!o && l.type.isAnonymous || e(l) !== !1)) {
        if (l.firstChild())
          continue;
        h = !0;
      }
      for (; h && i && (o || !l.type.isAnonymous) && i(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        h = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(t) {
    return t.perNode ? this.props ? this.props[t.id] : void 0 : this.type.prop(t);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let t = [];
    if (this.props)
      for (let e in this.props)
        t.push([+e, this.props[e]]);
    return t;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(t = {}) {
    return this.children.length <= 8 ? this : bb(Ue.none, this.children, this.positions, 0, this.children.length, 0, this.length, (e, i, s) => new Ir(this.type, e, i, s, this.propValues), t.makeTree || ((e, i, s) => new Ir(Ue.none, e, i, s)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(t) {
    return $6(t);
  }
}, c(Ir, "Vr"), Ir);
f(d6, "Tree");
let Lt = d6;
Lt.empty = new Lt(Ue.none, [], [], 0);
var go;
const u6 = (go = class {
  constructor(t, e) {
    this.buffer = t, this.index = e;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new go(this.buffer, this.index);
  }
}, c(go, "so"), go);
f(u6, "FlatBufferCursor");
let EV = u6;
var vo;
const p6 = (vo = class {
  /**
  Create a tree buffer.
  */
  constructor(t, e, i) {
    this.buffer = t, this.length = e, this.set = i;
  }
  /**
  @internal
  */
  get type() {
    return Ue.none;
  }
  /**
  @internal
  */
  toString() {
    let t = [];
    for (let e = 0; e < this.buffer.length; )
      t.push(this.childString(e)), e = this.buffer[e + 3];
    return t.join(",");
  }
  /**
  @internal
  */
  childString(t) {
    let e = this.buffer[t], i = this.buffer[t + 3], s = this.set.types[e], r = s.name;
    if (/\W/.test(r) && !s.isError && (r = JSON.stringify(r)), t += 4, i == t)
      return r;
    let a = [];
    for (; t < i; )
      a.push(this.childString(t)), t = this.buffer[t + 3];
    return r + "(" + a.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(t, e, i, s, r) {
    let { buffer: a } = this, o = -1;
    for (let l = t; l != e && !(q5(r, s, a[l + 1], a[l + 2]) && (o = l, i > 0)); l = a[l + 3])
      ;
    return o;
  }
  /**
  @internal
  */
  slice(t, e, i) {
    let s = this.buffer, r = new Uint16Array(e - t), a = 0;
    for (let o = t, l = 0; o < e; ) {
      r[l++] = s[o++], r[l++] = s[o++] - i;
      let h = r[l++] = s[o++] - i;
      r[l++] = s[o++] - t, a = Math.max(a, h);
    }
    return new vo(r, a, this.set);
  }
}, c(vo, "oo"), vo);
f(p6, "TreeBuffer");
let Hf = p6;
function q5(n, t, e, i) {
  switch (n) {
    case -2:
      return e < t;
    case -1:
      return i >= t && e < t;
    case 0:
      return e < t && i > t;
    case 1:
      return e <= t && i > t;
    case 2:
      return i > t;
    case 4:
      return !0;
  }
}
c(q5, "FO");
f(q5, "checkSide");
function Yf(n, t, e, i) {
  for (var s; n.from == n.to || (e < 1 ? n.from >= t : n.from > t) || (e > -1 ? n.to <= t : n.to < t); ) {
    let a = !i && n instanceof sn && n.index < 0 ? null : n.parent;
    if (!a)
      return n;
    n = a;
  }
  let r = i ? 0 : Yt.IgnoreOverlays;
  if (i)
    for (let a = n, o = a.parent; o; a = o, o = a.parent)
      a instanceof sn && a.index < 0 && ((s = o.enter(t, e, r)) === null || s === void 0 ? void 0 : s.from) != a.from && (n = o);
  for (; ; ) {
    let a = n.enter(t, e, r);
    if (!a)
      return n;
    n = a;
  }
}
c(Yf, "sn$1");
f(Yf, "resolveNode");
var Fh;
const f6 = (Fh = class {
  cursor(t = 0) {
    return new hv(this, t);
  }
  getChild(t, e = null, i = null) {
    let s = fx(this, t, e, i);
    return s.length ? s[0] : null;
  }
  getChildren(t, e = null, i = null) {
    return fx(this, t, e, i);
  }
  resolve(t, e = 0) {
    return Yf(this, t, e, !1);
  }
  resolveInner(t, e = 0) {
    return Yf(this, t, e, !0);
  }
  matchContext(t) {
    return cv(this.parent, t);
  }
  enterUnfinishedNodesBefore(t) {
    let e = this.childBefore(t), i = this;
    for (; e; ) {
      let s = e.lastChild;
      if (!s || s.to != e.to)
        break;
      s.type.isError && s.from == s.to ? (i = e, e = s.prevSibling) : e = s;
    }
    return i;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}, c(Fh, "Af"), Fh);
f(f6, "BaseNode");
let y6 = f6;
var _s;
const m6 = (_s = class extends y6 {
  constructor(t, e, i, s) {
    super(), this._tree = t, this.from = e, this.index = i, this._parent = s;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(t, e, i, s, r = 0) {
    for (let a = this; ; ) {
      for (let { children: o, positions: l } = a._tree, h = e > 0 ? o.length : -1; t != h; t += e) {
        let u = o[t], p = l[t] + a.from;
        if (q5(s, i, p, p + u.length)) {
          if (u instanceof Hf) {
            if (r & Yt.ExcludeBuffers)
              continue;
            let y = u.findChild(0, u.buffer.length, e, i - p, s);
            if (y > -1)
              return new gw(new _V(a, u, t, p), null, y);
          } else if (r & Yt.IncludeAnonymous || !u.type.isAnonymous || vb(u)) {
            let y;
            if (!(r & Yt.IgnoreMounts) && (y = ww.get(u)) && !y.overlay)
              return new _s(y.tree, p, t, a);
            let m = new _s(u, p, t, a);
            return r & Yt.IncludeAnonymous || !m.type.isAnonymous ? m : m.nextChild(e < 0 ? u.children.length - 1 : 0, e, i, s);
          }
        }
      }
      if (r & Yt.IncludeAnonymous || !a.type.isAnonymous || (a.index >= 0 ? t = a.index + e : t = e < 0 ? -1 : a._parent._tree.children.length, a = a._parent, !a))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.nextChild(
      0,
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  enter(t, e, i = 0) {
    let s;
    if (!(i & Yt.IgnoreOverlays) && (s = ww.get(this._tree)) && s.overlay) {
      let r = t - this.from;
      for (let { from: a, to: o } of s.overlay)
        if ((e > 0 ? a <= r : a < r) && (e < 0 ? o >= r : o > r))
          return new _s(s.tree, s.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, t, e, i);
  }
  nextSignificantParent() {
    let t = this;
    for (; t.type.isAnonymous && t._parent; )
      t = t._parent;
    return t;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}, c(_s, "wi"), _s);
f(m6, "TreeNode");
let sn = m6;
function fx(n, t, e, i) {
  let s = n.cursor(), r = [];
  if (!s.firstChild())
    return r;
  if (e != null) {
    for (let a = !1; !a; )
      if (a = s.type.is(e), !s.nextSibling())
        return r;
  }
  for (; ; ) {
    if (i != null && s.type.is(i))
      return r;
    if (s.type.is(t) && r.push(s.node), !s.nextSibling())
      return i == null ? r : [];
  }
}
c(fx, "Qu$1");
f(fx, "getChildren");
function cv(n, t, e = t.length - 1) {
  for (let i = n; e >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (t[e] && t[e] != i.name)
        return !1;
      e--;
    }
  }
  return !0;
}
c(cv, "ea$1");
f(cv, "matchNodeContext");
var Uh;
const w6 = (Uh = class {
  constructor(t, e, i, s) {
    this.parent = t, this.buffer = e, this.index = i, this.start = s;
  }
}, c(Uh, "Zf"), Uh);
f(w6, "BufferContext");
let _V = w6;
var Hn;
const g6 = (Hn = class extends y6 {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(t, e, i) {
    super(), this.context = t, this._parent = e, this.index = i, this.type = t.buffer.set.types[t.buffer.buffer[i]];
  }
  child(t, e, i) {
    let { buffer: s } = this.context, r = s.findChild(this.index + 4, s.buffer[this.index + 3], t, e - this.context.start, i);
    return r < 0 ? null : new Hn(this.context, this, r);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.child(
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.child(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  enter(t, e, i = 0) {
    if (i & Yt.ExcludeBuffers)
      return null;
    let { buffer: s } = this.context, r = s.findChild(this.index + 4, s.buffer[this.index + 3], e > 0 ? 1 : -1, t - this.context.start, e);
    return r < 0 ? null : new Hn(this.context, this, r);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(t) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + t,
      t,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: t } = this.context, e = t.buffer[this.index + 3];
    return e < (this._parent ? t.buffer[this._parent.index + 3] : t.buffer.length) ? new Hn(this.context, this._parent, e) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: t } = this.context, e = this._parent ? this._parent.index + 4 : 0;
    return this.index == e ? this.externalSibling(-1) : new Hn(this.context, this._parent, t.findChild(
      e,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let t = [], e = [], { buffer: i } = this.context, s = this.index + 4, r = i.buffer[this.index + 3];
    if (r > s) {
      let a = i.buffer[this.index + 1];
      t.push(i.slice(s, r, a)), e.push(0);
    }
    return new Lt(this.type, t, e, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}, c(Hn, "Bt"), Hn);
f(g6, "BufferNode");
let gw = g6;
function j5(n) {
  if (!n.length)
    return null;
  let t = 0, e = n[0];
  for (let r = 1; r < n.length; r++) {
    let a = n[r];
    (a.from > e.from || a.to < e.to) && (e = a, t = r);
  }
  let i = e instanceof sn && e.index < 0 ? null : e.parent, s = n.slice();
  return i ? s[t] = i : s.splice(t, 1), new zV(s, e);
}
c(j5, "KO");
f(j5, "iterStack");
var Bh;
const v6 = (Bh = class {
  constructor(t, e) {
    this.heads = t, this.node = e;
  }
  get next() {
    return j5(this.heads);
  }
}, c(Bh, "Lf"), Bh);
f(v6, "StackIterator");
let zV = v6;
function b6(n, t, e) {
  let i = n.resolveInner(t, e), s = null;
  for (let r = i instanceof sn ? i : i.context.parent; r; r = r.parent)
    if (r.index < 0) {
      let a = r.parent;
      (s || (s = [i])).push(a.resolve(t, e)), r = a;
    } else {
      let a = ww.get(r.tree);
      if (a && a.overlay && a.overlay[0].from <= t && a.overlay[a.overlay.length - 1].to >= t) {
        let o = new sn(a.tree, a.overlay[0].from + r.from, -1, r);
        (s || (s = [i])).push(Yf(o, t, e, !1));
      }
    }
  return s ? j5(s) : i;
}
c(b6, "wy$1");
f(b6, "stackIterator");
var Xh;
const O6 = (Xh = class {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(t, e = 0) {
    if (this.mode = e, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, t instanceof sn)
      this.yieldNode(t);
    else {
      this._tree = t.context.parent, this.buffer = t.context;
      for (let i = t._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = t, this.yieldBuf(t.index);
    }
  }
  yieldNode(t) {
    return t ? (this._tree = t, this.type = t.type, this.from = t.from, this.to = t.to, !0) : !1;
  }
  yieldBuf(t, e) {
    this.index = t;
    let { start: i, buffer: s } = this.buffer;
    return this.type = e || s.set.types[s.buffer[t]], this.from = i + s.buffer[t + 1], this.to = i + s.buffer[t + 2], !0;
  }
  /**
  @internal
  */
  yield(t) {
    return t ? t instanceof sn ? (this.buffer = null, this.yieldNode(t)) : (this.buffer = t.context, this.yieldBuf(t.index, t.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(t, e, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(t < 0 ? this._tree._tree.children.length - 1 : 0, t, e, i, this.mode));
    let { buffer: s } = this.buffer, r = s.findChild(this.index + 4, s.buffer[this.index + 3], t, e - this.buffer.start, i);
    return r < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(r));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(t) {
    return this.enterChild(
      1,
      t,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(t) {
    return this.enterChild(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(t, e, i = this.mode) {
    return this.buffer ? i & Yt.ExcludeBuffers ? !1 : this.enterChild(1, t, e) : this.yield(this._tree.enter(t, e, i));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Yt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let t = this.mode & Yt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(t);
  }
  /**
  @internal
  */
  sibling(t) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + t, t, 0, 4, this.mode)) : !1;
    let { buffer: e } = this.buffer, i = this.stack.length - 1;
    if (t < 0) {
      let s = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != s)
        return this.yieldBuf(e.findChild(
          s,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let s = e.buffer[this.index + 3];
      if (s < (i < 0 ? e.buffer.length : e.buffer[this.stack[i] + 3]))
        return this.yieldBuf(s);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + t, t, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(t) {
    let e, i, { buffer: s } = this;
    if (s) {
      if (t > 0) {
        if (this.index < s.buffer.buffer.length)
          return !1;
      } else
        for (let r = 0; r < this.index; r++)
          if (s.buffer.buffer[r + 3] < this.index)
            return !1;
      ({ index: e, parent: i } = s);
    } else
      ({ index: e, _parent: i } = this._tree);
    for (; i; { index: e, _parent: i } = i)
      if (e > -1)
        for (let r = e + t, a = t < 0 ? -1 : i._tree.children.length; r != a; r += t) {
          let o = i._tree.children[r];
          if (this.mode & Yt.IncludeAnonymous || o instanceof Hf || !o.type.isAnonymous || vb(o))
            return !1;
        }
    return !0;
  }
  move(t, e) {
    if (e && this.enterChild(
      t,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(t))
        return !0;
      if (this.atLastNode(t) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(t = !0) {
    return this.move(1, t);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(t = !0) {
    return this.move(-1, t);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(t, e = 0) {
    for (; (this.from == this.to || (e < 1 ? this.from >= t : this.from > t) || (e > -1 ? this.to <= t : this.to < t)) && this.parent(); )
      ;
    for (; this.enterChild(1, t, e); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let t = this.bufferNode, e = null, i = 0;
    if (t && t.context == this.buffer)
      t: for (let s = this.index, r = this.stack.length; r >= 0; ) {
        for (let a = t; a; a = a._parent)
          if (a.index == s) {
            if (s == this.index)
              return a;
            e = a, i = r + 1;
            break t;
          }
        s = this.stack[--r];
      }
    for (let s = i; s < this.stack.length; s++)
      e = new gw(this.buffer, e, this.stack[s]);
    return this.bufferNode = new gw(this.buffer, e, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(t, e) {
    for (let i = 0; ; ) {
      let s = !1;
      if (this.type.isAnonymous || t(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (s = !0);
      }
      for (; ; ) {
        if (s && e && e(this), s = this.type.isAnonymous, !i)
          return;
        if (this.nextSibling())
          break;
        this.parent(), i--, s = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(t) {
    if (!this.buffer)
      return cv(this.node.parent, t);
    let { buffer: e } = this.buffer, { types: i } = e.set;
    for (let s = t.length - 1, r = this.stack.length - 1; s >= 0; r--) {
      if (r < 0)
        return cv(this._tree, t, s);
      let a = i[e.buffer[this.stack[r]]];
      if (!a.isAnonymous) {
        if (t[s] && t[s] != a.name)
          return !1;
        s--;
      }
    }
    return !0;
  }
}, c(Xh, "Mf"), Xh);
f(O6, "TreeCursor");
let hv = O6;
function vb(n) {
  return n.children.some((t) => t instanceof Hf || !t.type.isAnonymous || vb(t));
}
c(vb, "fh");
f(vb, "hasChild");
function $6(n) {
  var t;
  let { buffer: e, nodeSet: i, maxBufferLength: s = r6, reused: r = [], minRepeatType: a = i.types.length } = n, o = Array.isArray(e) ? new EV(e, e.length) : e, l = i.types, h = 0, u = 0;
  function p(A, I, Z, j, N, ut) {
    let { id: ct, start: K, end: wt, size: it } = o, At = u, kt = h;
    for (; it < 0; )
      if (o.next(), it == -1) {
        let _e = r[ct];
        Z.push(_e), j.push(K - A);
        return;
      } else if (it == -3) {
        h = ct;
        return;
      } else if (it == -4) {
        u = ct;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${it}`);
    let Zt = l[ct], Dt, Wt, Oi = K - A;
    if (wt - K <= s && (Wt = $(o.pos - I, N))) {
      let _e = new Uint16Array(Wt.size - Wt.skip), pe = o.pos - Wt.size, se = _e.length;
      for (; o.pos > pe; )
        se = x(Wt.start, _e, se);
      Dt = new Hf(_e, wt - Wt.start, i), Oi = Wt.start - A;
    } else {
      let _e = o.pos - it;
      o.next();
      let pe = [], se = [], ge = ct >= a ? ct : -1, $i = 0, zi = wt;
      for (; o.pos > _e; )
        ge >= 0 && o.id == ge && o.size >= 0 ? (o.end <= zi - s && (w(pe, se, K, $i, o.end, zi, ge, At, kt), $i = pe.length, zi = o.end), o.next()) : ut > 2500 ? y(K, _e, pe, se) : p(K, _e, pe, se, ge, ut + 1);
      if (ge >= 0 && $i > 0 && $i < pe.length && w(pe, se, K, $i, K, zi, ge, At, kt), pe.reverse(), se.reverse(), ge > -1 && $i > 0) {
        let Ni = m(Zt, kt);
        Dt = bb(Zt, pe, se, 0, pe.length, 0, wt - K, Ni, Ni);
      } else
        Dt = b(Zt, pe, se, wt - K, At - wt, kt);
    }
    Z.push(Dt), j.push(Oi);
  }
  c(p, "u"), f(p, "takeNode");
  function y(A, I, Z, j) {
    let N = [], ut = 0, ct = -1;
    for (; o.pos > I; ) {
      let { id: K, start: wt, end: it, size: At } = o;
      if (At > 4)
        o.next();
      else {
        if (ct > -1 && wt < ct)
          break;
        ct < 0 && (ct = it - s), N.push(K, wt, it), ut++, o.next();
      }
    }
    if (ut) {
      let K = new Uint16Array(ut * 4), wt = N[N.length - 2];
      for (let it = N.length - 3, At = 0; it >= 0; it -= 3)
        K[At++] = N[it], K[At++] = N[it + 1] - wt, K[At++] = N[it + 2] - wt, K[At++] = At;
      Z.push(new Hf(K, N[2] - wt, i)), j.push(wt - A);
    }
  }
  c(y, "d"), f(y, "takeFlatNode");
  function m(A, I) {
    return (Z, j, N) => {
      let ut = 0, ct = Z.length - 1, K, wt;
      if (ct >= 0 && (K = Z[ct]) instanceof Lt) {
        if (!ct && K.type == A && K.length == N)
          return K;
        (wt = K.prop(xt.lookAhead)) && (ut = j[ct] + K.length + wt);
      }
      return b(A, Z, j, N, ut, I);
    };
  }
  c(m, "O"), f(m, "makeBalanced");
  function w(A, I, Z, j, N, ut, ct, K, wt) {
    let it = [], At = [];
    for (; A.length > j; )
      it.push(A.pop()), At.push(I.pop() + Z - N);
    A.push(b(i.types[ct], it, At, ut - N, K - ut, wt)), I.push(N - Z);
  }
  c(w, "p"), f(w, "makeRepeatLeaf");
  function b(A, I, Z, j, N, ut, ct) {
    if (ut) {
      let K = [xt.contextHash, ut];
      ct = ct ? [K].concat(ct) : [K];
    }
    if (N > 25) {
      let K = [xt.lookAhead, N];
      ct = ct ? [K].concat(ct) : [K];
    }
    return new Lt(A, I, Z, j, ct);
  }
  c(b, "m"), f(b, "makeTree");
  function $(A, I) {
    let Z = o.fork(), j = 0, N = 0, ut = 0, ct = Z.end - s, K = { size: 0, start: 0, skip: 0 };
    t: for (let wt = Z.pos - A; Z.pos > wt; ) {
      let it = Z.size;
      if (Z.id == I && it >= 0) {
        K.size = j, K.start = N, K.skip = ut, ut += 4, j += 4, Z.next();
        continue;
      }
      let At = Z.pos - it;
      if (it < 0 || At < wt || Z.start < ct)
        break;
      let kt = Z.id >= a ? 4 : 0, Zt = Z.start;
      for (Z.next(); Z.pos > At; ) {
        if (Z.size < 0)
          if (Z.size == -3)
            kt += 4;
          else
            break t;
        else Z.id >= a && (kt += 4);
        Z.next();
      }
      N = Zt, j += it, ut += kt;
    }
    return (I < 0 || j == A) && (K.size = j, K.start = N, K.skip = ut), K.size > 4 ? K : void 0;
  }
  c($, "y"), f($, "findBufferSize");
  function x(A, I, Z) {
    let { id: j, start: N, end: ut, size: ct } = o;
    if (o.next(), ct >= 0 && j < a) {
      let K = Z;
      if (ct > 4) {
        let wt = o.pos - (ct - 4);
        for (; o.pos > wt; )
          Z = x(A, I, Z);
      }
      I[--Z] = K, I[--Z] = ut - A, I[--Z] = N - A, I[--Z] = j;
    } else ct == -3 ? h = j : ct == -4 && (u = j);
    return Z;
  }
  c(x, "b"), f(x, "copyToBuffer");
  let C = [], R = [];
  for (; o.pos > 0; )
    p(n.start || 0, n.bufferStart || 0, C, R, -1, 0);
  let E = (t = n.length) !== null && t !== void 0 ? t : C.length ? R[0] + C[0].length : 0;
  return new Lt(l[n.topID], C.reverse(), R.reverse(), E);
}
c($6, "xy$1");
f($6, "buildTree");
const O4 = /* @__PURE__ */ new WeakMap();
function nw(n, t) {
  if (!n.isAnonymous || t instanceof Hf || t.type != n)
    return 1;
  let e = O4.get(t);
  if (e == null) {
    e = 1;
    for (let i of t.children) {
      if (i.type != n || !(i instanceof Lt)) {
        e = 1;
        break;
      }
      e += nw(n, i);
    }
    O4.set(t, e);
  }
  return e;
}
c(nw, "Hn$1");
f(nw, "nodeSize");
function bb(n, t, e, i, s, r, a, o, l) {
  let h = 0;
  for (let w = i; w < s; w++)
    h += nw(n, t[w]);
  let u = Math.ceil(
    h * 1.5 / 8
    /* Balance.BranchFactor */
  ), p = [], y = [];
  function m(w, b, $, x, C) {
    for (let R = $; R < x; ) {
      let E = R, A = b[R], I = nw(n, w[R]);
      for (R++; R < x; R++) {
        let Z = nw(n, w[R]);
        if (I + Z >= u)
          break;
        I += Z;
      }
      if (R == E + 1) {
        if (I > u) {
          let Z = w[E];
          m(Z.children, Z.positions, 0, Z.children.length, b[E] + C);
          continue;
        }
        p.push(w[E]);
      } else {
        let Z = b[R - 1] + w[R - 1].length - A;
        p.push(bb(n, w, b, E, R, A, Z, null, l));
      }
      y.push(A + C - r);
    }
  }
  return c(m, "O"), f(m, "divide"), m(t, e, i, s, 0), (o || l)(p, y, a);
}
c(bb, "ch");
f(bb, "balanceRange");
var Nh;
const x6 = (Nh = class {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(t, e, i) {
    let s = this.map.get(t);
    s || this.map.set(t, s = /* @__PURE__ */ new Map()), s.set(e, i);
  }
  getBuffer(t, e) {
    let i = this.map.get(t);
    return i && i.get(e);
  }
  /**
  Set the value for this syntax node.
  */
  set(t, e) {
    t instanceof gw ? this.setBuffer(t.context.buffer, t.index, e) : t instanceof sn && this.map.set(t.tree, e);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(t) {
    return t instanceof gw ? this.getBuffer(t.context.buffer, t.index) : t instanceof sn ? this.map.get(t.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(t, e) {
    t.buffer ? this.setBuffer(t.buffer.buffer, t.index, e) : this.map.set(t.tree, e);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(t) {
    return t.buffer ? this.getBuffer(t.buffer.buffer, t.index) : this.map.get(t.tree);
  }
}, c(Nh, "_f"), Nh);
f(x6, "NodeWeakMap");
let k6 = x6;
var Zr;
const S6 = (Zr = class {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(t, e, i, s, r = !1, a = !1) {
    this.from = t, this.to = e, this.tree = i, this.offset = s, this.open = (r ? 1 : 0) | (a ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(t, e = [], i = !1) {
    let s = [new Zr(0, t.length, t, 0, !1, i)];
    for (let r of e)
      r.to > t.length && s.push(r);
    return s;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(t, e, i = 128) {
    if (!e.length)
      return t;
    let s = [], r = 1, a = t.length ? t[0] : null;
    for (let o = 0, l = 0, h = 0; ; o++) {
      let u = o < e.length ? e[o] : null, p = u ? u.fromA : 1e9;
      if (p - l >= i)
        for (; a && a.from < p; ) {
          let y = a;
          if (l >= y.from || p <= y.to || h) {
            let m = Math.max(y.from, l) - h, w = Math.min(y.to, p) - h;
            y = m >= w ? null : new Zr(m, w, y.tree, y.offset + h, o > 0, !!u);
          }
          if (y && s.push(y), a.to > p)
            break;
          a = r < t.length ? t[r++] : null;
        }
      if (!u)
        break;
      l = u.toA, h = u.toA - u.toB;
    }
    return s;
  }
}, c(Zr, "Ur"), Zr);
f(S6, "TreeFragment");
let Dc = S6;
var Hh;
const P6 = (Hh = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(t, e, i) {
    return typeof t == "string" && (t = new LV(t)), i = i ? i.length ? i.map((s) => new Ki(s.from, s.to)) : [new Ki(0, 0)] : [new Ki(0, t.length)], this.createParse(t, e || [], i);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(t, e, i) {
    let s = this.startParse(t, e, i);
    for (; ; ) {
      let r = s.advance();
      if (r)
        return r;
    }
  }
}, c(Hh, "Cf"), Hh);
f(P6, "Parser");
let Ob = P6;
var Yh;
const C6 = (Yh = class {
  constructor(t) {
    this.string = t;
  }
  get length() {
    return this.string.length;
  }
  chunk(t) {
    return this.string.slice(t);
  }
  get lineChunks() {
    return !1;
  }
  read(t, e) {
    return this.string.slice(t, e);
  }
}, c(Yh, "Ef"), Yh);
f(C6, "StringInput");
let LV = C6;
function F5(n) {
  return (t, e, i, s) => new ZV(t, n, e, i, s);
}
c(F5, "JO");
f(F5, "parseMixed");
var Gh;
const Q6 = (Gh = class {
  constructor(t, e, i, s, r) {
    this.parser = t, this.parse = e, this.overlay = i, this.target = s, this.from = r;
  }
}, c(Gh, "Vf"), Gh);
f(Q6, "InnerParse");
let $4 = Q6;
function yx(n) {
  if (!n.length || n.some((t) => t.from >= t.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(n));
}
c(yx, "xu$1");
f(yx, "checkRanges");
var Kh;
const M6 = (Kh = class {
  constructor(t, e, i, s, r, a, o) {
    this.parser = t, this.predicate = e, this.mounts = i, this.index = s, this.start = r, this.target = a, this.prev = o, this.depth = 0, this.ranges = [];
  }
}, c(Kh, "Uf"), Kh);
f(M6, "ActiveOverlay");
let IV = M6;
const mx = new xt({ perNode: !0 });
var Jh;
const T6 = (Jh = class {
  constructor(t, e, i, s, r) {
    this.nest = e, this.input = i, this.fragments = s, this.ranges = r, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = t;
  }
  advance() {
    if (this.baseParse) {
      let i = this.baseParse.advance();
      if (!i)
        return null;
      if (this.baseParse = null, this.baseTree = i, this.startInner(), this.stoppedAt != null)
        for (let s of this.inner)
          s.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let i = this.baseTree;
      return this.stoppedAt != null && (i = new Lt(i.type, i.children, i.positions, i.length, i.propValues.concat([[mx, this.stoppedAt]]))), i;
    }
    let t = this.inner[this.innerDone], e = t.parse.advance();
    if (e) {
      this.innerDone++;
      let i = Object.assign(/* @__PURE__ */ Object.create(null), t.target.props);
      i[xt.mounted.id] = new ww(e, t.overlay, t.parser), t.target.props = i;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let t = this.input.length;
    for (let e = this.innerDone; e < this.inner.length; e++)
      this.inner[e].from < t && (t = Math.min(t, this.inner[e].parse.parsedPos));
    return t;
  }
  stopAt(t) {
    if (this.stoppedAt = t, this.baseParse)
      this.baseParse.stopAt(t);
    else
      for (let e = this.innerDone; e < this.inner.length; e++)
        this.inner[e].parse.stopAt(t);
  }
  startInner() {
    let t = new VV(this.fragments), e = null, i = null, s = new hv(new sn(this.baseTree, this.ranges[0].from, 0, null), Yt.IncludeAnonymous | Yt.IgnoreMounts);
    t: for (let r, a; ; ) {
      let o = !0, l;
      if (this.stoppedAt != null && s.from >= this.stoppedAt)
        o = !1;
      else if (t.hasNode(s)) {
        if (e) {
          let h = e.mounts.find((u) => u.frag.from <= s.from && u.frag.to >= s.to && u.mount.overlay);
          if (h)
            for (let u of h.mount.overlay) {
              let p = u.from + h.pos, y = u.to + h.pos;
              p >= s.from && y <= s.to && !e.ranges.some((m) => m.from < y && m.to > p) && e.ranges.push({ from: p, to: y });
            }
        }
        o = !1;
      } else if (i && (a = A6(i.ranges, s.from, s.to)))
        o = a != 2;
      else if (!s.type.isAnonymous && (r = this.nest(s, this.input)) && (s.from < s.to || !r.overlay)) {
        s.tree || R6(s);
        let h = t.findMounts(s.from, r.parser);
        if (typeof r.overlay == "function")
          e = new IV(r.parser, r.overlay, h, this.inner.length, s.from, s.tree, e);
        else {
          let u = gx(this.ranges, r.overlay || (s.from < s.to ? [new Ki(s.from, s.to)] : []));
          u.length && yx(u), (u.length || !r.overlay) && this.inner.push(new $4(r.parser, u.length ? r.parser.startParse(this.input, vx(h, u), u) : r.parser.startParse(""), r.overlay ? r.overlay.map((p) => new Ki(p.from - s.from, p.to - s.from)) : null, s.tree, u.length ? u[0].from : s.from)), r.overlay ? u.length && (i = { ranges: u, depth: 0, prev: i }) : o = !1;
        }
      } else if (e && (l = e.predicate(s)) && (l === !0 && (l = new Ki(s.from, s.to)), l.from < l.to)) {
        let h = e.ranges.length - 1;
        h >= 0 && e.ranges[h].to == l.from ? e.ranges[h] = { from: e.ranges[h].from, to: l.to } : e.ranges.push(l);
      }
      if (o && s.firstChild())
        e && e.depth++, i && i.depth++;
      else
        for (; !s.nextSibling(); ) {
          if (!s.parent())
            break t;
          if (e && !--e.depth) {
            let h = gx(this.ranges, e.ranges);
            h.length && (yx(h), this.inner.splice(e.index, 0, new $4(e.parser, e.parser.startParse(this.input, vx(e.mounts, h), h), e.ranges.map((u) => new Ki(u.from - e.start, u.to - e.start)), e.target, h[0].from))), e = e.prev;
          }
          i && !--i.depth && (i = i.prev);
        }
    }
  }
}, c(Jh, "Wf"), Jh);
f(T6, "MixedParse");
let ZV = T6;
function A6(n, t, e) {
  for (let i of n) {
    if (i.from >= e)
      break;
    if (i.to > t)
      return i.from <= t && i.to >= e ? 2 : 1;
  }
  return 0;
}
c(A6, "ky$1");
f(A6, "checkCover");
function wx(n, t, e, i, s, r) {
  if (t < e) {
    let a = n.buffer[t + 1];
    i.push(n.slice(t, e, a)), s.push(a - r);
  }
}
c(wx, "ku$1");
f(wx, "sliceBuf");
function R6(n) {
  let { node: t } = n, e = [], i = t.context.buffer;
  do
    e.push(n.index), n.parent();
  while (!n.tree);
  let s = n.tree, r = s.children.indexOf(i), a = s.children[r], o = a.buffer, l = [r];
  function h(u, p, y, m, w, b) {
    let $ = e[b], x = [], C = [];
    wx(a, u, $, x, C, m);
    let R = o[$ + 1], E = o[$ + 2];
    l.push(x.length);
    let A = b ? h($ + 4, o[$ + 3], a.set.types[o[$]], R, E - R, b - 1) : t.toTree();
    return x.push(A), C.push(R - m), wx(a, o[$ + 3], p, x, C, m), new Lt(y, x, C, w);
  }
  c(h, "h"), f(h, "split"), s.children[r] = h(0, o.length, Ue.none, 0, a.length, e.length - 1);
  for (let u of l) {
    let p = n.tree.children[u], y = n.tree.positions[u];
    n.yield(new sn(p, y + n.from, u, n._tree));
  }
}
c(R6, "Py$1");
f(R6, "materialize");
var td;
const E6 = (td = class {
  constructor(t, e) {
    this.offset = e, this.done = !1, this.cursor = t.cursor(Yt.IncludeAnonymous | Yt.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(t) {
    let { cursor: e } = this, i = t - this.offset;
    for (; !this.done && e.from < i; )
      e.to >= t && e.enter(i, 1, Yt.IgnoreOverlays | Yt.ExcludeBuffers) || e.next(!1) || (this.done = !0);
  }
  hasNode(t) {
    if (this.moveTo(t.from), !this.done && this.cursor.from + this.offset == t.from && this.cursor.tree)
      for (let e = this.cursor.tree; ; ) {
        if (e == t.tree)
          return !0;
        if (e.children.length && e.positions[0] == 0 && e.children[0] instanceof Lt)
          e = e.children[0];
        else
          break;
      }
    return !1;
  }
}, c(td, "Xf"), td);
f(E6, "StructureCursor");
let x4 = E6;
var SO, ed;
let VV = (SO = (ed = class {
  constructor(t) {
    var e;
    if (this.fragments = t, this.curTo = 0, this.fragI = 0, t.length) {
      let i = this.curFrag = t[0];
      this.curTo = (e = i.tree.prop(mx)) !== null && e !== void 0 ? e : i.to, this.inner = new x4(i.tree, -i.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(t) {
    for (; this.curFrag && t.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= t.from && this.curTo >= t.to && this.inner.hasNode(t);
  }
  nextFrag() {
    var t;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let e = this.curFrag = this.fragments[this.fragI];
      this.curTo = (t = e.tree.prop(mx)) !== null && t !== void 0 ? t : e.to, this.inner = new x4(e.tree, -e.offset);
    }
  }
  findMounts(t, e) {
    var i;
    let s = [];
    if (this.inner) {
      this.inner.cursor.moveTo(t, 1);
      for (let r = this.inner.cursor.node; r; r = r.parent) {
        let a = (i = r.tree) === null || i === void 0 ? void 0 : i.prop(xt.mounted);
        if (a && a.parser == e)
          for (let o = this.fragI; o < this.fragments.length; o++) {
            let l = this.fragments[o];
            if (l.from >= r.to)
              break;
            l.tree == this.curFrag.tree && s.push({
              frag: l,
              pos: r.from - l.offset,
              mount: a
            });
          }
      }
    }
    return s;
  }
}, c(ed, "Zi$1"), ed), f(SO, "FragmentCursor"), SO);
function gx(n, t) {
  let e = null, i = t;
  for (let s = 1, r = 0; s < n.length; s++) {
    let a = n[s - 1].to, o = n[s].from;
    for (; r < i.length; r++) {
      let l = i[r];
      if (l.from >= o)
        break;
      l.to <= a || (e || (i = e = t.slice()), l.from < a ? (e[r] = new Ki(l.from, a), l.to > o && e.splice(r + 1, 0, new Ki(o, l.to))) : l.to > o ? e[r--] = new Ki(o, l.to) : e.splice(r--, 1));
    }
  }
  return i;
}
c(gx, "Pu$1");
f(gx, "punchRanges");
function _6(n, t, e, i) {
  let s = 0, r = 0, a = !1, o = !1, l = -1e9, h = [];
  for (; ; ) {
    let u = s == n.length ? 1e9 : a ? n[s].to : n[s].from, p = r == t.length ? 1e9 : o ? t[r].to : t[r].from;
    if (a != o) {
      let y = Math.max(l, e), m = Math.min(u, p, i);
      y < m && h.push(new Ki(y, m));
    }
    if (l = Math.min(u, p), l == 1e9)
      break;
    u == l && (a ? (a = !1, s++) : a = !0), p == l && (o ? (o = !1, r++) : o = !0);
  }
  return h;
}
c(_6, "$y$1");
f(_6, "findCoverChanges");
function vx(n, t) {
  let e = [];
  for (let { pos: i, mount: s, frag: r } of n) {
    let a = i + (s.overlay ? s.overlay[0].from : 0), o = a + s.tree.length, l = Math.max(r.from, a), h = Math.min(r.to, o);
    if (s.overlay) {
      let u = s.overlay.map((y) => new Ki(y.from + i, y.to + i)), p = _6(t, u, l, h);
      for (let y = 0, m = l; ; y++) {
        let w = y == p.length, b = w ? h : p[y].from;
        if (b > m && e.push(new Dc(m, b, s.tree, -a, r.from >= m || r.openStart, r.to <= b || r.openEnd)), w)
          break;
        m = p[y].to;
      }
    } else
      e.push(new Dc(l, h, s.tree, -a, r.from >= a || r.openStart, r.to <= o || r.openEnd));
  }
  return e;
}
c(vx, "Ru$1");
f(vx, "enterFragments");
let DV = 0;
var Vr;
const z6 = (Vr = class {
  /**
  @internal
  */
  constructor(t, e, i, s) {
    this.name = t, this.set = e, this.base = i, this.modified = s, this.id = DV++;
  }
  toString() {
    let { name: t } = this;
    for (let e of this.modified)
      e.name && (t = `${e.name}(${t})`);
    return t;
  }
  static define(t, e) {
    let i = typeof t == "string" ? t : "?";
    if (t instanceof Vr && (e = t), e?.base)
      throw new Error("Can not derive from a modified tag");
    let s = new Vr(i, [], null, []);
    if (s.set.push(s), e)
      for (let r of e.set)
        s.set.push(r);
    return s;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(t) {
    let e = new k4(t);
    return (i) => i.modified.indexOf(e) > -1 ? i : k4.get(i.base || i, i.modified.concat(e).sort((s, r) => s.id - r.id));
  }
}, c(Vr, "Wr"), Vr);
f(z6, "Tag");
let jn = z6, WV = 0;
var bo;
const L6 = (bo = class {
  constructor(t) {
    this.name = t, this.instances = [], this.id = WV++;
  }
  static get(t, e) {
    if (!e.length)
      return t;
    let i = e[0].instances.find((o) => o.base == t && I6(e, o.modified));
    if (i)
      return i;
    let s = [], r = new jn(t.name, s, t, e);
    for (let o of e)
      o.instances.push(r);
    let a = Z6(e);
    for (let o of t.set)
      if (!o.modified.length)
        for (let l of a)
          s.push(bo.get(o, l));
    return r;
  }
}, c(bo, "lo"), bo);
f(L6, "Modifier");
let k4 = L6;
function I6(n, t) {
  return n.length == t.length && n.every((e, i) => e == t[i]);
}
c(I6, "Ay$1");
f(I6, "sameArray");
function Z6(n) {
  let t = [[]];
  for (let e = 0; e < n.length; e++)
    for (let i = 0, s = t.length; i < s; i++)
      t.push(t[i].concat(n[e]));
  return t.sort((e, i) => i.length - e.length);
}
c(Z6, "Zy$1");
f(Z6, "powerSet");
function ol(n) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let e in n) {
    let i = n[e];
    Array.isArray(i) || (i = [i]);
    for (let s of e.split(" "))
      if (s) {
        let r = [], a = 2, o = s;
        for (let p = 0; ; ) {
          if (o == "..." && p > 0 && p + 3 == s.length) {
            a = 1;
            break;
          }
          let y = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(o);
          if (!y)
            throw new RangeError("Invalid path: " + s);
          if (r.push(y[0] == "*" ? "" : y[0][0] == '"' ? JSON.parse(y[0]) : y[0]), p += y[0].length, p == s.length)
            break;
          let m = s[p++];
          if (p == s.length && m == "!") {
            a = 0;
            break;
          }
          if (m != "/")
            throw new RangeError("Invalid path: " + s);
          o = s.slice(p);
        }
        let l = r.length - 1, h = r[l];
        if (!h)
          throw new RangeError("Invalid path: " + s);
        let u = new dv(i, a, l > 0 ? r.slice(0, l) : null);
        t[h] = u.sort(t[h]);
      }
  }
  return V6.add(t);
}
c(ol, "Ji$1");
f(ol, "styleTags");
const V6 = new xt();
var PO, id;
let dv = (PO = (id = class {
  constructor(t, e, i, s) {
    this.tags = t, this.mode = e, this.context = i, this.next = s;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(t) {
    return !t || t.depth < this.depth ? (this.next = t, this) : (t.next = this.sort(t.next), t);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}, c(id, "Li$1"), id), f(PO, "Rule"), PO);
dv.empty = new dv([], 2, null);
function U5(n, t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r of n)
    if (!Array.isArray(r.tag))
      e[r.tag.id] = r.class;
    else
      for (let a of r.tag)
        e[a.id] = r.class;
  let { scope: i, all: s = null } = t || {};
  return {
    style: /* @__PURE__ */ f((r) => {
      let a = s;
      for (let o of r)
        for (let l of o.set) {
          let h = e[l.id];
          if (h) {
            a = a ? a + " " + h : h;
            break;
          }
        }
      return a;
    }, "style"),
    scope: i
  };
}
c(U5, "tp$1");
f(U5, "tagHighlighter");
function D6(n, t) {
  let e = null;
  for (let i of n) {
    let s = i.style(t);
    s && (e = e ? e + " " + s : s);
  }
  return e;
}
c(D6, "Ly$1");
f(D6, "highlightTags");
function W6(n, t, e, i = 0, s = n.length) {
  let r = new qV(i, Array.isArray(t) ? t : [t], e);
  r.highlightRange(n.cursor(), i, s, "", r.highlighters), r.flush(s);
}
c(W6, "My$1");
f(W6, "highlightTree");
var nd;
const q6 = (nd = class {
  constructor(t, e, i) {
    this.at = t, this.highlighters = e, this.span = i, this.class = "";
  }
  startSpan(t, e) {
    e != this.class && (this.flush(t), t > this.at && (this.at = t), this.class = e);
  }
  flush(t) {
    t > this.at && this.class && this.span(this.at, t, this.class);
  }
  highlightRange(t, e, i, s, r) {
    let { type: a, from: o, to: l } = t;
    if (o >= i || l <= e)
      return;
    a.isTop && (r = this.highlighters.filter((m) => !m.scope || m.scope(a)));
    let h = s, u = j6(t) || dv.empty, p = D6(r, u.tags);
    if (p && (h && (h += " "), h += p, u.mode == 1 && (s += (s ? " " : "") + p)), this.startSpan(Math.max(e, o), h), u.opaque)
      return;
    let y = t.tree && t.tree.prop(xt.mounted);
    if (y && y.overlay) {
      let m = t.node.enter(y.overlay[0].from + o, 1), w = this.highlighters.filter(($) => !$.scope || $.scope(y.tree.type)), b = t.firstChild();
      for (let $ = 0, x = o; ; $++) {
        let C = $ < y.overlay.length ? y.overlay[$] : null, R = C ? C.from + o : l, E = Math.max(e, x), A = Math.min(i, R);
        if (E < A && b)
          for (; t.from < A && (this.highlightRange(t, E, A, s, r), this.startSpan(Math.min(A, t.to), h), !(t.to >= R || !t.nextSibling())); )
            ;
        if (!C || R > i)
          break;
        x = C.to + o, x > e && (this.highlightRange(m.cursor(), Math.max(e, C.from + o), Math.min(i, x), "", w), this.startSpan(Math.min(i, x), h));
      }
      b && t.parent();
    } else if (t.firstChild()) {
      y && (s = "");
      do
        if (!(t.to <= e)) {
          if (t.from >= i)
            break;
          this.highlightRange(t, e, i, s, r), this.startSpan(Math.min(i, t.to), h);
        }
      while (t.nextSibling());
      t.parent();
    }
  }
}, c(nd, "Yf"), nd);
f(q6, "HighlightBuilder");
let qV = q6;
function j6(n) {
  let t = n.type.prop(V6);
  for (; t && t.context && !n.matchContext(t.context); )
    t = t.next;
  return t || null;
}
c(j6, "_y$1");
f(j6, "getStyleTags");
const H = jn.define, zg = H(), fr = H(), S4 = H(fr), P4 = H(fr), yr = H(), Lg = H(yr), CO = H(yr), Vn = H(), xa = H(Vn), _n = H(), zn = H(), bx = H(), Dy = H(bx), Ig = H(), M = {
  /**
  A comment.
  */
  comment: zg,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: H(zg),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: H(zg),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: H(zg),
  /**
  Any kind of identifier.
  */
  name: fr,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: H(fr),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: S4,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: H(S4),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: P4,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: H(P4),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: H(fr),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: H(fr),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: H(fr),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: H(fr),
  /**
  A literal value.
  */
  literal: yr,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Lg,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: H(Lg),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: H(Lg),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: H(Lg),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: CO,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: H(CO),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: H(CO),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: H(yr),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: H(yr),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: H(yr),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: H(yr),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: H(yr),
  /**
  A language keyword.
  */
  keyword: _n,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: H(_n),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: H(_n),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: H(_n),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: H(_n),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: H(_n),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: H(_n),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: H(_n),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: H(_n),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: H(_n),
  /**
  An operator.
  */
  operator: zn,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: H(zn),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: H(zn),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: H(zn),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: H(zn),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: H(zn),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: H(zn),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: H(zn),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: H(zn),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: H(zn),
  /**
  Program or markup punctuation.
  */
  punctuation: bx,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: H(bx),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Dy,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: H(Dy),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: H(Dy),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: H(Dy),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: H(Dy),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Vn,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: xa,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: H(xa),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: H(xa),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: H(xa),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: H(xa),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: H(xa),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: H(xa),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: H(Vn),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: H(Vn),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: H(Vn),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: H(Vn),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: H(Vn),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: H(Vn),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: H(Vn),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: H(Vn),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: H(),
  /**
  Deleted text.
  */
  deleted: H(),
  /**
  Changed text.
  */
  changed: H(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: H(),
  /**
  Metadata or meta-instruction.
  */
  meta: Ig,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: H(Ig),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: H(Ig),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: H(Ig),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: jn.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: jn.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: jn.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: jn.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: jn.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: jn.defineModifier("special")
};
for (let n in M) {
  let t = M[n];
  t instanceof jn && (t.name = n);
}
U5([
  { tag: M.link, class: "tok-link" },
  { tag: M.heading, class: "tok-heading" },
  { tag: M.emphasis, class: "tok-emphasis" },
  { tag: M.strong, class: "tok-strong" },
  { tag: M.keyword, class: "tok-keyword" },
  { tag: M.atom, class: "tok-atom" },
  { tag: M.bool, class: "tok-bool" },
  { tag: M.url, class: "tok-url" },
  { tag: M.labelName, class: "tok-labelName" },
  { tag: M.inserted, class: "tok-inserted" },
  { tag: M.deleted, class: "tok-deleted" },
  { tag: M.literal, class: "tok-literal" },
  { tag: M.string, class: "tok-string" },
  { tag: M.number, class: "tok-number" },
  { tag: [M.regexp, M.escape, M.special(M.string)], class: "tok-string2" },
  { tag: M.variableName, class: "tok-variableName" },
  { tag: M.local(M.variableName), class: "tok-variableName tok-local" },
  { tag: M.definition(M.variableName), class: "tok-variableName tok-definition" },
  { tag: M.special(M.variableName), class: "tok-variableName2" },
  { tag: M.definition(M.propertyName), class: "tok-propertyName tok-definition" },
  { tag: M.typeName, class: "tok-typeName" },
  { tag: M.namespace, class: "tok-namespace" },
  { tag: M.className, class: "tok-className" },
  { tag: M.macroName, class: "tok-macroName" },
  { tag: M.propertyName, class: "tok-propertyName" },
  { tag: M.operator, class: "tok-operator" },
  { tag: M.comment, class: "tok-comment" },
  { tag: M.meta, class: "tok-meta" },
  { tag: M.invalid, class: "tok-invalid" },
  { tag: M.punctuation, class: "tok-punctuation" }
]);
var QO;
const Or = /* @__PURE__ */ new xt();
function tg(n) {
  return gt.define({
    combine: n ? (t) => t.concat(n) : void 0
  });
}
c(tg, "So$1");
f(tg, "defineLanguageFacet");
const B5 = /* @__PURE__ */ new xt();
var sd;
const F6 = (sd = class {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(t, e, i = [], s = "") {
    this.data = t, this.name = s, ze.prototype.hasOwnProperty("tree") || Object.defineProperty(ze.prototype, "tree", { get() {
      return he(this);
    } }), this.parser = e, this.extension = [
      Gf.of(this),
      ze.languageData.of((r, a, o) => {
        let l = Ox(r, a, o), h = l.type.prop(Or);
        if (!h)
          return [];
        let u = r.facet(h), p = l.type.prop(B5);
        if (p) {
          let y = l.resolve(a - l.from, o);
          for (let m of p)
            if (m.test(y, r)) {
              let w = r.facet(m.facet);
              return m.type == "replace" ? w : w.concat(u);
            }
        }
        return u;
      })
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(t, e, i = -1) {
    return Ox(t, e, i).type.prop(Or) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(t) {
    let e = t.facet(Gf);
    if (e?.data == this.data)
      return [{ from: 0, to: t.doc.length }];
    if (!e || !e.allowsNesting)
      return [];
    let i = [], s = /* @__PURE__ */ f((r, a) => {
      if (r.prop(Or) == this.data) {
        i.push({ from: a, to: a + r.length });
        return;
      }
      let o = r.prop(xt.mounted);
      if (o) {
        if (o.tree.prop(Or) == this.data) {
          if (o.overlay)
            for (let l of o.overlay)
              i.push({ from: l.from + a, to: l.to + a });
          else
            i.push({ from: a, to: a + r.length });
          return;
        } else if (o.overlay) {
          let l = i.length;
          if (s(o.tree, o.overlay[0].from + a), i.length > l)
            return;
        }
      }
      for (let l = 0; l < r.children.length; l++) {
        let h = r.children[l];
        h instanceof Lt && s(h, r.positions[l] + a);
      }
    }, "explore");
    return s(he(t), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}, c(sd, "If"), sd);
f(F6, "Language");
let Fi = F6;
Fi.setState = /* @__PURE__ */ Bt.define();
function Ox(n, t, e) {
  let i = n.facet(Gf), s = he(n).topNode;
  if (!i || i.allowsNesting)
    for (let r = s; r; r = r.enter(t, e, Yt.ExcludeBuffers))
      r.type.isTop && (s = r);
  return s;
}
c(Ox, "Tu$1");
f(Ox, "topNodeAt");
var Dr;
const U6 = (Dr = class extends Fi {
  constructor(t, e, i) {
    super(t, e, [], i), this.parser = e;
  }
  /**
  Define a language from a parser.
  */
  static define(t) {
    let e = tg(t.languageData);
    return new Dr(e, t.parser.configure({
      props: [Or.add((i) => i.isTop ? e : void 0)]
    }), t.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(t, e) {
    return new Dr(this.data, this.parser.configure(t), e || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}, c(Dr, "Xr"), Dr);
f(U6, "LRLanguage");
let X5 = U6;
function he(n) {
  let t = n.field(Fi.state, !1);
  return t ? t.tree : Lt.empty;
}
c(he, "F$2");
f(he, "syntaxTree");
var rd;
const B6 = (rd = class {
  /**
  Create an input object for the given document.
  */
  constructor(t) {
    this.doc = t, this.cursorPos = 0, this.string = "", this.cursor = t.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(t) {
    return this.string = this.cursor.next(t - this.cursorPos).value, this.cursorPos = t + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(t) {
    return this.syncTo(t), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(t, e) {
    let i = this.cursorPos - this.string.length;
    return t < i || e >= this.cursorPos ? this.doc.sliceString(t, e) : this.string.slice(t - i, e - i);
  }
}, c(rd, "jf"), rd);
f(B6, "DocInput");
let jV = B6, Wy = null;
var Wr;
const X6 = (Wr = class {
  constructor(t, e, i = [], s, r, a, o, l) {
    this.parser = t, this.state = e, this.fragments = i, this.tree = s, this.treeLen = r, this.viewport = a, this.skipped = o, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new Wr(t, e, [], Lt.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new jV(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(t, e) {
    return e != null && e >= this.state.doc.length && (e = void 0), this.tree != Lt.empty && this.isDone(e ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof t == "number") {
        let s = Date.now() + t;
        t = /* @__PURE__ */ f(() => Date.now() > s, "until");
      }
      for (this.parse || (this.parse = this.startParse()), e != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > e) && e < this.state.doc.length && this.parse.stopAt(e); ; ) {
        let s = this.parse.advance();
        if (s)
          if (this.fragments = this.withoutTempSkipped(Dc.addTree(s, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = s, this.parse = null, this.treeLen < (e ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (t())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let t, e;
    this.parse && (t = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > t) && this.parse.stopAt(t), this.withContext(() => {
      for (; !(e = this.parse.advance()); )
        ;
    }), this.treeLen = t, this.tree = e, this.fragments = this.withoutTempSkipped(Dc.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(t) {
    let e = Wy;
    Wy = this;
    try {
      return t();
    } finally {
      Wy = e;
    }
  }
  withoutTempSkipped(t) {
    for (let e; e = this.tempSkipped.pop(); )
      t = $x(t, e.from, e.to);
    return t;
  }
  /**
  @internal
  */
  changes(t, e) {
    let { fragments: i, tree: s, treeLen: r, viewport: a, skipped: o } = this;
    if (this.takeTree(), !t.empty) {
      let l = [];
      if (t.iterChangedRanges((h, u, p, y) => l.push({ fromA: h, toA: u, fromB: p, toB: y })), i = Dc.applyChanges(i, l), s = Lt.empty, r = 0, a = { from: t.mapPos(a.from, -1), to: t.mapPos(a.to, 1) }, this.skipped.length) {
        o = [];
        for (let h of this.skipped) {
          let u = t.mapPos(h.from, 1), p = t.mapPos(h.to, -1);
          u < p && o.push({ from: u, to: p });
        }
      }
    }
    return new Wr(this.parser, e, i, s, r, a, o, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(t) {
    if (this.viewport.from == t.from && this.viewport.to == t.to)
      return !1;
    this.viewport = t;
    let e = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: s, to: r } = this.skipped[i];
      s < t.to && r > t.from && (this.fragments = $x(this.fragments, s, r), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= e ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(t, e) {
    this.skipped.push({ from: t, to: e });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(t) {
    return new class extends Ob {
      createParse(e, i, s) {
        let r = s[0].from, a = s[s.length - 1].to;
        return {
          parsedPos: r,
          advance() {
            let o = Wy;
            if (o) {
              for (let l of s)
                o.tempSkipped.push(l);
              t && (o.scheduleOn = o.scheduleOn ? Promise.all([o.scheduleOn, t]) : t);
            }
            return this.parsedPos = a, new Lt(Ue.none, [], [], a - r);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(t) {
    t = Math.min(t, this.state.doc.length);
    let e = this.fragments;
    return this.treeLen >= t && e.length && e[0].from == 0 && e[0].to >= t;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Wy;
  }
}, c(Wr, "Yr"), Wr);
f(X6, "ParseContext");
let uv = X6;
function $x(n, t, e) {
  return Dc.applyChanges(n, [{ fromA: t, toA: e, fromB: t, toB: e }]);
}
c($x, "Au$1");
f($x, "cutFragments");
var qr;
const N6 = (qr = class {
  constructor(t) {
    this.context = t, this.tree = t.tree;
  }
  apply(t) {
    if (!t.docChanged && this.tree == this.context.tree)
      return this;
    let e = this.context.changes(t.changes, t.state), i = this.context.treeLen == t.startState.doc.length ? void 0 : Math.max(t.changes.mapPos(this.context.treeLen), e.viewport.to);
    return e.work(20, i) || e.takeTree(), new qr(e);
  }
  static init(t) {
    let e = Math.min(3e3, t.doc.length), i = uv.create(t.facet(Gf).parser, t, { from: 0, to: e });
    return i.work(20, e) || i.takeTree(), new qr(i);
  }
}, c(qr, "Ir"), qr);
f(N6, "LanguageState");
let xx = N6;
Fi.state = /* @__PURE__ */ Xs.define({
  create: xx.init,
  update(n, t) {
    for (let e of t.effects)
      if (e.is(Fi.setState))
        return e.value;
    return t.startState.facet(Gf) != t.state.facet(Gf) ? xx.init(t.state) : n.apply(t);
  }
});
let H6 = /* @__PURE__ */ f((n) => {
  let t = setTimeout(
    () => n(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(t);
}, "requestIdle");
typeof requestIdleCallback < "u" && (H6 = /* @__PURE__ */ f((n) => {
  let t = -1, e = setTimeout(
    () => {
      t = requestIdleCallback(n, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => t < 0 ? clearTimeout(e) : cancelIdleCallback(t);
}, "requestIdle"));
const MO = typeof navigator < "u" && !((QO = navigator.scheduling) === null || QO === void 0) && QO.isInputPending ? () => navigator.scheduling.isInputPending() : null;
var TO, ad;
const FV = /* @__PURE__ */ Zs.fromClass((TO = (ad = class {
  constructor(t) {
    this.view = t, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(t) {
    let e = this.view.state.field(Fi.state).context;
    (e.updateViewport(t.view.viewport) || this.view.viewport.to > e.treeLen) && this.scheduleWork(), (t.docChanged || t.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(e);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: t } = this.view, e = t.field(Fi.state);
    (e.tree != e.context.tree || !e.context.isDone(t.doc.length)) && (this.working = H6(this.work));
  }
  work(t) {
    this.working = null;
    let e = Date.now();
    if (this.chunkEnd < e && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = e + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: s } } = this.view, r = i.field(Fi.state);
    if (r.tree == r.context.tree && r.context.isDone(
      s + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let a = Date.now() + Math.min(this.chunkBudget, 100, t && !MO ? Math.max(25, t.timeRemaining() - 5) : 1e9), o = r.context.treeLen < s && i.doc.length > s + 1e3, l = r.context.work(() => MO && MO() || Date.now() > a, s + (o ? 0 : 1e5));
    this.chunkBudget -= Date.now() - e, (l || this.chunkBudget <= 0) && (r.context.takeTree(), this.view.dispatch({ effects: Fi.setState.of(new xx(r.context)) })), this.chunkBudget > 0 && !(l && !o) && this.scheduleWork(), this.checkAsyncSchedule(r.context);
  }
  checkAsyncSchedule(t) {
    t.scheduleOn && (this.workScheduled++, t.scheduleOn.then(() => this.scheduleWork()).catch((e) => Ci(this.view.state, e)).then(() => this.workScheduled--), t.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, c(ad, "Mi$1"), ad), f(TO, "ParseWorker"), TO), {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Gf = /* @__PURE__ */ gt.define({
  combine(n) {
    return n.length ? n[0] : null;
  },
  enables: /* @__PURE__ */ f((n) => [
    Fi.state,
    FV,
    $t.contentAttributes.compute([n], (t) => {
      let e = t.facet(n);
      return e && e.name ? { "data-language": e.name } : {};
    })
  ], "enables")
});
var od;
const Y6 = (od = class {
  /**
  Create a language support object.
  */
  constructor(t, e = []) {
    this.language = t, this.support = e, this.extension = [t, e];
  }
}, c(od, "qf"), od);
f(Y6, "LanguageSupport");
let Kf = Y6;
var Oo;
const G6 = (Oo = class {
  constructor(t, e, i, s, r, a = void 0) {
    this.name = t, this.alias = e, this.extensions = i, this.filename = s, this.loadFunc = r, this.support = a, this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return this.loading || (this.loading = this.loadFunc().then((t) => this.support = t, (t) => {
      throw this.loading = null, t;
    }));
  }
  /**
  Create a language description.
  */
  static of(t) {
    let { load: e, support: i } = t;
    if (!e) {
      if (!i)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      e = /* @__PURE__ */ f(() => Promise.resolve(i), "load");
    }
    return new Oo(t.name, (t.alias || []).concat(t.name).map((s) => s.toLowerCase()), t.extensions || [], t.filename, e, i);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(t, e) {
    for (let s of t)
      if (s.filename && s.filename.test(e))
        return s;
    let i = /\.([^.]+)$/.exec(e);
    if (i) {
      for (let s of t)
        if (s.extensions.indexOf(i[1]) > -1)
          return s;
    }
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(t, e, i = !0) {
    e = e.toLowerCase();
    for (let s of t)
      if (s.alias.some((r) => r == e))
        return s;
    if (i)
      for (let s of t)
        for (let r of s.alias) {
          let a = e.indexOf(r);
          if (a > -1 && (r.length > 2 || !/\w/.test(e[a - 1]) && !/\w/.test(e[a + r.length])))
            return s;
        }
    return null;
  }
}, c(Oo, "ao"), Oo);
f(G6, "LanguageDescription");
let C4 = G6;
const UV = /* @__PURE__ */ gt.define(), $b = /* @__PURE__ */ gt.define({
  combine: /* @__PURE__ */ f((n) => {
    if (!n.length)
      return "  ";
    let t = n[0];
    if (!t || /\S/.test(t) || Array.from(t).some((e) => e != t[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(n[0]));
    return t;
  }, "combine")
});
function vw(n) {
  let t = n.facet($b);
  return t.charCodeAt(0) == 9 ? n.tabSize * t.length : t.length;
}
c(vw, "ai$1");
f(vw, "getIndentUnit");
function kx(n, t) {
  let e = "", i = n.tabSize, s = n.facet($b)[0];
  if (s == "	") {
    for (; t >= i; )
      e += "	", t -= i;
    s = " ";
  }
  for (let r = 0; r < t; r++)
    e += s;
  return e;
}
c(kx, "Qs$1");
f(kx, "indentString");
function K6(n, t) {
  n instanceof ze && (n = new N5(n));
  for (let i of n.state.facet(UV)) {
    let s = i(n, t);
    if (s !== void 0)
      return s;
  }
  let e = he(n.state);
  return e.length >= t ? tM(n, e, t) : null;
}
c(K6, "rp$1");
f(K6, "getIndentation");
var ld;
const J6 = (ld = class {
  /**
  Create an indent context.
  */
  constructor(t, e = {}) {
    this.state = t, this.options = e, this.unit = vw(t);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(t, e = 1) {
    let i = this.state.doc.lineAt(t), { simulateBreak: s, simulateDoubleBreak: r } = this.options;
    return s != null && s >= i.from && s <= i.to ? r && s == t ? { text: "", from: t } : (e < 0 ? s < t : s <= t) ? { text: i.text.slice(s - i.from), from: s } : { text: i.text.slice(0, s - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(t, e = 1) {
    if (this.options.simulateDoubleBreak && t == this.options.simulateBreak)
      return "";
    let { text: i, from: s } = this.lineAt(t, e);
    return i.slice(t - s, Math.min(i.length, t + 100 - s));
  }
  /**
  Find the column for the given position.
  */
  column(t, e = 1) {
    let { text: i, from: s } = this.lineAt(t, e), r = this.countColumn(i, t - s), a = this.options.overrideIndentation ? this.options.overrideIndentation(s) : -1;
    return a > -1 && (r += a - this.countColumn(i, i.search(/\S|$/))), r;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(t, e = t.length) {
    return Nr(t, this.state.tabSize, e);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(t, e = 1) {
    let { text: i, from: s } = this.lineAt(t, e), r = this.options.overrideIndentation;
    if (r) {
      let a = r(s);
      if (a > -1)
        return a;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}, c(ld, "Df"), ld);
f(J6, "IndentContext");
let N5 = J6;
const ky = /* @__PURE__ */ new xt();
function tM(n, t, e) {
  let i = t.resolveStack(e), s = t.resolveInner(e, -1).resolve(e, 0).enterUnfinishedNodesBefore(e);
  if (s != i.node) {
    let r = [];
    for (let a = s; a && !(a.from < i.node.from || a.to > i.node.to || a.from == i.node.from && a.type == i.node.type); a = a.parent)
      r.push(a);
    for (let a = r.length - 1; a >= 0; a--)
      i = { node: r[a], next: i };
  }
  return H5(i, n, e);
}
c(tM, "Vy$1");
f(tM, "syntaxIndentation");
function H5(n, t, e) {
  for (let i = n; i; i = i.next) {
    let s = iM(i.node);
    if (s)
      return s(BV.create(t, e, i));
  }
  return 0;
}
c(H5, "np$1");
f(H5, "indentFor");
function eM(n) {
  return n.pos == n.options.simulateBreak && n.options.simulateDoubleBreak;
}
c(eM, "Uy$1");
f(eM, "ignoreClosed");
function iM(n) {
  let t = n.type.prop(ky);
  if (t)
    return t;
  let e = n.firstChild, i;
  if (e && (i = e.type.prop(xt.closedBy))) {
    let s = n.lastChild, r = s && i.indexOf(s.name) > -1;
    return (a) => Y5(a, !0, 1, void 0, r && !eM(a) ? s.from : void 0);
  }
  return n.parent == null ? nM : null;
}
c(iM, "Wy$1");
f(iM, "indentStrategy");
function nM() {
  return 0;
}
c(nM, "Xy$1");
f(nM, "topIndent");
var $o;
const sM = ($o = class extends N5 {
  constructor(t, e, i) {
    super(t.state, t.options), this.base = t, this.pos = e, this.context = i;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(t, e, i) {
    return new $o(t, e, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(t) {
    let e = this.state.doc.lineAt(t.from);
    for (; ; ) {
      let i = t.resolve(e.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (rM(i, t))
        break;
      e = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(e.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return H5(this.context.next, this.base, this.pos);
  }
}, c($o, "ho"), $o);
f(sM, "TreeIndentContext");
let BV = sM;
function rM(n, t) {
  for (let e = t; e; e = e.parent)
    if (n == e)
      return !0;
  return !1;
}
c(rM, "Yy$1");
f(rM, "isParent");
function aM(n) {
  let t = n.node, e = t.childAfter(t.from), i = t.lastChild;
  if (!e)
    return null;
  let s = n.options.simulateBreak, r = n.state.doc.lineAt(e.from), a = s == null || s <= r.from ? r.to : Math.min(r.to, s);
  for (let o = e.to; ; ) {
    let l = t.childAfter(o);
    if (!l || l == i)
      return null;
    if (!l.type.isSkipped) {
      if (l.from >= a)
        return null;
      let h = /^ */.exec(r.text.slice(e.to - r.from))[0].length;
      return { from: e.from, to: e.to + h };
    }
    o = l.to;
  }
}
c(aM, "Iy$1");
f(aM, "bracketedAligned");
function oM({ closing: n, align: t = !0, units: e = 1 }) {
  return (i) => Y5(i, t, e, n);
}
c(oM, "jy$1");
f(oM, "delimitedIndent");
function Y5(n, t, e, i, s) {
  let r = n.textAfter, a = r.match(/^\s*/)[0].length, o = i && r.slice(a, a + i.length) == i || s == n.pos + a, l = t ? aM(n) : null;
  return l ? o ? n.column(l.from) : n.column(l.to) : n.baseIndent + (o ? 0 : n.unit * e);
}
c(Y5, "sp$1");
f(Y5, "delimitedStrategy");
const XV = /* @__PURE__ */ f((n) => n.baseIndent, "flatIndent");
function sw({ except: n, units: t = 1 } = {}) {
  return (e) => {
    let i = n && n.test(e.textAfter);
    return e.baseIndent + (i ? 0 : t * e.unit);
  };
}
c(sw, "Fn$1");
f(sw, "continuedIndent");
const NV = /* @__PURE__ */ gt.define(), eg = /* @__PURE__ */ new xt();
function G5(n) {
  let t = n.firstChild, e = n.lastChild;
  return t && t.to < e.from ? { from: t.to, to: e.type.isError ? n.to : e.from } : null;
}
c(G5, "op$1");
f(G5, "foldInside");
var xo;
const lM = (xo = class {
  constructor(t, e) {
    this.specs = t;
    let i;
    function s(o) {
      let l = Hr.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + l] = o, l;
    }
    c(s, "n"), f(s, "def");
    const r = typeof e.all == "string" ? e.all : e.all ? s(e.all) : void 0, a = e.scope;
    this.scope = a instanceof Fi ? (o) => o.prop(Or) == a.data : a ? (o) => o == a : void 0, this.style = U5(t.map((o) => ({
      tag: o.tag,
      class: o.class || s(Object.assign({}, o, { tag: null }))
    })), {
      all: r
    }).style, this.module = i ? new Hr(i) : null, this.themeType = e.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(t, e) {
    return new xo(t, e || {});
  }
}, c(xo, "fo"), xo);
f(lM, "HighlightStyle");
let cM = lM;
const Sx = /* @__PURE__ */ gt.define(), hM = /* @__PURE__ */ gt.define({
  combine(n) {
    return n.length ? [n[0]] : null;
  }
});
function a1(n) {
  let t = n.facet(Sx);
  return t.length ? t : n.facet(hM);
}
c(a1, "Eo$1");
f(a1, "getHighlighters");
function HV(n, t) {
  let e = [GV], i;
  return n instanceof cM && (n.module && e.push($t.styleModule.of(n.module)), i = n.themeType), t?.fallback ? e.push(hM.of(n)) : i ? e.push(Sx.computeN([$t.darkTheme], (s) => s.facet($t.darkTheme) == (i == "dark") ? [n] : [])) : e.push(Sx.of(n)), e;
}
c(HV, "By$1");
f(HV, "syntaxHighlighting");
var cd;
const dM = (cd = class {
  constructor(t) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = he(t.state), this.decorations = this.buildDeco(t, a1(t.state)), this.decoratedTo = t.viewport.to;
  }
  update(t) {
    let e = he(t.state), i = a1(t.state), s = i != a1(t.startState), { viewport: r } = t.view, a = t.changes.mapPos(this.decoratedTo, 1);
    e.length < r.to && !s && e.type == this.tree.type && a >= r.to ? (this.decorations = this.decorations.map(t.changes), this.decoratedTo = a) : (e != this.tree || t.viewportChanged || s) && (this.tree = e, this.decorations = this.buildDeco(t.view, i), this.decoratedTo = r.to);
  }
  buildDeco(t, e) {
    if (!e || !this.tree.length)
      return ee.none;
    let i = new tv();
    for (let { from: s, to: r } of t.visibleRanges)
      W6(this.tree, e, (a, o, l) => {
        i.add(a, o, this.markCache[l] || (this.markCache[l] = ee.mark({ class: l })));
      }, s, r);
    return i.finish();
  }
}, c(cd, "Bf"), cd);
f(dM, "TreeHighlighter");
let YV = dM;
const GV = /* @__PURE__ */ al.high(/* @__PURE__ */ Zs.fromClass(YV, {
  decorations: /* @__PURE__ */ f((n) => n.decorations, "decorations")
})), KV = 1e4, JV = "()[]{}", uM = /* @__PURE__ */ new xt();
function pv(n, t, e) {
  let i = n.prop(t < 0 ? xt.openedBy : xt.closedBy);
  if (i)
    return i;
  if (n.name.length == 1) {
    let s = e.indexOf(n.name);
    if (s > -1 && s % 2 == (t < 0 ? 1 : 0))
      return [e[s + t]];
  }
  return null;
}
c(pv, "da$1");
f(pv, "matchingNodes");
function fv(n) {
  let t = n.type.prop(uM);
  return t ? t(n.node) : n;
}
c(fv, "Oa$1");
f(fv, "findHandle");
function ja(n, t, e, i = {}) {
  let s = i.maxScanDistance || KV, r = i.brackets || JV, a = he(n), o = a.resolveInner(t, e);
  for (let l = o; l; l = l.parent) {
    let h = pv(l.type, e, r);
    if (h && l.from < l.to) {
      let u = fv(l);
      if (u && (e > 0 ? t >= u.from && t < u.to : t > u.from && t <= u.to))
        return pM(n, t, e, l, u, h, r);
    }
  }
  return fM(n, t, e, a, o.type, s, r);
}
c(ja, "gi$1");
f(ja, "matchBrackets");
function pM(n, t, e, i, s, r, a) {
  let o = i.parent, l = { from: s.from, to: s.to }, h = 0, u = o?.cursor();
  if (u && (e < 0 ? u.childBefore(i.from) : u.childAfter(i.to)))
    do
      if (e < 0 ? u.to <= i.from : u.from >= i.to) {
        if (h == 0 && r.indexOf(u.type.name) > -1 && u.from < u.to) {
          let p = fv(u);
          return { start: l, end: p ? { from: p.from, to: p.to } : void 0, matched: !0 };
        } else if (pv(u.type, e, a))
          h++;
        else if (pv(u.type, -e, a)) {
          if (h == 0) {
            let p = fv(u);
            return {
              start: l,
              end: p && p.from < p.to ? { from: p.from, to: p.to } : void 0,
              matched: !1
            };
          }
          h--;
        }
      }
    while (e < 0 ? u.prevSibling() : u.nextSibling());
  return { start: l, matched: !1 };
}
c(pM, "Hy$1");
f(pM, "matchMarkedBrackets");
function fM(n, t, e, i, s, r, a) {
  let o = e < 0 ? n.sliceDoc(t - 1, t) : n.sliceDoc(t, t + 1), l = a.indexOf(o);
  if (l < 0 || l % 2 == 0 != e > 0)
    return null;
  let h = { from: e < 0 ? t - 1 : t, to: e > 0 ? t + 1 : t }, u = n.doc.iterRange(t, e > 0 ? n.doc.length : 0), p = 0;
  for (let y = 0; !u.next().done && y <= r; ) {
    let m = u.value;
    e < 0 && (y += m.length);
    let w = t + y * e;
    for (let b = e > 0 ? 0 : m.length - 1, $ = e > 0 ? m.length : -1; b != $; b += e) {
      let x = a.indexOf(m[b]);
      if (!(x < 0 || i.resolveInner(w + b, 1).type != s))
        if (x % 2 == 0 == e > 0)
          p++;
        else {
          if (p == 1)
            return { start: h, end: { from: w + b, to: w + b + 1 }, matched: x >> 1 == l >> 1 };
          p--;
        }
    }
    e > 0 && (y += m.length);
  }
  return u.done ? { start: h, matched: !1 } : null;
}
c(fM, "Fy$1");
f(fM, "matchPlainBrackets");
function Px(n, t, e, i = 0, s = 0) {
  t == null && (t = n.search(/[^\s\u00a0]/), t == -1 && (t = n.length));
  let r = s;
  for (let a = i; a < t; a++)
    n.charCodeAt(a) == 9 ? r += e - r % e : r++;
  return r;
}
c(Px, "Zu$1");
f(Px, "countCol");
var hd;
const yM = (hd = class {
  /**
  Create a stream.
  */
  constructor(t, e, i, s) {
    this.string = t, this.tabSize = e, this.indentUnit = i, this.overrideIndent = s, this.pos = 0, this.start = 0, this.lastColumnPos = 0, this.lastColumnValue = 0;
  }
  /**
  True if we are at the end of the line.
  */
  eol() {
    return this.pos >= this.string.length;
  }
  /**
  True if we are at the start of the line.
  */
  sol() {
    return this.pos == 0;
  }
  /**
  Get the next code unit after the current position, or undefined
  if we're at the end of the line.
  */
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  /**
  Read the next code unit and advance `this.pos`.
  */
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  /**
  Match the next character against the given string, regular
  expression, or predicate. Consume and return it if it matches.
  */
  eat(t) {
    let e = this.string.charAt(this.pos), i;
    if (typeof t == "string" ? i = e == t : i = e && (t instanceof RegExp ? t.test(e) : t(e)), i)
      return ++this.pos, e;
  }
  /**
  Continue matching characters that match the given string,
  regular expression, or predicate function. Return true if any
  characters were consumed.
  */
  eatWhile(t) {
    let e = this.pos;
    for (; this.eat(t); )
      ;
    return this.pos > e;
  }
  /**
  Consume whitespace ahead of `this.pos`. Return true if any was
  found.
  */
  eatSpace() {
    let t = this.pos;
    for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
      ++this.pos;
    return this.pos > t;
  }
  /**
  Move to the end of the line.
  */
  skipToEnd() {
    this.pos = this.string.length;
  }
  /**
  Move to directly before the given character, if found on the
  current line.
  */
  skipTo(t) {
    let e = this.string.indexOf(t, this.pos);
    if (e > -1)
      return this.pos = e, !0;
  }
  /**
  Move back `n` characters.
  */
  backUp(t) {
    this.pos -= t;
  }
  /**
  Get the column position at `this.pos`.
  */
  column() {
    return this.lastColumnPos < this.start && (this.lastColumnValue = Px(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue;
  }
  /**
  Get the indentation column of the current line.
  */
  indentation() {
    var t;
    return (t = this.overrideIndent) !== null && t !== void 0 ? t : Px(this.string, null, this.tabSize);
  }
  /**
  Match the input against the given string or regular expression
  (which should start with a `^`). Return true or the regexp match
  if it matches.
  
  Unless `consume` is set to `false`, this will move `this.pos`
  past the matched text.
  
  When matching a string `caseInsensitive` can be set to true to
  make the match case-insensitive.
  */
  match(t, e, i) {
    if (typeof t == "string") {
      let s = /* @__PURE__ */ f((a) => i ? a.toLowerCase() : a, "cased"), r = this.string.substr(this.pos, t.length);
      return s(r) == s(t) ? (e !== !1 && (this.pos += t.length), !0) : null;
    } else {
      let s = this.string.slice(this.pos).match(t);
      return s && s.index > 0 ? null : (s && e !== !1 && (this.pos += s[0].length), s);
    }
  }
  /**
  Get the current token.
  */
  current() {
    return this.string.slice(this.start, this.pos);
  }
}, c(hd, "zf"), hd);
f(yM, "StringStream");
let mM = yM;
function wM(n) {
  return {
    name: n.name || "",
    token: n.token,
    blankLine: n.blankLine || (() => {
    }),
    startState: n.startState || (() => !0),
    copyState: n.copyState || gM,
    indent: n.indent || (() => null),
    languageData: n.languageData || {},
    tokenTable: n.tokenTable || tS,
    mergeTokens: n.mergeTokens !== !1
  };
}
c(wM, "Ky$1");
f(wM, "fullParser");
function gM(n) {
  if (typeof n != "object")
    return n;
  let t = {};
  for (let e in n) {
    let i = n[e];
    t[e] = i instanceof Array ? i.slice() : i;
  }
  return t;
}
c(gM, "Jy$1");
f(gM, "defaultCopyState");
const Q4 = /* @__PURE__ */ new WeakMap();
var ko;
const vM = (ko = class extends Fi {
  constructor(t) {
    let e = tg(t.languageData), i = wM(t), s, r = new class extends Ob {
      createParse(a, o, l) {
        return new eD(s, a, o, l);
      }
    }();
    super(e, r, [], t.name), this.topNode = kM(e, this), s = this, this.streamParser = i, this.stateAfter = new xt({ perNode: !0 }), this.tokenTable = t.tokenTable ? new xM(i.tokenTable) : nD;
  }
  /**
  Define a stream language.
  */
  static define(t) {
    return new ko(t);
  }
  /**
  @internal
  */
  getIndent(t) {
    let e, { overrideIndentation: i } = t.options;
    i && (e = Q4.get(t.state), e != null && e < t.pos - 1e4 && (e = void 0));
    let s = xb(this, t.node.tree, t.node.from, t.node.from, e ?? t.pos), r, a;
    if (s ? (a = s.state, r = s.pos + 1) : (a = this.streamParser.startState(t.unit), r = t.node.from), t.pos - r > 1e4)
      return null;
    for (; r < t.pos; ) {
      let l = t.state.doc.lineAt(r), h = Math.min(t.pos, l.to);
      if (l.length) {
        let u = i ? i(l.from) : -1, p = new mM(l.text, t.state.tabSize, t.unit, u < 0 ? void 0 : u);
        for (; p.pos < h - l.from; )
          J5(this.streamParser.token, p, a);
      } else
        this.streamParser.blankLine(a, t.unit);
      if (h == t.pos)
        break;
      r = l.to + 1;
    }
    let o = t.lineAt(t.pos);
    return i && e == null && Q4.set(t.state, o.from), this.streamParser.indent(a, /^\s*(.*)/.exec(o.text)[1], t);
  }
  get allowsNesting() {
    return !1;
  }
}, c(ko, "co"), ko);
f(vM, "StreamLanguage");
let tD = vM;
function xb(n, t, e, i, s) {
  let r = e >= i && e + t.length <= s && t.prop(n.stateAfter);
  if (r)
    return { state: n.streamParser.copyState(r), pos: e + t.length };
  for (let a = t.children.length - 1; a >= 0; a--) {
    let o = t.children[a], l = e + t.positions[a], h = o instanceof Lt && l < s && xb(n, o, l, i, s);
    if (h)
      return h;
  }
  return null;
}
c(xb, "dh");
f(xb, "findState");
function K5(n, t, e, i, s) {
  if (s && e <= 0 && i >= t.length)
    return t;
  !s && e == 0 && t.type == n.topNode && (s = !0);
  for (let r = t.children.length - 1; r >= 0; r--) {
    let a = t.positions[r], o = t.children[r], l;
    if (a < i && o instanceof Lt) {
      if (!(l = K5(n, o, e - a, i - a, s)))
        break;
      return s ? new Lt(t.type, t.children.slice(0, r).concat(l), t.positions.slice(0, r + 1), a + l.length) : l;
    }
  }
  return null;
}
c(K5, "hp$1");
f(K5, "cutTree");
function bM(n, t, e, i, s) {
  for (let r of t) {
    let a = r.from + (r.openStart ? 25 : 0), o = r.to - (r.openEnd ? 25 : 0), l = a <= e && o > e && xb(n, r.tree, 0 - r.offset, e, o), h;
    if (l && l.pos <= i && (h = K5(n, r.tree, e + r.offset, l.pos + r.offset, !1)))
      return { state: l.state, tree: h };
  }
  return { state: n.streamParser.startState(s ? vw(s) : 4), tree: Lt.empty };
}
c(bM, "eb$1");
f(bM, "findStartInFragments");
var AO, dd;
let eD = (AO = (dd = class {
  constructor(t, e, i, s) {
    this.lang = t, this.input = e, this.fragments = i, this.ranges = s, this.stoppedAt = null, this.chunks = [], this.chunkPos = [], this.chunk = [], this.chunkReused = void 0, this.rangeIndex = 0, this.to = s[s.length - 1].to;
    let r = uv.get(), a = s[0].from, { state: o, tree: l } = bM(t, i, a, this.to, r?.state);
    this.state = o, this.parsedPos = this.chunkStart = a + l.length;
    for (let h = 0; h < l.children.length; h++)
      this.chunks.push(l.children[h]), this.chunkPos.push(l.positions[h]);
    r && this.parsedPos < r.viewport.from - 1e5 && s.some((h) => h.from <= r.viewport.from && h.to >= r.viewport.from) && (this.state = this.lang.streamParser.startState(vw(r.state)), r.skipUntilInView(this.parsedPos, r.viewport.from), this.parsedPos = r.viewport.from), this.moveRangeIndex();
  }
  advance() {
    let t = uv.get(), e = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt), i = Math.min(
      e,
      this.chunkStart + 512
      /* C.ChunkSize */
    );
    for (t && (i = Math.min(i, t.viewport.to)); this.parsedPos < i; )
      this.parseLine(t);
    return this.chunkStart < this.parsedPos && this.finishChunk(), this.parsedPos >= e ? this.finish() : t && this.parsedPos >= t.viewport.to ? (t.skipUntilInView(this.parsedPos, e), this.finish()) : null;
  }
  stopAt(t) {
    this.stoppedAt = t;
  }
  lineAfter(t) {
    let e = this.input.chunk(t);
    if (this.input.lineChunks)
      e == `
` && (e = "");
    else {
      let i = e.indexOf(`
`);
      i > -1 && (e = e.slice(0, i));
    }
    return t + e.length <= this.to ? e : e.slice(0, this.to - t);
  }
  nextLine() {
    let t = this.parsedPos, e = this.lineAfter(t), i = t + e.length;
    for (let s = this.rangeIndex; ; ) {
      let r = this.ranges[s].to;
      if (r >= i || (e = e.slice(0, r - (i - e.length)), s++, s == this.ranges.length))
        break;
      let a = this.ranges[s].from, o = this.lineAfter(a);
      e += o, i = a + o.length;
    }
    return { line: e, end: i };
  }
  skipGapsTo(t, e, i) {
    for (; ; ) {
      let s = this.ranges[this.rangeIndex].to, r = t + e;
      if (i > 0 ? s > r : s >= r)
        break;
      let a = this.ranges[++this.rangeIndex].from;
      e += a - s;
    }
    return e;
  }
  moveRangeIndex() {
    for (; this.ranges[this.rangeIndex].to < this.parsedPos; )
      this.rangeIndex++;
  }
  emitToken(t, e, i, s) {
    let r = 4;
    if (this.ranges.length > 1) {
      s = this.skipGapsTo(e, s, 1), e += s;
      let o = this.chunk.length;
      s = this.skipGapsTo(i, s, -1), i += s, r += this.chunk.length - o;
    }
    let a = this.chunk.length - 4;
    return this.lang.streamParser.mergeTokens && r == 4 && a >= 0 && this.chunk[a] == t && this.chunk[a + 2] == e ? this.chunk[a + 2] = i : this.chunk.push(t, e, i, r), s;
  }
  parseLine(t) {
    let { line: e, end: i } = this.nextLine(), s = 0, { streamParser: r } = this.lang, a = new mM(e, t ? t.state.tabSize : 4, t ? vw(t.state) : 2);
    if (a.eol())
      r.blankLine(this.state, a.indentUnit);
    else
      for (; !a.eol(); ) {
        let o = J5(r.token, a, this.state);
        if (o && (s = this.emitToken(this.lang.tokenTable.resolve(o), this.parsedPos + a.start, this.parsedPos + a.pos, s)), a.start > 1e4)
          break;
      }
    this.parsedPos = i, this.moveRangeIndex(), this.parsedPos < this.to && this.parsedPos++;
  }
  finishChunk() {
    let t = Lt.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet: iD,
      topID: 0,
      maxBufferLength: 512,
      reused: this.chunkReused
    });
    t = new Lt(t.type, t.children, t.positions, t.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]), this.chunks.push(t), this.chunkPos.push(this.chunkStart - this.ranges[0].from), this.chunk = [], this.chunkReused = void 0, this.chunkStart = this.parsedPos;
  }
  finish() {
    return new Lt(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
}, c(dd, "_i$1"), dd), f(AO, "Parse"), AO);
function J5(n, t, e) {
  t.start = t.pos;
  for (let i = 0; i < 10; i++) {
    let s = n(t, e);
    if (t.pos > t.start)
      return s;
  }
  throw new Error("Stream parser failed to advance stream.");
}
c(J5, "fp$1");
f(J5, "readToken$1");
const tS = /* @__PURE__ */ Object.create(null), bw = [Ue.none], iD = /* @__PURE__ */ new gb(bw), M4 = [], T4 = /* @__PURE__ */ Object.create(null), OM = /* @__PURE__ */ Object.create(null);
for (let [n, t] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  OM[n] = /* @__PURE__ */ eS(tS, t);
var ud;
const $M = (ud = class {
  constructor(t) {
    this.extra = t, this.table = Object.assign(/* @__PURE__ */ Object.create(null), OM);
  }
  resolve(t) {
    return t ? this.table[t] || (this.table[t] = eS(this.extra, t)) : 0;
  }
}, c(ud, "Nf"), ud);
f($M, "TokenTable");
let xM = $M;
const nD = /* @__PURE__ */ new xM(tS);
function o1(n, t) {
  M4.indexOf(n) > -1 || (M4.push(n), console.warn(t));
}
c(o1, "Vo$1");
f(o1, "warnForPart");
function eS(n, t) {
  let e = [];
  for (let o of t.split(" ")) {
    let l = [];
    for (let h of o.split(".")) {
      let u = n[h] || M[h];
      u ? typeof u == "function" ? l.length ? l = l.map(u) : o1(h, `Modifier ${h} used at start of tag`) : l.length ? o1(h, `Tag ${h} used as modifier`) : l = Array.isArray(u) ? u : [u] : o1(h, `Unknown highlighting tag ${h}`);
    }
    for (let h of l)
      e.push(h);
  }
  if (!e.length)
    return 0;
  let i = t.replace(/ /g, "_"), s = i + " " + e.map((o) => o.id), r = T4[s];
  if (r)
    return r.id;
  let a = T4[s] = Ue.define({
    id: bw.length,
    name: i,
    props: [ol({ [i]: e })]
  });
  return bw.push(a), a.id;
}
c(eS, "up$1");
f(eS, "createTokenType");
function kM(n, t) {
  let e = Ue.define({ id: bw.length, name: "Document", props: [
    Or.add(() => n),
    ky.add(() => (i) => t.getIndent(i))
  ], top: !0 });
  return bw.push(e), e;
}
c(kM, "nb$1");
f(kM, "docID");
Qe.RTL, Qe.LTR;
var pd;
const SM = (pd = class {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(t, e, i, s) {
    this.state = t, this.pos = e, this.explicit = i, this.view = s, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(t) {
    let e = he(this.state).resolveInner(this.pos, -1);
    for (; e && t.indexOf(e.name) < 0; )
      e = e.parent;
    return e ? {
      from: e.from,
      to: this.pos,
      text: this.state.sliceDoc(e.from, this.pos),
      type: e.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(t) {
    let e = this.state.doc.lineAt(this.pos), i = Math.max(e.from, this.pos - 250), s = e.text.slice(i - e.from, this.pos - e.from), r = s.search(sS(t, !1));
    return r < 0 ? null : { from: i + r, to: this.pos, text: s.slice(r) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(t, e, i) {
    t == "abort" && this.abortListeners && (this.abortListeners.push(e), i && i.onDocChange && (this.abortOnDocChange = !0));
  }
}, c(pd, "Gf"), pd);
f(SM, "CompletionContext");
let iS = SM;
function Cx(n) {
  let t = Object.keys(n).join(""), e = /\w/.test(t);
  return e && (t = t.replace(/\w/g, "")), `[${e ? "\\w" : ""}${t.replace(/[^\w\s]/g, "\\$&")}]`;
}
c(Cx, "Cu$1");
f(Cx, "toSet");
function PM(n) {
  let t = /* @__PURE__ */ Object.create(null), e = /* @__PURE__ */ Object.create(null);
  for (let { label: s } of n) {
    t[s[0]] = !0;
    for (let r = 1; r < s.length; r++)
      e[s[r]] = !0;
  }
  let i = Cx(t) + Cx(e) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
c(PM, "sb$1");
f(PM, "prefixMatch");
function nS(n) {
  let t = n.map((s) => typeof s == "string" ? { label: s } : s), [e, i] = t.every((s) => /^\w+$/.test(s.label)) ? [/\w*$/, /\w+$/] : PM(t);
  return (s) => {
    let r = s.matchBefore(i);
    return r || s.explicit ? { from: r ? r.from : s.pos, options: t, validFor: e } : null;
  };
}
c(nS, "dp$1");
f(nS, "completeFromList");
function CM(n, t) {
  return (e) => {
    for (let i = he(e.state).resolveInner(e.pos, -1); i; i = i.parent) {
      if (n.indexOf(i.name) > -1)
        return null;
      if (i.type.isTop)
        break;
    }
    return t(e);
  };
}
c(CM, "ob$1");
f(CM, "ifNotIn");
var fd;
const QM = (fd = class {
  constructor(t, e, i, s) {
    this.completion = t, this.source = e, this.match = i, this.score = s;
  }
}, c(fd, "Hf"), fd);
f(QM, "Option");
let A4 = QM;
function Sr(n) {
  return n.selection.main.from;
}
c(Sr, "Jt$2");
f(Sr, "cur");
function sS(n, t) {
  var e;
  let { source: i } = n, s = t && i[0] != "^", r = i[i.length - 1] != "$";
  return !s && !r ? n : new RegExp(`${s ? "^" : ""}(?:${i})${r ? "$" : ""}`, (e = n.flags) !== null && e !== void 0 ? e : n.ignoreCase ? "i" : "");
}
c(sS, "Op$1");
f(sS, "ensureAnchor");
const rS = /* @__PURE__ */ Ns.define();
function MM(n, t, e, i) {
  let { main: s } = n.selection, r = e - s.from, a = i - s.from;
  return {
    ...n.changeByRange((o) => {
      if (o != s && e != i && n.sliceDoc(o.from + r, o.from + a) != n.sliceDoc(e, i))
        return { range: o };
      let l = n.toText(t);
      return {
        changes: { from: o.from + r, to: i == s.from ? o.to : o.from + a, insert: l },
        range: J.cursor(o.from + r + l.length)
      };
    }),
    scrollIntoView: !0,
    userEvent: "input.complete"
  };
}
c(MM, "lb$1");
f(MM, "insertCompletionText");
const R4 = /* @__PURE__ */ new WeakMap();
function TM(n) {
  if (!Array.isArray(n))
    return n;
  let t = R4.get(n);
  return t || R4.set(n, t = nS(n)), t;
}
c(TM, "ab$1");
f(TM, "asSource");
const yv = /* @__PURE__ */ Bt.define(), Ow = /* @__PURE__ */ Bt.define();
var yd;
const AM = (yd = class {
  constructor(t) {
    this.pattern = t, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let e = 0; e < t.length; ) {
      let i = pr(t, e), s = Wa(i);
      this.chars.push(i);
      let r = t.slice(e, e + s), a = r.toUpperCase();
      this.folded.push(pr(a == r ? r.toLowerCase() : a, 0)), e += s;
    }
    this.astral = t.length != this.chars.length;
  }
  ret(t, e) {
    return this.score = t, this.matched = e, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(t) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (t.length < this.pattern.length)
      return null;
    let { chars: e, folded: i, any: s, precise: r, byWord: a } = this;
    if (e.length == 1) {
      let C = pr(t, 0), R = Wa(C), E = R == t.length ? 0 : -100;
      if (C != e[0]) if (C == i[0])
        E += -200;
      else
        return null;
      return this.ret(E, [0, R]);
    }
    let o = t.indexOf(this.pattern);
    if (o == 0)
      return this.ret(t.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = e.length, h = 0;
    if (o < 0) {
      for (let C = 0, R = Math.min(t.length, 200); C < R && h < l; ) {
        let E = pr(t, C);
        (E == e[h] || E == i[h]) && (s[h++] = C), C += Wa(E);
      }
      if (h < l)
        return null;
    }
    let u = 0, p = 0, y = !1, m = 0, w = -1, b = -1, $ = /[a-z]/.test(t), x = !0;
    for (let C = 0, R = Math.min(t.length, 200), E = 0; C < R && p < l; ) {
      let A = pr(t, C);
      o < 0 && (u < l && A == e[u] && (r[u++] = C), m < l && (A == e[m] || A == i[m] ? (m == 0 && (w = C), b = C + 1, m++) : m = 0));
      let I, Z = A < 255 ? A >= 48 && A <= 57 || A >= 97 && A <= 122 ? 2 : A >= 65 && A <= 90 ? 1 : 0 : (I = A9(A)) != I.toLowerCase() ? 1 : I != I.toUpperCase() ? 2 : 0;
      (!C || Z == 1 && $ || E == 0 && Z != 0) && (e[p] == A || i[p] == A && (y = !0) ? a[p++] = C : a.length && (x = !1)), E = Z, C += Wa(A);
    }
    return p == l && a[0] == 0 && x ? this.result(-100 + (y ? -200 : 0), a, t) : m == l && w == 0 ? this.ret(-200 - t.length + (b == t.length ? 0 : -100), [0, b]) : o > -1 ? this.ret(-700 - t.length, [o, o + this.pattern.length]) : m == l ? this.ret(-900 - t.length, [w, b]) : p == l ? this.result(-100 + (y ? -200 : 0) + -700 + (x ? 0 : -1100), a, t) : e.length == 2 ? null : this.result((s[0] ? -700 : 0) + -200 + -1100, s, t);
  }
  result(t, e, i) {
    let s = [], r = 0;
    for (let a of e) {
      let o = a + (this.astral ? Wa(pr(i, a)) : 1);
      r && s[r - 1] == a ? s[r - 1] = o : (s[r++] = a, s[r++] = o);
    }
    return this.ret(t - i.length, s);
  }
}, c(yd, "Ff"), yd);
f(AM, "FuzzyMatcher");
let sD = AM;
var md;
const RM = (md = class {
  constructor(t) {
    this.pattern = t, this.matched = [], this.score = 0, this.folded = t.toLowerCase();
  }
  match(t) {
    if (t.length < this.pattern.length)
      return null;
    let e = t.slice(0, this.pattern.length), i = e == this.pattern ? 0 : e.toLowerCase() == this.folded ? -200 : null;
    return i == null ? null : (this.matched = [0, e.length], this.score = i + (t.length == this.pattern.length ? 0 : -100), this);
  }
}, c(md, "Kf"), md);
f(RM, "StrictMatcher");
let rD = RM;
const je = /* @__PURE__ */ gt.define({
  combine(n) {
    return o5(n, {
      activateOnTyping: !0,
      activateOnCompletion: /* @__PURE__ */ f(() => !1, "activateOnCompletion"),
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: /* @__PURE__ */ f(() => "", "tooltipClass"),
      optionClass: /* @__PURE__ */ f(() => "", "optionClass"),
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: EM,
      filterStrict: !1,
      compareCompletions: /* @__PURE__ */ f((t, e) => t.label.localeCompare(e.label), "compareCompletions"),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: /* @__PURE__ */ f((t, e) => t && e, "defaultKeymap"),
      closeOnBlur: /* @__PURE__ */ f((t, e) => t && e, "closeOnBlur"),
      icons: /* @__PURE__ */ f((t, e) => t && e, "icons"),
      tooltipClass: /* @__PURE__ */ f((t, e) => (i) => Qx(t(i), e(i)), "tooltipClass"),
      optionClass: /* @__PURE__ */ f((t, e) => (i) => Qx(t(i), e(i)), "optionClass"),
      addToOptions: /* @__PURE__ */ f((t, e) => t.concat(e), "addToOptions"),
      filterStrict: /* @__PURE__ */ f((t, e) => t || e, "filterStrict")
    });
  }
});
function Qx(n, t) {
  return n ? t ? n + " " + t : n : t;
}
c(Qx, "Vu");
f(Qx, "joinClass");
function EM(n, t, e, i, s, r) {
  let a = n.textDirection == Qe.RTL, o = a, l = !1, h = "top", u, p, y = t.left - s.left, m = s.right - t.right, w = i.right - i.left, b = i.bottom - i.top;
  if (o && y < Math.min(w, m) ? o = !1 : !o && m < Math.min(w, y) && (o = !0), w <= (o ? y : m))
    u = Math.max(s.top, Math.min(e.top, s.bottom - b)) - t.top, p = Math.min(400, o ? y : m);
  else {
    l = !0, p = Math.min(
      400,
      (a ? t.right : s.right - t.left) - 30
      /* Info.Margin */
    );
    let C = s.bottom - t.bottom;
    C >= b || C > t.top ? u = e.bottom - t.top : (h = "bottom", u = t.bottom - e.top);
  }
  let $ = (t.bottom - t.top) / r.offsetHeight, x = (t.right - t.left) / r.offsetWidth;
  return {
    style: `${h}: ${u / $}px; max-width: ${p / x}px`,
    class: "cm-completionInfo-" + (l ? a ? "left-narrow" : "right-narrow" : o ? "left" : "right")
  };
}
c(EM, "hb$1");
f(EM, "defaultPositionInfo");
function _M(n) {
  let t = n.addToOptions.slice();
  return n.icons && t.push({
    render(e) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), e.type && i.classList.add(...e.type.split(/\s+/g).map((s) => "cm-completionIcon-" + s)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), t.push({
    render(e, i, s, r) {
      let a = document.createElement("span");
      a.className = "cm-completionLabel";
      let o = e.displayLabel || e.label, l = 0;
      for (let h = 0; h < r.length; ) {
        let u = r[h++], p = r[h++];
        u > l && a.appendChild(document.createTextNode(o.slice(l, u)));
        let y = a.appendChild(document.createElement("span"));
        y.appendChild(document.createTextNode(o.slice(u, p))), y.className = "cm-completionMatchedText", l = p;
      }
      return l < o.length && a.appendChild(document.createTextNode(o.slice(l))), a;
    },
    position: 50
  }, {
    render(e) {
      if (!e.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = e.detail, i;
    },
    position: 80
  }), t.sort((e, i) => e.position - i.position).map((e) => e.render);
}
c(_M, "fb$1");
f(_M, "optionContent");
function l1(n, t, e) {
  if (n <= e)
    return { from: 0, to: n };
  if (t < 0 && (t = 0), t <= n >> 1) {
    let s = Math.floor(t / e);
    return { from: s * e, to: (s + 1) * e };
  }
  let i = Math.floor((n - t) / e);
  return { from: n - (i + 1) * e, to: n - i * e };
}
c(l1, "Uo$1");
f(l1, "rangeAroundSelected");
var wd;
const zM = (wd = class {
  constructor(t, e, i) {
    this.view = t, this.stateField = e, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: /* @__PURE__ */ f(() => this.measureInfo(), "read"),
      write: /* @__PURE__ */ f((l) => this.placeInfo(l), "write"),
      key: this
    }, this.space = null, this.currentClass = "";
    let s = t.state.field(e), { options: r, selected: a } = s.open, o = t.state.facet(je);
    this.optionContent = _M(o), this.optionClass = o.optionClass, this.tooltipClass = o.tooltipClass, this.range = l1(r.length, a, o.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(t.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: h } = t.state.field(e).open;
      for (let u = l.target, p; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (p = /-(\d+)$/.exec(u.id)) && +p[1] < h.length) {
          this.applyCompletion(t, h[+p[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let h = t.state.field(this.stateField, !1);
      h && h.tooltip && t.state.facet(je).closeOnBlur && l.relatedTarget != t.contentDOM && t.dispatch({ effects: Ow.of(null) });
    }), this.showOptions(r, s.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(t, e) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t, e, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(t) {
    var e;
    let i = t.state.field(this.stateField), s = t.startState.field(this.stateField);
    if (this.updateTooltipClass(t.state), i != s) {
      let { options: r, selected: a, disabled: o } = i.open;
      (!s.open || s.open.options != r) && (this.range = l1(r.length, a, t.state.facet(je).maxRenderedOptions), this.showOptions(r, i.id)), this.updateSel(), o != ((e = s.open) === null || e === void 0 ? void 0 : e.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!o);
    }
  }
  updateTooltipClass(t) {
    let e = this.tooltipClass(t);
    if (e != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of e.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = e;
    }
  }
  positioned(t) {
    this.space = t, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let t = this.view.state.field(this.stateField), e = t.open;
    (e.selected > -1 && e.selected < this.range.from || e.selected >= this.range.to) && (this.range = l1(e.options.length, e.selected, this.view.state.facet(je).maxRenderedOptions), this.showOptions(e.options, t.id));
    let i = this.updateSelectedOption(e.selected);
    if (i) {
      this.destroyInfo();
      let { completion: s } = e.options[e.selected], { info: r } = s;
      if (!r)
        return;
      let a = typeof r == "string" ? document.createTextNode(r) : r(s);
      if (!a)
        return;
      "then" in a ? a.then((o) => {
        o && this.view.state.field(this.stateField, !1) == t && this.addInfoPane(o, s);
      }).catch((o) => Ci(this.view.state, o, "completion info")) : (this.addInfoPane(a, s), i.setAttribute("aria-describedby", this.info.id));
    }
  }
  addInfoPane(t, e) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", i.id = "cm-completionInfo-" + Math.floor(Math.random() * 65535).toString(16), t.nodeType != null)
      i.appendChild(t), this.infoDestroy = null;
    else {
      let { dom: s, destroy: r } = t;
      i.appendChild(s), this.infoDestroy = r || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(t) {
    let e = null;
    for (let i = this.list.firstChild, s = this.range.from; i; i = i.nextSibling, s++)
      i.nodeName != "LI" || !i.id ? s-- : s == t ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), e = i) : i.hasAttribute("aria-selected") && (i.removeAttribute("aria-selected"), i.removeAttribute("aria-describedby"));
    return e && IM(this.list, e), e;
  }
  measureInfo() {
    let t = this.dom.querySelector("[aria-selected]");
    if (!t || !this.info)
      return null;
    let e = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), s = t.getBoundingClientRect(), r = this.space;
    if (!r) {
      let a = this.dom.ownerDocument.documentElement;
      r = { left: 0, top: 0, right: a.clientWidth, bottom: a.clientHeight };
    }
    return s.top > Math.min(r.bottom, e.bottom) - 10 || s.bottom < Math.max(r.top, e.top) + 10 ? null : this.view.state.facet(je).positionInfo(this.view, e, s, i, r, this.dom);
  }
  placeInfo(t) {
    this.info && (t ? (t.style && (this.info.style.cssText = t.style), this.info.className = "cm-tooltip cm-completionInfo " + (t.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(t, e, i) {
    const s = document.createElement("ul");
    s.id = e, s.setAttribute("role", "listbox"), s.setAttribute("aria-expanded", "true"), s.setAttribute("aria-label", this.view.state.phrase("Completions")), s.addEventListener("mousedown", (a) => {
      a.target == s && a.preventDefault();
    });
    let r = null;
    for (let a = i.from; a < i.to; a++) {
      let { completion: o, match: l } = t[a], { section: h } = o;
      if (h) {
        let y = typeof h == "string" ? h : h.name;
        if (y != r && (a > i.from || i.from == 0))
          if (r = y, typeof h != "string" && h.header)
            s.appendChild(h.header(h));
          else {
            let m = s.appendChild(document.createElement("completion-section"));
            m.textContent = y;
          }
      }
      const u = s.appendChild(document.createElement("li"));
      u.id = e + "-" + a, u.setAttribute("role", "option");
      let p = this.optionClass(o);
      p && (u.className = p);
      for (let y of this.optionContent) {
        let m = y(o, this.view.state, this.view, l);
        m && u.appendChild(m);
      }
    }
    return i.from && s.classList.add("cm-completionListIncompleteTop"), i.to < t.length && s.classList.add("cm-completionListIncompleteBottom"), s;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}, c(wd, "Jf"), wd);
f(zM, "CompletionTooltip");
let aD = zM;
function LM(n, t) {
  return (e) => new aD(e, n, t);
}
c(LM, "cb$1");
f(LM, "completionTooltip");
function IM(n, t) {
  let e = n.getBoundingClientRect(), i = t.getBoundingClientRect(), s = e.height / n.offsetHeight;
  i.top < e.top ? n.scrollTop -= (e.top - i.top) / s : i.bottom > e.bottom && (n.scrollTop += (i.bottom - e.bottom) / s);
}
c(IM, "ub$1");
f(IM, "scrollIntoView");
function Mx(n) {
  return (n.boost || 0) * 100 + (n.apply ? 10 : 0) + (n.info ? 5 : 0) + (n.type ? 1 : 0);
}
c(Mx, "Uu");
f(Mx, "score");
function ZM(n, t) {
  let e = [], i = null, s = null, r = /* @__PURE__ */ f((u) => {
    e.push(u);
    let { section: p } = u.completion;
    if (p) {
      i || (i = []);
      let y = typeof p == "string" ? p : p.name;
      i.some((m) => m.name == y) || i.push(typeof p == "string" ? { name: y } : p);
    }
  }, "addOption"), a = t.facet(je);
  for (let u of n)
    if (u.hasResult()) {
      let p = u.result.getMatch;
      if (u.result.filter === !1)
        for (let y of u.result.options)
          r(new A4(y, u.source, p ? p(y) : [], 1e9 - e.length));
      else {
        let y = t.sliceDoc(u.from, u.to), m, w = a.filterStrict ? new rD(y) : new sD(y);
        for (let b of u.result.options)
          if (m = w.match(b.label)) {
            let $ = b.displayLabel ? p ? p(b, m.matched) : [] : m.matched, x = m.score + (b.boost || 0);
            if (r(new A4(b, u.source, $, x)), typeof b.section == "object" && b.section.rank === "dynamic") {
              let { name: C } = b.section;
              s || (s = /* @__PURE__ */ Object.create(null)), s[C] = Math.max(x, s[C] || -1e9);
            }
          }
      }
    }
  if (i) {
    let u = /* @__PURE__ */ Object.create(null), p = 0, y = /* @__PURE__ */ f((m, w) => (m.rank === "dynamic" && w.rank === "dynamic" ? s[w.name] - s[m.name] : 0) || (typeof m.rank == "number" ? m.rank : 1e9) - (typeof w.rank == "number" ? w.rank : 1e9) || (m.name < w.name ? -1 : 1), "cmp");
    for (let m of i.sort(y))
      p -= 1e5, u[m.name] = p;
    for (let m of e) {
      let { section: w } = m.completion;
      w && (m.score += u[typeof w == "string" ? w : w.name]);
    }
  }
  let o = [], l = null, h = a.compareCompletions;
  for (let u of e.sort((p, y) => y.score - p.score || h(p.completion, y.completion))) {
    let p = u.completion;
    !l || l.label != p.label || l.detail != p.detail || l.type != null && p.type != null && l.type != p.type || l.apply != p.apply || l.boost != p.boost ? o.push(u) : Mx(u.completion) > Mx(l) && (o[o.length - 1] = u), l = u.completion;
  }
  return o;
}
c(ZM, "db$1");
f(ZM, "sortOptions");
var Yn;
const VM = (Yn = class {
  constructor(t, e, i, s, r, a) {
    this.options = t, this.attrs = e, this.tooltip = i, this.timestamp = s, this.selected = r, this.disabled = a;
  }
  setSelected(t, e) {
    return t == this.selected || t >= this.options.length ? this : new Yn(this.options, Tx(e, t), this.tooltip, this.timestamp, t, this.disabled);
  }
  static build(t, e, i, s, r, a) {
    if (s && !a && t.some((h) => h.isPending))
      return s.setDisabled();
    let o = ZM(t, e);
    if (!o.length)
      return s && t.some((h) => h.isPending) ? s.setDisabled() : null;
    let l = e.facet(je).selectOnOpen ? 0 : -1;
    if (s && s.selected != l && s.selected != -1) {
      let h = s.options[s.selected].completion;
      for (let u = 0; u < o.length; u++)
        if (o[u].completion == h) {
          l = u;
          break;
        }
    }
    return new Yn(o, Tx(i, l), {
      pos: t.reduce((h, u) => u.hasResult() ? Math.min(h, u.from) : h, 1e8),
      create: uD,
      above: r.aboveCursor
    }, s ? s.timestamp : Date.now(), l, !1);
  }
  map(t) {
    return new Yn(this.options, this.attrs, { ...this.tooltip, pos: t.mapPos(this.tooltip.pos) }, this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new Yn(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}, c(Yn, "zt"), Yn);
f(VM, "CompletionDialog");
let oD = VM;
var jr;
const DM = (jr = class {
  constructor(t, e, i) {
    this.active = t, this.id = e, this.open = i;
  }
  static start() {
    return new jr(dD, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(t) {
    let { state: e } = t, i = e.facet(je), s = (i.override || e.languageDataAt("autocomplete", Sr(e)).map(TM)).map((o) => (this.active.find((l) => l.source == o) || new Fa(
      o,
      this.active.some(
        (l) => l.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(t, i));
    s.length == this.active.length && s.every((o, l) => o == this.active[l]) && (s = this.active);
    let r = this.open, a = t.effects.some((o) => o.is(oS));
    r && t.docChanged && (r = r.map(t.changes)), t.selection || s.some((o) => o.hasResult() && t.changes.touchesRange(o.from, o.to)) || !WM(s, this.active) || a ? r = oD.build(s, e, this.id, r, i, a) : r && r.disabled && !s.some((o) => o.isPending) && (r = null), !r && s.every((o) => !o.isPending) && s.some((o) => o.hasResult()) && (s = s.map((o) => o.hasResult() ? new Fa(
      o.source,
      0
      /* State.Inactive */
    ) : o));
    for (let o of t.effects)
      o.is(BM) && (r = r && r.setSelected(o.value, this.id));
    return s == this.active && r == this.open ? this : new jr(s, this.id, r);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? cD : hD;
  }
}, c(jr, "jr"), jr);
f(DM, "CompletionState");
let lD = DM;
function WM(n, t) {
  if (n == t)
    return !0;
  for (let e = 0, i = 0; ; ) {
    for (; e < n.length && !n[e].hasResult(); )
      e++;
    for (; i < t.length && !t[i].hasResult(); )
      i++;
    let s = e == n.length, r = i == t.length;
    if (s || r)
      return s == r;
    if (n[e++].result != t[i++].result)
      return !1;
  }
}
c(WM, "Ob$1");
f(WM, "sameResults");
const cD = {
  "aria-autocomplete": "list"
}, hD = {};
function Tx(n, t) {
  let e = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": n
  };
  return t > -1 && (e["aria-activedescendant"] = n + "-" + t), e;
}
c(Tx, "Wu");
f(Tx, "makeAttrs");
const dD = [];
function aS(n, t) {
  if (n.isUserEvent("input.complete")) {
    let i = n.annotation(rS);
    if (i && t.activateOnCompletion(i))
      return 12;
  }
  let e = n.isUserEvent("input.type");
  return e && t.activateOnTyping ? 5 : e ? 1 : n.isUserEvent("delete.backward") ? 2 : n.selection ? 8 : n.docChanged ? 16 : 0;
}
c(aS, "pp$1");
f(aS, "getUpdateType");
var Gn;
const qM = (Gn = class {
  constructor(t, e, i = !1) {
    this.source = t, this.state = e, this.explicit = i;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(t, e) {
    let i = aS(t, e), s = this;
    (i & 8 || i & 16 && this.touches(t)) && (s = new Gn(
      s.source,
      0
      /* State.Inactive */
    )), i & 4 && s.state == 0 && (s = new Gn(
      this.source,
      1
      /* State.Pending */
    )), s = s.updateFor(t, i);
    for (let r of t.effects)
      if (r.is(yv))
        s = new Gn(s.source, 1, r.value);
      else if (r.is(Ow))
        s = new Gn(
          s.source,
          0
          /* State.Inactive */
        );
      else if (r.is(oS))
        for (let a of r.value)
          a.source == s.source && (s = a);
    return s;
  }
  updateFor(t, e) {
    return this.map(t.changes);
  }
  map(t) {
    return this;
  }
  touches(t) {
    return t.changes.touchesRange(Sr(t.state));
  }
}, c(Gn, "Nt"), Gn);
f(qM, "ActiveSource");
let Fa = qM;
var zs;
const jM = (zs = class extends Fa {
  constructor(t, e, i, s, r, a) {
    super(t, 3, e), this.limit = i, this.result = s, this.from = r, this.to = a;
  }
  hasResult() {
    return !0;
  }
  updateFor(t, e) {
    var i;
    if (!(e & 3))
      return this.map(t.changes);
    let s = this.result;
    s.map && !t.changes.empty && (s = s.map(s, t.changes));
    let r = t.changes.mapPos(this.from), a = t.changes.mapPos(this.to, 1), o = Sr(t.state);
    if (o > a || !s || e & 2 && (Sr(t.startState) == this.from || o < this.limit))
      return new Fa(
        this.source,
        e & 4 ? 1 : 0
        /* State.Inactive */
      );
    let l = t.changes.mapPos(this.limit);
    return UM(s.validFor, t.state, r, a) ? new zs(this.source, this.explicit, l, s, r, a) : s.update && (s = s.update(s, r, a, new iS(t.state, o, !1))) ? new zs(this.source, this.explicit, l, s, s.from, (i = s.to) !== null && i !== void 0 ? i : Sr(t.state)) : new Fa(this.source, 1, this.explicit);
  }
  map(t) {
    return t.empty ? this : (this.result.map ? this.result.map(this.result, t) : this.result) ? new zs(this.source, this.explicit, t.mapPos(this.limit), this.result, t.mapPos(this.from), t.mapPos(this.to, 1)) : new Fa(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(t) {
    return t.changes.touchesRange(this.from, this.to);
  }
}, c(zs, "xi"), zs);
f(jM, "ActiveResult");
let FM = jM;
function UM(n, t, e, i) {
  if (!n)
    return !1;
  let s = t.sliceDoc(e, i);
  return typeof n == "function" ? n(s, e, i, t) : sS(n, !0).test(s);
}
c(UM, "yb$1");
f(UM, "checkValid");
const oS = /* @__PURE__ */ Bt.define({
  map(n, t) {
    return n.map((e) => e.map(t));
  }
}), BM = /* @__PURE__ */ Bt.define(), mi = /* @__PURE__ */ Xs.define({
  create() {
    return lD.start();
  },
  update(n, t) {
    return n.update(t);
  },
  provide: /* @__PURE__ */ f((n) => [
    n6.from(n, (t) => t.tooltip),
    $t.contentAttributes.from(n, (t) => t.attrs)
  ], "provide")
});
function kb(n, t) {
  const e = t.completion.apply || t.completion.label;
  let i = n.state.field(mi).active.find((s) => s.source == t.source);
  return i instanceof FM ? (typeof e == "string" ? n.dispatch({
    ...MM(n.state, e, i.from, i.to),
    annotations: rS.of(t.completion)
  }) : e(n, t.completion, i.from, i.to), !0) : !1;
}
c(kb, "gh");
f(kb, "applyCompletion");
const uD = /* @__PURE__ */ LM(mi, kb);
function bm(n, t = "option") {
  return (e) => {
    let i = e.state.field(mi, !1);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < e.state.facet(je).interactionDelay)
      return !1;
    let s = 1, r;
    t == "page" && (r = W5(e, i.open.tooltip)) && (s = Math.max(2, Math.floor(r.dom.offsetHeight / r.dom.querySelector("li").offsetHeight) - 1));
    let { length: a } = i.open.options, o = i.open.selected > -1 ? i.open.selected + s * (n ? 1 : -1) : n ? 0 : a - 1;
    return o < 0 ? o = t == "page" ? 0 : a - 1 : o >= a && (o = t == "page" ? a - 1 : 0), e.dispatch({ effects: BM.of(o) }), !0;
  };
}
c(bm, "Yn$1");
f(bm, "moveCompletionSelection");
const pD = /* @__PURE__ */ f((n) => {
  let t = n.state.field(mi, !1);
  return n.state.readOnly || !t || !t.open || t.open.selected < 0 || t.open.disabled || Date.now() - t.open.timestamp < n.state.facet(je).interactionDelay ? !1 : kb(n, t.open.options[t.open.selected]);
}, "acceptCompletion"), RO = /* @__PURE__ */ f((n) => n.state.field(mi, !1) ? (n.dispatch({ effects: yv.of(!0) }), !0) : !1, "startCompletion"), fD = /* @__PURE__ */ f((n) => {
  let t = n.state.field(mi, !1);
  return !t || !t.active.some(
    (e) => e.state != 0
    /* State.Inactive */
  ) ? !1 : (n.dispatch({ effects: Ow.of(null) }), !0);
}, "closeCompletion");
var gd;
const XM = (gd = class {
  constructor(t, e) {
    this.active = t, this.context = e, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}, c(gd, "ec"), gd);
f(XM, "RunningQuery");
let yD = XM;
const mD = 50, wD = 1e3, gD = /* @__PURE__ */ Zs.fromClass(class {
  constructor(n) {
    this.view = n, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let t of n.state.field(mi).active)
      t.isPending && this.startQuery(t);
  }
  update(n) {
    let t = n.state.field(mi), e = n.state.facet(je);
    if (!n.selectionSet && !n.docChanged && n.startState.field(mi) == t)
      return;
    let i = n.transactions.some((r) => {
      let a = aS(r, e);
      return a & 8 || (r.selection || r.docChanged) && !(a & 3);
    });
    for (let r = 0; r < this.running.length; r++) {
      let a = this.running[r];
      if (i || a.context.abortOnDocChange && n.docChanged || a.updates.length + n.transactions.length > mD && Date.now() - a.time > wD) {
        for (let o of a.context.abortListeners)
          try {
            o();
          } catch (l) {
            Ci(this.view.state, l);
          }
        a.context.abortListeners = null, this.running.splice(r--, 1);
      } else
        a.updates.push(...n.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), n.transactions.some((r) => r.effects.some((a) => a.is(yv))) && (this.pendingStart = !0);
    let s = this.pendingStart ? 50 : e.activateOnTypingDelay;
    if (this.debounceUpdate = t.active.some((r) => r.isPending && !this.running.some((a) => a.active.source == r.source)) ? setTimeout(() => this.startUpdate(), s) : -1, this.composing != 0)
      for (let r of n.transactions)
        r.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && r.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: n } = this.view, t = n.field(mi);
    for (let e of t.active)
      e.isPending && !this.running.some((i) => i.active.source == e.source) && this.startQuery(e);
    this.running.length && t.open && t.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(je).updateSyncTime));
  }
  startQuery(n) {
    let { state: t } = this.view, e = Sr(t), i = new iS(t, e, n.explicit, this.view), s = new yD(n, i);
    this.running.push(s), Promise.resolve(n.source(i)).then((r) => {
      s.context.aborted || (s.done = r || null, this.scheduleAccept());
    }, (r) => {
      this.view.dispatch({ effects: Ow.of(null) }), Ci(this.view.state, r);
    });
  }
  scheduleAccept() {
    this.running.every((n) => n.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(je).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var n;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let t = [], e = this.view.state.facet(je), i = this.view.state.field(mi);
    for (let s = 0; s < this.running.length; s++) {
      let r = this.running[s];
      if (r.done === void 0)
        continue;
      if (this.running.splice(s--, 1), r.done) {
        let o = Sr(r.updates.length ? r.updates[0].startState : this.view.state), l = Math.min(o, r.done.from + (r.active.explicit ? 0 : 1)), h = new FM(r.active.source, r.active.explicit, l, r.done, r.done.from, (n = r.done.to) !== null && n !== void 0 ? n : o);
        for (let u of r.updates)
          h = h.update(u, e);
        if (h.hasResult()) {
          t.push(h);
          continue;
        }
      }
      let a = i.active.find((o) => o.source == r.active.source);
      if (a && a.isPending)
        if (r.done == null) {
          let o = new Fa(
            r.active.source,
            0
            /* State.Inactive */
          );
          for (let l of r.updates)
            o = o.update(l, e);
          o.isPending || t.push(o);
        } else
          this.startQuery(a);
    }
    (t.length || i.open && i.open.disabled) && this.view.dispatch({ effects: oS.of(t) });
  }
}, {
  eventHandlers: {
    blur(n) {
      let t = this.view.state.field(mi, !1);
      if (t && t.tooltip && this.view.state.facet(je).closeOnBlur) {
        let e = t.open && W5(this.view, t.open.tooltip);
        (!e || !e.dom.contains(n.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: Ow.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: yv.of(!1) }), 20), this.composing = 0;
    }
  }
}), vD = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), bD = /* @__PURE__ */ al.highest(/* @__PURE__ */ $t.domEventHandlers({
  keydown(n, t) {
    let e = t.state.field(mi, !1);
    if (!e || !e.open || e.open.disabled || e.open.selected < 0 || n.key.length > 1 || n.ctrlKey && !(vD && n.altKey) || n.metaKey)
      return !1;
    let i = e.open.options[e.open.selected], s = e.active.find((a) => a.source == i.source), r = i.completion.commitCharacters || s.result.commitCharacters;
    return r && r.indexOf(n.key) > -1 && kb(t, i), !1;
  }
})), NM = /* @__PURE__ */ $t.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
var vd;
const HM = (vd = class {
  constructor(t, e, i, s) {
    this.field = t, this.line = e, this.from = i, this.to = s;
  }
}, c(vd, "tc"), vd);
f(HM, "FieldPos");
let OD = HM;
var So;
const YM = (So = class {
  constructor(t, e, i) {
    this.field = t, this.from = e, this.to = i;
  }
  map(t) {
    let e = t.mapPos(this.from, -1, wi.TrackDel), i = t.mapPos(this.to, 1, wi.TrackDel);
    return e == null || i == null ? null : new So(this.field, e, i);
  }
}, c(So, "uo"), So);
f(YM, "FieldRange");
let $D = YM;
var Po;
const GM = (Po = class {
  constructor(t, e) {
    this.lines = t, this.fieldPositions = e;
  }
  instantiate(t, e) {
    let i = [], s = [e], r = t.doc.lineAt(e), a = /^\s*/.exec(r.text)[0];
    for (let l of this.lines) {
      if (i.length) {
        let h = a, u = /^\t*/.exec(l)[0].length;
        for (let p = 0; p < u; p++)
          h += t.facet($b);
        s.push(e + h.length - u), l = h + l.slice(u);
      }
      i.push(l), e += l.length + 1;
    }
    let o = this.fieldPositions.map((l) => new $D(l.field, s[l.line] + l.from, s[l.line] + l.to));
    return { text: i, ranges: o };
  }
  static parse(t) {
    let e = [], i = [], s = [], r;
    for (let a of t.split(/\r\n?|\n/)) {
      for (; r = /[#$]\{(?:(\d+)(?::([^{}]*))?|((?:\\[{}]|[^{}])*))\}/.exec(a); ) {
        let o = r[1] ? +r[1] : null, l = r[2] || r[3] || "", h = -1, u = l.replace(/\\[{}]/g, (p) => p[1]);
        for (let p = 0; p < e.length; p++)
          (o != null ? e[p].seq == o : u && e[p].name == u) && (h = p);
        if (h < 0) {
          let p = 0;
          for (; p < e.length && (o == null || e[p].seq != null && e[p].seq < o); )
            p++;
          e.splice(p, 0, { seq: o, name: u }), h = p;
          for (let y of s)
            y.field >= h && y.field++;
        }
        for (let p of s)
          if (p.line == i.length && p.from > r.index) {
            let y = r[2] ? 3 + (r[1] || "").length : 2;
            p.from -= y, p.to -= y;
          }
        s.push(new OD(h, i.length, r.index, r.index + u.length)), a = a.slice(0, r.index) + l + a.slice(r.index + r[0].length);
      }
      a = a.replace(/\\([{}])/g, (o, l, h) => {
        for (let u of s)
          u.line == i.length && u.from > h && (u.from--, u.to--);
        return l;
      }), i.push(a);
    }
    return new Po(i, s);
  }
}, c(Po, "Oo"), Po);
f(GM, "Snippet");
let xD = GM, kD = /* @__PURE__ */ ee.widget({ widget: /* @__PURE__ */ new class extends xy {
  toDOM() {
    let n = document.createElement("span");
    return n.className = "cm-snippetFieldPosition", n;
  }
  ignoreEvent() {
    return !1;
  }
}() }), SD = /* @__PURE__ */ ee.mark({ class: "cm-snippetField" });
var Co;
const KM = (Co = class {
  constructor(t, e) {
    this.ranges = t, this.active = e, this.deco = ee.set(t.map((i) => (i.from == i.to ? kD : SD).range(i.from, i.to)), !0);
  }
  map(t) {
    let e = [];
    for (let i of this.ranges) {
      let s = i.map(t);
      if (!s)
        return null;
      e.push(s);
    }
    return new Co(e, this.active);
  }
  selectionInsideField(t) {
    return t.ranges.every((e) => this.ranges.some((i) => i.field == this.active && i.from <= e.from && i.to >= e.to));
  }
}, c(Co, "po"), Co);
f(KM, "ActiveSnippet");
let Sb = KM;
const ig = /* @__PURE__ */ Bt.define({
  map(n, t) {
    return n && n.map(t);
  }
}), PD = /* @__PURE__ */ Bt.define(), $w = /* @__PURE__ */ Xs.define({
  create() {
    return null;
  },
  update(n, t) {
    for (let e of t.effects) {
      if (e.is(ig))
        return e.value;
      if (e.is(PD) && n)
        return new Sb(n.ranges, e.value);
    }
    return n && t.docChanged && (n = n.map(t.changes)), n && t.selection && !n.selectionInsideField(t.selection) && (n = null), n;
  },
  provide: /* @__PURE__ */ f((n) => $t.decorations.from(n, (t) => t ? t.deco : ee.none), "provide")
});
function Pb(n, t) {
  return J.create(n.filter((e) => e.field == t).map((e) => J.range(e.from, e.to)));
}
c(Pb, "yh");
f(Pb, "fieldSelection");
function JM(n) {
  let t = xD.parse(n);
  return (e, i, s, r) => {
    let { text: a, ranges: o } = t.instantiate(e.state, s), { main: l } = e.state.selection, h = {
      changes: { from: s, to: r == l.from ? l.to : r, insert: Vt.of(a) },
      scrollIntoView: !0,
      annotations: i ? [rS.of(i), gi.userEvent.of("input.complete")] : void 0
    };
    if (o.length && (h.selection = Pb(o, 0)), o.some((u) => u.field > 0)) {
      let u = new Sb(o, 0), p = h.effects = [ig.of(u)];
      e.state.field($w, !1) === void 0 && p.push(Bt.appendConfig.of([$w, AD, RD, NM]));
    }
    e.dispatch(e.state.update(h));
  };
}
c(JM, "Tb$1");
f(JM, "snippet");
function lS(n) {
  return ({ state: t, dispatch: e }) => {
    let i = t.field($w, !1);
    if (!i || n < 0 && i.active == 0)
      return !1;
    let s = i.active + n, r = n > 0 && !i.ranges.some((a) => a.field == s + n);
    return e(t.update({
      selection: Pb(i.ranges, s),
      effects: ig.of(r ? null : new Sb(i.ranges, s)),
      scrollIntoView: !0
    })), !0;
  };
}
c(lS, "bp$1");
f(lS, "moveField");
const CD = /* @__PURE__ */ f(({ state: n, dispatch: t }) => n.field($w, !1) ? (t(n.update({ effects: ig.of(null) })), !0) : !1, "clearSnippet"), QD = /* @__PURE__ */ lS(1), MD = /* @__PURE__ */ lS(-1), TD = [
  { key: "Tab", run: QD, shift: MD },
  { key: "Escape", run: CD }
], E4 = /* @__PURE__ */ gt.define({
  combine(n) {
    return n.length ? n[0] : TD;
  }
}), AD = /* @__PURE__ */ al.highest(/* @__PURE__ */ wb.compute([E4], (n) => n.facet(E4)));
function ui(n, t) {
  return { ...t, apply: JM(n) };
}
c(ui, "ge$2");
f(ui, "snippetCompletion");
const RD = /* @__PURE__ */ $t.domEventHandlers({
  mousedown(n, t) {
    let e = t.state.field($w, !1), i;
    if (!e || (i = t.posAtCoords({ x: n.clientX, y: n.clientY })) == null)
      return !1;
    let s = e.ranges.find((r) => r.from <= i && r.to >= i);
    return !s || s.field == e.active ? !1 : (t.dispatch({
      selection: Pb(e.ranges, s.field),
      effects: ig.of(e.ranges.some((r) => r.field > s.field) ? new Sb(e.ranges, s.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), tT = /* @__PURE__ */ new class extends Io {
}();
tT.startSide = 1;
tT.endSide = -1;
function ED(n = {}) {
  return [
    bD,
    mi,
    je.of(n),
    gD,
    zD,
    NM
  ];
}
c(ED, "Eb$1");
f(ED, "autocompletion");
const _D = [
  { key: "Ctrl-Space", run: RO },
  { mac: "Alt-`", run: RO },
  { mac: "Alt-i", run: RO },
  { key: "Escape", run: fD },
  { key: "ArrowDown", run: /* @__PURE__ */ bm(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ bm(!1) },
  { key: "PageDown", run: /* @__PURE__ */ bm(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ bm(!1, "page") },
  { key: "Enter", run: pD }
], zD = /* @__PURE__ */ al.highest(/* @__PURE__ */ wb.computeN([je], (n) => n.facet(je).defaultKeymap ? [_D] : []));
function LD(n) {
  let t = n.field(mi, !1);
  return t && t.active.some((e) => e.isPending) ? "pending" : t && t.active.some(
    (e) => e.state != 0
    /* State.Inactive */
  ) ? "active" : null;
}
c(LD, "Wb$1");
f(LD, "completionStatus");
var Qo;
const eT = (Qo = class {
  static create(t, e, i, s, r) {
    let a = s + (s << 8) + t + (e << 4) | 0;
    return new Qo(t, e, i, a, r, [], []);
  }
  constructor(t, e, i, s, r, a, o) {
    this.type = t, this.value = e, this.from = i, this.hash = s, this.end = r, this.children = a, this.positions = o, this.hashProp = [[xt.contextHash, s]];
  }
  addChild(t, e) {
    t.prop(xt.contextHash) != this.hash && (t = new Lt(t.type, t.children, t.positions, t.length, this.hashProp)), this.children.push(t), this.positions.push(e);
  }
  toTree(t, e = this.end) {
    let i = this.children.length - 1;
    return i >= 0 && (e = Math.max(e, this.positions[i] + this.children[i].length + this.from)), new Lt(t.types[this.type], this.children, this.positions, e - this.from).balance({
      makeTree: /* @__PURE__ */ f((s, r, a) => new Lt(Ue.none, s, r, a, this.hashProp), "makeTree")
    });
  }
}, c(Qo, "mo"), Qo);
f(eT, "CompositeBlock");
let _4 = eT;
var B;
(function(n) {
  n[n.Document = 1] = "Document", n[n.CodeBlock = 2] = "CodeBlock", n[n.FencedCode = 3] = "FencedCode", n[n.Blockquote = 4] = "Blockquote", n[n.HorizontalRule = 5] = "HorizontalRule", n[n.BulletList = 6] = "BulletList", n[n.OrderedList = 7] = "OrderedList", n[n.ListItem = 8] = "ListItem", n[n.ATXHeading1 = 9] = "ATXHeading1", n[n.ATXHeading2 = 10] = "ATXHeading2", n[n.ATXHeading3 = 11] = "ATXHeading3", n[n.ATXHeading4 = 12] = "ATXHeading4", n[n.ATXHeading5 = 13] = "ATXHeading5", n[n.ATXHeading6 = 14] = "ATXHeading6", n[n.SetextHeading1 = 15] = "SetextHeading1", n[n.SetextHeading2 = 16] = "SetextHeading2", n[n.HTMLBlock = 17] = "HTMLBlock", n[n.LinkReference = 18] = "LinkReference", n[n.Paragraph = 19] = "Paragraph", n[n.CommentBlock = 20] = "CommentBlock", n[n.ProcessingInstructionBlock = 21] = "ProcessingInstructionBlock", n[n.Escape = 22] = "Escape", n[n.Entity = 23] = "Entity", n[n.HardBreak = 24] = "HardBreak", n[n.Emphasis = 25] = "Emphasis", n[n.StrongEmphasis = 26] = "StrongEmphasis", n[n.Link = 27] = "Link", n[n.Image = 28] = "Image", n[n.InlineCode = 29] = "InlineCode", n[n.HTMLTag = 30] = "HTMLTag", n[n.Comment = 31] = "Comment", n[n.ProcessingInstruction = 32] = "ProcessingInstruction", n[n.Autolink = 33] = "Autolink", n[n.HeaderMark = 34] = "HeaderMark", n[n.QuoteMark = 35] = "QuoteMark", n[n.ListMark = 36] = "ListMark", n[n.LinkMark = 37] = "LinkMark", n[n.EmphasisMark = 38] = "EmphasisMark", n[n.CodeMark = 39] = "CodeMark", n[n.CodeText = 40] = "CodeText", n[n.CodeInfo = 41] = "CodeInfo", n[n.LinkTitle = 42] = "LinkTitle", n[n.LinkLabel = 43] = "LinkLabel", n[n.URL = 44] = "URL";
})(B || (B = {}));
var bd;
const iT = (bd = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.start = t, this.content = e, this.marks = [], this.parsers = [];
  }
}, c(bd, "ic"), bd);
f(iT, "LeafBlock");
let ID = iT;
var Od;
const nT = (Od = class {
  constructor() {
    this.text = "", this.baseIndent = 0, this.basePos = 0, this.depth = 0, this.markers = [], this.pos = 0, this.indent = 0, this.next = -1;
  }
  /**
  @internal
  */
  forward() {
    this.basePos > this.pos && this.forwardInner();
  }
  /**
  @internal
  */
  forwardInner() {
    let t = this.skipSpace(this.basePos);
    this.indent = this.countIndent(t, this.pos, this.indent), this.pos = t, this.next = t == this.text.length ? -1 : this.text.charCodeAt(t);
  }
  /**
  Skip whitespace after the given position, return the position of
  the next non-space character or the end of the line if there's
  only space after `from`.
  */
  skipSpace(t) {
    return Wc(this.text, t);
  }
  /**
  @internal
  */
  reset(t) {
    for (this.text = t, this.baseIndent = this.basePos = this.pos = this.indent = 0, this.forwardInner(), this.depth = 1; this.markers.length; )
      this.markers.pop();
  }
  /**
  Move the line's base position forward to the given position.
  This should only be called by composite [block
  parsers](#BlockParser.parse) or [markup skipping
  functions](#NodeSpec.composite).
  */
  moveBase(t) {
    this.basePos = t, this.baseIndent = this.countIndent(t, this.pos, this.indent);
  }
  /**
  Move the line's base position forward to the given _column_.
  */
  moveBaseColumn(t) {
    this.baseIndent = t, this.basePos = this.findColumn(t);
  }
  /**
  Store a composite-block-level marker. Should be called from
  [markup skipping functions](#NodeSpec.composite) when they
  consume any non-whitespace characters.
  */
  addMarker(t) {
    this.markers.push(t);
  }
  /**
  Find the column position at `to`, optionally starting at a given
  position and column.
  */
  countIndent(t, e = 0, i = 0) {
    for (let s = e; s < t; s++)
      i += this.text.charCodeAt(s) == 9 ? 4 - i % 4 : 1;
    return i;
  }
  /**
  Find the position corresponding to the given column.
  */
  findColumn(t) {
    let e = 0;
    for (let i = 0; e < this.text.length && i < t; e++)
      i += this.text.charCodeAt(e) == 9 ? 4 - i % 4 : 1;
    return e;
  }
  /**
  @internal
  */
  scrub() {
    if (!this.baseIndent)
      return this.text;
    let t = "";
    for (let e = 0; e < this.basePos; e++)
      t += " ";
    return t + this.text.slice(this.basePos);
  }
}, c(Od, "rc"), Od);
f(nT, "Line");
let ZD = nT;
function Ax(n, t, e) {
  if (e.pos == e.text.length || n != t.block && e.indent >= t.stack[e.depth + 1].value + e.baseIndent)
    return !0;
  if (e.indent >= e.baseIndent + 4)
    return !1;
  let i = (n.type == B.OrderedList ? Mb : Qb)(e, t, !1);
  return i > 0 && (n.type != B.BulletList || Cb(e, t, !1) < 0) && e.text.charCodeAt(e.pos + i - 1) == n.value;
}
c(Ax, "Yu$1");
f(Ax, "skipForList");
const sT = {
  [B.Blockquote](n, t, e) {
    return e.next != 62 ? !1 : (e.markers.push(Rt(B.QuoteMark, t.lineStart + e.pos, t.lineStart + e.pos + 1)), e.moveBase(e.pos + (Ui(e.text.charCodeAt(e.pos + 1)) ? 2 : 1)), n.end = t.lineStart + e.text.length, !0);
  },
  [B.ListItem](n, t, e) {
    return e.indent < e.baseIndent + n.value && e.next > -1 ? !1 : (e.moveBaseColumn(e.baseIndent + n.value), !0);
  },
  [B.OrderedList]: Ax,
  [B.BulletList]: Ax,
  [B.Document]() {
    return !0;
  }
};
function Ui(n) {
  return n == 32 || n == 9 || n == 10 || n == 13;
}
c(Ui, "Ve$1");
f(Ui, "space$2");
function Wc(n, t = 0) {
  for (; t < n.length && Ui(n.charCodeAt(t)); )
    t++;
  return t;
}
c(Wc, "xr$1");
f(Wc, "skipSpace");
function Rx(n, t, e) {
  for (; t > e && Ui(n.charCodeAt(t - 1)); )
    t--;
  return t;
}
c(Rx, "Iu$1");
f(Rx, "skipSpaceBack");
function cS(n) {
  if (n.next != 96 && n.next != 126)
    return -1;
  let t = n.pos + 1;
  for (; t < n.text.length && n.text.charCodeAt(t) == n.next; )
    t++;
  if (t < n.pos + 3)
    return -1;
  if (n.next == 96) {
    for (let e = t; e < n.text.length; e++)
      if (n.text.charCodeAt(e) == 96)
        return -1;
  }
  return t;
}
c(cS, "wp$1");
f(cS, "isFencedCode");
function hS(n) {
  return n.next != 62 ? -1 : n.text.charCodeAt(n.pos + 1) == 32 ? 2 : 1;
}
c(hS, "xp$1");
f(hS, "isBlockquote");
function Cb(n, t, e) {
  if (n.next != 42 && n.next != 45 && n.next != 95)
    return -1;
  let i = 1;
  for (let s = n.pos + 1; s < n.text.length; s++) {
    let r = n.text.charCodeAt(s);
    if (r == n.next)
      i++;
    else if (!Ui(r))
      return -1;
  }
  return e && n.next == 45 && pS(n) > -1 && n.depth == t.stack.length && t.parser.leafBlockParsers.indexOf(cT.SetextHeading) > -1 || i < 3 ? -1 : 1;
}
c(Cb, "bh");
f(Cb, "isHorizontalRule");
function dS(n, t) {
  for (let e = n.stack.length - 1; e >= 0; e--)
    if (n.stack[e].type == t)
      return !0;
  return !1;
}
c(dS, "kp$1");
f(dS, "inList");
function Qb(n, t, e) {
  return (n.next == 45 || n.next == 43 || n.next == 42) && (n.pos == n.text.length - 1 || Ui(n.text.charCodeAt(n.pos + 1))) && (!e || dS(t, B.BulletList) || n.skipSpace(n.pos + 2) < n.text.length) ? 1 : -1;
}
c(Qb, "Sh");
f(Qb, "isBulletList");
function Mb(n, t, e) {
  let i = n.pos, s = n.next;
  for (; s >= 48 && s <= 57; ) {
    if (i++, i == n.text.length)
      return -1;
    s = n.text.charCodeAt(i);
  }
  return i == n.pos || i > n.pos + 9 || s != 46 && s != 41 || i < n.text.length - 1 && !Ui(n.text.charCodeAt(i + 1)) || e && !dS(t, B.OrderedList) && (n.skipSpace(i + 1) == n.text.length || i > n.pos + 1 || n.next != 49) ? -1 : i + 1 - n.pos;
}
c(Mb, "Qh$1");
f(Mb, "isOrderedList");
function uS(n) {
  if (n.next != 35)
    return -1;
  let t = n.pos + 1;
  for (; t < n.text.length && n.text.charCodeAt(t) == 35; )
    t++;
  if (t < n.text.length && n.text.charCodeAt(t) != 32)
    return -1;
  let e = t - n.pos;
  return e > 6 ? -1 : e;
}
c(uS, "Pp$1");
f(uS, "isAtxHeading");
function pS(n) {
  if (n.next != 45 && n.next != 61 || n.indent >= n.baseIndent + 4)
    return -1;
  let t = n.pos + 1;
  for (; t < n.text.length && n.text.charCodeAt(t) == n.next; )
    t++;
  let e = t;
  for (; t < n.text.length && Ui(n.text.charCodeAt(t)); )
    t++;
  return t == n.text.length ? e : -1;
}
c(pS, "Rp$1");
f(pS, "isSetextUnderline");
const Ex = /^[ \t]*$/, rT = /-->/, aT = /\?>/, _x = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, rT],
  [/^\s*<\?/, aT],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, Ex],
  [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, Ex]
];
function fS(n, t, e) {
  if (n.next != 60)
    return -1;
  let i = n.text.slice(n.pos);
  for (let s = 0, r = _x.length - (e ? 1 : 0); s < r; s++)
    if (_x[s][0].test(i))
      return s;
  return -1;
}
c(fS, "Tp$1");
f(fS, "isHTMLBlock");
function zx(n, t) {
  let e = n.countIndent(t, n.pos, n.indent), i = n.countIndent(n.skipSpace(t), t, e);
  return i >= e + 5 ? e + 1 : i;
}
c(zx, "ju");
f(zx, "getListIndent");
function cr(n, t, e) {
  let i = n.length - 1;
  i >= 0 && n[i].to == t && n[i].type == B.CodeText ? n[i].to = e : n.push(Rt(B.CodeText, t, e));
}
c(cr, "Ut$2");
f(cr, "addCodeText");
const Zg = {
  LinkReference: void 0,
  IndentedCode(n, t) {
    let e = t.baseIndent + 4;
    if (t.indent < e)
      return !1;
    let i = t.findColumn(e), s = n.lineStart + i, r = n.lineStart + t.text.length, a = [], o = [];
    for (cr(a, s, r); n.nextLine() && t.depth >= n.stack.length; )
      if (t.pos == t.text.length) {
        cr(o, n.lineStart - 1, n.lineStart);
        for (let l of t.markers)
          o.push(l);
      } else {
        if (t.indent < e)
          break;
        {
          if (o.length) {
            for (let h of o)
              h.type == B.CodeText ? cr(a, h.from, h.to) : a.push(h);
            o = [];
          }
          cr(a, n.lineStart - 1, n.lineStart);
          for (let h of t.markers)
            a.push(h);
          r = n.lineStart + t.text.length;
          let l = n.lineStart + t.findColumn(t.baseIndent + 4);
          l < r && cr(a, l, r);
        }
      }
    return o.length && (o = o.filter((l) => l.type != B.CodeText), o.length && (t.markers = o.concat(t.markers))), n.addNode(n.buffer.writeElements(a, -s).finish(B.CodeBlock, r - s), s), !0;
  },
  FencedCode(n, t) {
    let e = cS(t);
    if (e < 0)
      return !1;
    let i = n.lineStart + t.pos, s = t.next, r = e - t.pos, a = t.skipSpace(e), o = Rx(t.text, t.text.length, a), l = [Rt(B.CodeMark, i, i + r)];
    a < o && l.push(Rt(B.CodeInfo, n.lineStart + a, n.lineStart + o));
    for (let h = !0; n.nextLine() && t.depth >= n.stack.length; h = !1) {
      let u = t.pos;
      if (t.indent - t.baseIndent < 4)
        for (; u < t.text.length && t.text.charCodeAt(u) == s; )
          u++;
      if (u - t.pos >= r && t.skipSpace(u) == t.text.length) {
        for (let p of t.markers)
          l.push(p);
        l.push(Rt(B.CodeMark, n.lineStart + t.pos, n.lineStart + u)), n.nextLine();
        break;
      } else {
        h || cr(l, n.lineStart - 1, n.lineStart);
        for (let m of t.markers)
          l.push(m);
        let p = n.lineStart + t.basePos, y = n.lineStart + t.text.length;
        p < y && cr(l, p, y);
      }
    }
    return n.addNode(n.buffer.writeElements(l, -i).finish(B.FencedCode, n.prevLineEnd() - i), i), !0;
  },
  Blockquote(n, t) {
    let e = hS(t);
    return e < 0 ? !1 : (n.startContext(B.Blockquote, t.pos), n.addNode(B.QuoteMark, n.lineStart + t.pos, n.lineStart + t.pos + 1), t.moveBase(t.pos + e), null);
  },
  HorizontalRule(n, t) {
    if (Cb(t, n, !1) < 0)
      return !1;
    let e = n.lineStart + t.pos;
    return n.nextLine(), n.addNode(B.HorizontalRule, e), !0;
  },
  BulletList(n, t) {
    let e = Qb(t, n, !1);
    if (e < 0)
      return !1;
    n.block.type != B.BulletList && n.startContext(B.BulletList, t.basePos, t.next);
    let i = zx(t, t.pos + 1);
    return n.startContext(B.ListItem, t.basePos, i - t.baseIndent), n.addNode(B.ListMark, n.lineStart + t.pos, n.lineStart + t.pos + e), t.moveBaseColumn(i), null;
  },
  OrderedList(n, t) {
    let e = Mb(t, n, !1);
    if (e < 0)
      return !1;
    n.block.type != B.OrderedList && n.startContext(B.OrderedList, t.basePos, t.text.charCodeAt(t.pos + e - 1));
    let i = zx(t, t.pos + e);
    return n.startContext(B.ListItem, t.basePos, i - t.baseIndent), n.addNode(B.ListMark, n.lineStart + t.pos, n.lineStart + t.pos + e), t.moveBaseColumn(i), null;
  },
  ATXHeading(n, t) {
    let e = uS(t);
    if (e < 0)
      return !1;
    let i = t.pos, s = n.lineStart + i, r = Rx(t.text, t.text.length, i), a = r;
    for (; a > i && t.text.charCodeAt(a - 1) == t.next; )
      a--;
    (a == r || a == i || !Ui(t.text.charCodeAt(a - 1))) && (a = t.text.length);
    let o = n.buffer.write(B.HeaderMark, 0, e).writeElements(n.parser.parseInline(t.text.slice(i + e + 1, a), s + e + 1), -s);
    a < t.text.length && o.write(B.HeaderMark, a - i, r - i);
    let l = o.finish(B.ATXHeading1 - 1 + e, t.text.length - i);
    return n.nextLine(), n.addNode(l, s), !0;
  },
  HTMLBlock(n, t) {
    let e = fS(t, n, !1);
    if (e < 0)
      return !1;
    let i = n.lineStart + t.pos, s = _x[e][1], r = [], a = s != Ex;
    for (; !s.test(t.text) && n.nextLine(); ) {
      if (t.depth < n.stack.length) {
        a = !1;
        break;
      }
      for (let h of t.markers)
        r.push(h);
    }
    a && n.nextLine();
    let o = s == rT ? B.CommentBlock : s == aT ? B.ProcessingInstructionBlock : B.HTMLBlock, l = n.prevLineEnd();
    return n.addNode(n.buffer.writeElements(r, -i).finish(o, l - i), i), !0;
  },
  SetextHeading: void 0
  // Specifies relative precedence for block-continue function
};
var $d;
const oT = ($d = class {
  constructor(t) {
    this.stage = 0, this.elts = [], this.pos = 0, this.start = t.start, this.advance(t.content);
  }
  nextLine(t, e, i) {
    if (this.stage == -1)
      return !1;
    let s = i.content + `
` + e.scrub(), r = this.advance(s);
    return r > -1 && r < s.length ? this.complete(t, i, r) : !1;
  }
  finish(t, e) {
    return (this.stage == 2 || this.stage == 3) && Wc(e.content, this.pos) == e.content.length ? this.complete(t, e, e.content.length) : !1;
  }
  complete(t, e, i) {
    return t.addLeafElement(e, Rt(B.LinkReference, this.start, this.start + i, this.elts)), !0;
  }
  nextStage(t) {
    return t ? (this.pos = t.to - this.start, this.elts.push(t), this.stage++, !0) : (t === !1 && (this.stage = -1), !1);
  }
  advance(t) {
    for (; ; ) {
      if (this.stage == -1)
        return -1;
      if (this.stage == 0) {
        if (!this.nextStage(gS(t, this.pos, this.start, !0)))
          return -1;
        if (t.charCodeAt(this.pos) != 58)
          return this.stage = -1;
        this.elts.push(Rt(B.LinkMark, this.pos + this.start, this.pos + this.start + 1)), this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(mS(t, Wc(t, this.pos), this.start)))
          return -1;
      } else if (this.stage == 2) {
        let e = Wc(t, this.pos), i = 0;
        if (e > this.pos) {
          let s = wS(t, e, this.start);
          if (s) {
            let r = c1(t, s.to - this.start);
            r > 0 && (this.nextStage(s), i = r);
          }
        }
        return i || (i = c1(t, this.pos)), i > 0 && i < t.length ? i : -1;
      } else
        return c1(t, this.pos);
    }
  }
}, c($d, "nc"), $d);
f(oT, "LinkReferenceParser");
let VD = oT;
function c1(n, t) {
  for (; t < n.length; t++) {
    let e = n.charCodeAt(t);
    if (e == 10)
      break;
    if (!Ui(e))
      return -1;
  }
  return t;
}
c(c1, "Xo$1");
f(c1, "lineEnd");
var xd;
const lT = (xd = class {
  nextLine(t, e, i) {
    let s = e.depth < t.stack.length ? -1 : pS(e), r = e.next;
    if (s < 0)
      return !1;
    let a = Rt(B.HeaderMark, t.lineStart + e.pos, t.lineStart + s);
    return t.nextLine(), t.addLeafElement(i, Rt(r == 61 ? B.SetextHeading1 : B.SetextHeading2, i.start, t.prevLineEnd(), [
      ...t.parser.parseInline(i.content, i.start),
      a
    ])), !0;
  }
  finish() {
    return !1;
  }
}, c(xd, "sc"), xd);
f(lT, "SetextHeadingParser");
let DD = lT;
const cT = {
  LinkReference(n, t) {
    return t.content.charCodeAt(0) == 91 ? new VD(t) : null;
  },
  SetextHeading() {
    return new DD();
  }
}, WD = [
  (n, t) => uS(t) >= 0,
  (n, t) => cS(t) >= 0,
  (n, t) => hS(t) >= 0,
  (n, t) => Qb(t, n, !0) >= 0,
  (n, t) => Mb(t, n, !0) >= 0,
  (n, t) => Cb(t, n, !0) >= 0,
  (n, t) => fS(t, n, !0) >= 0
], qD = { text: "", end: 0 };
var kd;
const hT = (kd = class {
  /**
  @internal
  */
  constructor(t, e, i, s) {
    this.parser = t, this.input = e, this.ranges = s, this.line = new ZD(), this.atEnd = !1, this.reusePlaceholders = /* @__PURE__ */ new Map(), this.stoppedAt = null, this.rangeI = 0, this.to = s[s.length - 1].to, this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = s[0].from, this.block = _4.create(B.Document, 0, this.lineStart, 0, 0), this.stack = [this.block], this.fragments = i.length ? new BD(i, e) : null, this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
      return this.finish();
    let { line: t } = this;
    for (; ; ) {
      for (let i = 0; ; ) {
        let s = t.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
        for (; i < t.markers.length && (!s || t.markers[i].from < s.end); ) {
          let r = t.markers[i++];
          this.addNode(r.type, r.from, r.to);
        }
        if (!s)
          break;
        this.finishContext();
      }
      if (t.pos < t.text.length)
        break;
      if (!this.nextLine())
        return this.finish();
    }
    if (this.fragments && this.reuseFragment(t.basePos))
      return null;
    t: for (; ; ) {
      for (let i of this.parser.blockParsers)
        if (i) {
          let s = i(this, t);
          if (s != !1) {
            if (s == !0)
              return null;
            t.forward();
            continue t;
          }
        }
      break;
    }
    let e = new ID(this.lineStart + t.pos, t.text.slice(t.pos));
    for (let i of this.parser.leafBlockParsers)
      if (i) {
        let s = i(this, e);
        s && e.parsers.push(s);
      }
    t: for (; this.nextLine() && t.pos != t.text.length; ) {
      if (t.indent < t.baseIndent + 4) {
        for (let i of this.parser.endLeafBlock)
          if (i(this, t, e))
            break t;
      }
      for (let i of e.parsers)
        if (i.nextLine(this, t, e))
          return null;
      e.content += `
` + t.scrub();
      for (let i of t.markers)
        e.marks.push(i);
    }
    return this.finishLeaf(e), null;
  }
  stopAt(t) {
    if (this.stoppedAt != null && this.stoppedAt < t)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = t;
  }
  reuseFragment(t) {
    if (!this.fragments.moveTo(this.absoluteLineStart + t, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
      return !1;
    let e = this.fragments.takeNodes(this);
    return e ? (this.absoluteLineStart += e, this.lineStart = vS(this.absoluteLineStart, this.ranges), this.moveRangeI(), this.absoluteLineStart < this.to ? (this.lineStart++, this.absoluteLineStart++, this.readLine()) : (this.atEnd = !0, this.readLine()), !0) : !1;
  }
  /**
  The number of parent blocks surrounding the current block.
  */
  get depth() {
    return this.stack.length;
  }
  /**
  Get the type of the parent block at the given depth. When no
  depth is passed, return the type of the innermost parent.
  */
  parentType(t = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[t].type];
  }
  /**
  Move to the next input line. This should only be called by
  (non-composite) [block parsers](#BlockParser.parse) that consume
  the line directly, or leaf block parser
  [`nextLine`](#LeafBlockParser.nextLine) methods when they
  consume the current line (and return true).
  */
  nextLine() {
    return this.lineStart += this.line.text.length, this.absoluteLineEnd >= this.to ? (this.absoluteLineStart = this.absoluteLineEnd, this.atEnd = !0, this.readLine(), !1) : (this.lineStart++, this.absoluteLineStart = this.absoluteLineEnd + 1, this.moveRangeI(), this.readLine(), !0);
  }
  /**
  Retrieve the text of the line after the current one, without
  actually moving the context's current line forward.
  */
  peekLine() {
    return this.scanLine(this.absoluteLineEnd + 1).text;
  }
  moveRangeI() {
    for (; this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to; )
      this.rangeI++, this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
  }
  /**
  @internal
  Collect the text for the next line.
  */
  scanLine(t) {
    let e = qD;
    if (e.end = t, t >= this.to)
      e.text = "";
    else if (e.text = this.lineChunkAt(t), e.end += e.text.length, this.ranges.length > 1) {
      let i = this.absoluteLineStart, s = this.rangeI;
      for (; this.ranges[s].to < e.end; ) {
        s++;
        let r = this.ranges[s].from, a = this.lineChunkAt(r);
        e.end = r + a.length, e.text = e.text.slice(0, this.ranges[s - 1].to - i) + a, i = e.end - e.text.length;
      }
    }
    return e;
  }
  /**
  @internal
  Populate this.line with the content of the next line. Skip
  leading characters covered by composite blocks.
  */
  readLine() {
    let { line: t } = this, { text: e, end: i } = this.scanLine(this.absoluteLineStart);
    for (this.absoluteLineEnd = i, t.reset(e); t.depth < this.stack.length; t.depth++) {
      let s = this.stack[t.depth], r = this.parser.skipContextMarkup[s.type];
      if (!r)
        throw new Error("Unhandled block context " + B[s.type]);
      if (!r(s, this, t))
        break;
      t.forward();
    }
  }
  lineChunkAt(t) {
    let e = this.input.chunk(t), i;
    if (this.input.lineChunks)
      i = e == `
` ? "" : e;
    else {
      let s = e.indexOf(`
`);
      i = s < 0 ? e : e.slice(0, s);
    }
    return t + i.length > this.to ? i.slice(0, this.to - t) : i;
  }
  /**
  The end position of the previous line.
  */
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  /**
  @internal
  */
  startContext(t, e, i = 0) {
    this.block = _4.create(t, i, this.lineStart + e, this.block.hash, this.lineStart + this.line.text.length), this.stack.push(this.block);
  }
  /**
  Start a composite block. Should only be called from [block
  parser functions](#BlockParser.parse) that return null.
  */
  startComposite(t, e, i = 0) {
    this.startContext(this.parser.getNodeType(t), e, i);
  }
  /**
  @internal
  */
  addNode(t, e, i) {
    typeof t == "number" && (t = new Lt(this.parser.nodeSet.types[t], Jf, Jf, (i ?? this.prevLineEnd()) - e)), this.block.addChild(t, e - this.block.from);
  }
  /**
  Add a block element. Can be called by [block
  parsers](#BlockParser.parse).
  */
  addElement(t) {
    this.block.addChild(t.toTree(this.parser.nodeSet), t.from - this.block.from);
  }
  /**
  Add a block element from a [leaf parser](#LeafBlockParser). This
  makes sure any extra composite block markup (such as blockquote
  markers) inside the block are also added to the syntax tree.
  */
  addLeafElement(t, e) {
    this.addNode(this.buffer.writeElements(wv(e.children, t.marks), -e.from).finish(e.type, e.to - e.from), e.from);
  }
  /**
  @internal
  */
  finishContext() {
    let t = this.stack.pop(), e = this.stack[this.stack.length - 1];
    e.addChild(t.toTree(this.parser.nodeSet), t.from - e.from), this.block = e;
  }
  finish() {
    for (; this.stack.length > 1; )
      this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(t) {
    return this.ranges.length > 1 ? yS(this.ranges, 0, t.topNode, this.ranges[0].from, this.reusePlaceholders) : t;
  }
  /**
  @internal
  */
  finishLeaf(t) {
    for (let i of t.parsers)
      if (i.finish(this, t))
        return;
    let e = wv(this.parser.parseInline(t.content, t.start), t.marks);
    this.addNode(this.buffer.writeElements(e, -t.start).finish(B.Paragraph, t.content.length), t.start);
  }
  elt(t, e, i, s) {
    return typeof t == "string" ? Rt(this.parser.getNodeType(t), e, i, s) : new wT(t, e);
  }
  /**
  @internal
  */
  get buffer() {
    return new yT(this.parser.nodeSet);
  }
}, c(kd, "oc"), kd);
f(hT, "BlockContext");
let jD = hT;
function yS(n, t, e, i, s) {
  let r = n[t].to, a = [], o = [], l = e.from + i;
  function h(u, p) {
    for (; p ? u >= r : u > r; ) {
      let y = n[t + 1].from - r;
      i += y, u += y, t++, r = n[t].to;
    }
  }
  c(h, "h"), f(h, "movePastNext");
  for (let u = e.firstChild; u; u = u.nextSibling) {
    h(u.from + i, !0);
    let p = u.from + i, y, m = s.get(u.tree);
    m ? y = m : u.to + i > r ? (y = yS(n, t, u, i, s), h(u.to + i, !1)) : y = u.toTree(), a.push(y), o.push(p - l);
  }
  return h(e.to + i, !1), new Lt(e.type, a, o, e.to + i - l, e.tree ? e.tree.propValues : void 0);
}
c(yS, "Zp$1");
f(yS, "injectGaps");
var Mo;
const dT = (Mo = class extends Ob {
  /**
  @internal
  */
  constructor(t, e, i, s, r, a, o, l, h) {
    super(), this.nodeSet = t, this.blockParsers = e, this.leafBlockParsers = i, this.blockNames = s, this.endLeafBlock = r, this.skipContextMarkup = a, this.inlineParsers = o, this.inlineNames = l, this.wrappers = h, this.nodeTypes = /* @__PURE__ */ Object.create(null);
    for (let u of t.types)
      this.nodeTypes[u.name] = u.id;
  }
  createParse(t, e, i) {
    let s = new jD(this, t, e, i);
    for (let r of this.wrappers)
      s = r(s, t, e, i);
    return s;
  }
  /**
  Reconfigure the parser.
  */
  configure(t) {
    let e = mv(t);
    if (!e)
      return this;
    let { nodeSet: i, skipContextMarkup: s } = this, r = this.blockParsers.slice(), a = this.leafBlockParsers.slice(), o = this.blockNames.slice(), l = this.inlineParsers.slice(), h = this.inlineNames.slice(), u = this.endLeafBlock.slice(), p = this.wrappers;
    if (cc(e.defineNodes)) {
      s = Object.assign({}, s);
      let y = i.types.slice(), m;
      for (let w of e.defineNodes) {
        let { name: b, block: $, composite: x, style: C } = typeof w == "string" ? { name: w } : w;
        if (y.some((A) => A.name == b))
          continue;
        x && (s[y.length] = (A, I, Z) => x(I, Z, A.value));
        let R = y.length, E = x ? ["Block", "BlockContext"] : $ ? R >= B.ATXHeading1 && R <= B.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"] : void 0;
        y.push(Ue.define({
          id: R,
          name: b,
          props: E && [[xt.group, E]]
        })), C && (m || (m = {}), Array.isArray(C) || C instanceof jn ? m[b] = C : Object.assign(m, C));
      }
      i = new gb(y), m && (i = i.extend(ol(m)));
    }
    if (cc(e.props) && (i = i.extend(...e.props)), cc(e.remove))
      for (let y of e.remove) {
        let m = this.blockNames.indexOf(y), w = this.inlineNames.indexOf(y);
        m > -1 && (r[m] = a[m] = void 0), w > -1 && (l[w] = void 0);
      }
    if (cc(e.parseBlock))
      for (let y of e.parseBlock) {
        let m = o.indexOf(y.name);
        if (m > -1)
          r[m] = y.parse, a[m] = y.leaf;
        else {
          let w = y.before ? Om(o, y.before) : y.after ? Om(o, y.after) + 1 : o.length - 1;
          r.splice(w, 0, y.parse), a.splice(w, 0, y.leaf), o.splice(w, 0, y.name);
        }
        y.endLeaf && u.push(y.endLeaf);
      }
    if (cc(e.parseInline))
      for (let y of e.parseInline) {
        let m = h.indexOf(y.name);
        if (m > -1)
          l[m] = y.parse;
        else {
          let w = y.before ? Om(h, y.before) : y.after ? Om(h, y.after) + 1 : h.length - 1;
          l.splice(w, 0, y.parse), h.splice(w, 0, y.name);
        }
      }
    return e.wrap && (p = p.concat(e.wrap)), new Mo(i, r, a, o, u, s, l, h, p);
  }
  /**
  @internal
  */
  getNodeType(t) {
    let e = this.nodeTypes[t];
    if (e == null)
      throw new RangeError(`Unknown node type '${t}'`);
    return e;
  }
  /**
  Parse the given piece of inline text at the given offset,
  returning an array of [`Element`](#Element) objects representing
  the inline content.
  */
  parseInline(t, e) {
    let i = new FD(this, t, e);
    t: for (let s = e; s < i.end; ) {
      let r = i.char(s);
      for (let a of this.inlineParsers)
        if (a) {
          let o = a(i, r, s);
          if (o >= 0) {
            s = o;
            continue t;
          }
        }
      s++;
    }
    return i.resolveMarkers(0);
  }
}, c(Mo, "go"), Mo);
f(dT, "MarkdownParser");
let uT = dT;
function cc(n) {
  return n != null && n.length > 0;
}
c(cc, "lr$1");
f(cc, "nonEmpty");
function mv(n) {
  if (!Array.isArray(n))
    return n;
  if (n.length == 0)
    return null;
  let t = mv(n[0]);
  if (n.length == 1)
    return t;
  let e = mv(n.slice(1));
  if (!e || !t)
    return t || e;
  let i = /* @__PURE__ */ f((a, o) => (a || Jf).concat(o || Jf), "conc"), s = t.wrap, r = e.wrap;
  return {
    props: i(t.props, e.props),
    defineNodes: i(t.defineNodes, e.defineNodes),
    parseBlock: i(t.parseBlock, e.parseBlock),
    parseInline: i(t.parseInline, e.parseInline),
    remove: i(t.remove, e.remove),
    wrap: s ? r ? (a, o, l, h) => s(r(a, o, l, h), o, l, h) : s : r
  };
}
c(mv, "La$1");
f(mv, "resolveConfig");
function Om(n, t) {
  let e = n.indexOf(t);
  if (e < 0)
    throw new RangeError(`Position specified relative to unknown parser ${t}`);
  return e;
}
c(Om, "jn$1");
f(Om, "findName");
let pT = [Ue.none];
for (let n = 1, t; t = B[n]; n++)
  pT[n] = Ue.define({
    id: n,
    name: t,
    props: n >= B.Escape ? [] : [[xt.group, n in sT ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
    top: t == "Document"
  });
const Jf = [];
var Sd;
const fT = (Sd = class {
  constructor(t) {
    this.nodeSet = t, this.content = [], this.nodes = [];
  }
  write(t, e, i, s = 0) {
    return this.content.push(t, e, i, 4 + s * 4), this;
  }
  writeElements(t, e = 0) {
    for (let i of t)
      i.writeTo(this, e);
    return this;
  }
  finish(t, e) {
    return Lt.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: t,
      length: e
    });
  }
}, c(Sd, "lc"), Sd);
f(fT, "Buffer");
let yT = fT;
var EO, Pd;
let xw = (EO = (Pd = class {
  /**
  @internal
  */
  constructor(t, e, i, s = Jf) {
    this.type = t, this.from = e, this.to = i, this.children = s;
  }
  /**
  @internal
  */
  writeTo(t, e) {
    let i = t.content.length;
    t.writeElements(this.children, e), t.content.push(this.type, this.from + e, this.to + e, t.content.length + 4 - i);
  }
  /**
  @internal
  */
  toTree(t) {
    return new yT(t).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
}, c(Pd, "Ci$1"), Pd), f(EO, "Element"), EO);
var Cd;
const mT = (Cd = class {
  constructor(t, e) {
    this.tree = t, this.from = e;
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return Jf;
  }
  writeTo(t, e) {
    t.nodes.push(this.tree), t.content.push(t.nodes.length - 1, this.from + e, this.to + e, -1);
  }
  toTree() {
    return this.tree;
  }
}, c(Cd, "ac"), Cd);
f(mT, "TreeElement");
let wT = mT;
function Rt(n, t, e, i) {
  return new xw(n, t, e, i);
}
c(Rt, "W$2");
f(Rt, "elt");
const gT = { resolve: "Emphasis", mark: "EmphasisMark" }, vT = { resolve: "Emphasis", mark: "EmphasisMark" }, hc = {}, Lx = {};
var Qd;
const bT = (Qd = class {
  constructor(t, e, i, s) {
    this.type = t, this.from = e, this.to = i, this.side = s;
  }
}, c(Qd, "hc"), Qd);
f(bT, "InlineDelimiter");
let Yi = bT;
const z4 = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
let kw = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  kw = new RegExp("[\\p{S}|\\p{P}]", "u");
} catch {
}
const _O = {
  Escape(n, t, e) {
    if (t != 92 || e == n.end - 1)
      return -1;
    let i = n.char(e + 1);
    for (let s = 0; s < z4.length; s++)
      if (z4.charCodeAt(s) == i)
        return n.append(Rt(B.Escape, e, e + 2));
    return -1;
  },
  Entity(n, t, e) {
    if (t != 38)
      return -1;
    let i = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(n.slice(e + 1, e + 31));
    return i ? n.append(Rt(B.Entity, e, e + 1 + i[0].length)) : -1;
  },
  InlineCode(n, t, e) {
    if (t != 96 || e && n.char(e - 1) == 96)
      return -1;
    let i = e + 1;
    for (; i < n.end && n.char(i) == 96; )
      i++;
    let s = i - e, r = 0;
    for (; i < n.end; i++)
      if (n.char(i) == 96) {
        if (r++, r == s && n.char(i + 1) != 96)
          return n.append(Rt(B.InlineCode, e, i + 1, [
            Rt(B.CodeMark, e, e + s),
            Rt(B.CodeMark, i + 1 - s, i + 1)
          ]));
      } else
        r = 0;
    return -1;
  },
  HTMLTag(n, t, e) {
    if (t != 60 || e == n.end - 1)
      return -1;
    let i = n.slice(e + 1, n.end), s = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(i);
    if (s)
      return n.append(Rt(B.Autolink, e, e + 1 + s[0].length, [
        Rt(B.LinkMark, e, e + 1),
        // url[0] includes the closing bracket, so exclude it from this slice
        Rt(B.URL, e + 1, e + s[0].length),
        Rt(B.LinkMark, e + s[0].length, e + 1 + s[0].length)
      ]));
    let r = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(i);
    if (r)
      return n.append(Rt(B.Comment, e, e + 1 + r[0].length));
    let a = /^\?[^]*?\?>/.exec(i);
    if (a)
      return n.append(Rt(B.ProcessingInstruction, e, e + 1 + a[0].length));
    let o = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(i);
    return o ? n.append(Rt(B.HTMLTag, e, e + 1 + o[0].length)) : -1;
  },
  Emphasis(n, t, e) {
    if (t != 95 && t != 42)
      return -1;
    let i = e + 1;
    for (; n.char(i) == t; )
      i++;
    let s = n.slice(e - 1, e), r = n.slice(i, i + 1), a = kw.test(s), o = kw.test(r), l = /\s|^$/.test(s), h = /\s|^$/.test(r), u = !h && (!o || l || a), p = !l && (!a || h || o), y = u && (t == 42 || !p || a), m = p && (t == 42 || !u || o);
    return n.append(new Yi(t == 95 ? gT : vT, e, i, (y ? 1 : 0) | (m ? 2 : 0)));
  },
  HardBreak(n, t, e) {
    if (t == 92 && n.char(e + 1) == 10)
      return n.append(Rt(B.HardBreak, e, e + 2));
    if (t == 32) {
      let i = e + 1;
      for (; n.char(i) == 32; )
        i++;
      if (n.char(i) == 10 && i >= e + 2)
        return n.append(Rt(B.HardBreak, e, i + 1));
    }
    return -1;
  },
  Link(n, t, e) {
    return t == 91 ? n.append(new Yi(
      hc,
      e,
      e + 1,
      1
      /* Mark.Open */
    )) : -1;
  },
  Image(n, t, e) {
    return t == 33 && n.char(e + 1) == 91 ? n.append(new Yi(
      Lx,
      e,
      e + 2,
      1
      /* Mark.Open */
    )) : -1;
  },
  LinkEnd(n, t, e) {
    if (t != 93)
      return -1;
    for (let i = n.parts.length - 1; i >= 0; i--) {
      let s = n.parts[i];
      if (s instanceof Yi && (s.type == hc || s.type == Lx)) {
        if (!s.side || n.skipSpace(s.to) == e && !/[(\[]/.test(n.slice(e + 1, e + 2)))
          return n.parts[i] = null, -1;
        let r = n.takeContent(i), a = n.parts[i] = OT(n, r, s.type == hc ? B.Link : B.Image, s.from, e + 1);
        if (s.type == hc)
          for (let o = 0; o < i; o++) {
            let l = n.parts[o];
            l instanceof Yi && l.type == hc && (l.side = 0);
          }
        return a.to;
      }
    }
    return -1;
  }
};
function OT(n, t, e, i, s) {
  let { text: r } = n, a = n.char(s), o = s;
  if (t.unshift(Rt(B.LinkMark, i, i + (e == B.Image ? 2 : 1))), t.push(Rt(B.LinkMark, s - 1, s)), a == 40) {
    let l = n.skipSpace(s + 1), h = mS(r, l - n.offset, n.offset), u;
    h && (l = n.skipSpace(h.to), l != h.to && (u = wS(r, l - n.offset, n.offset), u && (l = n.skipSpace(u.to)))), n.char(l) == 41 && (t.push(Rt(B.LinkMark, s, s + 1)), o = l + 1, h && t.push(h), u && t.push(u), t.push(Rt(B.LinkMark, l, o)));
  } else if (a == 91) {
    let l = gS(r, s - n.offset, n.offset, !1);
    l && (t.push(l), o = l.to);
  }
  return Rt(e, i, o, t);
}
c(OT, "Ib$1");
f(OT, "finishLink");
function mS(n, t, e) {
  if (n.charCodeAt(t) == 60) {
    for (let i = t + 1; i < n.length; i++) {
      let s = n.charCodeAt(i);
      if (s == 62)
        return Rt(B.URL, t + e, i + 1 + e);
      if (s == 60 || s == 10)
        return !1;
    }
    return null;
  } else {
    let i = 0, s = t;
    for (let r = !1; s < n.length; s++) {
      let a = n.charCodeAt(s);
      if (Ui(a))
        break;
      if (r)
        r = !1;
      else if (a == 40)
        i++;
      else if (a == 41) {
        if (!i)
          break;
        i--;
      } else a == 92 && (r = !0);
    }
    return s > t ? Rt(B.URL, t + e, s + e) : s == n.length ? null : !1;
  }
}
c(mS, "Cp$1");
f(mS, "parseURL");
function wS(n, t, e) {
  let i = n.charCodeAt(t);
  if (i != 39 && i != 34 && i != 40)
    return !1;
  let s = i == 40 ? 41 : i;
  for (let r = t + 1, a = !1; r < n.length; r++) {
    let o = n.charCodeAt(r);
    if (a)
      a = !1;
    else {
      if (o == s)
        return Rt(B.LinkTitle, t + e, r + 1 + e);
      o == 92 && (a = !0);
    }
  }
  return null;
}
c(wS, "Ep$1");
f(wS, "parseLinkTitle");
function gS(n, t, e, i) {
  for (let s = !1, r = t + 1, a = Math.min(n.length, r + 999); r < a; r++) {
    let o = n.charCodeAt(r);
    if (s)
      s = !1;
    else {
      if (o == 93)
        return i ? !1 : Rt(B.LinkLabel, t + e, r + 1 + e);
      if (i && !Ui(o) && (i = !1), o == 91)
        return !1;
      o == 92 && (s = !0);
    }
  }
  return null;
}
c(gS, "Vp$1");
f(gS, "parseLinkLabel");
var Md;
const $T = (Md = class {
  /**
  @internal
  */
  constructor(t, e, i) {
    this.parser = t, this.text = e, this.offset = i, this.parts = [];
  }
  /**
  Get the character code at the given (document-relative)
  position.
  */
  char(t) {
    return t >= this.end ? -1 : this.text.charCodeAt(t - this.offset);
  }
  /**
  The position of the end of this inline section.
  */
  get end() {
    return this.offset + this.text.length;
  }
  /**
  Get a substring of this inline section. Again uses
  document-relative positions.
  */
  slice(t, e) {
    return this.text.slice(t - this.offset, e - this.offset);
  }
  /**
  @internal
  */
  append(t) {
    return this.parts.push(t), t.to;
  }
  /**
  Add a [delimiter](#DelimiterType) at this given position. `open`
  and `close` indicate whether this delimiter is opening, closing,
  or both. Returns the end of the delimiter, for convenient
  returning from [parse functions](#InlineParser.parse).
  */
  addDelimiter(t, e, i, s, r) {
    return this.append(new Yi(t, e, i, (s ? 1 : 0) | (r ? 2 : 0)));
  }
  /**
  Returns true when there is an unmatched link or image opening
  token before the current position.
  */
  get hasOpenLink() {
    for (let t = this.parts.length - 1; t >= 0; t--) {
      let e = this.parts[t];
      if (e instanceof Yi && (e.type == hc || e.type == Lx))
        return !0;
    }
    return !1;
  }
  /**
  Add an inline element. Returns the end of the element.
  */
  addElement(t) {
    return this.append(t);
  }
  /**
  Resolve markers between this.parts.length and from, wrapping matched markers in the
  appropriate node and updating the content of this.parts. @internal
  */
  resolveMarkers(t) {
    for (let i = t; i < this.parts.length; i++) {
      let s = this.parts[i];
      if (!(s instanceof Yi && s.type.resolve && s.side & 2))
        continue;
      let r = s.type == gT || s.type == vT, a = s.to - s.from, o, l = i - 1;
      for (; l >= t; l--) {
        let w = this.parts[l];
        if (w instanceof Yi && w.side & 1 && w.type == s.type && // Ignore emphasis delimiters where the character count doesn't match
        !(r && (s.side & 1 || w.side & 2) && (w.to - w.from + a) % 3 == 0 && ((w.to - w.from) % 3 || a % 3))) {
          o = w;
          break;
        }
      }
      if (!o)
        continue;
      let h = s.type.resolve, u = [], p = o.from, y = s.to;
      if (r) {
        let w = Math.min(2, o.to - o.from, a);
        p = o.to - w, y = s.from + w, h = w == 1 ? "Emphasis" : "StrongEmphasis";
      }
      o.type.mark && u.push(this.elt(o.type.mark, p, o.to));
      for (let w = l + 1; w < i; w++)
        this.parts[w] instanceof xw && u.push(this.parts[w]), this.parts[w] = null;
      s.type.mark && u.push(this.elt(s.type.mark, s.from, y));
      let m = this.elt(h, p, y, u);
      this.parts[l] = r && o.from != p ? new Yi(o.type, o.from, p, o.side) : null, (this.parts[i] = r && s.to != y ? new Yi(s.type, y, s.to, s.side) : null) ? this.parts.splice(i, 0, m) : this.parts[i] = m;
    }
    let e = [];
    for (let i = t; i < this.parts.length; i++) {
      let s = this.parts[i];
      s instanceof xw && e.push(s);
    }
    return e;
  }
  /**
  Find an opening delimiter of the given type. Returns `null` if
  no delimiter is found, or an index that can be passed to
  [`takeContent`](#InlineContext.takeContent) otherwise.
  */
  findOpeningDelimiter(t) {
    for (let e = this.parts.length - 1; e >= 0; e--) {
      let i = this.parts[e];
      if (i instanceof Yi && i.type == t)
        return e;
    }
    return null;
  }
  /**
  Remove all inline elements and delimiters starting from the
  given index (which you should get from
  [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
  resolve delimiters inside of them, and return them as an array
  of elements.
  */
  takeContent(t) {
    let e = this.resolveMarkers(t);
    return this.parts.length = t, e;
  }
  /**
  Skip space after the given (document) position, returning either
  the position of the next non-space character or the end of the
  section.
  */
  skipSpace(t) {
    return Wc(this.text, t - this.offset) + this.offset;
  }
  elt(t, e, i, s) {
    return typeof t == "string" ? Rt(this.parser.getNodeType(t), e, i, s) : new wT(t, e);
  }
}, c(Md, "fc"), Md);
f($T, "InlineContext");
let FD = $T;
function wv(n, t) {
  if (!t.length)
    return n;
  if (!n.length)
    return t;
  let e = n.slice(), i = 0;
  for (let s of t) {
    for (; i < e.length && e[i].to < s.to; )
      i++;
    if (i < e.length && e[i].from < s.from) {
      let r = e[i];
      r instanceof xw && (e[i] = new xw(r.type, r.from, r.to, wv(r.children, [s])));
    } else
      e.splice(i++, 0, s);
  }
  return e;
}
c(wv, "Ca$1");
f(wv, "injectMarks");
const UD = [B.CodeBlock, B.ListItem, B.OrderedList, B.BulletList];
var zO, Td;
let BD = (zO = (Td = class {
  constructor(t, e) {
    this.fragments = t, this.input = e, this.i = 0, this.fragment = null, this.fragmentEnd = -1, this.cursor = null, t.length && (this.fragment = t[this.i++]);
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null, this.cursor = null, this.fragmentEnd = -1;
  }
  moveTo(t, e) {
    for (; this.fragment && this.fragment.to <= t; )
      this.nextFragment();
    if (!this.fragment || this.fragment.from > (t ? t - 1 : 0))
      return !1;
    if (this.fragmentEnd < 0) {
      let r = this.fragment.to;
      for (; r > 0 && this.input.read(r - 1, r) != `
`; )
        r--;
      this.fragmentEnd = r ? r - 1 : 0;
    }
    let i = this.cursor;
    i || (i = this.cursor = this.fragment.tree.cursor(), i.firstChild());
    let s = t + this.fragment.offset;
    for (; i.to <= s; )
      if (!i.parent())
        return !1;
    for (; ; ) {
      if (i.from >= s)
        return this.fragment.from <= e;
      if (!i.childAfter(s))
        return !1;
    }
  }
  matches(t) {
    let e = this.cursor.tree;
    return e && e.prop(xt.contextHash) == t;
  }
  takeNodes(t) {
    let e = this.cursor, i = this.fragment.offset, s = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0), r = t.absoluteLineStart, a = r, o = t.block.children.length, l = a, h = o;
    for (; ; ) {
      if (e.to - i > s) {
        if (e.type.isAnonymous && e.firstChild())
          continue;
        break;
      }
      let u = vS(e.from - i, t.ranges);
      if (e.to - i <= t.ranges[t.rangeI].to)
        t.addNode(e.tree, u);
      else {
        let p = new Lt(t.parser.nodeSet.types[B.Paragraph], [], [], 0, t.block.hashProp);
        t.reusePlaceholders.set(p, e.tree), t.addNode(p, u);
      }
      if (e.type.is("Block") && (UD.indexOf(e.type.id) < 0 ? (a = e.to - i, o = t.block.children.length) : (a = l, o = h, l = e.to - i, h = t.block.children.length)), !e.nextSibling())
        break;
    }
    for (; t.block.children.length > o; )
      t.block.children.pop(), t.block.positions.pop();
    return a - r;
  }
}, c(Td, "Ei$1"), Td), f(zO, "FragmentCursor"), zO);
function vS(n, t) {
  let e = n;
  for (let i = 1; i < t.length; i++) {
    let s = t[i - 1].to, r = t[i].from;
    s < n && (e -= r - s);
  }
  return e;
}
c(vS, "Up$1");
f(vS, "toRelative");
const XD = ol({
  "Blockquote/...": M.quote,
  HorizontalRule: M.contentSeparator,
  "ATXHeading1/... SetextHeading1/...": M.heading1,
  "ATXHeading2/... SetextHeading2/...": M.heading2,
  "ATXHeading3/...": M.heading3,
  "ATXHeading4/...": M.heading4,
  "ATXHeading5/...": M.heading5,
  "ATXHeading6/...": M.heading6,
  "Comment CommentBlock": M.comment,
  Escape: M.escape,
  Entity: M.character,
  "Emphasis/...": M.emphasis,
  "StrongEmphasis/...": M.strong,
  "Link/... Image/...": M.link,
  "OrderedList/... BulletList/...": M.list,
  "BlockQuote/...": M.quote,
  "InlineCode CodeText": M.monospace,
  "URL Autolink": M.url,
  "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": M.processingInstruction,
  "CodeInfo LinkLabel": M.labelName,
  LinkTitle: M.string,
  Paragraph: M.content
}), ND = new uT(new gb(pT).extend(XD), Object.keys(Zg).map((n) => Zg[n]), Object.keys(Zg).map((n) => cT[n]), Object.keys(Zg), WD, sT, Object.keys(_O).map((n) => _O[n]), Object.keys(_O), []);
function xT(n, t, e) {
  let i = [];
  for (let s = n.firstChild, r = t; ; s = s.nextSibling) {
    let a = s ? s.from : e;
    if (a > r && i.push({ from: r, to: a }), !s)
      break;
    r = s.to;
  }
  return i;
}
c(xT, "zb$1");
f(xT, "leftOverSpace");
function kT(n) {
  let { codeParser: t, htmlParser: e } = n;
  return { wrap: F5((i, s) => {
    let r = i.type.id;
    if (t && (r == B.CodeBlock || r == B.FencedCode)) {
      let a = "";
      if (r == B.FencedCode) {
        let l = i.node.getChild(B.CodeInfo);
        l && (a = s.read(l.from, l.to));
      }
      let o = t(a);
      if (o)
        return { parser: o, overlay: /* @__PURE__ */ f((l) => l.type.id == B.CodeText, "overlay") };
    } else if (e && (r == B.HTMLBlock || r == B.HTMLTag))
      return { parser: e, overlay: xT(i.node, i.from, i.to) };
    return null;
  }) };
}
c(kT, "Nb$1");
f(kT, "parseCode");
const HD = { resolve: "Strikethrough", mark: "StrikethroughMark" }, YD = {
  defineNodes: [{
    name: "Strikethrough",
    style: { "Strikethrough/...": M.strikethrough }
  }, {
    name: "StrikethroughMark",
    style: M.processingInstruction
  }],
  parseInline: [{
    name: "Strikethrough",
    parse(n, t, e) {
      if (t != 126 || n.char(e + 1) != 126 || n.char(e + 2) == 126)
        return -1;
      let i = n.slice(e - 1, e), s = n.slice(e + 2, e + 3), r = /\s|^$/.test(i), a = /\s|^$/.test(s), o = kw.test(i), l = kw.test(s);
      return n.addDelimiter(HD, e, e + 2, !a && (!l || r || o), !r && (!o || a || l));
    },
    after: "Emphasis"
  }]
};
function qc(n, t, e = 0, i, s = 0) {
  let r = 0, a = !0, o = -1, l = -1, h = !1, u = /* @__PURE__ */ f(() => {
    i.push(n.elt("TableCell", s + o, s + l, n.parser.parseInline(t.slice(o, l), s + o)));
  }, "parseCell");
  for (let p = e; p < t.length; p++) {
    let y = t.charCodeAt(p);
    y == 124 && !h ? ((!a || o > -1) && r++, a = !1, i && (o > -1 && u(), i.push(n.elt("TableDelimiter", p + s, p + s + 1))), o = l = -1) : (h || y != 32 && y != 9) && (o < 0 && (o = p), l = p + 1), h = !h && y == 92;
  }
  return o > -1 && (r++, i && u()), r;
}
c(qc, "kr$1");
f(qc, "parseRow");
function Ix(n, t) {
  for (let e = t; e < n.length; e++) {
    let i = n.charCodeAt(e);
    if (i == 124)
      return !0;
    i == 92 && e++;
  }
  return !1;
}
c(Ix, "Du$1");
f(Ix, "hasPipe");
const ST = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
var Ad;
const PT = (Ad = class {
  constructor() {
    this.rows = null;
  }
  nextLine(t, e, i) {
    if (this.rows == null) {
      this.rows = !1;
      let s;
      if ((e.next == 45 || e.next == 58 || e.next == 124) && ST.test(s = e.text.slice(e.pos))) {
        let r = [];
        qc(t, i.content, 0, r, i.start) == qc(t, s, e.pos) && (this.rows = [
          t.elt("TableHeader", i.start, i.start + i.content.length, r),
          t.elt("TableDelimiter", t.lineStart + e.pos, t.lineStart + e.text.length)
        ]);
      }
    } else if (this.rows) {
      let s = [];
      qc(t, e.text, e.pos, s, t.lineStart), this.rows.push(t.elt("TableRow", t.lineStart + e.pos, t.lineStart + e.text.length, s));
    }
    return !1;
  }
  finish(t, e) {
    return this.rows ? (t.addLeafElement(e, t.elt("Table", e.start, e.start + e.content.length, this.rows)), !0) : !1;
  }
}, c(Ad, "cc"), Ad);
f(PT, "TableParser");
let L4 = PT;
const GD = {
  defineNodes: [
    { name: "Table", block: !0 },
    { name: "TableHeader", style: { "TableHeader/...": M.heading } },
    "TableRow",
    { name: "TableCell", style: M.content },
    { name: "TableDelimiter", style: M.processingInstruction }
  ],
  parseBlock: [{
    name: "Table",
    leaf(n, t) {
      return Ix(t.content, 0) ? new L4() : null;
    },
    endLeaf(n, t, e) {
      if (e.parsers.some((s) => s instanceof L4) || !Ix(t.text, t.basePos))
        return !1;
      let i = n.peekLine();
      return ST.test(i) && qc(n, t.text, t.basePos) == qc(n, i, t.basePos);
    },
    before: "SetextHeading"
  }]
};
var Rd;
const CT = (Rd = class {
  nextLine() {
    return !1;
  }
  finish(t, e) {
    return t.addLeafElement(e, t.elt("Task", e.start, e.start + e.content.length, [
      t.elt("TaskMarker", e.start, e.start + 3),
      ...t.parser.parseInline(e.content.slice(3), e.start + 3)
    ])), !0;
  }
}, c(Rd, "uc"), Rd);
f(CT, "TaskParser");
let KD = CT;
const JD = {
  defineNodes: [
    { name: "Task", block: !0, style: M.list },
    { name: "TaskMarker", style: M.atom }
  ],
  parseBlock: [{
    name: "TaskList",
    leaf(n, t) {
      return /^\[[ xX]\][ \t]/.test(t.content) && n.parentType().name == "ListItem" ? new KD() : null;
    },
    after: "SetextHeading"
  }]
}, I4 = /(www\.)|(https?:\/\/)|([\w.+-]{1,100}@)|(mailto:|xmpp:)/gy, Z4 = /[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy, tW = /[\w-]+\.[\w-]+($|\/)/, V4 = /[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy, D4 = /\/[a-zA-Z\d@.]+/gy;
function Zx(n, t, e, i) {
  let s = 0;
  for (let r = t; r < e; r++)
    n[r] == i && s++;
  return s;
}
c(Zx, "Hu");
f(Zx, "count");
function QT(n, t) {
  Z4.lastIndex = t;
  let e = Z4.exec(n);
  if (!e || tW.exec(e[0])[0].indexOf("_") > -1)
    return -1;
  let i = t + e[0].length;
  for (; ; ) {
    let s = n[i - 1], r;
    if (/[?!.,:*_~]/.test(s) || s == ")" && Zx(n, t, i, ")") > Zx(n, t, i, "("))
      i--;
    else if (s == ";" && (r = /&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(n.slice(t, i))))
      i = t + r.index;
    else
      break;
  }
  return i;
}
c(QT, "e1$1");
f(QT, "autolinkURLEnd");
function Vx(n, t) {
  V4.lastIndex = t;
  let e = V4.exec(n);
  if (!e)
    return -1;
  let i = e[0][e[0].length - 1];
  return i == "_" || i == "-" ? -1 : t + e[0].length - (i == "." ? 1 : 0);
}
c(Vx, "Fu$1");
f(Vx, "autolinkEmailEnd");
const eW = {
  parseInline: [{
    name: "Autolink",
    parse(n, t, e) {
      let i = e - n.offset;
      if (i && /\w/.test(n.text[i - 1]))
        return -1;
      I4.lastIndex = i;
      let s = I4.exec(n.text), r = -1;
      if (!s)
        return -1;
      if (s[1] || s[2]) {
        if (r = QT(n.text, i + s[0].length), r > -1 && n.hasOpenLink) {
          let a = /([^\[\]]|\[[^\]]*\])*/.exec(n.text.slice(i, r));
          r = i + a[0].length;
        }
      } else s[3] ? r = Vx(n.text, i) : (r = Vx(n.text, i + s[0].length), r > -1 && s[0] == "xmpp:" && (D4.lastIndex = r, s = D4.exec(n.text), s && (r = s.index + s[0].length)));
      return r < 0 ? -1 : (n.addElement(n.elt("URL", e, r + n.offset)), r + n.offset);
    }
  }]
}, iW = [GD, JD, YD, eW];
function bS(n, t, e) {
  return (i, s, r) => {
    if (s != n || i.char(r + 1) == n)
      return -1;
    let a = [i.elt(e, r, r + 1)];
    for (let o = r + 1; o < i.end; o++) {
      let l = i.char(o);
      if (l == n)
        return i.addElement(i.elt(t, r, o + 1, a.concat(i.elt(e, o, o + 1))));
      if (l == 92 && a.push(i.elt("Escape", o, o++ + 2)), Ui(l))
        break;
    }
    return -1;
  };
}
c(bS, "Xp$1");
f(bS, "parseSubSuper");
const nW = {
  defineNodes: [
    { name: "Superscript", style: M.special(M.content) },
    { name: "SuperscriptMark", style: M.processingInstruction }
  ],
  parseInline: [{
    name: "Superscript",
    parse: bS(94, "Superscript", "SuperscriptMark")
  }]
}, sW = {
  defineNodes: [
    { name: "Subscript", style: M.special(M.content) },
    { name: "SubscriptMark", style: M.processingInstruction }
  ],
  parseInline: [{
    name: "Subscript",
    parse: bS(126, "Subscript", "SubscriptMark")
  }]
}, rW = {
  defineNodes: [{ name: "Emoji", style: M.character }],
  parseInline: [{
    name: "Emoji",
    parse(n, t, e) {
      let i;
      return t != 58 || !(i = /^[a-zA-Z_0-9]+:/.exec(n.slice(e + 1, n.end))) ? -1 : n.addElement(n.elt("Emoji", e, e + 1 + i[0].length));
    }
  }]
};
var Fr;
const MT = (Fr = class {
  /**
  @internal
  */
  constructor(t, e, i, s, r, a, o, l, h, u = 0, p) {
    this.p = t, this.stack = e, this.state = i, this.reducePos = s, this.pos = r, this.score = a, this.buffer = o, this.bufferBase = l, this.curContext = h, this.lookAhead = u, this.parent = p;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((t, e) => e % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(t, e, i = 0) {
    let s = t.parser.context;
    return new Fr(t, [], e, i, i, 0, [], 0, s ? new W4(s, s.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(t, e) {
    this.stack.push(this.state, e, this.bufferBase + this.buffer.length), this.state = t;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(t) {
    var e;
    let i = t >> 19, s = t & 65535, { parser: r } = this.p, a = this.reducePos < this.pos - 25;
    a && this.setLookAhead(this.pos);
    let o = r.dynamicPrecedence(s);
    if (o && (this.score += o), i == 0) {
      this.pushState(r.getGoto(this.state, s, !0), this.reducePos), s < r.minRepeatTerm && this.storeNode(s, this.reducePos, this.reducePos, a ? 8 : 4, !0), this.reduceContext(s, this.reducePos);
      return;
    }
    let l = this.stack.length - (i - 1) * 3 - (t & 262144 ? 6 : 0), h = l ? this.stack[l - 2] : this.p.ranges[0].from, u = this.reducePos - h;
    u >= 2e3 && !(!((e = this.p.parser.nodeSet.types[s]) === null || e === void 0) && e.isAnonymous) && (h == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = u) : this.p.lastBigReductionSize < u && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = h, this.p.lastBigReductionSize = u));
    let p = l ? this.stack[l - 1] : 0, y = this.bufferBase + this.buffer.length - p;
    if (s < r.minRepeatTerm || t & 131072) {
      let m = r.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(s, h, m, y + 4, !0);
    }
    if (t & 262144)
      this.state = this.stack[l];
    else {
      let m = this.stack[l - 3];
      this.state = r.getGoto(m, s, !0);
    }
    for (; this.stack.length > l; )
      this.stack.pop();
    this.reduceContext(s, h);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(t, e, i, s = 4, r = !1) {
    if (t == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let a = this, o = this.buffer.length;
      if (o == 0 && a.parent && (o = a.bufferBase - a.parent.bufferBase, a = a.parent), o > 0 && a.buffer[o - 4] == 0 && a.buffer[o - 1] > -1) {
        if (e == i)
          return;
        if (a.buffer[o - 2] >= e) {
          a.buffer[o - 2] = i;
          return;
        }
      }
    }
    if (!r || this.pos == i)
      this.buffer.push(t, e, i, s);
    else {
      let a = this.buffer.length;
      if (a > 0 && this.buffer[a - 4] != 0) {
        let o = !1;
        for (let l = a; l > 0 && this.buffer[l - 2] > i; l -= 4)
          if (this.buffer[l - 1] >= 0) {
            o = !0;
            break;
          }
        if (o)
          for (; a > 0 && this.buffer[a - 2] > i; )
            this.buffer[a] = this.buffer[a - 4], this.buffer[a + 1] = this.buffer[a - 3], this.buffer[a + 2] = this.buffer[a - 2], this.buffer[a + 3] = this.buffer[a - 1], a -= 4, s > 4 && (s -= 4);
      }
      this.buffer[a] = t, this.buffer[a + 1] = e, this.buffer[a + 2] = i, this.buffer[a + 3] = s;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(t, e, i, s) {
    if (t & 131072)
      this.pushState(t & 65535, this.pos);
    else if ((t & 262144) == 0) {
      let r = t, { parser: a } = this.p;
      (s > this.pos || e <= a.maxNode) && (this.pos = s, a.stateFlag(
        r,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = s)), this.pushState(r, i), this.shiftContext(e, i), e <= a.maxNode && this.buffer.push(e, i, s, 4);
    } else
      this.pos = s, this.shiftContext(e, i), e <= this.p.parser.maxNode && this.buffer.push(e, i, s, 4);
  }
  // Apply an action
  /**
  @internal
  */
  apply(t, e, i, s) {
    t & 65536 ? this.reduce(t) : this.shift(t, e, i, s);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(t, e) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != t) && (this.p.reused.push(t), i++);
    let s = this.pos;
    this.reducePos = this.pos = s + t.length, this.pushState(e, s), this.buffer.push(
      i,
      s,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, t, this, this.p.stream.reset(this.pos - t.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let t = this, e = t.buffer.length;
    for (; e > 0 && t.buffer[e - 2] > t.reducePos; )
      e -= 4;
    let i = t.buffer.slice(e), s = t.bufferBase + e;
    for (; t && s == t.bufferBase; )
      t = t.parent;
    return new Fr(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, s, this.curContext, this.lookAhead, t);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(t, e) {
    let i = t <= this.p.parser.maxNode;
    i && this.storeNode(t, this.pos, e, 4), this.storeNode(0, this.pos, e, i ? 8 : 4), this.pos = this.reducePos = e, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(t) {
    for (let e = new oW(this); ; ) {
      let i = this.p.parser.stateSlot(
        e.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(e.state, t);
      if (i == 0)
        return !1;
      if ((i & 65536) == 0)
        return !0;
      e.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(t) {
    if (this.stack.length >= 300)
      return [];
    let e = this.p.parser.nextStates(this.state);
    if (e.length > 8 || this.stack.length >= 120) {
      let s = [];
      for (let r = 0, a; r < e.length; r += 2)
        (a = e[r + 1]) != this.state && this.p.parser.hasAction(a, t) && s.push(e[r], a);
      if (this.stack.length < 120)
        for (let r = 0; s.length < 8 && r < e.length; r += 2) {
          let a = e[r + 1];
          s.some((o, l) => l & 1 && o == a) || s.push(e[r], a);
        }
      e = s;
    }
    let i = [];
    for (let s = 0; s < e.length && i.length < 4; s += 2) {
      let r = e[s + 1];
      if (r == this.state)
        continue;
      let a = this.split();
      a.pushState(r, this.pos), a.storeNode(0, a.pos, a.pos, 4, !0), a.shiftContext(e[s], this.pos), a.reducePos = this.pos, a.score -= 200, i.push(a);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: t } = this.p, e = t.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((e & 65536) == 0)
      return !1;
    if (!t.validAction(this.state, e)) {
      let i = e >> 19, s = e & 65535, r = this.stack.length - i * 3;
      if (r < 0 || t.getGoto(this.stack[r], s, !1) < 0) {
        let a = this.findForcedReduction();
        if (a == null)
          return !1;
        e = a;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(e), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: t } = this.p, e = [], i = /* @__PURE__ */ f((s, r) => {
      if (!e.includes(s))
        return e.push(s), t.allActions(s, (a) => {
          if (!(a & 393216)) if (a & 65536) {
            let o = (a >> 19) - r;
            if (o > 1) {
              let l = a & 65535, h = this.stack.length - o * 3;
              if (h >= 0 && t.getGoto(this.stack[h], l, !1) >= 0)
                return o << 19 | 65536 | l;
            }
          } else {
            let o = i(a, r + 1);
            if (o != null)
              return o;
          }
        });
    }, "explore");
    return i(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: t } = this.p;
    return t.data[t.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !t.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(t) {
    if (this.state != t.state || this.stack.length != t.stack.length)
      return !1;
    for (let e = 0; e < this.stack.length; e += 3)
      if (this.stack[e] != t.stack[e])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(t) {
    return this.p.parser.dialect.flags[t];
  }
  shiftContext(t, e) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, t, this, this.p.stream.reset(e)));
  }
  reduceContext(t, e) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, t, this, this.p.stream.reset(e)));
  }
  /**
  @internal
  */
  emitContext() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(t) {
    if (t != this.curContext.context) {
      let e = new W4(this.curContext.tracker, t);
      e.hash != this.curContext.hash && this.emitContext(), this.curContext = e;
    }
  }
  /**
  @internal
  */
  setLookAhead(t) {
    t > this.lookAhead && (this.emitLookAhead(), this.lookAhead = t);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}, c(Fr, "qr"), Fr);
f(MT, "Stack");
let aW = MT;
var Ed;
const TT = (Ed = class {
  constructor(t, e) {
    this.tracker = t, this.context = e, this.hash = t.strict ? t.hash(e) : 0;
  }
}, c(Ed, "dc"), Ed);
f(TT, "StackContext");
let W4 = TT;
var _d;
const AT = (_d = class {
  constructor(t) {
    this.start = t, this.state = t.state, this.stack = t.stack, this.base = this.stack.length;
  }
  reduce(t) {
    let e = t & 65535, i = t >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let s = this.start.p.parser.getGoto(this.stack[this.base - 3], e, !0);
    this.state = s;
  }
}, c(_d, "Oc"), _d);
f(AT, "SimulatedStack");
let oW = AT;
var Ur;
const RT = (Ur = class {
  constructor(t, e, i) {
    this.stack = t, this.pos = e, this.index = i, this.buffer = t.buffer, this.index == 0 && this.maybeNext();
  }
  static create(t, e = t.bufferBase + t.buffer.length) {
    return new Ur(t, e, e - t.bufferBase);
  }
  maybeNext() {
    let t = this.stack.parent;
    t != null && (this.index = this.stack.bufferBase - t.bufferBase, this.stack = t, this.buffer = t.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new Ur(this.stack, this.pos, this.index);
  }
}, c(Ur, "Dr"), Ur);
f(RT, "StackBufferCursor");
let lW = RT;
function _c(n, t = Uint16Array) {
  if (typeof n != "string")
    return n;
  let e = null;
  for (let i = 0, s = 0; i < n.length; ) {
    let r = 0;
    for (; ; ) {
      let a = n.charCodeAt(i++), o = !1;
      if (a == 126) {
        r = 65535;
        break;
      }
      a >= 92 && a--, a >= 34 && a--;
      let l = a - 32;
      if (l >= 46 && (l -= 46, o = !0), r += l, o)
        break;
      r *= 46;
    }
    e ? e[s++] = r : e = new t(r);
  }
  return e;
}
c(_c, "pr$1");
f(_c, "decodeArray");
var zd;
const ET = (zd = class {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}, c(zd, "pc"), zd);
f(ET, "CachedToken");
let h1 = ET;
const q4 = new h1();
var Ld;
const _T = (Ld = class {
  /**
  @internal
  */
  constructor(t, e) {
    this.input = t, this.ranges = e, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = q4, this.rangeIndex = 0, this.pos = this.chunkPos = e[0].from, this.range = e[0], this.end = e[e.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(t, e) {
    let i = this.range, s = this.rangeIndex, r = this.pos + t;
    for (; r < i.from; ) {
      if (!s)
        return null;
      let a = this.ranges[--s];
      r -= i.from - a.to, i = a;
    }
    for (; e < 0 ? r > i.to : r >= i.to; ) {
      if (s == this.ranges.length - 1)
        return null;
      let a = this.ranges[++s];
      r += a.from - i.to, i = a;
    }
    return r;
  }
  /**
  @internal
  */
  clipPos(t) {
    if (t >= this.range.from && t < this.range.to)
      return t;
    for (let e of this.ranges)
      if (e.to > t)
        return Math.max(t, e.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(t) {
    let e = this.chunkOff + t, i, s;
    if (e >= 0 && e < this.chunk.length)
      i = this.pos + t, s = this.chunk.charCodeAt(e);
    else {
      let r = this.resolveOffset(t, 1);
      if (r == null)
        return -1;
      if (i = r, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        s = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let a = this.rangeIndex, o = this.range;
        for (; o.to <= i; )
          o = this.ranges[++a];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > o.to && (this.chunk2 = this.chunk2.slice(0, o.to - i)), s = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), s;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(t, e = 0) {
    let i = e ? this.resolveOffset(e, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = t, this.token.end = i;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(t, e) {
    this.token.value = t, this.token.end = e;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: t, chunkPos: e } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = t, this.chunk2Pos = e, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let t = this.input.chunk(this.pos), e = this.pos + t.length;
      this.chunk = e > this.range.to ? t.slice(0, this.range.to - this.pos) : t, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(t = 1) {
    for (this.chunkOff += t; this.pos + t >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      t -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += t, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(t, e) {
    if (e ? (this.token = e, e.start = t, e.lookAhead = t + 1, e.value = e.extended = -1) : this.token = q4, this.pos != t) {
      if (this.pos = t, t == this.end)
        return this.setDone(), this;
      for (; t < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; t >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      t >= this.chunkPos && t < this.chunkPos + this.chunk.length ? this.chunkOff = t - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(t, e) {
    if (t >= this.chunkPos && e <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(t - this.chunkPos, e - this.chunkPos);
    if (t >= this.chunk2Pos && e <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(t - this.chunk2Pos, e - this.chunk2Pos);
    if (t >= this.range.from && e <= this.range.to)
      return this.input.read(t, e);
    let i = "";
    for (let s of this.ranges) {
      if (s.from >= e)
        break;
      s.to > t && (i += this.input.read(Math.max(s.from, t), Math.min(s.to, e)));
    }
    return i;
  }
}, c(Ld, "mc"), Ld);
f(_T, "InputStream");
let cW = _T;
var Id;
const zT = (Id = class {
  constructor(t, e) {
    this.data = t, this.id = e;
  }
  token(t, e) {
    let { parser: i } = e.p;
    OS(this.data, t, e, this.id, i.data, i.tokenPrecTable);
  }
}, c(Id, "gc"), Id);
f(zT, "TokenGroup");
let jc = zT;
jc.prototype.contextual = jc.prototype.fallback = jc.prototype.extend = !1;
var Zd;
const LT = (Zd = class {
  constructor(t, e, i) {
    this.precTable = e, this.elseToken = i, this.data = typeof t == "string" ? _c(t) : t;
  }
  token(t, e) {
    let i = t.pos, s = 0;
    for (; ; ) {
      let r = t.next < 0, a = t.resolveOffset(1, 1);
      if (OS(this.data, t, e, 0, this.data, this.precTable), t.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (r || s++, a == null)
        break;
      t.reset(a, t.token);
    }
    s && (t.reset(i, t.token), t.acceptToken(this.elseToken, s));
  }
}, c(Zd, "yc"), Zd);
f(LT, "LocalTokenGroup");
let gv = LT;
gv.prototype.contextual = jc.prototype.fallback = jc.prototype.extend = !1;
var Vd;
const IT = (Vd = class {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(t, e = {}) {
    this.token = t, this.contextual = !!e.contextual, this.fallback = !!e.fallback, this.extend = !!e.extend;
  }
}, c(Vd, "bc"), Vd);
f(IT, "ExternalTokenizer");
let dn = IT;
function OS(n, t, e, i, s, r) {
  let a = 0, o = 1 << i, { dialect: l } = e.p.parser;
  t: for (; (o & n[a]) != 0; ) {
    let h = n[a + 1];
    for (let m = a + 3; m < h; m += 2)
      if ((n[m + 1] & o) > 0) {
        let w = n[m];
        if (l.allows(w) && (t.token.value == -1 || t.token.value == w || ZT(w, t.token.value, s, r))) {
          t.acceptToken(w);
          break;
        }
      }
    let u = t.next, p = 0, y = n[a + 2];
    if (t.next < 0 && y > p && n[h + y * 3 - 3] == 65535) {
      a = n[h + y * 3 - 1];
      continue t;
    }
    for (; p < y; ) {
      let m = p + y >> 1, w = h + m + (m << 1), b = n[w], $ = n[w + 1] || 65536;
      if (u < b)
        y = m;
      else if (u >= $)
        p = m + 1;
      else {
        a = n[w + 2], t.advance();
        continue t;
      }
    }
    break;
  }
}
c(OS, "Yp$1");
f(OS, "readToken");
function Dx(n, t, e) {
  for (let i = t, s; (s = n[i]) != 65535; i++)
    if (s == e)
      return i - t;
  return -1;
}
c(Dx, "Ju$1");
f(Dx, "findOffset");
function ZT(n, t, e, i) {
  let s = Dx(e, i, t);
  return s < 0 || Dx(e, i, n) < s;
}
c(ZT, "o1$1");
f(ZT, "overrides");
const Li = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let LO = null;
function Wx(n, t, e) {
  let i = n.cursor(Yt.IncludeAnonymous);
  for (i.moveTo(t); ; )
    if (!(e < 0 ? i.childBefore(t) : i.childAfter(t)))
      for (; ; ) {
        if ((e < 0 ? i.to < t : i.from > t) && !i.type.isError)
          return e < 0 ? Math.max(0, Math.min(
            i.to - 1,
            t - 25
            /* Lookahead.Margin */
          )) : Math.min(n.length, Math.max(
            i.from + 1,
            t + 25
            /* Lookahead.Margin */
          ));
        if (e < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return e < 0 ? 0 : n.length;
      }
}
c(Wx, "ed$1");
f(Wx, "cutAt");
var Dd;
const VT = (Dd = class {
  constructor(t, e) {
    this.fragments = t, this.nodeSet = e, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let t = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (t) {
      for (this.safeFrom = t.openStart ? Wx(t.tree, t.from + t.offset, 1) - t.offset : t.from, this.safeTo = t.openEnd ? Wx(t.tree, t.to + t.offset, -1) - t.offset : t.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(t.tree), this.start.push(-t.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(t) {
    if (t < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= t; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let e = this.trees.length - 1;
      if (e < 0)
        return this.nextFragment(), null;
      let i = this.trees[e], s = this.index[e];
      if (s == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let r = i.children[s], a = this.start[e] + i.positions[s];
      if (a > t)
        return this.nextStart = a, null;
      if (r instanceof Lt) {
        if (a == t) {
          if (a < this.safeFrom)
            return null;
          let o = a + r.length;
          if (o <= this.safeTo) {
            let l = r.prop(xt.lookAhead);
            if (!l || o + l < this.fragment.to)
              return r;
          }
        }
        this.index[e]++, a + r.length >= Math.max(this.safeFrom, t) && (this.trees.push(r), this.start.push(a), this.index.push(0));
      } else
        this.index[e]++, this.nextStart = a + r.length;
    }
  }
}, c(Dd, "Sc"), Dd);
f(VT, "FragmentCursor");
let hW = VT;
var Wd;
const DT = (Wd = class {
  constructor(t, e) {
    this.stream = e, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = t.tokenizers.map((i) => new h1());
  }
  getActions(t) {
    let e = 0, i = null, { parser: s } = t.p, { tokenizers: r } = s, a = s.stateSlot(
      t.state,
      3
      /* ParseState.TokenizerMask */
    ), o = t.curContext ? t.curContext.hash : 0, l = 0;
    for (let h = 0; h < r.length; h++) {
      if ((1 << h & a) == 0)
        continue;
      let u = r[h], p = this.tokens[h];
      if (!(i && !u.fallback) && ((u.contextual || p.start != t.pos || p.mask != a || p.context != o) && (this.updateCachedToken(p, u, t), p.mask = a, p.context = o), p.lookAhead > p.end + 25 && (l = Math.max(p.lookAhead, l)), p.value != 0)) {
        let y = e;
        if (p.extended > -1 && (e = this.addActions(t, p.extended, p.end, e)), e = this.addActions(t, p.value, p.end, e), !u.extend && (i = p, e > y))
          break;
      }
    }
    for (; this.actions.length > e; )
      this.actions.pop();
    return l && t.setLookAhead(l), !i && t.pos == this.stream.end && (i = new h1(), i.value = t.p.parser.eofTerm, i.start = i.end = t.pos, e = this.addActions(t, i.value, i.end, e)), this.mainToken = i, this.actions;
  }
  getMainToken(t) {
    if (this.mainToken)
      return this.mainToken;
    let e = new h1(), { pos: i, p: s } = t;
    return e.start = i, e.end = Math.min(i + 1, s.stream.end), e.value = i == s.stream.end ? s.parser.eofTerm : 0, e;
  }
  updateCachedToken(t, e, i) {
    let s = this.stream.clipPos(i.pos);
    if (e.token(this.stream.reset(s, t), i), t.value > -1) {
      let { parser: r } = i.p;
      for (let a = 0; a < r.specialized.length; a++)
        if (r.specialized[a] == t.value) {
          let o = r.specializers[a](this.stream.read(t.start, t.end), i);
          if (o >= 0 && i.p.parser.dialect.allows(o >> 1)) {
            (o & 1) == 0 ? t.value = o >> 1 : t.extended = o >> 1;
            break;
          }
        }
    } else
      t.value = 0, t.end = this.stream.clipPos(s + 1);
  }
  putAction(t, e, i, s) {
    for (let r = 0; r < s; r += 3)
      if (this.actions[r] == t)
        return s;
    return this.actions[s++] = t, this.actions[s++] = e, this.actions[s++] = i, s;
  }
  addActions(t, e, i, s) {
    let { state: r } = t, { parser: a } = t.p, { data: o } = a;
    for (let l = 0; l < 2; l++)
      for (let h = a.stateSlot(
        r,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; h += 3) {
        if (o[h] == 65535)
          if (o[h + 1] == 1)
            h = Fn(o, h + 2);
          else {
            s == 0 && o[h + 1] == 2 && (s = this.putAction(Fn(o, h + 2), e, i, s));
            break;
          }
        o[h] == e && (s = this.putAction(Fn(o, h + 1), e, i, s));
      }
    return s;
  }
}, c(Wd, "Qc"), Wd);
f(DT, "TokenCache");
let dW = DT;
var qd;
const WT = (qd = class {
  constructor(t, e, i, s) {
    this.parser = t, this.input = e, this.ranges = s, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new cW(e, s), this.tokens = new dW(t, this.stream), this.topTerm = t.top[1];
    let { from: r } = s[0];
    this.stacks = [aW.start(this, t.top[0], r)], this.fragments = i.length && this.stream.end - r > t.bufferLength * 4 ? new hW(i, t.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let t = this.stacks, e = this.minStackPos, i = this.stacks = [], s, r;
    if (this.bigReductionCount > 300 && t.length == 1) {
      let [a] = t;
      for (; a.forceReduce() && a.stack.length && a.stack[a.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let a = 0; a < t.length; a++) {
      let o = t[a];
      for (; ; ) {
        if (this.tokens.mainToken = null, o.pos > e)
          i.push(o);
        else {
          if (this.advanceStack(o, i, t))
            continue;
          {
            s || (s = [], r = []), s.push(o);
            let l = this.tokens.getMainToken(o);
            r.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let a = s && BT(s);
      if (a)
        return Li && console.log("Finish with " + this.stackID(a)), this.stackToTree(a);
      if (this.parser.strict)
        throw Li && s && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + e);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && s) {
      let a = this.stoppedAt != null && s[0].pos > this.stoppedAt ? s[0] : this.runRecovery(s, r, i);
      if (a)
        return Li && console.log("Force-finish " + this.stackID(a)), this.stackToTree(a.forceAll());
    }
    if (this.recovering) {
      let a = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > a)
        for (i.sort((o, l) => l.score - o.score); i.length > a; )
          i.pop();
      i.some((o) => o.reducePos > e) && this.recovering--;
    } else if (i.length > 1) {
      t: for (let a = 0; a < i.length - 1; a++) {
        let o = i[a];
        for (let l = a + 1; l < i.length; l++) {
          let h = i[l];
          if (o.sameState(h) || o.buffer.length > 500 && h.buffer.length > 500)
            if ((o.score - h.score || o.buffer.length - h.buffer.length) > 0)
              i.splice(l--, 1);
            else {
              i.splice(a--, 1);
              continue t;
            }
        }
      }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let a = 1; a < i.length; a++)
      i[a].pos < this.minStackPos && (this.minStackPos = i[a].pos);
    return null;
  }
  stopAt(t) {
    if (this.stoppedAt != null && this.stoppedAt < t)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = t;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(t, e, i) {
    let s = t.pos, { parser: r } = this, a = Li ? this.stackID(t) + " -> " : "";
    if (this.stoppedAt != null && s > this.stoppedAt)
      return t.forceReduce() ? t : null;
    if (this.fragments) {
      let h = t.curContext && t.curContext.tracker.strict, u = h ? t.curContext.hash : 0;
      for (let p = this.fragments.nodeAt(s); p; ) {
        let y = this.parser.nodeSet.types[p.type.id] == p.type ? r.getGoto(t.state, p.type.id) : -1;
        if (y > -1 && p.length && (!h || (p.prop(xt.contextHash) || 0) == u))
          return t.useNode(p, y), Li && console.log(a + this.stackID(t) + ` (via reuse of ${r.getName(p.type.id)})`), !0;
        if (!(p instanceof Lt) || p.children.length == 0 || p.positions[0] > 0)
          break;
        let m = p.children[0];
        if (m instanceof Lt && p.positions[0] == 0)
          p = m;
        else
          break;
      }
    }
    let o = r.stateSlot(
      t.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (o > 0)
      return t.reduce(o), Li && console.log(a + this.stackID(t) + ` (via always-reduce ${r.getName(
        o & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (t.stack.length >= 8400)
      for (; t.stack.length > 6e3 && t.forceReduce(); )
        ;
    let l = this.tokens.getActions(t);
    for (let h = 0; h < l.length; ) {
      let u = l[h++], p = l[h++], y = l[h++], m = h == l.length || !i, w = m ? t : t.split(), b = this.tokens.mainToken;
      if (w.apply(u, p, b ? b.start : w.pos, y), Li && console.log(a + this.stackID(w) + ` (via ${(u & 65536) == 0 ? "shift" : `reduce of ${r.getName(
        u & 65535
        /* Action.ValueMask */
      )}`} for ${r.getName(p)} @ ${s}${w == t ? "" : ", split"})`), m)
        return !0;
      w.pos > s ? e.push(w) : i.push(w);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(t, e) {
    let i = t.pos;
    for (; ; ) {
      if (!this.advanceStack(t, null, null))
        return !1;
      if (t.pos > i)
        return qx(t, e), !0;
    }
  }
  runRecovery(t, e, i) {
    let s = null, r = !1;
    for (let a = 0; a < t.length; a++) {
      let o = t[a], l = e[a << 1], h = e[(a << 1) + 1], u = Li ? this.stackID(o) + " -> " : "";
      if (o.deadEnd && (r || (r = !0, o.restart(), Li && console.log(u + this.stackID(o) + " (restarted)"), this.advanceFully(o, i))))
        continue;
      let p = o.split(), y = u;
      for (let m = 0; p.forceReduce() && m < 10 && (Li && console.log(y + this.stackID(p) + " (via force-reduce)"), !this.advanceFully(p, i)); m++)
        Li && (y = this.stackID(p) + " -> ");
      for (let m of o.recoverByInsert(l))
        Li && console.log(u + this.stackID(m) + " (via recover-insert)"), this.advanceFully(m, i);
      this.stream.end > o.pos ? (h == o.pos && (h++, l = 0), o.recoverByDelete(l, h), Li && console.log(u + this.stackID(o) + ` (via recover-delete ${this.parser.getName(l)})`), qx(o, i)) : (!s || s.score < o.score) && (s = o);
    }
    return s;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(t) {
    return t.close(), Lt.build({
      buffer: lW.create(t),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: t.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(t) {
    let e = (LO || (LO = /* @__PURE__ */ new WeakMap())).get(t);
    return e || LO.set(t, e = String.fromCodePoint(this.nextStackID++)), e + t;
  }
}, c(qd, "wc"), qd);
f(WT, "Parse");
let uW = WT;
function qx(n, t) {
  for (let e = 0; e < t.length; e++) {
    let i = t[e];
    if (i.pos == n.pos && i.sameState(n)) {
      t[e].score < n.score && (t[e] = n);
      return;
    }
  }
  t.push(n);
}
c(qx, "td$1");
f(qx, "pushStackDedup");
var jd;
const qT = (jd = class {
  constructor(t, e, i) {
    this.source = t, this.flags = e, this.disabled = i;
  }
  allows(t) {
    return !this.disabled || this.disabled[t] == 0;
  }
}, c(jd, "xc"), jd);
f(qT, "Dialect");
let pW = qT;
const IO = /* @__PURE__ */ f((n) => n, "id");
var Fd;
const jT = (Fd = class {
  /**
  Define a context tracker.
  */
  constructor(t) {
    this.start = t.start, this.shift = t.shift || IO, this.reduce = t.reduce || IO, this.reuse = t.reuse || IO, this.hash = t.hash || (() => 0), this.strict = t.strict !== !1;
  }
}, c(Fd, "kc"), Fd);
f(jT, "ContextTracker");
let FT = jT;
var Br;
const UT = (Br = class extends Ob {
  /**
  @internal
  */
  constructor(t) {
    if (super(), this.wrappers = [], t.version != 14)
      throw new RangeError(`Parser version (${t.version}) doesn't match runtime version (14)`);
    let e = t.nodeNames.split(" ");
    this.minRepeatTerm = e.length;
    for (let o = 0; o < t.repeatNodeCount; o++)
      e.push("");
    let i = Object.keys(t.topRules).map((o) => t.topRules[o][1]), s = [];
    for (let o = 0; o < e.length; o++)
      s.push([]);
    function r(o, l, h) {
      s[o].push([l, l.deserialize(String(h))]);
    }
    if (c(r, "s"), f(r, "setProp"), t.nodeProps)
      for (let o of t.nodeProps) {
        let l = o[0];
        typeof l == "string" && (l = xt[l]);
        for (let h = 1; h < o.length; ) {
          let u = o[h++];
          if (u >= 0)
            r(u, l, o[h++]);
          else {
            let p = o[h + -u];
            for (let y = -u; y > 0; y--)
              r(o[h++], l, p);
            h++;
          }
        }
      }
    this.nodeSet = new gb(e.map((o, l) => Ue.define({
      name: l >= this.minRepeatTerm ? void 0 : o,
      id: l,
      props: s[l],
      top: i.indexOf(l) > -1,
      error: l == 0,
      skipped: t.skippedNodes && t.skippedNodes.indexOf(l) > -1
    }))), t.propSources && (this.nodeSet = this.nodeSet.extend(...t.propSources)), this.strict = !1, this.bufferLength = r6;
    let a = _c(t.tokenData);
    this.context = t.context, this.specializerSpecs = t.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let o = 0; o < this.specializerSpecs.length; o++)
      this.specialized[o] = this.specializerSpecs[o].term;
    this.specializers = this.specializerSpecs.map(jx), this.states = _c(t.states, Uint32Array), this.data = _c(t.stateData), this.goto = _c(t.goto), this.maxTerm = t.maxTerm, this.tokenizers = t.tokenizers.map((o) => typeof o == "number" ? new jc(a, o) : o), this.topRules = t.topRules, this.dialects = t.dialects || {}, this.dynamicPrecedences = t.dynamicPrecedences || null, this.tokenPrecTable = t.tokenPrec, this.termNames = t.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(t, e, i) {
    let s = new uW(this, t, e, i);
    for (let r of this.wrappers)
      s = r(s, t, e, i);
    return s;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(t, e, i = !1) {
    let s = this.goto;
    if (e >= s[0])
      return -1;
    for (let r = s[e + 1]; ; ) {
      let a = s[r++], o = a & 1, l = s[r++];
      if (o && i)
        return l;
      for (let h = r + (a >> 1); r < h; r++)
        if (s[r] == t)
          return l;
      if (o)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(t, e) {
    let i = this.data;
    for (let s = 0; s < 2; s++)
      for (let r = this.stateSlot(
        t,
        s ? 2 : 1
        /* ParseState.Actions */
      ), a; ; r += 3) {
        if ((a = i[r]) == 65535)
          if (i[r + 1] == 1)
            a = i[r = Fn(i, r + 2)];
          else {
            if (i[r + 1] == 2)
              return Fn(i, r + 2);
            break;
          }
        if (a == e || a == 0)
          return Fn(i, r + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(t, e) {
    return this.states[t * 6 + e];
  }
  /**
  @internal
  */
  stateFlag(t, e) {
    return (this.stateSlot(
      t,
      0
      /* ParseState.Flags */
    ) & e) > 0;
  }
  /**
  @internal
  */
  validAction(t, e) {
    return !!this.allActions(t, (i) => i == e ? !0 : null);
  }
  /**
  @internal
  */
  allActions(t, e) {
    let i = this.stateSlot(
      t,
      4
      /* ParseState.DefaultReduce */
    ), s = i ? e(i) : void 0;
    for (let r = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); s == null; r += 3) {
      if (this.data[r] == 65535)
        if (this.data[r + 1] == 1)
          r = Fn(this.data, r + 2);
        else
          break;
      s = e(Fn(this.data, r + 1));
    }
    return s;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(t) {
    let e = [];
    for (let i = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = Fn(this.data, i + 2);
        else
          break;
      if ((this.data[i + 2] & 1) == 0) {
        let s = this.data[i + 1];
        e.some((r, a) => a & 1 && r == s) || e.push(this.data[i], s);
      }
    }
    return e;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(t) {
    let e = Object.assign(Object.create(Br.prototype), this);
    if (t.props && (e.nodeSet = this.nodeSet.extend(...t.props)), t.top) {
      let i = this.topRules[t.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${t.top}`);
      e.top = i;
    }
    return t.tokenizers && (e.tokenizers = this.tokenizers.map((i) => {
      let s = t.tokenizers.find((r) => r.from == i);
      return s ? s.to : i;
    })), t.specializers && (e.specializers = this.specializers.slice(), e.specializerSpecs = this.specializerSpecs.map((i, s) => {
      let r = t.specializers.find((o) => o.from == i.external);
      if (!r)
        return i;
      let a = Object.assign(Object.assign({}, i), { external: r.to });
      return e.specializers[s] = jx(a), a;
    })), t.contextTracker && (e.context = t.contextTracker), t.dialect && (e.dialect = this.parseDialect(t.dialect)), t.strict != null && (e.strict = t.strict), t.wrap && (e.wrappers = e.wrappers.concat(t.wrap)), t.bufferLength != null && (e.bufferLength = t.bufferLength), e;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(t) {
    return this.termNames ? this.termNames[t] : String(t <= this.maxNode && this.nodeSet.types[t].name || t);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(t) {
    let e = this.dynamicPrecedences;
    return e == null ? 0 : e[t] || 0;
  }
  /**
  @internal
  */
  parseDialect(t) {
    let e = Object.keys(this.dialects), i = e.map(() => !1);
    if (t)
      for (let r of t.split(" ")) {
        let a = e.indexOf(r);
        a >= 0 && (i[a] = !0);
      }
    let s = null;
    for (let r = 0; r < e.length; r++)
      if (!i[r])
        for (let a = this.dialects[e[r]], o; (o = this.data[a++]) != 65535; )
          (s || (s = new Uint8Array(this.maxTerm + 1)))[o] = 1;
    return new pW(t, i, s);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(t) {
    return new Br(t);
  }
}, c(Br, "Br"), Br);
f(UT, "LRParser");
let $S = UT;
function Fn(n, t) {
  return n[t] | n[t + 1] << 16;
}
c(Fn, "at$2");
f(Fn, "pair");
function BT(n) {
  let t = null;
  for (let e of n) {
    let i = e.p.stoppedAt;
    (e.pos == e.p.stream.end || i != null && e.pos > i) && e.p.parser.stateFlag(
      e.state,
      2
      /* StateFlag.Accepting */
    ) && (!t || t.score < e.score) && (t = e);
  }
  return t;
}
c(BT, "l1$1");
f(BT, "findFinished");
function jx(n) {
  if (n.external) {
    let t = n.extend ? 1 : 0;
    return (e, i) => n.external(e, i) << 1 | t;
  }
  return n.get;
}
c(jx, "id$1");
f(jx, "getSpecializer");
const fW = 54, yW = 1, mW = 55, wW = 2, gW = 56, vW = 3, j4 = 4, bW = 5, vv = 6, XT = 7, NT = 8, HT = 9, YT = 10, OW = 11, $W = 12, xW = 13, ZO = 57, kW = 14, F4 = 58, GT = 20, SW = 22, KT = 23, PW = 24, Fx = 26, JT = 27, CW = 28, QW = 31, MW = 34, TW = 36, AW = 37, RW = 0, EW = 1, _W = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, zW = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, U4 = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function tA(n) {
  return n == 45 || n == 46 || n == 58 || n >= 65 && n <= 90 || n == 95 || n >= 97 && n <= 122 || n >= 161;
}
c(tA, "A1$1");
f(tA, "nameChar");
function xS(n) {
  return n == 9 || n == 10 || n == 13 || n == 32;
}
c(xS, "Gp$1");
f(xS, "isSpace");
let B4 = null, X4 = null, N4 = 0;
function bv(n, t) {
  let e = n.pos + t;
  if (N4 == e && X4 == n) return B4;
  let i = n.peek(t);
  for (; xS(i); ) i = n.peek(++t);
  let s = "";
  for (; tA(i); )
    s += String.fromCharCode(i), i = n.peek(++t);
  return X4 = n, N4 = e, B4 = s ? s.toLowerCase() : i == LW || i == IW ? void 0 : null;
}
c(bv, "Ba$1");
f(bv, "tagNameAfter");
const eA = 60, Ov = 62, kS = 47, LW = 63, IW = 33, ZW = 45;
function Ux(n, t) {
  this.name = n, this.parent = t;
}
c(Ux, "hd$1");
f(Ux, "ElementContext");
const VW = [vv, YT, XT, NT, HT], DW = new FT({
  start: null,
  shift(n, t, e, i) {
    return VW.indexOf(t) > -1 ? new Ux(bv(i, 1) || "", n) : n;
  },
  reduce(n, t) {
    return t == GT && n ? n.parent : n;
  },
  reuse(n, t, e, i) {
    let s = t.type.id;
    return s == vv || s == TW ? new Ux(bv(i, 1) || "", n) : n;
  },
  strict: !1
}), WW = new dn((n, t) => {
  if (n.next != eA) {
    n.next < 0 && t.context && n.acceptToken(ZO);
    return;
  }
  n.advance();
  let e = n.next == kS;
  e && n.advance();
  let i = bv(n, 0);
  if (i === void 0) return;
  if (!i) return n.acceptToken(e ? kW : vv);
  let s = t.context ? t.context.name : null;
  if (e) {
    if (i == s) return n.acceptToken(OW);
    if (s && zW[s]) return n.acceptToken(ZO, -2);
    if (t.dialectEnabled(RW)) return n.acceptToken($W);
    for (let r = t.context; r; r = r.parent) if (r.name == i) return;
    n.acceptToken(xW);
  } else {
    if (i == "script") return n.acceptToken(XT);
    if (i == "style") return n.acceptToken(NT);
    if (i == "textarea") return n.acceptToken(HT);
    if (_W.hasOwnProperty(i)) return n.acceptToken(YT);
    s && U4[s] && U4[s][i] ? n.acceptToken(ZO, -1) : n.acceptToken(vv);
  }
}, { contextual: !0 }), qW = new dn((n) => {
  for (let t = 0, e = 0; ; e++) {
    if (n.next < 0) {
      e && n.acceptToken(F4);
      break;
    }
    if (n.next == ZW)
      t++;
    else if (n.next == Ov && t >= 2) {
      e >= 3 && n.acceptToken(F4, -2);
      break;
    } else
      t = 0;
    n.advance();
  }
});
function iA(n) {
  for (; n; n = n.parent)
    if (n.name == "svg" || n.name == "math") return !0;
  return !1;
}
c(iA, "U1$1");
f(iA, "inForeignElement");
const jW = new dn((n, t) => {
  if (n.next == kS && n.peek(1) == Ov) {
    let e = t.dialectEnabled(EW) || iA(t.context);
    n.acceptToken(e ? bW : j4, 2);
  } else n.next == Ov && n.acceptToken(j4, 1);
});
function Tb(n, t, e) {
  let i = 2 + n.length;
  return new dn((s) => {
    for (let r = 0, a = 0, o = 0; ; o++) {
      if (s.next < 0) {
        o && s.acceptToken(t);
        break;
      }
      if (r == 0 && s.next == eA || r == 1 && s.next == kS || r >= 2 && r < i && s.next == n.charCodeAt(r - 2))
        r++, a++;
      else if ((r == 2 || r == i) && xS(s.next))
        a++;
      else if (r == i && s.next == Ov) {
        o > a ? s.acceptToken(t, -a) : s.acceptToken(e, -(a - 2));
        break;
      } else if ((s.next == 10 || s.next == 13) && o) {
        s.acceptToken(t, 1);
        break;
      } else
        r = a = 0;
      s.advance();
    }
  });
}
c(Tb, "xh");
f(Tb, "contentTokenizer");
const FW = Tb("script", fW, yW), UW = Tb("style", mW, wW), BW = Tb("textarea", gW, vW), XW = ol({
  "Text RawText": M.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": M.angleBracket,
  TagName: M.tagName,
  "MismatchedCloseTag/TagName": [M.tagName, M.invalid],
  AttributeName: M.attributeName,
  "AttributeValue UnquotedAttributeValue": M.attributeValue,
  Is: M.definitionOperator,
  "EntityReference CharacterReference": M.character,
  Comment: M.blockComment,
  ProcessingInst: M.processingInstruction,
  DoctypeDecl: M.documentMeta
}), NW = $S.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: ",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: DW,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"],
    ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""]
  ],
  propSources: [XW],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [FW, UW, BW, jW, WW, qW, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 509 },
  tokenPrec: 511
});
function SS(n, t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let i of n.getChildren(KT)) {
    let s = i.getChild(PW), r = i.getChild(Fx) || i.getChild(JT);
    s && (e[t.read(s.from, s.to)] = r ? r.type.id == Fx ? t.read(r.from + 1, r.to - 1) : t.read(r.from, r.to) : "");
  }
  return e;
}
c(SS, "Fp$1");
f(SS, "getAttrs");
function Bx(n, t) {
  let e = n.getChild(SW);
  return e ? t.read(e.from, e.to) : " ";
}
c(Bx, "fd$1");
f(Bx, "findTagName");
function d1(n, t, e) {
  let i;
  for (let s of e)
    if (!s.attrs || s.attrs(i || (i = SS(n.node.parent.firstChild, t))))
      return { parser: s.parser };
  return null;
}
c(d1, "Do$1");
f(d1, "maybeNest");
function PS(n = [], t = []) {
  let e = [], i = [], s = [], r = [];
  for (let o of n)
    (o.tag == "script" ? e : o.tag == "style" ? i : o.tag == "textarea" ? s : r).push(o);
  let a = t.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let o of t) (a[o.name] || (a[o.name] = [])).push(o);
  return F5((o, l) => {
    let h = o.type.id;
    if (h == CW) return d1(o, l, e);
    if (h == QW) return d1(o, l, i);
    if (h == MW) return d1(o, l, s);
    if (h == GT && r.length) {
      let u = o.node, p = u.firstChild, y = p && Bx(p, l), m;
      if (y) {
        for (let w of r)
          if (w.tag == y && (!w.attrs || w.attrs(m || (m = SS(p, l))))) {
            let b = u.lastChild, $ = b.type.id == AW ? b.from : u.to;
            if ($ > p.to)
              return { parser: w.parser, overlay: [{ from: p.to, to: $ }] };
          }
      }
    }
    if (a && h == KT) {
      let u = o.node, p;
      if (p = u.firstChild) {
        let y = a[l.read(p.from, p.to)];
        if (y) for (let m of y) {
          if (m.tagName && m.tagName != Bx(u.parent, l)) continue;
          let w = u.lastChild;
          if (w.type.id == Fx) {
            let b = w.from + 1, $ = w.lastChild, x = w.to - ($ && $.isError ? 0 : 1);
            if (x > b) return { parser: m.parser, overlay: [{ from: b, to: x }] };
          } else if (w.type.id == JT)
            return { parser: m.parser, overlay: [{ from: w.from, to: w.to }] };
        }
      }
    }
    return null;
  });
}
c(PS, "Kp$1");
f(PS, "configureNesting");
const HW = 100, H4 = 1, YW = 101, GW = 102, Y4 = 2, nA = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], KW = 58, JW = 40, sA = 95, tq = 91, u1 = 45, eq = 46, iq = 35, nq = 37, sq = 38, rq = 92, aq = 10;
function ty(n) {
  return n >= 65 && n <= 90 || n >= 97 && n <= 122 || n >= 161;
}
c(ty, "On$1");
f(ty, "isAlpha");
function CS(n) {
  return n >= 48 && n <= 57;
}
c(CS, "tm$1");
f(CS, "isDigit");
const oq = new dn((n, t) => {
  for (let e = !1, i = 0, s = 0; ; s++) {
    let { next: r } = n;
    if (ty(r) || r == u1 || r == sA || e && CS(r))
      !e && (r != u1 || s > 0) && (e = !0), i === s && r == u1 && i++, n.advance();
    else if (r == rq && n.peek(1) != aq)
      n.advance(), n.next > -1 && n.advance(), e = !0;
    else {
      e && n.acceptToken(r == JW ? YW : i == 2 && t.canShift(Y4) ? Y4 : GW);
      break;
    }
  }
}), lq = new dn((n) => {
  if (nA.includes(n.peek(-1))) {
    let { next: t } = n;
    (ty(t) || t == sA || t == iq || t == eq || t == tq || t == KW && ty(n.peek(1)) || t == u1 || t == sq) && n.acceptToken(HW);
  }
}), cq = new dn((n) => {
  if (!nA.includes(n.peek(-1))) {
    let { next: t } = n;
    if (t == nq && (n.advance(), n.acceptToken(H4)), ty(t)) {
      do
        n.advance();
      while (ty(n.next) || CS(n.next));
      n.acceptToken(H4);
    }
  }
}), hq = ol({
  "AtKeyword import charset namespace keyframes media supports": M.definitionKeyword,
  "from to selector": M.keyword,
  NamespaceName: M.namespace,
  KeyframeName: M.labelName,
  KeyframeRangeName: M.operatorKeyword,
  TagName: M.tagName,
  ClassName: M.className,
  PseudoClassName: M.constant(M.className),
  IdName: M.labelName,
  "FeatureName PropertyName": M.propertyName,
  AttributeName: M.attributeName,
  NumberLiteral: M.number,
  KeywordQuery: M.keyword,
  UnaryQueryOp: M.operatorKeyword,
  "CallTag ValueName": M.atom,
  VariableName: M.variableName,
  Callee: M.operatorKeyword,
  Unit: M.unit,
  "UniversalSelector NestingSelector": M.definitionOperator,
  MatchOp: M.compareOperator,
  "ChildOp SiblingOp, LogicOp": M.logicOperator,
  BinOp: M.arithmeticOperator,
  Important: M.modifier,
  Comment: M.blockComment,
  ColorLiteral: M.color,
  "ParenthesizedContent StringLiteral": M.string,
  ":": M.punctuation,
  "PseudoOp #": M.derefOperator,
  "; ,": M.separator,
  "( )": M.paren,
  "[ ]": M.squareBracket,
  "{ }": M.brace
}), dq = { __proto__: null, lang: 34, "nth-child": 34, "nth-last-child": 34, "nth-of-type": 34, "nth-last-of-type": 34, dir: 34, "host-context": 34, url: 62, "url-prefix": 62, domain: 62, regexp: 62, selector: 140 }, uq = { __proto__: null, "@import": 120, "@media": 144, "@charset": 148, "@namespace": 152, "@keyframes": 158, "@supports": 170 }, pq = { __proto__: null, not: 134, only: 134 }, fq = $S.deserialize({
  version: 14,
  states: ":jQYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#CiO$qQ[O'#DUO$vQ[O'#DXOOQP'#En'#EnO${QdO'#DhO%jQ[O'#DuO${QdO'#DwO%{Q[O'#DyO&WQ[O'#D|O&`Q[O'#ESO&nQ[O'#EUOOQS'#Em'#EmOOQS'#EX'#EXQYQ[OOO&uQXO'#CdO'jQWO'#DdO'oQWO'#EsO'zQ[O'#EsQOQWOOP(UO#tO'#C_POOO)C@])C@]OOQP'#Ch'#ChOOQP,59Q,59QO#kQ[O,59QO(aQ[O'#E]O({QWO,58{O)TQ[O,59TO$qQ[O,59pO$vQ[O,59sO(aQ[O,59vO(aQ[O,59xO(aQ[O,59yO)`Q[O'#DcOOQS,58{,58{OOQP'#Cl'#ClOOQO'#DS'#DSOOQP,59T,59TO)gQWO,59TO)lQWO,59TOOQP'#DW'#DWOOQP,59p,59pOOQO'#DY'#DYO)qQ`O,59sOOQS'#Cq'#CqO${QdO'#CrO)yQvO'#CtO+ZQtO,5:SOOQO'#Cy'#CyO)lQWO'#CxO+oQWO'#CzO+tQ[O'#DPOOQS'#Ep'#EpOOQO'#Dk'#DkO+|Q[O'#DrO,[QWO'#EtO&`Q[O'#DpO,jQWO'#DsOOQO'#Eu'#EuO)OQWO,5:aO,oQpO,5:cOOQS'#D{'#D{O,wQWO,5:eO,|Q[O,5:eOOQO'#EO'#EOO-UQWO,5:hO-ZQWO,5:nO-cQWO,5:pOOQS-E8V-E8VO-kQdO,5:OO-{Q[O'#E_O.YQWO,5;_O.YQWO,5;_POOO'#EW'#EWP.eO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO/[QXO,5:wOOQO-E8Z-E8ZOOQS1G.g1G.gOOQP1G.o1G.oO)gQWO1G.oO)lQWO1G.oOOQP1G/[1G/[O/iQ`O1G/_O0SQXO1G/bO0jQXO1G/dO1QQXO1G/eO1hQWO,59}O1mQ[O'#DTO1tQdO'#CpOOQP1G/_1G/_O${QdO1G/_O1{QpO,59^OOQS,59`,59`O${QdO,59bO2TQWO1G/nOOQS,59d,59dO2YQ!bO,59fOOQS'#DQ'#DQOOQS'#EZ'#EZO2eQ[O,59kOOQS,59k,59kO2mQWO'#DkO2xQWO,5:WO2}QWO,5:^O&`Q[O,5:YO&`Q[O'#E`O3VQWO,5;`O3bQWO,5:[O(aQ[O,5:_OOQS1G/{1G/{OOQS1G/}1G/}OOQS1G0P1G0PO3sQWO1G0PO3xQdO'#EPOOQS1G0S1G0SOOQS1G0Y1G0YOOQS1G0[1G0[O4TQtO1G/jOOQO1G/j1G/jOOQO,5:y,5:yO4kQ[O,5:yOOQO-E8]-E8]O4xQWO1G0yPOOO-E8U-E8UPOOO1G.e1G.eOOQP7+$Z7+$ZOOQP7+$y7+$yO${QdO7+$yOOQS1G/i1G/iO5TQXO'#ErO5[QWO,59oO5aQtO'#EYO6XQdO'#EoO6cQWO,59[O6hQpO7+$yOOQS1G.x1G.xOOQS1G.|1G.|OOQS7+%Y7+%YOOQS1G/Q1G/QO6pQWO1G/QOOQS-E8X-E8XOOQS1G/V1G/VO${QdO1G/rOOQO1G/x1G/xOOQO1G/t1G/tO6uQWO,5:zOOQO-E8^-E8^O7TQXO1G/yOOQS7+%k7+%kO7[QYO'#CtOOQO'#ER'#ERO7gQ`O'#EQOOQO'#EQ'#EQO7rQWO'#EaO7zQdO,5:kOOQS,5:k,5:kO8VQtO'#E^O${QdO'#E^O9WQdO7+%UOOQO7+%U7+%UOOQO1G0e1G0eO9kQpO<<HeO9sQWO,5;^OOQP1G/Z1G/ZOOQS-E8W-E8WO${QdO'#E[O9{QWO,5;ZOOQT1G.v1G.vOOQP<<He<<HeOOQS7+$l7+$lO:TQdO7+%^OOQO7+%e7+%eOOQO,5:l,5:lO3{QdO'#EbO7rQWO,5:{OOQS,5:{,5:{OOQS-E8_-E8_OOQS1G0V1G0VO:[QtO,5:xOOQS-E8[-E8[OOQO<<Hp<<HpOOQPAN>PAN>PO;]QdO,5:vOOQO-E8Y-E8YOOQO<<Hx<<HxOOQO,5:|,5:|OOQO-E8`-E8`OOQS1G0g1G0g",
  stateData: ";o~O#[OS#]QQ~OUYOXYOZTO^VO_VOrXOyWO!]aO!^ZO!j[O!l]O!n^O!q_O!w`O#YRO~OQfOUYOXYOZTO^VO_VOrXOyWO!]aO!^ZO!j[O!l]O!n^O!q_O!w`O#YeO~O#V#gP~P!ZO#]jO~O#YlO~OZnO^qO_qOrsOuoOyrO!PtO!SvO#WuO~O!UwO~P#pOa}O#XzO#YyO~O#Y!OO~O#Y!QO~OQ![Oc!TOg![Oi![Oo!YOr!ZO#X!WO#Y!SO#e!UO~Oc!^O!e!`O!h!aO#Y!]O!U#hP~Oi!fOo!YO#Y!eO~Oi!hO#Y!hO~Oc!^O!e!`O!h!aO#Y!]O~O!Z#hP~P%jOZWX^WX^!XX_WXrWXuWXyWX!PWX!SWX!UWX#WWX~O^!mO~O!Z!nO#V#gX!T#gX~O#V#gX!T#gX~P!ZO#^!qO#_!qO#`!sO~OUYOXYOZTO^VO_VOrXOyWO#YRO~OuoO!UwO~Oa!zO#XzO#YyO~O!T#gP~P!ZOc#RO~Oc#SO~Oq#TO}#UO~OP#WOchXkhX!ZhX!ehX!hhX#YhXbhXQhXghXihXohXrhXuhX!YhX#VhX#XhX#ehXqhX!ThX~Oc!^Ok#XO!e!`O!h!aO#Y!]O!Z#hP~Oc#[O~Oq#`O#Y#]O~Oc!^O!e!`O!h!aO#Y#aO~Ou#eO!c#dO!U#hX!Z#hX~Oc#hO~Ok#XO!Z#jO~O!Z#kO~Oi#lOo!YO~O!U#mO~O!UwO!c#dO~O!UwO!Z#pO~O!Y#rO!Z!Wa#V!Wa!T!Wa~P${O!Z#RX#V#RX!T#RX~P!ZO!Z!nO#V#ga!T#ga~O#^!qO#_!qO#`#xO~OZnO^qO_qOrsOyrO!PtO!SvO#WuO~Ou#Pa!U#Pab#Pa~P.pOq#zO}#{O~OZnO^qO_qOrsOyrO~Ou!Oi!P!Oi!S!Oi!U!Oi#W!Oib!Oi~P/qOu!Qi!P!Qi!S!Qi!U!Qi#W!Qib!Qi~P/qOu!Ri!P!Ri!S!Ri!U!Ri#W!Rib!Ri~P/qO!T#|O~Ob#fP~P(aOb#cP~P${Ob$TOk#XO~O!Z$VO~Ob$WOi$XOp$XO~Oq$ZO#Y#]O~O^!aXb!_X!c!_X~O^$[O~Ob$]O!c#dO~Ou#eO!U#ha!Z#ha~O!c#dOu!da!U!da!Z!dab!da~O!Z$bO~O!T$iO#Y$dO#e$cO~Ok#XOu$kO!Y$mO!Z!Wi#V!Wi!T!Wi~P${O!Z#Ra#V#Ra!T#Ra~P!ZO!Z!nO#V#gi!T#gi~Ob#fX~P#pOb$qO~Ok#XOQ!|Xb!|Xc!|Xg!|Xi!|Xo!|Xr!|Xu!|X#X!|X#Y!|X#e!|X~Ou$sOb#cX~P${Ob$uO~Ok#XOq$vO~Ob$wO~O!c#dOu#Sa!U#Sa!Z#Sa~Ob$yO~P.pOP#WOuhX!UhX~O#e$cOu!tX!U!tX~Ou${O!UwO~O!T%PO#Y$dO#e$cO~Ok#XOQ#QXc#QXg#QXi#QXo#QXr#QXu#QX!Y#QX!Z#QX#V#QX#X#QX#Y#QX#e#QX!T#QX~Ou$kO!Y%SO!Z!Wq#V!Wq!T!Wq~P${Ok#XOq%TO~OuoOb#fa~Ou$sOb#ca~Ob%WO~P${Ok#XOQ#Qac#Qag#Qai#Qao#Qar#Qau#Qa!Y#Qa!Z#Qa#V#Qa#X#Qa#Y#Qa#e#Qa!T#Qa~Ob#Oau#Oa~P${O#[p#]#ek!S#e~",
  goto: "-g#jPPP#kP#nP#w$WP#wP$g#wPP$mPPP$s$|$|P%`P$|P$|%z&^PPPP$|&vP&z'Q#wP'W#w'^P#wP#w#wPPP'd'y(WPP#nPP(_(_(i(_P(_P(_(_P#nP#nP#nP(l#nP(o(r(u(|#nP#nP)R)X)h)v)|*S*^*d*n*t*zPPPPPPPPPP+Q+Z+v+yP,o,r,x-RRkQ_bOPdhw!n#tkYOPdhotuvw!n#R#h#tkSOPdhotuvw!n#R#h#tQmTR!tnQ{VR!xqQ!x}Q#Z!XR#y!zq![Z]!T!m#S#U#X#q#{$Q$[$k$l$s$x%Up![Z]!T!m#S#U#X#q#{$Q$[$k$l$s$x%UU$f#m$h${R$z$eq!XZ]!T!m#S#U#X#q#{$Q$[$k$l$s$x%Up![Z]!T!m#S#U#X#q#{$Q$[$k$l$s$x%UQ!f^R#l!gT#^!Z#_Q|VR!yqQ!x|R#y!yQ!PWR!{rQ!RXR!|sQxUQ!wpQ#i!cQ#o!jQ#p!kQ$}$gR%Z$|SgPwQ!phQ#s!nR$n#tZfPhw!n#ta!b[`a!V!^!`#d#eR#b!^R!g^R!i_R#n!iS$g#m$hR%X${V$e#m$h${Q!rjR#w!rQdOShPwU!ldh#tR#t!nQ$Q#SU$r$Q$x%UQ$x$[R%U$sQ#_!ZR$Y#_Q$t$QR%V$tQpUS!vp$pR$p#}Q$l#qR%R$lQ!ogS#u!o#vR#v!pQ#f!_R$`#fQ$h#mR%O$hQ$|$gR%Y$|_cOPdhw!n#t^UOPdhw!n#tQ!uoQ!}tQ#OuQ#PvQ#}#RR$a#hR$R#SQ!VZQ!d]Q#V!TQ#q!m[$P#S$Q$[$s$x%UQ$S#UQ$U#XS$j#q$lQ$o#{R%Q$kR$O#RQiPR#QwQ!c[Q!kaR#Y!VU!_[a!VQ!j`Q#c!^Q#g!`Q$^#dR$_#e",
  nodeNames: "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector . ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 117,
  nodeProps: [
    ["isolate", -2, 3, 25, ""],
    ["openedBy", 18, "(", 33, "[", 51, "{"],
    ["closedBy", 19, ")", 34, "]", 52, "}"]
  ],
  propSources: [hq],
  skippedNodes: [0, 3, 88],
  repeatNodeCount: 11,
  tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSp`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#[~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#[~p`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUp`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Up`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUp`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Up`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUp`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Up`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUp`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Up`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!Y[p`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOi~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYyQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYp`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYp`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYg[p`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYg[p`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYp`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYg[p`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYp`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSg[p`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS}Sp`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSc^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOb~n9{UUQkWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWkW!SQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUp`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYp`#e[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYp`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUp`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUp`#e[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[p`#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSu^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWkWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VUZQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTkWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSp`#]~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU^QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S_Qp`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Z^Oy%^z;'S%^;'S;=`%o<%lO%^dCoS}SOy%^z;'S%^;'S;=`%o<%lO%^bDQU!PQOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS!PQp`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[!]Qp`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^nFfSr^Oy%^z;'S%^;'S;=`%o<%lO%^nFwSq^Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUp`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!cQp`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!UUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!T^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!SQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
  tokenizers: [lq, cq, oq, 1, 2, 3, 4, new gv("m~RRYZ[z{a~~g~aO#_~~dP!P!Qg~lO#`~~", 28, 106)],
  topRules: { StyleSheet: [0, 4], Styles: [1, 87] },
  specialized: [{ term: 101, get: /* @__PURE__ */ f((n) => dq[n] || -1, "get") }, { term: 59, get: /* @__PURE__ */ f((n) => uq[n] || -1, "get") }, { term: 102, get: /* @__PURE__ */ f((n) => pq[n] || -1, "get") }],
  tokenPrec: 1219
});
let VO = null;
function p1() {
  if (!VO && typeof document == "object" && document.body) {
    let { style: n } = document.body, t = [], e = /* @__PURE__ */ new Set();
    for (let i in n)
      i != "cssText" && i != "cssFloat" && typeof n[i] == "string" && (/[A-Z]/.test(i) && (i = i.replace(/[A-Z]/g, (s) => "-" + s.toLowerCase())), e.has(i) || (t.push(i), e.add(i)));
    VO = t.sort().map((i) => ({ type: "property", label: i, apply: i + ": " }));
  }
  return VO || [];
}
c(p1, "zo$1");
f(p1, "properties");
const G4 = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((n) => ({ type: "class", label: n })), K4 = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((n) => ({ type: "keyword", label: n })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((n) => ({ type: "constant", label: n }))), yq = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((n) => ({ type: "type", label: n })), mq = /* @__PURE__ */ [
  "@charset",
  "@color-profile",
  "@container",
  "@counter-style",
  "@font-face",
  "@font-feature-values",
  "@font-palette-values",
  "@import",
  "@keyframes",
  "@layer",
  "@media",
  "@namespace",
  "@page",
  "@position-try",
  "@property",
  "@scope",
  "@starting-style",
  "@supports",
  "@view-transition"
].map((n) => ({ type: "keyword", label: n })), fs = /^(\w[\w-]*|-\w[\w-]*|)$/, wq = /^-(-[\w-]*)?$/;
function rA(n, t) {
  var e;
  if ((n.name == "(" || n.type.isError) && (n = n.parent || n), n.name != "ArgList")
    return !1;
  let i = (e = n.parent) === null || e === void 0 ? void 0 : e.firstChild;
  return i?.name != "Callee" ? !1 : t.sliceString(i.from, i.to) == "var";
}
c(rA, "OS");
f(rA, "isVarArg");
const J4 = /* @__PURE__ */ new k6(), gq = ["Declaration"];
function aA(n) {
  for (let t = n; ; ) {
    if (t.type.isTop)
      return t;
    if (!(t = t.parent))
      return n;
  }
}
c(aA, "mS");
f(aA, "astTop");
function QS(n, t, e) {
  if (t.to - t.from > 4096) {
    let i = J4.get(t);
    if (i)
      return i;
    let s = [], r = /* @__PURE__ */ new Set(), a = t.cursor(Yt.IncludeAnonymous);
    if (a.firstChild())
      do
        for (let o of QS(n, a.node, e))
          r.has(o.label) || (r.add(o.label), s.push(o));
      while (a.nextSibling());
    return J4.set(t, s), s;
  } else {
    let i = [], s = /* @__PURE__ */ new Set();
    return t.cursor().iterate((r) => {
      var a;
      if (e(r) && r.matchContext(gq) && ((a = r.node.nextSibling) === null || a === void 0 ? void 0 : a.name) == ":") {
        let o = n.sliceString(r.from, r.to);
        s.has(o) || (s.add(o), i.push({ label: o, type: "variable" }));
      }
    }), i;
  }
}
c(QS, "im$1");
f(QS, "variableNames");
const vq = /* @__PURE__ */ f((n) => (t) => {
  let { state: e, pos: i } = t, s = he(e).resolveInner(i, -1), r = s.type.isError && s.from == s.to - 1 && e.doc.sliceString(s.from, s.to) == "-";
  if (s.name == "PropertyName" || (r || s.name == "TagName") && /^(Block|Styles)$/.test(s.resolve(s.to).name))
    return { from: s.from, options: p1(), validFor: fs };
  if (s.name == "ValueName")
    return { from: s.from, options: K4, validFor: fs };
  if (s.name == "PseudoClassName")
    return { from: s.from, options: G4, validFor: fs };
  if (n(s) || (t.explicit || r) && rA(s, e.doc))
    return {
      from: n(s) || r ? s.from : i,
      options: QS(e.doc, aA(s), n),
      validFor: wq
    };
  if (s.name == "TagName") {
    for (let { parent: l } = s; l; l = l.parent)
      if (l.name == "Block")
        return { from: s.from, options: p1(), validFor: fs };
    return { from: s.from, options: yq, validFor: fs };
  }
  if (s.name == "AtKeyword")
    return { from: s.from, options: mq, validFor: fs };
  if (!t.explicit)
    return null;
  let a = s.resolve(i), o = a.childBefore(i);
  return o && o.name == ":" && a.name == "PseudoClassSelector" ? { from: i, options: G4, validFor: fs } : o && o.name == ":" && a.name == "Declaration" || a.name == "ArgList" ? { from: i, options: K4, validFor: fs } : a.name == "Block" || a.name == "Styles" ? { from: i, options: p1(), validFor: fs } : null;
}, "defineCSSCompletionSource"), bq = /* @__PURE__ */ vq((n) => n.name == "VariableName"), $v = /* @__PURE__ */ X5.define({
  name: "css",
  parser: /* @__PURE__ */ fq.configure({
    props: [
      /* @__PURE__ */ ky.add({
        Declaration: /* @__PURE__ */ sw()
      }),
      /* @__PURE__ */ eg.add({
        "Block KeyframeList": G5
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function oA() {
  return new Kf($v, $v.data.of({ autocomplete: bq }));
}
c(oA, "sm$1");
f(oA, "css");
const Oq = 314, $q = 315, t3 = 1, xq = 2, kq = 3, Sq = 4, Pq = 316, Cq = 318, Qq = 319, Mq = 5, Tq = 6, Aq = 0, Xx = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], lA = 125, Rq = 59, Nx = 47, Eq = 42, _q = 43, zq = 45, Lq = 60, Iq = 44, Zq = 63, Vq = 46, Dq = 91, Wq = new FT({
  start: !1,
  shift(n, t) {
    return t == Mq || t == Tq || t == Cq ? n : t == Qq;
  },
  strict: !1
}), qq = new dn((n, t) => {
  let { next: e } = n;
  (e == lA || e == -1 || t.context) && n.acceptToken(Pq);
}, { contextual: !0, fallback: !0 }), jq = new dn((n, t) => {
  let { next: e } = n, i;
  Xx.indexOf(e) > -1 || e == Nx && ((i = n.peek(1)) == Nx || i == Eq) || e != lA && e != Rq && e != -1 && !t.context && n.acceptToken(Oq);
}, { contextual: !0 }), Fq = new dn((n, t) => {
  n.next == Dq && !t.context && n.acceptToken($q);
}, { contextual: !0 }), Uq = new dn((n, t) => {
  let { next: e } = n;
  if (e == _q || e == zq) {
    if (n.advance(), e == n.next) {
      n.advance();
      let i = !t.context && t.canShift(t3);
      n.acceptToken(i ? t3 : xq);
    }
  } else e == Zq && n.peek(1) == Vq && (n.advance(), n.advance(), (n.next < 48 || n.next > 57) && n.acceptToken(kq));
}, { contextual: !0 });
function f1(n, t) {
  return n >= 65 && n <= 90 || n >= 97 && n <= 122 || n == 95 || n >= 192 || !t && n >= 48 && n <= 57;
}
c(f1, "No$1");
f(f1, "identifierChar");
const Bq = new dn((n, t) => {
  if (n.next != Lq || !t.dialectEnabled(Aq) || (n.advance(), n.next == Nx)) return;
  let e = 0;
  for (; Xx.indexOf(n.next) > -1; )
    n.advance(), e++;
  if (f1(n.next, !0)) {
    for (n.advance(), e++; f1(n.next, !1); )
      n.advance(), e++;
    for (; Xx.indexOf(n.next) > -1; )
      n.advance(), e++;
    if (n.next == Iq) return;
    for (let i = 0; ; i++) {
      if (i == 7) {
        if (!f1(n.next, !0)) return;
        break;
      }
      if (n.next != "extends".charCodeAt(i)) break;
      n.advance(), e++;
    }
  }
  n.acceptToken(Sq, -e);
}), Xq = ol({
  "get set async static": M.modifier,
  "for while do if else switch try catch finally return throw break continue default case": M.controlKeyword,
  "in of await yield void typeof delete instanceof": M.operatorKeyword,
  "let var const using function class extends": M.definitionKeyword,
  "import export from": M.moduleKeyword,
  "with debugger as new": M.keyword,
  TemplateString: M.special(M.string),
  super: M.atom,
  BooleanLiteral: M.bool,
  this: M.self,
  null: M.null,
  Star: M.modifier,
  VariableName: M.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": M.function(M.variableName),
  VariableDefinition: M.definition(M.variableName),
  Label: M.labelName,
  PropertyName: M.propertyName,
  PrivatePropertyName: M.special(M.propertyName),
  "CallExpression/MemberExpression/PropertyName": M.function(M.propertyName),
  "FunctionDeclaration/VariableDefinition": M.function(M.definition(M.variableName)),
  "ClassDeclaration/VariableDefinition": M.definition(M.className),
  "NewExpression/VariableName": M.className,
  PropertyDefinition: M.definition(M.propertyName),
  PrivatePropertyDefinition: M.definition(M.special(M.propertyName)),
  UpdateOp: M.updateOperator,
  "LineComment Hashbang": M.lineComment,
  BlockComment: M.blockComment,
  Number: M.number,
  String: M.string,
  Escape: M.escape,
  ArithOp: M.arithmeticOperator,
  LogicOp: M.logicOperator,
  BitOp: M.bitwiseOperator,
  CompareOp: M.compareOperator,
  RegExp: M.regexp,
  Equals: M.definitionOperator,
  Arrow: M.function(M.punctuation),
  ": Spread": M.punctuation,
  "( )": M.paren,
  "[ ]": M.squareBracket,
  "{ }": M.brace,
  "InterpolationStart InterpolationEnd": M.special(M.brace),
  ".": M.derefOperator,
  ", ;": M.separator,
  "@": M.meta,
  TypeName: M.typeName,
  TypeDefinition: M.definition(M.typeName),
  "type enum interface implements namespace module declare": M.definitionKeyword,
  "abstract global Privacy readonly override": M.modifier,
  "is keyof unique infer asserts": M.operatorKeyword,
  JSXAttributeValue: M.attributeValue,
  JSXText: M.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": M.angleBracket,
  "JSXIdentifier JSXNameSpacedName": M.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": M.attributeName,
  "JSXBuiltin/JSXIdentifier": M.standard(M.tagName)
}), Nq = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, const: 52, extends: 56, this: 60, true: 68, false: 68, null: 80, void: 84, typeof: 88, super: 104, new: 138, delete: 150, yield: 159, await: 163, class: 168, public: 231, private: 231, protected: 231, readonly: 233, instanceof: 252, satisfies: 255, in: 256, import: 290, keyof: 347, unique: 351, infer: 357, asserts: 393, is: 395, abstract: 415, implements: 417, type: 419, let: 422, var: 424, using: 427, interface: 433, enum: 437, namespace: 443, module: 445, declare: 449, global: 453, for: 472, of: 481, while: 484, with: 488, do: 492, if: 496, else: 498, switch: 502, case: 508, try: 514, catch: 518, finally: 522, return: 526, throw: 530, break: 534, continue: 538, debugger: 542 }, Hq = { __proto__: null, async: 125, get: 127, set: 129, declare: 191, public: 193, private: 193, protected: 193, static: 195, abstract: 197, override: 199, readonly: 205, accessor: 207, new: 399 }, Yq = { __proto__: null, "<": 189 }, Gq = $S.deserialize({
  version: 14,
  states: "$EOQ%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#D_O.QQlO'#DeO.bQlO'#DpO%[QlO'#DxO0fQlO'#EQOOQ!0Lf'#EY'#EYO1PQ`O'#EVOOQO'#En'#EnOOQO'#Ij'#IjO1XQ`O'#GrO1dQ`O'#EmO1iQ`O'#EmO3hQ!0MxO'#JpO6[Q!0MxO'#JqO6uQ`O'#F[O6zQ,UO'#FsOOQ!0Lf'#Fe'#FeO7VO7dO'#FeO7eQMhO'#F{O9UQ`O'#FzOOQ!0Lf'#Jq'#JqOOQ!0Lb'#Jp'#JpO9ZQ`O'#GvOOQ['#K]'#K]O9fQ`O'#IWO9kQ!0LrO'#IXOOQ['#J^'#J^OOQ['#I]'#I]Q`QlOOQ`QlOOO9sQ!L^O'#DtO9zQlO'#D|O:RQlO'#EOO9aQ`O'#GrO:YQMhO'#CoO:hQ`O'#ElO:sQ`O'#EwO:xQMhO'#FdO;gQ`O'#GrOOQO'#K^'#K^O;lQ`O'#K^O;zQ`O'#GzO;zQ`O'#G{O;zQ`O'#G}O9aQ`O'#HQO<qQ`O'#HTO>YQ`O'#CeO>jQ`O'#HaO>rQ`O'#HgO>rQ`O'#HiO`QlO'#HkO>rQ`O'#HmO>rQ`O'#HpO>wQ`O'#HvO>|Q!0LsO'#H|O%[QlO'#IOO?XQ!0LsO'#IQO?dQ!0LsO'#ISO9kQ!0LrO'#IUO?oQ!0MxO'#CiO@qQpO'#DjQOQ`OOO%[QlO'#EOOAXQ`O'#ERO:YQMhO'#ElOAdQ`O'#ElOAoQ!bO'#FdOOQ['#Cg'#CgOOQ!0Lb'#Do'#DoOOQ!0Lb'#Jt'#JtO%[QlO'#JtOOQO'#Jw'#JwOOQO'#If'#IfOBoQpO'#EeOOQ!0Lb'#Ed'#EdOOQ!0Lb'#J{'#J{OCkQ!0MSO'#EeOCuQpO'#EUOOQO'#Jv'#JvODZQpO'#JwOEhQpO'#EUOCuQpO'#EePEuO&2DjO'#CbPOOO)CD{)CD{OOOO'#I^'#I^OFQO#tO,59UOOQ!0Lh,59U,59UOOOO'#I_'#I_OF`O&jO,59UOFnQ!L^O'#DaOOOO'#Ia'#IaOFuO#@ItO,59yOOQ!0Lf,59y,59yOGTQlO'#IbOGhQ`O'#JrOIgQ!fO'#JrO+}QlO'#JrOInQ`O,5:POJUQ`O'#EnOJcQ`O'#KROJnQ`O'#KQOJnQ`O'#KQOJvQ`O,5;[OJ{Q`O'#KPOOQ!0Ln,5:[,5:[OKSQlO,5:[OMQQ!0MxO,5:dOMqQ`O,5:lON[Q!0LrO'#KOONcQ`O'#J}O9ZQ`O'#J}ONwQ`O'#J}O! PQ`O,5;ZO! UQ`O'#J}O!#ZQ!fO'#JqOOQ!0Lh'#Ci'#CiO%[QlO'#EQO!#yQ!fO,5:qOOQS'#Jx'#JxOOQO-E<h-E<hO9aQ`O,5=^O!$aQ`O,5=^O!$fQlO,5;XO!&iQMhO'#EiO!(SQ`O,5;XO!(XQlO'#DwO!(cQpO,5;bO!(kQpO,5;bO%[QlO,5;bOOQ['#FS'#FSOOQ['#FU'#FUO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cO%[QlO,5;cOOQ['#FY'#FYO!(yQlO,5;sOOQ!0Lf,5;x,5;xOOQ!0Lf,5;y,5;yOOQ!0Lf,5;{,5;{O%[QlO'#InO!*|Q!0LrO,5<hO%[QlO,5;cO!&iQMhO,5;cO!+kQMhO,5;cO!-]QMhO'#E[O%[QlO,5;vOOQ!0Lf,5;z,5;zO!-dQ,UO'#FiO!.aQ,UO'#KVO!-{Q,UO'#KVO!.hQ,UO'#KVOOQO'#KV'#KVO!.|Q,UO,5<ROOOW,5<_,5<_O!/_QlO'#FuOOOW'#Im'#ImO7VO7dO,5<PO!/fQ,UO'#FwOOQ!0Lf,5<P,5<PO!0VQ$IUO'#CwOOQ!0Lh'#C{'#C{O!0jO#@ItO'#DPO!1WQMjO,5<dO!1_Q`O,5<gO!2zQ(CWO'#GWO!3XQ`O'#GXO!3^Q`O'#GXO!4|Q(CWO'#G]O!6RQpO'#GaOOQO'#Gm'#GmO!+rQMhO'#GlOOQO'#Go'#GoO!+rQMhO'#GnO!6tQ$IUO'#JjOOQ!0Lh'#Jj'#JjO!7OQ`O'#JiO!7^Q`O'#JhO!7fQ`O'#CuOOQ!0Lh'#Cy'#CyO!7qQ`O'#C{OOQ!0Lh'#DT'#DTOOQ!0Lh'#DV'#DVO1SQ`O'#DXO!+rQMhO'#GOO!+rQMhO'#GQO!7vQ`O'#GSO!7{Q`O'#GTO!3^Q`O'#GZO!+rQMhO'#G`O;zQ`O'#JiO!8QQ`O'#EoO!8oQ`O,5<fOOQ!0Lb'#Cr'#CrO!8wQ`O'#EpO!9qQpO'#EqOOQ!0Lb'#KP'#KPO!9xQ!0LrO'#K_O9kQ!0LrO,5=bO`QlO,5>rOOQ['#Jf'#JfOOQ[,5>s,5>sOOQ[-E<Z-E<ZO!;wQ!0MxO,5:`O!9lQpO,5:^O!>bQ!0MxO,5:hO%[QlO,5:hO!@xQ!0MxO,5:jOOQO,5@x,5@xO!AiQMhO,5=^O!AwQ!0LrO'#JgO9UQ`O'#JgO!BYQ!0LrO,59ZO!BeQpO,59ZO!BmQMhO,59ZO:YQMhO,59ZO!BxQ`O,5;XO!CQQ`O'#H`O!CfQ`O'#KbO%[QlO,5;|O!9lQpO,5<OO!CnQ`O,5=yO!CsQ`O,5=yO!CxQ`O,5=yO9kQ!0LrO,5=yO;zQ`O,5=iOOQO'#Cw'#CwO!DWQpO,5=fO!D`QMhO,5=gO!DkQ`O,5=iO!DpQ!bO,5=lO!DxQ`O'#K^O>wQ`O'#HVO9aQ`O'#HXO!D}Q`O'#HXO:YQMhO'#HZO!ESQ`O'#HZOOQ[,5=o,5=oO!EXQ`O'#H[O!EjQ`O'#CoO!EoQ`O,59PO!EyQ`O,59PO!HOQlO,59POOQ[,59P,59PO!H`Q!0LrO,59PO%[QlO,59PO!JkQlO'#HcOOQ['#Hd'#HdOOQ['#He'#HeO`QlO,5={O!KRQ`O,5={O`QlO,5>RO`QlO,5>TO!KWQ`O,5>VO`QlO,5>XO!K]Q`O,5>[O!KbQlO,5>bOOQ[,5>h,5>hO%[QlO,5>hO9kQ!0LrO,5>jOOQ[,5>l,5>lO# lQ`O,5>lOOQ[,5>n,5>nO# lQ`O,5>nOOQ[,5>p,5>pO#!YQpO'#D]O%[QlO'#JtO#!{QpO'#JtO##VQpO'#DkO##hQpO'#DkO#%yQlO'#DkO#&QQ`O'#JsO#&YQ`O,5:UO#&_Q`O'#ErO#&mQ`O'#KSO#&uQ`O,5;]O#&zQpO'#DkO#'XQpO'#ETOOQ!0Lf,5:m,5:mO%[QlO,5:mO#'`Q`O,5:mO>wQ`O,5;WO!BeQpO,5;WO!BmQMhO,5;WO:YQMhO,5;WO#'hQ`O,5@`O#'mQ07dO,5:qOOQO-E<d-E<dO#(sQ!0MSO,5;POCuQpO,5:pO#(}QpO,5:pOCuQpO,5;PO!BYQ!0LrO,5:pOOQ!0Lb'#Eh'#EhOOQO,5;P,5;PO%[QlO,5;PO#)[Q!0LrO,5;PO#)gQ!0LrO,5;PO!BeQpO,5:pOOQO,5;V,5;VO#)uQ!0LrO,5;PPOOO'#I['#I[P#*ZO&2DjO,58|POOO,58|,58|OOOO-E<[-E<[OOQ!0Lh1G.p1G.pOOOO-E<]-E<]OOOO,59{,59{O#*fQ!bO,59{OOOO-E<_-E<_OOQ!0Lf1G/e1G/eO#*kQ!fO,5>|O+}QlO,5>|OOQO,5?S,5?SO#*uQlO'#IbOOQO-E<`-E<`O#+SQ`O,5@^O#+[Q!fO,5@^O#+cQ`O,5@lOOQ!0Lf1G/k1G/kO%[QlO,5@mO#+kQ`O'#IhOOQO-E<f-E<fO#+cQ`O,5@lOOQ!0Lb1G0v1G0vOOQ!0Ln1G/v1G/vOOQ!0Ln1G0W1G0WO%[QlO,5@jO#,PQ!0LrO,5@jO#,bQ!0LrO,5@jO#,iQ`O,5@iO9ZQ`O,5@iO#,qQ`O,5@iO#-PQ`O'#IkO#,iQ`O,5@iOOQ!0Lb1G0u1G0uO!(cQpO,5:sO!(nQpO,5:sOOQS,5:u,5:uO#-qQdO,5:uO#-yQMhO1G2xO9aQ`O1G2xOOQ!0Lf1G0s1G0sO#.XQ!0MxO1G0sO#/^Q!0MvO,5;TOOQ!0Lh'#GV'#GVO#/zQ!0MzO'#JjO!$fQlO1G0sO#2VQ!fO'#JuO%[QlO'#JuO#2aQ`O,5:cOOQ!0Lh'#D]'#D]OOQ!0Lf1G0|1G0|O%[QlO1G0|OOQ!0Lf1G1e1G1eO#2fQ`O1G0|O#4zQ!0MxO1G0}O#5RQ!0MxO1G0}O#7iQ!0MxO1G0}O#7pQ!0MxO1G0}O#:WQ!0MxO1G0}O#<nQ!0MxO1G0}O#<uQ!0MxO1G0}O#<|Q!0MxO1G0}O#?dQ!0MxO1G0}O#?kQ!0MxO1G0}O#AxQ?MtO'#CiO#CsQ?MtO1G1_O#CzQ?MtO'#JqO#D_Q!0MxO,5?YOOQ!0Lb-E<l-E<lO#FlQ!0MxO1G0}O#GiQ!0MzO1G0}OOQ!0Lf1G0}1G0}O#HlQMjO'#JzO#HvQ`O,5:vO#H{Q!0MxO1G1bO#IoQ,UO,5<VO#IwQ,UO,5<WO#JPQ,UO'#FnO#JhQ`O'#FmOOQO'#KW'#KWOOQO'#Il'#IlO#JmQ,UO1G1mOOQ!0Lf1G1m1G1mOOOW1G1x1G1xO#KOQ?MtO'#JpO#KYQ`O,5<aO!(yQlO,5<aOOOW-E<k-E<kOOQ!0Lf1G1k1G1kO#K_QpO'#KVOOQ!0Lf,5<c,5<cO#KgQpO,5<cO#KlQMhO'#DROOOO'#I`'#I`O#KsO#@ItO,59kOOQ!0Lh,59k,59kO%[QlO1G2OO!7{Q`O'#IpO#LOQ`O,5<yOOQ!0Lh,5<v,5<vO!+rQMhO'#IsO#LlQMjO,5=WO!+rQMhO'#IuO#M_QMjO,5=YO!&iQMhO,5=[OOQO1G2R1G2RO#MiQ!dO'#CrO#M|Q(CWO'#EpO$ RQpO'#GaO$ iQ!dO,5<rO$ pQ`O'#KYO9ZQ`O'#KYO$!OQ`O,5<tO!+rQMhO,5<sO$!TQ`O'#GYO$!fQ`O,5<sO$!kQ!dO'#GVO$!xQ!dO'#KZO$#SQ`O'#KZO!&iQMhO'#KZO$#XQ`O,5<wO$#^QlO'#JtO$#hQpO'#GbO##hQpO'#GbO$#yQ`O'#GfO!3^Q`O'#GjO$$OQ!0LrO'#IrO$$ZQpO,5<{OOQ!0Lp,5<{,5<{O$$bQpO'#GbO$$oQpO'#GcO$%QQpO'#GcO$%VQMjO,5=WO$%gQMjO,5=YOOQ!0Lh,5=],5=]O!+rQMhO,5@TO!+rQMhO,5@TO$%wQ`O'#IwO$&VQ`O,5@SO$&_Q`O,59aOOQ!0Lh,59g,59gO$'UQ$IYO,59sOOQ!0Lh'#Jn'#JnO$'wQMjO,5<jO$(jQMjO,5<lO@iQ`O,5<nOOQ!0Lh,5<o,5<oO$(tQ`O,5<uO$(yQMjO,5<zO$)ZQ`O,5@TO$)iQ`O'#J}O!$fQlO1G2QO$)nQ`O1G2QO9ZQ`O'#KQO9ZQ`O'#ErO%[QlO'#ErO9ZQ`O'#IyO$)sQ!0LrO,5@yOOQ[1G2|1G2|OOQ[1G4^1G4^OOQ!0Lf1G/z1G/zOOQ!0Lf1G/x1G/xO$+uQ!0MxO1G0SOOQ[1G2x1G2xO!&iQMhO1G2xO%[QlO1G2xO#-|Q`O1G2xO$-yQMhO'#EiOOQ!0Lb,5@R,5@RO$.WQ!0LrO,5@ROOQ[1G.u1G.uO!BYQ!0LrO1G.uO!BeQpO1G.uO!BmQMhO1G.uO$.iQ`O1G0sO$.nQ`O'#CiO$.yQ`O'#KcO$/RQ`O,5=zO$/WQ`O'#KcO$/]Q`O'#KcO$/kQ`O'#JPO$/yQ`O,5@|O$0RQ!fO1G1hOOQ!0Lf1G1j1G1jO9aQ`O1G3eO@iQ`O1G3eO$0YQ`O1G3eO$0_Q`O1G3eOOQ[1G3e1G3eO!DkQ`O1G3TO!&iQMhO1G3QO$0dQ`O1G3QOOQ[1G3R1G3RO!&iQMhO1G3RO$0iQ`O1G3RO$0qQpO'#HPOOQ[1G3T1G3TO!5|QpO'#I{O!DpQ!bO1G3WOOQ[1G3W1G3WOOQ[,5=q,5=qO$0yQMhO,5=sO9aQ`O,5=sO$#yQ`O,5=uO9UQ`O,5=uO!BeQpO,5=uO!BmQMhO,5=uO:YQMhO,5=uO$1XQ`O'#KaO$1dQ`O,5=vOOQ[1G.k1G.kO$1iQ!0LrO1G.kO@iQ`O1G.kO$1tQ`O1G.kO9kQ!0LrO1G.kO$3|Q!fO,5AOO$4ZQ`O,5AOO9ZQ`O,5AOO$4fQlO,5=}O$4mQ`O,5=}OOQ[1G3g1G3gO`QlO1G3gOOQ[1G3m1G3mOOQ[1G3o1G3oO>rQ`O1G3qO$4rQlO1G3sO$8vQlO'#HrOOQ[1G3v1G3vO$9TQ`O'#HxO>wQ`O'#HzOOQ[1G3|1G3|O$9]QlO1G3|O9kQ!0LrO1G4SOOQ[1G4U1G4UOOQ!0Lb'#G^'#G^O9kQ!0LrO1G4WO9kQ!0LrO1G4YO$=dQ`O,5@`O!(yQlO,5;^O9ZQ`O,5;^O>wQ`O,5:VO!(yQlO,5:VO!BeQpO,5:VO$=iQ?MtO,5:VOOQO,5;^,5;^O$=sQpO'#IcO$>ZQ`O,5@_OOQ!0Lf1G/p1G/pO$>cQpO'#IiO$>mQ`O,5@nOOQ!0Lb1G0w1G0wO##hQpO,5:VOOQO'#Ie'#IeO$>uQpO,5:oOOQ!0Ln,5:o,5:oO#'cQ`O1G0XOOQ!0Lf1G0X1G0XO%[QlO1G0XOOQ!0Lf1G0r1G0rO>wQ`O1G0rO!BeQpO1G0rO!BmQMhO1G0rOOQ!0Lb1G5z1G5zO!BYQ!0LrO1G0[OOQO1G0k1G0kO%[QlO1G0kO$>|Q!0LrO1G0kO$?XQ!0LrO1G0kO!BeQpO1G0[OCuQpO1G0[O$?gQ!0LrO1G0kOOQO1G0[1G0[O$?{Q!0MxO1G0kPOOO-E<Y-E<YPOOO1G.h1G.hOOOO1G/g1G/gO$@VQ!bO,5<hO$@_Q!fO1G4hOOQO1G4n1G4nO%[QlO,5>|O$@iQ`O1G5xO$@qQ`O1G6WO$@yQ!fO1G6XO9ZQ`O,5?SO$ATQ!0MxO1G6UO%[QlO1G6UO$AeQ!0LrO1G6UO$AvQ`O1G6TO$AvQ`O1G6TO9ZQ`O1G6TO$BOQ`O,5?VO9ZQ`O,5?VOOQO,5?V,5?VO$BdQ`O,5?VO$)iQ`O,5?VOOQO-E<i-E<iOOQS1G0_1G0_OOQS1G0a1G0aO#-tQ`O1G0aOOQ[7+(d7+(dO!&iQMhO7+(dO%[QlO7+(dO$BrQ`O7+(dO$B}QMhO7+(dO$C]Q!0MzO,5=WO$EhQ!0MzO,5=YO$GsQ!0MzO,5=WO$JUQ!0MzO,5=YO$LgQ!0MzO,59sO$NlQ!0MzO,5<jO%!wQ!0MzO,5<lO%%SQ!0MzO,5<zOOQ!0Lf7+&_7+&_O%'eQ!0MxO7+&_O%(XQlO'#IdO%(fQ`O,5@aO%(nQ!fO,5@aOOQ!0Lf1G/}1G/}O%(xQ`O7+&hOOQ!0Lf7+&h7+&hO%(}Q?MtO,5:dO%[QlO7+&yO%)XQ?MtO,5:`O%)fQ?MtO,5:hO%)pQ?MtO,5:jO%)zQMhO'#IgO%*UQ`O,5@fOOQ!0Lh1G0b1G0bOOQO1G1q1G1qOOQO1G1r1G1rO%*^Q!jO,5<YO!(yQlO,5<XOOQO-E<j-E<jOOQ!0Lf7+'X7+'XOOOW7+'d7+'dOOOW1G1{1G1{O%*iQ`O1G1{OOQ!0Lf1G1}1G1}OOOO,59m,59mO%*nQ!dO,59mOOOO-E<^-E<^OOQ!0Lh1G/V1G/VO%*uQ!0MxO7+'jOOQ!0Lh,5?[,5?[O%+iQMhO1G2eP%+pQ`O'#IpPOQ!0Lh-E<n-E<nO%,^QMjO,5?_OOQ!0Lh-E<q-E<qO%-PQMjO,5?aOOQ!0Lh-E<s-E<sO%-ZQ!dO1G2vO%-bQ!dO'#CrO%-xQMhO'#KQO$#^QlO'#JtOOQ!0Lh1G2^1G2^O%.PQ`O'#IoO%.eQ`O,5@tO%.eQ`O,5@tO%.mQ`O,5@tO%.xQ`O,5@tOOQO1G2`1G2`O%/WQMjO1G2_O!+rQMhO1G2_O%/hQ(CWO'#IqO%/uQ`O,5@uO!&iQMhO,5@uO%/}Q!dO,5@uOOQ!0Lh1G2c1G2cO%2_Q!fO'#CiO%2iQ`O,5=OOOQ!0Lb,5<|,5<|O%2qQpO,5<|OOQ!0Lb,5<},5<}OCfQ`O,5<|O%2|QpO,5<|OOQ!0Lb,5=Q,5=QO$)iQ`O,5=UOOQO,5?^,5?^OOQO-E<p-E<pOOQ!0Lp1G2g1G2gO##hQpO,5<|O$#^QlO,5=OO%3[Q`O,5<}O%3gQpO,5<}O!+rQMhO'#IsO%4aQMjO1G2rO!+rQMhO'#IuO%5SQMjO1G2tO%5^QMjO1G5oO%5hQMjO1G5oOOQO,5?c,5?cOOQO-E<u-E<uOOQO1G.{1G.{O!9lQpO,59uO%[QlO,59uOOQ!0Lh,5<i,5<iO%5uQ`O1G2YO!+rQMhO1G2aO!+rQMhO1G5oO!+rQMhO1G5oO%5zQ!0MxO7+'lOOQ!0Lf7+'l7+'lO!$fQlO7+'lO%6nQ`O,5;^OOQ!0Lb,5?e,5?eOOQ!0Lb-E<w-E<wO%6sQ!dO'#K[O#'cQ`O7+(dO4UQ!fO7+(dO$BuQ`O7+(dO%6}Q!0MvO'#CiO%7nQ!0LrO,5=RO%8PQ!0MvO,5=RO%8dQ`O,5=ROOQ!0Lb1G5m1G5mOOQ[7+$a7+$aO!BYQ!0LrO7+$aO!BeQpO7+$aO!$fQlO7+&_O%8lQ`O'#JOO%9TQ`O,5@}OOQO1G3f1G3fO9aQ`O,5@}O%9TQ`O,5@}O%9]Q`O,5@}OOQO,5?k,5?kOOQO-E<}-E<}OOQ!0Lf7+'S7+'SO%9bQ`O7+)PO9kQ!0LrO7+)PO9aQ`O7+)PO@iQ`O7+)POOQ[7+(o7+(oO%9gQ!0MvO7+(lO!&iQMhO7+(lO!DfQ`O7+(mOOQ[7+(m7+(mO!&iQMhO7+(mO%9qQ`O'#K`O%9|Q`O,5=kOOQO,5?g,5?gOOQO-E<y-E<yOOQ[7+(r7+(rO%;`QpO'#HYOOQ[1G3_1G3_O!&iQMhO1G3_O%[QlO1G3_O%;gQ`O1G3_O%;rQMhO1G3_O9kQ!0LrO1G3aO$#yQ`O1G3aO9UQ`O1G3aO!BeQpO1G3aO!BmQMhO1G3aO%<QQ`O'#I}O%<fQ`O,5@{O%<nQpO,5@{OOQ!0Lb1G3b1G3bOOQ[7+$V7+$VO@iQ`O7+$VO9kQ!0LrO7+$VO%<yQ`O7+$VO%[QlO1G6jO%[QlO1G6kO%=OQ!0LrO1G6jO%=YQlO1G3iO%=aQ`O1G3iO%=fQlO1G3iOOQ[7+)R7+)RO9kQ!0LrO7+)]O`QlO7+)_OOQ['#Kf'#KfOOQ['#JQ'#JQO%=mQlO,5>^OOQ[,5>^,5>^O%[QlO'#HsO%=zQ`O'#HuOOQ[,5>d,5>dO9ZQ`O,5>dOOQ[,5>f,5>fOOQ[7+)h7+)hOOQ[7+)n7+)nOOQ[7+)r7+)rOOQ[7+)t7+)tO%>PQpO1G5zO%>kQ?MtO1G0xO%>uQ`O1G0xOOQO1G/q1G/qO%?QQ?MtO1G/qO>wQ`O1G/qO!(yQlO'#DkOOQO,5>},5>}OOQO-E<a-E<aOOQO,5?T,5?TOOQO-E<g-E<gO!BeQpO1G/qOOQO-E<c-E<cOOQ!0Ln1G0Z1G0ZOOQ!0Lf7+%s7+%sO#'cQ`O7+%sOOQ!0Lf7+&^7+&^O>wQ`O7+&^O!BeQpO7+&^OOQO7+%v7+%vO$?{Q!0MxO7+&VOOQO7+&V7+&VO%[QlO7+&VO%?[Q!0LrO7+&VO!BYQ!0LrO7+%vO!BeQpO7+%vO%?gQ!0LrO7+&VO%?uQ!0MxO7++pO%[QlO7++pO%@VQ`O7++oO%@VQ`O7++oOOQO1G4q1G4qO9ZQ`O1G4qO%@_Q`O1G4qOOQS7+%{7+%{O#'cQ`O<<LOO4UQ!fO<<LOO%@mQ`O<<LOOOQ[<<LO<<LOO!&iQMhO<<LOO%[QlO<<LOO%@uQ`O<<LOO%AQQ!0MzO,5?_O%C]Q!0MzO,5?aO%EhQ!0MzO1G2_O%GyQ!0MzO1G2rO%JUQ!0MzO1G2tO%LaQ!fO,5?OO%[QlO,5?OOOQO-E<b-E<bO%LkQ`O1G5{OOQ!0Lf<<JS<<JSO%LsQ?MtO1G0sO%NzQ?MtO1G0}O& RQ?MtO1G0}O&#SQ?MtO1G0}O&#ZQ?MtO1G0}O&%[Q?MtO1G0}O&']Q?MtO1G0}O&'dQ?MtO1G0}O&'kQ?MtO1G0}O&)lQ?MtO1G0}O&)sQ?MtO1G0}O&)zQ!0MxO<<JeO&+rQ?MtO1G0}O&,oQ?MvO1G0}O&-rQ?MvO'#JjO&/xQ?MtO1G1bO&0VQ?MtO1G0SO&0aQMjO,5?ROOQO-E<e-E<eO!(yQlO'#FpOOQO'#KX'#KXOOQO1G1t1G1tO&0kQ`O1G1sO&0pQ?MtO,5?YOOOW7+'g7+'gOOOO1G/X1G/XO&0zQ!dO1G4vOOQ!0Lh7+(P7+(PP!&iQMhO,5?[O!+rQMhO7+(bO&1RQ`O,5?ZO9ZQ`O,5?ZOOQO-E<m-E<mO&1aQ`O1G6`O&1aQ`O1G6`O&1iQ`O1G6`O&1tQMjO7+'yO&2UQ!dO,5?]O&2`Q`O,5?]O!&iQMhO,5?]OOQO-E<o-E<oO&2eQ!dO1G6aO&2oQ`O1G6aO&2wQ`O1G2jO!&iQMhO1G2jOOQ!0Lb1G2h1G2hOOQ!0Lb1G2i1G2iO%2qQpO1G2hO!BeQpO1G2hOCfQ`O1G2hOOQ!0Lb1G2p1G2pO&2|QpO1G2hO&3[Q`O1G2jO$)iQ`O1G2iOCfQ`O1G2iO$#^QlO1G2jO&3dQ`O1G2iO&4WQMjO,5?_OOQ!0Lh-E<r-E<rO&4yQMjO,5?aOOQ!0Lh-E<t-E<tO!+rQMhO7++ZOOQ!0Lh1G/a1G/aO&5TQ`O1G/aOOQ!0Lh7+'t7+'tO&5YQMjO7+'{O&5jQMjO7++ZO&5tQMjO7++ZO&6RQ!0MxO<<KWOOQ!0Lf<<KW<<KWO&6uQ`O1G0xO!&iQMhO'#IxO&6zQ`O,5@vO&8|Q!fO<<LOO!&iQMhO1G2mO&9TQ!0LrO1G2mOOQ[<<G{<<G{O!BYQ!0LrO<<G{O&9fQ!0MxO<<IyOOQ!0Lf<<Iy<<IyOOQO,5?j,5?jO&:YQ`O,5?jO&:_Q`O,5?jOOQO-E<|-E<|O&:mQ`O1G6iO&:mQ`O1G6iO9aQ`O1G6iO@iQ`O<<LkOOQ[<<Lk<<LkO&:uQ`O<<LkO9kQ!0LrO<<LkOOQ[<<LW<<LWO%9gQ!0MvO<<LWOOQ[<<LX<<LXO!DfQ`O<<LXO&:zQpO'#IzO&;VQ`O,5@zO!(yQlO,5@zOOQ[1G3V1G3VOOQO'#I|'#I|O9kQ!0LrO'#I|O&;_QpO,5=tOOQ[,5=t,5=tO&;fQpO'#EeO&;mQpO'#GdO&;rQ`O7+(yO&;wQ`O7+(yOOQ[7+(y7+(yO!&iQMhO7+(yO%[QlO7+(yO&<PQ`O7+(yOOQ[7+({7+({O9kQ!0LrO7+({O$#yQ`O7+({O9UQ`O7+({O!BeQpO7+({O&<[Q`O,5?iOOQO-E<{-E<{OOQO'#H]'#H]O&<gQ`O1G6gO9kQ!0LrO<<GqOOQ[<<Gq<<GqO@iQ`O<<GqO&<oQ`O7+,UO&<tQ`O7+,VO%[QlO7+,UO%[QlO7+,VOOQ[7+)T7+)TO&<yQ`O7+)TO&=OQlO7+)TO&=VQ`O7+)TOOQ[<<Lw<<LwOOQ[<<Ly<<LyOOQ[-E=O-E=OOOQ[1G3x1G3xO&=[Q`O,5>_OOQ[,5>a,5>aO&=aQ`O1G4OO9ZQ`O7+&dO!(yQlO7+&dOOQO7+%]7+%]O&=fQ?MtO1G6XO>wQ`O7+%]OOQ!0Lf<<I_<<I_OOQ!0Lf<<Ix<<IxO>wQ`O<<IxOOQO<<Iq<<IqO$?{Q!0MxO<<IqO%[QlO<<IqOOQO<<Ib<<IbO!BYQ!0LrO<<IbO&=pQ!0LrO<<IqO&={Q!0MxO<= [O&>]Q`O<= ZOOQO7+*]7+*]O9ZQ`O7+*]OOQ[ANAjANAjO&>eQ!fOANAjO!&iQMhOANAjO#'cQ`OANAjO4UQ!fOANAjO&>lQ`OANAjO%[QlOANAjO&>tQ!0MzO7+'yO&AVQ!0MzO,5?_O&CbQ!0MzO,5?aO&EmQ!0MzO7+'{O&HOQ!fO1G4jO&HYQ?MtO7+&_O&J^Q?MvO,5=WO&LeQ?MvO,5=YO&LuQ?MvO,5=WO&MVQ?MvO,5=YO&MgQ?MvO,59sO' mQ?MvO,5<jO'#pQ?MvO,5<lO'&UQ?MvO,5<zO''zQ?MtO7+'jO'(XQ?MtO7+'lO'(fQ`O,5<[OOQO7+'_7+'_OOQ!0Lh7+*b7+*bO'(kQMjO<<K|OOQO1G4u1G4uO'(rQ`O1G4uO'(}Q`O1G4uO')]Q`O7++zO')]Q`O7++zO!&iQMhO1G4wO')eQ!dO1G4wO')oQ`O7++{O')wQ`O7+(UO'*SQ!dO7+(UOOQ!0Lb7+(S7+(SOOQ!0Lb7+(T7+(TO!BeQpO7+(SOCfQ`O7+(SO'*^Q`O7+(UO!&iQMhO7+(UO$)iQ`O7+(TO'*cQ`O7+(UOCfQ`O7+(TO'*kQMjO<<NuOOQ!0Lh7+${7+${O!+rQMhO<<NuO'*uQ!dO,5?dOOQO-E<v-E<vO'+PQ!0MvO7+(XO!&iQMhO7+(XOOQ[AN=gAN=gO9aQ`O1G5UOOQO1G5U1G5UO'+aQ`O1G5UO'+fQ`O7+,TO'+fQ`O7+,TO9kQ!0LrOANBVO@iQ`OANBVOOQ[ANBVANBVOOQ[ANArANArOOQ[ANAsANAsO'+nQ`O,5?fOOQO-E<x-E<xO'+yQ?MtO1G6fOOQO,5?h,5?hOOQO-E<z-E<zOOQ[1G3`1G3`O',TQ`O,5=OOOQ[<<Le<<LeO!&iQMhO<<LeO&;rQ`O<<LeO',YQ`O<<LeO%[QlO<<LeOOQ[<<Lg<<LgO9kQ!0LrO<<LgO$#yQ`O<<LgO9UQ`O<<LgO',bQpO1G5TO',mQ`O7+,ROOQ[AN=]AN=]O9kQ!0LrOAN=]OOQ[<= p<= pOOQ[<= q<= qO',uQ`O<= pO',zQ`O<= qOOQ[<<Lo<<LoO'-PQ`O<<LoO'-UQlO<<LoOOQ[1G3y1G3yO>wQ`O7+)jO'-]Q`O<<JOO'-hQ?MtO<<JOOOQO<<Hw<<HwOOQ!0LfAN?dAN?dOOQOAN?]AN?]O$?{Q!0MxOAN?]OOQOAN>|AN>|O%[QlOAN?]OOQO<<Mw<<MwOOQ[G27UG27UO!&iQMhOG27UO#'cQ`OG27UO'-rQ!fOG27UO4UQ!fOG27UO'-yQ`OG27UO'.RQ?MtO<<JeO'.`Q?MvO1G2_O'0UQ?MvO,5?_O'2XQ?MvO,5?aO'4[Q?MvO1G2rO'6_Q?MvO1G2tO'8bQ?MtO<<KWO'8oQ?MtO<<IyOOQO1G1v1G1vO!+rQMhOANAhOOQO7+*a7+*aO'8|Q`O7+*aO'9XQ`O<= fO'9aQ!dO7+*cOOQ!0Lb<<Kp<<KpO$)iQ`O<<KpOCfQ`O<<KpO'9kQ`O<<KpO!&iQMhO<<KpOOQ!0Lb<<Kn<<KnO!BeQpO<<KnO'9vQ!dO<<KpOOQ!0Lb<<Ko<<KoO':QQ`O<<KpO!&iQMhO<<KpO$)iQ`O<<KoO':VQMjOANDaO':aQ!0MvO<<KsOOQO7+*p7+*pO9aQ`O7+*pO':qQ`O<= oOOQ[G27qG27qO9kQ!0LrOG27qO!(yQlO1G5QO':yQ`O7+,QO';RQ`O1G2jO&;rQ`OANBPOOQ[ANBPANBPO!&iQMhOANBPO';WQ`OANBPOOQ[ANBRANBRO9kQ!0LrOANBRO$#yQ`OANBROOQO'#H^'#H^OOQO7+*o7+*oOOQ[G22wG22wOOQ[ANE[ANE[OOQ[ANE]ANE]OOQ[ANBZANBZO';`Q`OANBZOOQ[<<MU<<MUO!(yQlOAN?jOOQOG24wG24wO$?{Q!0MxOG24wO#'cQ`OLD,pOOQ[LD,pLD,pO!&iQMhOLD,pO';eQ!fOLD,pO';lQ?MvO7+'yO'=bQ?MvO,5?_O'?eQ?MvO,5?aO'AhQ?MvO7+'{O'C^QMjOG27SOOQO<<M{<<M{OOQ!0LbANA[ANA[O$)iQ`OANA[OCfQ`OANA[O'CnQ!dOANA[OOQ!0LbANAYANAYO'CuQ`OANA[O!&iQMhOANA[O'DQQ!dOANA[OOQ!0LbANAZANAZOOQO<<N[<<N[OOQ[LD-]LD-]O'D[Q?MtO7+*lOOQO'#Ge'#GeOOQ[G27kG27kO&;rQ`OG27kO!&iQMhOG27kOOQ[G27mG27mO9kQ!0LrOG27mOOQ[G27uG27uO'DfQ?MtOG25UOOQOLD*cLD*cOOQ[!$(![!$(![O#'cQ`O!$(![O!&iQMhO!$(![O'DpQ!0MzOG27SOOQ!0LbG26vG26vO$)iQ`OG26vO'GRQ`OG26vOCfQ`OG26vO'G^Q!dOG26vO!&iQMhOG26vOOQ[LD-VLD-VO&;rQ`OLD-VOOQ[LD-XLD-XOOQ[!)9Ev!)9EvO#'cQ`O!)9EvOOQ!0LbLD,bLD,bO$)iQ`OLD,bOCfQ`OLD,bO'GeQ`OLD,bO'GpQ!dOLD,bOOQ[!$(!q!$(!qOOQ[!.K;b!.K;bO'GwQ?MvOG27SOOQ!0Lb!$( |!$( |O$)iQ`O!$( |OCfQ`O!$( |O'ImQ`O!$( |OOQ!0Lb!)9Eh!)9EhO$)iQ`O!)9EhOCfQ`O!)9EhOOQ!0Lb!.K;S!.K;SO$)iQ`O!.K;SOOQ!0Lb!4/0n!4/0nO!(yQlO'#DxO1PQ`O'#EVO'IxQ!fO'#JpO'JPQ!L^O'#DtO'JWQlO'#D|O'J_Q!fO'#CiO'LuQ!fO'#CiO!(yQlO'#EOO'MVQlO,5;XO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO,5;cO!(yQlO'#InO( YQ`O,5<hO!(yQlO,5;cO( bQMhO,5;cO(!{QMhO,5;cO!(yQlO,5;vO!&iQMhO'#GlO( bQMhO'#GlO!&iQMhO'#GnO( bQMhO'#GnO1SQ`O'#DXO1SQ`O'#DXO!&iQMhO'#GOO( bQMhO'#GOO!&iQMhO'#GQO( bQMhO'#GQO!&iQMhO'#G`O( bQMhO'#G`O!(yQlO,5:hO(#SQpO'#D]O(#^QpO'#JtO!(yQlO,5@mO'MVQlO1G0sO(#hQ?MtO'#CiO!(yQlO1G2OO!&iQMhO'#IsO( bQMhO'#IsO!&iQMhO'#IuO( bQMhO'#IuO(#rQ!dO'#CrO!&iQMhO,5<sO( bQMhO,5<sO'MVQlO1G2QO!(yQlO7+&yO!&iQMhO1G2_O( bQMhO1G2_O!&iQMhO'#IsO( bQMhO'#IsO!&iQMhO'#IuO( bQMhO'#IuO!&iQMhO1G2aO( bQMhO1G2aO'MVQlO7+'lO'MVQlO7+&_O!&iQMhOANAhO( bQMhOANAhO($VQ`O'#EmO($[Q`O'#EmO($dQ`O'#F[O($iQ`O'#EwO($nQ`O'#KRO($yQ`O'#KPO(%UQ`O,5;XO(%ZQMjO,5<dO(%bQ`O'#GXO(%gQ`O'#GXO(%lQ`O,5<fO(%tQ`O,5;XO(%|Q?MtO1G1_O(&TQ`O,5<sO(&YQ`O,5<sO(&_Q`O,5<uO(&dQ`O,5<uO(&iQ`O1G2QO(&nQ`O1G0sO(&sQMjO<<K|O(&zQMjO<<K|O7eQMhO'#F{O9UQ`O'#FzOAdQ`O'#ElO!(yQlO,5;sO!3^Q`O'#GXO!3^Q`O'#GXO!3^Q`O'#GZO!3^Q`O'#GZO!+rQMhO7+(bO!+rQMhO7+(bO%-ZQ!dO1G2vO%-ZQ!dO1G2vO!&iQMhO,5=[O!&iQMhO,5=[",
  stateData: "((P~O'zOS'{OSTOS'|RQ~OPYOQYOSfOY!VOaqOdzOeyOj!POnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]XO!guO!jZO!mYO!nYO!oYO!qvO!swO!vxO!z]O$V|O$miO%g}O%i!QO%k!OO%l!OO%m!OO%p!RO%r!SO%u!TO%v!TO%x!UO&U!WO&[!XO&^!YO&`!ZO&b![O&e!]O&k!^O&q!_O&s!`O&u!aO&w!bO&y!cO(RSO(TTO(WUO(_VO(m[O~OWtO~P`OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(R!dO(TTO(WUO(_VO(m[O~Oa!wOq!nO!Q!oO!`!yO!a!vO!b!vO!z;wO#R!pO#S!pO#T!xO#U!pO#V!pO#Y!zO#Z!zO(S!lO(TTO(WUO(c!mO(m!sO~O'|!{O~OP]XR]X[]Xa]Xp]X!O]X!Q]X!Z]X!j]X!n]X#P]X#Q]X#^]X#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X'x]X(_]X(p]X(w]X(x]X~O!e%QX~P(qO_!}O(T#PO(U!}O(V#PO~O_#QO(V#PO(W#PO(X#QO~Ov#SO!S#TO(`#TO(a#VO~OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(R;{O(TTO(WUO(_VO(m[O~O!Y#ZO!Z#WO!W(fP!W(tP~P+}O![#cO~P`OPYOQYOSfOd!jOe!iOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(TTO(WUO(_VO(m[O~On#mO!Y#iO!z]O#g#lO#h#iO(R;|O!i(qP~P.iO!j#oO(R#nO~O!v#sO!z]O%g#tO~O#i#uO~O!e#vO#i#uO~OP$[OR#zO[$cOp$aO!O#yO!Q#{O!Z$_O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO#y$WO#z$XO(_VO(p$YO(w#|O(x#}O~Oa(dX'x(dX'u(dX!i(dX!W(dX!](dX%h(dX!e(dX~P1qO#Q$dO#^$eO$P$eOP(eXR(eX[(eXp(eX!O(eX!Q(eX!Z(eX!j(eX!n(eX#P(eX#l(eX#m(eX#n(eX#o(eX#p(eX#q(eX#r(eX#s(eX#t(eX#u(eX#w(eX#y(eX#z(eX(_(eX(p(eX(w(eX(x(eX!](eX%h(eX~Oa(eX'x(eX'u(eX!W(eX!i(eXt(eX!e(eX~P4UO#^$eO~O$[$hO$^$gO$e$mO~OSfO!]$nO$h$oO$j$qO~Oh%VOj%cOn%WOp%XOq$tOr$tOx%YOz%ZO|%[O!Q${O!]$|O!g%aO!j$xO#h%bO$V%_O$s%]O$u%^O$x%`O(R$sO(TTO(WUO(_$uO(w$}O(x%POg([P~O!j%dO~O!Q%gO!]%hO(R%fO~O!e%lO~Oa%mO'x%mO~O!O%qO~P%[O(S!lO~P%[O%m%uO~P%[Oh%VO!j%dO(R%fO(S!lO~Oe%|O!j%dO(R%fO~O#t$RO~O!O&RO!]&OO!j&QO%i&UO(R%fO(S!lO(TTO(WUO`)UP~O!v#sO~O%r&WO!Q)QX!])QX(R)QX~O(R&XO~Oj!PO!s&^O%i!QO%k!OO%l!OO%m!OO%p!RO%r!SO%u!TO%v!TO~Od&cOe&bO!v&`O%g&aO%z&_O~P<POd&fOeyOj!PO!]&eO!s&^O!vxO!z]O%g}O%k!OO%l!OO%m!OO%p!RO%r!SO%u!TO%v!TO%x!UO~Ob&iO#^&lO%i&gO(S!lO~P=UO!j&mO!s&qO~O!j#oO~O!]XO~Oa%mO'v&yO'x%mO~Oa%mO'v&|O'x%mO~Oa%mO'v'OO'x%mO~O'u]X!W]Xt]X!i]X&Y]X!]]X%h]X!e]X~P(qO!`']O!a'UO!b'UO(S!lO(TTO(WUO~Oq'SO!Q'RO!Y'VO(c'QO![(gP![(vP~P@]Ol'`O!]'^O(R%fO~Oe'eO!j%dO(R%fO~O!O&RO!j&QO~Oq!nO!Q!oO!z;wO#R!pO#S!pO#U!pO#V!pO(S!lO(TTO(WUO(c!mO(m!sO~O!`'kO!a'jO!b'jO#T!pO#Y'lO#Z'lO~PAwOa%mOh%VO!e#vO!j%dO'x%mO(p'nO~O!n'rO#^'pO~PCVOq!nO!Q!oO(TTO(WUO(c!mO(m!sO~O!]XOq(kX!Q(kX!`(kX!a(kX!b(kX!z(kX#R(kX#S(kX#T(kX#U(kX#V(kX#Y(kX#Z(kX(S(kX(T(kX(W(kX(c(kX(m(kX~O!a'jO!b'jO(S!lO~PCuO'}'vO(O'vO(P'xO~O_!}O(T'zO(U!}O(V'zO~O_#QO(V'zO(W'zO(X#QO~Ot'|O~P%[Ov#SO!S#TO(`#TO(a(PO~O!Y(RO!W'UX!W'[X!Z'UX!Z'[X~P+}O!Z(TO!W(fX~OP$[OR#zO[$cOp$aO!O#yO!Q#{O!Z(TO!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO#y$WO#z$XO(_VO(p$YO(w#|O(x#}O~O!W(fX~PGpO!W(YO~O!W(sX!Z(sX!e(sX!i(sX(p(sX~O#^(sX#i#bX![(sX~PIsO#^(ZO!W(uX!Z(uX~O!Z([O!W(tX~O!W(_O~O#^$eO~PIsO![(`O~P`OR#zO!O#yO!Q#{O!j#xO(_VOP!la[!lap!la!Z!la!n!la#P!la#l!la#m!la#n!la#o!la#p!la#q!la#r!la#s!la#t!la#u!la#w!la#y!la#z!la(p!la(w!la(x!la~Oa!la'x!la'u!la!W!la!i!lat!la!]!la%h!la!e!la~PKZO!i(aO~O!e#vO#^(bO(p'nO!Z(rXa(rX'x(rX~O!i(rX~PMvO!Q%gO!]%hO!z]O#g(gO#h(fO(R%fO~O!Z(hO!i(qX~O!i(jO~O!Q%gO!]%hO#h(fO(R%fO~OP(eXR(eX[(eXp(eX!O(eX!Q(eX!Z(eX!j(eX!n(eX#P(eX#l(eX#m(eX#n(eX#o(eX#p(eX#q(eX#r(eX#s(eX#t(eX#u(eX#w(eX#y(eX#z(eX(_(eX(p(eX(w(eX(x(eX~O!e#vO!i(eX~P! dOR(lO!O(kO!j#xO#Q$dO!z!ya!Q!ya~O!v!ya%g!ya!]!ya#g!ya#h!ya(R!ya~P!#eO!v(pO~OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]XO!guO!jZO!mYO!nYO!oYO!qvO!s!gO!v!hO$V!kO$miO(R!dO(TTO(WUO(_VO(m[O~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<eO!Q${O!]$|O!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(R(tO(TTO(WUO(_$uO(w$}O(x%PO~O#i(vO~O!Y(xO!i(iP~P%[O(c(zO(m[O~O!Q(|O!j#xO(c(zO(m[O~OP;vOQ;vOSfOd=rOe!iOnkOp;vOqkOrkOxkOz;vO|;vO!QWO!UkO!VkO!]!eO!g;yO!jZO!m;vO!n;vO!o;vO!q;zO!s;}O!v!hO$V!kO$m=pO(R)ZO(TTO(WUO(_VO(m[O~O!Z$_Oa$pa'x$pa'u$pa!i$pa!W$pa!]$pa%h$pa!e$pa~Oj)bO~P!&iOh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|%[O!Q${O!]$|O!g%aO!j$xO#h%bO$V%_O$s%]O$u%^O$x%`O(R(tO(TTO(WUO(_$uO(w$}O(x%PO~Og(nP~P!+rO!O)gO!e)fO!]$]X$Y$]X$[$]X$^$]X$e$]X~O!e)fO!](yX$Y(yX$[(yX$^(yX$e(yX~O!O)gO~P!-{O!O)gO!](yX$Y(yX$[(yX$^(yX$e(yX~O!])iO$Y)mO$[)hO$^)hO$e)nO~O!Y)qO~P!(yO$[$hO$^$gO$e)uO~Ol$yX!O$yX#Q$yX'w$yX(w$yX(x$yX~OgkXg$yXlkX!ZkX#^kX~P!/qOv)wO(`)xO(a)zO~Ol*TO!O)|O'w)}O(w$}O(x%PO~Og){O~P!0uOg*UO~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<eO!Q*WO!]*XO!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(TTO(WUO(_$uO(w$}O(x%PO~O!Y*[O(R*VO!i(|P~P!1dO#i*^O~O!j*_O~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<eO!Q${O!]$|O!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(R*aO(TTO(WUO(_$uO(w$}O(x%PO~O!Y*dO!W(}P~P!3cOp*pOq!nO!Q*fO!`*nO!a*hO!b*hO!j*_O#Y*oO%_*jO(S!lO(TTO(WUO(c!mO~O![*mO~P!5WO#Q$dOl(^X!O(^X'w(^X(w(^X(x(^X!Z(^X#^(^X~Og(^X#}(^X~P!6YOl*uO#^*tOg(]X!Z(]X~O!Z*vOg([X~Oj%cO(R&XOg([P~Oq*yO~O!j+OO~O(R(tO~On+TO!Q%gO!Y#iO!]%hO!z]O#g#lO#h#iO(R%fO!i(qP~O!e#vO#i+UO~O!Q%gO!Y+WO!Z([O!]%hO(R%fO!W(tP~Oq'YO!Q+YO!Y+XO(TTO(WUO(c(zO~O![(vP~P!9]O!Z+ZOa)RX'x)RX~OP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO#y$WO#z$XO(_VO(p$YO(w#|O(x#}O~Oa!ha!Z!ha'x!ha'u!ha!W!ha!i!hat!ha!]!ha%h!ha!e!ha~P!:TOR#zO!O#yO!Q#{O!j#xO(_VOP!pa[!pap!pa!Z!pa!n!pa#P!pa#l!pa#m!pa#n!pa#o!pa#p!pa#q!pa#r!pa#s!pa#t!pa#u!pa#w!pa#y!pa#z!pa(p!pa(w!pa(x!pa~Oa!pa'x!pa'u!pa!W!pa!i!pat!pa!]!pa%h!pa!e!pa~P!<kOR#zO!O#yO!Q#{O!j#xO(_VOP!ra[!rap!ra!Z!ra!n!ra#P!ra#l!ra#m!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#w!ra#y!ra#z!ra(p!ra(w!ra(x!ra~Oa!ra'x!ra'u!ra!W!ra!i!rat!ra!]!ra%h!ra!e!ra~P!?ROh%VOl+dO!]'^O%h+cO~O!e+fOa(ZX!](ZX'x(ZX!Z(ZX~Oa%mO!]XO'x%mO~Oh%VO!j%dO~Oh%VO!j%dO(R%fO~O!e#vO#i(vO~Ob+qO%i+rO(R+nO(TTO(WUO![)VP~O!Z+sO`)UX~O[+wO~O`+xO~O!]&OO(R%fO(S!lO`)UP~Oh%VO#^+}O~Oh%VOl,QO!]$|O~O!],SO~O!O,UO!]XO~O%m%uO~O!v,ZO~Oe,`O~Ob,aO(R#nO(TTO(WUO![)TP~Oe%|O~O%i!QO(R&XO~P=UO[,fO`,eO~OPYOQYOSfOdzOeyOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!guO!jZO!mYO!nYO!oYO!qvO!vxO!z]O$miO%g}O(TTO(WUO(_VO(m[O~O!]!eO!s!gO$V!kO(R!dO~P!FRO`,eOa%mO'x%mO~OPYOQYOSfOd!jOe!iOnkOpYOqkOrkOxkOzYO|YO!QWO!UkO!VkO!]!eO!guO!jZO!mYO!nYO!oYO!qvO!v!hO$V!kO$miO(R!dO(TTO(WUO(_VO(m[O~Oa,kOj!OO!swO%k!OO%l!OO%m!OO~P!HkO!j&mO~O&[,qO~O!],sO~O&m,uO&o,vOP&jaQ&jaS&jaY&jaa&jad&jae&jaj&jan&jap&jaq&jar&jax&jaz&ja|&ja!Q&ja!U&ja!V&ja!]&ja!g&ja!j&ja!m&ja!n&ja!o&ja!q&ja!s&ja!v&ja!z&ja$V&ja$m&ja%g&ja%i&ja%k&ja%l&ja%m&ja%p&ja%r&ja%u&ja%v&ja%x&ja&U&ja&[&ja&^&ja&`&ja&b&ja&e&ja&k&ja&q&ja&s&ja&u&ja&w&ja&y&ja'u&ja(R&ja(T&ja(W&ja(_&ja(m&ja![&ja&c&jab&ja&h&ja~O(R,{O~Oh!cX!Z!PX![!PX!e!PX!e!cX!j!cX#^!PX~O!Z!cX![!cX~P# qO!e-QO#^-POh(hX!Z#fX![#fX!e(hX!j(hX~O!Z(hX![(hX~P#!dOh%VO!e-SO!j%dO!Z!_X![!_X~Oq!nO!Q!oO(TTO(WUO(c!mO~OP;vOQ;vOSfOd=rOe!iOnkOp;vOqkOrkOxkOz;vO|;vO!QWO!UkO!VkO!]!eO!g;yO!jZO!m;vO!n;vO!o;vO!q;zO!s;}O!v!hO$V!kO$m=pO(TTO(WUO(_VO(m[O~O(R<rO~P##yO!Z-WO![(gX~O![-YO~O!e-QO#^-PO!Z#fX![#fX~O!Z-ZO![(vX~O![-]O~O!a-^O!b-^O(S!lO~P##hO![-aO~P'_Ol-dO!]'^O~O!W-iO~Oq!ya!`!ya!a!ya!b!ya#R!ya#S!ya#T!ya#U!ya#V!ya#Y!ya#Z!ya(S!ya(T!ya(W!ya(c!ya(m!ya~P!#eO!n-nO#^-lO~PCVO!a-pO!b-pO(S!lO~PCuOa%mO#^-lO'x%mO~Oa%mO!e#vO#^-lO'x%mO~Oa%mO!e#vO!n-nO#^-lO'x%mO(p'nO~O'}'vO(O'vO(P-uO~Ot-vO~O!W'Ua!Z'Ua~P!:TO!Y-zO!W'UX!Z'UX~P%[O!Z(TO!W(fa~O!W(fa~PGpO!Z([O!W(ta~O!Q%gO!Y.OO!]%hO(R%fO!W'[X!Z'[X~O#^.QO!Z(ra!i(raa(ra'x(ra~O!e#vO~P#,PO!Z(hO!i(qa~O!Q%gO!]%hO#h.UO(R%fO~On.ZO!Q%gO!Y.WO!]%hO!z]O#g.YO#h.WO(R%fO!Z'_X!i'_X~OR._O!j#xO~Oh%VOl.bO!]'^O%h.aO~Oa#ai!Z#ai'x#ai'u#ai!W#ai!i#ait#ai!]#ai%h#ai!e#ai~P!:TOl=|O!O)|O'w)}O(w$}O(x%PO~O#i#]aa#]a#^#]a'x#]a!Z#]a!i#]a!]#]a!W#]a~P#.{O#i(^XP(^XR(^X[(^Xa(^Xp(^X!Q(^X!j(^X!n(^X#P(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#s(^X#t(^X#u(^X#w(^X#y(^X#z(^X'x(^X(_(^X(p(^X!i(^X!W(^X'u(^Xt(^X!](^X%h(^X!e(^X~P!6YO!Z.oO!i(iX~P!:TO!i.rO~O!W.tO~OP$[OR#zO!O#yO!Q#{O!j#xO!n$[O(_VO[#kia#kip#ki!Z#ki#P#ki#m#ki#n#ki#o#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki'x#ki(p#ki(w#ki(x#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#l#ki~P#2kO#l$OO~P#2kOP$[OR#zOp$aO!O#yO!Q#{O!j#xO!n$[O#l$OO#m$PO#n$PO#o$PO(_VO[#kia#ki!Z#ki#P#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki'x#ki(p#ki(w#ki(x#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#p#ki~P#5YO#p$QO~P#5YOP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO(_VOa#ki!Z#ki#w#ki#y#ki#z#ki'x#ki(p#ki(w#ki(x#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#u#ki~P#7wOP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO(_VO(x#}Oa#ki!Z#ki#y#ki#z#ki'x#ki(p#ki(w#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#w$UO~P#:_O#w#ki~P#:_O#u$SO~P#7wOP$[OR#zO[$cOp$aO!O#yO!Q#{O!j#xO!n$[O#P$RO#l$OO#m$PO#n$PO#o$PO#p$QO#q$RO#r$RO#s$bO#t$RO#u$SO#w$UO(_VO(w#|O(x#}Oa#ki!Z#ki#z#ki'x#ki(p#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~O#y#ki~P#=TO#y$WO~P#=TOP]XR]X[]Xp]X!O]X!Q]X!j]X!n]X#P]X#Q]X#^]X#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X(_]X(p]X(w]X(x]X!Z]X![]X~O#}]X~P#?rOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO#u<TO#w<VO#y<XO#z<YO(_VO(p$YO(w#|O(x#}O~O#}.vO~P#BPO#Q$dO#^<`O$P<`O#}(eX![(eX~P! dOa'ba!Z'ba'x'ba'u'ba!i'ba!W'bat'ba!]'ba%h'ba!e'ba~P!:TO[#kia#kip#ki!Z#ki#P#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki'x#ki(p#ki'u#ki!W#ki!i#kit#ki!]#ki%h#ki!e#ki~OP$[OR#zO!O#yO!Q#{O!j#xO!n$[O#l$OO#m$PO#n$PO#o$PO(_VO(w#ki(x#ki~P#EROl=|O!O)|O'w)}O(w$}O(x%POP#kiR#ki!Q#ki!j#ki!n#ki#l#ki#m#ki#n#ki#o#ki(_#ki~P#ERO!Z.zOg(nX~P!0uOg.|O~Oa$Oi!Z$Oi'x$Oi'u$Oi!W$Oi!i$Oit$Oi!]$Oi%h$Oi!e$Oi~P!:TO$[.}O$^.}O~O$[/OO$^/OO~O!e)fO#^/PO!]$bX$Y$bX$[$bX$^$bX$e$bX~O!Y/QO~O!])iO$Y/SO$[)hO$^)hO$e/TO~O!Z<ZO![(dX~P#BPO![/UO~O!e)fO$e(yX~O$e/WO~Ot/XO~P!&iOv)wO(`)xO(a/[O~O!Q/_O~O(w$}Ol%`a!O%`a'w%`a(x%`a!Z%`a#^%`a~Og%`a#}%`a~P#LTO(x%POl%ba!O%ba'w%ba(w%ba!Z%ba#^%ba~Og%ba#}%ba~P#LvO!ZfX!efX!ifX!i$yX(pfX~P!/qO!Y/hO!Z([O(R/gO!W(tP!W(}P~P!1dOp*pO!`*nO!a*hO!b*hO!j*_O#Y*oO%_*jO(S!lO(TTO(WUO~Oq<oO!Q/iO!Y+XO![*mO(c<nO![(vP~P#NaO!i/jO~P#.{O!Z/kO!e#vO(p'nO!i(|X~O!i/pO~O!Q%gO!Y*[O!]%hO(R%fO!i(|P~O#i/rO~O!W$yX!Z$yX!e%QX~P!/qO!Z/sO!W(}X~P#.{O!e/uO~O!W/wO~OnkO(R/xO~P.iOh%VOp/}O!e#vO!j%dO(p'nO~O!e+fO~Oa%mO!Z0RO'x%mO~O![0TO~P!5WO!a0UO!b0UO(S!lO~P##hOq!nO!Q0VO(TTO(WUO(c!mO~O#Y0XO~Og%`a!Z%`a#^%`a#}%`a~P!0uOg%ba!Z%ba#^%ba#}%ba~P!0uOj%cO(R&XOg'kX!Z'kX~O!Z*vOg([a~Og0bO~OR0cO!O0cO!Q0dO#Q$dOl{a'w{a(w{a(x{a!Z{a#^{a~Og{a#}{a~P$&dO!O)|O'w)}Ol$ra(w$ra(x$ra!Z$ra#^$ra~Og$ra#}$ra~P$'`O!O)|O'w)}Ol$ta(w$ta(x$ta!Z$ta#^$ta~Og$ta#}$ta~P$(RO#i0gO~Og%Sa!Z%Sa#^%Sa#}%Sa~P!0uOl0iO#^0hOg(]a!Z(]a~O!e#vO~O#i0lO~O!Z+ZOa)Ra'x)Ra~OR#zO!O#yO!Q#{O!j#xO(_VOP!pi[!pip!pi!Z!pi!n!pi#P!pi#l!pi#m!pi#n!pi#o!pi#p!pi#q!pi#r!pi#s!pi#t!pi#u!pi#w!pi#y!pi#z!pi(p!pi(w!pi(x!pi~Oa!pi'x!pi'u!pi!W!pi!i!pit!pi!]!pi%h!pi!e!pi~P$*OOh%VOp%XOq$tOr$tOx%YOz%ZO|<eO!Q${O!]$|O!g=vO!j$xO#h<kO$V%_O$s<gO$u<iO$x%`O(TTO(WUO(_$uO(w$}O(x%PO~On0vO%[0wO(R0tO~P$,fO!e+fOa(Za!](Za'x(Za!Z(Za~O#i0|O~O[]X!ZfX![fX~O!Z0}O![)VX~O![1PO~O[1QO~Ob1SO(R+nO(TTO(WUO~O!]&OO(R%fO`'sX!Z'sX~O!Z+sO`)Ua~O!i1VO~P!:TO[1YO~O`1ZO~O#^1^O~Ol1aO!]$|O~O(c(zO![)SP~Oh%VOl1jO!]1gO%h1iO~O[1tO!Z1rO![)TX~O![1uO~O`1wOa%mO'x%mO~O(R#nO(TTO(WUO~O#Q$dO#^$eO$P$eOP(eXR(eX[(eXp(eX!O(eX!Q(eX!Z(eX!j(eX!n(eX#P(eX#l(eX#m(eX#n(eX#o(eX#p(eX#q(eX#r(eX#s(eX#u(eX#w(eX#y(eX#z(eX(_(eX(p(eX(w(eX(x(eX~O#t1zO&Y1{Oa(eX~P$2PO#^$eO#t1zO&Y1{O~Oa1}O~P%[Oa2PO~O&c2SOP&aiQ&aiS&aiY&aia&aid&aie&aij&ain&aip&aiq&air&aix&aiz&ai|&ai!Q&ai!U&ai!V&ai!]&ai!g&ai!j&ai!m&ai!n&ai!o&ai!q&ai!s&ai!v&ai!z&ai$V&ai$m&ai%g&ai%i&ai%k&ai%l&ai%m&ai%p&ai%r&ai%u&ai%v&ai%x&ai&U&ai&[&ai&^&ai&`&ai&b&ai&e&ai&k&ai&q&ai&s&ai&u&ai&w&ai&y&ai'u&ai(R&ai(T&ai(W&ai(_&ai(m&ai![&aib&ai&h&ai~Ob2YO![2WO&h2XO~P`O!]XO!j2[O~O&o,vOP&jiQ&jiS&jiY&jia&jid&jie&jij&jin&jip&jiq&jir&jix&jiz&ji|&ji!Q&ji!U&ji!V&ji!]&ji!g&ji!j&ji!m&ji!n&ji!o&ji!q&ji!s&ji!v&ji!z&ji$V&ji$m&ji%g&ji%i&ji%k&ji%l&ji%m&ji%p&ji%r&ji%u&ji%v&ji%x&ji&U&ji&[&ji&^&ji&`&ji&b&ji&e&ji&k&ji&q&ji&s&ji&u&ji&w&ji&y&ji'u&ji(R&ji(T&ji(W&ji(_&ji(m&ji![&ji&c&jib&ji&h&ji~O!W2bO~O!Z!_a![!_a~P#BPOq!nO!Q!oO!Y2hO(c!mO!Z'VX!['VX~P@]O!Z-WO![(ga~O!Z']X![']X~P!9]O!Z-ZO![(va~O![2oO~P'_Oa%mO#^2xO'x%mO~Oa%mO!e#vO#^2xO'x%mO~Oa%mO!e#vO!n2|O#^2xO'x%mO(p'nO~Oa%mO'x%mO~P!:TO!Z$_Ot$pa~O!W'Ui!Z'Ui~P!:TO!Z(TO!W(fi~O!Z([O!W(ti~O!W(ui!Z(ui~P!:TO!Z(ri!i(ria(ri'x(ri~P!:TO#^3OO!Z(ri!i(ria(ri'x(ri~O!Z(hO!i(qi~O!Q%gO!]%hO!z]O#g3TO#h3SO(R%fO~O!Q%gO!]%hO#h3SO(R%fO~Ol3[O!]'^O%h3ZO~Oh%VOl3[O!]'^O%h3ZO~O#i%`aP%`aR%`a[%`aa%`ap%`a!Q%`a!j%`a!n%`a#P%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#t%`a#u%`a#w%`a#y%`a#z%`a'x%`a(_%`a(p%`a!i%`a!W%`a'u%`at%`a!]%`a%h%`a!e%`a~P#LTO#i%baP%baR%ba[%baa%bap%ba!Q%ba!j%ba!n%ba#P%ba#l%ba#m%ba#n%ba#o%ba#p%ba#q%ba#r%ba#s%ba#t%ba#u%ba#w%ba#y%ba#z%ba'x%ba(_%ba(p%ba!i%ba!W%ba'u%bat%ba!]%ba%h%ba!e%ba~P#LvO#i%`aP%`aR%`a[%`aa%`ap%`a!Q%`a!Z%`a!j%`a!n%`a#P%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#t%`a#u%`a#w%`a#y%`a#z%`a'x%`a(_%`a(p%`a!i%`a!W%`a'u%`a#^%`at%`a!]%`a%h%`a!e%`a~P#.{O#i%baP%baR%ba[%baa%bap%ba!Q%ba!Z%ba!j%ba!n%ba#P%ba#l%ba#m%ba#n%ba#o%ba#p%ba#q%ba#r%ba#s%ba#t%ba#u%ba#w%ba#y%ba#z%ba'x%ba(_%ba(p%ba!i%ba!W%ba'u%ba#^%bat%ba!]%ba%h%ba!e%ba~P#.{O#i{aP{a[{aa{ap{a!j{a!n{a#P{a#l{a#m{a#n{a#o{a#p{a#q{a#r{a#s{a#t{a#u{a#w{a#y{a#z{a'x{a(_{a(p{a!i{a!W{a'u{at{a!]{a%h{a!e{a~P$&dO#i$raP$raR$ra[$raa$rap$ra!Q$ra!j$ra!n$ra#P$ra#l$ra#m$ra#n$ra#o$ra#p$ra#q$ra#r$ra#s$ra#t$ra#u$ra#w$ra#y$ra#z$ra'x$ra(_$ra(p$ra!i$ra!W$ra'u$rat$ra!]$ra%h$ra!e$ra~P$'`O#i$taP$taR$ta[$taa$tap$ta!Q$ta!j$ta!n$ta#P$ta#l$ta#m$ta#n$ta#o$ta#p$ta#q$ta#r$ta#s$ta#t$ta#u$ta#w$ta#y$ta#z$ta'x$ta(_$ta(p$ta!i$ta!W$ta'u$tat$ta!]$ta%h$ta!e$ta~P$(RO#i%SaP%SaR%Sa[%Saa%Sap%Sa!Q%Sa!Z%Sa!j%Sa!n%Sa#P%Sa#l%Sa#m%Sa#n%Sa#o%Sa#p%Sa#q%Sa#r%Sa#s%Sa#t%Sa#u%Sa#w%Sa#y%Sa#z%Sa'x%Sa(_%Sa(p%Sa!i%Sa!W%Sa'u%Sa#^%Sat%Sa!]%Sa%h%Sa!e%Sa~P#.{Oa#aq!Z#aq'x#aq'u#aq!W#aq!i#aqt#aq!]#aq%h#aq!e#aq~P!:TO!Y3dO!Z'WX!i'WX~P%[O!Z.oO!i(ia~O!Z.oO!i(ia~P!:TO!W3gO~O#}!la![!la~PKZO#}!ha!Z!ha![!ha~P#BPO#}!pa![!pa~P!<kO#}!ra![!ra~P!?ROg'ZX!Z'ZX~P!+rO!Z.zOg(na~OSfO!]3{O$c3|O~O![4QO~Ot4RO~P#.{Oa$lq!Z$lq'x$lq'u$lq!W$lq!i$lqt$lq!]$lq%h$lq!e$lq~P!:TO!W4TO~P!&iO!Q4UO~O!O)|O'w)}O(x%POl'ga(w'ga!Z'ga#^'ga~Og'ga#}'ga~P%+uO!O)|O'w)}Ol'ia(w'ia(x'ia!Z'ia#^'ia~Og'ia#}'ia~P%,hO(p$YO~P#.{O!WfX!W$yX!ZfX!Z$yX!e%QX#^fX~P!/qO(R<xO~P!1dO!Q%gO!Y4XO!]%hO(R%fO!Z'cX!i'cX~O!Z/kO!i(|a~O!Z/kO!e#vO!i(|a~O!Z/kO!e#vO(p'nO!i(|a~Og${i!Z${i#^${i#}${i~P!0uO!Y4aO!W'eX!Z'eX~P!3cO!Z/sO!W(}a~O!Z/sO!W(}a~P#.{OP]XR]X[]Xp]X!O]X!Q]X!W]X!Z]X!j]X!n]X#P]X#Q]X#^]X#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X(_]X(p]X(w]X(x]X~O!e%XX#t%XX~P%0XO!e#vO#t4fO~Oh%VO!e#vO!j%dO~Oh%VOp4kO!j%dO(p'nO~Op4pO!e#vO(p'nO~Oq!nO!Q4qO(TTO(WUO(c!mO~O(w$}Ol%`i!O%`i'w%`i(x%`i!Z%`i#^%`i~Og%`i#}%`i~P%3xO(x%POl%bi!O%bi'w%bi(w%bi!Z%bi#^%bi~Og%bi#}%bi~P%4kOg(]i!Z(]i~P!0uO#^4wOg(]i!Z(]i~P!0uO!i4zO~Oa$nq!Z$nq'x$nq'u$nq!W$nq!i$nqt$nq!]$nq%h$nq!e$nq~P!:TO!W5QO~O!Z5RO!])OX~P#.{Oa]Xa$yX!]]X!]$yX%]]X'x]X'x$yX!Z]X!Z$yX~P!/qO%]5UOa%Za!]%Za'x%Za!Z%Za~OlmX!OmX'wmX(wmX(xmX~P%7nOn5VO(R#nO~Ob5]O%i5^O(R+nO(TTO(WUO!Z'rX!['rX~O!Z0}O![)Va~O[5bO~O`5cO~Oa%mO'x%mO~P#.{O!Z5kO#^5mO![)SX~O![5nO~Op5tOq!nO!Q*fO!`!yO!a!vO!b!vO!z;wO#R!pO#S!pO#T!pO#U!pO#V!pO#Y5sO#Z!zO(S!lO(TTO(WUO(c!mO(m!sO~O![5rO~P%:ROl5yO!]1gO%h5xO~Oh%VOl5yO!]1gO%h5xO~Ob6QO(R#nO(TTO(WUO!Z'qX!['qX~O!Z1rO![)Ta~O(TTO(WUO(c6SO~O`6WO~O#t6ZO&Y6[O~PMvO!i6]O~P%[Oa6_O~Oa6_O~P%[Ob2YO![6dO&h2XO~P`O!e6fO~O!e6hOh(hi!Z(hi![(hi!e(hi!j(hip(hi(p(hi~O!Z#fi![#fi~P#BPO#^6iO!Z#fi![#fi~O!Z!_i![!_i~P#BPOa%mO#^6rO'x%mO~Oa%mO!e#vO#^6rO'x%mO~O!Z(rq!i(rqa(rq'x(rq~P!:TO!Z(hO!i(qq~O!Q%gO!]%hO#h6yO(R%fO~O!]'^O%h6|O~Ol7QO!]'^O%h6|O~O#i'gaP'gaR'ga['gaa'gap'ga!Q'ga!j'ga!n'ga#P'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#t'ga#u'ga#w'ga#y'ga#z'ga'x'ga(_'ga(p'ga!i'ga!W'ga'u'gat'ga!]'ga%h'ga!e'ga~P%+uO#i'iaP'iaR'ia['iaa'iap'ia!Q'ia!j'ia!n'ia#P'ia#l'ia#m'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#w'ia#y'ia#z'ia'x'ia(_'ia(p'ia!i'ia!W'ia'u'iat'ia!]'ia%h'ia!e'ia~P%,hO#i${iP${iR${i[${ia${ip${i!Q${i!Z${i!j${i!n${i#P${i#l${i#m${i#n${i#o${i#p${i#q${i#r${i#s${i#t${i#u${i#w${i#y${i#z${i'x${i(_${i(p${i!i${i!W${i'u${i#^${it${i!]${i%h${i!e${i~P#.{O#i%`iP%`iR%`i[%`ia%`ip%`i!Q%`i!j%`i!n%`i#P%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#t%`i#u%`i#w%`i#y%`i#z%`i'x%`i(_%`i(p%`i!i%`i!W%`i'u%`it%`i!]%`i%h%`i!e%`i~P%3xO#i%biP%biR%bi[%bia%bip%bi!Q%bi!j%bi!n%bi#P%bi#l%bi#m%bi#n%bi#o%bi#p%bi#q%bi#r%bi#s%bi#t%bi#u%bi#w%bi#y%bi#z%bi'x%bi(_%bi(p%bi!i%bi!W%bi'u%bit%bi!]%bi%h%bi!e%bi~P%4kO!Z'Wa!i'Wa~P!:TO!Z.oO!i(ii~O#}#ai!Z#ai![#ai~P#BPOP$[OR#zO!O#yO!Q#{O!j#xO!n$[O(_VO[#kip#ki#P#ki#m#ki#n#ki#o#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki#}#ki(p#ki(w#ki(x#ki!Z#ki![#ki~O#l#ki~P%MQO#l<PO~P%MQOP$[OR#zOp<]O!O#yO!Q#{O!j#xO!n$[O#l<PO#m<QO#n<QO#o<QO(_VO[#ki#P#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki#}#ki(p#ki(w#ki(x#ki!Z#ki![#ki~O#p#ki~P& YO#p<RO~P& YOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO(_VO#w#ki#y#ki#z#ki#}#ki(p#ki(w#ki(x#ki!Z#ki![#ki~O#u#ki~P&#bOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO#u<TO(_VO(x#}O#y#ki#z#ki#}#ki(p#ki(w#ki!Z#ki![#ki~O#w<VO~P&%cO#w#ki~P&%cO#u<TO~P&#bOP$[OR#zO[<_Op<]O!O#yO!Q#{O!j#xO!n$[O#P<SO#l<PO#m<QO#n<QO#o<QO#p<RO#q<SO#r<SO#s<^O#t<SO#u<TO#w<VO(_VO(w#|O(x#}O#z#ki#}#ki(p#ki!Z#ki![#ki~O#y#ki~P&'rO#y<XO~P&'rOa#{y!Z#{y'x#{y'u#{y!W#{y!i#{yt#{y!]#{y%h#{y!e#{y~P!:TO[#kip#ki#P#ki#p#ki#q#ki#r#ki#s#ki#t#ki#u#ki#w#ki#y#ki#z#ki#}#ki(p#ki!Z#ki![#ki~OP$[OR#zO!O#yO!Q#{O!j#xO!n$[O#l<PO#m<QO#n<QO#o<QO(_VO(w#ki(x#ki~P&*nOl=}O!O)|O'w)}O(w$}O(x%POP#kiR#ki!Q#ki!j#ki!n#ki#l#ki#m#ki#n#ki#o#ki(_#ki~P&*nO#Q$dOP(^XR(^X[(^Xl(^Xp(^X!O(^X!Q(^X!j(^X!n(^X#P(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#s(^X#t(^X#u(^X#w(^X#y(^X#z(^X#}(^X'w(^X(_(^X(p(^X(w(^X(x(^X!Z(^X![(^X~O#}$Oi!Z$Oi![$Oi~P#BPO#}!pi![!pi~P$*OOg'Za!Z'Za~P!0uO![7dO~O!Z'ba!['ba~P#BPO!W7eO~P#.{O!e#vO(p'nO!Z'ca!i'ca~O!Z/kO!i(|i~O!Z/kO!e#vO!i(|i~Og${q!Z${q#^${q#}${q~P!0uO!W'ea!Z'ea~P#.{O!e7lO~O!Z/sO!W(}i~P#.{O!Z/sO!W(}i~O!W7oO~Oh%VOp7tO!j%dO(p'nO~O!e#vO#t7vO~Op7yO!e#vO(p'nO~O!O)|O'w)}O(x%POl'ha(w'ha!Z'ha#^'ha~Og'ha#}'ha~P&3oO!O)|O'w)}Ol'ja(w'ja(x'ja!Z'ja#^'ja~Og'ja#}'ja~P&4bO!W7{O~Og$}q!Z$}q#^$}q#}$}q~P!0uOg(]q!Z(]q~P!0uO#^7|Og(]q!Z(]q~P!0uOa$ny!Z$ny'x$ny'u$ny!W$ny!i$nyt$ny!]$ny%h$ny!e$ny~P!:TO!e6hO~O!Z5RO!])Oa~O!]'^OP$SaR$Sa[$Sap$Sa!O$Sa!Q$Sa!Z$Sa!j$Sa!n$Sa#P$Sa#l$Sa#m$Sa#n$Sa#o$Sa#p$Sa#q$Sa#r$Sa#s$Sa#t$Sa#u$Sa#w$Sa#y$Sa#z$Sa(_$Sa(p$Sa(w$Sa(x$Sa~O%h6|O~P&7SO%]8QOa%Zi!]%Zi'x%Zi!Z%Zi~Oa#ay!Z#ay'x#ay'u#ay!W#ay!i#ayt#ay!]#ay%h#ay!e#ay~P!:TO[8SO~Ob8UO(R+nO(TTO(WUO~O!Z0}O![)Vi~O`8YO~O(c(zO!Z'nX!['nX~O!Z5kO![)Sa~O![8cO~P%:RO(m!sO~P$$oO#Y8dO~O!]1gO~O!]1gO%h8fO~Ol8iO!]1gO%h8fO~O[8nO!Z'qa!['qa~O!Z1rO![)Ti~O!i8rO~O!i8sO~O!i8vO~O!i8vO~P%[Oa8xO~O!e8yO~O!i8zO~O!Z(ui![(ui~P#BPOa%mO#^9SO'x%mO~O!Z(ry!i(rya(ry'x(ry~P!:TO!Z(hO!i(qy~O%h9VO~P&7SO!]'^O%h9VO~O#i${qP${qR${q[${qa${qp${q!Q${q!Z${q!j${q!n${q#P${q#l${q#m${q#n${q#o${q#p${q#q${q#r${q#s${q#t${q#u${q#w${q#y${q#z${q'x${q(_${q(p${q!i${q!W${q'u${q#^${qt${q!]${q%h${q!e${q~P#.{O#i'haP'haR'ha['haa'hap'ha!Q'ha!j'ha!n'ha#P'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#w'ha#y'ha#z'ha'x'ha(_'ha(p'ha!i'ha!W'ha'u'hat'ha!]'ha%h'ha!e'ha~P&3oO#i'jaP'jaR'ja['jaa'jap'ja!Q'ja!j'ja!n'ja#P'ja#l'ja#m'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#w'ja#y'ja#z'ja'x'ja(_'ja(p'ja!i'ja!W'ja'u'jat'ja!]'ja%h'ja!e'ja~P&4bO#i$}qP$}qR$}q[$}qa$}qp$}q!Q$}q!Z$}q!j$}q!n$}q#P$}q#l$}q#m$}q#n$}q#o$}q#p$}q#q$}q#r$}q#s$}q#t$}q#u$}q#w$}q#y$}q#z$}q'x$}q(_$}q(p$}q!i$}q!W$}q'u$}q#^$}qt$}q!]$}q%h$}q!e$}q~P#.{O!Z'Wi!i'Wi~P!:TO#}#aq!Z#aq![#aq~P#BPO(w$}OP%`aR%`a[%`ap%`a!Q%`a!j%`a!n%`a#P%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#t%`a#u%`a#w%`a#y%`a#z%`a#}%`a(_%`a(p%`a!Z%`a![%`a~Ol%`a!O%`a'w%`a(x%`a~P&HgO(x%POP%baR%ba[%bap%ba!Q%ba!j%ba!n%ba#P%ba#l%ba#m%ba#n%ba#o%ba#p%ba#q%ba#r%ba#s%ba#t%ba#u%ba#w%ba#y%ba#z%ba#}%ba(_%ba(p%ba!Z%ba![%ba~Ol%ba!O%ba'w%ba(w%ba~P&JnOl=}O!O)|O'w)}O(x%PO~P&HgOl=}O!O)|O'w)}O(w$}O~P&JnOR0cO!O0cO!Q0dO#Q$dOP{a[{al{ap{a!j{a!n{a#P{a#l{a#m{a#n{a#o{a#p{a#q{a#r{a#s{a#t{a#u{a#w{a#y{a#z{a#}{a'w{a(_{a(p{a(w{a(x{a!Z{a![{a~O!O)|O'w)}OP$raR$ra[$ral$rap$ra!Q$ra!j$ra!n$ra#P$ra#l$ra#m$ra#n$ra#o$ra#p$ra#q$ra#r$ra#s$ra#t$ra#u$ra#w$ra#y$ra#z$ra#}$ra(_$ra(p$ra(w$ra(x$ra!Z$ra![$ra~O!O)|O'w)}OP$taR$ta[$tal$tap$ta!Q$ta!j$ta!n$ta#P$ta#l$ta#m$ta#n$ta#o$ta#p$ta#q$ta#r$ta#s$ta#t$ta#u$ta#w$ta#y$ta#z$ta#}$ta(_$ta(p$ta(w$ta(x$ta!Z$ta![$ta~Ol=}O!O)|O'w)}O(w$}O(x%PO~OP%SaR%Sa[%Sap%Sa!Q%Sa!j%Sa!n%Sa#P%Sa#l%Sa#m%Sa#n%Sa#o%Sa#p%Sa#q%Sa#r%Sa#s%Sa#t%Sa#u%Sa#w%Sa#y%Sa#z%Sa#}%Sa(_%Sa(p%Sa!Z%Sa![%Sa~P'%sO#}$lq!Z$lq![$lq~P#BPO#}$nq!Z$nq![$nq~P#BPO![9dO~O#}9eO~P!0uO!e#vO!Z'ci!i'ci~O!e#vO(p'nO!Z'ci!i'ci~O!Z/kO!i(|q~O!W'ei!Z'ei~P#.{O!Z/sO!W(}q~Op9lO!e#vO(p'nO~O[9nO!W9mO~P#.{O!W9mO~O!e#vO#t9tO~Og(]y!Z(]y~P!0uO!Z'la!]'la~P#.{Oa%Zq!]%Zq'x%Zq!Z%Zq~P#.{O[9yO~O!Z0}O![)Vq~O#^9}O!Z'na!['na~O!Z5kO![)Si~P#BPO!Q:PO~O!]1gO%h:SO~O(TTO(WUO(c:XO~O!Z1rO![)Tq~O!i:[O~O!i:]O~O!i:^O~O!i:^O~P%[O#^:aO!Z#fy![#fy~O!Z#fy![#fy~P#BPO%h:fO~P&7SO!]'^O%h:fO~O#}#{y!Z#{y![#{y~P#BPOP${iR${i[${ip${i!Q${i!j${i!n${i#P${i#l${i#m${i#n${i#o${i#p${i#q${i#r${i#s${i#t${i#u${i#w${i#y${i#z${i#}${i(_${i(p${i!Z${i![${i~P'%sO!O)|O'w)}O(x%POP'gaR'ga['gal'gap'ga!Q'ga!j'ga!n'ga#P'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#t'ga#u'ga#w'ga#y'ga#z'ga#}'ga(_'ga(p'ga(w'ga!Z'ga!['ga~O!O)|O'w)}OP'iaR'ia['ial'iap'ia!Q'ia!j'ia!n'ia#P'ia#l'ia#m'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#w'ia#y'ia#z'ia#}'ia(_'ia(p'ia(w'ia(x'ia!Z'ia!['ia~O(w$}OP%`iR%`i[%`il%`ip%`i!O%`i!Q%`i!j%`i!n%`i#P%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#t%`i#u%`i#w%`i#y%`i#z%`i#}%`i'w%`i(_%`i(p%`i(x%`i!Z%`i![%`i~O(x%POP%biR%bi[%bil%bip%bi!O%bi!Q%bi!j%bi!n%bi#P%bi#l%bi#m%bi#n%bi#o%bi#p%bi#q%bi#r%bi#s%bi#t%bi#u%bi#w%bi#y%bi#z%bi#}%bi'w%bi(_%bi(p%bi(w%bi!Z%bi![%bi~O#}$ny!Z$ny![$ny~P#BPO#}#ay!Z#ay![#ay~P#BPO!e#vO!Z'cq!i'cq~O!Z/kO!i(|y~O!W'eq!Z'eq~P#.{Op:pO!e#vO(p'nO~O[:tO!W:sO~P#.{O!W:sO~Og(]!R!Z(]!R~P!0uOa%Zy!]%Zy'x%Zy!Z%Zy~P#.{O!Z0}O![)Vy~O!Z5kO![)Sq~O(R:zO~O!]1gO%h:}O~O!i;QO~O%h;VO~P&7SOP${qR${q[${qp${q!Q${q!j${q!n${q#P${q#l${q#m${q#n${q#o${q#p${q#q${q#r${q#s${q#t${q#u${q#w${q#y${q#z${q#}${q(_${q(p${q!Z${q![${q~P'%sO!O)|O'w)}O(x%POP'haR'ha['hal'hap'ha!Q'ha!j'ha!n'ha#P'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#w'ha#y'ha#z'ha#}'ha(_'ha(p'ha(w'ha!Z'ha!['ha~O!O)|O'w)}OP'jaR'ja['jal'jap'ja!Q'ja!j'ja!n'ja#P'ja#l'ja#m'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#w'ja#y'ja#z'ja#}'ja(_'ja(p'ja(w'ja(x'ja!Z'ja!['ja~OP$}qR$}q[$}qp$}q!Q$}q!j$}q!n$}q#P$}q#l$}q#m$}q#n$}q#o$}q#p$}q#q$}q#r$}q#s$}q#t$}q#u$}q#w$}q#y$}q#z$}q#}$}q(_$}q(p$}q!Z$}q![$}q~P'%sOg%d!Z!Z%d!Z#^%d!Z#}%d!Z~P!0uO!W;ZO~P#.{Op;[O!e#vO(p'nO~O[;^O!W;ZO~P#.{O!Z'nq!['nq~P#BPO!Z#f!Z![#f!Z~P#BPO#i%d!ZP%d!ZR%d!Z[%d!Za%d!Zp%d!Z!Q%d!Z!Z%d!Z!j%d!Z!n%d!Z#P%d!Z#l%d!Z#m%d!Z#n%d!Z#o%d!Z#p%d!Z#q%d!Z#r%d!Z#s%d!Z#t%d!Z#u%d!Z#w%d!Z#y%d!Z#z%d!Z'x%d!Z(_%d!Z(p%d!Z!i%d!Z!W%d!Z'u%d!Z#^%d!Zt%d!Z!]%d!Z%h%d!Z!e%d!Z~P#.{Op;fO!e#vO(p'nO~O!W;gO~P#.{Op;nO!e#vO(p'nO~O!W;oO~P#.{OP%d!ZR%d!Z[%d!Zp%d!Z!Q%d!Z!j%d!Z!n%d!Z#P%d!Z#l%d!Z#m%d!Z#n%d!Z#o%d!Z#p%d!Z#q%d!Z#r%d!Z#s%d!Z#t%d!Z#u%d!Z#w%d!Z#y%d!Z#z%d!Z#}%d!Z(_%d!Z(p%d!Z!Z%d!Z![%d!Z~P'%sOp;rO!e#vO(p'nO~Ot(dX~P1qO!O%qO~P!(yO(S!lO~P!(yO!WfX!ZfX#^fX~P%0XOP]XR]X[]Xp]X!O]X!Q]X!Z]X!ZfX!j]X!n]X#P]X#Q]X#^]X#^fX#ifX#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#w]X#y]X#z]X$P]X(_]X(p]X(w]X(x]X~O!efX!i]X!ifX(pfX~P'JlOP;vOQ;vOSfOd=rOe!iOnkOp;vOqkOrkOxkOz;vO|;vO!QWO!UkO!VkO!]XO!g;yO!jZO!m;vO!n;vO!o;vO!q;zO!s;}O!v!hO$V!kO$m=pO(R)ZO(TTO(WUO(_VO(m[O~O!Z<ZO![$pa~Oh%VOn%WOp%XOq$tOr$tOx%YOz%ZO|<fO!Q${O!]$|O!g=wO!j$xO#h<lO$V%_O$s<hO$u<jO$x%`O(R(tO(TTO(WUO(_$uO(w$}O(x%PO~Oj)bO~P( bOp!cX(p!cX~P# qOp(hX(p(hX~P#!dO![]X![fX~P'JlO!WfX!W$yX!ZfX!Z$yX#^fX~P!/qO#i<OO~O!e#vO#i<OO~O#^<`O~O#t<SO~O#^<pO!Z(uX![(uX~O#^<`O!Z(sX![(sX~O#i<qO~Og<sO~P!0uO#i<yO~O#i<zO~O!e#vO#i<{O~O!e#vO#i<qO~O#}<|O~P#BPO#i<}O~O#i=OO~O#i=TO~O#i=UO~O#i=VO~O#i=WO~O#}=XO~P!0uO#}=YO~P!0uO#Q#R#S#U#V#Y#g#h#s$m$s$u$x%[%]%g%h%i%p%r%u%v%x%z~'|T#m!V'z(S#nq#l#op!O'{$['{(R$^(c~",
  goto: "$8f)ZPPPPPP)[PP)_P)pP+Q/VPPPP6aPP6wPP<oP@cP@yP@yPPP@yPCRP@yP@yP@yPCVPC[PCyPHsPPPHwPPPPHwKzPPPLQLrPHwPHwPP! QHwPPPHwPHwP!#XHwP!&o!'t!'}P!(q!(u!(q!,SPPPPPPP!,s!'tPP!-T!.uP!2RHwHw!2W!5d!:Q!:Q!>PPPP!>XHwPPPPPPPPPP!AhP!BuPPHw!DWPHwPHwHwHwHwHwPHw!EjP!HtP!KzP!LO!LY!L^!L^P!HqP!Lb!LbP# hP# lHwPHw# r#$wCV@yP@yP@y@yP#&U@y@y#(h@y#+`@y#-l@y@y#.[#0p#0p#0u#1O#0p#1ZPP#0pP@y#1s@y#5r@y@y6aPPP#9wPPP#:b#:bP#:bP#:x#:bPP#;OP#:uP#:u#;c#:u#;}#<T#<W)_#<Z)_P#<b#<b#<bP)_P)_P)_P)_PP)_P#<h#<kP#<k)_P#<oP#<rP)_P)_P)_P)_P)_P)_)_PP#<x#=O#=Z#=a#=g#=m#=s#>R#>X#>c#>i#>s#>y#?Z#?a#@R#@e#@k#@q#AP#Af#CZ#Ci#Cp#E[#Ej#G[#Gj#Gp#Gv#G|#HW#H^#Hd#Hn#IQ#IWPPPPPPPPPPP#I^PPPPPPP#JR#MY#Nr#Ny$ RPPP$&mP$&v$)o$0Y$0]$0`$1_$1b$1i$1qP$1w$1zP$2h$2l$3d$4r$4w$5_PP$5d$5j$5n$5q$5u$5y$6u$7^$7u$7y$7|$8P$8V$8Y$8^$8bR!|RoqOXst!Z#d%l&p&r&s&u,n,s2S2VY!vQ'^-`1g5qQ%svQ%{yQ&S|Q&h!VS'U!e-WQ'd!iS'j!r!yU*h$|*X*lQ+l%|Q+y&UQ,_&bQ-^']Q-h'eQ-p'kQ0U*nQ1q,`R<m;z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9SS#q];w!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU*{%[<e<fQ+q&OQ,a&eQ,h&mQ0r+dQ0u+fQ1S+rQ1y,fQ3W.bQ5V0wQ5]0}Q6Q1rQ7O3[Q8U5^R9Y7Q'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s!S!nQ!r!v!y!z$|'U']'^'j'k'l*h*l*n*o-W-^-`-p0U0X1g5q5s%[$ti#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q&V|Q'S!eS'Y%h-ZQ+q&OQ,a&eQ0f+OQ1S+rQ1X+xQ1x,eQ1y,fQ5]0}Q5f1ZQ6Q1rQ6T1tQ6U1wQ8U5^Q8X5cQ8q6WQ9|8YQ:Y8nR<o*XrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR,c&i&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=r=s[#]WZ#W#Z'V(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ%vxQ%zyS&P|&UQ&]!TQ'a!hQ'c!iQ(o#sS+k%{%|Q+o&OQ,Y&`Q,^&bS-g'd'eQ.d(pQ0{+lQ1R+rQ1T+sQ1W+wQ1l,ZS1p,_,`Q2t-hQ5[0}Q5`1QQ5e1YQ6P1qQ8T5^Q8W5bQ9x8SR:w9y!U$zi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y!^%xy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pQ+e%vQ,O&YQ,R&ZQ,]&bQ.c(oQ1k,YU1o,^,_,`Q3].dQ5z1lS6O1p1qQ8m6P#f=t#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o=u<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YW%Ti%V*v=pS&Y!Q&gQ&Z!RQ&[!SQ+S%cR+|&W%]%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}T)x$u)yV*{%[<e<fW'Y!e%h*X-ZS({#y#zQ+`%qQ+v&RS.](k(lQ1b,SQ4x0cR8^5k'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s$i$^c#Y#e%p%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.w.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ'W!eR2i-W!W!nQ!e!r!v!y!z$|'U']'^'j'k'l*X*h*l*n*o-W-^-`-p0U0X1g5q5sR1d,UnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&w!^Q't!xS(q#u<OQ+i%yQ,W&]Q,X&_Q-e'bQ-r'mS.m(v<qS0k+U<{Q0y+jQ1f,VQ2Z,uQ2],vQ2e-RQ2r-fQ2u-jS5P0l=VQ5W0zS5Z0|=WQ6j2gQ6n2sQ6s2zQ8R5XQ8}6lQ9O6oQ9R6tR:`8z$d$]c#Y#e%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gS(m#p'gQ(}#zS+_%p.wS.^(l(nR3U._'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS#q];wQ&r!XQ&s!YQ&u![Q&v!]R2R,qQ'_!hQ+b%vQ-c'aS.`(o+eQ2p-bW3Y.c.d0q0sQ6m2qW6z3V3X3]5TU9U6{6}7PU:e9W9X9ZS;T:d:gQ;b;UR;j;cU!wQ'^-`T5o1g5q!Q_OXZ`st!V!Z#d#h%d%l&g&i&p&r&s&u(h,n,s.V2S2V]!pQ!r'^-`1g5qT#q];w%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS({#y#zS.](k(l!s=^$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU$fd)],hS(n#p'gU*s%R(u3vU0e*z.i7]Q5T0rQ6{3WQ9X7OR:g9Ym!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sQ'r!uS(d#g1|S-n'i'uQ/n*ZQ/{*gQ2|-qQ4]/oQ4i/}Q4j0OQ4o0WQ7h4WS7s4k4mS7w4p4rQ9g7iQ9k7oQ9p7tQ9u7yS:o9l9mS;Y:p:sS;e;Z;[S;m;f;gS;q;n;oR;t;rQ#wbQ'q!uS(c#g1|S(e#m+TQ+V%eQ+g%wQ+m%}U-m'i'r'uQ.R(dQ/m*ZQ/|*gQ0P*iQ0x+hQ1m,[S2y-n-qQ3R.ZS4[/n/oQ4e/yS4h/{0WQ4l0QQ5|1nQ6u2|Q7g4WQ7k4]U7r4i4o4rQ7u4nQ8k5}S9f7h7iQ9j7oQ9r7wQ9s7xQ:V8lQ:m9gS:n9k9mQ:v9uQ;P:WS;X:o:sS;d;Y;ZS;l;e;gS;p;m;oQ;s;qQ;u;tQ=a=[Q=l=eR=m=fV!wQ'^-`%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS#wz!j!r=Z$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=a=r%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SQ%ej!^%wy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pS%}z!jQ+h%xQ,[&bW1n,],^,_,`U5}1o1p1qS8l6O6PQ:W8m!r=[$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ=e=qR=f=r%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SY#bWZ#W#Z(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ,i&m!p=]$Z$n)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=`'VU'Z!e%h*XR2k-Z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9S!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ,h&mQ0r+dQ3W.bQ7O3[R9Y7Q!b$Tc#Y%p(Q(W(r(w)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!P<U)[)o-U.w2c2f3h3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!f$Vc#Y%p(Q(W(r(w)U)V)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!T<W)[)o-U.w2c2f3h3n3o3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!^$Zc#Y%p(Q(W(r(w)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;xQ4V/fz=s)[)o-U.w2c2f3h3w4P6k7W7a7b8`8|9[9b9c:y;R=gQ=x=zR=y={'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS$oh$pR3|/P'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$kf$qQ$ifS)h$l)lR)t$qT$jf$qT)j$l)l'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$oh$pQ$rhR)s$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9S!s=q$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s#glOPXZst!Z!`!o#S#d#o#{$n%l&i&l&m&p&r&s&u&y'R'`(|)q*f+Y+d,k,n,s-d.b/Q/i0V0d1j1z1{1}2P2S2V2X3[3{4q5y6Z6[6_7Q8i8x!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}Q+P%`Q/^)|o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!U$yi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yQ*`$zU*i$|*X*lQ+Q%aQ0Q*j#f=c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n=d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YQ=h=tQ=i=uQ=j=vR=k=w!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YnoOXst!Z#d%l&p&r&s&u,n,s2S2VS*c${*WQ,|&|Q,}'OR4`/s%[%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q,P&ZQ1`,RQ5i1_R8]5jV*k$|*X*lU*k$|*X*lT5p1g5qS/y*f/iQ4n0VT7x4q:PQ+g%wQ0P*iQ0x+hQ1m,[Q5|1nQ8k5}Q:V8lR;P:W!U%Oi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yx*P$v)c*Q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=oS0Y*q0Z#f<a#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<b<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!d<t(s)a*Y*b.e.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={`<u3u7X7[7`9]:h:k;kS=P.g3aT=Q7Z9`!U%Qi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y|*R$v)c*S*q+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=oS0[*r0]#f<c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!h<v(s)a*Y*b.f.g.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={d<w3u7Y7Z7`9]9^:h:i:k;kS=R.h3bT=S7[9arnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ&d!UR,k&mrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR&d!UQ,T&[R1[+|snOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ1h,YS5w1k1lU8e5u5v5zS:R8g8hS:{:Q:TQ;_:|R;i;`Q&k!VR,d&gR6T1tR:Y8nS&P|&UR1T+sQ&p!WR,n&qR,t&vT2T,s2VR,x&wQ,w&wR2^,xQ'w!{R-t'wSsOtQ#dXT%os#dQ#OTR'y#OQ#RUR'{#RQ)y$uR/Z)yQ#UVR(O#UQ#XWU(U#X(V-{Q(V#YR-{(WQ-X'WR2j-XQ.p(wS3e.p3fR3f.qQ-`'^R2n-`Y!rQ'^-`1g5qR'h!rQ.{)cR3z.{U#_W%g*WU(]#_(^-|Q(^#`R-|(XQ-['ZR2l-[t`OXst!V!Z#d%l&g&i&p&r&s&u,n,s2S2VS#hZ%dU#r`#h.VR.V(hQ(i#jQ.S(eW.[(i.S3P6wQ3P.TR6w3QQ)l$lR/R)lQ$phR)r$pQ$`cU)_$`-w<[Q-w;xR<[)oQ/l*ZW4Y/l4Z7j9hU4Z/m/n/oS7j4[4]R9h7k$e*O$v(s)a)c*Y*b*q*r*|*}+R.g.h.j.k.l/Y/b/d/f/q/v0^0_0p1]3^3_3`3u3y4S4^4_4c4s4u4{4|4}5h7R7S7T7U7Z7[7^7_7`7f7m7p7z7}8P9]9^9_9i9q9v9w:h:i:j:k:l:q:u;W;];h;k=b=n=o=z={Q/t*bU4b/t4d7nQ4d/vR7n4cS*l$|*XR0S*lx*Q$v)c*q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=o!d.e(s)a*Y*b.g.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/c*Q.e7Xa7X3u7Z7[7`9]:h:k;kQ0Z*qQ3a.gU4t0Z3a9`R9`7Z|*S$v)c*q*r+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=o!h.f(s)a*Y*b.g.h.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/e*S.f7Ye7Y3u7Z7[7`9]9^:h:i:k;kQ0]*rQ3b.hU4v0]3b9aR9a7[Q*w%UR0a*wQ5S0pR8O5SQ+[%jR0o+[Q5l1bS8_5l:OR:O8`Q,V&]R1e,VQ5q1gR8b5qQ1s,aS6R1s8oR8o6TQ1O+oW5_1O5a8V9zQ5a1RQ8V5`R9z8WQ+t&PR1U+tQ2V,sR6c2VYrOXst#dQ&t!ZQ+^%lQ,m&pQ,o&rQ,p&sQ,r&uQ2Q,nS2T,s2VR6b2SQ%npQ&x!_Q&{!aQ&}!bQ'P!cQ'o!uQ+]%kQ+i%yQ+{&VQ,c&kQ,z&zW-k'i'q'r'uQ-r'mQ0R*kQ0y+jS1v,d,gQ2_,yQ2`,|Q2a,}Q2u-jW2w-m-n-q-sQ5W0zQ5d1XQ5g1]Q5{1mQ6V1xQ6a2RU6p2v2y2|Q6s2zQ8R5XQ8Z5fQ8[5hQ8a5pQ8j5|Q8p6US9P6q6uQ9R6tQ9{8XQ:U8kQ:Z8qQ:b9QQ:x9|Q;O:VQ;S:cR;a;PQ%yyQ'b!iQ'm!uU+j%z%{%|Q-R'TU-f'c'd'eS-j'i'sQ/z*gS0z+k+lQ2g-TS2s-g-hQ2z-oS4g/{0OQ5X0{Q6l2mQ6o2tQ6t2{U7q4i4j4mQ9o7sR:r9pS$wi=pR*x%VU%Ui%V=pR0`*vQ$viS(s#v+fS)a$b$cQ)c$dQ*Y$xS*b${*WQ*q%OQ*r%QQ*|%]Q*}%^Q+R%bQ.g<aQ.h<cQ.j<gQ.k<iQ.l<kQ/Y)wQ/b*PQ/d*RQ/f*TQ/q*^S/v*d/hQ0^*tQ0_*ul0p+c,Q.a1a1i3Z5x6|8f9V:S:f:};VQ1]+}Q3^<tQ3_<vQ3`<yS3u<^<_Q3y.zS4S/_4UQ4^/rQ4_/sQ4c/uQ4s0YQ4u0[Q4{0gQ4|0hQ4}0iQ5h1^Q7R<}Q7S=PQ7T=RQ7U=TQ7Z<bQ7[<dQ7^<hQ7_<jQ7`<lQ7f4VQ7m4aQ7p4fQ7z4wQ7}5RQ8P5UQ9]<zQ9^<uQ9_<wQ9i7lQ9q7vQ9v7|Q9w8QQ:h=OQ:i=QQ:j=SQ:k=UQ:l9eQ:q9nQ:u9tQ;W=XQ;]:tQ;h;^Q;k=YQ=b=pQ=n=xQ=o=yQ=z=|R={=}Q*z%[Q.i<eR7]<fnpOXst!Z#d%l&p&r&s&u,n,s2S2VQ!fPS#fZ#oQ&z!`W'f!o*f0V4qQ'}#SQ)O#{Q)p$nS,g&i&lQ,l&mQ,y&yS-O'R/iQ-b'`Q.s(|Q/V)qQ0m+YQ0s+dQ2O,kQ2q-dQ3X.bQ4O/QQ4y0dQ5v1jQ6X1zQ6Y1{Q6^1}Q6`2PQ6e2XQ7P3[Q7c3{Q8h5yQ8t6ZQ8u6[Q8w6_Q9Z7QQ:T8iR:_8x#[cOPXZst!Z!`!o#d#o#{%l&i&l&m&p&r&s&u&y'R'`(|*f+Y+d,k,n,s-d.b/i0V0d1j1z1{1}2P2S2V2X3[4q5y6Z6[6_7Q8i8xQ#YWQ#eYQ%puQ%rvS%tw!gS(Q#W(TQ(W#ZQ(r#uQ(w#xQ)P$OQ)Q$PQ)R$QQ)S$RQ)T$SQ)U$TQ)V$UQ)W$VQ)X$WQ)Y$XQ)[$ZQ)^$_Q)`$aQ)e$eW)o$n)q/Q3{Q+a%sQ+u&QS-U'V2hQ-s'pS-x(R-zQ-}(ZQ.P(bQ.n(vQ.q(xQ.u;vQ.w;yQ.x;zQ.y;}Q/]){Q0j+UQ2c-PQ2f-SQ2v-lQ2}.QQ3c.oQ3h<OQ3i<PQ3j<QQ3k<RQ3l<SQ3m<TQ3n<UQ3o<VQ3p<WQ3q<XQ3r<YQ3s.vQ3t<]Q3w<`Q3x<mQ4P<ZQ5O0lQ5Y0|Q6k<pQ6q2xQ6v3OQ7V3dQ7W<qQ7a<sQ7b<{Q8`5mQ8|6iQ9Q6rQ9[<|Q9b=VQ9c=WQ:c9SQ:y9}Q;R:aQ;x#SR=g=sR#[WR'X!el!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sS'T!e-WU*g$|*X*lS-T'U']S0O*h*nQ0W*oQ2m-^Q4m0UR4r0XR(y#xQ!fQT-_'^-`]!qQ!r'^-`1g5qQ#p]R'g;wR)d$dY!uQ'^-`1g5qQ'i!rS's!v!yS'u!z5sS-o'j'kQ-q'lR2{-pT#kZ%dS#jZ%dS%jm,jU(e#h#i#lS.T(f(gQ.X(hQ0n+ZQ3Q.UU3R.V.W.YS6x3S3TR9T6yd#^W#W#Z%g(R([*W+W.O/hr#gZm#h#i#l%d(f(g(h+Z.U.V.W.Y3S3T6yS*Z$x*_Q/o*[Q1|,jQ2d-QQ4W/kQ6g2[Q7i4XQ8{6hT=_'V+XV#aW%g*WU#`W%g*WS(S#W([U(X#Z+W/hS-V'V+XT-y(R.OV'[!e%h*XQ$lfR)v$qT)k$l)lR3}/PT*]$x*_T*e${*WQ0q+cQ1_,QQ3V.aQ5j1aQ5u1iQ6}3ZQ8g5xQ9W6|Q:Q8fQ:d9VQ:|:SQ;U:fQ;`:}R;c;VnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&j!VR,c&gtmOXst!U!V!Z#d%l&g&p&r&s&u,n,s2S2VR,j&mT%km,jR1c,SR,b&eQ&T|R+z&UR+p&OT&n!W&qT&o!W&qT2U,s2V",
  nodeNames: "⚠ ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 378,
  context: Wq,
  nodeProps: [
    ["isolate", -8, 5, 6, 14, 35, 37, 49, 51, 53, ""],
    ["group", -26, 9, 17, 19, 66, 206, 210, 214, 215, 217, 220, 223, 233, 235, 241, 243, 245, 247, 250, 256, 262, 264, 266, 268, 270, 272, 273, "Statement", -34, 13, 14, 30, 33, 34, 40, 49, 52, 53, 55, 60, 68, 70, 74, 78, 80, 82, 83, 108, 109, 118, 119, 135, 138, 140, 141, 142, 143, 144, 146, 147, 166, 168, 170, "Expression", -23, 29, 31, 35, 39, 41, 43, 172, 174, 176, 177, 179, 180, 181, 183, 184, 185, 187, 188, 189, 200, 202, 204, 205, "Type", -3, 86, 101, 107, "ClassItem"],
    ["openedBy", 23, "<", 36, "InterpolationStart", 54, "[", 58, "{", 71, "(", 159, "JSXStartCloseTag"],
    ["closedBy", -2, 24, 167, ">", 38, "InterpolationEnd", 48, "]", 59, "}", 72, ")", 164, "JSXEndTag"]
  ],
  propSources: [Xq],
  skippedNodes: [0, 5, 6, 276],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$h&j(X!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(X!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$h&j(UpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(UpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$h&j(Up(X!b'z0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(V#S$h&j'{0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$h&j(Up(X!b'{0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$h&j!n),Q(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#u(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#u(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(T':f$h&j(X!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$h&j(X!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$h&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$c`$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$c``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$c`$h&j(X!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(X!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$c`(X!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$h&j(Up(X!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$h&j(Up(X!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$h&j(X!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$h&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(X!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$h&j(UpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(UpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Up(X!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$h&j(m%1l(Up(X!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$h&j(Up(X!b$[#t(R,2j(c$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$h&j(Up(X!b$[#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$h&j(Up(X!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$h&j$P(Ch(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(x+JY$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$h&j#y(Ch(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(W';W$h&j(UpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$h&j(UpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$h&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$c`$h&j(UpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(UpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$c`(UpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!j/.^$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!i!Lf$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$h&j(Up(X!b(S%&f#o(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$h&j(Up(X!b#l(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$h&j(Up(X!bp+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!Z+Jf$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$h&j(Up(X!b!O.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_!Y!L^$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$h&j(Up(X!b#m(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$h&j(Up(X!b!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$h&j(X!b!V7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$h&j!V7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$h&j!V7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!V7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!V7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$h&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$h&j(X!b!V7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(X!b!V7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(X!b!V7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(X!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$h&j(X!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$h&j(Up!V7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$h&j(Up!V7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Up!V7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Up!V7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(UpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$h&j(UpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$h&j(Up(X!b!V7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Up(X!b!V7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Up(X!b!V7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Up(X!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$h&j(Up(X!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$h&j(Up(X!b'|0/l!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$h&j(Up(X!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$h&j(X!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$h&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(X!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$h&j(UpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(UpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Up(X!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$h&j$P(Ch(Up(X!b!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Y#t$h&j(Up(X!b!V7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$h&j(Up(X!bq'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!e$b$h&j#})Lv(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#P-<U(Up(X!b$m7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$j&j(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#p(Ch(Up(X!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$P(Ch(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#q(Ch(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#^*!Y$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#i(Cl$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#q(Ch$e#|$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#q(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#p(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#p(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(p(Ct$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$h&j#z(Ch(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!z$Ip$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!Q0,v$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$h&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$h&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$h&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$h&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$h&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!W#)l$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#w(Ch$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$h&j(Up(X!b(_+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$h&j(Up(X!b(R,2j$^#t(c$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$h&j(Up(X!b$^#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!]#Hb(Up(X!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(w+JY$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_![(CdtBr$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!o7`$h&j(Up(X!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$h&j(Up(X!b'z0/l$[#t(R,2j(c$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$h&j(Up(X!b'{0/l$[#t(R,2j(c$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [jq, Fq, Uq, Bq, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, qq, new gv("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOv~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!S~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(a~~", 141, 338), new gv("j~RQYZXz{^~^O(O~~aP!P!Qd~iO(P~~", 25, 321)],
  topRules: { Script: [0, 7], SingleExpression: [1, 274], SingleClassItem: [2, 275] },
  dialects: { jsx: 0, ts: 15091 },
  dynamicPrecedences: { 78: 1, 80: 1, 92: 1, 168: 1, 198: 1 },
  specialized: [{ term: 325, get: /* @__PURE__ */ f((n) => Nq[n] || -1, "get") }, { term: 341, get: /* @__PURE__ */ f((n) => Hq[n] || -1, "get") }, { term: 93, get: /* @__PURE__ */ f((n) => Yq[n] || -1, "get") }],
  tokenPrec: 15116
}), cA = [
  /* @__PURE__ */ ui("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ ui("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ ui("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ ui("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ ui("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ ui(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ ui("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ ui(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ ui(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ ui('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ ui('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], Kq = /* @__PURE__ */ cA.concat([
  /* @__PURE__ */ ui("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ ui("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ ui("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), e3 = /* @__PURE__ */ new k6(), hA = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function dc(n) {
  return (t, e) => {
    let i = t.node.getChild("VariableDefinition");
    return i && e(i, n), !0;
  };
}
c(dc, "ar$1");
f(dc, "defID");
const Jq = ["FunctionDeclaration"], tj = {
  FunctionDeclaration: /* @__PURE__ */ dc("function"),
  ClassDeclaration: /* @__PURE__ */ dc("class"),
  ClassExpression: /* @__PURE__ */ f(() => !0, "ClassExpression"),
  EnumDeclaration: /* @__PURE__ */ dc("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ dc("type"),
  NamespaceDeclaration: /* @__PURE__ */ dc("namespace"),
  VariableDefinition(n, t) {
    n.matchContext(Jq) || t(n, "variable");
  },
  TypeDefinition(n, t) {
    t(n, "type");
  },
  __proto__: null
};
function MS(n, t) {
  let e = e3.get(t);
  if (e)
    return e;
  let i = [], s = !0;
  function r(a, o) {
    let l = n.sliceString(a.from, a.to);
    i.push({ label: l, type: o });
  }
  return c(r, "s"), f(r, "def"), t.cursor(Yt.IncludeAnonymous).iterate((a) => {
    if (s)
      s = !1;
    else if (a.name) {
      let o = tj[a.name];
      if (o && o(a, r) || hA.has(a.name))
        return !1;
    } else if (a.to - a.from > 8192) {
      for (let o of MS(n, a.node))
        i.push(o);
      return !1;
    }
  }), e3.set(t, i), i;
}
c(MS, "hm$1");
f(MS, "getScope");
const xv = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, TS = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  "JSXText",
  "JSXAttributeValue",
  "JSXOpenTag",
  "JSXCloseTag",
  "JSXSelfClosingTag",
  ".",
  "?."
];
function dA(n) {
  let t = he(n.state).resolveInner(n.pos, -1);
  if (TS.indexOf(t.name) > -1)
    return null;
  let e = t.name == "VariableName" || t.to - t.from < 20 && xv.test(n.state.sliceDoc(t.from, t.to));
  if (!e && !n.explicit)
    return null;
  let i = [];
  for (let s = t; s; s = s.parent)
    hA.has(s.name) && (i = i.concat(MS(n.state.doc, s)));
  return {
    options: i,
    from: e ? t.from : n.pos,
    validFor: xv
  };
}
c(dA, "fm$1");
f(dA, "localCompletionSource");
function y1(n, t, e) {
  var i;
  let s = [];
  for (; ; ) {
    let r = t.firstChild, a;
    if (r?.name == "VariableName")
      return s.push(n(r)), { path: s.reverse(), name: e };
    if (r?.name == "MemberExpression" && ((i = a = r.lastChild) === null || i === void 0 ? void 0 : i.name) == "PropertyName")
      s.push(n(a)), t = r;
    else
      return null;
  }
}
c(y1, "Go$1");
f(y1, "pathFor");
function uA(n) {
  let t = /* @__PURE__ */ f((i) => n.state.doc.sliceString(i.from, i.to), "read"), e = he(n.state).resolveInner(n.pos, -1);
  return e.name == "PropertyName" ? y1(t, e.parent, t(e)) : (e.name == "." || e.name == "?.") && e.parent.name == "MemberExpression" ? y1(t, e.parent, "") : TS.indexOf(e.name) > -1 ? null : e.name == "VariableName" || e.to - e.from < 20 && xv.test(t(e)) ? { path: [], name: t(e) } : e.name == "MemberExpression" ? y1(t, e, "") : n.explicit ? { path: [], name: "" } : null;
}
c(uA, "cm$1");
f(uA, "completionPath");
function pA(n, t) {
  let e = [], i = /* @__PURE__ */ new Set();
  for (let s = 0; ; s++) {
    for (let a of (Object.getOwnPropertyNames || Object.keys)(n)) {
      if (!/^[a-zA-Z_$\xaa-\uffdc][\w$\xaa-\uffdc]*$/.test(a) || i.has(a))
        continue;
      i.add(a);
      let o;
      try {
        o = n[a];
      } catch {
        continue;
      }
      e.push({
        label: a,
        type: typeof o == "function" ? /^[A-Z]/.test(a) ? "class" : t ? "function" : "method" : t ? "variable" : "property",
        boost: -s
      });
    }
    let r = Object.getPrototypeOf(n);
    if (!r)
      return e;
    n = r;
  }
}
c(pA, "FS");
f(pA, "enumeratePropertyCompletions");
function ej(n) {
  let t = /* @__PURE__ */ new Map();
  return (e) => {
    let i = uA(e);
    if (!i)
      return null;
    let s = n;
    for (let a of i.path)
      if (s = s[a], !s)
        return null;
    let r = t.get(s);
    return r || t.set(s, r = pA(s, !i.path.length)), {
      from: e.pos - i.name.length,
      options: r,
      validFor: xv
    };
  };
}
c(ej, "KS");
f(ej, "scopeCompletionSource");
const bn = /* @__PURE__ */ X5.define({
  name: "javascript",
  parser: /* @__PURE__ */ Gq.configure({
    props: [
      /* @__PURE__ */ ky.add({
        IfStatement: /* @__PURE__ */ sw({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ sw({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: XV,
        SwitchBody: /* @__PURE__ */ f((n) => {
          let t = n.textAfter, e = /^\s*\}/.test(t), i = /^\s*(case|default)\b/.test(t);
          return n.baseIndent + (e ? 0 : i ? 1 : 2) * n.unit;
        }, "SwitchBody"),
        Block: /* @__PURE__ */ oM({ closing: "}" }),
        ArrowFunction: /* @__PURE__ */ f((n) => n.baseIndent + n.unit, "ArrowFunction"),
        "TemplateString BlockComment": /* @__PURE__ */ f(() => null, "TemplateString BlockComment"),
        "Statement Property": /* @__PURE__ */ sw({ except: /^{/ }),
        JSXElement(n) {
          let t = /^\s*<\//.test(n.textAfter);
          return n.lineIndent(n.node.from) + (t ? 0 : n.unit);
        },
        JSXEscape(n) {
          let t = /\s*\}/.test(n.textAfter);
          return n.lineIndent(n.node.from) + (t ? 0 : n.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(n) {
          return n.column(n.node.from) + n.unit;
        }
      }),
      /* @__PURE__ */ eg.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": G5,
        BlockComment(n) {
          return { from: n.from + 2, to: n.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), fA = {
  test: /* @__PURE__ */ f((n) => /^JSX/.test(n.name), "test"),
  facet: /* @__PURE__ */ tg({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, yA = /* @__PURE__ */ bn.configure({ dialect: "ts" }, "typescript"), mA = /* @__PURE__ */ bn.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ B5.add((n) => n.isTop ? [fA] : void 0)]
}), wA = /* @__PURE__ */ bn.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ B5.add((n) => n.isTop ? [fA] : void 0)]
}, "typescript");
let gA = /* @__PURE__ */ f((n) => ({ label: n, type: "keyword" }), "kwCompletion");
const vA = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(gA), ij = /* @__PURE__ */ vA.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(gA));
function bA(n = {}) {
  let t = n.jsx ? n.typescript ? wA : mA : n.typescript ? yA : bn, e = n.typescript ? Kq.concat(ij) : cA.concat(vA);
  return new Kf(t, [
    bn.data.of({
      autocomplete: CM(TS, nS(e))
    }),
    bn.data.of({
      autocomplete: dA
    }),
    n.jsx ? sj : []
  ]);
}
c(bA, "pm$1");
f(bA, "javascript");
function OA(n) {
  for (; ; ) {
    if (n.name == "JSXOpenTag" || n.name == "JSXSelfClosingTag" || n.name == "JSXFragmentTag")
      return n;
    if (n.name == "JSXEscape" || !n.parent)
      return null;
    n = n.parent;
  }
}
c(OA, "eQ");
f(OA, "findOpenTag");
function Hx(n, t, e = n.length) {
  for (let i = t?.firstChild; i; i = i.nextSibling)
    if (i.name == "JSXIdentifier" || i.name == "JSXBuiltin" || i.name == "JSXNamespacedName" || i.name == "JSXMemberExpression")
      return n.sliceString(i.from, Math.min(i.to, e));
  return "";
}
c(Hx, "yd$1");
f(Hx, "elementName$1");
const nj = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), sj = /* @__PURE__ */ $t.inputHandler.of((n, t, e, i, s) => {
  if ((nj ? n.composing : n.compositionStarted) || n.state.readOnly || t != e || i != ">" && i != "/" || !bn.isActiveAt(n.state, t, -1))
    return !1;
  let r = s(), { state: a } = r, o = a.changeByRange((l) => {
    var h;
    let { head: u } = l, p = he(a).resolveInner(u - 1, -1), y;
    if (p.name == "JSXStartTag" && (p = p.parent), !(a.doc.sliceString(u - 1, u) != i || p.name == "JSXAttributeValue" && p.to > u)) {
      if (i == ">" && p.name == "JSXFragmentTag")
        return { range: l, changes: { from: u, insert: "</>" } };
      if (i == "/" && p.name == "JSXStartCloseTag") {
        let m = p.parent, w = m.parent;
        if (w && m.from == u - 2 && ((y = Hx(a.doc, w.firstChild, u)) || ((h = w.firstChild) === null || h === void 0 ? void 0 : h.name) == "JSXFragmentTag")) {
          let b = `${y}>`;
          return { range: J.cursor(u + b.length, -1), changes: { from: u, insert: b } };
        }
      } else if (i == ">") {
        let m = OA(p);
        if (m && m.name == "JSXOpenTag" && !/^\/?>|^<\//.test(a.doc.sliceString(u, u + 2)) && (y = Hx(a.doc, m, u)))
          return { range: l, changes: { from: u, insert: `</${y}>` } };
      }
    }
    return { range: l };
  });
  return o.changes.empty ? !1 : (n.dispatch([
    r,
    a.update(o, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
});
function rj(n, t) {
  return t || (t = {
    parserOptions: { ecmaVersion: 2019, sourceType: "module" },
    env: { browser: !0, node: !0, es6: !0, es2015: !0, es2017: !0, es2020: !0 },
    rules: {}
  }, n.getRules().forEach((e, i) => {
    e.meta.docs.recommended && (t.rules[i] = 2);
  })), (e) => {
    let { state: i } = e, s = [];
    for (let { from: r, to: a } of bn.findRegions(i)) {
      let o = i.doc.lineAt(r), l = { line: o.number - 1, col: r - o.from, pos: r };
      for (let h of n.verify(i.sliceDoc(r, a), t))
        s.push($A(h, i.doc, l));
    }
    return s;
  };
}
c(rj, "iQ");
f(rj, "esLint");
function Yx(n, t, e, i) {
  return e.line(n + i.line).from + t + (n == 1 ? i.col - 1 : -1);
}
c(Yx, "bd$1");
f(Yx, "mapPos");
function $A(n, t, e) {
  let i = Yx(n.line, n.column, t, e), s = {
    from: i,
    to: n.endLine != null && n.endColumn != 1 ? Yx(n.endLine, n.endColumn, t, e) : i,
    message: n.message,
    source: n.ruleId ? "eslint:" + n.ruleId : "eslint",
    severity: n.severity == 1 ? "warning" : "error"
  };
  if (n.fix) {
    let { range: r, text: a } = n.fix, o = r[0] + e.pos - i, l = r[1] + e.pos - i;
    s.actions = [{
      name: "fix",
      apply(h, u) {
        h.dispatch({ changes: { from: u + o, to: u + l, insert: a }, scrollIntoView: !0 });
      }
    }];
  }
  return s;
}
c($A, "rQ");
f($A, "translateDiagnostic");
const qy = ["_blank", "_self", "_top", "_parent"], DO = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], WO = ["get", "post", "put", "delete"], qO = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], Ii = ["true", "false"], ht = {}, aj = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: qy,
      hreflang: null
    }
  },
  abbr: ht,
  address: ht,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: ht,
  aside: ht,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: ht,
  base: { attrs: { href: null, target: qy } },
  bdi: ht,
  bdo: ht,
  blockquote: { attrs: { cite: null } },
  body: ht,
  br: ht,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: qO,
      formmethod: WO,
      formnovalidate: ["novalidate"],
      formtarget: qy,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: ht,
  center: ht,
  cite: ht,
  code: ht,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: ht,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: ht,
  div: ht,
  dl: ht,
  dt: ht,
  em: ht,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: ht,
  figure: ht,
  footer: ht,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": DO,
      autocomplete: ["on", "off"],
      enctype: qO,
      method: WO,
      novalidate: ["novalidate"],
      target: qy
    }
  },
  h1: ht,
  h2: ht,
  h3: ht,
  h4: ht,
  h5: ht,
  h6: ht,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: ht,
  hgroup: ht,
  hr: ht,
  html: {
    attrs: { manifest: null }
  },
  i: ht,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: qO,
      formmethod: WO,
      formnovalidate: ["novalidate"],
      formtarget: qy,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: ht,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: ht,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: ht,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: DO,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: ht,
  noscript: ht,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: ht,
  param: { attrs: { name: null, value: null } },
  pre: ht,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: ht,
  rt: ht,
  ruby: ht,
  samp: ht,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: DO
    }
  },
  section: ht,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: ht,
  source: { attrs: { src: null, type: null, media: null } },
  span: ht,
  strong: ht,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: ht,
  summary: ht,
  sup: ht,
  table: ht,
  tbody: ht,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: ht,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: ht,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: ht,
  time: { attrs: { datetime: null } },
  title: ht,
  tr: ht,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: ht,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: ht
}, xA = {
  accesskey: null,
  class: null,
  contenteditable: Ii,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Ii,
  autocorrect: Ii,
  autocapitalize: Ii,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Ii,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Ii,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Ii,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Ii,
  "aria-hidden": Ii,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Ii,
  "aria-multiselectable": Ii,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Ii,
  "aria-relevant": null,
  "aria-required": Ii,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, kA = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((n) => "on" + n);
for (let n of kA)
  xA[n] = null;
var Ud;
const SA = (Ud = class {
  constructor(t, e) {
    this.tags = Object.assign(Object.assign({}, aj), t), this.globalAttrs = Object.assign(Object.assign({}, xA), e), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}, c(Ud, "Pc"), Ud);
f(SA, "Schema");
let Sw = SA;
Sw.default = /* @__PURE__ */ new Sw();
function Do(n, t, e = n.length) {
  if (!t)
    return "";
  let i = t.firstChild, s = i && i.getChild("TagName");
  return s ? n.sliceString(s.from, Math.min(s.to, e)) : "";
}
c(Do, "Fi$1");
f(Do, "elementName");
function Wo(n, t = !1) {
  for (; n; n = n.parent)
    if (n.name == "Element")
      if (t)
        t = !1;
      else
        return n;
  return null;
}
c(Wo, "Ki$1");
f(Wo, "findParentElement");
function AS(n, t, e) {
  return e.tags[Do(n, Wo(t))]?.children || e.allTags;
}
c(AS, "bm$1");
f(AS, "allowedChildren");
function Ab(n, t) {
  let e = [];
  for (let i = Wo(t); i && !i.type.isTop; i = Wo(i.parent)) {
    let s = Do(n, i);
    if (s && i.lastChild.name == "CloseTag")
      break;
    s && e.indexOf(s) < 0 && (t.name == "EndTag" || t.from >= i.firstChild.to) && e.push(s);
  }
  return e;
}
c(Ab, "Th$1");
f(Ab, "openTags");
const PA = /^[:\-\.\w\u00b7-\uffff]*$/;
function Gx(n, t, e, i, s) {
  let r = /\s*>/.test(n.sliceDoc(s, s + 5)) ? "" : ">", a = Wo(e, !0);
  return {
    from: i,
    to: s,
    options: AS(n.doc, a, t).map((o) => ({ label: o, type: "type" })).concat(Ab(n.doc, e).map((o, l) => ({
      label: "/" + o,
      apply: "/" + o + r,
      type: "type",
      boost: 99 - l
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
c(Gx, "Sd$1");
f(Gx, "completeTag");
function Kx(n, t, e, i) {
  let s = /\s*>/.test(n.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: e,
    to: i,
    options: Ab(n.doc, t).map((r, a) => ({ label: r, apply: r + s, type: "type", boost: 99 - a })),
    validFor: PA
  };
}
c(Kx, "Qd");
f(Kx, "completeCloseTag");
function CA(n, t, e, i) {
  let s = [], r = 0;
  for (let a of AS(n.doc, e, t))
    s.push({ label: "<" + a, type: "type" });
  for (let a of Ab(n.doc, e))
    s.push({ label: "</" + a + ">", type: "type", boost: 99 - r++ });
  return { from: i, to: i, options: s, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
c(CA, "sQ");
f(CA, "completeStartTag");
function QA(n, t, e, i, s) {
  let r = Wo(e), a = r ? t.tags[Do(n.doc, r)] : null, o = a && a.attrs ? Object.keys(a.attrs) : [], l = a && a.globalAttrs === !1 ? o : o.length ? o.concat(t.globalAttrNames) : t.globalAttrNames;
  return {
    from: i,
    to: s,
    options: l.map((h) => ({ label: h, type: "property" })),
    validFor: PA
  };
}
c(QA, "oQ");
f(QA, "completeAttrName");
function MA(n, t, e, i, s) {
  var r;
  let a = (r = e.parent) === null || r === void 0 ? void 0 : r.getChild("AttributeName"), o = [], l;
  if (a) {
    let h = n.sliceDoc(a.from, a.to), u = t.globalAttrs[h];
    if (!u) {
      let p = Wo(e), y = p ? t.tags[Do(n.doc, p)] : null;
      u = y?.attrs && y.attrs[h];
    }
    if (u) {
      let p = n.sliceDoc(i, s).toLowerCase(), y = '"', m = '"';
      /^['"]/.test(p) ? (l = p[0] == '"' ? /^[^"]*$/ : /^[^']*$/, y = "", m = n.sliceDoc(s, s + 1) == p[0] ? "" : p[0], p = p.slice(1), i++) : l = /^[^\s<>='"]*$/;
      for (let w of u)
        o.push({ label: w, apply: y + w + m, type: "constant" });
    }
  }
  return { from: i, to: s, options: o, validFor: l };
}
c(MA, "lQ");
f(MA, "completeAttrValue");
function RS(n, t) {
  let { state: e, pos: i } = t, s = he(e).resolveInner(i, -1), r = s.resolve(i);
  for (let a = i, o; r == s && (o = s.childBefore(a)); ) {
    let l = o.lastChild;
    if (!l || !l.type.isError || l.from < l.to)
      break;
    r = s = o, a = l.from;
  }
  return s.name == "TagName" ? s.parent && /CloseTag$/.test(s.parent.name) ? Kx(e, s, s.from, i) : Gx(e, n, s, s.from, i) : s.name == "StartTag" ? Gx(e, n, s, i, i) : s.name == "StartCloseTag" || s.name == "IncompleteCloseTag" ? Kx(e, s, i, i) : s.name == "OpenTag" || s.name == "SelfClosingTag" || s.name == "AttributeName" ? QA(e, n, s, s.name == "AttributeName" ? s.from : i, i) : s.name == "Is" || s.name == "AttributeValue" || s.name == "UnquotedAttributeValue" ? MA(e, n, s, s.name == "Is" ? i : s.from, i) : t.explicit && (r.name == "Element" || r.name == "Text" || r.name == "Document") ? CA(e, n, s, i) : null;
}
c(RS, "Qm$1");
f(RS, "htmlCompletionFor");
function TA(n) {
  return RS(Sw.default, n);
}
c(TA, "wm$1");
f(TA, "htmlCompletionSource");
function AA(n) {
  let { extraTags: t, extraGlobalAttributes: e } = n, i = e || t ? new Sw(t, e) : Sw.default;
  return (s) => RS(i, s);
}
c(AA, "xm$1");
f(AA, "htmlCompletionSourceWith");
const oj = /* @__PURE__ */ bn.parser.configure({ top: "SingleExpression" }), RA = [
  {
    tag: "script",
    attrs: /* @__PURE__ */ f((n) => n.type == "text/typescript" || n.lang == "ts", "attrs"),
    parser: yA.parser
  },
  {
    tag: "script",
    attrs: /* @__PURE__ */ f((n) => n.type == "text/babel" || n.type == "text/jsx", "attrs"),
    parser: mA.parser
  },
  {
    tag: "script",
    attrs: /* @__PURE__ */ f((n) => n.type == "text/typescript-jsx", "attrs"),
    parser: wA.parser
  },
  {
    tag: "script",
    attrs(n) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(n.type);
    },
    parser: oj
  },
  {
    tag: "script",
    attrs(n) {
      return !n.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(n.type);
    },
    parser: bn.parser
  },
  {
    tag: "style",
    attrs(n) {
      return (!n.lang || n.lang == "css") && (!n.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(n.type));
    },
    parser: $v.parser
  }
], EA = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ $v.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ kA.map((n) => ({ name: n, parser: bn.parser }))), _A = /* @__PURE__ */ X5.define({
  name: "html",
  parser: /* @__PURE__ */ NW.configure({
    props: [
      /* @__PURE__ */ ky.add({
        Element(n) {
          let t = /^(\s*)(<\/)?/.exec(n.textAfter);
          return n.node.to <= n.pos + t[0].length ? n.continue() : n.lineIndent(n.node.from) + (t[2] ? 0 : n.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(n) {
          return n.column(n.node.from) + n.unit;
        },
        Document(n) {
          if (n.pos + /\s*/.exec(n.textAfter)[0].length < n.node.to)
            return n.continue();
          let t = null, e;
          for (let i = n.node; ; ) {
            let s = i.lastChild;
            if (!s || s.name != "Element" || s.to != i.to)
              break;
            t = i = s;
          }
          return t && !((e = t.lastChild) && (e.name == "CloseTag" || e.name == "SelfClosingTag")) ? n.lineIndent(t.from) + n.unit : null;
        }
      }),
      /* @__PURE__ */ eg.add({
        Element(n) {
          let t = n.firstChild, e = n.lastChild;
          return !t || t.name != "OpenTag" ? null : { from: t.to, to: e.name == "CloseTag" ? e.from : n.to };
        }
      }),
      /* @__PURE__ */ uM.add({
        "OpenTag CloseTag": /* @__PURE__ */ f((n) => n.getChild("TagName"), "OpenTag CloseTag")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
}), m1 = /* @__PURE__ */ _A.configure({
  wrap: /* @__PURE__ */ PS(RA, EA)
});
function zA(n = {}) {
  let t = "", e;
  n.matchClosingTags === !1 && (t = "noMatch"), n.selfClosingTags === !0 && (t = (t ? t + " " : "") + "selfClosing"), (n.nestedLanguages && n.nestedLanguages.length || n.nestedAttributes && n.nestedAttributes.length) && (e = PS((n.nestedLanguages || []).concat(RA), (n.nestedAttributes || []).concat(EA)));
  let i = e ? _A.configure({ wrap: e, dialect: t }) : t ? m1.configure({ dialect: t }) : m1;
  return new Kf(i, [
    m1.data.of({ autocomplete: AA(n) }),
    n.autoCloseTags !== !1 ? lj : [],
    bA().support,
    oA().support
  ]);
}
c(zA, "Rm$1");
f(zA, "html");
const i3 = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), lj = /* @__PURE__ */ $t.inputHandler.of((n, t, e, i, s) => {
  if (n.composing || n.state.readOnly || t != e || i != ">" && i != "/" || !m1.isActiveAt(n.state, t, -1))
    return !1;
  let r = s(), { state: a } = r, o = a.changeByRange((l) => {
    var h, u, p;
    let y = a.doc.sliceString(l.from - 1, l.to) == i, { head: m } = l, w = he(a).resolveInner(m, -1), b;
    if (y && i == ">" && w.name == "EndTag") {
      let $ = w.parent;
      if (((u = (h = $.parent) === null || h === void 0 ? void 0 : h.lastChild) === null || u === void 0 ? void 0 : u.name) != "CloseTag" && (b = Do(a.doc, $.parent, m)) && !i3.has(b)) {
        let x = m + (a.doc.sliceString(m, m + 1) === ">" ? 1 : 0), C = `</${b}>`;
        return { range: l, changes: { from: m, to: x, insert: C } };
      }
    } else if (y && i == "/" && w.name == "IncompleteCloseTag") {
      let $ = w.parent;
      if (w.from == m - 2 && ((p = $.lastChild) === null || p === void 0 ? void 0 : p.name) != "CloseTag" && (b = Do(a.doc, $, m)) && !i3.has(b)) {
        let x = m + (a.doc.sliceString(m, m + 1) === ">" ? 1 : 0), C = `${b}>`;
        return {
          range: J.cursor(m + C.length, -1),
          changes: { from: m, to: x, insert: C }
        };
      }
    }
    return { range: l };
  });
  return o.changes.empty ? !1 : (n.dispatch([
    r,
    a.update(o, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), LA = /* @__PURE__ */ tg({ commentTokens: { block: { open: "<!--", close: "-->" } } }), IA = /* @__PURE__ */ new xt(), ZA = /* @__PURE__ */ ND.configure({
  props: [
    /* @__PURE__ */ eg.add((n) => !n.is("Block") || n.is("Document") || kv(n) != null || VA(n) ? void 0 : (t, e) => ({ from: e.doc.lineAt(t.from).to, to: t.to })),
    /* @__PURE__ */ IA.add(kv),
    /* @__PURE__ */ ky.add({
      Document: /* @__PURE__ */ f(() => null, "Document")
    }),
    /* @__PURE__ */ Or.add({
      Document: LA
    })
  ]
});
function kv(n) {
  let t = /^(?:ATX|Setext)Heading(\d)$/.exec(n.name);
  return t ? +t[1] : void 0;
}
c(kv, "Ga$1");
f(kv, "isHeading");
function VA(n) {
  return n.name == "OrderedList" || n.name == "BulletList";
}
c(VA, "fQ");
f(VA, "isList");
function DA(n, t) {
  let e = n;
  for (; ; ) {
    let i = e.nextSibling, s;
    if (!i || (s = kv(i.type)) != null && s <= t)
      break;
    e = i;
  }
  return e.to;
}
c(DA, "cQ");
f(DA, "findSectionEnd");
const cj = /* @__PURE__ */ NV.of((n, t, e) => {
  for (let i = he(n).resolveInner(e, -1); i && !(i.from < t); i = i.parent) {
    let s = i.type.prop(IA);
    if (s == null)
      continue;
    let r = DA(i, s);
    if (r > e)
      return { from: e, to: r };
  }
  return null;
});
function Rb(n) {
  return new Fi(LA, n, [], "markdown");
}
c(Rb, "Zh$1");
f(Rb, "mkLang");
const hj = /* @__PURE__ */ Rb(ZA), dj = /* @__PURE__ */ ZA.configure([iW, sW, nW, rW, {
  props: [
    /* @__PURE__ */ eg.add({
      Table: /* @__PURE__ */ f((n, t) => ({ from: t.doc.lineAt(n.from).to, to: n.to }), "Table")
    })
  ]
}]), Sv = /* @__PURE__ */ Rb(dj);
function WA(n, t) {
  return (e) => {
    if (e && n) {
      let i = null;
      if (e = /\S*/.exec(e)[0], typeof n == "function" ? i = n(e) : i = C4.matchLanguageName(n, e, !0), i instanceof C4)
        return i.support ? i.support.language.parser : uv.getSkippingParser(i.load());
      if (i)
        return i.parser;
    }
    return t ? t.parser : null;
  };
}
c(WA, "OQ");
f(WA, "getCodeParser");
var Bd;
const qA = (Bd = class {
  constructor(t, e, i, s, r, a, o) {
    this.node = t, this.from = e, this.to = i, this.spaceBefore = s, this.spaceAfter = r, this.type = a, this.item = o;
  }
  blank(t, e = !0) {
    let i = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
    if (t != null) {
      for (; i.length < t; )
        i += " ";
      return i;
    } else {
      for (let s = this.to - this.from - i.length - this.spaceAfter.length; s > 0; s--)
        i += " ";
      return i + (e ? this.spaceAfter : "");
    }
  }
  marker(t, e) {
    let i = this.node.name == "OrderedList" ? String(+_S(this.item, t)[2] + e) : "";
    return this.spaceBefore + i + this.type + this.spaceAfter;
  }
}, c(Bd, "Rc"), Bd);
f(qA, "Context");
let jO = qA;
function ES(n, t) {
  let e = [], i = [];
  for (let s = n; s; s = s.parent) {
    if (s.name == "FencedCode")
      return i;
    (s.name == "ListItem" || s.name == "Blockquote") && e.push(s);
  }
  for (let s = e.length - 1; s >= 0; s--) {
    let r = e[s], a, o = t.lineAt(r.from), l = r.from - o.from;
    if (r.name == "Blockquote" && (a = /^ *>( ?)/.exec(o.text.slice(l))))
      i.push(new jO(r, l, l + a[0].length, "", a[1], ">", null));
    else if (r.name == "ListItem" && r.parent.name == "OrderedList" && (a = /^( *)\d+([.)])( *)/.exec(o.text.slice(l)))) {
      let h = a[3], u = a[0].length;
      h.length >= 4 && (h = h.slice(0, h.length - 4), u -= 4), i.push(new jO(r.parent, l, l + u, a[1], h, a[2], r));
    } else if (r.name == "ListItem" && r.parent.name == "BulletList" && (a = /^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(o.text.slice(l)))) {
      let h = a[4], u = a[0].length;
      h.length > 4 && (h = h.slice(0, h.length - 4), u -= 4);
      let p = a[2];
      a[3] && (p += a[3].replace(/[xX]/, " ")), i.push(new jO(r.parent, l, l + u, a[1], h, p, r));
    }
  }
  return i;
}
c(ES, "Lm$1");
f(ES, "getContext");
function _S(n, t) {
  return /^(\s*)(\d+)(?=[.)])/.exec(t.sliceString(n.from, n.from + 10));
}
c(_S, "Mm$1");
f(_S, "itemNumber");
function w1(n, t, e, i = 0) {
  for (let s = -1, r = n; ; ) {
    if (r.name == "ListItem") {
      let o = _S(r, t), l = +o[2];
      if (s >= 0) {
        if (l != s + 1)
          return;
        e.push({ from: r.from + o[1].length, to: r.from + o[0].length, insert: String(s + 2 + i) });
      }
      s = l;
    }
    let a = r.nextSibling;
    if (!a)
      break;
    r = a;
  }
}
c(w1, "Jo$1");
f(w1, "renumberList");
function Eb(n, t) {
  let e = /^[ \t]*/.exec(n)[0].length;
  if (!e || t.facet($b) != "	")
    return n;
  let i = Nr(n, 4, e), s = "";
  for (let r = i; r > 0; )
    r >= 4 ? (s += "	", r -= 4) : (s += " ", r--);
  return s + n.slice(e);
}
c(Eb, "Lh$1");
f(Eb, "normalizeIndent");
const uj = /* @__PURE__ */ f((n = {}) => ({ state: t, dispatch: e }) => {
  let i = he(t), { doc: s } = t, r = null, a = t.changeByRange((o) => {
    if (!o.empty || !Sv.isActiveAt(t, o.from, -1) && !Sv.isActiveAt(t, o.from, 1))
      return r = { range: o };
    let l = o.from, h = s.lineAt(l), u = ES(i.resolveInner(l, -1), s);
    for (; u.length && u[u.length - 1].from > l - h.from; )
      u.pop();
    if (!u.length)
      return r = { range: o };
    let p = u[u.length - 1];
    if (p.to - p.spaceAfter.length > l - h.from)
      return r = { range: o };
    let y = l >= p.to - p.spaceAfter.length && !/\S/.test(h.text.slice(p.to));
    if (p.item && y) {
      let x = p.node.firstChild, C = p.node.getChild("ListItem", "ListItem");
      if (x.to >= l || C && C.to < l || h.from > 0 && !/[^\s>]/.test(s.lineAt(h.from - 1).text) || n.nonTightLists === !1) {
        let R = u.length > 1 ? u[u.length - 2] : null, E, A = "";
        R && R.item ? (E = h.from + R.from, A = R.marker(s, 1)) : E = h.from + (R ? R.to : 0);
        let I = [{ from: E, to: l, insert: A }];
        return p.node.name == "OrderedList" && w1(p.item, s, I, -2), R && R.node.name == "OrderedList" && w1(R.item, s, I), { range: J.cursor(E + A.length), changes: I };
      } else {
        let R = tk(u, t, h);
        return {
          range: J.cursor(l + R.length + 1),
          changes: { from: h.from, insert: R + t.lineBreak }
        };
      }
    }
    if (p.node.name == "Blockquote" && y && h.from) {
      let x = s.lineAt(h.from - 1), C = />\s*$/.exec(x.text);
      if (C && C.index == p.from) {
        let R = t.changes([
          { from: x.from + C.index, to: x.to },
          { from: h.from + p.from, to: h.to }
        ]);
        return { range: o.map(R), changes: R };
      }
    }
    let m = [];
    p.node.name == "OrderedList" && w1(p.item, s, m);
    let w = p.item && p.item.from < h.from, b = "";
    if (!w || /^[\s\d.)\-+*>]*/.exec(h.text)[0].length >= p.to)
      for (let x = 0, C = u.length - 1; x <= C; x++)
        b += x == C && !w ? u[x].marker(s, 1) : u[x].blank(x < C ? Nr(h.text, 4, u[x + 1].from) - b.length : null);
    let $ = l;
    for (; $ > h.from && /\s/.test(h.text.charAt($ - h.from - 1)); )
      $--;
    return b = Eb(b, t), jA(p.node, t.doc) && (b = tk(u, t, h) + t.lineBreak + b), m.push({ from: $, to: l, insert: t.lineBreak + b }), { range: J.cursor($ + b.length + 1), changes: m };
  });
  return r ? !1 : (e(t.update(a, { scrollIntoView: !0, userEvent: "input" })), !0);
}, "insertNewlineContinueMarkupCommand"), pj = /* @__PURE__ */ uj();
function Jx(n) {
  return n.name == "QuoteMark" || n.name == "ListMark";
}
c(Jx, "xd$1");
f(Jx, "isMark");
function jA(n, t) {
  if (n.name != "OrderedList" && n.name != "BulletList")
    return !1;
  let e = n.firstChild, i = n.getChild("ListItem", "ListItem");
  if (!i)
    return !1;
  let s = t.lineAt(e.to), r = t.lineAt(i.from), a = /^[\s>]*$/.test(s.text);
  return s.number + (a ? 0 : 1) < r.number;
}
c(jA, "pQ");
f(jA, "nonTightList");
function tk(n, t, e) {
  let i = "";
  for (let s = 0, r = n.length - 2; s <= r; s++)
    i += n[s].blank(s < r ? Nr(e.text, 4, n[s + 1].from) - i.length : null, s < r);
  return Eb(i, t);
}
c(tk, "kd$1");
f(tk, "blankLine");
function FA(n, t) {
  let e = n.resolveInner(t, -1), i = t;
  Jx(e) && (i = e.from, e = e.parent);
  for (let s; s = e.childBefore(i); )
    if (Jx(s))
      i = s.from;
    else if (s.name == "OrderedList" || s.name == "BulletList")
      e = s.lastChild, i = e.to;
    else
      break;
  return e;
}
c(FA, "mQ");
f(FA, "contextNodeForDelete");
const fj = /* @__PURE__ */ f(({ state: n, dispatch: t }) => {
  let e = he(n), i = null, s = n.changeByRange((r) => {
    let a = r.from, { doc: o } = n;
    if (r.empty && Sv.isActiveAt(n, r.from)) {
      let l = o.lineAt(a), h = ES(FA(e, a), o);
      if (h.length) {
        let u = h[h.length - 1], p = u.to - u.spaceAfter.length + (u.spaceAfter ? 1 : 0);
        if (a - l.from > p && !/\S/.test(l.text.slice(p, a - l.from)))
          return {
            range: J.cursor(l.from + p),
            changes: { from: l.from + p, to: a }
          };
        if (a - l.from == p && // Only apply this if we're on the line that has the
        // construct's syntax, or there's only indentation in the
        // target range
        (!u.item || l.from <= u.item.from || !/\S/.test(l.text.slice(0, u.to)))) {
          let y = l.from + u.from;
          if (u.item && u.node.from < u.item.from && /\S/.test(l.text.slice(u.from, u.to))) {
            let m = u.blank(Nr(l.text, 4, u.to) - Nr(l.text, 4, u.from));
            return y == l.from && (m = Eb(m, n)), {
              range: J.cursor(y + m.length),
              changes: { from: y, to: l.from + u.to, insert: m }
            };
          }
          if (y < a)
            return { range: J.cursor(y), changes: { from: y, to: a } };
        }
      }
    }
    return i = { range: r };
  });
  return i ? !1 : (t(n.update(s, { scrollIntoView: !0, userEvent: "delete" })), !0);
}, "deleteMarkupBackward"), yj = [
  { key: "Enter", run: pj },
  { key: "Backspace", run: fj }
], UA = /* @__PURE__ */ zA({ matchClosingTags: !1 });
function mj(n = {}) {
  let { codeLanguages: t, defaultCodeLanguage: e, addKeymap: i = !0, base: { parser: s } = hj, completeHTMLTags: r = !0, pasteURLAsLink: a = !0, htmlTagLanguage: o = UA } = n;
  if (!(s instanceof uT))
    throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let l = n.extensions ? [n.extensions] : [], h = [o.support, cj], u;
  a && h.push(gj), e instanceof Kf ? (h.push(e.support), u = e.language) : e && (u = e);
  let p = t || u ? WA(t, u) : void 0;
  l.push(kT({ codeParser: p, htmlParser: o.language.parser })), i && h.push(al.high(wb.of(yj)));
  let y = Rb(s.configure(l));
  return r && h.push(y.data.of({ autocomplete: BA })), new Kf(y, h);
}
c(mj, "Wm$1");
f(mj, "markdown");
function BA(n) {
  let { state: t, pos: e } = n, i = /<[:\-\.\w\u00b7-\uffff]*$/.exec(t.sliceDoc(e - 25, e));
  if (!i)
    return null;
  let s = he(t).resolveInner(e, -1);
  for (; s && !s.type.isTop; ) {
    if (s.name == "CodeBlock" || s.name == "FencedCode" || s.name == "ProcessingInstructionBlock" || s.name == "CommentBlock" || s.name == "Link" || s.name == "Image")
      return null;
    s = s.parent;
  }
  return {
    from: e - i[0].length,
    to: e,
    options: XA(),
    validFor: /^<[:\-\.\w\u00b7-\uffff]*$/
  };
}
c(BA, "gQ");
f(BA, "htmlTagCompletion");
let FO = null;
function XA() {
  if (FO)
    return FO;
  let n = TA(new iS(ze.create({ extensions: UA }), 0, !0));
  return FO = n ? n.options : [];
}
c(XA, "yQ");
f(XA, "htmlTagCompletions");
const wj = /code|horizontalrule|html|link|comment|processing|escape|entity|image|mark|url/i, gj = /* @__PURE__ */ $t.domEventHandlers({
  paste: /* @__PURE__ */ f((n, t) => {
    var e;
    let { main: i } = t.state.selection;
    if (i.empty)
      return !1;
    let s = (e = n.clipboardData) === null || e === void 0 ? void 0 : e.getData("text/plain");
    if (!s || !/^(https?:\/\/|mailto:|xmpp:|www\.)/.test(s) || (/^www\./.test(s) && (s = "https://" + s), !Sv.isActiveAt(t.state, i.from, 1)))
      return !1;
    let r = he(t.state), a = !1;
    return r.iterate({
      from: i.from,
      to: i.to,
      enter: /* @__PURE__ */ f((o) => {
        (o.from > i.from || wj.test(o.name)) && (a = !0);
      }, "enter"),
      leave: /* @__PURE__ */ f((o) => {
        o.to < i.to && (a = !0);
      }, "leave")
    }), a ? !1 : (t.dispatch({
      changes: [{ from: i.from, insert: "[" }, { from: i.to, insert: `](${s})` }],
      userEvent: "input.paste",
      scrollIntoView: !0
    }), !0);
  }, "paste")
});
function vj(n) {
  return new Kf(tD.define(n));
}
c(vj, "w$1");
f(vj, "legacy");
function bj(n) {
  return import(
    /* webpackIgnore: true */
    /* @vite-ignore */
    new URL("./@codemirror/lang-sql/dist/index.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
  ).then((t) => t.sql({ dialect: t[n] }));
}
c(bj, "pt$1");
f(bj, "sql");
function Oj(n) {
  const t = new Event("Weavy-SoftSubmit");
  return n.dom.dispatchEvent(t), !0;
}
c(Oj, "Ym$1");
f(Oj, "softSubmit");
const n3 = new SV({
  regexp: /(\[(.+?)\])(\(@u(\d+)\))/g,
  decoration: /* @__PURE__ */ f((n) => ee.replace({
    // NOTE: can't use backspace to go "up one row" when inclusive is false
    inclusive: !0,
    widget: new $j(n)
  }), "decoration")
});
var Xd;
const NA = (Xd = class extends xy {
  constructor(t) {
    super(), this.match = t;
  }
  eq(t) {
    return t.match[1] === this.match[1];
  }
  toDOM() {
    ii();
    const t = document.createElement("span");
    return t.className = "wy-mention", t.innerHTML = typeof this.match[5] < "u" ? this.match[5] : this.match[2], t;
  }
  ignoreEvent() {
    return !1;
  }
}, c(Xd, "$c"), Xd);
f(NA, "MentionWidget");
let $j = NA;
Zs.fromClass(
  class {
    constructor(n) {
      this.mentions = n3.createDeco(n);
    }
    update(n) {
      this.mentions = n3.updateDeco(n, this.mentions);
    }
  },
  {
    decorations: /* @__PURE__ */ f((n) => n.mentions, "decorations"),
    provide: /* @__PURE__ */ f((n) => $t.atomicRanges.of((t) => t.plugin(n)?.mentions || ee.none), "provide")
  }
);
function xj(n, t) {
  return ({ state: e, dispatch: i }) => {
    if (e.readOnly)
      return !1;
    let s = n(t, e);
    return s ? (i(e.update(s)), !0) : !1;
  };
}
c(xj, "Mh");
f(xj, "command");
function zS(n, t) {
  let e = n.languageDataAt("commentTokens", t, 1);
  return e.length ? e[0] : {};
}
c(zS, "_h");
f(zS, "getConfig");
const jy = 50;
function HA(n, { open: t, close: e }, i, s) {
  let r = n.sliceDoc(i - jy, i), a = n.sliceDoc(s, s + jy), o = /\s*$/.exec(r)[0].length, l = /^\s*/.exec(a)[0].length, h = r.length - o;
  if (r.slice(h - t.length, h) == t && a.slice(l, l + e.length) == e)
    return {
      open: { pos: i - o, margin: o && 1 },
      close: { pos: s + l, margin: l && 1 }
    };
  let u, p;
  s - i <= 2 * jy ? u = p = n.sliceDoc(i, s) : (u = n.sliceDoc(i, i + jy), p = n.sliceDoc(s - jy, s));
  let y = /^\s*/.exec(u)[0].length, m = /\s*$/.exec(p)[0].length, w = p.length - m - e.length;
  return u.slice(y, y + t.length) == t && p.slice(w, w + e.length) == e ? {
    open: {
      pos: i + y + t.length,
      margin: /\s/.test(u.charAt(y + t.length)) ? 1 : 0
    },
    close: {
      pos: s - m - e.length,
      margin: /\s/.test(p.charAt(w - 1)) ? 1 : 0
    }
  } : null;
}
c(HA, "AQ");
f(HA, "findBlockComment");
function kj(n) {
  let t = [];
  for (let e of n.selection.ranges) {
    let i = n.doc.lineAt(e.from), s = e.to <= i.to ? i : n.doc.lineAt(e.to);
    s.from > i.from && s.from == e.to && (s = e.to == i.to + 1 ? i : n.doc.lineAt(e.to - 1));
    let r = t.length - 1;
    r >= 0 && t[r].to > i.from ? t[r].to = s.to : t.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: s.to });
  }
  return t;
}
c(kj, "ZQ");
f(kj, "selectedLineRanges");
function Sj(n, t, e = t.selection.ranges) {
  let i = e.map((r) => zS(t, r.from).block);
  if (!i.every((r) => r))
    return null;
  let s = e.map((r, a) => HA(t, i[a], r.from, r.to));
  if (n != 2 && !s.every((r) => r))
    return { changes: t.changes(e.map((r, a) => s[a] ? [] : [{ from: r.from, insert: i[a].open + " " }, { from: r.to, insert: " " + i[a].close }])) };
  if (n != 1 && s.some((r) => r)) {
    let r = [];
    for (let a = 0, o; a < s.length; a++)
      if (o = s[a]) {
        let l = i[a], { open: h, close: u } = o;
        r.push({ from: h.pos - l.open.length, to: h.pos + h.margin }, { from: u.pos - u.margin, to: u.pos + l.close.length });
      }
    return { changes: r };
  }
  return null;
}
c(Sj, "Im$1");
f(Sj, "changeBlockComment");
function Pj(n, t, e = t.selection.ranges) {
  let i = [], s = -1;
  for (let { from: r, to: a } of e) {
    let o = i.length, l = 1e9, h = zS(t, r).line;
    if (h) {
      for (let u = r; u <= a; ) {
        let p = t.doc.lineAt(u);
        if (p.from > s && (r == a || a > p.from)) {
          s = p.from;
          let y = /^\s*/.exec(p.text)[0].length, m = y == p.length, w = p.text.slice(y, y + h.length) == h ? y : -1;
          y < p.text.length && y < l && (l = y), i.push({ line: p, comment: w, token: h, indent: y, empty: m, single: !1 });
        }
        u = p.to + 1;
      }
      if (l < 1e9)
        for (let u = o; u < i.length; u++)
          i[u].indent < i[u].line.text.length && (i[u].indent = l);
      i.length == o + 1 && (i[o].single = !0);
    }
  }
  if (n != 2 && i.some((r) => r.comment < 0 && (!r.empty || r.single))) {
    let r = [];
    for (let { line: o, token: l, indent: h, empty: u, single: p } of i)
      (p || !u) && r.push({ from: o.from + h, insert: l + " " });
    let a = t.changes(r);
    return { changes: a, selection: t.selection.map(a, 1) };
  } else if (n != 1 && i.some((r) => r.comment >= 0)) {
    let r = [];
    for (let { line: a, comment: o, token: l } of i)
      if (o >= 0) {
        let h = a.from + o, u = h + l.length;
        a.text[u - a.from] == " " && u++, r.push({ from: h, to: u });
      }
    return { changes: r };
  }
  return null;
}
c(Pj, "LQ");
f(Pj, "changeLineComment");
const ek = /* @__PURE__ */ Ns.define(), Cj = /* @__PURE__ */ Ns.define(), Qj = /* @__PURE__ */ gt.define(), YA = /* @__PURE__ */ gt.define({
  combine(n) {
    return o5(n, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: /* @__PURE__ */ f((t, e) => e, "joinToEvent")
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: /* @__PURE__ */ f((t, e) => (i, s) => t(i, s) || e(i, s), "joinToEvent")
    });
  }
}), GA = /* @__PURE__ */ Xs.define({
  create() {
    return rw.empty;
  },
  update(n, t) {
    let e = t.state.facet(YA), i = t.annotation(ek);
    if (i) {
      let l = Ps.fromTransaction(t, i.selection), h = i.side, u = h == 0 ? n.undone : n.done;
      return l ? u = Pw(u, u.length, e.minDepth, l) : u = ZS(u, t.startState.selection), new rw(h == 0 ? i.rest : u, h == 0 ? u : i.rest);
    }
    let s = t.annotation(Cj);
    if ((s == "full" || s == "before") && (n = n.isolate()), t.annotation(gi.addToHistory) === !1)
      return t.changes.empty ? n : n.addMapping(t.changes.desc);
    let r = Ps.fromTransaction(t), a = t.annotation(gi.time), o = t.annotation(gi.userEvent);
    return r ? n = n.addChanges(r, a, o, e, t) : t.selection && (n = n.addSelection(t.startState.selection, a, o, e.newGroupDelay)), (s == "full" || s == "after") && (n = n.isolate()), n;
  },
  toJSON(n) {
    return { done: n.done.map((t) => t.toJSON()), undone: n.undone.map((t) => t.toJSON()) };
  },
  fromJSON(n) {
    return new rw(n.done.map(Ps.fromJSON), n.undone.map(Ps.fromJSON));
  }
});
function Mj(n = {}) {
  return [
    GA,
    YA.of(n),
    $t.domEventHandlers({
      beforeinput(t, e) {
        let i = t.inputType == "historyUndo" ? Tj : t.inputType == "historyRedo" ? Aj : null;
        return i ? (t.preventDefault(), i(e)) : !1;
      }
    })
  ];
}
c(Mj, "CQ");
f(Mj, "history");
function LS(n, t) {
  return function({ state: e, dispatch: i }) {
    if (!t && e.readOnly)
      return !1;
    let s = e.field(GA, !1);
    if (!s)
      return !1;
    let r = s.pop(n, e, t);
    return r ? (i(r), !0) : !1;
  };
}
c(LS, "Qo$1");
f(LS, "cmd");
const Tj = /* @__PURE__ */ LS(0, !1), Aj = /* @__PURE__ */ LS(1, !1);
var Kn;
const KA = (Kn = class {
  constructor(t, e, i, s, r) {
    this.changes = t, this.effects = e, this.mapped = i, this.startSelection = s, this.selectionsAfter = r;
  }
  setSelAfter(t) {
    return new Kn(this.changes, this.effects, this.mapped, this.startSelection, t);
  }
  toJSON() {
    var t, e, i;
    return {
      changes: (t = this.changes) === null || t === void 0 ? void 0 : t.toJSON(),
      mapped: (e = this.mapped) === null || e === void 0 ? void 0 : e.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
    };
  }
  static fromJSON(t) {
    return new Kn(t.changes && $n.fromJSON(t.changes), [], t.mapped && zc.fromJSON(t.mapped), t.startSelection && J.fromJSON(t.startSelection), t.selectionsAfter.map(J.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(t, e) {
    let i = Ji;
    for (let s of t.startState.facet(Qj)) {
      let r = s(t);
      r.length && (i = i.concat(r));
    }
    return !i.length && t.changes.empty ? null : new Kn(t.changes.invert(t.startState.doc), i, void 0, e || t.startState.selection, Ji);
  }
  static selection(t) {
    return new Kn(void 0, Ji, void 0, void 0, t);
  }
}, c(Kn, "Gt"), Kn);
f(KA, "HistEvent");
let Ps = KA;
function Pw(n, t, e, i) {
  let s = t + 1 > e + 20 ? t - e - 1 : 0, r = n.slice(s, t);
  return r.push(i), r;
}
c(Pw, "Us$1");
f(Pw, "updateBranch");
function JA(n, t) {
  let e = [], i = !1;
  return n.iterChangedRanges((s, r) => e.push(s, r)), t.iterChangedRanges((s, r, a, o) => {
    for (let l = 0; l < e.length; ) {
      let h = e[l++], u = e[l++];
      o >= h && a <= u && (i = !0);
    }
  }), i;
}
c(JA, "UQ");
f(JA, "isAdjacent");
function tR(n, t) {
  return n.ranges.length == t.ranges.length && n.ranges.filter((e, i) => e.empty != t.ranges[i].empty).length === 0;
}
c(tR, "WQ");
f(tR, "eqSelectionShape");
function IS(n, t) {
  return n.length ? t.length ? n.concat(t) : n : t;
}
c(IS, "Bm$1");
f(IS, "conc");
const Ji = [], Rj = 200;
function ZS(n, t) {
  if (n.length) {
    let e = n[n.length - 1], i = e.selectionsAfter.slice(Math.max(0, e.selectionsAfter.length - Rj));
    return i.length && i[i.length - 1].eq(t) ? n : (i.push(t), Pw(n, n.length - 1, 1e9, e.setSelAfter(i)));
  } else
    return [Ps.selection([t])];
}
c(ZS, "zm$1");
f(ZS, "addSelection");
function eR(n) {
  let t = n[n.length - 1], e = n.slice();
  return e[n.length - 1] = t.setSelAfter(t.selectionsAfter.slice(0, t.selectionsAfter.length - 1)), e;
}
c(eR, "YQ");
f(eR, "popSelection");
function g1(n, t) {
  if (!n.length)
    return n;
  let e = n.length, i = Ji;
  for (; e; ) {
    let s = iR(n[e - 1], t, i);
    if (s.changes && !s.changes.empty || s.effects.length) {
      let r = n.slice(0, e);
      return r[e - 1] = s, r;
    } else
      t = s.mapped, e--, i = s.selectionsAfter;
  }
  return i.length ? [Ps.selection(i)] : Ji;
}
c(g1, "tl$1");
f(g1, "addMappingToBranch");
function iR(n, t, e) {
  let i = IS(n.selectionsAfter.length ? n.selectionsAfter.map((o) => o.map(t)) : Ji, e);
  if (!n.changes)
    return Ps.selection(i);
  let s = n.changes.map(t), r = t.mapDesc(n.changes, !0), a = n.mapped ? n.mapped.composeDesc(r) : r;
  return new Ps(s, Bt.mapEffects(n.effects, t), a, n.startSelection.map(r), i);
}
c(iR, "IQ");
f(iR, "mapEvent");
const Ej = /^(input\.type|delete)($|\.)/;
var Jn;
const nR = (Jn = class {
  constructor(t, e, i = 0, s = void 0) {
    this.done = t, this.undone = e, this.prevTime = i, this.prevUserEvent = s;
  }
  isolate() {
    return this.prevTime ? new Jn(this.done, this.undone) : this;
  }
  addChanges(t, e, i, s, r) {
    let a = this.done, o = a[a.length - 1];
    return o && o.changes && !o.changes.empty && t.changes && (!i || Ej.test(i)) && (!o.selectionsAfter.length && e - this.prevTime < s.newGroupDelay && s.joinToEvent(r, JA(o.changes, t.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? a = Pw(a, a.length - 1, s.minDepth, new Ps(t.changes.compose(o.changes), IS(Bt.mapEffects(t.effects, o.changes), o.effects), o.mapped, o.startSelection, Ji)) : a = Pw(a, a.length, s.minDepth, t), new Jn(a, Ji, e, i);
  }
  addSelection(t, e, i, s) {
    let r = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Ji;
    return r.length > 0 && e - this.prevTime < s && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && tR(r[r.length - 1], t) ? this : new Jn(ZS(this.done, t), this.undone, e, i);
  }
  addMapping(t) {
    return new Jn(g1(this.done, t), g1(this.undone, t), this.prevTime, this.prevUserEvent);
  }
  pop(t, e, i) {
    let s = t == 0 ? this.done : this.undone;
    if (s.length == 0)
      return null;
    let r = s[s.length - 1], a = r.selectionsAfter[0] || e.selection;
    if (i && r.selectionsAfter.length)
      return e.update({
        selection: r.selectionsAfter[r.selectionsAfter.length - 1],
        annotations: ek.of({ side: t, rest: eR(s), selection: a }),
        userEvent: t == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (r.changes) {
      let o = s.length == 1 ? Ji : s.slice(0, s.length - 1);
      return r.mapped && (o = g1(o, r.mapped)), e.update({
        changes: r.changes,
        selection: r.startSelection,
        effects: r.effects,
        annotations: ek.of({ side: t, rest: o, selection: a }),
        filter: !1,
        userEvent: t == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}, c(Jn, "Ht"), Jn);
f(nR, "HistoryState");
let rw = nR;
rw.empty = /* @__PURE__ */ new rw(Ji, Ji);
function ng(n, t) {
  return J.create(n.ranges.map(t), n.mainIndex);
}
c(ng, "tr$1");
f(ng, "updateSel");
function Sy(n, t) {
  return n.update({ selection: t, scrollIntoView: !0, userEvent: "select" });
}
c(Sy, "De$2");
f(Sy, "setSel");
function _b({ state: n, dispatch: t }, e) {
  let i = ng(n.selection, e);
  return i.eq(n.selection, !0) ? !1 : (t(Sy(n, i)), !0);
}
c(_b, "Be$2");
f(_b, "moveSel");
function sg(n, t) {
  return J.cursor(t ? n.to : n.from);
}
c(sg, "wo$1");
f(sg, "rangeEnd");
function _j(n, t) {
  return _b(n, (e) => e.empty ? n.moveByChar(e, t) : sg(e, t));
}
c(_j, "Nm$1");
f(_j, "cursorByChar");
function zj(n) {
  return n.textDirectionAt(n.state.selection.main.head) == Qe.LTR;
}
c(zj, "he$1");
f(zj, "ltrAtCursor");
function Lj(n, t) {
  return _b(n, (e) => e.empty ? n.moveByGroup(e, t) : sg(e, t));
}
c(Lj, "Fm$1");
f(Lj, "cursorByGroup");
function sR(n, t, e) {
  if (t.type.prop(e))
    return !0;
  let i = t.to - t.from;
  return i && (i > 2 || /[^\s,.;:]/.test(n.sliceDoc(t.from, t.to))) || t.firstChild;
}
c(sR, "zQ");
f(sR, "interestingNode");
function Ij(n, t, e) {
  let i = he(n).resolveInner(t.head), s = e ? xt.closedBy : xt.openedBy;
  for (let l = t.head; ; ) {
    let h = e ? i.childAfter(l) : i.childBefore(l);
    if (!h)
      break;
    sR(n, h, s) ? i = h : l = e ? h.to : h.from;
  }
  let r = i.type.prop(s), a, o;
  return r && (a = e ? ja(n, i.from, 1) : ja(n, i.to, -1)) && a.matched ? o = e ? a.end.to : a.end.from : o = e ? i.to : i.from, J.cursor(o, e ? -1 : 1);
}
c(Ij, "xo$1");
f(Ij, "moveBySyntax");
function Zj(n, t) {
  return _b(n, (e) => {
    if (!e.empty)
      return sg(e, t);
    let i = n.moveVertically(e, t);
    return i.head != e.head ? i : n.moveToLineBoundary(e, t);
  });
}
c(Zj, "Km$1");
f(Zj, "cursorByLine");
function VS(n) {
  let t = n.scrollDOM.clientHeight < n.scrollDOM.scrollHeight - 2, e = 0, i = 0, s;
  if (t) {
    for (let r of n.state.facet($t.scrollMargins)) {
      let a = r(n);
      a?.top && (e = Math.max(a?.top, e)), a?.bottom && (i = Math.max(a?.bottom, i));
    }
    s = n.scrollDOM.clientHeight - e - i;
  } else
    s = (n.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: e,
    marginBottom: i,
    selfScroll: t,
    height: Math.max(n.defaultLineHeight, s - 5)
  };
}
c(VS, "tg$1");
f(VS, "pageInfo");
function Vj(n, t) {
  let e = VS(n), { state: i } = n, s = ng(i.selection, (a) => a.empty ? n.moveVertically(a, t, e.height) : sg(a, t));
  if (s.eq(i.selection))
    return !1;
  let r;
  if (e.selfScroll) {
    let a = n.coordsAtPos(i.selection.main.head), o = n.scrollDOM.getBoundingClientRect(), l = o.top + e.marginTop, h = o.bottom - e.marginBottom;
    a && a.top > l && a.bottom < h && (r = $t.scrollIntoView(s.main.head, { y: "start", yMargin: a.top - l }));
  }
  return n.dispatch(Sy(i, s), { effects: r }), !0;
}
c(Vj, "ig$1");
f(Vj, "cursorByPage");
function Dj(n, t, e) {
  let i = n.lineBlockAt(t.head), s = n.moveToLineBoundary(t, e);
  if (s.head == t.head && s.head != (e ? i.to : i.from) && (s = n.moveToLineBoundary(t, e, !1)), !e && s.head == i.from && i.length) {
    let r = /^\s*/.exec(n.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    r && t.head != i.from + r && (s = J.cursor(i.from + r));
  }
  return s;
}
c(Dj, "_t$1");
f(Dj, "moveByLineBoundary");
function Wj(n, t, e) {
  let i = !1, s = ng(n.selection, (r) => {
    let a = ja(n, r.head, -1) || ja(n, r.head, 1) || r.head > 0 && ja(n, r.head - 1, 1) || r.head < n.doc.length && ja(n, r.head + 1, -1);
    if (!a || !a.end)
      return r;
    i = !0;
    let o = a.start.from == r.head ? a.end.to : a.end.from;
    return J.cursor(o);
  });
  return i ? (t(Sy(n, s)), !0) : !1;
}
c(Wj, "iw$1");
f(Wj, "toMatchingBracket");
function rg(n, t) {
  let e = ng(n.state.selection, (i) => {
    let s = t(i);
    return J.range(i.anchor, s.head, s.goalColumn, s.bidiLevel || void 0);
  });
  return e.eq(n.state.selection) ? !1 : (n.dispatch(Sy(n.state, e)), !0);
}
c(rg, "Ue$2");
f(rg, "extendSel");
function qj(n, t) {
  return rg(n, (e) => n.moveByChar(e, t));
}
c(qj, "rg$1");
f(qj, "selectByChar");
function jj(n, t) {
  return rg(n, (e) => n.moveByGroup(e, t));
}
c(jj, "og$1");
f(jj, "selectByGroup");
function Fj(n, t) {
  return rg(n, (e) => n.moveVertically(e, t));
}
c(Fj, "lg$1");
f(Fj, "selectByLine");
function Uj(n, t) {
  return rg(n, (e) => n.moveVertically(e, t, VS(n).height));
}
c(Uj, "fg$1");
f(Uj, "selectByPage");
function Bj(n, t) {
  let { state: e } = n, i = e.selection, s = e.selection.ranges.slice();
  for (let r of e.selection.ranges) {
    let a = e.doc.lineAt(r.head);
    if (t ? a.to < n.state.doc.length : a.from > 0)
      for (let o = r; ; ) {
        let l = n.moveVertically(o, t);
        if (l.head < a.from || l.head > a.to) {
          s.some((h) => h.head == l.head) || s.push(l);
          break;
        } else {
          if (l.head == o.head)
            break;
          o = l;
        }
      }
  }
  return s.length == i.ranges.length ? !1 : (n.dispatch(Sy(e, J.create(s, s.length - 1))), !0);
}
c(Bj, "cg$1");
f(Bj, "addCursorVertically");
function Xj(n, t) {
  if (n.state.readOnly)
    return !1;
  let e = "delete.selection", { state: i } = n, s = i.changeByRange((r) => {
    let { from: a, to: o } = r;
    if (a == o) {
      let l = t(r);
      l < a ? (e = "delete.backward", l = $m(n, l, !1)) : l > a && (e = "delete.forward", l = $m(n, l, !0)), a = Math.min(a, l), o = Math.max(o, l);
    } else
      a = $m(n, a, !1), o = $m(n, o, !0);
    return a == o ? { range: r } : { changes: { from: a, to: o }, range: J.cursor(a, a < r.head ? -1 : 1) };
  });
  return s.changes.empty ? !1 : (n.dispatch(i.update(s, {
    scrollIntoView: !0,
    userEvent: e,
    effects: e == "delete.selection" ? $t.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
c(Xj, "xn$1");
f(Xj, "deleteBy");
function $m(n, t, e) {
  if (n instanceof $t)
    for (let i of n.state.facet($t.atomicRanges).map((s) => s(n)))
      i.between(t, t, (s, r) => {
        s < t && r > t && (t = e ? r : s);
      });
  return t;
}
c($m, "Dn$1");
f($m, "skipAtomic");
function DS(n) {
  let t = [], e = -1;
  for (let i of n.selection.ranges) {
    let s = n.doc.lineAt(i.from), r = n.doc.lineAt(i.to);
    if (!i.empty && i.to == r.from && (r = n.doc.lineAt(i.to - 1)), e >= s.number) {
      let a = t[t.length - 1];
      a.to = r.to, a.ranges.push(i);
    } else
      t.push({ from: s.from, to: r.to, ranges: [i] });
    e = r.number + 1;
  }
  return t;
}
c(DS, "ko$1");
f(DS, "selectedLineBlocks");
function Nj(n, t, e) {
  if (n.readOnly)
    return !1;
  let i = [], s = [];
  for (let r of DS(n)) {
    if (e ? r.to == n.doc.length : r.from == 0)
      continue;
    let a = n.doc.lineAt(e ? r.to + 1 : r.from - 1), o = a.length + 1;
    if (e) {
      i.push({ from: r.to, to: a.to }, { from: r.from, insert: a.text + n.lineBreak });
      for (let l of r.ranges)
        s.push(J.range(Math.min(n.doc.length, l.anchor + o), Math.min(n.doc.length, l.head + o)));
    } else {
      i.push({ from: a.from, to: r.from }, { from: r.to, insert: n.lineBreak + a.text });
      for (let l of r.ranges)
        s.push(J.range(l.anchor - o, l.head - o));
    }
  }
  return i.length ? (t(n.update({
    changes: i,
    scrollIntoView: !0,
    selection: J.create(s, n.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
c(Nj, "mg$1");
f(Nj, "moveLine");
function Hj(n, t, e) {
  if (n.readOnly)
    return !1;
  let i = [];
  for (let s of DS(n))
    e ? i.push({ from: s.from, insert: n.doc.slice(s.from, s.to) + n.lineBreak }) : i.push({ from: s.to, insert: n.lineBreak + n.doc.slice(s.from, s.to) });
  return t(n.update({ changes: i, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
c(Hj, "gg$1");
f(Hj, "copyLine");
function rR(n, t) {
  if (/\(\)|\[\]|\{\}/.test(n.sliceDoc(t - 1, t + 1)))
    return { from: t, to: t };
  let e = he(n).resolveInner(t), i = e.childBefore(t), s = e.childAfter(t), r;
  return i && s && i.to <= t && s.from >= t && (r = i.type.prop(xt.closedBy)) && r.indexOf(s.name) > -1 && n.doc.lineAt(i.to).from == n.doc.lineAt(s.from).from && !/\S/.test(n.sliceDoc(i.to, s.from)) ? { from: i.to, to: s.from } : null;
}
c(rR, "Zw$1");
f(rR, "isBetweenBrackets");
function Yj(n) {
  return ({ state: t, dispatch: e }) => {
    if (t.readOnly)
      return !1;
    let i = t.changeByRange((s) => {
      let { from: r, to: a } = s, o = t.doc.lineAt(r), l = !n && r == a && rR(t, r);
      n && (r = a = (a <= o.to ? o : t.doc.lineAt(a)).to);
      let h = new N5(t, { simulateBreak: r, simulateDoubleBreak: !!l }), u = K6(h, r);
      for (u == null && (u = Nr(/^\s*/.exec(t.doc.lineAt(r).text)[0], t.tabSize)); a < o.to && /\s/.test(o.text[a - o.from]); )
        a++;
      l ? { from: r, to: a } = l : r > o.from && r < o.from + 100 && !/\S/.test(o.text.slice(0, r)) && (r = o.from);
      let p = ["", kx(t, u)];
      return l && p.push(kx(t, h.lineIndent(o.from, -1))), {
        changes: { from: r, to: a, insert: Vt.of(p) },
        range: J.cursor(r + 1 + p[1].length)
      };
    });
    return e(t.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
c(Yj, "yg$1");
f(Yj, "newlineAndIndent");
function Gj(n, t) {
  let e = -1;
  return n.changeByRange((i) => {
    let s = [];
    for (let a = i.from; a <= i.to; ) {
      let o = n.doc.lineAt(a);
      o.number > e && (i.empty || i.to > o.from) && (t(o, s, i), e = o.number), a = o.to + 1;
    }
    let r = n.changes(s);
    return {
      changes: s,
      range: J.range(r.mapPos(i.anchor, 1), r.mapPos(i.head, 1))
    };
  });
}
c(Gj, "Ch");
f(Gj, "changeBySelectedLine");
cM.define([
  { tag: M.meta, class: "code" },
  { tag: M.link, class: "wy-link" },
  { tag: M.heading, textDecoration: "underline", fontWeight: "bold" },
  { tag: M.emphasis, fontStyle: "italic" },
  { tag: M.strong, fontWeight: "bold" },
  { tag: M.strikethrough, textDecoration: "line-through" },
  { tag: M.keyword, class: "code token keyword" },
  { tag: [M.atom, M.bool], class: "code token builtin" },
  { tag: [M.url, M.contentSeparator, M.labelName], class: "code token prolog" },
  { tag: M.literal, class: "code token char" },
  { tag: M.inserted, class: "code token inserted" },
  { tag: M.deleted, class: "code token deleted" },
  { tag: M.string, class: "code token string" },
  { tag: [M.regexp, M.escape, M.special(M.string)], class: "code token regex" },
  { tag: M.definition(M.variableName), class: "code token constant" },
  { tag: M.local(M.variableName), class: "code token variable" },
  { tag: [M.typeName, M.namespace], class: "code token keyword" },
  { tag: M.className, class: "code token class-name" },
  { tag: [M.special(M.variableName), M.macroName], class: "code token function" },
  { tag: M.propertyName, class: "code token property" },
  { tag: M.comment, class: "code token comment" },
  { tag: M.invalid, color: "#f00", class: "code token" }
]);
function Kj(n) {
  WS(n, "start");
  var t = {}, e = n.languageData || {}, i = !1;
  for (var s in n) if (s != e && n.hasOwnProperty(s))
    for (var r = t[s] = [], a = n[s], o = 0; o < a.length; o++) {
      var l = a[o];
      r.push(new lR(l, n)), (l.indent || l.dedent) && (i = !0);
    }
  return {
    name: e.name,
    startState: /* @__PURE__ */ f(function() {
      return { state: "start", pending: null, indent: i ? [] : null };
    }, "startState"),
    copyState: /* @__PURE__ */ f(function(h) {
      var u = { state: h.state, pending: h.pending, indent: h.indent && h.indent.slice(0) };
      return h.stack && (u.stack = h.stack.slice(0)), u;
    }, "copyState"),
    token: cR(t),
    indent: hR(t, e),
    mergeTokens: e.mergeTokens,
    languageData: e
  };
}
c(Kj, "ix$1");
f(Kj, "simpleMode");
function WS(n, t) {
  if (!n.hasOwnProperty(t))
    throw new Error("Undefined state " + t + " in simple mode");
}
c(WS, "bg$1");
f(WS, "ensureState");
function aR(n, t) {
  if (!n) return /(?:)/;
  var e = "";
  return n instanceof RegExp ? (n.ignoreCase && (e = "i"), n = n.source) : n = String(n), new RegExp("^(?:" + n + ")", e);
}
c(aR, "Yw$1");
f(aR, "toRegex");
function oR(n) {
  if (!n) return null;
  if (n.apply) return n;
  if (typeof n == "string") return n.replace(/\./g, " ");
  for (var t = [], e = 0; e < n.length; e++)
    t.push(n[e] && n[e].replace(/\./g, " "));
  return t;
}
c(oR, "Iw$1");
f(oR, "asToken");
function lR(n, t) {
  (n.next || n.push) && WS(t, n.next || n.push), this.regex = aR(n.regex), this.token = oR(n.token), this.data = n;
}
c(lR, "jw$1");
f(lR, "Rule");
function cR(n) {
  return function(t, e) {
    if (e.pending) {
      var i = e.pending.shift();
      return e.pending.length == 0 && (e.pending = null), t.pos += i.text.length, i.token;
    }
    for (var s = n[e.state], r = 0; r < s.length; r++) {
      var a = s[r], o = (!a.data.sol || t.sol()) && t.match(a.regex);
      if (o) {
        a.data.next ? e.state = a.data.next : a.data.push ? ((e.stack || (e.stack = [])).push(e.state), e.state = a.data.push) : a.data.pop && e.stack && e.stack.length && (e.state = e.stack.pop()), a.data.indent && e.indent.push(t.indentation() + t.indentUnit), a.data.dedent && e.indent.pop();
        var l = a.token;
        if (l && l.apply && (l = l(o)), o.length > 2 && a.token && typeof a.token != "string") {
          e.pending = [];
          for (var h = 2; h < o.length; h++)
            o[h] && e.pending.push({ text: o[h], token: a.token[h - 1] });
          return t.backUp(o[0].length - (o[1] ? o[1].length : 0)), l[0];
        } else return l && l.join ? l[0] : l;
      }
    }
    return t.next(), null;
  };
}
c(cR, "qw$1");
f(cR, "tokenFunction");
function hR(n, t) {
  return function(e, i) {
    if (e.indent == null || t.dontIndentStates && t.dontIndentStates.indexOf(e.state) > -1)
      return null;
    var s = e.indent.length - 1, r = n[e.state];
    t: for (; ; ) {
      for (var a = 0; a < r.length; a++) {
        var o = r[a];
        if (o.data.dedent && o.data.dedentIfLineStart !== !1) {
          var l = o.regex.exec(i);
          if (l && l[0]) {
            s--, (o.next || o.push) && (r = n[o.next || o.push]), i = i.slice(l[0].length);
            continue t;
          }
        }
      }
      break;
    }
    return s < 0 ? 0 : e.indent[s];
  };
}
c(hR, "Dw$1");
f(hR, "indentFunction");
var Jj = Object.defineProperty, dt = /* @__PURE__ */ c((n, t) => Jj(n, "name", { value: t, configurable: !0 }), "o$1");
const ik = "lit-localize-status", tF = /* @__PURE__ */ dt((n, ...t) => ({
  strTag: !0,
  strings: n,
  values: t
}), "_str"), nt = tF, eF = /* @__PURE__ */ dt((n) => typeof n != "string" && "strTag" in n, "isStrTagged"), dR = /* @__PURE__ */ dt((n, t, e) => {
  let i = n[0];
  for (let s = 1; s < n.length; s++)
    i += t[e ? e[s - 1] : s - 1], i += n[s];
  return i;
}, "joinStringsAndValues"), uR = /* @__PURE__ */ dt((n) => eF(n) ? dR(n.strings, n.values) : n, "defaultMsg");
let P = uR, s3 = !1;
function pR(n) {
  if (s3)
    throw new Error("lit-localize can only be configured once");
  P = n, s3 = !0;
}
c(pR, "kt");
dt(pR, "_installMsgImplementation");
var Nd;
const fR = (Nd = class {
  constructor(t) {
    this.__litLocalizeEventHandler = (e) => {
      e.detail.status === "ready" && this.host.requestUpdate();
    }, this.host = t;
  }
  hostConnected() {
    window.addEventListener(ik, this.__litLocalizeEventHandler);
  }
  hostDisconnected() {
    window.removeEventListener(ik, this.__litLocalizeEventHandler);
  }
}, c(Nd, "We"), Nd);
dt(fR, "LocalizeController");
let iF = fR;
const nF = /* @__PURE__ */ dt((n) => n.addController(new iF(n)), "_updateWhenLocaleChanges"), sF = nF, bt = /* @__PURE__ */ dt(() => (n, t) => (n.addInitializer(sF), n), "localized");
var Hd;
const yR = (Hd = class {
  constructor() {
    this.settled = !1, this.promise = new Promise((t, e) => {
      this._resolve = t, this._reject = e;
    });
  }
  resolve(t) {
    this.settled = !0, this._resolve(t);
  }
  reject(t) {
    this.settled = !0, this._reject(t);
  }
}, c(Hd, "Ve"), Hd);
dt(yR, "Deferred");
let mR = yR;
const vs = [];
for (let n = 0; n < 256; n++)
  vs[n] = (n >> 4 & 15).toString(16) + (n & 15).toString(16);
function wR(n) {
  let t = 0, e = 8997, i = 0, s = 33826, r = 0, a = 40164, o = 0, l = 52210;
  for (let h = 0; h < n.length; h++)
    e ^= n.charCodeAt(h), t = e * 435, i = s * 435, r = a * 435, o = l * 435, r += e << 8, o += s << 8, i += t >>> 16, e = t & 65535, r += i >>> 16, s = i & 65535, l = o + (r >>> 16) & 65535, a = r & 65535;
  return vs[l >> 8] + vs[l & 255] + vs[a >> 8] + vs[a & 255] + vs[s >> 8] + vs[s & 255] + vs[e >> 8] + vs[e & 255];
}
c(wR, "Nt$1");
dt(wR, "fnv1a64");
const rF = "", aF = "h", oF = "s";
function gR(n, t) {
  return (t ? aF : oF) + wR(typeof n == "string" ? n : n.join(rF));
}
c(gR, "It$1");
dt(gR, "generateMsgId");
const r3 = /* @__PURE__ */ new WeakMap(), a3 = /* @__PURE__ */ new Map();
function vR(n, t, e) {
  if (n) {
    const i = e?.id ?? bR(t), s = n[i];
    if (s) {
      if (typeof s == "string")
        return s;
      if ("strTag" in s)
        return dR(
          s.strings,
          // Cast `template` because its type wasn't automatically narrowed (but
          // we know it must be the same type as `localized`).
          t.values,
          s.values
        );
      {
        let r = r3.get(s);
        return r === void 0 && (r = s.values, r3.set(s, r)), {
          ...s,
          values: r.map((a) => t.values[a])
        };
      }
    }
  }
  return uR(t);
}
c(vR, "jt$1");
dt(vR, "runtimeMsg");
function bR(n) {
  const t = typeof n == "string" ? n : n.strings;
  let e = a3.get(t);
  return e === void 0 && (e = gR(t, typeof n != "string" && !("strTag" in n)), a3.set(t, e)), e;
}
c(bR, "Dt$1");
dt(bR, "generateId");
function v1(n) {
  window.dispatchEvent(new CustomEvent(ik, { detail: n }));
}
c(v1, "ye$1");
dt(v1, "dispatchStatusEvent");
let Pv = "", UO, OR, Cv, nk, $R, Za = new mR();
Za.resolve();
let Vg = 0;
const lF = /* @__PURE__ */ dt((n) => (pR((t, e) => vR($R, t, e)), Pv = OR = n.sourceLocale, Cv = new Set(n.targetLocales), Cv.add(n.sourceLocale), nk = n.loadLocale, { getLocale: cF, setLocale: hF }), "configureLocalization"), cF = /* @__PURE__ */ dt(() => Pv, "getLocale"), hF = /* @__PURE__ */ dt((n) => {
  if (n === (UO ?? Pv))
    return Za.promise;
  if (!Cv || !nk)
    throw new Error("Internal error");
  if (!Cv.has(n))
    throw new Error("Invalid locale code");
  Vg++;
  const t = Vg;
  return UO = n, Za.settled && (Za = new mR()), v1({ status: "loading", loadingLocale: n }), (n === OR ? (
    // We could switch to the source locale synchronously, but we prefer to
    // queue it on a microtask so that switching locales is consistently
    // asynchronous.
    Promise.resolve({ templates: void 0 })
  ) : nk(n)).then((e) => {
    Vg === t && (Pv = n, UO = void 0, $R = e.templates, v1({ status: "ready", readyLocale: n }), Za.resolve());
  }, (e) => {
    Vg === t && (v1({
      status: "error",
      errorLocale: n,
      errorMessage: e.toString()
    }), Za.reject(e));
  }), Za.promise;
}, "setLocale");
var BO, Yd;
const dF = (BO = (Yd = class {
  get shadowRoot() {
    return this.__host.__shadowRoot;
  }
  constructor(t) {
    this.ariaAtomic = "", this.ariaAutoComplete = "", this.ariaBrailleLabel = "", this.ariaBrailleRoleDescription = "", this.ariaBusy = "", this.ariaChecked = "", this.ariaColCount = "", this.ariaColIndex = "", this.ariaColSpan = "", this.ariaCurrent = "", this.ariaDescription = "", this.ariaDisabled = "", this.ariaExpanded = "", this.ariaHasPopup = "", this.ariaHidden = "", this.ariaInvalid = "", this.ariaKeyShortcuts = "", this.ariaLabel = "", this.ariaLevel = "", this.ariaLive = "", this.ariaModal = "", this.ariaMultiLine = "", this.ariaMultiSelectable = "", this.ariaOrientation = "", this.ariaPlaceholder = "", this.ariaPosInSet = "", this.ariaPressed = "", this.ariaReadOnly = "", this.ariaRequired = "", this.ariaRoleDescription = "", this.ariaRowCount = "", this.ariaRowIndex = "", this.ariaRowSpan = "", this.ariaSelected = "", this.ariaSetSize = "", this.ariaSort = "", this.ariaValueMax = "", this.ariaValueMin = "", this.ariaValueNow = "", this.ariaValueText = "", this.role = "", this.form = null, this.labels = [], this.states = /* @__PURE__ */ new Set(), this.validationMessage = "", this.validity = {}, this.willValidate = !0, this.__host = t;
  }
  checkValidity() {
    return console.warn("`ElementInternals.checkValidity()` was called on the server.This method always returns true."), !0;
  }
  reportValidity() {
    return !0;
  }
  setFormValue() {
  }
  setValidity() {
  }
}, c(Yd, "O"), Yd), dt(BO, "ElementInternals"), BO);
var Dn = /* @__PURE__ */ c(function(n, t, e, i, s) {
  if (typeof t == "function" ? n !== t || !0 : !t.has(n)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t.set(n, e), e;
}, "E"), He = /* @__PURE__ */ c(function(n, t, e, i) {
  if (typeof t == "function" ? n !== t || !i : !t.has(n)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e === "m" ? i : e === "a" ? i.call(n) : i ? i.value : t.get(n);
}, "$"), Kl, Dg, Wg, Fy, XO, Uy, qg, ka, By, nr, jg, o3;
const l3 = /* @__PURE__ */ dt((n) => typeof n == "boolean" ? n : n?.capture ?? !1, "isCaptureEventListener"), Qv = 0, sk = 1, Mv = 2, rk = 3;
var NO, Gd;
const uF = (NO = (Gd = class {
  constructor() {
    this.__eventListeners = /* @__PURE__ */ new Map(), this.__captureEventListeners = /* @__PURE__ */ new Map();
  }
  addEventListener(t, e, i) {
    if (e == null)
      return;
    const s = l3(i) ? this.__captureEventListeners : this.__eventListeners;
    let r = s.get(t);
    if (r === void 0)
      r = /* @__PURE__ */ new Map(), s.set(t, r);
    else if (r.has(e))
      return;
    const a = typeof i == "object" && i ? i : {};
    a.signal?.addEventListener("abort", () => this.removeEventListener(t, e, i)), r.set(e, a ?? {});
  }
  removeEventListener(t, e, i) {
    if (e == null)
      return;
    const s = l3(i) ? this.__captureEventListeners : this.__eventListeners, r = s.get(t);
    r !== void 0 && (r.delete(e), r.size || s.delete(t));
  }
  dispatchEvent(t) {
    const e = [this];
    let i = this.__eventTargetParent;
    if (t.composed)
      for (; i; )
        e.push(i), i = i.__eventTargetParent;
    else
      for (; i && i !== this.__host; )
        e.push(i), i = i.__eventTargetParent;
    let s = !1, r = !1, a = Qv, o = null, l = null, h = null;
    const u = t.stopPropagation, p = t.stopImmediatePropagation;
    Object.defineProperties(t, {
      target: {
        get() {
          return o ?? l;
        },
        ...Ft
      },
      srcElement: {
        get() {
          return t.target;
        },
        ...Ft
      },
      currentTarget: {
        get() {
          return h;
        },
        ...Ft
      },
      eventPhase: {
        get() {
          return a;
        },
        ...Ft
      },
      composedPath: {
        value: /* @__PURE__ */ dt(() => e, "value"),
        ...Ft
      },
      stopPropagation: {
        value: /* @__PURE__ */ dt(() => {
          s = !0, u.call(t);
        }, "value"),
        ...Ft
      },
      stopImmediatePropagation: {
        value: /* @__PURE__ */ dt(() => {
          r = !0, p.call(t);
        }, "value"),
        ...Ft
      }
    });
    const y = /* @__PURE__ */ dt((x, C, R) => {
      typeof x == "function" ? x(t) : typeof x?.handleEvent == "function" && x.handleEvent(t), C.once && R.delete(x);
    }, "invokeEventListener"), m = /* @__PURE__ */ dt(() => (h = null, a = Qv, !t.defaultPrevented), "finishDispatch"), w = e.slice().reverse();
    o = !this.__host || !t.composed ? this : null;
    const b = /* @__PURE__ */ dt((x) => {
      for (l = this; l.__host && x.includes(l.__host); )
        l = l.__host;
    }, "retarget");
    for (const x of w) {
      !o && (!l || l === x.__host) && b(w.slice(w.indexOf(x))), h = x, a = x === t.target ? Mv : sk;
      const C = x.__captureEventListeners.get(t.type);
      if (C) {
        for (const [R, E] of C)
          if (y(R, E, C), r)
            return m();
      }
      if (s)
        return m();
    }
    const $ = t.bubbles ? e : [this];
    l = null;
    for (const x of $) {
      !o && (!l || x === l.__host) && b($.slice(0, $.indexOf(x) + 1)), h = x, a = x === t.target ? Mv : rk;
      const C = x.__eventListeners.get(t.type);
      if (C) {
        for (const [R, E] of C)
          if (y(R, E, C), r)
            return m();
      }
      if (s)
        return m();
    }
    return m();
  }
}, c(Gd, "U$1"), Gd), dt(NO, "EventTarget"), NO), pF = uF, Ft = { __proto__: null };
Ft.enumerable = !0;
Object.freeze(Ft);
var HO, Kd;
const qS = (nr = (HO = (Kd = class {
  constructor(t, e = {}) {
    if (Kl.set(this, !1), Dg.set(this, !1), Wg.set(this, !1), Fy.set(this, !1), XO.set(this, Date.now()), Uy.set(this, !1), qg.set(this, void 0), ka.set(this, void 0), By.set(this, void 0), this.NONE = Qv, this.CAPTURING_PHASE = sk, this.AT_TARGET = Mv, this.BUBBLING_PHASE = rk, arguments.length === 0)
      throw new Error("The type argument must be specified");
    if (typeof e != "object" || !e)
      throw new Error('The "options" argument must be an object');
    const { bubbles: i, cancelable: s, composed: r } = e;
    Dn(this, Kl, !!s), Dn(this, Dg, !!i), Dn(this, Wg, !!r), Dn(this, qg, `${t}`), Dn(this, ka, null), Dn(this, By, !1);
  }
  initEvent(t, e, i) {
    throw new Error("Method not implemented.");
  }
  stopImmediatePropagation() {
    this.stopPropagation();
  }
  preventDefault() {
    Dn(this, Fy, !0);
  }
  get target() {
    return He(this, ka, "f");
  }
  get currentTarget() {
    return He(this, ka, "f");
  }
  get srcElement() {
    return He(this, ka, "f");
  }
  get type() {
    return He(this, qg, "f");
  }
  get cancelable() {
    return He(this, Kl, "f");
  }
  get defaultPrevented() {
    return He(this, Kl, "f") && He(this, Fy, "f");
  }
  get timeStamp() {
    return He(this, XO, "f");
  }
  composedPath() {
    return He(this, By, "f") ? [He(this, ka, "f")] : [];
  }
  get returnValue() {
    return !He(this, Kl, "f") || !He(this, Fy, "f");
  }
  get bubbles() {
    return He(this, Dg, "f");
  }
  get composed() {
    return He(this, Wg, "f");
  }
  get eventPhase() {
    return He(this, By, "f") ? nr.AT_TARGET : nr.NONE;
  }
  get cancelBubble() {
    return He(this, Uy, "f");
  }
  set cancelBubble(t) {
    t && Dn(this, Uy, !0);
  }
  stopPropagation() {
    Dn(this, Uy, !0);
  }
  get isTrusted() {
    return !1;
  }
}, c(Kd, "H"), Kd), dt(HO, "Event"), HO), Kl = /* @__PURE__ */ new WeakMap(), Dg = /* @__PURE__ */ new WeakMap(), Wg = /* @__PURE__ */ new WeakMap(), Fy = /* @__PURE__ */ new WeakMap(), XO = /* @__PURE__ */ new WeakMap(), Uy = /* @__PURE__ */ new WeakMap(), qg = /* @__PURE__ */ new WeakMap(), ka = /* @__PURE__ */ new WeakMap(), By = /* @__PURE__ */ new WeakMap(), nr.NONE = Qv, nr.CAPTURING_PHASE = sk, nr.AT_TARGET = Mv, nr.BUBBLING_PHASE = rk, nr);
Object.defineProperties(qS.prototype, {
  initEvent: Ft,
  stopImmediatePropagation: Ft,
  preventDefault: Ft,
  target: Ft,
  currentTarget: Ft,
  srcElement: Ft,
  type: Ft,
  cancelable: Ft,
  defaultPrevented: Ft,
  timeStamp: Ft,
  composedPath: Ft,
  returnValue: Ft,
  bubbles: Ft,
  composed: Ft,
  eventPhase: Ft,
  cancelBubble: Ft,
  stopPropagation: Ft,
  isTrusted: Ft
});
var YO, Jd;
const xR = (o3 = (YO = (Jd = class extends qS {
  constructor(t, e = {}) {
    super(t, e), jg.set(this, void 0), Dn(this, jg, e?.detail ?? null);
  }
  initCustomEvent(t, e, i, s) {
    throw new Error("Method not implemented.");
  }
  get detail() {
    return He(this, jg, "f");
  }
}, c(Jd, "I"), Jd), dt(YO, "CustomEvent"), YO), jg = /* @__PURE__ */ new WeakMap(), o3);
Object.defineProperties(xR.prototype, {
  detail: Ft
});
const fF = qS, yF = xR;
globalThis.Event ??= fF;
globalThis.CustomEvent ??= yF;
const c3 = /* @__PURE__ */ new WeakMap(), Xy = /* @__PURE__ */ dt((n) => {
  let t = c3.get(n);
  return t === void 0 && c3.set(n, t = /* @__PURE__ */ new Map()), t;
}, "attributesForElement");
var GO, tu;
const mF = (GO = (tu = class extends pF {
  constructor() {
    super(...arguments), this.__shadowRootMode = null, this.__shadowRoot = null, this.__internals = null;
  }
  get attributes() {
    return Array.from(Xy(this)).map(([t, e]) => ({
      name: t,
      value: e
    }));
  }
  get shadowRoot() {
    return this.__shadowRootMode === "closed" ? null : this.__shadowRoot;
  }
  get localName() {
    return this.constructor.__localName;
  }
  get tagName() {
    return this.localName?.toUpperCase();
  }
  setAttribute(t, e) {
    Xy(this).set(t, String(e));
  }
  removeAttribute(t) {
    Xy(this).delete(t);
  }
  toggleAttribute(t, e) {
    if (this.hasAttribute(t)) {
      if (e === void 0 || !e)
        return this.removeAttribute(t), !1;
    } else
      return e === void 0 || e ? (this.setAttribute(t, ""), !0) : !1;
    return !0;
  }
  hasAttribute(t) {
    return Xy(this).has(t);
  }
  attachShadow(t) {
    const e = { host: this };
    return this.__shadowRootMode = t.mode, t && t.mode === "open" && (this.__shadowRoot = e), e;
  }
  attachInternals() {
    if (this.__internals !== null)
      throw new Error("Failed to execute 'attachInternals' on 'HTMLElement': ElementInternals for the specified element was already attached.");
    const t = new dF(this);
    return this.__internals = t, t;
  }
  getAttribute(t) {
    return Xy(this).get(t) ?? null;
  }
}, c(tu, "j"), tu), dt(GO, "Element"), GO);
var KO, eu;
const wF = (KO = (eu = class extends mF {
}, c(eu, "D"), eu), dt(KO, "HTMLElement"), KO), kR = wF;
globalThis.litServerRoot ??= Object.defineProperty(new kR(), "localName", {
  // Patch localName (and tagName) to return a unique name.
  get() {
    return "lit-server-root";
  }
});
var JO, iu;
const gF = (JO = (iu = class {
  constructor() {
    this.__definitions = /* @__PURE__ */ new Map();
  }
  define(t, e) {
    if (this.__definitions.has(t))
      throw new Error(`Failed to execute 'define' on 'CustomElementRegistry': the name "${t}" has already been used with this registry`);
    e.__localName = t, this.__definitions.set(t, {
      ctor: e,
      // Note it's important we read `observedAttributes` in case it is a getter
      // with side-effects, as is the case in Lit, where it triggers class
      // finalization.
      //
      // TODO(aomarks) To be spec compliant, we should also capture the
      // registration-time lifecycle methods like `connectedCallback`. For them
      // to be actually accessible to e.g. the Lit SSR element renderer, though,
      // we'd need to introduce a new API for accessing them (since `get` only
      // returns the constructor).
      observedAttributes: e.observedAttributes ?? []
    });
  }
  get(t) {
    return this.__definitions.get(t)?.ctor;
  }
}, c(iu, "B"), iu), dt(JO, "CustomElementRegistry"), JO), vF = gF, bF = new vF(), aw = globalThis, zb = aw.ShadowRoot && (aw.ShadyCSS === void 0 || aw.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, jS = Symbol(), h3 = /* @__PURE__ */ new WeakMap();
var t0, nu;
let SR = (t0 = (nu = class {
  constructor(t, e, i) {
    if (this._$cssResult$ = !0, i !== jS) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (zb && t === void 0) {
      const i = e !== void 0 && e.length === 1;
      i && (t = h3.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), i && h3.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
}, c(nu, "W$1"), nu), dt(t0, "n"), t0);
const PR = /* @__PURE__ */ dt((n) => new SR(typeof n == "string" ? n : n + "", void 0, jS), "r$2"), Qt = /* @__PURE__ */ dt((n, ...t) => {
  const e = n.length === 1 ? n[0] : t.reduce((i, s, r) => i + ((a) => {
    if (a._$cssResult$ === !0) return a.cssText;
    if (typeof a == "number") return a;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + a + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s) + n[r + 1], n[0]);
  return new SR(e, n, jS);
}, "i$2"), CR = /* @__PURE__ */ dt((n, t) => {
  if (zb) n.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else for (const e of t) {
    const i = document.createElement("style"), s = aw.litNonce;
    s !== void 0 && i.setAttribute("nonce", s), i.textContent = e.cssText, n.appendChild(i);
  }
}, "S$1"), d3 = zb || aw.CSSStyleSheet === void 0 ? (n) => n : (n) => n instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const i of t.cssRules) e += i.cssText;
  return PR(e);
})(n) : n, { is: OF, defineProperty: $F, getOwnPropertyDescriptor: xF, getOwnPropertyNames: kF, getOwnPropertySymbols: SF, getPrototypeOf: PF } = Object, ag = globalThis;
ag.customElements ??= bF;
const u3 = ag.trustedTypes, CF = u3 ? u3.emptyScript : "", QF = ag.reactiveElementPolyfillSupport, ow = /* @__PURE__ */ dt((n, t) => n, "f$1"), Tv = { toAttribute(n, t) {
  switch (t) {
    case Boolean:
      n = n ? CF : null;
      break;
    case Object:
    case Array:
      n = n == null ? n : JSON.stringify(n);
  }
  return n;
}, fromAttribute(n, t) {
  let e = n;
  switch (t) {
    case Boolean:
      e = n !== null;
      break;
    case Number:
      e = n === null ? null : Number(n);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(n);
      } catch {
        e = null;
      }
  }
  return e;
} }, FS = /* @__PURE__ */ dt((n, t) => !OF(n, t), "m$1"), p3 = { attribute: !0, type: String, converter: Tv, reflect: !1, useDefault: !1, hasChanged: FS };
Symbol.metadata ??= Symbol("metadata"), ag.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var e0, su;
let uc = (e0 = (su = class extends (globalThis.HTMLElement ?? kR) {
  static addInitializer(t) {
    this._$Ei(), (this.l ??= []).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = p3) {
    if (e.state && (e.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(t) && ((e = Object.create(e)).wrapped = !0), this.elementProperties.set(t, e), !e.noAccessor) {
      const i = Symbol(), s = this.getPropertyDescriptor(t, i, e);
      s !== void 0 && $F(this.prototype, t, s);
    }
  }
  static getPropertyDescriptor(t, e, i) {
    const { get: s, set: r } = xF(this.prototype, t) ?? { get() {
      return this[e];
    }, set(a) {
      this[e] = a;
    } };
    return { get: s, set(a) {
      const o = s?.call(this);
      r?.call(this, a), this.requestUpdate(t, o, i);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? p3;
  }
  static _$Ei() {
    if (this.hasOwnProperty(ow("elementProperties"))) return;
    const t = PF(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(ow("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(ow("properties"))) {
      const e = this.properties, i = [...kF(e), ...SF(e)];
      for (const s of i) this.createProperty(s, e[s]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0) for (const [i, s] of e) this.elementProperties.set(i, s);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, i] of this.elementProperties) {
      const s = this._$Eu(e, i);
      s !== void 0 && this._$Eh.set(s, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const i = new Set(t.flat(1 / 0).reverse());
      for (const s of i) e.unshift(d3(s));
    } else t !== void 0 && e.push(d3(t));
    return e;
  }
  static _$Eu(t, e) {
    const i = e.attribute;
    return i === !1 ? void 0 : typeof i == "string" ? i : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t) => this.enableUpdating = t), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t) => t(this));
  }
  addController(t) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t), this.renderRoot !== void 0 && this.isConnected && t.hostConnected?.();
  }
  removeController(t) {
    this._$EO?.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const i of e.keys()) this.hasOwnProperty(i) && (t.set(i, this[i]), delete this[i]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return CR(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(!0), this._$EO?.forEach((t) => t.hostConnected?.());
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t) => t.hostDisconnected?.());
  }
  attributeChangedCallback(t, e, i) {
    this._$AK(t, i);
  }
  _$ET(t, e) {
    const i = this.constructor.elementProperties.get(t), s = this.constructor._$Eu(t, i);
    if (s !== void 0 && i.reflect === !0) {
      const r = (i.converter?.toAttribute !== void 0 ? i.converter : Tv).toAttribute(e, i.type);
      this._$Em = t, r == null ? this.removeAttribute(s) : this.setAttribute(s, r), this._$Em = null;
    }
  }
  _$AK(t, e) {
    const i = this.constructor, s = i._$Eh.get(t);
    if (s !== void 0 && this._$Em !== s) {
      const r = i.getPropertyOptions(s), a = typeof r.converter == "function" ? { fromAttribute: r.converter } : r.converter?.fromAttribute !== void 0 ? r.converter : Tv;
      this._$Em = s, this[s] = a.fromAttribute(e, r.type) ?? this._$Ej?.get(s) ?? null, this._$Em = null;
    }
  }
  requestUpdate(t, e, i) {
    if (t !== void 0) {
      const s = this.constructor, r = this[t];
      if (i ??= s.getPropertyOptions(t), !((i.hasChanged ?? FS)(r, e) || i.useDefault && i.reflect && r === this._$Ej?.get(t) && !this.hasAttribute(s._$Eu(t, i)))) return;
      this.C(t, e, i);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$EP());
  }
  C(t, e, { useDefault: i, reflect: s, wrapped: r }, a) {
    i && !(this._$Ej ??= /* @__PURE__ */ new Map()).has(t) && (this._$Ej.set(t, a ?? e ?? this[t]), r !== !0 || a !== void 0) || (this._$AL.has(t) || (this.hasUpdated || i || (e = void 0), this._$AL.set(t, e)), s === !0 && this._$Em !== t && (this._$Eq ??= /* @__PURE__ */ new Set()).add(t));
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [s, r] of this._$Ep) this[s] = r;
        this._$Ep = void 0;
      }
      const i = this.constructor.elementProperties;
      if (i.size > 0) for (const [s, r] of i) {
        const { wrapped: a } = r, o = this[s];
        a !== !0 || this._$AL.has(s) || o === void 0 || this.C(s, void 0, r, o);
      }
    }
    let t = !1;
    const e = this._$AL;
    try {
      t = this.shouldUpdate(e), t ? (this.willUpdate(e), this._$EO?.forEach((i) => i.hostUpdate?.()), this.update(e)) : this._$EM();
    } catch (i) {
      throw t = !1, this._$EM(), i;
    }
    t && this._$AE(e);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    this._$EO?.forEach((e) => e.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$Eq &&= this._$Eq.forEach((e) => this._$ET(e, this[e])), this._$EM();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
}, c(su, "V$1"), su), dt(e0, "g"), e0);
uc.elementStyles = [], uc.shadowRootOptions = { mode: "open" }, uc[ow("elementProperties")] = /* @__PURE__ */ new Map(), uc[ow("finalized")] = /* @__PURE__ */ new Map(), QF?.({ ReactiveElement: uc }), (ag.reactiveElementVersions ??= []).push("2.1.0");
const Lb = globalThis, Av = Lb.trustedTypes, f3 = Av ? Av.createPolicy("lit-html", { createHTML: /* @__PURE__ */ dt((n) => n, "createHTML") }) : void 0, QR = "$lit$", vr = `lit$${Math.random().toFixed(9).slice(2)}$`, MR = "?" + vr, MF = `<${MR}>`, qo = Lb.document === void 0 ? { createTreeWalker: /* @__PURE__ */ dt(() => ({}), "createTreeWalker") } : document, Cw = /* @__PURE__ */ dt(() => qo.createComment(""), "l"), Qw = /* @__PURE__ */ dt((n) => n === null || typeof n != "object" && typeof n != "function", "c"), US = Array.isArray, TF = /* @__PURE__ */ dt((n) => US(n) || typeof n?.[Symbol.iterator] == "function", "u"), i0 = `[ 	
\f\r]`, Ny = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, y3 = /-->/g, m3 = />/g, Sa = RegExp(`>|${i0}(?:([^\\s"'>=/]+)(${i0}*=${i0}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), w3 = /'/g, g3 = /"/g, TR = /^(?:script|style|textarea|title)$/i, AR = /* @__PURE__ */ dt((n) => (t, ...e) => ({ _$litType$: n, strings: t, values: e }), "y"), v = AR(1), v3 = AR(2), Sn = Symbol.for("lit-noChange"), Q = Symbol.for("lit-nothing"), b3 = /* @__PURE__ */ new WeakMap(), Ua = qo.createTreeWalker(qo, 129);
function BS(n, t) {
  if (!US(n) || !n.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return f3 !== void 0 ? f3.createHTML(t) : t;
}
c(BS, "Pt$1");
dt(BS, "P");
const AF = /* @__PURE__ */ dt((n, t) => {
  const e = n.length - 1, i = [];
  let s, r = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", a = Ny;
  for (let o = 0; o < e; o++) {
    const l = n[o];
    let h, u, p = -1, y = 0;
    for (; y < l.length && (a.lastIndex = y, u = a.exec(l), u !== null); ) y = a.lastIndex, a === Ny ? u[1] === "!--" ? a = y3 : u[1] !== void 0 ? a = m3 : u[2] !== void 0 ? (TR.test(u[2]) && (s = RegExp("</" + u[2], "g")), a = Sa) : u[3] !== void 0 && (a = Sa) : a === Sa ? u[0] === ">" ? (a = s ?? Ny, p = -1) : u[1] === void 0 ? p = -2 : (p = a.lastIndex - u[2].length, h = u[1], a = u[3] === void 0 ? Sa : u[3] === '"' ? g3 : w3) : a === g3 || a === w3 ? a = Sa : a === y3 || a === m3 ? a = Ny : (a = Sa, s = void 0);
    const m = a === Sa && n[o + 1].startsWith("/>") ? " " : "";
    r += a === Ny ? l + MF : p >= 0 ? (i.push(h), l.slice(0, p) + QR + l.slice(p) + vr + m) : l + vr + (p === -2 ? o : m);
  }
  return [BS(n, r + (n[e] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), i];
}, "V");
var To;
const RR = (To = class {
  constructor({ strings: t, _$litType$: e }, i) {
    let s;
    this.parts = [];
    let r = 0, a = 0;
    const o = t.length - 1, l = this.parts, [h, u] = AF(t, e);
    if (this.el = To.createElement(h, i), Ua.currentNode = this.el.content, e === 2 || e === 3) {
      const p = this.el.content.firstChild;
      p.replaceWith(...p.childNodes);
    }
    for (; (s = Ua.nextNode()) !== null && l.length < o; ) {
      if (s.nodeType === 1) {
        if (s.hasAttributes()) for (const p of s.getAttributeNames()) if (p.endsWith(QR)) {
          const y = u[a++], m = s.getAttribute(p).split(vr), w = /([.?@])?(.*)/.exec(y);
          l.push({ type: 1, index: r, name: w[2], strings: m, ctor: w[1] === "." ? EF : w[1] === "?" ? _F : w[1] === "@" ? zF : Zb }), s.removeAttribute(p);
        } else p.startsWith(vr) && (l.push({ type: 6, index: r }), s.removeAttribute(p));
        if (TR.test(s.tagName)) {
          const p = s.textContent.split(vr), y = p.length - 1;
          if (y > 0) {
            s.textContent = Av ? Av.emptyScript : "";
            for (let m = 0; m < y; m++) s.append(p[m], Cw()), Ua.nextNode(), l.push({ type: 2, index: ++r });
            s.append(p[y], Cw());
          }
        }
      } else if (s.nodeType === 8) if (s.data === MR) l.push({ type: 2, index: r });
      else {
        let p = -1;
        for (; (p = s.data.indexOf(vr, p + 1)) !== -1; ) l.push({ type: 7, index: r }), p += vr.length - 1;
      }
      r++;
    }
  }
  static createElement(t, e) {
    const i = qo.createElement("template");
    return i.innerHTML = t, i;
  }
}, c(To, "be"), To);
dt(RR, "N");
let ak = RR;
function jo(n, t, e = n, i) {
  if (t === Sn) return t;
  let s = i !== void 0 ? e._$Co?.[i] : e._$Cl;
  const r = Qw(t) ? void 0 : t._$litDirective$;
  return s?.constructor !== r && (s?._$AO?.(!1), r === void 0 ? s = void 0 : (s = new r(n), s._$AT(n, e, i)), i !== void 0 ? (e._$Co ??= [])[i] = s : e._$Cl = s), s !== void 0 && (t = jo(n, s._$AS(n, t.values), s, i)), t;
}
c(jo, "F$1");
dt(jo, "S");
var ru;
const ER = (ru = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: i } = this._$AD, s = (t?.creationScope ?? qo).importNode(e, !0);
    Ua.currentNode = s;
    let r = Ua.nextNode(), a = 0, o = 0, l = i[0];
    for (; l !== void 0; ) {
      if (a === l.index) {
        let h;
        l.type === 2 ? h = new Ib(r, r.nextSibling, this, t) : l.type === 1 ? h = new l.ctor(r, l.name, l.strings, this, t) : l.type === 6 && (h = new LF(r, this, t)), this._$AV.push(h), l = i[++o];
      }
      a !== l?.index && (r = Ua.nextNode(), a++);
    }
    return Ua.currentNode = qo, s;
  }
  p(t) {
    let e = 0;
    for (const i of this._$AV) i !== void 0 && (i.strings !== void 0 ? (i._$AI(t, i, e), e += i.strings.length - 2) : i._$AI(t[e])), e++;
  }
}, c(ru, "ze"), ru);
dt(ER, "M");
let RF = ER;
var Ao;
const _R = (Ao = class {
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(t, e, i, s) {
    this.type = 2, this._$AH = Q, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = i, this.options = s, this._$Cv = s?.isConnected ?? !0;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && t?.nodeType === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = jo(this, t, e), Qw(t) ? t === Q || t == null || t === "" ? (this._$AH !== Q && this._$AR(), this._$AH = Q) : t !== this._$AH && t !== Sn && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : TF(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== Q && Qw(this._$AH) ? this._$AA.nextSibling.data = t : this.T(qo.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    const { values: e, _$litType$: i } = t, s = typeof i == "number" ? this._$AC(t) : (i.el === void 0 && (i.el = ak.createElement(BS(i.h, i.h[0]), this.options)), i);
    if (this._$AH?._$AD === s) this._$AH.p(e);
    else {
      const r = new RF(s, this), a = r.u(this.options);
      r.p(e), this.T(a), this._$AH = r;
    }
  }
  _$AC(t) {
    let e = b3.get(t.strings);
    return e === void 0 && b3.set(t.strings, e = new ak(t)), e;
  }
  k(t) {
    US(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let i, s = 0;
    for (const r of t) s === e.length ? e.push(i = new Ao(this.O(Cw()), this.O(Cw()), this, this.options)) : i = e[s], i._$AI(r), s++;
    s < e.length && (this._$AR(i && i._$AB.nextSibling, s), e.length = s);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    for (this._$AP?.(!1, !0, e); t && t !== this._$AB; ) {
      const i = t.nextSibling;
      t.remove(), t = i;
    }
  }
  setConnected(t) {
    this._$AM === void 0 && (this._$Cv = t, this._$AP?.(t));
  }
}, c(Ao, "$e"), Ao);
dt(_R, "k");
let Ib = _R;
var au;
const zR = (au = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, i, s, r) {
    this.type = 1, this._$AH = Q, this._$AN = void 0, this.element = t, this.name = e, this._$AM = s, this.options = r, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = Q;
  }
  _$AI(t, e = this, i, s) {
    const r = this.strings;
    let a = !1;
    if (r === void 0) t = jo(this, t, e, 0), a = !Qw(t) || t !== this._$AH && t !== Sn, a && (this._$AH = t);
    else {
      const o = t;
      let l, h;
      for (t = r[0], l = 0; l < r.length - 1; l++) h = jo(this, o[i + l], e, l), h === Sn && (h = this._$AH[l]), a ||= !Qw(h) || h !== this._$AH[l], h === Q ? t = Q : t !== Q && (t += (h ?? "") + r[l + 1]), this._$AH[l] = h;
    }
    a && !s && this.j(t);
  }
  j(t) {
    t === Q ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}, c(au, "Fe"), au);
dt(zR, "R");
let Zb = zR;
var ou;
const LR = (ou = class extends Zb {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === Q ? void 0 : t;
  }
}, c(ou, "Ge"), ou);
dt(LR, "H");
let EF = LR;
var lu;
const IR = (lu = class extends Zb {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== Q);
  }
}, c(lu, "qe"), lu);
dt(IR, "I");
let _F = IR;
var cu;
const ZR = (cu = class extends Zb {
  constructor(t, e, i, s, r) {
    super(t, e, i, s, r), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = jo(this, t, e, 0) ?? Q) === Sn) return;
    const i = this._$AH, s = t === Q && i !== Q || t.capture !== i.capture || t.once !== i.once || t.passive !== i.passive, r = t !== Q && (i === Q || s);
    s && this.element.removeEventListener(this.name, this, i), r && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    typeof this._$AH == "function" ? this._$AH.call(this.options?.host ?? this.element, t) : this._$AH.handleEvent(t);
  }
}, c(cu, "Ke"), cu);
dt(ZR, "L");
let zF = ZR;
var hu;
const VR = (hu = class {
  constructor(t, e, i) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = i;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    jo(this, t);
  }
}, c(hu, "Ze"), hu);
dt(VR, "z");
let LF = VR;
const IF = { I: Ib }, ZF = Lb.litHtmlPolyfillSupport;
ZF?.(ak, Ib), (Lb.litHtmlVersions ??= []).push("3.3.0");
const VF = /* @__PURE__ */ dt((n, t, e) => {
  const i = e?.renderBefore ?? t;
  let s = i._$litPart$;
  if (s === void 0) {
    const r = e?.renderBefore ?? null;
    i._$litPart$ = s = new Ib(t.insertBefore(Cw(), r), r, void 0, e ?? {});
  }
  return s._$AI(n), s;
}, "j"), XS = globalThis;
var du;
const DR = (du = class extends uc {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    const t = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t.firstChild, t;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = VF(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(!0);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(!1);
  }
  render() {
    return Sn;
  }
}, c(du, "Je"), du);
dt(DR, "i");
let pt = DR;
pt._$litElement$ = !0, pt.finalized = !0, XS.litElementHydrateSupport?.({ LitElement: pt });
const DF = XS.litElementPolyfillSupport;
DF?.({ LitElement: pt });
(XS.litElementVersions ??= []).push("4.2.0");
v`<strong>${0}</strong> redigerade <em>${1}</em>`, v`<strong>${0}</strong> nämnde dig i ett inlägg`, v`<strong>${0}</strong> kommenterade på <strong>${1}</strong>`, v`<strong>${0}</strong> reagerade med ${1} på <em>${2}</em>`, v`<strong>${0}</strong> svarade på ett inlägg`, v`<strong>${0}</strong> redigerade ett inlägg`, v`<strong>${0}</strong> nämnde dig i ett meddelande`, v`<strong>${0}</strong> nämnde dig i en kommentar`, v`<strong>${0}</strong> och <strong>${1}</strong> röstade i din omröstning`, v`<strong>${0}</strong> reagerade med ${1} på ditt inlägg`, v`<strong>${0}</strong> reagerade med ${1} på din kommentar`, v`Nytt meddelande från <strong>${0}</strong>`, v`<strong>${0}</strong> svarade på ditt inlägg`, v`<strong>${0}</strong> röstade i din omröstning`, v`<strong>${0}</strong> publicerade ett inlägg i <strong>${1}</strong>`, v`<strong>${0}</strong> gillade ditt meddelande`, v`<strong>${0}</strong>, <strong>${1}</strong> och <strong>${2}</strong> röstade i din omröstning`, v`<strong>${0}</strong> lade till <em>${1}</em> till <strong>${2}</strong>`, v`<strong>${0}</strong> skickade ett meddelande i <strong>${1}</strong>`, v`<strong>${0}</strong> reagerade med ${1} på ditt meddelande`, v`<strong>${0}</strong> gillade <em>${1}</em>`, v`<strong>${0}</strong> gillade ditt inlägg`, v`<strong>${0}</strong> gillade din kommentar`, v`<strong>${0}</strong> och ${1} andra röstade i din omröstning`, v`<strong>${0}</strong> kommenterade på <em>${1}</em>`, nt`${0} svarade på ditt inlägg`, nt`${0} röstade i din omröstning`, nt`Öppna i ${0}?`, nt`${0} skriver${1}`, nt`${0} och ${1} röstade i din omröstning`, nt`${0} kommenterade på ${1}`, nt`${0} gillade ${1}`, nt`${0} skickade ett meddelande i ${1}`, nt`${0} redigerade ett inlägg`, nt`Röster på ${0}`, nt`${0} kommentarer`, nt`Sedd av ${0} vid ${1}`, nt`${0} och ${1} andra röstade i din omröstning`, nt`Nytt meddelande från ${0}`, nt`${0} reagerade med ${1} på ditt inlägg`, nt`${0} nämnde dig i ett inlägg`, nt`${0} nämnde dig i en kommentar`, nt`${0} publicerade ett inlägg i ${1}`, nt`${0} gillade ditt inlägg`, nt`${0} nämnde dig i ett meddelande`, nt`${0} reagerade med ${1} på din kommentar`, nt` Öppna i ${0}
        `, nt`${0} svarade på ett inlägg`, nt`${0} lade till ${1} till ${2}`, nt`${0} redigerade ${1}`, nt`${0} gillade ditt meddelande`, nt`${0}, ${1} och ${2} röstade i din omröstning`, nt`${0} reagerade med ${1} på ${2}`, nt`${0} reagerade med ${1} på ditt meddelande`, nt`${0} gillade din kommentar`, nt`${0} skriver${1}`;
var WF = Object.defineProperty, WR = /* @__PURE__ */ c((n) => {
  throw TypeError(n);
}, "ny"), d = /* @__PURE__ */ c((n, t) => WF(n, "name", { value: t, configurable: !0 }), "a"), NS = /* @__PURE__ */ c((n, t, e) => t.has(n) || WR("Cannot " + e), "Eh"), k = /* @__PURE__ */ c((n, t, e) => (NS(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "y"), q = /* @__PURE__ */ c((n, t, e) => t.has(n) ? WR("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "T"), L = /* @__PURE__ */ c((n, t, e, i) => (NS(n, t, "write to private field"), t.set(n, e), e), "z"), yt = /* @__PURE__ */ c((n, t, e) => (NS(n, t, "access private method"), e), "J"), ok = /* @__PURE__ */ c((n, t, e, i) => ({
  set _(s) {
    L(n, t, s);
  },
  get _() {
    return k(n, t, i);
  }
}), "El");
function Mw(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
c(Mw, "ql");
d(Mw, "isObject");
function Fo(n) {
  if (Mw(n) === !1) return !1;
  const t = n.constructor;
  if (t === void 0) return !0;
  const e = t.prototype;
  return !(Mw(e) === !1 || Object.prototype.hasOwnProperty.call(e, "isPrototypeOf") === !1);
}
c(Fo, "To");
d(Fo, "isPlainObject$1");
function Rv(n) {
  return typeof n.toJSON == "function";
}
c(Rv, "Qh");
d(Rv, "hasToJSON");
function qR(n) {
  return typeof n == "boolean" || typeof n == "number" || typeof n == "string" || n === null || Fo(n) || Array.isArray(n);
}
c(qR, "cv");
d(qR, "isJSONSerializable");
function lw(n, t, e = !1) {
  n = n || {}, t = t || {};
  const i = {};
  for (const s in n)
    Object.prototype.hasOwnProperty.call(n, s) && (i[s] = n[s]);
  for (const s in t)
    Object.prototype.hasOwnProperty.call(t, s) && (e && i[s] && Fo(i[s]) && Fo(t[s]) ? i[s] = lw(i[s], t[s], e) : i[s] = t[s]);
  return i;
}
c(lw, "Tl");
d(lw, "assign");
function jR(n) {
  return n ? Array.isArray(n) ? n : [n] : [];
}
c(jR, "lv");
d(jR, "asArray");
async function FR(n, t) {
  for (const e of n)
    if (await t(e))
      return e;
}
c(FR, "dv");
d(FR, "findAsyncSequential");
function Fc(n, t, e = !1, i = !1) {
  if (!i && (!Fo(n) || !Fo(t)) || i && (!Mw(n) || !Mw(t)))
    return !1;
  const s = Object.getOwnPropertyNames(n), r = Object.getOwnPropertyNames(t);
  if (!e && s.length !== r.length)
    return !1;
  for (let a = 0; a < s.length; a++) {
    const o = s[a], l = n[o], h = t[o];
    if (l !== h && !Fc(l, h, e))
      return !1;
  }
  return !0;
}
c(Fc, "mc");
d(Fc, "eqObjects");
function HS(n) {
  return Object.entries(n);
}
c(HS, "_w");
d(HS, "objectAsIterable");
function Vb(n) {
  return n.charAt(0).toUpperCase() + n.substring(1).toLowerCase();
}
c(Vb, "Qu");
d(Vb, "toUpperCaseFirst");
const qF = '\\s,.:;"', jF = new RegExp(`^|[${qF}]|$`, "g"), FF = ".!?", UF = new RegExp(`^|(?<=[${FF}])|$`);
function YS(n) {
  return n.length > 0 ? n.replace(/([a-z\d])([A-Z]+)/g, "$1-$2").replace(/_|\s+/g, "-").toLowerCase() : n;
}
c(YS, "Mw");
d(YS, "toKebabCase");
function UR(n, t = 2) {
  if (!n)
    return null;
  let e = "";
  const i = n.split(jF).filter((s) => s);
  return i.length == 1 ? e = i[0] : i.forEach((s) => {
    e += s.charAt(0);
  }), e.substring(0, t).toUpperCase();
}
c(UR, "wv");
d(UR, "getInitials");
function GS(n) {
  let t;
  const e = n.split(UF).filter((i) => i);
  return e.length ? t = e[0] : t = n, t;
}
c(GS, "zw");
d(GS, "getTitleFromText");
function KS(n, t = 256) {
  return n.length > t && (n = n.substring(0, t - 1) + "…"), n;
}
c(KS, "Pw");
d(KS, "truncateText");
const BF = {
  //mode: 'cors', // no-cors, *cors, same-origin
  // cache: 'default' means the server is in control of the caching which is preferred instead of using 'reload'
  //cache: 'default', // *default, no-cache, reload, force-cache, only-if-cached
  credentials: "omit",
  // include, *same-origin, omit
  headers: {
    // https://stackoverflow.com/questions/8163703/cross-domain-ajax-doesnt-send-x-requested-with-header
    "X-Requested-With": "XMLHttpRequest"
  },
  redirect: "manual"
  // manual, *follow, error
  //referrerPolicy: 'no-referrer-when-downgrade', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
};
function BR() {
  const n = /* @__PURE__ */ new WeakSet(), t = /* @__PURE__ */ d(function(e, i) {
    if (Rv(i) && (i = i.toJSON()), !(i !== null && typeof i == "object"))
      return i;
    if (n.has(i))
      return "[Circular]";
    let s;
    if (n.add(i), Fo(i)) {
      const r = {};
      Object.keys(i).forEach((a) => {
        r[a] = t(a, i[a]);
      }), s = r;
    } else Array.isArray(i) && (s = i.map((r, a) => t(a, r)));
    return n.delete(i), s;
  }, "replacer");
  return t;
}
c(BR, "mv");
d(BR, "getCircularReferenceReplacer");
function ey() {
  return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
}
c(ey, "Cc");
d(ey, "S4");
function XR(n) {
  if (n && n.ok && n.body) {
    const t = n.body.getReader();
    return new ReadableStream({
      start(e) {
        const i = /* @__PURE__ */ d(() => t.read().then(({ done: s, value: r }) => {
          if (s) {
            e.close();
            return;
          }
          return e.enqueue(r), i();
        }), "pump");
        return i();
      }
    });
  } else
    throw new Error("Could not parse text stream");
}
c(XR, "vv");
d(XR, "getTextStreamFromResponse");
function JS(n) {
  let t;
  try {
    if (t = window[n], t) {
      const e = "__storage_test__";
      t.setItem(e, e), t.removeItem(e);
    }
  } catch (e) {
    e instanceof DOMException && e.name === "QuotaExceededError" && // acknowledge QuotaExceededError only if there's something already stored
    t && t.length !== 0 && console.error("Storage not available:", n);
  }
  return t;
}
c(JS, "Sw");
d(JS, "getStorage");
var uu;
const NR = (uu = class extends Error {
  constructor() {
    super("Instance destroyed"), this.name = "DestroyError";
  }
}, c(uu, "Pp"), uu);
d(NR, "DestroyError");
let Ce = NR;
var n0, pu, Py = (n0 = (pu = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, c(pu, "Gr"), pu), d(n0, "Subscribable"), n0), XF = {
  // We need the wrapper function syntax below instead of direct references to
  // global setTimeout etc.
  //
  // BAD: `setTimeout: setTimeout`
  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
  //
  // If we use direct references here, then anything that wants to spy on or
  // replace the global setTimeout (like tests) won't work since we'll already
  // have a hard reference to the original implementation at the time when this
  // file was imported.
  setTimeout: /* @__PURE__ */ d((n, t) => setTimeout(n, t), "setTimeout"),
  clearTimeout: /* @__PURE__ */ d((n) => clearTimeout(n), "clearTimeout"),
  setInterval: /* @__PURE__ */ d((n, t) => setInterval(n, t), "setInterval"),
  clearInterval: /* @__PURE__ */ d((n) => clearInterval(n), "clearInterval")
}, Pa, O3, s0, fu, NF = (s0 = (fu = class {
  constructor() {
    q(this, Pa, XF), q(this, O3, !1);
  }
  setTimeoutProvider(t) {
    L(this, Pa, t);
  }
  setTimeout(t, e) {
    return k(this, Pa).setTimeout(t, e);
  }
  clearTimeout(t) {
    k(this, Pa).clearTimeout(t);
  }
  setInterval(t, e) {
    return k(this, Pa).setInterval(t, e);
  }
  clearInterval(t) {
    k(this, Pa).clearInterval(t);
  }
}, c(fu, "Zr"), fu), Pa = /* @__PURE__ */ new WeakMap(), O3 = /* @__PURE__ */ new WeakMap(), d(s0, "TimeoutManager"), s0), $r = new NF();
function HR(n) {
  setTimeout(n, 0);
}
c(HR, "xv");
d(HR, "systemSetTimeoutZero");
var iy = typeof window > "u" || "Deno" in globalThis;
function Ke() {
}
c(Ke, "be");
d(Ke, "noop$1");
function YR(n, t) {
  return typeof n == "function" ? n(t) : n;
}
c(YR, "$v");
d(YR, "functionalUpdate");
function Ev(n) {
  return typeof n == "number" && n >= 0 && n !== 1 / 0;
}
c(Ev, "Kh");
d(Ev, "isValidTimeout");
function tP(n, t) {
  return Math.max(n + (t || 0) - Date.now(), 0);
}
c(tP, "Aw");
d(tP, "timeUntilStale");
function Is(n, t) {
  return typeof n == "function" ? n(t) : n;
}
c(Is, "$s");
d(Is, "resolveStaleTime");
function qi(n, t) {
  return typeof n == "function" ? n(t) : n;
}
c(qi, "Ke");
d(qi, "resolveEnabled");
function lk(n, t) {
  const {
    type: e = "all",
    exact: i,
    fetchStatus: s,
    predicate: r,
    queryKey: a,
    stale: o
  } = n;
  if (a) {
    if (i) {
      if (t.queryHash !== Db(a, t.options))
        return !1;
    } else if (!ny(t.queryKey, a))
      return !1;
  }
  if (e !== "all") {
    const l = t.isActive();
    if (e === "active" && !l || e === "inactive" && l)
      return !1;
  }
  return !(typeof o == "boolean" && t.isStale() !== o || s && s !== t.state.fetchStatus || r && !r(t));
}
c(lk, "cy");
d(lk, "matchQuery");
function ck(n, t) {
  const { exact: e, status: i, predicate: s, mutationKey: r } = n;
  if (r) {
    if (!t.options.mutationKey)
      return !1;
    if (e) {
      if (ta(t.options.mutationKey) !== ta(r))
        return !1;
    } else if (!ny(t.options.mutationKey, r))
      return !1;
  }
  return !(i && t.state.status !== i || s && !s(t));
}
c(ck, "ly");
d(ck, "matchMutation");
function Db(n, t) {
  return (t?.queryKeyHashFn || ta)(n);
}
c(Db, "Ku");
d(Db, "hashQueryKeyByOptions");
function ta(n) {
  return JSON.stringify(
    n,
    (t, e) => _v(e) ? Object.keys(e).sort().reduce((i, s) => (i[s] = e[s], i), {}) : e
  );
}
c(ta, "or");
d(ta, "hashKey");
function ny(n, t) {
  return n === t ? !0 : typeof n != typeof t ? !1 : n && t && typeof n == "object" && typeof t == "object" ? Object.keys(t).every((e) => ny(n[e], t[e])) : !1;
}
c(ny, "kc");
d(ny, "partialMatchKey");
var HF = Object.prototype.hasOwnProperty;
function Cy(n, t) {
  if (n === t)
    return n;
  const e = hk(n) && hk(t);
  if (!e && !(_v(n) && _v(t))) return t;
  const i = (e ? n : Object.keys(n)).length, s = e ? t : Object.keys(t), r = s.length, a = e ? new Array(r) : {};
  let o = 0;
  for (let l = 0; l < r; l++) {
    const h = e ? l : s[l], u = n[h], p = t[h];
    if (u === p) {
      a[h] = u, (e ? l < i : HF.call(n, h)) && o++;
      continue;
    }
    if (u === null || p === null || typeof u != "object" || typeof p != "object") {
      a[h] = p;
      continue;
    }
    const y = Cy(u, p);
    a[h] = y, y === u && o++;
  }
  return i === r && o === i ? n : a;
}
c(Cy, "wl");
d(Cy, "replaceEqualDeep");
function Tw(n, t) {
  if (!t || Object.keys(n).length !== Object.keys(t).length)
    return !1;
  for (const e in n)
    if (n[e] !== t[e])
      return !1;
  return !0;
}
c(Tw, "Nl");
d(Tw, "shallowEqualObjects");
function hk(n) {
  return Array.isArray(n) && n.length === Object.keys(n).length;
}
c(hk, "dy");
d(hk, "isPlainArray");
function _v(n) {
  if (!dk(n))
    return !1;
  const t = n.constructor;
  if (t === void 0)
    return !0;
  const e = t.prototype;
  return !(!dk(e) || !e.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(n) !== Object.prototype);
}
c(_v, "Gh");
d(_v, "isPlainObject");
function dk(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
c(dk, "hy");
d(dk, "hasObjectPrototype");
function GR(n) {
  return new Promise((t) => {
    $r.setTimeout(t, n);
  });
}
c(GR, "kv");
d(GR, "sleep");
function zv(n, t, e) {
  return typeof e.structuralSharing == "function" ? e.structuralSharing(n, t) : e.structuralSharing !== !1 ? Cy(n, t) : t;
}
c(zv, "Zh");
d(zv, "replaceData");
function KR(n, t, e = 0) {
  const i = [...n, t];
  return e && i.length > e ? i.slice(1) : i;
}
c(KR, "_v");
d(KR, "addToEnd");
function JR(n, t, e = 0) {
  const i = [t, ...n];
  return e && i.length > e ? i.slice(0, -1) : i;
}
c(JR, "Mv");
d(JR, "addToStart");
var eP = Symbol();
function iP(n, t) {
  return !n.queryFn && t?.initialPromise ? () => t.initialPromise : !n.queryFn || n.queryFn === eP ? () => Promise.reject(new Error(`Missing queryFn: '${n.queryHash}'`)) : n.queryFn;
}
c(iP, "Ew");
d(iP, "ensureQueryFn");
var Jl, Ca, Hy, r0, yu, YF = (r0 = (yu = class extends Py {
  constructor() {
    super(), q(this, Jl), q(this, Ca), q(this, Hy), L(this, Hy, (t) => {
      if (!iy && window.addEventListener) {
        const e = /* @__PURE__ */ d(() => t(), "listener");
        return window.addEventListener("visibilitychange", e, !1), () => {
          window.removeEventListener("visibilitychange", e);
        };
      }
    });
  }
  onSubscribe() {
    k(this, Ca) || this.setEventListener(k(this, Hy));
  }
  onUnsubscribe() {
    var t;
    this.hasListeners() || ((t = k(this, Ca)) == null || t.call(this), L(this, Ca, void 0));
  }
  setEventListener(t) {
    var e;
    L(this, Hy, t), (e = k(this, Ca)) == null || e.call(this), L(this, Ca, t((i) => {
      typeof i == "boolean" ? this.setFocused(i) : this.onFocus();
    }));
  }
  setFocused(t) {
    k(this, Jl) !== t && (L(this, Jl, t), this.onFocus());
  }
  onFocus() {
    const t = this.isFocused();
    this.listeners.forEach((e) => {
      e(t);
    });
  }
  isFocused() {
    return typeof k(this, Jl) == "boolean" ? k(this, Jl) : globalThis.document?.visibilityState !== "hidden";
  }
}, c(yu, "Xr"), yu), Jl = /* @__PURE__ */ new WeakMap(), Ca = /* @__PURE__ */ new WeakMap(), Hy = /* @__PURE__ */ new WeakMap(), d(r0, "FocusManager"), r0), nP = new YF();
function Lv() {
  let n, t;
  const e = new Promise((s, r) => {
    n = s, t = r;
  });
  e.status = "pending", e.catch(() => {
  });
  function i(s) {
    Object.assign(e, s), delete e.resolve, delete e.reject;
  }
  return c(i, "s"), d(i, "finalize"), e.resolve = (s) => {
    i({
      status: "fulfilled",
      value: s
    }), n(s);
  }, e.reject = (s) => {
    i({
      status: "rejected",
      reason: s
    }), t(s);
  }, e;
}
c(Lv, "Yh");
d(Lv, "pendingThenable");
function tE(n) {
  let t;
  if (n.then((e) => (t = e, e), Ke)?.catch(Ke), t !== void 0)
    return { data: t };
}
c(tE, "Pv");
d(tE, "tryResolveSync");
function sP(n) {
  return n;
}
c(sP, "Rw");
d(sP, "defaultTransformerFn");
function eE(n) {
  return {
    mutationKey: n.options.mutationKey,
    state: n.state,
    ...n.options.scope && { scope: n.options.scope },
    ...n.meta && { meta: n.meta }
  };
}
c(eE, "Sv");
d(eE, "dehydrateMutation");
function iE(n, t, e) {
  const i = n.promise?.then(t).catch((s) => e(s) ? Promise.reject(new Error("redacted")) : Promise.reject(s));
  return i?.catch(Ke), {
    dehydratedAt: Date.now(),
    state: {
      ...n.state,
      ...n.state.data !== void 0 && {
        data: t(n.state.data)
      }
    },
    queryKey: n.queryKey,
    queryHash: n.queryHash,
    ...n.state.status === "pending" && {
      promise: i
    },
    ...n.meta && { meta: n.meta }
  };
}
c(iE, "Av");
d(iE, "dehydrateQuery");
function nE(n) {
  return n.state.isPaused;
}
c(nE, "Ev");
d(nE, "defaultShouldDehydrateMutation");
function sE(n) {
  return n.state.status === "success";
}
c(sE, "Rv");
d(sE, "defaultShouldDehydrateQuery");
function rE(n) {
  return !0;
}
c(rE, "Ov");
d(rE, "defaultShouldRedactErrors");
function aE(n, t = {}) {
  const e = t.shouldDehydrateMutation ?? n.getDefaultOptions().dehydrate?.shouldDehydrateMutation ?? nE, i = n.getMutationCache().getAll().flatMap(
    (l) => e(l) ? [eE(l)] : []
  ), s = t.shouldDehydrateQuery ?? n.getDefaultOptions().dehydrate?.shouldDehydrateQuery ?? sE, r = t.shouldRedactErrors ?? n.getDefaultOptions().dehydrate?.shouldRedactErrors ?? rE, a = t.serializeData ?? n.getDefaultOptions().dehydrate?.serializeData ?? sP, o = n.getQueryCache().getAll().flatMap(
    (l) => s(l) ? [iE(l, a, r)] : []
  );
  return { mutations: i, queries: o };
}
c(aE, "Lv");
d(aE, "dehydrate");
function oE(n, t, e) {
  if (typeof t != "object" || t === null)
    return;
  const i = n.getMutationCache(), s = n.getQueryCache(), r = n.getDefaultOptions().hydrate?.deserializeData ?? sP, a = t.mutations || [], o = t.queries || [];
  a.forEach(({ state: l, ...h }) => {
    i.build(
      n,
      {
        ...n.getDefaultOptions().hydrate?.mutations,
        ...e?.defaultOptions?.mutations,
        ...h
      },
      l
    );
  }), o.forEach(
    ({ queryKey: l, state: h, queryHash: u, meta: p, promise: y, dehydratedAt: m }) => {
      const w = y ? tE(y) : void 0, b = h.data === void 0 ? w?.data : h.data, $ = b === void 0 ? b : r(b);
      let x = s.get(u);
      const C = x?.state.status === "pending", R = x?.state.fetchStatus === "fetching";
      if (x) {
        const E = w && // We only need this undefined check to handle older dehydration
        // payloads that might not have dehydratedAt
        m !== void 0 && m > x.state.dataUpdatedAt;
        if (h.dataUpdatedAt > x.state.dataUpdatedAt || E) {
          const { fetchStatus: A, ...I } = h;
          x.setState({
            ...I,
            data: $
          });
        }
      } else
        x = s.build(
          n,
          {
            ...n.getDefaultOptions().hydrate?.queries,
            ...e?.defaultOptions?.queries,
            queryKey: l,
            queryHash: u,
            meta: p
          },
          // Reset fetch status to idle to avoid
          // query being stuck in fetching state upon hydration
          {
            ...h,
            data: $,
            fetchStatus: "idle",
            status: $ !== void 0 ? "success" : h.status
          }
        );
      y && !C && !R && // Only hydrate if dehydration is newer than any existing data,
      // this is always true for new queries
      (m === void 0 || m > x.state.dataUpdatedAt) && x.fetch(void 0, {
        // RSC transformed promises are not thenable
        initialPromise: Promise.resolve(y).then(r)
      }).catch(Ke);
    }
  );
}
c(oE, "Iv");
d(oE, "hydrate");
var GF = HR;
function lE() {
  let n = [], t = 0, e = /* @__PURE__ */ d((o) => {
    o();
  }, "notifyFn"), i = /* @__PURE__ */ d((o) => {
    o();
  }, "batchNotifyFn"), s = GF;
  const r = /* @__PURE__ */ d((o) => {
    t ? n.push(o) : s(() => {
      e(o);
    });
  }, "schedule"), a = /* @__PURE__ */ d(() => {
    const o = n;
    n = [], o.length && s(() => {
      i(() => {
        o.forEach((l) => {
          e(l);
        });
      });
    });
  }, "flush");
  return {
    batch: /* @__PURE__ */ d((o) => {
      let l;
      t++;
      try {
        l = o();
      } finally {
        t--, t || a();
      }
      return l;
    }, "batch"),
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: /* @__PURE__ */ d((o) => (...l) => {
      r(() => {
        o(...l);
      });
    }, "batchCalls"),
    schedule: r,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: /* @__PURE__ */ d((o) => {
      e = o;
    }, "setNotifyFunction"),
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: /* @__PURE__ */ d((o) => {
      i = o;
    }, "setBatchNotifyFunction"),
    setScheduler: /* @__PURE__ */ d((o) => {
      s = o;
    }, "setScheduler")
  };
}
c(lE, "Fv");
d(lE, "createNotifyManager");
var ei = lE(), Yy, Qa, Gy, a0, mu, KF = (a0 = (mu = class extends Py {
  constructor() {
    super(), q(this, Yy, !0), q(this, Qa), q(this, Gy), L(this, Gy, (t) => {
      if (!iy && window.addEventListener) {
        const e = /* @__PURE__ */ d(() => t(!0), "onlineListener"), i = /* @__PURE__ */ d(() => t(!1), "offlineListener");
        return window.addEventListener("online", e, !1), window.addEventListener("offline", i, !1), () => {
          window.removeEventListener("online", e), window.removeEventListener("offline", i);
        };
      }
    });
  }
  onSubscribe() {
    k(this, Qa) || this.setEventListener(k(this, Gy));
  }
  onUnsubscribe() {
    var t;
    this.hasListeners() || ((t = k(this, Qa)) == null || t.call(this), L(this, Qa, void 0));
  }
  setEventListener(t) {
    var e;
    L(this, Gy, t), (e = k(this, Qa)) == null || e.call(this), L(this, Qa, t(this.setOnline.bind(this)));
  }
  setOnline(t) {
    k(this, Yy) !== t && (L(this, Yy, t), this.listeners.forEach((e) => {
      e(t);
    }));
  }
  isOnline() {
    return k(this, Yy);
  }
}, c(mu, "en"), mu), Yy = /* @__PURE__ */ new WeakMap(), Qa = /* @__PURE__ */ new WeakMap(), Gy = /* @__PURE__ */ new WeakMap(), d(a0, "OnlineManager"), a0), Iv = new KF();
function cE(n) {
  return Math.min(1e3 * 2 ** n, 3e4);
}
c(cE, "Hv");
d(cE, "defaultRetryDelay");
function rP(n) {
  return (n ?? "online") === "online" ? Iv.isOnline() : !0;
}
c(rP, "Ow");
d(rP, "canFetch");
var o0, wu, uk = (o0 = (wu = class extends Error {
  constructor(t) {
    super("CancelledError"), this.revert = t?.revert, this.silent = t?.silent;
  }
}, c(wu, "sn"), wu), d(o0, "CancelledError"), o0);
function aP(n) {
  let t = !1, e = 0, i;
  const s = Lv(), r = /* @__PURE__ */ d(() => s.status !== "pending", "isResolved"), a = /* @__PURE__ */ d((b) => {
    if (!r()) {
      const $ = new uk(b);
      y($), n.onCancel?.($);
    }
  }, "cancel"), o = /* @__PURE__ */ d(() => {
    t = !0;
  }, "cancelRetry"), l = /* @__PURE__ */ d(() => {
    t = !1;
  }, "continueRetry"), h = /* @__PURE__ */ d(() => nP.isFocused() && (n.networkMode === "always" || Iv.isOnline()) && n.canRun(), "canContinue"), u = /* @__PURE__ */ d(() => rP(n.networkMode) && n.canRun(), "canStart"), p = /* @__PURE__ */ d((b) => {
    r() || (i?.(), s.resolve(b));
  }, "resolve"), y = /* @__PURE__ */ d((b) => {
    r() || (i?.(), s.reject(b));
  }, "reject"), m = /* @__PURE__ */ d(() => new Promise((b) => {
    i = /* @__PURE__ */ d(($) => {
      (r() || h()) && b($);
    }, "continueFn"), n.onPause?.();
  }).then(() => {
    i = void 0, r() || n.onContinue?.();
  }), "pause"), w = /* @__PURE__ */ d(() => {
    if (r())
      return;
    let b;
    const $ = e === 0 ? n.initialPromise : void 0;
    try {
      b = $ ?? n.fn();
    } catch (x) {
      b = Promise.reject(x);
    }
    Promise.resolve(b).then(p).catch((x) => {
      if (r())
        return;
      const C = n.retry ?? (iy ? 0 : 3), R = n.retryDelay ?? cE, E = typeof R == "function" ? R(e, x) : R, A = C === !0 || typeof C == "number" && e < C || typeof C == "function" && C(e, x);
      if (t || !A) {
        y(x);
        return;
      }
      e++, n.onFail?.(e, x), GR(E).then(() => h() ? void 0 : m()).then(() => {
        t ? y(x) : w();
      });
    });
  }, "run");
  return {
    promise: s,
    status: /* @__PURE__ */ d(() => s.status, "status"),
    cancel: a,
    continue: /* @__PURE__ */ d(() => (i?.(), s), "continue"),
    cancelRetry: o,
    continueRetry: l,
    canStart: u,
    start: /* @__PURE__ */ d(() => (u() ? w() : m().then(w), s), "start")
  };
}
c(aP, "Lw");
d(aP, "createRetryer");
var tc, l0, gu, hE = (l0 = (gu = class {
  constructor() {
    q(this, tc);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), Ev(this.gcTime) && L(this, tc, $r.setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t ?? (iy ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    k(this, tc) && ($r.clearTimeout(k(this, tc)), L(this, tc, void 0));
  }
}, c(gu, "rn"), gu), tc = /* @__PURE__ */ new WeakMap(), d(l0, "Removable"), l0), ec, Ky, pn, ic, Ne, Fg, nc, Ln, ys, c0, vu, JF = (c0 = (vu = class extends hE {
  constructor(t) {
    super(), q(this, Ln), q(this, ec), q(this, Ky), q(this, pn), q(this, ic), q(this, Ne), q(this, Fg), q(this, nc), L(this, nc, !1), L(this, Fg, t.defaultOptions), this.setOptions(t.options), this.observers = [], L(this, ic, t.client), L(this, pn, k(this, ic).getQueryCache()), this.queryKey = t.queryKey, this.queryHash = t.queryHash, L(this, ec, fk(this.options)), this.state = t.state ?? k(this, ec), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return k(this, Ne)?.promise;
  }
  setOptions(t) {
    if (this.options = { ...k(this, Fg), ...t }, this.updateGcTime(this.options.gcTime), this.state && this.state.data === void 0) {
      const e = fk(this.options);
      e.data !== void 0 && (this.setState(
        pk(e.data, e.dataUpdatedAt)
      ), L(this, ec, e));
    }
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && k(this, pn).remove(this);
  }
  setData(t, e) {
    const i = zv(this.state.data, t, this.options);
    return yt(this, Ln, ys).call(this, {
      data: i,
      type: "success",
      dataUpdatedAt: e?.updatedAt,
      manual: e?.manual
    }), i;
  }
  setState(t, e) {
    yt(this, Ln, ys).call(this, { type: "setState", state: t, setStateOptions: e });
  }
  cancel(t) {
    const e = k(this, Ne)?.promise;
    return k(this, Ne)?.cancel(t), e ? e.then(Ke).catch(Ke) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(k(this, ec));
  }
  isActive() {
    return this.observers.some(
      (t) => qi(t.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === eP || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (t) => Is(t.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (t) => t.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(t = 0) {
    return this.state.data === void 0 ? !0 : t === "static" ? !1 : this.state.isInvalidated ? !0 : !tP(this.state.dataUpdatedAt, t);
  }
  onFocus() {
    this.observers.find((t) => t.shouldFetchOnWindowFocus())?.refetch({ cancelRefetch: !1 }), k(this, Ne)?.continue();
  }
  onOnline() {
    this.observers.find((t) => t.shouldFetchOnReconnect())?.refetch({ cancelRefetch: !1 }), k(this, Ne)?.continue();
  }
  addObserver(t) {
    this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), k(this, pn).notify({ type: "observerAdded", query: this, observer: t }));
  }
  removeObserver(t) {
    this.observers.includes(t) && (this.observers = this.observers.filter((e) => e !== t), this.observers.length || (k(this, Ne) && (k(this, nc) ? k(this, Ne).cancel({ revert: !0 }) : k(this, Ne).cancelRetry()), this.scheduleGc()), k(this, pn).notify({ type: "observerRemoved", query: this, observer: t }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || yt(this, Ln, ys).call(this, { type: "invalidate" });
  }
  async fetch(t, e) {
    if (this.state.fetchStatus !== "idle" && // If the promise in the retyer is already rejected, we have to definitely
    // re-start the fetch; there is a chance that the query is still in a
    // pending state when that happens
    k(this, Ne)?.status() !== "rejected") {
      if (this.state.data !== void 0 && e?.cancelRefetch)
        this.cancel({ silent: !0 });
      else if (k(this, Ne))
        return k(this, Ne).continueRetry(), k(this, Ne).promise;
    }
    if (t && this.setOptions(t), !this.options.queryFn) {
      const o = this.observers.find((l) => l.options.queryFn);
      o && this.setOptions(o.options);
    }
    const i = new AbortController(), s = /* @__PURE__ */ d((o) => {
      Object.defineProperty(o, "signal", {
        enumerable: !0,
        get: /* @__PURE__ */ d(() => (L(this, nc, !0), i.signal), "get")
      });
    }, "addSignalProperty"), r = /* @__PURE__ */ d(() => {
      const o = iP(this.options, e), l = (/* @__PURE__ */ d(() => {
        const h = {
          client: k(this, ic),
          queryKey: this.queryKey,
          meta: this.meta
        };
        return s(h), h;
      }, "createQueryFnContext"))();
      return L(this, nc, !1), this.options.persister ? this.options.persister(
        o,
        l,
        this
      ) : o(l);
    }, "fetchFn"), a = (/* @__PURE__ */ d(() => {
      const o = {
        fetchOptions: e,
        options: this.options,
        queryKey: this.queryKey,
        client: k(this, ic),
        state: this.state,
        fetchFn: r
      };
      return s(o), o;
    }, "createFetchContext"))();
    this.options.behavior?.onFetch(a, this), L(this, Ky, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== a.fetchOptions?.meta) && yt(this, Ln, ys).call(this, { type: "fetch", meta: a.fetchOptions?.meta }), L(this, Ne, aP({
      initialPromise: e?.initialPromise,
      fn: a.fetchFn,
      onCancel: /* @__PURE__ */ d((o) => {
        o instanceof uk && o.revert && this.setState({
          ...k(this, Ky),
          fetchStatus: "idle"
        }), i.abort();
      }, "onCancel"),
      onFail: /* @__PURE__ */ d((o, l) => {
        yt(this, Ln, ys).call(this, { type: "failed", failureCount: o, error: l });
      }, "onFail"),
      onPause: /* @__PURE__ */ d(() => {
        yt(this, Ln, ys).call(this, { type: "pause" });
      }, "onPause"),
      onContinue: /* @__PURE__ */ d(() => {
        yt(this, Ln, ys).call(this, { type: "continue" });
      }, "onContinue"),
      retry: a.options.retry,
      retryDelay: a.options.retryDelay,
      networkMode: a.options.networkMode,
      canRun: /* @__PURE__ */ d(() => !0, "canRun")
    }));
    try {
      const o = await k(this, Ne).start();
      if (o === void 0)
        throw new Error(`${this.queryHash} data is undefined`);
      return this.setData(o), k(this, pn).config.onSuccess?.(o, this), k(this, pn).config.onSettled?.(
        o,
        this.state.error,
        this
      ), o;
    } catch (o) {
      if (o instanceof uk) {
        if (o.silent)
          return k(this, Ne).promise;
        if (o.revert) {
          if (this.state.data === void 0)
            throw o;
          return this.state.data;
        }
      }
      throw yt(this, Ln, ys).call(this, {
        type: "error",
        error: o
      }), k(this, pn).config.onError?.(
        o,
        this
      ), k(this, pn).config.onSettled?.(
        this.state.data,
        o,
        this
      ), o;
    } finally {
      this.scheduleGc();
    }
  }
}, c(vu, "an"), vu), ec = /* @__PURE__ */ new WeakMap(), Ky = /* @__PURE__ */ new WeakMap(), pn = /* @__PURE__ */ new WeakMap(), ic = /* @__PURE__ */ new WeakMap(), Ne = /* @__PURE__ */ new WeakMap(), Fg = /* @__PURE__ */ new WeakMap(), nc = /* @__PURE__ */ new WeakMap(), Ln = /* @__PURE__ */ new WeakSet(), ys = /* @__PURE__ */ d(function(n) {
  const t = /* @__PURE__ */ d((e) => {
    switch (n.type) {
      case "failed":
        return {
          ...e,
          fetchFailureCount: n.failureCount,
          fetchFailureReason: n.error
        };
      case "pause":
        return {
          ...e,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...e,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...e,
          ...oP(e.data, this.options),
          fetchMeta: n.meta ?? null
        };
      case "success":
        const i = {
          ...e,
          ...pk(n.data, n.dataUpdatedAt),
          dataUpdateCount: e.dataUpdateCount + 1,
          ...!n.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
        return L(this, Ky, n.manual ? i : void 0), i;
      case "error":
        const s = n.error;
        return {
          ...e,
          error: s,
          errorUpdateCount: e.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: e.fetchFailureCount + 1,
          fetchFailureReason: s,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...e,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...e,
          ...n.state
        };
    }
  }, "reducer");
  this.state = t(this.state), ei.batch(() => {
    this.observers.forEach((e) => {
      e.onQueryUpdate();
    }), k(this, pn).notify({ query: this, type: "updated", action: n });
  });
}, "#dispatch"), d(c0, "Query"), c0);
function oP(n, t) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: rP(t.networkMode) ? "fetching" : "paused",
    ...n === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
c(oP, "Tw");
d(oP, "fetchState");
function pk(n, t) {
  return {
    data: n,
    dataUpdatedAt: t ?? Date.now(),
    error: null,
    isInvalidated: !1,
    status: "success"
  };
}
c(pk, "uy");
d(pk, "successState");
function fk(n) {
  const t = typeof n.initialData == "function" ? n.initialData() : n.initialData, e = t !== void 0, i = e ? typeof n.initialDataUpdatedAt == "function" ? n.initialDataUpdatedAt() : n.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: e ? i ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: e ? "success" : "pending",
    fetchStatus: "idle"
  };
}
c(fk, "py");
d(fk, "getDefaultState$1");
var Zi, zt, Ug, xi, sc, Jy, sr, Ma, Bg, tm, em, rc, ac, Ta, im, ve, nm, h0, d0, u0, p0, f0, y0, m0, $3, w0, bu, dE = (w0 = (bu = class extends Py {
  constructor(t, e) {
    super(), q(this, ve), q(this, Zi), q(this, zt), q(this, Ug), q(this, xi), q(this, sc), q(this, Jy), q(this, sr), q(this, Ma), q(this, Bg), q(this, tm), q(this, em), q(this, rc), q(this, ac), q(this, Ta), q(this, im, /* @__PURE__ */ new Set()), this.options = e, L(this, Zi, t), L(this, Ma, null), L(this, sr, Lv()), this.bindMethods(), this.setOptions(e);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (k(this, zt).addObserver(this), yk(k(this, zt), this.options) ? yt(this, ve, nm).call(this) : this.updateResult(), yt(this, ve, p0).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return Zv(
      k(this, zt),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return Zv(
      k(this, zt),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), yt(this, ve, f0).call(this), yt(this, ve, y0).call(this), k(this, zt).removeObserver(this);
  }
  setOptions(t) {
    const e = this.options, i = k(this, zt);
    if (this.options = k(this, Zi).defaultQueryOptions(t), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof qi(this.options.enabled, k(this, zt)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    yt(this, ve, m0).call(this), k(this, zt).setOptions(this.options), e._defaulted && !Tw(this.options, e) && k(this, Zi).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: k(this, zt),
      observer: this
    });
    const s = this.hasListeners();
    s && mk(
      k(this, zt),
      i,
      this.options,
      e
    ) && yt(this, ve, nm).call(this), this.updateResult(), s && (k(this, zt) !== i || qi(this.options.enabled, k(this, zt)) !== qi(e.enabled, k(this, zt)) || Is(this.options.staleTime, k(this, zt)) !== Is(e.staleTime, k(this, zt))) && yt(this, ve, h0).call(this);
    const r = yt(this, ve, d0).call(this);
    s && (k(this, zt) !== i || qi(this.options.enabled, k(this, zt)) !== qi(e.enabled, k(this, zt)) || r !== k(this, Ta)) && yt(this, ve, u0).call(this, r);
  }
  getOptimisticResult(t) {
    const e = k(this, Zi).getQueryCache().build(k(this, Zi), t), i = this.createResult(e, t);
    return pE(this, i) && (L(this, xi, i), L(this, Jy, this.options), L(this, sc, k(this, zt).state)), i;
  }
  getCurrentResult() {
    return k(this, xi);
  }
  trackResult(t, e) {
    return new Proxy(t, {
      get: /* @__PURE__ */ d((i, s) => (this.trackProp(s), e?.(s), s === "promise" && (this.trackProp("data"), !this.options.experimental_prefetchInRender && k(this, sr).status === "pending" && k(this, sr).reject(
        new Error(
          "experimental_prefetchInRender feature flag is not enabled"
        )
      )), Reflect.get(i, s)), "get")
    });
  }
  trackProp(t) {
    k(this, im).add(t);
  }
  getCurrentQuery() {
    return k(this, zt);
  }
  refetch({ ...t } = {}) {
    return this.fetch({
      ...t
    });
  }
  fetchOptimistic(t) {
    const e = k(this, Zi).defaultQueryOptions(t), i = k(this, Zi).getQueryCache().build(k(this, Zi), e);
    return i.fetch().then(() => this.createResult(i, e));
  }
  fetch(t) {
    return yt(this, ve, nm).call(this, {
      ...t,
      cancelRefetch: t.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), k(this, xi)));
  }
  createResult(t, e) {
    const i = k(this, zt), s = this.options, r = k(this, xi), a = k(this, sc), o = k(this, Jy), l = t !== i ? t.state : k(this, Ug), { state: h } = t;
    let u = { ...h }, p = !1, y;
    if (e._optimisticResults) {
      const Z = this.hasListeners(), j = !Z && yk(t, e), N = Z && mk(t, i, e, s);
      (j || N) && (u = {
        ...u,
        ...oP(h.data, t.options)
      }), e._optimisticResults === "isRestoring" && (u.fetchStatus = "idle");
    }
    let { error: m, errorUpdatedAt: w, status: b } = u;
    y = u.data;
    let $ = !1;
    if (e.placeholderData !== void 0 && y === void 0 && b === "pending") {
      let Z;
      r?.isPlaceholderData && e.placeholderData === o?.placeholderData ? (Z = r.data, $ = !0) : Z = typeof e.placeholderData == "function" ? e.placeholderData(
        k(this, em)?.state.data,
        k(this, em)
      ) : e.placeholderData, Z !== void 0 && (b = "success", y = zv(
        r?.data,
        Z,
        e
      ), p = !0);
    }
    if (e.select && y !== void 0 && !$)
      if (r && y === a?.data && e.select === k(this, Bg))
        y = k(this, tm);
      else
        try {
          L(this, Bg, e.select), y = e.select(y), y = zv(r?.data, y, e), L(this, tm, y), L(this, Ma, null);
        } catch (Z) {
          L(this, Ma, Z);
        }
    k(this, Ma) && (m = k(this, Ma), y = k(this, tm), w = Date.now(), b = "error");
    const x = u.fetchStatus === "fetching", C = b === "pending", R = b === "error", E = C && x, A = y !== void 0, I = {
      status: b,
      fetchStatus: u.fetchStatus,
      isPending: C,
      isSuccess: b === "success",
      isError: R,
      isInitialLoading: E,
      isLoading: E,
      data: y,
      dataUpdatedAt: u.dataUpdatedAt,
      error: m,
      errorUpdatedAt: w,
      failureCount: u.fetchFailureCount,
      failureReason: u.fetchFailureReason,
      errorUpdateCount: u.errorUpdateCount,
      isFetched: u.dataUpdateCount > 0 || u.errorUpdateCount > 0,
      isFetchedAfterMount: u.dataUpdateCount > l.dataUpdateCount || u.errorUpdateCount > l.errorUpdateCount,
      isFetching: x,
      isRefetching: x && !C,
      isLoadingError: R && !A,
      isPaused: u.fetchStatus === "paused",
      isPlaceholderData: p,
      isRefetchError: R && A,
      isStale: Wb(t, e),
      refetch: this.refetch,
      promise: k(this, sr),
      isEnabled: qi(e.enabled, t) !== !1
    };
    if (this.options.experimental_prefetchInRender) {
      const Z = /* @__PURE__ */ d((ut) => {
        I.status === "error" ? ut.reject(I.error) : I.data !== void 0 && ut.resolve(I.data);
      }, "finalizeThenableIfPossible"), j = /* @__PURE__ */ d(() => {
        const ut = L(this, sr, I.promise = Lv());
        Z(ut);
      }, "recreateThenable"), N = k(this, sr);
      switch (N.status) {
        case "pending":
          t.queryHash === i.queryHash && Z(N);
          break;
        case "fulfilled":
          (I.status === "error" || I.data !== N.value) && j();
          break;
        case "rejected":
          (I.status !== "error" || I.error !== N.reason) && j();
          break;
      }
    }
    return I;
  }
  updateResult() {
    const t = k(this, xi), e = this.createResult(k(this, zt), this.options);
    if (L(this, sc, k(this, zt).state), L(this, Jy, this.options), k(this, sc).data !== void 0 && L(this, em, k(this, zt)), Tw(e, t))
      return;
    L(this, xi, e);
    const i = /* @__PURE__ */ d(() => {
      if (!t)
        return !0;
      const { notifyOnChangeProps: s } = this.options, r = typeof s == "function" ? s() : s;
      if (r === "all" || !r && !k(this, im).size)
        return !0;
      const a = new Set(
        r ?? k(this, im)
      );
      return this.options.throwOnError && a.add("error"), Object.keys(k(this, xi)).some((o) => {
        const l = o;
        return k(this, xi)[l] !== t[l] && a.has(l);
      });
    }, "shouldNotifyListeners");
    yt(this, ve, $3).call(this, { listeners: i() });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && yt(this, ve, p0).call(this);
  }
}, c(bu, "hn"), bu), Zi = /* @__PURE__ */ new WeakMap(), zt = /* @__PURE__ */ new WeakMap(), Ug = /* @__PURE__ */ new WeakMap(), xi = /* @__PURE__ */ new WeakMap(), sc = /* @__PURE__ */ new WeakMap(), Jy = /* @__PURE__ */ new WeakMap(), sr = /* @__PURE__ */ new WeakMap(), Ma = /* @__PURE__ */ new WeakMap(), Bg = /* @__PURE__ */ new WeakMap(), tm = /* @__PURE__ */ new WeakMap(), em = /* @__PURE__ */ new WeakMap(), rc = /* @__PURE__ */ new WeakMap(), ac = /* @__PURE__ */ new WeakMap(), Ta = /* @__PURE__ */ new WeakMap(), im = /* @__PURE__ */ new WeakMap(), ve = /* @__PURE__ */ new WeakSet(), nm = /* @__PURE__ */ d(function(n) {
  yt(this, ve, m0).call(this);
  let t = k(this, zt).fetch(
    this.options,
    n
  );
  return n?.throwOnError || (t = t.catch(Ke)), t;
}, "#executeFetch"), h0 = /* @__PURE__ */ d(function() {
  yt(this, ve, f0).call(this);
  const n = Is(
    this.options.staleTime,
    k(this, zt)
  );
  if (iy || k(this, xi).isStale || !Ev(n))
    return;
  const t = tP(k(this, xi).dataUpdatedAt, n) + 1;
  L(this, rc, $r.setTimeout(() => {
    k(this, xi).isStale || this.updateResult();
  }, t));
}, "#updateStaleTimeout"), d0 = /* @__PURE__ */ d(function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(k(this, zt)) : this.options.refetchInterval) ?? !1;
}, "#computeRefetchInterval"), u0 = /* @__PURE__ */ d(function(n) {
  yt(this, ve, y0).call(this), L(this, Ta, n), !(iy || qi(this.options.enabled, k(this, zt)) === !1 || !Ev(k(this, Ta)) || k(this, Ta) === 0) && L(this, ac, $r.setInterval(() => {
    (this.options.refetchIntervalInBackground || nP.isFocused()) && yt(this, ve, nm).call(this);
  }, k(this, Ta)));
}, "#updateRefetchInterval"), p0 = /* @__PURE__ */ d(function() {
  yt(this, ve, h0).call(this), yt(this, ve, u0).call(this, yt(this, ve, d0).call(this));
}, "#updateTimers"), f0 = /* @__PURE__ */ d(function() {
  k(this, rc) && ($r.clearTimeout(k(this, rc)), L(this, rc, void 0));
}, "#clearStaleTimeout"), y0 = /* @__PURE__ */ d(function() {
  k(this, ac) && ($r.clearInterval(k(this, ac)), L(this, ac, void 0));
}, "#clearRefetchInterval"), m0 = /* @__PURE__ */ d(function() {
  const n = k(this, Zi).getQueryCache().build(k(this, Zi), this.options);
  if (n === k(this, zt))
    return;
  const t = k(this, zt);
  L(this, zt, n), L(this, Ug, n.state), this.hasListeners() && (t?.removeObserver(this), n.addObserver(this));
}, "#updateQuery"), $3 = /* @__PURE__ */ d(function(n) {
  ei.batch(() => {
    n.listeners && this.listeners.forEach((t) => {
      t(k(this, xi));
    }), k(this, Zi).getQueryCache().notify({
      query: k(this, zt),
      type: "observerResultsUpdated"
    });
  });
}, "#notify"), d(w0, "QueryObserver"), w0);
function uE(n, t) {
  return qi(t.enabled, n) !== !1 && n.state.data === void 0 && !(n.state.status === "error" && t.retryOnMount === !1);
}
c(uE, "Uv");
d(uE, "shouldLoadOnMount");
function yk(n, t) {
  return uE(n, t) || n.state.data !== void 0 && Zv(n, t, t.refetchOnMount);
}
c(yk, "yy");
d(yk, "shouldFetchOnMount");
function Zv(n, t, e) {
  if (qi(t.enabled, n) !== !1 && Is(t.staleTime, n) !== "static") {
    const i = typeof e == "function" ? e(n) : e;
    return i === "always" || i !== !1 && Wb(n, t);
  }
  return !1;
}
c(Zv, "au");
d(Zv, "shouldFetchOn");
function mk(n, t, e, i) {
  return (n !== t || qi(i.enabled, n) === !1) && (!e.suspense || n.state.status !== "error") && Wb(n, e);
}
c(mk, "wy");
d(mk, "shouldFetchOptionally");
function Wb(n, t) {
  return qi(t.enabled, n) !== !1 && n.isStaleByTime(Is(t.staleTime, n));
}
c(Wb, "Yu");
d(Wb, "isStale");
function pE(n, t) {
  return !Tw(n.getCurrentResult(), t);
}
c(pE, "Bv");
d(pE, "shouldAssignObserverCurrentProperties");
function Aw(n) {
  return {
    onFetch: /* @__PURE__ */ d((t, e) => {
      const i = t.options, s = t.fetchOptions?.meta?.fetchMore?.direction, r = t.state.data?.pages || [], a = t.state.data?.pageParams || [];
      let o = { pages: [], pageParams: [] }, l = 0;
      const h = /* @__PURE__ */ d(async () => {
        let u = !1;
        const p = /* @__PURE__ */ d((w) => {
          Object.defineProperty(w, "signal", {
            enumerable: !0,
            get: /* @__PURE__ */ d(() => (t.signal.aborted ? u = !0 : t.signal.addEventListener("abort", () => {
              u = !0;
            }), t.signal), "get")
          });
        }, "addSignalProperty"), y = iP(t.options, t.fetchOptions), m = /* @__PURE__ */ d(async (w, b, $) => {
          if (u)
            return Promise.reject();
          if (b == null && w.pages.length)
            return Promise.resolve(w);
          const x = (/* @__PURE__ */ d(() => {
            const A = {
              client: t.client,
              queryKey: t.queryKey,
              pageParam: b,
              direction: $ ? "backward" : "forward",
              meta: t.options.meta
            };
            return p(A), A;
          }, "createQueryFnContext"))(), C = await y(x), { maxPages: R } = t.options, E = $ ? JR : KR;
          return {
            pages: E(w.pages, C, R),
            pageParams: E(w.pageParams, b, R)
          };
        }, "fetchPage");
        if (s && r.length) {
          const w = s === "backward", b = w ? lP : Vv, $ = {
            pages: r,
            pageParams: a
          }, x = b(i, $);
          o = await m($, x, w);
        } else {
          const w = n ?? r.length;
          do {
            const b = l === 0 ? a[0] ?? i.initialPageParam : Vv(i, o);
            if (l > 0 && b == null)
              break;
            o = await m(o, b), l++;
          } while (l < w);
        }
        return o;
      }, "fetchFn");
      t.options.persister ? t.fetchFn = () => t.options.persister?.(
        h,
        {
          client: t.client,
          queryKey: t.queryKey,
          meta: t.options.meta,
          signal: t.signal
        },
        e
      ) : t.fetchFn = h;
    }, "onFetch")
  };
}
c(Aw, "Wl");
d(Aw, "infiniteQueryBehavior");
function Vv(n, { pages: t, pageParams: e }) {
  const i = t.length - 1;
  return t.length > 0 ? n.getNextPageParam(
    t[i],
    t,
    e[i],
    e
  ) : void 0;
}
c(Vv, "ou");
d(Vv, "getNextPageParam");
function lP(n, { pages: t, pageParams: e }) {
  return t.length > 0 ? n.getPreviousPageParam?.(t[0], t, e[0], e) : void 0;
}
c(lP, "Hw");
d(lP, "getPreviousPageParam");
function fE(n, t) {
  return t ? Vv(n, t) != null : !1;
}
c(fE, "qv");
d(fE, "hasNextPage");
function yE(n, t) {
  return !t || !n.getPreviousPageParam ? !1 : lP(n, t) != null;
}
c(yE, "Nv");
d(yE, "hasPreviousPage");
var g0, Ou, tU = (g0 = (Ou = class extends dE {
  constructor(t, e) {
    super(t, e);
  }
  bindMethods() {
    super.bindMethods(), this.fetchNextPage = this.fetchNextPage.bind(this), this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
  }
  setOptions(t) {
    super.setOptions({
      ...t,
      behavior: Aw()
    });
  }
  getOptimisticResult(t) {
    return t.behavior = Aw(), super.getOptimisticResult(t);
  }
  fetchNextPage(t) {
    return this.fetch({
      ...t,
      meta: {
        fetchMore: { direction: "forward" }
      }
    });
  }
  fetchPreviousPage(t) {
    return this.fetch({
      ...t,
      meta: {
        fetchMore: { direction: "backward" }
      }
    });
  }
  createResult(t, e) {
    const { state: i } = t, s = super.createResult(t, e), { isFetching: r, isRefetching: a, isError: o, isRefetchError: l } = s, h = i.fetchMeta?.fetchMore?.direction, u = o && h === "forward", p = r && h === "forward", y = o && h === "backward", m = r && h === "backward";
    return {
      ...s,
      fetchNextPage: this.fetchNextPage,
      fetchPreviousPage: this.fetchPreviousPage,
      hasNextPage: fE(e, i.data),
      hasPreviousPage: yE(e, i.data),
      isFetchNextPageError: u,
      isFetchingNextPage: p,
      isFetchPreviousPageError: y,
      isFetchingPreviousPage: m,
      isRefetchError: l && !u && !y,
      isRefetching: a && !p && !m
    };
  }
}, c(Ou, "un"), Ou), d(g0, "InfiniteQueryObserver"), g0), Xg, ms, ki, oc, ws, rr, v0, $u, eU = (v0 = ($u = class extends hE {
  constructor(t) {
    super(), q(this, ws), q(this, Xg), q(this, ms), q(this, ki), q(this, oc), L(this, Xg, t.client), this.mutationId = t.mutationId, L(this, ki, t.mutationCache), L(this, ms, []), this.state = t.state || cP(), this.setOptions(t.options), this.scheduleGc();
  }
  setOptions(t) {
    this.options = t, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(t) {
    k(this, ms).includes(t) || (k(this, ms).push(t), this.clearGcTimeout(), k(this, ki).notify({
      type: "observerAdded",
      mutation: this,
      observer: t
    }));
  }
  removeObserver(t) {
    L(this, ms, k(this, ms).filter((e) => e !== t)), this.scheduleGc(), k(this, ki).notify({
      type: "observerRemoved",
      mutation: this,
      observer: t
    });
  }
  optionalRemove() {
    k(this, ms).length || (this.state.status === "pending" ? this.scheduleGc() : k(this, ki).remove(this));
  }
  continue() {
    return k(this, oc)?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(t) {
    const e = /* @__PURE__ */ d(() => {
      yt(this, ws, rr).call(this, { type: "continue" });
    }, "onContinue"), i = {
      client: k(this, Xg),
      meta: this.options.meta,
      mutationKey: this.options.mutationKey
    };
    L(this, oc, aP({
      fn: /* @__PURE__ */ d(() => this.options.mutationFn ? this.options.mutationFn(t, i) : Promise.reject(new Error("No mutationFn found")), "fn"),
      onFail: /* @__PURE__ */ d((a, o) => {
        yt(this, ws, rr).call(this, { type: "failed", failureCount: a, error: o });
      }, "onFail"),
      onPause: /* @__PURE__ */ d(() => {
        yt(this, ws, rr).call(this, { type: "pause" });
      }, "onPause"),
      onContinue: e,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: /* @__PURE__ */ d(() => k(this, ki).canRun(this), "canRun")
    }));
    const s = this.state.status === "pending", r = !k(this, oc).canStart();
    try {
      if (s)
        e();
      else {
        yt(this, ws, rr).call(this, { type: "pending", variables: t, isPaused: r }), await k(this, ki).config.onMutate?.(
          t,
          this,
          i
        );
        const o = await this.options.onMutate?.(
          t,
          i
        );
        o !== this.state.context && yt(this, ws, rr).call(this, {
          type: "pending",
          context: o,
          variables: t,
          isPaused: r
        });
      }
      const a = await k(this, oc).start();
      return await k(this, ki).config.onSuccess?.(
        a,
        t,
        this.state.context,
        this,
        i
      ), await this.options.onSuccess?.(
        a,
        t,
        this.state.context,
        i
      ), await k(this, ki).config.onSettled?.(
        a,
        null,
        this.state.variables,
        this.state.context,
        this,
        i
      ), await this.options.onSettled?.(
        a,
        null,
        t,
        this.state.context,
        i
      ), yt(this, ws, rr).call(this, { type: "success", data: a }), a;
    } catch (a) {
      try {
        throw await k(this, ki).config.onError?.(
          a,
          t,
          this.state.context,
          this,
          i
        ), await this.options.onError?.(
          a,
          t,
          this.state.context,
          i
        ), await k(this, ki).config.onSettled?.(
          void 0,
          a,
          this.state.variables,
          this.state.context,
          this,
          i
        ), await this.options.onSettled?.(
          void 0,
          a,
          t,
          this.state.context,
          i
        ), a;
      } finally {
        yt(this, ws, rr).call(this, { type: "error", error: a });
      }
    } finally {
      k(this, ki).runNext(this);
    }
  }
}, c($u, "pn"), $u), Xg = /* @__PURE__ */ new WeakMap(), ms = /* @__PURE__ */ new WeakMap(), ki = /* @__PURE__ */ new WeakMap(), oc = /* @__PURE__ */ new WeakMap(), ws = /* @__PURE__ */ new WeakSet(), rr = /* @__PURE__ */ d(function(n) {
  const t = /* @__PURE__ */ d((e) => {
    switch (n.type) {
      case "failed":
        return {
          ...e,
          failureCount: n.failureCount,
          failureReason: n.error
        };
      case "pause":
        return {
          ...e,
          isPaused: !0
        };
      case "continue":
        return {
          ...e,
          isPaused: !1
        };
      case "pending":
        return {
          ...e,
          context: n.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: n.isPaused,
          status: "pending",
          variables: n.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...e,
          data: n.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...e,
          data: void 0,
          error: n.error,
          failureCount: e.failureCount + 1,
          failureReason: n.error,
          isPaused: !1,
          status: "error"
        };
    }
  }, "reducer");
  this.state = t(this.state), ei.batch(() => {
    k(this, ms).forEach((e) => {
      e.onMutationUpdate(n);
    }), k(this, ki).notify({
      mutation: this,
      type: "updated",
      action: n
    });
  });
}, "#dispatch"), d(v0, "Mutation"), v0);
function cP() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
c(cP, "Vw");
d(cP, "getDefaultState");
var ar, In, Ng, b0, xu, iU = (b0 = (xu = class extends Py {
  constructor(t = {}) {
    super(), q(this, ar), q(this, In), q(this, Ng), this.config = t, L(this, ar, /* @__PURE__ */ new Set()), L(this, In, /* @__PURE__ */ new Map()), L(this, Ng, 0);
  }
  build(t, e, i) {
    const s = new eU({
      client: t,
      mutationCache: this,
      mutationId: ++ok(this, Ng)._,
      options: t.defaultMutationOptions(e),
      state: i
    });
    return this.add(s), s;
  }
  add(t) {
    k(this, ar).add(t);
    const e = xm(t);
    if (typeof e == "string") {
      const i = k(this, In).get(e);
      i ? i.push(t) : k(this, In).set(e, [t]);
    }
    this.notify({ type: "added", mutation: t });
  }
  remove(t) {
    if (k(this, ar).delete(t)) {
      const e = xm(t);
      if (typeof e == "string") {
        const i = k(this, In).get(e);
        if (i)
          if (i.length > 1) {
            const s = i.indexOf(t);
            s !== -1 && i.splice(s, 1);
          } else i[0] === t && k(this, In).delete(e);
      }
    }
    this.notify({ type: "removed", mutation: t });
  }
  canRun(t) {
    const e = xm(t);
    if (typeof e == "string") {
      const i = k(this, In).get(e)?.find(
        (s) => s.state.status === "pending"
      );
      return !i || i === t;
    } else
      return !0;
  }
  runNext(t) {
    const e = xm(t);
    return typeof e == "string" ? k(this, In).get(e)?.find((i) => i !== t && i.state.isPaused)?.continue() ?? Promise.resolve() : Promise.resolve();
  }
  clear() {
    ei.batch(() => {
      k(this, ar).forEach((t) => {
        this.notify({ type: "removed", mutation: t });
      }), k(this, ar).clear(), k(this, In).clear();
    });
  }
  getAll() {
    return Array.from(k(this, ar));
  }
  find(t) {
    const e = { exact: !0, ...t };
    return this.getAll().find(
      (i) => ck(e, i)
    );
  }
  findAll(t = {}) {
    return this.getAll().filter((e) => ck(t, e));
  }
  notify(t) {
    ei.batch(() => {
      this.listeners.forEach((e) => {
        e(t);
      });
    });
  }
  resumePausedMutations() {
    const t = this.getAll().filter((e) => e.state.isPaused);
    return ei.batch(
      () => Promise.all(
        t.map((e) => e.continue().catch(Ke))
      )
    );
  }
}, c(xu, "yn"), xu), ar = /* @__PURE__ */ new WeakMap(), In = /* @__PURE__ */ new WeakMap(), Ng = /* @__PURE__ */ new WeakMap(), d(b0, "MutationCache"), b0);
function xm(n) {
  return n.options.scope?.id;
}
c(xm, "Rl");
d(xm, "scopeFor");
var or, Aa, Vi, lr, Ra, Hg, O0, $0, ku, jt = ($0 = (ku = class extends Py {
  constructor(t, e) {
    super(), q(this, Ra), q(this, or), q(this, Aa), q(this, Vi), q(this, lr), L(this, or, t), this.setOptions(e), this.bindMethods(), yt(this, Ra, Hg).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);
  }
  setOptions(t) {
    const e = this.options;
    this.options = k(this, or).defaultMutationOptions(t), Tw(this.options, e) || k(this, or).getMutationCache().notify({
      type: "observerOptionsUpdated",
      mutation: k(this, Vi),
      observer: this
    }), e?.mutationKey && this.options.mutationKey && ta(e.mutationKey) !== ta(this.options.mutationKey) ? this.reset() : k(this, Vi)?.state.status === "pending" && k(this, Vi).setOptions(this.options);
  }
  onUnsubscribe() {
    this.hasListeners() || k(this, Vi)?.removeObserver(this);
  }
  onMutationUpdate(t) {
    yt(this, Ra, Hg).call(this), yt(this, Ra, O0).call(this, t);
  }
  getCurrentResult() {
    return k(this, Aa);
  }
  reset() {
    k(this, Vi)?.removeObserver(this), L(this, Vi, void 0), yt(this, Ra, Hg).call(this), yt(this, Ra, O0).call(this);
  }
  mutate(t, e) {
    return L(this, lr, e), k(this, Vi)?.removeObserver(this), L(this, Vi, k(this, or).getMutationCache().build(k(this, or), this.options)), k(this, Vi).addObserver(this), k(this, Vi).execute(t);
  }
}, c(ku, "wn"), ku), or = /* @__PURE__ */ new WeakMap(), Aa = /* @__PURE__ */ new WeakMap(), Vi = /* @__PURE__ */ new WeakMap(), lr = /* @__PURE__ */ new WeakMap(), Ra = /* @__PURE__ */ new WeakSet(), Hg = /* @__PURE__ */ d(function() {
  const n = k(this, Vi)?.state ?? cP();
  L(this, Aa, {
    ...n,
    isPending: n.status === "pending",
    isSuccess: n.status === "success",
    isError: n.status === "error",
    isIdle: n.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, "#updateResult"), O0 = /* @__PURE__ */ d(function(n) {
  ei.batch(() => {
    if (k(this, lr) && this.hasListeners()) {
      const t = k(this, Aa).variables, e = k(this, Aa).context, i = {
        client: k(this, or),
        meta: this.options.meta,
        mutationKey: this.options.mutationKey
      };
      n?.type === "success" ? (k(this, lr).onSuccess?.(
        n.data,
        t,
        e,
        i
      ), k(this, lr).onSettled?.(
        n.data,
        null,
        t,
        e,
        i
      )) : n?.type === "error" && (k(this, lr).onError?.(
        n.error,
        t,
        e,
        i
      ), k(this, lr).onSettled?.(
        void 0,
        n.error,
        t,
        e,
        i
      ));
    }
    this.listeners.forEach((t) => {
      t(k(this, Aa));
    });
  });
}, "#notify"), d($0, "MutationObserver"), $0), gs, x0, Su, nU = (x0 = (Su = class extends Py {
  constructor(t = {}) {
    super(), q(this, gs), this.config = t, L(this, gs, /* @__PURE__ */ new Map());
  }
  build(t, e, i) {
    const s = e.queryKey, r = e.queryHash ?? Db(s, e);
    let a = this.get(r);
    return a || (a = new JF({
      client: t,
      queryKey: s,
      queryHash: r,
      options: t.defaultQueryOptions(e),
      state: i,
      defaultOptions: t.getQueryDefaults(s)
    }), this.add(a)), a;
  }
  add(t) {
    k(this, gs).has(t.queryHash) || (k(this, gs).set(t.queryHash, t), this.notify({
      type: "added",
      query: t
    }));
  }
  remove(t) {
    const e = k(this, gs).get(t.queryHash);
    e && (t.destroy(), e === t && k(this, gs).delete(t.queryHash), this.notify({ type: "removed", query: t }));
  }
  clear() {
    ei.batch(() => {
      this.getAll().forEach((t) => {
        this.remove(t);
      });
    });
  }
  get(t) {
    return k(this, gs).get(t);
  }
  getAll() {
    return [...k(this, gs).values()];
  }
  find(t) {
    const e = { exact: !0, ...t };
    return this.getAll().find(
      (i) => lk(e, i)
    );
  }
  findAll(t = {}) {
    const e = this.getAll();
    return Object.keys(t).length > 0 ? e.filter((i) => lk(t, i)) : e;
  }
  notify(t) {
    ei.batch(() => {
      this.listeners.forEach((e) => {
        e(t);
      });
    });
  }
  onFocus() {
    ei.batch(() => {
      this.getAll().forEach((t) => {
        t.onFocus();
      });
    });
  }
  onOnline() {
    ei.batch(() => {
      this.getAll().forEach((t) => {
        t.onOnline();
      });
    });
  }
}, c(Su, "fn"), Su), gs = /* @__PURE__ */ new WeakMap(), d(x0, "QueryCache"), x0), be, Ea, _a, sm, rm, za, am, om, k0, Pu, sU = (k0 = (Pu = class {
  constructor(t = {}) {
    q(this, be), q(this, Ea), q(this, _a), q(this, sm), q(this, rm), q(this, za), q(this, am), q(this, om), L(this, be, t.queryCache || new nU()), L(this, Ea, t.mutationCache || new iU()), L(this, _a, t.defaultOptions || {}), L(this, sm, /* @__PURE__ */ new Map()), L(this, rm, /* @__PURE__ */ new Map()), L(this, za, 0);
  }
  mount() {
    ok(this, za)._++, k(this, za) === 1 && (L(this, am, nP.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), k(this, be).onFocus());
    })), L(this, om, Iv.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), k(this, be).onOnline());
    })));
  }
  unmount() {
    var t, e;
    ok(this, za)._--, k(this, za) === 0 && ((t = k(this, am)) == null || t.call(this), L(this, am, void 0), (e = k(this, om)) == null || e.call(this), L(this, om, void 0));
  }
  isFetching(t) {
    return k(this, be).findAll({ ...t, fetchStatus: "fetching" }).length;
  }
  isMutating(t) {
    return k(this, Ea).findAll({ ...t, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(t) {
    const e = this.defaultQueryOptions({ queryKey: t });
    return k(this, be).get(e.queryHash)?.state.data;
  }
  ensureQueryData(t) {
    const e = this.defaultQueryOptions(t), i = k(this, be).build(this, e), s = i.state.data;
    return s === void 0 ? this.fetchQuery(t) : (t.revalidateIfStale && i.isStaleByTime(Is(e.staleTime, i)) && this.prefetchQuery(e), Promise.resolve(s));
  }
  getQueriesData(t) {
    return k(this, be).findAll(t).map(({ queryKey: e, state: i }) => {
      const s = i.data;
      return [e, s];
    });
  }
  setQueryData(t, e, i) {
    const s = this.defaultQueryOptions({ queryKey: t }), r = k(this, be).get(
      s.queryHash
    )?.state.data, a = YR(e, r);
    if (a !== void 0)
      return k(this, be).build(this, s).setData(a, { ...i, manual: !0 });
  }
  setQueriesData(t, e, i) {
    return ei.batch(
      () => k(this, be).findAll(t).map(({ queryKey: s }) => [
        s,
        this.setQueryData(s, e, i)
      ])
    );
  }
  getQueryState(t) {
    const e = this.defaultQueryOptions({ queryKey: t });
    return k(this, be).get(
      e.queryHash
    )?.state;
  }
  removeQueries(t) {
    const e = k(this, be);
    ei.batch(() => {
      e.findAll(t).forEach((i) => {
        e.remove(i);
      });
    });
  }
  resetQueries(t, e) {
    const i = k(this, be);
    return ei.batch(() => (i.findAll(t).forEach((s) => {
      s.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...t
      },
      e
    )));
  }
  cancelQueries(t, e = {}) {
    const i = { revert: !0, ...e }, s = ei.batch(
      () => k(this, be).findAll(t).map((r) => r.cancel(i))
    );
    return Promise.all(s).then(Ke).catch(Ke);
  }
  invalidateQueries(t, e = {}) {
    return ei.batch(() => (k(this, be).findAll(t).forEach((i) => {
      i.invalidate();
    }), t?.refetchType === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...t,
        type: t?.refetchType ?? t?.type ?? "active"
      },
      e
    )));
  }
  refetchQueries(t, e = {}) {
    const i = {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }, s = ei.batch(
      () => k(this, be).findAll(t).filter((r) => !r.isDisabled() && !r.isStatic()).map((r) => {
        let a = r.fetch(void 0, i);
        return i.throwOnError || (a = a.catch(Ke)), r.state.fetchStatus === "paused" ? Promise.resolve() : a;
      })
    );
    return Promise.all(s).then(Ke);
  }
  fetchQuery(t) {
    const e = this.defaultQueryOptions(t);
    e.retry === void 0 && (e.retry = !1);
    const i = k(this, be).build(this, e);
    return i.isStaleByTime(
      Is(e.staleTime, i)
    ) ? i.fetch(e) : Promise.resolve(i.state.data);
  }
  prefetchQuery(t) {
    return this.fetchQuery(t).then(Ke).catch(Ke);
  }
  fetchInfiniteQuery(t) {
    return t.behavior = Aw(t.pages), this.fetchQuery(t);
  }
  prefetchInfiniteQuery(t) {
    return this.fetchInfiniteQuery(t).then(Ke).catch(Ke);
  }
  ensureInfiniteQueryData(t) {
    return t.behavior = Aw(t.pages), this.ensureQueryData(t);
  }
  resumePausedMutations() {
    return Iv.isOnline() ? k(this, Ea).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return k(this, be);
  }
  getMutationCache() {
    return k(this, Ea);
  }
  getDefaultOptions() {
    return k(this, _a);
  }
  setDefaultOptions(t) {
    L(this, _a, t);
  }
  setQueryDefaults(t, e) {
    k(this, sm).set(ta(t), {
      queryKey: t,
      defaultOptions: e
    });
  }
  getQueryDefaults(t) {
    const e = [...k(this, sm).values()], i = {};
    return e.forEach((s) => {
      ny(t, s.queryKey) && Object.assign(i, s.defaultOptions);
    }), i;
  }
  setMutationDefaults(t, e) {
    k(this, rm).set(ta(t), {
      mutationKey: t,
      defaultOptions: e
    });
  }
  getMutationDefaults(t) {
    const e = [...k(this, rm).values()], i = {};
    return e.forEach((s) => {
      ny(t, s.mutationKey) && Object.assign(i, s.defaultOptions);
    }), i;
  }
  defaultQueryOptions(t) {
    if (t._defaulted)
      return t;
    const e = {
      ...k(this, _a).queries,
      ...this.getQueryDefaults(t.queryKey),
      ...t,
      _defaulted: !0
    };
    return e.queryHash || (e.queryHash = Db(
      e.queryKey,
      e
    )), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.queryFn === eP && (e.enabled = !1), e;
  }
  defaultMutationOptions(t) {
    return t?._defaulted ? t : {
      ...k(this, _a).mutations,
      ...t?.mutationKey && this.getMutationDefaults(t.mutationKey),
      ...t,
      _defaulted: !0
    };
  }
  clear() {
    k(this, be).clear(), k(this, Ea).clear();
  }
}, c(Pu, "xn"), Pu), be = /* @__PURE__ */ new WeakMap(), Ea = /* @__PURE__ */ new WeakMap(), _a = /* @__PURE__ */ new WeakMap(), sm = /* @__PURE__ */ new WeakMap(), rm = /* @__PURE__ */ new WeakMap(), za = /* @__PURE__ */ new WeakMap(), am = /* @__PURE__ */ new WeakMap(), om = /* @__PURE__ */ new WeakMap(), d(k0, "QueryClient"), k0), Pt = /* @__PURE__ */ ((n) => (n.Chat = "d65dd4bc-418e-403c-9f56-f9cf4da931ed", n.Comments = "88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd", n.Files = "523edd88-4bbf-4547-b60f-2859a6d2ddc1", n.Posts = "5ebfa152-de85-48da-82dd-30a1b560c313", n.ChatRoom = "edb400ac-839b-45a7-b2a8-6a01820d1c44", n.PrivateChat = "7e14f418-8f15-46f4-b182-f619b671e470", n.AgentChat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", n))(Pt || {}), gn = /* @__PURE__ */ ((n) => (n.Chat = "chat", n.Comments = "comments", n.Files = "files", n.Posts = "posts", n.ChatRoom = "chat_room", n.PrivateChat = "private_chat", n.AgentChat = "agent_chat", n))(gn || {}), mE = /* @__PURE__ */ ((n) => (n["d65dd4bc-418e-403c-9f56-f9cf4da931ed"] = "chat", n["88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd"] = "comments", n["523edd88-4bbf-4547-b60f-2859a6d2ddc1"] = "files", n["5ebfa152-de85-48da-82dd-30a1b560c313"] = "posts", n["edb400ac-839b-45a7-b2a8-6a01820d1c44"] = "chat_room", n["7e14f418-8f15-46f4-b182-f619b671e470"] = "private_chat", n["2352a1c6-abc6-420e-8b85-ca7d5aed8779"] = "agent_chat", n))(mE || {}), wE = /* @__PURE__ */ ((n) => (n.chat = "d65dd4bc-418e-403c-9f56-f9cf4da931ed", n.comments = "88f96a08-c6c1-4eac-a0bd-5bf8fba1a3fd", n.files = "523edd88-4bbf-4547-b60f-2859a6d2ddc1", n.posts = "5ebfa152-de85-48da-82dd-30a1b560c313", n.chat_room = "edb400ac-839b-45a7-b2a8-6a01820d1c44", n.private_chat = "7e14f418-8f15-46f4-b182-f619b671e470", n.agent_chat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", n))(wE || {}), gE = /* @__PURE__ */ ((n) => (n["2352a1c6-abc6-420e-8b85-ca7d5aed8779"] = "agent_chat", n))(gE || {}), vE = /* @__PURE__ */ ((n) => (n.agent_chat = "2352a1c6-abc6-420e-8b85-ca7d5aed8779", n))(vE || {}), tn = /* @__PURE__ */ ((n) => (n.Unknown = "unknown", n))(tn || {}), mr = /* @__PURE__ */ ((n) => (n.None = "none", n.Read = "read", n.Write = "write", n.Admin = "admin", n))(mr || {}), Uo = /* @__PURE__ */ ((n) => (n.List = "list", n.Read = "read", n.Create = "create", n.Update = "update", n.Delete = "delete", n.Admin = "admin", n))(Uo || {}), ci = /* @__PURE__ */ ((n) => (n.App = "app", n.File = "file", n.Message = "message", n.User = "user", n.Comment = "comment", n.Post = "post", n))(ci || {});
function ll(n, t, e, i, s, r = "GET") {
  return {
    // eslint-disable-next-line @tanstack/query/exhaustive-deps
    queryKey: t,
    queryFn: /* @__PURE__ */ d(async () => {
      const a = await n.fetch(e || "/api/" + t.join("/"), { method: r, body: s });
      if (a.ok)
        return await a.json();
      throw new Error(`Error calling ${e || "/api/" + t.join("/")}`);
    }, "queryFn"),
    ...i
  };
}
c(ll, "ic");
d(ll, "getApiOptions");
async function Dv(n, t, e, i, s, r = "GET", a = !1) {
  const o = n.queryClient, l = ll(n, t, e, i, s, r);
  return a ? (l.staleTime = 1, await o.fetchQuery(l)) : await o.ensureQueryData(l);
}
c(Dv, "lu");
d(Dv, "getApi");
function bE(n, t, e = tn.Unknown, i) {
  return e === tn.Unknown || typeof t == "number" ? Dv(n, ["apps", t]) : Dv(n, ["apps", t], void 0, void 0, JSON.stringify({ type: e, ...i }), "PUT");
}
c(bE, "Zv");
d(bE, "getApp");
function OE(n, t, e = tn.Unknown, i, s) {
  return {
    // eslint-disable-next-line @tanstack/query/exhaustive-deps
    queryKey: ["apps", t],
    queryFn: /* @__PURE__ */ d(async () => {
      const r = [];
      e === tn.Unknown || typeof t == "number" ? r.push(
        // Get existing app
        n.fetch(`/api/apps/${t}`)
      ) : r.push(
        // Get, update or create app using app uid
        n.fetch(`/api/apps/${t}`, { method: "PUT", body: JSON.stringify({ type: e, members: i, ...s }) })
      );
      const a = (await Promise.allSettled(r)).findLast(
        (l) => l.status === "fulfilled" && l.value?.ok
      ), o = a?.status === "fulfilled" && a.value;
      if (o)
        return await o.json();
      throw new Error(`Error getting or creating app ${t}`);
    }, "queryFn")
  };
}
c(OE, "Yv");
d(OE, "getOrCreateAppOptions");
function $E(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ name: t, members: e, type: i, uid: s }) => await (await n.fetch("/api/apps", {
      method: "POST",
      body: JSON.stringify({
        name: t,
        members: e,
        type: i,
        uid: s
      })
    })).json(), "mutationFn"),
    onSettled: /* @__PURE__ */ d(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
c($E, "Xv");
d($E, "getCreateAppMutationOptions");
function hP(n) {
  return new jt(n.queryClient, $E(n));
}
c(hP, "jw");
d(hP, "getCreateAppMutation");
function dP(n, t) {
  const e = n.queryClient, i = ["apps", t.uid || t.id];
  return {
    mutationFn: /* @__PURE__ */ d(async ({ subscribe: s }) => {
      if (t.id >= 1) {
        const r = await n.fetch(`/api/apps/${t.id}/${s ? "subscribe" : "unsubscribe"}`, {
          method: "POST"
        });
        if (!r.ok)
          throw await r.json();
      } else
        throw new Error(`Could not subscribe to app ${t.uid || t.id}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => {
      let r;
      return e.setQueryData(i, (a) => (r = a.is_subscribed, { ...a, is_subscribed: s.subscribe })), {
        previousSubscribe: r,
        subscribe: s.subscribe
      };
    }, "onMutate"),
    onError(s, r, a) {
      a && a.previousSubscribe !== void 0 && e.setQueryData(i, (o) => ({ ...o, is_subscribed: a?.previousSubscribe }));
    }
  };
}
c(dP, "Ww");
d(dP, "getAppSubscribeMutationOptions");
function xE(n, t = [Pt.ChatRoom, Pt.PrivateChat], e, i = {}) {
  const s = new URLSearchParams({
    count_only: "true",
    unread: "true"
  });
  e && s.append("member", e), t?.forEach((a) => s.append("type", a));
  const r = `/api/apps?${s.toString()}`;
  return ll(n, ["apps", "badge", t], r, i);
}
c(xE, "Jv");
d(xE, "getBadgeOptions$1");
function kE(n, t = {}, e, i, s, r, a) {
  return {
    ...t,
    initialPageParam: 0,
    queryKey: ["apps", "list", e, i, r, a],
    queryFn: /* @__PURE__ */ d(async (o) => {
      const l = new URLSearchParams();
      i && l.append("member", i), o.pageParam && typeof o.pageParam == "number" && l.append("skip", o.pageParam?.toString()), e?.forEach((y) => l.append("type", y)), l.append("order_by", r);
      const h = s?.();
      h && l.append("q", h), l.append("uid", "false");
      const u = `/api/apps?${l.toString()}`, p = await (await n.fetch(u)).json();
      return p.data = p.data || [], p;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ d((o) => {
      if (o.end && o?.end < o?.count)
        return o.end;
    }, "getNextPageParam")
  };
}
c(kE, "t1");
d(kE, "getAppListOptions");
const rU = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s);
      const r = this;
      this.api = {
        apps: {
          async getApp(a) {
            return await bE(r, a);
          }
        }
      };
    }
  }, c(e, "t"), e), d(t, "WeavyApi"), t;
}, "WeavyApiMixin"), aU = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // AUTHENTICATION
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this._whenTokenFactory = new Promise((r) => {
        this._resolveTokenFactory = r;
      }), this._whenUrlAndTokenFactory = new Promise((r) => {
        this._resolveUrlAndTokenFactory = (a) => {
          r(a), this.configurationState = "configured";
        };
      }), this._whenTokenIsValid = new Promise((r) => {
        this._resolveTokenIsValid = r;
      }), this._tokenPromise = null, this._token = "", this._validTokenFromFactory = async (r = !1) => {
        const a = [this.whenTokenFactory()];
        this.tokenFactoryRetryDelay >= 0 && this.tokenFactoryRetryDelay < 1 / 0 && a.push(new Promise((l) => setTimeout(l, this.tokenFactoryRetryDelay))), await Promise.race(a);
        const o = await this.tokenFactory?.(r) ?? "";
        if (this._validateToken(o)) {
          if (r && o === this._token && this.tokenFactoryRetryDelay >= 0 && this.tokenFactoryRetryDelay < 1 / 0)
            return await new Promise((l) => setTimeout(l, this.tokenFactoryRetryDelay)), await this._validTokenFromFactory(!0);
        } else if (this._whenTokenFactory = new Promise((l) => {
          this._resolveTokenFactory = l;
        }), !r)
          return await this._validTokenFromFactory(!1);
        if (!o)
          throw new TypeError("Could not get a valid token from tokenFactory.");
        return this._resolveTokenFactory?.(!0), this.whenUrl().then(this._resolveUrlAndTokenFactory), o;
      }, Promise.all([this.whenUrl(), this.whenTokenFactory()]).then(() => {
        this.url && this.tokenFactory && this._resolveUrlAndTokenFactory?.(!0);
      });
    }
    async whenTokenFactory() {
      await this._whenTokenFactory;
    }
    async whenUrlAndTokenFactory() {
      await this._whenUrlAndTokenFactory;
    }
    async whenTokenIsValid() {
      await this._whenTokenIsValid;
    }
    /**
     * Async function returning an `access_token` string for _your_ authenticated user. A boolean `refresh` parameter is provided to let you now if a fresh token is needed from Weavy.
     */
    get tokenFactory() {
      return this._tokenFactory;
    }
    set tokenFactory(s) {
      if (this.isDestroyed)
        throw new Ce();
      this._tokenFactory && this._tokenFactory !== s && this.whenTokenFactory().then(() => {
        this.queryClient.refetchQueries({ stale: !0 });
      }), this._tokenFactory = s ?? void 0, this._tokenFactory && queueMicrotask(() => {
        this._resolveTokenFactory?.(!0);
      });
    }
    /**
     * An URL to an endpoint returning an JSON data containing an `access_token` string property for _your_ authenticated user. A boolean `refresh=true` query parameter is provided in the request to let you now if when a fresh token is needed from Weavy.
     */
    get tokenUrl() {
      return this._tokenUrl;
    }
    set tokenUrl(s) {
      if (this.isDestroyed)
        throw new Ce();
      try {
        if (typeof s == "string")
          s && (this._tokenUrl = new URL(s, window.location.toString()));
        else if (s instanceof URL)
          this._tokenUrl = s;
        else if (s == null)
          this._tokenUrl = void 0;
        else
          throw new Error();
      } catch (r) {
        throw new Error("Invalid url", r);
      }
      this._tokenUrl && !this.tokenFactory && (this.tokenFactory = async (r) => {
        if (!this.tokenUrl)
          throw new Error("tokenURL property is not valid");
        const a = new URL(this.tokenUrl);
        r ? a.searchParams.set("refresh", "true") : a.searchParams.delete("refresh");
        const o = await fetch(a);
        if (o.ok) {
          const l = await o.json();
          if (l.access_token === void 0)
            throw new Error("Token response does not contain required property: access_token");
          return l.access_token;
        } else
          throw new Error("Could not get access token from server!");
      });
    }
    _validateToken(s) {
      if (!s)
        return !1;
      if (typeof s != "string")
        throw new TypeError(`You have provided an invalid string access token of type ${typeof s}.`);
      if (typeof s == "string" && !s.startsWith("wyu_"))
        throw s.startsWith("wys_") ? new TypeError("You have provided an API key for authentication. Provide a user access token instead.") : new TypeError("You have provided an invalid string as access token.");
      return this._resolveTokenIsValid?.(s), !0;
    }
    async getToken(s = !1) {
      if (this.isDestroyed)
        throw new Ce();
      if (this._token && !s)
        return this._token;
      if (this._tokenPromise)
        return await this._tokenPromise;
      this._tokenPromise = new Promise((r, a) => {
        this._validTokenFromFactory(s).then(r).catch(a), this.tokenFactoryTimeout >= 0 && this.tokenFactoryTimeout < 1 / 0 && setTimeout(() => a(new Error("Token factory timeout.")), this.tokenFactoryTimeout), window.addEventListener("offline", () => a(new Error("Network changed.")), { once: !0 }), window.addEventListener("online", () => a(new Error("Network changed.")), { once: !0 });
      });
      try {
        const r = await this._tokenPromise;
        return this._tokenPromise = null, this._token = r, this._token;
      } catch (r) {
        throw this._tokenPromise = null, r;
      }
    }
  }, c(e, "t"), e), d(t, "WeavyAuthentication"), t;
}, "WeavyAuthenticationMixin");
var Yg = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function SE(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
c(SE, "s1");
d(SE, "getDefaultExportFromCjs");
function b1(n) {
  throw new Error('Could not dynamically require "' + n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
c(b1, "Rh");
d(b1, "commonjsRequire");
var x3 = { exports: {} }, k3;
function PE() {
  return k3 || (k3 = 1, function(n, t) {
    var e;
    e = /* @__PURE__ */ d(() => (() => {
      var vl, bl, Ol, $l, xl, kl, Sl, Pl, Cl, Ql, Ml, Tl, us, Al, Rl, El, _l, zl, ps, Ll, Il, Zl, Vl, Oa, Dl, Wl, ql, jl, Fl, Ul, Bl, Xl, $a, Nl, Hl, Yl;
      var i = { d: /* @__PURE__ */ d((U, g) => {
        for (var S in g) i.o(g, S) && !i.o(U, S) && Object.defineProperty(U, S, { enumerable: !0, get: g[S] });
      }, "d") };
      i.g = function() {
        if (typeof globalThis == "object") return globalThis;
        try {
          return this || new Function("return this")();
        } catch {
          if (typeof window == "object") return window;
        }
      }(), i.o = (U, g) => Object.prototype.hasOwnProperty.call(U, g), i.r = (U) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(U, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(U, "t", { value: !0 });
      };
      var s, r = {};
      i.r(r), i.d(r, { AbortError: /* @__PURE__ */ d(() => p, "AbortError"), DefaultHttpClient: /* @__PURE__ */ d(() => xC, "DefaultHttpClient"), HttpClient: /* @__PURE__ */ d(() => N, "HttpClient"), HttpError: /* @__PURE__ */ d(() => o, "HttpError"), HttpResponse: /* @__PURE__ */ d(() => Z, "HttpResponse"), HttpTransportType: /* @__PURE__ */ d(() => Pe, "HttpTransportType"), HubConnection: /* @__PURE__ */ d(() => AC, "HubConnection"), HubConnectionBuilder: /* @__PURE__ */ d(() => RZ, "HubConnectionBuilder"), HubConnectionState: /* @__PURE__ */ d(() => Kt, "HubConnectionState"), JsonHubProtocol: /* @__PURE__ */ d(() => UC, "JsonHubProtocol"), LogLevel: /* @__PURE__ */ d(() => s, "LogLevel"), MessageType: /* @__PURE__ */ d(() => St, "MessageType"), NullLogger: /* @__PURE__ */ d(() => ct, "NullLogger"), Subject: /* @__PURE__ */ d(() => CC, "Subject"), TimeoutError: /* @__PURE__ */ d(() => h, "TimeoutError"), TransferFormat: /* @__PURE__ */ d(() => Xe, "TransferFormat"), VERSION: /* @__PURE__ */ d(() => K, "VERSION") });
      const a = (vl = class extends Error {
        constructor(g, S) {
          const T = new.target.prototype;
          super(`${g}: Status code '${S}'`), this.statusCode = S, this.__proto__ = T;
        }
      }, c(vl, "Jd"), vl);
      d(a, "i");
      let o = a;
      const l = (bl = class extends Error {
        constructor(g = "A timeout occurred.") {
          const S = new.target.prototype;
          super(g), this.__proto__ = S;
        }
      }, c(bl, "th"), bl);
      d(l, "n");
      let h = l;
      const u = (Ol = class extends Error {
        constructor(g = "An abort occurred.") {
          const S = new.target.prototype;
          super(g), this.__proto__ = S;
        }
      }, c(Ol, "eh"), Ol);
      d(u, "r");
      let p = u;
      const y = ($l = class extends Error {
        constructor(g, S) {
          const T = new.target.prototype;
          super(g), this.transport = S, this.errorType = "UnsupportedTransportError", this.__proto__ = T;
        }
      }, c($l, "ih"), $l);
      d(y, "o");
      let m = y;
      const w = (xl = class extends Error {
        constructor(g, S) {
          const T = new.target.prototype;
          super(g), this.transport = S, this.errorType = "DisabledTransportError", this.__proto__ = T;
        }
      }, c(xl, "sh"), xl);
      d(w, "h");
      let b = w;
      const $ = (kl = class extends Error {
        constructor(g, S) {
          const T = new.target.prototype;
          super(g), this.transport = S, this.errorType = "FailedToStartTransportError", this.__proto__ = T;
        }
      }, c(kl, "rh"), kl);
      d($, "c");
      let x = $;
      const C = (Sl = class extends Error {
        constructor(g) {
          const S = new.target.prototype;
          super(g), this.errorType = "FailedToNegotiateWithServerError", this.__proto__ = S;
        }
      }, c(Sl, "nh"), Sl);
      d(C, "a");
      let R = C;
      const E = (Pl = class extends Error {
        constructor(g, S) {
          const T = new.target.prototype;
          super(g), this.innerErrors = S, this.__proto__ = T;
        }
      }, c(Pl, "ah"), Pl);
      d(E, "l");
      let A = E;
      const I = (Cl = class {
        constructor(g, S, T) {
          this.statusCode = g, this.statusText = S, this.content = T;
        }
      }, c(Cl, "oh"), Cl);
      d(I, "u");
      let Z = I;
      const j = (Ql = class {
        get(g, S) {
          return this.send({ ...S, method: "GET", url: g });
        }
        post(g, S) {
          return this.send({ ...S, method: "POST", url: g });
        }
        delete(g, S) {
          return this.send({ ...S, method: "DELETE", url: g });
        }
        getCookieString(g) {
          return "";
        }
      }, c(Ql, "ch"), Ql);
      d(j, "d");
      let N = j;
      (function(U) {
        U[U.Trace = 0] = "Trace", U[U.Debug = 1] = "Debug", U[U.Information = 2] = "Information", U[U.Warning = 3] = "Warning", U[U.Error = 4] = "Error", U[U.Critical = 5] = "Critical", U[U.None = 6] = "None";
      })(s || (s = {}));
      const ut = (Ml = class {
        constructor() {
        }
        log(g, S) {
        }
      }, c(Ml, "lh"), Ml);
      d(ut, "f");
      let ct = ut;
      ct.instance = new ct();
      const K = "9.0.6", wt = (Tl = class {
        static isRequired(g, S) {
          if (g == null) throw new Error(`The '${S}' argument is required.`);
        }
        static isNotEmpty(g, S) {
          if (!g || g.match(/^\s*$/)) throw new Error(`The '${S}' argument should not be empty.`);
        }
        static isIn(g, S, T) {
          if (!(g in S)) throw new Error(`Unknown ${T} value: ${g}.`);
        }
      }, c(Tl, "dh"), Tl);
      d(wt, "w");
      let it = wt;
      const At = (us = class {
        static get isBrowser() {
          return !us.isNode && typeof window == "object" && typeof window.document == "object";
        }
        static get isWebWorker() {
          return !us.isNode && typeof self == "object" && "importScripts" in self;
        }
        static get isReactNative() {
          return !us.isNode && typeof window == "object" && window.document === void 0;
        }
        static get isNode() {
          return typeof process < "u" && process.release && process.release.name === "node";
        }
      }, c(us, "Ar"), us);
      d(At, "g");
      let kt = At;
      function Zt(U, g) {
        let S = "";
        return Dt(U) ? (S = `Binary data of length ${U.byteLength}`, g && (S += `. Content: '${function(T) {
          const _ = new Uint8Array(T);
          let V = "";
          return _.forEach((W) => {
            V += `0x${W < 16 ? "0" : ""}${W.toString(16)} `;
          }), V.substr(0, V.length - 1);
        }(U)}'`)) : typeof U == "string" && (S = `String data of length ${U.length}`, g && (S += `. Content: '${U}'`)), S;
      }
      c(Zt, "B"), d(Zt, "m");
      function Dt(U) {
        return U && typeof ArrayBuffer < "u" && (U instanceof ArrayBuffer || U.constructor && U.constructor.name === "ArrayBuffer");
      }
      c(Dt, "S"), d(Dt, "y");
      async function Wt(U, g, S, T, _, V) {
        const W = {}, [at, ot] = ge();
        W[at] = ot, U.log(s.Trace, `(${g} transport) sending data. ${Zt(_, V.logMessageContent)}.`);
        const Mt = Dt(_) ? "arraybuffer" : "text", Ht = await S.post(T, { content: _, headers: { ...W, ...V.headers }, responseType: Mt, timeout: V.timeout, withCredentials: V.withCredentials });
        U.log(s.Trace, `(${g} transport) request complete. Response status: ${Ht.statusCode}.`);
      }
      c(Wt, "D"), d(Wt, "b");
      const Oi = (Al = class {
        constructor(g, S) {
          this.i = g, this.h = S;
        }
        dispose() {
          const g = this.i.observers.indexOf(this.h);
          g > -1 && this.i.observers.splice(g, 1), this.i.observers.length === 0 && this.i.cancelCallback && this.i.cancelCallback().catch((S) => {
          });
        }
      }, c(Al, "hh"), Al);
      d(Oi, "v");
      let _e = Oi;
      const pe = (Rl = class {
        constructor(g) {
          this.l = g, this.out = console;
        }
        log(g, S) {
          if (g >= this.l) {
            const T = `[${(/* @__PURE__ */ new Date()).toISOString()}] ${s[g]}: ${S}`;
            switch (g) {
              case s.Critical:
              case s.Error:
                this.out.error(T);
                break;
              case s.Warning:
                this.out.warn(T);
                break;
              case s.Information:
                this.out.info(T);
                break;
              default:
                this.out.log(T);
            }
          }
        }
      }, c(Rl, "uh"), Rl);
      d(pe, "E");
      let se = pe;
      function ge() {
        let U = "X-SignalR-User-Agent";
        return kt.isNode && (U = "User-Agent"), [U, $i(K, zi(), kt.isNode ? "NodeJS" : "Browser", Ni())];
      }
      c(ge, "Z"), d(ge, "$");
      function $i(U, g, S, T) {
        let _ = "Microsoft SignalR/";
        const V = U.split(".");
        return _ += `${V[0]}.${V[1]}`, _ += ` (${U}; `, _ += g && g !== "" ? `${g}; ` : "Unknown OS; ", _ += `${S}`, _ += T ? `; ${T}` : "; Unknown Runtime Version", _ += ")", _;
      }
      c($i, "Y"), d($i, "C");
      function zi() {
        if (!kt.isNode) return "";
        switch (process.platform) {
          case "win32":
            return "Windows NT";
          case "darwin":
            return "macOS";
          case "linux":
            return "Linux";
          default:
            return process.platform;
        }
      }
      c(zi, "Et"), d(zi, "S");
      function Ni() {
        if (kt.isNode) return process.versions.node;
      }
      c(Ni, "kt"), d(Ni, "k");
      function Nt(U) {
        return U.stack ? U.stack : U.message ? U.message : `${U}`;
      }
      c(Nt, "wt"), d(Nt, "P");
      const un = (El = class extends N {
        constructor(g) {
          if (super(), this.u = g, typeof fetch > "u" || kt.isNode) {
            const S = b1;
            this.p = new (S("tough-cookie")).CookieJar(), typeof fetch > "u" ? this.m = S("node-fetch") : this.m = fetch, this.m = S("fetch-cookie")(this.m, this.p);
          } else this.m = fetch.bind(function() {
            if (typeof globalThis < "u") return globalThis;
            if (typeof self < "u") return self;
            if (typeof window < "u") return window;
            if (i.g !== void 0) return i.g;
            throw new Error("could not find global");
          }());
          if (typeof AbortController > "u") {
            const S = b1;
            this.v = S("abort-controller");
          } else this.v = AbortController;
        }
        async send(g) {
          if (g.abortSignal && g.abortSignal.aborted) throw new p();
          if (!g.method) throw new Error("No method defined.");
          if (!g.url) throw new Error("No url defined.");
          const S = new this.v();
          let T;
          g.abortSignal && (g.abortSignal.onabort = () => {
            S.abort(), T = new p();
          });
          let _, V = null;
          if (g.timeout) {
            const ot = g.timeout;
            V = setTimeout(() => {
              S.abort(), this.u.log(s.Warning, "Timeout from HTTP request."), T = new h();
            }, ot);
          }
          g.content === "" && (g.content = void 0), g.content && (g.headers = g.headers || {}, Dt(g.content) ? g.headers["Content-Type"] = "application/octet-stream" : g.headers["Content-Type"] = "text/plain;charset=UTF-8");
          try {
            _ = await this.m(g.url, { body: g.content, cache: "no-cache", credentials: g.withCredentials === !0 ? "include" : "same-origin", headers: { "X-Requested-With": "XMLHttpRequest", ...g.headers }, method: g.method, mode: "cors", redirect: "follow", signal: S.signal });
          } catch (ot) {
            throw T || (this.u.log(s.Warning, `Error from HTTP request. ${ot}.`), ot);
          } finally {
            V && clearTimeout(V), g.abortSignal && (g.abortSignal.onabort = null);
          }
          if (!_.ok) {
            const ot = await gl(_, "text");
            throw new o(ot || _.statusText, _.status);
          }
          const W = gl(_, g.responseType), at = await W;
          return new Z(_.status, _.statusText, at);
        }
        getCookieString(g) {
          let S = "";
          return kt.isNode && this.p && this.p.getCookies(g, (T, _) => S = _.join("; ")), S;
        }
      }, c(El, "ph"), El);
      d(un, "T");
      let va = un;
      function gl(U, g) {
        let S;
        switch (g) {
          case "arraybuffer":
            S = U.arrayBuffer();
            break;
          case "text":
          default:
            S = U.text();
            break;
          case "blob":
          case "document":
          case "json":
            throw new Error(`${g} is not supported.`);
        }
        return S;
      }
      c(gl, "de"), d(gl, "I");
      const OC = (_l = class extends N {
        constructor(g) {
          super(), this.u = g;
        }
        send(g) {
          return g.abortSignal && g.abortSignal.aborted ? Promise.reject(new p()) : g.method ? g.url ? new Promise((S, T) => {
            const _ = new XMLHttpRequest();
            _.open(g.method, g.url, !0), _.withCredentials = g.withCredentials === void 0 || g.withCredentials, _.setRequestHeader("X-Requested-With", "XMLHttpRequest"), g.content === "" && (g.content = void 0), g.content && (Dt(g.content) ? _.setRequestHeader("Content-Type", "application/octet-stream") : _.setRequestHeader("Content-Type", "text/plain;charset=UTF-8"));
            const V = g.headers;
            V && Object.keys(V).forEach((W) => {
              _.setRequestHeader(W, V[W]);
            }), g.responseType && (_.responseType = g.responseType), g.abortSignal && (g.abortSignal.onabort = () => {
              _.abort(), T(new p());
            }), g.timeout && (_.timeout = g.timeout), _.onload = () => {
              g.abortSignal && (g.abortSignal.onabort = null), _.status >= 200 && _.status < 300 ? S(new Z(_.status, _.statusText, _.response || _.responseText)) : T(new o(_.response || _.responseText || _.statusText, _.status));
            }, _.onerror = () => {
              this.u.log(s.Warning, `Error from HTTP request. ${_.status}: ${_.statusText}.`), T(new o(_.statusText, _.status));
            }, _.ontimeout = () => {
              this.u.log(s.Warning, "Timeout from HTTP request."), T(new h());
            }, _.send(g.content);
          }) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."));
        }
      }, c(_l, "yh"), _l);
      d(OC, "_");
      let bZ = OC;
      const $C = (zl = class extends N {
        constructor(g) {
          if (super(), typeof fetch < "u" || kt.isNode) this.$ = new va(g);
          else {
            if (typeof XMLHttpRequest > "u") throw new Error("No usable HttpClient found.");
            this.$ = new bZ(g);
          }
        }
        send(g) {
          return g.abortSignal && g.abortSignal.aborted ? Promise.reject(new p()) : g.method ? g.url ? this.$.send(g) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."));
        }
        getCookieString(g) {
          return this.$.getCookieString(g);
        }
      }, c(zl, "wh"), zl);
      d($C, "H");
      let xC = $C;
      const kC = (ps = class {
        static write(g) {
          return `${g}${ps.RecordSeparator}`;
        }
        static parse(g) {
          if (g[g.length - 1] !== ps.RecordSeparator) throw new Error("Message is incomplete.");
          const S = g.split(ps.RecordSeparator);
          return S.pop(), S;
        }
      }, c(ps, "Er"), ps);
      d(kC, "D");
      let ds = kC;
      ds.RecordSeparatorCode = 30, ds.RecordSeparator = String.fromCharCode(ds.RecordSeparatorCode);
      const SC = (Ll = class {
        writeHandshakeRequest(g) {
          return ds.write(JSON.stringify(g));
        }
        parseHandshakeResponse(g) {
          let S, T;
          if (Dt(g)) {
            const W = new Uint8Array(g), at = W.indexOf(ds.RecordSeparatorCode);
            if (at === -1) throw new Error("Message is incomplete.");
            const ot = at + 1;
            S = String.fromCharCode.apply(null, Array.prototype.slice.call(W.slice(0, ot))), T = W.byteLength > ot ? W.slice(ot).buffer : null;
          } else {
            const W = g, at = W.indexOf(ds.RecordSeparator);
            if (at === -1) throw new Error("Message is incomplete.");
            const ot = at + 1;
            S = W.substring(0, ot), T = W.length > ot ? W.substring(ot) : null;
          }
          const _ = ds.parse(S), V = JSON.parse(_[0]);
          if (V.type) throw new Error("Expected a handshake response from the server.");
          return [T, V];
        }
      }, c(Ll, "fh"), Ll);
      d(SC, "R");
      let OZ = SC;
      var St, Kt;
      (function(U) {
        U[U.Invocation = 1] = "Invocation", U[U.StreamItem = 2] = "StreamItem", U[U.Completion = 3] = "Completion", U[U.StreamInvocation = 4] = "StreamInvocation", U[U.CancelInvocation = 5] = "CancelInvocation", U[U.Ping = 6] = "Ping", U[U.Close = 7] = "Close", U[U.Ack = 8] = "Ack", U[U.Sequence = 9] = "Sequence";
      })(St || (St = {}));
      const PC = (Il = class {
        constructor() {
          this.observers = [];
        }
        next(g) {
          for (const S of this.observers) S.next(g);
        }
        error(g) {
          for (const S of this.observers) S.error && S.error(g);
        }
        complete() {
          for (const g of this.observers) g.complete && g.complete();
        }
        subscribe(g) {
          return this.observers.push(g), new _e(this, g);
        }
      }, c(Il, "mh"), Il);
      d(PC, "U");
      let CC = PC;
      const QC = (Zl = class {
        constructor(g, S, T) {
          this.C = 1e5, this.S = [], this.k = 0, this.P = !1, this.T = 1, this.I = 0, this._ = 0, this.H = !1, this.D = g, this.R = S, this.C = T;
        }
        async A(g) {
          const S = this.D.writeMessage(g);
          let T = Promise.resolve();
          if (this.U(g)) {
            this.k++;
            let _ = /* @__PURE__ */ d(() => {
            }, "t"), V = /* @__PURE__ */ d(() => {
            }, "i");
            Dt(S) ? this._ += S.byteLength : this._ += S.length, this._ >= this.C && (T = new Promise((W, at) => {
              _ = W, V = at;
            })), this.S.push(new xZ(S, this.k, _, V));
          }
          try {
            this.H || await this.R.send(S);
          } catch {
            this.L();
          }
          await T;
        }
        N(g) {
          let S = -1;
          for (let T = 0; T < this.S.length; T++) {
            const _ = this.S[T];
            if (_.q <= g.sequenceId) S = T, Dt(_.M) ? this._ -= _.M.byteLength : this._ -= _.M.length, _.j();
            else {
              if (!(this._ < this.C)) break;
              _.j();
            }
          }
          S !== -1 && (this.S = this.S.slice(S + 1));
        }
        W(g) {
          if (this.P) return g.type === St.Sequence && (this.P = !1, !0);
          if (!this.U(g)) return !0;
          const S = this.T;
          return this.T++, S <= this.I ? (S === this.I && this.O(), !1) : (this.I = S, this.O(), !0);
        }
        F(g) {
          g.sequenceId > this.T ? this.R.stop(new Error("Sequence ID greater than amount of messages we've received.")) : this.T = g.sequenceId;
        }
        L() {
          this.H = !0, this.P = !0;
        }
        async B() {
          const g = this.S.length !== 0 ? this.S[0].q : this.k + 1;
          await this.R.send(this.D.writeMessage({ type: St.Sequence, sequenceId: g }));
          const S = this.S;
          for (const T of S) await this.R.send(T.M);
          this.H = !1;
        }
        X(g) {
          g != null || (g = new Error("Unable to reconnect to server."));
          for (const S of this.S) S.J(g);
        }
        U(g) {
          switch (g.type) {
            case St.Invocation:
            case St.StreamItem:
            case St.Completion:
            case St.StreamInvocation:
            case St.CancelInvocation:
              return !0;
            case St.Close:
            case St.Sequence:
            case St.Ping:
            case St.Ack:
              return !1;
          }
        }
        O() {
          this.V === void 0 && (this.V = setTimeout(async () => {
            try {
              this.H || await this.R.send(this.D.writeMessage({ type: St.Ack, sequenceId: this.I }));
            } catch {
            }
            clearTimeout(this.V), this.V = void 0;
          }, 1e3));
        }
      }, c(Zl, "vh"), Zl);
      d(QC, "L");
      let $Z = QC;
      const MC = (Vl = class {
        constructor(g, S, T, _) {
          this.M = g, this.q = S, this.j = T, this.J = _;
        }
      }, c(Vl, "gh"), Vl);
      d(MC, "N");
      let xZ = MC;
      (function(U) {
        U.Disconnected = "Disconnected", U.Connecting = "Connecting", U.Connected = "Connected", U.Disconnecting = "Disconnecting", U.Reconnecting = "Reconnecting";
      })(Kt || (Kt = {}));
      const TC = (Oa = class {
        static create(g, S, T, _, V, W, at) {
          return new Oa(g, S, T, _, V, W, at);
        }
        constructor(g, S, T, _, V, W, at) {
          this.K = 0, this.G = () => {
            this.u.log(s.Warning, "The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep");
          }, it.isRequired(g, "connection"), it.isRequired(S, "logger"), it.isRequired(T, "protocol"), this.serverTimeoutInMilliseconds = V ?? 3e4, this.keepAliveIntervalInMilliseconds = W ?? 15e3, this.Y = at ?? 1e5, this.u = S, this.D = T, this.connection = g, this.Z = _, this.tt = new OZ(), this.connection.onreceive = (ot) => this.et(ot), this.connection.onclose = (ot) => this.st(ot), this.it = {}, this.nt = {}, this.rt = [], this.ot = [], this.ht = [], this.ct = 0, this.lt = !1, this.ut = Kt.Disconnected, this.dt = !1, this.ft = this.D.writeMessage({ type: St.Ping });
        }
        get state() {
          return this.ut;
        }
        get connectionId() {
          return this.connection && this.connection.connectionId || null;
        }
        get baseUrl() {
          return this.connection.baseUrl || "";
        }
        set baseUrl(g) {
          if (this.ut !== Kt.Disconnected && this.ut !== Kt.Reconnecting) throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");
          if (!g) throw new Error("The HubConnection url must be a valid url.");
          this.connection.baseUrl = g;
        }
        start() {
          return this.wt = this.gt(), this.wt;
        }
        async gt() {
          if (this.ut !== Kt.Disconnected) return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));
          this.ut = Kt.Connecting, this.u.log(s.Debug, "Starting HubConnection.");
          try {
            await this.yt(), kt.isBrowser && window.document.addEventListener("freeze", this.G), this.ut = Kt.Connected, this.dt = !0, this.u.log(s.Debug, "HubConnection connected successfully.");
          } catch (g) {
            return this.ut = Kt.Disconnected, this.u.log(s.Debug, `HubConnection failed to start successfully because of error '${g}'.`), Promise.reject(g);
          }
        }
        async yt() {
          this.bt = void 0, this.lt = !1;
          const g = new Promise((S, T) => {
            this.vt = S, this.Et = T;
          });
          await this.connection.start(this.D.transferFormat);
          try {
            let S = this.D.version;
            this.connection.features.reconnect || (S = 1);
            const T = { protocol: this.D.name, version: S };
            if (this.u.log(s.Debug, "Sending handshake request."), await this.$t(this.tt.writeHandshakeRequest(T)), this.u.log(s.Information, `Using HubProtocol '${this.D.name}'.`), this.Ct(), this.St(), this.kt(), await g, this.bt) throw this.bt;
            this.connection.features.reconnect && (this.Pt = new $Z(this.D, this.connection, this.Y), this.connection.features.disconnected = this.Pt.L.bind(this.Pt), this.connection.features.resend = () => {
              if (this.Pt) return this.Pt.B();
            }), this.connection.features.inherentKeepAlive || await this.$t(this.ft);
          } catch (S) {
            throw this.u.log(s.Debug, `Hub handshake failed with error '${S}' during start(). Stopping HubConnection.`), this.Ct(), this.Tt(), await this.connection.stop(S), S;
          }
        }
        async stop() {
          const g = this.wt;
          this.connection.features.reconnect = !1, this.It = this._t(), await this.It;
          try {
            await g;
          } catch {
          }
        }
        _t(g) {
          if (this.ut === Kt.Disconnected) return this.u.log(s.Debug, `Call to HubConnection.stop(${g}) ignored because it is already in the disconnected state.`), Promise.resolve();
          if (this.ut === Kt.Disconnecting) return this.u.log(s.Debug, `Call to HttpConnection.stop(${g}) ignored because the connection is already in the disconnecting state.`), this.It;
          const S = this.ut;
          return this.ut = Kt.Disconnecting, this.u.log(s.Debug, "Stopping HubConnection."), this.Ht ? (this.u.log(s.Debug, "Connection stopped during reconnect delay. Done reconnecting."), clearTimeout(this.Ht), this.Ht = void 0, this.Dt(), Promise.resolve()) : (S === Kt.Connected && this.Rt(), this.Ct(), this.Tt(), this.bt = g || new p("The connection was stopped before the hub handshake could complete."), this.connection.stop(g));
        }
        async Rt() {
          try {
            await this.xt(this.At());
          } catch {
          }
        }
        stream(g, ...S) {
          const [T, _] = this.Ut(S), V = this.Lt(g, S, _);
          let W;
          const at = new CC();
          return at.cancelCallback = () => {
            const ot = this.Nt(V.invocationId);
            return delete this.it[V.invocationId], W.then(() => this.xt(ot));
          }, this.it[V.invocationId] = (ot, Mt) => {
            Mt ? at.error(Mt) : ot && (ot.type === St.Completion ? ot.error ? at.error(new Error(ot.error)) : at.complete() : at.next(ot.item));
          }, W = this.xt(V).catch((ot) => {
            at.error(ot), delete this.it[V.invocationId];
          }), this.qt(T, W), at;
        }
        $t(g) {
          return this.kt(), this.connection.send(g);
        }
        xt(g) {
          return this.Pt ? this.Pt.A(g) : this.$t(this.D.writeMessage(g));
        }
        send(g, ...S) {
          const [T, _] = this.Ut(S), V = this.xt(this.Mt(g, S, !0, _));
          return this.qt(T, V), V;
        }
        invoke(g, ...S) {
          const [T, _] = this.Ut(S), V = this.Mt(g, S, !1, _);
          return new Promise((W, at) => {
            this.it[V.invocationId] = (Mt, Ht) => {
              Ht ? at(Ht) : Mt && (Mt.type === St.Completion ? Mt.error ? at(new Error(Mt.error)) : W(Mt.result) : at(new Error(`Unexpected message type: ${Mt.type}`)));
            };
            const ot = this.xt(V).catch((Mt) => {
              at(Mt), delete this.it[V.invocationId];
            });
            this.qt(T, ot);
          });
        }
        on(g, S) {
          g && S && (g = g.toLowerCase(), this.nt[g] || (this.nt[g] = []), this.nt[g].indexOf(S) === -1 && this.nt[g].push(S));
        }
        off(g, S) {
          if (!g) return;
          g = g.toLowerCase();
          const T = this.nt[g];
          if (T) if (S) {
            const _ = T.indexOf(S);
            _ !== -1 && (T.splice(_, 1), T.length === 0 && delete this.nt[g]);
          } else delete this.nt[g];
        }
        onclose(g) {
          g && this.rt.push(g);
        }
        onreconnecting(g) {
          g && this.ot.push(g);
        }
        onreconnected(g) {
          g && this.ht.push(g);
        }
        et(g) {
          if (this.Ct(), this.lt || (g = this.jt(g), this.lt = !0), g) {
            const S = this.D.parseMessages(g, this.u);
            for (const T of S) if (!this.Pt || this.Pt.W(T)) switch (T.type) {
              case St.Invocation:
                this.Wt(T).catch((_) => {
                  this.u.log(s.Error, `Invoke client method threw error: ${Nt(_)}`);
                });
                break;
              case St.StreamItem:
              case St.Completion: {
                const _ = this.it[T.invocationId];
                if (_) {
                  T.type === St.Completion && delete this.it[T.invocationId];
                  try {
                    _(T);
                  } catch (V) {
                    this.u.log(s.Error, `Stream callback threw error: ${Nt(V)}`);
                  }
                }
                break;
              }
              case St.Ping:
                break;
              case St.Close: {
                this.u.log(s.Information, "Close message received from server.");
                const _ = T.error ? new Error("Server returned an error on close: " + T.error) : void 0;
                T.allowReconnect === !0 ? this.connection.stop(_) : this.It = this._t(_);
                break;
              }
              case St.Ack:
                this.Pt && this.Pt.N(T);
                break;
              case St.Sequence:
                this.Pt && this.Pt.F(T);
                break;
              default:
                this.u.log(s.Warning, `Invalid message type: ${T.type}.`);
            }
          }
          this.St();
        }
        jt(g) {
          let S, T;
          try {
            [T, S] = this.tt.parseHandshakeResponse(g);
          } catch (_) {
            const V = "Error parsing handshake response: " + _;
            this.u.log(s.Error, V);
            const W = new Error(V);
            throw this.Et(W), W;
          }
          if (S.error) {
            const _ = "Server returned handshake error: " + S.error;
            this.u.log(s.Error, _);
            const V = new Error(_);
            throw this.Et(V), V;
          }
          return this.u.log(s.Debug, "Server handshake complete."), this.vt(), T;
        }
        kt() {
          this.connection.features.inherentKeepAlive || (this.K = (/* @__PURE__ */ new Date()).getTime() + this.keepAliveIntervalInMilliseconds, this.Tt());
        }
        St() {
          if (!(this.connection.features && this.connection.features.inherentKeepAlive || (this.Ot = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds), this.Ft !== void 0))) {
            let g = this.K - (/* @__PURE__ */ new Date()).getTime();
            g < 0 && (g = 0), this.Ft = setTimeout(async () => {
              if (this.ut === Kt.Connected) try {
                await this.$t(this.ft);
              } catch {
                this.Tt();
              }
            }, g);
          }
        }
        serverTimeout() {
          this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."));
        }
        async Wt(g) {
          const S = g.target.toLowerCase(), T = this.nt[S];
          if (!T) return this.u.log(s.Warning, `No client method with the name '${S}' found.`), void (g.invocationId && (this.u.log(s.Warning, `No result given for '${S}' method and invocation ID '${g.invocationId}'.`), await this.xt(this.Bt(g.invocationId, "Client didn't provide a result.", null))));
          const _ = T.slice(), V = !!g.invocationId;
          let W, at, ot;
          for (const Mt of _) try {
            const Ht = W;
            W = await Mt.apply(this, g.arguments), V && W && Ht && (this.u.log(s.Error, `Multiple results provided for '${S}'. Sending error to server.`), ot = this.Bt(g.invocationId, "Client provided multiple results.", null)), at = void 0;
          } catch (Ht) {
            at = Ht, this.u.log(s.Error, `A callback for the method '${S}' threw error '${Ht}'.`);
          }
          ot ? await this.xt(ot) : V ? (at ? ot = this.Bt(g.invocationId, `${at}`, null) : W !== void 0 ? ot = this.Bt(g.invocationId, null, W) : (this.u.log(s.Warning, `No result given for '${S}' method and invocation ID '${g.invocationId}'.`), ot = this.Bt(g.invocationId, "Client didn't provide a result.", null)), await this.xt(ot)) : W && this.u.log(s.Error, `Result given for '${S}' method but server is not expecting a result.`);
        }
        st(g) {
          this.u.log(s.Debug, `HubConnection.connectionClosed(${g}) called while in state ${this.ut}.`), this.bt = this.bt || g || new p("The underlying connection was closed before the hub handshake could complete."), this.vt && this.vt(), this.Xt(g || new Error("Invocation canceled due to the underlying connection being closed.")), this.Ct(), this.Tt(), this.ut === Kt.Disconnecting ? this.Dt(g) : this.ut === Kt.Connected && this.Z ? this.Jt(g) : this.ut === Kt.Connected && this.Dt(g);
        }
        Dt(g) {
          if (this.dt) {
            this.ut = Kt.Disconnected, this.dt = !1, this.Pt && (this.Pt.X(g ?? new Error("Connection closed.")), this.Pt = void 0), kt.isBrowser && window.document.removeEventListener("freeze", this.G);
            try {
              this.rt.forEach((S) => S.apply(this, [g]));
            } catch (S) {
              this.u.log(s.Error, `An onclose callback called with error '${g}' threw error '${S}'.`);
            }
          }
        }
        async Jt(g) {
          const S = Date.now();
          let T = 0, _ = g !== void 0 ? g : new Error("Attempting to reconnect due to a unknown error."), V = this.zt(T++, 0, _);
          if (V === null) return this.u.log(s.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."), void this.Dt(g);
          if (this.ut = Kt.Reconnecting, g ? this.u.log(s.Information, `Connection reconnecting because of error '${g}'.`) : this.u.log(s.Information, "Connection reconnecting."), this.ot.length !== 0) {
            try {
              this.ot.forEach((W) => W.apply(this, [g]));
            } catch (W) {
              this.u.log(s.Error, `An onreconnecting callback called with error '${g}' threw error '${W}'.`);
            }
            if (this.ut !== Kt.Reconnecting) return void this.u.log(s.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.");
          }
          for (; V !== null; ) {
            if (this.u.log(s.Information, `Reconnect attempt number ${T} will start in ${V} ms.`), await new Promise((W) => {
              this.Ht = setTimeout(W, V);
            }), this.Ht = void 0, this.ut !== Kt.Reconnecting) return void this.u.log(s.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting.");
            try {
              if (await this.yt(), this.ut = Kt.Connected, this.u.log(s.Information, "HubConnection reconnected successfully."), this.ht.length !== 0) try {
                this.ht.forEach((W) => W.apply(this, [this.connection.connectionId]));
              } catch (W) {
                this.u.log(s.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${W}'.`);
              }
              return;
            } catch (W) {
              if (this.u.log(s.Information, `Reconnect attempt failed because of error '${W}'.`), this.ut !== Kt.Reconnecting) return this.u.log(s.Debug, `Connection moved to the '${this.ut}' from the reconnecting state during reconnect attempt. Done reconnecting.`), void (this.ut === Kt.Disconnecting && this.Dt());
              _ = W instanceof Error ? W : new Error(W.toString()), V = this.zt(T++, Date.now() - S, _);
            }
          }
          this.u.log(s.Information, `Reconnect retries have been exhausted after ${Date.now() - S} ms and ${T} failed attempts. Connection disconnecting.`), this.Dt();
        }
        zt(g, S, T) {
          try {
            return this.Z.nextRetryDelayInMilliseconds({ elapsedMilliseconds: S, previousRetryCount: g, retryReason: T });
          } catch (_) {
            return this.u.log(s.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${g}, ${S}) threw error '${_}'.`), null;
          }
        }
        Xt(g) {
          const S = this.it;
          this.it = {}, Object.keys(S).forEach((T) => {
            const _ = S[T];
            try {
              _(null, g);
            } catch (V) {
              this.u.log(s.Error, `Stream 'error' callback called with '${g}' threw error: ${Nt(V)}`);
            }
          });
        }
        Tt() {
          this.Ft && (clearTimeout(this.Ft), this.Ft = void 0);
        }
        Ct() {
          this.Ot && clearTimeout(this.Ot);
        }
        Mt(g, S, T, _) {
          if (T) return _.length !== 0 ? { target: g, arguments: S, streamIds: _, type: St.Invocation } : { target: g, arguments: S, type: St.Invocation };
          {
            const V = this.ct;
            return this.ct++, _.length !== 0 ? { target: g, arguments: S, invocationId: V.toString(), streamIds: _, type: St.Invocation } : { target: g, arguments: S, invocationId: V.toString(), type: St.Invocation };
          }
        }
        qt(g, S) {
          if (g.length !== 0) {
            S || (S = Promise.resolve());
            for (const T in g) g[T].subscribe({ complete: /* @__PURE__ */ d(() => {
              S = S.then(() => this.xt(this.Bt(T)));
            }, "complete"), error: /* @__PURE__ */ d((_) => {
              let V;
              V = _ instanceof Error ? _.message : _ && _.toString ? _.toString() : "Unknown error", S = S.then(() => this.xt(this.Bt(T, V)));
            }, "error"), next: /* @__PURE__ */ d((_) => {
              S = S.then(() => this.xt(this.Vt(T, _)));
            }, "next") });
          }
        }
        Ut(g) {
          const S = [], T = [];
          for (let _ = 0; _ < g.length; _++) {
            const V = g[_];
            if (this.Kt(V)) {
              const W = this.ct;
              this.ct++, S[W] = V, T.push(W.toString()), g.splice(_, 1);
            }
          }
          return [S, T];
        }
        Kt(g) {
          return g && g.subscribe && typeof g.subscribe == "function";
        }
        Lt(g, S, T) {
          const _ = this.ct;
          return this.ct++, T.length !== 0 ? { target: g, arguments: S, invocationId: _.toString(), streamIds: T, type: St.StreamInvocation } : { target: g, arguments: S, invocationId: _.toString(), type: St.StreamInvocation };
        }
        Nt(g) {
          return { invocationId: g, type: St.CancelInvocation };
        }
        Vt(g, S) {
          return { invocationId: g, item: S, type: St.StreamItem };
        }
        Bt(g, S, T) {
          return S ? { error: S, invocationId: g, type: St.Completion } : { invocationId: g, result: T, type: St.Completion };
        }
        At() {
          return { type: St.Close };
        }
      }, c(Oa, "Sl"), Oa);
      d(TC, "q");
      let AC = TC;
      const kZ = [0, 2e3, 1e4, 3e4, null], RC = (Dl = class {
        constructor(g) {
          this.Gt = g !== void 0 ? [...g, null] : kZ;
        }
        nextRetryDelayInMilliseconds(g) {
          return this.Gt[g.previousRetryCount];
        }
      }, c(Dl, "bh"), Dl);
      d(RC, "j");
      let EC = RC;
      const _C = (Wl = class {
      }, c(Wl, "xh"), Wl);
      d(_C, "W");
      let ba = _C;
      ba.Authorization = "Authorization", ba.Cookie = "Cookie";
      const zC = (ql = class extends N {
        constructor(g, S) {
          super(), this.Qt = g, this.Yt = S;
        }
        async send(g) {
          let S = !0;
          this.Yt && (!this.Zt || g.url && g.url.indexOf("/negotiate?") > 0) && (S = !1, this.Zt = await this.Yt()), this.te(g);
          const T = await this.Qt.send(g);
          return S && T.statusCode === 401 && this.Yt ? (this.Zt = await this.Yt(), this.te(g), await this.Qt.send(g)) : T;
        }
        te(g) {
          g.headers || (g.headers = {}), this.Zt ? g.headers[ba.Authorization] = `Bearer ${this.Zt}` : this.Yt && g.headers[ba.Authorization] && delete g.headers[ba.Authorization];
        }
        getCookieString(g) {
          return this.Qt.getCookieString(g);
        }
      }, c(ql, "$h"), ql);
      d(zC, "O");
      let SZ = zC;
      var Pe, Xe;
      (function(U) {
        U[U.None = 0] = "None", U[U.WebSockets = 1] = "WebSockets", U[U.ServerSentEvents = 2] = "ServerSentEvents", U[U.LongPolling = 4] = "LongPolling";
      })(Pe || (Pe = {})), function(U) {
        U[U.Text = 1] = "Text", U[U.Binary = 2] = "Binary";
      }(Xe || (Xe = {}));
      const LC = (jl = class {
        constructor() {
          this.ee = !1, this.onabort = null;
        }
        abort() {
          this.ee || (this.ee = !0, this.onabort && this.onabort());
        }
        get signal() {
          return this;
        }
        get aborted() {
          return this.ee;
        }
      }, c(jl, "Ch"), jl);
      d(LC, "X");
      let PZ = LC;
      const IC = (Fl = class {
        get pollAborted() {
          return this.se.aborted;
        }
        constructor(g, S, T) {
          this.$ = g, this.u = S, this.se = new PZ(), this.ie = T, this.ne = !1, this.onreceive = null, this.onclose = null;
        }
        async connect(g, S) {
          if (it.isRequired(g, "url"), it.isRequired(S, "transferFormat"), it.isIn(S, Xe, "transferFormat"), this.re = g, this.u.log(s.Trace, "(LongPolling transport) Connecting."), S === Xe.Binary && typeof XMLHttpRequest < "u" && typeof new XMLHttpRequest().responseType != "string") throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");
          const [T, _] = ge(), V = { [T]: _, ...this.ie.headers }, W = { abortSignal: this.se.signal, headers: V, timeout: 1e5, withCredentials: this.ie.withCredentials };
          S === Xe.Binary && (W.responseType = "arraybuffer");
          const at = `${g}&_=${Date.now()}`;
          this.u.log(s.Trace, `(LongPolling transport) polling: ${at}.`);
          const ot = await this.$.get(at, W);
          ot.statusCode !== 200 ? (this.u.log(s.Error, `(LongPolling transport) Unexpected response code: ${ot.statusCode}.`), this.oe = new o(ot.statusText || "", ot.statusCode), this.ne = !1) : this.ne = !0, this.he = this.ce(this.re, W);
        }
        async ce(g, S) {
          try {
            for (; this.ne; ) try {
              const T = `${g}&_=${Date.now()}`;
              this.u.log(s.Trace, `(LongPolling transport) polling: ${T}.`);
              const _ = await this.$.get(T, S);
              _.statusCode === 204 ? (this.u.log(s.Information, "(LongPolling transport) Poll terminated by server."), this.ne = !1) : _.statusCode !== 200 ? (this.u.log(s.Error, `(LongPolling transport) Unexpected response code: ${_.statusCode}.`), this.oe = new o(_.statusText || "", _.statusCode), this.ne = !1) : _.content ? (this.u.log(s.Trace, `(LongPolling transport) data received. ${Zt(_.content, this.ie.logMessageContent)}.`), this.onreceive && this.onreceive(_.content)) : this.u.log(s.Trace, "(LongPolling transport) Poll timed out, reissuing.");
            } catch (T) {
              this.ne ? T instanceof h ? this.u.log(s.Trace, "(LongPolling transport) Poll timed out, reissuing.") : (this.oe = T, this.ne = !1) : this.u.log(s.Trace, `(LongPolling transport) Poll errored after shutdown: ${T.message}`);
            }
          } finally {
            this.u.log(s.Trace, "(LongPolling transport) Polling complete."), this.pollAborted || this.ae();
          }
        }
        async send(g) {
          return this.ne ? Wt(this.u, "LongPolling", this.$, this.re, g, this.ie) : Promise.reject(new Error("Cannot send until the transport is connected"));
        }
        async stop() {
          this.u.log(s.Trace, "(LongPolling transport) Stopping polling."), this.ne = !1, this.se.abort();
          try {
            await this.he, this.u.log(s.Trace, `(LongPolling transport) sending DELETE request to ${this.re}.`);
            const g = {}, [S, T] = ge();
            g[S] = T;
            const _ = { headers: { ...g, ...this.ie.headers }, timeout: this.ie.timeout, withCredentials: this.ie.withCredentials };
            let V;
            try {
              await this.$.delete(this.re, _);
            } catch (W) {
              V = W;
            }
            V ? V instanceof o && (V.statusCode === 404 ? this.u.log(s.Trace, "(LongPolling transport) A 404 response was returned from sending a DELETE request.") : this.u.log(s.Trace, `(LongPolling transport) Error sending a DELETE request: ${V}`)) : this.u.log(s.Trace, "(LongPolling transport) DELETE request accepted.");
          } finally {
            this.u.log(s.Trace, "(LongPolling transport) Stop finished."), this.ae();
          }
        }
        ae() {
          if (this.onclose) {
            let g = "(LongPolling transport) Firing onclose event.";
            this.oe && (g += " Error: " + this.oe), this.u.log(s.Trace, g), this.onclose(this.oe);
          }
        }
      }, c(Fl, "kh"), Fl);
      d(IC, "J");
      let ZC = IC;
      const VC = (Ul = class {
        constructor(g, S, T, _) {
          this.$ = g, this.Zt = S, this.u = T, this.ie = _, this.onreceive = null, this.onclose = null;
        }
        async connect(g, S) {
          return it.isRequired(g, "url"), it.isRequired(S, "transferFormat"), it.isIn(S, Xe, "transferFormat"), this.u.log(s.Trace, "(SSE transport) Connecting."), this.re = g, this.Zt && (g += (g.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(this.Zt)}`), new Promise((T, _) => {
            let V, W = !1;
            if (S === Xe.Text) {
              if (kt.isBrowser || kt.isWebWorker) V = new this.ie.EventSource(g, { withCredentials: this.ie.withCredentials });
              else {
                const at = this.$.getCookieString(g), ot = {};
                ot.Cookie = at;
                const [Mt, Ht] = ge();
                ot[Mt] = Ht, V = new this.ie.EventSource(g, { withCredentials: this.ie.withCredentials, headers: { ...ot, ...this.ie.headers } });
              }
              try {
                V.onmessage = (at) => {
                  if (this.onreceive) try {
                    this.u.log(s.Trace, `(SSE transport) data received. ${Zt(at.data, this.ie.logMessageContent)}.`), this.onreceive(at.data);
                  } catch (ot) {
                    return void this.le(ot);
                  }
                }, V.onerror = (at) => {
                  W ? this.le() : _(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled."));
                }, V.onopen = () => {
                  this.u.log(s.Information, `SSE connected to ${this.re}`), this.ue = V, W = !0, T();
                };
              } catch (at) {
                return void _(at);
              }
            } else _(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));
          });
        }
        async send(g) {
          return this.ue ? Wt(this.u, "SSE", this.$, this.re, g, this.ie) : Promise.reject(new Error("Cannot send until the transport is connected"));
        }
        stop() {
          return this.le(), Promise.resolve();
        }
        le(g) {
          this.ue && (this.ue.close(), this.ue = void 0, this.onclose && this.onclose(g));
        }
      }, c(Ul, "_h"), Ul);
      d(VC, "z");
      let CZ = VC;
      const DC = (Bl = class {
        constructor(g, S, T, _, V, W) {
          this.u = T, this.Yt = S, this.de = _, this.fe = V, this.$ = g, this.onreceive = null, this.onclose = null, this.pe = W;
        }
        async connect(g, S) {
          let T;
          return it.isRequired(g, "url"), it.isRequired(S, "transferFormat"), it.isIn(S, Xe, "transferFormat"), this.u.log(s.Trace, "(WebSockets transport) Connecting."), this.Yt && (T = await this.Yt()), new Promise((_, V) => {
            let W;
            g = g.replace(/^http/, "ws");
            const at = this.$.getCookieString(g);
            let ot = !1;
            if (kt.isNode || kt.isReactNative) {
              const Mt = {}, [Ht, Gl] = ge();
              Mt[Ht] = Gl, T && (Mt[ba.Authorization] = `Bearer ${T}`), at && (Mt[ba.Cookie] = at), W = new this.fe(g, void 0, { headers: { ...Mt, ...this.pe } });
            } else T && (g += (g.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(T)}`);
            W || (W = new this.fe(g)), S === Xe.Binary && (W.binaryType = "arraybuffer"), W.onopen = (Mt) => {
              this.u.log(s.Information, `WebSocket connected to ${g}.`), this.we = W, ot = !0, _();
            }, W.onerror = (Mt) => {
              let Ht = null;
              Ht = typeof ErrorEvent < "u" && Mt instanceof ErrorEvent ? Mt.error : "There was an error with the transport", this.u.log(s.Information, `(WebSockets transport) ${Ht}.`);
            }, W.onmessage = (Mt) => {
              if (this.u.log(s.Trace, `(WebSockets transport) data received. ${Zt(Mt.data, this.de)}.`), this.onreceive) try {
                this.onreceive(Mt.data);
              } catch (Ht) {
                return void this.le(Ht);
              }
            }, W.onclose = (Mt) => {
              if (ot) this.le(Mt);
              else {
                let Ht = null;
                Ht = typeof ErrorEvent < "u" && Mt instanceof ErrorEvent ? Mt.error : "WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.", V(new Error(Ht));
              }
            };
          });
        }
        send(g) {
          return this.we && this.we.readyState === this.fe.OPEN ? (this.u.log(s.Trace, `(WebSockets transport) sending data. ${Zt(g, this.de)}.`), this.we.send(g), Promise.resolve()) : Promise.reject("WebSocket is not in the OPEN state");
        }
        stop() {
          return this.we && this.le(void 0), Promise.resolve();
        }
        le(g) {
          this.we && (this.we.onclose = () => {
          }, this.we.onmessage = () => {
          }, this.we.onerror = () => {
          }, this.we.close(), this.we = void 0), this.u.log(s.Trace, "(WebSockets transport) socket closed."), this.onclose && (!this.ge(g) || g.wasClean !== !1 && g.code === 1e3 ? g instanceof Error ? this.onclose(g) : this.onclose() : this.onclose(new Error(`WebSocket closed with status code: ${g.code} (${g.reason || "no reason given"}).`)));
        }
        ge(g) {
          return g && typeof g.wasClean == "boolean" && typeof g.code == "number";
        }
      }, c(Bl, "Mh"), Bl);
      d(DC, "V");
      let QZ = DC;
      const WC = (Xl = class {
        constructor(g, S = {}) {
          var T;
          if (this.me = () => {
          }, this.features = {}, this.ye = 1, it.isRequired(g, "url"), this.u = (T = S.logger) === void 0 ? new se(s.Information) : T === null ? ct.instance : T.log !== void 0 ? T : new se(T), this.baseUrl = this.be(g), (S = S || {}).logMessageContent = S.logMessageContent !== void 0 && S.logMessageContent, typeof S.withCredentials != "boolean" && S.withCredentials !== void 0) throw new Error("withCredentials option was not a 'boolean' or 'undefined' value");
          S.withCredentials = S.withCredentials === void 0 || S.withCredentials, S.timeout = S.timeout === void 0 ? 1e5 : S.timeout;
          let _ = null, V = null;
          if (kt.isNode) {
            const W = b1;
            _ = W("ws"), V = W("eventsource");
          }
          kt.isNode || typeof WebSocket > "u" || S.WebSocket ? kt.isNode && !S.WebSocket && _ && (S.WebSocket = _) : S.WebSocket = WebSocket, kt.isNode || typeof EventSource > "u" || S.EventSource ? kt.isNode && !S.EventSource && V !== void 0 && (S.EventSource = V) : S.EventSource = EventSource, this.$ = new SZ(S.httpClient || new xC(this.u), S.accessTokenFactory), this.ut = "Disconnected", this.dt = !1, this.ie = S, this.onreceive = null, this.onclose = null;
        }
        async start(g) {
          if (g = g || Xe.Binary, it.isIn(g, Xe, "transferFormat"), this.u.log(s.Debug, `Starting connection with transfer format '${Xe[g]}'.`), this.ut !== "Disconnected") return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."));
          if (this.ut = "Connecting", this.ve = this.yt(g), await this.ve, this.ut === "Disconnecting") {
            const S = "Failed to start the HttpConnection before stop() was called.";
            return this.u.log(s.Error, S), await this.It, Promise.reject(new p(S));
          }
          if (this.ut !== "Connected") {
            const S = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";
            return this.u.log(s.Error, S), Promise.reject(new p(S));
          }
          this.dt = !0;
        }
        send(g) {
          return this.ut !== "Connected" ? Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State.")) : (this.Ee || (this.Ee = new TZ(this.transport)), this.Ee.send(g));
        }
        async stop(g) {
          return this.ut === "Disconnected" ? (this.u.log(s.Debug, `Call to HttpConnection.stop(${g}) ignored because the connection is already in the disconnected state.`), Promise.resolve()) : this.ut === "Disconnecting" ? (this.u.log(s.Debug, `Call to HttpConnection.stop(${g}) ignored because the connection is already in the disconnecting state.`), this.It) : (this.ut = "Disconnecting", this.It = new Promise((S) => {
            this.me = S;
          }), await this._t(g), void await this.It);
        }
        async _t(g) {
          this.$e = g;
          try {
            await this.ve;
          } catch {
          }
          if (this.transport) {
            try {
              await this.transport.stop();
            } catch (S) {
              this.u.log(s.Error, `HttpConnection.transport.stop() threw error '${S}'.`), this.Ce();
            }
            this.transport = void 0;
          } else this.u.log(s.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.");
        }
        async yt(g) {
          let S = this.baseUrl;
          this.Yt = this.ie.accessTokenFactory, this.$.Yt = this.Yt;
          try {
            if (this.ie.skipNegotiation) {
              if (this.ie.transport !== Pe.WebSockets) throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");
              this.transport = this.Se(Pe.WebSockets), await this.ke(S, g);
            } else {
              let T = null, _ = 0;
              do {
                if (T = await this.Pe(S), this.ut === "Disconnecting" || this.ut === "Disconnected") throw new p("The connection was stopped during negotiation.");
                if (T.error) throw new Error(T.error);
                if (T.ProtocolVersion) throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");
                if (T.url && (S = T.url), T.accessToken) {
                  const V = T.accessToken;
                  this.Yt = () => V, this.$.Zt = V, this.$.Yt = void 0;
                }
                _++;
              } while (T.url && _ < 100);
              if (_ === 100 && T.url) throw new Error("Negotiate redirection limit exceeded.");
              await this.Te(S, this.ie.transport, T, g);
            }
            this.transport instanceof ZC && (this.features.inherentKeepAlive = !0), this.ut === "Connecting" && (this.u.log(s.Debug, "The HttpConnection connected successfully."), this.ut = "Connected");
          } catch (T) {
            return this.u.log(s.Error, "Failed to start the connection: " + T), this.ut = "Disconnected", this.transport = void 0, this.me(), Promise.reject(T);
          }
        }
        async Pe(g) {
          const S = {}, [T, _] = ge();
          S[T] = _;
          const V = this.Ie(g);
          this.u.log(s.Debug, `Sending negotiation request: ${V}.`);
          try {
            const W = await this.$.post(V, { content: "", headers: { ...S, ...this.ie.headers }, timeout: this.ie.timeout, withCredentials: this.ie.withCredentials });
            if (W.statusCode !== 200) return Promise.reject(new Error(`Unexpected status code returned from negotiate '${W.statusCode}'`));
            const at = JSON.parse(W.content);
            return (!at.negotiateVersion || at.negotiateVersion < 1) && (at.connectionToken = at.connectionId), at.useStatefulReconnect && this.ie._e !== !0 ? Promise.reject(new R("Client didn't negotiate Stateful Reconnect but the server did.")) : at;
          } catch (W) {
            let at = "Failed to complete negotiation with the server: " + W;
            return W instanceof o && W.statusCode === 404 && (at += " Either this is not a SignalR endpoint or there is a proxy blocking the connection."), this.u.log(s.Error, at), Promise.reject(new R(at));
          }
        }
        He(g, S) {
          return S ? g + (g.indexOf("?") === -1 ? "?" : "&") + `id=${S}` : g;
        }
        async Te(g, S, T, _) {
          let V = this.He(g, T.connectionToken);
          if (this.De(S)) return this.u.log(s.Debug, "Connection was provided an instance of ITransport, using that directly."), this.transport = S, await this.ke(V, _), void (this.connectionId = T.connectionId);
          const W = [], at = T.availableTransports || [];
          let ot = T;
          for (const Mt of at) {
            const Ht = this.Re(Mt, S, _, ot?.useStatefulReconnect === !0);
            if (Ht instanceof Error) W.push(`${Mt.transport} failed:`), W.push(Ht);
            else if (this.De(Ht)) {
              if (this.transport = Ht, !ot) {
                try {
                  ot = await this.Pe(g);
                } catch (Gl) {
                  return Promise.reject(Gl);
                }
                V = this.He(g, ot.connectionToken);
              }
              try {
                return await this.ke(V, _), void (this.connectionId = ot.connectionId);
              } catch (Gl) {
                if (this.u.log(s.Error, `Failed to start the transport '${Mt.transport}': ${Gl}`), ot = void 0, W.push(new x(`${Mt.transport} failed: ${Gl}`, Pe[Mt.transport])), this.ut !== "Connecting") {
                  const XC = "Failed to select transport before stop() was called.";
                  return this.u.log(s.Debug, XC), Promise.reject(new p(XC));
                }
              }
            }
          }
          return W.length > 0 ? Promise.reject(new A(`Unable to connect to the server with any of the available transports. ${W.join(" ")}`, W)) : Promise.reject(new Error("None of the transports supported by the client are supported by the server."));
        }
        Se(g) {
          switch (g) {
            case Pe.WebSockets:
              if (!this.ie.WebSocket) throw new Error("'WebSocket' is not supported in your environment.");
              return new QZ(this.$, this.Yt, this.u, this.ie.logMessageContent, this.ie.WebSocket, this.ie.headers || {});
            case Pe.ServerSentEvents:
              if (!this.ie.EventSource) throw new Error("'EventSource' is not supported in your environment.");
              return new CZ(this.$, this.$.Zt, this.u, this.ie);
            case Pe.LongPolling:
              return new ZC(this.$, this.u, this.ie);
            default:
              throw new Error(`Unknown transport: ${g}.`);
          }
        }
        ke(g, S) {
          return this.transport.onreceive = this.onreceive, this.features.reconnect ? this.transport.onclose = async (T) => {
            let _ = !1;
            if (this.features.reconnect) {
              try {
                this.features.disconnected(), await this.transport.connect(g, S), await this.features.resend();
              } catch {
                _ = !0;
              }
              _ && this.Ce(T);
            } else this.Ce(T);
          } : this.transport.onclose = (T) => this.Ce(T), this.transport.connect(g, S);
        }
        Re(g, S, T, _) {
          const V = Pe[g.transport];
          if (V == null) return this.u.log(s.Debug, `Skipping transport '${g.transport}' because it is not supported by this client.`), new Error(`Skipping transport '${g.transport}' because it is not supported by this client.`);
          if (!function(W, at) {
            return !W || !!(at & W);
          }(S, V)) return this.u.log(s.Debug, `Skipping transport '${Pe[V]}' because it was disabled by the client.`), new b(`'${Pe[V]}' is disabled by the client.`, V);
          if (!(g.transferFormats.map((W) => Xe[W]).indexOf(T) >= 0)) return this.u.log(s.Debug, `Skipping transport '${Pe[V]}' because it does not support the requested transfer format '${Xe[T]}'.`), new Error(`'${Pe[V]}' does not support ${Xe[T]}.`);
          if (V === Pe.WebSockets && !this.ie.WebSocket || V === Pe.ServerSentEvents && !this.ie.EventSource) return this.u.log(s.Debug, `Skipping transport '${Pe[V]}' because it is not supported in your environment.'`), new m(`'${Pe[V]}' is not supported in your environment.`, V);
          this.u.log(s.Debug, `Selecting transport '${Pe[V]}'.`);
          try {
            return this.features.reconnect = V === Pe.WebSockets ? _ : void 0, this.Se(V);
          } catch (W) {
            return W;
          }
        }
        De(g) {
          return g && typeof g == "object" && "connect" in g;
        }
        Ce(g) {
          if (this.u.log(s.Debug, `HttpConnection.stopConnection(${g}) called while in state ${this.ut}.`), this.transport = void 0, g = this.$e || g, this.$e = void 0, this.ut !== "Disconnected") {
            if (this.ut === "Connecting") throw this.u.log(s.Warning, `Call to HttpConnection.stopConnection(${g}) was ignored because the connection is still in the connecting state.`), new Error(`HttpConnection.stopConnection(${g}) was called while the connection is still in the connecting state.`);
            if (this.ut === "Disconnecting" && this.me(), g ? this.u.log(s.Error, `Connection disconnected with error '${g}'.`) : this.u.log(s.Information, "Connection disconnected."), this.Ee && (this.Ee.stop().catch((S) => {
              this.u.log(s.Error, `TransportSendQueue.stop() threw error '${S}'.`);
            }), this.Ee = void 0), this.connectionId = void 0, this.ut = "Disconnected", this.dt) {
              this.dt = !1;
              try {
                this.onclose && this.onclose(g);
              } catch (S) {
                this.u.log(s.Error, `HttpConnection.onclose(${g}) threw error '${S}'.`);
              }
            }
          } else this.u.log(s.Debug, `Call to HttpConnection.stopConnection(${g}) was ignored because the connection is already in the disconnected state.`);
        }
        be(g) {
          if (g.lastIndexOf("https://", 0) === 0 || g.lastIndexOf("http://", 0) === 0) return g;
          if (!kt.isBrowser) throw new Error(`Cannot resolve '${g}'.`);
          const S = window.document.createElement("a");
          return S.href = g, this.u.log(s.Information, `Normalizing '${g}' to '${S.href}'.`), S.href;
        }
        Ie(g) {
          const S = new URL(g);
          S.pathname.endsWith("/") ? S.pathname += "negotiate" : S.pathname += "/negotiate";
          const T = new URLSearchParams(S.searchParams);
          return T.has("negotiateVersion") || T.append("negotiateVersion", this.ye.toString()), T.has("useStatefulReconnect") ? T.get("useStatefulReconnect") === "true" && (this.ie._e = !0) : this.ie._e === !0 && T.append("useStatefulReconnect", "true"), S.search = T.toString(), S.toString();
        }
      }, c(Xl, "zh"), Xl);
      d(WC, "K");
      let MZ = WC;
      const qC = ($a = class {
        constructor(g) {
          this.xe = g, this.Ae = [], this.Ue = !0, this.Le = new Pg(), this.Ne = new Pg(), this.qe = this.Me();
        }
        send(g) {
          return this.je(g), this.Ne || (this.Ne = new Pg()), this.Ne.promise;
        }
        stop() {
          return this.Ue = !1, this.Le.resolve(), this.qe;
        }
        je(g) {
          if (this.Ae.length && typeof this.Ae[0] != typeof g) throw new Error(`Expected data to be of type ${typeof this.Ae} but was of type ${typeof g}`);
          this.Ae.push(g), this.Le.resolve();
        }
        async Me() {
          for (; ; ) {
            if (await this.Le.promise, !this.Ue) {
              this.Ne && this.Ne.reject("Connection stopped.");
              break;
            }
            this.Le = new Pg();
            const g = this.Ne;
            this.Ne = void 0;
            const S = typeof this.Ae[0] == "string" ? this.Ae.join("") : $a.We(this.Ae);
            this.Ae.length = 0;
            try {
              await this.xe.send(S), g.resolve();
            } catch (T) {
              g.reject(T);
            }
          }
        }
        static We(g) {
          const S = g.map((V) => V.byteLength).reduce((V, W) => V + W), T = new Uint8Array(S);
          let _ = 0;
          for (const V of g) T.set(new Uint8Array(V), _), _ += V.byteLength;
          return T.buffer;
        }
      }, c($a, "Al"), $a);
      d(qC, "G");
      let TZ = qC;
      const jC = (Nl = class {
        constructor() {
          this.promise = new Promise((g, S) => [this.j, this.Oe] = [g, S]);
        }
        resolve() {
          this.j();
        }
        reject(g) {
          this.Oe(g);
        }
      }, c(Nl, "Ph"), Nl);
      d(jC, "Q");
      let Pg = jC;
      const FC = (Hl = class {
        constructor() {
          this.name = "json", this.version = 2, this.transferFormat = Xe.Text;
        }
        parseMessages(g, S) {
          if (typeof g != "string") throw new Error("Invalid input for JSON hub protocol. Expected a string.");
          if (!g) return [];
          S === null && (S = ct.instance);
          const T = ds.parse(g), _ = [];
          for (const V of T) {
            const W = JSON.parse(V);
            if (typeof W.type != "number") throw new Error("Invalid payload.");
            switch (W.type) {
              case St.Invocation:
                this.U(W);
                break;
              case St.StreamItem:
                this.Fe(W);
                break;
              case St.Completion:
                this.Be(W);
                break;
              case St.Ping:
              case St.Close:
                break;
              case St.Ack:
                this.Xe(W);
                break;
              case St.Sequence:
                this.Je(W);
                break;
              default:
                S.log(s.Information, "Unknown message type '" + W.type + "' ignored.");
                continue;
            }
            _.push(W);
          }
          return _;
        }
        writeMessage(g) {
          return ds.write(JSON.stringify(g));
        }
        U(g) {
          this.ze(g.target, "Invalid payload for Invocation message."), g.invocationId !== void 0 && this.ze(g.invocationId, "Invalid payload for Invocation message.");
        }
        Fe(g) {
          if (this.ze(g.invocationId, "Invalid payload for StreamItem message."), g.item === void 0) throw new Error("Invalid payload for StreamItem message.");
        }
        Be(g) {
          if (g.result && g.error) throw new Error("Invalid payload for Completion message.");
          !g.result && g.error && this.ze(g.error, "Invalid payload for Completion message."), this.ze(g.invocationId, "Invalid payload for Completion message.");
        }
        Xe(g) {
          if (typeof g.sequenceId != "number") throw new Error("Invalid SequenceId for Ack message.");
        }
        Je(g) {
          if (typeof g.sequenceId != "number") throw new Error("Invalid SequenceId for Sequence message.");
        }
        ze(g, S) {
          if (typeof g != "string" || g === "") throw new Error(S);
        }
      }, c(Hl, "Sh"), Hl);
      d(FC, "Y");
      let UC = FC;
      const AZ = { trace: s.Trace, debug: s.Debug, info: s.Information, information: s.Information, warn: s.Warning, warning: s.Warning, error: s.Error, critical: s.Critical, none: s.None }, BC = (Yl = class {
        configureLogging(g) {
          if (it.isRequired(g, "logging"), g.log !== void 0) this.logger = g;
          else if (typeof g == "string") {
            const S = function(T) {
              const _ = AZ[T.toLowerCase()];
              if (_ !== void 0) return _;
              throw new Error(`Unknown log level: ${T}`);
            }(g);
            this.logger = new se(S);
          } else this.logger = new se(g);
          return this;
        }
        withUrl(g, S) {
          return it.isRequired(g, "url"), it.isNotEmpty(g, "url"), this.url = g, this.httpConnectionOptions = typeof S == "object" ? { ...this.httpConnectionOptions, ...S } : { ...this.httpConnectionOptions, transport: S }, this;
        }
        withHubProtocol(g) {
          return it.isRequired(g, "protocol"), this.protocol = g, this;
        }
        withAutomaticReconnect(g) {
          if (this.reconnectPolicy) throw new Error("A reconnectPolicy has already been set.");
          return g ? Array.isArray(g) ? this.reconnectPolicy = new EC(g) : this.reconnectPolicy = g : this.reconnectPolicy = new EC(), this;
        }
        withServerTimeout(g) {
          return it.isRequired(g, "milliseconds"), this.Ve = g, this;
        }
        withKeepAliveInterval(g) {
          return it.isRequired(g, "milliseconds"), this.Ke = g, this;
        }
        withStatefulReconnect(g) {
          return this.httpConnectionOptions === void 0 && (this.httpConnectionOptions = {}), this.httpConnectionOptions._e = !0, this.Y = g?.bufferSize, this;
        }
        build() {
          const g = this.httpConnectionOptions || {};
          if (g.logger === void 0 && (g.logger = this.logger), !this.url) throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");
          const S = new MZ(this.url, g);
          return AC.create(S, this.logger || ct.instance, this.protocol || new UC(), this.reconnectPolicy, this.Ve, this.Ke, this.Y);
        }
      }, c(Yl, "Ah"), Yl);
      d(BC, "tt");
      let RZ = BC;
      return Uint8Array.prototype.indexOf || Object.defineProperty(Uint8Array.prototype, "indexOf", { value: Array.prototype.indexOf, writable: !0 }), Uint8Array.prototype.slice || Object.defineProperty(Uint8Array.prototype, "slice", { value: /* @__PURE__ */ d(function(U, g) {
        return new Uint8Array(Array.prototype.slice.call(this, U, g));
      }, "value"), writable: !0 }), Uint8Array.prototype.forEach || Object.defineProperty(Uint8Array.prototype, "forEach", { value: Array.prototype.forEach, writable: !0 }), r;
    })(), "e"), n.exports = e();
  }(x3)), x3.exports;
}
c(PE, "r1");
d(PE, "requireSignalr_min");
var S3 = /* @__PURE__ */ PE();
const oU = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this._whenConnectionRequested = new Promise((r) => {
        this._resolveConnectionRequested = r;
      }), this._whenConnectionCreated = new Promise((r) => {
        this._resolveConnectionCreated = r;
      }), this._connectionEventListeners = [], this.signalRAccessTokenRefresh = !1, this._whenConnectionStarted = new Promise((r, a) => {
        this._whenConnectionStartedResolve = r, this._whenConnectionStartedReject = a;
      }), this.whenConnectionRequested().then(() => {
        this.isDestroyed || this.createConnection();
      });
    }
    async whenConnectionRequested() {
      await this._whenConnectionRequested;
    }
    async whenConnectionCreated() {
      return await this._whenConnectionCreated;
    }
    get rtmConnection() {
      return this._connection;
    }
    async whenConnectionStarted() {
      return await this._whenConnectionStarted;
    }
    async createConnection() {
      if (this.isDestroyed)
        throw new Ce();
      if (this.networkStateIsPending = !0, await this.whenUrlAndTokenFactory(), this._connection) {
        const s = new URL("/hubs/rtm", this.url);
        this._connection.baseUrl !== s.toString() && (this.connectionState = "reconnecting", console.info(
          this.weavyId,
          "Reconnecting due to changed url.",
          this._connection.baseUrl,
          "=>",
          s.toString()
        ), await this.disconnect(), this._connection.baseUrl = s.toString(), this.connect());
      } else {
        this.connectionState = "connecting";
        const s = new URL("/hubs/rtm", this.url);
        this._connection = new S3.HubConnectionBuilder().configureLogging(S3.LogLevel.None).withUrl(s.toString(), {
          accessTokenFactory: /* @__PURE__ */ d(async () => {
            try {
              if (this.signalRAccessTokenRefresh) {
                const r = await this.getToken(!0);
                return this.signalRAccessTokenRefresh = !1, r;
              } else
                return await this.getToken();
            } catch (r) {
              throw console.error(r), r;
            }
          }, "accessTokenFactory")
        }).withAutomaticReconnect({
          nextRetryDelayInMilliseconds: /* @__PURE__ */ d((r) => !this.isDestroyed && window.navigator.onLine && document?.visibilityState !== "hidden" && r.elapsedMilliseconds < 6e4 ? [0, 2e3, 1e4][r.previousRetryCount] || 1e4 : null, "nextRetryDelayInMilliseconds")
        }).build(), this._connection.onclose(() => {
          console.info(this.weavyId, "SignalR closed."), this.connectionState = "disconnected", !this.isDestroyed && (this.networkStateIsPending = !0, this._whenConnectionStarted = new Promise((r, a) => {
            this._whenConnectionStartedResolve = r, this._whenConnectionStartedReject = a;
          }), this.connect());
        }), this._connection.onreconnecting(() => {
          console.info(this.weavyId, "SignalR reconnecting..."), this.connectionState = "reconnecting";
        }), this._connection.onreconnected((r) => {
          console.info(this.weavyId, `SignalR reconnected ${r}`), this.connectionState = "connected", this.networkStateIsPending = !1;
          for (let a = 0; a < this._connectionEventListeners.length; a++)
            this._connection?.invoke("Subscribe", this._connectionEventListeners[a].name);
        }), this._resolveConnectionCreated?.(this._connection), this.connect();
      }
      return this._connection;
    }
    async disconnect() {
      this._connection && (await this._connection.stop(), this.connectionState = "disconnected");
    }
    async connect() {
      if (this.isDestroyed)
        throw new Ce();
      let s;
      this._connection ? s = this._connection : s = await this.whenConnectionCreated(), console.info(this.weavyId, "Connecting SignalR...");
      try {
        if (!window.navigator.onLine)
          throw new Error();
        await Promise.race([s.start(), this.whenConnectionStarted()]), this.signalRAccessTokenRefresh = !1, this.networkStateIsPending = !1, this.connectionState = "connected", this._whenConnectionStartedResolve?.(s), console.info(this.weavyId, `SignalR connected ${s.connectionId}`);
      } catch (r) {
        if (r instanceof Ce)
          return console.warn(this.weavyId, "SignalR connection aborted."), s;
        window.navigator.onLine ? !this.signalRAccessTokenRefresh && window.document.visibilityState !== "hidden" && r.toString().includes("Unauthorized") ? (console.info(this.weavyId, "Retrying SignalR connect with fresh token."), this.signalRAccessTokenRefresh = !0) : (console.info(
          this.weavyId,
          "Server is probably down, retrying SignalR connect after a delay or when window regains focus."
        ), this.connectionState = "reconnecting", await new Promise((a) => {
          setTimeout(a, 5e3), window.addEventListener("visibilitychange", a, { once: !0 }), window.addEventListener("offline", a, { once: !0 }), window.addEventListener("online", a, { once: !0 });
        })) : (this.networkStateIsPending = !1, console.info(this.weavyId, "Offline, reconnecting SignalR when online."), await new Promise((a) => {
          window.addEventListener("online", a, { once: !0 });
        })), window.navigator.onLine && document?.visibilityState !== "hidden" && await new Promise((a) => setTimeout(a, 1e3)), this.checkVersion(), this.networkStateIsPending = !0, await this.connect();
      }
      return s;
    }
    async subscribe(s, r, a) {
      if (this.isDestroyed)
        throw new Ce();
      this._resolveConnectionRequested?.(!0);
      const o = s ? s + ":" + r : r;
      try {
        if (this._connectionEventListeners || await new Promise((l) => queueMicrotask(() => l(!0))), this._connectionEventListeners.some((l) => l.name === o && l.callback === a))
          throw new Error("Duplicate subscribe: " + o);
        if (this._connectionEventListeners.push({ name: o, callback: a }), await this.whenConnectionStarted(), !this._connection)
          throw new Error("Connection not created");
        if (this._connection.on(o, a), await this._connection.invoke("Subscribe", o) === !1)
          throw new Error("Could not subscribe to " + o);
        return !0;
      } catch (l) {
        l instanceof Ce || console.error(this.weavyId, "Error in Subscribe:", l);
        const h = this._connectionEventListeners.findIndex((u) => u.name === o && u.callback === a);
        return h !== -1 && (this._connectionEventListeners.splice(h, 1), this._connection?.off(o, a)), !1;
      }
    }
    async unsubscribe(s, r, a) {
      if (this.isDestroyed)
        throw new Ce();
      try {
        const o = s ? s + ":" + r : r, l = this._connectionEventListeners.findIndex((h) => h.name === o && h.callback === a);
        if (l !== -1) {
          if (this._connectionEventListeners.splice(l, 1), await this.whenConnectionStarted(), !this._connection)
            throw new Error("Connection not created");
          this._connection?.off(o, a), this._connectionEventListeners.some((h) => h.name === o) || await this._connection.invoke("Unsubscribe", o);
        }
      } catch (o) {
        o instanceof Ce || console.error(this.weavyId, "Error in Unsubscribe:", o);
      }
    }
    destroy() {
      super.destroy(), this.disconnect(), this._whenConnectionStartedReject && (this._whenConnectionStarted.catch(() => {
      }), this._whenConnectionStartedReject(new Ce()));
    }
  }, c(e, "t"), e), d(t, "WeavyConnection"), t;
}, "WeavyConnectionMixin");
var Wv = /* @__PURE__ */ ((n) => (n.JSON = "application/json;charset=utf-8", n.FormData = "multipart/form-data;charset=utf-8", n.URLEncoded = "application/x-www-form-urlencoded;charset=utf-8", n.Text = "text/plain;charset=utf-8", n.Auto = "", n))(Wv || {});
const lU = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // FETCH
    async fetchOptions(s = {}, r = !0) {
      if (this.isDestroyed)
        throw new Ce();
      const a = {
        headers: {
          "X-Weavy-Source": `${Gt.sourceName}@${Gt.version}`,
          "Content-Type": Wv.JSON
        },
        method: "GET"
      }, o = lw(lw(BF, a, !0), s, !0);
      return r ? lw(
        o,
        {
          headers: {
            Authorization: "Bearer " + await this.getToken()
          }
        },
        !0
      ) : o;
    }
    async fetch(s, r, a = !0) {
      if (this.isDestroyed)
        throw new Ce();
      const o = await this.fetchOptions(r);
      this.networkStateIsPending = !0;
      const l = await fetch(new URL(s, this.url), o);
      if (l.ok)
        this.networkStateIsPending = !1, this.serverState = "ok";
      else if (l.status === 401 || l.status === 403) {
        if (a)
          return await this.getToken(!0), await this.fetch(s, r, !1);
        this.networkStateIsPending = !1, this.serverState = "unauthorized";
      } else
        this.networkStateIsPending = !1;
      return l;
    }
    async upload(s, r, a, o = Wv.JSON, l, h = !0) {
      if (this.isDestroyed)
        throw new Ce();
      const u = await this.getToken();
      return await new Promise((p, y) => {
        const m = new XMLHttpRequest();
        m.open(r, new URL(s, this.url), !0), m.setRequestHeader("Authorization", "Bearer " + u), m.setRequestHeader("X-Weavy-Source", `${Gt.sourceName}@${Gt.version}`), o && m.setRequestHeader("Content-Type", o), l && m.upload.addEventListener("progress", (w) => {
          l(w.loaded / w.total * 100 || 100);
        }), m.onload = (w) => {
          h && (m.status === 401 || m.status === 401) ? this.getToken(!0).then(() => this.upload(s, r, a, o, l, !1)).then(p).catch(y) : p(new Response(m.response, { status: m.status, statusText: m.statusText }));
        }, m.onerror = y, m.send(a);
      });
    }
    // DEPRECATED
    async get(s) {
      return console.warn(`weavy.get() is deprecated, use weavy.fetch("${s}") instead.`), this.fetch(s);
    }
    // DEPRECATED
    async post(s, r, a, o) {
      console.warn(
        `weavy.post() is deprecated, use weavy.fetch("${s}", { method: "${r}"}) instead.`
      );
      const l = o ? { "Content-Type": o } : void 0;
      return this.fetch(s, { method: r, body: a, headers: l });
    }
  }, c(e, "t"), e), d(t, "WeavyFetch"), t;
}, "WeavyFetchMixin"), CE = "en", cU = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    constructor() {
      super(...arguments), this._locales = /* @__PURE__ */ new Map([
        ["sv-SE", () => import(
          /* webpackIgnore: true */
          /* @vite-ignore */
          new URL("./es/locales/sv-SE.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
        ).then((s) => s.svSE)]
      ]), this._locale = t.sourceLocale;
    }
    /**
     * The locale used in the Weavy source.
     */
    static get sourceLocale() {
      try {
        return CE;
      } catch {
        return "";
      }
    }
    get locales() {
      return Array.from(this._locales.entries());
    }
    set locales(s) {
      if (this.isDestroyed)
        throw new Ce();
      if (this.localization)
        throw new Error("Locales may only be configured once");
      if (s) {
        if (!Array.isArray(s))
          throw new TypeError("Provided locales have invalid format.");
        s.forEach((r) => {
          if (!Array.isArray(r) || r.length !== 2 || typeof r[0] != "string")
            throw new TypeError("Invalid locale provided: " + r[0]);
          this._locales.set(...r);
        }), this.configureLocalization();
      }
    }
    get localization() {
      return this._localization;
    }
    /**
     * Selected locale. The locale must be pre configured in `.locales`.
     */
    get locale() {
      return this._locale;
    }
    set locale(s) {
      if (this.isDestroyed)
        throw new Ce();
      !this._locale && !s || (s ||= t.sourceLocale, this._locale = s, this.localization ? this.localization.setLocale(this._locale) : queueMicrotask(() => {
        this.localization ? this.localization.setLocale(this._locale) : this._locale !== t.sourceLocale && (this._locales.has(this._locale) && this.configureLocalization(), this.localization ? this.localization.setLocale(this._locale) : console.error(
          this.weavyId,
          `You need to configure additional languages in config to use '${s}'.`
        ));
      }));
    }
    async loadLocale(s) {
      if (this.isDestroyed)
        throw new Ce();
      if (this._locales?.has(s)) {
        const r = this._locales.get(s);
        return console.info(
          this.weavyId,
          typeof r == "function" ? "loading locale" : "preloaded locale",
          s
        ), await (typeof r == "function" ? r() : r);
      } else
        throw new Error("The requested locale is not configured");
    }
    configureLocalization() {
      if (this.isDestroyed)
        throw new Ce();
      if (this._locales?.size && !this.localization) {
        const s = this._locales.keys();
        console.info(this.weavyId, "Configuring locales", s);
        const { getLocale: r, setLocale: a } = lF({
          sourceLocale: t.sourceLocale,
          targetLocales: s,
          loadLocale: /* @__PURE__ */ d((o) => this.loadLocale(o), "loadLocale")
        });
        this._localization = {
          getLocale: r,
          setLocale: a
        };
      }
    }
  }, c(e, "t"), e), d(t, "WeavyLocalization"), t;
}, "WeavyLocalizationMixin"), hU = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this._configurationState = "pending", this._networkEvents = /* @__PURE__ */ new Set(), this._connectionState = "connecting", this._serverState = "ok", this._networkState = window.navigator.onLine ? "online" : "offline", this._networkStateIsPending = !1, window.addEventListener("online", () => {
        this.networkState = "online";
      }), window.addEventListener("offline", () => {
        this.networkState = "offline", this.networkStateIsPending = !1;
      }), queueMicrotask(() => this.requestConfigurationCheck());
    }
    get configurationState() {
      return this._configurationState;
    }
    set configurationState(s) {
      this._configurationState = s, this._configurationTimer && s === "configured" && (window.clearTimeout(this._configurationTimer), this._configurationTimer = null), this.triggerNetworkChange();
    }
    get networkState() {
      return this._networkState;
    }
    set networkState(s) {
      this._networkState = s, this.triggerNetworkChange();
    }
    get serverState() {
      return this._serverState;
    }
    set serverState(s) {
      this._serverState = s, this.triggerNetworkChange();
    }
    get connectionState() {
      return this._connectionState;
    }
    set connectionState(s) {
      this._connectionState = s, this.triggerNetworkChange();
    }
    get networkStateIsPending() {
      return this._networkStateIsPending;
    }
    set networkStateIsPending(s) {
      this._networkStateIsPending = s, this.triggerNetworkChange();
    }
    get network() {
      return {
        state: this._networkState === "online" ? (this._connectionState === "connected" || this._serverState === "ok") && this.configurationState !== "uninitialized" ? "online" : "unreachable" : "offline",
        isPending: this._networkStateIsPending
      };
    }
    requestConfigurationCheck() {
      !this._configurationTimer && this.configurationTimeout >= 0 && this.configurationTimeout < 1 / 0 && (this._configurationTimer = window.setTimeout(() => {
        this.configurationState === "pending" && (this.configurationState = "uninitialized", console.error("Weavy was not configured with required url and tokenFactory/tokenUrl within a reasonable time. Please check your configuration!")), this._configurationTimer = null;
      }, this.configurationTimeout));
    }
    triggerNetworkChange() {
      const s = this.network;
      this._networkEvents.forEach((r) => {
        r(s);
      });
    }
    addNetworkListener(s) {
      this._networkEvents.add(s);
    }
    removeNetworkListener(s) {
      this._networkEvents.delete(s);
    }
  }, c(e, "t"), e), d(t, "WeavyNetwork"), t;
}, "WeavyNetworkMixin");
function O1() {
}
c(O1, "Lh");
d(O1, "noop");
function QE({
  storage: n,
  key: t = "REACT_QUERY_OFFLINE_CACHE",
  throttleTime: e = 1e3,
  serialize: i = JSON.stringify,
  deserialize: s = JSON.parse,
  retry: r
}) {
  if (n) {
    const a = /* @__PURE__ */ d((o) => {
      try {
        n.setItem(t, i(o));
        return;
      } catch (l) {
        return l;
      }
    }, "trySave");
    return {
      persistClient: ME((o) => {
        let l = o, h = a(l), u = 0;
        for (; h && l; )
          u++, l = r?.({
            persistedClient: l,
            error: h,
            errorCount: u
          }), l && (h = a(l));
      }, e),
      restoreClient: /* @__PURE__ */ d(() => {
        const o = n.getItem(t);
        if (o)
          return s(o);
      }, "restoreClient"),
      removeClient: /* @__PURE__ */ d(() => {
        n.removeItem(t);
      }, "removeClient")
    };
  }
  return {
    persistClient: O1,
    restoreClient: O1,
    removeClient: O1
  };
}
c(QE, "l1");
d(QE, "createSyncStoragePersister");
function ME(n, t = 100) {
  let e = null, i;
  return function(...s) {
    i = s, e === null && (e = $r.setTimeout(() => {
      n(...i), e = null;
    }, t));
  };
}
c(ME, "d1");
d(ME, "throttle$1");
var dU = ["added", "removed", "updated"];
function wk(n) {
  return dU.includes(n);
}
c(wk, "vy");
d(wk, "isCacheEventType");
async function TE({
  queryClient: n,
  persister: t,
  maxAge: e = 1e3 * 60 * 60 * 24,
  buster: i = "",
  hydrateOptions: s
}) {
  try {
    const r = await t.restoreClient();
    if (r)
      if (r.timestamp) {
        const a = Date.now() - r.timestamp > e, o = r.buster !== i;
        if (a || o)
          return t.removeClient();
        oE(n, r.clientState, s);
      } else
        return t.removeClient();
  } catch (r) {
    throw await t.removeClient(), r;
  }
}
c(TE, "u1");
d(TE, "persistQueryClientRestore");
async function gk({
  queryClient: n,
  persister: t,
  buster: e = "",
  dehydrateOptions: i
}) {
  const s = {
    buster: e,
    timestamp: Date.now(),
    clientState: aE(n, i)
  };
  await t.persistClient(s);
}
c(gk, "gy");
d(gk, "persistQueryClientSave");
function AE(n) {
  const t = n.queryClient.getQueryCache().subscribe((i) => {
    wk(i.type) && gk(n);
  }), e = n.queryClient.getMutationCache().subscribe((i) => {
    wk(i.type) && gk(n);
  });
  return () => {
    t(), e();
  };
}
c(AE, "p1");
d(AE, "persistQueryClientSubscribe");
const uU = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // QUERY CLIENT
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this._queryClient = new sU({
        defaultOptions: {
          queries: {
            staleTime: this.staleTime,
            gcTime: this.gcTime
          }
        }
      }), this.initQueryClient();
    }
    get queryClient() {
      return this._queryClient;
    }
    async initQueryClient() {
      if (this.isDestroyed)
        throw new Ce();
      await this.whenUrl();
      try {
        this._sessionStoragePersister = QE({
          key: "WEAVY_QUERY_OFFLINE_CACHE",
          storage: window.sessionStorage,
          throttleTime: this.staleTime
        });
        const s = {
          queryClient: this._queryClient,
          persister: this._sessionStoragePersister,
          maxAge: this.gcTime,
          // 24h - should match gcTime
          buster: this.cachePrefix,
          // Cache busting parameter (build hash or similar)
          hydrateOptions: void 0,
          dehydrateOptions: {
            shouldDehydrateMutation: /* @__PURE__ */ d((r) => {
              const a = r.state.context?.status?.state === "pending";
              return !!(r.state.context && !a || r.state.isPaused);
            }, "shouldDehydrateMutation")
          }
        };
        await TE(s), this._unsubscribeQueryClient = AE(s);
      } catch {
        console.warn(this.weavyId, "Query cache persister not available.");
      }
      this.host.isConnected && this._queryClient.mount(), this._hostIsConnectedObserver = f9(this.host, (s) => {
        this.isDestroyed || (s ? (console.info(this.weavyId, "Query client mounted"), this._queryClient.mount()) : (console.info(this.weavyId, "Query client unmounted"), this._queryClient.unmount()));
      });
    }
    async reset() {
      await super.reset(), await this._queryClient.cancelQueries(), await this._sessionStoragePersister?.removeClient(), await this.queryClient.resetQueries();
    }
    async disconnectQueryClient() {
      console.info(this.weavyId, "Query client disconnected"), await this._queryClient.cancelQueries(), await this._sessionStoragePersister?.removeClient(), this._unsubscribeQueryClient?.(), this._queryClient.unmount(), this._queryClient.clear();
    }
    destroy() {
      super.destroy(), this._hostIsConnectedObserver?.disconnect(), this.disconnectQueryClient();
    }
  }, c(e, "t"), e), d(t, "WeavyQuery"), t;
}, "WeavyQueryMixin"), pU = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this._notificationEvents = Gt.defaults.notificationEvents ?? !1, this.dispatchRealtimeEvent = (r) => {
        ii();
        const a = this.host !== document.documentElement ? { composed: !0 } : { bubbles: !0 };
        switch (r.action) {
          case "notification_created":
          case "notification_updated":
          case "notification_deleted":
          case "notifications_marked": {
            const o = new CustomEvent("wy-notifications", {
              ...a,
              detail: r
            });
            this.host.dispatchEvent(o);
          }
        }
      };
    }
    get notificationEvents() {
      return this._notificationEvents;
    }
    set notificationEvents(s) {
      this.realtimeUnsubscribe(), this._notificationEvents = s ?? !1, this.realtimeSubscribe();
    }
    realtimeSubscribe() {
      const s = this;
      this.notificationEvents && (s.subscribe(null, "notification_created", this.dispatchRealtimeEvent), s.subscribe(null, "notification_updated", this.dispatchRealtimeEvent), s.subscribe(null, "notifications_marked", this.dispatchRealtimeEvent));
    }
    realtimeUnsubscribe() {
      const s = this;
      this.notificationEvents && (s.unsubscribe(null, "notification_created", this.dispatchRealtimeEvent), s.unsubscribe(null, "notification_updated", this.dispatchRealtimeEvent), s.unsubscribe(null, "notifications_marked", this.dispatchRealtimeEvent));
    }
    destroy() {
      this.realtimeUnsubscribe(), super.destroy();
    }
  }, c(e, "t"), e), d(t, "WeavyRealtime"), t;
}, "WeavyRealtimeMixin"), fU = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s);
    }
    set annotations(s) {
      this._annotations = s, this.updateContext();
    }
    get annotations() {
      return this._annotations ?? Gt.defaults.annotations;
    }
    set enterToSend(s) {
      this._enterToSend = s, this.updateContext();
    }
    get enterToSend() {
      return this._enterToSend ?? Gt.defaults.enterToSend;
    }
    set notifications(s) {
      this._notifications = s, this.updateContext();
    }
    get notifications() {
      return this._notifications ?? Gt.defaults.notifications;
    }
    set notificationsBadge(s) {
      this._notificationsBadge = s, this.updateContext();
    }
    get notificationsBadge() {
      return this._notificationsBadge ?? Gt.defaults.notificationsBadge;
    }
    set reactions(s) {
      this._reactions = s, this.updateContext();
    }
    get reactions() {
      return this._reactions ?? Gt.defaults.reactions;
    }
  }, c(e, "t"), e), d(t, "WeavySettings"), t;
}, "WeavySettingsMixin");
function di(n) {
  return n < 0 ? -1 : n === 0 ? 0 : 1;
}
c(di, "Se");
d(di, "signum");
function Uc(n, t, e) {
  return (1 - e) * n + e * t;
}
c(Uc, "vc");
d(Uc, "lerp");
function RE(n, t, e) {
  return e < n ? n : e > t ? t : e;
}
c(RE, "m1");
d(RE, "clampInt");
function Rw(n, t, e) {
  return e < n ? n : e > t ? t : e;
}
c(Rw, "Kl");
d(Rw, "clampDouble");
function qb(n) {
  return n = n % 360, n < 0 && (n = n + 360), n;
}
c(qb, "Xu");
d(qb, "sanitizeDegreesDouble");
function EE(n, t) {
  return qb(t - n) <= 180 ? 1 : -1;
}
c(EE, "v1");
d(EE, "rotationDirection");
function _E(n, t) {
  return 180 - Math.abs(Math.abs(n - t) - 180);
}
c(_E, "g1");
d(_E, "differenceDegrees");
function qv(n, t) {
  const e = n[0] * t[0][0] + n[1] * t[0][1] + n[2] * t[0][2], i = n[0] * t[1][0] + n[1] * t[1][1] + n[2] * t[1][2], s = n[0] * t[2][0] + n[1] * t[2][1] + n[2] * t[2][2];
  return [e, i, s];
}
c(qv, "du");
d(qv, "matrixMultiply");
const yU = [
  [0.41233895, 0.35762064, 0.18051042],
  [0.2126, 0.7152, 0.0722],
  [0.01932141, 0.11916382, 0.95034478]
], mU = [
  [
    3.2413774792388685,
    -1.5376652402851851,
    -0.49885366846268053
  ],
  [
    -0.9691452513005321,
    1.8758853451067872,
    0.04156585616912061
  ],
  [
    0.05562093689691305,
    -0.20395524564742123,
    1.0571799111220335
  ]
], wU = [95.047, 100, 108.883];
function jb(n, t, e) {
  return (255 << 24 | (n & 255) << 16 | (t & 255) << 8 | e & 255) >>> 0;
}
c(jb, "Ju");
d(jb, "argbFromRgb");
function vk(n) {
  const t = Pr(n[0]), e = Pr(n[1]), i = Pr(n[2]);
  return jb(t, e, i);
}
c(vk, "by");
d(vk, "argbFromLinrgb");
function uP(n) {
  return n >> 16 & 255;
}
c(uP, "Kw");
d(uP, "redFromArgb");
function pP(n) {
  return n >> 8 & 255;
}
c(pP, "Gw");
d(pP, "greenFromArgb");
function fP(n) {
  return n & 255;
}
c(fP, "Zw");
d(fP, "blueFromArgb");
function zE(n, t, e) {
  const i = mU, s = i[0][0] * n + i[0][1] * t + i[0][2] * e, r = i[1][0] * n + i[1][1] * t + i[1][2] * e, a = i[2][0] * n + i[2][1] * t + i[2][2] * e, o = Pr(s), l = Pr(r), h = Pr(a);
  return jb(o, l, h);
}
c(zE, "C1");
d(zE, "argbFromXyz");
function LE(n) {
  const t = Na(uP(n)), e = Na(pP(n)), i = Na(fP(n));
  return qv([t, e, i], yU);
}
c(LE, "k1");
d(LE, "xyzFromArgb");
function IE(n) {
  const t = Cs(n), e = Pr(t);
  return jb(e, e, e);
}
c(IE, "_1");
d(IE, "argbFromLstar");
function jv(n) {
  const t = LE(n)[1];
  return 116 * yP(t / 100) - 16;
}
c(jv, "hu");
d(jv, "lstarFromArgb");
function Cs(n) {
  return 100 * VE((n + 16) / 116);
}
c(Cs, "bs");
d(Cs, "yFromLstar");
function Fv(n) {
  return yP(n / 100) * 116 - 16;
}
c(Fv, "uu");
d(Fv, "lstarFromY");
function Na(n) {
  const t = n / 255;
  return t <= 0.040449936 ? t / 12.92 * 100 : Math.pow((t + 0.055) / 1.055, 2.4) * 100;
}
c(Na, "Qr");
d(Na, "linearized");
function Pr(n) {
  const t = n / 100;
  let e = 0;
  return t <= 31308e-7 ? e = t * 12.92 : e = 1.055 * Math.pow(t, 1 / 2.4) - 0.055, RE(0, 255, Math.round(e * 255));
}
c(Pr, "nr");
d(Pr, "delinearized");
function ZE() {
  return wU;
}
c(ZE, "M1");
d(ZE, "whitePointD65");
function yP(n) {
  const t = 0.008856451679035631, e = 24389 / 27;
  return n > t ? Math.pow(n, 1 / 3) : (e * n + 16) / 116;
}
c(yP, "Yw");
d(yP, "labF");
function VE(n) {
  const t = 0.008856451679035631, e = 24389 / 27, i = n * n * n;
  return i > t ? i : (116 * n - 16) / e;
}
c(VE, "z1");
d(VE, "labInvf");
var Ro;
const DE = (Ro = class {
  /**
   * Create ViewingConditions from a simple, physically relevant, set of
   * parameters.
   *
   * @param whitePoint White point, measured in the XYZ color space.
   *     default = D65, or sunny day afternoon
   * @param adaptingLuminance The luminance of the adapting field. Informally,
   *     how bright it is in the room where the color is viewed. Can be
   *     calculated from lux by multiplying lux by 0.0586. default = 11.72,
   *     or 200 lux.
   * @param backgroundLstar The lightness of the area surrounding the color.
   *     measured by L* in L*a*b*. default = 50.0
   * @param surround A general description of the lighting surrounding the
   *     color. 0 is pitch dark, like watching a movie in a theater. 1.0 is a
   *     dimly light room, like watching TV at home at night. 2.0 means there
   *     is no difference between the lighting on the color and around it.
   *     default = 2.0
   * @param discountingIlluminant Whether the eye accounts for the tint of the
   *     ambient lighting, such as knowing an apple is still red in green light.
   *     default = false, the eye does not perform this process on
   *       self-luminous objects like displays.
   */
  static make(t = ZE(), e = 200 / Math.PI * Cs(50) / 100, i = 50, s = 2, r = !1) {
    const a = t, o = a[0] * 0.401288 + a[1] * 0.650173 + a[2] * -0.051461, l = a[0] * -0.250268 + a[1] * 1.204414 + a[2] * 0.045854, h = a[0] * -2079e-6 + a[1] * 0.048952 + a[2] * 0.953127, u = 0.8 + s / 10, p = u >= 0.9 ? Uc(0.59, 0.69, (u - 0.9) * 10) : Uc(0.525, 0.59, (u - 0.8) * 10);
    let y = r ? 1 : u * (1 - 1 / 3.6 * Math.exp((-e - 42) / 92));
    y = y > 1 ? 1 : y < 0 ? 0 : y;
    const m = u, w = [
      y * (100 / o) + 1 - y,
      y * (100 / l) + 1 - y,
      y * (100 / h) + 1 - y
    ], b = 1 / (5 * e + 1), $ = b * b * b * b, x = 1 - $, C = $ * e + 0.1 * x * x * Math.cbrt(5 * e), R = Cs(i) / t[1], E = 1.48 + Math.sqrt(R), A = 0.725 / Math.pow(R, 0.2), I = A, Z = [
      Math.pow(C * w[0] * o / 100, 0.42),
      Math.pow(C * w[1] * l / 100, 0.42),
      Math.pow(C * w[2] * h / 100, 0.42)
    ], j = [
      400 * Z[0] / (Z[0] + 27.13),
      400 * Z[1] / (Z[1] + 27.13),
      400 * Z[2] / (Z[2] + 27.13)
    ], N = (2 * j[0] + j[1] + 0.05 * j[2]) * A;
    return new Ro(R, N, A, I, p, m, w, C, Math.pow(C, 0.25), E);
  }
  /**
   * Parameters are intermediate values of the CAM16 conversion process. Their
   * names are shorthand for technical color science terminology, this class
   * would not benefit from documenting them individually. A brief overview
   * is available in the CAM16 specification, and a complete overview requires
   * a color science textbook, such as Fairchild's Color Appearance Models.
   */
  constructor(t, e, i, s, r, a, o, l, h, u) {
    this.n = t, this.aw = e, this.nbb = i, this.ncb = s, this.c = r, this.nc = a, this.rgbD = o, this.fl = l, this.fLRoot = h, this.z = u;
  }
}, c(Ro, "gd"), Ro);
d(DE, "ViewingConditions");
let Qs = DE;
Qs.DEFAULT = Qs.make();
var Wi;
const WE = (Wi = class {
  /**
   * All of the CAM16 dimensions can be calculated from 3 of the dimensions, in
   * the following combinations:
   *      -  {j or q} and {c, m, or s} and hue
   *      - jstar, astar, bstar
   * Prefer using a static method that constructs from 3 of those dimensions.
   * This constructor is intended for those methods to use to return all
   * possible dimensions.
   *
   * @param hue
   * @param chroma informally, colorfulness / color intensity. like saturation
   *     in HSL, except perceptually accurate.
   * @param j lightness
   * @param q brightness; ratio of lightness to white point's lightness
   * @param m colorfulness
   * @param s saturation; ratio of chroma to white point's chroma
   * @param jstar CAM16-UCS J coordinate
   * @param astar CAM16-UCS a coordinate
   * @param bstar CAM16-UCS b coordinate
   */
  constructor(t, e, i, s, r, a, o, l, h) {
    this.hue = t, this.chroma = e, this.j = i, this.q = s, this.m = r, this.s = a, this.jstar = o, this.astar = l, this.bstar = h;
  }
  /**
   * CAM16 instances also have coordinates in the CAM16-UCS space, called J*,
   * a*, b*, or jstar, astar, bstar in code. CAM16-UCS is included in the CAM16
   * specification, and is used to measure distances between colors.
   */
  distance(t) {
    const e = this.jstar - t.jstar, i = this.astar - t.astar, s = this.bstar - t.bstar, r = Math.sqrt(e * e + i * i + s * s);
    return 1.41 * Math.pow(r, 0.63);
  }
  /**
   * @param argb ARGB representation of a color.
   * @return CAM16 color, assuming the color was viewed in default viewing
   *     conditions.
   */
  static fromInt(t) {
    return Wi.fromIntInViewingConditions(t, Qs.DEFAULT);
  }
  /**
   * @param argb ARGB representation of a color.
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   * @return CAM16 color.
   */
  static fromIntInViewingConditions(t, e) {
    const i = (t & 16711680) >> 16, s = (t & 65280) >> 8, r = t & 255, a = Na(i), o = Na(s), l = Na(r), h = 0.41233895 * a + 0.35762064 * o + 0.18051042 * l, u = 0.2126 * a + 0.7152 * o + 0.0722 * l, p = 0.01932141 * a + 0.11916382 * o + 0.95034478 * l, y = 0.401288 * h + 0.650173 * u - 0.051461 * p, m = -0.250268 * h + 1.204414 * u + 0.045854 * p, w = -2079e-6 * h + 0.048952 * u + 0.953127 * p, b = e.rgbD[0] * y, $ = e.rgbD[1] * m, x = e.rgbD[2] * w, C = Math.pow(e.fl * Math.abs(b) / 100, 0.42), R = Math.pow(e.fl * Math.abs($) / 100, 0.42), E = Math.pow(e.fl * Math.abs(x) / 100, 0.42), A = di(b) * 400 * C / (C + 27.13), I = di($) * 400 * R / (R + 27.13), Z = di(x) * 400 * E / (E + 27.13), j = (11 * A + -12 * I + Z) / 11, N = (A + I - 2 * Z) / 9, ut = (20 * A + 20 * I + 21 * Z) / 20, ct = (40 * A + 20 * I + Z) / 20, K = Math.atan2(N, j) * 180 / Math.PI, wt = K < 0 ? K + 360 : K >= 360 ? K - 360 : K, it = wt * Math.PI / 180, At = ct * e.nbb, kt = 100 * Math.pow(At / e.aw, e.c * e.z), Zt = 4 / e.c * Math.sqrt(kt / 100) * (e.aw + 4) * e.fLRoot, Dt = wt < 20.14 ? wt + 360 : wt, Wt = 0.25 * (Math.cos(Dt * Math.PI / 180 + 2) + 3.8), Oi = 5e4 / 13 * Wt * e.nc * e.ncb * Math.sqrt(j * j + N * N) / (ut + 0.305), _e = Math.pow(Oi, 0.9) * Math.pow(1.64 - Math.pow(0.29, e.n), 0.73), pe = _e * Math.sqrt(kt / 100), se = pe * e.fLRoot, ge = 50 * Math.sqrt(_e * e.c / (e.aw + 4)), $i = (1 + 100 * 7e-3) * kt / (1 + 7e-3 * kt), zi = 1 / 0.0228 * Math.log(1 + 0.0228 * se), Ni = zi * Math.cos(it), Nt = zi * Math.sin(it);
    return new Wi(wt, pe, kt, Zt, se, ge, $i, Ni, Nt);
  }
  /**
   * @param j CAM16 lightness
   * @param c CAM16 chroma
   * @param h CAM16 hue
   */
  static fromJch(t, e, i) {
    return Wi.fromJchInViewingConditions(t, e, i, Qs.DEFAULT);
  }
  /**
   * @param j CAM16 lightness
   * @param c CAM16 chroma
   * @param h CAM16 hue
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   */
  static fromJchInViewingConditions(t, e, i, s) {
    const r = 4 / s.c * Math.sqrt(t / 100) * (s.aw + 4) * s.fLRoot, a = e * s.fLRoot, o = e / Math.sqrt(t / 100), l = 50 * Math.sqrt(o * s.c / (s.aw + 4)), h = i * Math.PI / 180, u = (1 + 100 * 7e-3) * t / (1 + 7e-3 * t), p = 1 / 0.0228 * Math.log(1 + 0.0228 * a), y = p * Math.cos(h), m = p * Math.sin(h);
    return new Wi(i, e, t, r, a, l, u, y, m);
  }
  /**
   * @param jstar CAM16-UCS lightness.
   * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the Y axis.
   * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the X axis.
   */
  static fromUcs(t, e, i) {
    return Wi.fromUcsInViewingConditions(t, e, i, Qs.DEFAULT);
  }
  /**
   * @param jstar CAM16-UCS lightness.
   * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the Y axis.
   * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
   *     coordinate on the X axis.
   * @param viewingConditions Information about the environment where the color
   *     was observed.
   */
  static fromUcsInViewingConditions(t, e, i, s) {
    const r = e, a = i, o = Math.sqrt(r * r + a * a), l = (Math.exp(o * 0.0228) - 1) / 0.0228 / s.fLRoot;
    let h = Math.atan2(a, r) * (180 / Math.PI);
    h < 0 && (h += 360);
    const u = t / (1 - (t - 100) * 7e-3);
    return Wi.fromJchInViewingConditions(u, l, h, s);
  }
  /**
   *  @return ARGB representation of color, assuming the color was viewed in
   *     default viewing conditions, which are near-identical to the default
   *     viewing conditions for sRGB.
   */
  toInt() {
    return this.viewed(Qs.DEFAULT);
  }
  /**
   * @param viewingConditions Information about the environment where the color
   *     will be viewed.
   * @return ARGB representation of color
   */
  viewed(t) {
    const e = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100), i = Math.pow(e / Math.pow(1.64 - Math.pow(0.29, t.n), 0.73), 1 / 0.9), s = this.hue * Math.PI / 180, r = 0.25 * (Math.cos(s + 2) + 3.8), a = t.aw * Math.pow(this.j / 100, 1 / t.c / t.z), o = r * (5e4 / 13) * t.nc * t.ncb, l = a / t.nbb, h = Math.sin(s), u = Math.cos(s), p = 23 * (l + 0.305) * i / (23 * o + 11 * i * u + 108 * i * h), y = p * u, m = p * h, w = (460 * l + 451 * y + 288 * m) / 1403, b = (460 * l - 891 * y - 261 * m) / 1403, $ = (460 * l - 220 * y - 6300 * m) / 1403, x = Math.max(0, 27.13 * Math.abs(w) / (400 - Math.abs(w))), C = di(w) * (100 / t.fl) * Math.pow(x, 1 / 0.42), R = Math.max(0, 27.13 * Math.abs(b) / (400 - Math.abs(b))), E = di(b) * (100 / t.fl) * Math.pow(R, 1 / 0.42), A = Math.max(0, 27.13 * Math.abs($) / (400 - Math.abs($))), I = di($) * (100 / t.fl) * Math.pow(A, 1 / 0.42), Z = C / t.rgbD[0], j = E / t.rgbD[1], N = I / t.rgbD[2], ut = 1.86206786 * Z - 1.01125463 * j + 0.14918677 * N, ct = 0.38752654 * Z + 0.62144744 * j - 897398e-8 * N, K = -0.0158415 * Z - 0.03412294 * j + 1.04996444 * N;
    return zE(ut, ct, K);
  }
  /// Given color expressed in XYZ and viewed in [viewingConditions], convert to
  /// CAM16.
  static fromXyzInViewingConditions(t, e, i, s) {
    const r = 0.401288 * t + 0.650173 * e - 0.051461 * i, a = -0.250268 * t + 1.204414 * e + 0.045854 * i, o = -2079e-6 * t + 0.048952 * e + 0.953127 * i, l = s.rgbD[0] * r, h = s.rgbD[1] * a, u = s.rgbD[2] * o, p = Math.pow(s.fl * Math.abs(l) / 100, 0.42), y = Math.pow(s.fl * Math.abs(h) / 100, 0.42), m = Math.pow(s.fl * Math.abs(u) / 100, 0.42), w = di(l) * 400 * p / (p + 27.13), b = di(h) * 400 * y / (y + 27.13), $ = di(u) * 400 * m / (m + 27.13), x = (11 * w + -12 * b + $) / 11, C = (w + b - 2 * $) / 9, R = (20 * w + 20 * b + 21 * $) / 20, E = (40 * w + 20 * b + $) / 20, A = Math.atan2(C, x) * 180 / Math.PI, I = A < 0 ? A + 360 : A >= 360 ? A - 360 : A, Z = I * Math.PI / 180, j = E * s.nbb, N = 100 * Math.pow(j / s.aw, s.c * s.z), ut = 4 / s.c * Math.sqrt(N / 100) * (s.aw + 4) * s.fLRoot, ct = I < 20.14 ? I + 360 : I, K = 1 / 4 * (Math.cos(ct * Math.PI / 180 + 2) + 3.8), wt = 5e4 / 13 * K * s.nc * s.ncb * Math.sqrt(x * x + C * C) / (R + 0.305), it = Math.pow(wt, 0.9) * Math.pow(1.64 - Math.pow(0.29, s.n), 0.73), At = it * Math.sqrt(N / 100), kt = At * s.fLRoot, Zt = 50 * Math.sqrt(it * s.c / (s.aw + 4)), Dt = (1 + 100 * 7e-3) * N / (1 + 7e-3 * N), Wt = Math.log(1 + 0.0228 * kt) / 0.0228, Oi = Wt * Math.cos(Z), _e = Wt * Math.sin(Z);
    return new Wi(I, At, N, ut, kt, Zt, Dt, Oi, _e);
  }
  /// XYZ representation of CAM16 seen in [viewingConditions].
  xyzInViewingConditions(t) {
    const e = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100), i = Math.pow(e / Math.pow(1.64 - Math.pow(0.29, t.n), 0.73), 1 / 0.9), s = this.hue * Math.PI / 180, r = 0.25 * (Math.cos(s + 2) + 3.8), a = t.aw * Math.pow(this.j / 100, 1 / t.c / t.z), o = r * (5e4 / 13) * t.nc * t.ncb, l = a / t.nbb, h = Math.sin(s), u = Math.cos(s), p = 23 * (l + 0.305) * i / (23 * o + 11 * i * u + 108 * i * h), y = p * u, m = p * h, w = (460 * l + 451 * y + 288 * m) / 1403, b = (460 * l - 891 * y - 261 * m) / 1403, $ = (460 * l - 220 * y - 6300 * m) / 1403, x = Math.max(0, 27.13 * Math.abs(w) / (400 - Math.abs(w))), C = di(w) * (100 / t.fl) * Math.pow(x, 1 / 0.42), R = Math.max(0, 27.13 * Math.abs(b) / (400 - Math.abs(b))), E = di(b) * (100 / t.fl) * Math.pow(R, 1 / 0.42), A = Math.max(0, 27.13 * Math.abs($) / (400 - Math.abs($))), I = di($) * (100 / t.fl) * Math.pow(A, 1 / 0.42), Z = C / t.rgbD[0], j = E / t.rgbD[1], N = I / t.rgbD[2], ut = 1.86206786 * Z - 1.01125463 * j + 0.14918677 * N, ct = 0.38752654 * Z + 0.62144744 * j - 897398e-8 * N, K = -0.0158415 * Z - 0.03412294 * j + 1.04996444 * N;
    return [ut, ct, K];
  }
}, c(Wi, "fi"), Wi);
d(WE, "Cam16");
let Un = WE;
var vt;
const qE = (vt = class {
  /**
   * Sanitizes a small enough angle in radians.
   *
   * @param angle An angle in radians; must not deviate too much
   * from 0.
   * @return A coterminal angle between 0 and 2pi.
   */
  static sanitizeRadians(t) {
    return (t + Math.PI * 8) % (Math.PI * 2);
  }
  /**
   * Delinearizes an RGB component, returning a floating-point
   * number.
   *
   * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents
   * linear R/G/B channel
   * @return 0.0 <= output <= 255.0, color channel converted to
   * regular RGB space
   */
  static trueDelinearized(t) {
    const e = t / 100;
    let i = 0;
    return e <= 31308e-7 ? i = e * 12.92 : i = 1.055 * Math.pow(e, 1 / 2.4) - 0.055, i * 255;
  }
  static chromaticAdaptation(t) {
    const e = Math.pow(Math.abs(t), 0.42);
    return di(t) * 400 * e / (e + 27.13);
  }
  /**
   * Returns the hue of a linear RGB color in CAM16.
   *
   * @param linrgb The linear RGB coordinates of a color.
   * @return The hue of the color in CAM16, in radians.
   */
  static hueOf(t) {
    const e = qv(t, vt.SCALED_DISCOUNT_FROM_LINRGB), i = vt.chromaticAdaptation(e[0]), s = vt.chromaticAdaptation(e[1]), r = vt.chromaticAdaptation(e[2]), a = (11 * i + -12 * s + r) / 11, o = (i + s - 2 * r) / 9;
    return Math.atan2(o, a);
  }
  static areInCyclicOrder(t, e, i) {
    const s = vt.sanitizeRadians(e - t), r = vt.sanitizeRadians(i - t);
    return s < r;
  }
  /**
   * Solves the lerp equation.
   *
   * @param source The starting number.
   * @param mid The number in the middle.
   * @param target The ending number.
   * @return A number t such that lerp(source, target, t) = mid.
   */
  static intercept(t, e, i) {
    return (e - t) / (i - t);
  }
  static lerpPoint(t, e, i) {
    return [
      t[0] + (i[0] - t[0]) * e,
      t[1] + (i[1] - t[1]) * e,
      t[2] + (i[2] - t[2]) * e
    ];
  }
  /**
   * Intersects a segment with a plane.
   *
   * @param source The coordinates of point A.
   * @param coordinate The R-, G-, or B-coordinate of the plane.
   * @param target The coordinates of point B.
   * @param axis The axis the plane is perpendicular with. (0: R, 1:
   * G, 2: B)
   * @return The intersection point of the segment AB with the plane
   * R=coordinate, G=coordinate, or B=coordinate
   */
  static setCoordinate(t, e, i, s) {
    const r = vt.intercept(t[s], e, i[s]);
    return vt.lerpPoint(t, r, i);
  }
  static isBounded(t) {
    return 0 <= t && t <= 100;
  }
  /**
   * Returns the nth possible vertex of the polygonal intersection.
   *
   * @param y The Y value of the plane.
   * @param n The zero-based index of the point. 0 <= n <= 11.
   * @return The nth possible vertex of the polygonal intersection
   * of the y plane and the RGB cube, in linear RGB coordinates, if
   * it exists. If this possible vertex lies outside of the cube,
   * [-1.0, -1.0, -1.0] is returned.
   */
  static nthVertex(t, e) {
    const i = vt.Y_FROM_LINRGB[0], s = vt.Y_FROM_LINRGB[1], r = vt.Y_FROM_LINRGB[2], a = e % 4 <= 1 ? 0 : 100, o = e % 2 === 0 ? 0 : 100;
    if (e < 4) {
      const l = a, h = o, u = (t - l * s - h * r) / i;
      return vt.isBounded(u) ? [u, l, h] : [-1, -1, -1];
    } else if (e < 8) {
      const l = a, h = o, u = (t - h * i - l * r) / s;
      return vt.isBounded(u) ? [h, u, l] : [-1, -1, -1];
    } else {
      const l = a, h = o, u = (t - l * i - h * s) / r;
      return vt.isBounded(u) ? [l, h, u] : [-1, -1, -1];
    }
  }
  /**
   * Finds the segment containing the desired color.
   *
   * @param y The Y value of the color.
   * @param targetHue The hue of the color.
   * @return A list of two sets of linear RGB coordinates, each
   * corresponding to an endpoint of the segment containing the
   * desired color.
   */
  static bisectToSegment(t, e) {
    let i = [-1, -1, -1], s = i, r = 0, a = 0, o = !1, l = !0;
    for (let h = 0; h < 12; h++) {
      const u = vt.nthVertex(t, h);
      if (u[0] < 0)
        continue;
      const p = vt.hueOf(u);
      if (!o) {
        i = u, s = u, r = p, a = p, o = !0;
        continue;
      }
      (l || vt.areInCyclicOrder(r, p, a)) && (l = !1, vt.areInCyclicOrder(r, e, p) ? (s = u, a = p) : (i = u, r = p));
    }
    return [i, s];
  }
  static midpoint(t, e) {
    return [
      (t[0] + e[0]) / 2,
      (t[1] + e[1]) / 2,
      (t[2] + e[2]) / 2
    ];
  }
  static criticalPlaneBelow(t) {
    return Math.floor(t - 0.5);
  }
  static criticalPlaneAbove(t) {
    return Math.ceil(t - 0.5);
  }
  /**
   * Finds a color with the given Y and hue on the boundary of the
   * cube.
   *
   * @param y The Y value of the color.
   * @param targetHue The hue of the color.
   * @return The desired color, in linear RGB coordinates.
   */
  static bisectToLimit(t, e) {
    const i = vt.bisectToSegment(t, e);
    let s = i[0], r = vt.hueOf(s), a = i[1];
    for (let o = 0; o < 3; o++)
      if (s[o] !== a[o]) {
        let l = -1, h = 255;
        s[o] < a[o] ? (l = vt.criticalPlaneBelow(vt.trueDelinearized(s[o])), h = vt.criticalPlaneAbove(vt.trueDelinearized(a[o]))) : (l = vt.criticalPlaneAbove(vt.trueDelinearized(s[o])), h = vt.criticalPlaneBelow(vt.trueDelinearized(a[o])));
        for (let u = 0; u < 8 && !(Math.abs(h - l) <= 1); u++) {
          const p = Math.floor((l + h) / 2), y = vt.CRITICAL_PLANES[p], m = vt.setCoordinate(s, y, a, o), w = vt.hueOf(m);
          vt.areInCyclicOrder(r, e, w) ? (a = m, h = p) : (s = m, r = w, l = p);
        }
      }
    return vt.midpoint(s, a);
  }
  static inverseChromaticAdaptation(t) {
    const e = Math.abs(t), i = Math.max(0, 27.13 * e / (400 - e));
    return di(t) * Math.pow(i, 1 / 0.42);
  }
  /**
   * Finds a color with the given hue, chroma, and Y.
   *
   * @param hueRadians The desired hue in radians.
   * @param chroma The desired chroma.
   * @param y The desired Y.
   * @return The desired color as a hexadecimal integer, if found; 0
   * otherwise.
   */
  static findResultByJ(t, e, i) {
    let s = Math.sqrt(i) * 11;
    const r = Qs.DEFAULT, a = 1 / Math.pow(1.64 - Math.pow(0.29, r.n), 0.73), o = 0.25 * (Math.cos(t + 2) + 3.8) * (5e4 / 13) * r.nc * r.ncb, l = Math.sin(t), h = Math.cos(t);
    for (let u = 0; u < 5; u++) {
      const p = s / 100, y = e === 0 || s === 0 ? 0 : e / Math.sqrt(p), m = Math.pow(y * a, 1 / 0.9), w = r.aw * Math.pow(p, 1 / r.c / r.z) / r.nbb, b = 23 * (w + 0.305) * m / (23 * o + 11 * m * h + 108 * m * l), $ = b * h, x = b * l, C = (460 * w + 451 * $ + 288 * x) / 1403, R = (460 * w - 891 * $ - 261 * x) / 1403, E = (460 * w - 220 * $ - 6300 * x) / 1403, A = vt.inverseChromaticAdaptation(C), I = vt.inverseChromaticAdaptation(R), Z = vt.inverseChromaticAdaptation(E), j = qv([A, I, Z], vt.LINRGB_FROM_SCALED_DISCOUNT);
      if (j[0] < 0 || j[1] < 0 || j[2] < 0)
        return 0;
      const N = vt.Y_FROM_LINRGB[0], ut = vt.Y_FROM_LINRGB[1], ct = vt.Y_FROM_LINRGB[2], K = N * j[0] + ut * j[1] + ct * j[2];
      if (K <= 0)
        return 0;
      if (u === 4 || Math.abs(K - i) < 2e-3)
        return j[0] > 100.01 || j[1] > 100.01 || j[2] > 100.01 ? 0 : vk(j);
      s = s - (K - i) * s / (2 * K);
    }
    return 0;
  }
  /**
   * Finds an sRGB color with the given hue, chroma, and L*, if
   * possible.
   *
   * @param hueDegrees The desired hue, in degrees.
   * @param chroma The desired chroma.
   * @param lstar The desired L*.
   * @return A hexadecimal representing the sRGB color. The color
   * has sufficiently close hue, chroma, and L* to the desired
   * values, if possible; otherwise, the hue and L* will be
   * sufficiently close, and chroma will be maximized.
   */
  static solveToInt(t, e, i) {
    if (e < 1e-4 || i < 1e-4 || i > 99.9999)
      return IE(i);
    t = qb(t);
    const s = t / 180 * Math.PI, r = Cs(i), a = vt.findResultByJ(s, e, r);
    if (a !== 0)
      return a;
    const o = vt.bisectToLimit(r, s);
    return vk(o);
  }
  /**
   * Finds an sRGB color with the given hue, chroma, and L*, if
   * possible.
   *
   * @param hueDegrees The desired hue, in degrees.
   * @param chroma The desired chroma.
   * @param lstar The desired L*.
   * @return An CAM16 object representing the sRGB color. The color
   * has sufficiently close hue, chroma, and L* to the desired
   * values, if possible; otherwise, the hue and L* will be
   * sufficiently close, and chroma will be maximized.
   */
  static solveToCam(t, e, i) {
    return Un.fromInt(vt.solveToInt(t, e, i));
  }
}, c(vt, "rt"), vt);
d(qE, "HctSolver");
let xr = qE;
xr.SCALED_DISCOUNT_FROM_LINRGB = [
  [
    0.001200833568784504,
    0.002389694492170889,
    2795742885861124e-19
  ],
  [
    5891086651375999e-19,
    0.0029785502573438758,
    3270666104008398e-19
  ],
  [
    10146692491640572e-20,
    5364214359186694e-19,
    0.0032979401770712076
  ]
];
xr.LINRGB_FROM_SCALED_DISCOUNT = [
  [
    1373.2198709594231,
    -1100.4251190754821,
    -7.278681089101213
  ],
  [
    -271.815969077903,
    559.6580465940733,
    -32.46047482791194
  ],
  [
    1.9622899599665666,
    -57.173814538844006,
    308.7233197812385
  ]
];
xr.Y_FROM_LINRGB = [0.2126, 0.7152, 0.0722];
xr.CRITICAL_PLANES = [
  0.015176349177441876,
  0.045529047532325624,
  0.07588174588720938,
  0.10623444424209313,
  0.13658714259697685,
  0.16693984095186062,
  0.19729253930674434,
  0.2276452376616281,
  0.2579979360165119,
  0.28835063437139563,
  0.3188300904430532,
  0.350925934958123,
  0.3848314933096426,
  0.42057480301049466,
  0.458183274052838,
  0.4976837250274023,
  0.5391024159806381,
  0.5824650784040898,
  0.6277969426914107,
  0.6751227633498623,
  0.7244668422128921,
  0.775853049866786,
  0.829304845476233,
  0.8848452951698498,
  0.942497089126609,
  1.0022825574869039,
  1.0642236851973577,
  1.1283421258858297,
  1.1946592148522128,
  1.2631959812511864,
  1.3339731595349034,
  1.407011200216447,
  1.4823302800086415,
  1.5599503113873272,
  1.6398909516233677,
  1.7221716113234105,
  1.8068114625156377,
  1.8938294463134073,
  1.9832442801866852,
  2.075074464868551,
  2.1693382909216234,
  2.2660538449872063,
  2.36523901573795,
  2.4669114995532007,
  2.5710888059345764,
  2.6777882626779785,
  2.7870270208169257,
  2.898822059350997,
  3.0131901897720907,
  3.1301480604002863,
  3.2497121605402226,
  3.3718988244681087,
  3.4967242352587946,
  3.624204428461639,
  3.754355295633311,
  3.887192587735158,
  4.022731918402185,
  4.160988767090289,
  4.301978482107941,
  4.445716283538092,
  4.592217266055746,
  4.741496401646282,
  4.893568542229298,
  5.048448422192488,
  5.20615066083972,
  5.3666897647573375,
  5.5300801301023865,
  5.696336044816294,
  5.865471690767354,
  6.037501145825082,
  6.212438385869475,
  6.390297286737924,
  6.571091626112461,
  6.7548350853498045,
  6.941541251256611,
  7.131223617812143,
  7.323895587840543,
  7.5195704746346665,
  7.7182615035334345,
  7.919981813454504,
  8.124744458384042,
  8.332562408825165,
  8.543448553206703,
  8.757415699253682,
  8.974476575321063,
  9.194643831691977,
  9.417930041841839,
  9.644347703669503,
  9.873909240696694,
  10.106627003236781,
  10.342513269534024,
  10.58158024687427,
  10.8238400726681,
  11.069304815507364,
  11.317986476196008,
  11.569896988756009,
  11.825048221409341,
  12.083451977536606,
  12.345119996613247,
  12.610063955123938,
  12.878295467455942,
  13.149826086772048,
  13.42466730586372,
  13.702830557985108,
  13.984327217668513,
  14.269168601521828,
  14.55736596900856,
  14.848930523210871,
  15.143873411576273,
  15.44220572664832,
  15.743938506781891,
  16.04908273684337,
  16.35764934889634,
  16.66964922287304,
  16.985093187232053,
  17.30399201960269,
  17.62635644741625,
  17.95219714852476,
  18.281524751807332,
  18.614349837764564,
  18.95068293910138,
  19.290534541298456,
  19.633915083172692,
  19.98083495742689,
  20.331304511189067,
  20.685334046541502,
  21.042933821039977,
  21.404114048223256,
  21.76888489811322,
  22.137256497705877,
  22.50923893145328,
  22.884842241736916,
  23.264076429332462,
  23.6469514538663,
  24.033477234264016,
  24.42366364919083,
  24.817520537484558,
  25.21505769858089,
  25.61628489293138,
  26.021211842414342,
  26.429848230738664,
  26.842203703840827,
  27.258287870275353,
  27.678110301598522,
  28.10168053274597,
  28.529008062403893,
  28.96010235337422,
  29.39497283293396,
  29.83362889318845,
  30.276079891419332,
  30.722335150426627,
  31.172403958865512,
  31.62629557157785,
  32.08401920991837,
  32.54558406207592,
  33.010999283389665,
  33.4802739966603,
  33.953417292456834,
  34.430438229418264,
  34.911345834551085,
  35.39614910352207,
  35.88485700094671,
  36.37747846067349,
  36.87402238606382,
  37.37449765026789,
  37.87891309649659,
  38.38727753828926,
  38.89959975977785,
  39.41588851594697,
  39.93615253289054,
  40.460400508064545,
  40.98864111053629,
  41.520882981230194,
  42.05713473317016,
  42.597404951718396,
  43.141702194811224,
  43.6900349931913,
  44.24241185063697,
  44.798841244188324,
  45.35933162437017,
  45.92389141541209,
  46.49252901546552,
  47.065252796817916,
  47.64207110610409,
  48.22299226451468,
  48.808024568002054,
  49.3971762874833,
  49.9904556690408,
  50.587870934119984,
  51.189430279724725,
  51.79514187861014,
  52.40501387947288,
  53.0190544071392,
  53.637271562750364,
  54.259673423945976,
  54.88626804504493,
  55.517063457223934,
  56.15206766869424,
  56.79128866487574,
  57.43473440856916,
  58.08241284012621,
  58.734331877617365,
  59.39049941699807,
  60.05092333227251,
  60.715611475655585,
  61.38457167773311,
  62.057811747619894,
  62.7353394731159,
  63.417162620860914,
  64.10328893648692,
  64.79372614476921,
  65.48848194977529,
  66.18756403501224,
  66.89098006357258,
  67.59873767827808,
  68.31084450182222,
  69.02730813691093,
  69.74813616640164,
  70.47333615344107,
  71.20291564160104,
  71.93688215501312,
  72.67524319850172,
  73.41800625771542,
  74.16517879925733,
  74.9167682708136,
  75.67278210128072,
  76.43322770089146,
  77.1981124613393,
  77.96744375590167,
  78.74122893956174,
  79.51947534912904,
  80.30219030335869,
  81.08938110306934,
  81.88105503125999,
  82.67721935322541,
  83.4778813166706,
  84.28304815182372,
  85.09272707154808,
  85.90692527145302,
  86.72564993000343,
  87.54890820862819,
  88.3767072518277,
  89.2090541872801,
  90.04595612594655,
  90.88742016217518,
  91.73345337380438,
  92.58406282226491,
  93.43925555268066,
  94.29903859396902,
  95.16341895893969,
  96.03240364439274,
  96.9059996312159,
  97.78421388448044,
  98.6670533535366,
  99.55452497210776
];
var Ls;
const jE = (Ls = class {
  static from(t, e, i) {
    return new Ls(xr.solveToInt(t, e, i));
  }
  /**
   * @param argb ARGB representation of a color.
   * @return HCT representation of a color in default viewing conditions
   */
  static fromInt(t) {
    return new Ls(t);
  }
  toInt() {
    return this.argb;
  }
  /**
   * A number, in degrees, representing ex. red, orange, yellow, etc.
   * Ranges from 0 <= hue < 360.
   */
  get hue() {
    return this.internalHue;
  }
  /**
   * @param newHue 0 <= newHue < 360; invalid values are corrected.
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set hue(t) {
    this.setInternalState(xr.solveToInt(t, this.internalChroma, this.internalTone));
  }
  get chroma() {
    return this.internalChroma;
  }
  /**
   * @param newChroma 0 <= newChroma < ?
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set chroma(t) {
    this.setInternalState(xr.solveToInt(this.internalHue, t, this.internalTone));
  }
  /** Lightness. Ranges from 0 to 100. */
  get tone() {
    return this.internalTone;
  }
  /**
   * @param newTone 0 <= newTone <= 100; invalid valids are corrected.
   * Chroma may decrease because chroma has a different maximum for any given
   * hue and tone.
   */
  set tone(t) {
    this.setInternalState(xr.solveToInt(this.internalHue, this.internalChroma, t));
  }
  constructor(t) {
    this.argb = t;
    const e = Un.fromInt(t);
    this.internalHue = e.hue, this.internalChroma = e.chroma, this.internalTone = jv(t), this.argb = t;
  }
  setInternalState(t) {
    const e = Un.fromInt(t);
    this.internalHue = e.hue, this.internalChroma = e.chroma, this.internalTone = jv(t), this.argb = t;
  }
  /**
   * Translates a color into different [ViewingConditions].
   *
   * Colors change appearance. They look different with lights on versus off,
   * the same color, as in hex code, on white looks different when on black.
   * This is called color relativity, most famously explicated by Josef Albers
   * in Interaction of Color.
   *
   * In color science, color appearance models can account for this and
   * calculate the appearance of a color in different settings. HCT is based on
   * CAM16, a color appearance model, and uses it to make these calculations.
   *
   * See [ViewingConditions.make] for parameters affecting color appearance.
   */
  inViewingConditions(t) {
    const e = Un.fromInt(this.toInt()).xyzInViewingConditions(t), i = Un.fromXyzInViewingConditions(e[0], e[1], e[2], Qs.make());
    return Ls.from(i.hue, i.chroma, Fv(e[1]));
  }
}, c(Ls, "Wr"), Ls);
d(jE, "Hct");
let Pi = jE;
var Eo;
const FE = (Eo = class {
  /**
   * Blend the design color's HCT hue towards the key color's HCT
   * hue, in a way that leaves the original color recognizable and
   * recognizably shifted towards the key color.
   *
   * @param designColor ARGB representation of an arbitrary color.
   * @param sourceColor ARGB representation of the main theme color.
   * @return The design color with a hue shifted towards the
   * system's color, a slightly warmer/cooler variant of the design
   * color's hue.
   */
  static harmonize(t, e) {
    const i = Pi.fromInt(t), s = Pi.fromInt(e), r = _E(i.hue, s.hue), a = Math.min(r * 0.5, 15), o = qb(i.hue + a * EE(i.hue, s.hue));
    return Pi.from(o, i.chroma, i.tone).toInt();
  }
  /**
   * Blends hue from one color into another. The chroma and tone of
   * the original color are maintained.
   *
   * @param from ARGB representation of color
   * @param to ARGB representation of color
   * @param amount how much blending to perform; 0.0 >= and <= 1.0
   * @return from, with a hue blended towards to. Chroma and tone
   * are constant.
   */
  static hctHue(t, e, i) {
    const s = Eo.cam16Ucs(t, e, i), r = Un.fromInt(s), a = Un.fromInt(t);
    return Pi.from(r.hue, a.chroma, jv(t)).toInt();
  }
  /**
   * Blend in CAM16-UCS space.
   *
   * @param from ARGB representation of color
   * @param to ARGB representation of color
   * @param amount how much blending to perform; 0.0 >= and <= 1.0
   * @return from, blended towards to. Hue, chroma, and tone will
   * change.
   */
  static cam16Ucs(t, e, i) {
    const s = Un.fromInt(t), r = Un.fromInt(e), a = s.jstar, o = s.astar, l = s.bstar, h = r.jstar, u = r.astar, p = r.bstar, y = a + (h - a) * i, m = o + (u - o) * i, w = l + (p - l) * i;
    return Un.fromUcs(y, m, w).toInt();
  }
}, c(Eo, "bd"), Eo);
d(FE, "Blend");
let Zn = FE;
var yn;
const UE = (yn = class {
  /**
   * Returns a contrast ratio, which ranges from 1 to 21.
   *
   * @param toneA Tone between 0 and 100. Values outside will be clamped.
   * @param toneB Tone between 0 and 100. Values outside will be clamped.
   */
  static ratioOfTones(t, e) {
    return t = Rw(0, 100, t), e = Rw(0, 100, e), yn.ratioOfYs(Cs(t), Cs(e));
  }
  static ratioOfYs(t, e) {
    const i = t > e ? t : e, s = i === e ? t : e;
    return (i + 5) / (s + 5);
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns -1 if ratio cannot be achieved with tone parameter.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in -1 being returned.
   * @param ratio Contrast ratio of return value and tone.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static lighter(t, e) {
    if (t < 0 || t > 100)
      return -1;
    const i = Cs(t), s = e * (i + 5) - 5, r = yn.ratioOfYs(s, i), a = Math.abs(r - e);
    if (r < e && a > 0.04)
      return -1;
    const o = Fv(s) + 0.4;
    return o < 0 || o > 100 ? -1 : o;
  }
  /**
   * Returns a tone <= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns -1 if ratio cannot be achieved with tone parameter.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in -1 being returned.
   * @param ratio Contrast ratio of return value and tone.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static darker(t, e) {
    if (t < 0 || t > 100)
      return -1;
    const i = Cs(t), s = (i + 5) / e - 5, r = yn.ratioOfYs(i, s), a = Math.abs(r - e);
    if (r < e && a > 0.04)
      return -1;
    const o = Fv(s) - 0.4;
    return o < 0 || o > 100 ? -1 : o;
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns 100 if ratio cannot be achieved with tone parameter.
   *
   * This method is unsafe because the returned value is guaranteed to be in
   * bounds for tone, i.e. between 0 and 100. However, that value may not reach
   * the ratio with tone. For example, there is no color lighter than T100.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in 100 being returned.
   * @param ratio Desired contrast ratio of return value and tone parameter.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static lighterUnsafe(t, e) {
    const i = yn.lighter(t, e);
    return i < 0 ? 100 : i;
  }
  /**
   * Returns a tone >= tone parameter that ensures ratio parameter.
   * Return value is between 0 and 100.
   * Returns 100 if ratio cannot be achieved with tone parameter.
   *
   * This method is unsafe because the returned value is guaranteed to be in
   * bounds for tone, i.e. between 0 and 100. However, that value may not reach
   * the [ratio with [tone]. For example, there is no color darker than T0.
   *
   * @param tone Tone return value must contrast with.
   * Range is 0 to 100. Invalid values will result in 0 being returned.
   * @param ratio Desired contrast ratio of return value and tone parameter.
   * Range is 1 to 21, invalid values have undefined behavior.
   */
  static darkerUnsafe(t, e) {
    const i = yn.darker(t, e);
    return i < 0 ? 0 : i;
  }
}, c(yn, "os"), yn);
d(UE, "Contrast");
let Hi = UE;
var _o;
const BE = (_o = class {
  /**
   * Returns true if a color is disliked.
   *
   * @param hct A color to be judged.
   * @return Whether the color is disliked.
   *
   * Disliked is defined as a dark yellow-green that is not neutral.
   */
  static isDisliked(t) {
    const e = Math.round(t.hue) >= 90 && Math.round(t.hue) <= 111, i = Math.round(t.chroma) > 16, s = Math.round(t.tone) < 65;
    return e && i && s;
  }
  /**
   * If a color is disliked, lighten it to make it likable.
   *
   * @param hct A color to be judged.
   * @return A new color if the original color is disliked, or the original
   *   color if it is acceptable.
   */
  static fixIfDisliked(t) {
    return _o.isDisliked(t) ? Pi.from(t.hue, t.chroma, 70) : t;
  }
}, c(_o, "xd"), _o);
d(BE, "DislikeAnalyzer");
let gU = BE;
var We;
const XE = (We = class {
  /**
   * Create a DynamicColor defined by a TonalPalette and HCT tone.
   *
   * @param args Functions with DynamicScheme as input. Must provide a palette
   * and tone. May provide a background DynamicColor and ToneDeltaConstraint.
   */
  static fromPalette(t) {
    return new We(t.name ?? "", t.palette, t.tone, t.isBackground ?? !1, t.background, t.secondBackground, t.contrastCurve, t.toneDeltaPair);
  }
  /**
   * The base constructor for DynamicColor.
   *
   * _Strongly_ prefer using one of the convenience constructors. This class is
   * arguably too flexible to ensure it can support any scenario. Functional
   * arguments allow  overriding without risks that come with subclasses.
   *
   * For example, the default behavior of adjust tone at max contrast
   * to be at a 7.0 ratio with its background is principled and
   * matches accessibility guidance. That does not mean it's the desired
   * approach for _every_ design system, and every color pairing,
   * always, in every case.
   *
   * @param name The name of the dynamic color. Defaults to empty.
   * @param palette Function that provides a TonalPalette given
   * DynamicScheme. A TonalPalette is defined by a hue and chroma, so this
   * replaces the need to specify hue/chroma. By providing a tonal palette, when
   * contrast adjustments are made, intended chroma can be preserved.
   * @param tone Function that provides a tone, given a DynamicScheme.
   * @param isBackground Whether this dynamic color is a background, with
   * some other color as the foreground. Defaults to false.
   * @param background The background of the dynamic color (as a function of a
   *     `DynamicScheme`), if it exists.
   * @param secondBackground A second background of the dynamic color (as a
   *     function of a `DynamicScheme`), if it
   * exists.
   * @param contrastCurve A `ContrastCurve` object specifying how its contrast
   * against its background should behave in various contrast levels options.
   * @param toneDeltaPair A `ToneDeltaPair` object specifying a tone delta
   * constraint between two colors. One of them must be the color being
   * constructed.
   */
  constructor(t, e, i, s, r, a, o, l) {
    if (this.name = t, this.palette = e, this.tone = i, this.isBackground = s, this.background = r, this.secondBackground = a, this.contrastCurve = o, this.toneDeltaPair = l, this.hctCache = /* @__PURE__ */ new Map(), !r && a)
      throw new Error(`Color ${t} has secondBackgrounddefined, but background is not defined.`);
    if (!r && o)
      throw new Error(`Color ${t} has contrastCurvedefined, but background is not defined.`);
    if (r && !o)
      throw new Error(`Color ${t} has backgrounddefined, but contrastCurve is not defined.`);
  }
  /**
   * Return a ARGB integer (i.e. a hex code).
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getArgb(t) {
    return this.getHct(t).toInt();
  }
  /**
   * Return a color, expressed in the HCT color space, that this
   * DynamicColor is under the conditions in scheme.
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getHct(t) {
    const e = this.hctCache.get(t);
    if (e != null)
      return e;
    const i = this.getTone(t), s = this.palette(t).getHct(i);
    return this.hctCache.size > 4 && this.hctCache.clear(), this.hctCache.set(t, s), s;
  }
  /**
   * Return a tone, T in the HCT color space, that this DynamicColor is under
   * the conditions in scheme.
   *
   * @param scheme Defines the conditions of the user interface, for example,
   * whether or not it is dark mode or light mode, and what the desired
   * contrast level is.
   */
  getTone(t) {
    const e = t.contrastLevel < 0;
    if (this.toneDeltaPair) {
      const i = this.toneDeltaPair(t), s = i.roleA, r = i.roleB, a = i.delta, o = i.polarity, l = i.stayTogether, h = this.background(t).getTone(t), u = o === "nearer" || o === "lighter" && !t.isDark || o === "darker" && t.isDark, p = u ? s : r, y = u ? r : s, m = this.name === p.name, w = t.isDark ? 1 : -1, b = p.contrastCurve.getContrast(t.contrastLevel), $ = y.contrastCurve.getContrast(t.contrastLevel), x = p.tone(t);
      let C = Hi.ratioOfTones(h, x) >= b ? x : We.foregroundTone(h, b);
      const R = y.tone(t);
      let E = Hi.ratioOfTones(h, R) >= $ ? R : We.foregroundTone(h, $);
      return e && (C = We.foregroundTone(h, b), E = We.foregroundTone(h, $)), (E - C) * w >= a || (E = Rw(0, 100, C + a * w), (E - C) * w >= a || (C = Rw(0, 100, E - a * w))), 50 <= C && C < 60 ? w > 0 ? (C = 60, E = Math.max(E, C + a * w)) : (C = 49, E = Math.min(E, C + a * w)) : 50 <= E && E < 60 && (l ? w > 0 ? (C = 60, E = Math.max(E, C + a * w)) : (C = 49, E = Math.min(E, C + a * w)) : w > 0 ? E = 60 : E = 49), m ? C : E;
    } else {
      let i = this.tone(t);
      if (this.background == null)
        return i;
      const s = this.background(t).getTone(t), r = this.contrastCurve.getContrast(t.contrastLevel);
      if (Hi.ratioOfTones(s, i) >= r || (i = We.foregroundTone(s, r)), e && (i = We.foregroundTone(s, r)), this.isBackground && 50 <= i && i < 60 && (Hi.ratioOfTones(49, s) >= r ? i = 49 : i = 60), this.secondBackground) {
        const [a, o] = [this.background, this.secondBackground], [l, h] = [a(t).getTone(t), o(t).getTone(t)], [u, p] = [Math.max(l, h), Math.min(l, h)];
        if (Hi.ratioOfTones(u, i) >= r && Hi.ratioOfTones(p, i) >= r)
          return i;
        const y = Hi.lighter(u, r), m = Hi.darker(p, r), w = [];
        return y !== -1 && w.push(y), m !== -1 && w.push(m), We.tonePrefersLightForeground(l) || We.tonePrefersLightForeground(h) ? y < 0 ? 100 : y : w.length === 1 ? w[0] : m < 0 ? 0 : m;
      }
      return i;
    }
  }
  /**
   * Given a background tone, find a foreground tone, while ensuring they reach
   * a contrast ratio that is as close to [ratio] as possible.
   *
   * @param bgTone Tone in HCT. Range is 0 to 100, undefined behavior when it
   *     falls outside that range.
   * @param ratio The contrast ratio desired between bgTone and the return
   *     value.
   */
  static foregroundTone(t, e) {
    const i = Hi.lighterUnsafe(t, e), s = Hi.darkerUnsafe(t, e), r = Hi.ratioOfTones(i, t), a = Hi.ratioOfTones(s, t);
    if (We.tonePrefersLightForeground(t)) {
      const o = Math.abs(r - a) < 0.1 && r < e && a < e;
      return r >= e || r >= a || o ? i : s;
    } else
      return a >= e || a >= r ? s : i;
  }
  /**
   * Returns whether [tone] prefers a light foreground.
   *
   * People prefer white foregrounds on ~T60-70. Observed over time, and also
   * by Andrew Somers during research for APCA.
   *
   * T60 used as to create the smallest discontinuity possible when skipping
   * down to T49 in order to ensure light foregrounds.
   * Since `tertiaryContainer` in dark monochrome scheme requires a tone of
   * 60, it should not be adjusted. Therefore, 60 is excluded here.
   */
  static tonePrefersLightForeground(t) {
    return Math.round(t) < 60;
  }
  /**
   * Returns whether [tone] can reach a contrast ratio of 4.5 with a lighter
   * color.
   */
  static toneAllowsLightForeground(t) {
    return Math.round(t) <= 49;
  }
  /**
   * Adjust a tone such that white has 4.5 contrast, if the tone is
   * reasonably close to supporting it.
   */
  static enableLightForeground(t) {
    return We.tonePrefersLightForeground(t) && !We.toneAllowsLightForeground(t) ? 49 : t;
  }
}, c(We, "ke"), We);
d(XE, "DynamicColor");
let lt = XE;
var Ew;
(function(n) {
  n[n.MONOCHROME = 0] = "MONOCHROME", n[n.NEUTRAL = 1] = "NEUTRAL", n[n.TONAL_SPOT = 2] = "TONAL_SPOT", n[n.VIBRANT = 3] = "VIBRANT", n[n.EXPRESSIVE = 4] = "EXPRESSIVE", n[n.FIDELITY = 5] = "FIDELITY", n[n.CONTENT = 6] = "CONTENT", n[n.RAINBOW = 7] = "RAINBOW", n[n.FRUIT_SALAD = 8] = "FRUIT_SALAD";
})(Ew || (Ew = {}));
var Cu;
const NE = (Cu = class {
  /**
   * Creates a `ContrastCurve` object.
   *
   * @param low Contrast requirement for contrast level -1.0
   * @param normal Contrast requirement for contrast level 0.0
   * @param medium Contrast requirement for contrast level 0.5
   * @param high Contrast requirement for contrast level 1.0
   */
  constructor(t, e, i, s) {
    this.low = t, this.normal = e, this.medium = i, this.high = s;
  }
  /**
   * Returns the contrast ratio at a given contrast level.
   *
   * @param contrastLevel The contrast level. 0.0 is the default (normal);
   * -1.0 is the lowest; 1.0 is the highest.
   * @return The contrast ratio, a number between 1.0 and 21.0.
   */
  getContrast(t) {
    return t <= -1 ? this.low : t < 0 ? Uc(this.low, this.normal, (t - -1) / 1) : t < 0.5 ? Uc(this.normal, this.medium, (t - 0) / 0.5) : t < 1 ? Uc(this.medium, this.high, (t - 0.5) / 0.5) : this.high;
  }
}, c(Cu, "Sp"), Cu);
d(NE, "ContrastCurve");
let Et = NE;
var Qu;
const HE = (Qu = class {
  /**
   * Documents a constraint in tone distance between two DynamicColors.
   *
   * The polarity is an adjective that describes "A", compared to "B".
   *
   * For instance, ToneDeltaPair(A, B, 15, 'darker', stayTogether) states that
   * A's tone should be at least 15 darker than B's.
   *
   * 'nearer' and 'farther' describes closeness to the surface roles. For
   * instance, ToneDeltaPair(A, B, 10, 'nearer', stayTogether) states that A
   * should be 10 lighter than B in light mode, and 10 darker than B in dark
   * mode.
   *
   * @param roleA The first role in a pair.
   * @param roleB The second role in a pair.
   * @param delta Required difference between tones. Absolute value, negative
   * values have undefined behavior.
   * @param polarity The relative relation between tones of roleA and roleB,
   * as described above.
   * @param stayTogether Whether these two roles should stay on the same side of
   * the "awkward zone" (T50-59). This is necessary for certain cases where
   * one role has two backgrounds.
   */
  constructor(t, e, i, s, r) {
    this.roleA = t, this.roleB = e, this.delta = i, this.polarity = s, this.stayTogether = r;
  }
}, c(Qu, "Ap"), Qu);
d(HE, "ToneDeltaPair");
let Ri = HE;
function cl(n) {
  return n.variant === Ew.FIDELITY || n.variant === Ew.CONTENT;
}
c(cl, "sc");
d(cl, "isFidelity");
function me(n) {
  return n.variant === Ew.MONOCHROME;
}
c(me, "Wt");
d(me, "isMonochrome");
function YE(n, t, e, i) {
  let s = e, r = Pi.from(n, t, e);
  if (r.chroma < t) {
    let a = r.chroma;
    for (; r.chroma < t; ) {
      s += i ? -1 : 1;
      const o = Pi.from(n, t, s);
      if (a > o.chroma || Math.abs(o.chroma - t) < 0.4)
        break;
      const l = Math.abs(o.chroma - t), h = Math.abs(r.chroma - t);
      l < h && (r = o), a = Math.max(a, o.chroma);
    }
  }
  return s;
}
c(YE, "P1");
d(YE, "findDesiredChromaByTone");
function GE(n) {
  return Qs.make(
    /*whitePoint=*/
    void 0,
    /*adaptingLuminance=*/
    void 0,
    /*backgroundLstar=*/
    n.isDark ? 30 : 80,
    /*surround=*/
    void 0,
    /*discountingIlluminant=*/
    void 0
  );
}
c(GE, "S1");
d(GE, "viewingConditionsForAlbers");
function Fb(n, t) {
  const e = n.inViewingConditions(GE(t));
  return lt.tonePrefersLightForeground(n.tone) && !lt.toneAllowsLightForeground(e.tone) ? lt.enableLightForeground(n.tone) : lt.enableLightForeground(e.tone);
}
c(Fb, "tp");
d(Fb, "performAlbers");
var Xr;
const KE = (Xr = class {
  static highestSurface(t) {
    return t.isDark ? Xr.surfaceBright : Xr.surfaceDim;
  }
}, c(Xr, "$c"), Xr);
d(KE, "MaterialDynamicColors");
let D = KE;
D.contentAccentToneDelta = 15;
D.primaryPaletteKeyColor = lt.fromPalette({
  name: "primary_palette_key_color",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.primaryPalette.keyColor.tone, "tone")
});
D.secondaryPaletteKeyColor = lt.fromPalette({
  name: "secondary_palette_key_color",
  palette: /* @__PURE__ */ d((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.secondaryPalette.keyColor.tone, "tone")
});
D.tertiaryPaletteKeyColor = lt.fromPalette({
  name: "tertiary_palette_key_color",
  palette: /* @__PURE__ */ d((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.tertiaryPalette.keyColor.tone, "tone")
});
D.neutralPaletteKeyColor = lt.fromPalette({
  name: "neutral_palette_key_color",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.neutralPalette.keyColor.tone, "tone")
});
D.neutralVariantPaletteKeyColor = lt.fromPalette({
  name: "neutral_variant_palette_key_color",
  palette: /* @__PURE__ */ d((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.neutralVariantPalette.keyColor.tone, "tone")
});
D.background = lt.fromPalette({
  name: "background",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 6 : 98, "tone"),
  isBackground: !0
});
D.onBackground = lt.fromPalette({
  name: "on_background",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ d((n) => D.background, "background"),
  contrastCurve: new Et(3, 3, 4.5, 7)
});
D.surface = lt.fromPalette({
  name: "surface",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 6 : 98, "tone"),
  isBackground: !0
});
D.surfaceDim = lt.fromPalette({
  name: "surface_dim",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 6 : 87, "tone"),
  isBackground: !0
});
D.surfaceBright = lt.fromPalette({
  name: "surface_bright",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 24 : 98, "tone"),
  isBackground: !0
});
D.surfaceContainerLowest = lt.fromPalette({
  name: "surface_container_lowest",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 4 : 100, "tone"),
  isBackground: !0
});
D.surfaceContainerLow = lt.fromPalette({
  name: "surface_container_low",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 10 : 96, "tone"),
  isBackground: !0
});
D.surfaceContainer = lt.fromPalette({
  name: "surface_container",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 12 : 94, "tone"),
  isBackground: !0
});
D.surfaceContainerHigh = lt.fromPalette({
  name: "surface_container_high",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 17 : 92, "tone"),
  isBackground: !0
});
D.surfaceContainerHighest = lt.fromPalette({
  name: "surface_container_highest",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 22 : 90, "tone"),
  isBackground: !0
});
D.onSurface = lt.fromPalette({
  name: "on_surface",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ d((n) => D.highestSurface(n), "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
D.surfaceVariant = lt.fromPalette({
  name: "surface_variant",
  palette: /* @__PURE__ */ d((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 30 : 90, "tone"),
  isBackground: !0
});
D.onSurfaceVariant = lt.fromPalette({
  name: "on_surface_variant",
  palette: /* @__PURE__ */ d((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 80 : 30, "tone"),
  background: /* @__PURE__ */ d((n) => D.highestSurface(n), "background"),
  contrastCurve: new Et(3, 4.5, 7, 11)
});
D.inverseSurface = lt.fromPalette({
  name: "inverse_surface",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 90 : 20, "tone")
});
D.inverseOnSurface = lt.fromPalette({
  name: "inverse_on_surface",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 20 : 95, "tone"),
  background: /* @__PURE__ */ d((n) => D.inverseSurface, "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
D.outline = lt.fromPalette({
  name: "outline",
  palette: /* @__PURE__ */ d((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 60 : 50, "tone"),
  background: /* @__PURE__ */ d((n) => D.highestSurface(n), "background"),
  contrastCurve: new Et(1.5, 3, 4.5, 7)
});
D.outlineVariant = lt.fromPalette({
  name: "outline_variant",
  palette: /* @__PURE__ */ d((n) => n.neutralVariantPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 30 : 80, "tone"),
  background: /* @__PURE__ */ d((n) => D.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7)
});
D.shadow = lt.fromPalette({
  name: "shadow",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => 0, "tone")
});
D.scrim = lt.fromPalette({
  name: "scrim",
  palette: /* @__PURE__ */ d((n) => n.neutralPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => 0, "tone")
});
D.surfaceTint = lt.fromPalette({
  name: "surface_tint",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 80 : 40, "tone"),
  isBackground: !0
});
D.primary = lt.fromPalette({
  name: "primary",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => me(n) ? n.isDark ? 100 : 0 : n.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => D.highestSurface(n), "background"),
  contrastCurve: new Et(3, 4.5, 7, 11),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(D.primaryContainer, D.primary, 15, "nearer", !1), "toneDeltaPair")
});
D.onPrimary = lt.fromPalette({
  name: "on_primary",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => me(n) ? n.isDark ? 10 : 90 : n.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ d((n) => D.primary, "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
D.primaryContainer = lt.fromPalette({
  name: "primary_container",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => cl(n) ? Fb(n.sourceColorHct, n) : me(n) ? n.isDark ? 85 : 25 : n.isDark ? 30 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => D.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(D.primaryContainer, D.primary, 15, "nearer", !1), "toneDeltaPair")
});
D.onPrimaryContainer = lt.fromPalette({
  name: "on_primary_container",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => cl(n) ? lt.foregroundTone(D.primaryContainer.tone(n), 4.5) : me(n) ? n.isDark ? 0 : 100 : n.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ d((n) => D.primaryContainer, "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
D.inversePrimary = lt.fromPalette({
  name: "inverse_primary",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 40 : 80, "tone"),
  background: /* @__PURE__ */ d((n) => D.inverseSurface, "background"),
  contrastCurve: new Et(3, 4.5, 7, 11)
});
D.secondary = lt.fromPalette({
  name: "secondary",
  palette: /* @__PURE__ */ d((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => D.highestSurface(n), "background"),
  contrastCurve: new Et(3, 4.5, 7, 11),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(D.secondaryContainer, D.secondary, 15, "nearer", !1), "toneDeltaPair")
});
D.onSecondary = lt.fromPalette({
  name: "on_secondary",
  palette: /* @__PURE__ */ d((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => me(n) ? n.isDark ? 10 : 100 : n.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ d((n) => D.secondary, "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
D.secondaryContainer = lt.fromPalette({
  name: "secondary_container",
  palette: /* @__PURE__ */ d((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => {
    const t = n.isDark ? 30 : 90;
    if (me(n))
      return n.isDark ? 30 : 85;
    if (!cl(n))
      return t;
    let e = YE(n.secondaryPalette.hue, n.secondaryPalette.chroma, t, !n.isDark);
    return e = Fb(n.secondaryPalette.getHct(e), n), e;
  }, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => D.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(D.secondaryContainer, D.secondary, 15, "nearer", !1), "toneDeltaPair")
});
D.onSecondaryContainer = lt.fromPalette({
  name: "on_secondary_container",
  palette: /* @__PURE__ */ d((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => cl(n) ? lt.foregroundTone(D.secondaryContainer.tone(n), 4.5) : n.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ d((n) => D.secondaryContainer, "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
D.tertiary = lt.fromPalette({
  name: "tertiary",
  palette: /* @__PURE__ */ d((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => me(n) ? n.isDark ? 90 : 25 : n.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => D.highestSurface(n), "background"),
  contrastCurve: new Et(3, 4.5, 7, 11),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(D.tertiaryContainer, D.tertiary, 15, "nearer", !1), "toneDeltaPair")
});
D.onTertiary = lt.fromPalette({
  name: "on_tertiary",
  palette: /* @__PURE__ */ d((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => me(n) ? n.isDark ? 10 : 90 : n.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ d((n) => D.tertiary, "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
D.tertiaryContainer = lt.fromPalette({
  name: "tertiary_container",
  palette: /* @__PURE__ */ d((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => {
    if (me(n))
      return n.isDark ? 60 : 49;
    if (!cl(n))
      return n.isDark ? 30 : 90;
    const t = Fb(n.tertiaryPalette.getHct(n.sourceColorHct.tone), n), e = n.tertiaryPalette.getHct(t);
    return gU.fixIfDisliked(e).tone;
  }, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => D.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(D.tertiaryContainer, D.tertiary, 15, "nearer", !1), "toneDeltaPair")
});
D.onTertiaryContainer = lt.fromPalette({
  name: "on_tertiary_container",
  palette: /* @__PURE__ */ d((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => me(n) ? n.isDark ? 0 : 100 : cl(n) ? lt.foregroundTone(D.tertiaryContainer.tone(n), 4.5) : n.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ d((n) => D.tertiaryContainer, "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
D.error = lt.fromPalette({
  name: "error",
  palette: /* @__PURE__ */ d((n) => n.errorPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 80 : 40, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => D.highestSurface(n), "background"),
  contrastCurve: new Et(3, 4.5, 7, 11),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(D.errorContainer, D.error, 15, "nearer", !1), "toneDeltaPair")
});
D.onError = lt.fromPalette({
  name: "on_error",
  palette: /* @__PURE__ */ d((n) => n.errorPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 20 : 100, "tone"),
  background: /* @__PURE__ */ d((n) => D.error, "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
D.errorContainer = lt.fromPalette({
  name: "error_container",
  palette: /* @__PURE__ */ d((n) => n.errorPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 30 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => D.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(D.errorContainer, D.error, 15, "nearer", !1), "toneDeltaPair")
});
D.onErrorContainer = lt.fromPalette({
  name: "on_error_container",
  palette: /* @__PURE__ */ d((n) => n.errorPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => n.isDark ? 90 : 10, "tone"),
  background: /* @__PURE__ */ d((n) => D.errorContainer, "background"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
D.primaryFixed = lt.fromPalette({
  name: "primary_fixed",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => me(n) ? 40 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => D.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(D.primaryFixed, D.primaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
D.primaryFixedDim = lt.fromPalette({
  name: "primary_fixed_dim",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => me(n) ? 30 : 80, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => D.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(D.primaryFixed, D.primaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
D.onPrimaryFixed = lt.fromPalette({
  name: "on_primary_fixed",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => me(n) ? 100 : 10, "tone"),
  background: /* @__PURE__ */ d((n) => D.primaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ d((n) => D.primaryFixed, "secondBackground"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
D.onPrimaryFixedVariant = lt.fromPalette({
  name: "on_primary_fixed_variant",
  palette: /* @__PURE__ */ d((n) => n.primaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => me(n) ? 90 : 30, "tone"),
  background: /* @__PURE__ */ d((n) => D.primaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ d((n) => D.primaryFixed, "secondBackground"),
  contrastCurve: new Et(3, 4.5, 7, 11)
});
D.secondaryFixed = lt.fromPalette({
  name: "secondary_fixed",
  palette: /* @__PURE__ */ d((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => me(n) ? 80 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => D.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(D.secondaryFixed, D.secondaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
D.secondaryFixedDim = lt.fromPalette({
  name: "secondary_fixed_dim",
  palette: /* @__PURE__ */ d((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => me(n) ? 70 : 80, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => D.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(D.secondaryFixed, D.secondaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
D.onSecondaryFixed = lt.fromPalette({
  name: "on_secondary_fixed",
  palette: /* @__PURE__ */ d((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => 10, "tone"),
  background: /* @__PURE__ */ d((n) => D.secondaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ d((n) => D.secondaryFixed, "secondBackground"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
D.onSecondaryFixedVariant = lt.fromPalette({
  name: "on_secondary_fixed_variant",
  palette: /* @__PURE__ */ d((n) => n.secondaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => me(n) ? 25 : 30, "tone"),
  background: /* @__PURE__ */ d((n) => D.secondaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ d((n) => D.secondaryFixed, "secondBackground"),
  contrastCurve: new Et(3, 4.5, 7, 11)
});
D.tertiaryFixed = lt.fromPalette({
  name: "tertiary_fixed",
  palette: /* @__PURE__ */ d((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => me(n) ? 40 : 90, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => D.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(D.tertiaryFixed, D.tertiaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
D.tertiaryFixedDim = lt.fromPalette({
  name: "tertiary_fixed_dim",
  palette: /* @__PURE__ */ d((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => me(n) ? 30 : 80, "tone"),
  isBackground: !0,
  background: /* @__PURE__ */ d((n) => D.highestSurface(n), "background"),
  contrastCurve: new Et(1, 1, 3, 7),
  toneDeltaPair: /* @__PURE__ */ d((n) => new Ri(D.tertiaryFixed, D.tertiaryFixedDim, 10, "lighter", !0), "toneDeltaPair")
});
D.onTertiaryFixed = lt.fromPalette({
  name: "on_tertiary_fixed",
  palette: /* @__PURE__ */ d((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => me(n) ? 100 : 10, "tone"),
  background: /* @__PURE__ */ d((n) => D.tertiaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ d((n) => D.tertiaryFixed, "secondBackground"),
  contrastCurve: new Et(4.5, 7, 11, 21)
});
D.onTertiaryFixedVariant = lt.fromPalette({
  name: "on_tertiary_fixed_variant",
  palette: /* @__PURE__ */ d((n) => n.tertiaryPalette, "palette"),
  tone: /* @__PURE__ */ d((n) => me(n) ? 90 : 30, "tone"),
  background: /* @__PURE__ */ d((n) => D.tertiaryFixedDim, "background"),
  secondBackground: /* @__PURE__ */ d((n) => D.tertiaryFixed, "secondBackground"),
  contrastCurve: new Et(3, 4.5, 7, 11)
});
var ts;
const JE = (ts = class {
  /**
   * @param argb ARGB representation of a color
   * @return Tones matching that color's hue and chroma.
   */
  static fromInt(t) {
    const e = Pi.fromInt(t);
    return ts.fromHct(e);
  }
  /**
   * @param hct Hct
   * @return Tones matching that color's hue and chroma.
   */
  static fromHct(t) {
    return new ts(t.hue, t.chroma, t);
  }
  /**
   * @param hue HCT hue
   * @param chroma HCT chroma
   * @return Tones matching hue and chroma.
   */
  static fromHueAndChroma(t, e) {
    return new ts(t, e, ts.createKeyColor(t, e));
  }
  constructor(t, e, i) {
    this.hue = t, this.chroma = e, this.keyColor = i, this.cache = /* @__PURE__ */ new Map();
  }
  static createKeyColor(t, e) {
    let i = Pi.from(t, e, 50), s = Math.abs(i.chroma - e);
    for (let r = 1; r < 50; r += 1) {
      if (Math.round(e) === Math.round(i.chroma))
        return i;
      const a = Pi.from(t, e, 50 + r), o = Math.abs(a.chroma - e);
      o < s && (s = o, i = a);
      const l = Pi.from(t, e, 50 - r), h = Math.abs(l.chroma - e);
      h < s && (s = h, i = l);
    }
    return i;
  }
  /**
   * @param tone HCT tone, measured from 0 to 100.
   * @return ARGB representation of a color with that tone.
   */
  tone(t) {
    let e = this.cache.get(t);
    return e === void 0 && (e = Pi.from(this.hue, this.chroma, t).toInt(), this.cache.set(t, e)), e;
  }
  /**
   * @param tone HCT tone.
   * @return HCT representation of a color with that tone.
   */
  getHct(t) {
    return Pi.fromInt(this.tone(t));
  }
}, c(ts, "qs"), ts);
d(JE, "TonalPalette");
let re = JE;
function bk(n) {
  const t = uP(n), e = pP(n), i = fP(n), s = [t.toString(16), e.toString(16), i.toString(16)];
  for (const [r, a] of s.entries())
    a.length === 1 && (s[r] = "0" + a);
  return "#" + s.join("");
}
c(bk, "xy");
d(bk, "hexFromArgb");
function t_(n) {
  n = n.replace("#", "");
  const t = n.length === 3, e = n.length === 6, i = n.length === 8;
  if (!t && !e && !i)
    throw new Error("unexpected hex " + n);
  let s = 0, r = 0, a = 0;
  return t ? (s = Wn(n.slice(0, 1).repeat(2)), r = Wn(n.slice(1, 2).repeat(2)), a = Wn(n.slice(2, 3).repeat(2))) : e ? (s = Wn(n.slice(0, 2)), r = Wn(n.slice(2, 4)), a = Wn(n.slice(4, 6))) : i && (s = Wn(n.slice(2, 4)), r = Wn(n.slice(4, 6)), a = Wn(n.slice(6, 8))), (255 << 24 | (s & 255) << 16 | (r & 255) << 8 | a & 255) >>> 0;
}
c(t_, "A1");
d(t_, "argbFromHex");
function Wn(n) {
  return parseInt(n, 16);
}
c(Wn, "Li");
d(Wn, "parseIntHex");
function e_(n, t = !1) {
  const e = n.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+\.{0,1}\d*))?\)$/)?.slice(1).map((o, l) => l === 3 ? Math.round(parseFloat(o) * 255) : parseFloat(o));
  if (!e)
    throw new Error("Could not parse rgba color.");
  const [i, s, r, a] = e;
  return ((t ? 255 : a & 255) << 24 | (i & 255) << 16 | (s & 255) << 8 | r & 255) >>> 0;
}
c(e_, "E1");
d(e_, "argbFromRgba");
function i_(n) {
  ii();
  const t = document.createElement("wy-compute-styles");
  t.setAttribute("style", `color: ${n} !important;`), document.documentElement.append(t);
  const e = window.getComputedStyle(t).color;
  return t.remove(), e;
}
c(i_, "R1");
d(i_, "getComputedColor");
function Uv(n) {
  return getComputedStyle(n).getPropertyValue("--wy-theme-color") || void 0;
}
c(Uv, "yu");
d(Uv, "getCSSThemeColor");
function n_(n, t) {
  let e = Uv(n);
  const i = new MutationObserver(() => {
    const a = Uv(n);
    a !== e && (e = a, t(a));
  }), s = {
    attributes: !0,
    attributeFilter: ["class", "style"]
  };
  let r = n;
  for (; r && r !== document; )
    i.observe(r, s), r = r.parentNode;
  return () => i.disconnect();
}
c(n_, "O1");
d(n_, "observeCSSThemeColor");
function Bv() {
  return ii(), Array.from(document.head.querySelectorAll("meta[name='theme-color']")).filter((n) => {
    const t = n.getAttribute("media");
    return !t || window.matchMedia(t)?.matches;
  }).pop()?.getAttribute("content") || void 0;
}
c(Bv, "wu");
d(Bv, "getMetaThemeColor");
function s_(n) {
  ii();
  const t = Array.from(document.head.querySelectorAll("meta[name='theme-color']"));
  if (!t)
    return () => {
    };
  let e = Bv();
  const i = /* @__PURE__ */ d(() => {
    const o = Bv();
    o !== e && (e = o, n(o));
  }, "checkChangedColor"), s = new MutationObserver(i), r = {
    attributes: !0,
    attributeFilter: ["content"]
  }, a = [];
  return t.forEach((o) => {
    s.observe(o, r);
    const l = o.getAttribute("media");
    if (l) {
      const h = window.matchMedia(l);
      h.addEventListener("change", i), a.push(h);
    }
  }), () => {
    s.disconnect(), a.forEach((o) => o.removeEventListener("change", i));
  };
}
c(s_, "L1");
d(s_, "observeMetaThemeColor");
const lm = [], vU = 16;
function r_(n, t = !1) {
  if (lm.some((E) => E.seedColor === n)) {
    const E = lm.find((A) => A.seedColor === n)?.colors;
    if (E)
      return E;
  }
  const e = [];
  t && e.push(`--wy-theme-color:${n};`);
  let i = n;
  !n.startsWith("#") && !n.startsWith("rgb") && (i = i_(n));
  const s = n.startsWith("#") ? t_(i) : e_(i), r = Pi.fromInt(s), a = r.hue, o = r.chroma, l = Math.max(48, o), h = Math.min(l, 84), u = 360 / 16, p = 27.4, y = -8, m = (a + 360 - p - y + u / 2) % u + p + y - u / 2, w = {
    primary: re.fromHueAndChroma(a, l),
    secondary: re.fromHueAndChroma(a, l / 3),
    tertiary: re.fromHueAndChroma(a + 60, l / 2),
    neutral: re.fromHueAndChroma(a, Math.min(o / 12, 4)),
    "neutral-variant": re.fromHueAndChroma(a, Math.min(o / 6, 8)),
    error: re.fromHueAndChroma(m, 84),
    warning: re.fromHueAndChroma(m + 4 * u, h),
    // Same as yellow
    red: re.fromHueAndChroma(m, h),
    "deep-orange": re.fromHueAndChroma(m + 1 * u, h),
    orange: re.fromHueAndChroma(m + 2 * u, h),
    amber: re.fromHueAndChroma(m + 3 * u, h),
    yellow: re.fromHueAndChroma(m + 4 * u, h),
    lime: re.fromHueAndChroma(m + 5 * u, h),
    "light-green": re.fromHueAndChroma(m + 6 * u, h),
    green: re.fromHueAndChroma(m + 7 * u, h),
    teal: re.fromHueAndChroma(m + 8 * u, h),
    cyan: re.fromHueAndChroma(m + 9 * u, h),
    "light-blue": re.fromHueAndChroma(m + 10 * u, h),
    blue: re.fromHueAndChroma(m + 11 * u, h),
    indigo: re.fromHueAndChroma(m + 12 * u, h),
    "deep-purple": re.fromHueAndChroma(m + 13 * u, h),
    purple: re.fromHueAndChroma(m + 14 * u, h),
    pink: re.fromHueAndChroma(m + 15 * u, h),
    gray: re.fromHueAndChroma(a, 4)
  }, b = {
    //"100": 100,
    99: 99,
    95: 95,
    90: 90,
    80: 80,
    70: 70,
    60: 60,
    50: 50,
    40: 40,
    30: 30,
    20: 20,
    10: 10
    //"0": 0
  }, $ = {
    primary: b,
    secondary: b,
    tertiary: b,
    neutral: b,
    "neutral-variant": b,
    error: b,
    warning: b,
    blue: { light: 70, dark: 80 },
    indigo: { light: 60, dark: 60 },
    purple: { light: 60, dark: 70 },
    pink: { light: 60, dark: 70 },
    red: { light: 60, dark: 60 },
    orange: { light: 70, dark: 70 },
    yellow: { light: 70, dark: 80 },
    green: { light: 60, dark: 60 },
    teal: { light: 60, dark: 60 },
    cyan: { light: 50, dark: 60 },
    gray: { light: 50, dark: 60 }
  };
  for (const E in $) {
    const A = $[E];
    for (const I in A) {
      const Z = bk(w[E].tone(A[I]));
      e.push(`--wy-${E}-${I}:${Z};`);
    }
  }
  const x = {
    light: w.primary.tone(40),
    dark: w.primary.tone(80)
  }, C = {
    light: w.neutral.tone(99),
    dark: w.neutral.tone(10)
  }, R = {
    "surface-1": {
      light: Zn.cam16Ucs(C.light, x.light, 0.05),
      dark: Zn.cam16Ucs(C.dark, x.dark, 0.05)
    },
    "surface-2": {
      light: Zn.cam16Ucs(C.light, x.light, 0.08),
      dark: Zn.cam16Ucs(C.dark, x.dark, 0.08)
    },
    "surface-3": {
      light: Zn.cam16Ucs(C.light, x.light, 0.11),
      dark: Zn.cam16Ucs(C.dark, x.dark, 0.11)
    },
    "surface-4": {
      light: Zn.cam16Ucs(C.light, x.light, 0.12),
      dark: Zn.cam16Ucs(C.dark, x.dark, 0.12)
    },
    "surface-5": {
      light: Zn.cam16Ucs(C.light, x.light, 0.14),
      dark: Zn.cam16Ucs(C.dark, x.dark, 0.14)
    }
  };
  for (const E in R) {
    const A = R[E];
    for (const I in A) {
      const Z = bk(A[I]);
      e.push(`--wy-${E}-${I}:${Z};`);
    }
  }
  return lm.unshift({ seedColor: n, colors: e }), lm.length = Math.min(lm.length, vU), e;
}
c(r_, "T1");
d(r_, "generateThemeColors");
const bU = /* @__PURE__ */ d((n) => {
  if (ii(), zb)
    document.adoptedStyleSheets = n.map(
      (t) => t instanceof CSSStyleSheet ? t : t.styleSheet
    );
  else
    for (const t of n) {
      const e = document.createElement("style"), i = global.litNonce;
      i !== void 0 && e.setAttribute("nonce", i), e.textContent = t.cssText, (document.head || document.documentElement).appendChild(e);
    }
}, "adoptGlobalStyles"), Bi = Qt`.wy-light :where(wy-chat),.wy-light :where(wy-comments),.wy-light :where(wy-component),.wy-light :where(wy-copilot),.wy-light :where(wy-files),.wy-light :where(wy-messenger),.wy-light :where(wy-notification-toasts),.wy-light :where(wy-notifications),.wy-light :where(wy-posts),:host(.wy-light),:host .wy-light,::slotted(.wy-light){color-scheme:light;--wy-primary: var(--wy-primary-40, #006399);--wy-on-primary: var(--wy-white, #ffffff);--wy-primary-container: var(--wy-primary-90, #cde5ff);--wy-on-primary-container: var(--wy-primary-10, #001d32);--wy-secondary: var(--wy-secondary-40, #3b6a1c);--wy-on-secondary: var(--wy-white, #ffffff);--wy-secondary-container: var(--wy-secondary-90, #bbf294);--wy-on-secondary-container: var(--wy-secondary-10, #0a2100);--wy-tertiary: var(--wy-tertiary-40, #3b6a1c);--wy-on-tertiary: var(--wy-white, #ffffff);--wy-tertiary-container: var(--wy-tertiary-90, #bbf294);--wy-on-tertiary-container: var(--wy-tertiary-10, #0a2100);--wy-error: var(--wy-error-40, #ba1824);--wy-on-error: var(--wy-white, #ffffff);--wy-error-container: var(--wy-error-90, #ffdad7);--wy-on-error-container: var(--wy-error-10, #410004);--wy-warning: var(--wy-warning-70, #afb140);--wy-on-warning: var(--wy-black, #000000);--wy-warning-container: var(--wy-warning-90, #e7e971);--wy-on-warning-container: var(--wy-warning-10, #1c1d00);--wy-background: var(--wy-neutral-99, #fcfcff);--wy-on-background: var(--wy-neutral-10, #1a1c1e);--wy-surface: var(--wy-neutral-99, #fcfcff);--wy-on-surface: var(--wy-neutral-10, #1a1c1e);--wy-surface-variant: var(--wy-neutral-variant-90, #dee3eb);--wy-on-surface-variant: var(--wy-neutral-variant-30, #42474e);--wy-outline: var(--wy-neutral-variant-50, #72777e);--wy-outline-variant: var(--wy-neutral-variant-80, #c2c7ce);--wy-inverse-surface: var(--wy-neutral-20, #2f3033);--wy-on-inverse-surface: var(--wy-neutral-95, #f0f0f4);--wy-inverse-primary: var(--wy-primary-80, #95ccff);--wy-surface-1: var(--wy-surface-1-light, #f1f2f7);--wy-surface-2: var(--wy-surface-2-light, #eaedf3);--wy-surface-3: var(--wy-surface-3-light, #e3e7ee);--wy-surface-4: var(--wy-surface-4-light, #e1e6ed);--wy-surface-5: var(--wy-surface-5-light, #dce2ea);--wy-highlight: var(--wy-primary-95, #e8f2ff);--wy-on-highlight: var(--wy-primary-10, #001d32);--wy-link: var(--wy-primary-40, #006399);--wy-presence-active: var(--wy-green-light, #00a38b);--wy-blue: var(--wy-blue-light, #89a9fc);--wy-indigo: var(--wy-indigo-light, #9185de);--wy-purple: var(--wy-purple-light, #c675b7);--wy-pink: var(--wy-pink-light, #d57194);--wy-red: var(--wy-red-light, #db726c);--wy-orange: var(--wy-orange-light, #e89a3a);--wy-yellow: var(--wy-yellow-light, #afb140);--wy-green: var(--wy-green-light, #00a38b);--wy-teal: var(--wy-teal-light, #00a0a8);--wy-cyan: var(--wy-cyan-light, #0082a1);--wy-gray: var(--wy-gray-light, #76777a);--wy-code-text: var(--wy-code-text-light, #3b3b3b);--wy-code-variable: var(--wy-code-variable-light, #001080);--wy-code-operator: var(--wy-code-operator-light, #000000);--wy-code-prolog: var(--wy-code-prolog-light, #000080);--wy-code-comment: var(--wy-code-comment-light, #008000);--wy-code-builtin: var(--wy-code-builtin-light, #0070C1);--wy-code-number: var(--wy-code-number-light, #098658);--wy-code-inserted: var(--wy-code-inserted-light, #098658);--wy-code-constant: var(--wy-code-constant-light, #811F3F);--wy-code-hexcode: var(--wy-code-hexcode-light, #811F3F);--wy-code-regex: var(--wy-code-regex-light, #811F3F);--wy-code-char: var(--wy-code-char-light, #811F3F);--wy-code-tag: var(--wy-code-tag-light, #800000);--wy-code-attr-name: var(--wy-code-attr-name-light, #E50000);--wy-code-selector: var(--wy-code-selector-light, #E50000);--wy-code-property: var(--wy-code-property-light, #E50000);--wy-code-deleted: var(--wy-code-deleted-light, #A31515);--wy-code-string: var(--wy-code-string-light, #A31515);--wy-code-changed: var(--wy-code-changed-light, #0451A5);--wy-code-punctuation: var(--wy-code-punctuation-light, #000000);--wy-code-function: var(--wy-code-function-light, #0000FF);--wy-code-keyword: var(--wy-code-keyword-light, #AF00DB);--wy-code-class-name: var(--wy-code-class-name-light, #267F99)}.wy-dark:not(.wy-light) :where(wy-chat),.wy-dark:not(.wy-light) :where(wy-comments),.wy-dark:not(.wy-light) :where(wy-component),.wy-dark:not(.wy-light) :where(wy-copilot),.wy-dark:not(.wy-light) :where(wy-files),.wy-dark:not(.wy-light) :where(wy-messenger),.wy-dark:not(.wy-light) :where(wy-notification-toasts),.wy-dark:not(.wy-light) :where(wy-notifications),.wy-dark:not(.wy-light) :where(wy-posts),:host(.wy-dark:not(.wy-light)),:host .wy-dark:not(.wy-light),::slotted(.wy-dark:not(.wy-light)){color-scheme:dark;--wy-primary: var(--wy-primary-80, #95ccff);--wy-on-primary: var(--wy-primary-20, #003352);--wy-primary-container: var(--wy-primary-30, #004a75);--wy-on-primary-container: var(--wy-primary-90, #cde5ff);--wy-secondary: var(--wy-secondary-80, #a0d57b);--wy-on-secondary: var(--wy-secondary-20, #163800);--wy-secondary-container: var(--wy-secondary-30, #245103);--wy-on-secondary-container: var(--wy-secondary-90, #bbf294);--wy-tertiary: var(--wy-tertiary-80, #a0d57b);--wy-on-tertiary: var(--wy-tertiary-20, #163800);--wy-tertiary-container: var(--wy-tertiary-30, #245103);--wy-on-tertiary-container: var(--wy-tertiary-90, #bbf294);--wy-error: var(--wy-error-80, #ffb3ae);--wy-on-error: var(--wy-error-20, #68000b);--wy-error-container: var(--wy-error-30, #930014);--wy-on-error-container: var(--wy-error-90, #ffdad7);--wy-warning: var(--wy-warning-90, #e7e971);--wy-on-warning: var(--wy-warning-30, #484a00);--wy-warning-container: var(--wy-warning-50, #7a7c05);--wy-on-warning-container: var(--wy-warning-95, #f5f77d);--wy-background: var(--wy-neutral-10, #1a1c1e);--wy-on-background: var(--wy-neutral-90, #e2e2e5);--wy-surface: var(--wy-neutral-10, #1a1c1e);--wy-on-surface: var(--wy-neutral-90, #e2e2e5);--wy-surface-variant: var(--wy-neutral-variant-30, #42474e);--wy-on-surface-variant: var(--wy-neutral-variant-80, #c2c7ce);--wy-outline: var(--wy-neutral-variant-60, #8c9198);--wy-outline-variant: var(--wy-neutral-variant-30, #42474e);--wy-inverse-surface: var(--wy-neutral-90, #e2e2e5);--wy-on-inverse-surface: var(--wy-neutral-20, #2f3033);--wy-inverse-primary: var(--wy-primary-40, #006399);--wy-surface-1: var(--wy-surface-1-dark, #212427);--wy-surface-2: var(--wy-surface-2-dark, #25292d);--wy-surface-3: var(--wy-surface-3-dark, #292e33);--wy-surface-4: var(--wy-surface-4-dark, #2b3035);--wy-surface-5: var(--wy-surface-5-dark, #2d3338);--wy-highlight: var(--wy-primary-20, #003352);--wy-on-highlight: var(--wy-primary-90, #cde5ff);--wy-link: var(--wy-primary-80, #95ccff);--wy-presence-active: var(--wy-green-dark, #00a38b);--wy-blue: var(--wy-blue-dark, #b1c5ff);--wy-indigo: var(--wy-indigo-dark, #9185de);--wy-purple: var(--wy-purple-dark, #e38fd3);--wy-pink: var(--wy-pink-dark, #f48bae);--wy-red: var(--wy-red-dark, #db726c);--wy-orange: var(--wy-orange-dark, #e89a3a);--wy-yellow: var(--wy-yellow-dark, #cacc58);--wy-green: var(--wy-green-dark, #00a38b);--wy-teal: var(--wy-teal-dark, #00a0a8);--wy-cyan: var(--wy-cyan-dark, #009dc3);--wy-gray: var(--wy-gray-dark, #909194);--wy-code-text: var(--wy-code-text-dark, #cccccc);--wy-code-variable: var(--wy-code-variable-dark, #9CDCFE);--wy-code-operator: var(--wy-code-operator-dark, #d4d4d4);--wy-code-prolog: var(--wy-code-prolog-dark, #569CD6);--wy-code-comment: var(--wy-code-comment-dark, #6a9955);--wy-code-builtin: var(--wy-code-builtin-dark, #4fc1ff);--wy-code-number: var(--wy-code-number-dark, #b5cea8);--wy-code-inserted: var(--wy-code-inserted-dark, #b5cea8);--wy-code-constant: var(--wy-code-constant-dark, #646695);--wy-code-hexcode: var(--wy-code-hexcode-dark, #646695);--wy-code-regex: var(--wy-code-regex-dark, #d16969);--wy-code-char: var(--wy-code-char-dark, #d16969);--wy-code-tag: var(--wy-code-tag-dark, #569cd6);--wy-code-attr-name: var(--wy-code-attr-name-dark, #9cdcfe);--wy-code-selector: var(--wy-code-selector-dark, #9cdcfe);--wy-code-property: var(--wy-code-property-dark, #9cdcfe);--wy-code-deleted: var(--wy-code-deleted-dark, #ce9178);--wy-code-string: var(--wy-code-string-dark, #ce9178);--wy-code-changed: var(--wy-code-changed-dark, #569cd6);--wy-code-punctuation: var(--wy-code-punctuation-dark, #D4D4D4);--wy-code-function: var(--wy-code-function-dark, #569cd6);--wy-code-keyword: var(--wy-code-keyword-dark, #C586C0);--wy-code-class-name: var(--wy-code-class-name-dark, #4ec9b0)}`, OU = Qt`@property --wy-component-color{syntax: \"<color>\"; inherits: true; initial-value: currentColor;}@property --wy-component-background-color{syntax: \"<color>\"; inherits: true; initial-value: transparent;}`, $U = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), bU([OU, Bi]);
    }
  }, c(e, "t"), e), d(t, "WeavyStyles"), t;
}, "WeavyStylesMixin"), xU = /* @__PURE__ */ d((n) => {
  var e;
  var t;
  return t = (e = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...s) {
      super(...s), this.version = Gt.version, this.whenUrl().then(() => {
        this.isDestroyed || this.checkVersion();
      });
    }
    /**
     * Checks the version of the Weavy Context against the Weavy Environment version.
     *
     * @param {string} [version] - Optional version to check against the environment version.
     */
    async checkVersion(s = this.version) {
      await this.whenUrl(), this.networkStateIsPending = !0;
      let r;
      try {
        if (r = await fetch(new URL("/version", this.url), await this.fetchOptions({}, !1)), !r.ok)
          throw new Error("Could not verify environment version.");
        this.networkStateIsPending = !1, this.serverState = "ok";
      } catch (o) {
        this.networkStateIsPending = !1, this.serverState = "unreachable", console.warn("Could not check version: " + o.toString());
        return;
      }
      const a = await r.text();
      if (a.startsWith("v") && (!s || !a || s !== a))
        try {
          const o = s.split(".").slice(0, 2), l = a.split(".").slice(0, 2);
          if (o[0] !== l[0])
            throw new Error();
          o[1] !== l[1] && console.warn(
            `Version inconsistency: ${Gt.sourceName}@${this.version} ≠ ${this.url?.hostname}@${a}`
          );
        } catch {
          throw new Error(
            `Version mismatch! ${Gt.sourceName}@${this.version} ≠ ${this.url?.hostname}@${a}`
          );
        }
    }
  }, c(e, "t"), e), d(t, "WeavyVersion"), t;
}, "WeavyVersionMixin");
var S0, Mu;
let a_ = (S0 = (Mu = class extends Event {
  constructor(t, e, i, s) {
    super("context-request", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e, this.callback = i, this.subscribe = s ?? !1;
  }
}, c(Mu, "$n"), Mu), d(S0, "s"), S0);
var P0, Tu;
let Vs = (P0 = (Tu = class {
  constructor(t, e, i, s) {
    if (this.subscribe = !1, this.provided = !1, this.value = void 0, this.t = (r, a) => {
      this.unsubscribe && (this.unsubscribe !== a && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = r, this.host.requestUpdate(), this.provided && !this.subscribe || (this.provided = !0, this.callback && this.callback(r, a)), this.unsubscribe = a;
    }, this.host = t, e.context !== void 0) {
      const r = e;
      this.context = r.context, this.callback = r.callback, this.subscribe = r.subscribe ?? !1;
    } else this.context = e, this.callback = i, this.subscribe = s ?? !1;
    this.host.addController(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.host.dispatchEvent(new a_(this.context, this.host, this.t, this.subscribe));
  }
}, c(Tu, "Cn"), Tu), d(P0, "s"), P0);
var C0, Au;
let kU = (C0 = (Au = class {
  get value() {
    return this.o;
  }
  set value(t) {
    this.setValue(t);
  }
  setValue(t, e = !1) {
    const i = e || !Object.is(t, this.o);
    this.o = t, i && this.updateObservers();
  }
  constructor(t) {
    this.subscriptions = /* @__PURE__ */ new Map(), this.updateObservers = () => {
      for (const [e, { disposer: i }] of this.subscriptions) e(this.o, i);
    }, t !== void 0 && (this.value = t);
  }
  addCallback(t, e, i) {
    if (!i) return void t(this.value);
    this.subscriptions.has(t) || this.subscriptions.set(t, { disposer: /* @__PURE__ */ d(() => {
      this.subscriptions.delete(t);
    }, "disposer"), consumerHost: e });
    const { disposer: s } = this.subscriptions.get(t);
    t(this.value, s);
  }
  clearCallbacks() {
    this.subscriptions.clear();
  }
}, c(Au, "kn"), Au), d(C0, "s"), C0);
var Q0, Ru;
let SU = (Q0 = (Ru = class extends Event {
  constructor(t, e) {
    super("context-provider", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e;
  }
}, c(Ru, "_n"), Ru), d(Q0, "e"), Q0);
var M0, Eu;
let Ok = (M0 = (Eu = class extends kU {
  constructor(t, e, i) {
    super(e.context !== void 0 ? e.initialValue : i), this.onContextRequest = (s) => {
      if (s.context !== this.context) return;
      const r = s.contextTarget ?? s.composedPath()[0];
      r !== this.host && (s.stopPropagation(), this.addCallback(s.callback, r, s.subscribe));
    }, this.onProviderRequest = (s) => {
      if (s.context !== this.context || (s.contextTarget ?? s.composedPath()[0]) === this.host) return;
      const r = /* @__PURE__ */ new Set();
      for (const [a, { consumerHost: o }] of this.subscriptions) r.has(a) || (r.add(a), o.dispatchEvent(new a_(this.context, o, a, !0)));
      s.stopPropagation();
    }, this.host = t, e.context !== void 0 ? this.context = e.context : this.context = e, this.attachListeners(), this.host.addController?.(this);
  }
  attachListeners() {
    this.host.addEventListener("context-request", this.onContextRequest), this.host.addEventListener("context-provider", this.onProviderRequest);
  }
  hostConnected() {
    this.host.dispatchEvent(new SU(this.context, this.host));
  }
}, c(Eu, "Mn"), Eu), d(M0, "i"), M0);
function Hs({ context: n }) {
  return (t, e) => {
    const i = /* @__PURE__ */ new WeakMap();
    if (typeof e == "object") return { get() {
      return t.get.call(this);
    }, set(s) {
      return i.get(this).setValue(s), t.set.call(this, s);
    }, init(s) {
      return i.set(this, new Ok(this, { context: n, initialValue: s })), s;
    } };
    {
      t.constructor.addInitializer((a) => {
        i.set(a, new Ok(a, { context: n }));
      });
      const s = Object.getOwnPropertyDescriptor(t, e);
      let r;
      if (s === void 0) {
        const a = /* @__PURE__ */ new WeakMap();
        r = { get() {
          return a.get(this);
        }, set(o) {
          i.get(this).setValue(o), a.set(this, o);
        }, configurable: !0, enumerable: !0 };
      } else {
        const a = s.set;
        r = { ...s, set(o) {
          i.get(this).setValue(o), a?.call(this, o);
        } };
      }
      return void Object.defineProperty(t, e, r);
    }
  };
}
c(Hs, "Ls");
d(Hs, "e$5");
function xe({ context: n, subscribe: t }) {
  return (e, i) => {
    typeof i == "object" ? i.addInitializer(function() {
      new Vs(this, { context: n, callback: /* @__PURE__ */ d((s) => {
        e.set.call(this, s);
      }, "callback"), subscribe: t });
    }) : e.constructor.addInitializer((s) => {
      new Vs(s, { context: n, callback: /* @__PURE__ */ d((r) => {
        s[i] = r;
      }, "callback"), subscribe: t });
    });
  };
}
c(xe, "te");
d(xe, "c$2");
var _u;
const o_ = (_u = class extends Event {
  /**
   *
   * @param context the context key to request
   * @param contextTarget the original context target of the requester
   * @param callback the callback that should be invoked when the context with the specified key is available
   * @param subscribe when, true indicates we want to subscribe to future updates
   */
  constructor(t, e, i, s) {
    super("context-request", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e, this.callback = i, this.subscribe = s ?? !1;
  }
}, c(_u, "Ep"), _u);
d(o_, "ContextRequestEvent");
let PU = o_;
var zu;
const l_ = (zu = class extends Event {
  /**
   *
   * @param context the context which this provider can provide
   * @param contextTarget the original context target of the provider
   */
  constructor(t, e) {
    super("context-provider", { bubbles: !0, composed: !0 }), this.context = t, this.contextTarget = e;
  }
}, c(zu, "Rp"), zu);
d(l_, "ContextProviderEvent");
let CU = l_;
var Lu;
const c_ = (Lu = class extends Ok {
  constructor(t, e, i) {
    e.context !== void 0 ? super(t, e) : super(t, e, i), e.context !== void 0 ? this._context = e.context : this._context = e, this.isAttached = !0, this.host instanceof pt || this.dispatchWhenConnected();
  }
  dispatchWhenConnected() {
    this.isAttached && (this.host.isConnected ? this.host.dispatchEvent(new CU(this._context, this.host)) : requestAnimationFrame(() => this.dispatchWhenConnected()));
  }
  detachListeners() {
    this.isAttached = !1, this.host.removeEventListener("context-request", this.onContextRequest), this.host.removeEventListener("context-provider", this.onProviderRequest);
  }
}, c(Lu, "Op"), Lu);
d(c_, "WyContextProvider");
let h_ = c_;
const Le = Symbol.for("weavy-client");
function d_(n, t) {
  return ii(), new h_(n, { context: Le, initialValue: t });
}
c(d_, "q1");
d(d_, "createWeavyContextProvider");
const pc = ub() ? d_(document.documentElement) : void 0, QU = /* @__PURE__ */ d((n) => {
  var i;
  var t, e;
  return e = (i = class extends n {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...r) {
      super(...r), q(this, t), this.host !== document.documentElement ? (pc?.detachListeners(), L(this, t, new h_(this.host, {
        context: Le,
        initialValue: this
      }))) : pc?.setValue(this);
    }
    updateContext() {
      this.host !== document.documentElement ? k(this, t)?.updateObservers() : pc?.updateObservers();
    }
    destroy() {
      super.destroy(), this.host !== document.documentElement ? k(this, t)?.detachListeners() : pc?.value === this && pc?.setValue(void 0);
    }
  }, c(i, "e"), i), t = /* @__PURE__ */ new WeakMap(), d(e, "WeavyContextProvider"), e;
}, "WeavyContextProviderMixin");
var $1, x1, hr, km, qe;
const Sm = (qe = class {
  // CONSTRUCTOR
  constructor(t) {
    q(this, $1), q(this, x1), q(this, hr), q(this, km), this.weavySid = ey(), this.weavyId = `${qe.sourceName}#${this.weavySid}`, this.cloudFilePickerUrl = qe.defaults.cloudFilePickerUrl, this.configurationTimeout = qe.defaults.configurationTimeout, this.disableEnvironmentImports = qe.defaults.disableEnvironmentImports, this.gcTime = qe.defaults.gcTime, this.scrollBehavior = qe.defaults.scrollBehavior, this.staleTime = qe.defaults.staleTime, this.tokenFactoryRetryDelay = qe.defaults.tokenFactoryRetryDelay, this.tokenFactoryTimeout = qe.defaults.tokenFactoryTimeout, L(this, x1, new Promise((i) => {
      L(this, $1, i);
    })), L(this, km, !1), console.info(`${qe.sourceName}@${qe.version} #${this.weavySid}`), ii(), this.host = document.documentElement;
    const e = {};
    for (const i in t) {
      const s = i;
      t[s] !== void 0 && Object.assign(e, { [s]: t[s] });
    }
    e?.host && (this.host = e.host, delete e.host), e && Object.assign(this, e);
  }
  async whenUrl() {
    await k(this, x1);
  }
  /**
   * The URL to the weavy environment.
   */
  get url() {
    return k(this, hr);
  }
  set url(t) {
    var e;
    if (this.isDestroyed)
      throw new Ce();
    try {
      if (typeof t == "string")
        t && L(this, hr, new URL(t, window.location.toString()));
      else if (t instanceof URL)
        L(this, hr, t || void 0);
      else if (t == null)
        L(this, hr, void 0);
      else
        throw new Error();
    } catch {
      throw new TypeError("Invalid url");
    }
    t && !this.disableEnvironmentImports && globalThis.WEAVY_IMPORT_URL === void 0 && (globalThis.WEAVY_IMPORT_URL = new URL(
      "./uikit-web/",
      t
    ).href), k(this, hr) && ((e = k(this, $1)) == null || e.call(this, k(this, hr)));
  }
  /**
   * Prefix to use for caches.
   */
  get cachePrefix() {
    return `${qe.version}:${this.url}`;
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async reset() {
    console.info(this.weavyId, "is reset");
  }
  get isDestroyed() {
    return k(this, km);
  }
  destroy() {
    L(this, km, !0), console.info(this.weavyId, "was destroyed");
  }
}, c(qe, "ae"), qe);
$1 = /* @__PURE__ */ new WeakMap(), x1 = /* @__PURE__ */ new WeakMap(), hr = /* @__PURE__ */ new WeakMap(), km = /* @__PURE__ */ new WeakMap(), d(Sm, "WeavyClient"), Sm.version = "29.3.0", Sm.sourceName = "@weavy/uikit-web", Sm.defaults = {
  // StrictWeavyOptions
  cloudFilePickerUrl: "https://filebrowser.weavy.io/v14/",
  configurationTimeout: 5e3,
  disableEnvironmentImports: !1,
  gcTime: 1e3 * 60 * 60 * 24,
  // 24h,
  locale: CE,
  notificationEvents: !1,
  scrollBehavior: "auto",
  staleTime: 1e3 * 1,
  // 1s
  tokenFactoryRetryDelay: 2e3,
  tokenFactoryTimeout: 2e4,
  // WeavyComponentSettingProps
  annotations: "buttons-inline",
  enterToSend: "auto",
  notifications: "button-list",
  notificationsBadge: "count",
  reactions: "😍 😎 😉 😜 👍"
};
let Gt = Sm;
var Iu;
const u_ = (Iu = class extends QU(
  rU(
    pU(
      cU(
        oU(
          hU(
            aU(
              uU(xU(lU($U(fU(Gt)))))
            )
          )
        )
      )
    )
  )
) {
}, c(Iu, "Lp"), Iu);
d(u_, "Weavy");
let le = u_;
var Zu;
const p_ = (Zu = class {
  constructor(t, e, i, s, r) {
    if (this.subscribe = !1, this.provided = !1, this.value = void 0, this._callback = (a, o) => {
      this.unsubscribe && (this.unsubscribe !== o && (this.provided = !1, this.unsubscribe()), this.subscribe || this.unsubscribe()), this.value = a, this.host.requestUpdate(), (!this.provided || this.subscribe) && (this.provided = !0, this.callback && this.callback(a, o)), this.unsubscribe = o;
    }, this.host = t, e.context !== void 0) {
      const a = e;
      this.context = a.context, this.callback = a.callback, this.subscribe = a.subscribe ?? !1, this.ref = a.ref ?? t;
    } else
      this.context = e, this.callback = i, this.subscribe = s ?? !1, this.ref = r ?? t;
    this.host.addController?.(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  dispatchRequest() {
    this.ref.dispatchEvent(
      new PU(
        this.context,
        this.host,
        this._callback,
        this.subscribe
      )
    );
  }
}, c(Zu, "Ip"), Zu);
d(p_, "ContextConsumer");
let MU = p_;
var Vu;
const f_ = (Vu = class {
  /**
   * @param host - The host element
   * @param context - The Context to use. Should be constructed using createContext().
   */
  constructor(t, e, i) {
    this.whenRef = new Promise((s) => this.resolveRef = s), t.addController(this), this.host = t, this.setRef(i), this.setContext(e);
  }
  /**
   * The DOM connected element that can subscribe to a context
   */
  get ref() {
    return this._ref;
  }
  set ref(t) {
    this._ref = t, t && this.resolveRef?.(t);
  }
  /** 
   * Set the DOM connected element that can subscribe to a context.
   * Wrapper function for React linting compatibility. 
   */
  setRef(t) {
    this.ref = t;
  }
  async setContext(t) {
    this.whenContext = new Promise((i) => this.resolveContext = i);
    const e = await this.whenRef;
    this.context = new MU(this.host, {
      context: t,
      subscribe: !0,
      callback: /* @__PURE__ */ d((i, s) => {
        this.resolveContext?.(i), this.host.requestUpdate();
      }, "callback"),
      ref: e
    }), await Yk(e), this.context.dispatchRequest();
  }
  hostUpdate() {
    this.context?.value && this.resolveContext?.(this.context.value);
  }
}, c(Vu, "Tp"), Vu);
d(f_, "ContextController");
let TU = f_;
const AU = { attribute: !0, type: String, converter: Tv, reflect: !1, hasChanged: FS }, RU = /* @__PURE__ */ d((n = AU, t, e) => {
  const { kind: i, metadata: s } = e;
  let r = globalThis.litPropertyMetadata.get(s);
  if (r === void 0 && globalThis.litPropertyMetadata.set(s, r = /* @__PURE__ */ new Map()), i === "setter" && ((n = Object.create(n)).wrapped = !0), r.set(e.name, n), i === "accessor") {
    const { name: a } = e;
    return { set(o) {
      const l = t.get.call(this);
      t.set.call(this, o), this.requestUpdate(a, l, n);
    }, init(o) {
      return o !== void 0 && this.C(a, void 0, n, o), o;
    } };
  }
  if (i === "setter") {
    const { name: a } = e;
    return function(o) {
      const l = this[a];
      t.call(this, o), this.requestUpdate(a, l, n);
    };
  }
  throw Error("Unsupported decorator location: " + i);
}, "r$3");
function O(n) {
  return (t, e) => typeof e == "object" ? RU(n, t, e) : ((i, s, r) => {
    const a = s.hasOwnProperty(r);
    return s.constructor.createProperty(r, i), a ? Object.getOwnPropertyDescriptor(s, r) : void 0;
  })(n, t, e);
}
c(O, "p");
d(O, "n$3");
function F(n) {
  return O({ ...n, state: !0, attribute: !1 });
}
c(F, "F");
d(F, "r$2");
const EU = /* @__PURE__ */ d((n, t, e) => (e.configurable = !0, e.enumerable = !0, Reflect.decorate && typeof t != "object" && Object.defineProperty(n, t, e), e), "e$4");
function mP(n) {
  return (t, e) => {
    const { slot: i, selector: s } = n ?? {}, r = "slot" + (i ? `[name=${i}]` : ":not([name])");
    return EU(t, e, { get() {
      const a = this.renderRoot?.querySelector(r), o = a?.assignedElements(n) ?? [];
      return s === void 0 ? o : o.filter((l) => l.matches(s));
    } });
  };
}
c(mP, "Jw");
d(mP, "o$6");
var k1, Du;
const y_ = (Du = class {
  // PROPERTY INIT
  constructor(t) {
    q(this, k1), this.enterToSend = Gt.defaults.enterToSend, this.notifications = Gt.defaults.notifications, this.notificationsBadge = Gt.defaults.notificationsBadge, this.reactions = Gt.defaults.reactions, this.annotations = Gt.defaults.annotations, L(this, k1, t), Object.keys(this).forEach((e) => {
      e in t && Object.assign(this, { [e]: t[e] });
    });
  }
  /**
   * Provides a reference to the host.
   */
  get component() {
    return k(this, k1);
  }
}, c(Du, "Fp"), Du);
k1 = /* @__PURE__ */ new WeakMap(), d(y_, "WeavyComponentSettings");
let P3 = y_;
const m_ = Symbol.for("weavy-component-settings");
var Wu;
const w_ = (Wu = class {
  get result() {
    return this._result && this.observer ? this.observer.trackResult(this._result) : { isPending: !0 };
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenQueryClient = new Promise((e) => this.resolveQueryClient = e), this.setContext();
  }
  async setContext() {
    await rl(this.host), this.context = new Vs(this.host, {
      context: Le,
      subscribe: !0,
      callback: /* @__PURE__ */ d((t) => {
        t && (this.resolveContext?.(t), this.queryClient = t.queryClient, this.resolveQueryClient?.(t.queryClient));
      }, "callback")
    });
  }
  async trackQuery(t, e = !0) {
    this.observerUnsubscribe?.();
    const i = await this.whenQueryClient;
    if (!i)
      throw new Error("No QueryClient provided");
    const s = new dE(i, t);
    this.observer = s, this.observerSubscribe(e);
  }
  observerSubscribe(t = !0) {
    if (this.queryClient && this.observer) {
      t ? this._result = this.observer.getOptimisticResult(this.observer.options) : this._result = this.observer.getCurrentResult(), this.observerUnsubscribe = this.observer.subscribe(() => {
        if (this.observer) {
          const i = Cy(this.result, this.observer.getCurrentResult());
          i !== this._result && (this._result = i, this.host.requestUpdate());
        }
      }), this.observer.updateResult(), this.host.requestUpdate();
      let e;
      t ? e = this.observer.fetchOptimistic(this.observer.options) : e = this.queryClient.getQueryCache().get(this.observer.options.queryHash)?.promise, e?.catch(() => {
      }).finally(() => {
        this.observer?.updateResult();
      });
    }
  }
  untrackQuery() {
    this.observerUnsubscribe?.(), this.observerUnsubscribe = void 0, this._result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    this.observerUnsubscribe?.();
  }
}, c(Wu, "Dp"), Wu);
d(w_, "QueryController");
let ns = w_;
const wP = Symbol.for("weavy-app"), Ub = Symbol.for("weavy-user");
var z = /* @__PURE__ */ ((n) => (n.Attachments = "attachments", n.agents = "agents", n.CloudFiles = "cloud_files", n.ContextData = "context_data", n.Comments = "comments", n.Embeds = "embeds", n.GoogleMeet = "google_meet", n.Meetings = "meetings", n.Mentions = "mentions", n.MicrosoftTeams = "microsoft_teams", n.Polls = "polls", n.Previews = "previews", n.Reactions = "reactions", n.Receipts = "receipts", n.Thumbnails = "thumbnails", n.Typing = "typing", n.Versions = "versions", n.WebDAV = "web_dav", n.ZoomMeetings = "zoom_meetings", n))(z || {});
const Bb = Symbol.for("weavy-features");
var Va, fc, bs, zo;
const g_ = (zo = class {
  /**
   * Creates a feature policy. All features are initially enabled unless `defaultFeatures` is specified.
   *
   * @constructor
   * @param componentFeatures - Available features.
   */
  constructor(t, e) {
    q(this, Va), q(this, fc), q(this, bs), L(this, Va, Object.keys(t)), L(this, fc, Object.entries(t).reduce(
      (i, [s, r]) => (r && i.push(s), i),
      []
    )), L(this, bs, e ?? k(this, fc));
  }
  features() {
    return k(this, Va);
  }
  supportedFeature(...t) {
    return t.every((e) => k(this, Va).includes(e));
  }
  allowedFeatures() {
    return k(this, bs);
  }
  allowsFeature(...t) {
    return t.every((e) => this.supportedFeature(e) ? k(this, bs).includes(e) : !1);
  }
  allowsAnyFeature(...t) {
    return t.some((e) => this.supportedFeature(e) ? k(this, bs).includes(e) : !1);
  }
  /**
   * Sets the allowed features.
   * @param allowedFeatures - Space separated string with features that will be enabled. Empty string will disable all features. `null` or `undefined` will enable all features.
   */
  setAllowedFeatures(t) {
    return L(this, bs, typeof t == "string" ? gP(t, k(this, Va)) : k(this, fc)), k(this, bs);
  }
  immutable() {
    const t = Xb(k(this, Va), k(this, fc));
    return new zo(t, k(this, bs));
  }
}, c(zo, "$d"), zo);
Va = /* @__PURE__ */ new WeakMap(), fc = /* @__PURE__ */ new WeakMap(), bs = /* @__PURE__ */ new WeakMap(), d(g_, "ComponentFeatures");
let On = g_;
function gP(n, t) {
  return n.split(" ").filter((e) => {
    if (e) {
      if (t.includes(e))
        return !0;
      console.warn("Unknown feature provided:", e);
    }
    return !1;
  });
}
c(gP, "ef");
d(gP, "featureListFromString");
function Xb(n, t) {
  return t ??= n, Object.fromEntries(
    n.map((e) => [e, t.includes(e)])
  );
}
c(Xb, "ip");
d(Xb, "featureConfigFromList");
const $k = Object.values(z), v_ = Symbol.for("weavy-link"), Ye = [];
for (let n = 0; n < 256; ++n)
  Ye.push((n + 256).toString(16).slice(1));
function b_(n, t = 0) {
  return (Ye[n[t + 0]] + Ye[n[t + 1]] + Ye[n[t + 2]] + Ye[n[t + 3]] + "-" + Ye[n[t + 4]] + Ye[n[t + 5]] + "-" + Ye[n[t + 6]] + Ye[n[t + 7]] + "-" + Ye[n[t + 8]] + Ye[n[t + 9]] + "-" + Ye[n[t + 10]] + Ye[n[t + 11]] + Ye[n[t + 12]] + Ye[n[t + 13]] + Ye[n[t + 14]] + Ye[n[t + 15]]).toLowerCase();
}
c(b_, "K1");
d(b_, "unsafeStringify");
let T0;
const _U = new Uint8Array(16);
function O_() {
  if (!T0) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    T0 = crypto.getRandomValues.bind(crypto);
  }
  return T0(_U);
}
c(O_, "Z1");
d(O_, "rng");
const zU = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), C3 = { randomUUID: zU };
function $_(n, t, e) {
  n = n || {};
  const i = n.random ?? n.rng?.() ?? O_();
  if (i.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, b_(i);
}
c($_, "X1");
d($_, "_v4");
function Bc(n, t, e) {
  return C3.randomUUID && !n ? C3.randomUUID() : $_(n);
}
c(Bc, "gc");
d(Bc, "v4");
function x_(n) {
  let t;
  if (n instanceof URL)
    t = { type: "url", item: n };
  else if (n instanceof File)
    t = { type: "file", item: n };
  else if (n instanceof Blob)
    t = {
      type: "file",
      item: new File([n], `${Bc()}`, { type: n.type })
    };
  else if (typeof n == "string")
    t = {
      type: "file",
      item: new File([n], `${Bc()}.data.txt`, { type: "text/plain;charset=UTF-8" })
    };
  else if (qR(n) || Rv(n))
    try {
      const e = Rv(n) ? n.toJSON() : JSON.stringify(n, BR(), 2);
      t = {
        type: "file",
        item: new File([e], `${Bc()}.json.txt`, { type: "text/plain;charset=UTF-8" })
      };
    } catch (e) {
      console.error("Could not serialize context data to JSON.", e);
    }
  return t;
}
c(x_, "J1");
d(x_, "getContextDataRef");
const Qy = /* @__PURE__ */ d((n, t = 3) => {
  const e = [" B", " KB", " MB", " GB", " TB", " PB", " EB", " ZB", " YB"];
  let i = n, s = 0;
  for (; s < e.length - 1 && i >= 1024; )
    i = 100 * i / 1024 / 100, s++;
  return i.toLocaleString(void 0, { maximumSignificantDigits: t }) + e[s];
}, "fileSizeAsString");
function Ei(n) {
  return n.lastIndexOf(".") === -1 ? "." : (n.substring(n.lastIndexOf("."), n.length) || n).toLowerCase();
}
c(Ei, "Ne");
d(Ei, "getExtension");
function vP(n) {
  switch (n) {
    case ".aac":
    case ".aif":
    case ".aiff":
    case ".au":
    case ".gsm":
    case ".m4a":
    case ".mid":
    case ".midi":
    case ".mka":
    case ".mp3":
    case ".oga":
    case ".ogg":
    case ".ra":
    case ".ram":
    case ".snd":
    case ".spx":
    case ".wav":
    case ".wma":
      return !0;
    default:
      return !1;
  }
}
c(vP, "rf");
d(vP, "isAudio");
function k_(n) {
  switch (n) {
    case ".ai":
    case ".apng":
    case ".bmp":
    case ".emf":
    case ".eps":
    case ".gif":
    case ".heic":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".psd":
    case ".svg":
    case ".tif":
    case ".tiff":
    case ".webp":
    case ".wmf":
      return !0;
    default:
      return !1;
  }
}
c(k_, "tg");
d(k_, "isImage");
function S_(n) {
  switch (Ei(n)) {
    case ".apng":
    case ".bmp":
    case ".gif":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".svg":
    case ".webp":
      return !0;
    default:
      return !1;
  }
}
c(S_, "eg");
d(S_, "isWebImage");
function bP(n) {
  switch (n) {
    case ".3g2":
    case ".asx":
    case ".asf":
    case ".avi":
    case ".flv":
    case ".mk3d":
    case ".mkv":
    case ".mov":
    case ".mp4":
    case ".mpeg":
    case ".mpg":
    case ".ogm":
    case ".ogv":
    case ".ogx":
    case ".qt":
    case ".rm":
    case ".rv":
    case ".smi":
    case ".smil":
    case ".swf":
    case ".webm":
    case ".wmv":
    case ".xaml":
      return !0;
    default:
      return !1;
  }
}
c(bP, "nf");
d(bP, "isVideo");
function P_(n) {
  switch (n) {
    case ".markdown":
    case ".md":
      return !0;
    default:
      return !1;
  }
}
c(P_, "ig");
d(P_, "isMarkdown");
function OP(n) {
  switch (n) {
    case ".htm":
    case ".html":
    case ".xhtml":
    case ".xml":
      return !0;
    default:
      return !1;
  }
}
c(OP, "af");
d(OP, "isMarkup");
function Nb(n) {
  if (OP(n))
    return !0;
  switch (n) {
    case ".as":
    case ".as3":
    case ".asm":
    case ".aspx":
    case ".bat":
    case ".c":
    case ".cc":
    case ".cmake":
    case ".coffee":
    case ".cpp":
    case ".cs":
    case ".css":
    case ".cxx":
    case ".diff":
    case ".erb":
    case ".erl":
    case ".groovy":
    case ".gvy":
    case ".h":
    case ".haml":
    case ".hh":
    case ".hpp":
    case ".hxx":
    case ".java":
    case ".js":
    case ".json":
    case ".jsx":
    case ".less":
    case ".lst":
    case ".m":
    case ".make":
    case ".ml":
    case ".mm":
    case ".out":
    case ".patch":
    case ".php":
    case ".pl":
    case ".plist":
    case ".properties":
    case ".py":
    case ".rb":
    case ".sass":
    case ".scala":
    case ".scm":
    case ".script":
    case ".scss":
    case ".sh":
    case ".sml":
    case ".sql":
    case ".vb":
    case ".vi":
    case ".vim":
    case ".xsd":
    case ".xsl":
    case ".yaml":
    case ".yml":
      return !0;
    default:
      return !1;
  }
}
c(Nb, "sp");
d(Nb, "isCode");
function $P(n) {
  if (Nb(n) || P_(n))
    return !0;
  switch (n) {
    case ".txt":
      return !0;
    default:
      return !1;
  }
}
c($P, "of");
d($P, "isText");
function Mn(n) {
  const t = Ei(n);
  if (t === "") return { icon: "file" };
  if (vP(t))
    return { icon: "file-music", color: "indigo" };
  if (k_(t))
    return { icon: "file-image", color: "cyan" };
  if (bP(t))
    return { icon: "file-video", color: "pink" };
  if (OP(t))
    return { icon: "file-xml", color: "purple" };
  if (Nb(t))
    return { icon: "file-code", color: "purple" };
  if ($P(t))
    return { icon: "file-document" };
  switch (t) {
    case ".7z":
    case ".zip":
      return { icon: "file-compressed", color: "orange" };
    case ".doc":
    case ".docm":
    case ".docx":
    case ".dotm":
    case ".dotx":
      return { icon: "file-word", color: "native" };
    case ".eml":
    case ".msg":
      return { icon: "email", color: "" };
    case ".xls":
    case ".xlsm":
    case ".xlsx":
    case ".xltx":
      return { icon: "file-excel", color: "native" };
    case ".pdf":
      return { icon: "file-pdf", color: "native" };
    case ".ppt":
    case ".pptm":
    case ".pptx":
    case ".potx":
      return { icon: "file-powerpoint", color: "native" };
    case ".pages":
      return { icon: "file", color: "orange" };
    case ".numbers":
      return { icon: "file", color: "green" };
    case ".keynote":
      return { icon: "file", color: "blue" };
  }
  return { icon: "file" };
}
c(Mn, "Ai");
d(Mn, "getIcon");
function C_(n) {
  const t = Ei(n);
  return t === "" ? "none" : S_(t) ? "image" : Nb(t) ? "code" : $P(t) ? "text" : vP(t) ? "audio" : bP(t) ? "video" : "none";
}
c(C_, "sg");
d(C_, "getWebPreviewFormat");
function Ys(n) {
  switch (n) {
    case "Google Drive":
      return "google-drive";
    case "Dropbox":
      return "dropbox";
    case "OneDrive":
      return "onedrive";
    case "Box":
      return "box";
    default:
      return "";
  }
}
c(Ys, "Is");
d(Ys, "getProvider");
function My(n) {
  let t = "file";
  switch (Ei(n)) {
    case ".7z":
    case ".zip":
      t = "archive";
      break;
    case ".aac":
    case ".aif":
    case ".aiff":
    case ".au":
    case ".gsm":
    case ".m4a":
    case ".mid":
    case ".midi":
    case ".mka":
    case ".mp3":
    case ".oga":
    case ".ogg":
    case ".ra":
    case ".ram":
    case ".snd":
    case ".spx":
    case ".wav":
    case ".wma":
      t = "audio";
      break;
    case ".c":
    case ".cgi":
    case ".cpp":
    case ".cs":
    case ".cshtml":
    case ".css":
    case ".html":
    case ".java":
    case ".js":
    case ".json":
    case ".less":
    case ".php":
    case ".pl":
    case ".ps1":
    case ".py":
    case ".rb":
    case ".rs":
    case ".scss":
    case ".sh":
    case ".swift":
    case ".sql":
    case ".ts":
    case ".xml":
    case ".yaml":
    case ".yml":
      t = "code";
      break;
    case ".doc":
    case ".docm":
    case ".docx":
    case ".dotm":
    case ".dotx":
    case ".gdoc":
    case ".pages":
    case ".pdf":
      t = "document";
      break;
    case ".eml":
    case ".msg":
      t = "email";
      break;
    case ".gslides":
    case ".keynote":
    case ".ppt":
    case ".pptm":
    case ".pptx":
    case ".potx":
      t = "presentation";
      break;
    case ".gsheet":
    case ".numbers":
    case ".xls":
    case ".xlsm":
    case ".xlsx":
    case ".xltx":
      t = "spreadsheet";
      break;
    case ".ai":
    case ".apng":
    case ".bmp":
    case ".emf":
    case ".eps":
    case ".gif":
    case ".heic":
    case ".ico":
    case ".jpg":
    case ".jpeg":
    case ".png":
    case ".psd":
    case ".svg":
    case ".tif":
    case ".tiff":
    case ".webp":
    case ".wmf":
      t = "image";
      break;
    case ".md":
    case ".markdown":
    case ".txt":
      t = "text";
      break;
    case ".3g2":
    case ".asx":
    case ".asf":
    case ".avi":
    case ".flv":
    case ".mk3d":
    case ".mkv":
    case ".mov":
    case ".mp4":
    case ".mpeg":
    case ".mpg":
    case ".ogm":
    case ".ogv":
    case ".ogx":
    case ".qt":
    case ".rm":
    case ".rv":
    case ".smi":
    case ".smil":
    case ".swf":
    case ".webm":
    case ".wmv":
    case ".xaml":
      t = "video";
      break;
  }
  return t;
}
c(My, "fl");
d(My, "getKind");
function Hb(n) {
  const t = n.target, e = t?.value.lastIndexOf(".");
  e === -1 ? t?.select() : e !== void 0 && t?.setSelectionRange(0, e);
}
c(Hb, "rp");
d(Hb, "handleSelectFilename");
async function Xv(n, t = "SHA-256") {
  return await new Promise((e) => {
    if (n) {
      const i = new FileReader();
      i.readAsArrayBuffer(n), i.onloadend = async () => {
        const s = await crypto.subtle.digest(t, i.result);
        let r = "";
        s && (r = Array.from(new Uint8Array(s)).map((a) => a.toString(16).padStart(2, "0")).join("")), e(r);
      };
    } else
      e("");
  });
}
c(Xv, "xu");
d(Xv, "getHash");
function S1(n, t) {
  return n.findAll(t.filters).map(
    (e) => t.select ? t.select(e) : e.state
  );
}
c(S1, "Th");
d(S1, "getResult");
var qu;
const Q_ = (qu = class {
  constructor(t) {
    this.alwaysUpdate = !1, t.addController(this), this.host = t, this.setContext();
  }
  async setContext() {
    this.whenContext = new Promise((t) => this.resolveContext = t), await rl(this.host), this.context = new Vs(this.host, { context: Le, subscribe: !0 });
  }
  hostUpdate() {
    this.context?.value && this.resolveContext?.();
  }
  async trackMutationState(t, e) {
    if (e || (await this.whenContext, e = this.context?.value?.queryClient), !e)
      throw new Error("No QueryClient provided");
    return this.mutationCacheUnsubscribe?.(), this.options = t, this.mutationCache = e.getMutationCache(), this.mutationCacheSubscribe(), this.result;
  }
  mutationCacheSubscribe() {
    this.mutationCache && this.options && (this.result = S1(this.mutationCache, this.options), this.mutationCacheUnsubscribe = this.mutationCache.subscribe((t) => {
      if (this.mutationCache && this.options && /added|removed|updated/.test(t.type)) {
        const e = S1(this.mutationCache, this.options);
        (this.result !== e || Fc(this.result, e)) && (this.result = e, this.host.requestUpdate());
      }
    }), this.host.requestUpdate());
  }
  get isMutating() {
    return !this.mutationCache || !this.options?.filters ? 0 : S1(this.mutationCache, { filters: { ...this.options.filters, status: "pending" } }).length;
  }
  untrackMutationState() {
    this.mutationCacheUnsubscribe?.(), this.mutationCacheUnsubscribe = void 0, this.result = void 0, this.options = void 0, this.mutationCache = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.mutationCacheSubscribe();
  }
  hostDisconnected() {
    this.mutationCacheUnsubscribe?.();
  }
}, c(qu, "Hp"), qu);
d(Q_, "MutationStateController");
let og = Q_;
var ju;
const M_ = (ju = class {
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenObserver = new Promise((e) => this.resolveObserver = e), this.setContext();
  }
  async setContext() {
    await rl(this.host), this.context = new Vs(this.host, { context: Le, subscribe: !0 });
  }
  hostUpdate() {
    this.context?.value && this.resolveContext?.();
  }
  async trackMutation(t, e) {
    if (e || (await this.whenContext, e = this.context?.value?.queryClient), !e)
      throw new Error("No QueryClient provided");
    return this.observerUnsubscribe?.(), this.observer && (this.whenObserver = new Promise((i) => this.resolveObserver = i)), this.observer = new jt(e, { ...t }), this.observerSubscribe(), this.resolveObserver?.(this.observer), this.observer;
  }
  observerSubscribe() {
    this.observer && (this.result = this.observer.getCurrentResult(), this.observerUnsubscribe ??= this.observer.subscribe(() => {
      if (this.observer) {
        const t = Cy(this.result, this.observer.getCurrentResult());
        this.result !== t && (this.result = t, this.host.requestUpdate());
      }
    }), this.host.requestUpdate());
  }
  untrackMutation() {
    this.observerUnsubscribe?.(), this.observerUnsubscribe = void 0, this.result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  async mutate(t, e) {
    return (await this.whenObserver).mutate(t, e);
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    this.observerUnsubscribe?.();
  }
}, c(ju, "Vp"), ju);
d(M_, "MutationController");
let en = M_;
function ce(n, t, e, i) {
  const s = n.getMutationCache(), r = s.find({
    mutationKey: t,
    predicate: /* @__PURE__ */ d((a) => a.state.variables === e, "predicate")
  });
  if (r && r.state.context) {
    const a = { ...r.state.context };
    i(a);
    const o = { ...r.state, context: a };
    r.state = o, s.notify({
      mutation: r,
      type: "updated",
      action: {
        type: "pending",
        context: r.state.context,
        variables: r.state.variables,
        isPaused: !1
      }
    });
  }
}
c(ce, "Vt");
d(ce, "updateMutationContext");
function xP(n, t, e) {
  const i = n.getMutationCache().find({ mutationKey: t, exact: !0, predicate: e });
  i && n.getMutationCache().remove(i);
}
c(xP, "cf");
d(xP, "removeMutation");
function T_(n, t) {
  const e = n.getMutationCache();
  e.findAll({ mutationKey: t, exact: !0 }).forEach((i) => {
    e.remove(i);
  });
}
c(T_, "rg");
d(T_, "removeMutations");
const kP = /* @__PURE__ */ d((n, t, e = 0, i = "application/octet-stream", s, r = Date.now()) => {
  const a = n && (n instanceof URL ? n.toString() : URL.createObjectURL(n));
  return {
    id: r,
    app: { id: -1 },
    name: t,
    kind: My(t),
    size: e,
    media_type: i,
    embed_url: "",
    preview_format: C_(t),
    thumbnail_url: a,
    preview_url: a,
    download_url: a,
    rev: -1,
    created_by: s,
    created_at: (/* @__PURE__ */ new Date()).toUTCString(),
    is_subscribed: !1,
    is_trashed: !1,
    is_starred: !1
  };
}, "getTempFile");
function SP(n) {
  const t = n ? n.reduce(
    (e, i) => {
      const s = i.context?.file;
      return s && i.context?.status.progress && s.size ? {
        loaded: e.loaded + i.context.status.progress * s.size,
        total: e.total + s.size
      } : e;
    },
    { loaded: 0, total: 0 }
  ) : { loaded: 0, total: 0 };
  return {
    loaded: t.loaded,
    total: t.total,
    percent: t.total > 0 ? t.loaded / t.total : null
  };
}
c(SP, "lf");
d(SP, "getFileMutationsTotalProgress");
function PP(n) {
  return n ? n.some((t) => t.context?.status.state === "conflict") ? "conflict" : n.some((t) => t.status === "error") ? "error" : n.every((t) => t.status === "success") ? "ok" : "pending" : "ok";
}
c(PP, "df");
d(PP, "getFileMutationsTotalStatus");
function A_(n) {
  return n?.filter((t) => t.context?.status.state === "conflict" || t.status === "error") || [];
}
c(A_, "ng");
d(A_, "getFileMutationsByConflictOrError");
function R_(n, t, e) {
  const i = n.queryClient;
  i.getMutationCache().findAll({
    mutationKey: ["apps", t.id, "files"],
    exact: !0,
    predicate: /* @__PURE__ */ d((s) => /error|success/.test(s.state.status) && s.state.variables?.blob?.name === e, "predicate")
  }).forEach((s) => {
    i.getMutationCache().remove(s);
  });
}
c(R_, "ag");
d(R_, "removeSettledFileMutations");
function E_(n, t, e) {
  const i = n.queryClient, s = ["apps", e.id, "files"];
  return {
    mutationFn: /* @__PURE__ */ d(async ({ blob: r, replace: a = !1 }) => {
      const o = await n.fetch("/api/apps/" + e.id + "/files", {
        method: "POST",
        body: JSON.stringify({ blob_id: r.id, replace: a })
      });
      if (!o.ok) {
        const l = await o.json();
        throw new Error(l.detail || l.title, { cause: l });
      }
      return await o.json();
    }, "mutationFn"),
    mutationKey: s,
    onMutate: /* @__PURE__ */ d(async (r) => {
      await i.cancelQueries({ queryKey: s, exact: !0 }), __(n, e, r.blob.name), R_(n, e, r.blob.name);
      let a;
      try {
        a = r.blob.thumbnail_url && new URL(r.blob.thumbnail_url) || void 0;
      } catch {
      }
      const o = kP(a, r.blob.name, r.blob.size, r.blob.media_type, t);
      return {
        type: r.replace ? "replace" : "create",
        file: o,
        status: { state: "pending" }
      };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((r, a, o) => (ce(i, s, a, (l) => {
      l && (l.status.state = "ok", l.status.progress = void 0, l.status.text = void 0);
    }), i.invalidateQueries({ queryKey: s })), "onSuccess"),
    onError(r, a, o) {
      r?.cause?.status === 409 ? ce(i, s, a, (l) => {
        l && (l.status.progress = void 0, l.status.state = "conflict", l.status.text = r.message);
      }) : ce(i, s, a, (l) => {
        l && (l.status.state = "error", l.status.progress = void 0, l.status.text = r.message);
      });
    }
  };
}
c(E_, "og");
d(E_, "getCreateFileMutationOptions");
function __(n, t, e, i, s = "blobs") {
  const r = n.queryClient;
  r.getMutationCache().findAll({
    mutationKey: ["apps", t.id, s, i],
    exact: !0,
    status: "success",
    predicate: /* @__PURE__ */ d((a) => a.state.data?.name === e, "predicate")
  }).forEach((a) => {
    r.getMutationCache().remove(a);
  });
}
c(__, "cg");
d(__, "removeSuccessfulUploadBlobMutations");
async function CP(n, t, e) {
  const i = new FormData();
  i.append("blob", t);
  const s = await n.upload("/api/blobs", "POST", i, Wv.Auto, (r) => {
    e && e({ progress: r });
  });
  if (!s.ok) {
    const r = await s.json();
    throw new Error(r.detail || r.title, { cause: r });
  }
  return await s.json();
}
c(CP, "hf");
d(CP, "uploadBlob");
function z_(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async (t) => await CP(n, t.file, t.onProgress), "mutationFn")
    // TODO: implement onmutate, onsuccess, onerror...
  };
}
c(z_, "lg");
d(z_, "getSimpleUploadBlobMutationOptions");
function Yb(n, t, e, i, s = "blobs") {
  const r = n.queryClient, a = i ? ["apps", e, s, i] : ["apps", e, s];
  return {
    mutationFn: /* @__PURE__ */ d(async (o) => await CP(n, o.file, o.onProgress), "mutationFn"),
    mutationKey: a,
    onMutate: /* @__PURE__ */ d(async (o) => {
      await r.cancelQueries({ queryKey: a, exact: !0 });
      const l = kP(o.file, o.file.name, o.file.size, o.file.type, t);
      o.onProgress = ({ progress: u }) => {
        ce(r, a, o, (p) => {
          p.status.state = "pending", p.status.progress = u;
        });
      };
      const h = await Xv(o.file);
      return { type: "upload", file: l, status: { state: "pending" }, sha256: h };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((o, l, h) => {
      ce(r, a, l, (u) => {
        u.status.state = "ok", u.status.progress = void 0, u.status.text = void 0;
      });
    }, "onSuccess"),
    onError(o, l, h) {
      const u = o.cause;
      u && u.status === 409 ? ce(r, a, l, (p) => {
        p.status.state = "conflict", p.status.progress = void 0, p.status.text = u.detail || u.title;
      }) : ce(r, a, l, (p) => {
        p && (p.status.state = "error", p.status.progress = void 0, p.status.text = u.detail || u.title);
      });
    }
  };
}
c(Yb, "ap");
d(Yb, "getUploadBlobMutationOptions");
const L_ = Symbol.for("weavy-data-blobs"), I_ = Symbol.for("weavy-context-id");
function Z_(n) {
  if (n)
    return n.match(/^[0-9]+$/) ? parseInt(n) : n;
}
c(Z_, "dg");
d(Z_, "toIntOrString");
var LU = Object.defineProperty, IU = Object.getOwnPropertyDescriptor, oe = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? IU(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && LU(t, e, s), s;
}, "__decorateClass$1d"), P1, C1, Q1, M1, T1, A1, Pm, Cm, Qm, Mm, Tm, Am, Rm, Em, yc, mc, _m, zm, Lm, Im, Zm, Vm, Da, dr, Os, Dm, wc, Fu;
const V_ = (Fu = class extends pt {
  // PROPERTY INIT
  constructor() {
    super(), q(this, P1), q(this, C1), q(this, Q1), q(this, M1), q(this, T1), q(this, A1), q(this, Pm), q(this, Cm), q(this, Qm), q(this, Mm), q(this, Tm), q(this, Am), q(this, Rm), q(this, Em), q(this, yc), q(this, mc), q(this, _m), q(this, zm), q(this, Lm), q(this, Im), q(this, Zm), q(this, Vm), q(this, Da), q(this, dr), q(this, Os), q(this, Dm), q(this, wc), this.storage = JS("localStorage"), this.contextId = Bc(), this.storageLinkHandler = (t) => {
      t.storageArea === this.storage && t.key === "wy-link" && t.newValue && this.readStorageLink();
    }, this.linkEventHandler = async (t) => {
      t.defaultPrevented || (this.link && this.link.id === t.detail.link.id && (this.link = void 0, await this.updateComplete), this.link = t.detail.link, this.link || this.provideStorageLink(t.detail.link));
    }, this.notificationEventHandler = (t) => {
      t.stopPropagation(), t.defaultPrevented || this.isConnected && this.checkVisibility(Gk) && this.matchesLink(t.detail.link) && t.preventDefault();
    }, L(this, Cm, new Promise((t) => {
      L(this, Pm, t);
    })), L(this, Mm, new Promise((t) => {
      L(this, Qm, t);
    })), L(this, Am, new Promise((t) => {
      L(this, Tm, t);
    })), L(this, Em, new Promise((t) => {
      L(this, Rm, t);
    })), L(this, mc, new Promise((t) => {
      L(this, yc, t);
    })), L(this, zm, new Promise((t) => {
      L(this, _m, t);
    })), L(this, Im, new Promise((t) => {
      L(this, Lm, t);
    })), L(this, Vm, new Promise((t) => {
      L(this, Zm, t);
    })), L(this, Da, new ns(this)), L(this, dr, new ns(this)), L(this, Os, /* @__PURE__ */ new Map()), L(this, Dm, new en(this)), L(this, wc, new og(this)), this.settings = new P3(this);
  }
  reset() {
    this.app && (this.app = void 0), this._appName !== this._initialAppName && (this._appName = this._initialAppName);
  }
  /**
   * Checks if an Entity is matching the component.
   *
   * @param {EntityType} link Entity to check for match
   * @returns { boolean } True if the entity is matching the component
   */
  matchesLink(t) {
    return (
      // Messenger conversation
      t?.app?.type && !this.componentType && this.appTypes?.includes(t.app.type) ? t.agent ? t.agent === this.agent : !0 : (
        // Normal contextual app
        !!(t && t.app && this.componentType !== tn.Unknown && (typeof this.uid == "string" && t.app?.uid === this.uid || // Normal app with app uid
        typeof this.uid == "number" && t.app?.id === this.uid || // Normal app with app id
        this.agent && t.app.type === this.componentType && t.agent === this.agent))
      )
    );
  }
  set link(t) {
    const e = this._link;
    !this.uid && this.componentType && this.componentType !== tn.Unknown ? this.whenApp().then(() => {
      this._link = this.matchesLink(t) ? t : void 0, this.requestUpdate("link", e);
    }) : (this._link = this.matchesLink(t) ? t : void 0, this.requestUpdate("link", e));
  }
  get link() {
    return this._link;
  }
  /**
   * Clears the link and resets the promise.
   */
  clearLink() {
    this.link && (L(this, mc, new Promise((t) => {
      L(this, yc, t);
    })), this.link = void 0);
  }
  /**
   * Shares a link with other blocks that may consume it automatically.
   *
   * @param {LinkType} link - The entity to provide
   */
  provideStorageLink(t) {
    this.storage?.setItem("wy-link", btoa(JSON.stringify(t)));
  }
  /**
   * Reads a link from storage provides it in the .link property/context.
   */
  readStorageLink() {
    if (!this.storage) {
      console.error("Storage not available");
      return;
    }
    const t = this.storage.getItem("wy-link");
    if (t)
      try {
        const e = JSON.parse(atob(t));
        e && (this.link = e);
      } catch (e) {
        console.error("Error parsing link", e);
      }
  }
  /**
   * Consumes a link in the storage. Make sure to consume it after it has been used.
   */
  consumeStorageLink() {
    this.storage?.removeItem("wy-link");
  }
  set agent(t) {
    this._agentUid = t || void 0;
  }
  get agent() {
    return this._agentUid;
  }
  set data(t) {
    console.warn(".data property array is deprecated. Use .contextualData string instead."), L(this, P1, t);
  }
  get data() {
    return k(this, P1);
  }
  set name(t) {
    this._initialAppName = t, this._appName = t;
  }
  get name() {
    return this._appName;
  }
  set annotations(t) {
    L(this, C1, t);
  }
  get annotations() {
    return k(this, C1) ?? this.weavy?.annotations ?? Gt.defaults.annotations;
  }
  set enterToSend(t) {
    L(this, Q1, t);
  }
  get enterToSend() {
    return k(this, Q1) ?? this.weavy?.enterToSend ?? Gt.defaults.enterToSend;
  }
  set notifications(t) {
    L(this, M1, t);
  }
  get notifications() {
    return k(this, M1) ?? this.weavy?.notifications ?? Gt.defaults.notifications;
  }
  set notificationsBadge(t) {
    L(this, T1, t);
  }
  get notificationsBadge() {
    return k(this, T1) ?? this.weavy?.notificationsBadge ?? Gt.defaults.notificationsBadge;
  }
  set reactions(t) {
    L(this, A1, t);
  }
  get reactions() {
    return k(this, A1) ?? this.weavy?.reactions ?? Gt.defaults.reactions;
  }
  async whenApp() {
    return await k(this, Cm);
  }
  async whenContextDataBlobs() {
    return await k(this, Mm);
  }
  async whenContextId() {
    return await k(this, Am);
  }
  async whenComponentFeatures() {
    return await k(this, Em);
  }
  async whenLink() {
    return await k(this, mc);
  }
  async whenSettings() {
    return await k(this, zm);
  }
  async whenUser() {
    return await k(this, Im);
  }
  async whenWeavy() {
    return await k(this, Vm);
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("wy-link", this.linkEventHandler), window.addEventListener("storage", this.storageLinkHandler), this.app && this.requestUpdate("app"), this.componentFeatures && this.requestUpdate("componentFeatures"), this.contextDataBlobs && this.requestUpdate("contextDataBlobs"), this.contextId && this.requestUpdate("contextId"), this.link && this.requestUpdate("link"), this.settings && this.requestUpdate("settings"), this.user && this.requestUpdate("user"), this.weavy && this.requestUpdate("weavy");
  }
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("wy-link", this.linkEventHandler), window.removeEventListener("storage", this.storageLinkHandler), this.weavy?.host.removeEventListener("wy-notification", this.notificationEventHandler, { capture: !0 });
  }
  async scheduleUpdate() {
    await rl(this), await super.scheduleUpdate();
  }
  async willUpdate(t) {
    var e, i, s, r, a, o, l, h;
    super.willUpdate(t), this.weavyContextConsumer ??= new Vs(this, { context: Le, subscribe: !0 }), this.weavyContextConsumer?.value && this.weavy !== this.weavyContextConsumer?.value && (this.weavy = this.weavyContextConsumer?.value);
    const u = Object.keys(this.settings);
    if ((t.has("weavy") || u.find((y) => t.has(y))) && (this.settings = new P3(this)), t.has("weavy") && this.weavy && await k(this, dr).trackQuery(ll(this.weavy, ["user"])), k(this, dr).result?.isPending || (this.user && k(this, dr).result.data && this.user.id !== k(this, dr).result.data.id && (console.warn("User mismatch, resetting"), this.weavy?.reset()), this.user = k(this, dr).result?.data), t.has("features") && this.componentFeatures && (this.componentFeatures.setAllowedFeatures(this.features), this.componentFeatures instanceof On && (this.componentFeatures = this.componentFeatures.immutable())), (t.has("autoUid") || t.has("user") || t.has("agent")) && this.autoUid && this.user && (this.componentType && Nv.has(this.componentType) && this.agent || this.componentType && !Nv.has(this.componentType))) {
      const y = [this.autoUid];
      this.agent && y.push(this.agent), this.user && y.push(this.user.uid || this.user.id), this.uid = y.join("-");
    }
    const p = this.name;
    if (t.has("componentType") || t.has("uid") || t.has("agent") || t.has("name") || t.has("weavy"))
      if (this._appName !== this._initialAppName && (this._appName = this._initialAppName, this.requestUpdate("name", p)), this.componentType && this.uid && this.weavy) {
        const y = this.name ? { name: this.name } : void 0, m = this.agent ? [this.agent] : void 0;
        await k(this, Da).trackQuery(
          OE(this.weavy, this.uid, this.componentType, m, y)
        );
      } else
        k(this, Da).untrackQuery();
    if (k(this, Da).result?.isPending || (this.app = k(this, Da).result?.data, this.app?.name && (this.app.name !== this.name || this._appName !== this.app.name) && (this._appName = this.app.name, this.requestUpdate("name", p))), (t.has("weavy") || t.has("contextId") || t.has("user") || t.has("componentFeatures")) && this.weavy && this.contextId && this.user && this.componentFeatures?.allowsFeature(z.ContextData) && (await k(this, Dm).trackMutation(
      Yb(this.weavy, this.user, this.contextId, void 0, "data")
    ), await k(this, wc).trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.contextId, "data"],
          exact: !0
        }
      },
      this.weavy.queryClient
    )), t.has("contextualData") || t.has("data") || t.has("componentFeatures")) {
      const y = this.contextualData ? [this.contextualData] : this.data ? this.data : [], m = k(this, Os);
      if (L(this, Os, /* @__PURE__ */ new Map()), y.forEach((w) => {
        const b = m.get(w);
        if (b)
          k(this, Os).set(w, b);
        else {
          const $ = x_(w);
          $ && k(this, Os).set(w, $);
        }
      }), k(this, Os) && this.componentFeatures?.allowsFeature(z.ContextData)) {
        for (const x of Array.from(k(this, Os).values()))
          if (x.type === "file") {
            const C = await Xv(x.item);
            await FR(
              k(this, wc).result ?? [],
              async (R) => (R.context?.sha256 ?? await Xv(R.variables?.file)) === C
            ) || await k(this, Dm).mutate({ file: x.item });
          }
        const w = k(this, wc).result, b = w?.some((x) => x.status === "pending"), $ = w?.map((x) => x.data?.id).filter((x) => x).reverse() ?? [];
        b || (this.contextDataBlobs = $);
      } else
        this.contextDataBlobs = [];
    }
    if (t.has("uid") && (this.uid || t.get("uid")) && this.uid !== t.get("uid") && this.clearLink(), (!this.link && (t.has("uid") && this.uid || t.has("app") && this.app) && this.componentType && this.componentType !== tn.Unknown || (t.has("appTypes") || t.has("agent")) && this.appTypes) && this.readStorageLink(), t.has("link") && this.link && (console.info(
      `Opening notification link in ${this.uid ?? D_.get(this.componentType) ?? this.constructor.name}`
    ), this.consumeStorageLink()), t.has("app") && this.app) {
      const y = new CustomEvent("wy-app", {
        bubbles: !1,
        composed: !0,
        detail: {
          app: this.app
        }
      });
      this.dispatchEvent(y);
    }
    t.has("app") && this.app && (t.get("app") && L(this, Cm, new Promise((y) => {
      L(this, Pm, y);
    })), (e = k(this, Pm)) == null || e.call(this, this.app)), t.has("contextDataBlobs") && this.contextDataBlobs && (t.get("contextDataBlobs") && L(this, Mm, new Promise((y) => {
      L(this, Qm, y);
    })), (i = k(this, Qm)) == null || i.call(this, this.contextDataBlobs)), t.has("contextId") && this.contextId && (t.get("contextId") && L(this, Am, new Promise((y) => {
      L(this, Tm, y);
    })), (s = k(this, Tm)) == null || s.call(this, this.contextId)), t.has("componentFeatures") && this.componentFeatures && (t.get("componentFeatures") && L(this, Em, new Promise((y) => {
      L(this, Rm, y);
    })), (r = k(this, Rm)) == null || r.call(this, this.componentFeatures)), t.has("link") && this.link && (t.get("link") && L(this, mc, new Promise((y) => {
      L(this, yc, y);
    })), (a = k(this, yc)) == null || a.call(this, this.link)), t.has("settings") && this.settings && (t.get("settings") && L(this, zm, new Promise((y) => {
      L(this, _m, y);
    })), (o = k(this, _m)) == null || o.call(this, this.settings)), t.has("user") && this.user && (t.get("user") && L(this, Im, new Promise((y) => {
      L(this, Lm, y);
    })), (l = k(this, Lm)) == null || l.call(this, this.user)), t.has("weavy") && this.weavy && (t.get("weavy") && L(this, Vm, new Promise((y) => {
      L(this, Zm, y);
    })), this.weavy.host.addEventListener("wy-notification", this.notificationEventHandler, { capture: !0 }), (h = k(this, Zm)) == null || h.call(this, this.weavy)), t.has("bot") && typeof this.bot == "string" && console.error(`Using .bot property is deprecated. Use .agent = "${this.bot}"; instead`);
  }
}, c(Fu, "Up"), Fu);
P1 = /* @__PURE__ */ new WeakMap(), C1 = /* @__PURE__ */ new WeakMap(), Q1 = /* @__PURE__ */ new WeakMap(), M1 = /* @__PURE__ */ new WeakMap(), T1 = /* @__PURE__ */ new WeakMap(), A1 = /* @__PURE__ */ new WeakMap(), Pm = /* @__PURE__ */ new WeakMap(), Cm = /* @__PURE__ */ new WeakMap(), Qm = /* @__PURE__ */ new WeakMap(), Mm = /* @__PURE__ */ new WeakMap(), Tm = /* @__PURE__ */ new WeakMap(), Am = /* @__PURE__ */ new WeakMap(), Rm = /* @__PURE__ */ new WeakMap(), Em = /* @__PURE__ */ new WeakMap(), yc = /* @__PURE__ */ new WeakMap(), mc = /* @__PURE__ */ new WeakMap(), _m = /* @__PURE__ */ new WeakMap(), zm = /* @__PURE__ */ new WeakMap(), Lm = /* @__PURE__ */ new WeakMap(), Im = /* @__PURE__ */ new WeakMap(), Zm = /* @__PURE__ */ new WeakMap(), Vm = /* @__PURE__ */ new WeakMap(), Da = /* @__PURE__ */ new WeakMap(), dr = /* @__PURE__ */ new WeakMap(), Os = /* @__PURE__ */ new WeakMap(), Dm = /* @__PURE__ */ new WeakMap(), wc = /* @__PURE__ */ new WeakMap(), d(V_, "WeavyComponent");
let It = V_;
oe([
  F()
], It.prototype, "weavy", 2);
oe([
  Hs({ context: wP }),
  F()
], It.prototype, "app", 2);
oe([
  Hs({ context: L_ }),
  F()
], It.prototype, "contextDataBlobs", 2);
oe([
  Hs({ context: I_ }),
  F()
], It.prototype, "contextId", 2);
oe([
  Hs({ context: Bb }),
  F()
], It.prototype, "componentFeatures", 2);
oe([
  Hs({ context: m_ }),
  F()
], It.prototype, "settings", 2);
oe([
  Hs({ context: Ub }),
  F()
], It.prototype, "user", 2);
oe([
  Hs({ context: v_ })
], It.prototype, "_link", 2);
oe([
  O({ type: Object })
], It.prototype, "link", 1);
oe([
  F()
], It.prototype, "componentType", 2);
oe([
  F()
], It.prototype, "appTypes", 2);
oe([
  O()
], It.prototype, "features", 2);
oe([
  O({ type: String })
], It.prototype, "agent", 1);
oe([
  O({
    attribute: !0,
    type: String
  })
], It.prototype, "contextualData", 2);
oe([
  O({
    attribute: !0,
    type: String,
    converter: {
      fromAttribute(n) {
        return jR(n);
      }
    }
  })
], It.prototype, "data", 1);
oe([
  O()
], It.prototype, "autoUid", 2);
oe([
  O({ converter: Z_ })
], It.prototype, "uid", 2);
oe([
  O({ type: String })
], It.prototype, "name", 1);
oe([
  O({ type: String })
], It.prototype, "annotations", 1);
oe([
  O({ type: String })
], It.prototype, "enterToSend", 1);
oe([
  O({ type: String })
], It.prototype, "notifications", 1);
oe([
  O({ type: String })
], It.prototype, "notificationsBadge", 1);
oe([
  O({ type: String })
], It.prototype, "reactions", 1);
oe([
  O()
], It.prototype, "bot", 2);
const D_ = new Map(HS(mE)), ZU = new Map(HS(wE)), Nv = new Map(Object.entries(gE));
new Map(Object.entries(vE));
var VU = Object.defineProperty, pa = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = void 0, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = a(t, e, s) || s);
  return s && VU(t, e, s), s;
}, "__decorateClass$1c"), Wm, R1, qm, E1, jm, _1, Fm, z1, Um, L1, Bm, I1, Xm, Z1, Nm, V1, Uu;
const W_ = (Uu = class extends pt {
  constructor() {
    super(), q(this, Wm), q(this, R1, new Promise((t) => {
      L(this, Wm, t);
    })), q(this, qm), q(this, E1, new Promise((t) => {
      L(this, qm, t);
    })), q(this, jm), q(this, _1, new Promise((t) => {
      L(this, jm, t);
    })), q(this, Fm), q(this, z1, new Promise((t) => {
      L(this, Fm, t);
    })), q(this, Um), q(this, L1, new Promise((t) => {
      L(this, Um, t);
    })), q(this, Bm), q(this, I1, new Promise((t) => {
      L(this, Bm, t);
    })), q(this, Xm), q(this, Z1, new Promise((t) => {
      L(this, Xm, t);
    })), q(this, Nm), q(this, V1, new Promise((t) => {
      L(this, Nm, t);
    }));
  }
  async whenApp() {
    return await k(this, R1);
  }
  async whenContextDataBlobs() {
    return await k(this, E1);
  }
  async whenContextId() {
    return await k(this, _1);
  }
  async whenComponentFeatures() {
    return await k(this, z1);
  }
  async whenLink() {
    return await k(this, L1);
  }
  async whenSettings() {
    return await k(this, I1);
  }
  async whenUser() {
    return await k(this, Z1);
  }
  async whenWeavy() {
    return await k(this, V1);
  }
  willUpdate(t) {
    var e, i, s, r, a, o, l, h;
    super.willUpdate(t), t.has("app") && this.app && (t.get("app") && L(this, R1, new Promise((u) => {
      L(this, Wm, u);
    })), (e = k(this, Wm)) == null || e.call(this, this.app)), t.has("contextDataBlobs") && this.contextDataBlobs && (t.get("contextDataBlobs") && L(this, E1, new Promise((u) => {
      L(this, qm, u);
    })), (i = k(this, qm)) == null || i.call(this, this.contextDataBlobs)), t.has("contextId") && this.contextId && (t.get("contextId") && L(this, _1, new Promise((u) => {
      L(this, jm, u);
    })), (s = k(this, jm)) == null || s.call(this, this.contextId)), t.has("componentFeatures") && this.componentFeatures && (t.get("componentFeatures") && L(this, z1, new Promise((u) => {
      L(this, Fm, u);
    })), (r = k(this, Fm)) == null || r.call(this, this.componentFeatures)), t.has("link") && this.link && (t.get("link") && L(this, L1, new Promise((u) => {
      L(this, Um, u);
    })), (a = k(this, Um)) == null || a.call(this, this.link)), t.has("settings") && this.settings && (t.get("settings") && L(this, I1, new Promise((u) => {
      L(this, Bm, u);
    })), (o = k(this, Bm)) == null || o.call(this, this.settings)), t.has("user") && this.user && (t.get("user") && L(this, Z1, new Promise((u) => {
      L(this, Xm, u);
    })), (l = k(this, Xm)) == null || l.call(this, this.user)), t.has("weavy") && this.weavy && (t.get("weavy") && L(this, V1, new Promise((u) => {
      L(this, Nm, u);
    })), (h = k(this, Nm)) == null || h.call(this, this.weavy));
  }
  connectedCallback() {
    super.connectedCallback(), this.app && this.requestUpdate("app"), this.contextDataBlobs && this.requestUpdate("contextDataBlobs"), this.contextId && this.requestUpdate("contextId"), this.componentFeatures && this.requestUpdate("componentFeatures"), this.link && this.requestUpdate("link"), this.settings && this.requestUpdate("settings"), this.user && this.requestUpdate("user"), this.weavy && this.requestUpdate("weavy");
  }
}, c(Uu, "Bp"), Uu);
Wm = /* @__PURE__ */ new WeakMap(), R1 = /* @__PURE__ */ new WeakMap(), qm = /* @__PURE__ */ new WeakMap(), E1 = /* @__PURE__ */ new WeakMap(), jm = /* @__PURE__ */ new WeakMap(), _1 = /* @__PURE__ */ new WeakMap(), Fm = /* @__PURE__ */ new WeakMap(), z1 = /* @__PURE__ */ new WeakMap(), Um = /* @__PURE__ */ new WeakMap(), L1 = /* @__PURE__ */ new WeakMap(), Bm = /* @__PURE__ */ new WeakMap(), I1 = /* @__PURE__ */ new WeakMap(), Xm = /* @__PURE__ */ new WeakMap(), Z1 = /* @__PURE__ */ new WeakMap(), Nm = /* @__PURE__ */ new WeakMap(), V1 = /* @__PURE__ */ new WeakMap(), d(W_, "WeavySubComponent");
let _t = W_;
pa([
  xe({ context: wP, subscribe: !0 }),
  F()
], _t.prototype, "app");
pa([
  xe({ context: L_, subscribe: !0 }),
  F()
], _t.prototype, "contextDataBlobs");
pa([
  xe({ context: I_, subscribe: !0 }),
  F()
], _t.prototype, "contextId");
pa([
  xe({ context: Bb, subscribe: !0 }),
  F()
], _t.prototype, "componentFeatures");
pa([
  xe({ context: v_, subscribe: !0 }),
  F()
], _t.prototype, "link");
pa([
  xe({ context: m_, subscribe: !0 }),
  F()
], _t.prototype, "settings");
pa([
  xe({ context: Ub, subscribe: !0 }),
  F()
], _t.prototype, "user");
pa([
  xe({ context: Le, subscribe: !0 }),
  F()
], _t.prototype, "weavy");
function q_(n) {
  return typeof n == "string" && n ? n = eval?.(`"use strict";(${n})`) : n = void 0, n;
}
c(q_, "wg");
d(q_, "indirectEvalObject");
function lg(n) {
  if (n)
    try {
      return new URL(n, window.location.toString());
    } catch {
      console.warn("Invalid url: ", n);
    }
}
c(lg, "_d");
d(lg, "toUrl");
const X = /* @__PURE__ */ d((n) => (t, e) => {
  e !== void 0 ? e.addInitializer(() => {
    !customElements.get(n) && customElements.define(
      n,
      t
    );
  }) : !customElements.get(n) && customElements.define(n, t);
}, "customElement"), ft = Qt`@charset \"UTF-8\";:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]){box-sizing:border-box;text-align:initial;font-size:var(--wy-font-size, var(--wy-size, 1em))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:before,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:after{box-sizing:inherit}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a){text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-40, #006399))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):hover{text-decoration:var(--wy-link-hover-decoration, unset)}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])):hover{text-decoration:none}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(p),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(p){margin-top:0;margin-bottom:calc(1 * var(--wy-size, 1rem))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(label),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(label){cursor:inherit}:where(:host([hidden])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"])[hidden],:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *[hidden]{display:none!important}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where([role=button]),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where([role=button]){cursor:pointer}.wy-scroll-y{scroll-padding-top:var(--wy-scrollbar-adjust-top, 0);scroll-padding-bottom:var(--wy-scrollbar-adjust-bottom, 0)}.wy-scroll-y{overflow-y:auto;max-height:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-scroll-y:not(body){-webkit-overflow-scrolling:touch}.wy-scroll-y:not(.wy-scroll-x){overflow-x:hidden;touch-action:pan-y}.wy-scroll-x{overflow-x:auto;max-width:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-scroll-x:not(.wy-scroll-y){overflow-y:hidden;touch-action:pan-x}.wy-appbars{--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));background-color:var(--wy-component-background-color);box-shadow:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) 0 calc(-1 * var(--wy-border, 1px)) 0 0 inset}@supports (position: sticky){.wy-appbars{position:sticky;top:0;z-index:1020}}.wy-appbars>.wy-appbar,.wy-appbars>.wy-toolbar{background-color:transparent;box-shadow:none}.wy-appbar{--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));display:grid;align-items:center;justify-content:space-between;justify-items:center;height:var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem)))));padding:calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));flex:0 0 var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem)))));grid-template-columns:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) minmax(0,max-content) var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));column-gap:calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))) + var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));line-height:var(--wy-line-height, 1.5);background-color:var(--wy-component-background-color);color:var(--wy-component-color);box-shadow:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) 0 calc(-1 * var(--wy-border, 1px)) 0 0 inset}.wy-appbar .wy-badge{align-self:center}.wy-appbar-buttons,.wy-toolbar-buttons,.wy-appbar-section{display:flex;flex:0 0 auto;align-items:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));max-width:100%}.wy-appbar-buttons-first{justify-content:flex-start}.wy-appbar-buttons-last{justify-content:flex-end}.wy-toolbar-buttons-last{margin-inline-start:auto}.wy-appbar-text{max-width:100%;display:block;color:inherit!important;-webkit-user-select:none;user-select:none}.wy-appbar-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-appbar-text a,.wy-appbar-text a:hover{color:inherit}.wy-appbar-text-trashed{text-decoration:line-through}.wy-toolbars-bottom{position:absolute;z-index:1030;bottom:calc(var(--wy-footerbar-height, calc(4 * var(--wy-size, 1rem))) / 2);left:0;right:0;min-height:var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;justify-content:center;justify-items:center}.wy-toolbar{--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));display:flex;flex-wrap:wrap;align-items:center;justify-content:flex-start;justify-items:center;min-height:var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem)))));padding:calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));flex:1 0 var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem)))));column-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));line-height:var(--wy-line-height, 1.5);background-color:var(--wy-component-background-color);color:var(--wy-component-color);box-shadow:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) 0 calc(-1 * var(--wy-border, 1px)) 0 0 inset}.wy-toolbar-center{margin:0 auto;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)))}.wy-toolbar-center .wy-input{text-align:center}.wy-toolbar-text{margin-left:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-button]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399));color:var(--wy-component-color);background:var(--wy-component-background-color, transparent);height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;font-size:var(--wy-button-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-button-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));text-align:center;text-decoration:none;vertical-align:middle;cursor:pointer;-webkit-user-select:none;user-select:none;border:var(--wy-button-border-width, var(--wy-border-outline, 0)) solid var(--wy-outline, var(--wy-neutral-variant-50, #72777e));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));display:inline-flex;align-items:center;justify-content:center;gap:var(--wy-button-gap, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));position:relative}[part~=wy-button][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .8);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .5)}[part~=wy-button]:disabled{opacity:var(--wy-opacity-disabled, 38%);cursor:unset;pointer-events:none}[part~=wy-button-state-layer]>*{z-index:3}[part~=wy-button-state-layer]:before{content:\"\";z-index:2;position:absolute;inset:0;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-button-state-layer]:hover:before{opacity:8%}[part~=wy-button-state-layer]:focus:before,[part~=wy-button-state-layer]:active:before,[part~=wy-button-state-layer][part~=wy-active]:before{opacity:12%}[part~=wy-button-icon]{--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));line-height:1;align-items:center;justify-content:center}[part~=wy-button-icon][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);padding:0;margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .5)}[part~=wy-button-icon][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * -.1)}[part~=wy-button-icon][part~=wy-active]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-button-icon-inline]{height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));width:auto;min-width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));background:var(--wy-component-background-color);color:currentColor;display:flex;padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-button-icon-inline][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);min-width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .25);margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .5)}[part~=wy-button-icon-inline][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * -.1)}[part~=wy-button-inline]{border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:calc(.5 * var(--wy-size, 1rem)) calc(.75 * var(--wy-size, 1rem));margin-inline:calc(-.25 * var(--wy-size, 1rem))}[part~=wy-button-primary]{--wy-component-background-color: var(--wy-primary, var(--wy-primary-40, #006399));--wy-component-color: var(--wy-on-primary, var(--wy-white, #ffffff))}[part~=wy-button-variant]{--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}[part~=wy-button-primary-text]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-button-inherit-color]{--wy-component-color: currentColor}[part~=wy-button-no-color]{--wy-component-color: unset}[part=wy-button-link]{padding:0;color:var(--wy-link-color, var(--wy-primary, var(--wy-primary-40, #006399)));text-decoration:var(--wy-link-decoration, none)}[part=wy-button-link]:hover,[part=wy-button-link]:focus{text-decoration:var(--wy-link-hover-decoration, unset)}[part~=wy-buttons]{display:flex;align-items:center;flex-wrap:wrap;gap:calc(.5 * var(--wy-size, 1rem))}[part~=wy-buttons-reverse]{flex-direction:row-reverse}[part~=wy-buttons-floating]{position:sticky;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) 0;top:0;height:0;margin-bottom:calc(-1 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));z-index:1030;--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}[part~=wy-buttons-sticky]{position:sticky;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));top:0;z-index:1030;--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}.wy-code pre,.wy-editor .cm-content pre,.wy-content pre{text-wrap:pretty}.wy-code .code,.wy-code code[class*=language-],.wy-code pre[class*=language-],.wy-editor .cm-content .code,.wy-content .code,.wy-editor .cm-content code[class*=language-],.wy-content code[class*=language-],.wy-editor .cm-content pre[class*=language-],.wy-content pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);text-align:left;white-space:pre-wrap;word-spacing:normal;word-break:normal;word-wrap:break-word;line-height:1.25;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}@media print{.wy-code code[class*=language-],.wy-code pre[class*=language-],.wy-editor .cm-content code[class*=language-],.wy-content code[class*=language-],.wy-editor .cm-content pre[class*=language-],.wy-content pre[class*=language-]{text-shadow:none}}.wy-code pre[class*=language-],.wy-editor .cm-content pre[class*=language-],.wy-content pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}.wy-code :not(pre)>code[class*=language-],.wy-code pre[class*=language-],.wy-editor .cm-content :not(pre)>code[class*=language-],.wy-content :not(pre)>code[class*=language-],.wy-editor .cm-content pre[class*=language-],.wy-content pre[class*=language-]{color:var(--wy-code-text, var(--wy-code-text-light, #3b3b3b));background:var(--wy-background, var(--wy-neutral-99, #fcfcff))}.wy-code :not(pre)>code[class*=language-],.wy-editor .cm-content :not(pre)>code[class*=language-],.wy-content :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.wy-code .token.variable,.wy-editor .cm-content .token.variable,.wy-content .token.variable{color:var(--wy-code-variable, var(--wy-code-variable-light, #001080))}.wy-code .token.operator,.wy-editor .cm-content .token.operator,.wy-content .token.operator{color:var(--wy-code-operator, var(--wy-code-operator-light, #000000))}.wy-code .token.prolog,.wy-editor .cm-content .token.prolog,.wy-content .token.prolog{color:var(--wy-code-prolog, var(--wy-code-prolog-light, #000080))}.wy-code .token.comment,.wy-editor .cm-content .token.comment,.wy-content .token.comment{color:var(--wy-code-comment, var(--wy-code-comment-light, #008000))}.wy-code .token.builtin,.wy-editor .cm-content .token.builtin,.wy-content .token.builtin{color:var(--wy-code-builtin, var(--wy-code-builtin-light, #0070C1))}.wy-code .token.number,.wy-editor .cm-content .token.number,.wy-content .token.number{color:var(--wy-code-number, var(--wy-code-number-light, #098658))}.wy-code .token.inserted,.wy-editor .cm-content .token.inserted,.wy-content .token.inserted{color:var(--wy-code-inserted, var(--wy-code-inserted-light, #098658))}.wy-code .token.constant,.wy-editor .cm-content .token.constant,.wy-content .token.constant{color:var(--wy-code-constant, var(--wy-code-constant-light, #811F3F))}.wy-code .token.hexcode,.wy-editor .cm-content .token.hexcode,.wy-content .token.hexcode{color:var(--wy-code-hexcode, var(--wy-code-hexcode-light, #811F3F))}.wy-code .token.regex,.wy-editor .cm-content .token.regex,.wy-content .token.regex{color:var(--wy-code-regex, var(--wy-code-regex-light, #811F3F))}.wy-code .token.char,.wy-editor .cm-content .token.char,.wy-content .token.char{color:var(--wy-code-char, var(--wy-code-char-light, #811F3F))}.wy-code .token.tag,.wy-editor .cm-content .token.tag,.wy-content .token.tag{color:var(--wy-code-tag, var(--wy-code-tag-light, #800000))}.wy-code .token.attr-name,.wy-editor .cm-content .token.attr-name,.wy-content .token.attr-name{color:var(--wy-code-attr-name, var(--wy-code-attr-name-light, #E50000))}.wy-code .token.selector,.wy-editor .cm-content .token.selector,.wy-content .token.selector{color:var(--wy-code-selector, var(--wy-code-selector-light, #E50000))}.wy-code .token.property,.wy-editor .cm-content .token.property,.wy-content .token.property{color:var(--wy-code-property, var(--wy-code-property-light, #E50000))}.wy-code .token.deleted,.wy-editor .cm-content .token.deleted,.wy-content .token.deleted{color:var(--wy-code-deleted, var(--wy-code-deleted-light, #A31515))}.wy-code .token.string,.wy-editor .cm-content .token.string,.wy-content .token.string{color:var(--wy-code-string, var(--wy-code-string-light, #A31515))}.wy-code .token.changed,.wy-editor .cm-content .token.changed,.wy-content .token.changed{color:var(--wy-code-changed, var(--wy-code-changed-light, #0451A5))}.wy-code .token.punctuation,.wy-editor .cm-content .token.punctuation,.wy-content .token.punctuation{color:var(--wy-code-punctuation, var(--wy-code-punctuation-light, #000000))}.wy-code .token.function,.wy-editor .cm-content .token.function,.wy-content .token.function{color:var(--wy-code-function, var(--wy-code-function-light, #0000FF))}.wy-code .token.keyword,.wy-editor .cm-content .token.keyword,.wy-content .token.keyword{color:var(--wy-code-keyword, var(--wy-code-keyword-light, #AF00DB))}.wy-code .token.class-name,.wy-editor .cm-content .token.class-name,.wy-content .token.class-name{color:var(--wy-code-class-name, var(--wy-code-class-name-light, #267F99))}.wy-code .token.important,.wy-code .token.bold,.wy-editor .cm-content .token.important,.wy-content .token.important,.wy-editor .cm-content .token.bold,.wy-content .token.bold{font-weight:700}.wy-code .token.italic,.wy-editor .cm-content .token.italic,.wy-content .token.italic{font-style:italic}.wy-content{overflow-wrap:break-word;min-width:0}.wy-content:empty{display:none}.wy-content>:first-child{margin-top:0}.wy-content>:last-child{margin-bottom:0}.wy-content b,.wy-content strong{font-weight:var(--wy-font-weight-bold, 600)}.wy-content blockquote{border-left:calc(2 * var(--wy-border, 1px)) solid var(--wy-neutral-80, #c6c6c9);margin:var(--wy-size, 1rem) 0;padding:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));padding-left:var(--wy-size, 1rem)}.wy-content blockquote>p{margin:0}.wy-content pre,.wy-content code{font-family:var(--wy-font-monospace, ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace);font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}.wy-content :not(pre)>code{overflow-wrap:inherit}.wy-content pre>code{font-size:var(--wy-font-size, var(--wy-size, 1em));white-space:pre-wrap}.wy-content h1,.wy-content h2,.wy-content h3,.wy-content h4,.wy-content h5,.wy-content h6{font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.2));margin:0 0 var(--wy-gap, calc(.5 * var(--wy-size, 1rem))) 0}.wy-content h1{font-size:calc(2 * var(--wy-font-size, var(--wy-size, 1em)))}.wy-content h2{font-size:calc(1.8 * var(--wy-font-size, var(--wy-size, 1em)))}.wy-content h3{font-size:calc(1.6 * var(--wy-font-size, var(--wy-size, 1em)))}.wy-content h4{font-size:calc(1.4 * var(--wy-font-size, var(--wy-size, 1em)))}.wy-content h5{font-size:calc(1.2 * var(--wy-font-size, var(--wy-size, 1em)))}.wy-content h6{font-size:var(--wy-font-size, var(--wy-size, 1em))}.wy-content table{display:block;width:100%;max-width:-moz-max-content;max-width:max-content;margin:0 auto;overflow-x:auto;white-space:nowrap;border-collapse:separate;border-spacing:0 0;margin-bottom:var(--wy-size, 1rem)}.wy-content table th,.wy-content table td{padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));border-color:inherit;border-style:solid}.wy-content table th{text-align:inherit;text-align:-webkit-match-parent;border-width:var(--wy-border, 1px) 0 var(--wy-border, 1px) var(--wy-border, 1px);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600))}.wy-content table th:first-child{border-top-left-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-content table th:last-child{border-top-right-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-right-width:var(--wy-border, 1px)}.wy-content table td{border-width:0 0 var(--wy-border, 1px) var(--wy-border, 1px)}.wy-content table td:last-child{border-right-width:var(--wy-border, 1px)}.wy-content table tr:last-child td:first-child{border-bottom-left-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-content table tr:last-child td:last-child{border-bottom-right-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-content table>tbody{vertical-align:inherit}.wy-content table>thead{vertical-align:bottom}.wy-content img{max-width:100%;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin-block:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}ol{list-style-type:decimal}ul{list-style-type:disc}li{margin:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))) 0}ol,ul{margin:var(--wy-size, 1rem) 0;padding:0 0 0 1.625em}ol>li,ul>li{padding-left:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}ol>li>:first-child,ul>li>:first-child{margin-bottom:0;margin-top:0}ol>li>:last-child,ul>li>:last-child{margin-bottom:0}.wy-hashtag{color:var(--wy-primary, var(--wy-primary-40, #006399))}.wy-mention{font-weight:700}.wy-emoji-icon{display:inline-flex;justify-content:center;align-items:center;line-height:1;width:1em;height:1em;font-size:calc(1.25 * var(--wy-size, 1rem))}.wy-emoji-icon-sm{width:calc(1.125 * var(--wy-size, 1rem));height:calc(1.125 * var(--wy-size, 1rem));font-size:calc(1.125 * var(--wy-size, 1rem))}.wy-empty{display:flex;align-items:center;justify-content:center;flex:1;min-width:0;position:relative;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-icon]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-icon][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon-first]{margin-left:calc(-.5 * var(--wy-size, 1rem))}[part~=wy-icon-last]{margin-right:calc(-.5 * var(--wy-size, 1rem))}[part~=wy-icon-padded]{margin:16.66666667%}[part~=wy-icon-inline]{vertical-align:-.25em}[part~=wy-icon-overlay]{position:absolute;bottom:0;right:0;border-radius:50%}:host(wy-icon-stack),[part~=wy-icon-stack]{display:inline-flex;position:relative;line-height:1}[part~=wy-icon-stack-layer]{position:absolute}[part~=wy-icon-stack-overlay]{position:absolute;bottom:0;right:0;border-radius:50%;width:calc(var(--wy-component-icon-width) / 2);height:calc(var(--wy-component-icon-height) / 2)}[part~=wy-icon-current-color]{fill:currentColor}[part~=wy-icon-state]{transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));align-self:center;justify-self:center;margin:auto;opacity:0}[part~=wy-icon-state][part~=wy-active]{opacity:1}[part~=wy-icon-display]{color:var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));border-radius:var(--wy-component-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem));margin:auto}[part~=wy-icon-display-icon]{color:var(--wy-component-color);--wy-component-icon-width: calc(4 * var(--wy-size, 1rem));--wy-component-icon-height: calc(4 * var(--wy-size, 1rem));padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem))}[part~=wy-icon-display-text],[part~=wy-icon-display-meta]{color:var(--wy-component-color);padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem));text-align:center}[part~=wy-icon-color-primary]{fill:var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-icon-color-secondary]{fill:var(--wy-secondary, var(--wy-secondary-40, #3b6a1c))}[part~=wy-icon-color-tertiary]{fill:var(--wy-tertiary, var(--wy-tertiary-40, #3b6a1c))}[part~=wy-icon-color-surface]{fill:var(--wy-surface, var(--wy-neutral-99, #fcfcff))}[part~=wy-icon-color-surface-variant]{fill:var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb))}[part~=wy-icon-color-error]{fill:var(--wy-error, var(--wy-error-40, #ba1824))}[part~=wy-icon-color-warning]{fill:var(--wy-warning, var(--wy-warning-70, #afb140))}[part~=wy-icon-color-blue]{fill:var(--wy-blue, var(--wy-blue-light, #89a9fc))}[part~=wy-icon-color-indigo]{fill:var(--wy-indigo, var(--wy-indigo-light, #9185de))}[part~=wy-icon-color-purple]{fill:var(--wy-purple, var(--wy-purple-light, #c675b7))}[part~=wy-icon-color-pink]{fill:var(--wy-pink, var(--wy-pink-light, #d57194))}[part~=wy-icon-color-red]{fill:var(--wy-red, var(--wy-red-light, #db726c))}[part~=wy-icon-color-orange]{fill:var(--wy-orange, var(--wy-orange-light, #e89a3a))}[part~=wy-icon-color-yellow]{fill:var(--wy-yellow, var(--wy-yellow-light, #afb140))}[part~=wy-icon-color-green]{fill:var(--wy-green, var(--wy-green-light, #00a38b))}[part~=wy-icon-color-teal]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a8))}[part~=wy-icon-color-cyan]{fill:var(--wy-cyan, var(--wy-cyan-light, #0082a1))}[part~=wy-icon-color-gray]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-icon-color-black]{fill:var(--wy-black, var(--wy-black, #000000))}[part~=wy-icon-color-white]{fill:var(--wy-white, var(--wy-white, #ffffff))}[part*=wy-kind-]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-kind-archive]{fill:var(--wy-orange, var(--wy-orange-light, #e89a3a))}[part~=wy-kind-audio]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a8))}[part~=wy-kind-code]{fill:var(--wy-green, var(--wy-green-light, #00a38b))}[part~=wy-kind-document]{fill:var(--wy-blue, var(--wy-blue-light, #89a9fc))}[part~=wy-kind-email]{fill:var(--wy-red, var(--wy-red-light, #db726c))}[part~=wy-kind-presentation]{fill:var(--wy-orange, var(--wy-orange-light, #e89a3a))}[part~=wy-kind-spreadsheet]{fill:var(--wy-green, var(--wy-green-light, #00a38b))}[part~=wy-kind-image]{fill:var(--wy-pink, var(--wy-pink-light, #d57194))}[part~=wy-kind-text]{fill:var(--wy-cyan, var(--wy-cyan-light, #0082a1))}[part~=wy-kind-video]{fill:var(--wy-purple, var(--wy-purple-light, #c675b7))}[part~=wy-ext-pdf]{fill:var(--wy-red, var(--wy-red-light, #db726c))}[part~=wy-kind-text-icon]{width:calc(1.25 * var(--wy-size, 1rem));height:calc(1.25 * var(--wy-size, 1rem));vertical-align:calc(-.3125 * var(--wy-size, 1rem))}.wy-title{font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));font-size:var(--wy-headings-font-size, 1.25em);font-style:var(--wy-headings-font-style, unset);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.2));margin-block:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}.wy-input{--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border:var(--wy-input-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));display:block;width:100%;min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em)) * 1.5 * var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * 2 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) * 2);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-input-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem))));background-clip:padding-box;appearance:none;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}.wy-input:focus{--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));color:var(--wy-component-color);border-color:var(--wy-primary, var(--wy-primary-40, #006399));outline:0}.wy-input::placeholder{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));opacity:1}.wy-input:disabled{opacity:38%}.wy-input::file-selector-button,.wy-input::-webkit-file-upload-button{color:var(--wy-component-color);background-color:var(--wy-component-background-color);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));margin:calc(-1 * var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) calc(-1 * var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));margin-inline-end:var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));pointer-events:none;border-color:inherit;border-style:solid;border-width:0;border-inline-end-width:var(--wy-input-border-width, var(--wy-border, 1px));border-radius:0}.wy-input:hover:not(:disabled):not([readonly])::file-selector-button,.wy-input:hover:not(:disabled):not([readonly]) ::-webkit-file-upload-button{background-color:var(--wy-component-background-color)}.wy-input[type=file]{overflow:hidden}.wy-input[type=file]:not(:disabled):not([readonly]){cursor:pointer}.wy-input::-webkit-date-and-time-value{height:calc(var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem)))) * 1em)}.wy-input[type=search]::-webkit-search-cancel-button{-webkit-appearance:none}.wy-input-filled{--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-input-filled-border-radius, var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem)))));border-color:var(--wy-component-background-color)}.wy-input-filled:focus{border-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-label{display:inline-block;margin-bottom:calc(.5 * var(--wy-size, 1rem))}.wy-description{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));margin-top:calc(.25 * var(--wy-size, 1rem))}.wy-is-invalid,.wy-is-invalid:focus{border-color:var(--wy-error, var(--wy-error-40, #ba1824))}.wy-invalid-feedback{margin-top:calc(.25 * var(--wy-size, 1rem));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));color:var(--wy-error, var(--wy-error-40, #ba1824))}.wy-input-group{position:relative;display:flex;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));align-items:center;flex:1 0 auto}.wy-input-group-button-icon{--wy-component-background-color: transparent}.wy-input-group-input-with-overlay{padding-right:calc(var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) + var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}.wy-input-group-button-icon-overlay{position:absolute;display:inline-flex;top:0;right:0;z-index:4;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));--wy-component-background-color: transparent}.wy-input-group-input:placeholder-shown~.wy-input-group-button-icon[type=reset]{display:none}.wy-input-group-input:not(:placeholder-shown)~.wy-input-group-button-icon[type=reset]+.wy-input-group-button-icon{display:none}.wy-item{--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));position:relative;display:flex;align-items:center;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));text-decoration:none}.wy-list-item{min-height:calc(3 * var(--wy-size, 1rem))}.wy-list-item-lg{min-height:calc(4.5 * var(--wy-size, 1rem))}.wy-item-inner{display:flex;align-items:center;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));flex:1 1 100%}.wy-item-body{width:100%;min-width:0}.wy-item-rows{display:flex;flex-direction:column;width:100%;row-gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));min-width:0}.wy-item-rows:only-child{margin-inline-start:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-item-rows-compact{row-gap:0}.wy-item-rows-single{margin-inline-start:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-item-title{color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset))}.wy-item-title{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-item-title-lg{color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset))}.wy-item-title-lg{display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;overflow:hidden}.wy-item-text{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}.wy-item-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-item-text .wy-icon{width:calc(1.25 * var(--wy-size, 1rem));height:calc(1.25 * var(--wy-size, 1rem));vertical-align:calc(-.3125 * var(--wy-size, 1rem))}.wy-item-quote{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e))}.wy-item-quote:before,.wy-item-quote:after{content:'\"'}.wy-item-actions{--wy-component-background-color: transparent;display:flex;align-items:center;justify-items:flex-end;flex:0 0 auto;margin:calc(-.25 * var(--wy-size, 1rem))}.wy-item-top{align-self:flex-start}.wy-item-actions-bottom{align-self:flex-start;margin-block:calc(-.5 * var(--wy-size, 1rem))}.wy-item-row{display:flex;align-items:center;column-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}.wy-item-row .wy-item-title,.wy-item-row .wy-item-text{margin-right:auto}.wy-item-row .wy-meta{white-space:nowrap}.wy-item-right{margin-left:auto}.wy-item-hover{-webkit-user-select:none;user-select:none;cursor:pointer}.wy-item-hover:hover,.wy-item-hover:focus{--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);text-decoration:none}.wy-item-hover:active{--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-item-hover.wy-disabled,.wy-item-hover:disabled{opacity:var(--wy-opacity-disabled, 38%);pointer-events:none}.wy-item-hover.wy-active{--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-90, #cde5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-primary-10, #001d32));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-color:var(--wy-component-background-color)}.wy-item-trashed{text-decoration:line-through;opacity:var(--wy-opacity-disabled, 38%)}.wy-item-trashed.wy-item-hover:hover{opacity:1}.wy-list{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;gap:var(--wy-border);min-width:0}.wy-list .wy-item:not(.wy-item-hover){--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-list .wy-item:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.wy-list .wy-item:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.wy-list-bordered{border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));gap:0}.wy-list-bordered .wy-item{border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));border-left:none;border-right:none}.wy-list-bordered .wy-item:first-child{border-top:none}.wy-list-bordered .wy-item:last-child{border-bottom:none}.wy-list-bordered .wy-item+.wy-list-bordered .wy-item{border-top-width:0}@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-primary-95, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-primary-10, #001d32))}}.wy-messages{padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));flex:1 1 100%}.wy-message-placeholder{opacity:.5}.wy-date-separator{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));pointer-events:none;margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));text-align:center;position:sticky;top:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));z-index:10}.wy-date-separator time{background:var(--wy-surface-3, var(--wy-surface-3-light, #e3e7ee));color:var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:inline-block}.wy-message{display:flex;flex-direction:row;align-items:flex-start;margin-bottom:calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + .5 * var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));scroll-margin-block:6rem;--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}.wy-message[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}.wy-message-area{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-message-meta{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:0 0 calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));color:var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}.wy-message-bubble{background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));display:flex;flex-direction:column;padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));max-width:min(32 * var(--wy-size, 1rem),100% - 2 * var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}.wy-message-bubble>div{flex:1 1 100%}.wy-message-author{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:calc(1lh + .5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5 * var(--wy-size, 1rem)) 0 0}.wy-message-content{display:flex;flex-direction:column;width:100%;align-items:flex-start;flex-wrap:wrap;min-width:0;position:relative}.wy-message-content-row{display:flex;flex-direction:row;align-items:center;max-width:100%}.wy-message-agent{--wy-component-background-color: var(--wy-tertiary-container, var(--wy-tertiary-90, #bbf294));--wy-component-color: var(--wy-on-tertiary-container, var(--wy-tertiary-10, #0a2100))}.wy-message-me{margin-right:0;margin-left:calc(2.5 * var(--wy-size, 1rem));align-items:flex-end;--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-90, #cde5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-primary-10, #001d32))}.wy-message-me .wy-message-meta{margin:0 calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) 0}.wy-message-me .wy-message-content{align-items:flex-end}.wy-message-me .wy-message-content-row{flex-direction:row-reverse}.wy-message-emoji .wy-message-bubble{background:none;padding:0 0 var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}.wy-message-emoji .wy-content .wy-emoji{width:calc(3 * var(--wy-size, 1rem));height:calc(3 * var(--wy-size, 1rem));margin:0}.wy-message-emoji.wy-message-me .wy-content{text-align:end}.wy-readby-status{display:flex;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));height:calc(1.125 * var(--wy-size, 1rem));justify-content:flex-end;margin-top:calc(-.125 * var(--wy-size, 1rem))}.wy-message-readmore{justify-self:center;text-align:center}.wy-meta{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}.wy-meta-sm{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))}.wy-dialog{background:none;border:none;padding:0;margin:0}.wy-dialog[popover]{position:fixed;inset:0;z-index:1055}.wy-overlay-dialog{width:100%;height:100%;align-items:center;justify-content:center;overflow:visible;max-width:100%;max-height:100%}.wy-overlay-dialog[open]{display:flex}.wy-overlay-dialog:popover-open{display:flex}.wy-overlay-dialog:focus-visible{outline:none}.wy-overlay{--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column}.wy-overlay.wy-modal{width:100%;height:100%;overflow:hidden;border-radius:0}@media (min-width: 768px){.wy-overlay.wy-modal-padded{border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level4, 0 calc(1 * var(--wy-size, 1rem)) calc(2.25 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .14), 0 calc(.375 * var(--wy-size, 1rem)) calc(1.875 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .12), 0 calc(.5 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) calc(-.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));margin-left:calc(4 * var(--wy-size, 1rem));margin-top:auto;margin-right:calc(4 * var(--wy-size, 1rem));margin-bottom:auto;width:calc(32 * var(--wy-size, 1rem));max-height:calc(32 * var(--wy-size, 1rem))}}@media (min-width: 768px){.wy-overlay.wy-modal-full{margin:0;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level4, 0 calc(1 * var(--wy-size, 1rem)) calc(2.25 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .14), 0 calc(.375 * var(--wy-size, 1rem)) calc(1.875 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .12), 0 calc(.5 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) calc(-.3125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));max-width:calc(100% - 2 * var(--wy-size, 1rem));max-height:calc(100% - 2 * var(--wy-size, 1rem))}}.wy-overlay{opacity:0;visibility:hidden;transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) .01s,transform var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) .01s,visibility .01s step-end var(--wy-transition-duration-fast, .1s)}.wy-overlay.wy-open{transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),visibility var(--wy-transition-duration, .2s) step-start;visibility:visible}.wy-overlay.wy-open.wy-transition{opacity:1;transform:none}.wy-pane{display:flex;flex-direction:column;position:relative;min-height:0;height:100%;flex:1 1 auto}.wy-pane-body{display:flex;flex-direction:column;flex:1}.wy-pane-group{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}.wy-pane-background{--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-pane-toolbar{display:flex;flex:1;justify-content:space-evenly;align-items:center;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-picker-list{background:var(--wy-component-background-color);color:var(--wy-component-color);border:none}.wy-picker-list>.wy-picker-list-item:first-child,.wy-picker-list>:first-child .wy-picker-list-item{border-top:none}.wy-picker-list>.wy-picker-list-item:last-child,.wy-picker-list>:last-child .wy-picker-list-item{border-bottom:none}.wy-picker-list-item{display:flex;align-items:center;padding:calc(.25 * var(--wy-size, 1rem)) calc(.5 * var(--wy-size, 1rem))}.wy-picker-list-item>wy-icon{margin-left:calc(.25 * var(--wy-size, 1rem));margin-right:calc(.25 * var(--wy-size, 1rem));flex:0 0 auto}.wy-picker-list-item>button{margin-block-start:auto;flex:0 0 auto}.wy-picker-list-item-title{flex-grow:1}.wy-picker-list-item-title{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-main{display:flex;height:calc(100% - var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem))))));min-height:0}@media (max-width: 767.98px){.wy-main{flex-direction:column}}.wy-preview{--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;align-items:stretch;justify-content:stretch;position:relative;flex:1 1 100%;min-width:calc(16 * var(--wy-size, 1rem));min-height:calc(16 * var(--wy-size, 1rem));max-height:100%;max-width:100%}.wy-preview-layout{width:100%;height:100%}.wy-preview-swiper{display:flex;flex-direction:row;flex:1 1 100%;align-items:center;justify-content:start;min-width:calc(16 * var(--wy-size, 1rem));min-height:calc(16 * var(--wy-size, 1rem));max-height:100%;max-width:100%;overflow-x:scroll;scroll-snap-type:x mandatory;scroll-behavior:auto;overscroll-behavior-x:none;scrollbar-width:none}.wy-preview-swiper::-webkit-scrollbar{display:none}.wy-preview-swiper-disabled{overflow-x:hidden}.wy-preview-area{position:relative;min-width:100%;min-height:100%;width:100%;height:100%;flex:1 1 auto;display:flex;flex-direction:column;scroll-snap-stop:always;scroll-snap-align:center}.wy-nav-prev,.wy-nav-next{--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));background-color:var(--wy-component-background-color);position:absolute;top:50%;z-index:1000;border-radius:50%}.wy-nav-prev{left:calc(.5 * var(--wy-size, 1rem))}.wy-nav-next{right:calc(.5 * var(--wy-size, 1rem))}.wy-document{--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);align-self:flex-start;padding:calc(2 * var(--wy-size, 1rem)) calc(3.5 * var(--wy-size, 1rem));width:100%;min-height:100%;flex:1 0 auto}@media (min-width: 768px){.wy-document{padding:calc(3 * var(--wy-size, 1rem)) calc(4 * var(--wy-size, 1rem));margin:calc(2 * var(--wy-size, 1rem)) auto;border-radius:calc(.125 * var(--wy-size, 1rem));box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));width:120ch;min-height:170ch;max-width:calc(100% - 3.5 * var(--wy-size, 1rem))}}.wy-content-code{align-self:flex-start;width:100%;padding:calc(2 * var(--wy-size, 1rem)) calc(3.5 * var(--wy-size, 1rem));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}.wy-content-iframe{border:0;display:block;width:100%;height:100%;top:0;left:0;flex:1 1 100%}.wy-content-iframe.wy-loaded{--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-content-iframe.wy-loaded~.wy-content-iframe-fallback,.wy-content-iframe.wy-loaded~.wy-spinner,.wy-content-iframe.wy-loaded~wy-spinner{display:none}.wy-content-iframe.wy-loading:not(.wy-loaded){position:absolute;visibility:hidden;z-index:-1;pointer-events:none}.wy-content-iframe.wy-loading:not(.wy-loaded):not(.wy-fallback)~.wy-content-iframe-fallback{display:none}.wy-content-iframe.wy-loading:not(.wy-loaded).wy-fallback~.wy-spinner,.wy-content-iframe.wy-loading:not(.wy-loaded).wy-fallback~wy-spinner{display:none}.wy-content-iframe~.wy-spinner,.wy-content-iframe~wy-spinner{margin:auto}.wy-content-html pre,.wy-content-html code{word-break:break-word;white-space:pre-wrap}.wy-content-image{min-width:0;display:flex;align-items:center;justify-content:center;position:relative;margin:auto;max-height:100%;max-width:100%;transition:transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform-origin var(--wy-transition-duration, .2s) step-end}.wy-content-image.wy-zoom{cursor:zoom-out;transition:transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),transform-origin var(--wy-transition-duration, .2s) step-start}.wy-content-image img{min-width:0;min-height:0;width:100%;height:100%}.wy-content-image img:not(.wy-loading-transition):not([data-controller~=image])~.wy-spinner,.wy-content-image img:not(.wy-loading-transition):not([data-controller~=image])~wy-spinner{display:none}.wy-content-image img.wy-loading,.wy-content-image img[data-controller~=image]{transition:opacity .15s ease-out;opacity:0}.wy-content-image img.wy-loading.wy-loaded,.wy-content-image img[data-controller~=image].wy-loaded{opacity:1;transition:opacity .15s ease-out}.wy-content-image img.wy-loading.wy-loaded~img,.wy-content-image img[data-controller~=image].wy-loaded~img{transition-delay:.15s;opacity:0}.wy-content-image img.wy-loading.wy-loaded~.wy-spinner,.wy-content-image img.wy-loading.wy-loaded~wy-spinner,.wy-content-image img[data-controller~=image].wy-loaded~.wy-spinner,.wy-content-image img[data-controller~=image].wy-loaded~wy-spinner{display:none}.wy-content-image img.wy-responsive-image-thumb{position:absolute;z-index:-1}.wy-content-image img~.wy-spinner,.wy-content-image img~wy-spinner{position:absolute}.wy-content-video:not(.wy-error){min-height:0;max-width:100%;max-height:100%;flex:1 1 auto}.wy-content-video,.wy-content-audio{margin:auto}.wy-content-video.wy-loading:not(.wy-loaded),.wy-content-video[data-controller~=media]:not(.wy-loaded),.wy-content-audio.wy-loading:not(.wy-loaded),.wy-content-audio[data-controller~=media]:not(.wy-loaded){visibility:hidden}.wy-content-video.wy-loading.wy-loaded~.wy-spinner,.wy-content-video.wy-loading.wy-loaded~wy-spinner,.wy-content-video[data-controller~=media].wy-loaded~.wy-spinner,.wy-content-video[data-controller~=media].wy-loaded~wy-spinner,.wy-content-audio.wy-loading.wy-loaded~.wy-spinner,.wy-content-audio.wy-loading.wy-loaded~wy-spinner,.wy-content-audio[data-controller~=media].wy-loaded~.wy-spinner,.wy-content-audio[data-controller~=media].wy-loaded~wy-spinner{display:none}.wy-content-video:focus,.wy-content-audio:focus{outline:none}.wy-pdf-container{position:absolute;width:100%;height:100%;bottom:0;left:0}.wy-pdf-container{overflow-y:auto;max-height:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-pdf-container:not(body){-webkit-overflow-scrolling:touch}.wy-pdf-container{overflow-x:auto;max-width:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-content-pdf .textLayer{position:absolute;text-align:initial;inset:0;overflow:clip;opacity:1;line-height:1;text-size-adjust:none;forced-color-adjust:none;transform-origin:0 0;caret-color:CanvasText;z-index:0}.wy-content-pdf .textLayer.highlighting{touch-action:none}.wy-content-pdf .textLayer :is(span,br){color:transparent;position:absolute;white-space:pre;cursor:text;transform-origin:0% 0%}.wy-content-pdf .textLayer>:not(.markedContent),.wy-content-pdf .textLayer .markedContent span:not(.markedContent){z-index:1}.wy-content-pdf .textLayer span.markedContent{top:0;height:0}.wy-content-pdf .textLayer span[role=img]{-webkit-user-select:none;user-select:none;cursor:default}.wy-content-pdf .textLayer .highlight{--highlight-bg-color: rgb(180 0 170 / .25);--highlight-selected-bg-color: rgb(0 100 0 / .25);--highlight-backdrop-filter: none;--highlight-selected-backdrop-filter: none}@media screen and (forced-colors: active){.wy-content-pdf .textLayer .highlight{--highlight-bg-color: transparent;--highlight-selected-bg-color: transparent;--highlight-backdrop-filter: var(--hcm-highlight-filter);--highlight-selected-backdrop-filter: var(--hcm-highlight-selected-filter)}}.wy-content-pdf .textLayer .highlight{margin:-1px;padding:1px;background-color:var(--highlight-bg-color);-webkit-backdrop-filter:var(--highlight-backdrop-filter);backdrop-filter:var(--highlight-backdrop-filter);border-radius:4px}.wy-content-pdf .textLayer .highlight.appended{position:initial}.wy-content-pdf .textLayer .highlight.begin{border-radius:4px 0 0 4px}.wy-content-pdf .textLayer .highlight.end{border-radius:0 4px 4px 0}.wy-content-pdf .textLayer .highlight.middle{border-radius:0}.wy-content-pdf .textLayer .highlight.selected{background-color:var(--highlight-selected-bg-color);-webkit-backdrop-filter:var(--highlight-selected-backdrop-filter);backdrop-filter:var(--highlight-selected-backdrop-filter)}.wy-content-pdf .textLayer ::selection{background:#0000ff40;background:color-mix(in srgb,AccentColor,transparent 75%)}.wy-content-pdf .textLayer br::selection{background:transparent}.wy-content-pdf .textLayer .endOfContent{display:block;position:absolute;inset:100% 0 0;z-index:0;cursor:default;-webkit-user-select:none;user-select:none}.wy-content-pdf .textLayer.selecting .endOfContent{top:0}.wy-content-pdf .annotationLayer{--annotation-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\");--input-focus-border-color: Highlight;--input-focus-outline: 1px solid Canvas;--input-unfocused-border-color: transparent;--input-disabled-border-color: transparent;--input-hover-border-color: black;--link-outline: none}@media screen and (forced-colors: active){.wy-content-pdf .annotationLayer{--input-focus-border-color: CanvasText;--input-unfocused-border-color: ActiveText;--input-disabled-border-color: GrayText;--input-hover-border-color: Highlight;--link-outline: 1.5px solid LinkText}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):required,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:required,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:required{outline:1.5px solid selectedItem}.wy-content-pdf .annotationLayer .linkAnnotation{outline:var(--link-outline)}.wy-content-pdf .annotationLayer .linkAnnotation:hover{-webkit-backdrop-filter:var(--hcm-highlight-filter);backdrop-filter:var(--hcm-highlight-filter)}.wy-content-pdf .annotationLayer .linkAnnotation>a:hover{opacity:0!important;background:none!important;box-shadow:none}.wy-content-pdf .annotationLayer .popupAnnotation .popup{outline:calc(1.5px * var(--scale-factor)) solid CanvasText!important;background-color:ButtonFace!important;color:ButtonText!important}.wy-content-pdf .annotationLayer .highlightArea:hover:after{position:absolute;top:0;left:0;width:100%;height:100%;-webkit-backdrop-filter:var(--hcm-highlight-filter);backdrop-filter:var(--hcm-highlight-filter);content:\"\";pointer-events:none}.wy-content-pdf .annotationLayer .popupAnnotation.focused .popup{outline:calc(3px * var(--scale-factor)) solid Highlight!important}}.wy-content-pdf .annotationLayer{position:absolute;top:0;left:0;pointer-events:none;transform-origin:0 0}.wy-content-pdf .annotationLayer[data-main-rotation=\"90\"] .norotate{transform:rotate(270deg) translate(-100%)}.wy-content-pdf .annotationLayer[data-main-rotation=\"180\"] .norotate{transform:rotate(180deg) translate(-100%,-100%)}.wy-content-pdf .annotationLayer[data-main-rotation=\"270\"] .norotate{transform:rotate(90deg) translateY(-100%)}.wy-content-pdf .annotationLayer.disabled section,.wy-content-pdf .annotationLayer.disabled .popup{pointer-events:none}.wy-content-pdf .annotationLayer .annotationContent{position:absolute;width:100%;height:100%;pointer-events:none}.wy-content-pdf .annotationLayer .annotationContent.freetext{background:transparent;border:none;inset:0;overflow:visible;white-space:nowrap;font:10px sans-serif;line-height:1.35;-webkit-user-select:none;user-select:none}.wy-content-pdf .annotationLayer section{position:absolute;text-align:initial;pointer-events:auto;box-sizing:border-box;transform-origin:0 0}.wy-content-pdf .annotationLayer section:has(div.annotationContent) canvas.annotationContent{display:none}.textLayer.selecting~.wy-content-pdf .annotationLayer section{pointer-events:none}.wy-content-pdf .annotationLayer :is(.linkAnnotation,.buttonWidgetAnnotation.pushButton)>a{position:absolute;font-size:1em;top:0;left:0;width:100%;height:100%}.wy-content-pdf .annotationLayer :is(.linkAnnotation,.buttonWidgetAnnotation.pushButton):not(.hasBorder)>a:hover{opacity:.2;background-color:#ff0;box-shadow:0 2px 10px #ff0}.wy-content-pdf .annotationLayer .linkAnnotation.hasBorder:hover{background-color:#ff03}.wy-content-pdf .annotationLayer .hasBorder{background-size:100% 100%}.wy-content-pdf .annotationLayer .textAnnotation img{position:absolute;cursor:pointer;width:100%;height:100%;top:0;left:0}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea),.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input{background-image:var(--annotation-unfocused-field-background);border:2px solid var(--input-unfocused-border-color);box-sizing:border-box;font:calc(9px * var(--scale-factor)) sans-serif;height:100%;margin:0;vertical-align:top;width:100%}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):required,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:required,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:required{outline:1.5px solid red}.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select option{padding:0}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input{border-radius:50%}.wy-content-pdf .annotationLayer .textWidgetAnnotation textarea{resize:none}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea)[disabled],.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select[disabled],.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input[disabled]{background:none;border:2px solid var(--input-disabled-border-color);cursor:not-allowed}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):hover,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:hover,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:hover{border:2px solid var(--input-hover-border-color)}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):hover,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:hover,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:hover{border-radius:2px}.wy-content-pdf .annotationLayer .textWidgetAnnotation :is(input,textarea):focus,.wy-content-pdf .annotationLayer .choiceWidgetAnnotation select:focus{background:none;border:2px solid var(--input-focus-border-color);border-radius:2px;outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) :focus{background-image:none;background-color:transparent}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox :focus{border:2px solid var(--input-focus-border-color);border-radius:2px;outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton :focus{border:2px solid var(--input-focus-border-color);outline:var(--input-focus-outline)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{background-color:CanvasText;content:\"\";display:block;position:absolute}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{height:80%;left:45%;width:1px}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{transform:rotate(45deg)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{transform:rotate(-45deg)}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{border-radius:50%;height:50%;left:25%;top:25%;width:50%}.wy-content-pdf .annotationLayer .textWidgetAnnotation input.comb{font-family:monospace;padding-left:2px;padding-right:0}.wy-content-pdf .annotationLayer .textWidgetAnnotation input.comb:focus{width:103%}.wy-content-pdf .annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input{appearance:none}.wy-content-pdf .annotationLayer .fileAttachmentAnnotation .popupTriggerArea{height:100%;width:100%}.wy-content-pdf .annotationLayer .popupAnnotation{position:absolute;font-size:calc(9px * var(--scale-factor));pointer-events:none;width:max-content;max-width:45%;height:auto}.wy-content-pdf .annotationLayer .popup{background-color:#ff9;box-shadow:0 calc(2px * var(--scale-factor)) calc(5px * var(--scale-factor)) #888;border-radius:calc(2px * var(--scale-factor));outline:1.5px solid rgb(255,255,74);padding:calc(6px * var(--scale-factor));cursor:pointer;font:message-box;white-space:normal;word-wrap:break-word;pointer-events:auto}.wy-content-pdf .annotationLayer .popupAnnotation.focused .popup{outline-width:3px}.wy-content-pdf .annotationLayer .popup *{font-size:calc(9px * var(--scale-factor))}.wy-content-pdf .annotationLayer .popup>.header{display:inline-block}.wy-content-pdf .annotationLayer .popup>.header h1{display:inline}.wy-content-pdf .annotationLayer .popup>.header .popupDate{display:inline-block;margin-left:calc(5px * var(--scale-factor));width:fit-content}.wy-content-pdf .annotationLayer .popupContent{border-top:1px solid rgb(51,51,51);margin-top:calc(2px * var(--scale-factor));padding-top:calc(2px * var(--scale-factor))}.wy-content-pdf .annotationLayer .richText>*{white-space:pre-wrap;font-size:calc(9px * var(--scale-factor))}.wy-content-pdf .annotationLayer .popupTriggerArea{cursor:pointer}.wy-content-pdf .annotationLayer section svg{position:absolute;width:100%;height:100%;top:0;left:0}.wy-content-pdf .annotationLayer .annotationTextContent{position:absolute;width:100%;height:100%;opacity:0;color:transparent;-webkit-user-select:none;user-select:none;pointer-events:none}.wy-content-pdf .annotationLayer .annotationTextContent span{width:100%;display:inline-block}.wy-content-pdf .annotationLayer svg.quadrilateralsContainer{contain:strict;width:0;height:0;position:absolute;top:0;left:0;z-index:-1}:host{--xfa-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\");--xfa-focus-outline: auto}@media screen and (forced-colors: active){:host{--xfa-focus-outline: 2px solid CanvasText}.wy-content-pdf .xfaLayer *:required{outline:1.5px solid selectedItem}}.wy-content-pdf .xfaLayer{background-color:transparent}.wy-content-pdf .xfaLayer .highlight{margin:-1px;padding:1px;background-color:#efcbed;border-radius:4px}.wy-content-pdf .xfaLayer .highlight.appended{position:initial}.wy-content-pdf .xfaLayer .highlight.begin{border-radius:4px 0 0 4px}.wy-content-pdf .xfaLayer .highlight.end{border-radius:0 4px 4px 0}.wy-content-pdf .xfaLayer .highlight.middle{border-radius:0}.wy-content-pdf .xfaLayer .highlight.selected{background-color:#cbdfcb}.wy-content-pdf .xfaPage{overflow:hidden;position:relative}.wy-content-pdf .xfaContentarea{position:absolute}.wy-content-pdf .xfaPrintOnly{display:none}.wy-content-pdf .xfaLayer{position:absolute;text-align:initial;top:0;left:0;transform-origin:0 0;line-height:1.2}.wy-content-pdf .xfaLayer *{color:inherit;font:inherit;font-style:inherit;font-weight:inherit;font-kerning:inherit;letter-spacing:-.01px;text-align:inherit;text-decoration:inherit;box-sizing:border-box;background-color:transparent;padding:0;margin:0;pointer-events:auto;line-height:inherit}.wy-content-pdf .xfaLayer *:required{outline:1.5px solid red}.wy-content-pdf .xfaLayer div,.wy-content-pdf .xfaLayer svg,.wy-content-pdf .xfaLayer svg *{pointer-events:none}.wy-content-pdf .xfaLayer a{color:#00f}.wy-content-pdf .xfaRich li{margin-left:3em}.wy-content-pdf .xfaFont{color:#000;font-weight:400;font-kerning:none;font-size:10px;font-style:normal;letter-spacing:0;text-decoration:none;vertical-align:0}.wy-content-pdf .xfaCaption{overflow:hidden;flex:0 0 auto}.wy-content-pdf .xfaCaptionForCheckButton{overflow:hidden;flex:1 1 auto}.wy-content-pdf .xfaLabel{height:100%;width:100%}.wy-content-pdf .xfaLeft{display:flex;flex-direction:row;align-items:center}.wy-content-pdf .xfaRight{display:flex;flex-direction:row-reverse;align-items:center}.wy-content-pdf :is(.xfaLeft,.xfaRight)>:is(.xfaCaption,.xfaCaptionForCheckButton){max-height:100%}.wy-content-pdf .xfaTop{display:flex;flex-direction:column;align-items:flex-start}.wy-content-pdf .xfaBottom{display:flex;flex-direction:column-reverse;align-items:flex-start}.wy-content-pdf :is(.xfaTop,.xfaBottom)>:is(.xfaCaption,.xfaCaptionForCheckButton){width:100%}.wy-content-pdf .xfaBorder{background-color:transparent;position:absolute;pointer-events:none}.wy-content-pdf .xfaWrapped{width:100%;height:100%}.wy-content-pdf :is(.xfaTextfield,.xfaSelect):focus{background-image:none;background-color:transparent;outline:var(--xfa-focus-outline);outline-offset:-1px}.wy-content-pdf :is(.xfaCheckbox,.xfaRadio):focus{outline:var(--xfa-focus-outline)}.wy-content-pdf .xfaTextfield,.wy-content-pdf .xfaSelect{height:100%;width:100%;flex:1 1 auto;border:none;resize:none;background-image:var(--xfa-unfocused-field-background)}.wy-content-pdf .xfaSelect{padding-inline:2px}.wy-content-pdf :is(.xfaTop,.xfaBottom)>:is(.xfaTextfield,.xfaSelect){flex:0 1 auto}.wy-content-pdf .xfaButton{cursor:pointer;width:100%;height:100%;border:none;text-align:center}.wy-content-pdf .xfaLink{width:100%;height:100%;position:absolute;top:0;left:0}.wy-content-pdf .xfaCheckbox,.wy-content-pdf .xfaRadio{width:100%;height:100%;flex:0 0 auto;border:none}.wy-content-pdf .xfaRich{white-space:pre-wrap;width:100%;height:100%}.wy-content-pdf .xfaImage{object-position:left top;object-fit:contain;width:100%;height:100%}.wy-content-pdf .xfaLrTb,.wy-content-pdf .xfaRlTb,.wy-content-pdf .xfaTb{display:flex;flex-direction:column;align-items:stretch}.wy-content-pdf .xfaLr{display:flex;flex-direction:row;align-items:stretch}.wy-content-pdf .xfaRl{display:flex;flex-direction:row-reverse;align-items:stretch}.wy-content-pdf .xfaTb>div{justify-content:left}.wy-content-pdf .xfaPosition,.wy-content-pdf .xfaArea{position:relative}.wy-content-pdf .xfaValignMiddle{display:flex;align-items:center}.wy-content-pdf .xfaTable{display:flex;flex-direction:column;align-items:stretch}.wy-content-pdf .xfaTable .xfaRow{display:flex;flex-direction:row;align-items:stretch}.wy-content-pdf .xfaTable .xfaRlRow{display:flex;flex-direction:row-reverse;align-items:stretch;flex:1}.wy-content-pdf .xfaTable .xfaRlRow>div{flex:1}.wy-content-pdf :is(.xfaNonInteractive,.xfaDisabled,.xfaReadOnly) :is(input,textarea){background:initial}@media print{.wy-content-pdf .xfaTextfield,.wy-content-pdf .xfaSelect{background:transparent}.wy-content-pdf .xfaSelect{appearance:none;text-indent:1px;text-overflow:\"\"}}:host{--viewer-container-height: 0;--pdfViewer-padding-bottom: 0;--page-margin: 1px auto -8px;--page-border: 9px solid transparent;--spreadHorizontalWrapped-margin-LR: -3.5px;--loading-icon-delay: .4s}@media screen and (forced-colors: active){:host{--pdfViewer-padding-bottom: 9px;--page-margin: 8px auto -1px;--page-border: 1px solid CanvasText;--spreadHorizontalWrapped-margin-LR: 3.5px}}.wy-content-pdf [data-main-rotation=\"90\"]{transform:rotate(90deg) translateY(-100%)}.wy-content-pdf [data-main-rotation=\"180\"]{transform:rotate(180deg) translate(-100%,-100%)}.wy-content-pdf [data-main-rotation=\"270\"]{transform:rotate(270deg) translate(-100%)}.wy-content-pdf #hiddenCopyElement,.wy-content-pdf .hiddenCanvasElement{position:absolute;top:0;left:0;width:0;height:0;display:none}.wy-content-pdf .pdfViewer{--scale-factor: 1;--page-bg-color: unset;padding-bottom:var(--pdfViewer-padding-bottom);--hcm-highlight-filter: none;--hcm-highlight-selected-filter: none}@media screen and (forced-colors: active){.wy-content-pdf .pdfViewer{--hcm-highlight-filter: invert(100%)}}.wy-content-pdf .pdfViewer.copyAll{cursor:wait}.wy-content-pdf .pdfViewer .canvasWrapper{overflow:hidden;width:100%;height:100%}.wy-content-pdf .pdfViewer .canvasWrapper canvas{position:absolute;top:0;left:0;margin:0;display:block;width:100%;height:100%;contain:content}.wy-content-pdf .pdfViewer .canvasWrapper canvas .structTree{contain:strict}.wy-content-pdf .pdfViewer .page{--scale-round-x: 1px;--scale-round-y: 1px;direction:ltr;width:816px;height:1056px;margin:var(--page-margin);position:relative;overflow:visible;border:var(--page-border);background-clip:content-box;background-color:var(--page-bg-color, rgb(255, 255, 255))}.wy-content-pdf .pdfViewer .dummyPage{position:relative;width:0;height:var(--viewer-container-height)}.wy-content-pdf .pdfViewer.noUserSelect{-webkit-user-select:none;user-select:none}.wy-content-pdf .pdfViewer.removePageBorders .page{margin:0 auto 10px;border:none}.wy-content-pdf .pdfViewer.singlePageView{display:inline-block}.wy-content-pdf .pdfViewer.singlePageView .page{margin:0;border:none}.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped),.wy-content-pdf .spread{margin-inline:3.5px;text-align:center}.wy-content-pdf .pdfViewer.scrollHorizontal,.wy-content-pdf .spread{white-space:nowrap}.wy-content-pdf .pdfViewer.removePageBorders,.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) .spread{margin-inline:0}.wy-content-pdf .spread :is(.page,.dummyPage),.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) :is(.page,.spread){display:inline-block;vertical-align:middle}.wy-content-pdf .spread .page,.wy-content-pdf .pdfViewer:is(.scrollHorizontal,.scrollWrapped) .page{margin-inline:var(--spreadHorizontalWrapped-margin-LR)}.wy-content-pdf .pdfViewer.removePageBorders .spread .page,.wy-content-pdf .pdfViewer.removePageBorders:is(.scrollHorizontal,.scrollWrapped) .page{margin-inline:5px}.wy-content-pdf .pdfViewer .page.loadingIcon:after{position:absolute;top:0;left:0;content:\"\";width:100%;height:100%;display:none;transition-property:display;transition-delay:var(--loading-icon-delay);z-index:5;contain:strict}.wy-content-pdf .pdfViewer .page.loading:after{display:block}.wy-content-pdf .pdfViewer .page:not(.loading):after{transition-property:none;display:none}.wy-content-pdf .pdfPresentationMode .pdfViewer{padding-bottom:0}.wy-content-pdf .pdfPresentationMode .spread{margin:0}.wy-content-pdf .pdfPresentationMode .pdfViewer .page{margin:0 auto;border:2px solid transparent}.wy-content-pdf .pdfViewer .page{box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));background-color:var(--wy-white, var(--wy-white, #ffffff))}.wy-content-pdf .pdfViewer .page.loadingIcon:after{background:url(\"data:image/svg+xml,%3Csvg viewBox='0 0 24 24' width='24' height='24' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cstyle type='text/css'%3Eg%7Banimation:rotate 2s linear infinite;transform-origin:center center%7Dcircle%7Bstroke-dasharray:1,100;stroke-dashoffset:0;animation:dash 1.5s ease-in-out infinite,color 6s ease-in-out infinite%7D@keyframes rotate%7B100%25%7Btransform:rotate(360deg)%7D%7D@keyframes dash%7B0%25%7Bstroke-dasharray:1,100;stroke-dashoffset:0%7D50%25%7Bstroke-dasharray:44.5,100;stroke-dashoffset:-17.5px%7D100%25%7Bstroke-dasharray:44.5,100;stroke-dashoffset:-62px%7D%7D@keyframes color%7B0%25,100%25%7Bstroke:%23216eb4%7D40%25%7Bstroke:%2328b7cf%7D66%25%7Bstroke:%23216eb4%7D80%25,90%25%7Bstroke:%2328b7cf%7D%7D%3C/style%3E%3Cg%3E%3Ccircle fill='none' cx='12' cy='12' r='11' stroke-linecap='butt' stroke-width='2' /%3E%3C/g%3E%3C/svg%3E\") center no-repeat}.wy-pdf-page-number{width:calc(3 * var(--wy-size, 1rem))}.wy-pdf-zoom-level{width:calc(5 * var(--wy-size, 1rem))}.wy-content-text{word-break:break-word;white-space:pre-wrap}.wy-sheet{--wy-scrollbar-adjust-top: 0;--wy-scrollbar-adjust-bottom: 0;--wy-component-background-color: var(--wy-surface-3, var(--wy-surface-3-light, #e3e7ee));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);position:fixed;z-index:1055;display:flex;flex-direction:column;overflow:hidden;bottom:calc(.5 * var(--wy-size, 1rem));left:calc(.5 * var(--wy-size, 1rem));right:calc(.5 * var(--wy-size, 1rem));max-height:max(50vh,50%);min-height:calc(3 * var(--wy-size, 1rem));margin:calc(.5 * var(--wy-size, 1rem)) auto;max-width:calc(32 * var(--wy-size, 1rem));transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12))}.wy-sheet>.wy-appbars,.wy-sheet>.wy-appbar{border-top-left-radius:inherit;border-top-right-radius:inherit}.wy-sheet-body{overflow:hidden;padding:calc(.5 * var(--wy-size, 1rem));position:relative;min-height:calc(3 * var(--wy-size, 1rem))}.wy-sheet-body.wy-scroll-y{overflow-y:auto}.wy-sheet-no-padding{padding:0}.wy-sheet:not(.wy-show){opacity:0;transform:translateY(calc(32 * var(--wy-size, 1rem)))}.wy-sheet.wy-show{opacity:1;transform:none;transition:transform var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));pointer-events:auto}@starting-style{.wy-sheet.wy-show{opacity:0;transform:translateY(calc(32 * var(--wy-size, 1rem)))}}.wy-toasts{background:none;border:none;padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin:0;width:100%;height:100%;display:flex;flex-direction:column;flex-wrap:wrap;align-content:flex-end;align-items:flex-end;justify-content:flex-end;pointer-events:none}.wy-toasts[popover]{position:fixed;inset:0;z-index:1070}.wy-toasts>::slotted(*){pointer-events:auto}.wy-toast{--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background:var(--wy-component-background-color);color:var(--wy-component-color);gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));margin-top:0;margin-bottom:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));display:flex;cursor:pointer;border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));padding:0;-webkit-user-select:none;user-select:none;box-shadow:var(--wy-shadow-level2, 0 calc(.25 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.625 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12), 0 calc(.125 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem)) calc(-.0625 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2));position:relative;overflow:hidden;min-height:calc(4.5 * var(--wy-size, 1rem));max-width:calc(32 * var(--wy-size, 1rem))}.wy-toast.wy-fade{transition-property:opacity,min-height,padding-top,padding-bottom,margin-top,margin-bottom,height;transition-duration:var(--wy-transition-duration, .2s);transition-timing-function:var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))}.wy-toast.wy-fade:not(.wy-show){opacity:0;min-height:0;height:0;padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;pointer-events:none}.wy-toast-action{position:sticky;top:calc(4.5 * var(--wy-size, 1rem));bottom:calc(4.5 * var(--wy-size, 1rem));z-index:990;background-color:var(--wy-primary, var(--wy-primary-40, #006399));color:var(--wy-on-primary, var(--wy-white, #ffffff));padding:calc(.5 * var(--wy-size, 1rem)) calc(1 * var(--wy-size, 1rem));margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:calc(.5 * var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));width:max-content;min-height:0;max-width:calc(100% - 3 * var(--wy-size, 1rem));height:auto;align-self:center;text-align:center;box-shadow:none}.wy-toast-primary{background:var(--wy-on-primary-container, var(--wy-primary-10, #001d32));color:var(--wy-primary-container, var(--wy-primary-90, #cde5ff))}.wy-placeholder{cursor:wait;color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));background:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));opacity:.5;animation:wy-placeholder-glow 2s ease-in-out infinite}@keyframes wy-placeholder-glow{50%{opacity:.2}}.wy-meeting .wy-item-title{font-weight:700}.wy-meeting .wy-item-text{font-size:var(--wy-font-size, var(--wy-size, 1em))}.wy-meeting.wy-disabled .wy-item-title{font-weight:400}.wy-dragging:after{content:attr(data-drag-title);background-color:#ffffff80;display:flex;justify-content:center;align-items:center;border:calc(.125 * var(--wy-size, 1rem)) dashed var(--wy-primary, var(--wy-primary-40, #006399));font-weight:var(--wy-font-weight-bold, 600);z-index:10000;position:absolute;inset:0}.wy-message-editor-top{background-color:var(--wy-component-background-color);color:var(--wy-component-color)}@supports (position: sticky){.wy-message-editor-top{position:sticky;top:0;z-index:1020}}.wy-message-editor-bottom{background-color:var(--wy-component-background-color);color:var(--wy-component-color)}@supports (position: sticky){.wy-message-editor-bottom{position:sticky;bottom:0;z-index:1020}}.wy-message-form .wy-spinner{display:none}.wy-message-form.wy-uploading .wy-spinner{display:block}.wy-message-form.wy-uploading [data-icon=plus]{display:none}.wy-message-form .wy-picker-list:not(:empty){border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-message-editor-inputs{display:flex;flex-direction:row;align-items:flex-end;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em)) * 1.5 * var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * 2 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) * 2)}.wy-message-editor-buttons{flex:1 0 auto}.wy-message-editor-text{flex:1 1 100%;display:flex;flex-direction:column;margin-inline:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-message-editor-mention,.wy-message-editor-link{background:#00f;color:#fff}.wy-message-editor .cm-editor,.wy-message-editor-grow:after,.wy-message-editor-grow>textarea,.wy-message-editor-textfield{flex:1 1 100%;max-height:11.25em;background-color:var(--wy-background, var(--wy-neutral-99, #fcfcff));color:var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));border-radius:var(--wy-input-filled-border-radius, var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem)))));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid var(--wy-background, var(--wy-neutral-99, #fcfcff))}.wy-message-editor .cm-editor:focus,.wy-message-editor-grow:focus:after,.wy-message-editor-grow>textarea:focus,.wy-message-editor-textfield:focus{border-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-message-editor .cm-editor .cm-content,.wy-message-editor-textcontent{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)), inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em)) * 1.5 * var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * 2 - var(--wy-input-border-width, var(--wy-border, 1px)));line-height:calc(1.5 * var(--wy-size, 1rem))}.wy-message-editor-grow{display:grid}.wy-message-editor-grow:after,.wy-message-editor-grow>textarea{grid-area:1/1/2/2}.wy-message-editor-grow:after{content:attr(data-replicated-value) \" \";white-space:pre-wrap;visibility:hidden}.wy-message-editor-grow>textarea{resize:none;overflow:hidden}.wy-editor .cm-scroller{font-family:unset;line-height:1.5}.wy-editor .cm-widgetBuffer{vertical-align:unset}.wy-editor .cm-placeholder{pointer-events:none;color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e))}.wy-editor .cm-content{caret-color:var(--wy-on-background, var(--wy-neutral-10, #1a1c1e))}.wy-editor .cm-content .wy-link{text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-40, #006399))}.wy-editor .cm-editor{box-sizing:border-box;flex-direction:column;position:relative!important;display:flex!important}.wy-editor .cm-editor.cm-focused{--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));color:var(--wy-component-color);border-color:var(--wy-primary, var(--wy-primary-40, #006399));outline:0}.wy-editor .cm-editor .cm-scroller{overflow:auto}.wy-editor .cm-editor .cm-line{display:block;padding:0px var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) 0px var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-editor .cm-tooltip.cm-tooltip-autocomplete>ul{font-family:unset;max-height:calc(15 * var(--wy-size, 1rem))}.wy-editor .cm-tooltip.cm-tooltip-autocomplete>ul>li{padding:0}.wy-editor .cm-tooltip{border:none;background-clip:padding-box;background-color:var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));color:var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));overflow:hidden;z-index:1000}.wy-editor .cm-tooltip-autocomplete ul li[aria-selected]{background:var(--wy-primary-container, var(--wy-primary-90, #cde5ff));color:unset}.wy-editor .cm-tooltip-autocomplete .cm-completionLabel{display:none}.wy-editor .cm-tooltip-autocomplete .wy-item-hover:hover,.wy-editor .cm-tooltip-autocomplete .wy-item-hover:focus{background:var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb))}.wy-message-editor .cm-editor.cm-focused{border-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-message-editor .wy-is-invalid+[data-editor-target] .cm-editor,.wy-message-editor .wy-is-invalid .cm-editor{border-color:var(--wy-error, var(--wy-error-40, #ba1824))!important}.wy-chat-conversation{overflow-anchor:none;display:flex;flex-direction:column;flex:1 0 min-content;height:100%;width:100%;min-height:0;min-width:0}.wy-truncated-text-and-icon{display:flex;align-items:center;gap:.25rem}.wy-truncated-text-and-icon>:first-child{line-height:var(--wy-line-height, 1.5);flex:0 1 auto;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.wy-truncated-text-and-icon>:last-child:not(:first-child){flex:0 0 auto;white-space:nowrap}[part~=wy-filename]{font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);display:flex;flex-direction:column;justify-content:center}[part~=wy-filename] .wy-truncated-text-and-icon{justify-content:space-between}.wy-files{position:relative;display:flex;flex-direction:column;flex:1;min-height:0;container-type:inline-size}@supports (position: sticky){wy-files-appbar{position:sticky;top:0;z-index:1020}}.wy-table-files thead{text-align:left;display:none}@container (inline-size >= 576px){.wy-table-files thead{display:table-header-group}}.wy-table-files tr[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}.wy-table-files tr>:nth-child(2){width:100%}.wy-table-files tr>:nth-child(2) td{padding:0 var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))))}.wy-table-files tr>:nth-child(4){width:calc(7 * var(--wy-size, 1rem));display:none}@container (inline-size >= 768px){.wy-table-files tr>:nth-child(4){display:table-cell}}.wy-table-files tr>:nth-child(4){overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-table-files tr>:nth-child(5){width:calc(7.5 * var(--wy-size, 1rem));text-align:right;display:none}@container (inline-size >= 768px){.wy-table-files tr>:nth-child(5){display:table-cell}}.wy-table-files tr>:nth-child(5){overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-table-files tr>:nth-child(6){width:calc(7 * var(--wy-size, 1rem));text-align:right;display:none}@container (inline-size >= 576px){.wy-table-files tr>:nth-child(6){display:table-cell}}.wy-table-files tr>:nth-child(6){overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-sidebar{--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background:var(--wy-component-background-color);color:var(--wy-component-color);min-width:0;min-height:0;flex-grow:0;flex-shrink:0;flex-basis:calc(18 * var(--wy-size, 1rem));z-index:10;display:flex;flex-direction:column;transition:flex-basis var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));position:relative;order:9999;overflow:clip}.wy-sidebar>*{transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) - var(--wy-transition-duration-fast, .1s));min-width:calc(18 * var(--wy-size, 1rem))}.wy-sidebar[hidden]{display:flex!important;flex-basis:0}.wy-sidebar[hidden]>*{transition:opacity var(--wy-transition-fast, var(--wy-transition-duration-fast, .1s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));opacity:0}@media (min-width: 768px){.wy-sidebar>*{min-width:calc(18 * var(--wy-size, 1rem))}.wy-sidebar .wy-sidebar-handle{display:none}}@media (max-width: 767.98px){.wy-sidebar{transition:flex-basis var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))),margin-top var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));border-top-left-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-top-right-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));flex-basis:50vh}.wy-sidebar:not([hidden]){margin-top:calc(-1 * var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}.wy-sidebar:not([hidden]).wy-maximized{flex-basis:calc(100% - var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem))))) * .5);margin-top:calc(-50% + var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem))))) * 2.5 - var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}.wy-sidebar:not([hidden]).wy-maximized~* .wy-nav-prev,.wy-sidebar:not([hidden]).wy-maximized~* .wy-nav-next{display:none}.wy-sidebar>*{min-height:var(--wy-appbar-height, calc(max(1lh, var(--wy-button-size, calc(2.5 * var(--wy-size, 1rem)))) + 2 * var(--wy-padding, calc(.25 * var(--wy-size, 1rem)))))}}.wy-sidebar-handle{width:calc(4 * var(--wy-size, 1rem));background-clip:content-box;background-color:var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));height:calc(1 * var(--wy-size, 1rem));border:calc(.375 * var(--wy-size, 1rem)) solid transparent;position:absolute;top:0;z-index:2;left:50%;margin-left:calc(-2 * var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));cursor:pointer}.wy-table{table-layout:fixed;width:100%;vertical-align:top;border-collapse:collapse}.wy-table th,.wy-table td{background-color:var(--wy-component-background-color);padding:var(--wy-table-cell-padding-y, var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));box-shadow:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) 0 -1px 0 0 inset;line-height:1;vertical-align:middle;height:calc(2.5 * var(--wy-size, 1rem))}.wy-table th:first-child,.wy-table td:first-child{padding-left:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}.wy-table th:last-child,.wy-table td:last-child{padding-right:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}.wy-table>tbody{vertical-align:inherit}.wy-table>thead{vertical-align:bottom}.wy-table .wy-table-cell-icon{vertical-align:middle;text-align:center;padding:calc(var(--wy-table-cell-padding-y, var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .5) var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));width:calc(calc(2.5 * var(--wy-size, 1rem)) + var(--wy-table-cell-padding-x, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))) * 2);font-size:var(--wy-font-size, var(--wy-size, 1em));font-weight:var(--wy-font-weight, unset);text-transform:none;letter-spacing:normal}.wy-table .wy-table-cell-text{width:100%}.wy-table .wy-table-cell-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-table-hover>tbody>tr:hover>*{--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));color:var(--wy-component-color);cursor:pointer}.wy-table-row-trashed th,.wy-table-row-trashed td{text-decoration:line-through}.wy-table-row-trashed th:not(:last-child)>*,.wy-table-row-trashed td:not(:last-child)>*{opacity:var(--wy-opacity-disabled, 38%)}.wy-table-row-trashed th>a,.wy-table-row-trashed td>a{color:var(--wy-component-color)}.wy-table-row-trashed:hover th,.wy-table-row-trashed:hover td{opacity:1}.wy-table-no-result{text-align:center;padding:calc(1 * var(--wy-size, 1rem))}.wy-table-sort-link{display:inline-flex;align-items:center;color:var(--wy-link, var(--wy-primary-40, #006399));cursor:pointer}[part~=wy-image]{padding:0;width:50%;position:relative;flex:auto;background-color:inherit;background-clip:content-box}[part~=wy-image-full-width]{flex-basis:100%!important}[part~=wy-image-grid]{display:flex;flex-wrap:wrap;justify-content:space-evenly;position:relative;overflow:hidden;column-gap:1px;row-gap:1px}[part~=wy-image-area]{display:block;height:100%;cursor:pointer}[part~=wy-image-content]{position:absolute;height:100%;width:100%;object-fit:contain}[part~=wy-image-content][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-image-content][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-image-content][part~=wy-loading][part~=wy-loaded]~[part~=wy-image-preview]{transition-delay:.15s;opacity:0}[part~=wy-image-grid-more]{position:absolute;line-height:100%;color:var(--wy-white, #ffffff);inset:0;display:flex;align-items:center;justify-content:center;font-size:calc(1.5 * var(--wy-size, 1rem));background:rgba(0,0,0,var(--wy-opacity-disabled, 38%))}.wy-posts{display:flex;flex-direction:column;gap:calc(1 * var(--wy-size, 1rem))}.wy-post{--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;position:relative;--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-component-border-radius)}.wy-post[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}.wy-post wy-comment-list{border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-post-area{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-post-area-full-width{border-radius:0}.wy-post-body{display:flex;flex-direction:column;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-post-body:empty{display:none}.wy-post-footer{display:flex;align-items:center;justify-content:space-between;padding:0 calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) * .75) calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) * .75)}.wy-post-footer .wy-meta{margin-right:calc(.5 * var(--wy-size, 1rem))}.wy-post-comments:not(:empty){padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}.wy-post-dragging:after{content:attr(data-drag-title,\"Drop files here to upload.\");background-color:#ffffff80;display:flex;justify-content:center;align-items:center;border:calc(.125 * var(--wy-size, 1rem)) dashed var(--wy-primary, var(--wy-primary-40, #006399));font-weight:var(--wy-font-weight-bold, 600);z-index:10000;position:absolute;inset:0}.wy-poll{flex:1 1 100%;min-width:0;display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-poll-form{background:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-poll-form:empty{display:none}.wy-poll-option{overflow:hidden;position:relative;background-color:var(--wy-background, var(--wy-neutral-99, #fcfcff));border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));min-height:calc(2.5 * var(--wy-size, 1rem));cursor:pointer}.wy-poll-option .wy-progress{position:absolute;top:0;left:0;bottom:0;background-color:var(--wy-surface-5, var(--wy-surface-5-light, #dce2ea))}.wy-poll-option>:not(.wy-progress){z-index:1}.wy-embed{display:flex;flex-direction:column;word-wrap:break-word;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));clip-path:border-box;overflow:hidden}.wy-embed-photo a{display:flex}.wy-embed-photo img{width:100%;height:auto}.wy-embed-photo-sm a{padding:0 calc(1 * var(--wy-size, 1rem))}.wy-embed-photo-sm img{display:block;margin:0 auto;width:auto;max-width:100%;border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-embed-video{position:relative;display:block;width:100%;padding:0;overflow:hidden}.wy-embed-video:before{display:block;content:\"\";padding-top:56.25%}.wy-embed-video iframe,.wy-embed-video embed,.wy-embed-video object,.wy-embed-video video{position:absolute;top:0;bottom:0;left:0;width:100%;height:100%;border:0}.wy-embed-caption{--wy-component-background-color: var(--wy-surface-3, var(--wy-surface-3-light, #e3e7ee));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);padding:calc(.5 * var(--wy-size, 1rem)) calc(1 * var(--wy-size, 1rem)) calc(1 * var(--wy-size, 1rem));position:relative}.wy-embed-link{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));text-transform:uppercase;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}.wy-embed-link:after{position:absolute;inset:0;z-index:1;content:\"\"}.wy-embed-title{font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600));margin-bottom:calc(.5 * var(--wy-size, 1rem))}.wy-embed-description{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e))}.wy-embed-preview a[target=_blank]{pointer-events:none}.wy-embed-preview .wy-embed{border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));display:none}.wy-embed-preview .wy-embed:first-child{display:block}.wy-embed-preview .wy-embed-caption{border-bottom-left-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-bottom-right-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)))}.wy-embed-preview .wy-embed-actions{display:flex}.wy-embed-actions{display:none;justify-content:space-between;padding:calc(.5 * var(--wy-size, 1rem)) calc(.25 * var(--wy-size, 1rem))}.wy-embed-cycle{visibility:hidden}.wy-embed-show-cycle .wy-embed-cycle{visibility:visible}.wy-post-editor{padding:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;gap:var(--wy-gap-lg, calc(1.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-post-editor.wy-uploading .wy-icon-active-stack>:first-child{opacity:0}.wy-post-editor.wy-uploading .wy-icon-active-stack>:last-child{opacity:1}.wy-post-editor .wy-picker-list:not(:empty){margin-top:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-post-editor-inputs{display:flex;flex-direction:row;align-items:flex-end;justify-content:space-between;flex-wrap:wrap;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-post-editor-buttons{display:flex;flex-direction:row;align-items:flex-end;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));flex:1 0 auto}.wy-post-editor-text{flex:1 1 100%;display:flex;flex-direction:column}.wy-post-editor-mention,.wy-post-editor-link{background:#00f;color:#fff}.wy-post-editor .cm-editor,.wy-post-editor-grow:after,.wy-post-editor-grow>textarea,.wy-post-editor-textfield{flex:1 1 100%;max-height:11.25em;min-height:4em;background-color:var(--wy-background, var(--wy-neutral-99, #fcfcff));color:var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));caret-color:var(--wy-primary, var(--wy-primary-40, #006399))}.wy-post-editor .cm-editor:focus,.wy-post-editor-grow:focus:after,.wy-post-editor-grow>textarea:focus,.wy-post-editor-textfield:focus{border-color:var(--wy-primary, var(--wy-primary-40, #006399))}.wy-post-editor .cm-editor .cm-content,.wy-post-editor-textcontent{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}.wy-post-editor-grow{display:grid}.wy-post-editor-grow:after,.wy-post-editor-grow>textarea{grid-area:1/1/2/2}.wy-post-editor-grow:after{content:attr(data-replicated-value) \" \";white-space:pre-wrap;visibility:hidden}.wy-post-editor-grow>textarea{resize:none;overflow:hidden}.wy-post-editor .cm-editor .cm-line{padding:0}.wy-post-editor .wy-is-invalid+[data-editor-target] .cm-editor,.wy-post-editor .wy-is-invalid .cm-editor{border-color:var(--wy-error, var(--wy-error-40, #ba1824))!important}.wy-comments{display:flex;flex-direction:column;gap:var(--wy-gap-xl, calc(2 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));margin-bottom:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}.wy-comments-padded{margin:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}.wy-comment{--wy-component-background-color: var(--wy-surface-3, var(--wy-surface-3-light, #e3e7ee));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));border-radius:var(--wy-component-border-radius);background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;flex-direction:column;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));position:relative}.wy-comment[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}.wy-comment-body{flex:1 0 auto;z-index:1}.wy-comment-content{padding:0 var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));display:flex;flex-direction:column;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}.wy-comment-area{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-comment-editor .wy-spinner{display:none}.wy-comment-editor.wy-uploading .wy-spinner{display:block}.wy-comment-editor.wy-uploading [data-icon=plus]{display:none}.wy-comment-editor .wy-picker-list:not(:empty){border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-comment-editor.wy-comment-editor-bottom{position:sticky;bottom:0;z-index:999;background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-comment-editor-inputs{display:flex;flex-direction:row;align-items:flex-end;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));min-height:calc(3.5 * var(--wy-size, 1rem));gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-comment-editor-buttons{flex:1 0 auto}.wy-comment-editor-text{flex:1 1 100%;display:flex;flex-direction:column}.wy-comment-editor-mention,.wy-comment-editor-link{background:#00f;color:#fff}.wy-comment-editor .cm-editor,.wy-comment-editor-grow:after,.wy-comment-editor-grow>textarea,.wy-comment-editor-textfield{flex:1 1 100%;max-height:calc(11.25 * var(--wy-size, 1rem));background-color:var(--wy-background, var(--wy-neutral-99, #fcfcff));color:var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));border-radius:calc(1.25 * var(--wy-size, 1rem));border:var(--wy-input-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-comment-editor .cm-editor:focus,.wy-comment-editor-grow:focus:after,.wy-comment-editor-grow>textarea:focus,.wy-comment-editor-textfield:focus{border-color:var(--wy-primary, var(--wy-primary-40, #006399))}.wy-comment-editor .cm-editor .cm-content,.wy-comment-editor-textcontent{font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}.wy-comment-editor-grow{display:grid}.wy-comment-editor-grow:after,.wy-comment-editor-grow>textarea{grid-area:1/1/2/2}.wy-comment-editor-grow:after{content:attr(data-replicated-value) \" \";white-space:pre-wrap;visibility:hidden}.wy-comment-editor-grow>textarea{resize:none;overflow:hidden}.wy-comment-editor{position:relative}.wy-comment-editor .wy-is-invalid+.cm-editor,.wy-comment-editor .wy-is-invalid .cm-editor{border-color:var(--wy-error, var(--wy-error-40, #ba1824))!important}.wy-badge{display:inline-block;padding:.35em .65em;font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));font-weight:var(--wy-font-weight-bold, 600);line-height:1;color:var(--wy-on-primary, var(--wy-white, #ffffff));text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));background-color:var(--wy-primary, var(--wy-primary-40, #006399))}.wy-badge:empty{display:none}.wy-badge-reveal{opacity:1;transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{.wy-badge-reveal{opacity:0}}.wy-button-badge{position:absolute;right:0;top:0;margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .5);padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));min-width:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));max-width:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) * 3 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) * 2);height:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));line-height:calc(var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em))) - var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));display:block;text-align:center}.wy-button-badge{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-button-badge:empty{display:none}.wy-button-dot{position:absolute;right:0;top:0;content-visibility:hidden;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));margin:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));line-height:0;min-width:0;height:0}.wy-button-dot:empty{display:none}[part~=wy-tabs]{display:flex;overflow-y:hidden;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));flex:1 1 auto}[part~=wy-tabs]{overflow-x:auto;max-width:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-tabs]{scrollbar-width:thin;scrollbar-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) transparent}[part~=wy-tabs]::-webkit-scrollbar{height:.375rem;width:.375rem;background:transparent;z-index:999}[part~=wy-tabs]::-webkit-scrollbar-track{background:transparent}[part~=wy-tabs]::-webkit-scrollbar-thumb{background-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));opacity:75%;border:0 solid transparent;border-radius:0;background-clip:padding-box}[part~=wy-tabs]::-webkit-scrollbar-thumb:hover{background-color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));opacity:75%}[part~=wy-tabs]::-webkit-scrollbar-thumb:window-inactive{background-color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));opacity:50%}[part~=wy-tab]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399));--wy-component-background-color: transparent;color:var(--wy-component-color);background:var(--wy-component-background-color);border:none;border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));display:inline-flex;flex-direction:column;align-items:center;justify-content:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));position:relative;text-align:center;text-decoration:none;cursor:pointer;-webkit-user-select:none;user-select:none}[part~=wy-tab] .wy-tab-icon{position:relative;padding:calc(.25 * var(--wy-size, 1rem)) calc(1 * var(--wy-size, 1rem));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));display:inline-flex}[part~=wy-tab] .wy-tab-icon:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-tab]:hover .wy-tab-icon:before{opacity:8%}[part~=wy-tab]:focus .wy-tab-icon:before,[part~=wy-tab]:active .wy-tab-icon:before,[part~=wy-tab].wy-active .wy-tab-icon:before{opacity:12%}[part~=wy-tab] .wy-tab-label{font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));font-weight:var(--wy-font-weight, unset)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]{padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .5);margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) auto;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]:before{margin:calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * -.25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * 0)}.wy-conversations{position:relative}.wy-conversation{display:flex;position:relative}.wy-conversation .wy-item-title{font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset));font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em))}.wy-conversation.wy-unread .wy-item-title{font-weight:var(--wy-font-weight-bold, 600)}.wy-conversation.wy-unread .wy-item-text,.wy-conversation.wy-unread .wy-meta{color:var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));font-weight:var(--wy-font-weight-bold, 600)}.wy-conversation .wy-item-text .wy-typing-show{font-weight:var(--wy-font-weight, unset)}.wy-conversation .wy-item-text .wy-typing-show{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}`, Tt = Qt`:host{display:contents}`;
var DU = Object.defineProperty, WU = Object.getOwnPropertyDescriptor, we = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? WU(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && DU(t, e, s), s;
}, "__decorateClass$1b");
function xk(n) {
  return n != null && n !== !1;
}
c(xk, "ky");
d(xk, "acceptedValue");
const j_ = "wy-context";
var A0, Bu;
let ie = (A0 = (Bu = class extends pt {
  constructor() {
    super(), this.provider = !1, this.annotations = le.defaults.annotations, this.cloudFilePickerUrl = le.defaults.cloudFilePickerUrl, this.configurationTimeout = le.defaults.configurationTimeout, this.disableEnvironmentImports = le.defaults.disableEnvironmentImports, this.enterToSend = le.defaults.enterToSend, this.locale = le.defaults.locale, this.locales = le.defaults.locales, this.gcTime = le.defaults.gcTime, this.notificationEvents = le.defaults.notificationEvents, this.scrollBehavior = le.defaults.scrollBehavior, this.staleTime = le.defaults.staleTime, this.tokenFactory = le.defaults.tokenFactory, this.tokenFactoryRetryDelay = le.defaults.tokenFactoryRetryDelay, this.tokenFactoryTimeout = le.defaults.tokenFactoryTimeout, this.tokenUrl = le.defaults.tokenUrl, this.url = le.defaults.url, this.notifications = le.defaults.notifications, this.notificationsBadge = le.defaults.notificationsBadge, this.reactions = le.defaults.reactions, this.childElementCount && (this.provider = !0), this.weavy ??= new le({ host: this.provider ? this : void 0 });
  }
  /**
   * The semver version of the package.
   */
  get version() {
    return le.version;
  }
  /**
   * The Weavy source name; package name.
   */
  get sourceName() {
    return le.sourceName;
  }
  willUpdate(t) {
    if (super.willUpdate(t), this.weavy) {
      const e = {};
      Array.from(t.keys()).forEach((i) => {
        i !== "weavy" && (xk(this[i]) || xk(t.get(i))) && Object.assign(e, { [i]: this[i] });
      }), Object.assign(this.weavy, e);
    }
  }
  render() {
    return v` <slot></slot> `;
  }
}, c(Bu, "Yn"), Bu), d(A0, "WyContext"), A0);
ie.styles = [
  ft,
  Bi,
  Tt
];
we([
  O({ attribute: !0, type: Boolean })
], ie.prototype, "provider", 2);
we([
  O()
], ie.prototype, "annotations", 2);
we([
  O({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ d((n) => lg(n), "fromAttribute")
    }
  })
], ie.prototype, "cloudFilePickerUrl", 2);
we([
  O({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ d((n) => lg(n), "fromAttribute")
    }
  }),
  O({ attribute: !0 })
], ie.prototype, "configurationTimeout", 2);
we([
  O({ type: Boolean })
], ie.prototype, "disableEnvironmentImports", 2);
we([
  O({ attribute: !0 })
], ie.prototype, "enterToSend", 2);
we([
  O({ attribute: !0 })
], ie.prototype, "locale", 2);
we([
  O({ attribute: !0, type: Array })
], ie.prototype, "locales", 2);
we([
  O({ attribute: !0, type: Number })
], ie.prototype, "gcTime", 2);
we([
  O({ type: Boolean })
], ie.prototype, "notificationEvents", 2);
we([
  O({ attribute: !0 })
], ie.prototype, "scrollBehavior", 2);
we([
  O({ attribute: !0, type: Number })
], ie.prototype, "staleTime", 2);
we([
  O({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ d((n) => q_(n), "fromAttribute")
    }
  })
], ie.prototype, "tokenFactory", 2);
we([
  O({ attribute: !0, type: Number })
], ie.prototype, "tokenFactoryRetryDelay", 2);
we([
  O({ attribute: !0, type: Number })
], ie.prototype, "tokenFactoryTimeout", 2);
we([
  O({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ d((n) => lg(n), "fromAttribute")
    }
  })
], ie.prototype, "tokenUrl", 2);
we([
  O({
    attribute: !0,
    converter: {
      fromAttribute: /* @__PURE__ */ d((n) => lg(n), "fromAttribute")
    }
  })
], ie.prototype, "url", 2);
we([
  O({ attribute: !0 })
], ie.prototype, "notifications", 2);
we([
  O({ attribute: !0 })
], ie.prototype, "notificationsBadge", 2);
we([
  O({ attribute: !0 })
], ie.prototype, "reactions", 2);
we([
  F()
], ie.prototype, "weavy", 2);
ie = we([
  X(j_)
], ie);
var Hm, D1, Xu;
const F_ = (Xu = class {
  constructor(t, e) {
    q(this, Hm), q(this, D1), L(this, Hm, !0), this.styles = [], t.addController(this), this.host = t, e && (this.styles = e);
  }
  get themeColor() {
    return k(this, D1);
  }
  set themeColor(t) {
    L(this, D1, t), this.checkThemeUpdate();
  }
  checkThemeUpdate() {
    const t = this.themeColor || Uv(this.host) || Bv();
    if (t && t !== this._resolvedThemeColor) {
      this._resolvedThemeColor = t, console.info("Configuring theme", this._resolvedThemeColor);
      const e = r_(this._resolvedThemeColor).join(""), i = Qt`
        :host {
          ${PR(e)};
        }
      `, s = this.host.renderRoot;
      CR(s, [...this.styles, i]);
    }
  }
  hostUpdate() {
    k(this, Hm) && (this.checkThemeUpdate(), L(this, Hm, !1));
  }
  hostConnected() {
    this.cssObserverDisconnect = n_(this.host, () => this.checkThemeUpdate()), this.metaObserverDisconnect = s_(() => this.checkThemeUpdate());
  }
  hostDisconnected() {
    this.cssObserverDisconnect?.(), this.metaObserverDisconnect?.();
  }
}, c(Xu, "qp"), Xu);
Hm = /* @__PURE__ */ new WeakMap(), D1 = /* @__PURE__ */ new WeakMap(), d(F_, "ThemeController");
let Gs = F_;
const Ks = Qt`:host{font-family:var(--wy-font-family, unset)}`;
var qU = Object.defineProperty, jU = Object.getOwnPropertyDescriptor, QP = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? jU(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && qU(t, e, s), s;
}, "__decorateClass$1a");
const U_ = "wy-component";
var R0, Nu;
let Bo = (R0 = (Nu = class extends It {
  constructor() {
    super(...arguments), this.componentType = tn.Unknown, this.componentFeatures = new On(Xb($k)), this.theme = new Gs(this, Bo.styles);
  }
  render() {
    return v`<slot></slot>`;
  }
}, c(Nu, "Jn"), Nu), d(R0, "WyComponent"), R0);
Bo.styles = [Bi, Tt, Ks];
QP([
  O({
    converter: {
      fromAttribute(n, t) {
        return ZU.get(n) ?? n;
      }
    }
  })
], Bo.prototype, "componentType", 2);
QP([
  O({
    converter: {
      fromAttribute(n, t) {
        const e = typeof n == "string" ? gP(n, $k) : $k;
        return new On(Xb(e));
      }
    }
  })
], Bo.prototype, "componentFeatures", 2);
Bo = QP([
  X(U_)
], Bo);
const fa = Qt`:host{position:relative;display:flex;flex-direction:column;flex:1;min-height:3rem;min-width:16rem;isolation:isolate}`, hl = Qt`.wy-scroll-y{scroll-padding-top:var(--wy-scrollbar-adjust-top, 0);scroll-padding-bottom:var(--wy-scrollbar-adjust-bottom, 0)}.wy-scroll-y{overflow-y:auto;max-height:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-scroll-y:not(body){-webkit-overflow-scrolling:touch}.wy-scroll-y:not(.wy-scroll-x){overflow-x:hidden;touch-action:pan-y}.wy-scroll-x{overflow-x:auto;max-width:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-scroll-x:not(.wy-scroll-y){overflow-y:hidden;touch-action:pan-x}:host{overflow-y:auto;max-height:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}:host:not(body){-webkit-overflow-scrolling:touch}`;
function B_(n, t, e = {}, i) {
  if (n) {
    if (n = JSON.parse(JSON.stringify(n)), n?.pages) {
      let s = -1;
      return {
        pages: [...n.pages.map((r, a) => {
          if (s >= 0)
            return r;
          const o = r.data || [], l = o.filter(
            (h) => h.id !== t.id && !0
          );
          return e && e.by ? (s = l.findIndex((h) => {
            let u = e.by && h[e.by], p = e.by && t[e.by];
            if (e.by === "updated_at" && (u ??= h.created_at, p ??= t.created_at), typeof u == "string" && typeof p == "string") {
              const y = u.localeCompare(p, void 0, {
                sensitivity: "base",
                numeric: !0
              });
              return e.descending ? y < 0 : y > 0;
            }
            return u && p && (e.descending ? u < p : u > p);
          }), s >= 0 ? (l.splice(s, 0, t), r.data = [...l], r.end && (r.end += 1 + l.length - o.length)) : n && a == n.pages.length - 1 && r.end === r.count ? (r.data = [...l, t], r.end && (r.end += 1 + l.length - o.length)) : r.data = [...l]) : a === 0 && (e.descending ? r.data = [t, ...l] : r.data = [...l, t], r.end && (r.end += 1 + l.length - o.length)), r;
        }) ?? []],
        pageParams: [...n.pageParams]
      };
    } else if (n?.data?.length) {
      let s = -1;
      const r = [
        ...n.data?.filter(
          (o) => o.id !== t.id && !0
        ) || []
      ];
      let a = n.count;
      return e && e.by ? (s = r.findIndex((o) => {
        let l = o[e.by], h = t[e.by];
        if (e.by === "updated_at" && (l ??= o.created_at, h ??= t.created_at), typeof l == "string" && typeof h == "string") {
          const u = l.localeCompare(h, void 0, {
            sensitivity: "base",
            numeric: !0
          });
          return e.descending ? u < 0 : u > 0;
        }
        return l && h && (e.descending ? l < h : l > h);
      }), s >= 0 ? r.splice(s, 0, t) : (r.push(t), a++)) : (e.descending ? r.unshift(t) : r.push(t), a++), {
        data: r,
        count: a
      };
    }
  }
  return n;
}
c(B_, "$g");
d(B_, "addToQueryData");
function MP(n, t, e) {
  const i = t === void 0 ? () => !0 : t instanceof Function ? t : (s) => s.id === t;
  return n && (n = JSON.parse(JSON.stringify(n)), n.pages ? {
    pages: n.pages.map((s) => (s.data && (s.data = [
      ...s.data.map((r) => (i(r) && (r = { ...r }, e(r)), r))
    ]), s)) ?? [],
    pageParams: n.pageParams
  } : n.data?.length ? {
    ...n,
    data: [
      ...n.data?.map((s) => (i(s) && (s = { ...s }, e(s)), s)) || []
    ]
  } : n.data ? {
    data: [
      ...n.data.map((s) => (i(s) && (s = { ...s }, e(s)), s))
    ],
    count: n.count
  } : n);
}
c(MP, "wf");
d(MP, "updateQueryData");
function TP(n, t) {
  if (t !== void 0) {
    const e = t instanceof Function ? t : (i) => i.id === t;
    if (n) {
      if (n = JSON.parse(JSON.stringify(n)), n.pages)
        return {
          pages: n.pages.map((i) => (i.data && (i.data = [...i.data.filter((s) => !e(s))]), i)) ?? [],
          pageParams: n.pageParams
        };
      if (n.data?.length) {
        const i = n.data?.length;
        let s = n.count;
        const r = [...n.data?.filter((a) => !e(a)) || []];
        return i !== r.length && s--, {
          data: r,
          count: s
        };
      }
    }
  }
  return n;
}
c(TP, "ff");
d(TP, "removeQueryData");
const ea = /* @__PURE__ */ d((n, t, e, i) => n.setQueryData(t, (s) => B_(s, e, i)), "addCacheItem"), Oe = /* @__PURE__ */ d((n, t, e, i) => n.setQueryData(t, (s) => MP(
  s,
  e,
  i
)), "updateCacheItem"), Ot = /* @__PURE__ */ d((n, t, e, i) => {
  n.setQueriesData(t, (s) => MP(
    s,
    e,
    i
  ));
}, "updateCacheItems"), Gb = /* @__PURE__ */ d((n, t, e) => n.setQueryData(t, (i) => TP(
  i,
  e
)), "removeCacheItem"), FU = /* @__PURE__ */ d((n, t, e) => {
  n.setQueriesData(t, (i) => TP(i, e));
}, "removeCacheItems"), Hv = /* @__PURE__ */ d((n, t, e) => {
  n.setQueriesData(t, (i) => {
    const { count: s } = i;
    return { count: e(s) };
  });
}, "updateCacheItemsCount");
function kk(n, t, e, i = 1) {
  if (!n)
    return;
  const s = n.getQueryData(t);
  s?.pages?.length && s.pages.length > 1 && n.setQueryData(
    t,
    (r) => ({
      pages: r.pages.slice(0, i),
      pageParams: r.pageParams.slice(0, i)
    }),
    e
  );
}
c(kk, "_y");
d(kk, "keepPages");
function ia(n, t, e) {
  const i = n.getQueryCache().find({ queryKey: t });
  if (i && i.state.data) {
    const s = i.state.data.pages.flatMap((r) => r.data).filter((r) => r && r.id < 0).sort((r, a) => r && a ? r.id - a.id : 0);
    return s.length ? e ? s[s.length - 1] : s[0] : null;
  }
  return null;
}
c(ia, "dr");
d(ia, "getPendingCacheItem");
function cg(n, t, e) {
  const i = n.getQueryCache().find({ queryKey: t });
  return i && i.state.data ? i.state.data.pages.flatMap((s) => s.data).find((s) => s?.id === e) : null;
}
c(cg, "zd");
d(cg, "getCacheItem");
function hs(n) {
  return (n?.pages.flatMap((t) => t.data) || []).filter((t) => t);
}
c(hs, "ts");
d(hs, "getFlatInfiniteResultData");
function Sk(n) {
  return !n || !n?.pages.some((t) => t.data?.length);
}
c(Sk, "My");
d(Sk, "isInfiniteResultDataEmpty");
function X_(n, t, e = {}) {
  return {
    ...e,
    initialPageParam: 0,
    queryKey: ["messages", t],
    queryFn: /* @__PURE__ */ d(async (i) => {
      const s = i.pageParam, r = "/api/apps/" + t + "/messages?order_by=id+desc&skip=" + s, a = await (await n.fetch(r)).json();
      return a.data = a.data?.reverse() || [], a;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ d((i) => {
      if (i?.end && i?.end < i?.count)
        return i.end;
    }, "getNextPageParam"),
    select: /* @__PURE__ */ d((i) => ({
      // reverse scroll
      pages: [...i.pages].reverse(),
      pageParams: [...i.pageParams].reverse()
    }), "select")
  };
}
c(X_, "kg");
d(X_, "getMessagesOptions");
function N_(n, t) {
  return {
    mutationFn: /* @__PURE__ */ d(async (e) => await (await n.fetch("/api/apps/" + e.app_id + "/messages", {
      method: "POST",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        embed_id: e.embed_id || null,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ text: i.text })),
        metadata: e.metadata || null,
        context: e.context
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ d((e) => {
      const i = ["messages", e.app_id], s = ia(n.queryClient, i, !1), r = {
        id: s ? s.id - 1 : -1,
        app: { id: e.app_id },
        text: e.text,
        html: e.text,
        plain: e.text,
        created_by: e.user,
        created_at: (/* @__PURE__ */ new Date()).toUTCString(),
        attachments: { count: 0 },
        reactions: { count: 0 },
        is_starred: !1,
        is_subscribed: !0,
        is_trashed: !1
      };
      ea(n.queryClient, i, r);
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((e) => {
      Ot(
        n.queryClient,
        { queryKey: ["members", e.app.id] },
        e.created_by.id,
        (s) => {
          s.marked_id = e.id, s.marked_at = e.created_at;
        }
      );
      const i = ["messages", e.app.id];
      if (!cg(n.queryClient, i, e.id)) {
        const s = ia(n.queryClient, i, !0);
        s ? Oe(n.queryClient, i, s.id, (r) => {
          r.id = e.id, r.app = e.app, r.text = e.text, r.html = e.html, r.embed = e.embed, r.meeting = e.meeting, r.attachments = e.attachments, r.options = e.options, r.created_at = e.created_at, r.created_by = e.created_by, r.updated_at = e.updated_at, r.updated_by = e.updated_by;
        }) : ea(n.queryClient, i, e);
      }
    }, "onSuccess")
  };
}
c(N_, "_g");
d(N_, "getAddMessageMutationOptions");
var Hu;
const H_ = (Hu = class {
  get result() {
    return this._result && this.observer ? this.observer.trackResult(this._result) : this.observer?.getCurrentResult() ?? { isPending: !0 };
  }
  constructor(t) {
    t.addController(this), this.host = t, this.whenContext = new Promise((e) => this.resolveContext = e), this.whenQueryClient = new Promise((e) => this.resolveQueryClient = e), this.setContext();
  }
  async setContext() {
    await rl(this.host), this.context = new Vs(this.host, {
      context: Le,
      subscribe: !0,
      callback: /* @__PURE__ */ d((t) => {
        t && (this.resolveContext?.(t), this.queryClient = t.queryClient, this.resolveQueryClient?.(t.queryClient));
      }, "callback")
    });
  }
  async trackInfiniteQuery(t, e = !0) {
    this.observerUnsubscribe?.();
    const i = await this.whenQueryClient;
    if (!i)
      throw new Error("No QueryClient provided");
    const s = new tU(i, t);
    this.observer = s, this.observerSubscribe(e);
  }
  observerSubscribe(t = !0) {
    if (this.queryClient && this.observer) {
      t ? this._result = this.observer.getOptimisticResult(
        this.observer.options
      ) : this._result = this.observer.getCurrentResult(), this.observerUnsubscribe = this.observer.subscribe(() => {
        if (this.observer) {
          const i = Cy(this.result, this.observer.getCurrentResult());
          i !== this._result && (this._result = i, this.host.requestUpdate());
        }
      }), this.observer.updateResult(), this.host.requestUpdate();
      let e;
      t ? e = this.observer.fetchOptimistic(this.observer.options) : e = this.queryClient.getQueryCache().get(
        this.observer.options.queryHash
      )?.promise, e?.catch(() => {
      }).finally(() => {
        this.observer?.updateResult();
      });
    }
  }
  untrackInfiniteQuery() {
    this.observerUnsubscribe?.(), this.observerUnsubscribe = void 0, this._result = void 0, this.observer = void 0, this.host.requestUpdate();
  }
  hostConnected() {
    this.observerSubscribe();
  }
  hostDisconnected() {
    this.observerUnsubscribe?.();
  }
}, c(Hu, "Np"), Hu);
d(H_, "InfiniteQueryController");
let dl = H_;
function Y_(n) {
  for (; n; )
    if (n = n.nextElementSibling, n instanceof HTMLElement && /absolute|sticky|fixed/.test(getComputedStyle(n).position) === !1)
      return n;
  return null;
}
c(Y_, "Mg");
d(Y_, "getNextPositionedChild");
function hg(n, t = !1) {
  if (ii(), n) {
    let e = getComputedStyle(n);
    const i = e.position === "absolute", s = t ? /(auto|scroll|overlay|hidden)/ : /(auto|overlay|scroll)/;
    if (e.position === "fixed" && document.scrollingElement)
      return document.scrollingElement;
    for (let r = n; r = r.parentElement || r.parentNode || r.host; )
      if (r instanceof Element && (e = getComputedStyle(r), !(i && e.position === "static") && s.test(e.overflow + e.overflowY + e.overflowX)))
        return r;
  }
  return document.scrollingElement || n;
}
c(hg, "Pd");
d(hg, "getScrollParent");
function G_(n) {
  if (n && n.isConnected) {
    const t = hg(n);
    return t.clientHeight !== t.scrollHeight;
  }
  return !1;
}
c(G_, "zg");
d(G_, "hasScroll");
function K_(n, t = 32) {
  if (n) {
    const e = hg(n);
    return Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) < t;
  }
  return !1;
}
c(K_, "Pg");
d(K_, "isParentAtBottom");
async function J_(n, t = !1) {
  if (n) {
    const e = hg(n);
    Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) > 1 && (t ? e.scrollTo({
      top: e.scrollHeight,
      left: 0,
      behavior: "smooth"
    }) : e.scrollTop = e.scrollHeight), await new Promise((i) => {
      let s = e.scrollTop;
      const r = /* @__PURE__ */ d(() => {
        t && e.scrollTop === s && (e.scrollTop = e.scrollHeight), s = e.scrollTop, Math.abs(e.scrollTop + e.clientHeight - e.scrollHeight) > 1 ? requestAnimationFrame(r) : i(void 0);
      }, "scrollCheck");
      requestAnimationFrame(r);
    });
  }
}
c(J_, "Sg");
d(J_, "scrollParentToBottom");
const UU = 0, BU = void 0;
function tz(n, t, e = !1) {
  ii(), t ??= /* @__PURE__ */ d(() => Promise.reject(new Error("No scroll function defined")), "whenNext");
  const i = e ? hg(n) : document.documentElement, s = i === document.documentElement ? document : i;
  let r = !1;
  const a = new IntersectionObserver(
    (o) => {
      o.forEach((l) => {
        if (l.isIntersecting && !r)
          if (r = !0, e && i && s instanceof HTMLElement) {
            const h = Y_(l.target) || l.target, u = i.scrollHeight, p = h.offsetTop, y = /* @__PURE__ */ d(() => {
              queueMicrotask(() => {
                if (u !== i.scrollHeight) {
                  if (h?.isConnected) {
                    const m = h.offsetTop - p;
                    i.scrollTop += m;
                  }
                  requestAnimationFrame(() => r = !1);
                } else
                  queueMicrotask(() => {
                    if (u !== i.scrollHeight) {
                      if (h?.isConnected) {
                        const m = h.offsetTop - p;
                        i.scrollTop += m;
                      }
                      requestAnimationFrame(() => r = !1);
                    } else
                      requestAnimationFrame(() => {
                        if (a.takeRecords().length && h?.isConnected) {
                          const m = h.offsetTop - p;
                          i.scrollTop += m;
                        }
                        requestAnimationFrame(() => r = !1);
                      });
                  });
              });
            }, "afterNext");
            t().then(y);
          } else
            t().then(() => {
              requestAnimationFrame(() => r = !1);
            });
      });
    },
    { root: s, threshold: UU, rootMargin: BU }
  );
  return a.observe(n), a;
}
c(tz, "Rg");
d(tz, "createScroller");
var Yu;
const ez = (Yu = class {
  constructor(t, e = !1) {
    this.reverse = !1, this.isObservePending = !1, t.addController(this), this.host = t, this.reverse = e;
  }
  observe(t, e) {
    t && e && !t.isLoading && !this.isObservePending && (this.isObservePending = !0, requestAnimationFrame(() => {
      this.loadMoreRefElement = e, this.scroller?.disconnect(), this.scroller = tz(
        e,
        async () => {
          t.hasNextPage && !t.isFetching && (await t.fetchNextPage({ cancelRefetch: !1 }), this.reverse && await this.host.updateComplete);
        },
        this.reverse
      ), this.isObservePending = !1;
    }));
  }
  hostConnected() {
    this.loadMoreRefElement && this.scroller?.observe(this.loadMoreRefElement);
  }
  hostDisconnected() {
    this.scroller?.disconnect();
  }
}, c(Yu, "jp"), Yu);
d(ez, "InfiniteScrollController");
let ul = ez;
var Gu;
const iz = (Gu = class extends ul {
  constructor(t) {
    super(t, !0);
  }
}, c(Gu, "Wp"), Gu);
d(iz, "ReverseInfiniteScrollController");
let XU = iz;
const { I: NU } = IF, HU = /* @__PURE__ */ d((n) => n.strings === void 0, "f$1"), Q3 = /* @__PURE__ */ d(() => document.createComment(""), "s$1"), cm = /* @__PURE__ */ d((n, t, e) => {
  const i = n._$AA.parentNode, s = t === void 0 ? n._$AB : t._$AA;
  if (e === void 0) {
    const r = i.insertBefore(Q3(), s), a = i.insertBefore(Q3(), s);
    e = new NU(r, a, n, n.options);
  } else {
    const r = e._$AB.nextSibling, a = e._$AM, o = a !== n;
    if (o) {
      let l;
      e._$AQ?.(n), e._$AM = n, e._$AP !== void 0 && (l = n._$AU) !== a._$AU && e._$AP(l);
    }
    if (r !== s || o) {
      let l = e._$AA;
      for (; l !== r; ) {
        const h = l.nextSibling;
        i.insertBefore(l, s), l = h;
      }
    }
  }
  return e;
}, "r$1"), La = /* @__PURE__ */ d((n, t, e = n) => (n._$AI(t, e), n), "v"), YU = {}, nz = /* @__PURE__ */ d((n, t = YU) => n._$AH = t, "m"), GU = /* @__PURE__ */ d((n) => n._$AH, "p"), E0 = /* @__PURE__ */ d((n) => {
  n._$AP?.(!1, !0);
  let t = n._$AA;
  const e = n._$AB.nextSibling;
  for (; t !== e; ) {
    const i = t.nextSibling;
    t.remove(), t = i;
  }
}, "M"), Ty = { ATTRIBUTE: 1, CHILD: 2 }, ya = /* @__PURE__ */ d((n) => (...t) => ({ _$litDirective$: n, values: t }), "e$3");
var _0, Ku;
let pl = (_0 = (Ku = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, i) {
    this._$Ct = t, this._$AM = e, this._$Ci = i;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
}, c(Ku, "ta"), Ku), d(_0, "i"), _0);
const cw = /* @__PURE__ */ d((n, t) => {
  const e = n._$AN;
  if (e === void 0) return !1;
  for (const i of e) i._$AO?.(t, !1), cw(i, t);
  return !0;
}, "s"), Yv = /* @__PURE__ */ d((n) => {
  let t, e;
  do {
    if ((t = n._$AM) === void 0) break;
    e = t._$AN, e.delete(n), n = t;
  } while (e?.size === 0);
}, "o$5"), sz = /* @__PURE__ */ d((n) => {
  for (let t; t = n._$AM; n = t) {
    let e = t._$AN;
    if (e === void 0) t._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(n)) break;
    e.add(n), KU(t);
  }
}, "r");
function rz(n) {
  this._$AN !== void 0 ? (Yv(this), this._$AM = n, sz(this)) : this._$AM = n;
}
c(rz, "Fg");
d(rz, "h$1");
function az(n, t = !1, e = 0) {
  const i = this._$AH, s = this._$AN;
  if (s !== void 0 && s.size !== 0) if (t) if (Array.isArray(i)) for (let r = e; r < i.length; r++) cw(i[r], !1), Yv(i[r]);
  else i != null && (cw(i, !1), Yv(i));
  else cw(this, n);
}
c(az, "Dg");
d(az, "n$2");
const KU = /* @__PURE__ */ d((n) => {
  n.type == Ty.CHILD && (n._$AP ??= az, n._$AQ ??= rz);
}, "c$1");
var Ju;
const oz = (Ju = class extends pl {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, e, i) {
    super._$AT(t, e, i), sz(this), this.isConnected = t._$AU;
  }
  _$AO(t, e = !0) {
    t !== this.isConnected && (this.isConnected = t, t ? this.reconnected?.() : this.disconnected?.()), e && (cw(this, t), Yv(this));
  }
  setValue(t) {
    if (HU(this._$Ct)) this._$Ct._$AI(t, this);
    else {
      const e = [...this._$Ct._$AH];
      e[this._$Ci] = t, this._$Ct._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}, c(Ju, "Qp"), Ju);
d(oz, "f");
let JU = oz;
const mt = /* @__PURE__ */ d(() => new tB(), "e$2");
var tp;
const lz = (tp = class {
}, c(tp, "Kp"), tp);
d(lz, "h");
let tB = lz;
const z0 = /* @__PURE__ */ new WeakMap(), rt = ya(class extends JU {
  render(n) {
    return Q;
  }
  update(n, [t]) {
    const e = t !== this.G;
    return e && this.G !== void 0 && this.rt(void 0), (e || this.lt !== this.ct) && (this.G = t, this.ht = n.options?.host, this.rt(this.ct = n.element)), Q;
  }
  rt(n) {
    if (this.isConnected || (n = void 0), typeof this.G == "function") {
      const t = this.ht ?? globalThis;
      let e = z0.get(t);
      e === void 0 && (e = /* @__PURE__ */ new WeakMap(), z0.set(t, e)), e.get(this.G) !== void 0 && this.G.call(this.ht, void 0), e.set(this.G, n), n !== void 0 && this.G.call(this.ht, n);
    } else this.G.value = n;
  }
  get lt() {
    return typeof this.G == "function" ? z0.get(this.ht ?? globalThis)?.get(this.G) : this.G?.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
function cz(n, t, e) {
  const i = n.queryClient;
  return {
    mutationKey: ["apps", t, "polls"],
    mutationFn: /* @__PURE__ */ d(async ({ optionId: s }) => {
      const r = await n.fetch(`/api/options/${s}/vote`, { method: "POST" });
      if (!r.ok) {
        const a = await r.json();
        throw new Error(a.detail || a.title, { cause: a });
      }
      return await r.json();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => (Ot(i, { queryKey: e }, s.parentId, (r) => {
      r.options?.data && (r.options.data = r.options.data?.map((a) => {
        if (a.has_voted) {
          a.has_voted = !1;
          const o = a.votes?.count || 1;
          a.votes ? a.votes.count = o - 1 : a.votes = { count: o - 1 };
        } else if (!a.has_voted && a.id === s.optionId) {
          a.has_voted = !0;
          const o = a.votes?.count || 0;
          a.votes ? a.votes.count = o + 1 : a.votes = { count: o + 1 };
        }
        return a;
      }));
    }), { id: s.optionId }), "onMutate"),
    onSuccess: /* @__PURE__ */ d(async (s, r) => {
      const a = await (await n.fetch("/api/" + r.parentType + "/" + r.parentId)).json();
      Ot(
        i,
        { queryKey: e, exact: !1 },
        r.parentId,
        (o) => Object.assign(o, a)
      );
    }, "onSuccess")
    /*onError(error: Error, variables: MutatePollVariables) {
      updateCacheItems(queryClient, { queryKey: postsKey, exact: false }, variables.id, (existingPost: PostType) => Object.assign(existingPost, { is_subscribed: variables..is_subscribed }));
    },*/
  };
}
c(cz, "Vg");
d(cz, "getPollMutationOptions");
function Kb(n, t, e) {
  return new jt(n.queryClient, cz(n, t, e));
}
c(Kb, "cp");
d(Kb, "getPollMutation");
function hz(n, t) {
  return {
    queryKey: ["votes", t],
    enabled: !1,
    queryFn: /* @__PURE__ */ d(async () => await (await n.fetch(`/api/options/${t}`)).json(), "queryFn")
  };
}
c(hz, "Ug");
d(hz, "getVotesOptions");
const sy = /* @__PURE__ */ d((n, t) => !!(n && t && t.indexOf(n) !== -1), "hasPermission");
function dz(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ appId: t, messageId: e }) => {
      const i = e ? `/api/apps/${t}/mark?messageId=${e}` : `/api/apps/${t}/mark`;
      await n.fetch(i, { method: e ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d(async (t) => {
      await n.queryClient.cancelQueries({ queryKey: ["apps", t.appId] }), await n.queryClient.cancelQueries({ queryKey: ["apps", "list"], exact: !1 }), await n.queryClient.cancelQueries({ queryKey: ["members", t.appId] }), n.queryClient.setQueryData(
        ["apps", t.appId],
        (e) => e && { ...e, is_unread: !t.messageId || t.messageId < e.last_message.id }
      ), Ot(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.appId,
        (e) => {
          e.is_unread = !t.messageId || t.messageId < e.last_message.id;
        }
      ), t.userId && Ot(n.queryClient, { queryKey: ["members", t.appId] }, t.userId, (e) => {
        t.messageId ? (e.marked_at = (/* @__PURE__ */ new Date()).toISOString(), e.marked_id = t.messageId) : (e.marked_at = void 0, e.marked_id = void 0);
      });
    }, "onMutate"),
    onError: /* @__PURE__ */ d((t, e) => {
      console.error(t.message), Ot(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        e.appId,
        (i) => {
          i.is_unread = !i.is_unread;
        }
      );
    }, "onError"),
    onSettled: /* @__PURE__ */ d(async (t, e, i) => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps", i.appId] }), await n.queryClient.invalidateQueries({ queryKey: ["apps", "list"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["members", i.appId] });
    }, "onSettled")
  };
}
c(dz, "Bg");
d(dz, "getMarkConversationMutationOptions");
function uz(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ appId: t, star: e }) => {
      await n.fetch(`/api/apps/${t}/stars`, { method: e ? "POST" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((t) => {
      Ot(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.appId,
        (e) => {
          e.is_starred = t.star;
        }
      );
    }, "onMutate"),
    onError: /* @__PURE__ */ d((t, e) => {
      console.error(t.message), Ot(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        e.appId,
        (i) => {
          i.is_starred = !e.star;
        }
      );
    }, "onError")
  };
}
c(uz, "qg");
d(uz, "getStarConversationMutationOptions");
function pz(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ appId: t, pin: e }) => {
      await n.fetch(`/api/apps/${t}/pin`, { method: e ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((t) => {
      Ot(
        n.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.appId,
        (e) => {
          e.is_pinned = t.pin;
        }
      );
    }, "onMutate"),
    onSettled: /* @__PURE__ */ d(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
c(pz, "Ng");
d(pz, "getPinConversationMutationOptions");
function fz(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ appId: t, members: e }) => {
      await n.fetch(`/api/apps/${t}/members/${e.join(",")}`, { method: "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((t) => {
      Gb(n.queryClient, ["apps", "list"], t.appId);
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((t, e) => {
      n.queryClient.removeQueries({ queryKey: ["apps", e.appId] }), n.queryClient.removeQueries({ queryKey: ["members", e.appId] });
    }, "onSuccess"),
    onSettled: /* @__PURE__ */ d(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] }), await n.queryClient.invalidateQueries({ queryKey: ["members"] });
    }, "onSettled")
  };
}
c(fz, "jg");
d(fz, "getLeaveConversationMutationOptions");
function yz(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ appId: t }) => {
      await n.fetch(`/api/apps/${t}/remove`, { method: "POST" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((t) => {
      Gb(n.queryClient, ["apps", "list"], t.appId);
    }, "onMutate"),
    onSettled: /* @__PURE__ */ d(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
c(yz, "Wg");
d(yz, "getRemoveConversationMutationOptions");
function mz(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ appId: t, userId: e, access: i }) => {
      await n.fetch(`/api/apps/${t}/members/${e}`, { method: "PUT", body: JSON.stringify({ access: i }) });
    }, "mutationFn"),
    onSettled: /* @__PURE__ */ d(async (t, e, i) => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] }), await n.queryClient.invalidateQueries({ queryKey: ["members", i.appId] });
    }, "onSettled")
  };
}
c(mz, "Qg");
d(mz, "getUpdateMemberMutationOptions");
function wz(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ appId: t, members: e }) => {
      await n.fetch(`/api/apps/${t}/members`, {
        method: "PUT",
        body: JSON.stringify(
          e.map((i) => ({ id: i, access: "write" }))
        )
      });
    }, "mutationFn"),
    onSettled: /* @__PURE__ */ d(async (t, e, i) => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] }), await n.queryClient.invalidateQueries({ queryKey: ["members", i.appId] });
    }, "onSettled")
  };
}
c(wz, "Kg");
d(wz, "getAddMembersToConversationMutationOptions");
function gz(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ appId: t, name: e, blobId: i }) => await (await n.fetch(`/api/apps/${t}`, {
      method: "PATCH",
      body: JSON.stringify({
        name: e,
        picture: i
      })
    })).json(), "mutationFn"),
    onMutate: /* @__PURE__ */ d((t) => {
      const e = /* @__PURE__ */ d((i) => {
        typeof t.name == "string" && (i.name = t.name), typeof t?.thumbnailUrl == "string" && (i.avatar_url = t.thumbnailUrl);
      }, "modifyAppItem");
      Oe(n.queryClient, ["apps", t.appId], void 0, e), Ot(n.queryClient, { queryKey: ["apps", "list"], exact: !1 }, t.appId, e);
    }, "onMutate")
  };
}
c(gz, "Gg");
d(gz, "getUpdateConversationMutationOptions");
function vz(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ appId: t }) => {
      await n.fetch(`/api/apps/${t}/trash`, { method: "POST" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((t) => {
      Gb(n.queryClient, ["apps", "list"], t.appId);
    }, "onMutate"),
    onSettled: /* @__PURE__ */ d(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }, "onSettled")
  };
}
c(vz, "Zg");
d(vz, "getTrashConversationMutationOptions");
function AP(n) {
  return new jt(n.queryClient, dz(n));
}
c(AP, "gf");
d(AP, "getMarkConversationMutation");
function bz(n) {
  return new jt(n.queryClient, uz(n));
}
c(bz, "Yg");
d(bz, "getStarConversationMutation");
function Oz(n) {
  return new jt(n.queryClient, pz(n));
}
c(Oz, "Xg");
d(Oz, "getPinConversationMutation");
function RP(n) {
  return new jt(n.queryClient, fz(n));
}
c(RP, "bf");
d(RP, "getLeaveConversationMutation");
function $z(n) {
  return new jt(n.queryClient, yz(n));
}
c($z, "Jg");
d($z, "getRemoveConversationMutation");
function xz(n) {
  return new jt(n.queryClient, mz(n));
}
c(xz, "t0");
d(xz, "getUpdateMemberMutation");
function kz(n) {
  return new jt(n.queryClient, wz(n));
}
c(kz, "e0");
d(kz, "getAddMembersToConversationMutation");
function EP(n) {
  return new jt(n.queryClient, gz(n));
}
c(EP, "xf");
d(EP, "getUpdateConversationMutation");
function Sz(n) {
  return new jt(n.queryClient, vz(n));
}
c(Sz, "i0");
d(Sz, "getTrashConversationMutation");
function Pz(n, t, e = [Pt.ChatRoom, Pt.PrivateChat], i) {
  return ll(n, ["apps", t], void 0, {
    initialData: /* @__PURE__ */ d(() => n?.queryClient.getQueryData(["apps", "list", e, i])?.pages.flatMap((s) => s.data).find((s) => s?.id === t), "initialData")
  });
}
c(Pz, "s0");
d(Pz, "getConversationOptions");
function Pk(n, t, e = [Pt.ChatRoom, Pt.PrivateChat], i) {
  return Dv(n, ["apps", t], void 0, {
    initialData: /* @__PURE__ */ d(() => n?.queryClient.getQueryData(["apps", "list", e, i])?.pages.flatMap((s) => s.data).find((s) => s?.id === t), "initialData")
  });
}
c(Pk, "Py");
d(Pk, "getConversation");
async function Cz(n, t, e, i) {
  let s;
  if (typeof t == "number")
    s = await Pk(n, t, e, i);
  else if (typeof t.id == "number" && !t.type)
    s = await Pk(n, t.id, e, i);
  else if (typeof t.type == "string")
    s = t;
  else
    return;
  return e.includes(s.type) ? s : void 0;
}
c(Cz, "r0");
d(Cz, "resolveAppWithType");
var ep;
const Qz = (ep = class {
  constructor(t, e) {
    this.additionalTargets = /* @__PURE__ */ new Set(), this.setExportParts = (i) => {
      (!this.host.hasAttribute("exportparts") || this.shadowParts) && (this.shadowParts ??= /* @__PURE__ */ new Set(), i.forEach((s) => {
        s.part.forEach((r) => this.shadowParts?.add(r)), s.getAttribute("exportparts")?.split(", ").forEach((r) => this.shadowParts?.add(r));
      }), this.shadowParts.size && this.host.setAttribute("exportparts", Array.from(this.shadowParts.values()).join(", ")));
    }, t.addController(this), this.host = t, this.addLocalName = e;
  }
  addPartsFrom(t) {
    t && !this.additionalTargets.has(t) && (this.setExportParts([t]), this.observer?.observe(t, {
      attributeFilter: ["part", "exportparts"]
    }), this.additionalTargets.add(t));
  }
  async hostConnected() {
    if (await this.host.updateComplete, b$(this.host) && this.host.shadowRoot) {
      const t = Array.from(this.host.shadowRoot.querySelectorAll("[part], [exportparts]"));
      this.setExportParts(t), this.observer = new MutationObserver((e) => {
        const i = e.filter((s) => s.target instanceof Element).map((s) => s.target);
        this.setExportParts(i);
      }), this.observer.observe(this.host.shadowRoot, {
        subtree: !0,
        childList: !0,
        attributeFilter: ["part", "exportparts"]
      }), Array.from(this.additionalTargets).forEach((e) => {
        this.observer?.observe(e, {
          attributeFilter: ["part", "exportparts"]
        });
      });
    }
  }
  hostUpdated() {
    b$(this.host) && this.addLocalName !== !1 && !this.host.part.contains(this.host.localName) && (this.addLocalName || getComputedStyle(this.host).display !== "contents") && this.host.part.add(this.host.localName);
  }
  hostDisconnected() {
    this.observer?.disconnect();
  }
}, c(ep, "Gp"), ep);
d(Qz, "ShadowPartsController");
let et = Qz;
function _P(n, t, e) {
  return {
    queryKey: ["members", t],
    queryFn: /* @__PURE__ */ d(async () => await (await n.fetch(`/api/apps/${t}/members`)).json(), "queryFn"),
    ...e
  };
}
c(_P, "$f");
d(_P, "getMemberOptions");
function Mz(n, t, e, i) {
  return {
    queryKey: ["search__members", e],
    initialPageParam: 0,
    enabled: !0,
    queryFn: /* @__PURE__ */ d(async (s) => {
      const r = t(), a = s.pageParam;
      let o;
      e ? o = await n.fetch(`/api/apps/${e}/members?q=${r}${i() !== void 0 ? `&agent=${!!i()}` : ""}&member=false&system=false&skip=${a}`) : o = await n.fetch(`/api/users?q=${r}${i() !== void 0 ? `&agent=${!!i()}` : ""}&system=false&skip=${a}`);
      const l = await o.json();
      return l.data = l.data || [], l;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ d((s) => {
      if (s.end && s.end < s.count)
        return s.end;
    }, "getNextPageParam")
  };
}
c(Mz, "n0");
d(Mz, "getInfiniteSearchMemberOptions");
const Ct = /* @__PURE__ */ d((n) => n ?? Q, "o$3"), Tz = Qt`[part~=wy-footerbar]{--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));position:absolute;bottom:0;left:0;right:0;z-index:1020}[part~=wy-footerbar]:after{content:\"\";background-color:var(--wy-component-background-color);color:var(--wy-component-color);box-shadow:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) 0 var(--wy-border, 1px) 0 0 inset;position:absolute;width:100%;left:0;bottom:0;height:100%;z-index:-1}[part~=wy-footerbar-sticky]{position:sticky}`, ma = Qt`[part~=wy-pager]{position:relative;align-self:center;justify-self:center}[part~=wy-pager-bottom]{width:16px;height:256px;max-height:100%;margin-top:-256px;margin-inline:auto;pointer-events:none}[part~=wy-pager-top]{width:16px;height:256px;max-height:100%;margin-bottom:-256px;margin-inline:auto;pointer-events:none}`;
var zP = /* @__PURE__ */ ((n) => (n.Active = "active", n.Away = "away", n))(zP || {}), ip;
const Az = (ip = class extends pl {
  constructor(t) {
    if (super(t), t.type !== Ty.ATTRIBUTE || t.name !== "part" || t.strings?.length > 2)
      throw new Error(
        "`partMap()` can only be used in the `part` attribute and must be the only section in the attribute."
      );
  }
  render(t) {
    return " " + Object.keys(t).filter((e) => t[e]).join(" ") + " ";
  }
  update(t, [e]) {
    if (this._previousShadowParts === void 0) {
      this._previousShadowParts = /* @__PURE__ */ new Set(), t.strings !== void 0 && (this._staticShadowParts = new Set(
        t.strings.join(" ").split(/\s/).filter((s) => s !== "")
      ));
      for (const s in e)
        e[s] && !this._staticShadowParts?.has(s) && this._previousShadowParts.add(s);
      return this.render(e);
    }
    const i = t.element.part;
    for (const s of this._previousShadowParts)
      s in e || (i.remove(s), this._previousShadowParts.delete(s));
    for (const s in e) {
      const r = !!e[s];
      r !== this._previousShadowParts.has(s) && !this._staticShadowParts?.has(s) && (r ? (i.add(s), this._previousShadowParts.add(s)) : (i.remove(s), this._previousShadowParts.delete(s)));
    }
    return Sn;
  }
}, c(ip, "Zp"), ip);
d(Az, "ShadowPartMapDirective");
let eB = Az;
const Me = ya(eB), Ie = Qt`:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]){box-sizing:border-box;text-align:initial;font-size:var(--wy-font-size, var(--wy-size, 1em))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:before,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:after{box-sizing:inherit}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a){text-decoration:var(--wy-link-decoration, none);color:var(--wy-link, var(--wy-primary-40, #006399))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):hover{text-decoration:var(--wy-link-hover-decoration, unset)}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(a):where(:not([href]):not([class])):hover,:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(a):where(:not([href]):not([class])):hover{text-decoration:none}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(p),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(p){margin-top:0;margin-bottom:calc(1 * var(--wy-size, 1rem))}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where(label),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where(label){cursor:inherit}:where(:host([hidden])),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"])[hidden],:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *[hidden]{display:none!important}:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]):where([role=button]),:where(:host,:host>*,[class^=wy-],[class*=\" wy-\"]) *:where([role=button]){cursor:pointer}`, LP = Qt`:host(wy-avatar){position:relative;display:inline-flex}[part~=wy-avatar-shape]{border-radius:var(--wy-avatar-border-radius, var(--wy-border-radius-pill, var(--wy-border-radius, 50%)))}[part~=wy-avatar-img]{width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));object-fit:cover}[part~=wy-avatar-initials]{background-color:var(--wy-component-avatar-background-color, var(--wy-primary, var(--wy-primary-40, #006399)));color:var(--wy-component-avatar-color, var(--wy-on-primary, var(--wy-white, #ffffff)));width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));display:flex;align-items:center;align-content:center;justify-content:center;justify-items:center;font-size:calc(var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem))))}[part~=wy-avatar-initials-text]{font-size:max(8px,var(--wy-avatar-font-size, .382em));font-weight:var(--wy-avatar-font-weight, var(--wy-font-weight-bold, unset));line-height:1}[part~=wy-avatar-type]{display:flex;position:absolute;z-index:1;bottom:0;right:-8.3333333333%;border-radius:50%;color:var(--wy-primary-50, var(--wy-primary-50, #1e7dba));stroke:var(--wy-on-primary, var(--wy-white, #ffffff))}:host(wy-avatar-group){position:relative;display:inline-flex;flex-shrink:0;width:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)));height:var(--wy-component-avatar-size, calc(2 * var(--wy-size, 1rem)))}[part~=wy-avatar-back]{position:absolute;top:0;left:0}[part~=wy-avatar-front]{position:absolute;bottom:0;right:0}:host(wy-avatar-header){padding:calc(1.5 * var(--wy-size, 1rem));margin-left:auto;margin-right:auto;text-align:center;display:flex;flex-direction:column;justify-content:center;align-items:center}[part~=wy-avatar-description]{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}`, Rz = Qt`[part~=wy-presence]{width:calc(.75 * var(--wy-size, 1rem));height:calc(.75 * var(--wy-size, 1rem));border-radius:50%;position:absolute;bottom:0;right:-5%;box-sizing:border-box}[part~=wy-presence]:not([part~=wy-presence-active]){display:none}[part~=wy-presence]:after{content:\"\";position:absolute;width:100%;height:100%;top:0;left:0;border-radius:inherit;background-color:var(--wy-presence-active, var(--wy-green-light, #00a38b));background-clip:content-box;padding:calc(.125 * var(--wy-size, 1rem));box-sizing:border-box}[part~=wy-presence-mask]{-webkit-mask-image:radial-gradient(circle calc(.75 * var(--wy-size, 1rem)) at bottom calc(.375 * var(--wy-size, 1rem)) right calc(.375 * var(--wy-size, 1rem) - 5%),rgba(0,0,0,0) calc(.375 * var(--wy-size, 1rem)),rgb(0,0,0) calc(.375 * var(--wy-size, 1rem) + 1px));mask-image:radial-gradient(circle calc(.75 * var(--wy-size, 1rem)) at bottom calc(.375 * var(--wy-size, 1rem)) right calc(.375 * var(--wy-size, 1rem) - 5%),#0000 calc(.375 * var(--wy-size, 1rem)),#000 calc(.375 * var(--wy-size, 1rem) + 1px))}[part~=wy-presence-in-text]{position:absolute;bottom:unset;right:unset}[part~=wy-presence-in-text]:after{left:calc(-1 * var(--wy-size, 1rem))}`;
var iB = Object.defineProperty, nB = Object.getOwnPropertyDescriptor, IP = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? nB(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && iB(t, e, s), s;
}, "__decorateClass$19"), L0, np;
let ry = (L0 = (np = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.placement = "avatar";
  }
  render() {
    const t = {
      "wy-presence": !0,
      "wy-presence-active": this.status === zP.Active,
      "wy-presence-in-text": this.placement === "text"
    };
    return v` <span part=${Me(t)} data-presence-id=${this.id}></span> `;
  }
}, c(np, "ea"), np), d(L0, "WyPresence"), L0);
ry.styles = [
  Ie,
  Rz,
  Tt
];
IP([
  O()
], ry.prototype, "placement", 2);
IP([
  O()
], ry.prototype, "status", 2);
ry = IP([
  X("wy-presence")
], ry);
var sB = "M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M1,10V12H9V10M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12Z", rB = "M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M6,10V7H4V10H1V12H4V15H6V12H9V10M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12Z", aB = "M13 14H11V9H13M13 18H11V16H13M1 21H23L12 2L1 21Z", oB = "M13,13H11V7H13M13,17H11V15H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", lB = "M13 13H11V7H13M11 15H13V17H11M15.73 3H8.27L3 8.27V15.73L8.27 21H15.73L21 15.73V8.27L15.73 3Z", M3 = "M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z", cB = "M4,11V13H16L10.5,18.5L11.92,19.92L19.84,12L11.92,4.08L10.5,5.5L16,11H4Z", Ez = "M7.5,18A5.5,5.5 0 0,1 2,12.5A5.5,5.5 0 0,1 7.5,7H18A4,4 0 0,1 22,11A4,4 0 0,1 18,15H9.5A2.5,2.5 0 0,1 7,12.5A2.5,2.5 0 0,1 9.5,10H17V11.5H9.5A1,1 0 0,0 8.5,12.5A1,1 0 0,0 9.5,13.5H18A2.5,2.5 0 0,0 20.5,11A2.5,2.5 0 0,0 18,8.5H7.5A4,4 0 0,0 3.5,12.5A4,4 0 0,0 7.5,16.5H17V18H7.5Z", hB = "M12,3A9,9 0 0,0 3,12H0L4,16L8,12H5A7,7 0 0,1 12,5A7,7 0 0,1 19,12A7,7 0 0,1 12,19C10.5,19 9.09,18.5 7.94,17.7L6.5,19.14C8.04,20.3 9.94,21 12,21A9,9 0 0,0 21,12A9,9 0 0,0 12,3M14,12A2,2 0 0,0 12,10A2,2 0 0,0 10,12A2,2 0 0,0 12,14A2,2 0 0,0 14,12Z", _z = "M21,19V20H3V19L5,17V11C5,7.9 7.03,5.17 10,4.29C10,4.19 10,4.1 10,4A2,2 0 0,1 12,2A2,2 0 0,1 14,4C14,4.1 14,4.19 14,4.29C16.97,5.17 19,7.9 19,11V17L21,19M14,21A2,2 0 0,1 12,23A2,2 0 0,1 10,21", zz = "M20.84,22.73L18.11,20H3V19L5,17V11C5,9.86 5.29,8.73 5.83,7.72L1.11,3L2.39,1.73L22.11,21.46L20.84,22.73M19,15.8V11C19,7.9 16.97,5.17 14,4.29C14,4.19 14,4.1 14,4A2,2 0 0,0 12,2A2,2 0 0,0 10,4C10,4.1 10,4.19 10,4.29C9.39,4.47 8.8,4.74 8.26,5.09L19,15.8M12,23A2,2 0 0,0 14,21H10A2,2 0 0,0 12,23Z", dB = "M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3M9 17H7V10H9V17M13 17H11V7H13V17M17 17H15V13H17V17Z", I0 = "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z", uB = "M0.41,13.41L6,19L7.41,17.58L1.83,12M22.24,5.58L11.66,16.17L7.5,12L6.07,13.41L11.66,19L23.66,7M18,7L16.59,5.58L10.24,11.93L11.66,13.34L18,7Z", pB = "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41 10.59L10 14.17L17.59 6.58L19 8L10 17Z", fB = "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M12 20C7.59 20 4 16.41 4 12S7.59 4 12 4 20 7.59 20 12 16.41 20 12 20M16.59 7.58L10 14.17L7.41 11.59L6 13L10 17L18 9L16.59 7.58Z", yB = "M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3M19,5V19H5V5H19Z", mB = "M19,19H5V5H15V3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V11H19M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z", wB = "M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", gB = "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z", vB = "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z", bB = "M6.5 20Q4.22 20 2.61 18.43 1 16.85 1 14.58 1 12.63 2.17 11.1 3.35 9.57 5.25 9.15 5.88 6.85 7.75 5.43 9.63 4 12 4 14.93 4 16.96 6.04 19 8.07 19 11 20.73 11.2 21.86 12.5 23 13.78 23 15.5 23 17.38 21.69 18.69 20.38 20 18.5 20Z", OB = "M9,22A1,1 0 0,1 8,21V18H4A2,2 0 0,1 2,16V4C2,2.89 2.9,2 4,2H20A2,2 0 0,1 22,4V16A2,2 0 0,1 20,18H13.9L10.2,21.71C10,21.9 9.75,22 9.5,22V22H9Z", $B = "M9,22A1,1 0 0,1 8,21V18H4A2,2 0 0,1 2,16V4C2,2.89 2.9,2 4,2H20A2,2 0 0,1 22,4V16A2,2 0 0,1 20,18H13.9L10.2,21.71C10,21.9 9.75,22 9.5,22V22H9M10,16V19.08L13.08,16H20V4H4V16H10Z", xB = "M15,9H5V5H15M12,19A3,3 0 0,1 9,16A3,3 0 0,1 12,13A3,3 0 0,1 15,16A3,3 0 0,1 12,19M17,3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V7L17,3Z", kB = "M19,1L17.74,3.75L15,5L17.74,6.26L19,9L20.25,6.26L23,5L20.25,3.75M9,4L6.5,9.5L1,12L6.5,14.5L9,20L11.5,14.5L17,12L11.5,9.5M19,15L17.74,17.74L15,19L17.74,20.25L19,23L20.25,20.25L23,19L20.25,17.74", SB = "M13,19A1,1 0 0,0 14,20H16V22H13.5C12.95,22 12,21.55 12,21C12,21.55 11.05,22 10.5,22H8V20H10A1,1 0 0,0 11,19V5A1,1 0 0,0 10,4H8V2H10.5C11.05,2 12,2.45 12,3C12,2.45 12.95,2 13.5,2H16V4H14A1,1 0 0,0 13,5V19Z", Lz = "M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z", Iz = "M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19M8.46,11.88L9.87,10.47L12,12.59L14.12,10.47L15.53,11.88L13.41,14L15.53,16.12L14.12,17.53L12,15.41L9.88,17.53L8.47,16.12L10.59,14L8.46,11.88M15.5,4L14.5,3H9.5L8.5,4H5V6H19V4H15.5Z", PB = "M14,14H16L12,10L8,14H10V18H14V14M6,7H18V19C18,19.5 17.8,20 17.39,20.39C17,20.8 16.5,21 16,21H8C7.5,21 7,20.8 6.61,20.39C6.2,20 6,19.5 6,19V7M19,4V6H5V4H8.5L9.5,3H14.5L15.5,4H19Z", CB = "M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z", QB = "M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z", MB = "M17.9,17.39C17.64,16.59 16.89,16 16,16H15V13A1,1 0 0,0 14,12H8V10H10A1,1 0 0,0 11,9V7H13A2,2 0 0,0 15,5V4.59C17.93,5.77 20,8.64 20,12C20,14.08 19.2,15.97 17.9,17.39M11,19.93C7.05,19.44 4,16.08 4,12C4,11.38 4.08,10.78 4.21,10.21L9,15V16A2,2 0 0,0 11,18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z", TB = "M20,8L12,13L4,8V6L12,11L20,6M20,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V6C22,4.89 21.1,4 20,4Z", AB = "M13,9V3.5L18.5,9M6,2C4.89,2 4,2.89 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2H6Z", T3 = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M6.12,15.5L9.86,19.24L11.28,17.83L8.95,15.5L11.28,13.17L9.86,11.76L6.12,15.5M17.28,15.5L13.54,11.76L12.12,13.17L14.45,15.5L12.12,17.83L13.54,19.24L17.28,15.5Z", A3 = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M15,18V16H6V18H15M18,14V12H6V14H18Z", RB = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.8,20H14L12,16.6L10,20H8.2L11.1,15.5L8.2,11H10L12,14.4L14,11H15.8L12.9,15.5L15.8,20M13,9V3.5L18.5,9H13Z", EB = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M6,20H15L18,20V12L14,16L12,14L6,20M8,9A2,2 0 0,0 6,11A2,2 0 0,0 8,13A2,2 0 0,0 10,11A2,2 0 0,0 8,9Z", _B = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M13,13H11V18A2,2 0 0,1 9,20A2,2 0 0,1 7,18A2,2 0 0,1 9,16C9.4,16 9.7,16.1 10,16.3V11H13V13M13,9V3.5L18.5,9H13Z", zB = "M12.6,12.3H10.6V15.5H12.7C13.3,15.5 13.6,15.3 13.9,15C14.2,14.7 14.3,14.4 14.3,13.9C14.3,13.4 14.2,13.1 13.9,12.8C13.6,12.5 13.2,12.3 12.6,12.3M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.2,16C14.6,16.5 14.1,16.7 12.8,16.7H10.6V20H9V11H12.8C14.1,11 14.7,11.3 15.2,11.8C15.8,12.4 16,13 16,13.9C16,14.8 15.8,15.5 15.2,16M13,9V3.5L18.5,9H13Z", LB = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M13.5,16V19H10.5V16H8L12,12L16,16H13.5M13,9V3.5L18.5,9H13Z", IB = "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M17,19V13L14,15.2V13H7V19H14V16.8L17,19Z", ZB = "M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M15.2,20H13.8L12,13.2L10.2,20H8.8L6.6,11H8.1L9.5,17.8L11.3,11H12.6L14.4,17.8L15.8,11H17.3L15.2,20M13,9V3.5L18.5,9H13Z", VB = "M20,2H4C2.89,2 2,2.89 2,4V20C2,21.11 2.89,22 4,22H20C21.11,22 22,21.11 22,20V4C22,2.89 21.11,2 20,2M12,4L15,7H13V9H11V7H9M7,15L4,12L7,9V11H9V13H7M12,20L9,17H11V15H13V17H15M17,15V13H15V11H17V9L20,12", DB = "M17 4H20C21.1 4 22 4.9 22 6V8H20V6H17V4M4 8V6H7V4H4C2.9 4 2 4.9 2 6V8H4M20 16V18H17V20H20C21.1 20 22 19.1 22 18V16H20M7 18H4V16H2V18C2 19.1 2.9 20 4 20H7V18M18 8H6V16H18V8Z", WB = "M20 6H12L10 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V8C22 6.9 21.1 6 20 6M18 12H16V14H18V16H16V18H14V16H16V14H14V12H16V10H14V8H16V10H18V12Z", qB = "M17,7H22V17H17V19A1,1 0 0,0 18,20H20V22H17.5C16.95,22 16,21.55 16,21C16,21.55 15.05,22 14.5,22H12V20H14A1,1 0 0,0 15,19V5A1,1 0 0,0 14,4H12V2H14.5C15.05,2 16,2.45 16,3C16,2.45 16.95,2 17.5,2H20V4H18A1,1 0 0,0 17,5V7M2,7H13V9H4V15H13V17H2V7M20,15V9H17V15H20Z", jB = "M15.07,11.25L14.17,12.17C13.45,12.89 13,13.5 13,15H11V14.5C11,13.39 11.45,12.39 12.17,11.67L13.41,10.41C13.78,10.05 14,9.55 14,9C14,7.89 13.1,7 12,7A2,2 0 0,0 10,9H8A4,4 0 0,1 12,5A4,4 0 0,1 16,9C16,9.88 15.64,10.67 15.07,11.25M13,19H11V17H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12C22,6.47 17.5,2 12,2Z", FB = "M13.5,8H12V13L16.28,15.54L17,14.33L13.5,12.25V8M13,3A9,9 0 0,0 4,12H1L4.96,16.03L9,12H6A7,7 0 0,1 13,5A7,7 0 0,1 20,12A7,7 0 0,1 13,19C11.07,19 9.32,18.21 8.06,16.94L6.64,18.36C8.27,20 10.5,21 13,21A9,9 0 0,0 22,12A9,9 0 0,0 13,3", UB = "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M11,17H13V11H11V17Z", BB = "M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z", XB = "M7,10L12,15L17,10H7Z", NB = "M7,15L12,10L17,15H7Z", HB = "M19,13H5V11H19V13Z", YB = "M21 2C22.05 2 22.92 2.81 23 3.85L23 4V16C23 17.05 22.18 17.92 21.15 18L21 18H14V20H16V22H8V20H10V18H3C1.95 18 1.08 17.18 1 16.15L1 16V4C1 2.94 1.81 2.08 2.85 2L3 2H21M21 4H3V16H21V4M12 11C14.21 11 16 11.9 16 13V14H8V13C8 11.9 9.79 11 12 11M12 6C13.11 6 14 6.9 14 8S13.11 10 12 10 10 9.11 10 8 10.9 6 12 6Z", GB = "M14,3V5H17.59L7.76,14.83L9.17,16.24L19,6.41V10H21V3M19,19H5V5H12V3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V12H19V19Z", Ck = "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z", KB = "M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z", JB = "M2,5.27L3.28,4L20,20.72L18.73,22L12.8,16.07V22H11.2V16H6V14L8,12V11.27L2,5.27M16,12L18,14V16H17.82L8,6.18V4H7V2H17V4H16V12Z", Zz = "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z", tX = "M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M13,7H11V11H7V13H11V17H13V13H17V11H13V7Z", Vz = "M13,3A9,9 0 0,0 4,12H1L4.89,15.89L4.96,16.03L9,12H6A7,7 0 0,1 13,5A7,7 0 0,1 20,12A7,7 0 0,1 13,19C11.07,19 9.32,18.21 8.06,16.94L6.64,18.36C8.27,20 10.5,21 13,21A9,9 0 0,0 22,12A9,9 0 0,0 13,3Z", eX = "M4,3H5V5H3V4A1,1 0 0,1 4,3M20,3A1,1 0 0,1 21,4V5H19V3H20M15,5V3H17V5H15M11,5V3H13V5H11M7,5V3H9V5H7M21,20A1,1 0 0,1 20,21H19V19H21V20M15,21V19H17V21H15M11,21V19H13V21H11M7,21V19H9V21H7M4,21A1,1 0 0,1 3,20V19H5V21H4M3,15H5V17H3V15M21,15V17H19V15H21M3,11H5V13H3V11M21,11V13H19V11H21M3,7H5V9H3V7M21,7V9H19V7H21Z", iX = "M2,21L23,12L2,3V10L17,12L2,14V21Z", nX = "M13,19H14A1,1 0 0,1 15,20H15.73L13,17.27V19M22,20V21.18L20.82,20H22M21,22.72L19.73,24L17.73,22H15A1,1 0 0,1 14,23H10A1,1 0 0,1 9,22H2V20H9A1,1 0 0,1 10,19H11V17H4A1,1 0 0,1 3,16V12A1,1 0 0,1 4,11H6.73L4.73,9H4A1,1 0 0,1 3,8V7.27L1,5.27L2.28,4L21,22.72M4,3H20A1,1 0 0,1 21,4V8A1,1 0 0,1 20,9H9.82L7,6.18V5H5.82L3.84,3C3.89,3 3.94,3 4,3M20,11A1,1 0 0,1 21,12V16A1,1 0 0,1 20,17H17.82L11.82,11H20M9,7H10V5H9V7M9,15H10V14.27L9,13.27V15M5,13V15H7V13H5Z", sX = "M12 1L3 5V11C3 16.55 6.84 21.74 12 23C17.16 21.74 21 16.55 21 11V5L12 1M15.08 16L12 14.15L8.93 16L9.74 12.5L7.03 10.16L10.61 9.85L12 6.55L13.39 9.84L16.97 10.15L14.26 12.5L15.08 16Z", rX = "M21 11C21 16.55 17.16 21.74 12 23C6.84 21.74 3 16.55 3 11V5L12 1L21 5V11M12 21C15.75 20 19 15.54 19 11.22V6.3L12 3.18L5 6.3V11.22C5 15.54 8.25 20 12 21M15.05 16L11.97 14.15L8.9 16L9.71 12.5L7 10.16L10.58 9.85L11.97 6.55L13.37 9.84L16.95 10.15L14.23 12.5L15.05 16", aX = "M18 21L14 17H17V7H14L18 3L22 7H19V17H22M2 19V17H12V19M2 13V11H9V13M2 7V5H6V7H2Z", oX = "M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z", lX = "M12,1L9,9L1,12L9,15L12,23L15,15L23,12L15,9L12,1Z", cX = "M20.8 22.7L17.9 19.8L18.2 21L12 17.3L5.8 21L7.4 14L2 9.2L6.9 8.8L1.1 3L2.4 1.7L22.1 21.4L20.8 22.7M22 9.2L14.8 8.6L12 2L10 6.8L16.9 13.7L22 9.2Z", hX = "M21,9L17,5V8H10V10H17V13M7,11L3,15L7,19V16H14V14H7V11Z", dX = "M9,3L5,7H8V14H10V7H13M16,17V10H14V17H11L15,21L19,17H16Z", uX = "M23,10C23,8.89 22.1,8 21,8H14.68L15.64,3.43C15.66,3.33 15.67,3.22 15.67,3.11C15.67,2.7 15.5,2.32 15.23,2.05L14.17,1L7.59,7.58C7.22,7.95 7,8.45 7,9V19A2,2 0 0,0 9,21H18C18.83,21 19.54,20.5 19.84,19.78L22.86,12.73C22.95,12.5 23,12.26 23,12V10M1,21H5V9H1V21Z", pX = "M5,9V21H1V9H5M9,21A2,2 0 0,1 7,19V9C7,8.45 7.22,7.95 7.59,7.59L14.17,1L15.23,2.06C15.5,2.33 15.67,2.7 15.67,3.11L15.64,3.43L14.69,8H21C22.11,8 23,8.9 23,10V12C23,12.26 22.95,12.5 22.86,12.73L19.84,19.78C19.54,20.5 18.83,21 18,21H9M9,19H18.03L21,12V10H12.21L13.34,4.68L9,9.03V19Z", fX = "M9,3V4H4V6H5V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V6H20V4H15V3H9M9,8H11V17H9V8M13,8H15V17H13V8Z", yX = "M9,16V10H5L12,3L19,10H15V16H9M5,20V18H19V20H5Z", mX = "M17,10.5V7A1,1 0 0,0 16,6H4A1,1 0 0,0 3,7V17A1,1 0 0,0 4,18H16A1,1 0 0,0 17,17V13.5L21,17.5V6.5L17,10.5Z", wX = "M3 5V19H20V5H3M7 7V9H5V7H7M5 13V11H7V13H5M5 15H7V17H5V15M18 17H9V15H18V17M18 13H9V11H18V13M18 9H9V7H18V9Z", gX = "M4 5V18H21V5H4M14 7V10.5H11V7H14M6 7H9V10.5H6V7M6 16V12.5H9V16H6M11 16V12.5H14V16H11M19 16H16V12.5H19V16M16 10.5V7H19V10.5H16Z", vX = "M2.28,3L1,4.27L2.47,5.74C2.04,6 1.61,6.29 1.2,6.6L3,9C3.53,8.6 4.08,8.25 4.66,7.93L6.89,10.16C6.15,10.5 5.44,10.91 4.8,11.4L6.6,13.8C7.38,13.22 8.26,12.77 9.2,12.47L11.75,15C10.5,15.07 9.34,15.5 8.4,16.2L12,21L14.46,17.73L17.74,21L19,19.72M12,3C9.85,3 7.8,3.38 5.9,4.07L8.29,6.47C9.5,6.16 10.72,6 12,6C15.38,6 18.5,7.11 21,9L22.8,6.6C19.79,4.34 16.06,3 12,3M12,9C11.62,9 11.25,9 10.88,9.05L14.07,12.25C15.29,12.53 16.43,13.07 17.4,13.8L19.2,11.4C17.2,9.89 14.7,9 12,9Z";
const R3 = eX, E3 = {
  "zoom-meetings": '<path d="M21.5 12.5c0 .96-.08 1.91-.23 2.83a7.198 7.198 0 01-5.95 5.95 17.527 17.527 0 01-5.66 0 7.198 7.198 0 01-5.95-5.95 17.527 17.527 0 010-5.66c.49-3.05 2.9-5.46 5.95-5.95a17.527 17.527 0 015.66 0c3.05.49 5.46 2.9 5.95 5.95.15.92.23 1.86.23 2.83z" fill="#0b5cff"/><path d="M14.43 14.75c0 .53-.43.96-.96.96H9.29c-1.07 0-1.93-.86-1.93-1.93v-3.54c0-.53.43-.96.96-.96h4.18c1.07 0 1.93.86 1.93 1.93v3.54zM16.87 9.86l-1.41 1.06c-.24.18-.39.47-.39.77v1.61c0 .3.14.59.39.77l1.41 1.06c.32.24.77.01.77-.39v-4.5c0-.4-.45-.62-.77-.39z" fill="#fff"/>',
  "google-meet": '<path fill="#1e88e5" d="M3.5 9.07v5.86l2.09.42 2.1-.42V9.07l-2.1-.42-2.09.42z"/><path d="M17.73 12v5.86c0 .69-.56 1.26-1.26 1.26H7.69l-.42-2.09.42-2.09h5.86v-2.93l2.09-.42 2.09.42z" fill="#4caf50"/><path d="M17.73 6.14V12h-4.19V9.07H7.68l-.42-2.09.42-2.09h8.79c.69 0 1.26.56 1.26 1.26z" fill="#fbc02d"/><path d="M7.69 14.93v4.19H4.76c-.69 0-1.26-.56-1.26-1.26v-2.93h4.19z" fill="#1565c0"/><path fill="#e53935" d="M7.69 4.88v4.19H3.5l4.19-4.19z"/><path fill="#2e7d32" d="M18.15 12l-.42 3.54L13.55 12l4.18-3.54.42 3.54z"/><path d="M21.5 6.19v11.63c0 .35-.41.55-.68.33l-3.09-2.6V8.48l3.09-2.6c.27-.22.68-.03.68.33z" fill="#4caf50"/>',
  "webex-meetings": '<defs><radialGradient id="prefix__b" cx="-951.63" cy="549.04" fx="-951.63" fy="549.04" r=".05" gradientTransform="matrix(-87.16473 -146.04628 -122.52671 73.12756 -15652.44 -179117.85)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#007383"/><stop offset=".41" stop-color="#00717e" stop-opacity=".75"/><stop offset=".87" stop-color="#007281" stop-opacity="0"/></radialGradient><radialGradient id="prefix__c" cx="-952.67" cy="549.07" fx="-952.67" fy="549.07" r=".05" gradientTransform="rotate(-126.7 -53497.341 -58162.752) scale(138.69 -91.09)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#218970"/><stop offset=".46" stop-color="#267e6a"/><stop offset="1" stop-color="#026c51" stop-opacity="0"/></radialGradient><radialGradient id="prefix__d" cx="-952.61" cy="541.2" fx="-952.61" fy="541.2" r=".05" gradientTransform="matrix(-33.8827 -107.79009 -56.09397 17.63256 -1902.72 -112216.84)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#178697"/><stop offset=".41" stop-color="#17838f" stop-opacity=".79"/><stop offset=".87" stop-color="#007281" stop-opacity="0"/></radialGradient><radialGradient id="prefix__e" cx="-949.76" cy="547.24" fx="-949.76" fy="547.24" r=".05" gradientTransform="matrix(-146.98086 -246.36712 -75.94201 45.30646 -98045.43 -258761.67)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#25342f" stop-opacity=".3"/><stop offset="1" stop-color="#25342f" stop-opacity="0"/></radialGradient><radialGradient id="prefix__f" cx="-942.87" cy="563.62" fx="-942.87" fy="563.62" r=".05" gradientTransform="rotate(85.1 -69752.427 38265.017) scale(108.08 -61.22)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#056d4f"/><stop offset=".23" stop-color="#056c4e" stop-opacity=".75"/><stop offset=".6" stop-color="#056c4e" stop-opacity=".3"/><stop offset=".87" stop-color="#056c4f" stop-opacity="0"/></radialGradient><radialGradient id="prefix__g" cx="-940.36" cy="556.77" fx="-940.36" fy="556.77" r=".05" gradientTransform="matrix(68.96997 106.65216 55.9082 -36.1548 33735.1 120422.29)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#22b67b"/><stop offset=".41" stop-color="#24be82"/><stop offset="1" stop-color="#24be82" stop-opacity=".07"/></radialGradient><radialGradient id="prefix__i" cx="-940.77" cy="554.96" fx="-940.77" fy="554.96" r=".05" gradientTransform="rotate(49.69 -177135.555 122596.9) scale(165.85 -165.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></radialGradient><radialGradient id="prefix__j" cx="-944.1" cy="553.18" fx="-944.1" fy="553.18" r=".05" gradientTransform="rotate(48.05 -367132.581 263331.898) scale(336.36 -335.78)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00b8ff"/><stop offset=".75" stop-color="#00b9fc" stop-opacity="0"/></radialGradient><radialGradient id="prefix__k" cx="-951.17" cy="546.23" fx="-951.17" fy="546.23" r=".05" gradientTransform="matrix(-48.64247 -154.74493 -107.10322 33.66679 12252.88 -165563.53)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00bcff" stop-opacity=".76"/><stop offset=".57" stop-color="#00bafc" stop-opacity="0"/></radialGradient><radialGradient id="prefix__l" cx="-953.78" cy="550.07" fx="-953.78" fy="550.07" r=".05" gradientTransform="matrix(-72.9418 -88.45403 -61.91396 51.05608 -35502.54 -112443.2)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5fec50"/><stop offset="1" stop-color="#3cc08e" stop-opacity="0"/></radialGradient><radialGradient id="prefix__m" cx="-954.59" cy="523.18" fx="-954.59" fy="523.18" r=".05" gradientTransform="rotate(-79.11 -8961.313 -26349.067) scale(34.73 -23.99)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#28855b"/><stop offset="1" stop-color="#14795c" stop-opacity="0"/></radialGradient><radialGradient id="prefix__n" cx="-955.7" cy="534.72" fx="-955.7" fy="534.72" r=".05" gradientTransform="matrix(6.00138 -27.99393 -39.07222 -8.37636 26647.75 -22260.21)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#28855b"/><stop offset="1" stop-color="#14795c" stop-opacity="0"/></radialGradient><radialGradient id="prefix__o" cx="-954.99" cy="550.19" fx="-954.99" fy="550.19" r=".05" gradientTransform="matrix(-64.43177 -69.7019 -48.95728 45.25565 -34575.21 -91452.74)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5ff05b"/><stop offset=".81" stop-color="#5de955" stop-opacity="0"/></radialGradient><radialGradient id="prefix__p" cx="-938.28" cy="553.05" fx="-938.28" fy="553.05" r=".05" gradientTransform="matrix(66.96005 51.3617 71.4219 -93.11248 23342.15 99701.75)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".97" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__q" cx="-940.1" cy="550.5" fx="-940.1" fy="550.5" r=".05" gradientTransform="matrix(98.43675 14.71147 21.98813 -147.126 80455.97 94829.3)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".59" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__r" cx="-938.38" cy="551.97" fx="-938.38" fy="551.97" r=".05" gradientTransform="rotate(24.69 -231174.852 140478.806) scale(85.04 -151.66)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".76" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__s" cx="-945.2" cy="560.82" fx="-945.2" fy="560.82" r=".05" gradientTransform="rotate(95.79 -93552.04 41883.384) scale(153.04 -83.75)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".59" stop-color="#123aa8" stop-opacity="0"/><stop offset="1" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__t" cx="-945.05" cy="562.66" fx="-945.05" fy="562.66" r=".05" gradientTransform="rotate(93.66 -104350.43 63182.76) scale(184.18 -65.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__u" cx="-942.29" cy="567.94" fx="-942.29" fy="567.94" r=".05" gradientTransform="matrix(8.78957 97.33394 51.50044 -4.65066 -20951.98 94373.6)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__v" cx="-942.85" cy="562.23" fx="-942.85" fy="562.23" r=".05" gradientTransform="matrix(4.89377 101.88254 84.00315 -4.03496 -42611.94 98338.06)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".88" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__w" cx="-941.74" cy="549.74" fx="-941.74" fy="549.74" r=".05" gradientTransform="rotate(-23.2 244205.91 -321749.854) scale(113.62 -222.29)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#123aa8"/><stop offset=".71" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__x" cx="-959.91" cy="553.32" fx="-959.91" fy="553.32" r=".05" gradientTransform="matrix(-70.50332 -26.36011 -45.18376 120.84945 -42670.87 -92159.05)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#1a3da0"/><stop offset=".71" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__y" cx="-940.3" cy="551.63" fx="-940.3" fy="551.63" r=".05" gradientTransform="matrix(137.44492 41.41855 41.86 -138.90985 106154.62 115588.85)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#1e3882"/><stop offset=".76" stop-color="#123aa8" stop-opacity="0"/></radialGradient><radialGradient id="prefix__A" cx="-940.77" cy="554.96" fx="-940.77" fy="554.96" r=".05" gradientTransform="rotate(49.69 -177135.55 122596.884) scale(165.85 -165.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></radialGradient><radialGradient id="prefix__D" cx="-951.17" cy="546.23" fx="-951.17" fy="546.23" r=".05" gradientTransform="matrix(-48.64247 -154.74493 -107.10322 33.66679 12252.88 -165563.53)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#00bcff" stop-opacity=".76"/><stop offset=".57" stop-color="#00bafc" stop-opacity="0"/></radialGradient><linearGradient id="prefix__a" x1="76.14" y1="-95.89" x2="64.37" y2="-99.75" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#5cee64"/><stop offset="1" stop-color="#0bf"/></linearGradient><linearGradient id="prefix__h" x1="56.74" y1="-98.36" x2="65.09" y2="-98.43" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#09f8ff"/><stop offset="1" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient><linearGradient id="prefix__z" x1="61.48" y1="-92.95" x2="67.9" y2="-97.04" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset=".23" stop-color="#1dc4ff"/><stop offset="1" stop-color="#1cc1ff" stop-opacity="0"/></linearGradient><linearGradient id="prefix__B" x1="63.13" y1="-92.11" x2="64.93" y2="-93.74" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#26fbff"/><stop offset=".64" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient><linearGradient id="prefix__C" x1="60.36" y1="-97.78" x2="62.85" y2="-97.95" gradientTransform="matrix(1 0 0 -1 -58.17 -86.5)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#26fbff"/><stop offset=".64" stop-color="#0bf7f9" stop-opacity="0"/></linearGradient></defs><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__a)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__b)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__c)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__d)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__e)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__f)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__g)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__h)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__i)"/><path d="M15.37 5.44c-1.34 0-2.88.45-3.9 2.4-.59 1.12-.89 2.38-1.16 3.63-.09.41-.18.83-.28 1.22v5.66c.51-.14 1.05-.42 1.57-.95 1.96-1.99 2.28-7.2 3.26-8.19.11-.11.23-.18.36-.18.39 0 .7.5.99 1.1.32.67.71 1.43 1.84 1.43.52 0 1.72-.38 1.72-1.85 0-.88-1.47-4.28-4.39-4.28z" fill="url(#prefix__j)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__k)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__l)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__m)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__n)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__o)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="#316aff"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__p)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__q)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__r)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__s)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__t)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__u)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__v)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__w)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__x)"/><path d="M19.22 7.44c-.13 0-.26.01-.39.04.62.89.93 1.83.93 2.23 0 1.47-1.2 1.85-1.72 1.85-.41 0-.71-.1-.96-.25v.03c-.07.29-.13.61-.23.92-.19.6-.45 1.28-.73 1.81-.3.57-.59.9-.94.89-.4-.02-.72-.54-1.13-1.99-.13-.47-.25-.98-.36-1.49-.28-1.25-.62-2.52-1.2-3.63-.95-1.82-2.56-2.4-3.85-2.4-1.2 0-2.09.57-2.79 1.28-.19.2-.41.46-.62.78.61.15 1.19.61 1.28 1.48.02.17.15 1.49.58 3.03.12-.38.3-.95.72-1.88.2-.42.39-.7.56-.87.15-.16.29-.22.41-.22.13 0 .59.12 1.03 1.68.55 1.93.96 5.01 2.52 6.65.69.72 1.65 1.19 2.99 1.19 1.17 0 2.15-.52 2.84-1.24 1.14-1.18 1.77-3.14 2-3.86.64-2.06.82-3.92.84-4.11.12-1.12-.83-1.91-1.77-1.91z" fill="url(#prefix__y)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__z)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__A)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__B)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__C)"/><path d="M8.59 18.51c-3.33 0-4.47-4.22-4.72-5.04-.64-2.06-.83-3.92-.85-4.11-.12-1.12.78-1.91 1.77-1.91.75 0 1.62.45 1.73 1.54.02.18.17 1.76.71 3.48.56 1.8 1.16 2.49 1.59 2.49.69 0 1.12-1.78 1.49-3.48.28-1.25.57-2.51 1.16-3.63 1.02-1.95 2.57-2.4 3.9-2.4 2.93 0 4.39 3.4 4.39 4.28 0 1.47-1.2 1.85-1.72 1.85-1.14 0-1.52-.76-1.84-1.43-.29-.6-.6-1.1-.99-1.1-.13 0-.25.07-.36.18-.98 1-1.31 6.2-3.26 8.19-1.08 1.1-2.26 1.1-3 1.1z" fill="url(#prefix__D)"/>',
  "microsoft-teams": '<path d="M15.56 9.91h4.65c.44 0 .8.36.8.8v4.24c0 1.61-1.31 2.92-2.92 2.92h-.01c-1.61 0-2.92-1.31-2.92-2.92v-4.62c0-.23.19-.42.42-.42z" fill="#5059c9"/><circle cx="18.7" cy="7.19" r="1.88" fill="#5059c9"/><circle cx="12.84" cy="6.35" r="2.72" fill="#7b83eb"/><path d="M16.47 9.91H8.8a.79.79 0 00-.77.8v4.83c-.06 2.6 2 4.77 4.6 4.83 2.6-.06 4.67-2.23 4.6-4.83v-4.83a.783.783 0 00-.77-.8z" fill="#7b83eb"/><path d="M3.77 7.4h7.67c.42 0 .77.34.77.77v7.67c0 .42-.34.77-.77.77H3.77a.77.77 0 01-.77-.77V8.17c0-.42.34-.77.77-.77z" fill="#5a62c3"/><path d="M9.62 10.32H8.09v4.18h-.98v-4.18H5.58v-.81h4.04v.81z" fill="#fff"/>'
}, bX = {
  box: "M15.39,14.04V14.04C15.39,12.62 14.24,11.47 12.82,11.47C11.41,11.47 10.26,12.62 10.26,14.04V14.04C10.26,15.45 11.41,16.6 12.82,16.6C14.24,16.6 15.39,15.45 15.39,14.04M17.1,14.04C17.1,16.4 15.18,18.31 12.82,18.31C11.19,18.31 9.77,17.39 9.05,16.04C8.33,17.39 6.91,18.31 5.28,18.31C2.94,18.31 1.04,16.43 1,14.11V14.11H1V7H1V7C1,6.56 1.39,6.18 1.86,6.18C2.33,6.18 2.7,6.56 2.71,7V7H2.71V10.62C3.43,10.08 4.32,9.76 5.28,9.76C6.91,9.76 8.33,10.68 9.05,12.03C9.77,10.68 11.19,9.76 12.82,9.76C15.18,9.76 17.1,11.68 17.1,14.04V14.04M7.84,14.04V14.04C7.84,12.62 6.69,11.47 5.28,11.47C3.86,11.47 2.71,12.62 2.71,14.04V14.04C2.71,15.45 3.86,16.6 5.28,16.6C6.69,16.6 7.84,15.45 7.84,14.04M22.84,16.96V16.96C22.95,17.12 23,17.3 23,17.47C23,17.73 22.88,18 22.66,18.15C22.5,18.26 22.33,18.32 22.15,18.32C21.9,18.32 21.65,18.21 21.5,18L19.59,15.47L17.7,18V18C17.53,18.21 17.28,18.32 17.03,18.32C16.85,18.32 16.67,18.26 16.5,18.15C16.29,18 16.17,17.72 16.17,17.46C16.17,17.29 16.23,17.11 16.33,16.96V16.96H16.33V16.96L18.5,14.04L16.33,11.11V11.11H16.33V11.11C16.22,10.96 16.17,10.79 16.17,10.61C16.17,10.35 16.29,10.1 16.5,9.93C16.89,9.65 17.41,9.72 17.7,10.09V10.09L19.59,12.61L21.5,10.09C21.76,9.72 22.29,9.65 22.66,9.93C22.89,10.1 23,10.36 23,10.63C23,10.8 22.95,10.97 22.84,11.11V11.11H22.84V11.11L20.66,14.04L22.84,16.96V16.96H22.84Z",
  dropbox: "M3 6.2L8 9.39L13 6.2L8 3L3 6.2M13 6.2L18 9.39L23 6.2L18 3L13 6.2M3 12.55L8 15.74L13 12.55L8 9.35L3 12.55M18 9.35L13 12.55L18 15.74L23 12.55L18 9.35M8.03 16.8L13.04 20L18.04 16.8L13.04 13.61L8.03 16.8Z",
  "google-drive": "M7.71,3.5L1.15,15L4.58,21L11.13,9.5M9.73,15L6.3,21H19.42L22.85,15M22.28,14L15.42,2H8.58L8.57,2L15.43,14H22.28Z",
  onedrive: "M18.21 10.29Q19 10.34 19.7 10.68 20.39 11 20.9 11.57 21.41 12.12 21.71 12.83 22 13.54 22 14.34 22 15.18 21.68 15.92 21.36 16.66 20.8 17.21 20.25 17.76 19.5 18.08 18.78 18.41 17.94 18.41H7Q5.97 18.41 5.06 18 4.15 17.61 3.47 16.94 2.79 16.26 2.4 15.35 2 14.44 2 13.41 2 12.59 2.26 11.83 2.5 11.08 3 10.45 3.44 9.82 4.08 9.35 4.72 8.88 5.5 8.63 5.87 8.5 6.21 8.5 6.56 8.43 6.93 8.41H6.94Q7.37 7.75 7.95 7.23 8.5 6.71 9.2 6.34 9.87 6 10.62 5.78 11.37 5.59 12.16 5.59 13.22 5.59 14.2 5.94 15.18 6.29 16 6.91 16.8 7.53 17.37 8.39 17.95 9.26 18.21 10.29M12.16 6.84Q11.05 6.84 10.06 7.3 9.06 7.75 8.36 8.6 8.73 8.7 9.07 8.85 9.4 9 9.73 9.2L13.71 11.58L16 10.62Q16.21 10.53 16.44 10.45 16.67 10.38 16.92 10.33 16.68 9.55 16.21 8.91 15.74 8.27 15.11 7.81 14.5 7.35 13.73 7.1 13 6.84 12.16 6.84M4 15.66L12.27 12.18L9.08 10.26Q8.59 9.97 8.06 9.81 7.5 9.66 6.95 9.66 6.19 9.66 5.5 9.96 4.84 10.26 4.34 10.77 3.84 11.29 3.54 11.97 3.25 12.65 3.25 13.41 3.25 14 3.45 14.59 3.64 15.19 4 15.66M17.94 17.16Q18.41 17.16 18.84 17 19.27 16.86 19.64 16.58L13.61 13L5.03 16.59Q5.47 16.86 5.97 17 6.47 17.16 7 17.16M20.45 15.61Q20.75 15 20.75 14.34 20.75 13.7 20.5 13.17 20.26 12.65 19.85 12.28 19.43 11.91 18.88 11.71 18.32 11.5 17.7 11.5 17.35 11.5 17 11.6 16.66 11.68 16.33 11.81 16 11.93 15.67 12.08 15.35 12.23 15.04 12.37Z"
}, OX = {
  email: TB,
  file: AB,
  "file-upload": LB,
  "file-music": _B,
  "file-image": EB,
  "file-video": IB,
  "file-code": T3,
  "file-xml": T3,
  "file-document": A3,
  "file-word": ZB,
  "file-excel": RB,
  "file-pdf": A3,
  "file-powerpoint": zB,
  "file-compressed": WB
}, _3 = {
  "account-minus": sB,
  "account-plus": rB,
  alert: aB,
  "alert-circle": oB,
  "alert-octagon": lB,
  attachment: Ez,
  back: M3,
  "backup-restore": hB,
  bell: _z,
  "bell-off": zz,
  agent: lX,
  check: I0,
  "check-all": uB,
  "check-circle-outline": fB,
  "checkbox-blank": yB,
  "checkbox-marked": mB,
  "circle-outline": wB,
  "check-circle": pB,
  close: gB,
  "close-circle": vB,
  cloud: bB,
  comment: OB,
  "comment-outline": $B,
  "content-save": xB,
  delete: Lz,
  "delete-restore": PB,
  "delete-forever": Iz,
  "dots-vertical": CB,
  download: QB,
  earth: MB,
  "emoticon-plus": "M 19 0 L 19 3 L 16 3 L 16 5 L 19 5 L 19 8 L 21 8 L 21 5 L 24 5 L 24 3 L 21 3 L 21 0 L 19 0 z M 12 2 C 6.5 2 2 6.5 2 12 C 2 17.5 6.5 22 12 22 C 17.5 22 22 17.5 22 12 L 20 12 C 20 16.4 16.4 20 12 20 C 7.6 20 4 16.4 4 12 C 4 7.6 7.6 4 12 4 L 12 2 z M 8.5 8 C 7.7 8 7 8.7 7 9.5 C 7 10.3 7.7 11 8.5 11 C 9.3 11 10 10.3 10 9.5 C 10 8.7 9.3 8 8.5 8 z M 15.5 8 C 14.7 8 14 8.7 14 9.5 C 14 10.3 14.7 11 15.5 11 C 16.3 11 17 10.3 17 9.5 C 17 8.7 16.3 8 15.5 8 z M 6.9 14 C 7.7 16 9.7 17.5 12 17.5 C 14.3 17.5 16.3 16 17.1 14 L 6.9 14 z",
  "fit-screen": DB,
  "fit-width": VB,
  "help-circle": jB,
  information: UB,
  magnify: BB,
  meeting: YB,
  "menu-down": XB,
  "menu-up": NB,
  minus: HB,
  next: cB,
  "open-in-new": GB,
  pencil: Ck,
  pin: KB,
  unpin: JB,
  plus: Zz,
  "plus-circle-outline": tX,
  poll: dB,
  previous: M3,
  read: I0,
  restore: Vz,
  unread: I0,
  send: iX,
  "server-network-off": nX,
  "shield-star": sX,
  "shield-star-outline": rX,
  sort: aX,
  star: oX,
  unstar: cX,
  stars: kB,
  "swap-horizontal": hX,
  textbox: qB,
  "thumb-up": uX,
  "thumb-up-outline": pX,
  trashcan: fX,
  video: mX,
  "view-list-outline": wX,
  "view-module-outline": gX,
  "wifi-off": vX,
  ...OX,
  ...bX
}, z3 = {
  attach: Ez,
  create: Zz,
  "delete-forever": Iz,
  edit: Ck,
  modify: Ck,
  rename: SB,
  replace: dX,
  restore: Vz,
  subscribe: _z,
  trash: Lz,
  unsubscribe: zz,
  upload: yX,
  version: FB
}, L3 = {
  dropbox: "#0061fe",
  onedrive: "#0078d4",
  box: "#0161d5",
  "google-drive": "#1a73e8",
  zoom: "#4a8cff"
};
function Qk(n) {
  return n && n in _3 ? _3[n] : "";
}
c(Qk, "Fy");
d(Qk, "getIconMapping");
function Dz(n) {
  return n && n in E3 ? E3[n] : "";
}
c(Dz, "Mb");
d(Dz, "getSvgMapping");
function Wz(n) {
  return n && n in z3 ? z3[n] : "";
}
c(Wz, "zb");
d(Wz, "getFileActionIconMapping");
var Z0, sp;
let Gv = (Z0 = (sp = class extends pl {
  constructor(t) {
    if (super(t), this.it = Q, t.type !== Ty.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(t) {
    if (t === Q || t == null) return this._t = void 0, this.it = t;
    if (t === Sn) return t;
    if (typeof t != "string") throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (t === this.it) return this._t;
    this.it = t;
    const e = [t];
    return e.raw = e, this._t = { _$litType$: this.constructor.resultType, strings: e, values: [] };
  }
}, c(sp, "ia"), sp), d(Z0, "e"), Z0);
Gv.directiveName = "unsafeHTML", Gv.resultType = 1;
const Xo = ya(Gv);
var rp;
const qz = (rp = class extends Gv {
}, c(rp, "Yp"), rp);
d(qz, "t");
let Mk = qz;
Mk.directiveName = "unsafeSVG", Mk.resultType = 2;
const I3 = ya(Mk), ZP = Qt`[part~=wy-icon]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-icon][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-icon-first]{margin-left:calc(-.5 * var(--wy-size, 1rem))}[part~=wy-icon-last]{margin-right:calc(-.5 * var(--wy-size, 1rem))}[part~=wy-icon-padded]{margin:16.66666667%}[part~=wy-icon-inline]{vertical-align:-.25em}[part~=wy-icon-overlay]{position:absolute;bottom:0;right:0;border-radius:50%}:host(wy-icon-stack),[part~=wy-icon-stack]{display:inline-flex;position:relative;line-height:1}[part~=wy-icon-stack-layer]{position:absolute}[part~=wy-icon-stack-overlay]{position:absolute;bottom:0;right:0;border-radius:50%;width:calc(var(--wy-component-icon-width) / 2);height:calc(var(--wy-component-icon-height) / 2)}[part~=wy-icon-current-color]{fill:currentColor}[part~=wy-icon-state]{transition:opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1)));align-self:center;justify-self:center;margin:auto;opacity:0}[part~=wy-icon-state][part~=wy-active]{opacity:1}[part~=wy-icon-display]{color:var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));border-radius:var(--wy-component-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem));margin:auto}[part~=wy-icon-display-icon]{color:var(--wy-component-color);--wy-component-icon-width: calc(4 * var(--wy-size, 1rem));--wy-component-icon-height: calc(4 * var(--wy-size, 1rem));padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem))}[part~=wy-icon-display-text],[part~=wy-icon-display-meta]{color:var(--wy-component-color);padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem));text-align:center}[part~=wy-icon-color-primary]{fill:var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-icon-color-secondary]{fill:var(--wy-secondary, var(--wy-secondary-40, #3b6a1c))}[part~=wy-icon-color-tertiary]{fill:var(--wy-tertiary, var(--wy-tertiary-40, #3b6a1c))}[part~=wy-icon-color-surface]{fill:var(--wy-surface, var(--wy-neutral-99, #fcfcff))}[part~=wy-icon-color-surface-variant]{fill:var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb))}[part~=wy-icon-color-error]{fill:var(--wy-error, var(--wy-error-40, #ba1824))}[part~=wy-icon-color-warning]{fill:var(--wy-warning, var(--wy-warning-70, #afb140))}[part~=wy-icon-color-blue]{fill:var(--wy-blue, var(--wy-blue-light, #89a9fc))}[part~=wy-icon-color-indigo]{fill:var(--wy-indigo, var(--wy-indigo-light, #9185de))}[part~=wy-icon-color-purple]{fill:var(--wy-purple, var(--wy-purple-light, #c675b7))}[part~=wy-icon-color-pink]{fill:var(--wy-pink, var(--wy-pink-light, #d57194))}[part~=wy-icon-color-red]{fill:var(--wy-red, var(--wy-red-light, #db726c))}[part~=wy-icon-color-orange]{fill:var(--wy-orange, var(--wy-orange-light, #e89a3a))}[part~=wy-icon-color-yellow]{fill:var(--wy-yellow, var(--wy-yellow-light, #afb140))}[part~=wy-icon-color-green]{fill:var(--wy-green, var(--wy-green-light, #00a38b))}[part~=wy-icon-color-teal]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a8))}[part~=wy-icon-color-cyan]{fill:var(--wy-cyan, var(--wy-cyan-light, #0082a1))}[part~=wy-icon-color-gray]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-icon-color-black]{fill:var(--wy-black, var(--wy-black, #000000))}[part~=wy-icon-color-white]{fill:var(--wy-white, var(--wy-white, #ffffff))}[part*=wy-kind-]{fill:var(--wy-gray, var(--wy-gray-light, #76777a))}[part~=wy-kind-archive]{fill:var(--wy-orange, var(--wy-orange-light, #e89a3a))}[part~=wy-kind-audio]{fill:var(--wy-teal, var(--wy-teal-light, #00a0a8))}[part~=wy-kind-code]{fill:var(--wy-green, var(--wy-green-light, #00a38b))}[part~=wy-kind-document]{fill:var(--wy-blue, var(--wy-blue-light, #89a9fc))}[part~=wy-kind-email]{fill:var(--wy-red, var(--wy-red-light, #db726c))}[part~=wy-kind-presentation]{fill:var(--wy-orange, var(--wy-orange-light, #e89a3a))}[part~=wy-kind-spreadsheet]{fill:var(--wy-green, var(--wy-green-light, #00a38b))}[part~=wy-kind-image]{fill:var(--wy-pink, var(--wy-pink-light, #d57194))}[part~=wy-kind-text]{fill:var(--wy-cyan, var(--wy-cyan-light, #0082a1))}[part~=wy-kind-video]{fill:var(--wy-purple, var(--wy-purple-light, #c675b7))}[part~=wy-ext-pdf]{fill:var(--wy-red, var(--wy-red-light, #db726c))}[part~=wy-kind-text-icon]{width:calc(1.25 * var(--wy-size, 1rem));height:calc(1.25 * var(--wy-size, 1rem));vertical-align:calc(-.3125 * var(--wy-size, 1rem))}`;
var $X = Object.defineProperty, xX = Object.getOwnPropertyDescriptor, ke = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? xX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && $X(t, e, s), s;
}, "__decorateClass$18"), V0, ap;
let de = (V0 = (ap = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.color = "", this.size = 24, this.path = R3, this.inline = !1, this.first = !1, this.last = !1, this.padded = !1, this.layer = !1, this.state = !1, this.active = !1, this.uniqueId = `wy-icon-${ey()}`;
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("name") && this.name && (this.path = Qk(this.name) || R3, this.overlayPath = Qk(this.overlayName) || this.overlayPath, this.nativeIconColor = this.color === "native" && L3[this.name] || void 0, this.nativeOverlayColor = this.overlayName && L3[this.overlayName] || void 0);
  }
  render() {
    const t = this.kind ? YS(this.kind) : this.kind, e = this.ext?.startsWith(".") ? this.ext.substring(1) : this.ext, i = {
      "wy-icon": !0,
      "wy-icon-current-color": !t && !this.color,
      ["wy-kind-" + t]: !!t,
      ["wy-ext-" + e]: !!e,
      ["wy-icon-color-" + this.color]: !!this.color,
      "wy-icon-first": this.first,
      "wy-icon-last": this.last,
      "wy-icon-padded": this.padded,
      "wy-icon-inline": this.inline,
      "wy-icon-stack-layer": this.layer,
      "wy-icon-state": this.state,
      "wy-active": this.active
    }, s = this.size !== 24, r = this.size / 16, a = s ? `width: var(--wy-component-icon-width, calc(${r} * var(--wy-size, 1rem))); height: var(--wy-component-icon-height, calc(${r} * var(--wy-size, 1rem)));` : "", o = this.svg && Dz(this.svg);
    return this.overlayPath ? [
      v`
          <style>
            .icon-mask-bg {
              width: var(--wy-component-icon-width, calc(${r} * var(--wy-size, 1rem)));
              height: var(--wy-component-icon-height, calc(${r} * var(--wy-size, 1rem)));
              fill: white;
            }

            .icon-mask {
              width: calc(var(--wy-component-icon-width, calc(${r} * var(--wy-size, 1rem))));
              height: calc(var(--wy-component-icon-height, calc(${r} * var(--wy-size, 1rem))));
              ry: calc(var(--wy-border-radius-pill, var(--wy-border-radius, 50%)));
              x: calc(var(--wy-component-icon-width, calc(${r} * var(--wy-size, 1rem))) / 2);
              y: calc(var(--wy-component-icon-height, calc(${r} * var(--wy-size, 1rem))) / 2);
              stroke: black;
              stroke-width: 4px;
              fill: black;
            }
          </style>
        `,
      v`
          <wy-icon-stack style="${a}">
            <svg
              part=${Me(i)}
              viewBox="0 0 24 24"
              width="${this.size}"
              height="${this.size}"
              style="mask-image: url(#${this.uniqueId}-mask); -webkit-mask-image: url(#${this.uniqueId}-mask);"
            >
              <defs>
                <mask id="${this.uniqueId}-mask">
                  <rect class="icon-mask-bg" />
                  <rect class="icon-mask" />
                </mask>
              </defs>
              ${o ? I3(o) : v3`
          <path d="${this.path}" style="fill: ${Ct(this.nativeIconColor)}" />
        `}
              <!--rect width="24" height="24" fill="transparent" /-->
            </svg>
            <svg part="wy-icon-stack-overlay" viewBox="0 0 24 24" width="${this.size / 2}" height="${this.size / 2}">
              <path d="${this.overlayPath}" style="fill: ${Ct(this.nativeOverlayColor)}" />
              <!--rect width="24" height="24" fill="transparent" /-->
            </svg>
          </wy-icon-stack>
        `
    ] : v`
      <svg
        part=${Me(i)}
        style="${a}"
        viewBox="0 0 24 24"
        width="${this.size}"
        height="${this.size}"
      >
        ${o ? I3(o) : v3`
          <path d="${this.path}" style="fill: ${Ct(this.nativeIconColor)}" />
        `}
        <!--rect width="24" height="24" fill="transparent" /-->
      </svg>
    `;
  }
}, c(ap, "sa"), ap), d(V0, "WyIcon"), V0);
de.styles = [
  Ie,
  ZP,
  Tt
];
ke([
  O()
], de.prototype, "name", 2);
ke([
  O()
], de.prototype, "overlayName", 2);
ke([
  O()
], de.prototype, "svg", 2);
ke([
  O()
], de.prototype, "color", 2);
ke([
  O({ type: Number })
], de.prototype, "size", 2);
ke([
  O()
], de.prototype, "kind", 2);
ke([
  O()
], de.prototype, "ext", 2);
ke([
  O({ attribute: !1 })
], de.prototype, "path", 2);
ke([
  O({ attribute: !1 })
], de.prototype, "overlayPath", 2);
ke([
  O({ type: Boolean })
], de.prototype, "inline", 2);
ke([
  O({ type: Boolean })
], de.prototype, "first", 2);
ke([
  O({ type: Boolean })
], de.prototype, "last", 2);
ke([
  O({ type: Boolean })
], de.prototype, "padded", 2);
ke([
  O({ type: Boolean })
], de.prototype, "layer", 2);
ke([
  O({ type: Boolean })
], de.prototype, "state", 2);
ke([
  O({ type: Boolean })
], de.prototype, "active", 2);
ke([
  F()
], de.prototype, "nativeIconColor", 2);
ke([
  F()
], de.prototype, "nativeOverlayColor", 2);
de = ke([
  X("wy-icon")
], de);
var D0, op;
let Tk = (D0 = (op = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this);
  }
  render() {
    return v`<slot></slot>`;
  }
}, c(op, "ra"), op), d(D0, "WyIconStack"), D0);
Tk.styles = [Ie, ZP];
Tk = ke([
  X("wy-icon-stack")
], Tk);
var W0, lp;
let Ak = (W0 = (lp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this);
  }
  render() {
    return v`
      <div part="wy-icon-display-icon">
        <slot></slot>
      </div>
      <div part="wy-icon-display-text">
        <slot name="text"></slot>
      </div>
      <div part="wy-icon-display-meta">
        <slot name="meta"></slot>
      </div>
    `;
  }
}, c(lp, "na"), lp), d(W0, "WyIconDisplay"), W0);
Ak.styles = [Ie, ZP];
Ak = ke([
  X("wy-icon-display")
], Ak);
var kX = Object.defineProperty, SX = Object.getOwnPropertyDescriptor, Xi = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? SX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && kX(t, e, s), s;
}, "__decorateClass$17"), q0, cp;
let ss = (q0 = (cp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.size = 32, this.src = "", this.name = "", this.description = "", this.isAgent = !1;
  }
  render() {
    const t = this.size / 16;
    let e;
    !this.src && this.name && (e = UR(this.name));
    const i = {
      "wy-avatar-shape": !0,
      "wy-avatar-img": !!this.src,
      "wy-avatar-initials": !this.src,
      "wy-presence-mask": this.presence === zP.Active
    };
    return v`
      ${this.src ? v`
            <img
              alt=""
              title="${this.name}${this.description ? ` • ${this.description}` : ""}"
              part=${Me(i)}
              style="--wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));"
              height="${this.size}"
              width="${this.size}"
              src="${this.src}"
              decoding="async"
              loading="lazy"
            />
          ` : v`
            <div
              part=${Me(i)}
              style="--wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));"
              title="${this.name}${this.description ? ` • ${this.description}` : ""}"
            >
              <span part="wy-avatar-initials-text">${e}</span>
            </div>
          `}
      ${this.isAgent ? v`<wy-icon part="wy-avatar-type" name="agent" size="${this.size / 3 * 1.25}"></wy-icon>` : Q}
      ${this.presence && !this.isAgent ? v`<wy-presence .status=${this.presence} id=${this.id}></wy-presence>` : Q}
    `;
  }
}, c(cp, "aa"), cp), d(q0, "WyAvatar"), q0);
ss.styles = [Ie, LP, Rz];
Xi([
  O({ type: Number })
], ss.prototype, "size", 2);
Xi([
  O()
], ss.prototype, "src", 2);
Xi([
  O()
], ss.prototype, "name", 2);
Xi([
  O()
], ss.prototype, "description", 2);
Xi([
  O({ type: Boolean, reflect: !0 })
], ss.prototype, "isAgent", 2);
Xi([
  O()
], ss.prototype, "presence", 2);
ss = Xi([
  X("wy-avatar")
], ss);
var j0, hp;
let No = (j0 = (hp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.size = 32, this.uniqueId = `wy-avatar-${ey()}`;
  }
  render() {
    if (!this.user)
      return Q;
    const t = this.size / 16, e = (this.members || []).filter((r) => r.id !== this.user?.id).slice(0, 2).reverse(), i = e?.shift() || this.user, s = e?.shift() || (i !== this.user ? this.user : void 0);
    return [
      v`
        <style>
          :host {
            --wy-component-avatar-size: calc(${t} * var(--wy-size, 1rem));
          }

          .avatar-mask-bg {
            width: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            height: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            fill: white;
          }

          .avatar-mask {
            width: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            height: calc(${t * 2 / 3} * var(--wy-size, 1rem));
            ry: var(--wy-avatar-border-radius, var(--wy-border-radius-pill, var(--wy-border-radius, 50%)));
            x: calc(${t / 3} * var(--wy-size, 1rem));
            y: calc(${t / 3} * var(--wy-size, 1rem));
            stroke: black;
            stroke-width: 4px;
            fill: black;
          }
        </style>
      `,
      v`
        <svg>
          <defs>
            <mask id="${this.uniqueId}-mask">
              <rect class="avatar-mask-bg" />
              <rect class="avatar-mask" />
            </mask>
          </defs>
        </svg>
      `,
      v`
        <wy-avatar
          part="wy-avatar-back"
          style="mask-image: url(#${this.uniqueId}-mask); -webkit-mask-image: url(#${this.uniqueId}-mask);"
          .src=${s?.avatar_url}
          .name=${s?.name}
          size=${this.size * 2 / 3}
        ></wy-avatar>
        <wy-avatar
          part="wy-avatar-front"
          .src=${i.avatar_url}
          .name=${i.name}
          .isAgent=${i.is_agent}
          size=${this.size * 2 / 3}
        ></wy-avatar>
      `
    ];
  }
}, c(hp, "oa"), hp), d(j0, "WyAvatarGroup"), j0);
No.styles = [
  Ie,
  LP,
  Tt
];
Xi([
  O({ type: Number })
], No.prototype, "size", 2);
Xi([
  O({
    type: Array,
    attribute: !1
  })
], No.prototype, "members", 2);
Xi([
  xe({ context: Ub, subscribe: !0 }),
  F()
], No.prototype, "user", 2);
No = Xi([
  X("wy-avatar-group")
], No);
var F0, dp;
let Kv = (F0 = (dp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this);
  }
  render() {
    return v`
      <slot></slot>
      ${this.description ? v`
        <div part="wy-avatar-description">${this.description}</div>
          ` : Q}
      `;
  }
}, c(dp, "ca"), dp), d(F0, "WyAvatarHeader"), F0);
Kv.styles = [Ie, LP];
Xi([
  O()
], Kv.prototype, "description", 2);
Kv = Xi([
  X("wy-avatar-header")
], Kv);
const PX = Qt`[part~=wy-progress]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-progress]:not([width]),[part~=wy-progress][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress]:not([height]),[part~=wy-progress][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress-padded]{margin:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem))}[part~=wy-progress-reveal]{opacity:1;transition:width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),margin var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-progress-reveal]{width:0;height:0;opacity:0;margin:0}}[part~=wy-progress][part~=wy-primary]{color:var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-progress-remaining]{fill:none;stroke:var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb))}[part~=wy-progress-done]{fill:none;stroke:currentColor}[part~=wy-spinner]{align-self:center;justify-self:center;margin:auto}[part~=wy-spinner-padded]{margin:calc(1 * var(--wy-size, 1rem))}[part~=wy-spinner-overlay]{position:absolute;inset:0;margin:auto}[part~=wy-spinner-reveal]{opacity:1;transition:width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),margin var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-spinner-reveal]{width:0;height:0;opacity:0;margin:0}}[part~=wy-spinner-circle]{stroke-dasharray:1,100;stroke-dashoffset:0;transform-origin:center;fill:none!important}[part~=wy-spinner][part~=wy-spin]{animation:wy-rotate 1.4s linear infinite}[part~=wy-spinner-circle][part~=wy-spin]{animation:wy-dash 1.4s ease-in-out infinite,wy-color 2.8s ease-in-out infinite}@keyframes wy-rotate{to{transform:rotate(360deg)}}@keyframes wy-dash{0%{stroke-dasharray:1,100;stroke-dashoffset:0}50%{stroke-dasharray:44.5,100;stroke-dashoffset:-17.5}to{stroke-dasharray:44.5,100;stroke-dashoffset:-62}}@keyframes wy-color{0%,to{stroke:var(--wy-primary, var(--wy-primary-40, #006399))}25%{stroke:var(--wy-primary, var(--wy-primary-40, #006399))}50%{stroke:transparent}75%{stroke:var(--wy-primary, var(--wy-primary-40, #006399))}}`, CX = Qt`[part~=wy-progress]{display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;position:relative;width:var(--wy-component-icon-width);height:var(--wy-component-icon-height)}[part~=wy-progress]:not([width]),[part~=wy-progress][width=\"24\"]{width:var(--wy-component-icon-width, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress]:not([height]),[part~=wy-progress][height=\"24\"]{height:var(--wy-component-icon-height, calc(1.5 * var(--wy-size, 1rem)))}[part~=wy-progress-padded]{margin:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem))}[part~=wy-progress-reveal]{opacity:1;transition:width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),margin var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-progress-reveal]{width:0;height:0;opacity:0;margin:0}}[part~=wy-progress][part~=wy-primary]{color:var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-progress-remaining]{fill:none;stroke:var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb))}[part~=wy-progress-done]{fill:none;stroke:currentColor}`;
var QX = Object.defineProperty, MX = Object.getOwnPropertyDescriptor, fl = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? MX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && QX(t, e, s), s;
}, "__decorateClass$16"), U0, up;
let rs = (U0 = (up = class extends pt {
  constructor() {
    super(...arguments), this.shadowParts = new et(this), this.size = 24, this.noSpin = !1, this.padded = !1, this.overlay = !1, this.progress = NaN, this.reveal = !1;
  }
  render() {
    const t = this.noSpin && this.progress && 100 - this.progress || void 0;
    if (t !== void 0) {
      const e = Math.PI * 20, i = {
        "wy-progress": !0,
        "wy-primary": !0,
        "wy-progress-padded": this.padded,
        "wy-progress-reveal": this.reveal
      };
      return v`<svg
        part="${Me(i)}"
        viewBox="0 0 24 24"
        width=${this.size}
        height=${this.size}
        transform="rotate(-90)"
      >
        <circle
          part="wy-progress-circle wy-progress-remaining"
          cx="12"
          cy="12"
          r=${10}
          stroke-linecap="butt"
          stroke-width="2"
          fill="none"
          stroke="#eee"
        ></circle>
        <circle
          part="wy-progress-circle wy-progress-done"
          cx="12"
          cy="12"
          r=${10}
          stroke-dasharray=${e}
          stroke-dashoffset=${e * t / 100}
          stroke-linecap="butt"
          stroke-width="2"
          fill="none"
          stroke="currentColor"
          path-length="200"
        ></circle>
      </svg>`;
    } else {
      const e = {
        "wy-spinner": !0,
        "wy-spin": !this.noSpin,
        "wy-spinner-overlay": this.overlay,
        "wy-spinner-padded": this.padded,
        "wy-spinner-reveal": this.reveal
      }, i = {
        "wy-spinner-circle": !0,
        "wy-spin": !this.noSpin
      };
      return v`<svg
        part="${Me(e)}"
        width=${this.size}
        height=${this.size}
        viewBox="0 0 24 24"
        xmlns="http://www.w3.org/2000/svg"
      >
        <circle
          part="${Me(i)}"
          fill="none"
          cx="12"
          cy="12"
          r="11"
          stroke-linecap="butt"
          stroke-width="2"
        />
      </svg>`;
    }
  }
}, c(up, "la"), up), d(U0, "WySpinner"), U0);
rs.styles = [
  Ie,
  PX,
  CX,
  Tt
];
fl([
  O({ type: Number })
], rs.prototype, "size", 2);
fl([
  O({ type: Boolean })
], rs.prototype, "noSpin", 2);
fl([
  O({ type: Boolean })
], rs.prototype, "padded", 2);
fl([
  O({ type: Boolean })
], rs.prototype, "overlay", 2);
fl([
  O({ type: Number })
], rs.prototype, "progress", 2);
fl([
  O({ type: Boolean })
], rs.prototype, "reveal", 2);
rs = fl([
  X("wy-spinner")
], rs);
var TX = Object.defineProperty, AX = Object.getOwnPropertyDescriptor, VP = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? AX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && TX(t, e, s), s;
}, "__decorateClass$15"), B0, pp;
let ay = (B0 = (pp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.noNetwork = !1, this.handleUpdate = () => this.requestUpdate();
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("weavy")) {
      const e = t.get("weavy");
      e && e !== this.weavy && e.removeNetworkListener(this.handleUpdate), this.weavy && e !== this.weavy && this.weavy.addNetworkListener(this.handleUpdate);
    }
  }
  render() {
    return v`
      <div class="wy-empty">
        ${this.weavy && !this.noNetwork && this.weavy?.network.state === "unreachable" ? v`
              <wy-icon-display>
                <wy-icon name="server-network-off"></wy-icon>
                <span slot="text">${P("The server is offline, try again in a few minutes...")}</span>
                <wy-spinner slot="meta" ?hidden=${!this.weavy?.network.isPending}></wy-spinner>
              </wy-icon-display>
            ` : !this.noNetwork && this.weavy?.network.state === "offline" ? v`
              <wy-icon-display>
                <wy-icon name="wifi-off"></wy-icon>
                <span slot="text">${P("You are currently offline.")}</span>
                <wy-spinner slot="meta" ?hidden=${!this.weavy?.network.isPending}></wy-spinner>
              </wy-icon-display>
            ` : v`
              <slot>
                <wy-icon-display>
                  <wy-icon name="information"></wy-icon>
                  <slot slot="text" name="title">
                    <span>${P("Nothing to see here yet.")}</span>
                  </slot>
                </wy-icon-display>
              </slot>
            `}
      </div>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.weavy?.addNetworkListener(this.handleUpdate);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.weavy?.removeNetworkListener(this.handleUpdate);
  }
}, c(pp, "da"), pp), d(B0, "WyEmpty"), B0);
ay.styles = [
  ft,
  Tt
];
VP([
  xe({ context: Le, subscribe: !0 }),
  F()
], ay.prototype, "weavy", 2);
VP([
  O({ type: Boolean })
], ay.prototype, "noNetwork", 2);
ay = VP([
  X("wy-empty"),
  bt()
], ay);
const Z3 = /* @__PURE__ */ d((n, t, e) => {
  const i = /* @__PURE__ */ new Map();
  for (let s = t; s <= e; s++) i.set(n[s], s);
  return i;
}, "u"), Mi = ya(class extends pl {
  constructor(n) {
    if (super(n), n.type !== Ty.CHILD) throw Error("repeat() can only be used in text expressions");
  }
  dt(n, t, e) {
    let i;
    e === void 0 ? e = t : t !== void 0 && (i = t);
    const s = [], r = [];
    let a = 0;
    for (const o of n) s[a] = i ? i(o, a) : a, r[a] = e(o, a), a++;
    return { values: r, keys: s };
  }
  render(n, t, e) {
    return this.dt(n, t, e).values;
  }
  update(n, [t, e, i]) {
    const s = GU(n), { values: r, keys: a } = this.dt(t, e, i);
    if (!Array.isArray(s)) return this.ut = a, r;
    const o = this.ut ??= [], l = [];
    let h, u, p = 0, y = s.length - 1, m = 0, w = r.length - 1;
    for (; p <= y && m <= w; ) if (s[p] === null) p++;
    else if (s[y] === null) y--;
    else if (o[p] === a[m]) l[m] = La(s[p], r[m]), p++, m++;
    else if (o[y] === a[w]) l[w] = La(s[y], r[w]), y--, w--;
    else if (o[p] === a[w]) l[w] = La(s[p], r[w]), cm(n, l[w + 1], s[p]), p++, w--;
    else if (o[y] === a[m]) l[m] = La(s[y], r[m]), cm(n, s[p], s[y]), y--, m++;
    else if (h === void 0 && (h = Z3(a, m, w), u = Z3(o, p, y)), h.has(o[p])) if (h.has(o[y])) {
      const b = u.get(a[m]), $ = b !== void 0 ? s[b] : null;
      if ($ === null) {
        const x = cm(n, s[p]);
        La(x, r[m]), l[m] = x;
      } else l[m] = La($, r[m]), cm(n, s[p], $), s[b] = null;
      m++;
    } else E0(s[y]), y--;
    else E0(s[p]), p++;
    for (; m <= w; ) {
      const b = cm(n, l[w + 1]);
      La(b, r[m]), l[m++] = b;
    }
    for (; p <= y; ) {
      const b = s[p++];
      b !== null && E0(b);
    }
    return this.ut = a, nz(n, l), Sn;
  }
}), W1 = ya(class extends pl {
  constructor() {
    super(...arguments), this.key = Q;
  }
  render(n, t) {
    return this.key = n, t;
  }
  update(n, [t, e]) {
    return t !== this.key && (nz(n), this.key = t), e;
  }
});
function Ds(n) {
  n.stopPropagation();
}
c(Ds, "ks");
d(Ds, "inputConsume");
function jz(n) {
  n.key === "Escape" && (n.preventDefault(), n.stopPropagation(), n.target.value = "", n.target.dispatchEvent(new InputEvent("input", { data: "", inputType: "deleteContent" })));
}
c(jz, "Db");
d(jz, "inputClearOnEscape");
function _w(n) {
  n.key === "Escape" && (n.preventDefault(), n.stopPropagation(), n.target.blur(), n.target.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 })));
}
c(_w, "id");
d(_w, "inputBlurOnEscape");
function Fz(n) {
  n.key === "Enter" && n.target.blur();
}
c(Fz, "Hb");
d(Fz, "inputBlurOnEnter");
function Uz(n) {
  n.target.value ? jz(n) : _w(n);
}
c(Uz, "Vb");
d(Uz, "inputClearAndBlurOnEscape");
function DP(n) {
  n.key === "Enter" && (n.preventDefault(), n.stopPropagation(), n.target.click());
}
c(DP, "Rf");
d(DP, "clickOnEnter");
function Bz(n) {
  n.key === " " && (n.preventDefault(), n.stopPropagation());
}
c(Bz, "Ub");
d(Bz, "consumeOnSpace");
function Fe(n) {
  DP(n), Bz(n);
}
c(Fe, "we");
d(Fe, "clickOnEnterAndConsumeOnSpace");
function vi(n) {
  n.key === " " && (n.preventDefault(), n.stopPropagation(), n.target.click());
}
c(vi, "Te");
d(vi, "clickOnSpace");
function Jb(n) {
  DP(n), vi(n);
}
c(Jb, "yp");
d(Jb, "clickOnEnterAndSpace");
const Xt = ya(class extends pl {
  constructor(n) {
    if (super(n), n.type !== Ty.ATTRIBUTE || n.name !== "class" || n.strings?.length > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(n) {
    return " " + Object.keys(n).filter((t) => n[t]).join(" ") + " ";
  }
  update(n, [t]) {
    if (this.st === void 0) {
      this.st = /* @__PURE__ */ new Set(), n.strings !== void 0 && (this.nt = new Set(n.strings.join(" ").split(/\s/).filter((i) => i !== "")));
      for (const i in t) t[i] && !this.nt?.has(i) && this.st.add(i);
      return this.render(t);
    }
    const e = n.element.classList;
    for (const i of this.st) i in t || (e.remove(i), this.st.delete(i));
    for (const i in t) {
      const s = !!t[i];
      s === this.st.has(i) || this.nt?.has(i) || (s ? (e.add(i), this.st.add(i)) : (e.remove(i), this.st.delete(i)));
    }
    return Sn;
  }
});
function WP(n) {
  const t = [n];
  for (; n && n.parent; )
    n = n.parent, t.push(n);
  return t;
}
c(WP, "Of");
d(WP, "getEntityChain");
function qP(n, t, e) {
  return n.type === t && (!e || n.id === e.id);
}
c(qP, "Lf");
d(qP, "isEntityMatch");
function dg(n, t, e) {
  return WP(n).some((i) => i && qP(i, t, e));
}
c(dg, "Sd");
d(dg, "isEntityChainMatch");
function jP(n, t, e) {
  return WP(n).find((i) => i && qP(i, t, e));
}
c(jP, "If");
d(jP, "getEntityChainMatch");
function FP(n, t, e, i) {
  const s = jP(n, i);
  return s && s.parent ? dg(s.parent, t, e) : !1;
}
c(FP, "Tf");
d(FP, "hasEntityChildType");
async function UP(n, t, e) {
  let i;
  if (t && e.link.app?.id) {
    const r = await t.fetch(`/api/apps/${e.link.app.id}`);
    r.ok && (i = (await r.json()).metadata);
  }
  const s = new CustomEvent("wy-link", {
    bubbles: !0,
    composed: !0,
    cancelable: !0,
    detail: {
      link: {
        ...e.link,
        agent: BP(e)
      },
      app_type: e.link.app?.type && D_.get(e.link.app?.type) || tn.Unknown,
      source_name: i?.source_name,
      source_url: i?.source_url,
      source_data: i?.source_data
    }
  });
  return n.dispatchEvent(s);
}
c(UP, "Ff");
d(UP, "dispatchLinkEvent");
function BP(n) {
  return n.link.app?.type && Nv.has(n.link.app?.type) && n.actor.is_agent ? n.actor.uid : void 0;
}
c(BP, "Df");
d(BP, "getAgentName");
function XP(n) {
  const t = n.args;
  switch (n.template) {
    case "**{0}** added *{1}* to **{2}**": {
      const [e, i, s] = t;
      return {
        title: P(nt`${e} added ${i} to ${s}`),
        titleHtml: P(v`<strong>${e}</strong> added <em>${i}</em> to <strong>${s}</strong>`)
      };
    }
    case "**{0}** edited *{1}*": {
      const [e, i] = t;
      return {
        title: P(nt`${e} edited ${i}`),
        titleHtml: P(v`<strong>${e}</strong> edited <em>${i}</em>`)
      };
    }
    case '**{0}** commented on *{1}*: "{2}"': {
      const [e, i, s] = t;
      return {
        title: P(nt`${e} commented on ${i}`),
        titleHtml: P(v`<strong>${e}</strong> commented on <em>${i}</em>`),
        detail: s
      };
    }
    case '**{0}** commented on **{1}**: "{2}"': {
      const [e, i, s] = t;
      return {
        title: P(nt`${e} commented on ${i}`),
        titleHtml: P(v`<strong>${e}</strong> commented on <strong>${i}</strong>`),
        detail: s
      };
    }
    case '**{0}** replied to your post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(nt`${e} replied to your post`),
        titleHtml: P(v`<strong>${e}</strong> replied to your post`),
        detail: i
      };
    }
    case '**{0}** replied to a post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(nt`${e} replied to a post`),
        titleHtml: P(v`<strong>${e}</strong> replied to a post`),
        detail: i
      };
    }
    case '**{0}** mentioned you in a comment: "{1}"': {
      const [e, i] = t;
      return {
        title: P(nt`${e} mentioned you in a comment`),
        titleHtml: P(v`<strong>${e}</strong> mentioned you in a comment`),
        detail: i
      };
    }
    case '**{0}** posted in **{1}**: "{2}"': {
      const [e, i, s] = t;
      return {
        title: P(nt`${e} posted in ${i}`),
        titleHtml: P(v`<strong>${e}</strong> posted in <strong>${i}</strong>`),
        detail: s
      };
    }
    case '**{0}** mentioned you in a post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(nt`${e} mentioned you in a post`),
        titleHtml: P(v`<strong>${e}</strong> mentioned you in a post`),
        detail: i
      };
    }
    case 'New message from **{0}**: "{1}"': {
      const [e, i] = t;
      return {
        title: P(nt`New message from ${e}`),
        titleHtml: P(v`New message from <strong>${e}</strong>`),
        detail: i
      };
    }
    case '**{0}** sent a message in **{1}**: "{2}"': {
      const [e, i, s] = t;
      return {
        title: P(nt`${e} sent a message in ${i}`),
        titleHtml: P(v`<strong>${e}</strong> sent a message in <strong>${i}</strong>`),
        detail: s
      };
    }
    case '**{0}** mentioned you in a message: "{1}"': {
      const [e, i] = t;
      return {
        title: P(nt`${e} mentioned you in a message`),
        titleHtml: P(v`<strong>${e}</strong> mentioned you in a message`),
        detail: i
      };
    }
    case '**{0}** edited a post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(nt`${e} edited a post`),
        titleHtml: P(v`<strong>${e}</strong> edited a post`),
        detail: i
      };
    }
    case "**{0}** liked *{1}*": {
      const [e, i] = t;
      return {
        title: P(nt`${e} liked ${i}`),
        titleHtml: P(v`<strong>${e}</strong> liked <em>${i}</em>`)
      };
    }
    case "**{0}** reacted {2} to *{1}*": {
      const [e, i, s] = t;
      return {
        title: P(nt`${e} reacted ${i} to ${s}`),
        titleHtml: P(v`<strong>${e}</strong> reacted ${i} to <em>${s}</em>`)
      };
    }
    case '**{0}** liked your comment: "{1}"': {
      const [e, i] = t;
      return {
        title: P(nt`${e} liked your comment`),
        titleHtml: P(v`<strong>${e}</strong> liked your comment`),
        detail: i
      };
    }
    case '**{0}** reacted {1} to your comment: "{2}"': {
      const [e, i, s] = t;
      return {
        title: P(nt`${e} reacted ${i} to your comment`),
        titleHtml: P(v`<strong>${e}</strong> reacted ${i} to your comment`),
        detail: s
      };
    }
    case '**{0}** liked your message: "{1}"': {
      const [e, i] = t;
      return {
        title: P(nt`${e} liked your message`),
        titleHtml: P(v`<strong>${e}</strong> liked your message`),
        detail: i
      };
    }
    case '**{0}** reacted {1} to your message: "{2}"': {
      const [e, i, s] = t;
      return {
        title: P(nt`${e} reacted ${i} to your message`),
        titleHtml: P(v`<strong>${e}</strong> reacted ${i} to your message`),
        detail: s
      };
    }
    case '**{0}** liked your post: "{1}"': {
      const [e, i] = t;
      return {
        title: P(nt`${e} liked your post`),
        titleHtml: P(v`<strong>${e}</strong> liked your post`),
        detail: i
      };
    }
    case '**{0}** reacted {1} to your post: "{2}"': {
      const [e, i, s] = t;
      return {
        title: P(nt`${e} reacted ${i} to your post`),
        titleHtml: P(v`<strong>${e}</strong> reacted ${i} to your post`),
        detail: s
      };
    }
    case "**{0}** voted on your poll": {
      const [e] = t;
      return {
        title: P(nt`${e} voted on your poll`),
        titleHtml: P(v`<strong>${e}</strong> voted on your poll`)
      };
    }
    case "**{0}** and **{1}** voted on your poll": {
      const [e, i] = t;
      return {
        title: P(nt`${e} and ${i} voted on your poll`),
        titleHtml: P(v`<strong>${e}</strong> and <strong>${i}</strong> voted on your poll`)
      };
    }
    case "**{0}**, **{1}** and **{2}** voted on your poll": {
      const [e, i, s] = t;
      return {
        title: P(nt`${e}, ${i} and ${s} voted on your poll`),
        titleHtml: P(
          v`<strong>${e}</strong>, <strong>${i}</strong> and <strong>${s}</strong> voted on your poll`
        )
      };
    }
    case "**{0}** and {1} others voted on your poll": {
      const [e, i] = t;
      return {
        title: P(nt`${e} and ${i} others voted on your poll`),
        titleHtml: P(v`<strong>${e}</strong> and ${i} others voted on your poll`)
      };
    }
    default:
      return console.error(`Notification template not found! '${n.template}'`), { title: "", titleHtml: Q };
  }
}
c(XP, "Hf");
d(XP, "getNotificationText");
const Xz = Qt`[part~=wy-button]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399));color:var(--wy-component-color);background:var(--wy-component-background-color, transparent);height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;font-size:var(--wy-button-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-button-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));text-align:center;text-decoration:none;vertical-align:middle;cursor:pointer;-webkit-user-select:none;user-select:none;border:var(--wy-button-border-width, var(--wy-border-outline, 0)) solid var(--wy-outline, var(--wy-neutral-variant-50, #72777e));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));display:inline-flex;align-items:center;justify-content:center;gap:var(--wy-button-gap, var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))))));position:relative}[part~=wy-button][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .8);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .5)}[part~=wy-button]:disabled{opacity:var(--wy-opacity-disabled, 38%);cursor:unset;pointer-events:none}[part~=wy-button-state-layer]>*{z-index:3}[part~=wy-button-state-layer]:before{content:\"\";z-index:2;position:absolute;inset:0;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-button-state-layer]:hover:before{opacity:8%}[part~=wy-button-state-layer]:focus:before,[part~=wy-button-state-layer]:active:before,[part~=wy-button-state-layer][part~=wy-active]:before{opacity:12%}[part~=wy-button-icon]{--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));line-height:1;align-items:center;justify-content:center}[part~=wy-button-icon][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);padding:0;margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .5)}[part~=wy-button-icon][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * -.1)}[part~=wy-button-icon][part~=wy-active]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-button-icon-inline]{height:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));width:auto;min-width:var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));background:var(--wy-component-background-color);color:currentColor;display:flex;padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))}[part~=wy-button-icon-inline][part~=wy-button-sm]{height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);min-width:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6);padding:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .25);margin:calc(var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * .5)}[part~=wy-button-icon-inline][part~=wy-button-sm][part~=wy-button-state-layer]:before{margin:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * -.1)}[part~=wy-button-inline]{border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:calc(.5 * var(--wy-size, 1rem)) calc(.75 * var(--wy-size, 1rem));margin-inline:calc(-.25 * var(--wy-size, 1rem))}[part~=wy-button-primary]{--wy-component-background-color: var(--wy-primary, var(--wy-primary-40, #006399));--wy-component-color: var(--wy-on-primary, var(--wy-white, #ffffff))}[part~=wy-button-variant]{--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}[part~=wy-button-primary-text]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399))}[part~=wy-button-inherit-color]{--wy-component-color: currentColor}[part~=wy-button-no-color]{--wy-component-color: unset}[part=wy-button-link]{padding:0;color:var(--wy-link-color, var(--wy-primary, var(--wy-primary-40, #006399)));text-decoration:var(--wy-link-decoration, none)}[part=wy-button-link]:hover,[part=wy-button-link]:focus{text-decoration:var(--wy-link-hover-decoration, unset)}[part~=wy-buttons]{display:flex;align-items:center;flex-wrap:wrap;gap:calc(.5 * var(--wy-size, 1rem))}[part~=wy-buttons-reverse]{flex-direction:row-reverse}[part~=wy-buttons-floating]{position:sticky;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) 0;top:0;height:0;margin-bottom:calc(-1 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))));z-index:1030;--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}[part~=wy-buttons-sticky]{position:sticky;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));top:0;z-index:1030;--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}`, Nz = Qt`.wy-scroll-y{scroll-padding-top:var(--wy-scrollbar-adjust-top, 0);scroll-padding-bottom:var(--wy-scrollbar-adjust-bottom, 0)}.wy-scroll-y{overflow-y:auto;max-height:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-scroll-y:not(body){-webkit-overflow-scrolling:touch}.wy-scroll-y:not(.wy-scroll-x){overflow-x:hidden;touch-action:pan-y}.wy-scroll-x{overflow-x:auto;max-width:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}.wy-scroll-x:not(.wy-scroll-y){overflow-y:hidden;touch-action:pan-x}[part~=wy-tabs]{display:flex;overflow-y:hidden;padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));flex:1 1 auto}[part~=wy-tabs]{overflow-x:auto;max-width:100%;overflow-anchor:none;touch-action:pan-y,pan-x;will-change:scroll-position,opacity;backface-visibility:hidden}[part~=wy-tabs]{scrollbar-width:thin;scrollbar-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce)) transparent}[part~=wy-tabs]::-webkit-scrollbar{height:.375rem;width:.375rem;background:transparent;z-index:999}[part~=wy-tabs]::-webkit-scrollbar-track{background:transparent}[part~=wy-tabs]::-webkit-scrollbar-thumb{background-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));opacity:75%;border:0 solid transparent;border-radius:0;background-clip:padding-box}[part~=wy-tabs]::-webkit-scrollbar-thumb:hover{background-color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));opacity:75%}[part~=wy-tabs]::-webkit-scrollbar-thumb:window-inactive{background-color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));opacity:50%}[part~=wy-tab]{--wy-component-color: var(--wy-primary, var(--wy-primary-40, #006399));--wy-component-background-color: transparent;color:var(--wy-component-color);background:var(--wy-component-background-color);border:none;border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));display:inline-flex;flex-direction:column;align-items:center;justify-content:center;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));position:relative;text-align:center;text-decoration:none;cursor:pointer;-webkit-user-select:none;user-select:none}[part~=wy-tab] .wy-tab-icon{position:relative;padding:calc(.25 * var(--wy-size, 1rem)) calc(1 * var(--wy-size, 1rem));border-radius:var(--wy-button-border-radius, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))));display:inline-flex}[part~=wy-tab] .wy-tab-icon:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-tab]:hover .wy-tab-icon:before{opacity:8%}[part~=wy-tab]:focus .wy-tab-icon:before,[part~=wy-tab]:active .wy-tab-icon:before,[part~=wy-tab].wy-active .wy-tab-icon:before{opacity:12%}[part~=wy-tab] .wy-tab-label{font-family:var(--wy-button-font-family, var(--wy-font-family, unset)),inherit;line-height:var(--wy-button-line-height, var(--wy-line-height, 1.5));font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));font-weight:var(--wy-font-weight, unset)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]{padding:var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .5);margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) auto;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));height:calc(var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * .6)}[part~=wy-button-state-layer][part~=wy-button-sm][part~=wy-tab-sm]:before{margin:calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * -.25) calc(var(--wy-button-padding-x, calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) * 0)}`;
var RX = Object.defineProperty, EX = Object.getOwnPropertyDescriptor, Tn = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? EX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && RX(t, e, s), s;
}, "__decorateClass$14"), X0, fp;
let as = (X0 = (fp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this, !1), this.kind = "filled", this.active = !1, this.small = !1, this.disabled = !1;
  }
  render() {
    const t = {
      "wy-button": !0,
      "wy-active": !!this.active,
      "wy-disabled": !!this.disabled,
      "wy-button-inline": this.kind === "inline",
      "wy-button-icon": this.kind === "icon",
      "wy-button-icon-inline": this.kind === "icon-inline",
      "wy-button-link": this.kind === "link",
      "wy-button-primary": this.color === "primary",
      "wy-button-primary-text": this.color === "primary-text",
      "wy-button-inherit-color": this.color === "inherit",
      "wy-button-no-color": this.color === "none",
      "wy-button-variant": this.color === "variant",
      "wy-button-type-submit": this.type === "submit",
      "wy-button-type-reset": this.type === "reset",
      "wy-button-state-layer": this.kind !== "link" && !this.disabled,
      "wy-button-sm": !!this.small,
      "wy-tab": this.kind === "tab",
      "wy-tab-sm": this.kind === "tab" && !!this.small
    };
    return v`
      <button part=${Me(t)} type=${Ct(this.type)} ?disabled=${this.disabled}>
        <slot></slot>
      </button>
    `;
  }
}, c(fp, "ha"), fp), d(X0, "WyButton"), X0);
as.styles = [
  Ie,
  Xz,
  Nz,
  Tt,
  Qt`
      :host {
        position: relative;
      }
    `
];
Tn([
  O()
], as.prototype, "type", 2);
Tn([
  O()
], as.prototype, "kind", 2);
Tn([
  O({ type: Boolean })
], as.prototype, "active", 2);
Tn([
  O()
], as.prototype, "color", 2);
Tn([
  O({ type: Boolean })
], as.prototype, "small", 2);
Tn([
  O({ type: Boolean, reflect: !0 })
], as.prototype, "disabled", 2);
as = Tn([
  X("wy-button")
], as);
var N0, yp;
let Ho = (N0 = (yp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.tabs = !1, this.position = "normal", this.reverse = !1;
  }
  render() {
    const t = {
      "wy-buttons": !this.tabs,
      "wy-buttons-reverse": this.reverse,
      "wy-tabs": this.tabs,
      "wy-buttons-floating": this.position === "floating",
      "wy-buttons-sticky": this.position === "sticky"
    };
    return v`<div part=${Me(t)}><slot></slot></div>`;
  }
}, c(yp, "ua"), yp), d(N0, "WyButtons"), N0);
Ho.styles = [
  Ie,
  Xz,
  Nz,
  Tt
];
Tn([
  O({ type: Boolean })
], Ho.prototype, "tabs", 2);
Tn([
  O({ type: String })
], Ho.prototype, "position", 2);
Tn([
  O({ type: Boolean })
], Ho.prototype, "reverse", 2);
Ho = Tn([
  X("wy-buttons")
], Ho);
var _X = Object.defineProperty, zX = Object.getOwnPropertyDescriptor, NP = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? zX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && _X(t, e, s), s;
}, "__decorateClass$13"), H0, mp;
let oy = (H0 = (mp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.enableSwap = !1;
  }
  createRenderRoot() {
    return this;
  }
  dispatchRemove(t) {
    const e = new CustomEvent("embed-remove", { detail: { id: t } });
    return this.dispatchEvent(e);
  }
  dispatchSwap() {
    const t = new CustomEvent("embed-swap", { detail: {} });
    return this.dispatchEvent(t);
  }
  render() {
    const t = this.embed.type === "photo" && this.embed.provider_name.toLocaleLowerCase() === "giphy", e = !this.embed.html && !t;
    return v`
      <div class="wy-embed-actions">
        ${this.enableSwap ? v`<wy-button kind="icon" @click=${() => this.dispatchSwap()}
              ><wy-icon name="swap-horizontal"></wy-icon
            ></wy-button>` : v`<wy-button class="wy-embed-cycle"></wy-button>`}

        <wy-button kind="icon" @click=${() => this.dispatchRemove(this.embed.id)}
          ><wy-icon name="close-circle"></wy-icon
        ></wy-button>
      </div>

      ${this.embed.type === "audio" ? v`<div class="wy-embed-audio"></div>` : Q}
      ${this.embed.type === "video" && this.embed.html ? v`<div class="wy-embed-video"><div>${Xo(this.embed.html)}</div></div>` : Q}
      ${this.embed.type === "rich" ? v`<div class="wy-embed-rich"></div>` : Q}
      ${this.embed.type === "photo" && this.embed.thumbnail_url ? v`
            <div
              class=${Xt({
      "wy-embed-photo": !0,
      "wy-embed-photo-sm": (this.embed.thumbnail_width || 0) < 250
    })}>
              <a href=${this.embed.original_url} target="_blank">
                <img
                  src=${this.embed.thumbnail_url}
                  width=${Ct(this.embed.thumbnail_width)}
                  height=${Ct(this.embed.thumbnail_height)}
                  alt="" />
              </a>
            </div>
          ` : Q}
      ${this.embed.type !== "audio" && this.embed.type !== "video" && this.embed.type !== "rich" && this.embed.type !== "photo" && this.embed.thumbnail_url ? v`
            <div
              class=${Xt({
      "wy-embed-photo": !0,
      "wy-embed-photo-sm": (this.embed.thumbnail_width || 0) < 250
    })}>
              <a href=${this.embed.original_url} target="_blank">
                <img
                  src=${this.embed.thumbnail_url}
                  width=${Ct(this.embed.thumbnail_width)}
                  height=${Ct(this.embed.thumbnail_height)}
                  alt="" />
              </a>
            </div>
          ` : Q}
      ${e ? v` <div class="wy-embed-caption">
            <a class="wy-embed-link" href=${this.embed.original_url} target="_blank">${this.embed.host}</a>
            ${this.embed.title ? v`<div class="wy-embed-title">${this.embed.title}</div>` : Q}
            ${this.embed.description ? v`<div class="wy-embed-description">${this.embed.description}</div>` : Q}
          </div>` : Q}
    `;
  }
}, c(mp, "pa"), mp), d(H0, "WyEmbed"), H0);
oy.styles = ft;
NP([
  O({ attribute: !1 })
], oy.prototype, "embed", 2);
NP([
  O({ type: Boolean, attribute: !1 })
], oy.prototype, "enableSwap", 2);
oy = NP([
  X("wy-embed")
], oy);
var LX = Object.defineProperty, IX = Object.getOwnPropertyDescriptor, Ay = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? IX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && LX(t, e, s), s;
}, "__decorateClass$12"), Y0, wp;
let Ws = (Y0 = (wp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.name = "", this.previewUrl = "", this.url = "", this.size = 0;
  }
  render() {
    const t = this.size && this.size > 0 ? Qy(this.size) : null, e = Ei(this.name), { icon: i } = Mn(this.name), s = My(this.name), r = Ys(this.provider);
    return v`
      <a href=${this.previewUrl || this.url} class="wy-item wy-list-item-lg" target="_blank" title=${this.name}>
        <wy-icon name=${i} .overlayName=${r} size="48" kind=${s} ext=${e}></wy-icon>
        <div class="wy-item-body ">
          <div class="wy-item-title">${this.name}</div>
          ${t ? v`<div class="wy-item-text" title="${t}">${t}</div>` : ""}
        </div>
      </a>
    `;
  }
}, c(wp, "ya"), wp), d(Y0, "WyAttachment"), Y0);
Ws.styles = ft;
Ay([
  O()
], Ws.prototype, "name", 2);
Ay([
  O()
], Ws.prototype, "previewUrl", 2);
Ay([
  O()
], Ws.prototype, "url", 2);
Ay([
  O()
], Ws.prototype, "provider", 2);
Ay([
  O({ type: Number })
], Ws.prototype, "size", 2);
Ws = Ay([
  X("wy-attachment")
], Ws);
const Hz = "important", ZX = " !" + Hz, zw = ya(class extends pl {
  constructor(n) {
    if (super(n), n.type !== Ty.ATTRIBUTE || n.name !== "style" || n.strings?.length > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(n) {
    return Object.keys(n).reduce((t, e) => {
      const i = n[e];
      return i == null ? t : t + `${e = e.includes("-") ? e : e.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${i};`;
    }, "");
  }
  update(n, [t]) {
    const { style: e } = n.element;
    if (this.ft === void 0) return this.ft = new Set(Object.keys(t)), this.render(t);
    for (const i of this.ft) t[i] == null && (this.ft.delete(i), i.includes("-") ? e.removeProperty(i) : e[i] = null);
    for (const i in t) {
      const s = t[i];
      if (s != null) {
        this.ft.add(i);
        const r = typeof s == "string" && s.endsWith(ZX);
        i.includes("-") || r ? e.setProperty(i, r ? s.slice(0, -11) : s, r ? Hz : "") : e[i] = s;
      }
    }
    return Sn;
  }
});
function Lw(n) {
  const t = n;
  t && (t.complete && t.naturalHeight !== 0 ? t.classList.contains("wy-loading") ? t.decode().then(() => {
    t.classList.add("wy-loaded"), t.part.add("wy-loaded");
  }) : (t.classList.add("wy-loading", "wy-loaded"), t.part.add("wy-loading", "wy-loaded")) : (t.classList.add("wy-loading"), t.part.add("wy-loading")));
}
c(Lw, "sd");
d(Lw, "checkImageLoad");
function Iw(n) {
  const t = n.target;
  t.tagName === "IMG" && t.classList.contains("wy-loading") && !t.classList.contains("wy-loaded") && (t.classList.add("wy-loaded"), t.part.add("wy-loaded"));
}
c(Iw, "rd");
d(Iw, "imageLoaded");
const VX = Qt`[part~=wy-image]{padding:0;width:50%;position:relative;flex:auto;background-color:inherit;background-clip:content-box}[part~=wy-image-full-width]{flex-basis:100%!important}[part~=wy-image-grid]{display:flex;flex-wrap:wrap;justify-content:space-evenly;position:relative;overflow:hidden;column-gap:1px;row-gap:1px}[part~=wy-image-area]{display:block;height:100%;cursor:pointer}[part~=wy-image-content]{position:absolute;height:100%;width:100%;object-fit:contain}[part~=wy-image-content][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-image-content][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-image-content][part~=wy-loading][part~=wy-loaded]~[part~=wy-image-preview]{transition-delay:.15s;opacity:0}[part~=wy-image-grid-more]{position:absolute;line-height:100%;color:var(--wy-white, #ffffff);inset:0;display:flex;align-items:center;justify-content:center;font-size:calc(1.5 * var(--wy-size, 1rem));background:rgba(0,0,0,var(--wy-opacity-disabled, 38%))}`;
var DX = Object.defineProperty, WX = Object.getOwnPropertyDescriptor, HP = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? WX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && DX(t, e, s), s;
}, "__decorateClass$11"), G0, gp;
let ly = (G0 = (gp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.images = [], this.limit = 3;
  }
  dispatchFileOpen(t, e) {
    if (t.preventDefault(), !e.is_trashed) {
      const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
      this.dispatchEvent(i);
    }
  }
  render() {
    const t = this.images.length > this.limit ? this.images.length - this.limit : 0, e = this.images.slice(0, this.limit);
    return v`
      <div part="wy-image-grid">
        ${e.map((i, s) => {
      const r = i.width && i.height ? i.width / i.height : 1, a = 64, o = 2, l = r.toPrecision(5), h = (r * a).toPrecision(5) + "px", u = (100 / r).toPrecision(5) + "%", p = i.width + "px", y = i.width && i.width > 0 ? o * i.width + "px" : "none", m = this.images.length !== 2 && s === 0;
      return i.preview_url ? v`
            <a
              href="#"
              @click=${(w) => {
        !w.defaultPrevented && this.dispatchFileOpen(w, i);
      }}
              part=${Me({
        "wy-image": !0,
        "wy-image-full-width": m
      })}
              style=${zw({
        flexBasis: h,
        flexGrow: l,
        flexShrink: l,
        width: p,
        maxWidth: y
      })}>
              <div part="wy-image-area" style=${zw({ paddingBottom: u })}>
                <img
                  part="wy-image-content"
                  src=${i.preview_url}
                  ${rt(Lw)}
                  @load=${Iw}
                  alt=""
                  loading="lazy"
                  decoding="async" />
                ${s === e.length - 1 && t ? v`<span part="wy-image-grid-more">+${t}</span>` : ""}
              </div>
            </a>
          ` : Q;
    })}
      </div>
    `;
  }
}, c(gp, "wa"), gp), d(G0, "WyImageGrid"), G0);
ly.styles = [VX, Tt];
HP([
  O({ attribute: !1 })
], ly.prototype, "images", 2);
HP([
  O({ type: Number })
], ly.prototype, "limit", 2);
ly = HP([
  X("wy-image-grid")
], ly);
var qX = Object.defineProperty, jX = Object.getOwnPropertyDescriptor, Yz = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? jX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && qX(t, e, s), s;
}, "__decorateClass$10"), K0, vp;
let Jv = (K0 = (vp = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.files = [];
  }
  dispatchFileOpen(t, e) {
    t.preventDefault();
    const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
    return this.dispatchEvent(i);
  }
  render() {
    return this.settings?.annotations === "none" ? Q : v`
      <div part="wy-annotations">
        ${this.files.map((t) => {
      const e = t.size && t.size > 0 ? Qy(t.size) : null, i = Ei(t.name), { icon: s } = Mn(t.name), r = My(t.name), a = Ys(t.provider), o = `${t.name}${e ? ` • ${e}` : ""}`;
      return v`
            <wy-button
              part="wy-annotation"
              @click=${(l) => {
        !l.defaultPrevented && !t.is_trashed && this.dispatchFileOpen(l, t);
      }}
              kind="filled"
              small
              title=${o}
            >
              <wy-icon part="wy-annotation-icon" name=${s} .overlayName=${a} size="24" kind=${r} ext=${i}></wy-icon>
              <span part="wy-annotation-text">${t.name}</span>
            </wy-button>
          `;
    })}
      </div>
    `;
  }
}, c(vp, "fa"), vp), d(K0, "WyAttachmentsList"), K0);
Jv.styles = [Tt];
Yz([
  O({ attribute: !1 })
], Jv.prototype, "files", 2);
Jv = Yz([
  X("wy-annotations-list")
], Jv);
var FX = Object.defineProperty, UX = Object.getOwnPropertyDescriptor, Gz = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? UX(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && FX(t, e, s), s;
}, "__decorateClass$$"), J0, bp;
let Zw = (J0 = (bp = class extends pt {
  constructor() {
    super(...arguments), this.files = [];
  }
  //protected exportParts = new ShadowPartsController(this);
  createRenderRoot() {
    return this;
  }
  dispatchFileOpen(t, e) {
    t.preventDefault();
    const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
    return this.dispatchEvent(i);
  }
  render() {
    return v`
      <div class="wy-list wy-list-bordered">
        ${this.files.map((t) => {
      const e = t.size && t.size > 0 ? Qy(t.size) : null, i = Ei(t.name), { icon: s } = Mn(t.name), r = My(t.name), a = Ys(t.provider);
      return v`
            <a
              @click=${(o) => {
        !o.defaultPrevented && !t.is_trashed && this.dispatchFileOpen(o, t);
      }}
              class="wy-item wy-list-item"
              href="${Ct(t.download_url)}"
              title=${t.name}
            >
              <wy-icon name=${s} .overlayName=${a} size="48" kind=${r} ext=${i}></wy-icon>
              <div class="wy-item-body ">
                <div class="wy-item-title">${t.name}</div>
                ${e ? v`<div class="wy-item-text" title="${e}">${e}</div>` : ""}
              </div>
            </a>
          `;
    })}
      </div>
    `;
  }
}, c(bp, "ma"), bp), d(J0, "WyAttachmentsList"), J0);
Zw.styles = ft;
Gz([
  O({ attribute: !1 })
], Zw.prototype, "files", 2);
Zw = Gz([
  X("wy-attachments-list")
], Zw);
const tb = Math.min, Ha = Math.max, eb = Math.round, Gg = Math.floor, is = /* @__PURE__ */ d((n) => ({
  x: n,
  y: n
}), "createCoords"), BX = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, XX = {
  start: "end",
  end: "start"
};
function Rk(n, t, e) {
  return Ha(n, tb(t, e));
}
c(Rk, "Vy");
d(Rk, "clamp");
function ug(n, t) {
  return typeof n == "function" ? n(t) : n;
}
c(ug, "Ad");
d(ug, "evaluate");
function na(n) {
  return n.split("-")[0];
}
c(na, "yr");
d(na, "getSide");
function pg(n) {
  return n.split("-")[1];
}
c(pg, "Ed");
d(pg, "getAlignment");
function YP(n) {
  return n === "x" ? "y" : "x";
}
c(YP, "jf");
d(YP, "getOppositeAxis");
function GP(n) {
  return n === "y" ? "height" : "width";
}
c(GP, "Wf");
d(GP, "getAxisLength");
const NX = /* @__PURE__ */ new Set(["top", "bottom"]);
function Ms(n) {
  return NX.has(na(n)) ? "y" : "x";
}
c(Ms, "xs");
d(Ms, "getSideAxis");
function KP(n) {
  return YP(Ms(n));
}
c(KP, "Qf");
d(KP, "getAlignmentAxis");
function Kz(n, t, e) {
  e === void 0 && (e = !1);
  const i = pg(n), s = KP(n), r = GP(s);
  let a = s === "x" ? i === (e ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return t.reference[r] > t.floating[r] && (a = Vw(a)), [a, Vw(a)];
}
c(Kz, "n2");
d(Kz, "getAlignmentSides");
function Jz(n) {
  const t = Vw(n);
  return [ib(n), t, ib(t)];
}
c(Jz, "a2");
d(Jz, "getExpandedPlacements");
function ib(n) {
  return n.replace(/start|end/g, (t) => XX[t]);
}
c(ib, "Su");
d(ib, "getOppositeAlignmentPlacement");
const V3 = ["left", "right"], D3 = ["right", "left"], HX = ["top", "bottom"], YX = ["bottom", "top"];
function tL(n, t, e) {
  switch (n) {
    case "top":
    case "bottom":
      return e ? t ? D3 : V3 : t ? V3 : D3;
    case "left":
    case "right":
      return t ? HX : YX;
    default:
      return [];
  }
}
c(tL, "l2");
d(tL, "getSideList");
function eL(n, t, e, i) {
  const s = pg(n);
  let r = tL(na(n), e === "start", i);
  return s && (r = r.map((a) => a + "-" + s), t && (r = r.concat(r.map(ib)))), r;
}
c(eL, "d2");
d(eL, "getOppositeAxisPlacements");
function Vw(n) {
  return n.replace(/left|right|bottom|top/g, (t) => BX[t]);
}
c(Vw, "cd");
d(Vw, "getOppositePlacement");
function iL(n) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...n
  };
}
c(iL, "h2");
d(iL, "expandPaddingObject");
function nL(n) {
  return typeof n != "number" ? iL(n) : {
    top: n,
    right: n,
    bottom: n,
    left: n
  };
}
c(nL, "u2");
d(nL, "getPaddingObject");
function Dw(n) {
  const {
    x: t,
    y: e,
    width: i,
    height: s
  } = n;
  return {
    width: i,
    height: s,
    top: e,
    left: t,
    right: t + i,
    bottom: e + s,
    x: t,
    y: e
  };
}
c(Dw, "ld");
d(Dw, "rectToClientRect");
function Ek(n, t, e) {
  let {
    reference: i,
    floating: s
  } = n;
  const r = Ms(t), a = KP(t), o = GP(a), l = na(t), h = r === "y", u = i.x + i.width / 2 - s.width / 2, p = i.y + i.height / 2 - s.height / 2, y = i[o] / 2 - s[o] / 2;
  let m;
  switch (l) {
    case "top":
      m = {
        x: u,
        y: i.y - s.height
      };
      break;
    case "bottom":
      m = {
        x: u,
        y: i.y + i.height
      };
      break;
    case "right":
      m = {
        x: i.x + i.width,
        y: p
      };
      break;
    case "left":
      m = {
        x: i.x - s.width,
        y: p
      };
      break;
    default:
      m = {
        x: i.x,
        y: i.y
      };
  }
  switch (pg(t)) {
    case "start":
      m[a] -= y * (e && h ? -1 : 1);
      break;
    case "end":
      m[a] += y * (e && h ? -1 : 1);
      break;
  }
  return m;
}
c(Ek, "qy");
d(Ek, "computeCoordsFromPlacement");
const GX = /* @__PURE__ */ d(async (n, t, e) => {
  const {
    placement: i = "bottom",
    strategy: s = "absolute",
    middleware: r = [],
    platform: a
  } = e, o = r.filter(Boolean), l = await (a.isRTL == null ? void 0 : a.isRTL(t));
  let h = await a.getElementRects({
    reference: n,
    floating: t,
    strategy: s
  }), {
    x: u,
    y: p
  } = Ek(h, i, l), y = i, m = {}, w = 0;
  for (let b = 0; b < o.length; b++) {
    const {
      name: $,
      fn: x
    } = o[b], {
      x: C,
      y: R,
      data: E,
      reset: A
    } = await x({
      x: u,
      y: p,
      initialPlacement: i,
      placement: y,
      strategy: s,
      middlewareData: m,
      rects: h,
      platform: a,
      elements: {
        reference: n,
        floating: t
      }
    });
    u = C ?? u, p = R ?? p, m = {
      ...m,
      [$]: {
        ...m[$],
        ...E
      }
    }, A && w <= 50 && (w++, typeof A == "object" && (A.placement && (y = A.placement), A.rects && (h = A.rects === !0 ? await a.getElementRects({
      reference: n,
      floating: t,
      strategy: s
    }) : A.rects), {
      x: u,
      y: p
    } = Ek(h, y, l)), b = -1);
  }
  return {
    x: u,
    y: p,
    placement: y,
    strategy: s,
    middlewareData: m
  };
}, "computePosition$1");
async function JP(n, t) {
  var e;
  t === void 0 && (t = {});
  const {
    x: i,
    y: s,
    platform: r,
    rects: a,
    elements: o,
    strategy: l
  } = n, {
    boundary: h = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: p = "floating",
    altBoundary: y = !1,
    padding: m = 0
  } = ug(t, n), w = nL(m), b = o[y ? p === "floating" ? "reference" : "floating" : p], $ = Dw(await r.getClippingRect({
    element: (e = await (r.isElement == null ? void 0 : r.isElement(b))) == null || e ? b : b.contextElement || await (r.getDocumentElement == null ? void 0 : r.getDocumentElement(o.floating)),
    boundary: h,
    rootBoundary: u,
    strategy: l
  })), x = p === "floating" ? {
    x: i,
    y: s,
    width: a.floating.width,
    height: a.floating.height
  } : a.reference, C = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(o.floating)), R = await (r.isElement == null ? void 0 : r.isElement(C)) ? await (r.getScale == null ? void 0 : r.getScale(C)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, E = Dw(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: o,
    rect: x,
    offsetParent: C,
    strategy: l
  }) : x);
  return {
    top: ($.top - E.top + w.top) / R.y,
    bottom: (E.bottom - $.bottom + w.bottom) / R.y,
    left: ($.left - E.left + w.left) / R.x,
    right: (E.right - $.right + w.right) / R.x
  };
}
c(JP, "Kf");
d(JP, "detectOverflow");
const KX = /* @__PURE__ */ d(function(n) {
  return n === void 0 && (n = {}), {
    name: "flip",
    options: n,
    async fn(t) {
      var e, i;
      const {
        placement: s,
        middlewareData: r,
        rects: a,
        initialPlacement: o,
        platform: l,
        elements: h
      } = t, {
        mainAxis: u = !0,
        crossAxis: p = !0,
        fallbackPlacements: y,
        fallbackStrategy: m = "bestFit",
        fallbackAxisSideDirection: w = "none",
        flipAlignment: b = !0,
        ...$
      } = ug(n, t);
      if ((e = r.arrow) != null && e.alignmentOffset)
        return {};
      const x = na(s), C = Ms(o), R = na(o) === o, E = await (l.isRTL == null ? void 0 : l.isRTL(h.floating)), A = y || (R || !b ? [Vw(o)] : Jz(o)), I = w !== "none";
      !y && I && A.push(...eL(o, b, w, E));
      const Z = [o, ...A], j = await JP(t, $), N = [];
      let ut = ((i = r.flip) == null ? void 0 : i.overflows) || [];
      if (u && N.push(j[x]), p) {
        const it = Kz(s, a, E);
        N.push(j[it[0]], j[it[1]]);
      }
      if (ut = [...ut, {
        placement: s,
        overflows: N
      }], !N.every((it) => it <= 0)) {
        var ct, K;
        const it = (((ct = r.flip) == null ? void 0 : ct.index) || 0) + 1, At = Z[it];
        if (At && (!(p === "alignment" && C !== Ms(At)) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        ut.every((Zt) => Ms(Zt.placement) === C ? Zt.overflows[0] > 0 : !0)))
          return {
            data: {
              index: it,
              overflows: ut
            },
            reset: {
              placement: At
            }
          };
        let kt = (K = ut.filter((Zt) => Zt.overflows[0] <= 0).sort((Zt, Dt) => Zt.overflows[1] - Dt.overflows[1])[0]) == null ? void 0 : K.placement;
        if (!kt)
          switch (m) {
            case "bestFit": {
              var wt;
              const Zt = (wt = ut.filter((Dt) => {
                if (I) {
                  const Wt = Ms(Dt.placement);
                  return Wt === C || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Wt === "y";
                }
                return !0;
              }).map((Dt) => [Dt.placement, Dt.overflows.filter((Wt) => Wt > 0).reduce((Wt, Oi) => Wt + Oi, 0)]).sort((Dt, Wt) => Dt[1] - Wt[1])[0]) == null ? void 0 : wt[0];
              Zt && (kt = Zt);
              break;
            }
            case "initialPlacement":
              kt = o;
              break;
          }
        if (s !== kt)
          return {
            reset: {
              placement: kt
            }
          };
      }
      return {};
    }
  };
}, "flip$1"), JX = /* @__PURE__ */ new Set(["left", "top"]);
async function sL(n, t) {
  const {
    placement: e,
    platform: i,
    elements: s
  } = n, r = await (i.isRTL == null ? void 0 : i.isRTL(s.floating)), a = na(e), o = pg(e), l = Ms(e) === "y", h = JX.has(a) ? -1 : 1, u = r && l ? -1 : 1, p = ug(t, n);
  let {
    mainAxis: y,
    crossAxis: m,
    alignmentAxis: w
  } = typeof p == "number" ? {
    mainAxis: p,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: p.mainAxis || 0,
    crossAxis: p.crossAxis || 0,
    alignmentAxis: p.alignmentAxis
  };
  return o && typeof w == "number" && (m = o === "end" ? w * -1 : w), l ? {
    x: m * u,
    y: y * h
  } : {
    x: y * h,
    y: m * u
  };
}
c(sL, "f2");
d(sL, "convertValueToCoords");
const tN = /* @__PURE__ */ d(function(n) {
  return n === void 0 && (n = 0), {
    name: "offset",
    options: n,
    async fn(t) {
      var e, i;
      const {
        x: s,
        y: r,
        placement: a,
        middlewareData: o
      } = t, l = await sL(t, n);
      return a === ((e = o.offset) == null ? void 0 : e.placement) && (i = o.arrow) != null && i.alignmentOffset ? {} : {
        x: s + l.x,
        y: r + l.y,
        data: {
          ...l,
          placement: a
        }
      };
    }
  };
}, "offset$1"), eN = /* @__PURE__ */ d(function(n) {
  return n === void 0 && (n = {}), {
    name: "shift",
    options: n,
    async fn(t) {
      const {
        x: e,
        y: i,
        placement: s
      } = t, {
        mainAxis: r = !0,
        crossAxis: a = !1,
        limiter: o = {
          fn: /* @__PURE__ */ d(($) => {
            let {
              x,
              y: C
            } = $;
            return {
              x,
              y: C
            };
          }, "fn")
        },
        ...l
      } = ug(n, t), h = {
        x: e,
        y: i
      }, u = await JP(t, l), p = Ms(na(s)), y = YP(p);
      let m = h[y], w = h[p];
      if (r) {
        const $ = y === "y" ? "top" : "left", x = y === "y" ? "bottom" : "right", C = m + u[$], R = m - u[x];
        m = Rk(C, m, R);
      }
      if (a) {
        const $ = p === "y" ? "top" : "left", x = p === "y" ? "bottom" : "right", C = w + u[$], R = w - u[x];
        w = Rk(C, w, R);
      }
      const b = o.fn({
        ...t,
        [y]: m,
        [p]: w
      });
      return {
        ...b,
        data: {
          x: b.x - e,
          y: b.y - i,
          enabled: {
            [y]: r,
            [p]: a
          }
        }
      };
    }
  };
}, "shift$1");
function fg() {
  return typeof window < "u";
}
c(fg, "Rd");
d(fg, "hasWindow");
function yl(n) {
  return tC(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
c(yl, "oc");
d(yl, "getNodeName");
function Qi(n) {
  var t;
  return (n == null || (t = n.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
c(Qi, "Be");
d(Qi, "getWindow");
function An(n) {
  var t;
  return (t = (tC(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : t.documentElement;
}
c(An, "Ei");
d(An, "getDocumentElement");
function tC(n) {
  return fg() ? n instanceof Node || n instanceof Qi(n).Node : !1;
}
c(tC, "Gf");
d(tC, "isNode");
function rn(n) {
  return fg() ? n instanceof Element || n instanceof Qi(n).Element : !1;
}
c(rn, "li");
d(rn, "isElement");
function Pn(n) {
  return fg() ? n instanceof HTMLElement || n instanceof Qi(n).HTMLElement : !1;
}
c(Pn, "zi");
d(Pn, "isHTMLElement");
function _k(n) {
  return !fg() || typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof Qi(n).ShadowRoot;
}
c(_k, "Ny");
d(_k, "isShadowRoot");
const iN = /* @__PURE__ */ new Set(["inline", "contents"]);
function Ry(n) {
  const {
    overflow: t,
    overflowX: e,
    overflowY: i,
    display: s
  } = an(n);
  return /auto|scroll|overlay|hidden|clip/.test(t + i + e) && !iN.has(s);
}
c(Ry, "ml");
d(Ry, "isOverflowElement");
const nN = /* @__PURE__ */ new Set(["table", "td", "th"]);
function rL(n) {
  return nN.has(yl(n));
}
c(rL, "x2");
d(rL, "isTableElement");
const sN = [":popover-open", ":modal"];
function yg(n) {
  return sN.some((t) => {
    try {
      return n.matches(t);
    } catch {
      return !1;
    }
  });
}
c(yg, "Od");
d(yg, "isTopLayer");
const rN = ["transform", "translate", "scale", "rotate", "perspective"], aN = ["transform", "translate", "scale", "rotate", "perspective", "filter"], oN = ["paint", "layout", "strict", "content"];
function tO(n) {
  const t = eO(), e = rn(n) ? an(n) : n;
  return rN.some((i) => e[i] ? e[i] !== "none" : !1) || (e.containerType ? e.containerType !== "normal" : !1) || !t && (e.backdropFilter ? e.backdropFilter !== "none" : !1) || !t && (e.filter ? e.filter !== "none" : !1) || aN.some((i) => (e.willChange || "").includes(i)) || oN.some((i) => (e.contain || "").includes(i));
}
c(tO, "mp");
d(tO, "isContainingBlock");
function aL(n) {
  let t = qs(n);
  for (; Pn(t) && !Yo(t); ) {
    if (tO(t))
      return t;
    if (yg(t))
      return null;
    t = qs(t);
  }
  return null;
}
c(aL, "M2");
d(aL, "getContainingBlock");
function eO() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
c(eO, "vp");
d(eO, "isWebKit");
const lN = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Yo(n) {
  return lN.has(yl(n));
}
c(Yo, "No");
d(Yo, "isLastTraversableNode");
function an(n) {
  return Qi(n).getComputedStyle(n);
}
c(an, "di");
d(an, "getComputedStyle$1");
function mg(n) {
  return rn(n) ? {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  } : {
    scrollLeft: n.scrollX,
    scrollTop: n.scrollY
  };
}
c(mg, "Ld");
d(mg, "getNodeScroll");
function qs(n) {
  if (yl(n) === "html")
    return n;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    n.assignedSlot || // DOM Element detected.
    n.parentNode || // ShadowRoot detected.
    _k(n) && n.host || // Fallback.
    An(n)
  );
  return _k(t) ? t.host : t;
}
c(qs, "_s");
d(qs, "getParentNode");
function eC(n) {
  const t = qs(n);
  return Yo(t) ? n.ownerDocument ? n.ownerDocument.body : n.body : Pn(t) && Ry(t) ? t : eC(t);
}
c(eC, "Zf");
d(eC, "getNearestOverflowAncestor");
function cy(n, t, e) {
  var i;
  t === void 0 && (t = []), e === void 0 && (e = !0);
  const s = eC(n), r = s === ((i = n.ownerDocument) == null ? void 0 : i.body), a = Qi(s);
  if (r) {
    const o = nb(a);
    return t.concat(a, a.visualViewport || [], Ry(s) ? s : [], o && e ? cy(o) : []);
  }
  return t.concat(s, cy(s, [], e));
}
c(cy, "Sc");
d(cy, "getOverflowAncestors");
function nb(n) {
  return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null;
}
c(nb, "Au");
d(nb, "getFrameElement");
function iC(n) {
  const t = an(n);
  let e = parseFloat(t.width) || 0, i = parseFloat(t.height) || 0;
  const s = Pn(n), r = s ? n.offsetWidth : e, a = s ? n.offsetHeight : i, o = eb(e) !== r || eb(i) !== a;
  return o && (e = r, i = a), {
    width: e,
    height: i,
    $: o
  };
}
c(iC, "Yf");
d(iC, "getCssDimensions");
function iO(n) {
  return rn(n) ? n : n.contextElement;
}
c(iO, "gp");
d(iO, "unwrapElement");
function Ya(n) {
  const t = iO(n);
  if (!Pn(t))
    return is(1);
  const e = t.getBoundingClientRect(), {
    width: i,
    height: s,
    $: r
  } = iC(t);
  let a = (r ? eb(e.width) : e.width) / i, o = (r ? eb(e.height) : e.height) / s;
  return (!a || !Number.isFinite(a)) && (a = 1), (!o || !Number.isFinite(o)) && (o = 1), {
    x: a,
    y: o
  };
}
c(Ya, "Kr");
d(Ya, "getScale");
const cN = /* @__PURE__ */ is(0);
function nC(n) {
  const t = Qi(n);
  return !eO() || !t.visualViewport ? cN : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
c(nC, "Xf");
d(nC, "getVisualOffsets");
function oL(n, t, e) {
  return t === void 0 && (t = !1), !e || t && e !== Qi(n) ? !1 : t;
}
c(oL, "S2");
d(oL, "shouldAddVisualOffsets");
function sa(n, t, e, i) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  const s = n.getBoundingClientRect(), r = iO(n);
  let a = is(1);
  t && (i ? rn(i) && (a = Ya(i)) : a = Ya(n));
  const o = oL(r, e, i) ? nC(r) : is(0);
  let l = (s.left + o.x) / a.x, h = (s.top + o.y) / a.y, u = s.width / a.x, p = s.height / a.y;
  if (r) {
    const y = Qi(r), m = i && rn(i) ? Qi(i) : i;
    let w = y, b = nb(w);
    for (; b && i && m !== w; ) {
      const $ = Ya(b), x = b.getBoundingClientRect(), C = an(b), R = x.left + (b.clientLeft + parseFloat(C.paddingLeft)) * $.x, E = x.top + (b.clientTop + parseFloat(C.paddingTop)) * $.y;
      l *= $.x, h *= $.y, u *= $.x, p *= $.y, l += R, h += E, w = Qi(b), b = nb(w);
    }
  }
  return Dw({
    width: u,
    height: p,
    x: l,
    y: h
  });
}
c(sa, "wr");
d(sa, "getBoundingClientRect");
function wg(n, t) {
  const e = mg(n).scrollLeft;
  return t ? t.left + e : sa(An(n)).left + e;
}
c(wg, "Id");
d(wg, "getWindowScrollBarX");
function sC(n, t) {
  const e = n.getBoundingClientRect(), i = e.left + t.scrollLeft - wg(n, e), s = e.top + t.scrollTop;
  return {
    x: i,
    y: s
  };
}
c(sC, "Jf");
d(sC, "getHTMLOffset");
function lL(n) {
  let {
    elements: t,
    rect: e,
    offsetParent: i,
    strategy: s
  } = n;
  const r = s === "fixed", a = An(i), o = t ? yg(t.floating) : !1;
  if (i === a || o && r)
    return e;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, h = is(1);
  const u = is(0), p = Pn(i);
  if ((p || !p && !r) && ((yl(i) !== "body" || Ry(a)) && (l = mg(i)), Pn(i))) {
    const m = sa(i);
    h = Ya(i), u.x = m.x + i.clientLeft, u.y = m.y + i.clientTop;
  }
  const y = a && !p && !r ? sC(a, l) : is(0);
  return {
    width: e.width * h.x,
    height: e.height * h.y,
    x: e.x * h.x - l.scrollLeft * h.x + u.x + y.x,
    y: e.y * h.y - l.scrollTop * h.y + u.y + y.y
  };
}
c(lL, "A2");
d(lL, "convertOffsetParentRelativeRectToViewportRelativeRect");
function cL(n) {
  return Array.from(n.getClientRects());
}
c(cL, "E2");
d(cL, "getClientRects");
function hL(n) {
  const t = An(n), e = mg(n), i = n.ownerDocument.body, s = Ha(t.scrollWidth, t.clientWidth, i.scrollWidth, i.clientWidth), r = Ha(t.scrollHeight, t.clientHeight, i.scrollHeight, i.clientHeight);
  let a = -e.scrollLeft + wg(n);
  const o = -e.scrollTop;
  return an(i).direction === "rtl" && (a += Ha(t.clientWidth, i.clientWidth) - s), {
    width: s,
    height: r,
    x: a,
    y: o
  };
}
c(hL, "R2");
d(hL, "getDocumentRect");
const W3 = 25;
function dL(n, t) {
  const e = Qi(n), i = An(n), s = e.visualViewport;
  let r = i.clientWidth, a = i.clientHeight, o = 0, l = 0;
  if (s) {
    r = s.width, a = s.height;
    const u = eO();
    (!u || u && t === "fixed") && (o = s.offsetLeft, l = s.offsetTop);
  }
  const h = wg(i);
  if (h <= 0) {
    const u = i.ownerDocument, p = u.body, y = getComputedStyle(p), m = u.compatMode === "CSS1Compat" && parseFloat(y.marginLeft) + parseFloat(y.marginRight) || 0, w = Math.abs(i.clientWidth - p.clientWidth - m);
    w <= W3 && (r -= w);
  } else h <= W3 && (r += h);
  return {
    width: r,
    height: a,
    x: o,
    y: l
  };
}
c(dL, "O2");
d(dL, "getViewportRect");
const hN = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function uL(n, t) {
  const e = sa(n, !0, t === "fixed"), i = e.top + n.clientTop, s = e.left + n.clientLeft, r = Pn(n) ? Ya(n) : is(1), a = n.clientWidth * r.x, o = n.clientHeight * r.y, l = s * r.x, h = i * r.y;
  return {
    width: a,
    height: o,
    x: l,
    y: h
  };
}
c(uL, "I2");
d(uL, "getInnerBoundingClientRect");
function zk(n, t, e) {
  let i;
  if (t === "viewport")
    i = dL(n, e);
  else if (t === "document")
    i = hL(An(n));
  else if (rn(t))
    i = uL(t, e);
  else {
    const s = nC(n);
    i = {
      x: t.x - s.x,
      y: t.y - s.y,
      width: t.width,
      height: t.height
    };
  }
  return Dw(i);
}
c(zk, "Wy");
d(zk, "getClientRectFromClippingAncestor");
function rC(n, t) {
  const e = qs(n);
  return e === t || !rn(e) || Yo(e) ? !1 : an(e).position === "fixed" || rC(e, t);
}
c(rC, "tm");
d(rC, "hasFixedPositionAncestor");
function pL(n, t) {
  const e = t.get(n);
  if (e)
    return e;
  let i = cy(n, [], !1).filter((o) => rn(o) && yl(o) !== "body"), s = null;
  const r = an(n).position === "fixed";
  let a = r ? qs(n) : n;
  for (; rn(a) && !Yo(a); ) {
    const o = an(a), l = tO(a);
    !l && o.position === "fixed" && (s = null), (r ? !l && !s : !l && o.position === "static" && s && hN.has(s.position) || Ry(a) && !l && rC(n, a)) ? i = i.filter((h) => h !== a) : s = o, a = qs(a);
  }
  return t.set(n, i), i;
}
c(pL, "T2");
d(pL, "getClippingElementAncestors");
function fL(n) {
  let {
    element: t,
    boundary: e,
    rootBoundary: i,
    strategy: s
  } = n;
  const r = [...e === "clippingAncestors" ? yg(t) ? [] : pL(t, this._c) : [].concat(e), i], a = r[0], o = r.reduce((l, h) => {
    const u = zk(t, h, s);
    return l.top = Ha(u.top, l.top), l.right = tb(u.right, l.right), l.bottom = tb(u.bottom, l.bottom), l.left = Ha(u.left, l.left), l;
  }, zk(t, a, s));
  return {
    width: o.right - o.left,
    height: o.bottom - o.top,
    x: o.left,
    y: o.top
  };
}
c(fL, "F2");
d(fL, "getClippingRect");
function yL(n) {
  const {
    width: t,
    height: e
  } = iC(n);
  return {
    width: t,
    height: e
  };
}
c(yL, "D2");
d(yL, "getDimensions");
function mL(n, t, e) {
  const i = Pn(t), s = An(t), r = e === "fixed", a = sa(n, !0, r, t);
  let o = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = is(0);
  function h() {
    l.x = wg(s);
  }
  if (c(h, "u"), d(h, "setLeftRTLScrollbarOffset"), i || !i && !r)
    if ((yl(t) !== "body" || Ry(s)) && (o = mg(t)), i) {
      const m = sa(t, !0, r, t);
      l.x = m.x + t.clientLeft, l.y = m.y + t.clientTop;
    } else s && h();
  r && !i && s && h();
  const u = s && !i && !r ? sC(s, o) : is(0), p = a.left + o.scrollLeft - l.x - u.x, y = a.top + o.scrollTop - l.y - u.y;
  return {
    x: p,
    y,
    width: a.width,
    height: a.height
  };
}
c(mL, "H2");
d(mL, "getRectRelativeToOffsetParent");
function q1(n) {
  return an(n).position === "static";
}
c(q1, "Vh");
d(q1, "isStaticPositioned");
function Lk(n, t) {
  if (!Pn(n) || an(n).position === "fixed")
    return null;
  if (t)
    return t(n);
  let e = n.offsetParent;
  return An(n) === e && (e = e.ownerDocument.body), e;
}
c(Lk, "Qy");
d(Lk, "getTrueOffsetParent");
function aC(n, t) {
  const e = Qi(n);
  if (yg(n))
    return e;
  if (!Pn(n)) {
    let s = qs(n);
    for (; s && !Yo(s); ) {
      if (rn(s) && !q1(s))
        return s;
      s = qs(s);
    }
    return e;
  }
  let i = Lk(n, t);
  for (; i && rL(i) && q1(i); )
    i = Lk(i, t);
  return i && Yo(i) && q1(i) && !tO(i) ? e : i || aL(n) || e;
}
c(aC, "em");
d(aC, "getOffsetParent");
const dN = /* @__PURE__ */ d(async function(n) {
  const t = this.getOffsetParent || aC, e = this.getDimensions, i = await e(n.floating);
  return {
    reference: mL(n.reference, await t(n.floating), n.strategy),
    floating: {
      x: 0,
      y: 0,
      width: i.width,
      height: i.height
    }
  };
}, "getElementRects");
function wL(n) {
  return an(n).direction === "rtl";
}
c(wL, "U2");
d(wL, "isRTL");
const uN = {
  convertOffsetParentRelativeRectToViewportRelativeRect: lL,
  getDocumentElement: An,
  getClippingRect: fL,
  getOffsetParent: aC,
  getElementRects: dN,
  getClientRects: cL,
  getDimensions: yL,
  getScale: Ya,
  isElement: rn,
  isRTL: wL
};
function oC(n, t) {
  return n.x === t.x && n.y === t.y && n.width === t.width && n.height === t.height;
}
c(oC, "im");
d(oC, "rectsAreEqual");
function gL(n, t) {
  let e = null, i;
  const s = An(n);
  function r() {
    var o;
    clearTimeout(i), (o = e) == null || o.disconnect(), e = null;
  }
  c(r, "n"), d(r, "cleanup");
  function a(o, l) {
    o === void 0 && (o = !1), l === void 0 && (l = 1), r();
    const h = n.getBoundingClientRect(), {
      left: u,
      top: p,
      width: y,
      height: m
    } = h;
    if (o || t(), !y || !m)
      return;
    const w = Gg(p), b = Gg(s.clientWidth - (u + y)), $ = Gg(s.clientHeight - (p + m)), x = Gg(u), C = {
      rootMargin: -w + "px " + -b + "px " + -$ + "px " + -x + "px",
      threshold: Ha(0, tb(1, l)) || 1
    };
    let R = !0;
    function E(A) {
      const I = A[0].intersectionRatio;
      if (I !== l) {
        if (!R)
          return a();
        I ? a(!1, I) : i = setTimeout(() => {
          a(!1, 1e-7);
        }, 1e3);
      }
      I === 1 && !oC(h, n.getBoundingClientRect()) && a(), R = !1;
    }
    c(E, "S"), d(E, "handleObserve");
    try {
      e = new IntersectionObserver(E, {
        ...C,
        // Handle <iframe>s
        root: s.ownerDocument
      });
    } catch {
      e = new IntersectionObserver(E, C);
    }
    e.observe(n);
  }
  return c(a, "o"), d(a, "refresh"), a(!0), r;
}
c(gL, "q2");
d(gL, "observeMove");
function lC(n, t, e, i) {
  i === void 0 && (i = {});
  const {
    ancestorScroll: s = !0,
    ancestorResize: r = !0,
    elementResize: a = typeof ResizeObserver == "function",
    layoutShift: o = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = i, h = iO(n), u = s || r ? [...h ? cy(h) : [], ...cy(t)] : [];
  u.forEach((x) => {
    s && x.addEventListener("scroll", e, {
      passive: !0
    }), r && x.addEventListener("resize", e);
  });
  const p = h && o ? gL(h, e) : null;
  let y = -1, m = null;
  a && (m = new ResizeObserver((x) => {
    let [C] = x;
    C && C.target === h && m && (m.unobserve(t), cancelAnimationFrame(y), y = requestAnimationFrame(() => {
      var R;
      (R = m) == null || R.observe(t);
    })), e();
  }), h && !l && m.observe(h), m.observe(t));
  let w, b = l ? sa(n) : null;
  l && $();
  function $() {
    const x = sa(n);
    b && !oC(b, x) && e(), b = x, w = requestAnimationFrame($);
  }
  return c($, "P"), d($, "frameLoop"), e(), () => {
    var x;
    u.forEach((C) => {
      s && C.removeEventListener("scroll", e), r && C.removeEventListener("resize", e);
    }), p?.(), (x = m) == null || x.disconnect(), m = null, l && cancelAnimationFrame(w);
  };
}
c(lC, "sm");
d(lC, "autoUpdate");
const vL = tN, bL = eN, OL = KX, $L = /* @__PURE__ */ d((n, t, e) => {
  const i = /* @__PURE__ */ new Map(), s = {
    platform: uN,
    ...e
  }, r = {
    ...s.platform,
    _c: i
  };
  return GX(n, t, {
    ...s,
    platform: r
  });
}, "computePosition");
function xL(n, t, e, i, s, r, a) {
  return new jt(n.queryClient, {
    mutationFn: /* @__PURE__ */ d(async () => await n.fetch(`/api/${s}/${i}/reactions`, {
      method: r ? "POST" : "DELETE",
      body: JSON.stringify({ content: r })
    }), "mutationFn"),
    onMutate: /* @__PURE__ */ d(() => {
      const o = e === "apps" && s === "posts" ? [s, t] : [e, t, s];
      Oe(n.queryClient, o, i, (l) => {
        hy(l, r, a);
      });
    }, "onMutate")
  });
}
c(xL, "N2");
d(xL, "reactionMutation");
function kL(n, t, e) {
  return {
    queryKey: [t, e, "reactions"],
    enabled: !1,
    queryFn: /* @__PURE__ */ d(async () => await (await n.fetch("/api/" + t + "/" + e + "/reactions")).json(), "queryFn")
  };
}
c(kL, "j2");
d(kL, "getReactionListOptions");
function hy(n, t, e) {
  return !t && !n.reactions?.data || (n.reactions || (n.reactions = { count: 0, data: [] }), n.reactions.data || (n.reactions.data = []), t ? n.reactions.data = [
    ...n.reactions.data.filter((i) => i.created_by?.id !== e.id),
    { content: t, created_by: e }
  ] : n.reactions.data && (n.reactions.data = [...n.reactions.data.filter((i) => i.created_by?.id !== e.id)])), n;
}
c(hy, "Ac");
d(hy, "updateReaction");
var pN = Object.defineProperty, fN = Object.getOwnPropertyDescriptor, cC = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? fN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && pN(t, e, s), s;
}, "__decorateClass$_"), t2, Op;
let dy = (t2 = (Op = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.noPadding = !1, this.show = !1, this.viewportRef = mt();
  }
  close() {
    this.show = !1;
    try {
      this.viewportRef.value?.popover ? this.viewportRef.value?.hidePopover() : this.viewportRef.value?.close();
    } catch {
    }
  }
  handleClose(t) {
    (t.type === "toggle" && t.newState === "closed" || t.type === "close") && (this.show = !1, this.dispatchEvent(new CustomEvent("close")), this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 })));
  }
  render() {
    return v`
      <dialog class="wy-dialog" tabindex="0" ${rt(this.viewportRef)} popover="auto">
        <div class="wy-sheet ${this.show ? "wy-show" : ""}">
          <slot name="header">
            <header class="wy-appbars">
              <nav class="wy-appbar">
                <wy-button kind="icon" @click=${() => this.close()}>
                  <wy-icon name="close"></wy-icon>
                </wy-button>
                <slot name="appbar-text" class="wy-appbar-text"></slot>
                <slot name="appbar-buttons" class="wy-appbar-buttons wy-appbar-buttons-last"></slot>
              </nav>
            </header>
          </slot>
          <div class="wy-sheet-body wy-scroll-y ${this.noPadding ? "wy-sheet-no-padding" : ""}">
            <slot></slot>
          </div>
        </div>
      </dialog>
    `;
  }
  updated(t) {
    if (t.has("show"))
      try {
        this.show ? this.viewportRef.value?.popover ? this.viewportRef.value?.showPopover() : this.viewportRef.value?.show() : this.viewportRef.value?.popover ? this.viewportRef.value?.hidePopover() : this.viewportRef.value?.close();
      } catch {
      }
    t.has("show") && this.show && this.viewportRef.value?.focus();
  }
  firstUpdated(t) {
    this.viewportRef.value?.addEventListener(
      this.viewportRef.value.popover ? "toggle" : "close",
      (e) => this.handleClose(e)
    );
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.close();
  }
}, c(Op, "va"), Op), d(t2, "WySheet"), t2);
dy.styles = [
  ft,
  Tt
];
cC([
  O({ type: Boolean })
], dy.prototype, "noPadding", 2);
cC([
  O({ type: Boolean })
], dy.prototype, "show", 2);
dy = cC([
  X("wy-sheet")
], dy);
const yN = Qt`[part~=wy-reaction]{font-size:calc(1.125 * var(--wy-size, 1rem))}[part~=wy-reactions]{display:inline-flex;align-items:center;column-gap:calc(.25 * var(--wy-size, 1rem))}[part~=wy-reactions] :first-child:not(:only-child){margin-left:calc(.25 * var(--wy-size, 1rem))}[part~=wy-reactions] :last-child:not(:only-child){margin-right:calc(.25 * var(--wy-size, 1rem))}[part~=wy-reaction-count]{margin:0 calc(.25 * var(--wy-size, 1rem)) 0;line-height:1;font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}[part~=wy-reaction-menu]{width:max-content;position:absolute;z-index:1000;border:none;--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);display:flex;margin:0;text-align:left;background-clip:padding-box;box-shadow:var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12));overflow:hidden;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));font-size:calc(1.25 * var(--wy-size, 1rem));border-radius:var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem))))}[part~=wy-reaction-picker]{display:flex;flex-direction:row;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}[part~=wy-reactions-line]{display:flex;align-items:center;padding-left:calc(.1875 * var(--wy-size, 1rem));padding-right:calc(.1875 * var(--wy-size, 1rem));gap:calc(.1875 * var(--wy-size, 1rem));justify-content:end}[part~=wy-reactions-line-reverse]{flex-direction:row-reverse;justify-content:start}[part~=wy-reactions-line-bottom]{position:absolute;bottom:calc(-1 * var(--wy-size, 1rem));right:calc(.25 * var(--wy-size, 1rem));z-index:1}[part~=wy-reactions-line-below]{position:relative;height:0;min-height:0;max-height:0;margin:calc(var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))) - var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(-1 * var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))) calc(-1 * var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));padding-left:calc(.125 * var(--wy-size, 1rem));padding-right:calc(.125 * var(--wy-size, 1rem));gap:calc(.125 * var(--wy-size, 1rem));flex:1 0 auto;justify-content:flex-end}`, SL = Qt`.wy-item{--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));position:relative;display:flex;align-items:center;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));text-decoration:none}.wy-list-item{min-height:calc(3 * var(--wy-size, 1rem))}.wy-list-item-lg{min-height:calc(4.5 * var(--wy-size, 1rem))}.wy-item-inner{display:flex;align-items:center;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));flex:1 1 100%}.wy-item-body{width:100%;min-width:0}.wy-item-rows{display:flex;flex-direction:column;width:100%;row-gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));min-width:0}.wy-item-rows:only-child{margin-inline-start:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-item-rows-compact{row-gap:0}.wy-item-rows-single{margin-inline-start:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))))}.wy-item-title{color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset))}.wy-item-title{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-item-title-lg{color:var(--wy-component-color);font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset))}.wy-item-title-lg{display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;overflow:hidden}.wy-item-text{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}.wy-item-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.wy-item-text .wy-icon{width:calc(1.25 * var(--wy-size, 1rem));height:calc(1.25 * var(--wy-size, 1rem));vertical-align:calc(-.3125 * var(--wy-size, 1rem))}.wy-item-quote{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e))}.wy-item-quote:before,.wy-item-quote:after{content:'\"'}.wy-item-actions{--wy-component-background-color: transparent;display:flex;align-items:center;justify-items:flex-end;flex:0 0 auto;margin:calc(-.25 * var(--wy-size, 1rem))}.wy-item-top{align-self:flex-start}.wy-item-actions-bottom{align-self:flex-start;margin-block:calc(-.5 * var(--wy-size, 1rem))}.wy-item-row{display:flex;align-items:center;column-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))}.wy-item-row .wy-item-title,.wy-item-row .wy-item-text{margin-right:auto}.wy-item-row .wy-meta{white-space:nowrap}.wy-item-right{margin-left:auto}.wy-item-hover{-webkit-user-select:none;user-select:none;cursor:pointer}.wy-item-hover:hover,.wy-item-hover:focus{--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);text-decoration:none}.wy-item-hover:active{--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-item-hover.wy-disabled,.wy-item-hover:disabled{opacity:var(--wy-opacity-disabled, 38%);pointer-events:none}.wy-item-hover.wy-active{--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-90, #cde5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-primary-10, #001d32));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-color:var(--wy-component-background-color)}.wy-item-trashed{text-decoration:line-through;opacity:var(--wy-opacity-disabled, 38%)}.wy-item-trashed.wy-item-hover:hover{opacity:1}`, PL = Qt`.wy-emoji-icon{display:inline-flex;justify-content:center;align-items:center;line-height:1;width:1em;height:1em;font-size:calc(1.25 * var(--wy-size, 1rem))}.wy-emoji-icon-sm{width:calc(1.125 * var(--wy-size, 1rem));height:calc(1.125 * var(--wy-size, 1rem));font-size:calc(1.125 * var(--wy-size, 1rem))}`;
var mN = Object.defineProperty, wN = Object.getOwnPropertyDescriptor, Re = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? wN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && mN(t, e, s), s;
}, "__decorateClass$Z"), e2, $p;
let $e = (e2 = ($p = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.directionX = "left", this.directionY = "up", this.small = !1, this.reactions = [], this.emojis = "", this.parentType = "apps", this.entityType = "messages", this.line = !1, this.lineReverse = !1, this.lineBottom = !1, this.lineBelow = !1, this._placement = "bottom-start", this.show = !1, this.showSheet = !1, this.buttonRef = mt(), this.menuRef = mt(), this.reactionListQuery = new ns(this), this._documentClickHandler = (t) => {
      this.show && (t.preventDefault(), this.menuRef.value?.popover || (this.show = !1));
    }, this.handleReaction = async (t) => {
      if (!this.weavy || !this.parentId || !this.user)
        return;
      const e = xL(
        this.weavy,
        this.parentId,
        this.parentType,
        this.entityId,
        this.entityType,
        this.reactedEmoji === t ? void 0 : t,
        this.user
      );
      this.reactedEmoji = t, await e.mutate(), this.reactionListQuery.observer?.refetch();
    };
  }
  handleClose(t) {
    (t.type === "toggle" && t.newState === "closed" || t.type === "click") && (this.show = !1, this.dispatchEvent(new CustomEvent("close")), this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 })));
  }
  handleClickToggle(t) {
    t.stopPropagation(), this.show = !this.show;
  }
  handleReactionsClick() {
    this.reactionListQuery.observer?.refetch(), this.showSheet = !this.showSheet, this.show = !1;
  }
  async willUpdate(t) {
    if (super.willUpdate(t), (t.has("weavy") || t.has("entityId") || t.has("showSheet")) && this.weavy && this.entityId && this.showSheet && await this.reactionListQuery.trackQuery(kL(this.weavy, this.entityType, this.entityId)), (t.has("reactions") || t.has("user")) && this.user && (this.reactedEmoji = this.reactions?.find((e) => e.created_by?.id === this.user?.id)?.content), (t.has("directionX") || t.has("directionY")) && (this._placement = this.directionX === "right" && this.directionY === "down" ? "bottom-start" : this.directionX === "left" && this.directionY === "down" ? "bottom-end" : this.directionX === "right" && this.directionY === "up" ? "top-start" : "top-end"), t.has("show") && (this.show && !this._computePositionCleanup && this.buttonRef.value && this.menuRef.value ? this._computePositionCleanup = lC(this.buttonRef.value, this.menuRef.value, () => {
      requestAnimationFrame(() => {
        this.buttonRef.value && this.menuRef.value && $L(this.buttonRef.value, this.menuRef.value, {
          placement: this._placement,
          strategy: this.menuRef.value.popover ? "absolute" : "fixed",
          middleware: [
            OL(),
            vL({ mainAxis: 0, alignmentAxis: -8 }),
            bL({ mainAxis: !0, crossAxis: !0, padding: 4, altBoundary: !0 })
          ]
        }).then(({ x: e, y: i }) => {
          this.menuRef.value && Object.assign(this.menuRef.value.style, {
            marginLeft: `${e}px`,
            marginTop: `${i}px`,
            top: 0,
            left: 0,
            position: this.menuRef.value.popover ? void 0 : "fixed",
            zIndex: this.menuRef.value.popover ? void 0 : 1075
          });
        });
      });
    }) : !this.show && this._computePositionCleanup && (this._computePositionCleanup(), this._computePositionCleanup = void 0)), this.show) {
      requestAnimationFrame(() => {
        document.addEventListener("click", this._documentClickHandler, { once: !0, capture: !0 });
      });
      try {
        this.menuRef.value?.showPopover();
      } catch {
      }
    } else
      try {
        this.menuRef.value?.hidePopover();
      } catch {
      }
    t.has("settings") && this.settings?.reactions && this.emojis != this.settings.reactions && (this.emojis = this.settings.reactions);
  }
  render() {
    const { data: t, isPending: e } = this.reactionListQuery.result ?? {};
    if (!this.emojis?.length)
      return Q;
    const i = this.emojis?.length === 1 ? this.emojis[0] : "", s = [
      ...new Map(this.reactions?.map((h) => [h.content, h])).values()
    ], r = {
      "wy-emoji-icon": !0,
      "wy-emoji-icon-sm": this.small
    }, a = i ? v`
          ${this.reactions && this.reactions?.length > 1 ? v`<wy-button
                kind="icon-inline"
                ?active=${this.showSheet}
                ?small=${this.small}
                @click=${() => this.handleReactionsClick()}
              >
                <div part="wy-reactions">
                  <span class=${Xt(r)}>
                    <small part="wy-reaction-count">${this.reactions.length}</small>
                  </span>
                </div>
              </wy-button>` : Q}

          <div>
            <wy-button
              part="wy-reaction-menu-button"
              kind="icon"
              ?small=${this.small}
              ?active=${this.reactedEmoji === i}
              @click=${() => {
      this.handleReaction(i);
    }}
              @keydown=${Fe}
              @keyup=${vi}
              title=${P("React", { desc: "Button action to react" })}
            >
              <span class=${Xt(r)} title=${i}>${i}</span>
            </wy-button>
          </div>
        ` : v`
          ${s.length ? v`
                <wy-button
                  kind="icon-inline"
                  ?active=${this.showSheet}
                  ?small=${this.small}
                  @click=${() => this.handleReactionsClick()}
                >
                  <div part="wy-reactions">
                    ${s.map((h) => v`<span class=${Xt(r)} title="">${h.content}</span>`)}
                    ${this.reactions && this.reactions?.length > 1 ? v`<small part="wy-reaction-count">${this.reactions.length}</small>` : Q}
                  </div>
                </wy-button>
              ` : Q}

          <div ${rt(this.buttonRef)}>
            <wy-button
              part="wy-reaction-menu-button"
              kind="icon"
              ?active=${this.show}
              ?small=${this.small}
              @click=${(h) => this.handleClickToggle(h)}
              @keydown=${Fe}
              @keyup=${vi}
              title=${P("React", { desc: "Button action to react" })}
            >
              <wy-icon name="emoticon-plus" size=${this.small ? 18 : 20}></wy-icon>
            </wy-button>
          </div>

          <div
            ${rt(this.menuRef)}
            part="wy-reaction-menu"
            @click=${(h) => this.handleClickToggle(h)}
            @keyup=${Jb}
            ?hidden=${!this.show}
            popover=${Ct(N1() ? void 0 : "auto")}
          >
            <div part="wy-reaction-picker">
              ${this.emojis.split(" ").map(
      (h) => v`
                    <wy-button
                      kind="icon"
                      color="none"
                      ?active=${this.reactedEmoji === h}
                      @click=${() => {
        this.handleReaction(h);
      }}
                    >
                      <span class="wy-emoji-icon">${h}</span>
                    </wy-button>
                  `
    )}
            </div>
          </div>
        `, o = v`
      ${this.weavy && this.showSheet ? v`
            <wy-sheet
              .show=${this.showSheet}
              @close=${() => this.showSheet = !1}
              @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
            >
              <span slot="appbar-text">${P("Reactions")}</span>
              <!-- <wy-spinner></wy-spinner> -->
              ${this.showSheet && t && !e ? v`
                    ${t.data?.map(
      (h) => v` <wy-reaction-item .reaction=${h}></wy-reaction-item> `
    )}
                  ` : Q}
            </wy-sheet>
          ` : Q}
    `, l = {
      "wy-reactions-line": !0,
      "wy-reactions-line-reverse": this.lineReverse,
      "wy-reactions-line-bottom": this.lineBottom,
      "wy-reactions-line-below": this.lineBelow
    };
    return this.line || this.lineReverse || this.lineBottom || this.lineBelow ? v`
          <div part=${Me(l)}>${a}</div>
          ${o}
        ` : [a, o];
  }
  firstUpdated(t) {
    this.menuRef.value?.addEventListener(
      this.menuRef.value.popover ? "toggle" : "click",
      (e) => this.handleClose(e)
    );
  }
  disconnectedCallback() {
    this._computePositionCleanup?.(), super.disconnectedCallback();
  }
}, c($p, "ga"), $p), d(e2, "WyReactions"), e2);
$e.styles = [Ie, yN, PL, Tt];
Re([
  O()
], $e.prototype, "directionX", 2);
Re([
  O()
], $e.prototype, "directionY", 2);
Re([
  O({ type: Boolean })
], $e.prototype, "small", 2);
Re([
  O({ attribute: !1 })
], $e.prototype, "reactions", 2);
Re([
  O({ attribute: !1 })
], $e.prototype, "emojis", 2);
Re([
  O({ type: String })
], $e.prototype, "parentType", 2);
Re([
  O({ attribute: !0, type: Number })
], $e.prototype, "parentId", 2);
Re([
  O({ attribute: !0, type: String })
], $e.prototype, "entityType", 2);
Re([
  O({ attribute: !0, type: Number })
], $e.prototype, "entityId", 2);
Re([
  O({ type: Boolean })
], $e.prototype, "line", 2);
Re([
  O({ type: Boolean })
], $e.prototype, "lineReverse", 2);
Re([
  O({ type: Boolean })
], $e.prototype, "lineBottom", 2);
Re([
  O({ type: Boolean })
], $e.prototype, "lineBelow", 2);
Re([
  F()
], $e.prototype, "_placement", 2);
Re([
  F()
], $e.prototype, "reactedEmoji", 2);
Re([
  F()
], $e.prototype, "show", 2);
Re([
  F()
], $e.prototype, "showSheet", 2);
$e = Re([
  X("wy-reactions"),
  bt()
], $e);
var i2, xp;
let Ww = (i2 = (xp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this);
  }
  render() {
    return v`
      <div class="wy-item wy-list-item">
        <wy-avatar
          .src=${this.reaction.created_by?.avatar_url}
          .name=${this.reaction.created_by?.name}
        ></wy-avatar>
        <div class="wy-item-body">${this.reaction.created_by?.name}</div>
        <span class="wy-emoji-icon">${this.reaction.content}</span>
      </div>
    `;
  }
}, c(xp, "ba"), xp), d(i2, "WyReactionItem"), i2);
Ww.styles = [Ie, SL, PL];
Re([
  O({ attribute: !1 })
], Ww.prototype, "reaction", 2);
Ww = Re([
  X("wy-reaction-item")
], Ww);
function sb(n) {
  switch (n) {
    case "zoom":
      return "zoom-meetings";
    case "microsoft":
      return "microsoft-teams";
    case "google":
      return "google-meet";
  }
}
c(sb, "Eu");
d(sb, "getMeetingIconName");
function rb(n) {
  switch (n) {
    case "zoom":
      return P("Zoom meeting");
    case "microsoft":
      return P("Teams meeting");
    case "google":
      return P("Google Meet");
  }
}
c(rb, "Ru");
d(rb, "getMeetingTitle");
var gN = Object.defineProperty, vN = Object.getOwnPropertyDescriptor, CL = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? vN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && gN(t, e, s), s;
}, "__decorateClass$Y"), n2, kp;
let qw = (n2 = (kp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this);
  }
  render() {
    const t = ((/* @__PURE__ */ new Date()).getTime() - new Date(this.meeting.created_at).getTime()) / 36e5 > 2;
    return v`
      <div class="wy-list">
        ${t ? v`<div class="wy-item wy-list-item wy-meeting wy-disabled" title="${P("Meeting ended")}">
                <wy-icon svg="${sb(this.meeting.provider)}" size="48" ></wy-icon>                
                <div class="wy-item-body">
                  <div class="wy-item-title">${rb(this.meeting.provider)}</div>
                  <div class="wy-item-text">${this.meeting.code}</div>
                </div> 
              </div>` : v`<a class="wy-item wy-list-item wy-meeting" href=${this.meeting.join_url} target="_blank"  title="${P("Join meeting")}">
              <wy-icon svg="${sb(this.meeting.provider)}" size="48" color="native"></wy-icon>
              <div class="wy-item-body">
                <div class="wy-item-title">${rb(this.meeting.provider)}</div>
                <div class="wy-item-text">${this.meeting.code}</div>                
              </div>
            </a>`}
      </div>
    `;
  }
}, c(kp, "xa"), kp), d(n2, "WyMeetingCard"), n2);
qw.styles = ft;
CL([
  O({ attribute: !1 })
], qw.prototype, "meeting", 2);
qw = CL([
  X("wy-meeting-card"),
  bt()
], qw);
var bN = Object.defineProperty, ON = Object.getOwnPropertyDescriptor, QL = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? ON(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && bN(t, e, s), s;
}, "__decorateClass$X"), s2, Sp;
let jw = (s2 = (Sp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.text = "";
  }
  render() {
    const t = this.text.trim();
    let e = "";
    return t.length && (e = t.split(/(\n+)/).map((i) => `<div>${i.split(/(\s+)/).map((s) => `<span class="wy-placeholder">${this.escapeHTML(s)}</span>`).join(" ")}</div>`).join(" ")), v`
      <div>${Xo(e)}</div>
    `;
  }
  escapeHTML(t) {
    const e = document.createElement("div");
    return e.textContent = t, e.innerHTML;
  }
}, c(Sp, "$a"), Sp), d(s2, "WySkeleton"), s2);
jw.styles = ft;
QL([
  O()
], jw.prototype, "text", 2);
jw = QL([
  X("wy-skeleton")
], jw);
var Pp;
const ML = (Pp = class {
  constructor(t) {
    this.delay = NaN, this.sleep = !1, t.addController(this), this.host = t;
  }
  createObserver(t) {
    this.scrollObserver?.disconnect(), this.swipeElement = t, this.scrollObserver = new IntersectionObserver(
      (e) => {
        e.forEach(async (i) => {
          i.isIntersecting && !this.sleep && i.intersectionRatio >= 1 && (this.sleep = !0, Number.isNaN(this.delay) || await new Promise((s) => {
            setTimeout(s, this.delay);
          }), i.target === this.prevElement && this.whenPrev && await this.whenPrev(), i.target === this.nextElement && this.whenNext && await this.whenNext(), await this.host.updateComplete);
        });
      },
      { root: t, threshold: 1, rootMargin: "0px" }
    );
  }
  observe(t, e) {
    this.prevElement && (this.scrollObserver?.unobserve(this.prevElement), this.prevElement = void 0), this.nextElement && (this.scrollObserver?.unobserve(this.nextElement), this.nextElement = void 0), t && (this.scrollObserver?.observe(t), this.prevElement = t), e && (this.scrollObserver?.observe(e), this.nextElement = e), this.sleep = !1;
  }
  clearObserver() {
    this.prevElement = void 0, this.nextElement = void 0, this.scrollObserver?.disconnect(), this.sleep = !1;
  }
  hostConnected() {
    this.scrollObserver && (this.prevElement && this.scrollObserver.observe(this.prevElement), this.nextElement && this.scrollObserver.observe(this.nextElement), this.sleep = !1);
  }
  hostDisconnected() {
    this.scrollObserver?.disconnect();
  }
}, c(Pp, "Xp"), Pp);
d(ML, "SwipeScrollController");
let $N = ML;
var ur, gc, Cp;
const TL = (Cp = class {
  constructor(t) {
    if (q(this, ur), q(this, gc), L(this, ur, /* @__PURE__ */ new Map()), this.keyPrefix = "WEAVY_OFFLINE_CACHE", t)
      L(this, gc, t);
    else
      try {
        ii(), L(this, gc, window.sessionStorage);
      } catch {
        console.warn("Session storage not available.");
      }
  }
  resetPersistPropertiesCache() {
    k(this, ur).clear();
  }
  getStorageItem(t, e) {
    const i = k(this, gc)?.getItem(`${t}-${e.toString()}`);
    if (i)
      return JSON.parse(i);
  }
  setStorageItem(t, e, i) {
    const s = JSON.stringify(i);
    s && k(this, gc)?.setItem(`${t}-${e.toString()}`, s);
  }
  persistProperties(t, e, i, s) {
    const r = `${this.keyPrefix}:${s ? `${s}:` : ""}${typeof t}:${e}`;
    for (const a of i) {
      if (!k(this, ur).has(a.name)) {
        const o = this.getStorageItem(r, a.name);
        o && (a.override || !t[a.name]) && (t[a.name] = o), k(this, ur).set(a.name, o);
      }
      if (t[a.name] !== k(this, ur).get(a.name)) {
        const o = t[a.name];
        k(this, ur).set(a.name, o), this.setStorageItem(r, a.name, o);
      }
    }
  }
}, c(Cp, "Jp"), Cp);
ur = /* @__PURE__ */ new WeakMap(), gc = /* @__PURE__ */ new WeakMap(), d(TL, "PersistStorageCache");
let xN = TL;
var vc, Ym, Qp;
const AL = (Qp = class {
  constructor(t) {
    q(this, vc), q(this, Ym), L(this, vc, ""), this.properties = [], this.initialProperties = /* @__PURE__ */ new Map(), this.persistStorageCache = new xN(), t.addController(this), this.host = t;
  }
  get prefixKey() {
    return k(this, vc);
  }
  set prefixKey(t) {
    t !== k(this, vc) && (this.persistStorageCache.resetPersistPropertiesCache(), L(this, vc, t), this.host.requestUpdate());
  }
  get cachePrefix() {
    return k(this, Ym);
  }
  set cachePrefix(t) {
    t !== k(this, Ym) && (this.persistStorageCache.resetPersistPropertiesCache(), L(this, Ym, t), this.host.requestUpdate());
  }
  observe(t, e, i) {
    this.properties = t;
    const s = !!(this.prefixKey && this.prefixKey !== e || this.cachePrefix && this.cachePrefix !== i);
    this.properties.forEach((r) => {
      s && this.initialProperties.has(r.name) ? this.host[r.name] = this.initialProperties.get(r.name) : this.initialProperties.has(r.name) || this.initialProperties.set(r.name, this.host[r.name]);
    }), e && (this.prefixKey = e), i && (this.cachePrefix = i);
  }
  hostUpdate() {
    this.prefixKey && this.properties && this.host.weavy && this.persistStorageCache.persistProperties(this.host, this.prefixKey, this.properties, this.cachePrefix ? `${this.host.weavy.cachePrefix}:${this.cachePrefix}` : this.host.weavy.cachePrefix);
  }
}, c(Qp, "ty"), Qp);
vc = /* @__PURE__ */ new WeakMap(), Ym = /* @__PURE__ */ new WeakMap(), d(AL, "PersistStateController");
let hC = AL;
var kN = Object.defineProperty, SN = Object.getOwnPropertyDescriptor, gg = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? SN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && kN(t, e, s), s;
}, "__decorateClass$W"), r2, Mp;
let ra = (r2 = (Mp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.show = !0, this.maximized = !1, this.filled = !1, this.header = !1, this.viewportRef = mt();
  }
  close() {
    this.viewportRef.value?.close(), this.show = !1;
  }
  handleClose(t) {
    this.show = !1, this.dispatchEvent(new CustomEvent("close")), this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }));
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("show") && (this.show ? this.viewportRef.value?.showModal() : this.viewportRef.value?.close());
  }
  render() {
    const t = {
      "wy-open": this.show,
      "wy-modal-padded": !this.filled && !this.maximized,
      "wy-modal-full": this.maximized && !this.filled
    };
    return v`
      <dialog class="wy-dialog wy-overlay-dialog" ${rt(this.viewportRef)}>
        <div class="wy-overlay wy-transition wy-modal ${Xt(t)}">
          ${this.header ? v`
                <slot name="header">
                  <header class="wy-appbars">
                    <nav class="wy-appbar">
                      <wy-button kind="icon" @click=${() => this.close()}><wy-icon name="close"></wy-icon></wy-button>
                      <slot name="appbar-text" class="wy-appbar-text"></slot>
                      <slot name="appbar-buttons" class="wy-appbar-buttons wy-appbar-buttons-last"></slot>
                    </nav>
                  </header>
                </slot>
              ` : Q}
          <slot></slot>
        </div>
      </dialog>
    `;
  }
  updated(t) {
    t.has("show") && this.show && this.viewportRef.value?.focus();
  }
  firstUpdated(t) {
    this.viewportRef.value?.addEventListener("close", (e) => this.handleClose(e));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.close();
  }
}, c(Mp, "ka"), Mp), d(r2, "WyOverlay"), r2);
ra.styles = [
  ft,
  Bi,
  Tt
];
gg([
  O({ type: Boolean })
], ra.prototype, "show", 2);
gg([
  O({ type: Boolean })
], ra.prototype, "maximized", 2);
gg([
  O({ type: Boolean })
], ra.prototype, "filled", 2);
gg([
  O({ type: Boolean })
], ra.prototype, "header", 2);
ra = gg([
  X("wy-overlay")
], ra);
const nO = Qt`.wy-dropdown{position:relative}.wy-dropdown-toggle{white-space:nowrap}.wy-dropdown-menu{width:max-content;position:absolute;z-index:1000;min-width:calc(10 * var(--wy-size, 1rem));border:none;padding:0;--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);font-size:var(--wy-font-size, var(--wy-size, 1em));text-align:left;background-clip:padding-box;border-radius:var(--wy-dropdown-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));box-shadow:var(--wy-dropdown-shadow, var(--wy-shadow-level1, 0 calc(.125 * var(--wy-size, 1rem)) calc(.125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .14), 0 calc(.1875 * var(--wy-size, 1rem)) calc(.0625 * var(--wy-size, 1rem)) calc(-.125 * var(--wy-size, 1rem)) rgba(0, 0, 0, .2), 0 calc(.0625 * var(--wy-size, 1rem)) calc(.3125 * var(--wy-size, 1rem)) 0 rgba(0, 0, 0, .12)));overflow:hidden}.wy-dropdown-menu:not([popover]){display:block}.wy-dropdown-item{background-color:transparent;color:var(--wy-component-color, var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e)));width:100%;padding:var(--wy-dropdown-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-dropdown-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));clear:both;font-family:var(--wy-font-family, unset),inherit;font-size:inherit;font-weight:var(--wy-font-weight, unset);line-height:1;text-align:inherit;text-decoration:none;white-space:nowrap;border:0;gap:var(--wy-dropdown-gap, var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));cursor:pointer;display:flex;align-items:center}.wy-dropdown-item:hover,.wy-dropdown-item:focus{--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e));--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));color:var(--wy-component-color);background-color:var(--wy-component-background-color);text-decoration:none}.wy-dropdown-item.wy-active,.wy-dropdown-item:active{--wy-component-color: var(--wy-on-primary-container, var(--wy-primary-10, #001d32));--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-90, #cde5ff));color:var(--wy-component-color);background-color:var(--wy-component-background-color);text-decoration:none}.wy-dropdown-item.wy-disabled,.wy-dropdown-item:disabled{color:var(--wy-component-color);background-color:var(--wy-component-background-color);pointer-events:none;opacity:var(--wy-opacity-disabled, 38%)}.wy-dropdown-item>img,.wy-dropdown-item>wy-icon{margin-right:calc(.5 * var(--wy-size, 1rem))}.wy-dropdown-item>img,.wy-dropdown-item>img .wy-icon,.wy-dropdown-item>wy-icon,.wy-dropdown-item>wy-icon .wy-icon{color:inherit}.wy-dropdown-item:active>wy-icon,.wy-dropdown-item:active>wy-icon .wy-icon{color:inherit}.wy-dropdown-item.wy-option wy-icon{visibility:hidden}.wy-dropdown-item.wy-option.wy-selected wy-icon{visibility:visible}.wy-dropdown-divider{height:0;margin:0;overflow:hidden;border:none;border-top:var(--wy-dropdown-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}`;
var PN = Object.defineProperty, CN = Object.getOwnPropertyDescriptor, si = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? CN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && PN(t, e, s), s;
}, "__decorateClass$V"), a2, Tp;
let Ti = (a2 = (Tp = class extends pt {
  constructor() {
    super(), this.exportParts = new et(this), this.directionX = "right", this.directionY = "down", this.icon = "dots-vertical", this.small = !1, this.noWrapper = !1, this.disabled = !1, this._placement = "bottom-start", this.showMenu = !1, this.buttonRef = mt(), this.menuRef = mt(), this._documentClickHandler = (t) => {
      this.showMenu && (t.preventDefault(), this.menuRef.value?.popover || (this.showMenu = !1));
    }, this.addEventListener("click", (t) => {
      t.preventDefault();
    });
  }
  handleClose(t) {
    (t.type === "toggle" && t.newState === "closed" || t.type === "click") && (this.showMenu = !1, this.dispatchEvent(new CustomEvent("close")), this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 })));
  }
  handleClickToggle(t) {
    t.stopPropagation(), this.showMenu = this.disabled ? !1 : !this.showMenu;
  }
  willUpdate(t) {
    if (super.willUpdate(t), (t.has("disabled") || t.has("showMenu")) && this.disabled && this.showMenu && (this.showMenu = !1), (t.has("directionX") || t.has("directionY")) && (this._placement = this.directionX === "right" && this.directionY === "down" ? "bottom-start" : this.directionX === "left" && this.directionY === "down" ? "bottom-end" : this.directionX === "right" && this.directionY === "up" ? "top-start" : "top-end"), t.has("showMenu") && (this.showMenu && !this.computePositionCleanup && this.buttonRef.value && this.menuRef.value ? this.computePositionCleanup = lC(this.buttonRef.value, this.menuRef.value, () => {
      this.buttonRef.value && this.menuRef.value && $L(this.buttonRef.value, this.menuRef.value, {
        placement: this._placement,
        strategy: this.menuRef.value.popover ? "absolute" : "fixed",
        middleware: [
          OL(),
          vL(({ placement: e }) => e.includes("top") ? 9 : 13),
          bL({ mainAxis: !0, crossAxis: !0, padding: 4, altBoundary: !0 })
        ]
      }).then(({ x: e, y: i }) => {
        this.menuRef.value && Object.assign(this.menuRef.value.style, {
          marginLeft: `${e}px`,
          marginTop: `${i}px`,
          top: 0,
          left: 0,
          position: this.menuRef.value.popover ? void 0 : "fixed",
          zIndex: this.menuRef.value.popover ? void 0 : 1075
        });
      });
    }) : !this.showMenu && this.computePositionCleanup && (this.computePositionCleanup?.(), this.computePositionCleanup = void 0)), this.showMenu) {
      requestAnimationFrame(() => {
        document.addEventListener("click", this._documentClickHandler, { once: !0, capture: !0 });
      });
      try {
        this.menuRef.value?.showPopover();
      } catch {
      }
    } else
      try {
        this.menuRef.value?.hidePopover();
      } catch {
      }
  }
  render() {
    const t = this._slotButton.length === 0 || this._slotButton.length === 1 && this._slotButton[0] instanceof de;
    return v`
      <span>
        <span
          ${rt(this.buttonRef)}
          @click=${(e) => this.handleClickToggle(e)}
          @keydown=${Fe}
          @keyup=${vi}
        >
          <wy-button
            .kind=${t ? "icon" : void 0}
            ?small=${this.small}
            title=${this.title}
            ?active=${this.showMenu}
            ?disabled=${this.disabled}
          >
            <slot name="button" @slotchange=${() => this.requestUpdate()}>
              <wy-icon name=${this.icon}></wy-icon>
            </slot>
          </wy-button>
        </span>

        <div
          ${rt(this.menuRef)}
          @click=${(e) => this.handleClickToggle(e)}
          @keyup=${Jb}
          class="wy-dropdown-menu"
          ?hidden=${N1() && !this.showMenu}
          popover=${Ct(N1() ? void 0 : "auto")}
        >
          <slot></slot>
        </div>
      </span>
    `;
  }
  firstUpdated(t) {
    this.menuRef.value?.addEventListener(this.menuRef.value.popover ? "toggle" : "click", (e) => this.handleClose(e));
  }
  disconnectedCallback() {
    this.computePositionCleanup?.(), super.disconnectedCallback();
  }
}, c(Tp, "_a"), Tp), d(a2, "WyDropdown"), a2);
Ti.styles = [
  Ie,
  nO
];
si([
  O()
], Ti.prototype, "directionX", 2);
si([
  O()
], Ti.prototype, "directionY", 2);
si([
  O()
], Ti.prototype, "icon", 2);
si([
  O({ type: Boolean })
], Ti.prototype, "small", 2);
si([
  O({ type: Boolean })
], Ti.prototype, "noWrapper", 2);
si([
  O({ type: Boolean })
], Ti.prototype, "disabled", 2);
si([
  F()
], Ti.prototype, "_placement", 2);
si([
  F()
], Ti.prototype, "showMenu", 2);
si([
  mP({ slot: "button" })
], Ti.prototype, "_slotButton", 2);
si([
  F()
], Ti.prototype, "computePositionCleanup", 2);
Ti = si([
  X("wy-dropdown")
], Ti);
var o2, Ap;
let Fw = (o2 = (Ap = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.active = !1;
  }
  render() {
    return v`<div class="wy-dropdown-item ${Xt({ "wy-active": this.active })}" tabindex="0"
      ><slot></slot
    ></div>`;
  }
}, c(Ap, "Ma"), Ap), d(o2, "WyDropdownItem"), o2);
Fw.styles = [
  Ie,
  nO,
  Tt
];
si([
  O({ type: Boolean })
], Fw.prototype, "active", 2);
Fw = si([
  X("wy-dropdown-item")
], Fw);
var l2, Rp;
let uy = (l2 = (Rp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.active = !1, this.selected = !1;
  }
  render() {
    const t = {
      visibility: this.selected ? null : "hidden"
    };
    return v`
      <div
        class="wy-dropdown-item wy-option ${Xt({ "wy-active": this.active, "wy-selected": this.selected })}"
        tabindex="0"
      >
        <slot name="icon" style=${zw(t)}><wy-icon name="check"></wy-icon></slot>
        <slot></slot>
      </div>
    `;
  }
}, c(Rp, "za"), Rp), d(l2, "WyDropdownOption"), l2);
uy.styles = [
  Ie,
  nO,
  Tt
];
si([
  O({ type: Boolean })
], uy.prototype, "active", 2);
si([
  O({ type: Boolean })
], uy.prototype, "selected", 2);
uy = si([
  X("wy-dropdown-option")
], uy);
var c2, Ep;
let ab = (c2 = (Ep = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this);
  }
  render() {
    return v`<hr class="wy-dropdown-divider" />`;
  }
}, c(Ep, "Pa"), Ep), d(c2, "WyDropdownDivider"), c2);
ab.styles = [
  Ie,
  nO,
  Tt
];
ab = si([
  X("wy-dropdown-divider")
], ab);
var QN = Object.defineProperty, MN = Object.getOwnPropertyDescriptor, sO = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? MN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && QN(t, e, s), s;
}, "__decorateClass$U"), h2, _p;
let Go = (h2 = (_p = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this);
  }
  render() {
    const t = this.icon, e = Ys(this.provider);
    return v`
      <wy-icon-display>
        <wy-icon name=${t} .overlayName=${e}></wy-icon>
        <span slot="text">
          ${this.provider ? v`
                <span>${P("No preview available :(")} </span>
                <a href=${this.src} target="_blank">${P(nt`Open in ${this.provider}?`)}</a>
              ` : v`<span>${P("No preview available :(")}</span>`}
        </span>
      </wy-icon-display>
    `;
  }
}, c(_p, "Sa"), _p), d(h2, "WyPreviewIcon"), h2);
Go.styles = [
  ft,
  Tt
];
sO([
  O()
], Go.prototype, "src", 2);
sO([
  O()
], Go.prototype, "icon", 2);
sO([
  O()
], Go.prototype, "provider", 2);
Go = sO([
  X("wy-preview-icon"),
  bt()
], Go);
var TN = Object.defineProperty, AN = Object.getOwnPropertyDescriptor, rO = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? AN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && TN(t, e, s), s;
}, "__decorateClass$T"), d2, zp;
let Ko = (d2 = (zp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this);
  }
  render() {
    if (this.width && this.height) {
      const t = { "--width": this.width, "--height": this.height };
      return v`
        <div class="wy-content-image wy-responsive-image" style=${zw(t)}>
          <img
            class="wy-loading-transition"
            src=${this.src}
            ${rt(Lw)}
            @load=${Iw}
            width=${this.width}
            height=${this.height}
            decoding="async"
            alt=${P("Preview")} />
          <wy-spinner></wy-spinner>
        </div>
      `;
    } else
      return v`
        <div class="wy-content-image wy-responsive-image wy-intrinsic-image">
          <img src=${this.src} ${rt(Lw)} @load=${Iw} decoding="async" alt=${P("Preview")} />
        </div>
      `;
  }
}, c(zp, "Aa"), zp), d(d2, "WyPreviewImage"), d2);
Ko.styles = [
  ft,
  Tt
];
rO([
  O()
], Ko.prototype, "src", 2);
rO([
  O({ type: Number })
], Ko.prototype, "width", 2);
rO([
  O({ type: Number })
], Ko.prototype, "height", 2);
Ko = rO([
  X("wy-preview-image"),
  bt()
], Ko);
function dC(n) {
  n.classList.contains("wy-loading") && n.classList.add("wy-loaded"), n.classList.add("wy-error"), n.outerHTML = n.outerHTML.replace(/<(video|audio)/, "<div").replace(/(video|audio)>/, "div>");
}
c(dC, "um");
d(dC, "mediaFallback");
function Ik(n) {
  const t = n.target;
  (t.tagName === "VIDEO" || t.tagName === "AUDIO") && t.classList.contains("wy-loading") && t.classList.add("wy-loaded");
}
c(Ik, "Ky");
d(Ik, "mediaLoaded");
function Zk(n) {
  const t = n.target;
  if (t.tagName === "SOURCE" && t.parentNode) {
    const e = t.parentNode, i = parseInt(e.dataset.errors || "0") + 1;
    e.dataset.errors = i.toString(), e.querySelectorAll("source").length >= i && (console.warn(e.tagName.toLowerCase() + " source error, switching to fallback"), dC(e));
  }
}
c(Zk, "Gy");
d(Zk, "mediaError");
function Vk(n) {
  const t = n.target;
  (t.tagName === "VIDEO" || t.tagName === "AUDIO") && (t.tagName === "VIDEO" && !t.videoWidth || t.tagName === "AUDIO" && !t.duration) && (console.warn(t.tagName.toLowerCase() + " track not available, switching to fallback"), dC(t));
}
c(Vk, "Zy");
d(Vk, "codecError");
var RN = Object.defineProperty, EN = Object.getOwnPropertyDescriptor, Ey = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? EN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && RN(t, e, s), s;
}, "__decorateClass$S"), u2, Lp;
let js = (u2 = (Lp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.format = "", this.play = !1, this.name = "";
  }
  registerLoading(t) {
    this.unregisterLoading(), t && (this.mediaElement = t, t.classList.add("wy-loading"), t.addEventListener("error", Zk, !0), t.addEventListener("loadedmetadata", Ik, !0), t.addEventListener("loadedmetadata", Vk, !0));
  }
  unregisterLoading() {
    this.mediaElement && (this.mediaElement.pause(), this.mediaElement.removeAttribute("autoplay"), this.mediaElement.setAttribute("preload", "none"), this.mediaElement.removeEventListener("error", Zk, !0), this.mediaElement.removeEventListener("loadedmetadata", Ik, !0), this.mediaElement.removeEventListener("loadedmetadata", Vk, !0), this.mediaElement = void 0);
  }
  render() {
    return this.format === "video" ? v`
          <video ${rt((t) => this.registerLoading(t))} class="wy-content-video" controls crossorigin="use-credentials">
            <source src=${this.src} type=${Ct(this.mediaType)} />
            <wy-preview-icon src=${this.src} icon="file-video"></wy-preview-icon>
          </video>
          <wy-spinner></wy-spinner>
        ` : v`
          <audio ${rt((t) => this.registerLoading(t))} class="wy-content-audio" controls crossorigin="use-credentials">
            <source src=${this.src} type=${Ct(this.mediaType)} />
          </audio>
        `;
  }
  updated(t) {
    super.updated(t), t.has("play") && this.mediaElement && (this.play ? this.mediaElement.play() : this.mediaElement.pause());
  }
  disconnectedCallback() {
    this.unregisterLoading(), super.disconnectedCallback();
  }
}, c(Lp, "Ea"), Lp), d(u2, "WyPreviewMedia"), u2);
js.styles = [
  ft,
  Tt
];
Ey([
  O()
], js.prototype, "format", 2);
Ey([
  O()
], js.prototype, "src", 2);
Ey([
  O({ type: Boolean })
], js.prototype, "play", 2);
Ey([
  O()
], js.prototype, "name", 2);
Ey([
  O()
], js.prototype, "mediaType", 2);
js = Ey([
  X("wy-preview-media")
], js);
var _N = Object.defineProperty, zN = Object.getOwnPropertyDescriptor, ml = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? zN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && _N(t, e, s), s;
}, "__decorateClass$R"), p2, Ip;
let os = (p2 = (Ip = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.html = !1, this.code = !1, this.textOrHtmlContent = "", this.loading = !0;
  }
  updated(t) {
    super.updated(t), (t.has("weavy") || t.has("src")) && this.weavy && (this.loading = !0, this.weavy.fetchOptions().then((e) => fetch(this.src, e)).then(XR).then((e) => new Response(e)).then((e) => e.text()).then((e) => {
      this.loading = !1, this.textOrHtmlContent = e;
    }));
  }
  render() {
    return this.loading ? v` <wy-empty><wy-spinner></wy-spinner></wy-empty> ` : this.html ? this.code ? v` <div class="wy-content-code wy-code">${Xo(this.textOrHtmlContent)}</div> ` : v`
            <div class="wy-document wy-light">
              <div class="wy-content-html">${Xo(this.textOrHtmlContent)}</div>
            </div>
          ` : this.code ? v` <div class="wy-content-code">${this.textOrHtmlContent}</div> ` : v`
          <div class="wy-document wy-light">
            <pre class="wy-content-text">${this.textOrHtmlContent}</pre>
          </div>
        `;
  }
}, c(Ip, "Ra"), Ip), d(p2, "WyPreviewText"), p2);
os.styles = [ft, Bi, Tt];
ml([
  xe({ context: Le, subscribe: !0 }),
  F()
], os.prototype, "weavy", 2);
ml([
  O()
], os.prototype, "src", 2);
ml([
  O({ type: Boolean })
], os.prototype, "html", 2);
ml([
  O({ type: Boolean })
], os.prototype, "code", 2);
ml([
  F()
], os.prototype, "textOrHtmlContent", 2);
ml([
  F()
], os.prototype, "loading", 2);
os = ml([
  X("wy-preview-text")
], os);
var LN = Object.defineProperty, IN = Object.getOwnPropertyDescriptor, vg = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? IN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && LN(t, e, s), s;
}, "__decorateClass$Q"), f2, Zp;
let aa = (f2 = (Zp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this);
  }
  registerLoading(t) {
    if (this.unregisterLoading?.(), t) {
      this.embedElement = t, t.classList.add("wy-loading");
      const e = window.setTimeout(() => {
        t.classList.add("wy-fallback");
      }, 2500), i = /* @__PURE__ */ d((s) => {
        const r = s.target;
        r.tagName === "OBJECT" && r.classList.contains("wy-loading") && !r.classList.contains("wy-loaded") && (r.classList.add("wy-loaded"), window.clearTimeout(e));
      }, "embedLoaded");
      t.addEventListener("load", i, !0), this.unregisterLoading = () => {
        this.embedElement && (t.removeEventListener("load", i, !0), window.clearTimeout(e), this.embedElement = void 0);
      };
    }
  }
  render() {
    return v`
      <object title=${P("Preview")} ${rt((t) => this.registerLoading(t))} class="wy-content-iframe" data=${this.src}></object>
      <wy-spinner overlay></wy-spinner>
      <wy-preview-icon
        src=${this.src}
        icon=${this.icon}
        provider=${Ct(this.provider)}
        class="wy-content-iframe-fallback"></wy-preview-icon>
    `;
  }
  disconnectedCallback() {
    this.unregisterLoading?.(), super.disconnectedCallback();
  }
}, c(Zp, "Oa"), Zp), d(f2, "WyPreviewEmbed"), f2);
aa.styles = [
  ft,
  Tt
];
vg([
  O()
], aa.prototype, "src", 2);
vg([
  O()
], aa.prototype, "name", 2);
vg([
  O()
], aa.prototype, "icon", 2);
vg([
  O()
], aa.prototype, "provider", 2);
aa = vg([
  X("wy-preview-embed"),
  bt()
], aa);
function Xc(n = "", t = "", e = "", i = !1) {
  if (ii(), n) {
    const s = document.createElement("a");
    i && (/^(data:|blob:)/.test(n) ? s.download = e || "download" : n = n.includes("?d=1") || n.includes("&d=1") ? n : n.includes("?") ? n + "&d=1" : n + "?d=1"), t && (s.target = t), s.href = n, document.body.appendChild(s);
    try {
      s.click();
    } catch {
      if (console.warn("Could not open link normally, trying fallback"), /^(?:blob:|data:)/.test(n))
        console.error(`Could not ${i ? "download" : "open"} ${e}`);
      else
        try {
          window.open(n, t);
        } catch {
          console.error(`Could not ${i ? "download" : "open"} ${e}`);
        }
    }
    document.body.removeChild(s);
  }
}
c(Xc, "xc");
d(Xc, "openUrl");
function Dk(n, t) {
  return new URL(
    n,
    typeof WEAVY_IMPORT_URL == "string" && (!t || !new URL(t).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : t
  );
}
c(Dk, "Yy");
d(Dk, "environmentUrl");
var ZN = Object.defineProperty, VN = Object.getOwnPropertyDescriptor, aO = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? VN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && ZN(t, e, s), s;
}, "__decorateClass$P"), y2, Vp;
let Jo = (y2 = (Vp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.whenPdfjs = new Promise((t) => {
      this.whenPdfjsResolve = t;
    }), this.MAX_CANVAS_PIXELS = 0, this.TEXT_LAYER_MODE = 0, this.MAX_IMAGE_SIZE = -1, this.CMAP_PACKED = !0, this.DEFAULT_SCALE_DELTA = 1.1, this.MIN_SCALE = 0.25, this.MAX_SCALE = 10, this.DEFAULT_SCALE_VALUE = "auto", this.ENABLE_XFA = !0, this.DEFAULT_WORKER_URL = "/pdfjs/pdf.worker.min.mjs", this.DEFAULT_CMAPS_URL = "/pdfjs/cmaps/", this.pageNumberRef = mt(), this.totalPagesRef = mt(), this.zoomLevelRef = mt(), this.viewerContainerRef = mt(), this.resizer = new ResizeObserver(() => {
      this.pdfViewer && (this.delayedResize && (clearTimeout(this.delayedResize), this.delayedResize = void 0), this.delayedResize = window.setTimeout(() => {
        this.pdfViewer && (this.pdfViewer.currentScaleValue = this.pdfViewer._currentScaleValue);
      }, 100));
    });
  }
  ////////
  async open() {
    const { pdfjsLib: t } = await this.whenPdfjs;
    if (!this.pdfViewer || !this.pdfHistory || !this.l10n || !this.pdfLinkService)
      return;
    this.pdfLoadingTask && await this.close();
    const e = t.getDocument({
      url: this.src,
      maxImageSize: this.MAX_IMAGE_SIZE,
      enableXfa: this.ENABLE_XFA,
      cMapUrl: this.CMAP_URL?.toString() || "",
      cMapPacked: this.CMAP_PACKED
    });
    this.pdfLoadingTask = e, e.onProgress = (i) => {
    };
    try {
      const i = await e.promise;
      this.pdfDocument = i, this.pdfViewer.setDocument(i), this.pdfLinkService.setDocument(i), this.pdfHistory.initialize({
        // @ts-expect-error Type 'string | null' is not assignable to type 'string'.
        fingerprint: i.fingerprints[0]
      });
    } catch (i) {
      let s = "pdfjs-loading-error";
      i instanceof t.InvalidPDFException ? s = "pdfjs-invalid-file-error" : i instanceof t.MissingPDFException ? s = "pdfjs-missing-file-error" : i instanceof t.UnexpectedResponseException && (s = "pdfjs-unexpected-response-error"), await this.l10n.get(s, void 0, void 0).then((r) => {
        this.pdfViewError(t, r, { message: i?.message });
      });
    }
  }
  async close() {
    if (!this.pdfLoadingTask)
      return Promise.resolve();
    const t = this.pdfLoadingTask.destroy();
    return this.pdfLoadingTask = void 0, this.pdfDocument && (this.pdfDocument = void 0, this.pdfViewer?.setDocument(null), this.pdfLinkService?.setDocument(null, null), this.pdfHistory && this.pdfHistory.reset()), await t;
  }
  pdfViewError(t, e, i) {
    const s = [`PDF.js v${t?.version || "?"} (build: ${t?.build || "?"})`];
    i && (s.push(`Message: ${i.message}`), i.stack ? s.push(`Stack: ${i.stack}`) : (i.filename && s.push(`File: ${i.filename}`), i.lineNumber && s.push(`Line: ${i.lineNumber}`))), console.error(`${e}

${s.join(`
`)}`);
  }
  ///////
  setPage(t) {
    this.pdfViewer && (this.pdfViewer.currentPageNumber = t);
  }
  zoomIn(t = 0) {
    if (this.pdfViewer) {
      let e = this.pdfViewer.currentScale;
      do
        e = parseFloat((e * this.DEFAULT_SCALE_DELTA).toFixed(2)), e = Math.ceil(e * 10) / 10, e = Math.min(this.MAX_SCALE, e);
      while (--t && e < this.MAX_SCALE);
      this.pdfViewer.currentScaleValue = e.toFixed(2);
    }
  }
  zoomOut(t = 0) {
    if (this.pdfViewer) {
      let e = this.pdfViewer.currentScale;
      do
        e = parseFloat((e / this.DEFAULT_SCALE_DELTA).toFixed(2)), e = Math.floor(e * 10) / 10, e = Math.max(this.MIN_SCALE, e);
      while (--t && e > this.MIN_SCALE);
      this.pdfViewer.currentScaleValue = e.toFixed(2);
    }
  }
  setScale(t) {
    this.pdfViewer && (this.pdfViewer.currentScaleValue = typeof t == "number" ? t.toFixed(2) : t);
  }
  updatePage() {
    if (this.pdfViewer && this.pageNumberRef.value) {
      const t = parseInt(this.pageNumberRef.value.value);
      isNaN(t) ? this.setPage(this.pdfViewer.currentPageNumber) : t > this.pdfViewer.pagesCount ? this.setPage(this.pdfViewer.pagesCount) : t <= 0 ? this.setPage(1) : this.setPage(t);
    }
  }
  select(t) {
    const e = t.target;
    e && e.setSelectionRange(0, e.value.length);
  }
  fitToPage() {
    this.setScale("page-fit");
  }
  fitToWidth() {
    this.setScale("page-width");
  }
  updateZoom() {
    if (this.pdfViewer && this.zoomLevelRef.value) {
      const t = parseFloat(this.zoomLevelRef.value.value.replace("%", ""));
      isNaN(t) ? this.setScale(this.pdfViewer.currentScale + 1e-4) : this.setScale(t / 100);
    }
  }
  // clearDocument() {
  //   try {
  //     this.loadingTask?.destroy();
  //     //console.debug("loadingTask cleanup", loadingTask)
  //   } catch (e) {
  //     /* No worries */
  //   }
  //   try {
  //     // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  //     // @ts-ignore due to incorrect param type def?
  //     this.pdfViewer?.setDocument(null);
  //   } catch (e) {
  //     /* No worries */
  //   }
  //   try {
  //     this.pdfLinkService.setDocument(null, null);
  //   } catch (e) {
  //     /* No worries */
  //   }
  // }
  async willUpdate(t) {
    super.willUpdate(t), t.has("weavy") && this.weavy && (this.pdfjsLib || (await this.weavy.whenUrl(), this.pdfjsLib = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL("./es/pdfjs-dist/build/pdf.mjs.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
    ), globalThis.pdfjsLib = this.pdfjsLib, this.pdfjsViewer = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL("./es/pdfjs-dist/web/pdf_viewer.mjs.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
    ), this.whenPdfjsResolve?.({
      pdfjsLib: this.pdfjsLib,
      pdfjsViewer: this.pdfjsViewer
    })), this.pdfjsLib && !this.WORKER_URL && (this.WORKER_URL = Dk(this.DEFAULT_WORKER_URL, import.meta.url), this.WORKER_URL.searchParams.append("v", this.weavy.version), this.pdfjsLib.GlobalWorkerOptions.workerSrc = this.WORKER_URL.toString()), this.CMAP_URL || (this.CMAP_URL = Dk(this.DEFAULT_CMAPS_URL, import.meta.url)));
  }
  update(t) {
    super.update(t), (t.has("weavy") || t.has("src") || t.has("pdfViewer")) && this.weavy && this.src && this.pdfViewer && this.open();
  }
  async updated() {
    if (this.weavy && this.viewerContainerRef.value && !this.pdfViewer) {
      const { pdfjsLib: t, pdfjsViewer: e } = await this.whenPdfjs;
      this.viewerContainerRef.value && !this.pdfViewer && (this.pdfEventBus = new e.EventBus(), this.pdfLinkService = new e.PDFLinkService({
        eventBus: this.pdfEventBus
      }), this.l10n = new e.GenericL10n(this.weavy?.locale), this.pdfViewer = new e.PDFViewer({
        container: this.viewerContainerRef.value,
        eventBus: this.pdfEventBus,
        linkService: this.pdfLinkService,
        //findController: this.pdfFindController,
        annotationEditorMode: t.AnnotationEditorType.DISABLE,
        l10n: this.l10n,
        maxCanvasPixels: this.MAX_CANVAS_PIXELS,
        textLayerMode: this.TEXT_LAYER_MODE
      }), this.pdfLinkService?.setViewer(this.pdfViewer), this.pdfHistory = new e.PDFHistory({
        eventBus: this.pdfEventBus,
        linkService: this.pdfLinkService
      }), this.pdfLinkService?.setHistory(this.pdfHistory), this.pdfEventBus?.on("scalechanging", () => {
        this.zoomLevelRef.value && this.pdfViewer ? this.zoomLevelRef.value.value = Math.round(this.pdfViewer.currentScale * 100).toFixed(0) + "%" : console.warn("Could not set zoom level");
      }), this.pdfEventBus?.on("pagechanging", () => {
        this.pageNumberRef.value && this.pdfViewer ? this.pageNumberRef.value.value = this.pdfViewer.currentPageNumber.toFixed(0) : console.warn("Could not set page number");
      }), this.pdfEventBus?.on("pagesinit", () => {
        this.isConnected && this.pdfViewer && this.pageNumberRef.value && this.totalPagesRef.value ? (this.pdfViewer.currentScaleValue = this.DEFAULT_SCALE_VALUE, this.pageNumberRef.value.value = "1", this.totalPagesRef.value.innerText = this.pdfViewer.pagesCount.toFixed(0), this.resizer.observe(this.pdfViewer.container)) : console.warn("Could not init pdf page");
      }));
    }
  }
  render() {
    return v`
      <div class="wy-content-pdf">
        <div class="wy-toolbars-bottom">
          <nav class="wy-toolbar wy-toolbar-center">
            <div class="wy-toolbar-buttons">
              <input
                type="text"
                class="wy-input wy-pdf-page-number"
                ${rt(this.pageNumberRef)}
                @keydown=${_w}
                @keyup=${Ds}
                @change=${() => this.updatePage()}
                @click=${(t) => this.select(t)}
              />
              <span class="wy-toolbar-text">/</span>
              <span class="wy-toolbar-text" ${rt(this.totalPagesRef)}>1</span>
            </div>
            <div class="wy-toolbar-buttons">
              <wy-button kind="icon" class="btn-zoom-out" @click=${() => this.zoomOut()} title=${P("Zoom out")}>
                <wy-icon name="minus"></wy-icon>
              </wy-button>
              <input
                type="text"
                class="wy-input wy-pdf-zoom-level"
                ${rt(this.zoomLevelRef)}
                @keydown=${_w}
                @keyup=${Ds}
                @change=${() => this.updateZoom()}
                @click=${(t) => this.select(t)}
                value="100%"
              />
              <wy-button kind="icon" class="btn-zoom-in" @click=${() => this.zoomIn()} title=${P("Zoom in")}>
                <wy-icon name="plus"></wy-icon>
              </wy-button>
            </div>
            <div class="wy-toolbar-buttons">
              <wy-button kind="icon" class="btn-fit-page" @click=${() => this.fitToWidth()} title=${P("Fit to width")}>
                <wy-icon name="fit-width"></wy-icon>
              </wy-button>
              <wy-button kind="icon" @click=${() => this.fitToPage()} title=${P("Fit to screen")}>
                <wy-icon name="fit-screen"></wy-icon>
              </wy-button>
            </div>
          </nav>
        </div>
        <div ${rt(this.viewerContainerRef)} class="wy-pdf-container">
          <div class="pdfViewer"></div>
        </div>
      </div>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.pdfViewer && this.resizer.observe(this.pdfViewer.container);
  }
  disconnectedCallback() {
    this.resizer.unobserve(this);
    try {
      this.close(), this.pdfViewer?.cleanup();
    } catch {
    }
    this.pdfViewer = void 0, super.disconnectedCallback();
  }
}, c(Vp, "La"), Vp), d(y2, "WyPdfViewer"), y2);
Jo.styles = [
  ft,
  Tt
];
aO([
  xe({ context: Le, subscribe: !0 }),
  F()
], Jo.prototype, "weavy", 2);
aO([
  O()
], Jo.prototype, "src", 2);
aO([
  F()
], Jo.prototype, "pdfViewer", 2);
Jo = aO([
  X("wy-pdf-viewer"),
  bt()
], Jo);
var DN = Object.defineProperty, WN = Object.getOwnPropertyDescriptor, uC = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? WN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && DN(t, e, s), s;
}, "__decorateClass$O"), m2, Dp;
let py = (m2 = (Dp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.current = !1;
  }
  render() {
    const t = this.file;
    if (!t) return Q;
    const { icon: e } = Mn(t.name), i = Ei(t.name);
    let s = t.preview_url || t.download_url || "";
    t.preview_format === "image" && (i === ".gif" || i === ".svg") && (s = t.download_url || "");
    const r = s, a = t.external_url, o = t.is_trashed ? "none" : t.preview_format, l = t.name, h = t.width, u = t.height, p = t.media_type, y = t.provider;
    return o === "image" ? v`<wy-preview-image
        src=${r}
        width=${Ct(h)}
        height=${Ct(u)}
      ></wy-preview-image>` : o === "pdf" ? v`<wy-pdf-viewer src=${r}></wy-pdf-viewer>` : o === "video" || o === "audio" ? v`<wy-preview-media
        format=${o}
        src=${r}
        name=${l}
        mediaType=${p}
        ?play=${this.current}
      ></wy-preview-media>` : o === "text" ? v`<wy-preview-text src=${r}></wy-preview-text>` : o === "code" ? v`<wy-preview-text src=${r} ?html=${!/^(?:blob:|data:)/.test(r)} code></wy-preview-text>` : o === "html" ? v`<wy-preview-text src=${r} html></wy-preview-text>` : o === "embed" ? v`<wy-preview-embed
        src=${r}
        name=${l}
        icon=${e}
        provider=${Ct(y)}
      ></wy-preview-embed>` : o === "none" ? a ? v`<wy-preview-icon src=${a} icon=${e} provider=${Ct(y)}></wy-preview-icon>` : v`<wy-preview-icon src=${r} icon=${e}></wy-preview-icon>` : Q;
  }
}, c(Dp, "Ia"), Dp), d(m2, "WyPreviewItem"), m2);
py.styles = [
  ft,
  Tt
];
uC([
  O({ type: Object })
], py.prototype, "file", 2);
uC([
  O({ type: Boolean })
], py.prototype, "current", 2);
py = uC([
  X("wy-preview-item")
], py);
var qN = Object.defineProperty, jN = Object.getOwnPropertyDescriptor, _y = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? jN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && qN(t, e, s), s;
}, "__decorateClass$N"), w2, Wp;
let oa = (w2 = (Wp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.noWrapper = !1, this.small = !1, this.hasEventListener = {
      "edit-name": !1,
      subscribe: !1,
      trash: !1,
      restore: !1,
      "delete-forever": !1
    };
  }
  addEventListener(t, e, i) {
    if (this.hasEventListener) {
      const s = t;
      Object.prototype.hasOwnProperty.call(this.hasEventListener, s) && Object.assign(this.hasEventListener, {
        [s]: !0
      });
    }
    super.addEventListener(t, e, i);
  }
  triggerDownload() {
    this.file && Xc(this.file.download_url, "_top", this.file.name, !0);
  }
  triggerExternal() {
    this.file && Xc(this.file.external_url, "_blank", this.file.name);
  }
  triggerApplication() {
    this.file && Xc(this.file.application_url, "_top", this.file.name);
  }
  dispatchEditName() {
    const t = new CustomEvent("edit-name", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", {
      detail: {
        file: this.file,
        subscribe: t
      }
    });
    return this.dispatchEvent(e);
  }
  dispatchTrash() {
    const t = new CustomEvent("trash", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  dispatchRestore() {
    const t = new CustomEvent("restore", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  dispatchDeleteForever() {
    const t = new CustomEvent("delete-forever", {
      detail: { file: this.file }
    });
    return this.dispatchEvent(t);
  }
  render() {
    if (!this.file)
      return Q;
    const { icon: t } = Mn(this.file.name), e = this.file.id >= 1, i = this.file.provider, s = this.file.provider || "app";
    return v`
      <wy-dropdown directionX="left" ?noWrapper=${this.noWrapper} ?small=${this.small}>
        ${e && this.file.is_trashed ? v`
              ${this.hasEventListener.restore ? v`
                    <wy-dropdown-item @click=${() => this.dispatchRestore()}>
                      <wy-icon name="delete-restore"></wy-icon>
                      ${P("Restore")}
                    </wy-dropdown-item>
                  ` : Q}
              ${this.hasEventListener.restore && this.hasEventListener["delete-forever"] ? v` <wy-dropdown-divider></wy-dropdown-divider> ` : Q}
              ${this.hasEventListener["delete-forever"] ? v`
                    <wy-dropdown-item @click=${() => this.dispatchDeleteForever()}>
                      <wy-icon name="delete-forever"></wy-icon>
                      ${P("Delete")}
                    </wy-dropdown-item>
                  ` : Q}
            ` : Q}
        ${this.file.is_trashed ? Q : v`
              ${this.file.external_url ? v`
                    <wy-dropdown-item @click=${() => this.triggerExternal()}>
                      <wy-icon name=${t}></wy-icon>
                      ${P(nt`Open in ${i}`)}
                    </wy-dropdown-item>
                  ` : v`
                    ${this.componentFeatures?.allowsFeature(z.WebDAV) && this.file.application_url ? v`
                          <wy-dropdown-item @click=${() => this.triggerApplication()}>
                            <wy-icon
                              name=${this.file.provider ? YS(this.file.provider) : t}
                            ></wy-icon>
                            ${P(nt`Open in ${s}`)}
                          </wy-dropdown-item>
                        ` : Q}
                    <wy-dropdown-item @click=${() => this.triggerDownload()}>
                      <wy-icon name="download"></wy-icon>
                      ${P("Download")}
                    </wy-dropdown-item>
                  `}
              ${e ? v`
                    ${this.hasEventListener["edit-name"] ? v`
                          <wy-dropdown-item @click=${() => this.dispatchEditName()}>
                            <wy-icon name="textbox"></wy-icon>
                            ${P("Rename")}
                          </wy-dropdown-item>
                        ` : Q}
                    ${this.hasEventListener.subscribe ? this.file.is_subscribed ? v`
                            <wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                              <wy-icon name="bell-off"></wy-icon>
                              ${P("Unsubscribe")}
                            </wy-dropdown-item>
                          ` : v`
                            <wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                              <wy-icon name="bell"></wy-icon>
                              ${P("Subscribe")}
                            </wy-dropdown-item>
                          ` : Q}
                    ${this.hasEventListener.trash ? v`
                          <wy-dropdown-divider></wy-dropdown-divider>
                          <wy-dropdown-item @click=${() => this.dispatchTrash()}>
                            <wy-icon name="delete"></wy-icon>
                            ${P("Trash")}
                          </wy-dropdown-item>
                        ` : Q}
                  ` : Q}
            `}
        <slot></slot>
      </wy-dropdown>
    `;
  }
}, c(Wp, "Ta"), Wp), d(w2, "WyFileMenu"), w2);
_y([
  xe({ context: Bb, subscribe: !0 }),
  F()
], oa.prototype, "componentFeatures", 2);
_y([
  O({ type: Object })
], oa.prototype, "file", 2);
_y([
  O({ type: Boolean })
], oa.prototype, "noWrapper", 2);
_y([
  O({ type: Boolean })
], oa.prototype, "small", 2);
_y([
  O({ type: Object })
], oa.prototype, "hasEventListener", 2);
oa = _y([
  X("wy-file-menu"),
  bt()
], oa);
function RL(n, t, e, i = {}) {
  return {
    ...i,
    initialPageParam: 0,
    queryKey: [t, e, "comments"],
    queryFn: /* @__PURE__ */ d(async (s) => {
      const r = s.pageParam, a = "/api/" + t + "/" + e + "/comments?order_by=id&skip=" + r, o = await (await n.fetch(a)).json();
      return o.data = o.data || [], o;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ d((s) => {
      if (s.end && s.end < s.count)
        return s.end;
    }, "getNextPageParam")
  };
}
c(RL, "x5");
d(RL, "getCommentsOptions");
function EL(n, t) {
  return {
    mutationFn: /* @__PURE__ */ d(async (e) => await (await n.fetch("/api/comments/" + e.id, {
      method: "PATCH",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        attachments: e.attachments,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ id: i.id, text: i.text })),
        embed_id: e.embed_id || null
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onSuccess: /* @__PURE__ */ d((e, i) => {
      i.id && Oe(n.queryClient, [i.type, i.parent_id, "comments"], i.id, (s) => {
        s.text = e.text, s.html = e.html, s.attachments = e.attachments, s.meeting = e.meeting, s.updated_at = e.updated_at, s.updated_by = e.updated_by, s.options = e.options, s.embed = e.embed;
      });
    }, "onSuccess")
  };
}
c(EL, "$5");
d(EL, "getUpdateCommentMutationOptions");
function _L(n) {
  const t = n.queryClient;
  return {
    mutationFn: /* @__PURE__ */ d(async (e) => await (await n.fetch("/api/" + e.type + "/" + e.parent_id + "/comments", {
      method: "POST",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ text: i.text })),
        embed_id: e.embed_id,
        context: e.context
      })
    })).json(), "mutationFn"),
    onMutate: /* @__PURE__ */ d(async (e) => {
      const i = [e.type, e.parent_id, "comments"];
      await t.cancelQueries({ queryKey: i });
      const s = ia(n.queryClient, i, !1);
      if (e.user) {
        const r = {
          id: s ? s.id - 1 : -1,
          app: e.type === "apps" ? { id: e.parent_id } : { id: -1 },
          is_trashed: !1,
          text: e.text,
          html: e.text,
          plain: e.text,
          created_by: e.user,
          created_at: (/* @__PURE__ */ new Date()).toUTCString(),
          attachments: { count: 0 },
          reactions: { count: 0 },
          is_subscribed: !1,
          is_starred: !1
        };
        e.type === "files" ? r.parent = { type: ci.File, id: e.parent_id } : e.type === "posts" && (r.parent = { type: ci.Post, id: e.parent_id }), ea(t, i, r, { descending: !1 });
      }
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((e, i) => {
      const s = [i.type, e.parent?.id ?? e.app.id, "comments"];
      if (!cg(n.queryClient, s, e.id)) {
        const r = ia(n.queryClient, s, !0);
        r ? Oe(n.queryClient, s, r.id, (a) => {
          a.id = e.id, a.app = e.app, a.text = e.text, a.html = e.html, a.embed = e.embed, a.meeting = e.meeting, a.attachments = e.attachments, a.options = e.options, a.created_at = e.created_at, a.created_by = e.created_by, a.updated_at = e.updated_at, a.updated_by = e.updated_by;
        }) : ea(n.queryClient, s, e), e.parent?.type === ci.Post && Oe(t, ["posts", e.app.id], e.parent.id, (a) => {
          a.comments ? a.comments.count += 1 : a.comments = { count: 1 };
        });
      }
    }, "onSuccess")
  };
}
c(_L, "C5");
d(_L, "getAddCommentMutationOptions");
function zL(n, t, e) {
  const i = n.queryClient, s = {
    mutationKey: [t, e, "comments"],
    mutationFn: /* @__PURE__ */ d(async ({ id: r }) => {
      if (!(await n.fetch("/api/comments/" + r + "/trash", { method: "POST" })).ok)
        throw new Error();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((r) => {
      Ot(
        i,
        { queryKey: s.mutationKey, exact: !1 },
        r.id,
        (a) => Object.assign(a, { is_trashed: !0 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((r, a) => {
      Ot(
        i,
        { queryKey: s.mutationKey, exact: !1 },
        a.id,
        (o) => Object.assign(o, r)
      ), Oe(i, [a.type, a.appId], a.parentId, (o) => {
        o.comments.count -= 1;
      });
    }, "onSuccess")
  };
  return s;
}
c(zL, "k5");
d(zL, "getTrashCommentMutationOptions");
function LL(n, t, e) {
  return new jt(n.queryClient, zL(n, t, e));
}
c(LL, "_5");
d(LL, "getTrashCommentMutation");
function IL(n, t, e) {
  const i = n.queryClient, s = {
    mutationKey: [t, e, "comments"],
    mutationFn: /* @__PURE__ */ d(async ({ id: r }) => {
      const a = await n.fetch("/api/comments/" + r + "/restore", { method: "POST" });
      if (!a.ok) {
        const o = await a.json();
        throw new Error(o.detail || o.title, { cause: o });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((r) => {
      Ot(
        i,
        { queryKey: s.mutationKey, exact: !1 },
        r.id,
        (a) => Object.assign(a, { is_trashed: !1 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((r, a) => {
      Ot(
        i,
        { queryKey: s.mutationKey, exact: !1 },
        a.id,
        (o) => Object.assign(o, r)
      ), Oe(i, [a.type, a.appId], a.parentId, (o) => {
        o.comments.count += 1;
      });
    }, "onSuccess")
  };
  return s;
}
c(IL, "M5");
d(IL, "getRestoreCommentMutationOptions");
function ZL(n, t, e) {
  return new jt(n.queryClient, IL(n, t, e));
}
c(ZL, "z5");
d(ZL, "getRestoreCommentMutation");
var FN = Object.defineProperty, UN = Object.getOwnPropertyDescriptor, VL = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? UN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && FN(t, e, s), s;
}, "__decorateClass$M"), g2, qp;
let Uw = (g2 = (qp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this);
  }
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: { id: this.commentId } });
    return this.dispatchEvent(t);
  }
  render() {
    return v`
      <div class="wy-item">
        <div class="wy-item-body">${P("Comment was trashed.")}</div>
        <wy-button @click=${() => this.dispatchRestore()} color="variant">${P("Undo")}</wy-button>
      </div>
    `;
  }
}, c(qp, "Fa"), qp), d(g2, "WyCommentTrashed"), g2);
Uw.styles = ft;
VL([
  O({ type: Number })
], Uw.prototype, "commentId", 2);
Uw = VL([
  X("wy-comment-trashed"),
  bt()
], Uw);
const BN = 1e3 * 60 * 60, v2 = BN * 24;
function zy(n, t, e, i = 7) {
  e ??= /* @__PURE__ */ new Date();
  const s = new Date(e.getFullYear(), e.getMonth(), e.getDate()), r = t.valueOf() - e.valueOf(), a = t.toDateString() === e.toDateString(), o = t.valueOf() > s.valueOf() - v2 * i && t.valueOf() < s.valueOf() + v2 * i;
  if (!a && o) {
    const l = Math.round(r / v2);
    return new Intl.RelativeTimeFormat(n, { numeric: "auto" }).format(l, "days");
  } else return a ? new Intl.DateTimeFormat(n, { timeStyle: "short" }).format(t) : new Intl.DateTimeFormat(n, { dateStyle: "short" }).format(t);
}
c(zy, "bl");
d(zy, "relativeTime");
var XN = Object.defineProperty, NN = Object.getOwnPropertyDescriptor, oO = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? NN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && XN(t, e, s), s;
}, "__decorateClass$L"), b2, jp;
let tl = (b2 = (jp = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.totalVotes = 0, this.showSheet = !1, this.getVotesQuery = new ns(this);
  }
  async updated(t) {
    t.has("weavy") && this.weavy && this.option && this.option.id && await this.getVotesQuery.trackQuery(hz(this.weavy, this.option.id));
  }
  dispatchVote(t) {
    if (!t)
      return;
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  openSheet(t) {
    t.preventDefault(), t.stopPropagation(), this.getVotesQuery.observer?.refetch(), this.showSheet = !this.showSheet;
  }
  render() {
    if (!this.option || !this.option.id)
      return Q;
    const { data: t, isLoading: e } = this.getVotesQuery.result ?? {}, i = this.totalVotes > 0 ? Math.round((this.option.votes?.count || 0) / this.totalVotes * 100) : 0;
    return v`
      <div
        class="wy-item wy-list-item wy-poll-option"
        tabindex="0"
        @click=${() => this.dispatchVote(this.option?.id)}
        @keydown=${Fe}
        @keyup=${vi}
      >
        <div class="wy-progress" style="width: ${i + "%"}"></div>
        ${this.option.has_voted ? v`<wy-icon name="check-circle"></wy-icon>` : v`<wy-icon name="circle-outline"></wy-icon>`}
        <div class="wy-item-body">${this.option.text}</div>
        ${i > 0 ? v`<span
              class="wy-facepile"
              tabindex="0"
              @click=${(s) => this.openSheet(s)}
              @keydown=${Fe}
              @keyup=${vi}
            >
              ${i + "%"}
            </span>` : Q}
      </div>

      ${this.weavy ? v`
            <wy-sheet
              .show=${this.showSheet}
              @close=${() => this.showSheet = !1}
              @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
            >
              <span slot="appbar-text">${P(nt`Votes on ${this.option.text}`)}</span>
              <!-- <wy-spinner></wy-spinner> -->
              ${this.showSheet && t && !e ? v`
                    ${t.votes?.data ? t.votes.data.map(
      (s) => v`
                        <div class="wy-item wy-list-item">
                          <wy-avatar .size=${32} .src=${s.avatar_url} .name=${s.name}></wy-avatar>
                          <div class="wy-item-body">${s.name}</div>
                        </div>
                      `
    ) : Q}
                  ` : Q}
            </wy-sheet>
          ` : Q}
    `;
  }
}, c(jp, "Da"), jp), d(b2, "WyPollOption"), b2);
tl.styles = ft;
oO([
  O({ type: Number, attribute: !1 })
], tl.prototype, "totalVotes", 2);
oO([
  O({ attribute: !1 })
], tl.prototype, "option", 2);
oO([
  F()
], tl.prototype, "showSheet", 2);
tl = oO([
  X("wy-poll-option"),
  bt()
], tl);
var HN = Object.defineProperty, YN = Object.getOwnPropertyDescriptor, DL = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? YN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && HN(t, e, s), s;
}, "__decorateClass$K"), O2, Fp;
let Bw = (O2 = (Fp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.pollOptions = [];
  }
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  render() {
    const t = this.pollOptions.reduce((e, i) => e + (i.votes?.count || 0), 0);
    return v`
      <div class="wy-poll">
        ${this.pollOptions.map(
      (e) => v`<wy-poll-option
              @vote=${(i) => this.dispatchVote(i.detail.optionId)}
              .option=${e}
              .totalVotes=${t}></wy-poll-option>`
    )}
      </div>
    `;
  }
}, c(Fp, "Ha"), Fp), d(O2, "WyPoll"), O2);
Bw.styles = [
  ft,
  Qt`
      :host {
        display: grid;
      }
    `
];
DL([
  O({ type: Array, attribute: !1 })
], Bw.prototype, "pollOptions", 2);
Bw = DL([
  X("wy-poll")
], Bw);
var GN = Object.defineProperty, KN = Object.getOwnPropertyDescriptor, ri = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? KN(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && GN(t, e, s), s;
}, "__decorateClass$J"), $2, Up;
let Te = ($2 = (Up = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.location = "apps", this.createdAt = "", this.modifiedAt = void 0, this.isTrashed = !1, this.text = "", this.html = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.previewAnnotationsRef = mt(), this.previewAttachmentsRef = mt(), this.highlightRef = mt(), this.highlight = !1;
  }
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.commentId } });
    return this.dispatchEvent(t);
  }
  dispatchEdit(t) {
    const e = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(e);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("link") && (this.highlight = !!(this.link && dg(this.link, ci.Comment, { id: this.commentId }))), t.has("highlight") && (this.highlight ? this.part.add("wy-highlight") : this.part.remove("wy-highlight"));
  }
  render() {
    const t = this.attachments?.filter((r) => r.kind === "image" && r.thumbnail_url) || [], e = this.attachments?.filter((r) => r.kind !== "image" || !r.thumbnail_url) || [], i = new Intl.DateTimeFormat(this.weavy?.locale, {
      dateStyle: "full",
      timeStyle: "short"
    }).format(new Date(this.createdAt)), s = zy(this.weavy?.locale, new Date(this.createdAt));
    return this.commentId < 0 ? v`<div class="wy-item wy-item-sm wy-comment-header">
            <wy-avatar
              .src="${this.createdBy.avatar_url}"
              .size=${32}
              .name=${this.createdBy.name}
              .isAgent=${this.createdBy.is_agent}
            ></wy-avatar>
            <div class="wy-item-body">
              <div class="wy-item-title"><span class="wy-placeholder">${this.createdBy.name}</span></div>
              <div class="wy-item-text">
                <time class="wy-placeholder">${s}</time>
              </div>
            </div>
          </div>
          <div class="wy-comment-body">
            <div class="wy-comment-content">
              ${this.html ? v`<div class="wy-content"><wy-skeleton .text=${this.text}></wy-skeleton></div>` : ""}
            </div>
          </div>` : v`<div class="wy-item wy-comment-header" ${rt(this.highlightRef)}>
            <wy-avatar
              .src=${this.createdBy.avatar_url}
              .size=${32}
              .name=${this.createdBy.name}
              .isAgent=${this.createdBy.is_agent}
            ></wy-avatar>
            <div class="wy-item-body">
              <div class="wy-item-title">${this.createdBy.name}</div>
              <div class="wy-item-text">
                <time datetime=${this.createdAt} title=${i}>${s}</time>
                ${this.modifiedAt ? v`<time datetime=${this.modifiedAt}> · ${P("edited")}</time>` : Q}
              </div>
            </div>

            ${this.user && this.user.id === this.createdBy.id ? v`
                  <div class="wy-item-actions wy-item-top">
                    <wy-dropdown>
                      ${this.user.id === this.createdBy.id ? v`<wy-dropdown-item @click=${() => this.dispatchEdit(!0)}>
                            <wy-icon name="pencil"></wy-icon>
                            ${P("Edit")}
                          </wy-dropdown-item>` : Q}
                      ${this.user.id === this.createdBy.id ? v`<wy-dropdown-item @click=${() => this.dispatchTrash()}>
                            <wy-icon name="trashcan"></wy-icon>
                            ${P("Trash")}
                          </wy-dropdown-item>` : Q}
                    </wy-dropdown>
                  </div>
                ` : Q}
          </div>
          <div class="wy-comment-body">
            <div class="wy-comment-content">
              <!-- annotations -->
              ${this.annotations && this.annotations.length ? v`<wy-annotations-list
                    class="wy-message-area"
                    .files=${this.annotations}
                    @file-open=${(r) => {
      this.previewAnnotationsRef.value?.open(r.detail.fileId);
    }}
                  ></wy-annotations-list>` : ""}

              <!-- image grid -->
              ${t && t.length ? v`<wy-image-grid
                    class="wy-comment-area"
                    .images=${t}
                    @file-open=${(r) => {
      this.previewAttachmentsRef.value?.open(r.detail.fileId);
    }}
                  ></wy-image-grid>` : ""}

              <!-- embeds -->
              ${this.embed && this.componentFeatures?.allowsFeature(z.Embeds) ? v` <wy-embed class="wy-embed" .embed=${this.embed}></wy-embed> ` : Q}
              ${this.html ? v`<div class="wy-content">${Xo(this.html)}</div>` : ""}

              <!-- poll -->
              ${this.pollOptions && this.pollOptions.length > 0 ? v`
                    <wy-poll
                      .pollOptions=${this.pollOptions}
                      @vote=${(r) => this.dispatchVote(r.detail.optionId)}
                    ></wy-poll>
                  ` : Q}

              <!-- files -->
              ${e && e.length ? v`<wy-attachments-list
                    .files=${e ?? []}
                    @file-open=${(r) => {
      this.previewAttachmentsRef.value?.open(r.detail.fileId);
    }}
                  ></wy-attachments-list>` : ""}

              <!-- meeting -->
              ${this.meeting ? v`<wy-meeting-card .meeting=${this.meeting}></wy-meeting-card>` : ""}
            </div>
          </div>

          ${this.componentFeatures?.allowsFeature(z.Reactions) ? v` <wy-reactions
                lineBottom
                small
                .reactions=${this.reactions}
                parentType=${this.location}
                parentId=${this.parentId}
                entityId=${this.commentId}
                entityType="comments"
              ></wy-reactions>` : Q}
          ${this.annotations?.length ? v`<wy-preview
                ${rt(this.previewAnnotationsRef)}
                .files=${this.annotations}
                .isAttachment=${!0}
              ></wy-preview> ` : Q}
          ${this.attachments?.length ? v`<wy-preview
                ${rt(this.previewAttachmentsRef)}
                .files=${[...t, ...e]}
                .isAttachment=${!0}
              ></wy-preview> ` : Q} `;
  }
  updated(t) {
    t.has("highlight") && this.highlight && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, c(Up, "Va"), Up), d($2, "WyCommentView"), $2);
Te.styles = ft;
ri([
  O({ type: Number })
], Te.prototype, "commentId", 2);
ri([
  O({ type: Number })
], Te.prototype, "parentId", 2);
ri([
  O({ attribute: !1 })
], Te.prototype, "location", 2);
ri([
  O({ attribute: !1 })
], Te.prototype, "createdBy", 2);
ri([
  O()
], Te.prototype, "createdAt", 2);
ri([
  O()
], Te.prototype, "modifiedAt", 2);
ri([
  O({ type: Boolean })
], Te.prototype, "isTrashed", 2);
ri([
  O()
], Te.prototype, "text", 2);
ri([
  O()
], Te.prototype, "html", 2);
ri([
  O({ type: Array })
], Te.prototype, "annotations", 2);
ri([
  O({ type: Array })
], Te.prototype, "attachments", 2);
ri([
  O({ attribute: !1 })
], Te.prototype, "embed", 2);
ri([
  O({ type: Array })
], Te.prototype, "pollOptions", 2);
ri([
  O({ attribute: !1 })
], Te.prototype, "meeting", 2);
ri([
  O({ type: Array })
], Te.prototype, "reactions", 2);
ri([
  O({ type: Boolean })
], Te.prototype, "highlight", 2);
Te = ri([
  X("wy-comment-view"),
  bt()
], Te);
var x2, q3;
function WL() {
  if (q3) return x2;
  q3 = 1;
  var n = "Expected a function", t = NaN, e = "[object Symbol]", i = /^\s+|\s+$/g, s = /^[-+]0x[0-9a-f]+$/i, r = /^0b[01]+$/i, a = /^0o[0-7]+$/i, o = parseInt, l = typeof Yg == "object" && Yg && Yg.Object === Object && Yg, h = typeof self == "object" && self && self.Object === Object && self, u = l || h || Function("return this")(), p = Object.prototype, y = p.toString, m = Math.max, w = Math.min, b = /* @__PURE__ */ d(function() {
    return u.Date.now();
  }, "now");
  function $(I, Z, j) {
    var N, ut, ct, K, wt, it, At = 0, kt = !1, Zt = !1, Dt = !0;
    if (typeof I != "function")
      throw new TypeError(n);
    Z = A(Z) || 0, C(j) && (kt = !!j.leading, Zt = "maxWait" in j, ct = Zt ? m(A(j.maxWait) || 0, Z) : ct, Dt = "trailing" in j ? !!j.trailing : Dt);
    function Wt(Nt) {
      var un = N, va = ut;
      return N = ut = void 0, At = Nt, K = I.apply(va, un), K;
    }
    c(Wt, "Gt"), d(Wt, "invokeFunc");
    function Oi(Nt) {
      return At = Nt, wt = setTimeout(se, Z), kt ? Wt(Nt) : K;
    }
    c(Oi, "X"), d(Oi, "leadingEdge");
    function _e(Nt) {
      var un = Nt - it, va = Nt - At, gl = Z - un;
      return Zt ? w(gl, ct - va) : gl;
    }
    c(_e, "gt"), d(_e, "remainingWait");
    function pe(Nt) {
      var un = Nt - it, va = Nt - At;
      return it === void 0 || un >= Z || un < 0 || Zt && va >= ct;
    }
    c(pe, "si"), d(pe, "shouldInvoke");
    function se() {
      var Nt = b();
      if (pe(Nt))
        return ge(Nt);
      wt = setTimeout(se, _e(Nt));
    }
    c(se, "Ve"), d(se, "timerExpired");
    function ge(Nt) {
      return wt = void 0, Dt && N ? Wt(Nt) : (N = ut = void 0, K);
    }
    c(ge, "Ri"), d(ge, "trailingEdge");
    function $i() {
      wt !== void 0 && clearTimeout(wt), At = 0, N = it = ut = wt = void 0;
    }
    c($i, "Oi"), d($i, "cancel");
    function zi() {
      return wt === void 0 ? K : ge(b());
    }
    c(zi, "uc"), d(zi, "flush");
    function Ni() {
      var Nt = b(), un = pe(Nt);
      if (N = arguments, ut = this, it = Nt, un) {
        if (wt === void 0)
          return Oi(it);
        if (Zt)
          return wt = setTimeout(se, Z), Wt(it);
      }
      return wt === void 0 && (wt = setTimeout(se, Z)), K;
    }
    return c(Ni, "wi"), d(Ni, "debounced"), Ni.cancel = $i, Ni.flush = zi, Ni;
  }
  c($, "P"), d($, "debounce");
  function x(I, Z, j) {
    var N = !0, ut = !0;
    if (typeof I != "function")
      throw new TypeError(n);
    return C(j) && (N = "leading" in j ? !!j.leading : N, ut = "trailing" in j ? !!j.trailing : ut), $(I, Z, {
      leading: N,
      maxWait: Z,
      trailing: ut
    });
  }
  c(x, "O"), d(x, "throttle");
  function C(I) {
    var Z = typeof I;
    return !!I && (Z == "object" || Z == "function");
  }
  c(C, "A"), d(C, "isObject");
  function R(I) {
    return !!I && typeof I == "object";
  }
  c(R, "L"), d(R, "isObjectLike");
  function E(I) {
    return typeof I == "symbol" || R(I) && y.call(I) == e;
  }
  c(E, "B"), d(E, "isSymbol");
  function A(I) {
    if (typeof I == "number")
      return I;
    if (E(I))
      return t;
    if (C(I)) {
      var Z = typeof I.valueOf == "function" ? I.valueOf() : I;
      I = C(Z) ? Z + "" : Z;
    }
    if (typeof I != "string")
      return I === 0 ? I : +I;
    I = I.replace(i, "");
    var j = r.test(I);
    return j || a.test(I) ? o(I.slice(2), j ? 2 : 8) : s.test(I) ? t : +I;
  }
  return c(A, "S"), d(A, "toNumber"), x2 = x, x2;
}
c(WL, "F5");
d(WL, "requireLodash_throttle");
var JN = WL();
const Wk = /* @__PURE__ */ SE(JN);
function qL(n, t) {
  return new jt(n.queryClient, {
    mutationFn: /* @__PURE__ */ d(async () => await n.fetch(`/api/apps/${t}/typing`, {
      method: "PUT",
      body: JSON.stringify({})
    }), "mutationFn")
  });
}
c(qL, "H5");
d(qL, "typingMutation");
function qk(n, t) {
  return new jt(n.queryClient, {
    mutationFn: /* @__PURE__ */ d(async () => {
      const e = await n.fetch(`/x/${t}/meetings`, { method: "POST" });
      if (!e.ok)
        throw new Error("Failed to create meeting");
      return await e.json();
    }, "mutationFn")
  });
}
c(qk, "Jy");
d(qk, "addMeetingMutation");
async function jL(n, t) {
  const e = await n.fetch("/api/blobs/external", { method: "POST", body: JSON.stringify(t) });
  if (!e.ok) {
    const i = await e.json();
    throw new Error(i.detail || i.title, { cause: i });
  }
  return await e.json();
}
c(jL, "V5");
d(jL, "externalBlob");
function FL(n, t, e, i) {
  const s = n.queryClient, r = ["apps", e, "blobs", i];
  return {
    mutationFn: /* @__PURE__ */ d(async (a) => await jL(n, a.externalBlob), "mutationFn"),
    mutationKey: r,
    onMutate: /* @__PURE__ */ d(async (a) => (await s.cancelQueries({ queryKey: r, exact: !0 }), { type: "attach", file: kP(void 0, a.externalBlob.name, a.externalBlob.size, void 0, t), status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ d((a, o, l) => {
      ce(s, r, o, (h) => {
        h.status.state = "ok", h.status.progress = void 0, h.status.text = void 0;
      });
    }, "onSuccess"),
    onError(a, o, l) {
      const h = a.cause;
      h && h.status === 409 ? ce(s, r, o, (u) => {
        u.status.state = "conflict", u.status.progress = void 0, u.status.text = h.detail || h.title;
      }) : ce(s, r, o, (u) => {
        u && (u.status.state = "error", u.status.progress = void 0, u.status.text = h.detail || h.title);
      });
    }
  };
}
c(FL, "U5");
d(FL, "getExternalBlobMutationOptions");
function pC(n, t, e, i) {
  return new jt(n.queryClient, FL(n, t, e, i));
}
c(pC, "wm");
d(pC, "getExternalBlobMutation");
const tH = /(((https?|ftp):\/\/|(www|ftp)\.)[\w]+(.[\w]+)([\w\-.,@?^=%&amp;:/~+#]*[\w\-@?^=%&amp;/~+#]))/gim;
let bc = [], Xw = [], ob = [], j1 = [], xs = {};
const eH = /* @__PURE__ */ d((n, t) => n.length === t.length && n.every((e, i) => e === t[i]), "arrayEquals");
function UL() {
  return !!Object.keys(xs).length;
}
c(UL, "N5");
d(UL, "isFetchingEmbeds");
async function BL(n, t) {
  new FormData().append("url", n);
  let e;
  try {
    const i = await t.fetch("/api/embeds", { method: "POST", body: JSON.stringify({ url: n }) });
    if (!i.ok)
      throw new Error();
    e = await i.json(), delete xs[n], Xw = [...Xw, n];
  } catch {
    ob = [...ob, n], delete xs[n];
  }
  return e;
}
c(BL, "j5");
d(BL, "fetchEmbed");
const iH = /* @__PURE__ */ d(() => {
  bc = [], Xw = [], ob = [], j1 = [], xs = {};
}, "clearEmbeds"), j3 = /* @__PURE__ */ d((n) => {
  Xw = n;
}, "initEmbeds"), nH = /* @__PURE__ */ d((n, t, e) => {
  let i = n.match(tH)?.map((s) => s) || null;
  if (i !== null && (i = i.map((s) => s.startsWith("//") ? "http:" + s : !s.startsWith("http://") && !s.startsWith("https://") ? "http://" + s : s)), !(i === null || i.length === 0) && (i.length !== bc.length || !eH(i, bc))) {
    bc = i, i.forEach((s) => {
      !Xw.includes(s) && !ob.includes(s) && !j1.includes(s) && typeof xs[s] > "u" && (ii(), xs[s] = window.setTimeout(async () => {
        const r = await BL(s, e);
        r && t(r);
      }, 500));
    }), j1 = j1.filter((s) => bc.includes(s));
    for (const s in xs)
      bc.includes(s) || (ii(), window.clearTimeout(xs[s]), delete xs[s]);
  }
}, "getEmbeds");
var Gm, Bp;
const XL = (Bp = class {
  constructor(t) {
    q(this, Gm, !1), t.addController(this), this.host = t, t.addEventListener("dragstart", () => this.isDragActive = !0), t.addEventListener("dragenter", () => this.isDragActive = !0), t.addEventListener("dragover", (e) => {
      e.preventDefault(), this.isDragActive = !0;
    }), t.addEventListener("dragleave", () => this.isDragActive = !1), t.addEventListener("dragend", () => this.isDragActive = !1), t.addEventListener("drop", (e) => this.handleDrop(e));
  }
  get isDragActive() {
    return k(this, Gm);
  }
  set isDragActive(t) {
    k(this, Gm) !== t && (L(this, Gm, t), this.host.requestUpdate());
  }
  handleDrop(t) {
    t.preventDefault();
    const e = [];
    t.dataTransfer?.items ? [...t.dataTransfer.items].forEach((i) => {
      if (i.kind === "file") {
        const s = i.getAsFile();
        s ? e.push(s) : console.error("Could not add file");
      }
    }) : t.dataTransfer?.files && [...t.dataTransfer.files].forEach((i) => {
      e.push(i);
    }), e.length && this.dispatchUploadFiles(e), this.isDragActive = !1;
  }
  dispatchUploadFiles(t) {
    const e = new CustomEvent("drop-files", { detail: { files: t } });
    return this.host.dispatchEvent(e);
  }
  hostDisconnected() {
  }
}, c(Bp, "ey"), Bp);
Gm = /* @__PURE__ */ new WeakMap(), d(XL, "DropZoneController");
let NL = XL;
const Gi = ub() ? window.navigator.userAgent : "", HL = Gi.includes("iPad") || Gi.includes("Android") && !Gi.includes("Mobi") || !1, sH = Gi.includes("Mobi") || HL || !1, rH = !sH && !HL, F3 = Gi.includes("Windows") ? "Windows" : Gi.includes("Macintosh") ? "Mac" : Gi.includes("iPad") || Gi.includes("iPhone") || Gi.includes("iPod") ? "iOS" : Gi.includes("Android") ? "Android" : void 0;
F3 === "Android" && Gi.includes("; wv") || F3 === "iOS" && Gi.includes("Safari");
var aH = Object.defineProperty, oH = Object.getOwnPropertyDescriptor, Ly = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? oH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && aH(t, e, s), s;
}, "__decorateClass$I"), k2, Xp;
let Fs = (k2 = (Xp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.status = {
      state: "ok"
    }, this.hasHover = !0, this.isRenaming = !1;
  }
  dispatchEditName(t) {
    const e = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  dispatchRename(t, e) {
    const i = new CustomEvent("rename", { detail: { file: t, name: e } });
    return this.dispatchEvent(i);
  }
  dispatchTrash(t) {
    const e = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  dispatchRestore(t) {
    const e = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  dispatchDeleteForever(t) {
    const e = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  dispatchSubscribe(t, e) {
    const i = new CustomEvent("subscribe", { detail: { file: t, subscribe: e } });
    return this.dispatchEvent(i);
  }
  render() {
    const t = this.file;
    if (!t) return Q;
    const { icon: e } = Mn(t.name), i = Wz(this.actionType), s = Ei(t.name), r = Ys(t.provider), a = /* @__PURE__ */ d((l) => {
      l.stopImmediatePropagation();
      const h = l.target;
      h.value && h.value !== t.name ? this.dispatchRename(t, h.value) : this.dispatchEditName({ id: NaN });
    }, "handleRename"), o = /* @__PURE__ */ d((l) => {
      const h = l.target;
      l.key === "Escape" ? (l.preventDefault(), h.value = t.name, h.blur()) : l.key === "Enter" && (l.preventDefault(), h.blur());
    }, "handleRenameKey");
    return v`
      <div
        class="wy-item wy-list-item ${Xt({
      "wy-item-trashed": t.is_trashed,
      "wy-item-hover": this.hasHover && !t.is_trashed && !this.isRenaming
    })}"
        title=${t.name}>
        ${this.status.state === "error" ? v`<wy-icon name="alert-octagon" color="error" title=${Ct(this.status.text)}></wy-icon>` : this.status.state === "conflict" ? v`<wy-icon name="alert" color="yellow" title=${Ct(this.status.text)}></wy-icon>` : this.status.state === "pending" ? v`<wy-spinner ?nospin=${!!this.status.progress} .progress=${this.status.progress}></wy-spinner>` : v`<wy-icon .name=${e} .overlayName=${r} .overlayPath=${i} .size=${24} .kind=${t.kind} ext=${s}></wy-icon>`}
        <div class="wy-item-body">
          ${this.isRenaming ? v`
                <input
                  type="text"
                  maxlength="256"
                  class="wy-input"
                  .defaultValue=${t.name}
                  @blur=${a}
                  @keyup=${(l) => {
      Ds(l), o(l);
    }}
                  @click=${(l) => l.preventDefault()}
                  @focus=${Hb}
                  ${rt(Hk)} />
              ` : v`
                <span title=${t.name + (this.status.text ? `: ${this.status.text}` : "")}
                  ><slot name="title"
                    >${this.title || t.name}${this.status.text ? v`: <em>${this.status.text}</em>` : Q}</slot
                  ></span
                >
              `}
        </div>
        <div class="wy-item-actions">
          <slot name="actions">
            <wy-file-menu
              .file=${t}
              @edit-name=${(l) => this.dispatchEditName(l.detail.file)}
              @trash=${(l) => this.dispatchTrash(l.detail.file)}
              @restore=${(l) => this.dispatchRestore(l.detail.file)}
              @delete-forever=${(l) => this.dispatchDeleteForever(l.detail.file)}
              @subscribe=${(l) => this.dispatchSubscribe(l.detail.file, l.detail.subscribe)}>
            </wy-file-menu>
          </slot>
        </div>
      </div>
    `;
  }
}, c(Xp, "Ba"), Xp), d(k2, "WyFileItem"), k2);
Fs.styles = ft;
Ly([
  O({ type: Object })
], Fs.prototype, "file", 2);
Ly([
  O({ type: Object })
], Fs.prototype, "status", 2);
Ly([
  O({ type: Boolean })
], Fs.prototype, "hasHover", 2);
Ly([
  O()
], Fs.prototype, "actionType", 2);
Ly([
  F()
], Fs.prototype, "isRenaming", 2);
Fs = Ly([
  X("wy-file-item")
], Fs);
const lH = Qt`:host{--_track-height: 4px;--_track-shape: 2px;--_active-indicator-height: 2px;--_active-indicator-color: var(--wy-primary, var(--wy-primary-40, #006399));--_warning-color: var(--wy-warning, var(--wy-warning-70, #afb140));--_error-color: var(--wy-error, var(--wy-error-40, #ba1824));--_track-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));display:contents;position:relative}[part~=wy-progress]{border-radius:var(--_track-shape);position:relative;min-width:80px;height:var(--_track-height);content-visibility:auto;contain:strict;flex:1;direction:ltr;inset:0;border-radius:inherit;overflow:hidden;display:flex;align-items:center}[part~=wy-progress][part~=wy-progress-overlay],[part~=wy-inactive-track],[part~=wy-bar],[part~=wy-bar-inner]{position:absolute}[part~=wy-progress-reveal]{opacity:1;transition:width var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),height var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),margin var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) var(--wy-transition-reveal-delay, 1s),opacity var(--wy-transition, var(--wy-transition-duration, .2s) var(--wy-transition-curve, cubic-bezier(.4, 0, .2, 1))) calc(var(--wy-transition-duration, .2s) + var(--wy-transition-reveal-delay, 1s))}@starting-style{[part~=wy-progress-reveal]{width:0;height:0;opacity:0;margin:0}}[part~=wy-bar]{animation:none;width:100%;height:var(--_active-indicator-height);transform-origin:left center;transition:transform .25s cubic-bezier(.4,0,.6,1)}[part~=wy-secondary-bar]{display:none}[part~=wy-bar-inner]{inset:0;animation:none;background:var(--_active-indicator-color)}[part~=wy-inactive-track]{background:var(--_track-color);inset:0;transition:transform .25s cubic-bezier(.4,0,.6,1);transform-origin:left center}[part~=wy-indeterminate] [part~=wy-bar]{transition:none}[part~=wy-indeterminate] [part~=wy-primary-bar]{inset-inline-start:-145.167%}[part~=wy-indeterminate] [part~=wy-secondary-bar]{inset-inline-start:-54.8889%;display:block}[part~=wy-indeterminate] [part~=wy-primary-bar]{animation:linear infinite 2s;animation-name:primary-indeterminate-translate}[part~=wy-indeterminate] [part~=wy-primary-bar]>[part~=wy-bar-inner]{animation:linear infinite 2s primary-indeterminate-scale}[part~=wy-indeterminate] [part~=wy-secondary-bar]{animation:linear infinite 2s;animation-name:secondary-indeterminate-translate}[part~=wy-indeterminate] [part~=wy-secondary-bar]>[part~=wy-bar-inner]{animation:linear infinite 2s secondary-indeterminate-scale}@keyframes primary-indeterminate-scale{0%{transform:scaleX(.08)}36.65%{animation-timing-function:cubic-bezier(.334731,.12482,.785844,1);transform:scaleX(.08)}69.15%{animation-timing-function:cubic-bezier(.06,.11,.6,1);transform:scaleX(.661479)}to{transform:scaleX(.08)}}@keyframes secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(.205028,.057051,.57661,.453971);transform:scaleX(.08)}19.15%{animation-timing-function:cubic-bezier(.152313,.196432,.648374,1.00432);transform:scaleX(.457104)}44.15%{animation-timing-function:cubic-bezier(.257759,-.003163,.211762,1.38179);transform:scaleX(.72796)}to{transform:scaleX(.08)}}@keyframes primary-indeterminate-translate{0%{transform:translate(0)}20%{animation-timing-function:cubic-bezier(.5,0,.701732,.495819);transform:translate(0)}59.15%{animation-timing-function:cubic-bezier(.302435,.381352,.55,.956352);transform:translate(83.6714%)}to{transform:translate(200.611%)}}@keyframes secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(.15,0,.515058,.409685);transform:translate(0)}25%{animation-timing-function:cubic-bezier(.31033,.284058,.8,.733712);transform:translate(37.6519%)}48.35%{animation-timing-function:cubic-bezier(.4,.627035,.6,.902026);transform:translate(84.3862%)}to{transform:translate(160.278%)}}[part~=wy-progress-warning] [part~=wy-primary-bar],[part~=wy-progress-warning] [part~=wy-secondary-bar],[part~=wy-progress-warning] [part~=wy-bar-inner],[part~=wy-progress-error] [part~=wy-primary-bar],[part~=wy-progress-error] [part~=wy-secondary-bar],[part~=wy-progress-error] [part~=wy-bar-inner]{animation:none!important}[part~=wy-progress-warning] [part~=wy-secondary-bar],[part~=wy-progress-error] [part~=wy-secondary-bar]{display:none!important}[part~=wy-progress-warning] [part~=wy-primary-bar],[part~=wy-progress-error] [part~=wy-primary-bar]{transform:scaleX(1)!important}[part~=wy-progress-warning] [part~=wy-bar-inner]{background:var(--_warning-color)}[part~=wy-progress-error] [part~=wy-bar-inner]{background:var(--_error-color)}`;
var cH = Object.defineProperty, hH = Object.getOwnPropertyDescriptor, Js = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? hH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && cH(t, e, s), s;
}, "__decorateClass$H"), S2, Np;
let on = (S2 = (Np = class extends pt {
  constructor() {
    super(...arguments), this.shadowParts = new et(this), this.padded = !1, this.overlay = !1, this.reveal = !1, this.value = 0, this.max = 1, this.indeterminate = !1, this.warning = !1, this.error = !1;
  }
  render() {
    const t = {
      transform: `scaleX(${(this.indeterminate ? 1 : this.value / this.max) * 100}%)`
    }, e = {
      "wy-indeterminate": this.indeterminate,
      "wy-progress-overlay": this.overlay,
      "wy-progress-reveal": this.reveal,
      "wy-progress-warning": this.warning,
      "wy-progress-error": this.error
    };
    return v`
      <div
        part="wy-progress ${Me(e)}"
        role="progressbar"
        aria-label="${Q}"
        aria-valuemin="0"
        aria-valuemax=${this.max}
        aria-valuenow=${this.indeterminate ? Q : this.value}
      >
        <div part="wy-inactive-track"></div>
        <div part="wy-bar wy-primary-bar" style=${zw(t)}>
          <div part="wy-bar-inner"></div>
        </div>
        <div part="wy-bar wy-secondary-bar">
          <div part="wy-bar-inner"></div>
        </div>
      </div>
    `;
  }
}, c(Np, "qa"), Np), d(S2, "WyProgressLinear"), S2);
on.styles = [Ie, lH];
Js([
  O({ type: Boolean })
], on.prototype, "padded", 2);
Js([
  O({ type: Boolean })
], on.prototype, "overlay", 2);
Js([
  O({ type: Boolean })
], on.prototype, "reveal", 2);
Js([
  O({ type: Number })
], on.prototype, "value", 2);
Js([
  O({ type: Number })
], on.prototype, "max", 2);
Js([
  O({ type: Boolean })
], on.prototype, "indeterminate", 2);
Js([
  O({ type: Boolean })
], on.prototype, "warning", 2);
Js([
  O({ type: Boolean })
], on.prototype, "error", 2);
on = Js([
  X("wy-progress-linear")
], on);
var dH = Object.defineProperty, uH = Object.getOwnPropertyDescriptor, ne = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? uH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && dH(t, e, s), s;
}, "__decorateClass$G"), P2, Hp;
let qt = (P2 = (Hp = class extends _t {
  constructor() {
    super(), this.exportParts = new et(this), this.storage = JS("localStorage"), this.disabled = !1, this._placeholder = "", this.text = "", this.metadata = {}, this.options = [], this.attachments = [], this.buttonText = "", this.typing = !0, this.draft = !1, this.editorType = "posts", this.editorClass = "wy-post-editor", this.editorLocation = "apps", this.editorError = !1, this.showPolls = !1, this.pollOptions = [], this.embeds = [], this.draftKey = "", this.uploadBlobMutation = new en(
      this
    ), this.mutatingFiles = new og(this), this.fileInputRef = mt(), this.cloudFilesRef = mt(), this.dropZone = new NL(this), this.keyMap = [], this.editorRef = mt(), this.editorInitialized = !1, this.throttledTyping = Wk(
      async () => {
        this.weavy && this.app && !Nv.has(this.app.type) && await qL(this.weavy, this.app.id).mutate();
      },
      2e3,
      { leading: !0, trailing: !1 }
    ), this.throttledDrafting = Wk(
      () => {
        this.saveDraft();
      },
      500,
      { leading: !0, trailing: !0 }
    ), this.openFileInput = () => {
      this.fileInputRef.value?.click();
    }, this.openCloudFiles = () => {
      this.cloudFilesRef.value?.open();
    }, this.createMeeting = async (t) => {
      if (this.weavy && t.source === this.authWindow && this.weavy.url.origin === t.origin && t.data && t.data.name && t.data.name.endsWith("-authorized")) {
        const e = t.data.name.slice(0, -11), i = await qk(this.weavy, e).mutate();
        i.auth_url || (this.meeting = i);
      }
    }, this.addEventListener("drop-files", (t) => this.handleDropFiles(t)), this.addEventListener("keydown", _w), this.addEventListener("keyup", Ds);
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(t) {
    this._placeholder = t;
  }
  selectAllContent() {
    this.editor?.dispatch({
      selection: {
        anchor: 0,
        head: this.editor.state.doc.length
      }
    });
  }
  setCursorLast() {
    this.editor?.dispatch({
      selection: {
        anchor: this.editor.state.doc.length,
        head: this.editor.state.doc.length
      }
    });
  }
  focusInput() {
    this.editor?.focus();
  }
  willUpdate(t) {
    if (super.willUpdate(t), (t.has("weavy") || t.has("app") || t.has("user") || t.has("parentId")) && this.weavy && this.user) {
      if (this.mutationAppId = this.mutationAppId ?? this.app?.id ?? Date.now() * -1, this.draftKey = `draft-${this.editorType}-${this.parentId || this.mutationAppId}`, this.uploadBlobMutation.trackMutation(
        Yb(
          this.weavy,
          this.user,
          this.mutationAppId,
          `${this.editorLocation}-${this.parentId || this.mutationAppId}`
        )
      ), this.mutatingFiles.trackMutationState(
        {
          filters: {
            mutationKey: [
              "apps",
              this.mutationAppId,
              "blobs",
              `${this.editorLocation}-${this.parentId || this.mutationAppId}`
            ],
            exact: !0
          }
        },
        this.weavy.queryClient
      ), this.externalBlobMutation = pC(
        this.weavy,
        this.user,
        this.mutationAppId,
        `${this.editorLocation}-${this.parentId || this.mutationAppId}`
      ), this.draft && this.storage) {
        const e = this.storage.getItem(this.draftKey);
        if (e) {
          const i = JSON.parse(e);
          this.text = i.text, this.embeds = i.embeds, this.meeting = i.meeting, i.pollOptions?.length > 0 && (this.showPolls = !0, this.pollOptions = i.pollOptions), j3(this.embeds.map((s) => s.original_url));
        } else
          this.clearEditor();
      }
      this.embed && (this.embeds = [this.embed], j3(this.embeds.map((e) => e.original_url))), this.options && this.options.length > 0 && (this.pollOptions = this.options, this.showPolls = !0);
    }
    t.has("text") && this.editor && this.editor.state.doc.toString() !== this.text && this.editor.dispatch({ changes: { from: 0, to: this.editor.state.doc.length, insert: this.text } });
  }
  updated(t) {
    if ((t.has("weavy") || t.has("app") || t.has("user") || t.has("parentId")) && this.weavy && this.user && this.editorRef.value && this.weavy.whenUrl().then(() => {
      import(
        /* webpackIgnore: true */
        /* @vite-ignore */
        new URL("./es/editor.js", typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url).href
      ).then((e) => e.editor).then(
        ({
          weavyHighlighter: e,
          syntaxHighlighting: i,
          history: s,
          dropCursor: r,
          mentions: a,
          autocompletion: o,
          placeholder: l,
          keymap: h,
          weavyKeymap: u,
          defaultKeymap: p,
          historyKeymap: y,
          markdown: m,
          languages: w,
          EditorView: b,
          EditorState: $,
          weavyEnterSendKeymap: x,
          weavyModifierEnterSendKeymap: C,
          Compartment: R
        }) => {
          this.editorInitialized = !0, this.editorRef.value && !this.editor && (this.editorRef.value.innerHTML = ""), this.editorEditable = new R(), this.editorPlaceholder = new R(), this.editorKeymap = new R(), this.EditorView = b, this.placeholderExtension = l, this.keymapFacet = h, this.keymaps = {
            weavyEnterSendKeymap: x,
            weavyModifierEnterSendKeymap: C,
            weavyKeymap: u,
            defaultKeymap: [...p],
            historyKeymap: [...y]
          }, this.editorExtensions = [
            b.contentAttributes.of({
              spellcheck: "true",
              autocorrect: "on",
              autocapitalize: "on",
              enterkeyhint: this.settings?.enterToSend === "always" ? "send" : "enter"
            }),
            s(),
            r(),
            a,
            o({
              override: this.componentFeatures?.allowsFeature(z.Mentions) ? [(E) => this.autocomplete(E)] : [],
              //showMention
              closeOnBlur: !1,
              aboveCursor: this.editorType !== "posts",
              icons: !1,
              addToOptions: [
                {
                  render: /* @__PURE__ */ d(function(E, A) {
                    const I = document.createElement("div");
                    I.classList.add("wy-item"), I.classList.add("wy-list-item"), I.classList.add("wy-item-hover"), (!E.item?.access || E.item.access === mr.None) && I.classList.add("wy-disabled");
                    const Z = document.createElement("wy-avatar");
                    Z.src = E.item?.avatar_url || "", Z.name = E.item?.name || "";
                    const j = document.createElement("div");
                    return j.classList.add("wy-item-body"), j.innerText = E.item?.name || "", I.appendChild(Z), I.appendChild(j), I;
                  }, "render"),
                  position: 10
                }
              ]
            }),
            i(e, { fallback: !0 }),
            b.lineWrapping,
            m({ codeLanguages: w }),
            b.domEventHandlers({
              paste: /* @__PURE__ */ d((E, A) => {
                let I = [];
                const Z = E.clipboardData?.items || [];
                for (const j of Z)
                  if (j.kind === "file") {
                    const N = j.getAsFile();
                    N && (I = [...I, N]);
                  }
                if (this.componentFeatures?.allowsFeature(z.Attachments) && I.length > 0) {
                  for (let j = 0; j < I.length; j++)
                    this.handleUploadFiles(I);
                  return !0;
                }
              }, "paste"),
              keyup: /* @__PURE__ */ d((E, A) => {
                this.text = A.state.doc.toString(), this.componentFeatures?.allowsFeature(z.Typing) && this.typing && A.state.doc.toString() !== "" && this.throttledTyping(), this.draft && this.throttledDrafting(), this.componentFeatures?.allowsFeature(z.Embeds) && A.state.doc.toString() !== "" && this.handleEmbeds(A.state.doc.toString());
              }, "keyup")
            }),
            // Compartments
            this.editorEditable.of(b.editable.of(!this.disabled)),
            this.editorPlaceholder.of(this.placeholderExtension(this.placeholder)),
            this.editorKeymap.of(this.keymapFacet.of(this.getKeymaps())),
            b.updateListener.of((E) => {
              this.setPlaceHolderText();
              const A = Array.from(
                (this.editor?.state).config.compartments.keys()
              );
              this.editorEditable = A[0], this.editorPlaceholder = A[1], this.editorKeymap = A[2];
            })
          ], this.editor || (this.editor = new b({
            state: $.create({
              doc: this.text,
              extensions: this.editorExtensions
            }),
            parent: this.editorRef.value
          }), this.editorRef.value?.querySelector(".cm-editor")?.addEventListener("Weavy-SoftSubmit", this.submit.bind(this)));
        }
      );
    }), t.has("disabled") && this.editor && this.editorEditable && this.EditorView && this.editor.dispatch({
      // Update readonly state
      effects: this.editorEditable.reconfigure(this.EditorView.editable.of(!this.disabled))
    }), t.has("placeholder") && this.editor && this.editorPlaceholder && this.placeholderExtension) {
      const e = this.placeholderExtension(this.placeholder);
      this.editor.dispatch({
        // Update placeholder state
        effects: this.editorPlaceholder.reconfigure(e)
      }), this.setPlaceHolderText();
    }
    t.has("settings") && this.editor && this.editorKeymap && this.keymapFacet && (this.editor.dispatch({
      // Update readonly state
      effects: this.editorKeymap.reconfigure(this.keymapFacet.of(this.getKeymaps()))
    }), this.setEnterKeyHint());
  }
  setPlaceHolderText() {
    const t = this.renderRoot.querySelector(".cm-placeholder");
    t && this.editor && (t.setAttribute("aria-label", `placeholder ${this.placeholder}`), t.innerText = this.placeholder);
  }
  setEditable() {
    const t = this.renderRoot.querySelector(".cm-content");
    t && this.editor && (t.contentEditable = String(!this.disabled));
  }
  setEnterKeyHint() {
    const t = this.renderRoot.querySelector(".cm-content");
    t && this.editor && (t.enterKeyHint = this.settings?.enterToSend === "always" ? "send" : "enter");
  }
  getKeymaps() {
    if (!this.keymaps)
      return [];
    const {
      weavyEnterSendKeymap: t,
      weavyModifierEnterSendKeymap: e,
      weavyKeymap: i,
      defaultKeymap: s,
      historyKeymap: r
    } = this.keymaps;
    let a = this.settings?.enterToSend === "never" ? [] : [...e];
    return ((!this.settings?.enterToSend || this.settings?.enterToSend === "auto") && this.editorType === "messages" && rH || this.settings?.enterToSend === "always") && (a = [...t, ...a]), [...a, ...i, ...s, ...r];
  }
  connectedCallback() {
    super.connectedCallback(), window.addEventListener("message", this.createMeeting);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("message", this.createMeeting);
  }
  handleRemoveMeeting() {
    this.meeting = void 0;
  }
  async autocomplete(t) {
    if (!this.weavy || !this.app)
      return null;
    let e = t.matchBefore(/(?!\]\(@)(^[^@]{0,1}|[^@]{2})@([^@]+)/);
    if (!t.explicit && !e) return null;
    e = t.matchBefore(/@[^@]+/);
    const i = e?.text.substring(1), s = await (await this.weavy.fetch(`/api/apps/${this.app.id}/members?member=null&q=${i}`)).json();
    let r = [];
    return s.data && (r = s.data.filter((a) => typeof a.name < "u").map((a) => ({
      item: a,
      label: a.name,
      apply: /* @__PURE__ */ d((o, l, h, u) => {
        const p = "[" + a.name + "](@u" + a.id.toString() + ")";
        let y = o.state.update({ changes: { from: h - 1, to: h } });
        o.dispatch(y), y = o.state.update({
          changes: { from: h - 1, to: u - 1, insert: p }
        }), o.dispatch(y);
      }, "apply")
    }))), {
      from: e ? e.from + 1 : t.pos,
      options: r,
      filter: !1
    };
  }
  handleDropFiles(t) {
    const e = t.detail;
    e.files && this.handleUploadFiles(e.files);
  }
  async handleUploadFiles(t, e) {
    if (t) {
      for (let i = 0; i < t.length; i++) {
        const s = { file: t[i] };
        await this.uploadBlobMutation.mutate(s), this.saveDraft();
      }
      e && (e.value = "");
    }
  }
  handleExternalBlobs(t) {
    if (t)
      for (let e = 0; e < t.length; e++) {
        const i = t[e];
        this.externalBlobMutation?.mutate({ externalBlob: i });
      }
  }
  handleRemoveUpload(t) {
    !this.weavy || !this.mutationAppId || xP(
      this.weavy.queryClient,
      ["apps", this.mutationAppId, "blobs", `${this.editorLocation}-${this.parentId || this.mutationAppId}`],
      (e) => e.state.data?.id === t.data?.id
    );
  }
  saveDraft() {
    if (!this.draft || !this.storage) return;
    const t = this.mutatingFiles.result;
    let e = this.editor?.state.doc.toString();
    if (e === void 0 && (e = this.text), (!t || !t.length) && !this.meeting && !this.embeds.length && (!this.pollOptions.length || this.pollOptions.filter((i) => i.text.trim() !== "").length === 0) && e === "")
      this.storage.removeItem(this.draftKey);
    else {
      const i = {
        meeting: this.meeting,
        text: e,
        pollOptions: this.pollOptions.filter((s) => s.text.trim() !== ""),
        embeds: this.embeds
      };
      this.storage.setItem(this.draftKey, JSON.stringify(i));
    }
  }
  handleRemoveAttachment(t) {
    this.attachments = this.attachments.filter((e) => e.id !== t.id);
  }
  submit() {
    const t = this.mutatingFiles.result, e = t?.some((u) => u.status === "pending"), i = this.editor?.state.doc.toString().trim() ?? "", s = this.meeting?.id, r = t?.map((u) => u.data?.id).filter((u) => u), a = this.attachments?.map((u) => u.id) || [], o = this.pollOptions.filter((u) => u.text.trim() !== "");
    if (UL() || e || !this.contextDataBlobs || !i && !s && r?.length == 0 && o.length == 0 && a.length == 0 && this.embeds.length == 0)
      return;
    const l = this.contextDataBlobs.length ? this.contextDataBlobs : void 0, h = new CustomEvent("submit", {
      detail: { text: i, meetingId: s, blobs: r, attachments: a, pollOptions: o, embedId: this.embeds[0]?.id, contextData: l },
      bubbles: !0,
      composed: !0
    });
    this.dispatchEvent(h), this.resetEditor();
  }
  resetEditor() {
    this.clearEditor(), this.weavy && this.mutationAppId && T_(this.weavy.queryClient, [
      "apps",
      this.mutationAppId,
      "blobs",
      `${this.editorLocation}-${this.parentId || this.mutationAppId}`
    ]), this.storage?.removeItem(this.draftKey);
  }
  clearEditor() {
    this.editor?.dispatch({ changes: { from: 0, to: this.editor.state.doc.length, insert: "" } }), this.text = "", this.meeting = void 0, this.pollOptions = [], this.showPolls = !1, this.embeds = [], this.metadata = {}, iH();
  }
  async handleMeetingClick(t) {
    if (!this.weavy || !this.user)
      return;
    const e = await qk(this.weavy, t).mutate();
    e.auth_url ? this.authWindow = window.open(e.auth_url, "oauthwin", "height=640,width=480") : this.meeting = e;
  }
  setEmbeds(t) {
    this.embeds = [t, ...this.embeds], this.saveDraft();
  }
  handleEmbeds(t) {
    this.weavy && nH(t, this.setEmbeds.bind(this), this.weavy);
  }
  removeEmbed(t) {
    this.embeds = this.embeds.filter((e) => e.id !== t.detail.id), this.saveDraft();
  }
  swapEmbed() {
    const t = this.embeds.shift();
    t && (this.embeds = [...this.embeds, t]), this.saveDraft();
  }
  openPolls() {
    if (this.showPolls)
      this.showPolls = !1;
    else {
      if (this.pollOptions.length === 0) {
        const t = { id: null, text: "" };
        this.pollOptions = [...this.pollOptions, t];
      }
      this.showPolls = !0;
    }
  }
  handlePollOptionChange(t, e) {
    const i = [...this.pollOptions];
    i[e].text = t.target.value, this.pollOptions = i, this.saveDraft();
  }
  handlePollOptionAdd(t, e) {
    if (e === this.pollOptions.length - 1 && this.pollOptions.length < 5) {
      const i = { id: null, text: "" };
      this.pollOptions = [...this.pollOptions, i], this.saveDraft();
    }
  }
  /**
   * Editor loading fallback dummy.
   * Hard copy of the rendered nodes when the editor is empty. Cleaned up to not be editable.
   */
  renderEditorDummy() {
    return this.editorInitialized ? Q : v`
          <div class="cm-editor">
            <div class="cm-announced"></div>
            <div tabindex="-1" class="cm-scroller">
              <div class="cm-content cm-lineWrapping">
                <div class="cm-line"
                  ><img class="cm-widgetBuffer" aria-hidden="true" /><span class="cm-placeholder"
                    >${this.placeholder}</span
                  ><br
                /></div>
              </div>
            </div>
          </div>
        `;
  }
  renderTopSlot() {
    return Q;
  }
  renderMiddleSlot() {
    return v`
      <!-- Input -->
      <div class=${Xt({ "wy-post-editor-text": !0, "wy-is-invalid": this.editorError })} ${rt(this.editorRef)}>
        ${this.renderEditorDummy()}
      </div>

      <div class="wy-post-editor-inputs">
        <div class="wy-post-editor-buttons">
          ${this.componentFeatures?.allowsFeature(z.Attachments) ? v`<wy-button
                  kind="icon"
                  @click=${this.openFileInput}
                  title=${P("From device")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon name="attachment"></wy-icon>
                </wy-button>
                <input
                  type="file"
                  ${rt(this.fileInputRef)}
                  @click=${(t) => t.stopPropagation()}
                  @change=${(t) => this.handleUploadFiles(
      Array.from(t.target.files || []),
      t.target
    )}
                  multiple
                  hidden
                  tabindex="-1"
                  ?disabled=${this.disabled}
                />` : Q}
          ${this.componentFeatures?.allowsFeature(z.CloudFiles) ? v`<wy-button
                kind="icon"
                @click=${this.openCloudFiles}
                title=${P("From cloud")}
                ?disabled=${this.disabled}
              >
                <wy-icon name="cloud"></wy-icon>
              </wy-button>` : Q}
          ${this.componentFeatures?.allowsAnyFeature(z.Meetings, z.ZoomMeetings) ? v`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("zoom")}
                  title=${P("Zoom meeting")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="zoom-meetings"></wy-icon>
                </wy-button>
              ` : Q}
          ${this.componentFeatures?.allowsAnyFeature(z.Meetings, z.GoogleMeet) ? v`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("google")}
                  title=${P("Google Meet")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="google-meet"></wy-icon>
                </wy-button>
              ` : Q}
          ${this.componentFeatures?.allowsAnyFeature(z.Meetings, z.MicrosoftTeams) ? v`
                <wy-button
                  kind="icon"
                  @click=${() => this.handleMeetingClick("microsoft")}
                  title=${P("Microsoft Teams")}
                  ?disabled=${this.disabled}
                >
                  <wy-icon svg="microsoft-teams"></wy-icon>
                </wy-button>
              ` : Q}
          ${this.componentFeatures?.allowsFeature(z.Polls) ? v`<wy-button
                kind="icon"
                @click=${() => this.openPolls()}
                title=${P("Poll")}
                ?disabled=${this.disabled}
              >
                <wy-icon name="poll"></wy-icon>
              </wy-button>` : Q}
        </div>

        <!-- Button -->
        <wy-button @click="${() => this.submit()}" color="primary" title=${this.buttonText} ?disabled=${this.disabled}>
          ${this.buttonText}
        </wy-button>
      </div>
    `;
  }
  renderBottomSlot() {
    return [this.renderLists()];
  }
  renderLists() {
    const t = this.mutatingFiles.result;
    return this.disabled ? Q : v`
      <!-- polls -->
      ${this.componentFeatures?.allowsFeature(z.Polls) && this.showPolls && this.pollOptions.length > 0 ? v`
            <div class="wy-poll-form">
              ${this.pollOptions.map((e, i) => v`<input
                  value=${e.text}
                  @change=${(s) => this.handlePollOptionChange(s, i)}
                  @keyup=${Ds}
                  class="wy-input"
                  type="text"
                  placeholder=${P("+ add an option")}
                  @focus=${(s) => this.handlePollOptionAdd(s, i)}
                />`)}
            </div>
          ` : Q}

      <!-- meetings -->
      ${this.meeting?.provider === "zoom" && this.componentFeatures?.allowsAnyFeature(z.Meetings, z.ZoomMeetings) || this.meeting?.provider === "google" && this.componentFeatures?.allowsAnyFeature(z.Meetings, z.GoogleMeet) || this.meeting?.provider === "microsoft" && this.componentFeatures?.allowsAnyFeature(z.Meetings, z.MicrosoftTeams) ? v`
            <div class="wy-item wy-list-item">
              <wy-icon svg="${sb(this.meeting.provider)}"></wy-icon>
              <div class="wy-item-body">${rb(this.meeting.provider)}</div>
              <wy-button kind="icon" @click=${() => this.handleRemoveMeeting()}>
                <wy-icon name="close-circle"></wy-icon>
              </wy-button>
            </div>
          ` : Q}

      <!-- blobs -->
      ${t && t.length ? Mi(
      t,
      (e) => "mutation" + e.submittedAt,
      (e) => {
        if (e.context?.file) {
          const i = e.context.file, s = {
            ...e.context.status
          };
          return v`
                  <wy-file-item
                    .file=${e.context.file}
                    .status=${s}
                    title="${Vb(e.context.type)}: ${i.name + (s.text ? `: ${s.text}` : "")}"
                  >
                    <span slot="title"
                      ><strong></strong> ${i.name}
                      ${s.text ? v`: <em>${s.text}</em>` : Q}</span
                    >
                    <wy-button
                      slot="actions"
                      kind="icon"
                      @click=${() => this.handleRemoveUpload(e)}
                      title=${P("Discard", { desc: "Button action to discard" })}
                    >
                      <wy-icon name="close"></wy-icon>
                    </wy-button>
                  </wy-file-item>
                `;
        }
        return Q;
      }
    ) : Q}

      <!-- attachments -->
      ${this.attachments && this.attachments.map(
      (e) => v`<wy-file-item .file=${e} title="${e.name}">
          <span slot="title">${e.name}</span>
          <wy-button
            slot="actions"
            kind="icon"
            @click=${() => this.handleRemoveAttachment(e)}
            title=${P("Remove", { desc: "Button action to remove" })}
          >
            <wy-icon name="close"></wy-icon>
          </wy-button>
        </wy-file-item>`
    )}

      <!-- embeds -->
      ${this.componentFeatures?.allowsFeature(z.Embeds) && this.embeds.length > 0 ? v`<div class="wy-embed-preview">
            ${this.embeds.map(
      (e) => v`
                <wy-embed
                  class="wy-embed"
                  .embed=${e}
                  @embed-remove=${(i) => this.removeEmbed(i)}
                  @embed-swap=${() => this.swapEmbed()}
                  .enableSwap=${this.embeds.length > 1}
                ></wy-embed>
              `
    )}
          </div> ` : Q}
    `;
  }
  renderCloudFiles() {
    return this.disabled ? Q : v`
      <wy-cloud-files
        ${rt(this.cloudFilesRef)}
        @external-blobs=${(t) => this.handleExternalBlobs(t.detail.externalBlobs)}
      ></wy-cloud-files>
    `;
  }
  render() {
    const t = this.dropZone.isDragActive;
    return v`
      <div
        class=${Xt({
      "wy-editor": !0,
      [this.editorClass]: !0,
      "wy-dragging": t
    })}
        data-drag-title=${P("Drop files here to upload.")}
      >
        ${this.renderTopSlot()} ${this.renderMiddleSlot()} ${this.renderBottomSlot()}
      </div>
      ${this.renderCloudFiles()}
    `;
  }
}, c(Hp, "Na"), Hp), d(P2, "WyEditor"), P2);
qt.styles = ft;
ne([
  O({ type: Boolean })
], qt.prototype, "disabled", 2);
ne([
  O({ attribute: !1 })
], qt.prototype, "parentId", 2);
ne([
  O()
], qt.prototype, "placeholder", 1);
ne([
  O()
], qt.prototype, "text", 2);
ne([
  O({ type: Object })
], qt.prototype, "metadata", 2);
ne([
  O({ attribute: !1 })
], qt.prototype, "embed", 2);
ne([
  O({ attribute: !1 })
], qt.prototype, "options", 2);
ne([
  O({ attribute: !1 })
], qt.prototype, "attachments", 2);
ne([
  O()
], qt.prototype, "buttonText", 2);
ne([
  O({ type: Boolean })
], qt.prototype, "typing", 2);
ne([
  O({ type: Boolean })
], qt.prototype, "draft", 2);
ne([
  O()
], qt.prototype, "editorType", 2);
ne([
  O()
], qt.prototype, "editorClass", 2);
ne([
  O()
], qt.prototype, "editorLocation", 2);
ne([
  F()
], qt.prototype, "meeting", 2);
ne([
  F()
], qt.prototype, "editorError", 2);
ne([
  F()
], qt.prototype, "showPolls", 2);
ne([
  F()
], qt.prototype, "pollOptions", 2);
ne([
  F()
], qt.prototype, "embeds", 2);
ne([
  F()
], qt.prototype, "draftKey", 2);
ne([
  F()
], qt.prototype, "mutationAppId", 2);
ne([
  F()
], qt.prototype, "keyMap", 2);
ne([
  F()
], qt.prototype, "editorExtensions", 2);
ne([
  F()
], qt.prototype, "editor", 2);
qt = ne([
  X("wy-editor"),
  bt()
], qt);
var pH = Object.defineProperty, fH = Object.getOwnPropertyDescriptor, tr = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? fH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && pH(t, e, s), s;
}, "__decorateClass$F"), C2, Yp;
let ln = (C2 = (Yp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.location = "apps", this.text = "", this.attachments = [], this.pollOptions = [], this.updateCommentMutation = new en(this);
  }
  dispatchEdit(t) {
    const e = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(e);
  }
  handleSubmit(t) {
    this.updateCommentMutation.mutate({
      id: this.commentId,
      type: this.location,
      parent_id: this.parentId,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      attachments: t.detail.attachments,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId
    }), this.dispatchEdit(!1);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("parentId") || t.has("weavy")) && this.parentId && this.weavy && await this.updateCommentMutation.trackMutation(
      EL(this.weavy, [this.location, this.parentId, "comments"])
    );
  }
  render() {
    return v`
      <nav class="wy-item">
        <div class="wy-item-body">
          <div class="wy-item-title">${P("Edit comment")}</div>
        </div>

        <wy-button @click=${() => this.dispatchEdit(!1)} kind="icon">
          <wy-icon name="close"></wy-icon>
        </wy-button>
      </nav>
      <wy-editor
        editorLocation=${this.location}
        .text=${this.text}
        .embed=${this.embed}
        .options=${this.pollOptions}
        .attachments=${this.attachments ?? []}
        .parentId=${this.commentId}
        .typing=${!1}
        .draft=${!1}
        placeholder=${P("Edit comment...")}
        buttonText=${P("Update", { desc: "Button action to update" })}
        @submit=${(t) => this.handleSubmit(t)}></wy-editor>
    `;
  }
}, c(Yp, "ja"), Yp), d(C2, "WyCommentEdit"), C2);
ln.styles = ft;
tr([
  xe({ context: Le, subscribe: !0 }),
  F()
], ln.prototype, "weavy", 2);
tr([
  O({ type: Number })
], ln.prototype, "parentId", 2);
tr([
  O({ attribute: !1 })
], ln.prototype, "location", 2);
tr([
  O({ type: Number })
], ln.prototype, "commentId", 2);
tr([
  O()
], ln.prototype, "text", 2);
tr([
  O({ type: Array })
], ln.prototype, "attachments", 2);
tr([
  O({ type: Array })
], ln.prototype, "pollOptions", 2);
tr([
  O({ attribute: !1 })
], ln.prototype, "embed", 2);
ln = tr([
  X("wy-comment-edit"),
  bt()
], ln);
var yH = Object.defineProperty, mH = Object.getOwnPropertyDescriptor, Ze = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? mH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && yH(t, e, s), s;
}, "__decorateClass$E"), Q2, Gp;
let fe = (Q2 = (Gp = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.location = "apps", this.createdAt = "", this.modifiedAt = void 0, this.isTrashed = !1, this.html = "", this.text = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.commentCount = 0, this.seenBy = [], this.editing = !1;
  }
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t, parentId: this.commentId, parentType: "comments" } });
    return this.dispatchEvent(e);
  }
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.commentId } });
    return this.dispatchEvent(t);
  }
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: { id: this.commentId } });
    return this.dispatchEvent(t);
  }
  render() {
    return v`
      ${this.isTrashed ? v`<wy-comment-trashed
            class="wy-comment"
            commentId=${this.commentId}
            @restore=${() => {
      this.dispatchRestore();
    }}></wy-comment-trashed> ` : Q}
      ${!this.isTrashed && this.editing ? v`<wy-comment-edit
            class="wy-comment"
            .commentId=${this.commentId}
            .parentId=${this.parentId}
            .location=${this.location}
            .text=${this.text}
            .pollOptions=${this.pollOptions}
            .attachments=${this.attachments}
            .embed=${this.embed}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}></wy-comment-edit> ` : Q}
      ${!this.isTrashed && !this.editing ? v`<wy-comment-view
            class="wy-comment"
            id="comment-view-${this.commentId}"
            .commentId=${this.commentId}
            .parentId=${this.parentId}
            .location=${this.location}
            .createdBy=${this.createdBy}
            .createdAt=${this.createdAt}
            .modifiedAt=${this.modifiedAt}
            .isTrashed=${this.isTrashed}
            .text=${this.text}
            .html=${this.html}
            .annotations=${this.annotations}          
            .attachments=${this.attachments}
            .embed=${this.embed}
            .meeting=${this.meeting}
            .pollOptions=${this.pollOptions}
            .reactions=${this.reactions}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}
            @trash=${() => {
      this.dispatchTrash();
    }}
            @vote=${(t) => {
      this.dispatchVote(t.detail.optionId);
    }}></wy-comment-view> ` : Q}
    `;
  }
}, c(Gp, "Wa"), Gp), d(Q2, "WyComment"), Q2);
fe.styles = [ft, Tt];
Ze([
  O({ type: Number })
], fe.prototype, "commentId", 2);
Ze([
  O({ type: Number })
], fe.prototype, "parentId", 2);
Ze([
  O({ attribute: !1 })
], fe.prototype, "location", 2);
Ze([
  O({ attribute: !1 })
], fe.prototype, "createdBy", 2);
Ze([
  O()
], fe.prototype, "createdAt", 2);
Ze([
  O()
], fe.prototype, "modifiedAt", 2);
Ze([
  O({ type: Boolean })
], fe.prototype, "isTrashed", 2);
Ze([
  O()
], fe.prototype, "html", 2);
Ze([
  O()
], fe.prototype, "text", 2);
Ze([
  O({ attribute: !1 })
], fe.prototype, "annotations", 2);
Ze([
  O({ attribute: !1 })
], fe.prototype, "attachments", 2);
Ze([
  O({ type: Array })
], fe.prototype, "pollOptions", 2);
Ze([
  O({ attribute: !1 })
], fe.prototype, "meeting", 2);
Ze([
  O({ attribute: !1 })
], fe.prototype, "embed", 2);
Ze([
  O({ type: Array })
], fe.prototype, "reactions", 2);
Ze([
  O({ attribute: !1 })
], fe.prototype, "commentCount", 2);
Ze([
  O({ type: Array })
], fe.prototype, "seenBy", 2);
Ze([
  F()
], fe.prototype, "editing", 2);
fe = Ze([
  X("wy-comment")
], fe);
var wH = Object.getOwnPropertyDescriptor, gH = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? wH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = a(s) || s);
  return s;
}, "__decorateClass$D"), M2, Kp;
let jk = (M2 = (Kp = class extends qt {
  constructor() {
    super(), this.editorType = "comments", this.editorClass = "wy-comment-editor";
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("editorLocation") && this.editorLocation === "files" && (this.editorClass = "wy-comment-editor wy-comment-editor-bottom");
  }
  renderTopSlot() {
    return Q;
  }
  renderMiddleSlot() {
    return v`<div class="wy-comment-editor-inputs">
      <!-- Add -->
      ${this.componentFeatures?.allowsAnyFeature(
      z.Attachments,
      z.CloudFiles,
      z.Meetings,
      z.ZoomMeetings,
      z.GoogleMeet,
      z.MicrosoftTeams,
      z.Polls
    ) ? v`<wy-dropdown icon="plus" directionY="up" ?disabled=${this.disabled}>
            ${this.componentFeatures?.allowsFeature(z.Attachments) ? v`<wy-dropdown-item @click=${this.openFileInput} title=${P("From device")}>
                    <wy-icon name="attachment"></wy-icon>
                    <span>${P("From device")}</span>
                  </wy-dropdown-item>
                  <input
                    type="file"
                    ${rt(this.fileInputRef)}
                    @click=${(t) => t.stopPropagation()}
                    @change=${(t) => this.handleUploadFiles(
      Array.from(t.target.files || []),
      t.target
    )}
                    multiple
                    hidden
                    tabindex="-1"
                  />` : Q}
            ${this.componentFeatures?.allowsFeature(z.CloudFiles) ? v`<wy-dropdown-item @click=${this.openCloudFiles} title=${P("From cloud")}>
                  <wy-icon name="cloud"></wy-icon>
                  <span>${P("From cloud")}</span>
                </wy-dropdown-item>` : Q}
            ${this.componentFeatures?.allowsAnyFeature(z.Meetings, z.ZoomMeetings) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("zoom")} title=${P("Zoom meeting")}>
                    <wy-icon svg="zoom-meetings"></wy-icon>
                    <span>${P("Zoom meeting")}</span>
                  </wy-dropdown-item>
                ` : Q}
            ${this.componentFeatures?.allowsAnyFeature(z.Meetings, z.GoogleMeet) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("google")} title=${P("Google Meet")}>
                    <wy-icon svg="google-meet"></wy-icon>
                    <span>${P("Google Meet")}</span>
                  </wy-dropdown-item>
                ` : Q}
            ${this.componentFeatures?.allowsAnyFeature(z.Meetings, z.MicrosoftTeams) ? v`
                  <wy-dropdown-item
                    @click=${() => this.handleMeetingClick("microsoft")}
                    title=${P("Microsoft Teams")}
                  >
                    <wy-icon svg="microsoft-teams"></wy-icon>
                    <span>${P("Microsoft Teams")}</span>
                  </wy-dropdown-item>
                ` : Q}
            ${this.componentFeatures?.allowsFeature(z.Polls) ? v`<wy-dropdown-item @click=${() => this.openPolls()} title=${P("Poll")}>
                  <wy-icon name="poll"></wy-icon>
                  <span>${P("Poll")}</span>
                </wy-dropdown-item>` : Q}
          </wy-dropdown>` : Q}

      <!-- Input -->
      <div
        class=${Xt({ "wy-comment-editor-text": !0, "wy-is-invalid": this.editorError })}
        ${rt(this.editorRef)}
      >
        ${this.renderEditorDummy()}
      </div>

      <!-- Button -->
      <wy-button kind="icon" @click="${() => this.submit()}" title=${this.buttonText} ?disabled=${this.disabled}>
        <wy-icon name="send"></wy-icon>
      </wy-button>
    </div>`;
  }
  renderBottomSlot() {
    return [
      this.renderLists()
    ];
  }
}, c(Kp, "Qa"), Kp), d(M2, "WyCommentEditor"), M2);
jk = gH([
  X("wy-comment-editor"),
  bt()
], jk);
var vH = Object.defineProperty, bH = Object.getOwnPropertyDescriptor, YL = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$b"), lO = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? bH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && vH(t, e, s), s;
}, "__decorateClass$C"), GL = /* @__PURE__ */ d((n, t, e) => t.has(n) || YL("Cannot " + e), "__accessCheck$b"), Kg = /* @__PURE__ */ d((n, t, e) => (GL(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$b"), T2 = /* @__PURE__ */ d((n, t, e) => t.has(n) ? YL("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$b"), A2 = /* @__PURE__ */ d((n, t, e, i) => (GL(n, t, "write to private field"), t.set(n, e), e), "__privateSet$a"), F1, Fk, Oc, R2, Jp;
let el = (R2 = (Jp = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.location = "apps", T2(this, F1), T2(this, Fk, new Promise((t) => {
      A2(this, F1, t);
    })), this.commentsQuery = new dl(this), this.addCommentMutation = new en(this), this.infiniteScroll = new ul(this), this.pagerRef = mt(), T2(this, Oc), this.handleRealtimeCommentCreated = () => {
      this.weavy?.queryClient.invalidateQueries({ queryKey: [this.location, this.parentId, "comments"] });
    }, this.handleRealtimeReactionAdded = (t) => {
      !this.weavy || t.entity.type !== ci.Comment || Oe(
        this.weavy.queryClient,
        [this.location, this.parentId, "comments"],
        t.entity.id,
        (e) => {
          hy(e, t.reaction, t.actor);
        }
      );
    }, this.handleRealtimeReactionDeleted = (t) => {
      !this.weavy || t.entity.type !== ci.Comment || Oe(
        this.weavy.queryClient,
        [this.location, this.parentId, "comments"],
        t.entity.id,
        (e) => {
          hy(e, void 0, t.actor);
        }
      );
    };
  }
  async whenParentId() {
    return await Kg(this, Fk);
  }
  async willUpdate(t) {
    var e, i;
    if (super.willUpdate(t), t.has("parentId") && this.parentId && ((e = Kg(this, F1)) == null || e.call(this, this.parentId)), (t.has("parentId") || t.has("weavy") || t.has("componentFeatures")) && this.parentId && this.weavy && (await this.commentsQuery.trackInfiniteQuery(RL(this.weavy, this.location, this.parentId)), await this.addCommentMutation.trackMutation(_L(this.weavy)), this.removeCommentMutation = LL(this.weavy, this.location, this.parentId), this.restoreCommentMutation = ZL(this.weavy, this.location, this.parentId)), (t.has("weavy") || t.has("app") || t.has("componentFeatures")) && this.weavy && this.app) {
      this.pollMutation = Kb(this.weavy, this.app.id, [this.location, this.parentId, "comments"]), (i = Kg(this, Oc)) == null || i.call(this);
      const s = `a${this.app.id}`;
      this.weavy.subscribe(s, "comment_created", this.handleRealtimeCommentCreated), this.componentFeatures?.allowsFeature(z.Reactions) && (this.weavy.subscribe(s, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(s, "reaction_removed", this.handleRealtimeReactionDeleted)), A2(this, Oc, () => {
        this.weavy?.unsubscribe(s, "comment_created", this.handleRealtimeCommentCreated), this.weavy?.unsubscribe(s, "reaction_added", this.handleRealtimeReactionAdded), this.weavy?.unsubscribe(s, "reaction_removed", this.handleRealtimeReactionDeleted), A2(this, Oc, void 0);
      });
    }
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.commentsQuery.result, this.pagerRef.value);
  }
  async handleSubmit(t) {
    this.app && this.parentId && this.user && await this.addCommentMutation.mutate({
      app_id: this.app.id,
      parent_id: this.parentId,
      type: this.location,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      context: t.detail.contextData,
      user: this.user
    });
  }
  renderComments(t) {
    return t ? Mi(
      t,
      (e) => e.id,
      (e) => this.parentId ? v`<wy-comment
              id="comment-${e.id}"
              .commentId=${e.id}
              .parentId=${this.parentId}
              .location=${this.location}
              .createdBy=${e.created_by}
              .createdAt=${e.created_at}
              .modifiedAt=${e.updated_at}
              .isTrashed=${e.is_trashed}
              .html=${e.html}
              .text=${e.text}
              .annotations=${e.annotations?.data}
              .attachments=${e.attachments?.data}
              .embed=${e.embed}
              .meeting=${e.meeting}
              .pollOptions=${e.options?.data}
              .reactions=${e.reactions?.data}
              @trash=${async (i) => {
        const s = await this.whenApp(), r = await this.whenParentId();
        this.removeCommentMutation?.mutate({
          id: i.detail.id,
          appId: s.id,
          parentId: r,
          type: this.location
        });
      }}
              @restore=${async (i) => {
        const s = await this.whenApp(), r = await this.whenParentId();
        this.restoreCommentMutation?.mutate({
          id: i.detail.id,
          appId: s.id,
          parentId: r,
          type: this.location
        });
      }}
              @vote=${(i) => {
        i.detail.parentId && i.detail.parentType && this.pollMutation?.mutate({
          optionId: i.detail.optionId,
          parentType: i.detail.parentType,
          parentId: i.detail.parentId
        });
      }}
            ></wy-comment>` : Q
    ) : Q;
  }
  render() {
    const { data: t, hasNextPage: e, isPending: i } = this.commentsQuery.result ?? {}, s = hs(t), r = {
      "wy-comments": !0,
      "wy-comments-padded": this.location === "files"
    };
    return v`
      ${s && s.length ? v`
            <div class=${Xt(r)}>
              ${this.renderComments(s)}
              ${e ? v`<div ${rt(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : Q}
            </div>
          ` : i ? v`<wy-empty noNetwork><wy-spinner padded reveal></wy-spinner></wy-empty>` : Q}

      <wy-comment-editor
        editorLocation=${this.location}
        .parentId=${this.parentId}
        .typing=${!1}
        .draft=${!0}
        ?disabled=${!sy(Uo.Create, this.app?.permissions)}
        placeholder=${this.placeholder ?? P("Create a comment...")}
        buttonText=${P("Comment", { desc: "Button action to comment" })}
        @submit=${(a) => this.handleSubmit(a)}
      ></wy-comment-editor>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = Kg(this, Oc)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Jp, "Ka"), Jp), d(R2, "WyCommentList"), R2);
F1 = /* @__PURE__ */ new WeakMap();
Fk = /* @__PURE__ */ new WeakMap();
Oc = /* @__PURE__ */ new WeakMap();
el.styles = [ft, ma];
lO([
  O({ type: Number })
], el.prototype, "parentId", 2);
lO([
  O({ attribute: !1 })
], el.prototype, "location", 2);
lO([
  O()
], el.prototype, "placeholder", 2);
el = lO([
  X("wy-comment-list"),
  bt()
], el);
function cO(n, t) {
  return ["apps", n.id, "file", t.id, "versions"];
}
c(cO, "$p");
d(cO, "getFileVersionsKey");
function KL(n, t, e) {
  const i = n.queryClient, s = ["apps", t.id, "files"], r = cO(t, e), a = {
    mutationKey: s,
    mutationFn: /* @__PURE__ */ d(async ({ versionFile: o }) => {
      if (o.id >= 1 && o.rev) {
        if (!(await n.fetch(`/api/files/${o.id}/versions/${o.rev}/restore`, {
          method: "POST"
        })).ok)
          throw new Error();
      } else
        throw new Error(`Could not restore ${o.name} to version ${o.rev}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((o) => (Ot(
      i,
      { queryKey: a.mutationKey, exact: !1 },
      o.versionFile.id,
      (l) => Object.assign(l, o.versionFile, { status: "pending" })
    ), { type: "version", file: e, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ d((o, l) => {
      Ot(
        i,
        { queryKey: a.mutationKey, exact: !1 },
        l.versionFile.id,
        (h) => Object.assign(h, o, { status: "ok" })
      ), ce(i, a.mutationKey, l, (h) => {
        h.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ d((o, l, h) => {
      h?.file && Ot(
        i,
        { queryKey: a.mutationKey, exact: !1 },
        l.versionFile.id,
        (u) => Object.assign(u, h.file, { status: "error" })
      ), ce(i, a.mutationKey, l, (u) => {
        u.status.state = "error", u.status.text = o.message;
      });
    }, "onError"),
    onSettled: /* @__PURE__ */ d(async () => {
      await i.invalidateQueries({ queryKey: r });
    }, "onSettled")
  };
  return a;
}
c(KL, "h4");
d(KL, "getFileVersionRestoreMutationOptions");
function JL(n, t, e) {
  return new jt(n.queryClient, KL(n, t, e));
}
c(JL, "u4");
d(JL, "getFileVersionRestoreMutation");
function tI(n, t, e) {
  const i = n.queryClient, s = cO(t, e);
  return {
    mutationKey: s,
    mutationFn: /* @__PURE__ */ d(async ({ versionFile: r }) => {
      if (r.id >= 1 && r.rev) {
        const a = await n.fetch(`/api/files/${r.id}/versions/${r.rev}`, {
          method: "DELETE"
        });
        if (!a.ok) {
          const o = await a.json();
          throw new Error(o.detail || o.title, { cause: o });
        }
      } else {
        const a = {
          status: 400,
          title: `Could not remove ${r.name} version ${r.rev}.`
        };
        throw new Error(a.detail || a.title, { cause: a });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((r) => {
      Oe(
        i,
        s,
        /* @__PURE__ */ d((a) => a.id === r.versionFile.id && a.rev === r.versionFile.rev, "versionPredicate"),
        (a) => Object.assign(a, { status: "pending" })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((r, a) => {
      Gb(i, s, /* @__PURE__ */ d((o) => o.id === a.versionFile.id && o.rev === a.versionFile.rev, "versionPredicate"));
    }, "onSuccess"),
    onError: /* @__PURE__ */ d((r, a) => {
      Oe(
        i,
        s,
        /* @__PURE__ */ d((o) => o.id === a.versionFile.id && o.rev === a.versionFile.rev, "versionPredicate"),
        (o) => Object.assign(o, { status: void 0 })
      );
    }, "onError")
  };
}
c(tI, "p4");
d(tI, "getFileVersionDeleteMutationOptions");
function eI(n, t, e) {
  return new jt(n.queryClient, tI(n, t, e));
}
c(eI, "y4");
d(eI, "getFileVersionDeleteMutation");
var OH = Object.defineProperty, $H = Object.getOwnPropertyDescriptor, fC = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? $H(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && OH(t, e, s), s;
}, "__decorateClass$B"), E2, tf;
let fy = (E2 = (tf = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.fileVersionsQuery = new ns(this);
  }
  selectVersion(t) {
    this.activeVersion = t, this.dispatchFileVersionSelect(t);
  }
  dispatchFileVersionSelect(t) {
    const e = new CustomEvent("file-version-select", { detail: { versionFile: t } });
    return this.dispatchEvent(e);
  }
  handleRevert(t) {
    this.fileVersionRestoreMutation?.mutate({ versionFile: t }), this.selectVersion(t);
  }
  handleRemove(t) {
    this.fileVersionDeleteMutation?.mutate({ versionFile: t }), this.activeVersion === t && (this.activeVersion = this.file);
  }
  triggerDownload(t) {
    Xc(t.download_url, "_top", t.name, !0);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("file") || t.has("app")) && this.weavy && this.file && this.app && (await this.fileVersionsQuery.trackQuery(
      ll(
        this.weavy,
        cO(this.app, this.file),
        `/api/files/${this.file.id}/versions`
      )
    ), this.fileVersionRestoreMutation = JL(this.weavy, this.app, this.file), this.fileVersionDeleteMutation = eI(this.weavy, this.app, this.file));
  }
  render() {
    const { data: t, isPending: e } = this.fileVersionsQuery.result ?? { isPending: !0 };
    return e ? v`<wy-spinner overlay></wy-spinner>` : t?.data ? v`
          <div class="wy-list wy-versions">
            ${Mi(
      t.data,
      (i) => i.id,
      (i, s) => {
        const r = Mn(i.name || "").icon, a = t.data ? t.data.length - s : NaN, o = Ei(i.name), l = new Date(i.updated_at || i.created_at), h = !!this.file.external_url, u = new Intl.DateTimeFormat(this.weavy?.locale, {
          dateStyle: "full",
          timeStyle: "short"
        }).format(l), p = zy(this.weavy?.locale, new Date(l));
        return h ? v`
                      <wy-empty noNetwork>
                        <span slot="title">${P("Versions are not available for external cloud files.")}</span>
                      </wy-empty>
                    ` : v`
                      <div
                        class="wy-item wy-list-item-lg wy-item-hover ${Xt({
          "wy-active": i.rev == this.activeVersion?.rev
        })}"
                        tabindex="0"
                        @click=${() => this.selectVersion(i)}
                        @keydown=${Fe}
                        @keyup=${vi}
                      >
                        <wy-icon name=${r} size="48" kind=${i.kind} ext=${o}></wy-icon>
                        <div class="wy-item-body">
                          <div class="wy-item-title">${a}. ${i.name}</div>
                          <div class="wy-item-text">
                            <time datetime=${i.updated_at || i.created_at} title=${u}
                              >${p}</time
                            >
                            · ${i.updated_by?.name}</div
                          >
                        </div>

                        <wy-dropdown directionX="left">
                          <wy-dropdown-item @click=${() => this.triggerDownload(i)}>
                            <wy-icon name="download"></wy-icon>
                            ${P("Download")}
                          </wy-dropdown-item>                          

                          ${s !== 0 ? v`
                                <wy-dropdown-divider></wy-dropdown-divider>
                                <wy-dropdown-item @click=${() => this.handleRevert(i)}>
                                  <wy-icon name="restore"></wy-icon>
                                  ${"Revert"}
                                </wy-dropdown-item>
                                <wy-dropdown-item @click=${() => this.handleRemove(i)}>
                                  <wy-icon name="delete"></wy-icon>
                                  ${P("Remove", { desc: "Button action to remove" })}
                                </wy-dropdown-item>
                              ` : Q}
                        </wy-dropdown>
                      </div>
                    `;
      }
    )}
          </div>
        ` : Q;
  }
}, c(tf, "Ga"), tf), d(E2, "WyFileVersions"), E2);
fy.styles = ft;
fC([
  O({ attribute: !1 })
], fy.prototype, "file", 2);
fC([
  O({ attribute: !1 })
], fy.prototype, "activeVersion", 2);
fy = fC([
  X("wy-file-versions"),
  bt()
], fy);
var xH = Object.defineProperty, kH = Object.getOwnPropertyDescriptor, ai = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? kH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && xH(t, e, s), s;
}, "__decorateClass$A"), _2, ef;
let Ae = (_2 = (ef = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.currentId = NaN, this.isAttachment = !1, this.filled = !1, this.showOverlay = !1, this.commentsOpen = !1, this.versionsOpen = !1, this.sidePanelMaximized = !1, this.persistState = new hC(this), this.previewFileRef = mt(), this.swipeScrollRef = mt(), this.prevRef = mt(), this.nextRef = mt(), this.swipeScroller = new $N(this), this.disableSwipeScroll = !1, this.handleKeys = (t) => {
      this.showOverlay && (t.key === "ArrowLeft" ? (t.stopPropagation(), this.setPrev()) : t.key === "ArrowRight" && (t.stopPropagation(), this.setNext()));
    };
  }
  async dispatchOpen() {
    const t = await this.whenApp(), e = await this.whenComponentFeatures(), i = this.currentId, s = this.commentsOpen ? "comments" : this.versionsOpen ? "versions" : void 0, r = this.currentFile ? [this.currentFile] : [], a = this.isAttachment, o = this.contextDataBlobs, l = new CustomEvent("wy-preview-open", {
      detail: { fileId: i, tab: s, files: r, app: t, features: e.allowedFeatures().join(" "), isAttachment: a, contextDataBlobs: o },
      cancelable: !0,
      bubbles: !1,
      composed: !0
    });
    this.dispatchEvent(l) || (this.showOverlay = !1, this.commentsOpen = !1, this.versionsOpen = !1);
  }
  dispatchClose() {
    const t = new CustomEvent("wy-preview-close", {
      cancelable: !1,
      bubbles: !1,
      composed: !0
    });
    this.dispatchEvent(t);
  }
  async open(t, e) {
    await this.whenApp(), await this.updateComplete, t && (this.currentId = t), e && this.toggleSidebarTab(e, !0), this.showOverlay = !0;
  }
  close() {
    this.showOverlay = !1;
  }
  toggleSidebarTab(t, e) {
    t === "comments" ? (this.versionsOpen = !1, this.commentsOpen = e !== void 0 ? e : !this.commentsOpen) : t === "versions" ? (this.commentsOpen = !1, this.versionsOpen = e !== void 0 ? e : !this.versionsOpen) : (this.commentsOpen = !1, this.versionsOpen = !1);
  }
  handleVersionFile(t) {
    this.versionFile = t.detail.versionFile;
  }
  scrollToPrev() {
    this.prevRef.value && (this.unblockSwipeScroll(), this.prevRef.value.scrollIntoView({ behavior: this.weavy?.scrollBehavior }));
  }
  scrollToNext() {
    this.nextRef.value && (this.unblockSwipeScroll(), this.nextRef.value.scrollIntoView({ behavior: this.weavy?.scrollBehavior }));
  }
  blockSwipeScroll(t = 20) {
    window.clearTimeout(this.disableSwipeScrollTimeout), this.disableSwipeScroll = !0, this.disableSwipeScrollTimeout = window.setTimeout(() => this.disableSwipeScroll = !1, t);
  }
  unblockSwipeScroll() {
    window.clearTimeout(this.disableSwipeScrollTimeout), this.disableSwipeScroll = !1;
  }
  setPrev() {
    this.previousFile && (this.currentId = this.previousFile.id, this.blockSwipeScroll());
  }
  setNext() {
    this.nextFile && (this.currentId = this.nextFile.id, this.blockSwipeScroll());
  }
  async willUpdate(t) {
    if (super.willUpdate(t), (t.has("app") || t.has("user")) && this.app && this.user && !this.isAttachment && (this.persistState.observe(
      [
        { name: "commentsOpen", override: !0 },
        { name: "versionsOpen", override: !0 }
      ],
      `a${this.app.id}-preview`,
      `u${this.user.id}`
    ), this.commentsOpen && this.versionsOpen && (this.versionsOpen = !1)), t.has("queryResult") && this.queryResult) {
      const { data: e } = this.queryResult ?? {};
      this.files = e?.filter((i) => i && !i.is_trashed);
    }
    if (t.has("infiniteQueryResult") && this.infiniteQueryResult) {
      const { data: e } = this.infiniteQueryResult ?? {};
      this.files = hs(e).filter((i) => i && !i.is_trashed);
    }
    t.has("currentFile") && this.currentFile && this.currentFile.id !== this.currentId && (this.currentId = this.currentFile.id), (t.has("files") || t.has("currentId") || t.has("showOverlay")) && this.files && this.showOverlay && (this.currentFile = void 0, this.previousFile = void 0, this.nextFile = void 0, this.versionFile = void 0, this.currentFile = this.files.find((e, i) => this.files && e.id === this.currentId ? (i >= 1 && (this.previousFile = this.files[i - 1]), i < this.files.length - 1 && (this.nextFile = this.files[i + 1]), this.infiniteQueryResult && i >= this.files.length - 2 && this.infiniteQueryResult.hasNextPage && !this.infiniteQueryResult.isFetchingNextPage && this.infiniteQueryResult.fetchNextPage(), this.infiniteQueryResult && i <= 1 && this.infiniteQueryResult.hasPreviousPage && !this.infiniteQueryResult.isFetchingPreviousPage && this.infiniteQueryResult.fetchPreviousPage(), !0) : !1)), t.has("currentFile") && this.currentFile && !this.files && (this.files = [this.currentFile]), t.has("showOverlay") && (this.showOverlay ? await this.dispatchOpen() : t.get("showOverlay") && this.dispatchClose());
  }
  renderHeader(t) {
    const e = {
      "wy-appbar-text-trashed": !!t?.is_trashed
    };
    return v` <header class="wy-appbars">
      <nav class="wy-appbar">
        <wy-button kind="icon" @click=${() => this.close()}><wy-icon name="close"></wy-icon></wy-button>
        <div class="wy-appbar-text ${Xt(e)}">
          ${t ? v` <span>${t.name}</span> ` : Q}
        </div>
        <div class="wy-appbar-buttons wy-appbar-buttons-last">
          ${t ? v`
                ${this.componentFeatures?.allowsFeature(z.Comments) && t.id >= 1 && !this.isAttachment ? v`
                      <wy-button
                        kind="icon"
                        ?active=${this.commentsOpen}
                        @click=${() => this.toggleSidebarTab("comments")}
                        title=${P("Comments")}
                      >
                        <wy-icon-stack>
                          ${t.comments?.count && t.comments?.count > 0 ? v`<wy-icon name="comment" state ?active=${!this.commentsOpen}></wy-icon>
                                <wy-icon name="comment" layer state ?active=${this.commentsOpen}></wy-icon>` : v`<wy-icon name="comment-outline" state ?active=${!this.commentsOpen}></wy-icon>
                                <wy-icon name="comment" layer state ?active=${this.commentsOpen}></wy-icon>`}
                        </wy-icon-stack>
                      </wy-button>
                    ` : Q}
                <wy-file-menu .file=${t}>
                  ${this.componentFeatures?.allowsFeature(z.Versions) && t.id >= 1 && !this.isAttachment ? v`
                        <wy-dropdown-item
                          ?active=${this.versionsOpen}
                          @click=${() => this.toggleSidebarTab("versions")}
                        >
                          <wy-icon name="backup-restore"></wy-icon>
                          ${P("Versions")}
                        </wy-dropdown-item>
                      ` : Q}
                </wy-file-menu>
              ` : Q}
        </div>
      </nav>
    </header>`;
  }
  render() {
    let t = this.files === void 0;
    this.queryResult ? t = this.queryResult.isPending : this.infiniteQueryResult && (t = this.infiniteQueryResult.isPending);
    const e = this.versionFile || this.currentFile, i = [this.previousFile, e, this.nextFile].filter((r) => r);
    this.commentsOpen && this.versionsOpen && (this.versionsOpen = !1);
    const s = {
      "wy-preview-swiper-disabled": this.disableSwipeScroll
    };
    return this.weavy ? v`
      <wy-overlay
        class="wy-dark"
        maximized
        ?filled=${this.filled}
        .show=${this.showOverlay}
        @keyup=${this.handleKeys}
        @close=${() => {
      this.showOverlay = !1;
    }}
        @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
      >
        ${this.showOverlay ? v`<div class="wy-preview-layout">
              ${this.renderHeader(this.currentFile)}

              <div class="wy-main">
                ${this.isAttachment ? Q : v` <aside
                        id="tab-comments"
                        class="wy-sidebar ${Xt({
      "wy-active": this.commentsOpen,
      "wy-maximized": this.sidePanelMaximized
    })}"
                        ?hidden=${!this.commentsOpen}
                      >
                        <nav class="wy-item">
                          <div class="wy-item-body">
                            <div class="wy-item-title">${P("Comments")}</div>
                          </div>
                          <wy-button kind="icon" @click=${() => this.toggleSidebarTab("comments", !1)}>
                            <wy-icon name="close"></wy-icon>
                          </wy-button>
                          <button
                            @click=${() => this.sidePanelMaximized = !this.sidePanelMaximized}
                            class="wy-sidebar-handle"
                            title=${this.sidePanelMaximized ? P("Restore side panel") : P("Maximize side panel")}
                          ></button>
                        </nav>
                        <div class="wy-pane wy-scroll-y">
                          ${this.commentsOpen && this.currentFile && this.currentFile.id >= 1 && this.app && this.user ? v`
                                <wy-comment-list
                                  .parentId=${this.currentFile.id}
                                  .location=${"files"}
                                ></wy-comment-list>
                              ` : Q}
                        </div>
                      </aside>
                      <aside
                        id="tab-versions"
                        class="wy-sidebar ${Xt({
      "wy-active": this.versionsOpen,
      "wy-maximized": this.sidePanelMaximized
    })}"
                        ?hidden=${!this.versionsOpen}
                      >
                        <nav class="wy-item">
                          <div class="wy-item-body">
                            <div class="wy-item-title">${P("Versions")}</div>
                          </div>
                          <wy-button kind="icon" @click=${() => this.toggleSidebarTab("versions", !1)}>
                            <wy-icon name="close"></wy-icon>
                          </wy-button>
                          <button
                            @click=${() => this.sidePanelMaximized = !this.sidePanelMaximized}
                            class="wy-sidebar-handle"
                            title=${this.sidePanelMaximized ? P("Restore side panel") : P("Maximize side panel")}
                          ></button>
                        </nav>
                        <div class="wy-pane wy-scroll-y">
                          <div class="wy-pane-body">
                            ${this.versionsOpen && this.currentFile && this.app ? v`
                                  <wy-file-versions
                                    .file=${this.currentFile}
                                    .activeVersion=${this.versionFile || this.currentFile}
                                    @file-version-select=${(r) => this.handleVersionFile(r)}
                                  ></wy-file-versions>
                                ` : Q}
                          </div>
                        </div>
                      </aside>`}

                <div class="wy-preview">
                  <div ${rt(this.swipeScrollRef)} class="wy-preview-swiper ${Xt(s)}">
                    ${Mi(
      i,
      (r) => "preview-area-" + r?.id,
      (r) => {
        const a = r === e ? /* @__PURE__ */ d((o) => {
          o?.scrollIntoView(), requestAnimationFrame(() => o?.scrollIntoView());
        }, "currentPreviewFileCallback") : r === this.nextFile ? this.nextRef : r === this.previousFile ? this.prevRef : void 0;
        return r ? v`
                              <div
                                id="preview-${r.id}"
                                ${rt(a)}
                                class="wy-preview-area wy-scroll-y wy-scroll-x"
                              >
                                ${t ? v` <wy-spinner overlay></wy-spinner> ` : v` <wy-preview-item .file=${r} ?current=${r === e}></wy-preview-item> `}
                              </div>
                            ` : Q;
      }
    )}
                  </div>
                  ${this.currentFile ? v`
                        ${this.previousFile ? v`
                              <nav class="wy-nav-prev">
                                <wy-button kind="icon" @click=${() => this.scrollToPrev()}>
                                  <wy-icon name="previous"></wy-icon>
                                </wy-button>
                              </nav>
                            ` : Q}
                        ${this.nextFile ? v`
                              <nav class="wy-nav-next">
                                <wy-button kind="icon" @click=${() => this.scrollToNext()}>
                                  <wy-icon name="next"></wy-icon>
                                </wy-button>
                              </nav>
                            ` : Q}
                      ` : Q}
                </div>
              </div>
            </div> ` : Q}
      </wy-overlay>
    ` : Q;
  }
  updated() {
    requestAnimationFrame(
      () => requestAnimationFrame(() => {
        this.swipeScrollRef.value ? (this.swipeScroller.whenPrev ??= () => this.setPrev(), this.swipeScroller.whenNext ??= () => this.setNext(), this.swipeScroller.createObserver(this.swipeScrollRef.value), this.swipeScroller.observe(this.prevRef.value, this.nextRef.value)) : this.swipeScroller.clearObserver();
      })
    );
  }
}, c(ef, "Za"), ef), d(_2, "WyPreview"), _2);
Ae.styles = [ft];
ai([
  O({ attribute: !1 })
], Ae.prototype, "files", 2);
ai([
  O({ attribute: !1 })
], Ae.prototype, "queryResult", 2);
ai([
  O({ attribute: !1 })
], Ae.prototype, "infiniteQueryResult", 2);
ai([
  O({ type: Object })
], Ae.prototype, "user", 2);
ai([
  O({ type: Number })
], Ae.prototype, "currentId", 2);
ai([
  O({ type: Boolean })
], Ae.prototype, "isAttachment", 2);
ai([
  O({ type: Boolean })
], Ae.prototype, "filled", 2);
ai([
  F()
], Ae.prototype, "currentFile", 2);
ai([
  F()
], Ae.prototype, "previousFile", 2);
ai([
  F()
], Ae.prototype, "nextFile", 2);
ai([
  F()
], Ae.prototype, "showOverlay", 2);
ai([
  F()
], Ae.prototype, "commentsOpen", 2);
ai([
  F()
], Ae.prototype, "versionsOpen", 2);
ai([
  F()
], Ae.prototype, "versionFile", 2);
ai([
  F()
], Ae.prototype, "sidePanelMaximized", 2);
ai([
  F()
], Ae.prototype, "disableSwipeScroll", 2);
Ae = ai([
  X("wy-preview"),
  bt()
], Ae);
var SH = Object.defineProperty, PH = Object.getOwnPropertyDescriptor, Ee = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? PH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && SH(t, e, s), s;
}, "__decorateClass$z"), z2, nf;
let ue = (z2 = (nf = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.me = !1, this.isAgent = !1, this.isPrivateChat = !1, this.name = "", this.comment = "", this.avatar = "", this.createdAt = "", this.html = "", this.text = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.seenBy = [], this.highlight = !1, this.previewAnnotationsRef = mt(), this.previewAttachmentsRef = mt(), this.highlightRef = mt();
  }
  dispatchVote(t) {
    const e = new CustomEvent("vote", {
      detail: { optionId: t, parentId: this.messageId }
    });
    return this.dispatchEvent(e);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("link") && (this.highlight = !!(this.link && dg(this.link, ci.Message, { id: this.messageId })));
  }
  render() {
    const t = this.attachments?.filter((r) => r.kind === "image" && r.thumbnail_url) || [], e = this.attachments?.filter((r) => r.kind !== "image" || !r.thumbnail_url) || [], i = this.createdAt ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.createdAt)
    ) : "", s = this.createdAt ? new Intl.DateTimeFormat(this.weavy?.locale, { timeStyle: "short" }).format(new Date(this.createdAt)) : "";
    return v`
      <div
        class=${Xt({ "wy-message": !0, "wy-message-me": this.me, "wy-message-agent": this.isAgent })}
        part=${Me({ "wy-highlight": this.highlight })}
        ${rt(this.highlightRef)}
      >
        ${this.me ? "" : v`
              <div class="wy-message-author">
                <wy-avatar
                  .src=${this.avatar}
                  .size=${32}
                  .name=${this.name}
                  .description=${this.comment}
                  .isAgent=${this.isAgent}
                ></wy-avatar>
              </div>
            `}

        <div class="wy-message-content">
          <div class="wy-message-meta">
            ${!this.isPrivateChat && !this.me ? v` <span>${this.name} · </span> ` : ""}
            <time datetime=${this.createdAt} title=${i}>${s}</time>
          </div>

          <div class="wy-message-bubble">
            ${this.messageId < 0 ? v`<wy-skeleton .text=${this.text}></wy-skeleton>` : v`
                  <!-- image grid -->
                  ${t && t.length ? v`<wy-image-grid
                        class="wy-message-area"
                        .images=${t}
                        @file-open=${(r) => {
      this.previewAttachmentsRef.value?.open(r.detail.fileId);
    }}
                      ></wy-image-grid>` : ""}

                  <!-- embeds -->
                  ${this.componentFeatures?.allowsFeature(z.Embeds) && this.embed ? v` <wy-embed class="wy-embed" .embed=${this.embed}></wy-embed> ` : Q}

                  <!-- text -->
                  ${this.html ? v`<div class="wy-content">${Xo(this.html)}</div>` : ""}

                  <!-- annotations -->
                  ${this.annotations && this.annotations.length ? v`<wy-annotations-list
                        class="wy-message-area"
                        .files=${this.annotations}
                        @file-open=${(r) => {
      this.previewAnnotationsRef.value?.open(r.detail.fileId);
    }}
                      ></wy-annotations-list>` : ""}

                  <!-- poll -->
                  ${this.pollOptions && this.pollOptions.length ? v`
                        <wy-poll
                          .pollOptions=${this.pollOptions}
                          @vote=${(r) => this.dispatchVote(r.detail.optionId)}
                        ></wy-poll>
                      ` : Q}

                  <!-- meeting -->
                  ${this.meeting ? v`<wy-meeting-card .meeting=${this.meeting}></wy-meeting-card>` : ""}

                  <!-- files -->
                  ${e && e.length ? v`<wy-attachments-list
                        class="wy-message-area"
                        .files=${e}
                        @file-open=${(r) => {
      this.previewAttachmentsRef.value?.open(r.detail.fileId);
    }}
                      ></wy-attachments-list>` : ""}

                  <!-- reactions -->
                  ${this.componentFeatures?.allowsFeature(z.Reactions) && this.conversation ? v`
                        ${W1(
      `reactions-${this.conversation.id}-${this.messageId}`,
      v`
                            <wy-reactions
                              lineBelow
                              ?lineReverse=${!this.me}
                              small
                              directionX=${this.me ? "right" : "left"}
                              .reactions=${this.reactions}
                              parentId=${this.conversation.id}
                              parentType="apps"
                              entityId=${this.messageId}
                              entityType="messages"
                            ></wy-reactions>
                          `
    )}
                      ` : Q}
                `}
          </div>
        </div>
      </div>
      ${this.componentFeatures?.allowsFeature(z.Receipts) ? v`<div class="wy-readby-status">
            ${this.seenBy && this.seenBy.length ? v`
                  ${this.seenBy.map((r) => {
      const a = r.marked_at ? new Intl.DateTimeFormat(this.weavy?.locale, {
        dateStyle: "full",
        timeStyle: "short"
      }).format(new Date(r.marked_at)) : "";
      return v`<wy-avatar
                      title=${P(nt`Seen by ${r.name} at ${a}`)}
                      .name=${r.name}
                      .src=${r.avatar_url}
                      size=${18}
                    ></wy-avatar>`;
    })}
                ` : Q}
          </div>` : Q}
      ${this.annotations ? W1(
      `annotation-preview-message-${this.messageId}`,
      v`
              <wy-preview
                ${rt(this.previewAnnotationsRef)}
                .files=${this.annotations}
                .isAttachment=${!0}
              ></wy-preview>
            `
    ) : Q}
      ${this.attachments ? W1(
      `preview-message-${this.messageId}`,
      v`
              <wy-preview
                ${rt(this.previewAttachmentsRef)}
                .files=${[...t, ...e]}
                .isAttachment=${!0}
              ></wy-preview>
            `
    ) : Q}
    `;
  }
  updated(t) {
    t.has("highlight") && this.highlight && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, c(nf, "Ya"), nf), d(z2, "WyMessage"), z2);
ue.styles = ft;
Ee([
  O({ attribute: !1 })
], ue.prototype, "conversation", 2);
Ee([
  O({ type: Number })
], ue.prototype, "messageId", 2);
Ee([
  O({ type: Boolean })
], ue.prototype, "me", 2);
Ee([
  O({ type: Boolean })
], ue.prototype, "isAgent", 2);
Ee([
  O({ type: Boolean })
], ue.prototype, "isPrivateChat", 2);
Ee([
  O()
], ue.prototype, "name", 2);
Ee([
  O()
], ue.prototype, "comment", 2);
Ee([
  O()
], ue.prototype, "avatar", 2);
Ee([
  O()
], ue.prototype, "createdAt", 2);
Ee([
  O()
], ue.prototype, "html", 2);
Ee([
  O()
], ue.prototype, "text", 2);
Ee([
  O({ type: Array })
], ue.prototype, "annotations", 2);
Ee([
  O({ type: Array })
], ue.prototype, "attachments", 2);
Ee([
  O({ attribute: !1 })
], ue.prototype, "meeting", 2);
Ee([
  O({ type: Array })
], ue.prototype, "pollOptions", 2);
Ee([
  O({ attribute: !1 })
], ue.prototype, "embed", 2);
Ee([
  O({ type: Array })
], ue.prototype, "reactions", 2);
Ee([
  O({ type: Array })
], ue.prototype, "seenBy", 2);
Ee([
  O({ type: Boolean })
], ue.prototype, "highlight", 2);
ue = Ee([
  X("wy-message"),
  bt()
], ue);
var CH = Object.defineProperty, QH = Object.getOwnPropertyDescriptor, er = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? QH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && CH(t, e, s), s;
}, "__decorateClass$y"), L2, sf;
let cn = (L2 = (sf = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.dataUpdatedAt = NaN, this.unreadMarkerShow = !0, this.seenByShow = !1;
  }
  dispatchVote(t, e) {
    const i = new CustomEvent("vote", { detail: { optionId: t, parentId: e, parentType: "messages" } });
    return this.dispatchEvent(i);
  }
  render() {
    const t = hs(this.infiniteMessages);
    let e;
    return v`
      <div class="wy-messages">
        <slot name="start"></slot>
        <!-- this.user ?? -->
        ${t && this.conversation && this.user ? Mi(
      t,
      (i) => i.id,
      (i, s) => {
        const r = new Date(i.created_at);
        let a = v``;
        if (e?.toDateString() !== r.toDateString()) {
          const h = new Intl.DateTimeFormat(this.weavy?.locale, {
            dateStyle: "short"
          }).format(r);
          e = r, a = v`<div class="wy-date-separator"><time>${h}</time></div>`;
        }
        let o = v``;
        this.unreadMarkerId && this.unreadMarkerId === i.id && (o = v`<div
                    id="unread-marker"
                    class="wy-toast wy-toast-action wy-fade ${this.unreadMarkerShow ? "wy-show" : ""}"
                    tabindex=${this.unreadMarkerShow ? 0 : -1}
                    @click=${() => {
          let h = `#message-${this.unreadMarkerId}`;
          this.unreadMarkerPosition === "below" && (h += "~ wy-message"), this.renderRoot.querySelector(h)?.scrollIntoView({
            block: "start",
            inline: "nearest",
            behavior: "smooth"
          });
        }}
                    @keydown=${Fe}
                    @keyup=${vi}
                  >
                    ${P("New messages")}
                  </div>`);
        const l = this.members?.data?.find((h) => h.id === i.created_by.id) || i.created_by;
        return v`${[
          v`${a}`,
          v`${this.unreadMarkerPosition === "above" ? o : Q}`,
          W1(
            `message-${i.id}`,
            v`<wy-message
                      id="message-${i.id}"
                      .conversation=${this.conversation}
                      .messageId=${i.id}
                      .me=${l.id === this.user?.id}
                      .isAgent=${l.is_agent || !1}
                      .isPrivateChat=${this.conversation?.type === Pt.PrivateChat || this.conversation?.type === Pt.AgentChat}
                      .name=${l.name}
                      .comment=${l.comment}
                      .avatar=${l.avatar_url}
                      .createdAt=${i.created_at}
                      .text=${i.plain}
                      .html=${i.html}
                      .annotations=${i.annotations?.data}
                      .attachments=${i.attachments?.data}
                      .meeting=${i.meeting}
                      .pollOptions=${i.options?.data}
                      .embed=${i.embed}
                      .reactions=${i.reactions?.data}
                      .seenBy=${this.seenByShow && this.members && this.members.data && this.members.data.length > 0 ? this.members.data.filter((h) => h.marked_id === i.id && h.id !== this.user?.id) : []}
                      @vote=${(h) => {
              h.detail.parentId && this.dispatchVote(h.detail.optionId, h.detail.parentId);
            }}
                    ></wy-message>`
          ),
          v`${this.unreadMarkerPosition === "below" ? o : Q}`
        ]}`;
      }
    ) : Q}
        <slot name="end"></slot>
      </div>
    `;
  }
}, c(sf, "Xa"), sf), d(L2, "WyMessages"), L2);
cn.styles = [
  ft,
  Tt,
  Qt`
      wy-message {
        scroll-margin-block: 6rem;
      }
    `
];
er([
  O({ attribute: !1 })
], cn.prototype, "conversation", 2);
er([
  O({ attribute: !1 })
], cn.prototype, "infiniteMessages", 2);
er([
  O({ type: Number })
], cn.prototype, "dataUpdatedAt", 2);
er([
  O({ attribute: !1 })
], cn.prototype, "members", 2);
er([
  O({ attribute: !1 })
], cn.prototype, "unreadMarkerId", 2);
er([
  O({ attribute: !1 })
], cn.prototype, "unreadMarkerPosition", 2);
er([
  O({ attribute: !1 })
], cn.prototype, "unreadMarkerShow", 2);
er([
  O({ attribute: !1 })
], cn.prototype, "seenByShow", 2);
cn = er([
  X("wy-messages"),
  bt()
], cn);
var rf;
const iI = (rf = class {
  constructor(t) {
    this.registrationRequested = !1, this.typingTimeout = null, this.discardTime = 5 * 1e3, this.typingMembers = [], this.names = [], this.ellipsis = "", this.handleRealtimeTyping = (e) => {
      e.entity.id === this.appId && e.actor.id !== this.userId && (this.setTypers(e.actor), this.updateTyping());
    }, this.handleRealtimeStopTyping = (e) => {
      this.typingMembers.forEach((i, s) => {
        i.id === e.actor.id && this.typingMembers.splice(s, 1);
      }), this.updateTyping();
    }, t.addController(this), this.host = t, this.setContexts();
  }
  get weavy() {
    return this.weavyContext?.value;
  }
  get componentFeatures() {
    return this._componentFeatures;
  }
  get appId() {
    return this._appId;
  }
  set appId(t) {
    t !== this._appId && (this.typingMembers = [], this.unregisterRealtime(), this._appId = t, this.registerRealtime());
  }
  get userId() {
    return this._userId;
  }
  set userId(t) {
    t !== this._userId && (this.typingMembers = [], this.unregisterRealtime(), this._userId = t, this.registerRealtime());
  }
  async setContexts() {
    this.whenWeavyContext = new Promise((t) => this.resolveWeavyContext = t), this.whenComponentFeaturesContext = new Promise((t) => this.resolveComponentFeaturesContext = t), await rl(this.host), this.weavyContext = new Vs(this.host, { context: Le, subscribe: !0 }), this.componentFeaturesContext = new Vs(this.host, {
      context: Bb,
      subscribe: !0
    });
  }
  hostUpdate() {
    this.weavyContext?.value && this.resolveWeavyContext?.(this.weavyContext?.value);
    const t = this.componentFeaturesContext && this.componentFeaturesContext.value?.allowsFeature(z.Typing) !== this._componentFeatures?.allowsFeature(z.Typing);
    t && (this._componentFeatures = this.componentFeaturesContext?.value, this.componentFeaturesContext?.value && this.resolveComponentFeaturesContext?.(this.componentFeaturesContext.value), t && (this.unregisterRealtime(!0), this.registerRealtime()));
  }
  async registerRealtime() {
    !this.registrationRequested && this.appId && this._userId && (this.registrationRequested = !0, await Promise.all([this.whenWeavyContext, this.whenComponentFeaturesContext]), this.componentFeatures?.allowsFeature(z.Typing) && (this.weavy?.subscribe(`a${this.appId}`, "typing", this.handleRealtimeTyping), this.weavy?.subscribe(`a${this.appId}`, "message_created", this.handleRealtimeStopTyping)), this.registrationRequested = !1);
  }
  async unregisterRealtime(t = !1) {
    !this.registrationRequested && this.appId && this.userId && (!t && await this.whenWeavyContext, this.weavy?.unsubscribe(`a${this.appId}`, "typing", this.handleRealtimeTyping), this.weavy?.unsubscribe(`a${this.appId}`, "message_created", this.handleRealtimeStopTyping));
  }
  /**
   * @fires typing
   */
  updateTyping() {
    this.typingTimeout && (clearTimeout(this.typingTimeout), this.typingTimeout = null);
    const t = Date.now();
    if (this.typingMembers.forEach((i, s) => {
      t - i.time > this.discardTime && this.typingMembers.splice(s, 1);
    }), this.typingMembers.length) {
      const i = Date.now(), s = Math.round(
        (i - Math.max.apply(
          null,
          this.typingMembers.map((r) => r.time)
        )) / 1e3
      ) % 3 + 1;
      this.ellipsis = ".".repeat(s), this.names = this.typingMembers.map((r) => r.name).sort(), this.typingTimeout = window.setTimeout(() => this.updateTyping(), 1e3);
    } else
      this.names = [];
    this.host.requestUpdate();
    const e = new CustomEvent("typing", {
      bubbles: !0,
      composed: !1,
      detail: { count: this.typingMembers.length }
    });
    this.host.dispatchEvent(e);
  }
  setTypers(t) {
    this.typingMembers.forEach((i, s) => {
      i.id === t.id && this.typingMembers.splice(s, 1);
    });
    const e = { ...t, time: Date.now() };
    this.typingMembers.push(e);
  }
  hostDisconnected() {
    this.typingTimeout && (clearTimeout(this.typingTimeout), this.typingTimeout = null), this.typingMembers.length = 0, this.names.length = 0, this.weavy && this.unregisterRealtime(!0);
  }
}, c(rf, "iy"), rf);
d(iI, "TypingController");
let nI = iI;
const MH = Qt`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-primary-95, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-primary-10, #001d32))}}.wy-messages{padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));flex:1 1 100%}.wy-message-placeholder{opacity:.5}.wy-date-separator{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));pointer-events:none;margin:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));text-align:center;position:sticky;top:var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));z-index:10}.wy-date-separator time{background:var(--wy-surface-3, var(--wy-surface-3-light, #e3e7ee));color:var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:inline-block}.wy-message{display:flex;flex-direction:row;align-items:flex-start;margin-bottom:calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + .5 * var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));scroll-margin-block:6rem;--wy-component-background-color: var(--wy-surface-variant, var(--wy-neutral-variant-90, #dee3eb));--wy-component-color: var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}.wy-message[part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}.wy-message-area{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}.wy-message-meta{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:0 0 calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));color:var(--wy-on-surface-variant, var(--wy-neutral-variant-30, #42474e))}.wy-message-bubble{background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));display:flex;flex-direction:column;padding:var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));max-width:min(32 * var(--wy-size, 1rem),100% - 2 * var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}.wy-message-bubble>div{flex:1 1 100%}.wy-message-author{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)));margin:calc(1lh + .5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5 * var(--wy-size, 1rem)) 0 0}.wy-message-content{display:flex;flex-direction:column;width:100%;align-items:flex-start;flex-wrap:wrap;min-width:0;position:relative}.wy-message-content-row{display:flex;flex-direction:row;align-items:center;max-width:100%}.wy-message-agent{--wy-component-background-color: var(--wy-tertiary-container, var(--wy-tertiary-90, #bbf294));--wy-component-color: var(--wy-on-tertiary-container, var(--wy-tertiary-10, #0a2100))}.wy-message-me{margin-right:0;margin-left:calc(2.5 * var(--wy-size, 1rem));align-items:flex-end;--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-90, #cde5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-primary-10, #001d32))}.wy-message-me .wy-message-meta{margin:0 calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))) 0}.wy-message-me .wy-message-content{align-items:flex-end}.wy-message-me .wy-message-content-row{flex-direction:row-reverse}.wy-message-emoji .wy-message-bubble{background:none;padding:0 0 var(--wy-message-padding, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))))}.wy-message-emoji .wy-content .wy-emoji{width:calc(3 * var(--wy-size, 1rem));height:calc(3 * var(--wy-size, 1rem));margin:0}.wy-message-emoji.wy-message-me .wy-content{text-align:end}.wy-readby-status{display:flex;gap:var(--wy-gap-sm, calc(.5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem)))));height:calc(1.125 * var(--wy-size, 1rem));justify-content:flex-end;margin-top:calc(-.125 * var(--wy-size, 1rem))}.wy-message-readmore{justify-self:center;text-align:center}`, TH = Qt`@keyframes wy-bouncing{to{transform:translate3d(0,calc(-.25 * var(--wy-size, 1rem)),0)}}@keyframes wy-bouncing-fade{to{opacity:.2}}[part~=wy-bouncer]{width:calc(1.5 * var(--wy-size, 1rem));height:calc(.75 * var(--wy-size, 1rem))}[part~=wy-bouncer-dot]{position:relative;animation:wy-bouncing .6s infinite alternate,wy-bouncing-fade .6s infinite alternate;fill:currentColor}[part~=wy-bouncer-dot-start]{animation-delay:0s,.6s}[part~=wy-bouncer-dot-middle]{animation-delay:.3s,.3s}[part~=wy-bouncer-dot-end]{animation-delay:.6s,0s}`;
var AH = Object.defineProperty, RH = Object.getOwnPropertyDescriptor, ir = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? RH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && AH(t, e, s), s;
}, "__decorateClass$x"), I2, af;
let hn = (I2 = (af = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.typing = new nI(this), this.isPrivateChat = !1, this.members = [], this.typingMembers = [], this.names = [];
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("conversationId") && (this.typing.appId = this.conversationId), t.has("userId") && (this.typing.userId = this.userId);
    const { typingMembers: e, names: i } = this.typing;
    this.typingMembers = e, this.names = i, e.length ? this.typingTime ||= /* @__PURE__ */ new Date() : this.typingTime = void 0;
  }
  render() {
    const t = this.typingMembers.map(
      (a) => this.members.find((o) => o.id === a.id)
    ).filter((a) => a), e = new Intl.ListFormat(this.weavy?.locale, { style: "long", type: "conjunction" }).format(
      this.names
    ), i = this.typingTime ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(this.typingTime) : "", s = this.typingTime ? new Intl.DateTimeFormat(this.weavy?.locale, { timeStyle: "short" }).format(this.typingTime) : "", r = v`
      <svg part="wy-bouncer" viewBox="0 0 32 16" xmlns="http://www.w3.org/2000/svg">
        <circle part="wy-bouncer-dot wy-bouncer-dot-start" cx="4" cy="10" r="4" />
        <circle part="wy-bouncer-dot wy-bouncer-dot-middle" cx="16" cy="10" r="4" />
        <circle part="wy-bouncer-dot wy-bouncer-dot-end" cx="28" cy="10" r="4" />
      </svg>
    `;
    return t.length ? v`
          <div class=${Xt({ "wy-message": !0, "wy-message-agent": !!t[0]?.is_agent })}>
            <div class="wy-message-author">
              ${t.length > 1 ? v`
                    <wy-avatar-group
                      .size=${32}
                      .members=${t}
                      title=${e}
                    ></wy-avatar-group>
                  ` : v`
                    <wy-avatar
                      .size=${32}
                      .src=${t[0]?.avatar_url}
                      .description=${t[0]?.comment}
                      .name=${e}
                      .isAgent=${t[0]?.is_agent}
                    ></wy-avatar>
                  `}
            </div>

            <div class="wy-message-content">
              <div class="wy-message-meta">
                ${this.isPrivateChat ? v`
                      <time datetime=${Ct(this.typingTime?.toISOString())} title=${i}>${s}</time>
                    ` : e}
              </div>
              <div class="wy-message-bubble"> ${r} </div>
            </div>
          </div>
        ` : Q;
  }
}, c(af, "Ja"), af), d(I2, "WyMessageTyping"), I2);
hn.styles = [Ie, TH, MH];
ir([
  xe({ context: Le, subscribe: !0 }),
  F()
], hn.prototype, "weavy", 2);
ir([
  O({ attribute: !0, type: Number })
], hn.prototype, "conversationId", 2);
ir([
  O({ attribute: !0, type: Number })
], hn.prototype, "userId", 2);
ir([
  O({ type: Boolean })
], hn.prototype, "isPrivateChat", 2);
ir([
  O({ attribute: !1 })
], hn.prototype, "members", 2);
ir([
  F()
], hn.prototype, "typingMembers", 2);
ir([
  F()
], hn.prototype, "names", 2);
ir([
  F()
], hn.prototype, "typingTime", 2);
hn = ir([
  X("wy-message-typing")
], hn);
var EH = Object.defineProperty, _H = Object.getOwnPropertyDescriptor, sI = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$a"), Rn = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? _H(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && EH(t, e, s), s;
}, "__decorateClass$w"), rI = /* @__PURE__ */ d((n, t, e) => t.has(n) || sI("Cannot " + e), "__accessCheck$a"), U3 = /* @__PURE__ */ d((n, t, e) => (rI(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$a"), zH = /* @__PURE__ */ d((n, t, e) => t.has(n) ? sI("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$a"), B3 = /* @__PURE__ */ d((n, t, e, i) => (rI(n, t, "write to private field"), t.set(n, e), e), "__privateSet$9"), $c, Z2, of;
let Ai = (Z2 = (of = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.header = !1, this.lastReadMessagePosition = "below", this.showNewMessages = !1, this.isCreatingConversation = !1, this.showReadReceipts = !1, this.releaseFocusEvent = () => new CustomEvent("release-focus", { bubbles: !0, composed: !0 }), this.messagesQuery = new dl(this), this.membersQuery = new ns(this), this.addMessageMutation = new en(this), this.infiniteScroll = new XU(this), this.pagerRef = mt(), this.bottomRef = mt(), this.editorRef = mt(), this.shouldBeAtBottom = !0, this.isTyping = !1, this.handleRealtimeMessage = async (t) => {
      if (!this.weavy || !this.conversation || !(this.conversationId && this.conversationId > 0) || !this.user)
        return;
      await this.messagesQuery.observer?.getCurrentQuery().promise;
      const e = t.message.app.uid ?? t.message.app.id, i = ["messages", t.message.app.id];
      let s = cg(this.weavy.queryClient, i, t.message.id);
      s || (t.message.created_by.id === this.user.id && (s = ia(this.weavy.queryClient, i, !0), s && Oe(this.weavy.queryClient, i, s.id, (r) => {
        r.id = t.message.id, r.app = t.message.app, r.text = t.message.text, r.html = t.message.html, r.embed = t.message.embed, r.meeting = t.message.meeting, r.attachments = t.message.attachments, r.options = t.message.options, r.created_at = t.message.created_at, r.created_by = t.message.created_by, r.updated_at = t.message.updated_at, r.updated_by = t.message.updated_by;
      })), s || ea(this.weavy.queryClient, i, t.message)), this.weavy.queryClient.setQueryData(
        ["apps", e],
        (r) => r && { ...r, last_message: t.message }
      ), t.actor.id !== this.user.id && (this.isAtBottom ? (this.markAsRead(t.message.id), requestAnimationFrame(() => {
        this.scrollToBottom();
      })) : (this.weavy.queryClient.setQueryData(
        ["apps", e],
        (r) => r && { ...r, is_unread: !0 }
      ), this.lastReadMessagePosition = "above", this.lastReadMessageId = t.message.id, this.showNewMessages = !0), Ot(
        this.weavy.queryClient,
        { queryKey: ["members", t.message.app.id], exact: !1 },
        t.actor.id,
        (r) => {
          r.marked_id = t.message.id, r.marked_at = t.message.created_at;
        }
      ));
    }, this.handleRealtimeReactionAdded = (t) => {
      !this.weavy || !this.user || !this.conversation || Ot(
        this.weavy.queryClient,
        { queryKey: ["messages"], exact: !1 },
        t.entity.id,
        (e) => {
          e.reactions || (e.reactions = { count: 0 }), e.reactions.data = [
            ...(e.reactions.data || []).filter((i) => i.created_by?.id !== t.actor.id),
            { content: t.reaction, created_by: t.actor }
          ];
        }
      );
    }, this.handleRealtimeReactionDeleted = (t) => {
      !this.weavy || !this.conversation || !this.user || Ot(
        this.weavy.queryClient,
        { queryKey: ["messages"], exact: !1 },
        t.entity.id,
        (e) => {
          e.reactions && e.reactions.data && (e.reactions.data = e.reactions.data.filter((i) => i.created_by?.id !== t.actor.id));
        }
      );
    }, this.handleRealtimeMarked = (t) => {
      !this.weavy || !this.conversation || Ot(
        this.weavy.queryClient,
        { queryKey: ["members", this.conversation.id] },
        t.actor.id,
        (e) => {
          e.marked_id = t.marked_id, e.marked_at = t.marked_at;
        }
      );
    }, this.markAsReadHandler = () => {
      !document.hidden && this.isAtBottom && this.markAsRead();
    }, zH(this, $c);
  }
  isPrivateChat(t) {
    return (t ?? this.conversation)?.type === Pt.PrivateChat;
  }
  isChatRoom(t) {
    return (t ?? this.conversation)?.type === Pt.ChatRoom;
  }
  get isAtBottom() {
    return this.bottomRef.value ? K_(this.bottomRef.value) : !0;
  }
  async scrollToBottom(t = !1) {
    this.bottomRef.value && await X1(this.bottomRef.value), G_(this.bottomRef.value) && this.conversationId && this.conversationId > 0 && (requestAnimationFrame(() => {
      kk(this.weavy?.queryClient, ["messages", this.conversationId], void 0, 1);
    }), await J_(this.bottomRef.value, t));
  }
  handleTyping(t) {
    this.isTyping = !!t.detail.count, this.isTyping && this.isAtBottom && requestAnimationFrame(() => {
      this.scrollToBottom(!0);
    });
  }
  async handleSubmit(t) {
    if (!this.user)
      throw new Error("Error submitting message. Missing user.");
    const e = {
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      blobs: t.detail.blobs,
      user: this.user,
      context: t.detail.contextData
    };
    if (this.agentInstructions && (e.metadata = {
      instructions: this.agentInstructions
    }), !this.conversation && this.weavy && this.createConversation && (this.isCreatingConversation = !0, await this.createConversation(e), await this.updateComplete), !this.conversation)
      throw new Error("Error submitting message. Missing conversation.");
    const i = await this.addMessageMutation.mutate({
      ...e,
      app_id: this.conversation.id
    });
    return this.showNewMessages = !1, requestAnimationFrame(() => {
      this.scrollToBottom();
    }), this.isCreatingConversation = !1, i;
  }
  async setEditorText(t) {
    this.editorRef.value && (this.editorRef.value.text = t, await this.editorRef.value.updateComplete, await new Promise((e) => requestAnimationFrame(e)));
  }
  async setEditorMetadata(t = {}) {
    await this.updateComplete, this.editorRef.value && (this.editorRef.value.metadata = t);
  }
  async selectAllInEditor() {
    this.editorRef.value && (await this.updateComplete, await this.editorRef.value.updateComplete, this.editorRef.value?.selectAllContent());
  }
  async setCursorLastInEditor() {
    this.editorRef.value && (await this.updateComplete, await this.editorRef.value.updateComplete, this.editorRef.value?.setCursorLast());
  }
  focusEditor() {
    this.editorRef.value && this.editorRef.value?.focusInput();
  }
  async setEmptyConversationTitle(t) {
    !this.conversation || this.conversation.name || (t = KS(t), await this.updateConversationMutation?.mutate({ appId: this.conversation.id, name: t }));
  }
  async markAsRead(t) {
    await y9(), await Promise.race([X1(this), Yk(this, !1)]), !(!this.componentFeatures?.allowsFeature(z.Receipts) || !this.isConnected) && this.conversation && this.conversation.last_message && await this.markConversationMutation?.mutate({
      appId: this.conversation.id,
      messageId: t ?? this.conversation.last_message.id,
      userId: this.user?.id
    });
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("weavy") && this.weavy && (this.updateConversationMutation = EP(this.weavy), this.markConversationMutation = AP(this.weavy)), (t.has("weavy") || t.has("conversationId") || t.has("componentFeatures")) && this.weavy) {
      (e = U3(this, $c)) == null || e.call(this);
      const i = t.get("conversationId");
      if (i && i > 0 && requestAnimationFrame(() => {
        kk(this.weavy?.queryClient, ["messages", i], void 0, 1);
      }), this.conversationId && this.conversationId > 0) {
        await this.messagesQuery.trackInfiniteQuery(X_(this.weavy, this.conversationId)), await this.addMessageMutation.trackMutation(
          N_(this.weavy, ["messages", this.conversationId])
        ), await this.membersQuery.trackQuery(_P(this.weavy, this.conversationId, {})), this.pollMutation = Kb(this.weavy, this.conversationId, ["messages", this.conversationId]), this.lastReadMessageId = void 0, this.showNewMessages = !1;
        const s = `a${this.conversationId}`;
        this.weavy.subscribe(s, "message_created", this.handleRealtimeMessage), this.componentFeatures?.allowsFeature(z.Reactions) && (this.weavy.subscribe(s, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(s, "reaction_removed", this.handleRealtimeReactionDeleted)), this.componentFeatures?.allowsFeature(z.Receipts) && this.weavy.subscribe(s, "app_marked", this.handleRealtimeMarked).then((r) => {
          this.showReadReceipts = r;
        }), B3(this, $c, () => {
          this.weavy?.unsubscribe(s, "message_created", this.handleRealtimeMessage), this.weavy?.unsubscribe(s, "reaction_added", this.handleRealtimeReactionAdded), this.weavy?.unsubscribe(s, "reaction_removed", this.handleRealtimeReactionDeleted), this.weavy?.unsubscribe(s, "app_marked", this.handleRealtimeMarked), this.showReadReceipts = !1, B3(this, $c, void 0);
        });
      } else
        this.messagesQuery.untrackInfiniteQuery(), this.addMessageMutation.untrackMutation(), this.membersQuery.untrackQuery();
    }
    if (t.has("showNewMessages") && this.showNewMessages && (this.shouldBeAtBottom = this.isAtBottom), t.has("conversationId") && t.get("conversationId") !== this.conversationId ? this.shouldBeAtBottom = !!this.conversationId : this.shouldBeAtBottom = this.isAtBottom, t.has("conversation")) {
      const i = t.get("conversation");
      if (i?.id !== this.conversation?.id || i?.is_unread !== this.conversation?.is_unread)
        if (this.componentFeatures?.allowsFeature(z.Receipts) && this.conversation?.is_unread) {
          const s = this.membersQuery.result.data?.data?.find(
            (r) => r.id === this.user?.id
          )?.marked_id;
          s && s < this.conversation.last_message.id && (this.lastReadMessagePosition = "below", this.lastReadMessageId = s, this.showNewMessages = !0), (i?.id !== this.conversation?.id || i?.last_message.id !== this.conversation?.last_message.id && (this.shouldBeAtBottom || this.isAtBottom)) && this.markAsRead();
        } else i?.id !== this.conversation?.id && (this.showNewMessages = !1);
    }
    if (this.conversation && !this.conversation?.name && !Sk(this.messagesQuery.result.data)) {
      const i = hs(this.messagesQuery.result.data).find((s) => s.plain);
      i && this.setEmptyConversationTitle(GS(i.plain));
    }
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.messagesQuery.result, this.pagerRef.value);
  }
  renderConversationHeader() {
    if (!this.header)
      return v` <!-- Top of the conversation --> `;
    const { isPending: t, hasNextPage: e } = this.messagesQuery.result ?? {};
    if (!this.conversation || t || e)
      return Q;
    const { data: i } = this.membersQuery.result ?? {}, s = this.user && this.isPrivateChat() ? (this.conversation?.members?.data || []).filter((r) => r.id !== this.user?.id)?.[0] ?? this.user : null;
    return v`
      <wy-avatar-header description=${Ct(s?.comment)}>
        ${this.conversation.avatar_url ? v`<wy-avatar .size=${96} src=${this.conversation.avatar_url}></wy-avatar>` : this.isChatRoom() ? v` <wy-avatar-group
              .members=${i?.data}
              title=${this.conversation.name}
              .size=${96}
            ></wy-avatar-group>` : s?.avatar_url ? v`
              <wy-avatar
                src=${Ct(s?.avatar_url)}
                name=${this.conversation.name}
                description=${Ct(s?.comment)}
                ?isAgent=${s?.is_agent}
                size=${96}
              ></wy-avatar>
            ` : Q}
      </wy-avatar-header>
    `;
  }
  render() {
    const { isPending: t } = this.weavy?.network ?? { isPending: !0 }, { data: e, isPending: i, hasNextPage: s } = this.messagesQuery.result ?? { isPending: t }, { data: r } = this.membersQuery.result ?? {};
    return v`
      ${this.renderConversationHeader()}
      ${this.conversation && e && !Sk(e) ? v`
            <wy-messages
              .conversation=${this.conversation}
              .infiniteMessages=${e}
              .members=${r}
              .unreadMarkerId=${this.lastReadMessageId}
              .unreadMarkerPosition=${this.lastReadMessagePosition}
              .unreadMarkerShow=${this.showNewMessages}
              .seenByShow=${this.showReadReceipts}
              @vote=${(a) => {
      a.detail.parentType && a.detail.parentId && this.pollMutation?.mutate({
        optionId: a.detail.optionId,
        parentType: a.detail.parentType,
        parentId: a.detail.parentId
      });
    }}
            >
              ${s ? v`<div slot="start" ${rt(this.pagerRef)} part="wy-pager wy-pager-top"></div>` : Q}
              ${this.componentFeatures?.allowsFeature(z.Typing) ? v`
                    <wy-message-typing
                      slot="end"
                      .conversationId=${this.conversation.id}
                      .userId=${this.user?.id}
                      .isPrivateChat=${this.isPrivateChat()}
                      .members=${r?.data ?? []}
                      @typing=${(a) => this.handleTyping(a)}
                    ></wy-message-typing>
                  ` : Q}
            </wy-messages>
          ` : v`
            <div class="wy-messages">
              <wy-empty class="wy-pane">
                ${i && this.conversationId || this.isCreatingConversation ? v`<wy-spinner overlay></wy-spinner>` : v` <slot name="empty">${this.conversationId ? P("Start the conversation!") : Q}</slot> `}
              </wy-empty>
            </div>
          `}
      <div ${rt(this.bottomRef)}></div>
      <div part="wy-footerbar wy-footerbar-sticky">
        <slot name="footerbar"></slot>
        <wy-message-editor
          ${rt(this.editorRef)}
          .draft=${!0}
          placeholder=${this.placeholder ?? P("Type a message...")}
          ?disabled=${this.conversation && !sy(Uo.Create, this.conversation?.permissions)}
          @submit=${(a) => this.handleSubmit(a)}
        ></wy-message-editor>
      </div>
    `;
  }
  updated() {
    this.shouldBeAtBottom && requestAnimationFrame(() => {
      this.scrollToBottom();
    }), this.bottomObserver || (this.bottomObserver = new IntersectionObserver((t) => {
      t.forEach((e) => {
        e.isIntersecting && !this.isTyping && this.conversation?.is_unread && this.markAsRead();
      });
    })), this.bottomRef && this.bottomRef.value && this.bottomObserver.observe(this.bottomRef.value);
  }
  // hook up observer
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("visibilitychange", this.markAsReadHandler), this.conversationId && this.requestUpdate("conversationId");
  }
  disconnectedCallback() {
    var t;
    (t = U3(this, $c)) == null || t.call(this), this.bottomObserver && this.bottomObserver.disconnect(), document.removeEventListener("visibilitychange", this.markAsReadHandler), this.conversation = void 0, this.shouldBeAtBottom = this.isAtBottom, super.disconnectedCallback();
  }
}, c(of, "to"), of), d(Z2, "WyConversation"), Z2);
$c = /* @__PURE__ */ new WeakMap();
Ai.styles = [
  ft,
  ma,
  Tz,
  Qt`
      :host {
        position: relative;
        display: flex;
        flex-direction: column;
        flex: 1 1 auto;
      }
    `
];
Rn([
  Hs({ context: wP }),
  O({ attribute: !1 })
], Ai.prototype, "conversation", 2);
Rn([
  O({ type: Number })
], Ai.prototype, "conversationId", 2);
Rn([
  O({ type: Boolean })
], Ai.prototype, "header", 2);
Rn([
  O()
], Ai.prototype, "agentInstructions", 2);
Rn([
  O()
], Ai.prototype, "placeholder", 2);
Rn([
  F()
], Ai.prototype, "lastReadMessagePosition", 2);
Rn([
  F()
], Ai.prototype, "lastReadMessageId", 2);
Rn([
  F()
], Ai.prototype, "showNewMessages", 2);
Rn([
  F()
], Ai.prototype, "isCreatingConversation", 2);
Rn([
  F()
], Ai.prototype, "showReadReceipts", 2);
Ai = Rn([
  X("wy-conversation"),
  bt()
], Ai);
var Ge = /* @__PURE__ */ ((n) => (n.All = "", n.Activity = "activity", n.Mention = "mention", n.Reaction = "reaction", n))(Ge || {});
function aI(n, t = Ge.All, e, i = {}) {
  return {
    ...i,
    initialPageParam: 0,
    queryKey: ["notifications", "list", e, t],
    queryFn: /* @__PURE__ */ d(async (s) => {
      const r = new URLSearchParams({
        skip: s.pageParam?.toString() || "0",
        type: t
      }), a = `/api/${e ? `apps/${e.toString()}/` : ""}notifications?${r.toString()}`, o = await (await n.fetch(a)).json();
      return o.data = o.data || [], o;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ d((s) => {
      if (s.end && s.end < s.count)
        return s.end;
    }, "getNextPageParam")
  };
}
c(aI, "A4");
d(aI, "getNotificationsOptions");
function oI(n, t = Ge.All, e) {
  const i = n.queryClient.getQueryData(["notifications", "list", e, t])?.pages.flatMap((r) => r.data);
  let s;
  return i?.forEach((r) => {
    s = s && r && s.id > r.id ? s : r;
  }), s;
}
c(oI, "E4");
d(oI, "getLastNotification");
function lI(n, t) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ notificationId: e }) => {
      const i = new URL(`/api/${t ? `apps/${t.toString()}/` : ""}notifications/mark`, n.url);
      e && i.searchParams.append("id", e.toString()), await n.fetch(i, { method: "PUT" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((e) => {
      const i = [];
      return Ot(
        n.queryClient,
        { queryKey: t ? ["notifications", "list", t] : ["notifications", "list"], exact: !1 },
        void 0,
        (s) => {
          i.push({ id: s.id, is_unread: s.is_unread }), s.is_unread = !1;
        }
      ), t && i.length && Ot(
        n.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        (s) => !!i.find((r) => r.id === s.id && s.is_unread),
        (s) => {
          s.is_unread = !1;
        }
      ), t || Hv(
        n.queryClient,
        { queryKey: ["notifications", "badge"], exact: !1 },
        () => 0
      ), Hv(
        n.queryClient,
        {
          queryKey: t ? ["apps", "notifications", "badge", t] : ["apps", "notifications", "badge"],
          exact: !1
        },
        () => 0
      ), { changedNotifications: i };
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d(async () => {
      t && await n.queryClient.invalidateQueries({ queryKey: ["notifications", "badge"], exact: !1 });
    }, "onSuccess"),
    onSettled: /* @__PURE__ */ d(async () => {
      await n.queryClient.invalidateQueries({ queryKey: ["notifications", "list"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["notifications", "badge"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["apps", "notifications", "badge"], exact: !1 });
    }, "onSettled"),
    onError: /* @__PURE__ */ d((e, i, s) => {
      console.error(e.message);
    }, "onError")
  };
}
c(lI, "R4");
d(lI, "getMarkNotificationsMutationOptions");
function cI(n, t) {
  return new jt(n.queryClient, lI(n, t));
}
c(cI, "O4");
d(cI, "getMarkNotificationsMutation");
function hI(n) {
  return {
    mutationFn: /* @__PURE__ */ d(async ({ markAsRead: t, notificationId: e }) => {
      const i = `/api/notifications/${e}/mark`;
      await n.fetch(i, { method: t ? "PUT" : "DELETE" });
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((t) => {
      const e = /* @__PURE__ */ new Map();
      Ot(
        n.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        t.notificationId,
        (i) => {
          !!i.is_unread === t.markAsRead && e.set(i.id, i), i.is_unread = !t.markAsRead;
        }
      ), e.size && (Hv(
        n.queryClient,
        { queryKey: ["notifications", "badge"], exact: !1 },
        (i) => Math.max(0, i + (t.markAsRead ? -1 : 1))
      ), e.forEach((i) => {
        i.link.app && Hv(
          n.queryClient,
          {
            queryKey: ["apps", "notifications", "badge"],
            predicate: /* @__PURE__ */ d((s) => s.queryKey[3] === i.link.app?.id || s.queryKey[3] === i.link.app?.uid, "predicate"),
            exact: !1
          },
          (s) => Math.max(0, s + (t.markAsRead ? -1 : 1))
        );
      }));
    }, "onMutate"),
    onError: /* @__PURE__ */ d(async (t, e) => {
      Ot(
        n.queryClient,
        { queryKey: ["notifications", "list"], exact: !1 },
        e.notificationId,
        (i) => {
          i.is_unread = e.markAsRead;
        }
      ), await n.queryClient.invalidateQueries({ queryKey: ["notifications", "badge"], exact: !1 }), await n.queryClient.invalidateQueries({ queryKey: ["apps", "notifications", "badge"], exact: !1 });
    }, "onError")
  };
}
c(hI, "L4");
d(hI, "getMarkNotificationMutationOptions");
function yC(n) {
  return new jt(n.queryClient, hI(n));
}
c(yC, "xm");
d(yC, "getMarkNotificationMutation");
function dI(n, t = Ge.All, e, i = {}) {
  const s = new URLSearchParams({
    type: t,
    count_only: "true",
    unread: "true"
  }), r = `/api/${e ? `apps/${e.toString()}/` : ""}notifications?${s.toString()}`;
  return ll(n, e ? ["apps", "notifications", "badge", e, t] : ["notifications", "badge", t], r, i);
}
c(dI, "I4");
d(dI, "getBadgeOptions");
var LH = Object.defineProperty, IH = Object.getOwnPropertyDescriptor, uI = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$9"), pI = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? IH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && LH(t, e, s), s;
}, "__decorateClass$v"), fI = /* @__PURE__ */ d((n, t, e) => t.has(n) || uI("Cannot " + e), "__accessCheck$9"), X3 = /* @__PURE__ */ d((n, t, e) => (fI(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$9"), ZH = /* @__PURE__ */ d((n, t, e) => t.has(n) ? uI("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$9"), N3 = /* @__PURE__ */ d((n, t, e, i) => (fI(n, t, "write to private field"), t.set(n, e), e), "__privateSet$8"), xc, V2, lf;
let Nw = (V2 = (lf = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.typeFilter = Ge.All, this.badgeQuery = new ns(this), this.handleRefresh = () => {
      this.badgeQuery.result.refetch();
    }, ZH(this, xc);
  }
  async willUpdate(t) {
    var e;
    super.willUpdate(t), (t.has("weavy") || t.has("typeFilter") || t.has("app")) && this.weavy && await this.badgeQuery.trackQuery(dI(this.weavy, this.typeFilter, this.app?.id), !0), t.has("weavy") && this.weavy && ((e = X3(this, xc)) == null || e.call(this), this.weavy.subscribe(null, "notification_created", this.handleRefresh), this.weavy.subscribe(null, "notification_updated", this.handleRefresh), this.weavy.subscribe(null, "notifications_marked", this.handleRefresh), N3(this, xc, () => {
      this.weavy?.unsubscribe(null, "notification_created", this.handleRefresh), this.weavy?.unsubscribe(null, "notification_updated", this.handleRefresh), this.weavy?.unsubscribe(null, "notifications_marked", this.handleRefresh), N3(this, xc, void 0);
    }));
  }
  render() {
    const { data: t, isPending: e } = this.badgeQuery.result ?? {}, i = t?.count ? t.count >= 100 ? "99+" : t.count : "";
    return v`
      ${this.user && !e && t?.count ? v`
          <span class="wy-badge ${this.settings?.notificationsBadge === "count" ? "wy-button-badge" : "wy-button-dot"}" title=${t?.count}>${i}</span> 
        ` : Q}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = X3(this, xc)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(lf, "eo"), lf), d(V2, "WyNotificationBadge"), V2);
xc = /* @__PURE__ */ new WeakMap();
Nw.styles = [
  ft,
  Tt
];
pI([
  O()
], Nw.prototype, "typeFilter", 2);
Nw = pI([
  X("wy-notification-badge"),
  bt()
], Nw);
var VH = Object.defineProperty, DH = Object.getOwnPropertyDescriptor, yI = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? DH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && VH(t, e, s), s;
}, "__decorateClass$u"), D2, cf;
let lb = (D2 = (cf = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.showNotifications = !1, this.notificationsRef = mt(), this.appSubscribeMutation = new en(this);
  }
  handleSubscribe(t) {
    this.app?.id && this.appSubscribeMutation.mutate({ subscribe: t });
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && await this.appSubscribeMutation.trackMutation(dP(this.weavy, this.app));
  }
  render() {
    return this.settings?.notifications === "none" || !this.app ? Q : v`
      <wy-button
        kind="icon"
        ?active=${this.showNotifications}
        @click=${() => this.showNotifications = !this.showNotifications}
      >
        <wy-icon name="bell"></wy-icon>
        ${this.settings?.notificationsBadge !== "none" ? v` <wy-notification-badge></wy-notification-badge> ` : Q}
      </wy-button>

      <wy-sheet
        noPadding
        .show=${this.showNotifications}
        @close=${() => this.showNotifications = !1}
        @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
      >
        <wy-dropdown slot="appbar-buttons" ?disabled=${!this.app}>
          ${this.app?.is_subscribed ? v`<wy-dropdown-item @click=${() => this.handleSubscribe(!1)}>
                <wy-icon name="bell-off"></wy-icon>
                ${P("Unsubscribe")}
              </wy-dropdown-item>` : v`<wy-dropdown-item @click=${() => this.handleSubscribe(!0)}>
                <wy-icon name="bell"></wy-icon>
                ${P("Subscribe")}
              </wy-dropdown-item>`}
        </wy-dropdown>
        <span slot="appbar-text">${P("Notifications")}</span>
        ${this.showNotifications ? v`
              <wy-notification-list ${rt(this.notificationsRef)}>
                ${this.app?.is_subscribed ? Q : v`
                      <wy-empty slot="empty">
                          <div>${P("You are not subscribed to updates yet.")}</div>
                          <wy-button color="primary" @click=${() => this.handleSubscribe(!0)}>${P("Subscribe")}</wy-button>
                      </wy-empty>
                    `}
              </wy-notification-list>
            ` : Q}
      </wy-sheet>
    `;
  }
}, c(cf, "io"), cf), d(D2, "WyNotificationButtonList"), D2);
yI([
  F()
], lb.prototype, "showNotifications", 2);
lb = yI([
  X("wy-notification-button-list"),
  bt()
], lb);
var WH = Object.defineProperty, qH = Object.getOwnPropertyDescriptor, mI = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$8"), mC = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? qH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && WH(t, e, s), s;
}, "__decorateClass$t"), jH = /* @__PURE__ */ d((n, t, e) => t.has(n) || mI("Cannot " + e), "__accessCheck$8"), cb = /* @__PURE__ */ d((n, t, e) => (jH(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$8"), wI = /* @__PURE__ */ d((n, t, e) => t.has(n) ? mI("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$8"), U1, B1, W2, hf;
let hb = (W2 = (hf = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.itemType = "file", wI(this, U1, new og(this));
  }
  dispatchFileOpen(t, e) {
    t.preventDefault();
    const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
    return this.dispatchEvent(i);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("contextId") || t.has("componentFeatures")) && this.weavy && this.contextId && this.componentFeatures?.allowsFeature(z.ContextData) && await cb(this, U1).trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.contextId, "data"],
          exact: !0
        }
      },
      this.weavy.queryClient
    );
  }
  render() {
    const { result: t } = cb(this, U1), e = t?.filter((i) => i.variables?.file);
    return this.componentFeatures?.allowsFeature(z.ContextData) && e ? Mi(
      e,
      (i) => "mutation" + i.submittedAt,
      (i) => {
        if (i.context?.file) {
          const s = i.context.file, r = {
            ...i.context.status
          }, a = s.size && s.size > 0 ? Qy(s.size) : null, o = Ei(s.name), { icon: l } = Mn(s.name), h = My(s.name), u = Ys(s.provider);
          return this.itemType === "file" ? v`
                    <wy-file-item
                      @click=${(p) => {
            !p.defaultPrevented && !s.is_trashed && this.dispatchFileOpen(p, s);
          }}
                      .hasHover=${!1}
                      .file=${i.context.file}
                      .status=${r}
                      title="${Vb(i.context.type)}: ${s.name + (r.text ? `: ${r.text}` : "")}"
                    >
                      <span slot="title"
                        ><strong></strong> ${s.name}
                        ${r.text ? v`: <em>${r.text}</em>` : Q}</span
                      >
                      <span slot="actions"></span>
                    </wy-file-item>
                  ` : v`
                    <a
                      @click=${(p) => {
            !p.defaultPrevented && !s.is_trashed && this.dispatchFileOpen(p, s);
          }}
                      class="wy-item wy-list-item"
                      href="${Ct(s.download_url)}"
                      title=${s.name}
                    >
                      <wy-icon name=${l} .overlayName=${u} size="48" kind=${h} ext=${o}></wy-icon>
                      <div class="wy-item-body ">
                        <div class="wy-item-title">${s.name}</div>
                        ${a ? v`<div class="wy-item-text" title="${a}">${a}</div>` : ""}
                      </div>
                    </a>
                  `;
        }
        return Q;
      }
    ) : Q;
  }
}, c(hf, "so"), hf), d(W2, "WyContextDataItems"), W2);
U1 = /* @__PURE__ */ new WeakMap();
hb.styles = [ft, Tt];
mC([
  O()
], hb.prototype, "itemType", 2);
hb = mC([
  X("wy-context-data-items")
], hb);
var q2, df;
let Uk = (q2 = (df = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), wI(this, B1, new og(this));
  }
  dispatchFileOpen(t, e) {
    t.preventDefault();
    const i = new CustomEvent("file-open", { detail: { fileId: e.id } });
    return this.dispatchEvent(i);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("contextId") || t.has("componentFeatures")) && this.weavy && this.contextId && this.componentFeatures?.allowsFeature(z.ContextData) && await cb(this, B1).trackMutationState(
      {
        filters: {
          mutationKey: ["apps", this.contextId, "data"],
          exact: !0
        }
      },
      this.weavy.queryClient
    );
  }
  render() {
    const { result: t, isMutating: e } = cb(this, B1), i = t?.filter((a) => a.variables?.file), s = SP(i), r = PP(i);
    return this.componentFeatures?.allowsFeature(z.ContextData) && t && t.length ? v`
          ${e || s.percent !== null && s.percent < 100 ? v`
                <wy-progress-linear
                  ?indeterminate=${!s.percent}
                  overlay
                  reveal
                  ?warning=${r === "error"}
                  value=${s.percent ?? 0}
                  max=${100}
                ></wy-progress-linear>
              ` : Q}
        ` : Q;
  }
}, c(df, "ro"), df), d(q2, "WyContextDataProgress"), q2);
B1 = /* @__PURE__ */ new WeakMap();
Uk.styles = [ft, Tt];
Uk = mC([
  X("wy-context-data-progress")
], Uk);
var FH = Object.defineProperty, UH = Object.getOwnPropertyDescriptor, gI = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? UH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && FH(t, e, s), s;
}, "__decorateClass$s");
const vI = "wy-chat";
var j2, uf;
let yy = (j2 = (uf = class extends It {
  constructor() {
    super(...arguments), this.componentType = Pt.Chat, this.componentFeatures = new On({
      // All available features as enabled/disabled by default
      [z.Attachments]: !0,
      [z.ContextData]: !0,
      [z.CloudFiles]: !0,
      [z.Embeds]: !0,
      [z.GoogleMeet]: !0,
      [z.Meetings]: !0,
      [z.Mentions]: !0,
      [z.MicrosoftTeams]: !0,
      [z.Polls]: !0,
      [z.Previews]: !0,
      [z.Reactions]: !0,
      [z.Receipts]: !1,
      [z.Typing]: !1,
      [z.ZoomMeetings]: !0
    }), this.theme = new Gs(this, yy.styles);
  }
  render() {
    return v`
      <wy-context-data-progress></wy-context-data-progress>
      <wy-buttons position="floating" reverse>
        <wy-notification-button-list></wy-notification-button-list>
      </wy-buttons>

      <wy-conversation
        .conversation=${this.app}
        .conversationId=${this.app?.id}
        .placeholder=${this.placeholder}
      >
        <wy-context-data-progress slot="footerbar"></wy-context-data-progress>
      </wy-conversation>
    `;
  }
}, c(uf, "no"), uf), d(j2, "WyChat"), j2);
yy.styles = [ft, fa, hl, Bi, Ks];
gI([
  O()
], yy.prototype, "placeholder", 2);
yy = gI([
  X(vI),
  bt()
], yy);
var BH = Object.defineProperty, XH = Object.getOwnPropertyDescriptor, bI = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? XH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && BH(t, e, s), s;
}, "__decorateClass$r");
const OI = "wy-comments";
var F2, pf;
let my = (F2 = (pf = class extends It {
  constructor() {
    super(...arguments), this.componentType = Pt.Comments, this.componentFeatures = new On({
      // All available features as enabled/disabled by default
      [z.Attachments]: !0,
      [z.CloudFiles]: !0,
      [z.ContextData]: !0,
      [z.Embeds]: !0,
      [z.GoogleMeet]: !1,
      [z.Meetings]: !1,
      [z.Mentions]: !0,
      [z.MicrosoftTeams]: !1,
      [z.Polls]: !0,
      [z.Previews]: !0,
      [z.Reactions]: !0,
      [z.Typing]: !1,
      // Has no effect currently
      [z.ZoomMeetings]: !1
    }), this.theme = new Gs(this, my.styles);
  }
  render() {
    return v`
      <wy-buttons position="floating" reverse>
        <wy-notification-button-list></wy-notification-button-list>
      </wy-buttons>
      <wy-comment-list parentId=${this.app?.id} .location=${"apps"} .placeholder=${this.placeholder}></wy-comment-list>
      <wy-context-data-progress></wy-context-data-progress>
    `;
  }
}, c(pf, "ao"), pf), d(F2, "WyComments"), F2);
my.styles = [ft, fa, hl, Bi, Ks];
bI([
  O()
], my.prototype, "placeholder", 2);
my = bI([
  X(OI),
  bt()
], my);
function $I(n) {
  if (!this.weavy || !this.app)
    return;
  const t = {
    message: n.message,
    direction: n.message.created_by.id === this.user?.id ? "outbound" : "inbound"
  };
  n.message.created_by.is_agent && (t.agent = n.message.created_by.uid);
  const e = new CustomEvent("wy-message", {
    bubbles: !1,
    cancelable: !1,
    composed: !0,
    detail: t
  });
  this.dispatchEvent(e);
}
c($I, "Z4");
d($I, "handleRealtimeMessage");
const NH = Qt`.wy-list{border-radius:var(--wy-border-radius-sm, calc(var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))) - .25 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))));display:flex;flex-direction:column;gap:var(--wy-border);min-width:0}.wy-list .wy-item:not(.wy-item-hover){--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-list .wy-item:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.wy-list .wy-item:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.wy-list-bordered{border:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));gap:0}.wy-list-bordered .wy-item{border-top:var(--wy-border, 1px) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));border-left:none;border-right:none}.wy-list-bordered .wy-item:first-child{border-top:none}.wy-list-bordered .wy-item:last-child{border-bottom:none}.wy-list-bordered .wy-item+.wy-list-bordered .wy-item{border-top-width:0}`;
var HH = Object.defineProperty, YH = Object.getOwnPropertyDescriptor, wC = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? YH(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && HH(t, e, s), s;
}, "__decorateClass$q");
const xI = "wy-copilot";
var U2, ff;
let il = (U2 = (ff = class extends It {
  constructor() {
    super(...arguments), this.componentType = Pt.AgentChat, this.componentFeatures = new On({
      // All available features as enabled/disabled by default
      [z.Attachments]: !1,
      [z.ContextData]: !0,
      [z.Embeds]: !0,
      [z.Mentions]: !1,
      [z.Previews]: !0,
      [z.Reactions]: !1,
      [z.Typing]: !0
    }), this.theme = new Gs(this, il.styles), this.conversationRef = mt(), this.handleRealtimeMessage = $I.bind(this);
  }
  /**
   * Sets the editor input to a suggested text. This replaces the text content of the editor. This can be used to create any custom suggestions.
   *
   * @param {string} text - The text suggestion to place in the editor.
   */
  async setSuggestion(t) {
    await this.conversationRef.value?.setEditorText(t);
  }
  async willUpdate(t) {
    if (await super.willUpdate(t), t.has("weavy") && this.weavy && (this.addConversationMutation = hP(this.weavy)), (t.has("app") || t.has("weavy")) && this.weavy && (this.unsubscribeToRealtime?.(), this.app)) {
      const e = `a${this.app.id}`;
      this.weavy.subscribe(e, "message_created", this.handleRealtimeMessage), this.unsubscribeToRealtime = () => {
        this.weavy?.unsubscribe(e, "message_created", this.handleRealtimeMessage), this.unsubscribeToRealtime = void 0;
      };
    }
    t.has("agent") && t.get("agent") && this.agent && this.reset();
  }
  render() {
    return this.agent ? v`
          <wy-buttons position="floating" reverse>
            ${this.app && this.uid ? v` <wy-notification-button-list></wy-notification-button-list> ` : Q}
            <slot name="actions"></slot>
          </wy-buttons>
          <wy-conversation
            ${rt(this.conversationRef)}
            .conversation=${this.app}
            .conversationId=${this.app?.id}
            .placeholder=${this.placeholder ?? P("Ask anything...")}
            .agentInstructions=${this.instructions}
            .createConversation=${this.agent && this.addConversationMutation ? async (t) => {
      if (!this.agent || !this.addConversationMutation)
        throw new Error("Agent or addConversationMutation not defined");
      const e = {
        uid: `wy-copilot-${Bc()}`,
        name: KS(GS(this.name ?? t.text)),
        members: [this.agent],
        type: gn.AgentChat
      }, i = await this.addConversationMutation.mutate(e);
      return this.app = i, await this.updateComplete, i;
    } : void 0}
          >
            <slot
              slot="empty"
              name="empty"
              @click=${async (t) => {
      t.target.matches(".suggestion") && (t.stopPropagation(), await this.setSuggestion(t.target.innerText), await this.conversationRef.value?.setCursorLastInEditor(), this.conversationRef.value?.focusEditor());
    }}
              @keydown=${Fe}
              @keyup=${vi}
            >
              <slot name="header">
                <wy-icon-display>
                  <slot name="icon">
                    <wy-icon name="stars"></wy-icon>
                  </slot>
                </wy-icon-display>
              </slot>
              <slot name="suggestions">
                <div class="wy-list">
                  <slot name="suggestion-list">
                    <!--wy-button class="suggestion">Summarize this page</wy-button-->
                  </slot>
                </div>
              </slot>
              <slot name="footer"></slot>
            </slot>
            <wy-context-data-progress slot="footerbar"></wy-context-data-progress>
          </wy-conversation>
        ` : v`
          <wy-empty>
            <wy-icon-display>
              <slot name="icon">
                <wy-icon name="stars"></wy-icon>
              </slot>
            </wy-icon-display>
          </wy-empty>
        `;
  }
}, c(ff, "oo"), ff), d(U2, "WyCopilot"), U2);
il.styles = [fa, hl, Bi, Ks, NH];
wC([
  O()
], il.prototype, "instructions", 2);
wC([
  O()
], il.prototype, "placeholder", 2);
il = wC([
  X(xI),
  bt()
], il);
function kI(n, t, e = {}, i = {}) {
  if (!n)
    throw new Error("useFileList must be used within a WeavyContext");
  return {
    ...i,
    queryKey: ["apps", t, "files", e],
    initialPageParam: 0,
    queryFn: /* @__PURE__ */ d(async (s) => {
      const r = s.pageParam, a = !!e?.trashed, o = e.order ? e.order.by + (e.order.descending ? "+desc" : "") : "";
      let l = "/api/apps/" + t + "/files?skip=" + r + "&order_by=" + o;
      return a && (l += "&trashed=null"), await (await n.fetch(l)).json();
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ d((s) => s.end && s.end < s.count ? s.end : null, "getNextPageParam")
  };
}
c(kI, "ex");
d(kI, "getInfiniteFileListOptions");
function SI(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ d(async ({ file: s, name: r }) => {
      if (s.id >= 1) {
        const a = await n.fetch("/api/files/" + s.id, {
          method: "PATCH",
          body: JSON.stringify({
            name: r
          })
        });
        if (!a.ok) {
          const o = await a.json();
          throw new Error(o.detail || o.title, { cause: o });
        }
        return await a.json();
      } else
        throw new Error(`Could not rename ${s.name}`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => (Ot(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      s.file.id,
      (r) => Object.assign(r, { name: s.name })
    ), { type: "rename", file: s.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ d((s, r) => {
      Ot(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, s)
      ), ce(e, i.mutationKey, r, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ d((s, r) => {
      Ot(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { name: r.file.name })
      ), ce(e, i.mutationKey, r, (a) => {
        a.status.state = "error", a.status.text = s.message;
      });
    }, "onError")
  };
  return i;
}
c(SI, "ix");
d(SI, "getRenameFileMutationOptions");
function PI(n, t) {
  return new jt(n.queryClient, SI(n, t));
}
c(PI, "sx");
d(PI, "getRenameFileMutation");
function CI(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ d(async ({ file: s }) => {
      if (s.id >= 1) {
        if (!(await n.fetch("/api/files/" + s.id + "/trash", { method: "POST" })).ok)
          throw new Error();
      } else
        throw new Error(`Could not trash ${s.name}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => (Ot(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      s.file.id,
      (r) => Object.assign(r, { is_trashed: !0 })
    ), { type: "trash", file: s.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ d((s, r) => {
      Ot(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, s)
      ), ce(e, i.mutationKey, r, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError(s, r) {
      Ot(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { is_trashed: !1 })
      ), ce(e, i.mutationKey, r, (a) => {
        a.status.state = "error", a.status.text = s.message;
      });
    }
  };
  return i;
}
c(CI, "rx");
d(CI, "getTrashFileMutationOptions");
function QI(n, t) {
  return new jt(n.queryClient, CI(n, t));
}
c(QI, "nx");
d(QI, "getTrashFileMutation");
function MI(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ d(async ({ file: s }) => {
      if (s.id >= 1) {
        const r = await n.fetch("/api/files/" + s.id + "/restore", { method: "POST" });
        if (!r.ok) {
          const a = await r.json();
          throw new Error(a.detail || a.title, { cause: a });
        }
      } else {
        const r = { status: 400, title: `Could not restore ${s.name}.` };
        throw new Error(r.detail || r.title, { cause: r });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => (Ot(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      s.file.id,
      (r) => Object.assign(r, { status: "pending" })
    ), { type: "restore", file: s.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ d((s, r) => {
      Ot(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { is_trashed: !1, status: "ok" })
      ), ce(e, i.mutationKey, r, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError(s, r) {
      Ot(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { is_trashed: !0 })
      ), ce(e, i.mutationKey, r, (a) => {
        a.status.state = "error", a.status.text = s.message;
      });
    }
  };
  return i;
}
c(MI, "ax");
d(MI, "getRestoreFileMutationOptions");
function TI(n, t) {
  return new jt(n.queryClient, MI(n, t));
}
c(TI, "ox");
d(TI, "getRestoreFileMutation");
function AI(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["apps", t.id, "files"],
    mutationFn: /* @__PURE__ */ d(async ({ file: s }) => {
      if (s.id >= 1 && s.is_trashed) {
        const r = await n.fetch("/api/files/" + s.id, { method: "DELETE" });
        if (!r.ok) {
          const a = await r.json();
          throw new Error(a.detail || a.title, { cause: a });
        }
      } else {
        const r = { status: 400, title: `Could not delete ${s.name} forever.` };
        throw new Error(r.detail || r.title, { cause: r });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => (Ot(
      e,
      { queryKey: i.mutationKey, exact: !1 },
      s.file.id,
      (r) => Object.assign(r, { status: "pending" })
    ), { type: "delete-forever", file: s.file, status: { state: "pending" } }), "onMutate"),
    onSuccess: /* @__PURE__ */ d((s, r) => {
      FU(e, { queryKey: i.mutationKey, exact: !1 }, r.file.id), ce(e, i.mutationKey, r, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError(s, r) {
      Ot(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { status: void 0 })
      ), ce(e, i.mutationKey, r, (a) => {
        a.status.state = "error", a.status.text = s.message;
      });
    }
  };
  return i;
}
c(AI, "cx");
d(AI, "getDeleteForeverFileMutationOptions");
function RI(n, t) {
  return new jt(n.queryClient, AI(n, t));
}
c(RI, "lx");
d(RI, "getDeleteForeverFileMutation");
function EI(n, t) {
  const e = n.queryClient, i = ["apps", t.id, "files"];
  return {
    mutationKey: i,
    mutationFn: /* @__PURE__ */ d(async ({ file: s, subscribe: r }) => {
      if (s.id >= 1) {
        const a = await n.fetch(`/api/files/${s.id}/${r ? "subscribe" : "unsubscribe"}`, {
          method: "POST"
        });
        if (!a.ok) {
          const o = await a.json();
          throw new Error(o.detail || o.title, { cause: o });
        }
      } else
        throw new Error(`Could not ${r ? "subscribe" : "unsubscribe"} to ${s.name}.`);
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => (Ot(
      e,
      { queryKey: i, exact: !1 },
      s.file.id,
      (r) => Object.assign(r, { is_subscribed: s.subscribe, status: "pending" })
    ), {
      type: s.subscribe ? "subscribe" : "unsubscribe",
      file: s.file,
      status: { state: "pending" }
    }), "onMutate"),
    onSuccess: /* @__PURE__ */ d((s, r) => {
      Ot(
        e,
        { queryKey: i, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { status: "ok" })
      ), ce(e, i, r, (a) => {
        a.status.state = "ok";
      });
    }, "onSuccess"),
    onError: /* @__PURE__ */ d((s, r) => {
      Ot(
        e,
        { queryKey: i, exact: !1 },
        r.file.id,
        (a) => Object.assign(a, { is_subscribed: r.file.is_subscribed, status: "error" })
      ), ce(e, i, r, (a) => {
        a.status.state = "error", a.status.text = s.message;
      });
    }, "onError")
  };
}
c(EI, "dx");
d(EI, "getSubscribeFileMutationOptions");
function _I(n, t) {
  return new jt(n.queryClient, EI(n, t));
}
c(_I, "hx");
d(_I, "getSubscribeFileMutation");
const GH = /* @__PURE__ */ d((n) => {
  var p;
  var t, e, i, s, r, a, o, l, h, u;
  return u = (p = class extends n {
    /**
     * @constructor
     * @hideconstructor
     */
    constructor(...m) {
      super(...m), q(this, s), q(this, t, []), q(this, e), q(this, i, /* @__PURE__ */ new Set());
    }
    get eventParent() {
      return k(this, e);
    }
    set eventParent(m) {
      m?.eventChildren && m.eventChildren.add(this), L(this, e, m);
    }
    get eventChildren() {
      return k(this, i);
    }
    /**
     * Registers one or several event listeners. All event listeners are managed and automatically unregistered on destroy.
     *
     * When listening to weavy events, you may also listen to `before:` and `after:` events by simply adding the prefix to a weavy event.
     * Event handlers listening to weavy events may return modified data that is returned to the trigger. The data is passed on to the next event in the trigger event chain. If an event handler calls `event.stopPropagation()` or `return false`, the event chain will be stopped and the value is returned.
     *
     * @example <caption>Instance event</caption>
     * myInstance.on("before:options", function(options) { ... })
     * myInstance.on("options", function(options) { ... })
     * myInstance.on("after:options", function(options) { ... })
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#on
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string|Object} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     */
    on(...m) {
      const w = yt(this, s, h).call(this, m);
      if (m[3]) {
        const b = /* @__PURE__ */ d((...$) => {
          try {
            w.handler.apply(this, $);
          } catch {
            try {
              w.handler();
            } catch (x) {
              console.warn("Could not invoke one handler:", x);
            }
          }
          yt(this, s, o).call(this, w.events, w.selector, null, w.handler);
        }, "attachedHandler");
        yt(this, s, r).call(this, w.events, w.selector, b, w.handler);
      } else
        yt(this, s, r).call(this, w.events, w.selector, w.handler, w.handler);
    }
    /**
     * Registers one or several event listeners that are executed once. All event listeners are managed and automatically unregistered on destroy.
     *
     * Similar to {@link WeavyEvents#on}.
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#one
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string|Object} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {Function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     */
    one(m, w, b) {
      this.on(m, w, b, !0);
    }
    /**
     * Unregisters event listeners. The arguments must match the arguments provided on registration using .on() or .one().
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#off
     * @param {string} events - One or several event names separated by spaces. You may provide any namespaces in the names or use the general namespace parameter instead.
     * @param {string} [selector] - Only applicable if the context supports selectors, for instance jQuery.on().
     * @param {function} handler - The listener. The first argument is always the event, followed by any data arguments provided by the trigger.
     * @returns {boolean} Was the handler removed?
     */
    off(...m) {
      const w = yt(this, s, h).call(this, m), b = yt(this, s, a).call(this, w.events, w.selector, w.handler);
      return yt(this, s, o).call(this, w.events, w.selector, b, w.handler);
    }
    /**
     * Clears all registered eventhandlers
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#clear
     */
    clearEventHandlers() {
      k(this, t).length = 0;
    }
    /**
     * Trigger a custom event. Events are per default triggered on the weavy instance using the weavy namespace.
     *
     * The trigger has an event chain that adds `before:` and `after:` events automatically for all events except when any custom `prefix:` is specified. This way you may customize the eventchain by specifying `before:`, `on:` and `after:` in your event name to fire them one at the time. The `on:` prefix will then be removed from the name when the event is fired.
     *
     * Eventhandlers listening to the event may return modified data that is returned by the trigger event. The data is passed on to the next event in the trigger event chain. If an event handler calls `event.stopPropagation()` or `return false`, the event chain will be stopped and the value is returned.
     *
     * @example
     * // Normal triggering
     * weavyEvents.triggerEvent("myevent");
     *
     * // Will trigger the following events on the root instance
     * // 1. before:myevent.event.weavy
     * // 2. myevent.event.weavy
     * // 3. after:myevent.event.weavy
     *
     * @example
     * // Custom triggering, one at the time
     * weavyEvents.triggerEvent("before:myevent");
     * weavyEvents.triggerEvent("on:myevent");
     * weavyEvents.triggerEvent("after:myevent");
     *
     * @example
     * // Advanced triggering with data handling
     *
     * function doSomething() {
     *     // Will trigger the events sequentially and check the response data in between
     *
     *     var myTriggerData = { counter: 123, label: "my label" };
     *
     *     // Custom triggering, one at the time
     *
     *     // 1. Trigger before: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("before:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("before:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     // ...
     *
     *     // 2. Continue with on: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("on:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("on:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     // ...
     *
     *     // 3. At last trigger after: and save the response data back to myTriggerData
     *     myTriggerData = weavyEvents.triggerEvent("after:myevent", myTriggerData);
     *
     *     if (myTriggerData === false) {
     *         console.warn("after:myevent was cancelled by event.stopPropagation() or return false");
     *         return;
     *     }
     *
     *     console.log("myevent was fully executed", myTriggerData);
     *     return myTriggerData;
     * }
     *
     * @category eventhandling
     * @function
     * @name WeavyEvents#triggerEvent
     * @param {string} name - The name of the event.
     * @param {(Array/Object/JSON)} [data] - Data may be an array or plain object with data or a JSON encoded string.
     * @param {any} ...additionalData - Any raw extra data
     * @returns {data} The data passed to the event trigger including any modifications by event handlers. Returns false if the event is cancelled.
     */
    triggerEvent(m, w, ...b) {
      const $ = /^(before|on|after):/.test(m), x = $ ? m.split(":")[0] : "";
      m = m.replace(/^(before|on|after):/, "");
      const C = "before:" + m, R = m, E = "after:" + m;
      if (w && typeof w == "string")
        try {
          w = JSON.parse(w);
        } catch {
          console.warn("Could not parse event data", m, w);
        }
      let A;
      if ($) {
        if (x === "before" || x === "after") {
          if (k(this, e) && (A = k(this, e).triggerEvent(
            x === "before" ? C : E,
            w,
            ...b
          ), w = A || A === !1 ? A : w, w === !1) || (A = yt(this, s, l).call(this, x === "before" ? C : E, w, ...b), w = A || A === !1 ? A : w, w === !1))
            return w;
        } else if (x === "on" && (A = yt(this, s, l).call(this, R, w, ...b), w = A || A === !1 ? A : w, w === !1 || k(this, e) && (A = k(this, e).triggerEvent("on:" + R, w, ...b), w = A || A === !1 ? A : w, w === !1)))
          return w;
      } else {
        if (k(this, e) && (A = k(this, e).triggerEvent(C, w, ...b), w = A || A === !1 ? A : w, w === !1) || (A = yt(this, s, l).call(this, C, w, ...b), w = A || A === !1 ? A : w, w === !1) || (A = yt(this, s, l).call(this, R, w, ...b), w = A || A === !1 ? A : w, w === !1) || k(this, e) && (A = k(this, e).triggerEvent("on:" + R, w, ...b), w = A || A === !1 ? A : w, w === !1) || k(this, e) && (A = k(this, e).triggerEvent(E, w, ...b), w = A || A === !1 ? A : w, w === !1))
          return w;
        A = yt(this, s, l).call(this, E, w, ...b), w = A || A === !1 ? A : w;
      }
      return w;
    }
  }, c(p, "g"), p), t = /* @__PURE__ */ new WeakMap(), e = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakSet(), /**
  * Saves a single event handler.
  *
  * @internal
  * @function
  * @param {string} event - One or more events. Multiple events are currently not registered individually.
  * @param {string|Object} [selector] - Optional refinement selector
  * @param {function} handler - The handler function. may be wrapped for once-handlers
  * @param {function} originalHandler - The original non-wrapped event handler.
  */
  r = /* @__PURE__ */ d(function(y, m, w, b) {
    k(this, t).push({
      events: y,
      selector: m,
      handler: w,
      originalHandler: b
    });
  }, "#registerEventHandler"), /**
  * Returns the event handler or wrapped event handler. The arguments must match the registered event handler.
  *
  * @internal
  * @function
  * @param {string} events - The events registered
  * @param {string|Object} [selector] - The optional selector for the handler.
  * @param {function} handler - The registered handler
  * @param {function} [originalHandler] - The original registered handler
  */
  a = /* @__PURE__ */ d(function(y, m, w, b) {
    const $ = {
      events: y,
      selector: m,
      handler: w,
      originalHandler: b || w
    }, x = k(this, t).filter((C) => Fc($, C, !0)).pop();
    return x && x.handler;
  }, "#getEventHandler"), /**
  * Unregister an event handler. Arguments must match the registered event handler.
  *
  * @internal
  * @function
  * @param {string} event - The events registered
  * @param {function} handler - The registered handler
  * @param {string|Object} [selector] - The optional selector for the handler.
  * @returns {boolean} - True if any handler was removed
  */
  o = /* @__PURE__ */ d(function(y, m, w, b) {
    const $ = {
      events: y,
      selector: m,
      handler: w,
      originalHandler: b
    };
    let x = !1;
    return k(this, t).forEach((C, R) => {
      Fc($, C, !0) && (x = !0, k(this, t).splice(R, 1));
    }), x;
  }, "#unregisterEventHandler"), /**
  * Triggers any local event handlers registered. Each handler may modify the data and return it or return false to cancel the event chain. .stopPropagation() and .preventDefault() may also be used.
  *
  * @example
  * weavyEvents.on("myevent", function(e, data) { ... })
  *
  * triggerHandler(this, "myevent", { key: 1 })
  *
  * @internal
  * @function
  * @param {any} eventName - The name of the event. Event names without prefix will also trigger handlers with the "on:" prefix.
  * @param {any} data - Any data to pass to the handler
  * @param {any} ...additionalData - Any extra data
  */
  l = /* @__PURE__ */ d(function(y, m, ...w) {
    let b = !1;
    return k(this, t).forEach(($) => {
      $.events.split(" ").forEach((x) => {
        if (x = x.indexOf("on:") === 0 ? x.split("on:")[1] : x, y === x && (!$.selector || Fc($.selector, m, !0))) {
          const C = $.handler(m, ...w);
          C ? m = C : C === !1 && (b = !0);
        }
      });
    }), b ? !1 : m;
  }, "#triggerHandler"), /**
  * Extracts and normalizes all parts of the events arguments.
  *
  * @internal
  * @function
  * @param {Array.<Object>} eventArguments - The function argument list: `[context], events, [selector], handler`
  * @returns {Object}
  * @property {string} events - Event names with added namespace for local events.
  * @property {string|Object} selector - The optional selector.
  * @property {function} handler - The handler function
  * @
  */
  h = /* @__PURE__ */ d(function(y) {
    const m = typeof y[1] == "function" ? y[1] : y[2], w = typeof y[1] == "function" ? null : y[1];
    return { events: y[0], selector: w, handler: m };
  }, "#getEventArguments"), d(u, "WeavyEvents"), u;
}, "MixinWeavyEvents"), KH = GH(class {
});
function Bk(n) {
  let t = "";
  try {
    t = /^((?:https?:\/\/[^/]+)|(?:file:\/\/))\/?/.exec(n)?.[1] || "";
  } catch {
    console.error(
      "Unable to resolve location origin. Make sure you are using http, https or file protocol and have a valid location URL."
    );
  }
  return t;
}
c(Bk, "aw");
d(Bk, "extractOrigin");
var yf;
const zI = (yf = class extends KH {
  constructor(t = {}) {
    super(), this.contentWindows = /* @__PURE__ */ new Set(), this.contentWindowsMapByWeavyId = /* @__PURE__ */ new Map(), this.contentWindowOrigins = /* @__PURE__ */ new WeakMap(), this.contentWindowNames = /* @__PURE__ */ new WeakMap(), this.contentWindowWeavyIds = /* @__PURE__ */ new WeakMap(), this.contentWindowDomain = /* @__PURE__ */ new WeakMap(), this.origin = ub() ? Bk(window.location.href) : "", this.timeout = 2e3, t?.timeout && (this.timeout = t.timeout), window.addEventListener("message", (e) => {
      if (e.data.name && e.data.weavyId !== void 0) {
        if (e.data.weavyMessageId && e.data.name !== "message-receipt" && e.data.name !== "unready")
          try {
            e.source?.postMessage(
              { name: "message-receipt", weavyId: e.data.weavyId, weavyMessageId: e.data.weavyMessageId },
              { targetOrigin: e.origin }
            );
          } catch {
            console.error("could not post back message-receipt to source");
          }
        switch (e.data.name) {
          case "register-child": {
            if ((!e.source || !this.contentWindowWeavyIds.has(e.source)) && console.warn("register-child: contentWindow not pre-registered", e.source), e.source && this.contentWindowOrigins.get(e.source) !== e.origin) {
              console.error(
                "register-child: " + this.contentWindowNames.get(e.source) + " has invalid origin",
                e.origin
              );
              return;
            }
            try {
              const i = e.source ? this.contentWindowWeavyIds.get(e.source) : void 0, s = e.source ? this.contentWindowNames.get(e.source) : void 0;
              s && e.source && e.source.postMessage(
                {
                  name: "register-window",
                  windowName: s,
                  weavyId: i || !0
                },
                { targetOrigin: e.origin }
              );
            } catch (i) {
              console.error("could not register frame window", i);
            }
            break;
          }
          case "ready": {
            e.source && this.contentWindowsMapByWeavyId.has(e.data.weavyId) && this.contentWindowNames.has(e.source) && this.contentWindowsMapByWeavyId.get(e.data.weavyId)?.get(this.contentWindowNames.get(e.source)) && (this.contentWindowDomain.set(e.source, e.origin), this.distributeMessage(e));
            break;
          }
          case "unready": {
            this.contentWindowsMapByWeavyId.has(e.data.weavyId) && this.distributeMessage(e, !0);
            break;
          }
          default: {
            (e.source === window || this.contentWindowsMapByWeavyId.size) && this.distributeMessage(e);
            break;
          }
        }
      }
    });
  }
  /**
   * The weavy console logging.
   */
  get console() {
    return console;
  }
  distributeMessage(t, e = !1) {
    const i = t.source === window && t.origin === this.origin;
    if (e ||= t.source && this.contentWindowOrigins.has(t.source) && t.origin === this.contentWindowOrigins.get(t.source) || !1, i || e) {
      e && !t.data.windowName && t.source && (t.data.windowName = this.contentWindowNames.get(t.source));
      const s = t.data.name;
      s && this.triggerEvent(s, t.data, t), this.triggerEvent("message", t.data, t);
    }
  }
  /**
   * Sends the id of a frame to the frame content scripts, so that the frame gets aware of which id it has.
   * The frame needs to have a unique name attribute.
   *
   * @category panels
   * @param {string} weavyId - The id of the group or entity which the contentWindow belongs to.
   * @param {Window} contentWindow - The frame window to send the data to.
   */
  registerContentWindow(t, e, i, s) {
    try {
      if (!e) {
        console.error("registerContentWindow() No valid contentWindow to register, must be a window and have a name.");
        return;
      }
    } catch {
      console.error("registerContentWindow() cannot access contentWindowName");
    }
    t.self && (t = t.self), this.console.log("registerContentWindow", t), (!i || i === "true") && (i = !0), this.contentWindowsMapByWeavyId.has(i) || this.contentWindowsMapByWeavyId.set(i, /* @__PURE__ */ new Map()), this.contentWindowsMapByWeavyId.get(i)?.set(e, t), this.contentWindows.add(t), this.contentWindowNames.set(t, e), this.contentWindowWeavyIds.set(t, i), this.contentWindowOrigins.set(t, s);
  }
  unregisterAll(t) {
    this.contentWindowsMapByWeavyId.has(t) && (this.contentWindowsMapByWeavyId.get(t)?.forEach((e, i) => {
      this.unregisterContentWindow(i, t);
    }), this.contentWindowsMapByWeavyId.get(t), this.contentWindowsMapByWeavyId.delete(t));
  }
  unregisterContentWindow(t, e) {
    if (this.contentWindowsMapByWeavyId.has(e)) {
      if (this.contentWindowsMapByWeavyId.get(e)?.has(t)) {
        const i = this.contentWindowsMapByWeavyId.get(e)?.get(t);
        if (i)
          try {
            this.contentWindows.delete(i), this.contentWindowNames.delete(i), this.contentWindowWeavyIds.delete(i), this.contentWindowOrigins.delete(i);
          } catch {
          }
      }
      if (this.contentWindowsMapByWeavyId.get(e)?.delete(t), this.contentWindowsMapByWeavyId.get(e)?.size === 0)
        try {
          this.contentWindowsMapByWeavyId.delete(e);
        } catch {
        }
    }
  }
  async whenPostMessage(t, e, i) {
    ii(), i === null && (i = void 0);
    const s = t === window.self, r = s ? Bk(window.location.href) : this.contentWindowOrigins.get(t);
    if (s || t && r === this.contentWindowDomain.get(t)) {
      e.weavyMessageId || (e.weavyMessageId = ey() + ey());
      let a;
      await Promise.race([
        new Promise((o, l) => {
          a = window.setTimeout(() => {
            l(new Error("postMessage() receipt timed out: " + e.weavyMessageId + ", " + e.name));
          }, this.timeout || 2e3);
        }),
        new Promise((o) => {
          this.on("message-receipt", { weavyId: e.weavyId, weavyMessageId: e.weavyMessageId }, () => {
            clearTimeout(a), o(void 0);
          }), t.postMessage(e, { targetOrigin: r, transfer: i });
        })
      ]);
    } else
      throw new Error("postMessage() Invalid window origin: " + r + ", " + e.name);
  }
  postToChildren(t, e) {
    if (typeof t != "object" || !t.name) {
      console.error("postToChildren() Invalid message format", t);
      return;
    }
    e === null && (e = void 0), t.distributeName = t.name, t.name = "distribute", t.weavyId = t.weavyId || !0, this.contentWindows.forEach((i) => {
      const s = this.contentWindowOrigins.get(i);
      if (s === this.contentWindowDomain.get(i))
        try {
          i.postMessage(t, { targetOrigin: s, transfer: e });
        } catch {
          console.warn(
            "postToChildren() could not distribute message to " + this.contentWindowNames.get(i)
          );
        }
    });
  }
  async postToFrame(t, e, i, s) {
    if (typeof i != "object" || !i.name) {
      console.error("postToFrame() Invalid message format", i);
      return;
    }
    const r = this.contentWindowsMapByWeavyId.get(e)?.get(t);
    if (!r)
      throw new Error(`postToFrame() Window not registered: ${e}, ${t}`);
    return i.weavyId = e, await this.whenPostMessage(r, i, s);
  }
  async postToSelf(t, e) {
    if (typeof t != "object" || !t.name) {
      console.error("postToSelf() Invalid message format", t);
      return;
    }
    return t.weavyId = t.weavyId || !0, await this.whenPostMessage(window.self, t, e);
  }
  postToSource(t, e, i) {
    if (t.source && t.data.weavyId !== void 0) {
      const s = t.source === window.self && t.origin === this.origin, r = this.contentWindowOrigins.has(t.source) && t.origin === this.contentWindowOrigins.get(t.source);
      if (i === null && (i = void 0), s || r) {
        e.weavyId = t.data.weavyId;
        try {
          t.source.postMessage(e, { targetOrigin: t.origin, transfer: i });
        } catch (a) {
          console.error("postToSource() Could not post message back to source", a);
        }
      }
    }
  }
}, c(yf, "sy"), yf);
d(zI, "WeavyPostalParent");
let JH = zI;
var tY = Object.defineProperty, eY = Object.getOwnPropertyDescriptor, hO = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? eY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && tY(t, e, s), s;
}, "__decorateClass$p"), B2, mf;
let nl = (B2 = (mf = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.iframeVisible = !1, this.showOverlay = !1, this.isRegistered = !1, this.iframeElementRef = mt(), this.overlayRef = mt();
  }
  open() {
    this.showOverlay = !0;
  }
  close() {
    this.showOverlay = !1, this.iframeVisible = !1;
  }
  get origin() {
    let t = "";
    try {
      window.location.ancestorOrigins && 0 < window.location.ancestorOrigins.length ? t = window.location.ancestorOrigins[window.location.ancestorOrigins.length - 1] : window.top && (t = window.top.document.location.origin);
    } catch {
    }
    if (!t)
      try {
        t = window.self.document.location.origin;
      } catch {
        console.error("Filebrowser: Could not read current origin.");
      }
    return t;
  }
  dispatchExternalBlobs(t) {
    const e = new CustomEvent("external-blobs", { detail: { externalBlobs: t } });
    return this.dispatchEvent(e);
  }
  connectedCallback() {
    super.connectedCallback(), this.handleFiles = (t, e) => {
      e.source === this.iframeElementRef.value?.contentWindow?.self && (this.dispatchExternalBlobs(t.blobs), this.close());
    }, this.handleClose = (t, e) => {
      e.source === this.iframeElementRef.value?.contentWindow?.self && this.close();
    }, this.handleGoogleSelected = (t, e) => {
      e.source === this.iframeElementRef.value?.contentWindow?.self && this.overlayRef.value && (this.overlayRef.value.maximized = !0);
    }, this.weavyPostal || (this.weavyPostal = new JH()), this.weavyPostal.on("add-external-blobs", this.handleFiles), this.weavyPostal.on("request:file-browser-close", this.handleClose), this.weavyPostal.on("google-selected", this.handleGoogleSelected);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.weavyPostal?.off("add-external-blobs", this.handleFiles), this.weavyPostal?.off("request:file-browser-close", this.handleClose), this.weavyPostal?.off("google-selected", this.handleGoogleSelected);
  }
  updated() {
    this.weavy && (this.showOverlay && !this.src && (this.src = new URL(
      "?origin=" + this.origin + "&v=X&t=" + Date.now().toString() + "&weavyId=wy-filebrowser",
      this.weavy.cloudFilePickerUrl
    )), this.weavyPostal && !this.isRegistered && this.showOverlay && this.src ? this.iframeElementRef.value?.contentWindow && (this.weavyPostal.registerContentWindow(
      this.iframeElementRef.value?.contentWindow.self,
      "weavy-filebrowser",
      "wy-filebrowser",
      this.src.origin
    ), this.isRegistered = !0) : this.weavyPostal && this.isRegistered && !this.showOverlay && this.src && (this.weavyPostal.unregisterContentWindow("weavy-filebrowser", "wy-filebrowser"), this.isRegistered = !1, this.src = void 0));
  }
  render() {
    return this.weavy ? v`
      <wy-overlay
        .show=${this.showOverlay}
        ${rt(this.overlayRef)}
        @close=${() => this.close()}
        @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
      >
        ${this.showOverlay ? v`
              <wy-spinner overlay ?hidden=${this.iframeVisible}></wy-spinner>
              <iframe
                ${rt(this.iframeElementRef)}
                @load=${() => this.iframeVisible = !0}
                src=${Ct(this.src?.toString())}
                style="flex: 1 1 100%; border: 0;"
                id="weavy-filebrowser"
                name="weavy-filebrowser"
                title=${P("Cloud File Browser")}
              ></iframe>
            ` : Q}
      </wy-overlay>
    ` : Q;
  }
}, c(mf, "co"), mf), d(B2, "WyCloudFiles"), B2);
nl.styles = ft;
hO([
  F()
], nl.prototype, "src", 2);
hO([
  F()
], nl.prototype, "iframeVisible", 2);
hO([
  F()
], nl.prototype, "showOverlay", 2);
nl = hO([
  X("wy-cloud-files"),
  bt()
], nl);
var iY = Object.defineProperty, nY = Object.getOwnPropertyDescriptor, bg = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? nY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && iY(t, e, s), s;
}, "__decorateClass$o"), X2, wf;
let la = (X2 = (wf = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.order = { by: "name", descending: !1 }, this.view = "list", this.showTrashed = !1, this.showUploadSheet = !1, this.mutatingFiles = new og(
      this
    ), this.fileInputRef = mt(), this.cloudFilesRef = mt(), this.openFileInput = () => {
      this.fileInputRef.value?.click();
    }, this.openCloudFiles = () => {
      this.cloudFilesRef.value?.open();
    };
  }
  // remove file attachment
  async handleRemoveMutation(t) {
    const e = await this.whenWeavy(), i = await this.whenApp(), s = t.status === "error" && !t.variables?.blob ? ["apps", i.id, "blobs", void 0] : ["apps", i.id, "files"];
    xP(
      e.queryClient,
      s,
      (r) => r.state.submittedAt === t.submittedAt
    );
  }
  handleOverwriteUpload(t) {
    const e = t.variables?.blob;
    e && this.dispatchCreateFiles([e], !0);
  }
  dispatchUploadFiles(t) {
    const e = new CustomEvent("upload-files", {
      detail: { files: t }
    });
    return this.dispatchEvent(e);
  }
  dispatchExternalBlobs(t) {
    const e = new CustomEvent("external-blobs", {
      detail: { externalBlobs: t }
    });
    return this.dispatchEvent(e);
  }
  dispatchCreateFiles(t, e = !1) {
    const i = new CustomEvent("create-files", {
      detail: { blobs: t, replace: e }
    });
    return this.dispatchEvent(i);
  }
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  dispatchView(t) {
    const e = new CustomEvent("view", { detail: { view: t } });
    return this.dispatchEvent(e);
  }
  dispatchShowTrashed(t) {
    const e = new CustomEvent("show-trashed", {
      detail: { showTrashed: t }
    });
    return this.dispatchEvent(e);
  }
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", { detail: { subscribe: t } });
    return this.dispatchEvent(e);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && await this.mutatingFiles.trackMutationState(
      { filters: { mutationKey: ["apps", this.app.id], exact: !1 } },
      this.weavy.queryClient
    );
  }
  renderFileMutation(t) {
    if (t.context?.file) {
      const e = t.context.file, i = {
        ...t.context.status
      };
      return t.context.status.state === "conflict" && (i.text = P("Replace existing file?")), v`
        <wy-file-item
          .file=${t.context?.file}
          .status=${i}
          .actionType=${t.context.type}
          title="${Vb(t.context.type)}: ${e.name}"
        >
          <span slot="title">${e.name}</span>
          ${i.text ? v`: <span slot="actions" title=${i.text}><em>${i.text}</em></span>` : Q}
          ${i.state === "conflict" && t.variables?.blob ? v`
                <wy-button
                  slot="actions"
                  kind="icon"
                  @click=${() => this.handleOverwriteUpload(
        t
      )}
                  title=${P("Replace")}
                >
                  <wy-icon name="check"></wy-icon>
                </wy-button>
              ` : Q}
          <wy-button
            slot="actions"
            kind="icon"
            @click=${() => this.handleRemoveMutation(t)}
            title=${P("Discard", { desc: "Button action to discard" })}
          >
            <wy-icon name="close"></wy-icon>
          </wy-button>
        </wy-file-item>
      `;
    }
    return Q;
  }
  render() {
    const t = this.mutatingFiles.result, e = A_(t), i = t?.length ? t.filter((a) => a.context?.file && !e.includes(a)) : [], s = SP(t), r = PP(t);
    return v`
      <nav class="wy-toolbar">
        <div class="wy-toolbar-buttons">
          ${sy(Uo.Create, this.app?.permissions) ? v`
                <wy-dropdown title=${P("Add files")}>
                  <span slot="button">${P("Add files")}</span>
                  <wy-icon slot="button" name="plus" last></wy-icon>
                  <wy-dropdown-item @click=${this.openFileInput} title=${P("From device")}>
                    <wy-icon name="attachment"></wy-icon>
                    <span>${P("From device")}</span>
                  </wy-dropdown-item>
                  <input
                    type="file"
                    data-testid="uploadFile"
                    ${rt(this.fileInputRef)}
                    @click=${(a) => a.stopPropagation()}
                    @change=${(a) => {
      this.dispatchUploadFiles(a.target.files) && (a.target.value = "");
    }}
                    multiple
                    hidden
                    tabindex="-1"
                  />
                  ${this.componentFeatures?.allowsFeature(z.CloudFiles) ? v`
                        <wy-dropdown-item @click=${this.openCloudFiles} title=${P("From cloud")}>
                          <wy-icon name="cloud"></wy-icon>
                          <span>${P("From cloud")}</span>
                        </wy-dropdown-item>
                      ` : Q}
                </wy-dropdown>
              ` : Q}
        </div>
        <div class="wy-toolbar-buttons wy-toolbar-buttons-last">
          ${t?.length ? v`
                <wy-button
                  kind="icon"
                  @click=${() => {
      this.showUploadSheet = !this.showUploadSheet;
    }}
                  title=${P(r === "conflict" ? "File conflict" : r === "error" ? "Upload error" : r === "pending" ? "Pending" : "All uploads finished")}
                >
                  ${r === "conflict" ? v`<wy-icon name="alert" color="yellow" title=${P("File conflict")}></wy-icon>` : r === "error" ? v`<wy-icon name="alert-octagon" color="error" title=${P("Upload error")}></wy-icon>` : r === "pending" ? v`<wy-spinner
                        ?nospin=${s !== void 0 && s.percent !== null}
                        progress=${Ct(s.percent !== null ? s.percent : void 0)}
                        title=${P("Pending")}
                      ></wy-spinner>` : v`<wy-icon name="check" title=${P("All uploads finished")}></wy-icon>`}
                </wy-button>
              ` : Q}
          ${this.app ? v` <wy-notification-button-list></wy-notification-button-list> ` : Q}

          <wy-dropdown icon="sort" title="Sort items by" directionX="left">
            <wy-dropdown-option
              ?selected=${this.order.by === "name"}
              @click=${() => this.dispatchOrder({ ...this.order, by: "name" })}
            >
              ${P("Name")}
            </wy-dropdown-option>
            <wy-dropdown-option
              ?selected=${this.order.by === "updated_at"}
              @click=${() => this.dispatchOrder({ ...this.order, by: "updated_at" })}
            >
              ${P("Modified")}
            </wy-dropdown-option>
            <wy-dropdown-option
              ?selected=${this.order.by === "size"}
              @click=${() => this.dispatchOrder({ ...this.order, by: "size" })}
            >
              ${P("Size")}
            </wy-dropdown-option>
            <wy-dropdown-divider></wy-dropdown-divider>
            <wy-dropdown-option
              ?selected=${!this.order.descending}
              @click=${() => this.dispatchOrder({ ...this.order, descending: !1 })}
            >
              ${P("Ascending")}
            </wy-dropdown-option>
            <wy-dropdown-option
              ?selected=${this.order.descending}
              @click=${() => this.dispatchOrder({ ...this.order, descending: !0 })}
            >
              ${P("Descending")}
            </wy-dropdown-option>
          </wy-dropdown>

          <wy-dropdown
            icon=${this.view === "grid" ? "view-module-outline" : "view-list-outline"}
            title="View options"
            directionX="left"
          >
            <wy-dropdown-option ?selected=${this.view === "list"} @click=${() => this.dispatchView("list")}>
              ${P("List view")}
            </wy-dropdown-option>
            <wy-dropdown-option ?selected=${this.view === "grid"} @click=${() => this.dispatchView("grid")}>
              ${P("Grid view")}
            </wy-dropdown-option>
            <wy-dropdown-divider></wy-dropdown-divider>
            <wy-dropdown-option ?selected=${!this.showTrashed} @click=${() => this.dispatchShowTrashed(!1)}>
              ${P("Hide trashed")}
            </wy-dropdown-option>
            <wy-dropdown-option ?selected=${this.showTrashed} @click=${() => this.dispatchShowTrashed(!0)}>
              ${P("Show trashed")}
            </wy-dropdown-option>
          </wy-dropdown>

          <wy-dropdown directionX="left" ?disabled=${!this.app}>
            ${this.app?.is_subscribed ? v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                  <wy-icon name="bell-off"></wy-icon>
                  ${P("Unsubscribe")}
                </wy-dropdown-item>` : v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                  <wy-icon name="bell"></wy-icon>
                  ${P("Subscribe")}
                </wy-dropdown-item>`}
            ${this.app?.archive_url ? v`<wy-dropdown-item
                  @click=${() => Xc(this.app?.archive_url, "_top", `${this.app?.uid ? this.app.uid : `${this.app?.type}-${this.app?.id}`}.zip`, !0)}
                >
                  <wy-icon name="download"></wy-icon>
                  ${P("Download files")}
                </wy-dropdown-item>` : Q}
          </wy-dropdown>
        </div>
      </nav>

      <wy-context-data-progress></wy-context-data-progress>

      ${this.weavy ? v`
            <wy-sheet
              .show=${this.showUploadSheet}
              @close=${() => this.showUploadSheet = !1}
              @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
            >
              <wy-button
                kind="icon"
                slot="appbar-buttons"
                @click=${() => {
      t?.forEach((a) => this.handleRemoveMutation(a));
    }}
                title=${P("Remove all", { desc: "Button action to remove all" })}
              >
                <wy-icon name="trashcan"></wy-icon>
              </wy-button>
              <span slot="appbar-text">${P("File actions")}</span>
              ${e.length ? v`
                    ${Mi(
      e,
      (a) => "mutation" + a.submittedAt,
      (a) => this.renderFileMutation(a)
    )}
                    ${i.length ? v`<hr />` : Q}
                  ` : Q}
              ${i.length ? v`
                    ${Mi(
      i,
      (a) => "mutation" + a.submittedAt,
      (a) => this.renderFileMutation(a)
    )}
                  ` : Q}
            </wy-sheet>
          ` : Q}

      <wy-cloud-files
        ${rt(this.cloudFilesRef)}
        @external-blobs=${(a) => this.dispatchExternalBlobs(a.detail.externalBlobs)}
      ></wy-cloud-files>
    `;
  }
}, c(wf, "lo"), wf), d(X2, "WyFilesAppbar"), X2);
la.styles = [ft];
bg([
  O({ type: Object })
], la.prototype, "order", 2);
bg([
  O()
], la.prototype, "view", 2);
bg([
  O({ type: Boolean })
], la.prototype, "showTrashed", 2);
bg([
  F()
], la.prototype, "showUploadSheet", 2);
la = bg([
  X("wy-files-appbar"),
  bt()
], la);
const sY = Qt`[part~=wy-grid]{display:grid;grid-auto-flow:dense;grid-template-columns:repeat(auto-fill,minmax(calc(10 * var(--wy-size, 1rem)),1fr));grid-gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}`, rY = Qt`@keyframes wy-highlight{0%{--wy-component-background-color: var(--wy-highlight, var(--wy-primary-95, #e8f2ff));--wy-component-color: var(--wy-on-highlight, var(--wy-primary-10, #001d32))}}[part~=wy-card]{--wy-component-background-color: var(--wy-surface-1, var(--wy-surface-1-light, #f1f2f7));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));--wy-component-border-radius: var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem)));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-component-border-radius);position:relative;display:flex;flex-direction:column;min-width:0;word-wrap:break-word;background-clip:border-box}[part~=wy-card][part~=wy-highlight]{animation:wy-highlight 3s 1.5s ease-in-out both}[part~=wy-card-primary]{--wy-component-background-color: var(--wy-primary-container, var(--wy-primary-90, #cde5ff));--wy-component-color: var(--wy-on-primary-container, var(--wy-primary-10, #001d32))}[part~=wy-card-hover]{cursor:pointer;-webkit-user-select:none;user-select:none}[part~=wy-card-hover]:before{content:\"\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background:var(--wy-component-color);opacity:0%}[part~=wy-card-hover]:hover:before{opacity:var(--wy-opacity-state-hover, 8%)}[part~=wy-card-hover]:focus:before{opacity:var(--wy-opacity-state-focus, 12%)}[part~=wy-card-hover]:active:before,[part~=wy-card-hover][part~=wy-active]:before{opacity:var(--wy-opacity-state-active, 12%)}[part~=wy-card-actions]{position:absolute;top:calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + .5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));right:calc(var(--wy-padding, calc(.5 * var(--wy-size, 1rem))) + .5 * var(--wy-gap, calc(.5 * var(--wy-size, 1rem))));align-items:center;display:flex}[part~=wy-card-content]{flex:1 0 auto;padding-block-end:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));padding-inline-start:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)));padding-inline-end:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-card-content][part~=wy-card-top]{padding-block-start:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}[part~=wy-card-top]{border-radius:var(--wy-component-border-radius);object-fit:cover;object-position:top center;flex:1 1 100%;max-height:calc(10 * var(--wy-size, 1rem))}[part~=wy-card-icon]{--wy-component-icon-width: calc(6 * var(--wy-size, 1rem));--wy-component-icon-height: calc(6 * var(--wy-size, 1rem));display:flex;align-items:center;justify-content:center;flex-direction:column;text-align:center;padding:calc(1 * var(--wy-size, 1rem)) calc(2 * var(--wy-size, 1rem));margin:auto}[part~=wy-card-image]{width:auto;height:auto}[part~=wy-card-image][part~=wy-loading]{transition:opacity .15s ease-out;opacity:0}[part~=wy-card-image][part~=wy-loading][part~=wy-loaded]{opacity:1;transition:opacity .15s ease-out}[part~=wy-card-top-image]{object-position:50% 38%}[part~=wy-trashed]{opacity:var(--wy-opacity-disabled, 38%);text-decoration:line-through}`;
function LI(n, t, e, i, s) {
  return n && n.length ? v`
        <table class="wy-table wy-table-hover wy-table-files">
          <thead>${II.call(this, t)}</thead>
          <tbody>
            ${Mi(
    n,
    (r) => r.id,
    (r) => ZI.call(this, this.weavy, { file: r }, e, i, s)
  )}
          </tbody>
        </table>
        <slot name="end"></slot>
      ` : Q;
}
c(LI, "bx");
d(LI, "renderFileTable");
function II(n) {
  const t = [
    { by: void 0, title: "" },
    // File icon
    { by: "name", title: P("Name") },
    { by: void 0, title: "" },
    // Comments icon
    { by: "updated_at", title: P("Modified") },
    { by: void 0, title: P("Kind") },
    { by: "size", title: P("Size") },
    { by: void 0, title: "" }
    // Menu
  ];
  return v`
    <tr>
      ${t.map((e) => {
    if (e.title) {
      const i = e.by === n?.by, s = /* @__PURE__ */ d((r) => {
        r.preventDefault(), e.by && this.dispatchOrder({ by: e.by, descending: i && !n?.descending });
      }, "onHeaderClick");
      return v` <th>
            ${e.by ? v`<div
                  class="wy-table-sort-link"
                  tabindex="0"
                  @click=${s}
                  @keydown=${Fe}
                  @keyup=${vi}
                  >${e.title}
                  ${i && v`<wy-icon name=${n?.descending ? "menu-down" : "menu-up"}></wy-icon>` || Q}</div
                >` : e.title}
          </th>`;
    } else
      return v`<th class="wy-table-cell-icon"></th>`;
  })}
    </tr>
  `;
}
c(II, "xx");
d(II, "renderFileTableHeaders");
function ZI(n, { file: t }, e, i, s) {
  const r = t.size && t.size > 0 ? Qy(t.size) : Q, a = t.updated_at || t.created_at, o = new Intl.DateTimeFormat(n?.locale, { dateStyle: "full", timeStyle: "short" }).format(
    new Date(a)
  ), l = new Intl.DateTimeFormat(n?.locale, { dateStyle: "short" }).format(new Date(a)), h = !!(e && e === t.id), { icon: u } = Mn(t.name), p = Ei(t.name), y = Ys(t.provider), m = /* @__PURE__ */ d(($) => {
    $.stopImmediatePropagation();
    const x = $.target;
    x.value && x.value !== t.name ? this.dispatchRename(t, x.value) : this.dispatchEditName({ id: NaN });
  }, "handleRename"), w = /* @__PURE__ */ d(($) => {
    const x = $.target;
    $.key === "Escape" ? ($.preventDefault(), x.value = t.name, x.blur()) : $.key === "Enter" && ($.preventDefault(), x.blur());
  }, "handleRenameKey"), b = !!(i && i === t.id);
  return v`
    <tr
      class=${Xt({ "wy-table-row-trashed": t.is_trashed })}
      part=${Me({ "wy-highlight": b })}
      @click=${($) => {
    !$.defaultPrevented && !t.is_trashed && this.dispatchFileOpen(t.id);
  }}
      ${b && s ? rt(s) : Q}
    >
      <td class="wy-table-cell-icon"
        ><wy-icon name=${u} .overlayName=${y} size="24" kind=${t.kind} ext=${p}></wy-icon
      ></td>
      <td class="wy-table-cell-text">
        ${h ? v`
              <input
                type="text"
                maxlength="256"
                class="wy-input"
                .defaultValue=${t.name}
                @blur=${m}
                @keyup=${($) => {
    Ds($), w($);
  }}
                @click=${($) => $.preventDefault()}
                @focus=${Hb}
                ${rt(Hk)}
              />
            ` : v`${t.name}`}
      </td>
      <td class="wy-table-cell-icon"
        >${t.comments?.count ? v`<wy-button
              kind="icon"
              @click=${($) => {
    !$.defaultPrevented && !t.is_trashed && ($.target.blur(), this.dispatchFileOpen(t.id, "comments"), $.stopPropagation());
  }}
              title=${P(nt`${t.comments.count} comments`)}
            >
              <span class="wy-badge">${t.comments.count}</span>
            </wy-button>` : Q}</td
      >
      <td><time datetime="${a}" title=${o}>${l}</time></td>
      <td>${t.kind}</td>
      <td>${r}</td>
      <td class="wy-table-cell-icon">
        <wy-file-menu
          .file=${t}
          @edit-name=${($) => this.dispatchEditName($.detail.file)}
          @trash=${($) => this.dispatchTrash($.detail.file)}
          @restore=${($) => this.dispatchRestore($.detail.file)}
          @delete-forever=${($) => this.dispatchDeleteForever($.detail.file)}
          @subscribe=${($) => this.dispatchSubscribe($.detail.file, $.detail.subscribe)}
        >
        </wy-file-menu>
      </td>
    </tr>
  `;
}
c(ZI, "$x");
d(ZI, "renderFileTableRow");
function VI(n, t, e, i) {
  const s = n.size && n.size > 0 ? Qy(n.size) : Q, r = n.updated_at || n.created_at, a = new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(
    new Date(r)
  ), o = !!(t && t === n.id), { icon: l } = Mn(n.name), h = Ei(n.name), u = Ys(n.provider), p = /* @__PURE__ */ d((b) => {
    b.stopImmediatePropagation();
    const $ = b.target;
    $.value && $.value !== n.name ? this.dispatchRename(n, $.value) : this.dispatchEditName({ id: NaN });
  }, "handleRename"), y = /* @__PURE__ */ d((b) => {
    const $ = b.target;
    b.key === "Escape" ? (b.preventDefault(), $.value = n.name, $.blur()) : b.key === "Enter" && (b.preventDefault(), $.blur());
  }, "handleRenameKey"), m = {
    "wy-trashed": n.is_trashed
  }, w = !!(e && e === n.id);
  return v`
    <div
      part=${Me({
    "wy-card": !0,
    "wy-card-trashed": n.is_trashed,
    "wy-card-hover": !n.is_trashed && !o,
    "wy-highlight": w
  })}
      title="${n.name} • ${s} • ${a}"
      tabindex="0"
      @click=${(b) => {
    !b.defaultPrevented && !n.is_trashed && this.dispatchFileOpen(n.id);
  }}
      @keydown=${Fe}
      @keyup=${vi}
      ${w && i ? rt(i) : Q}
    >
      <div part="wy-card-actions">
        <wy-file-menu
          small
          .file=${n}
          @edit-name=${(b) => this.dispatchEditName(b.detail.file)}
          @trash=${(b) => this.dispatchTrash(b.detail.file)}
          @restore=${(b) => this.dispatchRestore(b.detail.file)}
          @delete-forever=${(b) => this.dispatchDeleteForever(b.detail.file)}
          @subscribe=${(b) => this.dispatchSubscribe(b.detail.file, b.detail.subscribe)}
        ></wy-file-menu>
      </div>
      ${!n.is_trashed && n.thumbnail_url ? v`
            <img
              part="wy-card-top wy-card-content wy-card-image ${Me({
    "wy-card-top-image": n.kind === "image",
    ...m
  })}"
              width=${Ct(n.width)}
              height=${Ct(n.height)}
              src=${n.thumbnail_url}
              alt=${n.name}
              ${rt(Lw)}
              @load=${Iw}
              loading="lazy"
              decoding="async"
            />
          ` : v`
            <div part="wy-card-top wy-card-content wy-card-icon ${Me(m)}">
              <wy-icon name=${l} .overlayName=${u} size="96" kind=${n.kind} ext=${h}></wy-icon>
            </div>
          `}
      <div part="wy-card-content wy-filename ${Me(m)}">
        ${o ? v`
              <input
                type="text"
                maxlength="256"
                class="wy-input"
                .defaultValue=${n.name}
                @blur=${p}
                @keyup=${(b) => {
    Ds(b), y(b);
  }}
                @click=${(b) => b.preventDefault()}
                @focus=${Hb}
                ${rt(Hk)}
              />
            ` : v`<div class="wy-truncated-text-and-icon"
              ><div>${n.name}</div> ${n.comments?.count ? v`<wy-button
                    small
                    kind="icon"
                    @click=${(b) => {
    !b.defaultPrevented && !n.is_trashed && (b.target.blur(), this.dispatchFileOpen(n.id, "comments"), b.stopPropagation());
  }}
                    title=${P(nt`${n.comments.count} comments`)}
                  >
                    <span class="wy-badge">${n.comments.count}</span>
                  </wy-button>` : Q}</div
            >`}
      </div>
    </div>
  `;
}
c(VI, "Cx");
d(VI, "renderFileCard");
var aY = Object.defineProperty, oY = Object.getOwnPropertyDescriptor, wa = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? oY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && aY(t, e, s), s;
}, "__decorateClass$n"), N2, gf;
let Cn = (N2 = (gf = class extends _t {
  constructor() {
    super(), this.exportParts = new et(this), this.order = { by: "name", descending: !1 }, this.view = "list", this.isRenamingId = NaN, this.highlightId = NaN, this.highlightComment = !1, this.highlightRef = mt(), this.addEventListener("edit-name", (t) => {
      this.isRenamingId = t.detail.file.id;
    }), this.addEventListener("rename", () => {
      this.isRenamingId = NaN;
    });
  }
  dispatchFileOpen(t, e) {
    const i = new CustomEvent("file-open", { detail: { fileId: t, tab: e } });
    return this.dispatchEvent(i);
  }
  dispatchOrder(t) {
    const e = new CustomEvent("order", { detail: { order: t } });
    return this.dispatchEvent(e);
  }
  dispatchEditName(t) {
    const e = new CustomEvent("edit-name", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  dispatchRename(t, e) {
    const i = new CustomEvent("rename", { detail: { file: t, name: e } });
    return this.dispatchEvent(i);
  }
  dispatchTrash(t) {
    const e = new CustomEvent("trash", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  dispatchRestore(t) {
    const e = new CustomEvent("restore", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  dispatchDeleteForever(t) {
    const e = new CustomEvent("delete-forever", { detail: { file: t } });
    return this.dispatchEvent(e);
  }
  dispatchSubscribe(t, e) {
    const i = new CustomEvent("subscribe", { detail: { file: t, subscribe: e } });
    return this.dispatchEvent(i);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("link") && (this.highlightId = this.link && jP(this.link, ci.File)?.id, this.highlightComment = this.link && this.highlightId ? FP(this.link, ci.File, { id: this.highlightId }, ci.Comment) : !1), t.has("highlightComment") && this.highlightComment && this.highlightId && this.dispatchFileOpen(this.highlightId, "comments");
  }
  render() {
    return this.files && this.files.length ? this.view === "grid" ? v`
          <div part="wy-grid">
            ${Mi(
      this.files,
      (t) => t.id,
      (t) => VI.call(this, t, this.isRenamingId, this.highlightId, this.highlightRef)
    )}
          </div>
          <slot name="end"></slot>
        ` : LI.call(this, this.files, this.order, this.isRenamingId, this.highlightId, this.highlightRef) : Q;
  }
  updated(t) {
    t.has("highlightId") && this.highlightId && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, c(gf, "ho"), gf), d(N2, "WyFilesList"), N2);
Cn.styles = [ft, hl, sY, rY];
wa([
  O({ attribute: !1 })
], Cn.prototype, "files", 2);
wa([
  O({ type: Number })
], Cn.prototype, "dataUpdatedAt", 2);
wa([
  O({ attribute: !1 })
], Cn.prototype, "order", 2);
wa([
  O()
], Cn.prototype, "view", 2);
wa([
  F()
], Cn.prototype, "isRenamingId", 2);
wa([
  F()
], Cn.prototype, "highlightId", 2);
wa([
  F()
], Cn.prototype, "highlightComment", 2);
Cn = wa([
  X("wy-files-list"),
  bt()
], Cn);
var lY = Object.defineProperty, cY = Object.getOwnPropertyDescriptor, DI = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$7"), dO = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? cY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && lY(t, e, s), s;
}, "__decorateClass$m"), WI = /* @__PURE__ */ d((n, t, e) => t.has(n) || DI("Cannot " + e), "__accessCheck$7"), H3 = /* @__PURE__ */ d((n, t, e) => (WI(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$7"), hY = /* @__PURE__ */ d((n, t, e) => t.has(n) ? DI("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$7"), Y3 = /* @__PURE__ */ d((n, t, e, i) => (WI(n, t, "write to private field"), t.set(n, e), e), "__privateSet$7"), kc;
const qI = "wy-files";
var H2, vf;
let ca = (H2 = (vf = class extends It {
  constructor() {
    super(), this.componentType = Pt.Files, this.componentFeatures = new On({
      // All available features as enabled/disabled by default
      [z.Attachments]: !0,
      [z.CloudFiles]: !0,
      [z.Comments]: !0,
      [z.ContextData]: !0,
      [z.Embeds]: !0,
      [z.GoogleMeet]: !1,
      [z.Meetings]: !1,
      [z.Mentions]: !0,
      [z.MicrosoftTeams]: !1,
      [z.Polls]: !0,
      [z.Previews]: !0,
      [z.Reactions]: !0,
      [z.Typing]: !1,
      // Has no effect currently
      [z.Versions]: !0,
      [z.WebDAV]: !0,
      [z.ZoomMeetings]: !1
    }), this.theme = new Gs(this, ca.styles), this.view = "list", this.order = { by: "name", descending: !1 }, this.showTrashed = !1, this.filesQuery = new dl(this), this.persistState = new hC(this), this.infiniteScroll = new ul(this), this.pagerRef = mt(), this.previewRef = mt(), this.dropZone = new NL(this), this.appSubscribeMutation = new en(this), this.uploadBlobMutation = new en(this), this.createFileMutation = new en(this), this.handleRealtimeFileCreated = (t) => {
      !this.weavy || !this.app || (t.file.created_by = t.actor, this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) }));
    }, this.handleRealtimeFileUpdated = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileTrashed = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileRestored = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeFileDeleted = (t) => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, this.handleRealtimeCommentCreated = () => {
      !this.weavy || !this.app || this.weavy.queryClient.invalidateQueries({ queryKey: this.getFilesQueryKey(this.app) });
    }, hY(this, kc), this.addEventListener("drop-files", (t) => this.handleBlobUpload(t));
  }
  // upload files
  handleBlobUpload(t) {
    const e = t.detail;
    if (e.files)
      for (let i = 0; i < e.files.length; i++) {
        const s = { file: e.files[i] };
        this.uploadBlobMutation.mutate(s).then((r) => this.handleCreateFile(r));
      }
  }
  // upload files
  handleExternalBlobs(t) {
    if (t.detail.externalBlobs)
      for (let e = 0; e < t.detail.externalBlobs.length; e++) {
        const i = t.detail.externalBlobs[e];
        this.externalBlobMutation?.mutate({ externalBlob: i }).then((s) => this.handleCreateFile(s));
      }
  }
  // add uploaded files
  async handleCreateFile(t, e) {
    return await this.createFileMutation.mutate({ blob: t, replace: e });
  }
  handleSubscribe(t) {
    this.app?.id && this.appSubscribeMutation.mutate({ subscribe: t });
  }
  getFilesQueryKey(t) {
    return ["apps", t.id, "files"];
  }
  async willUpdate(t) {
    var e;
    if (await super.willUpdate(t), (t.has("uid") || t.has("weavy") || t.has("user")) && this.uid && this.weavy && this.user && this.persistState.observe(
      [
        { name: "view", override: !0 },
        { name: "order", override: !0 },
        { name: "showTrashed", override: !0 }
      ],
      this.uid.toString(),
      `u${this.user.id}`
    ), (t.has("weavy") || t.has("app") || t.has("order") || t.has("showTrashed")) && this.weavy && this.app && await this.filesQuery.trackInfiniteQuery(
      kI(this.weavy, this.app.id, {
        order: this.order,
        trashed: this.showTrashed
      })
    ), (t.has("weavy") || t.has("app") || t.has("user")) && this.weavy && this.app && this.user) {
      await this.appSubscribeMutation.trackMutation(dP(this.weavy, this.app)), await this.uploadBlobMutation.trackMutation(Yb(this.weavy, this.user, this.app.id)), await this.createFileMutation.trackMutation(E_(this.weavy, this.user, this.app)), this.externalBlobMutation = pC(this.weavy, this.user, this.app.id), this.renameFileMutation = PI(this.weavy, this.app), this.subscribeFileMutation = _I(this.weavy, this.app), this.trashFileMutation = QI(this.weavy, this.app), this.restoreFileMutation = TI(this.weavy, this.app), this.deleteForeverFileMutation = RI(this.weavy, this.app), (e = H3(this, kc)) == null || e.call(this);
      const i = `a${this.app.id}`;
      this.weavy.subscribe(i, "file_created", this.handleRealtimeFileCreated), this.weavy.subscribe(i, "file_updated", this.handleRealtimeFileUpdated), this.weavy.subscribe(i, "file_trashed", this.handleRealtimeFileTrashed), this.weavy.subscribe(i, "file_restored", this.handleRealtimeFileRestored), this.weavy.subscribe(i, "file_deleted", this.handleRealtimeFileDeleted), this.weavy.subscribe(i, "comment_created", this.handleRealtimeCommentCreated), Y3(this, kc, () => {
        this.weavy?.unsubscribe(i, "file_created", this.handleRealtimeFileCreated), this.weavy?.unsubscribe(i, "file_updated", this.handleRealtimeFileUpdated), this.weavy?.unsubscribe(i, "file_trashed", this.handleRealtimeFileTrashed), this.weavy?.unsubscribe(i, "file_restored", this.handleRealtimeFileRestored), this.weavy?.unsubscribe(i, "file_deleted", this.handleRealtimeFileDeleted), this.weavy?.unsubscribe(i, "comment_created", this.handleRealtimeCommentCreated), Y3(this, kc, void 0);
      });
    }
  }
  updated() {
    this.infiniteScroll.observe(this.filesQuery.result, this.pagerRef.value);
  }
  render() {
    const { data: t, dataUpdatedAt: e, hasNextPage: i, isPending: s } = this.filesQuery.result, r = this.dropZone.isDragActive, a = hs(t);
    return [
      v`
        <wy-files-appbar
          .order=${this.order}
          .showTrashed=${this.showTrashed}
          .view=${this.view}
          @upload-files=${(o) => this.handleBlobUpload(o)}
          @external-blobs=${(o) => this.handleExternalBlobs(o)}
          @create-files=${(o) => o.detail.blobs.forEach((l) => this.handleCreateFile(l, o.detail.replace))}
          @order=${(o) => {
        this.order = o.detail.order;
      }}
          @show-trashed=${(o) => {
        this.showTrashed = o.detail.showTrashed;
      }}
          @view=${(o) => {
        this.view = o.detail.view;
      }}
          @subscribe=${(o) => this.handleSubscribe(o.detail.subscribe)}
        >
        </wy-files-appbar>
      `,
      this.app ? v`
            <div
              class="wy-files ${Xt({ "wy-dragging": r })}"
              data-drag-title=${P("Drop files here to upload.")}
            >
              ${a.length ? v`
                    <wy-files-list
                      .view=${this.view}
                      .files=${a}
                      .dataUpdatedAt=${e}
                      .order=${this.order}
                      @file-open=${(o) => {
        this.previewRef.value?.open(o.detail.fileId, o.detail.tab);
      }}
                      @order=${(o) => {
        this.order = o.detail.order;
      }}
                      @rename=${(o) => {
        this.renameFileMutation?.mutate({ file: o.detail.file, name: o.detail.name });
      }}
                      @subscribe=${(o) => {
        this.subscribeFileMutation?.mutate({
          file: o.detail.file,
          subscribe: o.detail.subscribe
        });
      }}
                      @trash=${(o) => {
        this.trashFileMutation?.mutate({ file: o.detail.file });
      }}
                      @restore=${(o) => {
        this.restoreFileMutation?.mutate({ file: o.detail.file });
      }}
                      @delete-forever=${(o) => {
        this.deleteForeverFileMutation?.mutate({ file: o.detail.file });
      }}
                    >
                      ${i ? v`<div slot="end" ${rt(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : Q}
                    </wy-files-list>
                  ` : v`
                    <wy-empty>
                      ${s ? v`<wy-spinner padded reveal></wy-spinner>` : v` <wy-icon-display>
                            <wy-icon name="file-upload"></wy-icon>
                            <span slot="text">${P("Add some files to get started!")}</span>
                          </wy-icon-display>`}
                    </wy-empty>
                  `}
            </div>
            ${t ? v` <wy-preview ${rt(this.previewRef)} .infiniteQueryResult=${this.filesQuery.result}></wy-preview> ` : Q}
          ` : v`<wy-empty><wy-spinner padded reveal></wy-spinner></wy-empty>`
    ];
  }
  disconnectedCallback() {
    var t;
    (t = H3(this, kc)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(vf, "uo"), vf), d(H2, "WyFiles"), H2);
kc = /* @__PURE__ */ new WeakMap();
ca.styles = [Bi, ft, fa, Ks, ma];
dO([
  O()
], ca.prototype, "view", 2);
dO([
  O({ type: Object })
], ca.prototype, "order", 2);
dO([
  O({ type: Boolean })
], ca.prototype, "showTrashed", 2);
ca = dO([
  X(qI),
  bt()
], ca);
const dY = Qt`.wy-messenger-layout{display:flex;flex:1;align-items:stretch;position:relative;container-type:inline-size;align-self:stretch;min-height:0;min-width:0}wy-conversation-list{flex:0 1 50%;min-width:0;max-width:24rem;border-right:1px solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c1c7ce))}.wy-messenger-conversation{display:flex;flex-direction:column;overflow-anchor:none;height:100%;width:100%;flex:0 1 100%;min-width:max(50%,16rem)}.wy-close-conversation{display:none}@container (max-width: 768px){wy-conversation-list{flex:0 1 100%;min-width:0;max-width:none;border-right:none}wy-conversation-list[conversationid]{display:none}.wy-messenger-conversation[data-conversation-id=\"\"]{display:none}.wy-close-conversation{display:contents}wy-empty{display:none}}`, uY = Qt`.wy-title{font-family:var(--wy-headings-font-family, var(--wy-font-family, unset));font-size:var(--wy-headings-font-size, 1.25em);font-style:var(--wy-headings-font-style, unset);font-weight:var(--wy-headings-font-weight, var(--wy-font-weight-bold, 600));line-height:var(--wy-headings-line-height, var(--wy-line-height, 1.2));margin-block:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}.wy-input{--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border:var(--wy-input-border-width, var(--wy-border, 1px)) solid var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce));display:block;width:100%;min-height:calc(var(--wy-input-font-size, var(--wy-font-size, 1em)) * 1.5 * var(--wy-size, 1rem) + var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) * 2 + var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) * 2);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));font-family:var(--wy-input-font-family, var(--wy-font-family, inherit)),inherit;font-size:var(--wy-input-font-size, var(--wy-font-size, 1em));font-weight:var(--wy-input-font-weight, var(--wy-font-weight, unset));line-height:var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem))));background-clip:padding-box;appearance:none;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))))}.wy-input:focus{--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));color:var(--wy-component-color);border-color:var(--wy-primary, var(--wy-primary-40, #006399));outline:0}.wy-input::placeholder{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));opacity:1}.wy-input:disabled{opacity:38%}.wy-input::file-selector-button,.wy-input::-webkit-file-upload-button{color:var(--wy-component-color);background-color:var(--wy-component-background-color);padding:var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));margin:calc(-1 * var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))) calc(-1 * var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))));margin-inline-end:var(--wy-input-padding-x, var(--wy-padding-lg, calc(1.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem))))));pointer-events:none;border-color:inherit;border-style:solid;border-width:0;border-inline-end-width:var(--wy-input-border-width, var(--wy-border, 1px));border-radius:0}.wy-input:hover:not(:disabled):not([readonly])::file-selector-button,.wy-input:hover:not(:disabled):not([readonly]) ::-webkit-file-upload-button{background-color:var(--wy-component-background-color)}.wy-input[type=file]{overflow:hidden}.wy-input[type=file]:not(:disabled):not([readonly]){cursor:pointer}.wy-input::-webkit-date-and-time-value{height:calc(var(--wy-input-line-height, var(--wy-line-height, calc(1.5 * var(--wy-size, 1rem)))) * 1em)}.wy-input[type=search]::-webkit-search-cancel-button{-webkit-appearance:none}.wy-input-filled{--wy-component-background-color: var(--wy-surface-2, var(--wy-surface-2-light, #eaedf3));--wy-component-color: var(--wy-on-surface, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color);border-radius:var(--wy-input-filled-border-radius, var(--wy-border-radius-pill, var(--wy-border-radius, calc(2.5 * var(--wy-size, 1rem)))));border-color:var(--wy-component-background-color)}.wy-input-filled:focus{border-color:var(--wy-outline-variant, var(--wy-neutral-variant-80, #c2c7ce))}.wy-label{display:inline-block;margin-bottom:calc(.5 * var(--wy-size, 1rem))}.wy-description{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));margin-top:calc(.25 * var(--wy-size, 1rem))}.wy-is-invalid,.wy-is-invalid:focus{border-color:var(--wy-error, var(--wy-error-40, #ba1824))}.wy-invalid-feedback{margin-top:calc(.25 * var(--wy-size, 1rem));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)));color:var(--wy-error, var(--wy-error-40, #ba1824))}.wy-input-group{position:relative;display:flex;gap:var(--wy-gap, calc(.5 * var(--wy-size, 1rem)));align-items:center;flex:1 0 auto}.wy-input-group-button-icon{--wy-component-background-color: transparent}.wy-input-group-input-with-overlay{padding-right:calc(var(--wy-input-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))) + var(--wy-button-size, calc(var(--wy-button-line-height, 1.5) * var(--wy-size, 1rem) + 2 * var(--wy-button-padding-y, var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))))}.wy-input-group-button-icon-overlay{position:absolute;display:inline-flex;top:0;right:0;z-index:4;border-radius:var(--wy-input-border-radius, var(--wy-border-radius, calc(.5 * var(--wy-size, 1rem))));--wy-component-background-color: transparent}.wy-input-group-input:placeholder-shown~.wy-input-group-button-icon[type=reset]{display:none}.wy-input-group-input:not(:placeholder-shown)~.wy-input-group-button-icon[type=reset]+.wy-input-group-button-icon{display:none}`;
var pY = Object.defineProperty, fY = Object.getOwnPropertyDescriptor, uO = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? fY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && pY(t, e, s), s;
}, "__decorateClass$l"), Y2, bf;
let wy = (Y2 = (bf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.inputRef = mt(), this.compact = !1, this.query = "", this.throttledSearch = Wk(
      () => {
        this.query = this.inputRef.value?.value || "";
      },
      250,
      { leading: !1, trailing: !0 }
    );
  }
  focusInput() {
    this.inputRef.value?.focus();
  }
  clear() {
    this.query = "";
  }
  willUpdate(t) {
    if (t.has("query")) {
      const e = new CustomEvent("search", {
        bubbles: !0,
        composed: !1,
        detail: { query: this.query }
      });
      this.dispatchEvent(e);
    }
  }
  render() {
    const t = {
      "wy-input": !0,
      "wy-input-group-input": !0,
      "wy-input-filled": !0,
      "wy-input-group-input-with-overlay": this.compact
    }, e = {
      "wy-input-group-button-icon": !0,
      "wy-input-group-button-icon-overlay": this.compact
    };
    return v`
      <div class="wy-input-group">
        <input
          class=${Xt(t)}
          name="text"
          .value=${this.query || ""}
          ${rt(this.inputRef)}
          @input=${() => this.throttledSearch()}
          @keydown=${Uz}
          @keyup=${Ds}
          placeholder=${this.placeholder || P("Search...")}
          size="4"
        />
        <wy-button type="reset" @click=${() => this.clear()} kind="icon" class=${Xt(e)}>
          <wy-icon name="close-circle"></wy-icon>
        </wy-button>
        <wy-button kind="icon" class=${Xt(e)}>
          <wy-icon name="magnify"></wy-icon>
        </wy-button>
      </div>
    `;
  }
}, c(bf, "po"), bf), d(Y2, "WySearch"), Y2);
wy.styles = [uY, Tt];
uO([
  O()
], wy.prototype, "placeholder", 2);
uO([
  O({ type: Boolean })
], wy.prototype, "compact", 2);
uO([
  F()
], wy.prototype, "query", 2);
wy = uO([
  X("wy-search"),
  bt()
], wy);
var yY = Object.defineProperty, mY = Object.getOwnPropertyDescriptor, ga = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? mY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && yY(t, e, s), s;
}, "__decorateClass$k"), G2, Of;
let Qn = (G2 = (Of = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.agentFilter = void 0, this.selected = [], this.select = [], this.text = "", this.peopleQuery = new dl(this), this.searchRef = mt(), this.infiniteScroll = new ul(this), this.pagerRef = mt();
  }
  dispatchSubmit() {
    this.selected = [...this.selected, ...this.select];
    const t = new CustomEvent("submit", { detail: { members: this.selected } });
    return this.dispatchEvent(t);
  }
  isChecked(t) {
    return this.select.find((e) => e.id === t) != null;
  }
  handleSelected(t, e) {
    e ? this.select = [...this.select, t] : (this.select = this.select.filter((i) => i.id !== t.id), this.selected = this.selected.filter((i) => i.id !== t.id));
  }
  getSelected() {
    return this.selected.length > 0 ? v`
        ${this.selected.map((t) => v`
            <div
              class="wy-item wy-list-item wy-item-hover"
              @click=${() => this.handleSelected(t, !1)}
              @keydown=${Fe}
              @keyup=${Fe}
            >
              <wy-avatar
                id=${t.id}
                .src=${t.avatar_url}
                .name=${t.name}
                .description=${t.comment}
                .presence=${t.presence}
                .isAgent=${t.is_agent}
                size=${32}
              ></wy-avatar>
              <div class="wy-item-body"> ${t.name} </div>
              <wy-icon name="checkbox-marked"></wy-icon>
            </div>
          `)}
      ` : Q;
  }
  getSearchResult() {
    const { data: t, hasNextPage: e, isPending: i } = this.peopleQuery.result ?? { data: [], isPending: !0 }, s = hs(t), r = !!s.length, a = [];
    return i ? a.push(v`<wy-spinner overlay></wy-spinner>`) : r || a.push(v`<div class="wy-pane-group">
        <div class="wy-table-no-result">
          ${this.text ? P("Your search did not match any people.") : P("No more users found.")}
        </div>
      </div>`), r && a.push(
      v` ${s.filter((o) => this.selected.find((l) => l.id === o.id) === void 0).map((o) => v`<div
              class="wy-item wy-list-item wy-item-hover"
              @click=${() => this.handleSelected(o, !this.isChecked(o.id))}
              @keydown=${Fe}
              @keyup=${Fe}
            >
              <wy-avatar
                id=${o.id}
                .src=${o.avatar_url}
                .name=${o.name}
                .description=${o.comment}
                .presence=${o.presence}
                .isAgent=${o.is_agent}
                size=${32}
              ></wy-avatar>
              <div class="wy-item-body"> ${o.name} </div>
              <wy-icon name="${this.isChecked(o.id) ? "checkbox-marked" : "checkbox-blank"}"></wy-icon>
            </div>`) ?? Q}`
    ), e && a.push(v`<div ${rt(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>`), a;
  }
  render() {
    return v`<div class="wy-pane wy-scroll-y">
      <div class="wy-pane-body">
        <div class="wy-pane-group">
          <wy-search ${rt(this.searchRef)} @search=${(t) => this.text = t.detail.query}></wy-search>
        </div>
        <div>
          <wy-buttons tabs>
            <wy-button
              ?active=${this.agentFilter === void 0}
              @click=${() => this.agentFilter = void 0}
              kind="tab"
              small
              >${P("All")}</wy-button
            >
            <wy-button ?active=${this.agentFilter === !1} @click=${() => this.agentFilter = !1} kind="tab" small
              >${P("People")}</wy-button
            >
            <wy-button ?active=${this.agentFilter === !0} @click=${() => this.agentFilter = !0} kind="tab" small
              >${P("Agents")}</wy-button
            >
          </wy-buttons>
        </div>
        <div class="wy-pane-body">
          ${this.getSelected()} ${this.getSearchResult()}
        </div>
      </div>
      <div part="wy-footerbar wy-footerbar-sticky">
        <div class="wy-pane-group">
          <wy-buttons reverse>
            <wy-button
              color="primary"
              @click=${() => this.dispatchSubmit()}
              ?disabled=${this.selected.length === 0 && this.select.length === 0 ? !0 : void 0}
              >${this.buttonTitle ?? P("Create")}</wy-button
            >
          </wy-buttons>
        </div>
      </div>
    </div>`;
  }
  async willUpdate(t) {
    super.willUpdate(t), t.has("weavy") && this.weavy && await this.peopleQuery.trackInfiniteQuery(
      Mz(
        this.weavy,
        () => this.text,
        this.appId,
        () => this.agentFilter
      )
    );
  }
  async updated(t) {
    this.infiniteScroll.observe(this.peopleQuery.result, this.pagerRef.value), (t.has("text") || t.has("agentFilter")) && (this.select.length > 0 && (this.selected = [...this.selected, ...this.select], this.select = []), await this.peopleQuery.result?.refetch?.(), this.searchRef.value?.focusInput());
  }
}, c(Of, "yo"), Of), d(G2, "WyUsersSearch"), G2);
Qn.styles = [
  ft,
  Tz,
  ma,
  Tt
];
ga([
  xe({ context: Le, subscribe: !0 }),
  F()
], Qn.prototype, "weavy", 2);
ga([
  O({ attribute: !1 })
], Qn.prototype, "appId", 2);
ga([
  O({ attribute: !1 })
], Qn.prototype, "buttonTitle", 2);
ga([
  F()
], Qn.prototype, "agentFilter", 2);
ga([
  F()
], Qn.prototype, "selected", 2);
ga([
  F()
], Qn.prototype, "select", 2);
ga([
  F()
], Qn.prototype, "text", 2);
Qn = ga([
  X("wy-users-search"),
  bt()
], Qn);
var wY = Object.defineProperty, gY = Object.getOwnPropertyDescriptor, gC = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? gY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && wY(t, e, s), s;
}, "__decorateClass$j"), K2, $f;
let gy = (K2 = ($f = class extends _t {
  constructor() {
    super(...arguments), this.uploadBlobMutation = new en(this), this.fileInputRef = mt(), this.openFileInput = () => {
      this.fileInputRef.value?.click();
    };
  }
  async handleBlobChange(t, e) {
    if (t && this.weavy) {
      const i = { file: t[0] };
      await this.uploadBlobMutation.trackMutation(z_(this.weavy));
      const s = await this.uploadBlobMutation.mutate(i);
      e && (e.value = "");
      const r = new CustomEvent("blob-uploaded", { detail: { blob: s } });
      this.dispatchEvent(r);
    }
  }
  render() {
    return v` <slot
        name="placeholder"
        @click=${this.openFileInput}
        @keydown=${Fe}
        @keyup=${vi}
      ></slot>
      <input
        accept=${Ct(this.accept)}
        type="file"
        ${rt(this.fileInputRef)}
        @click=${(t) => t.stopPropagation()}
        @change=${(t) => this.handleBlobChange(t.target.files, t.target)}
        hidden
      />
      <slot name="label">
        ${this.label ? v`<wy-button @click=${this.openFileInput}>${this.label}</wy-button>` : Q}
      </slot>`;
  }
}, c($f, "wo"), $f), d(K2, "WyBlobUpload"), K2);
gy.styles = [
  Qt`
      :host {
        text-align: center;
      }
      slot[name="placeholder"] {
        cursor: pointer;
      }
    `
];
gC([
  O({ attribute: !1 })
], gy.prototype, "label", 2);
gC([
  O({ attribute: !1 })
], gy.prototype, "accept", 2);
gy = gC([
  X("wy-blob-upload"),
  bt()
], gy);
var vY = Object.defineProperty, bY = Object.getOwnPropertyDescriptor, jI = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$6"), wl = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? bY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && vY(t, e, s), s;
}, "__decorateClass$i"), FI = /* @__PURE__ */ d((n, t, e) => t.has(n) || jI("Cannot " + e), "__accessCheck$6"), G3 = /* @__PURE__ */ d((n, t, e) => (FI(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$6"), OY = /* @__PURE__ */ d((n, t, e) => t.has(n) ? jI("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$6"), K3 = /* @__PURE__ */ d((n, t, e, i) => (FI(n, t, "write to private field"), t.set(n, e), e), "__privateSet$6"), Sc, J2, xf;
let ls = (J2 = (xf = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.showDetails = !1, this.showAddMembers = !1, this.conversationTitle = "", this.conversationTitleInput = "", this.releaseFocusEvent = () => new CustomEvent("release-focus", { bubbles: !0, composed: !0 }), this.membersQuery = new ns(this), this.handleRealtimeAppUpdated = (t) => {
      !this.conversationId || t.app.id !== this.conversationId || (this.conversationTitle = this.conversationTitleInput = t.app.name);
    }, this.handlePresenceChange = (t) => {
      if (!this.weavy)
        return;
      Array.isArray(t) || (t = [parseInt(t)]);
      const e = /* @__PURE__ */ d((i) => {
        const s = i.members.data ?? [];
        return s.forEach((r) => {
          r.presence = t.indexOf(r.id) != -1 ? "active" : "away";
        }), i.members.data = s, i;
      }, "updateMembersInApps");
      this.weavy.queryClient.setQueryData(["apps", this.conversationId], e);
    }, OY(this, Sc);
  }
  isAgentChat(t) {
    return (t ?? this.conversation)?.type === Pt.AgentChat;
  }
  isChatRoom(t) {
    return (t ?? this.conversation)?.type === Pt.ChatRoom;
  }
  isPrivateChat(t) {
    return (t ?? this.conversation)?.type === Pt.PrivateChat;
  }
  async addMembers(t) {
    this.showAddMembers = !1, this.showDetails = !0, !(!this.weavy || !this.conversationId) && (await this.addMembersMutation?.mutate({ appId: this.conversationId, members: t.map((e) => e.id) }), await this.membersQuery.result.refetch(), await this.weavy.queryClient.invalidateQueries({ queryKey: ["apps"] }));
  }
  async handleSaveConversationName() {
    if (!this.weavy || !this.conversationId)
      return;
    const t = this.conversationTitleInput.trim() === "" ? null : this.conversationTitleInput.trim();
    await this.updateConversationMutation?.mutate({ appId: this.conversationId, name: t });
  }
  async handleAvatarUploaded(t) {
    !this.weavy || !this.conversationId || await this.updateConversationMutation?.mutate({
      appId: this.conversationId,
      blobId: t.id,
      thumbnailUrl: t.thumbnail_url
    });
  }
  async clearAvatar() {
    !this.weavy || !this.conversationId || await this.updateConversationMutation?.mutate({ appId: this.conversationId, blobId: null, thumbnailUrl: null });
  }
  async updateMember(t, e) {
    !this.weavy || !this.conversationId || (await this.updateMemberMutation?.mutate({
      appId: this.conversationId,
      userId: t,
      access: e
    }), await this.membersQuery.result.refetch());
  }
  async leaveConversation(t) {
    if (!(!this.weavy || !this.conversationId || !this.user)) {
      if (t && await this.leaveConversationMutation?.mutate({
        appId: this.conversationId,
        members: [t]
      }), !t || t === this.user.id) {
        this.showDetails = !1, this.conversation = void 0, this.conversationId = void 0;
        const e = new CustomEvent("selected", { detail: { id: void 0 } });
        this.dispatchEvent(e);
      } else
        await this.membersQuery.result.refetch();
      await this.weavy.queryClient.invalidateQueries({ queryKey: ["apps"] });
    }
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("weavy") && this.weavy && (this.leaveConversationMutation = RP(this.weavy), this.addMembersMutation = kz(this.weavy), this.updateConversationMutation = EP(this.weavy), this.updateMemberMutation = xz(this.weavy)), t.has("conversationId") && (this.showDetails = !1), (t.has("weavy") || t.has("conversationId")) && this.weavy)
      if ((e = G3(this, Sc)) == null || e.call(this), this.conversationId) {
        await this.membersQuery.trackQuery(
          _P(this.weavy, this.conversationId, {
            initialData: /* @__PURE__ */ d(() => {
              if (this.conversationId)
                return this.weavy?.queryClient.getQueryData(["apps", this.conversationId])?.members;
            }, "initialData")
          })
        );
        const i = `a${this.conversationId}`;
        this.weavy.subscribe(i, "app_updated", this.handleRealtimeAppUpdated), this.weavy.subscribe(null, "online", this.handlePresenceChange), K3(this, Sc, () => {
          this.weavy?.unsubscribe(i, "app_updated", this.handleRealtimeAppUpdated), this.weavy?.unsubscribe(null, "online", this.handlePresenceChange), K3(this, Sc, void 0);
        });
      } else
        this.membersQuery.untrackQuery();
    t.has("conversation") && this.conversation && (this.conversationTitleInput = this.conversationTitle = this.conversation.name);
  }
  render() {
    const { data: t } = this.membersQuery.result ?? {}, e = (t?.data || []).filter((s) => s.access === mr.Admin).length, i = this.user && this.isPrivateChat() ? (this.conversation?.members?.data || []).filter((s) => s.id !== this.user?.id)?.[0] ?? this.user : null;
    return this.conversationId ? v`
      <header class="wy-appbars">
        <nav class="wy-appbar">
          <slot class="wy-appbar-buttons wy-appbar-buttons-first" name="action"></slot>
          ${this.conversation && this.user ? v`
                <div class="wy-appbar-section">
                  ${this.conversation.type === Pt.PrivateChat ? v`<wy-presence
                        placement="text"
                        .status=${i?.presence}
                        id=${Ct(i?.id)}
                      ></wy-presence>` : Q}
                  <span class="wy-appbar-text">${this.conversationTitle}</span>
                </div>
              ` : v`<span></span>`}
          ${this.isChatRoom() ? v`<wy-button kind="icon" @click=${() => this.showDetails = !0} title="${P("Details")}">
                <wy-icon name="information"></wy-icon>
              </wy-button>` : Q}
        </nav>
      </header>

      <!-- details modal -->
      ${this.weavy ? v`
            <wy-overlay
              .show=${this.showDetails}
              @close=${() => {
      this.showDetails = !1;
    }}
              @release-focus=${() => this.dispatchEvent(this.releaseFocusEvent())}
            >
              <header class="wy-appbars">
                <nav class="wy-appbar">
                  <wy-button
                    kind="icon"
                    @click=${() => {
      this.showDetails = !1;
    }}
                  >
                    <wy-icon name="close"></wy-icon>
                  </wy-button>
                  <div class="wy-appbar-text">${this.conversationTitle}</div>
                </nav>
              </header>
              <div class="wy-scroll-y">
                ${this.showDetails && this.conversation && this.user ? v`
                      <wy-avatar-header>
                        ${this.isChatRoom() ? v`
                              <wy-blob-upload
                                @blob-uploaded=${(s) => this.handleAvatarUploaded(s.detail.blob)}
                                .accept=${"image/*"}
                                .label=${P("Select picture")}
                              >
                                <div slot="placeholder">
                                  ${this.conversation.avatar_url ? v`<wy-avatar .size=${96} src=${this.conversation.avatar_url}></wy-avatar>` : v`<wy-avatar-group
                                        .members=${t?.data}
                                        title=${this.conversation.name}
                                        .size=${96}
                                      ></wy-avatar-group>`}
                                </div>
                                ${this.conversation.avatar_url ? v`<div slot="label"
                                      ><wy-button @click=${() => this.clearAvatar()}
                                        >${P("Remove picture")}</wy-button
                                      ></div
                                    >` : Q}
                              </wy-blob-upload>
                            ` : v`
                              <wy-avatar
                                src=${Ct(i?.avatar_url)}
                                name=${Ct(i?.name)}
                                presence=${i?.presence || "away"}
                                ?isAgent=${i?.is_agent}
                                id=${Ct(i?.id)}
                                size=${96}
                              ></wy-avatar>
                            `}
                      </wy-avatar-header>
                      ${this.isChatRoom() ? v`
                            <div class="wy-pane-group">
                              <label class="wy-label" for="roomName">${P("Room name")}</label>

                              <input
                                id="roomName"
                                class="wy-input"
                                .value=${this.conversationTitleInput}
                                @input=${(s) => {
      this.conversationTitleInput = s.target.value;
    }}
                                @keyup=${Fz}
                                @blur=${() => this.handleSaveConversationName()}
                              />

                              <div class="wy-description">
                                ${P("Changing the name of a group chat changes it for everyone.")}
                              </div>
                              <br />
                              <label class="wy-label">${P("Members")}</label>
                              ${t ? v`
                                    <div class="wy-list">
                                      ${t.data?.map(
      (s) => v`
                                          <div class="wy-item wy-list-item">
                                            <wy-avatar
                                              .src=${s.avatar_url}
                                              .name=${s.name}
                                              .description=${s.comment}
                                              .isAgent=${s.is_agent}
                                              size=${32}
                                            ></wy-avatar>
                                            <div class="wy-item-body">
                                              ${s.name}
                                              ${s.access === mr.Admin ? v` <wy-icon
                                                    size="20"
                                                    inline
                                                    name="shield-star"
                                                    title=${P("Admin")}
                                                  ></wy-icon>` : Q}
                                            </div>
                                            ${this.user && this.user.id === s.id && !sy(Uo.Admin, this.conversation?.permissions) ? v` <wy-button
                                                  @click=${() => this.leaveConversation(s.id)}
                                                  title=${P("Leave conversation")}
                                                  kind="icon"
                                                >
                                                  <wy-icon name="close"></wy-icon>
                                                </wy-button>` : sy(Uo.Admin, this.conversation?.permissions) ? v`<wy-dropdown>
                                                  <wy-dropdown-item @click=${() => this.leaveConversation(s.id)}>
                                                    <wy-icon name="account-minus"></wy-icon>
                                                    ${this.user && this.user.id === s.id ? P("Leave conversation") : P("Remove member")}
                                                  </wy-dropdown-item>
                                                  ${e > 1 && s.access === mr.Admin ? v`<wy-dropdown-item
                                                        @click=${() => this.updateMember(s.id, mr.Write)}
                                                      >
                                                        <wy-icon name="shield-star-outline"></wy-icon>
                                                        ${P("Remove as admin")}
                                                      </wy-dropdown-item>` : s.access !== mr.Admin ? v`<wy-dropdown-item
                                                        @click=${() => this.updateMember(s.id, mr.Admin)}
                                                      >
                                                        <wy-icon name="shield-star"></wy-icon>
                                                        ${P("Make admin")}
                                                      </wy-dropdown-item>` : Q}
                                                </wy-dropdown>` : Q}
                                          </div>
                                        `
    ) ?? Q}
                                    </div>
                                  ` : Q}
                              <wy-button
                                kind="filled"
                                color="primary"
                                @click=${() => {
      this.showDetails = !1, this.showAddMembers = !0;
    }}
                                title=${P("Add members")}
                              >
                                ${P("Add members")}
                              </wy-button>
                            </div>
                          ` : Q}
                    ` : Q}
              </div>
            </wy-overlay>
          ` : Q}

      <!-- add members modal -->
      ${this.weavy ? v`
            <wy-overlay
              .show=${this.showAddMembers}
              @close=${() => {
      this.showAddMembers = !1;
    }}
              @release-focus=${() => this.dispatchEvent(this.releaseFocusEvent())}
            >
              <header class="wy-appbars">
                <nav class="wy-appbar">
                  <wy-button
                    kind="icon"
                    @click=${() => {
      this.showAddMembers = !1;
    }}
                  >
                    <wy-icon name="close"></wy-icon>
                  </wy-button>
                  <div class="wy-appbar-text">${P("Add members")}</div>
                </nav>
              </header>
              ${this.showAddMembers ? v`
                    <wy-users-search
                      .buttonTitle=${P("Add members")}
                      .appId=${this.conversationId}
                      @submit=${(s) => this.addMembers(s.detail.members)}
                    ></wy-users-search>
                  ` : Q}
            </wy-overlay>
          ` : Q}
    ` : Q;
  }
  disconnectedCallback() {
    var t;
    (t = G3(this, Sc)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(xf, "fo"), xf), d(J2, "WyConversationAppbar"), J2);
Sc = /* @__PURE__ */ new WeakMap();
ls.styles = [
  ft,
  Tt
];
wl([
  O({ attribute: !1 })
], ls.prototype, "conversationId", 2);
wl([
  O({ attribute: !1 })
], ls.prototype, "conversation", 2);
wl([
  O({ type: Boolean })
], ls.prototype, "showDetails", 2);
wl([
  O({ type: Boolean })
], ls.prototype, "showAddMembers", 2);
wl([
  O({ type: String })
], ls.prototype, "conversationTitle", 2);
wl([
  F()
], ls.prototype, "conversationTitleInput", 2);
ls = wl([
  X("wy-conversation-appbar"),
  bt()
], ls);
var $Y = Object.defineProperty, xY = Object.getOwnPropertyDescriptor, UI = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$5"), Og = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? xY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && $Y(t, e, s), s;
}, "__decorateClass$h"), BI = /* @__PURE__ */ d((n, t, e) => t.has(n) || UI("Cannot " + e), "__accessCheck$5"), J3 = /* @__PURE__ */ d((n, t, e) => (BI(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$5"), kY = /* @__PURE__ */ d((n, t, e) => t.has(n) ? UI("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$5"), t9 = /* @__PURE__ */ d((n, t, e, i) => (BI(n, t, "write to private field"), t.set(n, e), e), "__privateSet$5"), Pc, t$, kf;
let ha = (t$ = (kf = class extends pt {
  constructor() {
    super(...arguments), this.private = !0, this.rooms = !0, this.badgeQuery = new ns(this), this.handleBadgeRefresh = async () => {
      this.badgeQuery.result.isRefetching || await this.badgeQuery.result.refetch();
    }, this.handleRealtimeMessage = (t) => {
      this.handleBadgeRefresh();
    }, this.handleRealtimeSeenBy = (t) => {
      this.handleBadgeRefresh();
    }, kY(this, Pc);
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), t.has("weavy") && this.weavy) {
      const i = [];
      this.rooms && i.push(Pt.ChatRoom), this.private && i.push(Pt.PrivateChat), this.agent && i.push(Pt.AgentChat), await this.badgeQuery.trackQuery(xE(this.weavy, i, this.agent), !0), (e = J3(this, Pc)) == null || e.call(this), this.weavy.subscribe(null, "message_created", this.handleRealtimeMessage), this.weavy.subscribe(null, "app_marked", this.handleBadgeRefresh), t9(this, Pc, () => {
        this.weavy?.unsubscribe(null, "message_created", this.handleRealtimeMessage), this.weavy?.unsubscribe(null, "app_marked", this.handleBadgeRefresh), t9(this, Pc, void 0);
      });
    }
  }
  render() {
    const { data: t, isPending: e } = this.badgeQuery.result ?? {}, i = t ? t.count : 0;
    return v`
      ${!e && i > 0 ? v` <span class="wy-badge wy-badge-danger wy-badge-reveal">${i}</span> ` : Q}
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.weavy && this.requestUpdate("weavy");
  }
  disconnectedCallback() {
    var t;
    (t = J3(this, Pc)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(kf, "mo"), kf), d(t$, "WyMessengerBadge"), t$);
Pc = /* @__PURE__ */ new WeakMap();
ha.styles = ft;
Og([
  xe({ context: Le, subscribe: !0 }),
  F()
], ha.prototype, "weavy", 2);
Og([
  O({ attribute: !1, type: Boolean })
], ha.prototype, "private", 2);
Og([
  O({ attribute: !1, type: Boolean })
], ha.prototype, "rooms", 2);
Og([
  O()
], ha.prototype, "agent", 2);
ha = Og([
  X("wy-messenger-badge")
], ha);
var SY = Object.defineProperty, PY = Object.getOwnPropertyDescriptor, $g = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? PY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && SY(t, e, s), s;
}, "__decorateClass$g");
const _K = new Map(
  Object.entries({
    [gn.ChatRoom]: Pt.ChatRoom,
    [gn.PrivateChat]: Pt.PrivateChat,
    [Pt.ChatRoom]: gn.ChatRoom,
    [Pt.PrivateChat]: gn.PrivateChat
  })
);
new Map(
  Object.entries({
    [gn.AgentChat]: Pt.AgentChat,
    [Pt.AgentChat]: gn.AgentChat
  })
);
const XI = "wy-messenger", e9 = {
  // All available features as enabled/disabled by default
  [z.Attachments]: !0,
  [z.CloudFiles]: !0,
  [z.ContextData]: !0,
  [z.Embeds]: !0,
  [z.GoogleMeet]: !0,
  [z.Meetings]: !0,
  [z.Mentions]: !0,
  [z.MicrosoftTeams]: !0,
  [z.Polls]: !0,
  [z.Previews]: !0,
  [z.Reactions]: !0,
  [z.Receipts]: !0,
  [z.Typing]: !0,
  [z.ZoomMeetings]: !0
}, CY = {
  // All available features as enabled/disabled by default
  [z.Attachments]: !0,
  [z.ContextData]: !0,
  [z.Embeds]: !0,
  [z.Previews]: !0,
  [z.Reactions]: !1,
  [z.Receipts]: !0,
  [z.Typing]: !0
};
var e$, Sf;
let Us = (e$ = (Sf = class extends It {
  constructor() {
    super(...arguments), this.componentFeatures = new On(e9), this.theme = new Gs(this, Us.styles), this.appTypes = [Pt.ChatRoom, Pt.PrivateChat], this.conversationId = null, this.conversationQuery = new ns(this), this.persistState = new hC(this), this.conversationNewRef = mt(), this.conversationListRef = mt(), this.releaseFocusEvent = () => new CustomEvent("release-focus", { bubbles: !0, composed: !0 });
  }
  get agent() {
    return super.agent;
  }
  set agent(t) {
    super.agent = t, this._agentUid ? (this.appTypes = [Pt.AgentChat], this.componentFeatures = new On(
      CY,
      this.componentFeatures.allowedFeatures()
    )) : (this.appTypes = [Pt.ChatRoom, Pt.PrivateChat], this.componentFeatures = new On(
      e9,
      this.componentFeatures.allowedFeatures()
    )), this.conversationId = null;
  }
  /**
   * Checks if a conversation belongs to Messenger.
   *
   * @deprecated
   * @param conversation {AppRef | AppType | number} - The conversation or id to check if it belongs to Messenger.
   * @returns Promise<Boolean>
   */
  async conversationBelongsToMessenger(t) {
    return console.warn("conversationBelongsToMessenger() is deprecated. Compare app to to .appTypes instead."), this.weavy ? !!await Cz(this.weavy, t, this.appTypes, this.agent) : !1;
  }
  /**
   * Creates a new conversation.
   *
   * - When no members are specified, the user selector is shown.
   * - When in agent mode, a conversation is created instantly.
   *
   * @param members {(number|string)[] | undefined} - Optional array of member id or member uid to bypass user selection dialog.
   */
  async createConversation(t) {
    await this.conversationNewRef.value?.create(t);
  }
  /**
   * Set the active conversation.
   *
   * @deprecated
   * @param id {number} - The id of the conversation to select.
   */
  selectConversation(t) {
    return console.warn("selectConversation() is deprecated. Set .conversationId instead."), this.conversationId = t, !0;
  }
  /**
   * Deselects any active conversation.
   * @deprecated
   */
  clearConversation() {
    console.warn("clearConversation() is deprecated. Set .conversationId to null instead."), this.conversationId = null;
  }
  async willUpdate(t) {
    await super.willUpdate(t), (t.has("weavy") || t.has("agent") || t.has("user")) && this.weavy && this.user && this.persistState.observe(
      [{ name: "conversationId", override: !1 }],
      this.agent || "messenger",
      `u${this.user?.id}`
    ), t.has("link") && this.link?.app && (this.conversationId = this.link.app.id), (t.has("conversationId") || t.has("weavy")) && this.weavy && (this.conversationId ? this.conversationQuery.trackQuery(Pz(this.weavy, this.conversationId, this.appTypes)) : this.conversationQuery.untrackQuery());
  }
  render() {
    const { isPending: t } = this.weavy?.network ?? { isPending: !0 }, { data: e } = this.conversationQuery.result ?? {}, i = this.conversationListRef.value?.conversationsQuery.result.data?.pages[0].count || 0;
    return v`
      <div class="wy-messenger-layout">
        <wy-conversation-list
          ${rt(this.conversationListRef)}
          .conversationTypes=${this.appTypes}
          .agent=${this.agent}
          conversationId=${Ct(this.conversationId !== null ? this.conversationId : void 0)}
          @selected=${(s) => this.conversationId = s.detail.id}
        >
          <wy-conversation-new
            slot="actions"
            .agent=${this.agent}
            @selected=${(s) => this.conversationId = s.detail.id}
            ${rt(this.conversationNewRef)}
          >
            <slot name="conversation-new"></slot>
          </wy-conversation-new>
          <slot name="actions" slot="actions"></slot>
        </wy-conversation-list>

        <div
          class="wy-messenger-conversation wy-scroll-y"
          data-conversation-id=${this.conversationId !== null ? this.conversationId : ""}
        >
          <wy-conversation-appbar
            .conversationId=${this.conversationId || void 0}
            .conversation=${e}
            @release-focus=${() => this.dispatchEvent(this.releaseFocusEvent())}
            @selected=${(s) => this.conversationId = s.detail.id}
            ?hidden=${!this.conversationId}
          >
            <span slot="action" class="wy-close-conversation">
              <wy-button kind="icon" @click=${() => this.conversationId = null}>
                <wy-icon name="back"></wy-icon>
              </wy-button>
              <wy-messenger-badge slot="badge" .agent=${this.agent}></wy-messenger-badge>
            </span>
          </wy-conversation-appbar>

          ${this.conversationId ? v`<wy-conversation
                .conversationId=${this.conversationId}
                .conversation=${e}
                .placeholder=${this.placeholder ?? (this.agent ? P("Ask anything...") : void 0)}
                .header=${!this.agent}
              ></wy-conversation>` : i ? v`<wy-empty noNetwork>${P("Select a conversation")}</wy-empty>` : Q}
        </div>

        <wy-context-data-progress></wy-context-data-progress>
      </div>
    `;
  }
}, c(Sf, "vo"), Sf), d(e$, "WyMessenger"), e$);
Us.styles = [Bi, ft, dY, fa, Ks];
$g([
  F()
], Us.prototype, "appTypes", 2);
$g([
  O({ type: String })
], Us.prototype, "agent", 1);
$g([
  O()
], Us.prototype, "placeholder", 2);
$g([
  O({ type: Number })
], Us.prototype, "conversationId", 2);
Us = $g([
  X(XI),
  bt()
], Us);
const QY = Qt`.wy-meta{color:var(--wy-outline, var(--wy-neutral-variant-50, #72777e));font-size:var(--wy-font-size-sm, calc(.875 * var(--wy-font-size, 1em)))}.wy-meta-sm{font-size:var(--wy-font-size-xs, calc(.75 * var(--wy-font-size, 1em)))}`, MY = Qt`.wy-notification.wy-read{opacity:var(--wy-opacity-muted, 60%);--wy-component-color: var(--wy-outline, var(--wy-neutral-variant-50, #72777e))}`;
var TY = Object.defineProperty, AY = Object.getOwnPropertyDescriptor, xg = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? AY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && TY(t, e, s), s;
}, "__decorateClass$f"), i$, Pf;
let da = (i$ = (Pf = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.selected = !1, this.standalone = !1;
  }
  dispatchSelect(t) {
    const e = new CustomEvent("select", {
      detail: { notificationId: this.notificationId }
    });
    return this.dispatchEvent(e);
  }
  dispatchMark(t, e) {
    if (t.stopPropagation(), e === !!this.notification.is_unread) {
      const i = new CustomEvent("mark", {
        detail: { notificationId: this.notificationId, markAsRead: e }
      });
      return this.dispatchEvent(i);
    }
    return !0;
  }
  dispatchHide() {
    if (this.standalone) {
      const t = new CustomEvent("hide", {
        bubbles: !0
      });
      return this.dispatchEvent(t);
    }
    return !0;
  }
  dispatchClose() {
    if (this.standalone) {
      const t = new CustomEvent("close", {
        bubbles: !0
      });
      return this.dispatchEvent(t);
    }
    return !0;
  }
  async handleClick(t) {
    this.dispatchSelect(t), this.dispatchMark(t, !0), this.dispatchHide(), await UP(this, this.weavy, this.notification), this.dispatchClose();
  }
  render() {
    const t = this.notification.created_at ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.notification.created_at)
    ) : "", e = this.notification.created_at ? zy(this.weavy?.locale, new Date(this.notification.created_at)) : "", i = this.notification.actor, { title: s, titleHtml: r, detail: a } = XP(this.notification), o = this.standalone ? Q : v`
          <div class="wy-item-actions wy-item-right">
            <wy-button
              kind="icon-inline"
              @click=${(h) => this.dispatchMark(h, !!this.notification.is_unread) && this.dispatchClose()}
              title=${this.notification.is_unread ? P("Mark as read") : P("Mark as unread")}
            >
              <wy-icon
                name=${this.notification.is_unread ? "read" : "unread"}
                color=${this.notification.is_unread ? "" : "secondary"}
              ></wy-icon>
            </wy-button>
          </div>
        `, l = this.standalone ? Q : v`
          <time class="wy-meta" datetime=${this.notification.created_at.toString()} title=${t}>
            ${e}
          </time>
        `;
    return v`
      <div
        class=${Xt({
      "wy-item wy-list-item-lg wy-item-hover wy-notification": !0,
      "wy-unread": !this.standalone && !!this.notification.is_unread,
      "wy-read": !this.standalone && !this.notification.is_unread,
      "wy-active": !this.standalone && this.selected
    })}
        tabindex="0"
        @click=${(h) => this.handleClick(h)}
        @keydown=${Fe}
        @keyup=${vi}
      >
        <div class="wy-item-inner">
          <wy-avatar
            class="wy-item-top"
            src=${Ct(i?.avatar_url)}
            name=${Ct(i?.name)}
            description=${Ct(i?.comment)}
            presence=${i?.presence || "away"}
            ?isAgent=${i?.is_agent}
            id=${Ct(i?.id)}
            size=${48}
          ></wy-avatar>

          <div class="wy-item-rows wy-item-rows-compact">
            <div class="wy-item-row">
              <div class="wy-item-title-lg" title=${s + (a ? `: "${a}"` : "")}>
                ${r}${a ? v`: <q class="wy-item-quote">${a}</q> ` : Q}
              </div>
            </div>
            <div class="wy-item-row"> ${l} ${o} </div>
          </div>

          ${this.standalone ? v`
                <wy-button
                  kind="icon"
                  @click=${(h) => this.dispatchMark(h, !!this.notification.is_unread) && this.dispatchClose()}
                >
                  <wy-icon name="close"></wy-icon>
                </wy-button>
              ` : Q}
        </div>
      </div>
    `;
  }
}, c(Pf, "go"), Pf), d(i$, "WyNotificationListItem"), i$);
da.styles = [Ie, SL, QY, MY];
xg([
  O({ type: Number })
], da.prototype, "notificationId", 2);
xg([
  O({ type: Boolean, reflect: !0 })
], da.prototype, "selected", 2);
xg([
  O({ type: Boolean })
], da.prototype, "standalone", 2);
xg([
  O({ attribute: !1 })
], da.prototype, "notification", 2);
da = xg([
  X("wy-notification-list-item"),
  bt()
], da);
var RY = Object.defineProperty, EY = Object.getOwnPropertyDescriptor, NI = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$4"), vC = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? EY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && RY(t, e, s), s;
}, "__decorateClass$e"), HI = /* @__PURE__ */ d((n, t, e) => t.has(n) || NI("Cannot " + e), "__accessCheck$4"), i9 = /* @__PURE__ */ d((n, t, e) => (HI(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$4"), _Y = /* @__PURE__ */ d((n, t, e) => t.has(n) ? NI("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$4"), n9 = /* @__PURE__ */ d((n, t, e, i) => (HI(n, t, "write to private field"), t.set(n, e), e), "__privateSet$4"), Cc, n$, Cf;
let vy = (n$ = (Cf = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.typeFilter = Ge.All, this.notificationsQuery = new dl(this), this.infiniteScroll = new ul(this), this.pagerRef = mt(), this.handleRefresh = (t) => {
      this.notificationsQuery.result.refetch();
    }, this.handlePresenceChange = (t) => {
      this.weavy && (Array.isArray(t) || (t = [parseInt(t)]), Oe(this.weavy.queryClient, ["notifications", "list"], void 0, (e) => {
        const i = e.actor;
        i.presence = t.indexOf(i.id) != -1 ? "active" : "away", e.actor = i;
      }));
    }, _Y(this, Cc);
  }
  async markAllAsRead() {
    const t = await this.whenWeavy(), e = oI(t, Ge.All, this.app?.id)?.id;
    await this.markNotificationsMutation?.mutate({ notificationId: e });
  }
  async handleMark(t, e) {
    await this.markNotificationMutation?.mutate({ markAsRead: t, notificationId: e });
  }
  handleSelect(t) {
    this.notificationId = t.id;
  }
  async willUpdate(t) {
    var e;
    super.willUpdate(t), (t.has("weavy") || t.has("typeFilter") || t.has("app")) && this.weavy && await this.notificationsQuery.trackInfiniteQuery(aI(this.weavy, this.typeFilter, this.app?.id)), (t.has("weavy") || t.has("app")) && this.weavy && (this.markNotificationsMutation = cI(this.weavy, this.app?.id)), t.has("weavy") && this.weavy && (this.markNotificationMutation = yC(this.weavy), (e = i9(this, Cc)) == null || e.call(this), this.weavy.subscribe(null, "online", this.handlePresenceChange), this.weavy.subscribe(null, "notification_created", this.handleRefresh), this.weavy.subscribe(null, "notification_updated", this.handleRefresh), this.weavy.subscribe(null, "notifications_marked", this.handleRefresh), n9(this, Cc, () => {
      this.weavy?.unsubscribe(null, "online", this.handlePresenceChange), this.weavy?.unsubscribe(null, "notification_created", this.handleRefresh), this.weavy?.unsubscribe(null, "notification_updated", this.handleRefresh), this.weavy?.unsubscribe(null, "notifications_marked", this.handleRefresh), n9(this, Cc, void 0);
    }));
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.notificationsQuery.result, this.pagerRef.value);
  }
  renderNotifications(t, e) {
    if (e) {
      const i = hs(e);
      return Mi(
        i,
        (s) => s?.id,
        (s) => [
          v`<wy-notification-list-item
              notificationId=${s.id}
              .notification=${s}
              .selected=${this.notificationId == s.id}
              @select=${(r) => this.handleSelect(s)}
              @mark=${(r) => this.handleMark(r.detail.markAsRead, r.detail.notificationId)}
            ></wy-notification-list-item>`
        ]
      );
    }
    return Q;
  }
  render() {
    const { data: t, hasNextPage: e, isPending: i } = this.notificationsQuery.result ?? {};
    return v`
      ${this.user ? v`
            <div class="wy-pane-toolbar">
              <wy-buttons tabs>
                <wy-button
                  ?active=${this.typeFilter === Ge.All}
                  @click=${() => this.typeFilter = Ge.All}
                  kind="tab"
                  small
                >
                  ${P("All")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === Ge.Activity}
                  @click=${() => this.typeFilter = Ge.Activity}
                  kind="tab"
                  small
                >
                  ${P("Activities")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === Ge.Mention}
                  @click=${() => this.typeFilter = Ge.Mention}
                  kind="tab"
                  small
                >
                  ${P("Mentions")}
                </wy-button>
                <wy-button
                  ?active=${this.typeFilter === Ge.Reaction}
                  @click=${() => this.typeFilter = Ge.Reaction}
                  kind="tab"
                  small
                >
                  ${P("Reactions")}
                </wy-button>
              </wy-buttons>
              <wy-button
                slot="buttons"
                kind="icon"
                @click=${() => this.markAllAsRead()}
                title=${P("Mark all as read")}
              >
                <wy-icon name="check-all"></wy-icon>
              </wy-button>
              <slot name="buttons"></slot>
            </div>

            <div class="wy-notifications">
              ${!i && this.user && t ? t.pages[0]?.count ? this.renderNotifications(this.user, t) : v`
                      <div class="wy-pane-body">
                        <div class="wy-pane-group">
                          <slot name="empty">
                            <wy-empty>${P("No updates yet.")}</wy-empty>
                          </slot>
                        </div>
                      </div>
                    ` : v`<wy-empty><wy-spinner padded></wy-spinner></wy-empty>`}
              ${e ? v`<div ${rt(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : Q}
            </div>
          ` : v`<wy-empty class="wy-pane"><wy-spinner overlay></wy-spinner></wy-empty>`}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = i9(this, Cc)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Cf, "bo"), Cf), d(n$, "WyNotificationList"), n$);
Cc = /* @__PURE__ */ new WeakMap();
vy.styles = [
  ft,
  ma,
  Qt`
      :host {
        position: relative;
      }
    `
];
vC([
  O({ type: Number })
], vy.prototype, "notificationId", 2);
vC([
  O()
], vy.prototype, "typeFilter", 2);
vy = vC([
  X("wy-notification-list"),
  bt()
], vy);
var zY = Object.getOwnPropertyDescriptor, LY = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? zY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = a(s) || s);
  return s;
}, "__decorateClass$d");
const YI = "wy-notifications";
var s$, Qf;
let Hw = (s$ = (Qf = class extends It {
  constructor() {
    super(...arguments), this.componentType = tn.Unknown, this.theme = new Gs(this, Hw.styles), this.notificationsRef = mt();
  }
  /**
   * Mark all events as read.
   */
  async markAllAsRead() {
    await this.notificationsRef.value?.markAllAsRead();
  }
  render() {
    return v`
      ${this.user ? v` <wy-notification-list ${rt(this.notificationsRef)}></wy-notification-list> ` : v`
            <wy-empty>
              <wy-spinner padded reveal></wy-spinner>
            </wy-empty>
          `}
    `;
  }
}, c(Qf, "xo"), Qf), d(s$, "WyNotifications"), s$);
Hw.styles = [Bi, ft, fa, hl, Ks];
Hw = LY([
  X(YI),
  bt()
], Hw);
var IY = Object.defineProperty, ZY = Object.getOwnPropertyDescriptor, kg = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? ZY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && IY(t, e, s), s;
}, "__decorateClass$c"), r$, Mf;
let Yw = (r$ = (Mf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.show = !1, this.viewportRef = mt();
  }
  close() {
    this.show = !1;
    try {
      this.viewportRef.value?.hidePopover();
    } catch {
    }
  }
  handleClose(t) {
    (t.type === "toggle" && t.newState === "closed" || t.type === "click") && (this.show = !1, this.dispatchEvent(new CustomEvent("hide")), this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 })));
  }
  render() {
    return v`
      <div class="wy-toasts" tabindex="0" ${rt(this.viewportRef)} ?hidden=${!this.show} popover="auto">
        <slot></slot>
      </div>
    `;
  }
  willUpdate(t) {
    if (super.willUpdate(t), t.has("show"))
      try {
        this.show ? this.viewportRef.value?.showPopover() : this.viewportRef.value?.hidePopover();
      } catch {
      }
    t.has("show") && this.show && this.viewportRef.value?.focus();
  }
  firstUpdated(t) {
    this.viewportRef.value?.addEventListener(this.viewportRef.value.popover ? "toggle" : "click", (e) => {
      this.handleClose(e);
    }), this.show && this.viewportRef.value?.showPopover();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
  }
}, c(Mf, "$o"), Mf), d(r$, "WyToasts"), r$);
Yw.styles = [
  ft,
  Tt
];
kg([
  O({ type: Boolean })
], Yw.prototype, "show", 2);
Yw = kg([
  X("wy-toasts")
], Yw);
var a$, Tf;
let Bs = (a$ = (Tf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.toastRef = mt(), this.show = !1, this.duration = Bs.defaultDuration;
  }
  hide() {
    this.show = !1;
  }
  async close(t = !1) {
    this.show = !1, await new Promise((e) => requestAnimationFrame(e)), this.toastRef.value && await X1(this.toastRef.value, !1), this.dispatchEvent(new CustomEvent("closed", { detail: { silent: t } })), this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }));
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("show") && (this.timeout && (window.clearTimeout(this.timeout), this.timeout = void 0), this.show && this.duration > 0 && this.duration < 1 / 0 && (this.timeout = window.setTimeout(() => this.close(!0), this.duration)));
  }
  render() {
    return v`
      <div
        ${rt(this.toastRef)}
        class="wy-toast wy-fade ${this.show ? "wy-show" : ""}"
        @hide=${(t) => {
      t.stopPropagation(), this.hide();
    }}
        @close=${() => this.close()}
        @keyup=${Jb}
      >
        <slot></slot>
      </div>
    `;
  }
  firstUpdated() {
    requestAnimationFrame(() => {
      this.show = !0;
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.timeout && (window.clearTimeout(this.timeout), this.timeout = void 0);
  }
}, c(Tf, "Co"), Tf), d(a$, "WyToast"), a$);
Bs.styles = [
  ft,
  Tt
];
Bs.defaultDuration = 5e4;
kg([
  F()
], Bs.prototype, "show", 2);
kg([
  O({ type: Number })
], Bs.prototype, "duration", 2);
Bs = kg([
  X("wy-toast")
], Bs);
var VY = Object.defineProperty, DY = Object.getOwnPropertyDescriptor, GI = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$3"), Iy = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? DY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && VY(t, e, s), s;
}, "__decorateClass$b"), KI = /* @__PURE__ */ d((n, t, e) => t.has(n) || GI("Cannot " + e), "__accessCheck$3"), s9 = /* @__PURE__ */ d((n, t, e) => (KI(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$3"), WY = /* @__PURE__ */ d((n, t, e) => t.has(n) ? GI("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$3"), r9 = /* @__PURE__ */ d((n, t, e, i) => (KI(n, t, "write to private field"), t.set(n, e), e), "__privateSet$3"), Qc;
const JI = "wy-notification-toasts";
var o$, Af;
let cs = (o$ = (Af = class extends It {
  constructor() {
    super(...arguments), this.componentType = tn.Unknown, this.theme = new Gs(this, cs.styles), this.typeFilter = Ge.All, this.appearance = "internal", this.requestUserPermission = !1, this.duration = Bs.defaultDuration, this._notifications = [], this._nativeNotifications = [], this.handleEvent = async (t) => {
      if (this.typeFilter === Ge.All || this.typeFilter === t.notification.type)
        if (t.action === "notification_deleted")
          this.removeNotification(t.notification.id), this.closeNativeNotification(t.notification.id);
        else {
          const { title: e, detail: i } = XP(t.notification), s = {
            ...t.notification,
            title: e,
            detail: i,
            lang: this.weavy?.locale
          };
          s.link.agent = BP(s);
          const r = new CustomEvent("wy-notification", {
            bubbles: !0,
            composed: !0,
            cancelable: !0,
            detail: s
          });
          (!this.requestUserPermission && this.appearance !== "native" || await this.hasUserPermission()) && this.dispatchEvent(r) && (t.action === "notification_created" && t.notification.is_unread ? await this.addOrUpdateNotification(t.notification) : await this.updateNotification(t.notification), await this.addOrUpdateNativeNotification(s));
        }
    }, WY(this, Qc);
  }
  async addOrUpdateNotification(t) {
    if (!this.requestUserPermission || await this.hasUserPermission()) {
      const e = [...this._notifications], i = e.findIndex((s) => s.id === t.id);
      i !== -1 ? (e.splice(i, 1, t), this._notifications = e) : (e.push(t), this._notifications = e);
    }
  }
  async updateNotification(t) {
    if (!this.requestUserPermission || await this.hasUserPermission()) {
      const e = [...this._notifications], i = e.findIndex((s) => s.id === t.id);
      i !== -1 && (e.splice(i, 1, t), this._notifications = e);
    }
  }
  removeNotification(t) {
    const e = [...this._notifications], i = e.findIndex((s) => s.id === t);
    i !== -1 && (e.splice(i, 1), this._notifications = e);
  }
  async addOrUpdateNativeNotification(t) {
    if (this.appearance === "native" && await this.hasUserPermission()) {
      const e = this.removeNativeNotification(t.id), i = t.actor, s = new Notification(t.title, {
        tag: `wy-${t.id}`,
        lang: t.lang,
        body: t.detail,
        icon: i.avatar_url,
        // @ts-expect-error Property `renotify` not available in ts types yet
        renotify: e && t.is_unread
      });
      s.onclick = async () => {
        await this.handleMark(!0, t.id), await UP(this, this.weavy, t);
      }, s.onclose = () => {
        this.removeNativeNotification(t.id);
      }, this._nativeNotifications = [...this._nativeNotifications, s];
    }
  }
  removeNativeNotification(t) {
    const e = [...this._nativeNotifications], i = e.findIndex(
      (s) => s.tag === `wy-${t}`
    );
    return i ? (e.splice(i, 1), this._nativeNotifications = e, !0) : !1;
  }
  closeNativeNotification(t) {
    const e = this._nativeNotifications.findIndex(
      (i) => i.tag === `wy-${t}`
    );
    return e ? (this._nativeNotifications[e].close(), !0) : !1;
  }
  async hasUserPermission() {
    if (!("Notification" in window))
      console.error("This browser does not support desktop notifications");
    else if (!window.isSecureContext)
      console.error(
        `Desktop notifications can only be used in secure contexts. 
        See https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts`
      );
    else {
      if (Notification.permission === "granted")
        return !0;
      if (Notification.permission !== "denied")
        return await Notification.requestPermission() === "granted";
    }
    return !1;
  }
  clearNotifications() {
    this._notifications = [];
  }
  async handleMark(t, e) {
    await this.markNotificationMutation?.mutate({ markAsRead: t, notificationId: e });
  }
  async willUpdate(t) {
    var e;
    await super.willUpdate(t), t.has("weavy") && this.weavy && (this.markNotificationMutation = yC(this.weavy), (e = s9(this, Qc)) == null || e.call(this), this.weavy.subscribe(null, "notification_created", this.handleEvent), this.weavy.subscribe(null, "notification_updated", this.handleEvent), r9(this, Qc, () => {
      this.weavy?.unsubscribe(null, "notification_created", this.handleEvent), this.weavy?.unsubscribe(null, "notification_updated", this.handleEvent), r9(this, Qc, void 0);
    })), (t.has("requestUserPermission") && this.requestUserPermission || t.has("appearance") && this.appearance === "native") && this.hasUserPermission();
  }
  render() {
    return v`
      ${this.user && this.appearance === "internal" ? v`
            <wy-toasts ?show=${!!this._notifications.length} @hide=${() => this.clearNotifications()}>
              ${Mi(
      this._notifications,
      (t) => t.id,
      (t) => v`
                    <wy-toast
                      duration=${this.duration}
                      @closed=${(e) => {
        e.detail.silent || this.handleMark(!0, t.id), this.removeNotification(t.id);
      }}
                    >
                      <wy-notification-list-item standalone .notification=${t}></wy-notification-list-item>
                    </wy-toast>
                  `
    )}
            </wy-toasts>
          ` : Q}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = s9(this, Qc)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Af, "ko"), Af), d(o$, "WyNotificationToasts"), o$);
Qc = /* @__PURE__ */ new WeakMap();
cs.styles = [Bi, Tt, Ks];
Iy([
  O()
], cs.prototype, "typeFilter", 2);
Iy([
  O()
], cs.prototype, "appearance", 2);
Iy([
  O({ type: Boolean })
], cs.prototype, "requestUserPermission", 2);
Iy([
  O({ type: Number })
], cs.prototype, "duration", 2);
Iy([
  F()
], cs.prototype, "_notifications", 2);
cs = Iy([
  X(JI),
  bt()
], cs);
function tZ(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["posts", t.id],
    mutationFn: /* @__PURE__ */ d(async ({ id: s }) => {
      if (!(await n.fetch("/api/posts/" + s + "/trash", { method: "POST" })).ok)
        throw new Error();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => {
      Ot(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        s.id,
        (r) => Object.assign(r, { is_trashed: !0 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((s, r) => {
      Ot(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.id,
        (a) => Object.assign(a, s)
      );
    }, "onSuccess")
  };
  return i;
}
c(tZ, "d3");
d(tZ, "getTrashPostMutationOptions");
function eZ(n, t) {
  return new jt(n.queryClient, tZ(n, t));
}
c(eZ, "h3");
d(eZ, "getTrashPostMutation");
function iZ(n, t) {
  const e = n.queryClient, i = {
    mutationKey: ["posts", t.id],
    mutationFn: /* @__PURE__ */ d(async ({ id: s }) => {
      const r = await n.fetch("/api/posts/" + s + "/restore", { method: "POST" });
      if (!r.ok) {
        const a = await r.json();
        throw new Error(a.detail || a.title, { cause: a });
      }
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => {
      Ot(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        s.id,
        (r) => Object.assign(r, { is_trashed: !1 })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((s, r) => {
      Ot(
        e,
        { queryKey: i.mutationKey, exact: !1 },
        r.id,
        (a) => Object.assign(a, { is_trashed: !1 })
      );
    }, "onSuccess")
  };
  return i;
}
c(iZ, "u3");
d(iZ, "getRestorePostMutationOptions");
function nZ(n, t) {
  return new jt(n.queryClient, iZ(n, t));
}
c(nZ, "p3");
d(nZ, "getRestorePostMutation");
function sZ(n, t) {
  const e = n.queryClient, i = ["posts", t.id];
  return {
    mutationKey: i,
    mutationFn: /* @__PURE__ */ d(async ({ id: s, subscribe: r }) => {
      const a = await n.fetch(
        `/api/posts/${s}/${r ? "subscribe" : "unsubscribe"}`,
        { method: "POST" }
      );
      if (!a.ok) {
        const o = await a.json();
        throw new Error(o.detail || o.title, { cause: o });
      }
      return await a.json();
    }, "mutationFn"),
    onMutate: /* @__PURE__ */ d((s) => {
      Ot(
        e,
        { queryKey: i, exact: !1 },
        s.id,
        (r) => Object.assign(r, { is_subscribed: s.subscribe })
      );
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((s, r) => {
      Ot(
        e,
        { queryKey: i, exact: !1 },
        r.id,
        (a) => Object.assign(a, s)
      );
    }, "onSuccess")
  };
}
c(sZ, "y3");
d(sZ, "getSubscribePostMutationOptions");
function rZ(n, t) {
  return new jt(n.queryClient, sZ(n, t));
}
c(rZ, "w3");
d(rZ, "getSubscribePostMutation");
function aZ(n, t) {
  return {
    initialPageParam: 0,
    queryKey: ["posts", t],
    queryFn: /* @__PURE__ */ d(async (e) => {
      const i = e.pageParam, s = "/api/apps/" + t + "/posts?order_by=id+desc&skip=" + i, r = await (await n.fetch(s)).json();
      return r.data = r.data || [], r;
    }, "queryFn"),
    getNextPageParam: /* @__PURE__ */ d((e) => {
      if (e.end && e.end < e.count)
        return e.end;
    }, "getNextPageParam")
  };
}
c(aZ, "f3");
d(aZ, "getPostsOptions");
function oZ(n, t) {
  return {
    mutationFn: /* @__PURE__ */ d(async (e) => await (await n.fetch("/api/posts/" + e.id, {
      method: "PATCH",
      body: JSON.stringify({
        text: e.text,
        blobs: e.blobs,
        attachments: e.attachments,
        meeting_id: e.meeting_id,
        options: e.poll_options.filter((i) => i.text.trim() !== "").map((i) => ({ id: i.id, text: i.text })),
        embed_id: e.embed_id || null
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ d((e) => {
      Oe(n.queryClient, ["posts", e.app_id], e.id, (i) => {
        i.text = e.text, i.html = e.text;
      });
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((e, i) => {
      i.id && Oe(n.queryClient, ["posts", i.app_id], i.id, (s) => {
        s.text = e.text, s.html = e.html, s.attachments = e.attachments, s.embed = e.embed, s.meeting = e.meeting, s.updated_at = e.updated_at, s.updated_by = e.updated_by, s.options = e.options;
      });
    }, "onSuccess")
  };
}
c(oZ, "m3");
d(oZ, "getUpdatePostMutationOptions");
function lZ(n, t) {
  const e = n.queryClient;
  return {
    mutationFn: /* @__PURE__ */ d(async (i) => await (await n.fetch("/api/apps/" + i.app_id + "/posts", {
      method: "POST",
      body: JSON.stringify({
        text: i.text,
        blobs: i.blobs,
        meeting_id: i.meeting_id,
        options: i.poll_options.filter((s) => s.text.trim() !== "").map((s) => ({ text: s.text })),
        embed_id: i.embed_id,
        context: i.context
      })
    })).json(), "mutationFn"),
    mutationKey: t,
    onMutate: /* @__PURE__ */ d(async (i) => {
      const s = ["posts", i.app_id];
      await e.cancelQueries({ queryKey: s });
      const r = ia(n.queryClient, s, !1);
      if (i.user) {
        const a = {
          id: r ? r.id - 1 : -1,
          app: { id: i.app_id },
          is_subscribed: !0,
          is_trashed: !1,
          text: i.text,
          html: i.text,
          plain: i.text,
          created_by: i.user,
          created_at: (/* @__PURE__ */ new Date()).toUTCString(),
          attachments: { count: 0 },
          reactions: { count: 0 },
          is_starred: !1,
          comments: { count: 0 }
        };
        ea(e, ["posts", i.app_id], a, { descending: !0 });
      }
    }, "onMutate"),
    onSuccess: /* @__PURE__ */ d((i) => {
      const s = ["posts", i.app.id];
      if (!cg(n.queryClient, s, i.id)) {
        const r = ia(n.queryClient, s, !0);
        r ? Oe(n.queryClient, s, r.id, (a) => {
          a.id = i.id, a.app = i.app, a.text = i.text, a.html = i.html, a.embed = i.embed, a.meeting = i.meeting, a.attachments = i.attachments, a.options = i.options, a.created_at = i.created_at, a.created_by = i.created_by, a.updated_at = i.updated_at, a.updated_by = i.updated_by;
        }) : ea(n.queryClient, s, i);
      }
    }, "onSuccess")
  };
}
c(lZ, "v3");
d(lZ, "getAddPostMutationOptions");
var qY = Object.defineProperty, jY = Object.getOwnPropertyDescriptor, cZ = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? jY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && qY(t, e, s), s;
}, "__decorateClass$a"), l$, Rf;
let Gw = (l$ = (Rf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this);
  }
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: {} });
    return this.dispatchEvent(t);
  }
  render() {
    return v`
      <div class="wy-item">
        <div class="wy-item-body">${P("Post was trashed.")}</div>
        <wy-button @click=${() => this.dispatchRestore()} color="variant">${P("Undo")}</wy-button>
      </div>
    `;
  }
}, c(Rf, "_o"), Rf), d(l$, "WyPostTrashed"), l$);
Gw.styles = ft;
cZ([
  O({ type: Number })
], Gw.prototype, "postId", 2);
Gw = cZ([
  X("wy-post-trashed"),
  bt()
], Gw);
var FY = Object.defineProperty, UY = Object.getOwnPropertyDescriptor, Se = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? UY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && FY(t, e, s), s;
}, "__decorateClass$9"), c$, Ef;
let ae = (c$ = (Ef = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.html = "", this.text = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.commentCount = 0, this.seenBy = [], this.showComments = !1, this.loadComments = !1, this.highlight = !1, this.isCommentLinked = !1, this.previewAnnotationsRef = mt(), this.previewAttachmentsRef = mt(), this.highlightRef = mt();
  }
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t } });
    return this.dispatchEvent(e);
  }
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", {
      detail: { id: this.postId, subscribe: t }
    });
    return this.dispatchEvent(e);
  }
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  dispatchEdit(t) {
    const e = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(e);
  }
  handleCommentsClick(t) {
    t.preventDefault(), this.showComments = !this.showComments, this.loadComments = !0;
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("link") && (this.highlight = !!(this.link && dg(this.link, ci.Post, { id: this.postId })), this.isCommentLinked = !!(this.link && FP(this.link, ci.Post, { id: this.postId }, ci.Comment))), t.has("isCommentLinked") && this.isCommentLinked && (this.loadComments = !0, this.showComments = !0);
  }
  render() {
    const t = this.attachments?.filter((a) => a.kind === "image" && a.thumbnail_url), e = this.attachments?.filter((a) => a.kind !== "image" || !a.thumbnail_url), i = new Intl.DateTimeFormat(this.weavy?.locale, {
      dateStyle: "full",
      timeStyle: "short"
    }).format(new Date(this.createdAt)), s = zy(this.weavy?.locale, new Date(this.createdAt)), r = this.modifiedAt && this.weavy ? new Intl.DateTimeFormat(this.weavy.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.modifiedAt)
    ) : "";
    return this.postId < 0 ? v`<div class="wy-post">
          <div class="wy-item">
            <wy-avatar
              .src="${this.createdBy.avatar_url}"
              .isAgent=${this.createdBy.is_agent}
              .size=${48}
              .name=${this.createdBy.name}
            ></wy-avatar>
            <div class="wy-item-rows">
              <div class="wy-item-row">
                <div class="wy-item-title"><span class="wy-placeholder">${this.createdBy.name}</span></div>
              </div>
              <div class="wy-item-row">
                <div class="wy-item-text">
                  <time class="wy-placeholder">${s}</time>
                </div>
              </div>
            </div>
          </div>
          <div class="wy-post-body">
            <div class="wy-content"><wy-skeleton .text=${this.text}></wy-skeleton></div>
          </div>
        </div>` : v`
          <div class="wy-post" part=${Me({ "wy-highlight": this.highlight && !this.isCommentLinked })} ${rt(
      this.highlightRef
    )}>
            <div class="wy-item">
              <wy-avatar .src="${this.createdBy.avatar_url}" .isAgent=${this.createdBy.is_agent} .size=${48} .name=${this.createdBy.name}></wy-avatar>
              <div class="wy-item-rows">
                <div class="wy-item-row">
                  <div class="wy-item-title">${this.createdBy.name}</div>
                </div>
                <div class="wy-item-row">
                  <div class="wy-item-text">
                    <time datetime=${this.createdAt} title=${i}>${s}</time>
                    ${this.modifiedAt ? v`<time datetime="${this.modifiedAt}" title=${r}> · ${P("edited")}</time>` : Q}
                  </div>
                  </div>
                </div>

                <div class="wy-item-actions wy-item-top">
                  <wy-dropdown>
                    ${this.isSubscribed ? v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!1)}>
                            <wy-icon name="bell-off"></wy-icon>
                            ${P("Unsubscribe")}
                          </wy-dropdown-item>` : v`<wy-dropdown-item @click=${() => this.dispatchSubscribe(!0)}>
                            <wy-icon name="bell"></wy-icon>
                            ${P("Subscribe")}
                          </wy-dropdown-item>`}
                    ${this.user && this.user.id === this.createdBy.id ? v`<wy-dropdown-item @click=${() => this.dispatchEdit(!0)}>
                            <wy-icon name="pencil"></wy-icon>
                            ${P("Edit")}
                          </wy-dropdown-item>` : Q}
                    ${this.user && this.user.id === this.createdBy.id ? v`<wy-dropdown-item @click=${() => this.dispatchTrash()}>
                            <wy-icon name="trashcan"></wy-icon>
                            ${P("Trash")}
                          </wy-dropdown-item>` : Q}
                  </wy-dropdown>
                </div>
              </div>
              <!-- image grid -->
              ${t && t.length ? v`<wy-image-grid
                      class="wy-post-area-full-width"
                      .images=${t}
                      @file-open=${(a) => {
      this.previewAttachmentsRef.value?.open(a.detail.fileId);
    }}
                    ></wy-image-grid>` : ""}

              <!-- embeds -->
              ${this.componentFeatures?.allowsFeature(z.Embeds) && this.embed ? v` <wy-embed class="wy-embed" .embed=${this.embed}></wy-embed> ` : Q}

              <div class="wy-post-body">
                ${this.html ? v`<div class="wy-content">${Xo(this.html)}</div>` : ""}

                <!-- annotations -->
                  ${this.annotations && this.annotations.length ? v`<wy-annotations-list
                          class="wy-message-area"
                          .files=${this.annotations}
                          @file-open=${(a) => {
      this.previewAnnotationsRef.value?.open(a.detail.fileId);
    }}
                        ></wy-annotations-list>` : ""}

                <!-- poll -->
                ${this.pollOptions && this.pollOptions.length > 0 ? v`
                        <wy-poll
                          .pollOptions=${this.pollOptions}
                          @vote=${(a) => this.dispatchVote(a.detail.optionId)}
                        ></wy-poll>
                      ` : Q}

                <!-- files -->
                ${e && e.length ? v`<wy-attachments-list
                        .files=${e ?? []}
                        @file-open=${(a) => {
      this.previewAttachmentsRef.value?.open(a.detail.fileId);
    }}
                      ></wy-attachments-list>` : ""}

                <!-- meeting -->
                ${this.meeting ? v`<wy-meeting-card .meeting=${this.meeting}></wy-meeting-card>` : ""}
              </div>

              <div class="wy-post-footer">
                <div>
                  <!-- comment count -->
                  ${this.componentFeatures?.allowsFeature(z.Comments) ? v` <wy-button
                          small
                          kind="inline"
                          ?active=${this.showComments}
                          class="wy-meta"
                          color="inherit"
                          @click=${(a) => this.handleCommentsClick(a)}
                        >
                          ${this.commentCount !== 1 ? P(nt`${this.commentCount} comments`) : P("1 comment")}
                        </wy-button>` : Q}
                </div>
                ${this.componentFeatures?.allowsFeature(z.Reactions) && this.app ? v`
                        <wy-reactions
                          line
                          small
                          .reactions=${this.reactions}
                          parentId=${this.app.id}
                          parentType="apps"
                          entityId=${this.postId}
                          entityType="posts"
                        ></wy-reactions>
                      ` : Q}
              </div>

              <!-- comments -->
              ${this.loadComments ? v`
                      <div class="wy-post-comments" ?hidden=${!this.showComments}>
                        <wy-comment-list .parentId=${this.postId} .location=${"posts"}></wy-comment-list>
                      </div>
                    ` : Q}
            </div>
          
            ${this.annotations?.length ? v`<wy-preview
                    ${rt(this.previewAnnotationsRef)}
                    .files=${this.annotations}
                    .isAttachment=${!0}
                  ></wy-preview> ` : Q}
            ${this.attachments?.length ? v`<wy-preview
                    ${rt(this.previewAttachmentsRef)}
                    .files=${[...t, ...e]}
                    .isAttachment=${!0}
                  ></wy-preview> ` : Q}
           
          </div>
        `;
  }
  updated(t) {
    t.has("highlight") && this.highlight && this.highlightRef.value?.scrollIntoView({ block: "nearest" });
  }
}, c(Ef, "Mo"), Ef), d(c$, "WyPostView"), c$);
ae.styles = [ft, Tt];
Se([
  O({ type: Number })
], ae.prototype, "postId", 2);
Se([
  O({ attribute: !1 })
], ae.prototype, "createdBy", 2);
Se([
  O()
], ae.prototype, "createdAt", 2);
Se([
  O()
], ae.prototype, "modifiedAt", 2);
Se([
  O({ type: Boolean })
], ae.prototype, "isSubscribed", 2);
Se([
  O({ type: Boolean })
], ae.prototype, "isTrashed", 2);
Se([
  O()
], ae.prototype, "html", 2);
Se([
  O()
], ae.prototype, "text", 2);
Se([
  O({ type: Array })
], ae.prototype, "annotations", 2);
Se([
  O({ type: Array })
], ae.prototype, "attachments", 2);
Se([
  O({ type: Array })
], ae.prototype, "pollOptions", 2);
Se([
  O({ attribute: !1 })
], ae.prototype, "meeting", 2);
Se([
  O({ attribute: !1 })
], ae.prototype, "embed", 2);
Se([
  O({ type: Array })
], ae.prototype, "reactions", 2);
Se([
  O({ attribute: !1 })
], ae.prototype, "commentCount", 2);
Se([
  O({ type: Array })
], ae.prototype, "seenBy", 2);
Se([
  F()
], ae.prototype, "showComments", 2);
Se([
  F()
], ae.prototype, "loadComments", 2);
Se([
  O({ type: Boolean })
], ae.prototype, "highlight", 2);
Se([
  F()
], ae.prototype, "isCommentLinked", 2);
ae = Se([
  X("wy-post-view"),
  bt()
], ae);
var BY = Object.defineProperty, XY = Object.getOwnPropertyDescriptor, bi = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? XY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && BY(t, e, s), s;
}, "__decorateClass$8"), h$, _f;
let Be = (h$ = (_f = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.temp = !1, this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.text = "", this.attachments = [], this.pollOptions = [], this.reactions = [], this.seenBy = [], this.updatePostMutation = new en(this);
  }
  dispatchEdit(t) {
    const e = new CustomEvent("edit", { detail: { edit: t } });
    return this.dispatchEvent(e);
  }
  async handleSubmit(t) {
    const e = await this.whenApp();
    this.updatePostMutation.mutate({
      id: this.postId,
      app_id: e.id,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      attachments: t.detail.attachments,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId
    }), this.dispatchEdit(!1);
  }
  async willUpdate(t) {
    super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && await this.updatePostMutation.trackMutation(oZ(this.weavy, ["posts", this.app.id]));
  }
  render() {
    return v`
      <nav class="wy-item">
        <div class="wy-item-body">
          <div class="wy-item-title">${P("Edit post")}</div>
        </div>

        <wy-button kind="icon" @click=${() => this.dispatchEdit(!1)}>
          <wy-icon name="close"></wy-icon>
        </wy-button>
      </nav>
      <wy-editor
        editorLocation="apps"
        .text=${this.text}
        .embed=${this.embed}
        .options=${this.pollOptions}
        .attachments=${this.attachments ?? []}
        .parentId=${this.postId}
        .typing=${!1}
        .draft=${!1}
        placeholder=${P("Edit post...")}
        buttonText=${P("Update", { desc: "Button action to update" })}
        @submit=${(t) => this.handleSubmit(t)}></wy-editor>
    `;
  }
}, c(_f, "zo"), _f), d(h$, "WyPostEdit"), h$);
Be.styles = ft;
bi([
  O({ type: Number })
], Be.prototype, "postId", 2);
bi([
  O({ type: Boolean })
], Be.prototype, "temp", 2);
bi([
  O({ attribute: !1 })
], Be.prototype, "createdBy", 2);
bi([
  O()
], Be.prototype, "createdAt", 2);
bi([
  O()
], Be.prototype, "modifiedAt", 2);
bi([
  O({ type: Boolean })
], Be.prototype, "isSubscribed", 2);
bi([
  O({ type: Boolean })
], Be.prototype, "isTrashed", 2);
bi([
  O()
], Be.prototype, "text", 2);
bi([
  O({ type: Array })
], Be.prototype, "attachments", 2);
bi([
  O({ type: Array })
], Be.prototype, "pollOptions", 2);
bi([
  O({ attribute: !1 })
], Be.prototype, "meeting", 2);
bi([
  O({ attribute: !1 })
], Be.prototype, "embed", 2);
bi([
  O({ type: Array })
], Be.prototype, "reactions", 2);
bi([
  O({ type: Array })
], Be.prototype, "seenBy", 2);
Be = bi([
  X("wy-post-edit"),
  bt()
], Be);
var NY = Object.defineProperty, HY = Object.getOwnPropertyDescriptor, Ve = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? HY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && NY(t, e, s), s;
}, "__decorateClass$7"), d$, zf;
let ye = (d$ = (zf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.createdAt = "", this.modifiedAt = void 0, this.isSubscribed = !1, this.isTrashed = !1, this.html = "", this.text = "", this.plain = "", this.annotations = [], this.attachments = [], this.pollOptions = [], this.reactions = [], this.commentCount = 0, this.seenBy = [], this.editing = !1;
  }
  dispatchVote(t) {
    const e = new CustomEvent("vote", { detail: { optionId: t, parentId: this.postId, parentType: "posts" } });
    return this.dispatchEvent(e);
  }
  dispatchSubscribe(t) {
    const e = new CustomEvent("subscribe", { detail: { id: this.postId, subscribe: t } });
    return this.dispatchEvent(e);
  }
  dispatchTrash() {
    const t = new CustomEvent("trash", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  dispatchRestore() {
    const t = new CustomEvent("restore", { detail: { id: this.postId } });
    return this.dispatchEvent(t);
  }
  render() {
    return v`
      ${this.isTrashed ? v`<wy-post-trashed
            class="wy-post"
            postId=${this.postId}
            @restore=${() => {
      this.dispatchRestore();
    }}></wy-post-trashed> ` : Q}
      ${!this.isTrashed && this.editing ? v`<wy-post-edit
            class="wy-post"
            .postId=${this.postId}
            .text=${this.text}
            .embed=${this.embed}
            .pollOptions=${this.pollOptions}
            .attachments=${this.attachments}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}></wy-post-edit> ` : Q}
      ${!this.isTrashed && !this.editing ? v`<wy-post-view
            id="${this.id}"
            .postId=${this.postId}
            .createdBy=${this.createdBy}
            .createdAt=${this.createdAt}
            .modifiedAt=${this.modifiedAt}
            .isSubscribed=${this.isSubscribed}
            .isTrashed=${this.isTrashed}
            .html=${this.html}
            .text=${this.plain}
            .annotations=${this.annotations ?? []}
            .attachments=${this.attachments ?? []}
            .meeting=${this.meeting}
            .pollOptions=${this.pollOptions}
            .embed=${this.embed}
            .reactions=${this.reactions}
            .commentCount=${this.commentCount}
            @edit=${(t) => {
      this.editing = t.detail.edit;
    }}
            @subscribe=${(t) => {
      this.dispatchSubscribe(t.detail.subscribe);
    }}
            @trash=${() => {
      this.dispatchTrash();
    }}
            @vote=${(t) => {
      this.dispatchVote(t.detail.optionId);
    }}></wy-post-view> ` : Q}
    `;
  }
}, c(zf, "Po"), zf), d(d$, "WyPost"), d$);
ye.styles = ft;
Ve([
  O({ type: Number })
], ye.prototype, "postId", 2);
Ve([
  O({ attribute: !1 })
], ye.prototype, "createdBy", 2);
Ve([
  O()
], ye.prototype, "createdAt", 2);
Ve([
  O()
], ye.prototype, "modifiedAt", 2);
Ve([
  O({ type: Boolean })
], ye.prototype, "isSubscribed", 2);
Ve([
  O({ type: Boolean })
], ye.prototype, "isTrashed", 2);
Ve([
  O()
], ye.prototype, "html", 2);
Ve([
  O()
], ye.prototype, "text", 2);
Ve([
  O()
], ye.prototype, "plain", 2);
Ve([
  O({ attribute: !1 })
], ye.prototype, "annotations", 2);
Ve([
  O({ attribute: !1 })
], ye.prototype, "attachments", 2);
Ve([
  O({ type: Array })
], ye.prototype, "pollOptions", 2);
Ve([
  O({ attribute: !1 })
], ye.prototype, "meeting", 2);
Ve([
  O({ attribute: !1 })
], ye.prototype, "embed", 2);
Ve([
  O({ type: Array })
], ye.prototype, "reactions", 2);
Ve([
  O({ attribute: !1 })
], ye.prototype, "commentCount", 2);
Ve([
  O({ type: Array })
], ye.prototype, "seenBy", 2);
Ve([
  F()
], ye.prototype, "editing", 2);
ye = Ve([
  X("wy-post")
], ye);
var YY = Object.defineProperty, GY = Object.getOwnPropertyDescriptor, hZ = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$2"), dZ = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? GY(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && YY(t, e, s), s;
}, "__decorateClass$6"), uZ = /* @__PURE__ */ d((n, t, e) => t.has(n) || hZ("Cannot " + e), "__accessCheck$2"), a9 = /* @__PURE__ */ d((n, t, e) => (uZ(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$2"), KY = /* @__PURE__ */ d((n, t, e) => t.has(n) ? hZ("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$2"), o9 = /* @__PURE__ */ d((n, t, e, i) => (uZ(n, t, "write to private field"), t.set(n, e), e), "__privateSet$2"), Mc, u$, Lf;
let db = (u$ = (Lf = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.postsQuery = new dl(this), this.infiniteScroll = new ul(this), this.pagerRef = mt(), this.addPostMutation = new en(this), this.handleRealtimePostCreated = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp(), s = await this.whenUser();
      t.post.app.id !== i.id || t.post.created_by?.id === s.id || (t.post.created_by = t.actor, ea(e.queryClient, ["posts", i.id], t.post, {
        descending: !0
      }));
    }, this.handleRealtimeCommentCreated = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp(), s = await this.whenUser();
      t.actor.id === s.id || !t.comment.parent || (Oe(e.queryClient, ["posts", i.id], t.comment.parent.id, (r) => {
        r.comments ? r.comments.count += 1 : r.comments = { count: 1 };
      }), await e.queryClient.invalidateQueries({ queryKey: ["posts", t.comment.app.id, "comments"] }));
    }, this.handleRealtimeReactionAdded = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp();
      t.entity.type === ci.Post && Oe(e.queryClient, ["posts", i.id], t.entity.id, (s) => {
        hy(s, t.reaction, t.actor);
      });
    }, this.handleRealtimeReactionDeleted = async (t) => {
      const e = await this.whenWeavy(), i = await this.whenApp();
      t.entity.type === ci.Post && Oe(e.queryClient, ["posts", i.id], t.entity.id, (s) => {
        hy(s, void 0, t.actor);
      });
    }, KY(this, Mc);
  }
  async handleSubmit(t) {
    const e = await this.whenApp(), i = await this.whenUser();
    this.addPostMutation.mutate({
      app_id: e.id,
      text: t.detail.text,
      meeting_id: t.detail.meetingId,
      blobs: t.detail.blobs,
      poll_options: t.detail.pollOptions,
      embed_id: t.detail.embedId,
      user: i,
      context: t.detail.contextData
    });
  }
  async willUpdate(t) {
    var e;
    if (super.willUpdate(t), (t.has("weavy") || t.has("app")) && this.weavy && this.app && this.app?.id !== t.get("app")?.id && await this.postsQuery.trackInfiniteQuery(aZ(this.weavy, this.app.id)), (t.has("weavy") || t.has("app") || t.has("componentFeatures")) && this.weavy && this.app && this.app?.id !== t.get("app")?.id) {
      await this.addPostMutation.trackMutation(lZ(this.weavy, ["posts", this.app.id])), this.subscribePostMutation = rZ(this.weavy, this.app), this.removePostMutation = eZ(this.weavy, this.app), this.restorePostMutation = nZ(this.weavy, this.app), this.pollMutation = Kb(this.weavy, this.app.id, ["posts", this.app.id]), (e = a9(this, Mc)) == null || e.call(this);
      const i = `a${this.app.id}`;
      this.weavy.subscribe(i, "post_created", this.handleRealtimePostCreated), this.weavy.subscribe(i, "comment_created", this.handleRealtimeCommentCreated), this.componentFeatures?.allowsFeature(z.Reactions) && (this.weavy.subscribe(i, "reaction_added", this.handleRealtimeReactionAdded), this.weavy.subscribe(i, "reaction_removed", this.handleRealtimeReactionDeleted)), o9(this, Mc, () => {
        this.weavy?.unsubscribe(i, "post_created", this.handleRealtimePostCreated), this.weavy?.unsubscribe(i, "comment_created", this.handleRealtimeCommentCreated), this.weavy?.unsubscribe(i, "reaction_added", this.handleRealtimeReactionAdded), this.weavy?.unsubscribe(i, "reaction_removed", this.handleRealtimeReactionDeleted), o9(this, Mc, void 0);
      });
    }
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.postsQuery.result, this.pagerRef.value);
  }
  render() {
    const { data: t, isPending: e, hasNextPage: i } = this.postsQuery.result ?? {}, s = hs(t);
    return v`
      <div class="wy-posts">
        <div class="wy-post">
          <wy-editor
            editorLocation="apps"
            ?disabled=${!sy(Uo.Create, this.app?.permissions)}
            .typing=${!1}
            .draft=${!0}
            placeholder=${this.placeholder ?? P("Create a post...")}
            buttonText=${P("Post")}
            @submit=${(r) => this.handleSubmit(r)}
          ></wy-editor>
        </div>

        <!-- this.user ?? -->
        ${e ? v`<wy-empty><wy-spinner padded reveal></wy-spinner></wy-empty> ` : v`
              ${s ? Mi(
      s,
      (r) => r.id,
      (r) => v`<wy-post
                        id="post-${r.id}"
                        .postId=${r.id}
                        .createdBy=${r.created_by}
                        .createdAt=${r.created_at}
                        .modifiedAt=${r.updated_at}
                        .isSubscribed=${r.is_subscribed}
                        .isTrashed=${r.is_trashed}
                        .html=${r.html}
                        .text=${r.text}
                        .plain=${r.plain}
                        .annotations=${r.annotations?.data}
                        .attachments=${r.attachments?.data}
                        .meeting=${r.meeting}
                        .pollOptions=${r.options?.data}
                        .embed=${r.embed}
                        .reactions=${r.reactions?.data}
                        .commentCount=${r.comments?.count || 0}
                        @subscribe=${(a) => {
        this.subscribePostMutation?.mutate({
          id: a.detail.id,
          subscribe: a.detail.subscribe
        });
      }}
                        @trash=${(a) => {
        this.removePostMutation?.mutate({ id: a.detail.id });
      }}
                        @restore=${(a) => {
        this.restorePostMutation?.mutate({ id: a.detail.id });
      }}
                        @vote=${(a) => {
        a.detail.parentType && a.detail.parentId && this.pollMutation?.mutate({
          optionId: a.detail.optionId,
          parentType: a.detail.parentType,
          parentId: a.detail.parentId
        });
      }}
                      ></wy-post>`
    ) : v`<wy-empty></wy-empty>`}
              ${i ? v`<div ${rt(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : Q}
            `}
      </div>
    `;
  }
  disconnectedCallback() {
    var t;
    (t = a9(this, Mc)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Lf, "So"), Lf), d(u$, "WyPostList"), u$);
Mc = /* @__PURE__ */ new WeakMap();
db.styles = [ft, ma];
dZ([
  O()
], db.prototype, "placeholder", 2);
db = dZ([
  X("wy-post-list"),
  bt()
], db);
var JY = Object.defineProperty, tG = Object.getOwnPropertyDescriptor, pZ = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? tG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && JY(t, e, s), s;
}, "__decorateClass$5");
const fZ = "wy-posts";
var p$, If;
let by = (p$ = (If = class extends It {
  constructor() {
    super(...arguments), this.componentType = Pt.Posts, this.componentFeatures = new On({
      // All available features as enabled/disabled by default
      [z.Attachments]: !0,
      [z.CloudFiles]: !0,
      [z.Comments]: !0,
      [z.ContextData]: !0,
      [z.Embeds]: !0,
      [z.GoogleMeet]: !1,
      [z.Meetings]: !1,
      [z.Mentions]: !0,
      [z.MicrosoftTeams]: !1,
      [z.Polls]: !0,
      [z.Previews]: !0,
      [z.Reactions]: !0,
      [z.Typing]: !1,
      // Has no effect currently
      [z.ZoomMeetings]: !1
    }), this.theme = new Gs(this, by.styles);
  }
  render() {
    return v`
      <wy-buttons position="floating" reverse>
        <wy-notification-button-list></wy-notification-button-list>
      </wy-buttons>

      <wy-post-list .placeholder=${this.placeholder}></wy-post-list>

      <wy-context-data-progress></wy-context-data-progress>
    `;
  }
}, c(If, "Ao"), If), d(p$, "WyPosts"), p$);
by.styles = [
  Bi,
  ft,
  fa,
  hl,
  Ks,
  ma
];
pZ([
  O()
], by.prototype, "placeholder", 2);
by = pZ([
  X(fZ),
  bt()
], by);
var eG = Object.defineProperty, iG = Object.getOwnPropertyDescriptor, pO = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? iG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && eG(t, e, s), s;
}, "__decorateClass$4"), f$, Zf;
let Oy = (f$ = (Zf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.typing = new nI(this);
  }
  willUpdate(t) {
    super.willUpdate(t), t.has("appId") && (this.typing.appId = this.appId), t.has("userId") && (this.typing.userId = this.userId);
  }
  render() {
    const { names: t, ellipsis: e } = this.typing;
    let i;
    if (t.length === 1) {
      const s = t[0];
      i = P(nt`${s} is typing${e}`, { desc: "A is typing..." });
    } else if (t.length > 1) {
      const s = new Intl.ListFormat(this.weavy?.locale, { style: "long", type: "conjunction" }).format(
        t
      );
      i = P(nt`${s} are typing${e}`, {
        desc: "A, B and C are typing..."
      });
    }
    return i ? v`<span>${i}</span>` : v`<slot></slot>`;
  }
}, c(Zf, "Eo"), Zf), d(f$, "WyTyping"), f$);
pO([
  xe({ context: Le, subscribe: !0 }),
  F()
], Oy.prototype, "weavy", 2);
pO([
  O({ attribute: !0, type: Number })
], Oy.prototype, "appId", 2);
pO([
  O({ attribute: !0, type: Number })
], Oy.prototype, "userId", 2);
Oy = pO([
  X("wy-typing"),
  bt()
], Oy);
const nG = Qt`.wy-conversations{position:relative}.wy-conversation{display:flex;position:relative}.wy-conversation .wy-item-title{font-weight:var(--wy-item-title-font-weight, var(--wy-font-weight, unset));font-size:var(--wy-item-title-font-size, var(--wy-font-size, 1em))}.wy-conversation.wy-unread .wy-item-title{font-weight:var(--wy-font-weight-bold, 600)}.wy-conversation.wy-unread .wy-item-text,.wy-conversation.wy-unread .wy-meta{color:var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));font-weight:var(--wy-font-weight-bold, 600)}.wy-conversation .wy-item-text .wy-typing-show{font-weight:var(--wy-font-weight, unset)}.wy-conversation .wy-item-text .wy-typing-show{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}`, sG = Qt`.wy-pane{display:flex;flex-direction:column;position:relative;min-height:0;height:100%;flex:1 1 auto}.wy-pane-body{display:flex;flex-direction:column;flex:1}.wy-pane-group{padding:var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))}.wy-pane-background{--wy-component-background-color: var(--wy-background, var(--wy-neutral-99, #fcfcff));--wy-component-color: var(--wy-on-background, var(--wy-neutral-10, #1a1c1e));background-color:var(--wy-component-background-color);color:var(--wy-component-color)}.wy-pane-toolbar{display:flex;flex:1;justify-content:space-evenly;align-items:center;padding:var(--wy-padding-sm, calc(.5 * var(--wy-padding, calc(.5 * var(--wy-size, 1rem)))))}`;
var rG = Object.defineProperty, aG = Object.getOwnPropertyDescriptor, yZ = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError$1"), _i = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? aG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && rG(t, e, s), s;
}, "__decorateClass$3"), mZ = /* @__PURE__ */ d((n, t, e) => t.has(n) || yZ("Cannot " + e), "__accessCheck$1"), l9 = /* @__PURE__ */ d((n, t, e) => (mZ(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet$1"), oG = /* @__PURE__ */ d((n, t, e) => t.has(n) ? yZ("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd$1"), c9 = /* @__PURE__ */ d((n, t, e, i) => (mZ(n, t, "write to private field"), t.set(n, e), e), "__privateSet$1"), Tc, y$, Vf;
let ni = (y$ = (Vf = class extends pt {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.unread = !1, this.avatarUrl = "", this.hideAvatar = !1, this.name = "", this.type = Pt.PrivateChat, this.selected = !1, this.starred = !1, this.pinned = !1, this.handleMessageCreated = (t) => {
      !this.user || !this.weavy || (Oe(this.weavy.queryClient, ["apps", t.message.app.id], void 0, (e) => {
        e.last_message = t.message, e.is_unread = t.message.created_by.id !== this.user?.id;
      }), Ot(
        this.weavy.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        t.message.app.id,
        (e) => {
          e.last_message = t.message, e.is_unread = t.message.created_by.id !== this.user?.id;
        }
      ));
    }, this.handleConversationUpdated = () => {
      this.weavy?.queryClient.invalidateQueries({ queryKey: ["apps"], exact: !1 });
    }, this.handleConversationMarked = (t) => {
      this.user && t.actor.id === this.user.id && this.weavy?.queryClient.invalidateQueries({ queryKey: ["apps"], exact: !1 });
    }, oG(this, Tc);
  }
  dispatchSelected(t) {
    if (t.preventDefault(), !this.conversationId)
      return;
    const e = new CustomEvent("selected", { detail: { id: this.conversationId } });
    return this.dispatchEvent(e);
  }
  handleStar(t, e) {
    if (!this.conversationId)
      return;
    const i = new CustomEvent("star", {
      detail: { id: this.conversationId, star: e }
    });
    return this.dispatchEvent(i);
  }
  handlePin(t, e) {
    if (!this.conversationId)
      return;
    const i = new CustomEvent("pin", {
      detail: { id: this.conversationId, pin: e }
    });
    return this.dispatchEvent(i);
  }
  dispatchMarked(t) {
    if (!this.conversationId)
      return;
    const e = new CustomEvent("mark", {
      detail: { id: this.conversationId, messageId: t ? this.lastMessage?.id : null }
    });
    return this.dispatchEvent(e);
  }
  handleLeaveConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("leave", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  handleRemoveConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("remove", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  handleTrashConversation() {
    if (!this.conversationId)
      return;
    const t = new CustomEvent("trash", {
      detail: { id: this.conversationId }
    });
    return this.dispatchEvent(t);
  }
  willUpdate(t) {
    var e;
    if (super.willUpdate(t), (t.has("weavy") || t.has("conversationId")) && this.weavy && this.conversationId) {
      (e = l9(this, Tc)) == null || e.call(this);
      const i = `a${this.conversationId}`;
      this.weavy.subscribe(i, "app_updated", this.handleConversationUpdated), this.weavy.subscribe(i, "member_added", this.handleConversationUpdated), this.weavy.subscribe(i, "message_created", this.handleMessageCreated), this.weavy.subscribe(i, "app_marked", this.handleConversationMarked), c9(this, Tc, () => {
        this.weavy?.unsubscribe(i, "app_updated", this.handleConversationUpdated), this.weavy?.unsubscribe(i, "member_added", this.handleConversationUpdated), this.weavy?.unsubscribe(i, "message_created", this.handleMessageCreated), this.weavy?.unsubscribe(i, "app_marked", this.handleConversationMarked), c9(this, Tc, void 0);
      });
    }
  }
  render() {
    const t = this.lastMessage?.created_at ? new Intl.DateTimeFormat(this.weavy?.locale, { dateStyle: "full", timeStyle: "short" }).format(
      new Date(this.lastMessage.created_at)
    ) : "", e = this.lastMessage?.created_at ? zy(this.weavy?.locale, new Date(this.lastMessage.created_at)) : "", i = this.type === Pt.PrivateChat && this.user ? (this.members?.data || []).filter((s) => s.id !== this.user?.id)?.[0] ?? this.user : null;
    return v`
      <div
        class=${Xt({
      "wy-item wy-list-item-lg wy-item-hover wy-conversation": !0,
      "wy-unread": this.unread,
      "wy-active": this.selected
    })}
        tabindex="0"
        @click=${(s) => this.dispatchSelected(s)}
        @keydown=${Fe}
        @keyup=${vi}
      >
        ${this.type !== Pt.AgentChat ? this.avatarUrl ? v`<wy-avatar .size=${48} src=${this.avatarUrl}></wy-avatar>` : this.type == Pt.ChatRoom ? v` <wy-avatar-group .members=${this.members?.data} title=${this.name} .size=${48}></wy-avatar-group>` : v`
                <wy-avatar
                  src=${Ct(i?.avatar_url)}
                  name=${Ct(i?.name)}
                  description=${Ct(i?.comment)}
                  presence=${i?.presence || "away"}
                  ?isAgent=${i?.is_agent}
                  id=${Ct(i?.id)}
                  size=${48}
                ></wy-avatar>
              ` : Q}

        <div class="wy-item-rows">
          <div class="wy-item-row">
            <div class="wy-item-title">${this.name || this.lastMessage?.plain || P("Untitled conversation")}</div>
            ${this.lastMessage ? v`<time class="wy-meta" datetime=${this.lastMessage.created_at.toString()} title=${t}
                  >${e}</time
                >` : Q}
          </div>
          <div class="wy-item-row">
            <div class="wy-item-text">
              ${this.user ? v`
                    <wy-typing appId=${this.conversationId} userId=${this.user.id}>
                      ${this.lastMessage ? v`
                            ${this.user.id === this.lastMessage.created_by.id ? v`${P("You")}: ` : Q}
                            ${this.members.count > 2 && this.user.id !== this.lastMessage?.created_by.id ? v`${this.lastMessage?.created_by.name}: ` : Q}
                          ` : Q}
                      ${this.lastMessage?.text ? v`<span>${this.lastMessage.plain}</span>` : Q}
                      ${!this.lastMessage?.text && (this.lastMessage?.attachments?.count || 0) > 0 ? v`<wy-icon kind="text-icon" name="attachment"></wy-icon>` : Q}
                      ${!this.lastMessage?.text && this.lastMessage?.meeting?.id ? v`<wy-icon kind="text-icon" name="video"></wy-icon>` : Q}
                      ${this.lastMessage ? Q : v`&nbsp;`}
                    </wy-typing>
                  ` : Q}
            </div>

            <div class="wy-item-actions wy-item-actions-bottom">
              ${this.starred ? v`<wy-button
                    kind="icon"
                    @click=${(s) => {
      s.stopPropagation(), this.handleStar(s, !1);
    }}
                  >
                    <wy-icon name="star" size=${24} color="yellow"></wy-icon>
                  </wy-button>` : Q}
              ${this.pinned ? v`<wy-button
                    kind="icon"
                    @click=${(s) => {
      s.stopPropagation(), this.handlePin(s, !1);
    }}
                  >
                    <wy-icon name="pin" size=${24} color=""></wy-icon>
                  </wy-button>` : Q}

              <wy-dropdown directionX="left">
                <wy-dropdown-item @click=${() => this.dispatchMarked(this.unread)}>
                  <wy-icon name=${this.unread ? "read" : "unread"}></wy-icon>
                  ${this.unread ? P("Mark as read") : P("Mark as unread")}
                </wy-dropdown-item>
                <wy-dropdown-item @click=${(s) => this.handlePin(s, !this.pinned)}>
                  <wy-icon name=${this.pinned ? "unpin" : "pin"}></wy-icon>
                  ${this.pinned ? P("Unpin") : P("Pin")}
                </wy-dropdown-item>
                <wy-dropdown-item @click=${(s) => this.handleStar(s, !this.starred)}>
                  <wy-icon name=${this.starred ? "unstar" : "star"}></wy-icon>
                  ${this.starred ? P("Unstar") : P("Star")}
                </wy-dropdown-item>
                ${this.type === Pt.PrivateChat ? v`<wy-dropdown-item @click=${() => this.handleRemoveConversation()}>
                      <wy-icon name="trashcan"></wy-icon>
                      ${P("Delete")}
                    </wy-dropdown-item>` : Q}
                ${this.type === Pt.ChatRoom ? v`<wy-dropdown-item @click=${() => this.handleLeaveConversation()}>
                      <wy-icon name="account-minus"></wy-icon>
                      ${P("Leave")}
                    </wy-dropdown-item>` : Q}
                ${this.type === Pt.AgentChat ? v`
                      <wy-dropdown-item @click=${() => this.handleTrashConversation()}>
                        <wy-icon name="trashcan"></wy-icon>
                        ${P("Delete")}
                      </wy-dropdown-item>
                    ` : Q}
              </wy-dropdown>
            </div>
          </div>
        </div>
      </div>
    `;
  }
  connectedCallback() {
    super.connectedCallback(), this.weavy && this.requestUpdate("weavy");
  }
  disconnectedCallback() {
    var t;
    (t = l9(this, Tc)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Vf, "Ro"), Vf), d(y$, "WyConversationListItem"), y$);
Tc = /* @__PURE__ */ new WeakMap();
ni.styles = ft;
_i([
  xe({ context: Le, subscribe: !0 }),
  F()
], ni.prototype, "weavy", 2);
_i([
  O({ attribute: !0, type: Number })
], ni.prototype, "conversationId", 2);
_i([
  O({ attribute: !0, type: Boolean })
], ni.prototype, "unread", 2);
_i([
  O({ attribute: !0 })
], ni.prototype, "avatarUrl", 2);
_i([
  O({ attribute: !0, type: Boolean })
], ni.prototype, "hideAvatar", 2);
_i([
  O({ attribute: !0 })
], ni.prototype, "name", 2);
_i([
  O({ attribute: !0, type: String, reflect: !0 })
], ni.prototype, "type", 2);
_i([
  O({ attribute: !0, type: Boolean, reflect: !0 })
], ni.prototype, "selected", 2);
_i([
  O({ attribute: !0, type: Boolean, reflect: !0 })
], ni.prototype, "starred", 2);
_i([
  O({ attribute: !0, type: Boolean, reflect: !0 })
], ni.prototype, "pinned", 2);
_i([
  O({ attribute: !1 })
], ni.prototype, "members", 2);
_i([
  O({ attribute: !1 })
], ni.prototype, "lastMessage", 2);
_i([
  xe({ context: Ub, subscribe: !0 }),
  F()
], ni.prototype, "user", 2);
ni = _i([
  X("wy-conversation-list-item"),
  bt()
], ni);
var lG = Object.defineProperty, cG = Object.getOwnPropertyDescriptor, fO = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? cG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && lG(t, e, s), s;
}, "__decorateClass$2"), m$, Df;
let sl = (m$ = (Df = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.show = !1;
  }
  async create(t) {
    this.agent && await this.submit(), t ? await this.submit(t) : this.open();
  }
  open() {
    this.show = !0;
  }
  close() {
    this.show = !1;
  }
  async submit(t = []) {
    const e = this.agent ? { members: [this.agent], type: gn.AgentChat } : { members: t, type: t.length === 1 ? gn.PrivateChat : gn.ChatRoom };
    this.close();
    const i = await this.addConversationMutation?.mutate(e), s = new CustomEvent("selected", { detail: { id: i?.id } });
    return this.dispatchEvent(s);
  }
  updated(t) {
    t.has("weavy") && this.weavy && (this.addConversationMutation = hP(this.weavy));
  }
  render() {
    return v`
      ${this.slotElements.length ? Q : v`
        <wy-button part="wy-conversation-new-button" kind="icon" @click=${() => this.create()}>
          <wy-icon name="plus"></wy-icon>
        </wy-button>
      `}
      <slot></slot>

      ${!this.agent && this.weavy ? v`<wy-overlay
            .show=${this.show}
            @close=${() => {
      this.show = !1;
    }}
            @release-focus=${() => this.dispatchEvent(new CustomEvent("release-focus", { bubbles: !0, composed: !0 }))}
          >
            <header class="wy-appbars">
              <nav class="wy-appbar">
                <wy-button kind="icon" @click=${() => this.close()}>
                  <wy-icon name="close"></wy-icon>
                </wy-button>
                <div class="wy-appbar-text">${P("New conversation")}</div>
              </nav>
            </header>
            ${this.show ? v` <wy-users-search @submit=${(t) => this.submit(t.detail.members.map((e) => e.id))}></wy-users-search> ` : Q}
          </wy-overlay>` : Q}
    `;
  }
}, c(Df, "Oo"), Df), d(m$, "WyConversationNew"), m$);
sl.styles = [ft, Tt];
fO([
  O()
], sl.prototype, "agent", 2);
fO([
  F()
], sl.prototype, "show", 2);
fO([
  mP({ flatten: !0 })
], sl.prototype, "slotElements", 2);
sl = fO([
  X("wy-conversation-new"),
  bt()
], sl);
var hG = Object.defineProperty, dG = Object.getOwnPropertyDescriptor, wZ = /* @__PURE__ */ d((n) => {
  throw TypeError(n);
}, "__typeError"), Sg = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? dG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = (i ? a(t, e, s) : a(s)) || s);
  return i && s && hG(t, e, s), s;
}, "__decorateClass$1"), gZ = /* @__PURE__ */ d((n, t, e) => t.has(n) || wZ("Cannot " + e), "__accessCheck"), h9 = /* @__PURE__ */ d((n, t, e) => (gZ(n, t, "read from private field"), e ? e.call(n) : t.get(n)), "__privateGet"), uG = /* @__PURE__ */ d((n, t, e) => t.has(n) ? wZ("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), "__privateAdd"), d9 = /* @__PURE__ */ d((n, t, e, i) => (gZ(n, t, "write to private field"), t.set(n, e), e), "__privateSet"), Ac, w$, Wf;
let ua = (w$ = (Wf = class extends _t {
  constructor() {
    super(...arguments), this.exportParts = new et(this), this.conversationTypes = [Pt.ChatRoom, Pt.PrivateChat], this.searchText = "", this.conversationsQuery = new dl(this), this.infiniteScroll = new ul(this), this.pagerRef = mt(), this.handleRefresh = () => {
      this.conversationsQuery.result.refetch();
    }, this.handlePresenceChange = (t) => {
      if (!this.weavy)
        return;
      Array.isArray(t) || (t = [parseInt(t)]);
      const e = /* @__PURE__ */ d((i) => {
        const s = i.members.data ?? [];
        s.forEach((r) => {
          r.presence = t.indexOf(r.id) != -1 ? "active" : "away";
        }), i.members.data = s;
      }, "updateMembersInApps");
      Ot(
        this.weavy.queryClient,
        { queryKey: ["apps", "list"], exact: !1 },
        void 0,
        e
      );
    }, uG(this, Ac);
  }
  dispatchSelected(t) {
    this.conversationId = t;
    const e = new CustomEvent("selected", { detail: { id: t } });
    return this.dispatchEvent(e);
  }
  async handleMark(t, e) {
    await this.markConversationMutation?.mutate({ appId: t, messageId: e, userId: this.user?.id });
  }
  async handleStar(t, e) {
    await this.starConversationMutation?.mutate({ appId: t, star: e });
  }
  async handlePin(t, e) {
    await this.pinConversationMutation?.mutate({ appId: t, pin: e });
  }
  async handleLeaveConversation(t) {
    this.conversationId === t && this.dispatchSelected(void 0);
    const e = await this.whenUser();
    await this.leaveConversationMutation?.mutate({ appId: t, members: [e.id] }), this.conversationsQuery.result.refetch();
  }
  async handleRemoveConversation(t) {
    this.conversationId === t && this.dispatchSelected(void 0), await this.removeConversationMutation?.mutate({ appId: t }), this.conversationsQuery.result.refetch();
  }
  async handleTrashConversation(t) {
    this.conversationId === t && this.dispatchSelected(void 0), await this.trashConversationMutation?.mutate({ appId: t }), this.conversationsQuery.result.refetch();
  }
  async willUpdate(t) {
    var e;
    super.willUpdate(t), (t.has("weavy") || t.has("conversationTypes")) && this.weavy && (await this.conversationsQuery.trackInfiniteQuery(
      kE(
        this.weavy,
        {},
        this.conversationTypes,
        this.agent,
        () => this.searchText,
        "pinned_at desc,rev desc",
        !1
      )
    ), this.markConversationMutation = AP(this.weavy), this.starConversationMutation = bz(this.weavy), this.pinConversationMutation = Oz(this.weavy), this.leaveConversationMutation = RP(this.weavy), this.removeConversationMutation = $z(this.weavy), this.trashConversationMutation = Sz(this.weavy), (e = h9(this, Ac)) == null || e.call(this), this.weavy.subscribe(null, "app_created", this.handleRefresh), this.weavy.subscribe(null, "message_created", this.handleRefresh), this.weavy.subscribe(null, "member_added", this.handleRefresh), this.weavy.subscribe(null, "online", this.handlePresenceChange), d9(this, Ac, () => {
      this.weavy?.unsubscribe(null, "app_created", this.handleRefresh), this.weavy?.unsubscribe(null, "message_created", this.handleRefresh), this.weavy?.unsubscribe(null, "member_added", this.handleRefresh), this.weavy?.unsubscribe(null, "online", this.handlePresenceChange), d9(this, Ac, void 0);
    }));
  }
  update(t) {
    super.update(t), this.infiniteScroll.observe(this.conversationsQuery.result, this.pagerRef.value);
  }
  async updated(t) {
    t.has("searchText") && t.get("searchText") !== void 0 && this.conversationsQuery.result && await this.conversationsQuery.result.refetch?.();
  }
  renderConversations(t, e) {
    if (e) {
      const i = hs(e);
      return Mi(
        i,
        (s) => s?.id,
        (s) => [
          v`<wy-conversation-list-item
              .conversationId=${s?.id}
              .avatarUrl=${s?.avatar_url}
              .hideAvatar=${!!this.agent}
              .name=${s.name}
              .lastMessage=${s.last_message}
              .members=${s.members}
              .unread=${s.is_unread}
              .starred=${s.is_starred}
              .pinned=${s.is_pinned}
              .type=${s.type}
              .selected=${this.conversationId == s.id}
              @selected=${(r) => this.dispatchSelected(r.detail.id)}
              @mark=${(r) => this.handleMark(r.detail.id, r.detail.messageId)}
              @star=${(r) => this.handleStar(r.detail.id, r.detail.star)}
              @pin=${(r) => this.handlePin(r.detail.id, r.detail.pin)}
              @leave=${(r) => this.handleLeaveConversation(r.detail.id)}
              @remove=${(r) => this.handleRemoveConversation(r.detail.id)}
              @trash=${(r) => this.handleTrashConversation(r.detail.id)}
            ></wy-conversation-list-item>`
        ]
      );
    }
    return Q;
  }
  render() {
    const { data: t, isPending: e, hasNextPage: i } = this.conversationsQuery.result ?? {};
    return v`
      ${this.user ? v`
            <wy-buttons position=${this.agent ? "floating" : "sticky"} ?reverse=${!!this.agent}>
              ${this.agent ? Q : v`
                    <wy-search
                      compact
                      placeholder=${P("Search for conversations...")}
                      @search=${(s) => this.searchText = s.detail.query}
                    ></wy-search>
                  `}
              <slot name="actions"></slot>
            </wy-buttons>

            <div class="wy-conversations">
              ${!e && this.user && t ? t.pages[0]?.count || this.searchText ? this.renderConversations(this.user, t) : v`
                      <div class="wy-pane-body">
                        <div class="wy-pane-group">
                          <wy-empty noNetwork>${P("Create a conversation to get started.")}</wy-empty>
                        </div>
                      </div>
                    ` : v`<wy-empty><wy-spinner padded></wy-spinner></wy-empty>`}
              ${i ? v`<div ${rt(this.pagerRef)} part="wy-pager wy-pager-bottom"></div>` : Q}
            </div>
          ` : v`<wy-empty class="wy-pane"><wy-spinner overlay></wy-spinner></wy-empty>`}
    `;
  }
  disconnectedCallback() {
    var t;
    (t = h9(this, Ac)) == null || t.call(this), super.disconnectedCallback();
  }
}, c(Wf, "Lo"), Wf), d(w$, "WeavyConversationList"), w$);
Ac = /* @__PURE__ */ new WeakMap();
ua.styles = [
  nG,
  sG,
  fa,
  hl,
  ma
];
Sg([
  O({ type: Number })
], ua.prototype, "conversationId", 2);
Sg([
  O({ type: Array })
], ua.prototype, "conversationTypes", 2);
Sg([
  O()
], ua.prototype, "agent", 2);
Sg([
  F()
], ua.prototype, "searchText", 2);
ua = Sg([
  X("wy-conversation-list"),
  bt()
], ua);
var pG = Object.getOwnPropertyDescriptor, fG = /* @__PURE__ */ d((n, t, e, i) => {
  for (var s = i > 1 ? void 0 : i ? pG(t, e) : t, r = n.length - 1, a; r >= 0; r--)
    (a = n[r]) && (s = a(s) || s);
  return s;
}, "__decorateClass"), g$, qf;
let Xk = (g$ = (qf = class extends qt {
  constructor() {
    super(), this.editorType = "messages", this.editorClass = "wy-message-editor";
  }
  renderTopSlot() {
    return [
      this.renderLists()
    ];
  }
  renderMiddleSlot() {
    return v` <div class="wy-message-editor-inputs">
      <!-- Add -->
      ${this.componentFeatures?.allowsAnyFeature(
      z.Attachments,
      z.CloudFiles,
      z.Polls,
      z.Meetings,
      z.ZoomMeetings,
      z.GoogleMeet,
      z.MicrosoftTeams
    ) ? v`<wy-dropdown icon="plus" directionY="up" ?disabled=${this.disabled}>
            ${this.componentFeatures?.allowsFeature(z.Attachments) ? v`
                  <wy-dropdown-item @click=${this.openFileInput} title=${P("From device")}>
                    <wy-icon name="attachment"></wy-icon>
                    <span>${P("From device")}</span>
                  </wy-dropdown-item>
                  <input
                    type="file"
                    ${rt(this.fileInputRef)}
                    @click=${(t) => t.stopPropagation()}
                    @change=${(t) => this.handleUploadFiles(
      Array.from(t.target.files || []),
      t.target
    )}
                    multiple
                    hidden
                    tabindex="-1"
                  />
                ` : Q}
            ${this.componentFeatures?.allowsFeature(z.CloudFiles) ? v`
                  <wy-dropdown-item @click=${this.openCloudFiles} title=${P("From cloud")}>
                    <wy-icon name="cloud"></wy-icon>
                    <span>${P("From cloud")}</span>
                  </wy-dropdown-item>
                ` : Q}
            ${this.componentFeatures?.allowsFeature(z.Polls) ? v`
                  <wy-dropdown-item @click=${() => this.openPolls()} title=${P("Poll")}>
                    <wy-icon name="poll"></wy-icon>
                    <span>${P("Poll")}</span>
                  </wy-dropdown-item>
                ` : Q}
            ${this.componentFeatures?.allowsAnyFeature(z.Meetings, z.ZoomMeetings) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("zoom")} title=${P("Zoom meeting")}>
                    <wy-icon svg="zoom-meetings"></wy-icon>
                    <span>${P("Zoom meeting")}</span>
                  </wy-dropdown-item>
                ` : Q}
            ${this.componentFeatures?.allowsAnyFeature(z.Meetings, z.GoogleMeet) ? v`
                  <wy-dropdown-item @click=${() => this.handleMeetingClick("google")} title=${P("Google Meet")}>
                    <wy-icon svg="google-meet"></wy-icon>
                    <span>${P("Google Meet")}</span>
                  </wy-dropdown-item>
                ` : Q}
            ${this.componentFeatures?.allowsAnyFeature(z.Meetings, z.MicrosoftTeams) ? v`
                  <wy-dropdown-item
                    @click=${() => this.handleMeetingClick("microsoft")}
                    title=${P("Microsoft Teams")}
                  >
                    <wy-icon svg="microsoft-teams"></wy-icon>
                    <span>${P("Microsoft Teams")}</span>
                  </wy-dropdown-item>
                ` : Q}
          </wy-dropdown>` : Q}

      <!-- Input -->
      <div class="wy-message-editor-text" ${rt(this.editorRef)}> ${this.renderEditorDummy()} </div>

      <!-- Button -->
      <wy-button
        kind="icon"
        color="primary-text"
        title=${P("Send", { desc: "Button action to send" })}
        @click="${() => this.submit()}"
        ?disabled=${this.disabled}
      >
        <wy-icon name="send"></wy-icon>
      </wy-button>
    </div>`;
  }
  renderBottomSlot() {
    return Q;
  }
}, c(qf, "Io"), qf), d(g$, "WyMessageEditor"), g$);
Xk = fG([
  X("wy-message-editor"),
  bt()
], Xk);
const st = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get WyAttachment() {
    return Ws;
  },
  get WyAttachmentsList() {
    return Zw;
  },
  get WyAvatar() {
    return ss;
  },
  get WyAvatarGroup() {
    return No;
  },
  get WyBlobUpload() {
    return gy;
  },
  get WyButton() {
    return as;
  },
  get WyButtons() {
    return Ho;
  },
  get WyCloudFiles() {
    return nl;
  },
  get WyComment() {
    return fe;
  },
  get WyCommentEdit() {
    return ln;
  },
  get WyCommentEditor() {
    return jk;
  },
  get WyCommentList() {
    return el;
  },
  get WyCommentTrashed() {
    return Uw;
  },
  get WyCommentView() {
    return Te;
  },
  get WyConversation() {
    return Ai;
  },
  get WyConversationAppbar() {
    return ls;
  },
  get WyConversationList() {
    return ua;
  },
  get WyConversationListItem() {
    return ni;
  },
  get WyConversationNew() {
    return sl;
  },
  get WyDropdown() {
    return Ti;
  },
  get WyDropdownDivider() {
    return ab;
  },
  get WyDropdownItem() {
    return Fw;
  },
  get WyDropdownOption() {
    return uy;
  },
  get WyEditor() {
    return qt;
  },
  get WyEmbed() {
    return oy;
  },
  get WyEmpty() {
    return ay;
  },
  get WyFileItem() {
    return Fs;
  },
  get WyFileMenu() {
    return oa;
  },
  get WyFileVersions() {
    return fy;
  },
  get WyFilesAppbar() {
    return la;
  },
  get WyFilesList() {
    return Cn;
  },
  get WyIcon() {
    return de;
  },
  get WyImageGrid() {
    return ly;
  },
  get WyMeetingCard() {
    return qw;
  },
  get WyMessage() {
    return ue;
  },
  get WyMessageEditor() {
    return Xk;
  },
  get WyMessageTyping() {
    return hn;
  },
  get WyMessages() {
    return cn;
  },
  get WyMessengerBadge() {
    return ha;
  },
  get WyNotificationBadge() {
    return Nw;
  },
  get WyNotificationButtonList() {
    return lb;
  },
  get WyNotificationList() {
    return vy;
  },
  get WyNotificationListItem() {
    return da;
  },
  get WyOverlay() {
    return ra;
  },
  get WyPdfViewer() {
    return Jo;
  },
  get WyPoll() {
    return Bw;
  },
  get WyPollOption() {
    return tl;
  },
  get WyPost() {
    return ye;
  },
  get WyPostEdit() {
    return Be;
  },
  get WyPostTrashed() {
    return Gw;
  },
  get WyPostView() {
    return ae;
  },
  get WyPresence() {
    return ry;
  },
  get WyPreview() {
    return Ae;
  },
  get WyPreviewEmbed() {
    return aa;
  },
  get WyPreviewIcon() {
    return Go;
  },
  get WyPreviewImage() {
    return Ko;
  },
  get WyPreviewItem() {
    return py;
  },
  get WyPreviewMedia() {
    return js;
  },
  get WyPreviewText() {
    return os;
  },
  get WyProgressLinear() {
    return on;
  },
  get WyReactionItem() {
    return Ww;
  },
  get WyReactions() {
    return $e;
  },
  get WySheet() {
    return dy;
  },
  get WySkeleton() {
    return jw;
  },
  get WySpinner() {
    return rs;
  },
  get WyToast() {
    return Bs;
  },
  get WyToasts() {
    return Yw;
  },
  get WyTyping() {
    return Oy;
  },
  get WyUsersSearch() {
    return Qn;
  }
}, Symbol.toStringTag, { value: "Module" }));
Gt.version = "1.0.0";
Gt.sourceName = "@weavy/uikit-react";
const yG = _Z(null);
function zK(n, t = []) {
  const [e, i] = NC(), s = {
    ...n,
    cloudFilePickerUrl: n.cloudFilePickerUrl?.toString(),
    locales: HC(() => n.locales, [n.locales?.length]),
    tokenUrl: n.tokenUrl?.toString(),
    tokenFactory: HC(
      () => n.tokenFactory,
      [n.tokenFactory?.toString(), ...t]
    ),
    url: n.url?.toString()
  }, [r, a] = NC(s);
  return v$(() => {
    if (!e) {
      const l = pc?.value ?? new le(s);
      i(l);
    }
  }, []), v$(() => {
    if (e && !e.isDestroyed) {
      const o = {};
      Object.entries(s).forEach(([l, h]) => {
        h !== r[l] && Object.assign(o, { [l]: h });
      }), Object.keys(o).length && (a(s), Object.assign(e, o));
    }
  }, [s]), e;
}
c(zK, "useWeavy");
const vZ = Promise.resolve(), bC = class bC {
  constructor(t, e) {
    this.o = [], this.t = !0, this.i = !1, this.l = t, this.h = e, this.u = new Promise((i, s) => {
      this.p = i;
    });
  }
  addController(t) {
    this.o.push(t);
  }
  removeController(t) {
    this.o?.splice(this.o.indexOf(t) >>> 0, 1);
  }
  requestUpdate() {
    this.t || (this.t = !0, vZ.then(() => this.h(++this.l)));
  }
  get updateComplete() {
    return this.u;
  }
  m() {
    this.i = !0, this.o.forEach((t) => t.hostConnected?.());
  }
  _() {
    this.i = !1, this.o.forEach((t) => t.hostDisconnected?.());
  }
  v() {
    this.o.forEach((t) => t.hostUpdate?.());
  }
  C() {
    this.t = !1;
    const t = this.p;
    this.u = new Promise((e, i) => {
      this.p = e;
    }), this.o.forEach((e) => e.hostUpdated?.()), t(this.t);
  }
};
c(bC, "s");
let Nk = bC;
const mG = /* @__PURE__ */ c((n, t) => {
  const { useState: e, useLayoutEffect: i } = n, [s, r] = e(0);
  let a = !1;
  const [o] = e(() => {
    const l = new Nk(s, r), h = t(l);
    return l.M = h, l.m(), a = !0, vZ.then(() => {
      a && l._();
    }), l;
  });
  return o.t = !0, i(() => (a = !1, o.i || o.m(), () => o._()), []), i(() => o.C()), o.v(), o.M;
}, "e$1");
function wG(n, t) {
  const e = (typeof n == "function" ? n() : n && "current" in n ? n.current : n) || void 0, i = mG(
    Y,
    (s) => new TU(s, t ?? Le, e)
  );
  return v$(() => {
    e && i.setRef(e);
  }, [i, e]), i.context?.value;
}
c(wG, "useWeavyContext");
var gG = /* @__PURE__ */ ((n) => (n.Attachments = "attachments", n.agents = "agents", n.CloudFiles = "cloud_files", n.ContextData = "context_data", n.Comments = "comments", n.Embeds = "embeds", n.GoogleMeet = "google_meet", n.Meetings = "meetings", n.Mentions = "mentions", n.MicrosoftTeams = "microsoft_teams", n.Polls = "polls", n.Previews = "previews", n.Reactions = "reactions", n.Receipts = "receipts", n.Thumbnails = "thumbnails", n.Typing = "typing", n.Versions = "versions", n.WebDAV = "web_dav", n.ZoomMeetings = "zoom_meetings", n))(gG || {});
const vG = /* @__PURE__ */ new Set(["children", "localName", "ref", "style", "className"]), u9 = /* @__PURE__ */ new WeakMap(), p9 = /* @__PURE__ */ c((n, t, e, i, s) => {
  const r = s?.[t];
  r === void 0 ? (n[t] = e, e == null && t in HTMLElement.prototype && n.removeAttribute(t)) : e !== i && ((a, o, l) => {
    let h = u9.get(a);
    h === void 0 && u9.set(a, h = /* @__PURE__ */ new Map());
    let u = h.get(o);
    l !== void 0 ? u === void 0 ? (h.set(o, u = { handleEvent: l }), a.addEventListener(o, u)) : u.handleEvent = l : u !== void 0 && (h.delete(o), a.removeEventListener(o, u));
  })(n, r, e);
}, "t"), G = /* @__PURE__ */ c(({ react: n, tagName: t, elementClass: e, events: i, displayName: s }) => {
  const r = new Set(Object.keys(i ?? {})), a = n.forwardRef((o, l) => {
    const h = n.useRef(/* @__PURE__ */ new Map()), u = n.useRef(null), p = {}, y = {};
    for (const [m, w] of Object.entries(o)) vG.has(m) ? p[m === "className" ? "class" : m] = w : r.has(m) || m in e.prototype ? y[m] = w : p[m] = w;
    return n.useLayoutEffect(() => {
      if (u.current === null) return;
      const m = /* @__PURE__ */ new Map();
      for (const w in y) p9(u.current, w, o[w], h.current.get(w), i), h.current.delete(w), m.set(w, o[w]);
      for (const [w, b] of h.current) p9(u.current, w, void 0, b, i);
      h.current = m;
    }), n.useLayoutEffect(() => {
      u.current?.removeAttribute("defer-hydration");
    }, []), p.suppressHydrationWarning = !0, n.createElement(t, { ...p, ref: n.useCallback((m) => {
      u.current = m, typeof l == "function" ? l(m) : l !== null && (l.current = m);
    }, [l]) });
  });
  return a.displayName = s ?? e.name, a;
}, "o"), LK = G({
  react: Y,
  tagName: vI,
  elementClass: yy,
  events: {
    onWyApp: "wy-app",
    onWyPreviewOpen: "wy-preview-open"
  }
}), IK = G({
  react: Y,
  tagName: OI,
  elementClass: my,
  events: {
    onWyApp: "wy-app",
    onWyPreviewOpen: "wy-preview-open"
  }
}), ZK = G({
  react: Y,
  tagName: U_,
  elementClass: Bo,
  events: {
    onWyApp: "wy-app"
  }
}), bG = G({
  react: Y,
  tagName: j_,
  elementClass: ie,
  events: {
    onWyNotifications: "wy-notifications"
  }
});
function VK({
  children: n,
  ...t
}) {
  const e = zZ(null), i = wG(() => e.current);
  return /* @__PURE__ */ Y.createElement(bG, { ref: e, ...t }, /* @__PURE__ */ Y.createElement(yG.Provider, { value: i ?? null }, n));
}
c(VK, "WyContext");
const DK = G({
  react: Y,
  tagName: xI,
  elementClass: il,
  events: {
    onWyApp: "wy-app",
    onWyMessage: "wy-message",
    onWyPreviewOpen: "wy-preview-open"
  }
}), WK = G({
  react: Y,
  tagName: qI,
  elementClass: ca,
  events: {
    onWyApp: "wy-app",
    onWyPreviewOpen: "wy-preview-open"
  }
}), qK = G({
  react: Y,
  tagName: XI,
  elementClass: Us,
  events: {
    onWyPreviewOpen: "wy-preview-open"
  }
}), jK = G({
  react: Y,
  tagName: YI,
  elementClass: Hw,
  events: {
    onWyApp: "wy-app",
    onWyLink: "wy-link"
  }
}), FK = G({
  react: Y,
  tagName: JI,
  elementClass: cs,
  events: {
    onWyApp: "wy-app",
    onWyLink: "wy-link",
    onWyNotification: "wy-notification"
  }
}), UK = G({
  react: Y,
  tagName: fZ,
  elementClass: by,
  events: {
    onWyApp: "wy-app",
    onWyPreviewOpen: "wy-preview-open"
  }
}), OG = G({
  react: Y,
  tagName: "wy-attachment",
  elementClass: st.WyAttachment
}), $G = G({
  react: Y,
  tagName: "wy-attachments-list",
  elementClass: st.WyAttachmentsList,
  events: {
    onFileOpen: "file-open"
  }
}), xG = G({
  react: Y,
  tagName: "wy-avatar",
  elementClass: st.WyAvatar
}), kG = G({
  react: Y,
  tagName: "wy-blob-upload",
  elementClass: st.WyBlobUpload
}), SG = G({
  react: Y,
  tagName: "wy-button",
  elementClass: st.WyButton
}), PG = G({
  react: Y,
  tagName: "wy-buttons",
  elementClass: st.WyButtons
}), CG = G({
  react: Y,
  tagName: "wy-cloud-files",
  elementClass: st.WyCloudFiles,
  events: {
    onExternalBlobs: "external-blobs",
    onReleaseFocus: "release-focus"
  }
}), QG = G({
  react: Y,
  tagName: "wy-comment-list",
  elementClass: st.WyCommentList
}), MG = G({
  react: Y,
  tagName: "wy-comment",
  elementClass: st.WyComment,
  events: {
    onVote: "vote",
    onSubscribe: "subscribe",
    onTrash: "trash",
    onRestore: "restore"
  }
}), TG = G({
  react: Y,
  tagName: "wy-comment-view",
  elementClass: st.WyCommentView,
  events: {
    onVote: "vote",
    onTrash: "trash",
    onEdit: "edit"
  }
}), AG = G({
  react: Y,
  tagName: "wy-comment-edit",
  elementClass: st.WyCommentEdit,
  events: {
    onEdit: "edit"
  }
}), RG = G({
  react: Y,
  tagName: "wy-comment-editor",
  elementClass: st.WyCommentEditor,
  events: {
    onSubmit: "submit"
  }
}), EG = G({
  react: Y,
  tagName: "wy-comment-trashed",
  elementClass: st.WyCommentTrashed,
  events: {
    onRestore: "restore"
  }
}), _G = G({
  react: Y,
  tagName: "wy-conversation",
  elementClass: st.WyConversation,
  events: {
    onReleaseFocus: "release-focus"
  }
}), zG = G({
  react: Y,
  tagName: "wy-conversation-appbar",
  elementClass: st.WyConversationAppbar,
  events: {
    onReleaseFocus: "release-focus"
  }
}), LG = G({
  react: Y,
  tagName: "wy-conversation-new",
  elementClass: st.WyConversationNew,
  events: {
    onReleaseFocus: "release-focus"
  }
}), IG = G({
  react: Y,
  tagName: "wy-conversation-list",
  elementClass: st.WyConversationList,
  events: {
    onConversationSelected: "conversation-selected"
  }
}), ZG = G({
  react: Y,
  tagName: "wy-conversation-list-item",
  elementClass: st.WyConversationListItem,
  events: {
    onRefetch: "refetch",
    onSelected: "selected",
    onStar: "star",
    onPin: "pin",
    onMark: "mark",
    onLeave: "leave"
  }
}), VG = G({
  react: Y,
  tagName: "wy-dropdown",
  elementClass: st.WyDropdown
}), DG = G({
  react: Y,
  tagName: "wy-dropdown-item",
  elementClass: st.WyDropdownItem
}), WG = G({
  react: Y,
  tagName: "wy-dropdown-option",
  elementClass: st.WyDropdownOption
}), qG = G({
  react: Y,
  tagName: "wy-dropdown-divider",
  elementClass: st.WyDropdownDivider
}), jG = G({
  react: Y,
  tagName: "wy-editor",
  elementClass: st.WyEditor,
  events: {
    onSubmit: "submit"
  }
}), FG = G({
  react: Y,
  tagName: "wy-embed",
  elementClass: st.WyEmbed,
  events: {
    onEmbedRemove: "embed-remove",
    onEmbedSwap: "embed-swap"
  }
}), UG = G({
  react: Y,
  tagName: "wy-empty",
  elementClass: st.WyEmpty
}), BG = G({
  react: Y,
  tagName: "wy-file-item",
  elementClass: st.WyFileItem,
  events: {
    onEditName: "edit-name",
    onRename: "rename",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever",
    onSubscribe: "subscribe"
  }
}), XG = G({
  react: Y,
  tagName: "wy-file-menu",
  elementClass: st.WyFileMenu,
  events: {
    onEditName: "edit-name",
    onSubscribe: "subscribe",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever"
  }
}), NG = G({
  react: Y,
  tagName: "wy-file-versions",
  elementClass: st.WyFileVersions,
  events: {
    onFileVersionSelect: "file-version-select"
  }
}), HG = G({
  react: Y,
  tagName: "wy-files-appbar",
  elementClass: st.WyFilesAppbar,
  events: {
    onReleaseFocus: "release-focus",
    onUploadFiles: "upload-files",
    onExternalBlobs: "external-blobs",
    onCreateFiles: "create-files",
    onOrder: "order",
    onView: "view",
    onShowTrashed: "show-trashed",
    onSubscribe: "subscribe"
  }
}), YG = G({
  react: Y,
  tagName: "wy-files-list",
  elementClass: st.WyFilesList,
  events: {
    onFileOpen: "file-open",
    onOrder: "order",
    onEditName: "edit-name",
    onRename: "rename",
    onTrash: "trash",
    onRestore: "restore",
    onDeleteForever: "delete-forever",
    onSubscribe: "subscribe"
  }
}), GG = G({
  react: Y,
  tagName: "wy-icon",
  elementClass: st.WyIcon
}), KG = G({
  react: Y,
  tagName: "wy-image-grid",
  elementClass: st.WyImageGrid,
  events: {
    onFileOpen: "file-open"
  }
}), JG = G({
  react: Y,
  tagName: "wy-meeting-card",
  elementClass: st.WyMeetingCard
}), tK = G({
  react: Y,
  tagName: "wy-message",
  elementClass: st.WyMessage
}), eK = G({
  react: Y,
  tagName: "wy-messages",
  elementClass: st.WyMessages,
  events: {
    onScrollToBottom: "scroll-to-bottom"
  }
}), iK = G({
  react: Y,
  tagName: "wy-message-editor",
  elementClass: st.WyMessageEditor,
  events: {
    onSubmit: "submit"
  }
}), nK = G({
  react: Y,
  tagName: "wy-message-typing",
  elementClass: st.WyMessageTyping
}), sK = G({
  react: Y,
  tagName: "wy-messenger-badge",
  elementClass: st.WyMessengerBadge
}), rK = G({
  react: Y,
  tagName: "wy-notification-badge",
  elementClass: st.WyNotificationBadge
}), aK = G({
  react: Y,
  tagName: "wy-notification-button-list",
  elementClass: st.WyNotificationButtonList
}), oK = G({
  react: Y,
  tagName: "wy-notification-list",
  elementClass: st.WyNotificationList
}), lK = G({
  react: Y,
  tagName: "wy-notification-list-item",
  elementClass: st.WyNotificationListItem
}), cK = G({
  react: Y,
  tagName: "wy-overlay",
  elementClass: st.WyOverlay,
  events: {
    onReleaseFocus: "release-focus",
    onClose: "close"
  }
}), hK = G({
  react: Y,
  tagName: "wy-pdf-viewer",
  elementClass: st.WyPdfViewer
}), dK = G({
  react: Y,
  tagName: "wy-poll",
  elementClass: st.WyPoll,
  events: {
    onReleaseFocus: "release-focus",
    onVote: "vote"
  }
}), uK = G({
  react: Y,
  tagName: "wy-poll-option",
  elementClass: st.WyPollOption,
  events: {
    onReleaseFocus: "release-focus",
    onVote: "vote"
  }
}), pK = G({
  react: Y,
  tagName: "wy-post",
  elementClass: st.WyPost,
  events: {
    onVote: "vote",
    onSubscribe: "subscribe",
    onTrash: "trash",
    onRestore: "restore"
  }
}), fK = G({
  react: Y,
  tagName: "wy-post-view",
  elementClass: st.WyPostView,
  events: {
    onVote: "vote",
    onSubscribe: "subscribe",
    onTrash: "trash",
    onEdit: "edit"
  }
}), yK = G({
  react: Y,
  tagName: "wy-post-edit",
  elementClass: st.WyPostEdit,
  events: {
    onEdit: "edit"
  }
}), mK = G({
  react: Y,
  tagName: "wy-post-trashed",
  elementClass: st.WyPostTrashed,
  events: {
    onRestore: "restore"
  }
}), wK = G({
  react: Y,
  tagName: "wy-presence",
  elementClass: st.WyPresence
}), gK = G({
  react: Y,
  tagName: "wy-preview",
  elementClass: st.WyPreview,
  events: {
    onReleaseFocus: "release-focus",
    onWyPreviewOpen: "wy-preview-open",
    onWyPreviewClose: "wy-preview-close"
  }
}), vK = G({
  react: Y,
  tagName: "wy-preview-item",
  elementClass: st.WyPreviewItem
}), bK = G({
  react: Y,
  tagName: "wy-preview-embed",
  elementClass: st.WyPreviewEmbed
}), OK = G({
  react: Y,
  tagName: "wy-preview-icon",
  elementClass: st.WyPreviewIcon
}), $K = G({
  react: Y,
  tagName: "wy-preview-image",
  elementClass: st.WyPreviewImage
}), xK = G({
  react: Y,
  tagName: "wy-preview-media",
  elementClass: st.WyPreviewMedia
}), kK = G({
  react: Y,
  tagName: "wy-preview-text",
  elementClass: st.WyPreviewText
}), SK = G({
  react: Y,
  tagName: "wy-reactions",
  elementClass: st.WyReactions,
  events: {
    onReleaseFocus: "release-focus"
  }
}), PK = G({
  react: Y,
  tagName: "wy-reaction-item",
  elementClass: st.WyReactionItem
}), CK = G({
  react: Y,
  tagName: "wy-sheet",
  elementClass: st.WySheet,
  events: {
    onReleaseFocus: "release-focus",
    onClose: "close"
  }
}), QK = G({
  react: Y,
  tagName: "wy-skeleton",
  elementClass: st.WySkeleton
}), MK = G({
  react: Y,
  tagName: "wy-spinner",
  elementClass: st.WySpinner
}), TK = G({
  react: Y,
  tagName: "wy-typing",
  elementClass: st.WyTyping
}), AK = G({
  react: Y,
  tagName: "wy-users-search",
  elementClass: st.WyUsersSearch,
  events: {
    onSubmit: "submit"
  }
}), BK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  WyAttachment: OG,
  WyAttachmentsList: $G,
  WyAvatar: xG,
  WyBlobUpload: kG,
  WyButton: SG,
  WyButtons: PG,
  WyCloudFiles: CG,
  WyComment: MG,
  WyCommentEdit: AG,
  WyCommentEditor: RG,
  WyCommentList: QG,
  WyCommentTrashed: EG,
  WyCommentView: TG,
  WyConversation: _G,
  WyConversationAppbar: zG,
  WyConversationList: IG,
  WyConversationListItem: ZG,
  WyConversationNew: LG,
  WyDropdown: VG,
  WyDropdownDivider: qG,
  WyDropdownItem: DG,
  WyDropdownOption: WG,
  WyEditor: jG,
  WyEmbed: FG,
  WyEmpty: UG,
  WyFileItem: BG,
  WyFileMenu: XG,
  WyFileVersions: NG,
  WyFilesAppbar: HG,
  WyFilesList: YG,
  WyIcon: GG,
  WyImageGrid: KG,
  WyMeetingCard: JG,
  WyMessage: tK,
  WyMessageEditor: iK,
  WyMessageTyping: nK,
  WyMessages: eK,
  WyMessengerBadge: sK,
  WyNotificationBadge: rK,
  WyNotificationButtonList: aK,
  WyNotificationList: oK,
  WyNotificationListitem: lK,
  WyOverlay: cK,
  WyPdfViewer: hK,
  WyPoll: dK,
  WyPollOption: uK,
  WyPost: pK,
  WyPostEdit: yK,
  WyPostTrashed: mK,
  WyPostView: fK,
  WyPresence: wK,
  WyPreview: gK,
  WyPreviewEmbed: bK,
  WyPreviewIcon: OK,
  WyPreviewImage: $K,
  WyPreviewItem: vK,
  WyPreviewMedia: xK,
  WyPreviewText: kK,
  WyReactionItem: PK,
  WyReactions: SK,
  WySheet: CK,
  WySkeleton: QK,
  WySpinner: MK,
  WyTyping: TK,
  WyUsersSearch: AK
}, Symbol.toStringTag, { value: "Module" }));
export {
  D_ as AppTypeGuids,
  ZU as AppTypeStrings,
  gG as Feature,
  _K as MessengerTypes,
  le as Weavy,
  BK as WeavyComponents,
  yG as WeavyContext,
  LK as WyChat,
  IK as WyComments,
  ZK as WyComponent,
  VK as WyContext,
  DK as WyCopilot,
  WK as WyFiles,
  qK as WyMessenger,
  FK as WyNotificationToasts,
  jK as WyNotifications,
  UK as WyPosts,
  zK as useWeavy,
  wG as useWeavyContext
};
